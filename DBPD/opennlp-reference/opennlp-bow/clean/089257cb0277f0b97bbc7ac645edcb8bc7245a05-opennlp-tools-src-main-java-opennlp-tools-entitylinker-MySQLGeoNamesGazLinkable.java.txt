OPENNLP-579
GeoEntityLinkerImpl: Implemented better scoring using Dice coefficient of bigram, as well as highly improved scoring based on country context. Created an NgramGenerator class and a FuzzyStringMatching class, assuming they would be useful for other linker impls. Implemented Regex based discovery of countrycontext, which enabled proximity based analysis of doctext
Multiple other small efficiencies in the GeoEntityLinker

git-svn-id: https://svn.apache.org/repos/asf/opennlp/trunk@1533959 13f79535-47bb-0310-9956-ffa450edef68

-/**
- *
- * @author Owner
- */
+
-import java.util.HashSet;
-import java.util.List;
+import java.util.Map;
- *
+ *Links names to the NGA gazateer
-  public ArrayList<BaseLink> find(String locationText, Span span, List<CountryContextHit> countryHits, EntityLinkerProperties properties) {
+  public ArrayList<BaseLink> find(String locationText, Span span, Map<String, Set<Integer>> countryHits, EntityLinkerProperties properties) {
-      Set<String> countrycodes = getCountryCodes(countryHits);
+      
-      returnlocs.addAll(this.searchGaz(locationText, threshhold, countrycodes, properties));
+      returnlocs.addAll(this.searchGaz(locationText, threshhold, countryHits.keySet(), properties));
-   // EntityLinkerProperties property = new EntityLinkerProperties(new File("c:\\temp\\opennlpmodels\\entitylinker.properties"));
+    // EntityLinkerProperties property = new EntityLinkerProperties(new File("c:\\temp\\opennlpmodels\\entitylinker.properties"));
-    cs = con.prepareCall("CALL `search_geonames`(?, ?)");
+    cs = con.prepareCall("CALL `search_geonames`(?, ?, ?)");
-    ArrayList<MySQLGeoNamesGazEntry> retLocs = new ArrayList<MySQLGeoNamesGazEntry>();
+    if (filterCountryContext) {
+      cs.setString(3,CountryContext.getCountryCodeCSV(countryCodes));
+    } else {
+      //database stored procedure handles empty string
+      cs.setString(3, "");
+    }
+
+    ArrayList<MySQLGeoNamesGazEntry> toponyms = new ArrayList<MySQLGeoNamesGazEntry>();
-        return retLocs;
+        return toponyms;
-        if (filterCountryContext) {
-          if (countryCodes.contains(s.getCC1().toLowerCase())) {
-          //  System.out.println(searchString +" GeoNames qualified on: " + s.getCC1());
-            s.setRank(s.getRank() + 1.0);
-          } else {
-         //    System.out.println(s.getFULL_NAME_ND_RO() + ", with CC1 of "+ s.getCC1()+ ", is not within countries discovered in the document. The Country list used to discover countries can be modified in mysql procedure getCountryList()");
-            continue;
-          }
-        }
-
-        retLocs.add(s);
+            //set the base link data
+        s.setItemName(s.getFULL_NAME_ND_RO().toLowerCase().trim());
+        s.setItemID(s.getUFI());
+        s.setItemType(s.getDSG());
+        s.setItemParentID(s.getCC1().toLowerCase());
+   
+        toponyms.add(s);
-    return retLocs;
+    return toponyms;
-  private Set<String> getCountryCodes(List<CountryContextHit> hits) {
-    Set<String> ccs = new HashSet<String>();
-    for (CountryContextHit hit : hits) {
-      ccs.add(hit.getCountryCode().toLowerCase());
-    }
-    return ccs;
-  }
+

OPENNLP-1166: TwoPassDataIndexer fails if features contain \n

-import java.io.BufferedWriter;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.FileInputStream;
-import java.io.OutputStreamWriter;
-import java.io.Writer;
-import java.nio.charset.StandardCharsets;
+import java.math.BigInteger;
-    try (Writer osw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tmp),
-        StandardCharsets.UTF_8))) {
-      numEvents = computeEventCounts(eventStream, osw, predicateIndex, cutoff);
+    BigInteger writeHash;
+    HashSumEventStream writeEventStream = new HashSumEventStream(eventStream);  // do not close.
+    try (DataOutputStream dos = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(tmp)))) {
+      numEvents = computeEventCounts(writeEventStream, dos, predicateIndex, cutoff);
+    writeHash = writeEventStream.calculateHashSum();
+
-    try (FileEventStream fes = new FileEventStream(tmp)) {
-      eventsToCompare = index(fes, predicateIndex);
+    BigInteger readHash = null;
+    try (HashSumEventStream readStream = new HashSumEventStream(new EventStream(tmp))) {
+      eventsToCompare = index(readStream, predicateIndex);
+      readHash = readStream.calculateHashSum();
-
+
+    if (readHash.compareTo(writeHash) != 0)
+      throw new IOException("Event hash for writing and reading events did not match.");
+
+   * Protocol:
+   *  1 - (utf string) - Event outcome
+   *  2 - (int) - Event context array length
+   *  3+ - (utf string) - Event context string
+   *  4 - (int) - Event values array length
+   *  5+ - (float) - Event value
+   *
-  private int computeEventCounts(ObjectStream<Event> eventStream, Writer eventStore,
+  private int computeEventCounts(ObjectStream<Event> eventStream, DataOutputStream eventStore,
-      eventStore.write(FileEventStream.toLine(ev));
+
+      eventStore.writeUTF(ev.getOutcome());
+
+      eventStore.writeInt(ev.getContext().length);
+      for (String ctxString : ec)
+        eventStore.writeUTF(ctxString);
+
+      if (ev.getValues() == null) {
+        eventStore.writeInt(0);
+      }
+      else {
+        eventStore.writeInt(ev.getValues().length);
+        for (float value : ev.getValues())
+          eventStore.writeFloat(value);
+      }
+
+  private static class EventStream implements ObjectStream<Event> {
+
+    private final DataInputStream inputStream;
+
+    public EventStream(File file) throws IOException {
+      inputStream = new DataInputStream(new BufferedInputStream(new FileInputStream(file)));
+    }
+
+    @Override
+    public Event read() throws IOException {
+      if (inputStream.available() != 0) {
+        String outcome = inputStream.readUTF();
+        int contextLenght = inputStream.readInt();
+        String[] context = new String[contextLenght];
+        for (int i = 0; i < contextLenght; i++)
+          context[i] = inputStream.readUTF();
+        int valuesLength = inputStream.readInt();
+        float[] values = null;
+        if (valuesLength > 0) {
+          values = new float[valuesLength];
+          for (int i = 0; i < valuesLength; i++)
+            values[i] = inputStream.readFloat();
+        }
+        return new Event(outcome, context, values);
+      }
+      else {
+        return null;
+      }
+    }
+
+    @Override
+    public void reset() throws IOException, UnsupportedOperationException {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void close() throws IOException {
+      inputStream.close();
+    }
+  }

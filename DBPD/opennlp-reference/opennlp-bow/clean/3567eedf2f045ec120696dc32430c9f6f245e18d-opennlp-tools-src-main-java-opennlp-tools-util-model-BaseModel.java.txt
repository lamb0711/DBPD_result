OPENNLP-581 the model now first reads the manifest.properties file and then proceeds with all the other artifacts

git-svn-id: https://svn.apache.org/repos/asf/opennlp/trunk@1554661 13f79535-47bb-0310-9956-ffa450edef68

+  private static int MODEL_BUFFER_SIZE_LIMIT = Integer.MAX_VALUE;
+  
-  private Map<String, byte[]> leftoverArtifacts;
-
-    if (in == null)
-        throw new IllegalArgumentException("in must not be null!");
-
-    InputStream in = modelURL.openStream();
+    InputStream in = new BufferedInputStream(modelURL.openStream());
+    
+    if (in == null) {
+      throw new IllegalArgumentException("in must not be null!");
+    }
+    
+    if (!in.markSupported()) {
+      in = new BufferedInputStream(in);
+    }
+    
+    // TODO: Discuss this solution, the buffering should 
+    in.mark(MODEL_BUFFER_SIZE_LIMIT);
+    
-    // will read it in two steps, first using the known factories, latter the
-    // unknown.
-    leftoverArtifacts = new HashMap<String, byte[]>();
-
+    // The model package can contain artifacts which are serialized with 3rd party
+    // serializers which are configured in the manifest file. To be able to load
+    // the model the manifest must be read first, and afterwards all the artifacts 
+    // can be de-serialized.
+    
+    // The ordering of artifacts in a zip package is not guaranteed. The stream is first
+    // read until the manifest appears, reseted, and read again to load all artifacts.
+    
+    boolean isSearchingForManifest = true;
+    
-    while((entry = zip.getNextEntry()) != null ) {
+    while((entry = zip.getNextEntry()) != null && isSearchingForManifest) {
-      String extension = getEntryExtension(entry.getName());
-
-      ArtifactSerializer factory = artifactSerializers.get(extension);
-
-      if (factory == null) {
-        /* TODO: find a better solution, that would consume less memory */
-        byte[] bytes = toByteArray(zip);
-        leftoverArtifacts.put(entry.getName(), bytes);
-      } else {
+      if ("manifest.properties".equals(entry.getName())) {
+        // TODO: Probably better to use the serializer here directly!
+        ArtifactSerializer factory = artifactSerializers.get("properties");
+        isSearchingForManifest = false;
-      
+
-
+    
-    finishLoadingArtifacts();
+
+    // The Input Stream should always be reset-able because if markSupport returns
+    // false it is wrapped before hand into an Buffered InputStream
+    in.reset();
+    
+    finishLoadingArtifacts(in);
+    
-  private void finishLoadingArtifacts()
+  private void finishLoadingArtifacts(InputStream in)
-    finishedLoadingArtifacts = true;
-    if (leftoverArtifacts == null || leftoverArtifacts.size() == 0) {
-      return;
-    }
-
+    
+    final ZipInputStream zip = new ZipInputStream(in);
+    
-    for (String entryName : leftoverArtifacts.keySet()) {
+    ZipEntry entry;
+    while((entry = zip.getNextEntry()) != null ) {
+      // Note: The manifest.properties file will be read here again,
+      // there should be no need to prevent that.
+      
+      String entryName = entry.getName();
-      if (leftoverArtifacts.containsKey(entryName)) {
-        ArtifactSerializer factory = artifactSerializers.get(extension);
+      ArtifactSerializer factory = artifactSerializers.get(extension);
-        if (factory == null) {
-          String artifactSerializerClazzName = 
-              getManifestProperty(SERIALIZER_CLASS_NAME_PREFIX + entryName);
+      String artifactSerializerClazzName = 
+          getManifestProperty(SERIALIZER_CLASS_NAME_PREFIX + entryName);
-          if (artifactSerializerClazzName != null) {
-            factory = ExtensionLoader.instantiateExtension(ArtifactSerializer.class, artifactSerializerClazzName);
-          }
-        }
-        
-        if (factory == null) {
-          throw new InvalidFormatException("Unknown artifact format: "
-              + extension);
-        } else {
-          artifactMap.put(entryName, factory.create(new ByteArrayInputStream(leftoverArtifacts.get(entryName))));
+      if (artifactSerializerClazzName != null) {
+        if (artifactSerializerClazzName != null) {
+          factory = ExtensionLoader.instantiateExtension(ArtifactSerializer.class, artifactSerializerClazzName);
+      
+      if (factory != null) {
+        artifactMap.put(entryName, factory.create(zip));
+      } else {
+        throw new InvalidFormatException("Unknown artifact format: " + extension);
+      }
+      
+      zip.closeEntry();
-    this.leftoverArtifacts = null;
+
+    
+    finishedLoadingArtifacts = true;
-      if (serializer == null && artifact instanceof SerializableArtifact) {
+      // If model is serialize-able always use the provided serializer
+      if (artifact instanceof SerializableArtifact) {
+  
+  public static void main(String[] args) throws Exception {
+    
+    // create a stream which can be reset, enclose it in a buffered stream which supports reseting 
+    InputStream in = new FileInputStream("annotation.conf");
+    
+    System.out.println("Is mark supported: " + in.markSupported());
+    
+    in = new BufferedInputStream(in);
+    
+    System.out.println("Is mark supported: " + in.markSupported());
+    
+    // 2 GB limit 
+    in.mark(4096);
+    
+    in.read();
+    
+    in.reset();
+    
+    // the mark support can be used to test if reseting is supported, we shoudl use this test anyway
+    // to fail gracefully in the cross validators ...
+    
+  }

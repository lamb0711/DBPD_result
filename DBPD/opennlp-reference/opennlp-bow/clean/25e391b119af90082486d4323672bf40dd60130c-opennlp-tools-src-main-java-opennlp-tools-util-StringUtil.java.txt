OPENNLP-760 adding factory and string utils to induce lemma classes

git-svn-id: https://svn.apache.org/repos/asf/opennlp/trunk@1731145 13f79535-47bb-0310-9956-ffa450edef68

+  
+  /**
+   * Get mininum of three values.
+   * @param a number a
+   * @param b number b
+   * @param c number c
+   * @return the minimum
+   */
+  private static int minimum(int a, int b, int c) {
+      int minValue;
+      minValue = a;
+      if (b < minValue) {
+        minValue = b;
+      }
+      if (c < minValue) {
+        minValue = c;
+      }
+      return minValue;
+  }
+  
+  /**
+   * Computes the Levenshtein distance of two strings in a matrix.
+   * Based on pseudo-code provided here:
+   * https://en.wikipedia.org/wiki/Levenshtein_distance#Computing_Levenshtein_distance
+   * which in turn is based on the paper Wagner, Robert A.; Fischer, Michael J. (1974),
+   * "The String-to-String Correction Problem", Journal of the ACM 21 (1): 168-173
+   * @param wordForm the form
+   * @param lemma the lemma
+   * @return the distance
+   */
+  public static int[][] levenshteinDistance(String wordForm, String lemma) {
+
+    int wordLength = wordForm.length();
+    int lemmaLength = lemma.length();
+    int cost;
+    int[][] distance = new int[wordLength + 1][lemmaLength + 1];
+    
+    if (wordLength == 0) {
+      return distance;
+    }
+    if (lemmaLength == 0) {
+      return distance;
+    }
+    //fill in the rows of column 0
+    for (int i = 0; i <= wordLength; i++) {
+      distance[i][0] = i;
+    }
+    //fill in the columns of row 0
+    for (int j = 0; j <= lemmaLength; j++) {
+      distance[0][j] = j;
+    }
+    //fill in the rest of the matrix calculating the minimum distance
+    for (int i = 1; i <= wordLength; i++) {
+      int s_i = wordForm.charAt(i - 1);
+      for (int j = 1; j <= lemmaLength; j++) {
+        if (s_i == lemma.charAt(j - 1)) {
+          cost = 0;
+        } else {
+          cost = 1;
+        }
+        //obtain minimum distance from calculating deletion, insertion, substitution
+        distance[i][j] = minimum(distance[i - 1][j] + 1, distance[i][j - 1] + 1, distance[i - 1][j - 1] + cost);
+      }
+    }
+    return distance;
+  }
+  
+  /**
+   * Computes the Shortest Edit Script (SES) to convert a word into its lemma.
+   * This is based on Chrupala's PhD thesis (2008).
+ * @param wordForm the token
+ * @param lemma the target lemma
+ * @param distance the levenshtein distance
+ * @param permutations the number of permutations
+ */
+public static void computeShortestEditScript(String wordForm, String lemma, int[][] distance, StringBuffer permutations) {
+    
+    int n = distance.length;
+    int m = distance[0].length;
+    
+    int wordFormLength = n - 1;
+    int lemmaLength = m - 1;
+    while(true) {
+        
+        if (distance[wordFormLength][lemmaLength] == 0) {
+          break;
+        }
+        if ((lemmaLength > 0 && wordFormLength > 0) && (distance[wordFormLength - 1][lemmaLength - 1] < distance[wordFormLength][lemmaLength])) {
+            permutations.append('R').append(Integer.toString(wordFormLength - 1)).append(wordForm.charAt(wordFormLength - 1)).append(lemma.charAt(lemmaLength - 1));
+            lemmaLength--;
+            wordFormLength--;
+            continue;
+        }
+        if (lemmaLength > 0 && (distance[wordFormLength][lemmaLength - 1] < distance[wordFormLength][lemmaLength])) {
+            permutations.append('I').append(Integer.toString(wordFormLength)).append(lemma.charAt(lemmaLength - 1));
+            lemmaLength--;
+            continue;
+        }
+        if (wordFormLength > 0 && (distance[wordFormLength - 1][lemmaLength] < distance[wordFormLength][lemmaLength])) {
+            permutations.append('D').append(Integer.toString(wordFormLength - 1)).append(wordForm.charAt(wordFormLength - 1));
+            wordFormLength--;
+            continue;
+        }
+        if ((wordFormLength > 0 && lemmaLength > 0) && (distance[wordFormLength - 1][lemmaLength - 1] == distance[wordFormLength][lemmaLength])) {
+            wordFormLength--; lemmaLength--;
+            continue ;
+        }
+        if (wordFormLength > 0 && (distance[wordFormLength - 1][lemmaLength] == distance[wordFormLength][lemmaLength])) {
+            wordFormLength--;
+            continue;
+        }
+        if (lemmaLength > 0 && (distance[wordFormLength][lemmaLength - 1] == distance[wordFormLength][lemmaLength])) {
+            lemmaLength--;
+            continue;
+        }   
+    }
+}
+
+/**
+ * Get the SES required to go from a word to a lemma.
+ * @param wordForm the word
+ * @param lemma the lemma
+ * @return the shortest edit script
+ */
+public static String getShortestEditScript(String wordForm, String lemma) {
+  String reversedWF = new StringBuffer(wordForm.toLowerCase()).reverse().toString();
+  String reversedLemma = new StringBuffer(lemma.toLowerCase()).reverse().toString();
+  StringBuffer permutations = new StringBuffer();
+  String ses;
+  if (!reversedWF.equals(reversedLemma)) {
+    int[][]levenDistance = StringUtil.levenshteinDistance(reversedWF, reversedLemma);
+    StringUtil.computeShortestEditScript(reversedWF, reversedLemma, levenDistance, permutations);
+    ses = permutations.toString();
+  } else {
+    ses = "O";
+  }
+  return ses;
+}
+

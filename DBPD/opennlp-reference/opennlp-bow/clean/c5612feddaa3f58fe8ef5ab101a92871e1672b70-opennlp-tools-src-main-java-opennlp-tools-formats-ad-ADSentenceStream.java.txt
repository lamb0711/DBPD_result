OPENNLP-422: Improved the AD corpus handling

git-svn-id: https://svn.apache.org/repos/asf/incubator/opennlp/trunk@1240390 13f79535-47bb-0310-9956-ffa450edef68

+    
+    public static final String META_LABEL_FINAL = "final";
-    //private Pattern rootPattern = Pattern.compile("^[^:=]+:[^(\\s]+(\\(.*?\\))?$");
-	private Pattern rootPattern = Pattern.compile("^A\\d+$");
-        .compile("^([=-]*)([^:=]+:[^\\(\\s]+)(\\(([^\\)]+)\\))?\\s*$");
+        .compile("([=-]*)([^:=]+:[^\\(\\s]+)(\\(([^\\)]+)\\))?\\s*(?:(\\((<.+>)\\))*)\\s*$");
-        .compile("^([=-]*)([^:=]+:[^\\(\\s]+)\\(([\"'].+[\"'])?\\s*([^\\)]+)?\\)\\s+(.+)");
+        .compile("^([=-]*)([^:=]+):([^\\(\\s]+)\\([\"'](.+)[\"']\\s*((?:<.+>)*)\\s*([^\\)]+)?\\)\\s+(.+)");
-	        meta = line.substring(0, start) + " p=" + para + titleTag + boxTag + metaFromSource;
+	        if(start > 0) {
+	          meta = line.substring(0, start) + " p=" + para + titleTag + boxTag + metaFromSource;
+	        } else {
+	          // rare case were there is no space between id and the sentence.
+              // will use previous meta for now
+	        }
-        while (!rootPattern.matcher(line).matches()) {
-          line = reader.readLine();
-          if (line == null) {
-            return null;
-          }
-        }
-        // now we have to take care of the lastLevel. Every time it raises, we
-        // will add the
-        // leaf to the node at the top. If it decreases, we remove the top.
+        
+        /* now we have to take care of the lastLevel. Every time it raises, we will add the
+        leaf to the node at the top. If it decreases, we remove the top. */
-        String morphologicalTag = nodeMatcher.group(3);
-        node.setMorphologicalTag(morphologicalTag);
-        String lemma = leafMatcher.group(3);
-        String morphologicalTag = leafMatcher.group(4);
-        String lexeme = leafMatcher.group(5);
+        String funcTag = leafMatcher.group(3);
+        String lemma = leafMatcher.group(4);
+        String secondaryTag = leafMatcher.group(5);
+        String morphologicalTag = leafMatcher.group(6);
+        String lexeme = leafMatcher.group(7);
+        leaf.setFunctionalTag(funcTag);
+        leaf.setSecondaryTag(secondaryTag);
-        if (lemma != null) {
-          if (lemma.length() > 2) {
-            lemma = lemma.substring(1, lemma.length() - 1);
-          }
-          leaf.setLemma(lemma);
-        }
+        leaf.setLemma(lemma);
+        	if(lexeme.matches("\\w.*?[\\.<>].*")) {
+        	  return null;
+        	}
+        	
+      private String secondaryTag;
+      private String functionalTag;
+      public void setFunctionalTag(String funcTag) {
+        this.functionalTag = funcTag;
+      }
+      
+      public String getFunctionalTag(){
+        return this.functionalTag;
+      }
+
+      public void setSecondaryTag(String secondaryTag) {
+        this.secondaryTag = secondaryTag;
+      }
+      
+      public String getSecondaryTag() {
+        return this.secondaryTag;
+      }
+
+      
+      private String emptyOrString(String value, String prefix, String suffix) {
+        if(value == null) return "";
+        return prefix + value + suffix;
+      }
-          sb.append(this.getSyntacticTag()).append("(").append(this.getMorphologicalTag()).append(") ");
+          sb.append(this.getSyntacticTag()).append(":")
+              .append(getFunctionalTag()).append("(")
+              .append(emptyOrString(getLemma(), "'", "' "))
+              .append(emptyOrString(getSecondaryTag(), "", " "))
+              .append(this.getMorphologicalTag()).append(") ");
+  private static final Pattern extEnd = Pattern.compile("</ext>");
-    		  if (sentEnd.matcher(line).matches()) {
+    		  if (sentEnd.matcher(line).matches() || extEnd.matcher(line).matches()) {
+	          } else if(line.startsWith("A1")) {
+	            // skip

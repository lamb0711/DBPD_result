OPENNLP-85 Created a static method to create spans of phrase chunks and added javadoc

git-svn-id: https://svn.apache.org/repos/asf/incubator/opennlp/trunk@1063351 13f79535-47bb-0310-9956-ffa450edef68

+/**
+ * Class for holding chunks for a single unit of text.
+ */
+	
-
-  
-  
+
+  /**
+   * Initializes the current instance.
+   * 
+   * @param sentence
+   *          training sentence
+   * @param tags
+   *          POS Tags for the sentence
+   * @param preds
+   *          Chunk tags in B-* I-* notation
+   */
+  /**
+   * Initializes the current instance.
+   * 
+   * @param sentence
+   *          training sentence
+   * @param tags
+   *          POS Tags for the sentence
+   * @param preds
+   *          Chunk tags in B-* I-* notation
+   */
-    // TODO: Add validation of params ...
+  	if (sentence.size() != tags.size()  || tags.size()  != preds.size() )
+      throw new IllegalArgumentException("All arrays must have the same length!");
+  	
-  
+ 
+  /** Gets the training sentence */
-  
+
+  /** Gets the POS Tags for the sentence */
+  /** Gets the Chunk tags in B-* I-* notation */
+  /** Gets the phrases as an array of spans */
-	  List<Span> phrases =  new ArrayList<Span>();
-	  String startTag = "";
-	  int startIndex = 0;
-	  boolean foundPhrase = false;
-	    
-	    for (int ci=0, cn = preds.size(); ci < cn; ci++) {
-	    	String pred = preds.get(ci);
-	    	if( pred.startsWith("B-") || ( !pred.equals("I-" + startTag) && !pred.equals("O") )) { // start
-	    		if(foundPhrase) { // handle the last
-	    			phrases.add(new Span(startIndex, ci, startTag));
-	    		}
-	    		startIndex = ci;
-	    		startTag = pred.substring(2);
-	    		foundPhrase = true;
-	    	} else if(pred.equals("I-" + startTag)) { // middle 
-	    		// do nothing
-	    	} else if(foundPhrase) {// end
-	    		phrases.add(new Span(startIndex, ci, startTag));
-	    		foundPhrase = false;
-	    		startTag = "";
-	    	}
-	    }
-	    if(foundPhrase) { // leftover
-	    	phrases.add(new Span(startIndex, preds.size(), startTag));
-	    }
-	    
-	    return phrases.toArray(new Span[phrases.size()]);
+    return phrasesAsSpanList(getSentence(), getTags(), getPreds());
+  /**
+   * Static method to create arrays of spans of phrases
+   * 
+   * @param aSentence
+   *          training sentence
+   * @param aTags
+   *          POS Tags for the sentence
+   * @param aPreds
+   *          Chunk tags in B-* I-* notation
+   * 
+   * @return the phrases as an array of spans
+   */
+  public static Span[] phrasesAsSpanList(String[] aSentence, String[] aTags,
+      String[] aPreds) {
+
+    if (aSentence.length != aTags.length || aTags.length != aPreds.length)
+      throw new IllegalArgumentException(
+          "All arrays must have the same length!");
+
+    List<Span> phrases = new ArrayList<Span>();
+    String startTag = "";
+    int startIndex = 0;
+    boolean foundPhrase = false;
+
+    for (int ci = 0, cn = aPreds.length; ci < cn; ci++) {
+      String pred = aPreds[ci];
+      if (pred.startsWith("B-")
+          || (!pred.equals("I-" + startTag) && !pred.equals("O"))) { // start
+        if (foundPhrase) { // handle the last
+          phrases.add(new Span(startIndex, ci, startTag));
+        }
+        startIndex = ci;
+        startTag = pred.substring(2);
+        foundPhrase = true;
+      } else if (pred.equals("I-" + startTag)) { // middle
+        // do nothing
+      } else if (foundPhrase) {// end
+        phrases.add(new Span(startIndex, ci, startTag));
+        foundPhrase = false;
+        startTag = "";
+      }
+    }
+    if (foundPhrase) { // leftover
+      phrases.add(new Span(startIndex, aPreds.length, startTag));
+    }
+
+    return phrases.toArray(new Span[phrases.size()]);
+  }
+  /**
+   * Creates a nice to read string for the phrases formatted as following: <br>
+   * <code>
+   * [NP Rockwell_NNP ] [VP said_VBD ] [NP the_DT agreement_NN ] [VP calls_VBZ ] [SBAR for_IN ] [NP it_PRP ] [VP to_TO supply_VB ] [NP 200_CD additional_JJ so-called_JJ shipsets_NNS ] [PP for_IN ] [NP the_DT planes_NNS ] ._.
+   * </code>
+   * 
+   * @return a nice to read string representation of the chunk phases
+   */

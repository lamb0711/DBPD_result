OPENNLP-643
Added constructor for String, Pattern[] again, for backwards compatibility

git-svn-id: https://svn.apache.org/repos/asf/opennlp/trunk@1568030 13f79535-47bb-0310-9956-ffa450edef68

+  private Pattern mPatterns[];
+  private String sType;
+  public RegexNameFinder(Pattern patterns[], String type) {
+    if (patterns == null || patterns.length == 0) {
+      throw new IllegalArgumentException("patterns must not be null or empty!");
+    }
+
+    mPatterns = patterns;
+    sType = type;
+  }
+
+  /**
+   * use constructor {@link #RegexNameFinder(Pattern[], String)}
+   * for single types, and/or constructor 
+   * {@link #RegexNameFinder(Map)}
+   */
+  @Deprecated
+  public RegexNameFinder(Pattern patterns[]) {
+    if (patterns == null || patterns.length == 0) {
+      throw new IllegalArgumentException("patterns must not be null or empty!");
+    }
+
+    mPatterns = patterns;
+    sType = null;
+  }
+
-    if (regexMap != null) {
+    if (mPatterns == null && regexMap != null) {
-    }
+    } else {
+      for (Pattern mPattern : mPatterns) {
+        Matcher matcher = mPattern.matcher(sentenceString);
+        while (matcher.find()) {
+          Integer tokenStartIndex =
+                  sentencePosTokenMap.get(matcher.start());
+          Integer tokenEndIndex =
+                  sentencePosTokenMap.get(matcher.end());
+
+          if (tokenStartIndex != null && tokenEndIndex != null) {
+            Span annotation = new Span(tokenStartIndex, tokenEndIndex, sType);
+            annotations.add(annotation);
+          }
+        }
+      }
+    }
-   * NEW. This method removes the need for tokenization, but returns the
-   * character spans rather than word spans. Span.spansToStrings will not work
-   * properly on this output.
+   * NEW. This method removes the need for tokenization, but returns the Span
+   * with character indices, rather than word.
-    if (regexMap != null) {
+    if (mPatterns == null && regexMap != null) {
+    } else {
+      for (Pattern mPattern : mPatterns) {
+        Matcher matcher = mPattern.matcher(text);
+
+        while (matcher.find()) {
+          Integer tokenStartIndex = matcher.start();
+          Integer tokenEndIndex = matcher.end();
+          Span annotation = new Span(tokenStartIndex, tokenEndIndex, sType);
+          annotations.add(annotation);
+
+        }
+      }
+
- 
-}
+  public Pattern[] getmPatterns() {
+    return mPatterns;
+  }
+
+  public void setmPatterns(Pattern[] mPatterns) {
+    this.mPatterns = mPatterns;
+  }
+
+  public String getsType() {
+    return sType;
+  }
+
+  public void setsType(String sType) {
+    this.sType = sType;
+  }
+}

OPENNLP-699
OPENNLP-684
Moved MarkableFileInputStreamFactory and MarkableFileInputStream classes to utils. This prompted a minor change to imports in CmdLineUtil
Removed setter for double prob from Span, and added additional constructors to support spans with probs while preserving immutable. Changed the SentenceDetectorMe and NameFinderME to use the new constructors rather than the setter.

All unit tests pass.

git-svn-id: https://svn.apache.org/repos/asf/opennlp/trunk@1596320 13f79535-47bb-0310-9956-ffa450edef68

-
-
-
- **/
+ *
+ */
-  private double prob=0d;//default is 0
+  private final double prob;//default is 0
-   * Initializes a new Span Object.
+   * Initializes a new Span Object. Sets the prob to 0 as default.
-      throw new IllegalArgumentException("start index must not be larger than end index: " +
-          "start=" + s + ", end=" + e);
+      throw new IllegalArgumentException("start index must not be larger than end index: "
+              + "start=" + s + ", end=" + e);
+    this.prob = 0d;
- public Span(int s, int e, String type, double prob) {
+
+  public Span(int s, int e, String type, double prob) {
-      throw new IllegalArgumentException("start index must not be larger than end index: " +
-          "start=" + s + ", end=" + e);
+      throw new IllegalArgumentException("start index must not be larger than end index: "
+              + "start=" + s + ", end=" + e);
-    this.prob=prob;
+    this.prob = prob;
+
-   * Initializes a new Span Object.
+   * Initializes a new Span Object. Sets the prob to 0 as default
-    this(s, e, null);
+    this(s, e, null, 0d);
-   * Initializes a new Span object with an existing Span
-   * which is shifted by an offset.
+   *
+   * @param s the start of the span (the token index, not the char index)
+   * @param e the end of the span (the token index, not the char index)
+   * @param prob
+   */
+  public Span(int s, int e, double prob) {
+    this(s, e, null, prob);
+  }
+
+  /**
+   * Initializes a new Span object with an existing Span which is shifted by an
+   * offset.
+/**
+ * Creates a new immutable span based on an existing span, where the existing span did not include the prob
+ * @param span the span that has no prob or the prob is incorrect and a new Span must be generated
+ * @param prob the probability of the span
+ */
+  public Span(Span span, double prob) {
+    this(span.start, span.end, span.getType(), prob);
+  }
-   **/
+   *
+   */
-   * Note: that the returned index is one past the
-   * actual end of the span in the text, or the first
-   * element past the end of the span.
+   * Note: that the returned index is one past the actual end of the span in the
+   * text, or the first element past the end of the span.
-   **/
+   *
+   */
-    return end-start;
+    return end - start;
-   * Returns true if the specified span is contained by this span.
-   * Identical spans are considered to contain each other.
+   * Returns true if the specified span is contained by this span. Identical
+   * spans are considered to contain each other.
-   * @return true is the specified span is contained by this span;
-   * false otherwise.
+   * @return true is the specified span is contained by this span; false
+   * otherwise.
-   * Returns true if the specified index is contained inside this span.
-   * An index with the value of end is considered outside the span.
+   * Returns true if the specified index is contained inside this span. An index
+   * with the value of end is considered outside the span.
-   * @return true if the span contains this specified index;
-   * false otherwise.
+   * @return true if the span contains this specified index; false otherwise.
-   * @return true if the specified span starts with this span and is
-   * contained in this span; false otherwise
+   * @return true if the specified span starts with this span and is contained
+   * in this span; false otherwise
-    return this.contains(s) || s.contains(this) ||
-	   getStart() <= sstart && sstart < getEnd() ||
-	   sstart <= getStart() && getStart() < s.getEnd();
+    return this.contains(s) || s.contains(this)
+            || getStart() <= sstart && sstart < getEnd()
+            || sstart <= getStart() && getStart() < s.getEnd();
-    return !this.contains(s) && !s.contains(this) &&
-	   (getStart() <= sstart && sstart < getEnd() ||
-	   sstart <= getStart() && getStart() < s.getEnd());
+    return !this.contains(s) && !s.contains(this)
+            && (getStart() <= sstart && sstart < getEnd()
+            || sstart <= getStart() && getStart() < s.getEnd());
-      throw new IllegalArgumentException("The span " + toString() +
-          " is outside the given text which has length " + text.length() + "!");
+      throw new IllegalArgumentException("The span " + toString()
+              + " is outside the given text which has length " + text.length() + "!");
-    }
-    else if (newStartOffset > newEndOffset) {
+    } else if (newStartOffset > newEndOffset) {
-    }
-    else {
+    } else {
-    }
-    else if (getStart() == s.getStart()) {
+    } else if (getStart() == s.getStart()) {
-      }
-      else if (getEnd() < s.getEnd()) {
+      } else if (getEnd() < s.getEnd()) {
-      }
-      else {
+      } else {
-        } else if(getType() != null) {
+        } else if (getType() != null) {
-    }
-    else {
+    } else {
-    if ( getType() == null) {
+    if (getType() == null) {
-    }
-    else {
+    } else {
-    }
-    else if (o instanceof Span) {
+    } else if (o instanceof Span) {
-      result = (getStart() == s.getStart()) &&
-          (getEnd() == s.getEnd()) &&
-          (getType() != null ? type.equals(s.getType()) : true) &&
-          (s.getType() != null ? s.getType().equals(getType()) : true);
-    }
-    else {
+      result = (getStart() == s.getStart())
+              && (getEnd() == s.getEnd())
+              && (getType() != null ? type.equals(s.getType()) : true)
+              && (s.getType() != null ? s.getType().equals(getType()) : true);
+    } else {
-        toStringBuffer.append(" ");
-        toStringBuffer.append(getType());
+      toStringBuffer.append(" ");
+      toStringBuffer.append(getType());
-      for (int ti=spans[si].getStart();ti<spans[si].getEnd();ti++) {
+      for (int ti = spans[si].getStart(); ti < spans[si].getEnd(); ti++) {
-      chunks[si]=cb.substring(0, cb.length()-1);
+      chunks[si] = cb.substring(0, cb.length() - 1);
-  public void setProb(double prob) {
-    this.prob = prob;
-  }

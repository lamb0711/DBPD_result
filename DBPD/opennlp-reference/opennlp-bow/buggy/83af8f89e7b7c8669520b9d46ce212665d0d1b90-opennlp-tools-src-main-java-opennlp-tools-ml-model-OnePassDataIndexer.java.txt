OPENNLP-880: Refactor data indexer

1.) Added method to EventTrainer – train(DataIndexer indexer)
    –Then I added the method to AbstractEventTrainer.
    No other code needed to be changed.

2.) Created a new class – PluggableParmeters: Only AbstractTrainers
    had access to getXXXParam(Value,Default). So I pulled out this
    functionality into a separate class. Now both
    AbstractTrainers and AbstractDataIndexers can hold parameters.

3.) Refactored DataIndexer. This touched a lot of code.
    Added init(Map,Map) method and index(ObjectStream) method.
    Changed 1-Pass and 2-Pass DataIndexers. Everywhere 1-pass/2-pass
    indexers where created, I changed the constructor,
    and added the init and index methods.

4.) Changed GIS.doTrain(indexer) to use the parameters
    passed in the init method.

5.) QNTrainer – created a working init method. Changed the
    isValid method so it is not the init method.

This closes #14

+  @Deprecated
+  @Deprecated
+  @Deprecated
-    LinkedList<Event> events;
+    List<Event> events;
+    List<ComparableEvent> eventsToCompare;
+  
+    System.out.println("Indexing events using cutoff of " + cutoff + "\n");
+  
+    System.out.print("\tComputing event counts...  ");
+    events = computeEventCounts(eventStream, predicateIndex, cutoff);
+    System.out.println("done. " + events.size() + " events");
+  
+    System.out.print("\tIndexing...  ");
+    eventsToCompare = index(events, predicateIndex);
+    // done with event list
+    events = null;
+    // done with predicates
+    predicateIndex = null;
+  
+    System.out.println("done.");
+  
+    System.out.print("Sorting and merging events... ");
+    sortAndMerge(eventsToCompare, sort);
+    System.out.println("Done indexing.");
+  }
+
+  public OnePassDataIndexer(){}
+
+  @Override
+  public void index(ObjectStream<Event> eventStream) throws IOException {
+    int cutoff = parameters.getIntParam(CUTOFF_PARAM, CUTOFF_DEFAULT);
+    boolean sort = parameters.getBooleanParam(SORT_PARAM, SORT_DEFAULT);
+
+    Map<String, Integer> predicateIndex = new HashMap<>();
+    List<Event> events;
-  private LinkedList<Event> computeEventCounts(ObjectStream<Event> eventStream,
+  private List<Event> computeEventCounts(ObjectStream<Event> eventStream,
-    LinkedList<Event> events = new LinkedList<>();
+    List<Event> events = new LinkedList<>();
-      events.addLast(ev);
+      events.add(ev);
-  protected List<ComparableEvent> index(LinkedList<Event> events,
+  protected List<ComparableEvent> index(List<Event> events,
-    for (int eventIndex = 0; eventIndex < numEvents; eventIndex++) {
-      Event ev = events.removeFirst();
+    for (Event ev:events) {

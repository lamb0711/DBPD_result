OPENNLP-29 Added multi threaded GIS training support

git-svn-id: https://svn.apache.org/repos/asf/incubator/opennlp/trunk@1126493 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
-  /**
-   * Stores the expected values of the features based on the current models
+  /** 
+   * Stores the expected values of the features based on the current models 
-  private MutableContext[] modelExpects;
+  private MutableContext[][] modelExpects;
-    return trainModel(iterations,di,new UniformPrior(),cutoff);
+    return trainModel(iterations,di,new UniformPrior(),cutoff,1);
-  public GISModel trainModel(int iterations, DataIndexer di, Prior modelPrior, int cutoff) {
+  public GISModel trainModel(int iterations, DataIndexer di, Prior modelPrior, int cutoff, int threads) {
+    
+    if (threads <= 0)
+      throw new IllegalArgumentException("threads must be at leat one or greater!");
+    
+    modelExpects = new MutableContext[threads][];
+    
-    modelExpects = new MutableContext[numPreds];
+    for (int i = 0; i< modelExpects.length; i++)
+      modelExpects[i] = new MutableContext[numPreds];
-      modelExpects[pi] = new MutableContext(outcomePattern,new double[numActiveOutcomes]);
+      for (int i = 0; i< modelExpects.length; i++)
+        modelExpects[i][pi] = new MutableContext(outcomePattern,new double[numActiveOutcomes]);
-        modelExpects[pi].setParameter(aoi, 0.0);
+        for (int i = 0; i< modelExpects.length; i++)
+          modelExpects[i][pi].setParameter(aoi, 0.0);
-    double f;
-    double modelValue = modelExpects[predicate].getParameters()[oid];
+    double modelValue = modelExpects[0][predicate].getParameters()[oid];
-      f = tmp + (param + x0) / sigma - observedValue;
+      double f = tmp + (param + x0) / sigma - observedValue;
+  private class ModelExpactationComputeTask implements Callable<ModelExpactationComputeTask> {
+
+    private final int startIndex;
+    private final int length; 
+    
+    private double loglikelihood = 0;
+    
+    private int numEvents = 0;
+    private int numCorrect = 0;
+    
+    final private int threadIndex;
+
+    // startIndex to compute, number of events to compute
+    ModelExpactationComputeTask(int threadIndex, int startIndex, int length) {
+      this.startIndex = startIndex;
+      this.length = length;
+      this.threadIndex = threadIndex;
+    }
+    
+    public ModelExpactationComputeTask call() {
+      
+      final double[] modelDistribution = new double[numOutcomes];
+      
+      
+      for (int ei = startIndex; ei < startIndex + length; ei++) {
+        
+        // TODO: check interruption status here, if interrupted set a poisoned flag and return
+        
+        if (values != null) {
+          prior.logPrior(modelDistribution, contexts[ei], values[ei]); 
+          GISModel.eval(contexts[ei], values[ei], modelDistribution, evalParams);
+        }
+        else {
+          prior.logPrior(modelDistribution,contexts[ei]);
+          GISModel.eval(contexts[ei], modelDistribution, evalParams);
+        }
+        for (int j = 0; j < contexts[ei].length; j++) {
+          int pi = contexts[ei][j];
+          if (predicateCounts[pi] >= cutoff) {
+            int[] activeOutcomes = modelExpects[threadIndex][pi].getOutcomes();
+            for (int aoi=0;aoi<activeOutcomes.length;aoi++) {
+              int oi = activeOutcomes[aoi];
+              
+              // TODO: Read and write to modelExpects must be thread safe ... 
+              // numTimesEventsSeen must also be thread safe
+              if (values != null && values[ei] != null) {
+                modelExpects[threadIndex][pi].updateParameter(aoi,modelDistribution[oi] * values[ei][j] * numTimesEventsSeen[ei]);
+              }
+              else {
+                modelExpects[threadIndex][pi].updateParameter(aoi,modelDistribution[oi] * numTimesEventsSeen[ei]);
+              }
+            }
+          }
+        }
+        
+        loglikelihood += Math.log(modelDistribution[outcomeList[ei]]) * numTimesEventsSeen[ei];
+        
+        numEvents += numTimesEventsSeen[ei];
+        if (printMessages) {
+          int max = 0;
+          for (int oi = 1; oi < numOutcomes; oi++) {
+            if (modelDistribution[oi] > modelDistribution[max]) {
+              max = oi;
+            }
+          }
+          if (max == outcomeList[ei]) {
+            numCorrect += numTimesEventsSeen[ei];
+          }
+        }
+        
+      }
+      
+      return this;
+    }
+    
+    synchronized int getNumEvents() {
+      return numEvents;
+    }
+    
+    synchronized int getNumCorrect() {
+      return numCorrect;
+    }
+    
+    synchronized double getLoglikelihood() {
+      return loglikelihood;
+    }
+  }
+  
-    double[] modelDistribution = new double[numOutcomes];
-    for (int ei = 0; ei < numUniqueEvents; ei++) {
-      if (values != null) {
-        prior.logPrior(modelDistribution,contexts[ei],values[ei]);
-        GISModel.eval(contexts[ei], values[ei], modelDistribution, evalParams);
-      }
-      else {
-        prior.logPrior(modelDistribution,contexts[ei]);
-        GISModel.eval(contexts[ei], modelDistribution, evalParams);
-      }
-      
-      for (int j = 0; j < contexts[ei].length; j++) {
-        int pi = contexts[ei][j];
-        if (predicateCounts[pi] >= cutoff) {
-          int[] activeOutcomes = modelExpects[pi].getOutcomes();
-          for (int aoi=0;aoi<activeOutcomes.length;aoi++) {
-            int oi = activeOutcomes[aoi];
-            if (values != null && values[ei] != null) {
-              modelExpects[pi].updateParameter(aoi,modelDistribution[oi] * values[ei][j] * numTimesEventsSeen[ei]);
-            }
-            else {
-              modelExpects[pi].updateParameter(aoi,modelDistribution[oi] * numTimesEventsSeen[ei]);
-            }
-          }
-        }
-      }
-      
-      loglikelihood += Math.log(modelDistribution[outcomeList[ei]]) * numTimesEventsSeen[ei];
-      numEvents += numTimesEventsSeen[ei];
-      if (printMessages) {
-        int max = 0;
-        for (int oi = 1; oi < numOutcomes; oi++) {
-          if (modelDistribution[oi] > modelDistribution[max]) {
-            max = oi;
-          }
-        }
-        if (max == outcomeList[ei]) {
-          numCorrect += numTimesEventsSeen[ei];
-        }
-      }
-
+    
+    int numberOfThreads = modelExpects.length;
+    
+    ExecutorService executor = Executors.newFixedThreadPool(numberOfThreads);
+    
+    int taskSize = numUniqueEvents / numberOfThreads;
+    
+    int leftOver = numUniqueEvents % numberOfThreads;
+    
+    List<Future<?>> futures = new ArrayList<Future<?>>();
+    
+    for (int i = 0; i < numberOfThreads; i++) {
+      if (i != numberOfThreads - 1)
+        futures.add(executor.submit(new ModelExpactationComputeTask(i, i*taskSize, taskSize)));
+      else 
+        futures.add(executor.submit(new ModelExpactationComputeTask(i, i*taskSize, taskSize + leftOver)));
+    
+    for (Future<?> future : futures) {
+      ModelExpactationComputeTask finishedTask = null;
+      try {
+        finishedTask = (ModelExpactationComputeTask) future.get();
+      } catch (InterruptedException e) {
+        // In case we get interuppted, the exception should be rethrown
+        // and the executor services shutdownNow should be called, to stop any work
+        e.printStackTrace();
+      } catch (ExecutionException e) {
+        e.printStackTrace();
+      }
+      
+      // When they are done, retrieve the results ...
+      numEvents += finishedTask.getNumEvents();
+      numCorrect += finishedTask.getNumCorrect();
+      loglikelihood += finishedTask.getLoglikelihood();
+    }
+
+    executor.shutdown();
+    
+    // merge the results of the two computations
+    for (int pi = 0; pi < numPreds; pi++) {
+      int[] activeOutcomes = params[pi].getOutcomes();
+      
+      for (int aoi=0;aoi<activeOutcomes.length;aoi++) {
+        for (int i = 1; i < modelExpects.length; i++) {
+          modelExpects[0][pi].updateParameter(aoi, modelExpects[i][pi].getParameters()[aoi]);
+        }
+      }
+    }
+    
+    display(".");
+    
-      double[] model = modelExpects[pi].getParameters();
+      double[] model = modelExpects[0][pi].getParameters();
-        modelExpects[pi].setParameter(aoi,0.0); // re-initialize to 0.0's
+        
+        for (int i = 0; i< modelExpects.length; i++)
+          modelExpects[i][pi].setParameter(aoi,0.0); // re-initialize to 0.0's
+
-

OPENNLP-402 Added formats support to trainer and evaluator tools. Refactoring of various things. Thanks to Aliaksandr Autayeu for providing a patch.

git-svn-id: https://svn.apache.org/repos/asf/incubator/opennlp/trunk@1209220 13f79535-47bb-0310-9956-ffa450edef68

-      Object value = null;
+      Object value;
-        throw new TerminateToolException(-1, String.format(INVALID_ARG, argName, argValue) +
+        throw new TerminateToolException(1, String.format(INVALID_ARG, argName, argValue) +
-          throw new TerminateToolException(-1,  String.format(INVALID_ARG, argName, charsetName) + 
+          throw new TerminateToolException(1,  String.format(INVALID_ARG, argName, charsetName) +
-        throw new TerminateToolException(-1, String.format(INVALID_ARG, argName, charsetName) + 
+        throw new TerminateToolException(1, String.format(INVALID_ARG, argName, charsetName) +
-  private static <T> void checkProxyInterface(Class<T> proxyInterface) {
-    if (!proxyInterface.isInterface())
-      throw new IllegalArgumentException("proxy interface is not an interface!");
-    
-    // all checks should also be performed for super interfaces
-    
-    Method methods[] = proxyInterface.getMethods();
-    
-    if (methods.length == 0)
-      throw new IllegalArgumentException("proxy interface must at least declare one method!");
-    
-    for (Method method : methods) {
-      
-      // check that method names start with get
-      if (!method.getName().startsWith("get") && method.getName().length() > 3) 
-        throw new IllegalArgumentException(method.getName() + " method name does not start with get!");
-    
-      // check that method has zero arguments
-      if (method.getParameterTypes().length != 0)
-        throw new IllegalArgumentException(method.getName() + " method must have zero parameters!");
-      
-      // check return types of interface
-      Class<?> returnType = method.getReturnType();
-      
-      Set<Class<?>> compatibleReturnTypes = argumentFactories.keySet();
-      
-      if(!compatibleReturnTypes.contains(returnType))
-         throw new IllegalArgumentException(method.getName() + " method must have compatible return type!");
+  private static <T> void checkProxyInterfaces(Class<T>... proxyInterfaces) {
+    for (Class<T> proxyInterface : proxyInterfaces) {
+      if (null != proxyInterface) {
+        if (!proxyInterface.isInterface())
+          throw new IllegalArgumentException("proxy interface is not an interface!");
+
+        // all checks should also be performed for super interfaces
+
+        Method methods[] = proxyInterface.getMethods();
+
+        if (methods.length == 0)
+          throw new IllegalArgumentException("proxy interface must at least declare one method!");
+
+        for (Method method : methods) {
+
+          // check that method names start with get
+          if (!method.getName().startsWith("get") && method.getName().length() > 3)
+            throw new IllegalArgumentException(method.getName() + " method name does not start with get!");
+
+          // check that method has zero arguments
+          if (method.getParameterTypes().length != 0)
+            throw new IllegalArgumentException(method.getName() + " method must have zero parameters!");
+
+          // check return types of interface
+          Class<?> returnType = method.getReturnType();
+
+          Set<Class<?>> compatibleReturnTypes = argumentFactories.keySet();
+
+          if(!compatibleReturnTypes.contains(returnType))
+             throw new IllegalArgumentException(method.getName() + " method must have compatible return type!");
+        }
+      }
-    
+
-    
+
-  
+
-   * 
-   * @param argProxyInterface
-   * 
+   *
+   * @param argProxyInterface interface with parameter descriptions
+  @SuppressWarnings({"unchecked"})
+    return createUsage(new Class[]{argProxyInterface});
+  }
-    checkProxyInterface(argProxyInterface);
-    
+  
+  /**
+   * Creates a usage string which can be printed in case the user did specify the arguments
+   * incorrectly. Incorrectly is defined as {@link ArgumentParser#validateArguments(String[],
+   * Class[])}
+   * returns false.
+   * 
+   * @param argProxyInterfaces interfaces with parameter descriptions
+   * @return the help message usage string
+   */
+  public static <T> String createUsage(Class<T>... argProxyInterfaces) {
+    checkProxyInterfaces(argProxyInterfaces);
+
-    
-    for (Method method : argProxyInterface.getMethods()) {
-      
-      ParameterDescription desc = method.getAnnotation(ParameterDescription.class);
-      
-      OptionalParameter optional = method.getAnnotation(OptionalParameter.class);
-      
-      if (desc != null) {
-        String paramName = methodNameToParameter(method.getName());
-        
-        if (optional != null)
-          usage.append('[');
-        
-        usage.append(paramName).append(' ').append(desc.valueName());
-        details.append('\t').append(paramName).append(' ').append(desc.valueName()).append('\n');
-        if(desc.description() != null && desc.description().length() > 0) {
-          details.append("\t\t").append(desc.description()).append('\n');
+    for (Class<T> argProxyInterface : argProxyInterfaces) {
+      if (null != argProxyInterface) {
+        for (Method method : argProxyInterface.getMethods()) {
+
+          ParameterDescription desc = method.getAnnotation(ParameterDescription.class);
+
+          OptionalParameter optional = method.getAnnotation(OptionalParameter.class);
+
+          if (desc != null) {
+            String paramName = methodNameToParameter(method.getName());
+
+            if (optional != null)
+              usage.append('[');
+
+            usage.append(paramName).append(' ').append(desc.valueName());
+            details.append('\t').append(paramName).append(' ').append(desc.valueName()).append('\n');
+            if(desc.description() != null && desc.description().length() > 0) {
+              details.append("\t\t").append(desc.description()).append('\n');
+            }
+
+            if (optional != null)
+              usage.append(']');
+
+            usage.append(' ');
+          }
-        
-        if (optional != null)
-          usage.append(']');
-        
-        usage.append(' ');
-    
+
-    
-    if(details.length() > 0) {
+
+    if (details.length() > 0) {
-    
+
-  
+
+  @SuppressWarnings({"unchecked"})
-    return null == validateArgumentsLoudly(args, argProxyInterface);
+    return validateArguments(args, new Class[]{argProxyInterface});
+  }
+
+  /**
+   * Tests if the argument are correct or incorrect. Incorrect means, that mandatory arguments are missing or
+   * there are unknown arguments. The argument value itself can also be incorrect, but this
+   * is checked by the {@link ArgumentParser#parse(String[], Class)} method and reported accordingly.
+   *
+   * @param args command line arguments
+   * @param argProxyInterfaces interfaces with parameters description
+   * @return true, if arguments are valid
+   */
+  public static <T> boolean validateArguments(String args[], Class<T>... argProxyInterfaces) {
+    return null == validateArgumentsLoudly(args, argProxyInterfaces);
+  }
+
+  /**
+   * Tests if the arguments are correct or incorrect.
+   *
+   * @param args command line arguments
+   * @param argProxyInterface interface with parameters description
+   * @return null, if arguments are valid or error message otherwise
+   */
+  @SuppressWarnings({"unchecked"})
+  public static <T> String validateArgumentsLoudly(String args[], Class<T> argProxyInterface) {
+    return validateArgumentsLoudly(args, new Class[]{argProxyInterface});
-   * @param argProxyInterface interface with parameters description
+   * @param argProxyInterfaces interfaces with parameters description
-  public static <T> String validateArgumentsLoudly(String args[], Class<T> argProxyInterface) {
-    
+  public static <T> String validateArgumentsLoudly(String args[], Class<T>... argProxyInterfaces) {
-      return "Error: Number of parameters must be at least 2 and always be even";
+      return "Number of parameters must be at least 2 and always be even";
-    
+
-
-    for (Method method : argProxyInterface.getMethods()) {
-      String paramName = methodNameToParameter(method.getName());
-      int paramIndex = CmdLineUtil.getParameterIndex(paramName, args);
-      String valueString = CmdLineUtil.getParameter(paramName, args);
-      if (valueString == null) {
-        OptionalParameter optionalParam = method.getAnnotation(OptionalParameter.class);
-        if (optionalParam == null) {
-          if (-1 < paramIndex) {
-            return "Error: Missing mandatory parameter value: " + paramName;
+    for (Class<T> argProxyInterface : argProxyInterfaces) {
+      for (Method method : argProxyInterface.getMethods()) {
+        String paramName = methodNameToParameter(method.getName());
+        int paramIndex = CmdLineUtil.getParameterIndex(paramName, args);
+        String valueString = CmdLineUtil.getParameter(paramName, args);
+        if (valueString == null) {
+          OptionalParameter optionalParam = method.getAnnotation(OptionalParameter.class);
+
+          if (optionalParam == null) {
+            if (-1 < paramIndex) {
+              return "Missing mandatory parameter value: " + paramName;
+            } else {
+              return "Missing mandatory parameter: " + paramName;
+            }
-            return "Error: Missing mandatory parameter: " + paramName;
+            parameters.remove("-" + paramName);
-        } else {
-          parameters.remove("-" + paramName);
+        }
+        else {
+          parameters.remove(paramName);
+          parameters.remove(valueString);
+          argumentCount++;
-      else {
-        parameters.remove(paramName);
-        parameters.remove(valueString);
-        argumentCount++;
-      }
-    
+
-      return "Error: Unrecognized parameters encountered: " + parameters.toString();
+      return "Unrecognized parameters encountered: " + parameters.toString();
-    
+
-    checkProxyInterface(argProxyInterface);
+    checkProxyInterfaces(argProxyInterface);
+
+  /**
+   * Filters arguments leaving only those pertaining to argProxyInterface.
+   *
+   * @param args arguments
+   * @param argProxyInterface interface with parameters description
+   * @param <T> T
+   * @return arguments pertaining to argProxyInterface
+   */
+  public static <T> String[] filter(String args[], Class<T> argProxyInterface) {
+    ArrayList<String> parameters = new ArrayList<String>(args.length);
+
+    for (Method method : argProxyInterface.getMethods()) {
+
+      String parameterName = methodNameToParameter(method.getName());
+      int idx = CmdLineUtil.getParameterIndex(parameterName, args);
+      if (-1 < idx) {
+        parameters.add(parameterName);
+        String valueString = CmdLineUtil.getParameter(parameterName, args);
+        if (null != valueString) {
+          parameters.add(valueString);
+        }
+      }
+    }
+
+    return parameters.toArray(new String[parameters.size()]);
+  }

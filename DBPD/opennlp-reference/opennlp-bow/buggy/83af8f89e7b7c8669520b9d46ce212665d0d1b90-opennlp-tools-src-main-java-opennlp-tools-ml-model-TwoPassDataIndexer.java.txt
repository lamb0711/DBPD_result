OPENNLP-880: Refactor data indexer

1.) Added method to EventTrainer – train(DataIndexer indexer)
    –Then I added the method to AbstractEventTrainer.
    No other code needed to be changed.

2.) Created a new class – PluggableParmeters: Only AbstractTrainers
    had access to getXXXParam(Value,Default). So I pulled out this
    functionality into a separate class. Now both
    AbstractTrainers and AbstractDataIndexers can hold parameters.

3.) Refactored DataIndexer. This touched a lot of code.
    Added init(Map,Map) method and index(ObjectStream) method.
    Changed 1-Pass and 2-Pass DataIndexers. Everywhere 1-pass/2-pass
    indexers where created, I changed the constructor,
    and added the init and index methods.

4.) Changed GIS.doTrain(indexer) to use the parameters
    passed in the init method.

5.) QNTrainer – created a working init method. Changed the
    isValid method so it is not the init method.

This closes #14

+  @Deprecated
+  @Deprecated
+  @Deprecated
+  
+    System.out.println("Indexing events using cutoff of " + cutoff + "\n");
+  
+    System.out.print("\tComputing event counts...  ");
+    try {
+      File tmp = File.createTempFile("events", null);
+      tmp.deleteOnExit();
+      Writer osw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tmp),"UTF8"));
+      int numEvents = computeEventCounts(eventStream, osw, predicateIndex, cutoff);
+      System.out.println("done. " + numEvents + " events");
+  
+      System.out.print("\tIndexing...  ");
+  
+      try (FileEventStream fes = new FileEventStream(tmp)) {
+        eventsToCompare = index(numEvents, fes, predicateIndex);
+      }
+      // done with predicates
+      predicateIndex = null;
+      tmp.delete();
+      System.out.println("done.");
+  
+      if (sort) {
+        System.out.print("Sorting and merging events... ");
+      }
+      else {
+        System.out.print("Collecting events... ");
+      }
+      sortAndMerge(eventsToCompare,sort);
+      System.out.println("Done indexing.");
+    }
+    catch (IOException e) {
+      System.err.println(e);
+    }
+  }
+
+  public TwoPassDataIndexer() {}
+
+  @Override
+  public void index(ObjectStream<Event> eventStream) throws IOException {
+    int cutoff = parameters.getIntParam(CUTOFF_PARAM, CUTOFF_DEFAULT);
+    boolean sort = parameters.getBooleanParam(SORT_PARAM, SORT_DEFAULT);
+
+    Map<String,Integer> predicateIndex = new HashMap<>();
+    List<ComparableEvent> eventsToCompare;
-
-      * Reads events from <tt>eventStream</tt> into a linked list.  The
-      * predicates associated with each event are counted and any which
-      * occur at least <tt>cutoff</tt> times are added to the
-      * <tt>predicatesInOut</tt> map along with a unique integer index.
-      *
-      * @param eventStream an <code>EventStream</code> value
-      * @param eventStore a writer to which the events are written to for later processing.
-      * @param predicatesInOut a <code>TObjectIntHashMap</code> value
-      * @param cutoff an <code>int</code> value
-      */
+   * Reads events from <tt>eventStream</tt> into a linked list.  The
+   * predicates associated with each event are counted and any which
+   * occur at least <tt>cutoff</tt> times are added to the
+   * <tt>predicatesInOut</tt> map along with a unique integer index.
+   *
+   * @param eventStream an <code>EventStream</code> value
+   * @param eventStore a writer to which the events are written to for later processing.
+   * @param predicatesInOut a <code>TObjectIntHashMap</code> value
+   * @param cutoff an <code>int</code> value
+   */
-                                 Map<String,Integer> predicatesInOut, int cutoff) throws IOException {
+      Map<String,Integer> predicatesInOut, int cutoff) throws IOException {

OPENNLP-580 Added a factory to construct the name finder

git-svn-id: https://svn.apache.org/repos/asf/opennlp/trunk@1576085 13f79535-47bb-0310-9956-ffa450edef68

+import opennlp.tools.chunker.ChunkerFactory;
+import opennlp.tools.util.BaseToolFactory;
-  private static final String GENERATOR_DESCRIPTOR_ENTRY_NAME = "generator.featuregen";
+  static final String GENERATOR_DESCRIPTOR_ENTRY_NAME = "generator.featuregen";
-  private static final String SEQUENCE_CODEC_CLASS_NAME_PARAMETER = "sequenceCodecImplName";
+  static final String SEQUENCE_CODEC_CLASS_NAME_PARAMETER = "sequenceCodecImplName";
-  public SequenceCodec<String> createSequenceCodec() {
-    
-    // TODO: Lookup impl name with
-    // SEQUENCE_CODEC_CLASS_NAME_PARAMETER
-    Properties manifest = (Properties) artifactMap.get(MANIFEST_ENTRY);
-    
-    String sequeceCodecImplName = manifest.getProperty(SEQUENCE_CODEC_CLASS_NAME_PARAMETER);
-    return instantiateSequenceCodec(sequeceCodecImplName);
+  @Override
+  protected Class<? extends BaseToolFactory> getDefaultFactory() {
+    return TokenNameFinderFactory.class;
+  public TokenNameFinderFactory getFactory() {
+    return (TokenNameFinderFactory) this.toolFactory;
+  }
+
+  // TODO: This should be moved to the NameFinderFactory ... !!!
+  // Lets deprecate it!
+  
+   * @deprecated use TokenNameFinderFactory.createFeatureGenerators instead!
+  @Deprecated
-
-    byte descriptorBytes[] = (byte[]) artifactMap.get(GENERATOR_DESCRIPTOR_ENTRY_NAME);
-    
-    if (descriptorBytes != null) {
-      InputStream descriptorIn = new ByteArrayInputStream(descriptorBytes);
-  
-      AdaptiveFeatureGenerator generator = null;
-      try {
-        generator = GeneratorFactory.create(descriptorIn, new FeatureGeneratorResourceProvider() {
-  
-          public Object getResource(String key) {
-            return artifactMap.get(key);
-          }
-        });
-      } catch (InvalidFormatException e) {
-        // It is assumed that the creation of the feature generation does not
-        // fail after it succeeded once during model loading.
-        
-        // But it might still be possible that such an exception is thrown,
-        // in this case the caller should not be forced to handle the exception
-        // and a Runtime Exception is thrown instead.
-        
-        // If the re-creation of the feature generation fails it is assumed
-        // that this can only be caused by a programming mistake and therefore
-        // throwing a Runtime Exception is reasonable
-        
-        throw new FeatureGeneratorCreationError(e);
-      } catch (IOException e) {
-        throw new IllegalStateException("Reading from mem cannot result in an I/O error", e);
-      }
-  
-      return generator;
-    }
-    else {
-      return null;
-    }
+    return getFactory().createFeatureGenerators();
-          descriptor, Collections.<String, Object>emptyMap(), Collections.<String, String>emptyMap(), createSequenceCodec());
+          descriptor, Collections.<String, Object>emptyMap(), Collections.<String, String>emptyMap(),
+          getFactory().createSequenceCodec());
-          createSequenceCodec());
+          getFactory().createSequenceCodec());
-  public boolean isModelValid(MaxentModel model) {
+  boolean isModelValid(MaxentModel model) {
-    return createSequenceCodec().areOutcomesCompatible(outcomes);
+    return getFactory().createSequenceCodec().areOutcomesCompatible(outcomes);
-
-  public static SequenceCodec<String> instantiateSequenceCodec(
-      String sequenceCodecImplName) {
-    
-    if (sequenceCodecImplName != null) {
-      return ExtensionLoader.instantiateExtension(
-          SequenceCodec.class, sequenceCodecImplName);
-    }
-    else {
-      // If nothing is specified return old default!
-      return new BioCodec();
-    }
-  }

OPENNLP-641 Added initial sequence classification support

git-svn-id: https://svn.apache.org/repos/asf/opennlp/trunk@1570210 13f79535-47bb-0310-9956-ffa450edef68

+import opennlp.tools.ml.EventTrainer;
+import opennlp.tools.ml.SequenceTrainer;
+import opennlp.tools.ml.TrainerFactory;
+import opennlp.tools.ml.TrainerFactory.TrainerType;
+import opennlp.tools.ml.model.SequenceClassificationModel;
-import opennlp.tools.util.BeamSearch;
+import opennlp.tools.postag.POSSampleSequenceStream;
-  /**
-   * The beam used to search for sequences of chunk tag assignments.
-   */
-  protected BeamSearch<String> beam;
-
-  protected MaxentModel model;
+  protected SequenceClassificationModel<String> model;
+
+  private ChunkerContextGenerator contextGenerator;
+  private SequenceValidator<String> sequenceValidator;
+  @Deprecated
-    this.model = model.getChunkerModel();
-    beam = new BeamSearch<String>(beamSize, contextGenerator, this.model, sequenceValidator, 0);
+    
+    this.sequenceValidator = sequenceValidator;
+    this.contextGenerator = contextGenerator;
+    
+    if (model.getChunkerModel() != null) {
+      this.model = new opennlp.tools.ml.BeamSearch<String>(beamSize,
+          model.getChunkerModel(), 0);
+    }
+    else {
+      this.model = model.getChunkerSequenceModel();
+    }
+  @Deprecated
-
+  
-    this.model = model.getChunkerModel();
-    ChunkerContextGenerator contextGenerator = model.getFactory().getContextGenerator();
-    SequenceValidator<String> sequenceValidator = model.getFactory().getSequenceValidator();
-    beam = new BeamSearch<String>(beamSize, contextGenerator, this.model, sequenceValidator, 0);
+    
+   contextGenerator = model.getFactory().getContextGenerator();
+   sequenceValidator = model.getFactory().getSequenceValidator();
+    // beam = new BeamSearch<String>(beamSize, contextGenerator, this.model, sequenceValidator, 0);
+    
+    if (model.getChunkerModel() != null) {
+      this.model = new opennlp.tools.ml.BeamSearch<String>(beamSize,
+          model.getChunkerModel(), 0);
+    }
+    else {
+      this.model = model.getChunkerSequenceModel();
+    }
-        beam.bestSequence(toks.toArray(new String[toks.size()]), new Object[] { tags.toArray(new String[tags.size()]) });
+        model.bestSequence(toks.toArray(new String[toks.size()]), new Object[] { tags.toArray(new String[tags.size()]) },
+            contextGenerator, sequenceValidator);
-    bestSequence = beam.bestSequence(toks, new Object[] {tags});
+    bestSequence = model.bestSequence(toks, new Object[] {tags}, contextGenerator, sequenceValidator);
-    return beam.bestSequences(DEFAULT_BEAM_SIZE, sentence,
-        new Object[] { tags });
+    return model.bestSequences(DEFAULT_BEAM_SIZE, sentence,
+        new Object[] { tags }, contextGenerator, sequenceValidator);
-    return beam.bestSequences(DEFAULT_BEAM_SIZE, sentence, new Object[] { tags },minSequenceScore);
+    return model.bestSequences(DEFAULT_BEAM_SIZE, sentence, new Object[] { tags }, minSequenceScore,
+        contextGenerator, sequenceValidator);
-    ObjectStream<Event> es = new ChunkerEventStream(in, factory.getContextGenerator());
+    TrainerType trainerType = TrainerFactory.getTrainerType(mlParams.getSettings());
+    
-    MaxentModel maxentModel = TrainUtil.train(es, mlParams.getSettings(),
-        manifestInfoEntries);
-
-    return new ChunkerModel(lang, maxentModel, manifestInfoEntries, factory);
+    MaxentModel chunkerModel = null;
+    SequenceClassificationModel<String> seqChunkerModel = null;
+    
+    if (TrainerType.EVENT_MODEL_TRAINER.equals(trainerType)) {
+      ObjectStream<Event> es = new ChunkerEventStream(in, factory.getContextGenerator());
+      EventTrainer trainer = TrainerFactory.getEventTrainer(mlParams.getSettings(),
+          manifestInfoEntries);
+      chunkerModel = trainer.train(es);
+    }
+    else if (TrainerType.SEQUENCE_TRAINER.equals(trainerType)) {
+      SequenceTrainer trainer = TrainerFactory.getSequenceModelTrainer(
+          mlParams.getSettings(), manifestInfoEntries);
+      
+      // TODO: This will probably cause issue, since the feature generator uses the outcomes array
+      
+      ChunkSampleSequenceStream ss = new ChunkSampleSequenceStream(in, factory.getContextGenerator());
+      seqChunkerModel = trainer.train(ss);
+    }
+    else {
+      throw new IllegalArgumentException("Trainer type is not supported: " + trainerType);  
+    }
+    
+    if (chunkerModel != null) {
+      return new ChunkerModel(lang, chunkerModel, manifestInfoEntries, factory);
+    }
+    else {
+      return new ChunkerModel(lang, seqChunkerModel, manifestInfoEntries, factory);
+    }

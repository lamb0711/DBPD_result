Fixes to Perceptron (OPENNLP-154 improved normalization, OPENNLP-155 improved checking of training accuracy); 
OPENNLP-156 improved command line trainer so that a Perceptron model is actually stored, so that options are passed to Perceptron training, and so that output of ModelApplier is one line per test event.

git-svn-id: https://svn.apache.org/repos/asf/incubator/opennlp/trunk@1091994 13f79535-47bb-0310-9956-ffa450edef68

-      if (useAverage) averageParams[pi] = new MutableContext(allOutcomesPattern,new double[numOutcomes]);
+      if (useAverage) 
+	averageParams[pi] = 
+	  new MutableContext(allOutcomesPattern,new double[numOutcomes]);
-        if (useAverage) averageParams[pi].setParameter(aoi, 0.0);
+        if (useAverage) 
+	  averageParams[pi].setParameter(aoi, 0.0);
-    if (useAverage) {
+    if (useAverage)
-    }
-    else {
+    else
-    }
+
+
+    int numTimesSameAccuracy = 0;
+    double prevAccuracy = 0.0;
+
+      // Need to do this for the full set to get a representative
+      // accuracy -- doing it while training is biased because the
+      // events are ordered according to their outcomes.
+      double currAccuracy = trainingStats(averageParams);
+      
+      if (currAccuracy == prevAccuracy) {
+	numTimesSameAccuracy++;
+      } else {
+	prevAccuracy = currAccuracy;
+	numTimesSameAccuracy = 0;
+      }
+
+      // If the accuracy hasn't changed for four iterations, stop training.
+      if (numTimesSameAccuracy == 4) {
+	display("Accuracy repeated 4 times, stopping training.\n");
+	break;
+      }
-    if (useAverage) {
+    if (useAverage)
-    }
-    else {
+    else
-    }
+
-  /* Compute one iteration of Perceptron and return log-likelihood.*/
+  /* Compute one iteration of Perceptron.*/
-    int numCorrect = 0;
-    for (int ei = 0; ei < numUniqueEvents; ei++,oei++) {
-      //Arrays.sort(contexts[ei]); only needed for debugging
+    for (int ei = 0; ei < numUniqueEvents; ei++, oei++) {
-        //System.err.print("contexts["+ei+"]=");for (int ci=0;ci<contexts[ei].length;ci++) { System.err.print(" "+contexts[ei][ci]+" ");} System.err.println();
-        for (int oi = 0; oi < numOutcomes; oi++) {
+
+        for (int oi = 0; oi < numOutcomes; oi++)
-        }
-        if (values != null) {
+
+        if (values != null)
-        }
-        else {
+        else
-        }
+
-        for (int oi = 1; oi < numOutcomes; oi++) {
-          if (modelDistribution[oi] > modelDistribution[max]) {
+        for (int oi = 1; oi < numOutcomes; oi++) 
+          if (modelDistribution[oi] > modelDistribution[max]) 
-          }
-        }
-        boolean correct = max == outcomeList[oei]; 
-        if (correct) {
-          numCorrect ++;
-        }
+
-          if (oi == outcomeList[oei]) {
-            if (modelDistribution[oi] <= 0) {
-              for (int ci = 0; ci < contexts[ei].length; ci++) {
-                int pi = contexts[ei][ci];
-                if (values == null) {
-                  params[pi].updateParameter(oi, 1);
-                }
-                else {
-                  params[pi].updateParameter(oi, values[ei][ci]);
-                }
-                if (useAverage) {
-                  if (updates[pi][oi][VALUE] != 0) {
-                    averageParams[pi].updateParameter(oi,updates[pi][oi][VALUE]*(numEvents*(iteration-updates[pi][oi][ITER])+(ei-updates[pi][oi][EVENT])));
-                    //System.err.println("p avp["+pi+"]."+oi+"="+averageParams[pi].getParameters()[oi]);
-                  }
-                  //System.err.println("p updates["+pi+"]["+oi+"]=("+updates[pi][oi][ITER]+","+updates[pi][oi][EVENT]+","+updates[pi][oi][VALUE]+") + ("+iteration+","+ei+","+params[pi].getParameters()[oi]+") -> "+averageParams[pi].getParameters()[oi]);
-                  updates[pi][oi][VALUE] = (int) params[pi].getParameters()[oi];
-                  updates[pi][oi][ITER] = iteration;
-                  updates[pi][oi][EVENT] = ei;
-                }
-              }
-            }
-          }
-          else {
-            if (modelDistribution[oi] > 0) {
-              for (int ci = 0; ci < contexts[ei].length; ci++) {
-                int pi = contexts[ei][ci];
-                if (values == null) {
-                  params[pi].updateParameter(oi, -1);
-                }
-                else {
-                  params[pi].updateParameter(oi, -1*values[ei][ci]);
-                }
-                if (useAverage) {
-                  if (updates[pi][oi][VALUE] != 0) {
-                    averageParams[pi].updateParameter(oi,updates[pi][oi][VALUE]*(numEvents*(iteration-updates[pi][oi][ITER])+(ei-updates[pi][oi][EVENT])));
-                    //System.err.println("d avp["+pi+"]."+oi+"="+averageParams[pi].getParameters()[oi]);
-                  }
-                  //System.err.println(ei+" d updates["+pi+"]["+oi+"]=("+updates[pi][oi][ITER]+","+updates[pi][oi][EVENT]+","+updates[pi][oi][VALUE]+") + ("+iteration+","+ei+","+params[pi].getParameters()[oi]+") -> "+averageParams[pi].getParameters()[oi]);
-                  updates[pi][oi][VALUE] = (int) params[pi].getParameters()[oi];
-                  updates[pi][oi][ITER] = iteration;
-                  updates[pi][oi][EVENT] = ei;
-                }
-              }
-            }
-          }
-        }
+	  int updateValue = -1;
+          if (oi == outcomeList[oei])
+	    updateValue = 1;
+
+	  if (modelDistribution[oi]*updateValue <= 0) {
+	    for (int ci = 0; ci < contexts[ei].length; ci++) {
+	      int pi = contexts[ei][ci];
+	      if (values == null)
+		params[pi].updateParameter(oi, updateValue);
+	      else
+		params[pi].updateParameter(oi, updateValue*values[ei][ci]);
+
+	      if (useAverage) {
+
+		if (updates[pi][oi][VALUE] != 0)
+		  averageParams[pi].updateParameter(oi,
+		     updates[pi][oi][VALUE] *
+		     (numEvents * (iteration-updates[pi][oi][ITER])
+		      + (ei-updates[pi][oi][EVENT])));
+
+		updates[pi][oi][VALUE] = (int) params[pi].getParameters()[oi];
+		updates[pi][oi][ITER] = iteration;
+		updates[pi][oi][EVENT] = ei;
+	      }
+	    }
+	  }
+	}
+
-          if (updates[pi][oi][VALUE] != 0) {
-            predParams[oi] +=  updates[pi][oi][VALUE]*(numEvents*(iterations-updates[pi][oi][ITER])-updates[pi][oi][EVENT]);
-          }
+          if (updates[pi][oi][VALUE] != 0) 
+            predParams[oi] +=  
+	      updates[pi][oi][VALUE] *
+	      (numEvents * (iterations-updates[pi][oi][ITER])
+	       - updates[pi][oi][EVENT]);
+
-            //System.err.println("updates["+pi+"]["+oi+"]=("+updates[pi][oi][ITER]+","+updates[pi][oi][EVENT]+","+updates[pi][oi][VALUE]+") + ("+iterations+","+0+","+params[pi].getParameters()[oi]+") -> "+averageParams[pi].getParameters()[oi]);
-    display(". ("+numCorrect+"/"+numEvents+") "+((double) numCorrect / numEvents) + "\n");
-  private void trainingStats(MutableContext[] params) {
+  private double trainingStats(MutableContext[] params) {
-    for (int ei = 0; ei < numUniqueEvents; ei++) {
+    int oei = 0;
+    for (int ei = 0; ei < numUniqueEvents; ei++, oei++) {
-        for (int oi = 0; oi < numOutcomes; oi++) {
+        for (int oi = 0; oi < numOutcomes; oi++)
-        }
-        if (values != null) {
+        if (values != null)
-        }
-        else {
+        else
-        }
-        for (int oi = 1; oi < numOutcomes; oi++) {
-          if (modelDistribution[oi] > modelDistribution[max]) {
+        for (int oi = 1; oi < numOutcomes; oi++)
+          if (modelDistribution[oi] > modelDistribution[max])
-          }
-        }
-        if (max == outcomeList[ei]) {
+        if (max == outcomeList[oei])
-        }
-    display(". ("+numCorrect+"/"+numEvents+") "+((double) numCorrect / numEvents) + "\n");
+    double trainingAccuracy = (double) numCorrect / numEvents;
+    display(". ("+numCorrect+"/"+numEvents+") "+ trainingAccuracy + "\n");
+    return trainingAccuracy;

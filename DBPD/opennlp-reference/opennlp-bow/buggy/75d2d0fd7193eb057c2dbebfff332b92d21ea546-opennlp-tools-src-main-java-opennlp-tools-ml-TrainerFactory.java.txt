OPENNLP-636 Removed usage of Class.forName from all non-deprecated methods. OpenNLP code base should be converted to use the new methods.

git-svn-id: https://svn.apache.org/repos/asf/opennlp/trunk@1569390 13f79535-47bb-0310-9956-ffa450edef68

-
-// TODO: Another issue is that certain trainers will have certain properties,
-// the code using the trainer should have the possibilites to get these properties
-// in our case this could be communicated via the trainer interface itself!
-// For example via property methods.
-
-// 
+import opennlp.tools.util.ext.ExtensionLoader;
+import opennlp.tools.util.ext.ExtensionNotLoadedException;
-    // TODO: This will not work in an OSGi environment!
-    if (trainerClass == null) {
-      try {
-        trainerClass = Class.forName(alogrithmValue);
-      } catch (ClassNotFoundException e) {
-      }
-    }
-    
+
+    // Try to load the different trainers, and return the type on success
+    try {
+      ExtensionLoader.instantiateExtension(EventTrainer.class, alogrithmValue);
+      return TrainerType.EVENT_MODEL_TRAINER; 
+    }
+    catch (ExtensionNotLoadedException e) {
+    }
+    
+    try {
+      ExtensionLoader.instantiateExtension(EventModelSequenceTrainer.class, alogrithmValue);
+      return TrainerType.EVENT_MODEL_SEQUENCE_TRAINER;
+    }
+    catch (ExtensionNotLoadedException e) {
+    }
+
+    try {
+      ExtensionLoader.instantiateExtension(SequenceTrainer.class, alogrithmValue);
+      return TrainerType.SEQUENCE_TRAINER;
+    }
+    catch (ExtensionNotLoadedException e) {
+    }
+
-  
-    String trainerType = getTrainerTypeInt(trainParams);
-    if (BUILTIN_TRAINERS.containsKey(trainerType)) {
-      return TrainerFactory.<SequenceTrainer> create(
-          BUILTIN_TRAINERS.get(trainerType), trainParams, reportMap);
-    } else {
-      return TrainerFactory.<SequenceTrainer> create(trainerType, trainParams,
-          reportMap);
-    }
+    String trainerType = trainParams.get(AbstractTrainer.ALGORITHM_PARAM);
+    if (trainerType != null) {
+      if (BUILTIN_TRAINERS.containsKey(trainerType)) {
+        return TrainerFactory.<SequenceTrainer> createBuiltinTrainer(
+            BUILTIN_TRAINERS.get(trainerType), trainParams, reportMap);
+      } else {
+        return ExtensionLoader.instantiateExtension(SequenceTrainer.class, trainerType);
+      }
+    }
+    else {
+      throw new IllegalArgumentException("Trainer type couldn't be determined!");
+    }
-    return getSequenceTrainer(trainParams, reportMap);
+    String trainerType = trainParams.get(AbstractTrainer.ALGORITHM_PARAM);
+    if (trainerType != null) {
+      if (BUILTIN_TRAINERS.containsKey(trainerType)) {
+        return TrainerFactory.<EventModelSequenceTrainer> createBuiltinTrainer(
+            BUILTIN_TRAINERS.get(trainerType), trainParams, reportMap);
+      } else {
+        return ExtensionLoader.instantiateExtension(EventModelSequenceTrainer.class, trainerType);
+      }
+    }
+    else {
+      throw new IllegalArgumentException("Trainer type couldn't be determined!");
+    }
-    String trainerType = getTrainerTypeInt(trainParams);
-    if (BUILTIN_TRAINERS.containsKey(trainerType)) {
-      return TrainerFactory.<EventModelSequenceTrainer> create(
-          BUILTIN_TRAINERS.get(trainerType), trainParams, reportMap);
-    } else {
-      return TrainerFactory.<EventModelSequenceTrainer> create(trainerType, trainParams,
-          reportMap);
-    }
+    return getEventModelSequenceTrainer(trainParams, reportMap);
-    String trainerType = getTrainerTypeInt(trainParams);
-    if(trainerType == null) {
+    String trainerType = trainParams.get(AbstractTrainer.ALGORITHM_PARAM);
+    if (trainerType == null) {
-    
-    if (BUILTIN_TRAINERS.containsKey(trainerType)) {
-      return TrainerFactory.<EventTrainer> create(
-          BUILTIN_TRAINERS.get(trainerType), trainParams, reportMap);
-    } else {
-      return TrainerFactory.<EventTrainer> create(trainerType, trainParams,
-          reportMap);
+    else {
+      if (BUILTIN_TRAINERS.containsKey(trainerType)) {
+        return TrainerFactory.<EventTrainer> createBuiltinTrainer(
+            BUILTIN_TRAINERS.get(trainerType), trainParams, reportMap);
+      } else {
+        return ExtensionLoader.instantiateExtension(EventTrainer.class, trainerType);
+      }
-    // to check the algorithm we verify if it is a built in trainer, or if we can instantiate
-    // one if it is a class name
-    
+    // If a trainer type can be determined, then the trainer is valid!
-        !(BUILTIN_TRAINERS.containsKey(algorithmName) || canLoadTrainer(algorithmName))) {
+        !(BUILTIN_TRAINERS.containsKey(algorithmName) || getTrainerType(trainParams) != null)) {
-  private static boolean canLoadTrainer(String className) {
-    try {
-      Class<?> trainerClass = Class.forName(className);
-      if(trainerClass != null &&
-          (EventTrainer.class.isAssignableFrom(trainerClass)
-              || EventModelSequenceTrainer.class.isAssignableFrom(trainerClass) || SequenceTrainer.class.isAssignableFrom(trainerClass))) {
-        return true;
-      }
-    } catch (ClassNotFoundException e) {
-      // fail
-    }
-    return false;
-  }
-
-  private static String getTrainerTypeInt(Map<String, String> trainParams) {
-    return trainParams.get(AbstractTrainer.ALGORITHM_PARAM);
-  }
-
-  private static <T> T create(String className,
-      Map<String, String> trainParams, Map<String, String> reportMap) {
-    T theFactory = null;
-
-    try {
-      // TODO: won't work in OSGi!
-      Class<T> trainerClass = (Class<T>) Class.forName(className);
-      
-      theFactory = create(trainerClass, trainParams, reportMap);
-    } catch (Exception e) {
-      String msg = "Could not instantiate the " + className
-          + ". The initialization throw an exception.";
-      System.err.println(msg);
-      e.printStackTrace();
-      throw new IllegalArgumentException(msg, e);
-    }
-    return theFactory;
-  }
-
-  private static <T> T create(Class<T> trainerClass,
+  private static <T> T createBuiltinTrainer(Class<T> trainerClass,

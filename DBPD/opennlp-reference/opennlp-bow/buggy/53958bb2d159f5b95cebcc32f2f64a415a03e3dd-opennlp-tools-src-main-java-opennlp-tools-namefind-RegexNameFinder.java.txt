OPENNLP-643
Initial rough cut. Modified the RegexNameFinder to process a list of regexes by type via a constructor with a map. Added a RegexNameFinderFactory which can return a set of defaults as a RegexNameFinder. May have been overly creative with the Enum...All the regexes still need work, but they are effective for the most basic cases. Need non US P# regexes

git-svn-id: https://svn.apache.org/repos/asf/opennlp/trunk@1563130 13f79535-47bb-0310-9956-ffa450edef68

-
-
-  private final Pattern mPatterns[];
-  private final String sType;
+  private Pattern mPatterns[];
+  private String sType;
+  private Map<String, Pattern[]> regexMap;
+
+  public RegexNameFinder(Map<String, Pattern[]> regexMap) {
+    if (regexMap == null) {
+      throw new IllegalArgumentException("regexNameFinders must not be null");
+    }
+    this.regexMap = regexMap;
+
+  }
-  
-  public Span[] find(String tokens[]) {
-    Map<Integer, Integer> sentencePosTokenMap = new HashMap<Integer, Integer>();
-    StringBuffer sentenceString = new StringBuffer(tokens.length *  10);
+  @Override
+  public Span[] find(String tokens[]) {
+    Map<Integer, Integer> sentencePosTokenMap = new HashMap<>();
+
+    StringBuffer sentenceString = new StringBuffer(tokens.length * 10);
-    Collection<Span> annotations = new LinkedList<Span>();
+    Collection<Span> annotations = new LinkedList<>();
-    for (Pattern mPattern : mPatterns) {
-      Matcher matcher = mPattern.matcher(sentenceString);
+    if (mPatterns == null && regexMap != null) {
+      for (Map.Entry<String, Pattern[]> entry : regexMap.entrySet()) {
+        for (Pattern mPattern : entry.getValue()) {
+          Matcher matcher = mPattern.matcher(sentenceString);
-      while (matcher.find()) {
-        Integer tokenStartIndex =
-            sentencePosTokenMap.get(matcher.start());
-        Integer tokenEndIndex =
-            sentencePosTokenMap.get(matcher.end());
+          while (matcher.find()) {
+            Integer tokenStartIndex =
+                    sentencePosTokenMap.get(matcher.start());
+            Integer tokenEndIndex =
+                    sentencePosTokenMap.get(matcher.end());
-        if (tokenStartIndex != null && tokenEndIndex != null) {
+            if (tokenStartIndex != null && tokenEndIndex != null) {
+              Span annotation = new Span(tokenStartIndex, tokenEndIndex, entry.getKey());
+              annotations.add(annotation);
+            }
+          }
+        }
+      }
+    } else {
+      for (Pattern mPattern : mPatterns) {
+        Matcher matcher = mPattern.matcher(sentenceString);
+
+        while (matcher.find()) {
+          Integer tokenStartIndex =
+                  sentencePosTokenMap.get(matcher.start());
+          Integer tokenEndIndex =
+                  sentencePosTokenMap.get(matcher.end());
+
+          if (tokenStartIndex != null && tokenEndIndex != null) {
+            Span annotation = new Span(tokenStartIndex, tokenEndIndex, sType);
+            annotations.add(annotation);
+          }
+        }
+      }
+    }
+
+
+    return annotations.toArray(
+            new Span[annotations.size()]);
+  }
+
+  /**
+   * NEW. This method removes the need for tokenization, but returns the Span
+   * with character indices, rather than word.
+   *
+   * @param text
+   * @return
+   */
+  public Span[] find(String text) {
+    return getAnnotations(text);
+  }
+
+  private Span[] getAnnotations(String text) {
+    Collection<Span> annotations = new LinkedList<>();
+    if (mPatterns == null && regexMap != null) {
+      for (Map.Entry<String, Pattern[]> entry : regexMap.entrySet()) {
+        for (Pattern mPattern : entry.getValue()) {
+          Matcher matcher = mPattern.matcher(text);
+
+          while (matcher.find()) {
+            Integer tokenStartIndex = matcher.start();
+            Integer tokenEndIndex = matcher.end();
+            Span annotation = new Span(tokenStartIndex, tokenEndIndex, entry.getKey());
+            annotations.add(annotation);
+
+          }
+        }
+      }
+    } else {
+      for (Pattern mPattern : mPatterns) {
+        Matcher matcher = mPattern.matcher(text);
+
+        while (matcher.find()) {
+          Integer tokenStartIndex = matcher.start();
+          Integer tokenEndIndex = matcher.end();
+
-        new Span[annotations.size()]);
+            new Span[annotations.size()]);
-  
+
+  @Override
+
+  public Pattern[] getmPatterns() {
+    return mPatterns;
+  }
+
+  public void setmPatterns(Pattern[] mPatterns) {
+    this.mPatterns = mPatterns;
+  }
+
+  public String getsType() {
+    return sType;
+  }
+
+  public void setsType(String sType) {
+    this.sType = sType;
+  }

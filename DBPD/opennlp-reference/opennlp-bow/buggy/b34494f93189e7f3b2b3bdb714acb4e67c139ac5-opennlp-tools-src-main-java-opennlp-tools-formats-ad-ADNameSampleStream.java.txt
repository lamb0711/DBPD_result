OPENNLP-423: Improved AD NameSample formatter to work better with other corpus, like Amazonia and Selva.

git-svn-id: https://svn.apache.org/repos/asf/incubator/opennlp/trunk@1240436 13f79535-47bb-0310-9956-ffa450edef68

+  int textID = -1;
+  
+    // we should look for text here.
+      
+      int currentTextID = getTextID(paragraph);
+      boolean clearData = false;
+      if(currentTextID != textID) {
+        clearData = true;
+        textID = currentTextID;
+      }
+      
-          names.toArray(new Span[names.size()]), true);
+          names.toArray(new Span[names.size()]), clearData);
+    
+    boolean alreadyAdded = false;
-    if (leaf != null && leftContractionPart == null) {
+    if (leftContractionPart != null) {
+      // will handle the contraction
+      String tag = leaf.getSecondaryTag();
+      String right = leaf.getLexeme();
+      if (tag != null && tag.contains("<-sam>")) {
+        right = leaf.getLexeme();
+        String c = PortugueseContractionUtility.toContraction(leftContractionPart, right);
+
+        if (c != null) {
+          sentence.add(c);
+        } else {
+          System.err.println("missing " + leftContractionPart + " + " + right);
+          sentence.add(leftContractionPart);
+          sentence.add(right);
+        }
+
+      } else {
+        System.err.println("unmatch" + leftContractionPart + " + " + right);
+      }
+      leftContractionPart = null;
+      alreadyAdded = true;
+    }
-      String leafTag = leaf.getMorphologicalTag();
+      String leafTag = leaf.getSecondaryTag();
-        if (leafTag.contains("<sam->")) {
+        if (leafTag.contains("<sam->") && !alreadyAdded) {
-      sentence.addAll(Arrays.asList(leaf.getLexeme().split("_")));
-
+      if(!alreadyAdded) {
+        sentence.addAll(Arrays.asList(leaf.getLexeme().split("_")));
+      }
+      
-          // Maybe it is not the same NER, skip it.
-          // System.err.println("Missing NER start for sentence [" + sentence
-          // + "] node [" + leaf + "]");
+//           Maybe it is not the same NER, skip it.
+//           System.err.println("Missing NER start for sentence [" + sentence
+//           + "] node [" + leaf + "]");
-    } else {
-      // will handle the contraction
-      String tag = leaf.getMorphologicalTag();
-      String right = leaf.getLexeme();
-      if (tag != null && tag.contains("<-sam>")) {
-        right = leaf.getLexeme();
-        String c = PortugueseContractionUtility.toContraction(leftContractionPart, right);
-
-        if (c != null) {
-          sentence.add(c);
-        } else {
-          System.err.println("missing " + leftContractionPart + " + " + right);
-          sentence.add(leftContractionPart);
-          sentence.add(right);
-        }
-
-      } else {
-        System.err.println("unmatch" + leftContractionPart + " + " + right);
-      }
-      leftContractionPart = null;
-  }
+  
+    if(tags.contains("<NER2>")) {
+      return null;
+    }
+  
+  enum Type {
+    ama, cie, lit
+  }
+
+  private Type corpusType = null;
+
+  private Pattern metaPattern;
+  
+  // works for Amazonia
+//  private static final Pattern meta1 = Pattern
+//      .compile("^(?:[a-zA-Z\\-]*(\\d+)).*?p=(\\d+).*");
+//  
+//  // works for selva cie
+//  private static final Pattern meta2 = Pattern
+//    .compile("^(?:[a-zA-Z\\-]*(\\d+)).*?p=(\\d+).*");
+  
+  private int textIdMeta2 = -1;
+  private String textMeta2 = "";
+
+  private int getTextID(Sentence paragraph) {
+
+    String meta = paragraph.getMetadata();
+
+    if (corpusType == null) {
+      if (meta.startsWith("LIT")) {
+        corpusType = Type.lit;
+        metaPattern = Pattern.compile("^([a-zA-Z\\-]+)(\\d+).*?p=(\\d+).*");
+      } else if (meta.startsWith("CIE")) {
+        corpusType = Type.cie;
+        metaPattern = Pattern.compile("^.*?source=\"(.*?)\".*");
+      } else { // ama
+        corpusType = Type.ama;
+        metaPattern = Pattern.compile("^(?:[a-zA-Z\\-]*(\\d+)).*?p=(\\d+).*");
+      }
+    }
+
+    if (corpusType.equals(Type.lit)) {
+      Matcher m2 = metaPattern.matcher(meta);
+      if (m2.matches()) {
+        String textId = m2.group(1);
+        if (!textId.equals(textMeta2)) {
+          textIdMeta2++;
+          textMeta2 = textId;
+        }
+        return textIdMeta2;
+      } else {
+        throw new RuntimeException("Invalid metadata: " + meta);
+      }
+    } else if (corpusType.equals(Type.cie)) {
+      Matcher m2 = metaPattern.matcher(meta);
+      if (m2.matches()) {
+        String textId = m2.group(1);
+        if (!textId.equals(textMeta2)) {
+          textIdMeta2++;
+          textMeta2 = textId;
+        }
+        return textIdMeta2;
+      } else {
+        throw new RuntimeException("Invalid metadata: " + meta);
+      }
+    } else if (corpusType.equals(Type.ama)) {
+      Matcher m2 = metaPattern.matcher(meta);
+      if (m2.matches()) {
+        return Integer.parseInt(m2.group(1));
+        // currentPara = Integer.parseInt(m.group(2));
+      } else {
+        throw new RuntimeException("Invalid metadata: " + meta);
+      }
+    }
+
+    return 0;
+  }

OPENNLP-221 Refactored and extended the Argument Parser to also accept Charset types. And added the new Charset parameter to the BasicTrainingparameters interface. 

git-svn-id: https://svn.apache.org/repos/asf/incubator/opennlp/trunk@1145550 13f79535-47bb-0310-9956-ffa450edef68

+import java.nio.charset.Charset;
+import java.nio.charset.IllegalCharsetNameException;
+import java.util.Collections;
-import java.util.HashSet;
-public class ArgumentParser implements InvocationHandler {
+public class ArgumentParser {
+  private interface ArgumentFactory {
+    
+    static final String INVALID_ARG = "Invalid argument: %s %s \n";
+    
+    Object parseArgument(Method method, String argName, String argValue);
+  }
+ 
+  private static class IntegerArgumentFactory  implements ArgumentFactory {
+
+    public Object parseArgument(Method method, String argName, String argValue) {
+      
+      Object value = null;
+      
+      try {
+        value = Integer.parseInt(argValue);
+      }
+      catch (NumberFormatException e) {
+        throw new TerminateToolException(-1, String.format(INVALID_ARG, argName, argValue) +
+            "Value must be an integer!");
+      }
+      
+      return value;
+    }
+  }
+ 
+  private static class BooleanArgumentFactory implements ArgumentFactory {
+
+    public Object parseArgument(Method method, String argName, String argValue) {
+      return Boolean.parseBoolean(argValue);
+    }
+  } 
-  private final Map<String, Object> arguments;
+  private static class StringArgumentFactory implements ArgumentFactory {
+    
+    public Object parseArgument(Method method, String argName, String argValue) {
+      return argValue;
+    }
+  } 
-  private ArgumentParser(Map<String, Object> arguments) {
-    this.arguments = arguments;
+  private static class FileArgumentFactory implements ArgumentFactory {
+    
+    public Object parseArgument(Method method, String argName, String argValue) {
+      return new File(argValue);
+    }
+  } 
+  
+  private static class CharsetArgumentFactory implements ArgumentFactory {
+    
+    public Object parseArgument(Method method, String argName, String charsetName) {
+      
+      try {
+        if (Charset.isSupported(charsetName)) {
+          return Charset.forName(charsetName);
+        } else {
+          throw new TerminateToolException(-1,  String.format(INVALID_ARG, argName, charsetName) + 
+              "Encoding not supported on this platform.");
+        }
+      } catch (IllegalCharsetNameException e) {
+        throw new TerminateToolException(-1, String.format(INVALID_ARG, argName, charsetName) + 
+            "Illegal encoding name.");
+      }
+    }
+  } 
+  
+  private static class ArgumentProxy implements InvocationHandler {
+    
+    private final Map<String, Object> arguments;
+    
+    ArgumentProxy(Map<String, Object> arguments) {
+      this.arguments = arguments;
+    }
+    
+    public Object invoke(Object proxy, Method method, Object[] args)
+        throws Throwable {
+      
+      if (args != null)
+        throw new IllegalStateException();
+      
+      return arguments.get(method.getName());
+    }
-  public Object invoke(Object proxy, Method method, Object[] args)
-      throws Throwable {
+  private static final Map<Class<?>, ArgumentFactory> argumentFactories;
+  
+  static {
+    Map<Class<?>, ArgumentFactory> factories = new HashMap<Class<?>, ArgumentParser.ArgumentFactory>();
+    factories.put(Integer.class, new IntegerArgumentFactory());
+    factories.put(Boolean.class, new BooleanArgumentFactory());
+    factories.put(String.class, new StringArgumentFactory());
+    factories.put(File.class, new FileArgumentFactory());
+    factories.put(Charset.class, new CharsetArgumentFactory());
-    if (args != null)
-      throw new IllegalStateException();
-    
-    return arguments.get(method.getName());
+    argumentFactories = Collections.unmodifiableMap(factories);
+  }
+  
+  private ArgumentParser() {
-      Set<Class<?>> compatibleReturnTypes = new HashSet<Class<?>>();
-      compatibleReturnTypes.add(Integer.class);
-      compatibleReturnTypes.add(Boolean.class);
-      compatibleReturnTypes.add(String.class);
-      compatibleReturnTypes.add(File.class);
+      Set<Class<?>> compatibleReturnTypes = argumentFactories.keySet();
-  /**
-   * Converts the options to their method names and maps
-   * the method names to their return value.
-   * 
-   * @return the mapping or null if arguments are invalid
-   */
-  private static <T> Map<String, Object> createArgumentMap(String args[], Class<T> argProxyInterface) {
+  public static <T> boolean validateArguments(String args[], Class<T> argProxyInterface) {
-      return null;
+      return false;
-    // create argument map
-    Map<String, Object> arguments = new HashMap<String, Object>();
+    int argumentCount = 0;
-          return null;
+          return false;
+      }
+      else {
+        argumentCount++;
+      }
+    }
+    
+    if (args.length / 2 != argumentCount)
+      return false;
+    
+    return true;
+  }
+  
+  @SuppressWarnings("unchecked")
+  public static <T> T parse(String args[], Class<T> argProxyInterface) {
+    
+    checkProxyInterface(argProxyInterface);
+    
+    if (!validateArguments(args, argProxyInterface))
+      throw new IllegalArgumentException("Passed args must be valid!");
+    
+    Map<String, Object> arguments = new HashMap<String, Object>();
+    
+    for (Method method : argProxyInterface.getMethods()) {
+      
+      String parameterName = methodNameToParameter(method.getName());
+      String valueString = CmdLineUtil.getParameter(parameterName, args);
+      
+      if (valueString == null) {
+        OptionalParameter optionalParam = method.getAnnotation(OptionalParameter.class);
-        if (Integer.class.equals(returnType)) {
-          try {
-            value = Integer.parseInt(valueString);
-          }
-          catch (NumberFormatException e) {
-            // parameter is not a number
-            return null;
-          }
-        }
-        else if (Boolean.class.equals(returnType)) {
-          value = Boolean.parseBoolean(valueString);
-        }
-        else if (String.class.equals(returnType)) {
-          value = valueString;
-        }
-        else if (File.class.equals(returnType)) {
-          value = new File(valueString);
-        }
-        else {
+        ArgumentFactory factory = argumentFactories.get(returnType);
+        
+        if (factory == null)
-        }
+        
+        value = factory.parseArgument(method, parameterName, valueString);
-    return arguments;
-  }
-  
-  public static <T> boolean validateArguments(String args[], Class<T> argProxyInterface) {
-    return createArgumentMap(args, argProxyInterface) != null;
-  }
-  
-  @SuppressWarnings("unchecked")
-  public static <T> T parse(String args[], Class<T> argProxyInterface) {
-    
-    checkProxyInterface(argProxyInterface);
-    
-    Map<String, Object> argumentMap = createArgumentMap(args, argProxyInterface);
-    
-    if (argumentMap != null) {
-      return (T) java.lang.reflect.Proxy.newProxyInstance(
-          argProxyInterface.getClassLoader(),
-          new Class[]{argProxyInterface},
-          new ArgumentParser(argumentMap));
-    }
-    else {
-      return null;
-    }
+    return (T) java.lang.reflect.Proxy.newProxyInstance(
+        argProxyInterface.getClassLoader(),
+        new Class[]{argProxyInterface},
+        new ArgumentProxy(arguments));

MOV26 INS26 INS26 INS40 INS40 UPD40 INS55 INS55 INS55 INS55 INS55 INS55 INS55 INS23 INS28 INS31 INS31 INS83 INS42 INS23 INS31 INS83 INS83 INS42 INS43 INS31 INS83 INS83 INS42 INS43 INS31 INS83 INS83 INS42 INS43 INS31 INS83 INS83 INS42 INS43 INS31 INS83 INS83 INS42 INS43 INS31 INS83 INS83 INS42 MOV43 MOV23 MOV31 MOV31 INS83 INS83 INS83 UPD74 MOV74 INS59 INS83 INS8 INS83 INS42 INS8 INS83 INS83 MOV73 INS39 INS42 MOV44 MOV44 INS8 MOV79 UPD83 MOV43 INS42 INS83 INS83 MOV43 INS59 INS43 INS42 INS44 INS44 INS44 INS42 INS83 INS43 UPD42 MOV42 INS44 INS44 INS44 INS8 INS42 MOV83 INS43 INS42 INS44 INS44 INS44 INS8 UPD42 MOV42 INS83 INS43 UPD42 MOV42 INS44 MOV44 INS44 INS8 UPD42 MOV42 INS83 MOV43 INS42 INS44 INS44 INS44 MOV8 INS42 INS83 MOV43 INS42 INS44 INS44 INS44 INS8 UPD42 MOV43 INS43 INS42 INS60 MOV21 MOV21 MOV21 MOV21 INS21 INS21 MOV25 INS60 INS70 INS25 INS41 INS42 MOV21 INS25 INS42 INS45 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS60 INS54 INS41 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS41 INS42 INS43 INS42 UPD42 INS43 INS42 INS41 INS43 INS42 INS43 UPD42 MOV42 INS43 INS42 INS41 INS43 INS42 INS43 INS42 INS43 INS42 INS54 UPD42 MOV42 INS42 INS74 INS59 INS32 INS7 INS39 INS59 INS44 INS32 INS8 INS27 INS41 INS9 INS38 INS53 INS11 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS8 INS12 INS42 INS42 INS42 INS42 INS32 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 MOV14 UPD42 MOV42 MOV42 INS42 INS8 INS12 MOV43 INS74 INS43 INS42 INS14 UPD42 UPD42 INS14 UPD42 UPD42 INS14 UPD42 UPD42 INS14 UPD42 UPD42 INS14 INS42 INS42 INS57 INS14 INS42 INS32 INS9 INS42 INS34 INS43 INS42 INS42 INS42 MOV60 INS25 INS27 INS42 INS9 INS32 INS14 INS60 INS60 INS25 MOV43 INS32 INS42 INS42 INS33 INS21 MOV44 INS8 INS42 INS42 INS42 UPD42 INS25 INS44 INS8 INS43 INS76 INS42 INS74 INS43 INS43 INS43 INS43 INS43 UPD43 MOV43 INS42 INS42 INS42 INS42 INS27 INS8 INS8 INS40 INS34 INS42 INS42 INS42 INS43 INS45 MOV43 INS59 INS43 INS59 MOV27 INS8 MOV21 INS42 INS40 INS42 MOV32 MOV3 INS14 INS7 INS53 INS32 INS8 INS8 INS43 INS42 INS53 UPD42 MOV42 INS43 INS74 INS43 INS42 INS42 INS42 INS42 INS42 UPD42 INS32 INS42 INS33 INS60 MOV25 INS21 INS42 UPD42 MOV42 INS42 INS32 UPD42 MOV42 INS42 INS32 INS60 INS25 MOV21 INS43 INS42 INS42 INS32 INS14 INS42 INS42 INS42 INS41 INS53 INS42 INS14 INS42 INS43 INS76 INS40 INS42 INS42 INS43 INS59 INS37 UPD42 MOV42 INS32 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 INS43 INS59 INS27 MOV53 INS42 INS42 INS42 INS42 INS43 INS38 INS27 INS32 INS14 INS43 INS38 INS27 MOV42 INS42 INS42 INS32 INS9 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS42 INS33 INS32 INS42 INS42 INS34 MOV32 INS45 INS42 INS42 INS42 INS43 INS38 INS27 INS42 INS34 INS32 INS45 INS42 INS42 INS57 UPD42 MOV42 INS42 MOV42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 UPD42 UPD42 INS42 INS34 INS32 INS45 INS42 INS42 INS42 INS42 INS42 INS43 UPD42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 DEL85 DEL42 DEL7 DEL21 DEL83 DEL14 DEL33 DEL33 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL74 DEL42 DEL42 DEL43 DEL57 DEL42 DEL42 DEL32 DEL42 DEL32 DEL7 DEL21 DEL8 DEL33 DEL41 DEL8 DEL12 DEL54 DEL8 DEL43 DEL57 DEL42 DEL42 DEL32 DEL42 DEL32 DEL7 DEL21 DEL8 DEL43 DEL57 DEL32 DEL8 DEL42 DEL43 DEL57 DEL42 DEL42 DEL32 DEL8 DEL25 DEL25 DEL25 DEL25 DEL8 DEL25 DEL42 DEL83 DEL83 DEL39 DEL33 DEL27 DEL41 DEL8 DEL31 DEL83 DEL42 DEL73 DEL43 DEL43 DEL74 DEL44 DEL74 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL40 DEL42 DEL42 DEL14 DEL32 DEL11 DEL41 DEL8 DEL33 DEL41 DEL8 DEL25 DEL8 DEL31
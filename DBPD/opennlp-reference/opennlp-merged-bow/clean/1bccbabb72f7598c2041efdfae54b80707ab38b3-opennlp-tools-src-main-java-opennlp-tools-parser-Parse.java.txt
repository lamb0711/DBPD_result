Correct indentation and white spaces

This closes #30

See issue OPENNLP-914

-      Parse lc = c.parts.get(parts.size()-1);
-      c.parts.set(parts.size()-1,lc.clone(node));
+      Parse lc = c.parts.get(parts.size() - 1);
+      c.parts.set(parts.size() - 1,lc.clone(node));
+
-      int pi=0;
+      int pi = 0;
-    StringBuffer sb = new StringBuffer(text.length()*4);
+    StringBuffer sb = new StringBuffer(text.length() * 4);
-    this.prob+=logProb;
+    this.prob += logProb;
-    if(! parts.isEmpty()) {
-        if (index == 0 || index == parts.size()) { //size is orig last element
-            span = new Span((parts.get(0)).span.getStart(),(parts.get(parts.size()-1)).span.getEnd());
-          }
+    if (! parts.isEmpty()) {
+      if (index == 0 || index == parts.size()) { //size is orig last element
+        span = new Span((parts.get(0)).span.getStart(),(parts.get(parts.size() - 1)).span.getEnd());
+      }
-    Parse lastChild = parts.get(parts.size()-1);
+    Parse lastChild = parts.get(parts.size() - 1);
-    parts.set(parts.size()-1,adjNode);
+    parts.set(parts.size() - 1, adjNode);
-    for (int pi=0,ai=0;pi<parts.size();pi++,ai++) {
+    for (int pi = 0, ai = 0; pi < parts.size(); pi++,ai++) {
-            type = type+"-"+ftag;
+            type = type + "-" + ftag;
-   * null if the portion of the parse string does not represent a token.
+   *     null if the portion of the parse string does not represent a token.
-      for (int pi=0,pn=parts.size();pi<pn;pi++) {
+      for (int pi = 0, pn = parts.size(); pi < pn; pi++) {
-    span = new Span((parts.get(0)).span.getStart(),(parts.get(parts.size()-1)).span.getEnd());
+    span = new Span((parts.get(0)).span.getStart(),(parts.get(parts.size() - 1)).span.getEnd());
-    while(nodes.size() != 0) {
+    while (nodes.size() != 0) {
-    for (int ti=0;ti<tags.length;ti++) {
+    for (int ti = 0; ti < tags.length; ti++) {
-        if (ti+1 < tags.length && tags[ti+1].getParent() == tags[ti].getParent().getParent()) {
-          int start = tags[ti+1].getSpan().getStart();
-          int end = tags[ti+1].getSpan().getEnd();
-          for (int npi=ti+2;npi<tags.length;npi++) {
-            if (tags[npi].getParent() == tags[npi-1].getParent()) {
+        if (ti + 1 < tags.length && tags[ti + 1].getParent() == tags[ti].getParent().getParent()) {
+          int start = tags[ti + 1].getSpan().getStart();
+          int end = tags[ti + 1].getSpan().getEnd();
+          for (int npi = ti + 2; npi < tags.length; npi++) {
+            if (tags[npi].getParent() == tags[npi - 1].getParent()) {
-          Parse npPos = new Parse(parse.getText(),new Span(start,end),"NP",1,tags[ti+1]);
+          Parse npPos = new Parse(parse.getText(), new Span(start,end), "NP", 1 , tags[ti + 1]);
-          cons.add(new Constituent(con.getLabel(), new Span(start, offset-1)));
+          cons.add(new Constituent(con.getLabel(), new Span(start, offset - 1)));
-    for (int ci=0;ci < cons.size();ci++) {
+    for (int ci = 0; ci < cons.size(); ci++) {
-    for (int ci=0;ci<parts.size();ci++) {
+    for (int ci = 0; ci < parts.size(); ci++) {
-    while(nodes.size() != 0) {
+    while (nodes.size() != 0) {
-    while(cparent != null) {
+    while (cparent != null) {
-      if (this.parts.size() != p.parts.size()){
-      	return false;
+      if (this.parts.size() != p.parts.size()) {
+        return false;
-      for (int ci=0;ci<parts.size();ci++) {
+      for (int ci = 0; ci < parts.size(); ci++) {
-    result = 37*result + span.hashCode();
+    result = 37 * result + span.hashCode();
-//    result = 37*result + label.hashCode();
-    result = 37*result + text.hashCode();
+    // result = 37*result + label.hashCode();
+    result = 37 * result + text.hashCode();
-   * @return the derivation string for this parse or null if no derivation
-   * string has been created.
+   * @return the derivation string for this parse or null if no derivation string has been created.
-    int[] nlevels = new int[levels.length+1];
-    for (int li=0;li<levels.length;li++) {
+    int[] nlevels = new int[levels.length + 1];
+    for (int li = 0; li < levels.length; li++) {
-    for (int ki=0;ki<kids.length;ki++) {
+    for (int ki = 0; ki < kids.length; ki++) {
-      System.out.println(levelsBuff.toString() + ki + "] "+ kids[ki].getType() +
+      System.out.println(levelsBuff.toString() + ki + "] " + kids[ki].getType() +
-    for (int ni=0,nn=names.length;ni<nn;ni++) {
+    for (int ni = 0, nn = names.length; ni < nn; ni++) {
-          for (int ki=0,kn=kids.length;ki<kn;ki++) {
-            if (nameSpan.crosses(kids[ki].getSpan())){
+          for (int ki = 0, kn = kids.length; ki < kn; ki++) {
+            if (nameSpan.crosses(kids[ki].getSpan())) {
-              if (grandKids.length > 1 && nameSpan.contains(grandKids[grandKids.length-1].getSpan())) {
-                commonParent.insert(new Parse(commonParent.getText(),commonParent.getSpan(),tag,1.0,commonParent.getHeadIndex()));
+              if (grandKids.length > 1 && nameSpan.contains(grandKids[grandKids.length - 1].getSpan())) {
+                commonParent.insert(new Parse(commonParent.getText(), commonParent.getSpan(), tag,1.0, commonParent.getHeadIndex()));
-    int ai=0;
+    int ai = 0;
-    while(args[ai].startsWith("-") && ai < args.length) {
+    while (args[ai].startsWith("-") && ai < args.length) {

UPD66 DEL66
OPENNLP-85 Created a static method to create spans of phrase chunks and added javadoc

git-svn-id: https://svn.apache.org/repos/asf/incubator/opennlp/trunk@1063351 13f79535-47bb-0310-9956-ffa450edef68

+/**
+ * Class for holding chunks for a single unit of text.
+ */
+	
-
-  
-  
+
+  /**
+   * Initializes the current instance.
+   * 
+   * @param sentence
+   *          training sentence
+   * @param tags
+   *          POS Tags for the sentence
+   * @param preds
+   *          Chunk tags in B-* I-* notation
+   */
+  /**
+   * Initializes the current instance.
+   * 
+   * @param sentence
+   *          training sentence
+   * @param tags
+   *          POS Tags for the sentence
+   * @param preds
+   *          Chunk tags in B-* I-* notation
+   */
-    // TODO: Add validation of params ...
+  	if (sentence.size() != tags.size()  || tags.size()  != preds.size() )
+      throw new IllegalArgumentException("All arrays must have the same length!");
+  	
-  
+ 
+  /** Gets the training sentence */
-  
+
+  /** Gets the POS Tags for the sentence */
+  /** Gets the Chunk tags in B-* I-* notation */
+  /** Gets the phrases as an array of spans */
-	  List<Span> phrases =  new ArrayList<Span>();
-	  String startTag = "";
-	  int startIndex = 0;
-	  boolean foundPhrase = false;
-	    
-	    for (int ci=0, cn = preds.size(); ci < cn; ci++) {
-	    	String pred = preds.get(ci);
-	    	if( pred.startsWith("B-") || ( !pred.equals("I-" + startTag) && !pred.equals("O") )) { // start
-	    		if(foundPhrase) { // handle the last
-	    			phrases.add(new Span(startIndex, ci, startTag));
-	    		}
-	    		startIndex = ci;
-	    		startTag = pred.substring(2);
-	    		foundPhrase = true;
-	    	} else if(pred.equals("I-" + startTag)) { // middle 
-	    		// do nothing
-	    	} else if(foundPhrase) {// end
-	    		phrases.add(new Span(startIndex, ci, startTag));
-	    		foundPhrase = false;
-	    		startTag = "";
-	    	}
-	    }
-	    if(foundPhrase) { // leftover
-	    	phrases.add(new Span(startIndex, preds.size(), startTag));
-	    }
-	    
-	    return phrases.toArray(new Span[phrases.size()]);
+    return phrasesAsSpanList(getSentence(), getTags(), getPreds());
+  /**
+   * Static method to create arrays of spans of phrases
+   * 
+   * @param aSentence
+   *          training sentence
+   * @param aTags
+   *          POS Tags for the sentence
+   * @param aPreds
+   *          Chunk tags in B-* I-* notation
+   * 
+   * @return the phrases as an array of spans
+   */
+  public static Span[] phrasesAsSpanList(String[] aSentence, String[] aTags,
+      String[] aPreds) {
+
+    if (aSentence.length != aTags.length || aTags.length != aPreds.length)
+      throw new IllegalArgumentException(
+          "All arrays must have the same length!");
+
+    List<Span> phrases = new ArrayList<Span>();
+    String startTag = "";
+    int startIndex = 0;
+    boolean foundPhrase = false;
+
+    for (int ci = 0, cn = aPreds.length; ci < cn; ci++) {
+      String pred = aPreds[ci];
+      if (pred.startsWith("B-")
+          || (!pred.equals("I-" + startTag) && !pred.equals("O"))) { // start
+        if (foundPhrase) { // handle the last
+          phrases.add(new Span(startIndex, ci, startTag));
+        }
+        startIndex = ci;
+        startTag = pred.substring(2);
+        foundPhrase = true;
+      } else if (pred.equals("I-" + startTag)) { // middle
+        // do nothing
+      } else if (foundPhrase) {// end
+        phrases.add(new Span(startIndex, ci, startTag));
+        foundPhrase = false;
+        startTag = "";
+      }
+    }
+    if (foundPhrase) { // leftover
+      phrases.add(new Span(startIndex, aPreds.length, startTag));
+    }
+
+    return phrases.toArray(new Span[phrases.size()]);
+  }
+  /**
+   * Creates a nice to read string for the phrases formatted as following: <br>
+   * <code>
+   * [NP Rockwell_NNP ] [VP said_VBD ] [NP the_DT agreement_NN ] [VP calls_VBZ ] [SBAR for_IN ] [NP it_PRP ] [VP to_TO supply_VB ] [NP 200_CD additional_JJ so-called_JJ shipsets_NNS ] [PP for_IN ] [NP the_DT planes_NNS ] ._.
+   * </code>
+   * 
+   * @return a nice to read string representation of the chunk phases
+   */

INS29 INS31 INS65 INS29 INS29 INS29 INS29 INS29 INS29 INS83 INS5 INS42 INS8 INS29 INS83 UPD42 INS44 INS44 INS44 INS29 INS66 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS25 INS65 INS65 INS65 INS65 INS43 INS85 INS41 INS65 INS65 INS65 INS65 INS65 INS5 INS42 INS5 INS42 INS5 INS42 INS25 INS65 INS65 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS27 INS53 INS66 INS66 INS66 INS66 INS42 INS32 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS43 INS85 INS43 INS85 INS43 INS85 INS27 INS53 INS66 INS66 INS66 INS66 INS66 INS27 INS27 INS14 INS42 INS32 INS32 INS32 INS42 INS42 INS42 INS27 INS27 INS14 INS32 INS32 INS32 MOV32 INS43 INS45 INS42 INS42 INS42 INS40 INS40 INS40 INS40 INS43 INS45 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS2 INS42 INS42 INS40 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32
OPENNLP-429: Reseting the input stream could fail depending on how it was created. For now will store the artifact bytes to process it latter.

git-svn-id: https://svn.apache.org/repos/asf/incubator/opennlp/trunk@1243675 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
-import java.util.HashSet;
-  private HashSet<String> unloadedExtensions;
+  private Map<String, byte[]> leftoverArtifacts;
-    unloadedExtensions = new HashSet<String>();
+    leftoverArtifacts = new HashMap<String, byte[]>();
-        unloadedExtensions.add(extension);
+        /* TODO: find a better solution, that would consume less memory */
+        byte[] bytes = toByteArray(zip);
+        leftoverArtifacts.put(entry.getName(), bytes);
-    if (unloadedExtensions == null || unloadedExtensions.size() == 0) {
+    if (leftoverArtifacts == null || leftoverArtifacts.size() == 0) {
-    in.reset();
-    final ZipInputStream zip = new ZipInputStream(in);
-    Map<String, Object> artifactMap = new HashMap<String, Object>(
-        this.artifactMap);
-    ZipEntry entry;
-    while ((entry = zip.getNextEntry()) != null) {
-      String extension = getEntryExtension(entry.getName());
+    Map<String, Object> artifactMap = new HashMap<String, Object>();
+    
+    for (String entryName : leftoverArtifacts.keySet()) {
+      
+      String extension = getEntryExtension(entryName);
-      if (unloadedExtensions.contains(extension)) {
+      if (leftoverArtifacts.containsKey(entryName)) {
-          artifactMap.put(entry.getName(), factory.create(zip));
+          artifactMap.put(entryName, factory.create(new ByteArrayInputStream(leftoverArtifacts.get(entryName))));
-
-      zip.closeEntry();
-    this.unloadedExtensions = null;
+    this.leftoverArtifacts = null;
+  
+  private static byte[] toByteArray(InputStream input) throws IOException {
+    ByteArrayOutputStream output = new ByteArrayOutputStream();
+    byte[] buffer = new byte[1024 * 4];
+    int count = 0;
+    int n = 0;
+    while (-1 != (n = input.read(buffer))) {
+      output.write(buffer, 0, n);
+      count += n;
+    }
+    return output.toByteArray();
+  }

MOV26 INS26 UPD40 INS40 INS31 UPD74 INS83 INS83 INS5 INS42 INS44 INS43 INS8 UPD43 INS5 UPD42 INS70 INS39 INS85 INS43 INS42 INS42 INS60 INS60 INS60 INS60 INS61 INS41 UPD42 INS39 INS85 INS44 INS32 MOV8 INS42 INS43 INS59 INS5 INS59 INS39 INS59 INS39 INS59 INS27 INS8 INS32 UPD42 INS43 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS14 INS39 INS85 INS42 INS3 INS42 INS34 INS42 INS34 INS38 INS36 INS21 INS21 INS42 INS42 UPD74 UPD42 UPD42 MOV42 UPD42 INS43 INS5 INS27 INS34 INS7 INS32 INS7 UPD43 INS5 INS60 UPD42 UPD42 UPD42 UPD42 INS42 INS39 INS85 INS34 INS34 INS42 INS32 INS42 INS42 INS42 INS34 INS42 INS42 INS42 UPD42 INS39 INS85 INS5 INS59 UPD42 MOV42 INS42 INS42 INS42 INS39 INS85 INS42 INS32 UPD42 UPD42 INS32 INS42 INS42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS14 INS43 INS32 INS42 INS42 INS42 INS42 DEL42 DEL42 DEL32 DEL21 DEL83 DEL43 DEL42 DEL42 DEL43 DEL42 DEL14 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL32 DEL7 DEL36 DEL33 DEL27 DEL61
OPENNLP-581 the model now first reads the manifest.properties file and then proceeds with all the other artifacts

git-svn-id: https://svn.apache.org/repos/asf/opennlp/trunk@1554661 13f79535-47bb-0310-9956-ffa450edef68

+  private static int MODEL_BUFFER_SIZE_LIMIT = Integer.MAX_VALUE;
+  
-  private Map<String, byte[]> leftoverArtifacts;
-
-    if (in == null)
-        throw new IllegalArgumentException("in must not be null!");
-
-    InputStream in = modelURL.openStream();
+    InputStream in = new BufferedInputStream(modelURL.openStream());
+    
+    if (in == null) {
+      throw new IllegalArgumentException("in must not be null!");
+    }
+    
+    if (!in.markSupported()) {
+      in = new BufferedInputStream(in);
+    }
+    
+    // TODO: Discuss this solution, the buffering should 
+    in.mark(MODEL_BUFFER_SIZE_LIMIT);
+    
-    // will read it in two steps, first using the known factories, latter the
-    // unknown.
-    leftoverArtifacts = new HashMap<String, byte[]>();
-
+    // The model package can contain artifacts which are serialized with 3rd party
+    // serializers which are configured in the manifest file. To be able to load
+    // the model the manifest must be read first, and afterwards all the artifacts 
+    // can be de-serialized.
+    
+    // The ordering of artifacts in a zip package is not guaranteed. The stream is first
+    // read until the manifest appears, reseted, and read again to load all artifacts.
+    
+    boolean isSearchingForManifest = true;
+    
-    while((entry = zip.getNextEntry()) != null ) {
+    while((entry = zip.getNextEntry()) != null && isSearchingForManifest) {
-      String extension = getEntryExtension(entry.getName());
-
-      ArtifactSerializer factory = artifactSerializers.get(extension);
-
-      if (factory == null) {
-        /* TODO: find a better solution, that would consume less memory */
-        byte[] bytes = toByteArray(zip);
-        leftoverArtifacts.put(entry.getName(), bytes);
-      } else {
+      if ("manifest.properties".equals(entry.getName())) {
+        // TODO: Probably better to use the serializer here directly!
+        ArtifactSerializer factory = artifactSerializers.get("properties");
+        isSearchingForManifest = false;
-      
+
-
+    
-    finishLoadingArtifacts();
+
+    // The Input Stream should always be reset-able because if markSupport returns
+    // false it is wrapped before hand into an Buffered InputStream
+    in.reset();
+    
+    finishLoadingArtifacts(in);
+    
-  private void finishLoadingArtifacts()
+  private void finishLoadingArtifacts(InputStream in)
-    finishedLoadingArtifacts = true;
-    if (leftoverArtifacts == null || leftoverArtifacts.size() == 0) {
-      return;
-    }
-
+    
+    final ZipInputStream zip = new ZipInputStream(in);
+    
-    for (String entryName : leftoverArtifacts.keySet()) {
+    ZipEntry entry;
+    while((entry = zip.getNextEntry()) != null ) {
+      // Note: The manifest.properties file will be read here again,
+      // there should be no need to prevent that.
+      
+      String entryName = entry.getName();
-      if (leftoverArtifacts.containsKey(entryName)) {
-        ArtifactSerializer factory = artifactSerializers.get(extension);
+      ArtifactSerializer factory = artifactSerializers.get(extension);
-        if (factory == null) {
-          String artifactSerializerClazzName = 
-              getManifestProperty(SERIALIZER_CLASS_NAME_PREFIX + entryName);
+      String artifactSerializerClazzName = 
+          getManifestProperty(SERIALIZER_CLASS_NAME_PREFIX + entryName);
-          if (artifactSerializerClazzName != null) {
-            factory = ExtensionLoader.instantiateExtension(ArtifactSerializer.class, artifactSerializerClazzName);
-          }
-        }
-        
-        if (factory == null) {
-          throw new InvalidFormatException("Unknown artifact format: "
-              + extension);
-        } else {
-          artifactMap.put(entryName, factory.create(new ByteArrayInputStream(leftoverArtifacts.get(entryName))));
+      if (artifactSerializerClazzName != null) {
+        if (artifactSerializerClazzName != null) {
+          factory = ExtensionLoader.instantiateExtension(ArtifactSerializer.class, artifactSerializerClazzName);
+      
+      if (factory != null) {
+        artifactMap.put(entryName, factory.create(zip));
+      } else {
+        throw new InvalidFormatException("Unknown artifact format: " + extension);
+      }
+      
+      zip.closeEntry();
-    this.leftoverArtifacts = null;
+
+    
+    finishedLoadingArtifacts = true;
-      if (serializer == null && artifact instanceof SerializableArtifact) {
+      // If model is serialize-able always use the provided serializer
+      if (artifact instanceof SerializableArtifact) {
+  
+  public static void main(String[] args) throws Exception {
+    
+    // create a stream which can be reset, enclose it in a buffered stream which supports reseting 
+    InputStream in = new FileInputStream("annotation.conf");
+    
+    System.out.println("Is mark supported: " + in.markSupported());
+    
+    in = new BufferedInputStream(in);
+    
+    System.out.println("Is mark supported: " + in.markSupported());
+    
+    // 2 GB limit 
+    in.mark(4096);
+    
+    in.read();
+    
+    in.reset();
+    
+    // the mark support can be used to test if reseting is supported, we shoudl use this test anyway
+    // to fail gracefully in the cross validators ...
+    
+  }

INS23 INS31 MOV83 INS83 INS39 INS59 INS44 MOV8 INS83 INS83 INS39 INS42 INS44 INS43 INS8 INS42 INS40 MOV25 INS25 INS21 INS60 INS21 UPD43 MOV43 UPD42 MOV42 INS60 MOV60 INS60 INS61 MOV21 MOV21 INS5 INS42 INS42 INS60 INS21 INS21 INS21 INS21 INS21 INS21 INS8 INS38 INS8 INS32 INS39 INS59 INS27 INS32 UPD42 INS83 INS43 INS59 INS43 INS59 INS27 MOV8 MOV43 MOV85 INS43 INS59 INS32 INS7 INS32 INS32 INS32 INS32 INS14 MOV53 INS32 MOV21 INS42 INS42 INS42 INS42 INS9 MOV27 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS36 INS33 MOV60 MOV60 MOV60 MOV8 INS21 INS42 UPD42 MOV42 INS14 INS40 INS42 INS27 INS42 INS14 INS40 INS42 INS27 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS43 MOV32 INS42 INS42 MOV32 MOV32 INS43 INS42 INS7 INS43 UPD27 UPD27 INS32 MOV62 INS43 INS45 INS45 INS32 INS43 INS42 INS45 INS32 INS42 UPD42 INS45 UPD42 INS60 INS21 INS42 INS42 INS32 INS42 INS42 MOV32 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS43 INS59 INS7 INS42 INS42 UPD42 MOV42 INS42 INS42 INS32 INS42 INS9 INS42 INS42 INS45 INS42 DEL42 DEL43 DEL42 DEL43 DEL39 DEL5 DEL74 DEL59 DEL23 DEL43 DEL42 DEL43 DEL39 DEL85 DEL5 DEL74 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL33 DEL27 DEL39 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL21 DEL8 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL14 DEL42 DEL32 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL34 DEL27 DEL27 DEL41 DEL8 DEL25 DEL44 DEL42 DEL42 DEL32 DEL70 DEL52 DEL42 DEL22 DEL33 DEL7 DEL21 DEL8 DEL42 DEL33 DEL27 DEL27
OPENNLP-703 Improved NegLogLikelihood so that it runs faster and uses less memory

git-svn-id: https://svn.apache.org/repos/asf/opennlp/trunk@1612182 13f79535-47bb-0310-9956-ffa450edef68

-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package opennlp.tools.ml.maxent.quasinewton;
-
-import java.util.Arrays;
-
-import opennlp.tools.ml.model.DataIndexer;
-import opennlp.tools.ml.model.OnePassRealValueDataIndexer;
-
-/**
- * Evaluate negative log-likelihood and its gradient from DataIndexer.
- */
-public class NegLogLikelihood implements Function {
-  
-  private int dimension;
-  private double[] empiricalCount;
-  private int numOutcomes;
-  private int numFeatures;
-  private int numContexts;
-
-  // Information from data index
-  private final float[][] values;
-  private final int[][] contexts;
-  private final int[] outcomeList;
-  private final int[] numTimesEventsSeen;
-
-  // For computing negative log-likelihood
-  private double[][] voteSum;
-  private double[] logSumExp;
-  
-  // For gradient computation
-  private double[] gradient;
-  private double[] expectedCount;
-  
-  public NegLogLikelihood(DataIndexer indexer) {
-    
-    // Get data from indexer.
-    if (indexer instanceof OnePassRealValueDataIndexer) {
-      this.values = indexer.getValues();
-    } else {
-      this.values = null;
-    }
-
-    this.contexts    = indexer.getContexts();
-    this.outcomeList = indexer.getOutcomeList();
-    this.numTimesEventsSeen = indexer.getNumTimesEventsSeen();
-
-    this.numOutcomes    = indexer.getOutcomeLabels().length;
-    this.numFeatures    = indexer.getPredLabels().length;
-    this.numContexts    = this.contexts.length;
-    this.dimension      = numOutcomes * numFeatures;
-    this.empiricalCount = new double[dimension];
-
-    this.voteSum   = new double[numContexts][numOutcomes];
-    this.logSumExp = new double[numContexts];
-    
-    this.gradient      = new double[dimension];
-    this.expectedCount = new double[dimension];
-    
-    computeEmpCount();
-  }
-
-  public int getDimension() {
-    return this.dimension;
-  }
-
-  public double[] getInitialPoint() {
-    return new double[dimension];
-  }
-  
-  /**
-   * Negative log-likelihood
-   */
-  public double valueAt(double[] x) {
-    
-    if (x.length != this.dimension)
-      throw new IllegalArgumentException(
-          "x is invalid, its dimension is not equal to domain dimension.");
-
-    computeSums(x); // Compute voteSum and logSumExp
-    
-    double negLogLikelihood = 0.;
-    for (int ci = 0; ci < numContexts; ci++) {
-      int outcome = this.outcomeList[ci];
-      negLogLikelihood += (voteSum[ci][outcome] - logSumExp[ci]) * numTimesEventsSeen[ci];
-    }
-    negLogLikelihood = -negLogLikelihood;
-    
-    return negLogLikelihood;
-  }  
-
-  /**
-   * Compute gradient
-   */
-  public double[] gradientAt(double[] x) {
-    
-    if (x.length != this.dimension)
-      throw new IllegalArgumentException(
-          "x is invalid, its dimension is not equal to the function.");
-    
-    computeSums(x); // Compute voteSum and logSumExp
-    
-    // Reset
-    Arrays.fill(expectedCount, 0);
-    for (int ci = 0; ci < numContexts; ci++) {
-      for (int oi = 0; oi < numOutcomes; oi++) {
-        for (int af = 0; af < contexts[ci].length; af++) {
-          int vectorIndex = indexOf(oi, this.contexts[ci][af]);
-          double predValue = 1.;
-          if (values != null) predValue = this.values[ci][af];
-          if (predValue == 0.) continue;
-
-          expectedCount[vectorIndex] += 
-              predValue * Math.exp(voteSum[ci][oi] - logSumExp[ci]) * this.numTimesEventsSeen[ci];
-        }
-      }
-    }
-
-    for (int i = 0; i < dimension; i++) { 
-      gradient[i] = expectedCount[i] - this.empiricalCount[i];
-    }
-    
-    return gradient;
-  }
-
-  private int indexOf(int outcomeId, int featureId) {
-    return outcomeId * numFeatures + featureId;
-  }
-
-  /**
-   * Compute temporary values
-   */
-  private void computeSums(double[] x) {
-    for (int ci = 0; ci < numContexts; ci++) {
-      for (int oi = 0; oi < numOutcomes; oi++) {
-        double vecProduct = 0.;
-        for (int af = 0; af < this.contexts[ci].length; af++) {
-          int vectorIndex = indexOf(oi, contexts[ci][af]);
-          double predValue = 1.;
-          if (values != null) predValue = this.values[ci][af];
-          if (predValue == 0.) continue;
-          vecProduct += predValue * x[vectorIndex];
-        }
-        voteSum[ci][oi] = vecProduct;
-      }
-
-      // \log(\sum_{c'=1}^{C} e^{w_c'^T x_i})
-      logSumExp[ci] = ArrayMath.logSumOfExps(voteSum[ci]);
-    }
-  }
-  
-  /**
-   * Compute empirical count
-   */
-  private void computeEmpCount() {
-    for (int ci = 0; ci < numContexts; ci++) {
-      for (int af = 0; af < this.contexts[ci].length; af++) {
-        int vectorIndex = indexOf(this.outcomeList[ci], contexts[ci][af]);
-        if (values != null) {
-          empiricalCount[vectorIndex] += this.values[ci][af] * numTimesEventsSeen[ci];
-        } else {
-          empiricalCount[vectorIndex] += 1. * numTimesEventsSeen[ci];
-        }
-      }
-    }
-  }
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package opennlp.tools.ml.maxent.quasinewton;
+
+import java.util.Arrays;
+
+import opennlp.tools.ml.model.DataIndexer;
+import opennlp.tools.ml.model.OnePassRealValueDataIndexer;
+
+/**
+ * Evaluate negative log-likelihood and its gradient from DataIndexer.
+ */
+public class NegLogLikelihood implements Function {
+  
+  protected int dimension;
+  protected int numOutcomes;
+  protected int numFeatures;
+  protected int numContexts;
+
+  // Information from data index
+  protected final float[][] values;
+  protected final int[][] contexts;
+  protected final int[] outcomeList;
+  protected final int[] numTimesEventsSeen;
+
+  // For calculating negLogLikelihood and gradient 
+  protected double[] tempSums;
+  protected double[] expectation;
+  
+  protected double[] gradient;
+  
+  public NegLogLikelihood(DataIndexer indexer) {
+    
+    // Get data from indexer.
+    if (indexer instanceof OnePassRealValueDataIndexer) {
+      this.values = indexer.getValues();
+    } else {
+      this.values = null;
+    }
+
+    this.contexts    = indexer.getContexts();
+    this.outcomeList = indexer.getOutcomeList();
+    this.numTimesEventsSeen = indexer.getNumTimesEventsSeen();
+
+    this.numOutcomes = indexer.getOutcomeLabels().length;
+    this.numFeatures = indexer.getPredLabels().length;
+    this.numContexts = this.contexts.length;
+    this.dimension   = numOutcomes * numFeatures;
+    
+    this.expectation = new double[numOutcomes];
+    this.tempSums    = new double[numOutcomes];
+    this.gradient    = new double[dimension];
+  }
+
+  public int getDimension() {
+    return this.dimension;
+  }
+
+  public double[] getInitialPoint() {
+    return new double[dimension];
+  }
+
+  /**
+   * Negative log-likelihood
+   */
+  public double valueAt(double[] x) {
+    
+    if (x.length != dimension)
+      throw new IllegalArgumentException(
+          "x is invalid, its dimension is not equal to domain dimension.");
+
+    int ci, oi, ai, vectorIndex, outcome;
+    double predValue, logSumOfExps;
+    double negLogLikelihood = 0;
+    
+    for (ci = 0; ci < numContexts; ci++) {
+      for (oi = 0; oi < numOutcomes; oi++) {
+        tempSums[oi] = 0;
+        for (ai = 0; ai < contexts[ci].length; ai++) {
+          vectorIndex = indexOf(oi, contexts[ci][ai]);
+          predValue = values != null? values[ci][ai] : 1.0;
+          tempSums[oi] += predValue * x[vectorIndex];
+        }
+      }
+      
+      logSumOfExps = ArrayMath.logSumOfExps(tempSums);
+      
+      outcome = outcomeList[ci];
+      negLogLikelihood -= (tempSums[outcome] - logSumOfExps) * numTimesEventsSeen[ci];
+    }
+    
+    return negLogLikelihood;
+  }  
+  
+  /**
+   * Compute gradient
+   */
+  public double[] gradientAt(double[] x) {
+    
+    if (x.length != dimension)
+      throw new IllegalArgumentException(
+          "x is invalid, its dimension is not equal to the function.");
+    
+    int ci, oi, ai, vectorIndex;
+    double predValue, logSumOfExps;
+    int empirical;
+    
+    // Reset gradient
+    Arrays.fill(gradient, 0);
+    
+    for (ci = 0; ci < numContexts; ci++) {
+      for (oi = 0; oi < numOutcomes; oi++) {
+        expectation[oi] = 0;
+        for (ai = 0; ai < contexts[ci].length; ai++) {
+          vectorIndex = indexOf(oi, contexts[ci][ai]);
+          predValue = values != null? values[ci][ai] : 1.0;
+          expectation[oi] += predValue * x[vectorIndex];
+        }
+      }
+      
+      logSumOfExps = ArrayMath.logSumOfExps(expectation);
+      
+      for (oi = 0; oi < numOutcomes; oi++) {
+        expectation[oi] = Math.exp(expectation[oi] - logSumOfExps);
+      }
+      
+      for (oi = 0; oi < numOutcomes; oi++) {
+        empirical = outcomeList[ci] == oi? 1 : 0;
+        for (ai = 0; ai < contexts[ci].length; ai++) {
+          vectorIndex = indexOf(oi, contexts[ci][ai]);
+          predValue = values != null? values[ci][ai] : 1.0;
+          gradient[vectorIndex] += 
+              predValue * (expectation[oi] - empirical) * numTimesEventsSeen[ci];
+        }
+      }
+    }
+    
+    return gradient;
+  }
+  
+  protected int indexOf(int outcomeId, int featureId) {
+    return outcomeId * numFeatures + featureId;
+  }

MOV23 INS31 INS31 UPD83 UPD83 UPD83 UPD83 UPD83 UPD83 UPD83 UPD83 UPD83 UPD83 UPD83 MOV21 MOV29 INS83 INS39 INS42 MOV44 INS8 MOV29 UPD83 MOV83 MOV5 UPD42 MOV42 MOV44 INS8 UPD83 UPD42 UPD42 MOV25 INS60 MOV60 INS60 INS24 MOV41 MOV25 INS60 MOV60 INS60 INS21 INS24 MOV41 INS39 INS59 INS59 INS59 INS59 INS59 INS59 INS39 INS59 INS7 MOV27 MOV37 INS8 INS39 INS59 INS59 INS59 INS59 INS59 INS39 INS59 INS32 INS7 MOV27 MOV37 INS8 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 UPD42 INS42 UPD42 MOV42 MOV34 INS42 INS34 INS24 INS21 INS21 MOV21 INS42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS34 INS42 INS34 INS24 MOV21 INS24 MOV24 UPD42 UPD42 UPD42 UPD42 INS7 INS27 INS37 INS8 INS7 INS7 UPD7 INS7 MOV27 MOV37 INS8 INS7 INS27 INS37 INS8 INS7 MOV27 MOV37 INS8 UPD42 MOV42 INS34 INS42 INS42 INS42 MOV21 MOV24 INS42 INS32 INS42 INS2 INS42 INS27 INS42 INS34 INS21 INS24 INS42 INS32 INS42 INS34 INS42 INS42 INS42 MOV21 INS42 INS34 INS21 MOV24 INS7 INS7 INS27 MOV37 MOV8 INS42 INS42 INS42 INS42 INS42 INS36 MOV2 INS7 INS7 MOV27 MOV37 MOV8 INS42 INS42 INS42 INS7 INS7 INS2 INS34 INS42 INS34 INS42 INS22 UPD42 INS21 INS21 INS27 INS2 INS34 INS42 INS34 UPD42 UPD42 INS21 INS21 INS42 INS16 INS42 INS34 UPD42 UPD42 INS21 MOV21 MOV21 INS42 INS42 INS2 INS42 INS7 MOV7 MOV2 INS42 INS42 UPD42 MOV42 INS7 MOV7 UPD42 UPD42 UPD42 UPD42 INS27 INS27 INS34 INS34 INS7 UPD7 INS42 INS42 INS42 INS32 INS16 UPD42 UPD42 INS42 MOV32 INS16 INS2 INS2 INS42 INS2 UPD42 MOV42 INS42 INS42 MOV32 INS42 INS16 MOV42 MOV42 MOV2 MOV27 INS2 INS34 UPD42 UPD42 INS2 INS42 MOV27 INS2 INS34 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 MOV27 INS2 INS34 UPD42 INS42 INS36 MOV2 UPD42 MOV2 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV2 UPD42 MOV42 UPD42 MOV2 UPD42 MOV42 INS27 INS42 INS42 INS42 INS42 MOV2 INS42 UPD42 UPD42 DEL83 DEL39 DEL85 DEL5 DEL42 DEL59 DEL23 DEL83 DEL39 DEL85 DEL85 DEL5 DEL59 DEL23 DEL52 DEL42 DEL22 DEL39 DEL85 DEL85 DEL5 DEL42 DEL42 DEL3 DEL7 DEL21 DEL52 DEL42 DEL22 DEL39 DEL85 DEL5 DEL42 DEL3 DEL7 DEL21 DEL42 DEL32 DEL21 DEL52 DEL42 DEL22 DEL34 DEL42 DEL42 DEL42 DEL34 DEL32 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL2 DEL39 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL21 DEL25 DEL42 DEL34 DEL27 DEL18 DEL25 DEL42 DEL42 DEL2 DEL42 DEL2 DEL42 DEL42 DEL2 DEL27 DEL32 DEL52 DEL42 DEL22 DEL42 DEL2 DEL39 DEL42 DEL34 DEL59 DEL58 DEL39 DEL42 DEL34 DEL59 DEL58 DEL39 DEL42 DEL34 DEL59 DEL58 DEL24 DEL8 DEL24 DEL8 DEL42 DEL42 DEL2 DEL52 DEL42 DEL22 DEL42 DEL2 DEL27 DEL52 DEL42 DEL22 DEL34 DEL52 DEL42 DEL22 DEL42 DEL2 DEL52 DEL42 DEL22 DEL2 DEL39 DEL42 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL21 DEL25 DEL42 DEL34 DEL27 DEL18 DEL25 DEL42 DEL42 DEL42 DEL2 DEL42 DEL2 DEL42 DEL2 DEL39 DEL42 DEL34 DEL59 DEL58 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL42 DEL2 DEL2 DEL27 DEL34 DEL39 DEL42 DEL59 DEL60 DEL8 DEL8 DEL25 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL27 DEL42 DEL37 DEL8 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL21 DEL39 DEL59 DEL58 DEL39 DEL42 DEL52 DEL42 DEL22 DEL42 DEL2 DEL59 DEL60 DEL42 DEL42 DEL42 DEL2 DEL42 DEL2 DEL42 DEL42 DEL2 DEL27 DEL36 DEL27 DEL7 DEL21 DEL8 DEL24 DEL42 DEL38 DEL7 DEL21 DEL8 DEL31 DEL83 DEL42 DEL42 DEL42 DEL32 DEL21 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL37 DEL8 DEL24 DEL8 DEL31 DEL66 DEL65 DEL29 DEL39 DEL39 DEL85 DEL5 DEL42 DEL44 DEL39 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL37 DEL39 DEL34 DEL59 DEL58 DEL39 DEL34 DEL59 DEL58 DEL42 DEL52 DEL42 DEL22 DEL2 DEL42 DEL22 DEL27 DEL24 DEL8 DEL24 DEL8 DEL24 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL8 DEL31
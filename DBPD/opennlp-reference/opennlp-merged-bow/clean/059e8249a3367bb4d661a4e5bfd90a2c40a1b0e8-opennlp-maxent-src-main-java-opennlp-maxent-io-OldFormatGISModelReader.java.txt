OPENLP-24 Formated code to comply with conventions

git-svn-id: https://svn.apache.org/repos/asf/incubator/opennlp/trunk@1063310 13f79535-47bb-0310-9956-ffa450edef68

-    /**
-     * Constructor which takes the name of the model without any suffixes,
-     * such as ".mei.gz" or ".mep.gz".
-     */
-    public OldFormatGISModelReader(String modelname)
-	throws IOException {
-	super(new File(modelname+".mei.gz"));
-	paramsInput = new DataInputStream(new GZIPInputStream(
-		          new FileInputStream(modelname+".mep.gz")));
-    }
+  /**
+   * Constructor which takes the name of the model without any suffixes, such as
+   * ".mei.gz" or ".mep.gz".
+   */
+  public OldFormatGISModelReader(String modelname) throws IOException {
+    super(new File(modelname + ".mei.gz"));
+    paramsInput = new DataInputStream(new GZIPInputStream(new FileInputStream(
+        modelname + ".mep.gz")));
+  }
-    /**
-     * Reads the parameters from a file and populates an array of context objects.
-     * @param outcomePatterns The outcomes patterns for the model.  The first index refers to which 
-     * outcome pattern (a set of outcomes that occurs with a context) is being specified.  The
-     * second index specifies the number of contexts which use this pattern at index 0, and the
-     * index of each outcomes which make up this pattern in indicies 1-n.  
-     * @return An array of context objects.
-     * @throws java.io.IOException when the model file does not match the outcome patterns or can not be read.
-     */
-    protected Context[] getParameters (int[][] outcomePatterns) throws java.io.IOException {
-      Context[] params = new Context[NUM_PREDS];
-      int pid=0;
-      for (int i=0; i<outcomePatterns.length; i++) {
-        //construct outcome pattern
-        int[] outcomePattern = new int[outcomePatterns[i].length-1];
-        for (int k=1; k<outcomePatterns[i].length; k++) {
-          outcomePattern[k-1] = outcomePatterns[i][k];
-        }
-        //populate parameters for each context which uses this outcome pattern. 
-        for (int j=0; j<outcomePatterns[i][0]; j++) {
-          double[] contextParameters = new double[outcomePatterns[i].length-1];
-          for (int k=1; k<outcomePatterns[i].length; k++) {
-            contextParameters[k-1] = readDouble();
-          }
-          params[pid] = new Context(outcomePattern,contextParameters);
-          pid++;
-        }
+  /**
+   * Reads the parameters from a file and populates an array of context objects.
+   * 
+   * @param outcomePatterns
+   *          The outcomes patterns for the model. The first index refers to
+   *          which outcome pattern (a set of outcomes that occurs with a
+   *          context) is being specified. The second index specifies the number
+   *          of contexts which use this pattern at index 0, and the index of
+   *          each outcomes which make up this pattern in indicies 1-n.
+   * @return An array of context objects.
+   * @throws java.io.IOException
+   *           when the model file does not match the outcome patterns or can
+   *           not be read.
+   */
+  protected Context[] getParameters(int[][] outcomePatterns)
+      throws java.io.IOException {
+    Context[] params = new Context[NUM_PREDS];
+    int pid = 0;
+    for (int i = 0; i < outcomePatterns.length; i++) {
+      // construct outcome pattern
+      int[] outcomePattern = new int[outcomePatterns[i].length - 1];
+      for (int k = 1; k < outcomePatterns[i].length; k++) {
+        outcomePattern[k - 1] = outcomePatterns[i][k];
-      return params;
+      // populate parameters for each context which uses this outcome pattern.
+      for (int j = 0; j < outcomePatterns[i][0]; j++) {
+        double[] contextParameters = new double[outcomePatterns[i].length - 1];
+        for (int k = 1; k < outcomePatterns[i].length; k++) {
+          contextParameters[k - 1] = readDouble();
+        }
+        params[pid] = new Context(outcomePattern, contextParameters);
+        pid++;
+      }
+    }
+    return params;
+  }
+
+  /**
+   * Convert a model created with Maxent 1.0 to a format used with Maxent 1.2.
+   * 
+   * <p>
+   * Usage: java opennlp.maxent.io.OldFormatGISModelReader model_name_prefix
+   * (new_model_name)");
+   * 
+   * <p>
+   * If the new_model_name is left unspecified, the new model will be saved in
+   * gzipped, binary format as "<model_name_prefix>.bin.gz".
+   */
+  public static void main(String[] args) throws IOException {
+    if (args.length < 1) {
+      System.out
+          .println("Usage: java opennlp.maxent.io.OldFormatGISModelReader model_name_prefix (new_model_name)");
+      System.exit(0);
-    /**
-     * Convert a model created with Maxent 1.0 to a format used with
-     * Maxent 1.2.
-     *
-     * <p>Usage: java opennlp.maxent.io.OldFormatGISModelReader model_name_prefix (new_model_name)");
-     *
-     * <p>If the new_model_name is left unspecified, the new model will be saved
-     * in gzipped, binary format as "<model_name_prefix>.bin.gz".
-     */
-    public static void main (String[] args) throws IOException {
-	if (args.length < 1) {
-	    System.out.println("Usage: java opennlp.maxent.io.OldFormatGISModelReader model_name_prefix (new_model_name)");
-	    System.exit(0);
-	}
+    int nameIndex = 0;
-	int nameIndex = 0;
+    String infilePrefix = args[nameIndex];
+    String outfile;
-	String infilePrefix = args[nameIndex];
-	String outfile;
+    if (args.length > nameIndex)
+      outfile = args[nameIndex + 1];
+    else
+      outfile = infilePrefix + ".bin.gz";
-	if (args.length > nameIndex)
-	    outfile = args[nameIndex+1];
-	else
-	    outfile = infilePrefix + ".bin.gz";
+    AbstractModelReader reader = new OldFormatGISModelReader(infilePrefix);
+    new SuffixSensitiveGISModelWriter(reader.getModel(), new File(outfile))
+        .persist();
-	AbstractModelReader reader = new OldFormatGISModelReader(infilePrefix);
-
-	new SuffixSensitiveGISModelWriter(reader.getModel(),
-					  new File(outfile)).persist();
-				   
-    }
-    
+  }

UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 INS66 INS66 UPD66 UPD66
OPENNLP-569 Attached is the patch for the current L-BFGS implementation. It includes bug fixes for numerical overflow when calculating sum of exponential functions and the formula error when computing log-likelihood. Thanks to Vinh Khuc for poviding a patch.

git-svn-id: https://svn.apache.org/repos/asf/opennlp/trunk@1584282 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.List;
+
- * utility class for simple vector arithmetics.
+ * Utility class for simple vector arithmetic.
-    if (vecA == null || vecB == null) 
-      return Double.NaN;
-    if (vecA.length != vecB.length)
+    if (vecA == null || vecB == null || vecA.length != vecB.length)
-
-  public static double[] updatePoint(double[] point, double[] vector, double scale) {
-    if (point == null || vector == null)
-      return null;
-    if (point.length != vector.length)
-      return null;
-
-    double[] updated = point.clone();
-    for (int i = 0; i < updated.length; i++) {
-      updated[i] = updated[i] + (vector[i] * scale);
+  
+  /**
+   * L2-norm 
+   */
+  public static double norm(double[] v) {
+    return Math.sqrt(innerProduct(v, v));
+  }
+  
+  /**
+   * Computes \log(\sum_{i=1}^n e^{x_i}) using a maximum-element trick 
+   * to avoid arithmetic overflow.
+   * 
+   * @param x input vector
+   * @return log-sum of exponentials of vector elements
+   */
+  public static double logSumOfExps(double[] x) {
+    double max = max(x);
+    double sum = 0.0;
+    for (int i = 0; i < x.length; i++) {
+      if (x[i] != Double.NEGATIVE_INFINITY)
+        sum += Math.exp(x[i] - max);
-    return updated;
+    return max + Math.log(sum);
+  }
+
+  public static double max(double[] x) {
+    int maxIdx = maxIdx(x);
+    return x[maxIdx];
+  }
+
+  /**
+   * Find index of maximum element in the vector x
+   * @param x input vector
+   * @return index of the maximum element. Index of the first
+   * maximum element is returned if multiple maximums are found.
+   */
+  public static int maxIdx(double[] x) {
+    if (x == null || x.length == 0) {
+      throw new IllegalArgumentException("Vector x is null or empty");
+    }
+    
+    int maxIdx = 0;
+    for (int i = 1; i < x.length; i++) {
+      if (x[maxIdx] < x[i])
+        maxIdx = i;
+    }
+    return maxIdx;
+  }
+  
+  // === Not really related to math ===
+  /**
+   * Convert a list of Double objects into an array of primitive doubles 
+   */
+  public static double[] toDoubleArray(List<Double> list) {
+    double[] arr = new double[list.size()];
+    for (int i = 0; i < arr.length; i++) {
+      arr[i] = list.get(i);
+    }
+    return arr;
+  }
+  
+  /**
+   *  Convert a list of Integer objects into an array of primitive integers
+   */
+  public static int[] toIntArray(List<Integer> list) {
+    int[] arr = new int[list.size()];
+    for (int i = 0; i < arr.length; i++) { 
+      arr[i] = list.get(i);
+    }
+    return arr;

INS26 INS40 INS31 INS31 INS31 INS31 INS31 INS31 INS29 MOV83 MOV83 INS39 INS42 MOV44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS39 INS42 MOV44 INS8 INS29 INS83 INS83 INS39 INS42 MOV44 INS8 INS29 INS83 INS83 MOV5 INS42 INS44 INS8 INS29 INS83 INS83 INS5 INS42 INS44 INS8 UPD66 INS65 UPD42 INS41 INS65 INS65 INS65 MOV5 INS42 INS60 INS60 INS24 INS41 UPD42 INS60 INS41 INS65 INS65 INS65 INS5 UPD42 MOV25 INS60 INS24 INS41 INS65 INS74 INS42 INS60 INS24 INS41 INS65 INS39 INS85 INS74 INS42 MOV60 MOV24 MOV41 INS27 INS66 INS32 INS66 INS66 INS42 INS66 INS66 INS39 INS59 INS39 INS59 MOV58 INS27 MOV37 INS8 INS27 INS39 INS59 INS2 INS66 INS42 INS66 INS66 INS66 INS39 INS85 INS8 INS39 INS59 INS58 INS27 INS37 INS8 INS42 INS66 INS43 INS43 INS5 INS59 INS58 INS27 INS37 INS8 INS42 INS66 INS43 INS43 INS5 INS58 INS37 UPD42 MOV27 MOV27 INS42 INS42 INS32 INS42 INS32 INS42 INS34 INS42 INS40 INS25 INS42 INS32 INS42 INS32 INS42 INS42 INS53 INS42 INS34 INS39 INS59 INS42 UPD40 MOV40 INS42 INS25 INS42 INS42 INS39 INS85 INS42 INS3 INS39 INS59 INS42 UPD40 MOV40 INS42 INS21 INS42 INS42 INS39 INS85 UPD42 INS3 INS39 INS59 UPD40 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS21 INS42 INS42 INS42 INS42 INS42 UPD42 INS40 INS34 INS14 INS42 INS34 INS27 INS21 INS5 INS32 INS42 INS34 INS7 INS5 INS32 INS42 INS34 INS2 INS40 INS7 INS43 INS45 INS2 INS2 INS7 INS39 INS85 INS42 INS42 INS2 INS32 INS39 INS85 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS27 INS2 INS42 INS42 INS42 DEL40 DEL41 DEL25 DEL39 DEL42 DEL33 DEL33 DEL41 DEL32 DEL42 DEL42 DEL2 DEL42 DEL42 DEL2 DEL42 DEL27 DEL36 DEL27 DEL42 DEL27 DEL33 DEL41 DEL25 DEL8 DEL31
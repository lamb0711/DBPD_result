OPENNLP-636 Removed usage of Class.forName from all non-deprecated methods. OpenNLP code base should be converted to use the new methods.

git-svn-id: https://svn.apache.org/repos/asf/opennlp/trunk@1569390 13f79535-47bb-0310-9956-ffa450edef68

-
-// TODO: Another issue is that certain trainers will have certain properties,
-// the code using the trainer should have the possibilites to get these properties
-// in our case this could be communicated via the trainer interface itself!
-// For example via property methods.
-
-// 
+import opennlp.tools.util.ext.ExtensionLoader;
+import opennlp.tools.util.ext.ExtensionNotLoadedException;
-    // TODO: This will not work in an OSGi environment!
-    if (trainerClass == null) {
-      try {
-        trainerClass = Class.forName(alogrithmValue);
-      } catch (ClassNotFoundException e) {
-      }
-    }
-    
+
+    // Try to load the different trainers, and return the type on success
+    try {
+      ExtensionLoader.instantiateExtension(EventTrainer.class, alogrithmValue);
+      return TrainerType.EVENT_MODEL_TRAINER; 
+    }
+    catch (ExtensionNotLoadedException e) {
+    }
+    
+    try {
+      ExtensionLoader.instantiateExtension(EventModelSequenceTrainer.class, alogrithmValue);
+      return TrainerType.EVENT_MODEL_SEQUENCE_TRAINER;
+    }
+    catch (ExtensionNotLoadedException e) {
+    }
+
+    try {
+      ExtensionLoader.instantiateExtension(SequenceTrainer.class, alogrithmValue);
+      return TrainerType.SEQUENCE_TRAINER;
+    }
+    catch (ExtensionNotLoadedException e) {
+    }
+
-  
-    String trainerType = getTrainerTypeInt(trainParams);
-    if (BUILTIN_TRAINERS.containsKey(trainerType)) {
-      return TrainerFactory.<SequenceTrainer> create(
-          BUILTIN_TRAINERS.get(trainerType), trainParams, reportMap);
-    } else {
-      return TrainerFactory.<SequenceTrainer> create(trainerType, trainParams,
-          reportMap);
-    }
+    String trainerType = trainParams.get(AbstractTrainer.ALGORITHM_PARAM);
+    if (trainerType != null) {
+      if (BUILTIN_TRAINERS.containsKey(trainerType)) {
+        return TrainerFactory.<SequenceTrainer> createBuiltinTrainer(
+            BUILTIN_TRAINERS.get(trainerType), trainParams, reportMap);
+      } else {
+        return ExtensionLoader.instantiateExtension(SequenceTrainer.class, trainerType);
+      }
+    }
+    else {
+      throw new IllegalArgumentException("Trainer type couldn't be determined!");
+    }
-    return getSequenceTrainer(trainParams, reportMap);
+    String trainerType = trainParams.get(AbstractTrainer.ALGORITHM_PARAM);
+    if (trainerType != null) {
+      if (BUILTIN_TRAINERS.containsKey(trainerType)) {
+        return TrainerFactory.<EventModelSequenceTrainer> createBuiltinTrainer(
+            BUILTIN_TRAINERS.get(trainerType), trainParams, reportMap);
+      } else {
+        return ExtensionLoader.instantiateExtension(EventModelSequenceTrainer.class, trainerType);
+      }
+    }
+    else {
+      throw new IllegalArgumentException("Trainer type couldn't be determined!");
+    }
-    String trainerType = getTrainerTypeInt(trainParams);
-    if (BUILTIN_TRAINERS.containsKey(trainerType)) {
-      return TrainerFactory.<EventModelSequenceTrainer> create(
-          BUILTIN_TRAINERS.get(trainerType), trainParams, reportMap);
-    } else {
-      return TrainerFactory.<EventModelSequenceTrainer> create(trainerType, trainParams,
-          reportMap);
-    }
+    return getEventModelSequenceTrainer(trainParams, reportMap);
-    String trainerType = getTrainerTypeInt(trainParams);
-    if(trainerType == null) {
+    String trainerType = trainParams.get(AbstractTrainer.ALGORITHM_PARAM);
+    if (trainerType == null) {
-    
-    if (BUILTIN_TRAINERS.containsKey(trainerType)) {
-      return TrainerFactory.<EventTrainer> create(
-          BUILTIN_TRAINERS.get(trainerType), trainParams, reportMap);
-    } else {
-      return TrainerFactory.<EventTrainer> create(trainerType, trainParams,
-          reportMap);
+    else {
+      if (BUILTIN_TRAINERS.containsKey(trainerType)) {
+        return TrainerFactory.<EventTrainer> createBuiltinTrainer(
+            BUILTIN_TRAINERS.get(trainerType), trainParams, reportMap);
+      } else {
+        return ExtensionLoader.instantiateExtension(EventTrainer.class, trainerType);
+      }
-    // to check the algorithm we verify if it is a built in trainer, or if we can instantiate
-    // one if it is a class name
-    
+    // If a trainer type can be determined, then the trainer is valid!
-        !(BUILTIN_TRAINERS.containsKey(algorithmName) || canLoadTrainer(algorithmName))) {
+        !(BUILTIN_TRAINERS.containsKey(algorithmName) || getTrainerType(trainParams) != null)) {
-  private static boolean canLoadTrainer(String className) {
-    try {
-      Class<?> trainerClass = Class.forName(className);
-      if(trainerClass != null &&
-          (EventTrainer.class.isAssignableFrom(trainerClass)
-              || EventModelSequenceTrainer.class.isAssignableFrom(trainerClass) || SequenceTrainer.class.isAssignableFrom(trainerClass))) {
-        return true;
-      }
-    } catch (ClassNotFoundException e) {
-      // fail
-    }
-    return false;
-  }
-
-  private static String getTrainerTypeInt(Map<String, String> trainParams) {
-    return trainParams.get(AbstractTrainer.ALGORITHM_PARAM);
-  }
-
-  private static <T> T create(String className,
-      Map<String, String> trainParams, Map<String, String> reportMap) {
-    T theFactory = null;
-
-    try {
-      // TODO: won't work in OSGi!
-      Class<T> trainerClass = (Class<T>) Class.forName(className);
-      
-      theFactory = create(trainerClass, trainParams, reportMap);
-    } catch (Exception e) {
-      String msg = "Could not instantiate the " + className
-          + ". The initialization throw an exception.";
-      System.err.println(msg);
-      e.printStackTrace();
-      throw new IllegalArgumentException(msg, e);
-    }
-    return theFactory;
-  }
-
-  private static <T> T create(Class<T> trainerClass,
+  private static <T> T createBuiltinTrainer(Class<T> trainerClass,

INS26 INS26 INS40 INS40 INS31 MOV44 MOV44 MOV83 MOV83 MOV43 MOV42 MOV44 MOV44 INS8 INS8 UPD42 INS54 MOV54 INS54 INS25 MOV60 INS25 MOV41 INS25 INS8 INS12 INS8 INS12 INS27 INS8 INS8 MOV43 INS27 INS8 INS8 MOV27 MOV8 INS8 INS21 INS41 INS44 INS8 INS41 INS21 INS41 INS44 INS8 INS42 INS33 MOV25 INS53 UPD42 UPD42 MOV42 MOV33 INS25 MOV53 INS42 MOV32 MOV25 INS32 INS40 INS43 INS42 INS32 INS40 UPD43 INS32 INS40 INS43 INS42 UPD42 UPD42 INS40 INS14 UPD42 UPD42 INS40 MOV32 INS8 INS8 UPD42 MOV42 INS42 INS42 INS57 INS42 INS42 INS42 UPD42 MOV42 INS57 MOV42 UPD42 INS42 INS42 INS57 INS42 INS42 INS43 INS45 INS41 INS41 INS45 INS43 INS43 INS43 MOV32 MOV57 INS42 INS32 MOV32 MOV57 INS27 INS42 INS42 INS42 MOV43 UPD42 INS42 UPD42 UPD42 UPD42 MOV42 MOV43 UPD42 MOV42 MOV32 MOV42 MOV42 INS42 UPD42 UPD42 MOV43 UPD42 UPD42 UPD42 MOV57 UPD42 MOV32 INS33 UPD42 UPD42 DEL42 DEL33 DEL27 DEL8 DEL25 DEL42 DEL42 DEL32 DEL7 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL76 DEL74 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL42 DEL25 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL27 DEL42 DEL42 DEL32 DEL27 DEL36 DEL27 DEL9 DEL41 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL9 DEL41 DEL8 DEL31 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL41 DEL8 DEL31 DEL83 DEL83 DEL42 DEL73 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL45 DEL42 DEL45 DEL27 DEL59 DEL60 DEL40 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL42 DEL41 DEL8 DEL31
OPENNLP-17 Added support for custom feature generator

git-svn-id: https://svn.apache.org/repos/asf/incubator/opennlp/trunk@1127443 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.ByteArrayInputStream;
+import java.io.OutputStream;
+import java.util.Collections;
+import opennlp.tools.util.featuregen.AdaptiveFeatureGenerator;
+import opennlp.tools.util.featuregen.FeatureGeneratorResourceProvider;
+import opennlp.tools.util.featuregen.GeneratorFactory;
+import opennlp.tools.util.model.ModelUtil;
+  public static class FeatureGeneratorCreationError extends RuntimeException {
+    FeatureGeneratorCreationError(Throwable t) {
+      super(t);
+    }
+  }
+  
+  private static class ByteArraySerializer implements ArtifactSerializer<byte[]> {
+
+    public byte[] create(InputStream in) throws IOException,
+        InvalidFormatException {
+      
+      return ModelUtil.read(in);
+    }
+
+    public void serialize(byte[] artifact, OutputStream out) throws IOException {
+      out.write(artifact);
+    }
+  }
+  
-  
+ 
+  private static final String GENERATOR_DESCRIPTOR_ENTRY_NAME = "generator.featuregen";
+ 
-      Map<String, Object> resources, Map<String, String> manifestInfoEntries) {
+      byte[] generatorDescriptor, Map<String, Object> resources, Map<String, String> manifestInfoEntries) {
+    // TODO: Null check ?!
+    if (generatorDescriptor != null && generatorDescriptor.length > 0)
+      artifactMap.put(GENERATOR_DESCRIPTOR_ENTRY_NAME, generatorDescriptor);
+    
-    if (resources.containsKey(MAXENT_MODEL_ENTRY_NAME)) {
+    if (resources.containsKey(MAXENT_MODEL_ENTRY_NAME) ||
+        resources.containsKey(GENERATOR_DESCRIPTOR_ENTRY_NAME)) {
+  public TokenNameFinderModel(String languageCode, AbstractModel nameFinderModel,
+      Map<String, Object> resources, Map<String, String> manifestInfoEntries) {
+    this(languageCode, nameFinderModel, null, resources, manifestInfoEntries);
+  }
+      
+  /**
+   * Creates the {@link AdaptiveFeatureGenerator}. Usually this
+   * is a set of generators contained in the {@link AggregatedFeatureGenerator}.
+   *
+   * Note:
+   * The generators are created on every call to this method.
+   *
+   * @return the feature generator or null if there is no descriptor in the model
+   */
+  public AdaptiveFeatureGenerator createFeatureGenerators() {
+
+    byte descriptorBytes[] = (byte[]) artifactMap.get(GENERATOR_DESCRIPTOR_ENTRY_NAME);
+    
+    if (descriptorBytes != null) {
+      InputStream descriptorIn = new ByteArrayInputStream(descriptorBytes);
+  
+      AdaptiveFeatureGenerator generator = null;
+      try {
+        generator = GeneratorFactory.create(descriptorIn, new FeatureGeneratorResourceProvider() {
+  
+          public Object getResource(String key) {
+            return artifactMap.get(key);
+          }
+        });
+      } catch (InvalidFormatException e) {
+        // It is assumed that the creation of the feature generation does not
+        // fail after it succeeded once during model loading.
+        
+        // But it might still be possible that such an exception is thrown,
+        // in this case the caller should not be forced to handle the exception
+        // and a Runtime Exception is thrown instead.
+        
+        // If the re-creation of the feature generation fails it is assumed
+        // that this can only be caused by a programming mistake and therefore
+        // throwing a Runtime Exception is reasonable
+        
+        throw new FeatureGeneratorCreationError(e);
+      } catch (IOException e) {
+        throw new IllegalStateException("Reading from mem cannot result in an I/O error");
+      }
+  
+      return generator;
+    }
+    else {
+      return null;
+    }
+  }
+  
+  public TokenNameFinderModel updateFeatureGenerator(byte descriptor[]) {
+        
+    TokenNameFinderModel model = new TokenNameFinderModel(getLanguage(), getNameFinderModel(),
+        descriptor, Collections.<String, Object>emptyMap(), Collections.<String, String>emptyMap());
+    
+    // TODO: Not so nice!
+    model.artifactMap.clear();
+    model.artifactMap.putAll(artifactMap);
+    model.artifactMap.put(GENERATOR_DESCRIPTOR_ENTRY_NAME, descriptor);
+    
+    return model;
+  }
+  
+    
+    serializers.put("featuregen", new ByteArraySerializer());
+  }
+  
+  public static Map<String, ArtifactSerializer> createArtifactSerializers()  {
+    
+    // TODO: Not so nice, because code cannot really be reused by the other create serializer method
+    //       Has to be redesigned, we need static access to default serializers
+    //       and these should be able to extend during runtime ?! 
+    
+    Map<String, ArtifactSerializer> serializers = BaseModel.createArtifactSerializers();
+    
+    serializers.put("featuregen", new ByteArraySerializer());
+    
+    return serializers;

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS55 INS55 INS23 INS31 INS31 INS31 INS31 INS83 INS83 INS42 INS43 INS31 INS83 INS83 INS42 INS74 INS31 INS31 INS83 INS83 INS83 INS43 INS59 INS44 INS83 INS42 INS44 INS44 INS44 INS44 INS8 INS29 INS83 INS43 INS42 INS8 INS83 INS43 INS42 INS44 INS8 INS83 INS83 INS74 INS42 INS8 INS42 INS42 INS44 INS8 INS43 INS5 INS83 INS5 INS42 INS44 INS43 INS43 INS8 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS42 INS42 INS45 INS5 INS42 INS25 INS43 INS42 INS43 INS42 INS74 INS42 INS74 INS42 INS17 INS65 INS65 INS42 INS60 INS25 INS42 INS39 INS42 INS85 INS60 INS21 INS21 INS21 INS41 INS21 INS43 INS43 INS43 INS60 INS21 INS41 INS43 INS42 INS46 INS42 INS39 INS85 INS39 INS85 INS43 INS42 INS42 INS42 INS41 INS5 INS42 INS43 INS42 INS42 INS21 INS39 INS85 INS27 INS21 INS27 INS42 INS42 INS43 INS43 INS43 INS43 INS43 INS43 INS42 INS42 INS33 INS42 INS42 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS39 INS59 INS27 INS8 INS8 INS43 INS59 INS32 INS32 INS32 INS42 INS32 INS42 INS42 INS42 INS74 INS59 INS32 INS42 INS42 INS42 INS42 INS32 INS39 INS85 INS42 INS32 INS27 INS27 INS32 MOV32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS85 INS11 INS42 INS33 INS60 INS60 INS54 INS41 INS41 INS42 INS42 INS14 INS40 INS42 INS40 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS45 INS14 INS43 INS43 INS43 INS42 INS32 INS42 INS42 INS45 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS40 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS5 INS32 INS43 INS59 INS43 INS59 INS8 INS12 INS12 INS42 INS33 INS43 INS32 INS32 INS42 INS32 INS32 INS43 INS42 INS42 INS42 INS42 INS42 INS43 INS39 INS85 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS33 INS21 INS44 INS8 INS44 INS8 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS42 INS43 INS43 INS42 INS42 INS42 INS43 INS42 INS7 INS43 INS42 INS53 INS43 INS42 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS14 INS42 INS14 INS42 INS42 INS42 INS14 INS43 INS42 INS43 INS45 INS43 INS1 INS42 INS42 INS42 INS31 INS83 INS43 INS42 INS44 INS8 INS42 INS43 INS42 INS41 INS42 INS32 INS42 INS42 INS42
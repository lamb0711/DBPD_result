OPENNLP-402 Added formats support to trainer and evaluator tools. Refactoring of various things. Thanks to Aliaksandr Autayeu for providing a patch.

git-svn-id: https://svn.apache.org/repos/asf/incubator/opennlp/trunk@1209220 13f79535-47bb-0310-9956-ffa450edef68

-      Object value = null;
+      Object value;
-        throw new TerminateToolException(-1, String.format(INVALID_ARG, argName, argValue) +
+        throw new TerminateToolException(1, String.format(INVALID_ARG, argName, argValue) +
-          throw new TerminateToolException(-1,  String.format(INVALID_ARG, argName, charsetName) + 
+          throw new TerminateToolException(1,  String.format(INVALID_ARG, argName, charsetName) +
-        throw new TerminateToolException(-1, String.format(INVALID_ARG, argName, charsetName) + 
+        throw new TerminateToolException(1, String.format(INVALID_ARG, argName, charsetName) +
-  private static <T> void checkProxyInterface(Class<T> proxyInterface) {
-    if (!proxyInterface.isInterface())
-      throw new IllegalArgumentException("proxy interface is not an interface!");
-    
-    // all checks should also be performed for super interfaces
-    
-    Method methods[] = proxyInterface.getMethods();
-    
-    if (methods.length == 0)
-      throw new IllegalArgumentException("proxy interface must at least declare one method!");
-    
-    for (Method method : methods) {
-      
-      // check that method names start with get
-      if (!method.getName().startsWith("get") && method.getName().length() > 3) 
-        throw new IllegalArgumentException(method.getName() + " method name does not start with get!");
-    
-      // check that method has zero arguments
-      if (method.getParameterTypes().length != 0)
-        throw new IllegalArgumentException(method.getName() + " method must have zero parameters!");
-      
-      // check return types of interface
-      Class<?> returnType = method.getReturnType();
-      
-      Set<Class<?>> compatibleReturnTypes = argumentFactories.keySet();
-      
-      if(!compatibleReturnTypes.contains(returnType))
-         throw new IllegalArgumentException(method.getName() + " method must have compatible return type!");
+  private static <T> void checkProxyInterfaces(Class<T>... proxyInterfaces) {
+    for (Class<T> proxyInterface : proxyInterfaces) {
+      if (null != proxyInterface) {
+        if (!proxyInterface.isInterface())
+          throw new IllegalArgumentException("proxy interface is not an interface!");
+
+        // all checks should also be performed for super interfaces
+
+        Method methods[] = proxyInterface.getMethods();
+
+        if (methods.length == 0)
+          throw new IllegalArgumentException("proxy interface must at least declare one method!");
+
+        for (Method method : methods) {
+
+          // check that method names start with get
+          if (!method.getName().startsWith("get") && method.getName().length() > 3)
+            throw new IllegalArgumentException(method.getName() + " method name does not start with get!");
+
+          // check that method has zero arguments
+          if (method.getParameterTypes().length != 0)
+            throw new IllegalArgumentException(method.getName() + " method must have zero parameters!");
+
+          // check return types of interface
+          Class<?> returnType = method.getReturnType();
+
+          Set<Class<?>> compatibleReturnTypes = argumentFactories.keySet();
+
+          if(!compatibleReturnTypes.contains(returnType))
+             throw new IllegalArgumentException(method.getName() + " method must have compatible return type!");
+        }
+      }
-    
+
-    
+
-  
+
-   * 
-   * @param argProxyInterface
-   * 
+   *
+   * @param argProxyInterface interface with parameter descriptions
+  @SuppressWarnings({"unchecked"})
+    return createUsage(new Class[]{argProxyInterface});
+  }
-    checkProxyInterface(argProxyInterface);
-    
+  
+  /**
+   * Creates a usage string which can be printed in case the user did specify the arguments
+   * incorrectly. Incorrectly is defined as {@link ArgumentParser#validateArguments(String[],
+   * Class[])}
+   * returns false.
+   * 
+   * @param argProxyInterfaces interfaces with parameter descriptions
+   * @return the help message usage string
+   */
+  public static <T> String createUsage(Class<T>... argProxyInterfaces) {
+    checkProxyInterfaces(argProxyInterfaces);
+
-    
-    for (Method method : argProxyInterface.getMethods()) {
-      
-      ParameterDescription desc = method.getAnnotation(ParameterDescription.class);
-      
-      OptionalParameter optional = method.getAnnotation(OptionalParameter.class);
-      
-      if (desc != null) {
-        String paramName = methodNameToParameter(method.getName());
-        
-        if (optional != null)
-          usage.append('[');
-        
-        usage.append(paramName).append(' ').append(desc.valueName());
-        details.append('\t').append(paramName).append(' ').append(desc.valueName()).append('\n');
-        if(desc.description() != null && desc.description().length() > 0) {
-          details.append("\t\t").append(desc.description()).append('\n');
+    for (Class<T> argProxyInterface : argProxyInterfaces) {
+      if (null != argProxyInterface) {
+        for (Method method : argProxyInterface.getMethods()) {
+
+          ParameterDescription desc = method.getAnnotation(ParameterDescription.class);
+
+          OptionalParameter optional = method.getAnnotation(OptionalParameter.class);
+
+          if (desc != null) {
+            String paramName = methodNameToParameter(method.getName());
+
+            if (optional != null)
+              usage.append('[');
+
+            usage.append(paramName).append(' ').append(desc.valueName());
+            details.append('\t').append(paramName).append(' ').append(desc.valueName()).append('\n');
+            if(desc.description() != null && desc.description().length() > 0) {
+              details.append("\t\t").append(desc.description()).append('\n');
+            }
+
+            if (optional != null)
+              usage.append(']');
+
+            usage.append(' ');
+          }
-        
-        if (optional != null)
-          usage.append(']');
-        
-        usage.append(' ');
-    
+
-    
-    if(details.length() > 0) {
+
+    if (details.length() > 0) {
-    
+
-  
+
+  @SuppressWarnings({"unchecked"})
-    return null == validateArgumentsLoudly(args, argProxyInterface);
+    return validateArguments(args, new Class[]{argProxyInterface});
+  }
+
+  /**
+   * Tests if the argument are correct or incorrect. Incorrect means, that mandatory arguments are missing or
+   * there are unknown arguments. The argument value itself can also be incorrect, but this
+   * is checked by the {@link ArgumentParser#parse(String[], Class)} method and reported accordingly.
+   *
+   * @param args command line arguments
+   * @param argProxyInterfaces interfaces with parameters description
+   * @return true, if arguments are valid
+   */
+  public static <T> boolean validateArguments(String args[], Class<T>... argProxyInterfaces) {
+    return null == validateArgumentsLoudly(args, argProxyInterfaces);
+  }
+
+  /**
+   * Tests if the arguments are correct or incorrect.
+   *
+   * @param args command line arguments
+   * @param argProxyInterface interface with parameters description
+   * @return null, if arguments are valid or error message otherwise
+   */
+  @SuppressWarnings({"unchecked"})
+  public static <T> String validateArgumentsLoudly(String args[], Class<T> argProxyInterface) {
+    return validateArgumentsLoudly(args, new Class[]{argProxyInterface});
-   * @param argProxyInterface interface with parameters description
+   * @param argProxyInterfaces interfaces with parameters description
-  public static <T> String validateArgumentsLoudly(String args[], Class<T> argProxyInterface) {
-    
+  public static <T> String validateArgumentsLoudly(String args[], Class<T>... argProxyInterfaces) {
-      return "Error: Number of parameters must be at least 2 and always be even";
+      return "Number of parameters must be at least 2 and always be even";
-    
+
-
-    for (Method method : argProxyInterface.getMethods()) {
-      String paramName = methodNameToParameter(method.getName());
-      int paramIndex = CmdLineUtil.getParameterIndex(paramName, args);
-      String valueString = CmdLineUtil.getParameter(paramName, args);
-      if (valueString == null) {
-        OptionalParameter optionalParam = method.getAnnotation(OptionalParameter.class);
-        if (optionalParam == null) {
-          if (-1 < paramIndex) {
-            return "Error: Missing mandatory parameter value: " + paramName;
+    for (Class<T> argProxyInterface : argProxyInterfaces) {
+      for (Method method : argProxyInterface.getMethods()) {
+        String paramName = methodNameToParameter(method.getName());
+        int paramIndex = CmdLineUtil.getParameterIndex(paramName, args);
+        String valueString = CmdLineUtil.getParameter(paramName, args);
+        if (valueString == null) {
+          OptionalParameter optionalParam = method.getAnnotation(OptionalParameter.class);
+
+          if (optionalParam == null) {
+            if (-1 < paramIndex) {
+              return "Missing mandatory parameter value: " + paramName;
+            } else {
+              return "Missing mandatory parameter: " + paramName;
+            }
-            return "Error: Missing mandatory parameter: " + paramName;
+            parameters.remove("-" + paramName);
-        } else {
-          parameters.remove("-" + paramName);
+        }
+        else {
+          parameters.remove(paramName);
+          parameters.remove(valueString);
+          argumentCount++;
-      else {
-        parameters.remove(paramName);
-        parameters.remove(valueString);
-        argumentCount++;
-      }
-    
+
-      return "Error: Unrecognized parameters encountered: " + parameters.toString();
+      return "Unrecognized parameters encountered: " + parameters.toString();
-    
+
-    checkProxyInterface(argProxyInterface);
+    checkProxyInterfaces(argProxyInterface);
+
+  /**
+   * Filters arguments leaving only those pertaining to argProxyInterface.
+   *
+   * @param args arguments
+   * @param argProxyInterface interface with parameters description
+   * @param <T> T
+   * @return arguments pertaining to argProxyInterface
+   */
+  public static <T> String[] filter(String args[], Class<T> argProxyInterface) {
+    ArrayList<String> parameters = new ArrayList<String>(args.length);
+
+    for (Method method : argProxyInterface.getMethods()) {
+
+      String parameterName = methodNameToParameter(method.getName());
+      int idx = CmdLineUtil.getParameterIndex(parameterName, args);
+      if (-1 < idx) {
+        parameters.add(parameterName);
+        String valueString = CmdLineUtil.getParameter(parameterName, args);
+        if (null != valueString) {
+          parameters.add(valueString);
+        }
+      }
+    }
+
+    return parameters.toArray(new String[parameters.size()]);
+  }

INS31 INS31 INS31 INS31 UPD42 INS44 INS8 MOV29 INS79 INS83 INS83 INS73 INS43 INS42 INS44 INS8 INS29 INS44 INS79 INS29 INS83 INS83 INS73 INS39 INS42 INS44 INS44 INS8 MOV29 INS79 INS83 INS83 INS73 INS43 INS42 INS44 INS44 INS8 INS29 INS44 INS29 INS83 INS83 INS73 INS5 INS42 INS44 INS44 INS8 INS74 INS42 INS70 INS42 INS4 INS42 INS42 INS74 INS42 INS41 INS65 INS65 INS65 INS74 INS42 INS70 INS42 INS4 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS85 INS74 INS42 INS41 INS42 INS4 INS42 INS42 INS43 INS42 INS85 INS74 INS42 INS41 INS65 INS65 INS65 INS65 INS74 INS42 INS70 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS85 INS43 INS42 INS85 INS74 INS42 INS60 INS70 INS41 INS43 INS43 MOV44 INS42 INS8 INS66 INS45 INS43 INS43 INS32 INS66 INS66 INS65 INS66 INS42 INS66 INS66 INS43 INS43 MOV44 INS42 INS8 INS45 INS32 INS66 INS66 INS66 INS65 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS43 INS43 INS27 INS45 INS42 INS43 INS43 INS32 INS66 INS42 INS66 INS42 INS66 INS66 INS43 INS43 MOV44 INS42 INS8 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS66 INS42 INS42 INS43 INS43 INS74 INS59 INS44 INS32 INS8 INS32 INS42 INS42 INS25 INS42 INS42 INS42 INS3 INS68 INS42 INS42 UPD42 UPD42 INS25 UPD42 MOV42 MOV42 INS3 INS68 INS42 INS42 INS33 INS32 INS42 INS42 INS42 INS42 INS3 INS42 INS42 MOV70 UPD42 INS42 INS42 INS43 INS43 INS42 INS14 INS43 INS42 INS42 INS42 INS60 INS60 INS25 INS42 INS42 INS3 INS27 MOV8 INS5 INS4 INS42 INS42 INS69 INS69 INS27 INS8 INS5 INS4 INS42 INS42 INS69 INS69 INS42 INS42 INS42 INS5 INS4 UPD45 INS42 INS42 INS74 INS40 INS42 INS43 INS59 INS39 INS59 INS27 INS8 INS5 INS32 INS33 INS42 INS43 INS85 INS42 INS5 INS5 INS33 INS42 MOV70 INS43 INS85 INS42 INS5 INS43 INS43 INS85 INS42 UPD45 INS43 INS43 INS42 INS42 INS32 INS42 INS32 MOV38 INS42 INS21 INS60 INS25 INS43 INS85 INS42 INS42 INS42 INS43 INS85 INS43 INS85 INS42 INS43 INS85 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS43 INS59 INS27 INS8 INS42 INS34 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS33 INS42 INS21 INS42 INS42 INS42 INS42 INS32 INS34 INS42 INS42 INS42 UPD45 UPD45 DEL33 DEL34 DEL38 DEL34 DEL38 DEL33 DEL42 DEL32 DEL27
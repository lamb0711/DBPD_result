- adapted versioning again to spec 0.15
- added VirtualItemStateManager for reflecting virtual content


git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@55615 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.ItemImpl;
-     * key = UUID (String)
+     * key = versionId (String)
+     * the id of this history
+     */
+    private String historyId;
+
+    /**
+     * the version manager
+     */
+    private final PersistentVersionManager vMgr;
+
+    /**
-    InternalVersionHistory(PersistentNode node) throws RepositoryException {
+    InternalVersionHistory(PersistentVersionManager vMgr, PersistentNode node) throws RepositoryException {
+        this.vMgr = vMgr;
+        // get id
+        historyId = (String) node.getPropertyValue(PersistentVersionManager.PROPNAME_HISTORY_ID).internalValue();
+
-            if (child.getName().equals(VersionManager.NODENAME_VERSION_LABELS)) {
+            if (child.getName().equals(PersistentVersionManager.NODENAME_VERSION_LABELS)) {
-            versionCache.put(child.getUUID(), v);
-            if (child.getName().equals(VersionManager.NODENAME_ROOTVERSION)) {
+            versionCache.put(v.getId(), v);
+            if (v.isRootVersion()) {
-            String name = (String) lNode.getPropertyValue(VersionManager.PROPNAME_NAME).internalValue();
-            String ref = ((UUID) lNode.getPropertyValue(VersionManager.PROPNAME_VERSION).internalValue()).toString();
+            String name = (String) lNode.getPropertyValue(PersistentVersionManager.PROPNAME_NAME).internalValue();
+            String ref = (String) lNode.getPropertyValue(PersistentVersionManager.PROPNAME_VERSION).internalValue();
-     * Returns the uuid of this version history
+     * returns the version manager
+     * @return
+     */
+    public PersistentVersionManager getVersionManager() {
+        return vMgr;
+    }
+
+    /**
+     * Returns the id of this version history
-    public String getUUID() {
-        return node.getUUID();
+    public String getId() {
+        return historyId;
-        versionCache.remove(v.getUUID());
+        versionCache.remove(v.getId());
-    public void addVersionLabel(InternalVersion version, String label, boolean move) throws RepositoryException {
+    public void addVersionLabel(InternalVersion version, String label, boolean move)
+            throws VersionException, RepositoryException {
-            throw new RepositoryException("Version label " + label + " already defined for version " + prev);
+            throw new VersionException("Version label " + label + " already defined for version " + prev.getName());
-        lNode.setPropertyValue(VersionManager.PROPNAME_NAME, InternalValue.create(label));
-        lNode.setPropertyValue(VersionManager.PROPNAME_VERSION, InternalValue.create(new UUID(version.getUUID())));
-        lNode.store();
+        lNode.setPropertyValue(PersistentVersionManager.PROPNAME_NAME, InternalValue.create(label));
+        lNode.setPropertyValue(PersistentVersionManager.PROPNAME_VERSION, InternalValue.create(version.getId()));
+        labelNode.store();
+        // inform manager
+        vMgr.onVersionModified(version);
+
+        // inform manager
+        vMgr.onVersionModified(v);
-            String uuid = preds[i].getString();
+            String predId = preds[i].getString();
-            if (!versionCache.containsKey(uuid)) {
+            if (!versionCache.containsKey(predId)) {
-            predecessors[i] = InternalValue.create(new UUID(uuid));
+            predecessors[i] = InternalValue.create(predId);
-        vNode.setPropertyValue(ItemImpl.PROPNAME_UUID, InternalValue.create(vNode.getUUID()));
-        vNode.setMixinNodeTypes(new QName[]{NodeTypeRegistry.MIX_REFERENCEABLE});
+        String versionId = UUID.randomUUID().toString();
+        vNode.setPropertyValue(PersistentVersionManager.PROPNAME_VERSION_ID, InternalValue.create(versionId));
-        vNode.setPropertyValues(VersionManager.PROPNAME_PREDECESSORS, PropertyType.REFERENCE, predecessors);
-
+        vNode.setPropertyValues(VersionManager.PROPNAME_PREDECESSORS, PropertyType.STRING, predecessors);
-        InternalFrozenNode.checkin(vNode, VersionManager.NODENAME_FROZEN, src);
+        InternalFrozenNode.checkin(vNode, PersistentVersionManager.NODENAME_FROZEN, src, false);
-        versionCache.put(version.getUUID(), version);
+        versionCache.put(version.getId(), version);
+     * Returns an iterator over all versions (not ordered yet)
+     * @return
+     */
+    protected Iterator getVersions() {
+        return versionCache.values().iterator();
+    }
+
+    /**
-    protected static InternalVersionHistory create(PersistentNode parent, QName name)
+    protected static InternalVersionHistory create(PersistentVersionManager vMgr, PersistentNode parent, String historyId, QName name, NodeImpl src)
-        pNode.setPropertyValue(ItemImpl.PROPNAME_UUID, InternalValue.create(pNode.getUUID()));
-        pNode.setMixinNodeTypes(new QName[]{NodeTypeRegistry.MIX_REFERENCEABLE});
+        pNode.setPropertyValue(PersistentVersionManager.PROPNAME_HISTORY_ID, InternalValue.create(historyId));
-        pNode.addNode(VersionManager.NODENAME_VERSION_LABELS, NodeTypeRegistry.NT_UNSTRUCTURED);
+        pNode.addNode(PersistentVersionManager.NODENAME_VERSION_LABELS, NodeTypeRegistry.NT_UNSTRUCTURED);
+        String versionId = UUID.randomUUID().toString();
-        vNode.setPropertyValue(ItemImpl.PROPNAME_UUID, InternalValue.create(vNode.getUUID()));
-        vNode.setMixinNodeTypes(new QName[]{NodeTypeRegistry.MIX_REFERENCEABLE});
+        vNode.setPropertyValue(PersistentVersionManager.PROPNAME_VERSION_ID, InternalValue.create(versionId));
+        // add also an empty frozen node to the root version
+        InternalFrozenNode.checkin(vNode, PersistentVersionManager.NODENAME_FROZEN, src, true);
+
-        return new InternalVersionHistory(pNode);
+        return new InternalVersionHistory(vMgr, pNode);

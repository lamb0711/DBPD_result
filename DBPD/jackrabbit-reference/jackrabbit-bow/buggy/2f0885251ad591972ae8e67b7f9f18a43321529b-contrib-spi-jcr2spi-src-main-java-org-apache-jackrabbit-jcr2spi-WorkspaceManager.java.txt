Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.state.NoSuchItemStateException;
-import org.apache.jackrabbit.jcr2spi.state.ItemStateManager;
-import org.apache.jackrabbit.jcr2spi.state.WorkspaceItemStateManager;
+import org.apache.jackrabbit.jcr2spi.state.TransientItemStateFactory;
+import org.apache.jackrabbit.jcr2spi.state.TransientISFactory;
+import org.apache.jackrabbit.jcr2spi.hierarchy.HierarchyEventListener;
+import org.apache.jackrabbit.jcr2spi.hierarchy.HierarchyManager;
+import org.apache.jackrabbit.jcr2spi.hierarchy.HierarchyManagerImpl;
-import org.apache.jackrabbit.name.MalformedPathException;
-import java.util.Collection;
-    private final ItemStateManager cache;
+    private final ItemStateFactory isf;
+    private final HierarchyManager hierarchyManager;
-        cache = createItemStateManager();
-
-
+
+        TransientItemStateFactory stateFactory = createItemStateFactory(ntRegistry);
+        this.isf = stateFactory;
+        this.hierarchyManager = createHierarchyManager(stateFactory, service.getIdFactory());
+        createHierarchyListener(hierarchyManager);
+    public HierarchyManager getHierarchyManager() {
+        return hierarchyManager;
+    }
+
+    public ItemStateFactory getItemStateFactory() {
+        return isf;
+    }
+
-    private ItemStateManager createItemStateManager() {
+    private TransientItemStateFactory createItemStateFactory(NodeTypeRegistry ntReg) {
-        WorkspaceItemStateManager ism = new WorkspaceItemStateManager(this, cacheBehaviour, isf, service.getIdFactory());
-        return ism;
+        TransientItemStateFactory tisf = new TransientISFactory(isf, ntReg);
+        return tisf;
+    }
+
+    /**
+     *
+     * @return
+     */
+    private HierarchyManager createHierarchyManager(TransientItemStateFactory tisf, IdFactory idFactory) {
+        return new HierarchyManagerImpl(tisf, idFactory);
+    }
+
+    /**
+     *
+     * @return
+     */
+    private InternalEventListener createHierarchyListener(HierarchyManager hierarchyMgr) {
+        InternalEventListener listener = new HierarchyEventListener(this, hierarchyMgr, cacheBehaviour);
+        return listener;
-    //---------------------------------------------------< ItemStateManager >---
-    /**
-     * @inheritDoc
-     * @see ItemStateManager#getRootState()
-     */
-    public NodeState getRootState() throws ItemStateException {
-        // retrieve through cache
-        synchronized (cache) {
-            return cache.getRootState();
-        }
-    }
-
-    /**
-     * @inheritDoc
-     * @see ItemStateManager#getItemState(ItemId)
-     */
-    public ItemState getItemState(ItemId id) throws NoSuchItemStateException, ItemStateException {
-        // retrieve through cache
-        synchronized (cache) {
-            return cache.getItemState(id);
-        }
-    }
-
-    /**
-     * @inheritDoc
-     * @see ItemStateManager#hasItemState(ItemId)
-     */
-    public boolean hasItemState(ItemId id) {
-        synchronized (cache) {
-            return cache.hasItemState(id);
-        }
-    }
-
-    /**
-     * @inheritDoc
-     * @see ItemStateManager#getReferingStates(NodeState)
-     * @param nodeState
-     */
-    public Collection getReferingStates(NodeState nodeState) throws ItemStateException {
-        synchronized (cache) {
-            return cache.getReferingStates(nodeState);
-        }
-    }
-
-    /**
-     * @inheritDoc
-     * @see ItemStateManager#hasReferingStates(NodeState)
-     * @param nodeState
-     */
-    public boolean hasReferingStates(NodeState nodeState) {
-        synchronized (cache) {
-            return cache.hasReferingStates(nodeState);
-        }
-    }
-
-    //------ updatable -:>> review ---------------------------------------------
+    //------------------------------------------< UpdatableItemStateManager >---
+    // TODO: review
-            operation.persisted();
+            operation.persisted(cacheBehaviour);
+        hierarchyManager.dispose();
-            log.warn("Exception while disposing session info: " + e);            
+            log.warn("Exception while disposing session info: " + e);
-        // TODO: TOBEFIXED. 
-        ItemState wspState = parentState.getWorkspaceState();
-        if (wspState == null) {
-            Path.PathBuilder pb = new Path.PathBuilder();
-            pb.addAll(relPath.getElements());
-            while (wspState == null) {
-                pb.addFirst(parentState.getQName());
-
-                parentState = parentState.getParent();
-                wspState = parentState.getWorkspaceState();
-            }
-            try {
-                relPath = pb.getPath();
-            } catch (MalformedPathException e) {
-                throw new RepositoryException(e);
-            }
-        }
-
-
-        if (wspState == null) {
-            // internal error. should never occur
-            throw new RepositoryException("Internal error: Unable to retrieve overlayed state in hierarchy.");
-        } else {
-            NodeId parentId = ((NodeState)parentState).getNodeId();
-            // TODO: 'createNodeId' is basically wrong since isGranted is unspecific for any item.
-            ItemId id = getIdFactory().createNodeId(parentId, relPath);
-            return service.isGranted(sessionInfo, id, actions);
-        }
+        // TODO: check again.
+        // build itemId from the given state and the relative path without
+        // making an attempt to retrieve the proper id of the item possibly
+        // identified by the resulting id.
+        // the server must be able to deal with paths and with proper ids anyway.
+        // TODO: 'createNodeId' is basically wrong since isGranted is unspecific for any item.
+        ItemId id = getIdFactory().createNodeId(parentState.getNodeId(), relPath);
+        return service.isGranted(sessionInfo, id, actions);
-                    log.info("executing: " + op);
+                    log.debug("executing " + op.getName());
-            log.info("executing: " + workspaceOperation);
+            log.debug("executing " + workspaceOperation.getName());
-            int type = operation.getPropertyType();
-                NodeId nId = operation.getNodeState().getNodeId();
+                NodeState nState = operation.getNodeState();
+                NodeId nId = nState.getNodeId();
-                PropertyState mergeFailedState = (PropertyState) cache.getItemState(
-                        getIdFactory().createPropertyId(nId, QName.JCR_MERGEFAILED));
-
+                PropertyState mergeFailedState = nState.getPropertyState(QName.JCR_MERGEFAILED);
-                PropertyState predecessorState = (PropertyState) cache.getItemState(
-                        getIdFactory().createPropertyId(nId, QName.JCR_PREDECESSORS));
-
+                PropertyState predecessorState = nState.getPropertyState(QName.JCR_PREDECESSORS);

JCR-2700 : Allow for wildcard restriction in resource-based ACEs

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@983906 13f79535-47bb-0310-9956-ffa450edef68

-import java.security.Principal;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
+import org.apache.jackrabbit.api.security.JackrabbitAccessControlEntry;
+import org.apache.jackrabbit.spi.Name;
+import org.apache.jackrabbit.spi.commons.conversion.NameResolver;
+import org.apache.jackrabbit.value.ValueHelper;
+import javax.jcr.NamespaceException;
+import javax.jcr.RepositoryException;
-
-import org.apache.jackrabbit.api.security.JackrabbitAccessControlEntry;
-import org.apache.jackrabbit.value.ValueHelper;
+import java.security.Principal;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
-    private final Map<String, Value> restrictions;
-
-    /**
-     * Value factory
-     */
-    private final ValueFactory valueFactory;
+    private final Map<Name, Value> restrictions;
+     * @throws RepositoryException if another error occurs.
-            throws AccessControlException {
-        this(principal, privileges, true, null, null);
+            throws AccessControlException, RepositoryException {
+        this(principal, privileges, true, null);
-     * @param valueFactory the value factory.
+     * @throws RepositoryException if another error occurs.
-                                     boolean isAllow, Map<String, Value> restrictions,
-                                     ValueFactory valueFactory)
-            throws AccessControlException {
+                                     boolean isAllow, Map<String, Value> restrictions)
+            throws AccessControlException, RepositoryException {
-        this.valueFactory = valueFactory;
-        
+
-            this.restrictions = new HashMap<String, Value>(restrictions.size());
+            this.restrictions = new HashMap<Name, Value>(restrictions.size());
-                value = ValueHelper.copy(value, valueFactory);
-                this.restrictions.put(key, value);
+                value = ValueHelper.copy(value, getValueFactory());
+                this.restrictions.put(getResolver().getQName(key), value);
+            }
+        }
+    }
+
+    /**
+     * 
+     * @param base
+     * @param privileges
+     * @param isAllow
+     * @throws AccessControlException
+     */
+    protected AccessControlEntryImpl(AccessControlEntryImpl base, Privilege[] privileges, boolean isAllow) throws AccessControlException {
+        // make sure no abstract privileges are passed.
+        for (Privilege privilege : privileges) {
+            if (privilege.isAbstract()) {
+                throw new AccessControlException("Privilege " + privilege + " is abstract.");
+            }
+        }
+        this.principal = base.principal;
+        this.privileges = privileges;
+        this.privilegeBits = PrivilegeRegistry.getBits(privileges);
+        this.allow = isAllow;
+
+        if (base.restrictions == null) {
+            this.restrictions = Collections.emptyMap();
+        } else {
+            this.restrictions = new HashMap<Name, Value>(base.restrictions.size());
+            // validate the passed restrictions and fill the map
+            for (Name name : restrictions.keySet()) {
+                Value value = restrictions.get(name);
+                value = ValueHelper.copy(value, getValueFactory());
+                this.restrictions.put(name, value);
+     * Returns the restrictions defined for this entry.
+     *
+     * @return the restrictions defined for this entry.
+     */
+    public Map<Name,Value> getRestrictions() {
+        return Collections.unmodifiableMap(restrictions);
+    }
+
+    /**
+     * @param restrictionName
+     * @return The restriction with the specified name or <code>null</code>.
+     */
+    public Value getRestriction(Name restrictionName) {
+        return ValueHelper.copy(restrictions.get(restrictionName), getValueFactory());
+    }
+
+    /**
+     * @return Returns the name resolver used to convert JCR names to Name and vice versa.
+     */
+    protected abstract NameResolver getResolver();
+
+    /**
+     * @return The value factory to be used.
+     */
+    protected abstract ValueFactory getValueFactory();
+
+    /**
-    public String[] getRestrictionNames() {
-        return restrictions.keySet().toArray(new String[restrictions.size()]);
+    public String[] getRestrictionNames() throws NamespaceException {
+        String[] restrNames = new String[restrictions.size()];
+        int i = 0;
+        for (Name n : restrictions.keySet()) {
+            restrNames[i] = getResolver().getJCRName(n);
+            i++;
+        }
+        return restrNames;
-    public Value getRestriction(String restrictionName) {
-        if (restrictions.containsKey(restrictionName)) {
-            return ValueHelper.copy(restrictions.get(restrictionName), valueFactory);
-        } else {
-            return null;
-        }
+    public Value getRestriction(String restrictionName) throws RepositoryException {
+        return getRestriction(getResolver().getQName(restrictionName));

Implement indexing of jcr:data property of nt:resource nodes.

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@160905 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.Constants;
+import org.apache.jackrabbit.core.search.TextFilterService;
+import org.apache.log4j.Logger;
+import java.util.Map;
+import java.io.Reader;
- *
- * todo add support for indexing of nt:resource. e.g. when mime type is text/*
+     * The logger instance for this class.
+     */
+    private static final Logger log = Logger.getLogger(NodeIndexer.class);
+
+    /**
+     * QName for jcr:encoding
+     */
+    private static final QName JCR_ENCODING = new QName(Constants.NS_JCR_URI, "encoding");
+
+    /**
+     * QName for jcr:mimeType
+     */
+    private static final QName JCR_MIMETYPE = new QName(Constants.NS_JCR_URI, "mimeType");
+
+    /**
+     * QName for jcr:data
+     */
+    private static final QName JCR_DATA = new QName(Constants.NS_JCR_URI, "data");
+
+    /**
+
-     * This implementation does nothing as binary indexing is not implemented
-     * here.
+     * This implementation checks if this {@link #node} is of type nt:resource
+     * and if that is the case, tries to extract text from the data atom using
+     * {@link TextFilterService}add a {@link FieldNames#FULLTEXT} field
+     * .
-        // don't know how to index -> ignore
+        // 'check' if node is of type nt:resource
+        try {
+            String jcrData = mappings.getPrefix(Constants.NS_JCR_URI) + ":data";
+            if (!jcrData.equals(fieldName)) {
+                // don't know how to index
+                return;
+            }
+            if (node.hasPropertyEntry(JCR_ENCODING)
+                    && node.hasPropertyEntry(JCR_MIMETYPE)) {
+                PropertyState dataProp = (PropertyState) stateProvider.getItemState(new PropertyId(node.getUUID(), JCR_DATA));
+                PropertyState mimeTypeProp = (PropertyState) stateProvider.getItemState(new PropertyId(node.getUUID(), JCR_MIMETYPE));
+                PropertyState encodingProp = (PropertyState) stateProvider.getItemState(new PropertyId(node.getUUID(), JCR_ENCODING));
+
+                Map fields = TextFilterService.extractText(dataProp,
+                        mimeTypeProp.getValues()[0].internalValue().toString(),
+                        encodingProp.getValues()[0].internalValue().toString());
+                for (Iterator it = fields.keySet().iterator(); it.hasNext();) {
+                    String field = (String) it.next();
+                    Reader r = (Reader) fields.get(field);
+                    doc.add(Field.Text(field, r));
+                }
+            }
+        } catch (ItemStateException e) {
+            log.warn("Exception while indexing binary property: " + e.toString());
+            log.debug("Dump: ", e);
+        } catch (RepositoryException e) {
+            log.warn("Exception while indexing binary property: " + e.toString());
+            log.debug("Dump: ", e);
+        }

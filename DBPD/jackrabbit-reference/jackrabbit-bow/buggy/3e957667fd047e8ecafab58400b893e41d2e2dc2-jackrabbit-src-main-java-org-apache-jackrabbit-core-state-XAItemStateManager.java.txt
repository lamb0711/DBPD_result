Make versioning transactional
- Added specialized XAVersion and XAVersionHistory objects that refresh their internal state when needed
- Defined new observation interface in order to have VersionManagerImpl use standard event dispatching
  instead of writing its own
- Added test cases verifying isolation of versioning operations in transactions


git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@368026 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.WorkspaceImpl;
+import org.apache.jackrabbit.core.PropertyId;
+import org.apache.jackrabbit.core.NodeId;
+import org.apache.jackrabbit.core.observation.EventStateCollectionFactory;
+import org.apache.jackrabbit.core.value.InternalValue;
+import org.apache.jackrabbit.core.virtual.VirtualItemStateProvider;
+import javax.jcr.PropertyType;
+import java.util.Iterator;
+     * Current update operation.
+     */
+    private transient SharedItemStateManager.Update update;
+
+    /**
+     * Optional virtual item state provider.
+     */
+    private VirtualItemStateProvider virtualProvider;
+
+    /**
+     *
-     * @param wspImpl workspace
+     * @param factory        event state collection factory
-                              WorkspaceImpl wspImpl) {
-        this(sharedStateMgr, wspImpl, DEFAULT_ATTRIBUTE_NAME);
+                              EventStateCollectionFactory factory) {
+        this(sharedStateMgr, factory, DEFAULT_ATTRIBUTE_NAME);
+     *
-     * @param wspImpl workspace
-     * @param attributeName attribute name
+     * @param factory        event state collection factory
+     * @param attributeName  attribute name
-                              WorkspaceImpl wspImpl, String attributeName) {
-        super(sharedStateMgr, wspImpl);
+                              EventStateCollectionFactory factory,
+                              String attributeName) {
+        super(sharedStateMgr, factory);
+     * Set optional virtual item state provider.
+     */
+    public void setVirtualProvider(VirtualItemStateProvider virtualProvider) {
+        this.virtualProvider = virtualProvider;
+    }
+
+    /**
+    public void beforeOperation(TransactionContext tx) {
+        ChangeLog txLog = (ChangeLog) tx.getAttribute(attributeName);
+        if (txLog != null) {
+            ((CommitLog) commitLog.get()).setChanges(txLog);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
-                ((CommitLog) commitLog.get()).setChanges(txLog);
-                sharedStateMgr.checkReferentialIntegrity(txLog);
+                if (virtualProvider != null) {
+                    updateVirtualReferences(txLog);
+                }
+                update = sharedStateMgr.beginUpdate(txLog, factory, virtualProvider);
-            } finally {
-                ((CommitLog) commitLog.get()).setChanges(null);
-                ((CommitLog) commitLog.get()).setChanges(txLog);
-                super.update(txLog);
-            } catch (ReferentialIntegrityException rie) {
-                log.error(rie);
-                txLog.undo(sharedStateMgr);
-                throw new TransactionException("Unable to commit transaction.", rie);
+                update.end();
-            } finally {
-                ((CommitLog) commitLog.get()).setChanges(null);
-            try {
-                ((CommitLog) commitLog.get()).setChanges(txLog);
-                txLog.undo(sharedStateMgr);
-            } finally {
-                ((CommitLog) commitLog.get()).setChanges(null);
+            if (update != null) {
+                update.cancel();
+            txLog.undo(sharedStateMgr);
+     * {@inheritDoc}
+     */
+    public void afterOperation(TransactionContext tx) {
+        ((CommitLog) commitLog.get()).setChanges(null);
+    }
+
+    /**
+        if (virtualProvider != null && virtualProvider.hasItemState(id)) {
+            return virtualProvider.getItemState(id);
+        }
+        if (virtualProvider != null && virtualProvider.hasItemState(id)) {
+            return true;
+        }
+        if (virtualProvider != null && virtualProvider.hasNodeReferences(id)) {
+            return virtualProvider.getNodeReferences(id);
+        }
+        if (virtualProvider != null && virtualProvider.hasNodeReferences(id)) {
+            return true;
+        }
+    //-------------------------------------------------------< implementation >
+
+    /**
+     * Determine all node references whose targets only exist in the view of
+     * this transaction and store the modified view back to the virtual provider.
+     * @param changes change log
+     * @throws ItemStateException if an error occurs
+     */
+    private void updateVirtualReferences(ChangeLog changes) throws ItemStateException {
+        for (Iterator iter = changes.addedStates(); iter.hasNext();) {
+            ItemState state = (ItemState) iter.next();
+            if (!state.isNode()) {
+                PropertyState prop = (PropertyState) state;
+                if (prop.getType() == PropertyType.REFERENCE) {
+                    InternalValue[] vals = prop.getValues();
+                    for (int i = 0; vals != null && i < vals.length; i++) {
+                        String uuid = vals[i].toString();
+                        NodeReferencesId refsId = new NodeReferencesId(uuid);
+                        addVirtualReference((PropertyId) prop.getId(), refsId);
+                    }
+                }
+            }
+        }
+        for (Iterator iter = changes.modifiedStates(); iter.hasNext();) {
+            ItemState state = (ItemState) iter.next();
+            if (!state.isNode()) {
+                PropertyState newProp = (PropertyState) state;
+                PropertyState oldProp =
+                        (PropertyState) getItemState(state.getId());
+                if (oldProp.getType() == PropertyType.REFERENCE) {
+                    InternalValue[] vals = oldProp.getValues();
+                    for (int i = 0; vals != null && i < vals.length; i++) {
+                        String uuid = vals[i].toString();
+                        NodeReferencesId refsId = new NodeReferencesId(uuid);
+                        removeVirtualReference((PropertyId) oldProp.getId(), refsId);
+                    }
+                }
+                if (newProp.getType() == PropertyType.REFERENCE) {
+                    InternalValue[] vals = newProp.getValues();
+                    for (int i = 0; vals != null && i < vals.length; i++) {
+                        String uuid = vals[i].toString();
+                        NodeReferencesId refsId = new NodeReferencesId(uuid);
+                        addVirtualReference((PropertyId) newProp.getId(), refsId);
+                    }
+                }
+            }
+        }
+        for (Iterator iter = changes.deletedStates(); iter.hasNext();) {
+            ItemState state = (ItemState) iter.next();
+            if (!state.isNode()) {
+                PropertyState prop = (PropertyState) state;
+                if (prop.getType() == PropertyType.REFERENCE) {
+                    InternalValue[] vals = prop.getValues();
+                    for (int i = 0; vals != null && i < vals.length; i++) {
+                        String uuid = vals[i].toString();
+                        NodeReferencesId refsId = new NodeReferencesId(uuid);
+                        removeVirtualReference((PropertyId) prop.getId(), refsId);
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Add a virtual reference from some reference property to a virtual node.
+     * Ignored if <code>targetId</code> does not actually point to a virtual
+     * node.
+     * @param sourceId property id
+     * @param targetId node references id
+     */
+    private void addVirtualReference(PropertyId sourceId,
+                                     NodeReferencesId targetId)
+            throws NoSuchItemStateException, ItemStateException {
+
+        NodeReferences refs = virtualProvider.getNodeReferences(targetId);
+        if (refs == null && virtualProvider.hasItemState(new NodeId(targetId.getUUID()))) {
+            refs = new NodeReferences(targetId);
+        }
+        if (refs != null) {
+            refs.addReference(sourceId);
+            virtualProvider.setNodeReferences(refs);
+        }
+    }
+
+    /**
+     * Remove a virtual reference from some reference property to a virtual node.
+     * Ignored if <code>targetId</code> does not actually point to a virtual
+     * node.
+     * @param sourceId property id
+     * @param targetId node references id
+     */
+    private void removeVirtualReference(PropertyId sourceId,
+                                        NodeReferencesId targetId)
+            throws NoSuchItemStateException, ItemStateException {
+
+        NodeReferences refs = virtualProvider.getNodeReferences(targetId);
+        if (refs == null && virtualProvider.hasItemState(new NodeId(targetId.getUUID()))) {
+            refs = new NodeReferences(targetId);
+        }
+        if (refs != null) {
+            refs.removeReference(sourceId);
+            virtualProvider.setNodeReferences(refs);
+        }
+    }
+

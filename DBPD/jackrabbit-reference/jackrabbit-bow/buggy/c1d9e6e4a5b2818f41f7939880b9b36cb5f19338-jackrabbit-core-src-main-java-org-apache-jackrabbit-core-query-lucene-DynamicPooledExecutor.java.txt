JCR-2089: Use java.util.concurrent

Use java.util.concurrent constructs in DynamicPooledExecutor.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@995451 13f79535-47bb-0310-9956-ffa450edef68

-import EDU.oswego.cs.dl.util.concurrent.PooledExecutor;
-import EDU.oswego.cs.dl.util.concurrent.FutureResult;
-import EDU.oswego.cs.dl.util.concurrent.Callable;
-
-import java.lang.reflect.InvocationTargetException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
-public class DynamicPooledExecutor {
+public class DynamicPooledExecutor implements Executor {
-    private final PooledExecutor executor;
+    private final ThreadPoolExecutor executor;
-     * Timestamp when the pool size was last checked.
+     * The time (in milliseconds) when the pool size was last checked.
-    private volatile long lastCheck;
-
-    /**
-     * The number of processors.
-     */
-    private volatile int numProcessors;
+    private long lastCheck;
-        executor = new PooledExecutor();
-        executor.setKeepAliveTime(500);
-        adjustPoolSize();
+        this.executor = new ThreadPoolExecutor(
+                0, Runtime.getRuntime().availableProcessors(),
+                500, TimeUnit.MILLISECONDS,
+                new LinkedBlockingQueue<Runnable>());
+        this.lastCheck = System.currentTimeMillis();
+    }
+
+    /**
+     * Adjusts the pool size at most once every second.
+     */
+    private synchronized void adjustPoolSize() {
+        long now = System.currentTimeMillis();
+        if (lastCheck + 1000 < now) {
+            int n = Runtime.getRuntime().availableProcessors();
+            if (n != executor.getMaximumPoolSize()) {
+                executor.setMaximumPoolSize(n);
+            }
+            lastCheck = now;
+        }
-        if (numProcessors == 1) {
+        if (executor.getMaximumPoolSize() == 1) {
-            try {
-                executor.execute(command);
-            } catch (InterruptedException e) {
-                // run with current thread instead
-                command.run();
-            }
+            executor.execute(command);
-    /**
-     * Executes a set of commands and waits until all commands have been
-     * executed. The results of the commands are returned in the same order as
-     * the commands.
-     *
-     * @param commands the commands to execute.
-     * @return the results.
-     */
-    public Result[] executeAndWait(Command[] commands) {
-        Result[] results = new Result[commands.length];
-        if (numProcessors == 1) {
-            // optimize for one processor
-            for (int i = 0; i < commands.length; i++) {
-                Object obj = null;
-                InvocationTargetException ex = null;
-                try {
-                    obj = commands[i].call();
-                } catch (Exception e) {
-                    ex = new InvocationTargetException(e);
-                }
-                results[i] = new Result(obj, ex);
-            }
-        } else {
-            FutureResult[] futures = new FutureResult[commands.length];
-            for (int i = 0; i < commands.length; i++) {
-                final Command c = commands[i];
-                futures[i] = new FutureResult();
-                Runnable r = futures[i].setter(new Callable() {
-                    public Object call() throws Exception {
-                        return c.call();
-                    }
-                });
-                try {
-                    executor.execute(r);
-                } catch (InterruptedException e) {
-                    // run with current thread instead
-                    r.run();
-                }
-            }
-            // wait for all results
-            boolean interrupted = false;
-            for (int i = 0; i < futures.length; i++) {
-                Object obj = null;
-                InvocationTargetException ex = null;
-                for (;;) {
-                    try {
-                        obj = futures[i].get();
-                    } catch (InterruptedException e) {
-                        interrupted = true;
-                        // reset interrupted status and try again
-                        Thread.interrupted();
-                        continue;
-                    } catch (InvocationTargetException e) {
-                        ex = e;
-                    }
-                    results[i] = new Result(obj, ex);
-                    break;
-                }
-            }
-            if (interrupted) {
-                // restore interrupt status again
-                Thread.currentThread().interrupt();
-            }
-        }
-        return results;
-    }
-
-    /**
-     * Adjusts the pool size at most once every second.
-     */
-    private void adjustPoolSize() {
-        if (lastCheck + 1000 < System.currentTimeMillis()) {
-            int n = Runtime.getRuntime().availableProcessors();
-            if (numProcessors != n) {
-                executor.setMaximumPoolSize(n);
-                numProcessors = n;
-            }
-            lastCheck = System.currentTimeMillis();
-        }
-    }
-
-    public interface Command {
-
-        /**
-         * Perform some action that returns a result or throws an exception
-         */
-        Object call() throws Exception;
-    }
-
-    public static class Result {
-
-        /**
-         * The result object or <code>null</code> if an exception was thrown.
-         */
-        private final Object object;
-
-        /**
-         * The exception or <code>null</code> if no exception was thrown.
-         */
-        private final InvocationTargetException exception;
-
-        private Result(Object object, InvocationTargetException exception) {
-            this.object = object;
-            this.exception = exception;
-        }
-
-        /**
-         * @return the result object or <code>null</code> if an exception was
-         *         thrown.
-         */
-        public Object get() {
-            return object;
-        }
-
-        /**
-         * @return the exception or <code>null</code> if no exception was
-         *         thrown.
-         */
-        public InvocationTargetException getException() {
-            return exception;
-        }
-    }

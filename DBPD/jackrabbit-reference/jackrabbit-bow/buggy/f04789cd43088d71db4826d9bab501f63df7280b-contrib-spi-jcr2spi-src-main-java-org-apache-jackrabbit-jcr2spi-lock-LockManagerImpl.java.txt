work in progress

jcr2spi
- HierarchyManager: fixing methods with ItemId param
- HierarchyManagerImpl(s): removing unused methods
- ItemManagerImpl: replacing NodeId as cacheKey
- ItemImpl: remove ISM field

jcr2spi/xml
- ImporterImpl renamed to SessionImporter (used for s-import only)
- xml import: Use UUID String instead of creating NodeIds
- ReferenceChangeTracker: remove usage of spi NodeId

jcr2spi/state
- SessionItemStateManager: ValueFactory not needed since QPropertyDefinition returns qualified values.

jcr2spi/util
- LogUtil: add 'saveGetJCRName' utility method

jcr2spi/locking
- locking: LockManager to use NodeState instead of NodeId
- locking: removing locktoken from Session checks if Session is lock holder

jcr2spi/query
- NodeIteratorImpl: fix commented code, that allows to retrieve
  search results from IdIterator returned from QueryInfo
- minor reformatting, javadoc

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@430791 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.IdKeyMap;
-import org.apache.jackrabbit.jcr2spi.DefaultIdKeyMap;
-import org.apache.jackrabbit.jcr2spi.state.ItemStateException;
-import org.apache.jackrabbit.spi.NodeId;
-import org.apache.jackrabbit.spi.ItemId;
+import java.util.Map;
+import java.util.HashMap;
-     * Internal map holding all locks that where created by
-     * {@link #lock(NodeId, Node, boolean, boolean)}
-     * or accessed by {@link #getLock(NodeId)} until they end their life by
-     * an unlock (be it by the current Session or external reported by means
-     * of events).
+     * Map holding all locks that where created by this <code>Session</code> upon
+     * calls to {@link LockManager#lock(NodeState,boolean,boolean)} or to
+     * {@link LockManager#getLock(NodeState)}. The map entries are removed
+     * only if a lock ends his life by {@link Node#unlock()} or by implicit
+     * unlock upon {@link Session#logout()}.
-    // TODO: TO-BE-FIXED. With SPI_ItemId simple map cannot be used any more
-    private final IdKeyMap lockMap = new DefaultIdKeyMap();
+    private final Map lockMap;
+        // use hard references in order to make sure, that entries refering
+        // to locks created by the current session are not removed.
+        lockMap = new HashMap();
-     * @see LockManager#lock(NodeId, Node, boolean, boolean)
+     * @see LockManager#lock(NodeState,boolean,boolean)
-    public Lock lock(NodeId nodeId, Node node, boolean isDeep, boolean isSessionScoped) throws LockException, RepositoryException {
+    public Lock lock(NodeState nodeState, boolean isDeep, boolean isSessionScoped) throws LockException, RepositoryException {
+        // retrieve node first
+        Node lhNode;
+        Item item = itemManager.getItem(nodeState);
+        if (item.isNode()) {
+            lhNode = (Node) item;
+        } else {
+            throw new RepositoryException("Internal error: ItemManager returned Property from NodeState");
+        }
+
-        Operation op = LockOperation.create(nodeId, isDeep, isSessionScoped);
+        Operation op = LockOperation.create(nodeState.getNodeId(), isDeep, isSessionScoped);
-        Lock lock = new LockImpl(nodeId, node, isSessionScoped);
+        Lock lock = new LockImpl(nodeState, lhNode, isSessionScoped);
-     * @see LockManager#getLock(NodeId)
+     * @see LockManager#getLock(NodeState)
+     * @param nodeState
-    public Lock getLock(NodeId nodeId) throws LockException, RepositoryException {
-        // shortcut: check if node holds a lock and lock has been accessed before
-        if (lockMap.containsKey(nodeId)) {
-            return (Lock) lockMap.get(nodeId);
+    public Lock getLock(NodeState nodeState) throws LockException, RepositoryException {
+        // shortcut: check if lock has been accessed before
+        if (lockMap.containsKey(nodeState)) {
+            return (Lock) lockMap.get(nodeState);
-        NodeState lockHoldingState = getLockHoldingState(nodeId);
+        NodeState lockHoldingState = getLockHoldingState(nodeState);
-            throw new LockException("Node with id '" + nodeId + "' is not locked.");
+            throw new LockException("Node with id '" + nodeState.getNodeId() + "' is not locked.");
-            NodeId lhNodeId = lockHoldingState.getNodeId();
-            // check again lockMap with id of lockholding node
-            if (lockMap.containsKey(lhNodeId)) {
-                return (Lock) lockMap.get(lhNodeId);
+            // check lockMap again with the lockholding state
+            if (lockMap.containsKey(lockHoldingState)) {
+                return (Lock) lockMap.get(lockHoldingState);
-            // retrieve lock holding node. not that this may fail if the session
+            // retrieve lock holding node. note that this may fail if the session
-            Lock l = new LockImpl(lhNodeId, (Node)lockHoldingNode, false);
+            Lock l = new LockImpl(lockHoldingState, (Node)lockHoldingNode, false);
-     * @see LockManager#unlock(NodeId)
+     * @see LockManager#unlock(NodeState)
+     * @param nodeState
-    public void unlock(NodeId nodeId) throws LockException, RepositoryException {
+    public void unlock(NodeState nodeState) throws LockException, RepositoryException {
-        // does not provide sufficient information.
-        Operation op = LockRelease.create(nodeId);
+        // does not provide sufficient and relyable information.
+        Operation op = LockRelease.create(nodeState.getNodeId());
-        if (lockMap.containsKey(nodeId)) {
-            LockImpl l = (LockImpl) lockMap.remove(nodeId);
+        if (lockMap.containsKey(nodeState)) {
+            LockImpl l = (LockImpl) lockMap.remove(nodeState);
-     * @see LockManager#isLocked(NodeId)
+     * @see LockManager#isLocked(NodeState)
+     * @param nodeState
-    public boolean isLocked(NodeId nodeId) throws RepositoryException {
+    public boolean isLocked(NodeState nodeState) throws RepositoryException {
-        if (lockMap.containsKey(nodeId)) {
+        if (lockMap.containsKey(nodeState)) {
-            LockInfo lInfo = getLockInfo(nodeId);
+            LockInfo lInfo = getLockInfo(nodeState);
-     * @see LockManager#checkLock(NodeId)
+     * @see LockManager#checkLock(NodeState)
+     * @param nodeState
-    public void checkLock(NodeId nodeId) throws LockException, RepositoryException {
+    public void checkLock(NodeState nodeState) throws LockException, RepositoryException {
-        if (lockMap.containsKey(nodeId)) {
-            lInfo = ((LockImpl)lockMap.get(nodeId)).lockInfo;
+        if (lockMap.containsKey(nodeState)) {
+            lInfo = ((LockImpl)lockMap.get(nodeState)).lockInfo;
-            lInfo = getLockInfo(nodeId);
+            lInfo = getLockInfo(nodeState);
-            throw new LockException("Node with id '" + nodeId + "' is locked.");
+            throw new LockException("Node with id '" + nodeState + "' is locked.");
-        NodeId key = null;
-        while (it.hasNext() && key == null) {
+        boolean found = false;
+        // loop over cached locks to determine if the token belongs to a session
+        // scoped lock, in which case the removal must fail immediately.
+        while (it.hasNext() && !found) {
-            // break as soon as the lock associated with the given token is found.
+                // break as soon as the lock associated with the given token was found.
+                found = true;
-                key = l.nodeId;
+        if (!found) {
+            String msg = "Unable to remove lock token: lock is held by another session.";
+            log.warn(msg);
+            throw new RepositoryException(msg);
+        }
+
-        ItemId[] ids = (ItemId[]) lockMap.keySet().toArray(new ItemId[lockMap.size()]);
-        for (int i = 0; i < ids.length; i++) {
-            NodeId nId = (NodeId) ids[i];
-            LockImpl l = (LockImpl) lockMap.get(nId);
+        NodeState[] lhStates = (NodeState[]) lockMap.keySet().toArray(new NodeState[lockMap.size()]);
+        for (int i = 0; i < lhStates.length; i++) {
+            NodeState nState = (NodeState) lhStates[i];
+            LockImpl l = (LockImpl) lockMap.get(nState);
-                    unlock(nId);
+                    unlock(nState);
-     * @param nodeId
+     * @param nodeState
-    private LockInfo getLockInfo(NodeId nodeId) throws RepositoryException {
+    private LockInfo getLockInfo(NodeState nodeState) throws RepositoryException {
-            return wspManager.getLockInfo(nodeId);
+            return wspManager.getLockInfo(nodeState.getNodeId());
-            log.debug("No lock present on node with id '" + nodeId + "'", e);
+            log.debug("No lock present on node with id '" + nodeState.getNodeId() + "'", e);
+     * Search nearest ancestor that is locked. Returns <code>null</code> if no
+     * lock ancestor could be found.
-     * @param nodeId
-     * @return
-     * @throws RepositoryException
+     * @param nodeState <code>NodeState</code> from which searching starts.
+     * @return lock ancestor node or <code>null</code>.
-    private NodeState getLockHoldingState(NodeId nodeId) throws RepositoryException {
-        try {
-            NodeState nodeState = (NodeState) wspManager.getItemState(nodeId);
-            // search nearest ancestor that is locked
-            /**
-             * FIXME should not only rely on existence of jcr:lockOwner property
-             * but also verify that node.isNodeType("mix:lockable")==true;
-             * this would have a negative impact on performance though...
-             */
-            while (!nodeState.hasPropertyName(QName.JCR_LOCKOWNER)) {
-                NodeState parentState = nodeState.getParent();
-                if (parentState == null) {
-                    // reached root state without finding a locked node
-                    return null;
-                }
-                nodeState = parentState;
+    private NodeState getLockHoldingState(NodeState nodeState) {
+        /**
+         * FIXME should not only rely on existence of jcr:lockIsDeep property
+         * but also verify that node.isNodeType("mix:lockable")==true;
+         * this would have a negative impact on performance though...
+         */
+        while (!nodeState.hasPropertyName(QName.JCR_LOCKISDEEP)) {
+            NodeState parentState = nodeState.getParent();
+            if (parentState == null) {
+                // reached root state without finding a locked node
+                return null;
-            return nodeState;
-        } catch (ItemStateException e) {
-            // should not occur
-            throw new RepositoryException(e);
+            nodeState = parentState;
+        return nodeState;
-        private final NodeId nodeId;
+        private final NodeState lockHoldingState;
-         * @param lockHoldingId The Id of the lock holding <code>Node</code>.
+         * @param lockHoldingState The NodeState of the lock holding <code>Node</code>.
-        public LockImpl(NodeId lockHoldingId, Node lockHoldingNode, boolean isSessionScoped) throws LockException, RepositoryException {
-            this.nodeId = lockHoldingId;
+        public LockImpl(NodeState lockHoldingState, Node lockHoldingNode, boolean isSessionScoped) throws LockException, RepositoryException {
+            this.lockHoldingState = lockHoldingState;
-            this.lockInfo = wspManager.getLockInfo(nodeId);
+            this.lockInfo = wspManager.getLockInfo(lockHoldingState.getNodeId());
-            lockMap.put(nodeId, this);
+            lockMap.put(lockHoldingState, this);
-                Operation op = LockRefresh.create(nodeId);
+                Operation op = LockRefresh.create(lockHoldingState.getNodeId());
-        //----------------------------------------------< InternalEventListener >---
+        //------------------------------------------< InternalEventListener >---
-                // since only we only monitor the removal of the lock (by means
-                // of deletion of the jcr:lockOwner property, we are not interested
+                // since we only monitor the removal of the lock (by means
+                // of deletion of the jcr:lockIsDeep property, we are not interested
-                // if the jcr:lockOwner property related to this Lock got removed,
+                // if the jcr:lockIsDeep property related to this Lock got removed,
-                if (ev.getType() == Event.PROPERTY_REMOVED &&
-                    nodeId.equals(ev.getParentId()) &&
-                    QName.JCR_LOCKOWNER.equals(ev.getQPath().getNameElement().getName())) {
-                    // TODO: check if removal jcr:lockIsDeep must be checked as well.
+                // TODO: not correct to compare nodeIds
+                if (ev.getType() == Event.PROPERTY_REMOVED
+                    && QName.JCR_LOCKISDEEP.equals(ev.getQPath().getNameElement().getName())
+                    && lockHoldingState.getNodeId().equals(ev.getParentId())) {
+                // TODO: JSR 283 defines that Lock-Owner is reset upon moved lt
+        //----------------------------------------------< LockTokenListener >---
+         * A lock token as been added to the current Session. If this Lock
+         * object is not yet hold by the Session (thus does not know whether
+         * the new lock token belongs to it), it must reload the LockInfo
+         * from the server.
+         * @see LockTokenListener#lockTokenAdded(String)
-                // lock holder -> releoad info
+                // lock holder -> releoad info to assert.
+         * @see LockTokenListener#lockTokenRemoved(String)
-            // reload lock info, if session gave away its lock-holder state
-            // for this lock
+            // reload lock info, if session gave away its lock-holder status
+            // for this lock.
+         * Reload the lockInfo from the server.
-            // re-check with server, since Session.addLockToken will not
-            // automatically result in an update of the lock-map.
-            lockInfo = wspManager.getLockInfo(nodeId);
+            lockInfo = wspManager.getLockInfo(lockHoldingState.getNodeId());
-            if (lockMap.containsKey(nodeId)) {
-                lockMap.remove(nodeId);
+            if (lockMap.containsKey(lockHoldingState)) {
+                lockMap.remove(lockHoldingState);

JCR-3838:  [aws-ext] Proactive & Asynchronous caching of binary when its metadata is accessed from S3
Patch from Shashank

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1644549 13f79535-47bb-0310-9956-ffa450edef68

+ *     &lt;param name="{@link #setProactiveCaching(boolean) proactiveCaching}" value="true"/>
+    /**
+     * In memory map to hold in-progress asynchronous downloads. Once
+     * download is finished corresponding entry is flushed from the map.
+     */
+    protected final Map<DataIdentifier, Long> asyncDownloadCache = new ConcurrentHashMap<DataIdentifier, Long>(5);
+
+     * Flag to indicate that binary content will be cached proactively and
+     * asynchronously when binary metadata is retrieved from {@link Backend}.
+     */
+    private boolean proactiveCaching = true;
+
+    /**
+    /**
+     * {@link ExecutorService} to asynchronous downloads
+     */
+    private ExecutorService downloadExecService;
+
+            downloadExecService = Executors.newFixedThreadPool(5,
+                new NamedThreadFactory("backend-file-download-worker"));
+        boolean existsAtBackend = false;
-                || backend.exists(identifier)) {
-                LOG.debug("[{}] record retrieved from local cache or backend",
-                    identifier);
+                || (existsAtBackend = backend.exists(identifier))) {
+                if (existsAtBackend) {
+                    LOG.debug("[{}] record retrieved from backend", identifier);
+                    asyncDownload(identifier);
+                } else {
+                    LOG.debug("[{}] record retrieved from local cache",
+                        identifier);
+                }
-
+            asyncDownload(identifier);
-    public long getLength(DataIdentifier identifier) throws DataStoreException {
+    public long getLength(final DataIdentifier identifier)
+            throws DataStoreException {
-            return backend.getLength(identifier);
+            length = backend.getLength(identifier);
+            asyncDownload(identifier);
+            return length;
+    /**
+     * Invoke {@link #getStream(DataIdentifier)} asynchronously to cache binary
+     * asynchronously.
+     */
+    private void asyncDownload(final DataIdentifier identifier) {
+        if (proactiveCaching
+            && cacheSize != 0
+            && asyncDownloadCache.put(identifier, System.currentTimeMillis()) == null) {
+            downloadExecService.execute(new Runnable() {
+                @Override
+                public void run() {
+                    InputStream input = null;
+                    try {
+                        // getStream to cache file
+                        LOG.debug("Async download [{}] started.", identifier);
+                        input = getStream(identifier);
+                    } catch (RepositoryException re) {
+                        // ignore exception
+                    } finally {
+                        asyncDownloadCache.remove(identifier);
+                        IOUtils.closeQuietly(input);
+                        LOG.debug("Async download [{}] completed.", identifier);
+                    }
+                }
+            });
+        }
+    }
+        downloadExecService.shutdown();
-    
-    
+    public void setProactiveCaching(boolean proactiveCaching) {
+        this.proactiveCaching = proactiveCaching;
+    }
+

JCR-2113 : WIP (Contribution by Alfusainey Jallow)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1640892 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.Name;
+import javax.jcr.ValueFormatException;
+import javax.jcr.nodetype.NodeDefinition;
+import javax.jcr.nodetype.NodeTypeManager;
+import javax.jcr.nodetype.PropertyDefinition;
+    private NodeTypeManager ntManager;
+
+    @Override
+    @Override
+    @Override
+    @Override
+    private NodeTypeManager getNodeTypeManager() throws RepositoryException {
+        if (ntManager == null) {
+            ntManager = session.getWorkspace().getNodeTypeManager();
+        }
+        return ntManager;
+    }
+
-    
+
+    private static ContentHandler createContentHandler(Node parent) throws RepositoryException {
+        return parent.getSession().getImportContentHandler(parent.getPath(), ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW);
+    }
+
-        ContentHandler ch = parent.getSession().getImportContentHandler(parent.getPath(), ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW);
+        ContentHandler ch = createContentHandler(parent);
+        @Override
+        @Override
+        @Override
+        @Override
+        @Override
+        @Override
+        @Override
+        @Override
+        @Override
+        @Override
+        @Override
+        @Override
+        @Override
+        @Override
+        @Override
+        @Override
+        @Override
+        @Override
+        @Override
+        @Override
-                    obj.createItem(parent);                    
+                    if (obj.mandatesImport(parent)) {
+                        obj.importItem(createContentHandler(parent));
+                    } else {
+                        obj.createItem(parent);
+                    }
+                } catch (IOException e) {
+                    log.error(e.getMessage());
+                    throw new DiffException(e.getMessage(), e);
+        @Override
+        @Override
+        @Override
+        @Override
+        @Override
+        @Override
+        @Override
+
+        static final String TYPE_CDATA = "CDATA";
+
+
+        
+        void setNameAttribute(AttributesImpl attr) {
+            attr.addAttribute(Name.NS_SV_URI, "name", Name.NS_SV_PREFIX +":name", TYPE_CDATA, name);
+        }
-        abstract void createItem(Node parent) throws RepositoryException;
+        abstract boolean mandatesImport(Node parent);
+
+        abstract void createItem(Node parent) throws RepositoryException, IOException;
+
+        abstract void importItem(ContentHandler contentHandler) throws IOException;
-        private String ntName;
-        private String uuid;
+
+        private static final String LOCAL_NAME = "node";
+
+        private ImportProp ntName;
+        private ImportProp uuid;
-        private List<ImportItem> childP = new ArrayList<ImportItem>();
+        private List<ImportProperty> childP = new ArrayList<ImportProperty>();
+        private String getUUID() {
+            if (uuid != null && uuid.value != null) {
+                try {
+                    return uuid.value.getString();
+                } catch (RepositoryException e) {
+                    log.error(e.getMessage());
+                }
+            }
+            return null;
+        }
+
+        private String getPrimaryType() {
+            if (ntName != null && ntName.value != null) {
+                try {
+                    return ntName.value.getString();
+                } catch (RepositoryException e) {
+                    log.error(e.getMessage());
+                }
+            }
+            return null;
+        }
+
+        @Override
+        boolean mandatesImport(Node parent) {
+            String primaryType = getPrimaryType();
+            // Very simplistic and simplified test for protection that doesn't
+            // take mixin types into account and ignores all JCR primary types
+            if (!primaryType.startsWith(Name.NS_NT_PREFIX)) {
+                try {
+                    NodeType nt = getNodeTypeManager().getNodeType(primaryType);
+                    for (NodeDefinition nd : nt.getChildNodeDefinitions()) {
+                        if (nd.isProtected()) {
+                            return true;
+                        }
+                    }
+                    for (PropertyDefinition pd : nt.getPropertyDefinitions()) {
+                        if (!pd.getName().startsWith(Name.NS_JCR_PREFIX) && pd.isProtected()) {
+                            return true;
+                        }
+                    }
+                } catch (RepositoryException e) {
+                    log.warn(e.getMessage(), e);
+                }
+            }
+            return false;
+        }
+
-                try {
-                    ntName = (prop.value == null) ? null : prop.value.getString();
-                } catch (RepositoryException e) {
-                    // should never get here. Value.getString() should always succeed.
-                    log.error(e.getMessage());
-                }
+                ntName = prop;
-                try {
-                    uuid = (prop.value == null) ? null : prop.value.getString();
-                } catch (RepositoryException e) {
-                    // should never get here. Value.getString() should always succeed.
-                    log.error(e.getMessage());
-                }
+                uuid = prop;
-        void createItem(Node parent) throws RepositoryException {
-            Node n;
-            if (uuid == null) {
-                n = (ntName == null) ? parent.addNode(name) : parent.addNode(name,  ntName);
+        void importItem(ContentHandler contentHandler) throws IOException {
+            try {
+                AttributesImpl attr = new AttributesImpl();
+                setNameAttribute(attr);
+                contentHandler.startElement(Name.NS_SV_URI, LOCAL_NAME, Name.NS_SV_PREFIX+":"+LOCAL_NAME, attr);
+
+                if (ntName != null && ntName.value != null) {
+                    ntName.importItem(contentHandler);
+                }
+                if (uuid != null && uuid.value != null) {
+                    uuid.importItem(contentHandler);
+                }
+
+                for(ImportProperty prop : childP) {
+                    prop.importItem(contentHandler);
+                }
+
+                for(ImportNode node : childN) {
+                    node.importItem(contentHandler);
+                }
+                contentHandler.endElement(Name.NS_SV_URI, LOCAL_NAME, Name.NS_SV_PREFIX+":"+LOCAL_NAME);
+            } catch(SAXException e) {
+                throw new DiffException(e.getMessage(), e);
+            }
+        }
+
+        @Override
+        void createItem(Node parent) throws RepositoryException, IOException {
+            if (mandatesImport(parent)) {
+                ContentHandler ch = createContentHandler(parent);
+                try {
+                    ch.startDocument();
+                    importItem(ch);
+                    ch.endDocument();
+                } catch (SAXException e) {
+                    throw new DiffException(e.getMessage(), e);
+                }
-                n = importNode(parent, name, ntName, uuid);
-            }
-            // create all properties
-            for (ImportItem obj : childP) {
-                obj.createItem(n);
-            }
-            // recursively create all child nodes
-            for (ImportItem obj : childN) {
-                obj.createItem(n);
+                Node n;
+                String uuidValue = getUUID();
+                String primaryType = getPrimaryType();
+                if (uuidValue == null) {
+                    n = (primaryType == null) ? parent.addNode(name) : parent.addNode(name,  primaryType);
+                } else {
+                    n = importNode(parent, name, primaryType, uuidValue);
+                }
+                // create all properties
+                for (ImportItem obj : childP) {
+                    obj.createItem(n);
+                }
+                // recursively create all child nodes
+                for (ImportItem obj : childN) {
+                    obj.createItem(n);
+                }
-    private final class ImportProp extends ImportItem  {
+    private abstract class ImportProperty extends ImportItem {
+
+        static final String VALUE = "value";
+        static final String TYPE = "type";
+        static final String LOCAL_NAME = "property";
+
+        private ImportProperty(String name) throws IOException {
+            super(name);
+        }
+
+        @Override
+        boolean mandatesImport(Node parent) {
+            // TODO: verify again if a protected property (except for jcr:primaryType and jcr:mixinTypes) will ever change outside the scope of importing the whole tree.
+            return false;
+        }
+
+        @Override
+        void importItem(ContentHandler contentHandler) throws IOException {
+            try {
+                AttributesImpl propAtts = new AttributesImpl();
+                setNameAttribute(propAtts);
+                setTypeAttribute(propAtts);
+                contentHandler.startElement(Name.NS_SV_URI, LOCAL_NAME, Name.NS_SV_PREFIX+":"+LOCAL_NAME, propAtts);
+                startValueElement(contentHandler);
+                contentHandler.endElement(Name.NS_SV_URI, LOCAL_NAME, Name.NS_SV_PREFIX+":"+LOCAL_NAME);
+            } catch(SAXException e) {
+                throw new DiffException(e.getMessage(), e);
+            }
+        }
+
+        void setTypeAttribute(AttributesImpl attr) {
+            String type = null;
+            if (name.equals(JcrConstants.JCR_PRIMARYTYPE)) {
+                type = PropertyType.nameFromValue(PropertyType.NAME);
+            } else if (name.equals(JcrConstants.JCR_MIXINTYPES)) {
+                type = PropertyType.nameFromValue(PropertyType.NAME);
+            } else if (name.equals(JcrConstants.JCR_UUID)) {
+                type = PropertyType.nameFromValue(PropertyType.STRING);
+            } else {
+                type = PropertyType.nameFromValue(PropertyType.UNDEFINED);
+            }
+            attr.addAttribute(Name.NS_SV_URI, TYPE, Name.NS_SV_PREFIX+":"+TYPE, TYPE_CDATA, type);
+        }
+
+        abstract void startValueElement(ContentHandler contentHandler) throws IOException;
+    }
+
+    private final class ImportProp extends ImportProperty {
+
+
+        @Override
+        void startValueElement(ContentHandler contentHandler) throws IOException {
+            try {
+                String str = value.getString();
+                contentHandler.startElement(Name.NS_SV_URI, VALUE, Name.NS_SV_PREFIX+":"+VALUE, new AttributesImpl());
+                contentHandler.characters(str.toCharArray(), 0, str.length());
+                contentHandler.endElement(Name.NS_SV_URI, VALUE, Name.NS_SV_PREFIX+":"+VALUE);
+            } catch(SAXException e) {
+                throw new DiffException(e.getMessage());
+            } catch (ValueFormatException e) {
+                throw new DiffException(e.getMessage());
+            } catch (RepositoryException e) {
+                throw new DiffException(e.getMessage());
+            }
+        }
-    private final class ImportMvProp extends ImportItem  {
+    private final class ImportMvProp extends ImportProperty  {
+
-                parent.setProperty(name, vls);            
+                parent.setProperty(name, vls);
+            }
+        }
+
+        @Override
+        void startValueElement(ContentHandler contentHandler) throws IOException {
+            try {
+                for (Value v : values) {
+                    String str = v.getString();
+                    contentHandler.startElement(Name.NS_SV_URI, VALUE, Name.NS_SV_PREFIX+":"+VALUE, new AttributesImpl());
+                    contentHandler.characters(str.toCharArray(), 0, str.length());
+                    contentHandler.endElement(Name.NS_SV_URI, VALUE, Name.NS_SV_PREFIX+":"+VALUE);
+                }
+            } catch(SAXException e) {
+                throw new DiffException(e.getMessage());
+            } catch (ValueFormatException e) {
+                throw new DiffException(e.getMessage());
+            } catch (RepositoryException e) {
+                throw new DiffException(e.getMessage());

redesigned transaction support & PersistenceManager

orginal code contributed by dominique pfister, required a lot of tweaking to make it run & work; not thoroughly tested

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@126221 13f79535-47bb-0310-9956-ffa450edef68

-    protected final SessionItemStateManager itemStateMgr;
+    protected final SessionItemStateManager stateMgr;
-        itemStateMgr = session.getItemStateManager();
+        stateMgr = session.getItemStateManager();
-    protected abstract void makePersistent() throws RepositoryException;
+    protected abstract void makePersistent(UpdateOperation update);
-            itemStateMgr.disposeTransientItemState(transientState);
+            stateMgr.disposeTransientItemState(transientState);
-            itemStateMgr.moveTransientItemStateToAttic(transientState);
+            stateMgr.moveTransientItemStateToAttic(transientState);
-            Iterator iter = itemStateMgr.getDescendantTransientItemStates(id);
+            Iterator iter = stateMgr.getDescendantTransientItemStates(id);
-            Iterator iter = itemStateMgr.getDescendantTransientItemStatesInAttic(id);
+            Iterator iter = stateMgr.getDescendantTransientItemStatesInAttic(id);
-    private void checkReferences(Iterator iterDirty, Iterator iterRemoved,
-                                 ReferenceManager refMgr)
+    private Collection checkReferences(Iterator iterDirty, Iterator iterRemoved)
+
-                                refs = refMgr.get(targetId);
+                                try {
+                                    refs = stateMgr.getNodeReferences(targetId);
+                                } catch (ItemStateException e) {
+                                    String msg = itemMgr.safeGetJCRPath(targetId)
+                                            + ": failed to load node references";
+                                    log.error(msg, e);
+                                    throw new RepositoryException(msg, e);
+                                }
-                            refs = refMgr.get(targetId);
+                            try {
+                                refs = stateMgr.getNodeReferences(targetId);
+                            } catch (ItemStateException e) {
+                                String msg = itemMgr.safeGetJCRPath(targetId)
+                                        + ": failed to load node references";
+                                log.error(msg, e);
+                                throw new RepositoryException(msg, e);
+                            }
-                            refs = refMgr.get(targetId);
+                            try {
+                                refs = stateMgr.getNodeReferences(targetId);
+                            } catch (ItemStateException e) {
+                                String msg = itemMgr.safeGetJCRPath(targetId)
+                                        + ": failed to load node references";
+                                log.error(msg, e);
+                                throw new RepositoryException(msg, e);
+                            }
-                refs = refMgr.get(targetId);
+                try {
+                    refs = stateMgr.getNodeReferences(targetId);
+                } catch (ItemStateException e) {
+                    String msg = itemMgr.safeGetJCRPath(targetId)
+                            + ": failed to load node references";
+                    log.error(msg, e);
+                    throw new RepositoryException(msg, e);
+                }
-        // persist dirty NodeReferences objects
-        iter = dirtyNodeRefs.values().iterator();
-        while (iter.hasNext()) {
-            NodeReferences refs = (NodeReferences) iter.next();
-            refMgr.save(refs);
-        }
+        // return dirty NodeReferences objects
+        return dirtyNodeRefs.values();
-    private void removeTransientItems(Iterator iter) throws RepositoryException {
+    private void removeTransientItems(UpdateOperation update,
+                                      Iterator iter) {
+
-            PersistableItemState persistentState = (PersistableItemState) transientState.getOverlayedState();
+            ItemState persistentState = transientState.getOverlayedState();
-             * remove persistent state (incl. descendents, if there are any)
+             * remove persistent state
-            try {
-                persistentState.destroy();
-            } catch (ItemStateException ise) {
-                String msg = "failed to remove item " + transientState.getId();
-                log.error(msg, ise);
-                throw new RepositoryException(msg, ise);
-            }
+            update.destroy(persistentState);
-    private void persistTransientItems(Iterator iter) throws RepositoryException {
+    private void persistTransientItems(UpdateOperation update,
+                                       Iterator iter)
+            throws RepositoryException {
+
-            item.makePersistent();
+            item.makePersistent(update);
-                itemStateMgr.enablePathCaching(true);
+                stateMgr.enablePathCaching(true);
-                                parentState = (NodeState) itemStateMgr.getTransientItemState(id);
+                                parentState = (NodeState) stateMgr.getTransientItemState(id);
-                 * we need to make sure that we are not interrupted while
-                 * verifying/persisting node references
+                 * build list of transient descendents in the attic
+                 * (i.e. those marked as 'removed')
-                ReferenceManager refMgr = wsp.getReferenceManager();
-                synchronized (refMgr) {
-                    /**
-                     * build list of transient descendents in the attic
-                     * (i.e. those marked as 'removed')
-                     */
-                    Collection removed = getRemovedStates();
+                Collection removed = getRemovedStates();
-                    /**
-                     * referential integrity checks:
-                     * make sure that a referenced node cannot be removed and
-                     * that all references are updated and persisted
-                     */
-                    checkReferences(dirty.iterator(), removed.iterator(), refMgr);
+                /**
+                 * referential integrity checks:
+                 * make sure that a referenced node cannot be removed and
+                 * that all references are updated and persisted
+                 */
+                Collection dirtyRefs =
+                        checkReferences(dirty.iterator(), removed.iterator());
-                    /**
-                     * create event states for the affected item states and
-                     * prepare them for event dispatch (this step is necessary in order
-                     * to check access rights on items that will be removed)
-                     *
-                     * todo consolidate event generating and dispatching code (ideally one method call after save has succeeded)
-                     */
-                    events.createEventStates(dirty);
-                    events.createEventStates(removed);
-                    events.prepare();
+                /**
+                 * create event states for the affected item states and
+                 * prepare them for event dispatch (this step is necessary in order
+                 * to check access rights on items that will be removed)
+                 *
+                 * todo consolidate event generating and dispatching code (ideally one method call after save has succeeded)
+                 */
+                events.createEventStates(removed);
+                events.createEventStates(dirty);
+                events.prepare();
-                    // definitively remove transient items marked as 'removed'
-                    removeTransientItems(removed.iterator());
+                try {
+                    // start the update operation
+                    UpdateOperation update = stateMgr.beginUpdate();
-                    // dispose the transient states marked 'removed'
-                    iter = removed.iterator();
-                    while (iter.hasNext()) {
-                        transientState = (ItemState) iter.next();
-                        /**
-                         * dispose the transient state, it is no longer used
-                         * this will indirectly (through stateDiscarded listener method)
-                         * permanently invalidate the wrapping Item instance
-                         */
-                        itemStateMgr.disposeTransientItemStateInAttic(transientState);
-                    }
+                    // process transient items marked as 'removed'
+                    removeTransientItems(update, removed.iterator());
-                    // persist 'new' or 'modified' transient states
-                    persistTransientItems(dirty.iterator());
-                } // synchronized(refMgr)
+                    // process 'new' or 'modified' transient states
+                    persistTransientItems(update, dirty.iterator());
-                // now it is safe to dispose the transient states
+                    // store the references calculated above
+                    for (Iterator it = dirtyRefs.iterator(); it.hasNext();) {
+                        update.store((NodeReferences) it.next());
+                    }
+
+                    // end update operation
+                    update.end();
+
+                } catch (ItemStateException e) {
+
+                    String msg = safeGetJCRPath() + ": unable to update item.";
+                    log.error(msg);
+                    throw new RepositoryException(msg, e);
+
+                }
+
+                // now it is safe to dispose the transient states:
+                // dispose the transient states marked 'removed'
+                iter = removed.iterator();
+                while (iter.hasNext()) {
+                    transientState = (ItemState) iter.next();
+                    // dispose the transient state, it is no longer used
+                    stateMgr.disposeTransientItemStateInAttic(transientState);
+                }
+                // dispose the transient states marked 'new' or 'modified'
-                    itemStateMgr.disposeTransientItemState(transientState);
+                    stateMgr.disposeTransientItemState(transientState);
+
-                itemStateMgr.enablePathCaching(false);
+                stateMgr.enablePathCaching(false);
-                itemStateMgr.disposeAllTransientItemStates();
+                stateMgr.disposeAllTransientItemStates();
-            transientState = (ItemState) state;
+            transientState = state;
-            Iterator iter = itemStateMgr.getDescendantTransientItemStates(id);
+            Iterator iter = stateMgr.getDescendantTransientItemStates(id);
-            itemStateMgr.disposeTransientItemState(transientState);
+            stateMgr.disposeTransientItemState(transientState);
-        iter = itemStateMgr.getDescendantTransientItemStatesInAttic(id);
+        iter = stateMgr.getDescendantTransientItemStatesInAttic(id);
-            itemStateMgr.disposeTransientItemStateInAttic(transientState);
+            stateMgr.disposeTransientItemStateInAttic(transientState);

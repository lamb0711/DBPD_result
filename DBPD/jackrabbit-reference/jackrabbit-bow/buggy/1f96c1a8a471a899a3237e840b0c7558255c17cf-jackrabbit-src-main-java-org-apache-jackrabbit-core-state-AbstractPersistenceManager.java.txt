JCR-595 Refactoring of the Persistence Managers (+changing some eol-styles)


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@467925 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.NodeId;
-import org.apache.jackrabbit.core.PropertyId;
-
-import java.util.Iterator;
-
- * Implementation <code>PersistenceManager</code> that handles some
- * concepts.
+ * Legacy class kept for backward compatibility reasons.
+ * @deprecated use {@link org.apache.jackrabbit.core.persistence.AbstractPersistenceManager}
+ *             instead.
-public abstract class AbstractPersistenceManager implements PersistenceManager {
+public abstract class AbstractPersistenceManager extends org.apache.jackrabbit.core.persistence.AbstractPersistenceManager {
-    /**
-     * {@inheritDoc}
-     */
-    public NodeState createNew(NodeId id) {
-        return new NodeState(id, null, null, NodeState.STATUS_NEW, false);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public PropertyState createNew(PropertyId id) {
-        return new PropertyState(id, PropertyState.STATUS_NEW, false);
-    }
-
-    /**
-     * Right now, this iterates over all items in the changelog and
-     * calls the individual methods that handle single item states
-     * or node references objects. Properly implemented, this method
-     * should ensure that changes are either written completely to
-     * the underlying persistence layer, or not at all.
-     *
-     * {@inheritDoc}
-     */
-    public synchronized void store(ChangeLog changeLog) throws ItemStateException {
-        Iterator iter = changeLog.deletedStates();
-        while (iter.hasNext()) {
-            ItemState state = (ItemState) iter.next();
-            if (state.isNode()) {
-                destroy((NodeState) state);
-            } else {
-                destroy((PropertyState) state);
-            }
-        }
-        iter = changeLog.addedStates();
-        while (iter.hasNext()) {
-            ItemState state = (ItemState) iter.next();
-            if (state.isNode()) {
-                store((NodeState) state);
-            } else {
-                store((PropertyState) state);
-            }
-        }
-        iter = changeLog.modifiedStates();
-        while (iter.hasNext()) {
-            ItemState state = (ItemState) iter.next();
-            if (state.isNode()) {
-                store((NodeState) state);
-            } else {
-                store((PropertyState) state);
-            }
-        }
-        iter = changeLog.modifiedRefs();
-        while (iter.hasNext()) {
-            NodeReferences refs = (NodeReferences) iter.next();
-            if (refs.hasReferences()) {
-                store(refs);
-            } else {
-                if (exists(refs.getId())) {
-                    destroy(refs);
-                }
-            }
-        }
-    }
-
-    /**
-     * Store a node state. Subclass responsibility.
-     *
-     * @param state node state to store
-     * @throws ItemStateException if an error occurs
-     */
-    protected abstract void store(NodeState state) throws ItemStateException;
-
-    /**
-     * Store a property state. Subclass responsibility.
-     *
-     * @param state property state to store
-     * @throws ItemStateException if an error occurs
-     */
-    protected abstract void store(PropertyState state) throws ItemStateException;
-
-    /**
-     * Store a references object. Subclass responsibility.
-     *
-     * @param refs references object to store
-     * @throws ItemStateException if an error occurs
-     */
-    protected abstract void store(NodeReferences refs) throws ItemStateException;
-
-    /**
-     * Destroy a node state. Subclass responsibility.
-     *
-     * @param state node state to destroy
-     * @throws ItemStateException if an error occurs
-     */
-    protected abstract void destroy(NodeState state) throws ItemStateException;
-
-    /**
-     * Destroy a property state. Subclass responsibility.
-     *
-     * @param state property state to destroy
-     * @throws ItemStateException if an error occurs
-     */
-    protected abstract void destroy(PropertyState state) throws ItemStateException;
-
-    /**
-     * Destroy a node references object. Subclass responsibility.
-     *
-     * @param refs node references object to destroy
-     * @throws ItemStateException if an error occurs
-     */
-    protected abstract void destroy(NodeReferences refs)
-            throws ItemStateException;
-}
+}

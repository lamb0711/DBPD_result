JCR-702: Allow database as backend for clustering
JCR-703: Add signature and major/minor version to the journal files used for clustering 


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@495239 13f79535-47bb-0310-9956-ffa450edef68

-import java.io.DataOutputStream;
-import java.io.InputStream;
-import java.io.DataInput;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.BufferedInputStream;
-import java.io.FileInputStream;
- * Represents a file-based record. Physically, a file record contains its length in the
- * first 4 bytes, immediately followed by its creator in a length-prefixed, UTF-encoded
- * string. All further fields are record-specific.
+ * Represents a file-based record. Physically, a file record starts with its creator
+ * in a length-prefixed, UTF-encoded string, followed by a 4 byte indicating the
+ * length of data. All further fields are record-specific.
-     * Indicator for a literal UUID.
+     * Record creator.
-    static final byte UUID_LITERAL = 'L';
+    //private final String creator;
+    private final byte[] creator;
-     * Indicator for a UUID index.
+     * Record length.
-    static final byte UUID_INDEX = 'I';
+    private final int length;
+
+    /**
+     * Input stream associated with record data.
+     */
+    private final DataInputStream dataIn;
-     * Underlying input stream.
-     */
-    private DataInputStream in;
-
-    /**
-     * File use when creating a new record.
-     */
-    private File file;
-
-    /**
-     * Underlying output stream.
-     */
-    private DataOutputStream out;
-
-    /**
-     * Record length.
-     */
-    private int length;
-
-    /**
-     * Creator of a record.
-     */
-    private String creator;
-
-    /**
-     * Bytes used by creator when written in UTF encoding and length-prefixed.
-     */
-    private int creatorLength;
-
-    /**
-     * Flag indicating whether bytes need to be skipped at the end.
+     * Flag indicating whether the data associated with this record has been consumed.
-     * Creates a new file record. Used when opening an existing record.
-     *
-     * @param revision revision this record represents
-     * @param in underlying input stream
-     * @throws IOException if reading the creator fails
-     */
-    public FileRecord(long revision, InputStream in)
-            throws IOException {
-
-        this.revision = revision;
-        if (in instanceof DataInputStream) {
-            this.in = (DataInputStream) in;
-        } else {
-            this.in = new DataInputStream(in);
-        }
-        this.length = this.in.readInt();
-
-        readCreator();
-    }
-
-    /**
-     * Creates a new file record. Used when creating a new record.
+     * Creates a new instance of this class. Used when opening an existing record.
-     * @param file underlying (temporary) file
-     * @throws IOException if writing the creator fails
+     * @param length record length
+     * @param dataIn input stream containing record data
-    public FileRecord(String creator, File file) throws IOException {
-
+    public FileRecord(byte[] creator, int length, DataInputStream dataIn) {
-        this.file = file;
-
-        this.out = new DataOutputStream(new FileOutputStream(file));
-
-        writeCreator();
+        this.length = length;
+        this.dataIn = dataIn;
-     * Set the journal revision associated with this record.
+     * Set the journal revision associated with this record. Called after creation
+     * of the file record.
-     * @param revision journal revision
+     * @param revision revision
-    public void setRevision(long revision) {
+    void setRevision(long revision) {
-     * Return the journal counter associated with the next record.
+     * Return the journal counter associated with the next record. A file record's
+     * size is the size of the length-prefixed creator string plus the size of
+     * the length-prefixed data.
-        return revision + length + 4;
+        return revision + FileRecordLog.getRecordSize(creator, length);
-    public String getCreator() {
+    public byte[] getCreator() {
-    public FileRecordInput getInput(NamespaceResolver resolver) {
+    public RecordInput getInput(NamespaceResolver resolver) {
-        return new FileRecordInput(in, resolver);
-    }
-
-    /**
-     * Return an output on this record.
-     *
-     * @param resolver resolver to use when mapping full names to prefixes
-     * @return record output
-     */
-    public FileRecordOutput getOutput(NamespaceResolver resolver) {
-        return new FileRecordOutput(this, out, resolver);
-    }
-
-    /**
-     * Append this record to some output stream.
-     *
-     * @param out outputstream to append to
-     */
-    void append(DataOutputStream out) throws IOException {
-        out.writeInt(length);
-
-        byte[] buffer = new byte[8192];
-        int len;
-
-        InputStream in = new BufferedInputStream(new FileInputStream(file));
-        try {
-            while ((len = in.read(buffer)) > 0) {
-                out.write(buffer, 0, len);
-            }
-            out.flush();
-        } finally {
-            in.close();
-        }
+        return new RecordInput(dataIn, resolver);
-    void skip() throws IOException {
+    public void skip() throws IOException {
-            long skiplen = length - creatorLength;
+            long skiplen = length;
-                long skipped = in.skip(skiplen);
+                long skipped = dataIn.skip(skiplen);
-
-    /**
-     * Invoked when output has been closed.
-     */
-    void closed() {
-        length = (int) file.length();
-    }
-
-    /**
-     * Read creator from the underlying data input stream.
-     *
-     * @throws IOException if an I/O error occurs
-     */
-    private void readCreator() throws IOException {
-        UTFByteCounter counter = new UTFByteCounter(in);
-        creator = DataInputStream.readUTF(counter);
-        creatorLength = counter.getBytes();
-    }
-
-    /**
-     * Write creator to the underlying data output stream.
-     *
-     * @throws IOException if an I/O error occurs
-     */
-    private void writeCreator() throws IOException {
-        out.writeUTF(creator);
-    }
-
-    /**
-     * UTF byte counter. Counts the bytes actually read from a given
-     * <code>DataInputStream</code> that make up a UTF-encoded string.
-     */
-    static class UTFByteCounter implements DataInput {
-
-        /**
-         * Underlying input stream.
-         */
-        private final DataInputStream in;
-
-        /**
-         * UTF length.
-         */
-        private int bytes;
-
-        /**
-         * Create a new instance of this class.
-         *
-         * @param in underlying data input stream
-         */
-        public UTFByteCounter(DataInputStream in) {
-            this.in = in;
-        }
-
-        /**
-         * Return the number of bytes read from the underlying input stream.
-         *
-         * @return number of bytes
-         */
-        public int getBytes() {
-            return bytes;
-        }
-
-        /**
-         * @see java.io.DataInputStream#readUnsignedShort()
-         *
-         * Remember number of bytes read.
-         */
-        public int readUnsignedShort() throws IOException {
-            try {
-                return in.readUnsignedShort();
-            } finally {
-                bytes += 2;
-            }
-        }
-
-        /**
-         * @see java.io.DataInputStream#readUnsignedShort()
-         *
-         * Remember number of bytes read.
-         */
-        public void readFully(byte b[]) throws IOException {
-            try {
-                in.readFully(b);
-            } finally {
-                bytes += b.length;
-            }
-        }
-
-        /**
-         * @see java.io.DataInputStream#readUnsignedShort()
-         *
-         * Remember number of bytes read.
-         */
-        public void readFully(byte b[], int off, int len) throws IOException {
-            try {
-                in.readFully(b, off, len);
-            } finally {
-                bytes += b.length;
-            }
-        }
-
-        /**
-         * Methods not implemented.
-         */
-        public byte readByte() throws IOException {
-            throw new IllegalStateException("Unexpected call, deliberately not implemented.");
-        }
-
-        public char readChar() throws IOException {
-            throw new IllegalStateException("Unexpected call, deliberately not implemented.");
-        }
-
-        public double readDouble() throws IOException {
-            throw new IllegalStateException("Unexpected call, deliberately not implemented.");
-        }
-
-        public float readFloat() throws IOException {
-            throw new IllegalStateException("Unexpected call, deliberately not implemented.");
-        }
-
-        public int readInt() throws IOException {
-            throw new IllegalStateException("Unexpected call, deliberately not implemented.");
-       }
-
-        public int readUnsignedByte() throws IOException {
-            throw new IllegalStateException("Unexpected call, deliberately not implemented.");
-        }
-
-        public long readLong() throws IOException {
-            throw new IllegalStateException("Unexpected call, deliberately not implemented.");
-        }
-
-        public short readShort() throws IOException {
-            throw new IllegalStateException("Unexpected call, deliberately not implemented.");
-        }
-
-        public boolean readBoolean() throws IOException {
-            throw new IllegalStateException("Unexpected call, deliberately not implemented.");
-        }
-
-        public int skipBytes(int n) throws IOException {
-            throw new IllegalStateException("Unexpected call, deliberately not implemented.");
-        }
-
-        public String readLine() throws IOException {
-            throw new IllegalStateException("Unexpected call, deliberately not implemented.");
-        }
-
-        public String readUTF() throws IOException {
-            throw new IllegalStateException("Unexpected call, deliberately not implemented.");
-        }
-    }

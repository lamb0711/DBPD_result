migrating to v0.15 of the jsr 170 spec

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@55516 13f79535-47bb-0310-9956-ffa450edef68

-import javax.jcr.access.AccessDeniedException;
-import javax.jcr.access.Permission;
+import javax.jcr.version.VersionException;
-         *   check the ADD_NODE permission
+         *   check the WRITE permission
-         *   check the REMOVE_ITEM permission
+         *   check the WRITE permission
-         * - check the SET_PROPERTY permission
+         * - check the WRITE permission
-                    // check REMOVE_ITEM permission
-                    if (!accessMgr.isGranted(id, Permission.REMOVE_ITEM)) {
+                    // check WRITE permission
+                    if (!accessMgr.isGranted(id, AccessManager.WRITE)) {
-                        // check ADD_NODE permission
-                        if (!accessMgr.isGranted(id, Permission.ADD_NODE)) {
+                        // check WRITE permission
+                        if (!accessMgr.isGranted(id, AccessManager.WRITE)) {
-                    // check SET_PROPERTY permission
-                    if (!accessMgr.isGranted(nodeId, Permission.SET_PROPERTY)) {
+                    // check WRITE permission on property
+                    if (!accessMgr.isGranted(propId, AccessManager.WRITE)) {
+                    if (propState.getOverlayedState() == null) {
+                        // property has been added, check WRITE permission on parent
+                        if (!accessMgr.isGranted(nodeId, AccessManager.WRITE)) {
+                            String msg = itemMgr.safeGetJCRPath(nodeId) + ": not allowed to set property " + prop.getName();
+                            log.error(msg);
+                            throw new AccessDeniedException(msg);
+                        }
+                    }
-                    if (def.getValueConstraint() != null) {
+                    if (def.getValueConstraints() != null) {
-            throws ConstraintViolationException, RepositoryException {
+            throws ReferentialIntegrityException, RepositoryException {
-                            throw new ConstraintViolationException(msg);
+                            throw new ReferentialIntegrityException(msg);
-                                    throw new ConstraintViolationException(msg);
+                                    throw new ReferentialIntegrityException(msg);
-                throw new ConstraintViolationException(msg);
+                throw new ReferentialIntegrityException(msg);
+     * @see Item#remove
+     */
+    public void remove() throws RepositoryException {
+        // check state of this instance
+        checkItemState();
+
+        Path.PathElement thisName = getPrimaryPath().getNameElement();
+
+        // check if protected
+        if (isNode()) {
+            NodeImpl node = (NodeImpl) this;
+            NodeDef def = node.getDefinition();
+            // check protected flag
+            if (def.isProtected()) {
+                String msg = safeGetJCRPath() + ": cannot remove a protected node";
+                log.error(msg);
+                throw new ConstraintViolationException(msg);
+            }
+        } else {
+            PropertyImpl prop = (PropertyImpl) this;
+            PropertyDef def = prop.getDefinition();
+            // check protected flag
+            if (def.isProtected()) {
+                String msg = safeGetJCRPath() + ": cannot remove a protected property";
+                log.error(msg);
+                throw new ConstraintViolationException(msg);
+            }
+        }
+
+        NodeImpl parentNode = (NodeImpl) getParent();
+
+        // check if versioning allows write
+        if (!parentNode.safeIsCheckedOut()) {
+            String msg = parentNode.safeGetJCRPath() + ": cannot remove a child of a checked-in node";
+            log.error(msg);
+            throw new VersionException(msg);
+        }
+
+        // check protected flag of parent node
+        if (parentNode.getDefinition().isProtected()) {
+            String msg = parentNode.safeGetJCRPath() + ": cannot remove a child of a protected node";
+            log.error(msg);
+            throw new ConstraintViolationException(msg);
+        }
+
+        // delegate the removal of the child item to the parent node
+        if (isNode()) {
+            parentNode.removeChildNode(thisName.getName(), thisName.getIndex());
+        } else {
+            parentNode.removeChildProperty(thisName.getName());
+        }
+    }
+
+    /**
-            RepositoryException {
+            ReferentialIntegrityException, RepositoryException {
-     * @see Item#isGranted
-     */
-    public boolean isGranted(long permissions)
-            throws UnsupportedRepositoryOperationException, RepositoryException {
-        checkItemState();
-
-        try {
-            // check state of this instance
-            checkItemState();
-
-            Permission[] perms = session.getAccessManager().getSupportedPermissions();
-            // check each permission separately
-            AccessManagerImpl accessMgr = session.getAccessManager();
-            for (int i = 0; i < perms.length; i++) {
-                Permission perm = perms[i];
-                if ((permissions & perm.getValue()) == perm.getValue()) {
-                    if (!accessMgr.isGranted(id, perm.getValue())) {
-                        return false;
-                    }
-                }
-                permissions &= ~perm.getValue();
-            }
-            if (permissions > 0) {
-                log.warn("unsupported/unknown permissions: " + permissions);
-            }
-            return true;
-        } catch (PathNotFoundException pnfe) {
-            String msg = "failed to check permissions on " + safeGetJCRPath();
-            log.error(msg, pnfe);
-            throw new RepositoryException(msg, pnfe);
-        }
-    }
-
-    /**

- use seperate persistence manager for versioning

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@125924 13f79535-47bb-0310-9956-ffa450edef68

-import javax.jcr.nodetype.NodeDef;
-import javax.jcr.nodetype.PropertyDef;
-     * the node type manager
-     */
-    private final NodeTypeManagerImpl ntMgr;
-
-    /**
-     * @param ntMgr
-                             NodeTypeManagerImpl ntMgr,
-        this.ntMgr = ntMgr;
-                PropertyDefImpl def = getApplicablePropertyDef(name, type, multiValued);
-                propState.setDefinitionId(new PropDefId(def.unwrap()));
-
+                propState.setDefinitionId(PropDefId.valueOf("0"));
-     * retrieves the property definition for the given contraints
-     *
-     * @param propertyName
-     * @param type
-     * @param multiValued
-     * @return
-     * @throws RepositoryException
-     */
-    protected PropertyDefImpl getApplicablePropertyDef(QName propertyName,
-                                                       int type, boolean multiValued)
-            throws RepositoryException {
-        PropDef pd = getEffectiveNodeType().getApplicablePropertyDef(propertyName, type, multiValued);
-        return ntMgr.getPropDef(new PropDefId(pd));
-    }
-
-    /**
-     * Retrieves the node definition for the given contraints.
-     *
-     * @param nodeName
-     * @param nodeTypeName
-     * @return
-     * @throws RepositoryException
-     */
-    protected NodeDefImpl getApplicableChildNodeDef(QName nodeName, QName nodeTypeName)
-            throws RepositoryException {
-        ChildNodeDef cnd = getEffectiveNodeType().getApplicableChildNodeDef(nodeName, nodeTypeName);
-        return ntMgr.getNodeDef(new NodeDefId(cnd));
-    }
-
-    /**
-     * Returns the effective (i.e. merged and resolved) node type representation
-     * of this node's primary and mixin node types.
-     *
-     * @return the effective node type
-     * @throws RepositoryException
-     */
-    protected EffectiveNodeType getEffectiveNodeType() throws RepositoryException {
-        // build effective node type of mixins & primary type
-        NodeTypeRegistry ntReg = ntMgr.getNodeTypeRegistry();
-        // existing mixin's
-        HashSet set = new HashSet(nodeState.getMixinTypeNames());
-        // primary type
-        set.add(nodeState.getNodeTypeName());
-        try {
-            return ntReg.getEffectiveNodeType((QName[]) set.toArray(new QName[set.size()]));
-        } catch (NodeTypeConflictException ntce) {
-            String msg = "internal error: failed to build effective node type for node " + nodeState.getUUID();
-            throw new RepositoryException(msg, ntce);
-        }
-    }
-
-    /**
-            return new PersistentNode(stateMgr, ntMgr, state);
+            return new PersistentNode(stateMgr, state);
-            return new PersistentNode(stateMgr, ntMgr, state);
+            return new PersistentNode(stateMgr, state);
-        NodeTypeImpl nodeType = ntMgr.getNodeType(nodeTypeName);
-        NodeDefImpl def;
-        try {
-            def = getApplicableChildNodeDef(name, nodeType == null ? null : nodeType.getQName());
-        } catch (RepositoryException re) {
-            // hack, use nt:unstructured as parent
-            NodeTypeRegistry ntReg = ntMgr.getNodeTypeRegistry();
-            EffectiveNodeType ent = ntReg.getEffectiveNodeType(NodeTypeRegistry.NT_UNSTRUCTURED);
-            ChildNodeDef cnd = ent.getApplicableChildNodeDef(name, nodeTypeName);
-            def = ntMgr.getNodeDef(new NodeDefId(cnd));
-        }
-
-        if (nodeType == null) {
-            // use default node type
-            nodeType = (NodeTypeImpl) def.getDefaultPrimaryType();
-        }
-        return createChildNode(nodeName, def, nodeType, null);
+        return createChildNode(nodeName, nodeTypeName, null);
-     * @param def
-     * @param nodeType
-    private PersistentNode createChildNode(QName name, NodeDefImpl def,
-                                           NodeTypeImpl nodeType, String uuid)
+    private PersistentNode createChildNode(QName name, QName nodeTypeName, String uuid)
-            state = stateMgr.createNodeState(uuid, nodeType.getQName(), parentUUID);
-            state.setDefinitionId(new NodeDefId(def.unwrap()));
+            state = stateMgr.createNodeState(uuid, nodeTypeName, parentUUID);
+            state.setDefinitionId(NodeDefId.valueOf("0"));
-        PersistentNode node = new PersistentNode(stateMgr, ntMgr, state);
+        PersistentNode node = new PersistentNode(stateMgr, state);
-
-        // add 'auto-create' properties defined in node type
-        PropertyDef[] pda = nodeType.getAutoCreatePropertyDefs();
-        for (int i = 0; i < pda.length; i++) {
-            PropertyDefImpl pd = (PropertyDefImpl) pda[i];
-            node.getOrCreatePropertyState(pd.getQName(), pd.getRequiredType(), pd.isMultiple());
-        }
-
-        // recursively add 'auto-create' child nodes defined in node type
-        NodeDef[] nda = nodeType.getAutoCreateNodeDefs();
-        for (int i = 0; i < nda.length; i++) {
-            NodeDefImpl nd = (NodeDefImpl) nda[i];
-            node.createChildNode(nd.getQName(), nd, (NodeTypeImpl) nd.getDefaultPrimaryType(), null);
-        }
-
-        // store primary type
-        node.setPropertyValue(ItemImpl.PROPNAME_PRIMARYTYPE, InternalValue.create(nodeType.getQName()));
-                children[i] = new PersistentNode(stateMgr, ntMgr, state);
+                children[i] = new PersistentNode(stateMgr, state);
-            int type = values.length>0 ? values[0].getType() : prop.getDefinition().getRequiredType();
-            setPropertyValues(prop.getQName(), type, values);
+            setPropertyValues(prop.getQName(), values[0].getType(), values);

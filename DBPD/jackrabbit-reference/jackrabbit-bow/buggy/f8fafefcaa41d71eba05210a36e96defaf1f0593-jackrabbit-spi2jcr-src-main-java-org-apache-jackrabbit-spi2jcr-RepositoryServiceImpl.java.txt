JCR-2104: JSR 283 Versioning
   - VersionHistory.getAllFrozenNodes()  (move iteratoradaptor from core to jcr-commons), VersionHistory.getVersionableIdentifier()
   - Version.getFrozenNode, Version.getLinearPredecessor()
   - VersionManager (work in progress): 170-methods, shallow merge, checkpoint
      -> extend SPI interfaces accordingly

JCR-2003: JCR2SPI / SPI: Add support for JCR 2.0
   - Session.hasPermission()
   - Node.getProperties/getNodes with glob
   - Node.getIdentifier()

JCR-2004: Update SPI locking to match JCR 2.0
   - separate JCR LockManager from the internal lock manager

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@773828 13f79535-47bb-0310-9956-ffa450edef68

+import javax.jcr.version.VersionManager;
+    public NodeId checkpoint(SessionInfo sessionInfo, final NodeId nodeId) throws UnsupportedRepositoryOperationException, RepositoryException {
+        final SessionInfoImpl sInfo = getSessionInfoImpl(sessionInfo);
+        Version newVersion = (Version) executeWithLocalEvents(new Callable() {
+            public Object run() throws RepositoryException {
+                VersionManager vMgr = sInfo.getSession().getWorkspace().getVersionManager();
+                return vMgr.checkpoint(getNodePath(nodeId, sInfo));
+            }
+        }, sInfo);
+        return idFactory.createNodeId(newVersion, sInfo.getNamePathResolver());
+    }
+
+    public Iterator merge(final SessionInfo sessionInfo,
+                          final NodeId nodeId,
+                          final String srcWorkspaceName,
+                          final boolean bestEffort,
+                          final boolean isShallow)
+            throws NoSuchWorkspaceException, AccessDeniedException, MergeException, LockException, InvalidItemStateException, RepositoryException {
+        final SessionInfoImpl sInfo = getSessionInfoImpl(sessionInfo);
+        return (Iterator) executeWithLocalEvents(new Callable() {
+            public Object run() throws RepositoryException {
+                VersionManager vMgr = sInfo.getSession().getWorkspace().getVersionManager();
+                NodeIterator it = vMgr.merge(getNodePath(nodeId, sInfo), srcWorkspaceName, bestEffort, isShallow);
+                List ids = new ArrayList();
+                while (it.hasNext()) {
+                    ids.add(idFactory.createNodeId(it.nextNode(),
+                            sInfo.getNamePathResolver()));
+                }
+                return ids.iterator();
+            }
+        }, sInfo);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    private String getNodePath(NodeId nodeId, SessionInfoImpl sessionInfo) throws RepositoryException {
+        // TODO: improve. avoid roundtrip over node access.
+        return getNode(nodeId, sessionInfo).getPath();
+    }
+

Fix for JCR-1325 and review support for Collection & Map. 
The mapping definition can be simplified with parameterized collections and maps. In this case the ElementClass setting is not necessary.


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@650283 13f79535-47bb-0310-9956-ffa450edef68

+		String fieldName = "";
-
+				fieldName = propertyDescriptor.getName();
-			throw new InitMapperException("Impossible to read the mapping descriptor from the getter", e);
+			throw new InitMapperException("Impossible to read the mapping descriptor from the getter for class : " +
+					clazz.toString() +
+					(fieldName == null ? "" : " for field : " + fieldName), e);
-		collectionDescriptor.setCollectionClassName(field.getName());
+		collectionDescriptor.setCollectionClassName(field.getType().getName());
-
-//		    collectionDescriptor.setElementClassName(targetClass.getName());
-			Type type = field.getGenericType();
-			if (type instanceof ParameterizedType)
-			{
-				Type[] paramType = ((ParameterizedType) type).getActualTypeArguments();
-				//TODO : change this condition. No sure if it will be all the time true.
-				// If only one type argument, the attribute is certainly a collection
-				if (paramType.length == 1)
-				{
-					collectionDescriptor.setElementClassName(paramType[0].toString().replace("class ", ""));
-				}
-				// either, it is certainly a map
-				else
-				{
-					collectionDescriptor.setElementClassName(paramType[1].toString().replace("class ", ""));
-				}
-
-			}
-
+			setElementClassName(collectionDescriptor, field.getGenericType());
+
+
+	private void setElementClassName(CollectionDescriptor collectionDescriptor, Type type) {
+		if (type instanceof ParameterizedType)
+		{
+			Type[] paramType = ((ParameterizedType) type).getActualTypeArguments();
+			//TODO : change this condition. No sure if it will be all the time true.
+			// If only one type argument, the object is certainly a collection
+			if (paramType.length == 1)
+			{
+				collectionDescriptor.setElementClassName(paramType[0].toString().replace("class ", ""));
+
+			}
+			// either, it is certainly a map
+			else
+			{
+				collectionDescriptor.setElementClassName(paramType[1].toString().replace("class ", ""));
+			}
+
+		}
+		else
+		{
+			Type ancestorType = ((Class)type).getGenericSuperclass();
+            if ( ancestorType!= null)
+            {
+			   setElementClassName(collectionDescriptor,ancestorType);
+            }
+		}
+	}
+

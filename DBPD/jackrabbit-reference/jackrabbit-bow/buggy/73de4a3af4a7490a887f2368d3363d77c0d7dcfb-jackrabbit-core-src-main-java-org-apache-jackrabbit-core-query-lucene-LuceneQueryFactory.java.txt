JCR-2959 SQL2 QueryEngine should use Lucene for sort
 - work in progress

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1161475 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.lucene.search.Sort;
-    public List<Row> execute(
-            Map<String, PropertyValue> columns, Selector selector,
-            Constraint constraint) throws RepositoryException, IOException {
+    /**
+     * @param columns
+     * @param selector
+     * @param constraint
+     * @param externalSort
+     *            if <code>true</code> it means that the lqf should just let the
+     *            QueryEngine take care of sorting and applying applying offset
+     *            and limit constraints
+     * @param offsetIn
+     *            used in pagination
+     * @param limitIn
+     *            used in pagination
+     * @return a list of rows
+     * @throws RepositoryException
+     * @throws IOException
+     */
+    public List<Row> execute(Map<String, PropertyValue> columns,
+            Selector selector, Constraint constraint, Sort sort,
+            boolean externalSort, long offsetIn, long limitIn)
+            throws RepositoryException, IOException {
+        final int offset = offsetIn < 0 ? 0 : (int) offsetIn;
+        final int limit = limitIn < 0 ? Integer.MAX_VALUE : (int) limitIn;
+
-            hits = searcher.evaluate(qp.mainQuery);
+
+            // TODO depending on the filters, we could push the offset info
+            // into the searcher
+            hits = searcher.evaluate(qp.mainQuery, sort, offset + limit);
+            int currentNode = 0;
+            int addedNodes = 0;
+
+                Row row = null;
-                    Row row = new SelectorRow(
-                            columns, evaluator, selector.getSelectorName(),
+                    row = new SelectorRow(columns, evaluator,
+                            selector.getSelectorName(),
-                    if (filter.evaluate(row)) {
-                        rows.add(row);
-                    }
+                if (row != null && filter.evaluate(row)) {
+                    if (externalSort) {
+                        // return everything and not worry about sort
+                        rows.add(row);
+                    } else {
+                        // apply limit and offset rules locally
+                        if (currentNode >= offset
+                                && currentNode - offset < limit) {
+                            rows.add(row);
+                            addedNodes++;
+                        }
+                        currentNode++;
+                        // end the loop when going over the limit
+                        if (addedNodes == limit) {
+                            break;
+                        }
+                    }
+                }
-            if(hits != null){
+            if (hits != null) {

- fixed (JCR-69) removing source parent node after session move throws on save
  http://issues.apache.org/jira/browse/JCR-69
- fixed Session.move(): lock on source parent was not checked
  

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@157745 13f79535-47bb-0310-9956-ffa450edef68

-        ArrayList list = new ArrayList();
-        Iterator iter = childNodeEntries.iterator();
-        while (iter.hasNext()) {
-            ChildNodeEntry entry = (ChildNodeEntry) iter.next();
-            if (entry.getUUID().equals(uuid)) {
-                list.add(entry);
-            }
-        }
-        return Collections.unmodifiableList(list);
+        return childNodeEntries.get(uuid);
-        ArrayList list = new ArrayList();
-        Iterator iter = childNodeEntries.iterator();
-        while (iter.hasNext()) {
-            ChildNodeEntry entry = (ChildNodeEntry) iter.next();
-            if (entry.getName().equals(nodeName)) {
-                list.add(entry);
-            }
-        }
-        return Collections.unmodifiableList(list);
+        return childNodeEntries.get(nodeName);
-        ArrayList list = new ArrayList(parentUUIDs);
-
-        Iterator i = other.parentUUIDs.iterator();
-        while (i.hasNext()) {
-            list.remove(i.next());
-        }
-
+        ArrayList list = new ArrayList(parentUUIDs);
+        list.removeAll(other.parentUUIDs);
-        ArrayList list = new ArrayList(propertyEntries);
-
-        Iterator i = other.propertyEntries.iterator();
-        while (i.hasNext()) {
-            list.remove(i.next());
-        }
-
+        ArrayList list = new ArrayList(propertyEntries);
+        list.removeAll(other.propertyEntries);
-        ArrayList list = new ArrayList(childNodeEntries.entries());
-
-        Iterator i = other.childNodeEntries.entries().iterator();
-        while (i.hasNext()) {
-            list.remove(i.next());
-        }
-
-        return list;
+        return childNodeEntries.removeAll(other.childNodeEntries);
-
-        Iterator i = parentUUIDs.iterator();
-        while (i.hasNext()) {
-            list.remove(i.next());
-        }
-
+        list.removeAll(parentUUIDs);
-
-        Iterator i = propertyEntries.iterator();
-        while (i.hasNext()) {
-            list.remove(i.next());
-        }
-
+        list.removeAll(propertyEntries);
-        ArrayList list = new ArrayList(other.childNodeEntries.entries());
-
-        Iterator i = childNodeEntries.entries().iterator();
-        while (i.hasNext()) {
-            list.remove(i.next());
-        }
-
-        return list;
+        return other.childNodeEntries.removeAll(childNodeEntries);
-     * @param parentUUID the parent <code>NodeState</code>'s UUID or <code>null</code>
-     *                   if either this item state should represent the root node or this item state
-     *                   should be 'free floating', i.e. detached from the repository's hierarchy.
+     * @param parentUUID the parent <code>NodeState</code>'s UUID or
+     *                   <code>null</code> if either this item state should
+     *                   represent the root node or this item state should
+     *                   be 'free floating', i.e. detached from the repository's
+     *                   hierarchy.
-        // @todo is this correct?
-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
+    private void readObject(ObjectInputStream in)
+            throws IOException, ClassNotFoundException {
+        List get(QName nodeName) {
+            List siblings = (List) names.get(nodeName);
+            if (siblings == null) {
+                return Collections.EMPTY_LIST;
+            } else {
+                return Collections.unmodifiableList(siblings);
+            }
+        }
+
+        boolean remove(QName nodeName, String uuid) {
+            List siblings = (List) names.get(nodeName);
+            if (siblings == null || siblings.isEmpty()) {
+                return false;
+            }
+
+            Iterator iter = siblings.iterator();
+            while (iter.hasNext()) {
+                ChildNodeEntry entry = (ChildNodeEntry) iter.next();
+                if (entry.getUUID().equals(uuid)) {
+                    return remove(entry);
+                }
+            }
+            return false;
+        }
+
+        List get(String uuid) {
+            if (entries.isEmpty()) {
+                return Collections.EMPTY_LIST;
+            }
+            ArrayList list = new ArrayList();
+            Iterator iter = entries.iterator();
+            while (iter.hasNext()) {
+                ChildNodeEntry entry = (ChildNodeEntry) iter.next();
+                if (entry.getUUID().equals(uuid)) {
+                    list.add(entry);
+                }
+            }
+            return Collections.unmodifiableList(list);
+        }
+
+
+        /**
+         * Returns a list of <code>ChildNodeEntry</code>s who do only exist in
+         * <code>this</code> but not in <code>other</code>
+         * <p/>
+         * Note that two entries are considered identical in this context if
+         * they have the same name and uuid, i.e. the index is disregarded,
+         * whereas <code>ChildNodeEntry.equals(Object)</code> also compares
+         * the index.
+         *
+         * @param other entries to be removed
+         * @return a new list of entries who do only exist in <code>this</code>
+         *         but not in <code>other</code>
+         */
+        List removeAll(ChildNodeEntries other) {
+            if (entries.isEmpty()) {
+                return Collections.EMPTY_LIST;
+            }
+            if (other.entries.isEmpty()) {
+                return Collections.unmodifiableList(entries);
+            }
+
+            ChildNodeEntries result = new ChildNodeEntries();
+            result.addAll(entries);
+
+            Iterator iter = other.entries.iterator();
+            while (iter.hasNext()) {
+                ChildNodeEntry entry = (ChildNodeEntry) iter.next();
+                result.remove(entry.getName(), entry.getUUID());
+            }
+            return result.entries;
+        }

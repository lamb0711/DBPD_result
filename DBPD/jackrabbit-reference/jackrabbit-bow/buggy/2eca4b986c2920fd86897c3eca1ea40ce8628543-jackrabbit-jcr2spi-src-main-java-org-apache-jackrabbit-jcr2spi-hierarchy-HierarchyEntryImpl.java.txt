JCR-1799 updating events swallowed (CacheBehavior.OBSERVATION)   	
JCR-1783 incomplete changelog when combining move with removal of new destination parent

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@704361 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.state.ItemState;
+import org.apache.jackrabbit.jcr2spi.state.Status;
+import org.apache.jackrabbit.jcr2spi.state.ItemStateFactory;
-import org.apache.jackrabbit.jcr2spi.state.ItemState;
-import org.apache.jackrabbit.jcr2spi.state.ChangeLog;
-import org.apache.jackrabbit.jcr2spi.state.Status;
-import javax.jcr.RepositoryException;
+import javax.jcr.RepositoryException;
-                // only set 'target' if not already by upon resolution
-                if (!isAvailable()) {
+                // set the item state unless 'setItemState' has already been
+                // called by the ItemStateFactory (recall internalGetItemState)
+                if (internalGetItemState() == null) {
-     *
-    /**
-     *
-     * @param entry
-     */
-    static void removeEntry(HierarchyEntryImpl entry) {
-        ItemState state = entry.internalGetItemState();
-        if (state != null) {
-            state.setStatus(Status.REMOVED);
-        }
-    }
-        if (state == null || (denotesNode() && !state.isNode()) || (!denotesNode() && state.isNode())) {
+        ItemState currentState = internalGetItemState();
+        if (state == null || state == currentState || denotesNode() != state.isNode()) {
-        if (isAvailable()) {
-            throw new IllegalStateException("HierarchyEntry has already been resolved.");
+        if (currentState == null) {
+            // not connected yet to an item state. either a new entry or
+            // an unresolved hierarchy entry.
+            target = new WeakReference(state);
+        } else {
+            // was already resolved before -> merge the existing state
+            // with the passed state.
+            int currentStatus = currentState.getStatus();
+            boolean keepChanges = Status.isTransient(currentStatus) || Status.isStale(currentStatus);
+            boolean modified = currentState.merge(state, keepChanges);
+            if (currentStatus == Status.INVALIDATED) {
+                currentState.setStatus(Status.EXISTING);
+            } else if (modified) {
+                currentState.setStatus(Status.MODIFIED);
+            } // else: not modified. just leave status as it is.
-        target = new WeakReference(state);
-            // session-state TODO: only invalidate if existing?
-            if (state.getStatus() == Status.EXISTING) {
-                state.setStatus(Status.INVALIDATED);
-            }
+            state.setStatus(Status.INVALIDATED);
-                // revert state from overlayed
+                // revert state modifications
-                // revert state from overlayed
+                // revert state modifications
-                if (!denotesNode()) {
-                    parent.revertPropertyRemoval((PropertyEntry) this);
-                }
-                remove();
+                // however: don't remove the complete hierarchy
+                state.setStatus(Status.REMOVED);
+                parent.internalRemoveChildEntry(this);
-                // overlayed does not exist any more -> remove it
+                // overlayed does not exist any more -> reverting of pending
+                // transient changes (that lead to the stale status) can be
+                // omitted and the entry is complete removed instead.
-                // State was implicitely reverted
+                // State was implicitely reverted or external modifications
+                // reverted the modification.
-     /**
+    /**
-        ItemState state = internalGetItemState();
-        if (state == null) {
-            // nothing to do. entry will be validated upon resolution.
+        int status = getStatus();
+        if (status == Status._UNDEFINED_) {
+            // unresolved: entry will be loaded and validated upon resolution.
-        /*
-        if keepChanges is true only existing or invalidated states must be
-        updated. otherwise the state gets updated and might be marked 'Stale'
-        if transient changes are present and the workspace-state is modified.
-        */
-        // TODO: check again if 'reload' is not possible for transiently-modified state
-        if (!keepChanges || state.getStatus() == Status.EXISTING
-            || state.getStatus() == Status.INVALIDATED) {
-            // reload the workspace state from the persistent layer
-            state.reload(keepChanges);
+        if (Status.isTransient(status) || Status.isStale(status) || Status.isTerminal(status)) {
+            // transient || stale: avoid reloading
+            // new || terminal: cannot be reloaded from persistent layer anyway.
+            log.debug("Skip reload for item with status " + Status.getName(status) + ".");
+            return;
+        }
+        /**
+         * Retrieved a fresh ItemState from the persistent layer. Which will
+         * then be merged into the current state.
+         */
+        try {
+            ItemStateFactory isf = factory.getItemStateFactory();
+            if (denotesNode()) {
+                NodeEntry ne = (NodeEntry) this;
+                isf.createNodeState(ne.getWorkspaceId(), ne);
+            } else {
+                PropertyEntry pe = (PropertyEntry) this;
+                isf.createPropertyState(pe.getWorkspaceId(), pe);
+            }
+        } catch (ItemNotFoundException e) {
+            // remove hierarchyEntry including all children
+            log.debug("Item '" + getName() + "' cannot be found on the persistent layer -> remove.");
+            remove();
+        } catch (RepositoryException e) {
+            // TODO: rather throw?
+            log.error("Exception while reloading item: " + e);
-            // check if upon reload the item has been removed -> nothing to do
-            if (Status.isTerminal(state.getStatus())) {
-                return;
-            }
-                remove();
+                state.setStatus(Status.REMOVED);
+                parent.internalRemoveChildEntry(this);
-
-    /**
-     * {@inheritDoc}
-     * @see HierarchyEntry#collectStates(ChangeLog, boolean)
-     */
-    public void collectStates(ChangeLog changeLog, boolean throwOnStale) throws InvalidItemStateException {
-        ItemState state = internalGetItemState();
-        if (state == null) {
-            // nothing to do
-            return;
-        }
-
-        if (throwOnStale && Status.isStale(state.getStatus())) {
-            String msg = "Cannot save changes: " + state + " has been modified externally.";
-            log.debug(msg);
-            throw new InvalidItemStateException(msg);
-        }
-        // only interested in transient modifications or stale states
-        switch (state.getStatus()) {
-            case Status.NEW:
-                changeLog.added(state);
-                break;
-            case Status.EXISTING_MODIFIED:
-            case Status.STALE_MODIFIED:
-            case Status.STALE_DESTROYED:
-                changeLog.modified(state);
-                break;
-            case Status.EXISTING_REMOVED:
-                changeLog.deleted(state);
-                break;
-            default:
-                log.debug("Collecting states: Ignored ItemState with status " + Status.getName(state.getStatus()));
-        }
-    }

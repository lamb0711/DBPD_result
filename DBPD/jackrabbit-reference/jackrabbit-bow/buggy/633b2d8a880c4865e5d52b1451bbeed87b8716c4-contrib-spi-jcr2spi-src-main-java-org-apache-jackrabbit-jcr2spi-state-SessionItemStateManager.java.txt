fixed: move, reorder (work in progress)
fixed: locktoken transfer
fixed: recursive transient removal of invalidated tree fails (restoreTests)
improve: simplify usage of workspace operations
fixed: store original itemId with transient operations in order to properly reflect the changelog upon batch creation
fixed: workspace import doesn't invalidate
fixed: session import uuid handling




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@513279 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeConflictException;
+import org.apache.jackrabbit.jcr2spi.operation.WorkspaceImport;
-import org.apache.commons.collections.iterators.IteratorChain;
-            // now do it for real
-            // TODO: check if states are reverted in correct order
-            Iterator[] its = new Iterator[] {changeLog.addedStates(), changeLog.deletedStates(), changeLog.modifiedStates()};
-            IteratorChain chain = new IteratorChain(its);
-            while (chain.hasNext()) {
-                ItemState state = (ItemState) chain.next();
-                state.getHierarchyEntry().revert();
-            }
-
+            // let changelog revert all changes
+            changeLog.undo();
-        setPropertyStateValue(pState, operation.getValues(), operation.getPropertyType(), options);
+        setPropertyStateValue(pState, operation.getValues(), operation.getValueType(), options);
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(WorkspaceImport)
+     */
+    public void visit(WorkspaceImport operation) throws RepositoryException {
+        throw new UnsupportedOperationException("Internal error: WorkspaceImport cannot be handled by session ItemStateManager.");
+    }
+
-        // autocreated child nodes that my are 'protected' by their def.
+        // autocreated child nodes that may be 'protected'.
+        // a new NodeState doesn't have mixins defined yet -> ent is ent of primarytype
+        EffectiveNodeType ent = validator.getEffectiveNodeType(nodeTypeName);
-        try {
-            validator.getEffectiveNodeType(new QName[]{nodeTypeName});
-        } catch (NodeTypeConflictException e) {
-            throw new RepositoryException("node type conflict: " + e.getMessage());
-        }
-        NodeState nodeState = transientStateMgr.createNewNodeState(nodeName, uuid, nodeTypeName, definition, parent);
+        // create new nodeState. NOTE, that the uniqueID is not added to the
+        // state for consistency between 'addNode' and importXML // TODO review
+        NodeState nodeState = transientStateMgr.createNewNodeState(nodeName, null, nodeTypeName, definition, parent);
+        if (uuid != null) {
+            QValue[] value = getQValues(uuid, qValueFactory);
+            EffectiveNodeType effnt = validator.getEffectiveNodeType(QName.MIX_REFERENCEABLE);
+            QPropertyDefinition pDef = effnt.getApplicablePropertyDefinition(QName.JCR_UUID, PropertyType.STRING, false);
+            addPropertyState(nodeState, QName.JCR_UUID, PropertyType.STRING, value, pDef, 0);
+        }
-        EffectiveNodeType ent = validator.getEffectiveNodeType(nodeState);
-            QValue[] autoValue = computeSystemGeneratedPropertyValues(nodeState, pd);
-            if (autoValue != null) {
-                int propOptions = ItemStateValidator.CHECK_NONE;
-                // execute 'addProperty' without adding operation.
-                addPropertyState(nodeState, pd.getQName(), pd.getRequiredType(), autoValue, pd, propOptions);
+            if (!nodeState.hasPropertyName(pd.getQName())) {
+                QValue[] autoValue = computeSystemGeneratedPropertyValues(nodeState, pd);
+                if (autoValue != null) {
+                    int propOptions = ItemStateValidator.CHECK_NONE;
+                    // execute 'addProperty' without adding operation.
+                    addPropertyState(nodeState, pd.getQName(), pd.getRequiredType(), autoValue, pd, propOptions);
+                }
-                String uniqueID = parent.getUniqueID();
-                if (uniqueID == null) {
-                    uniqueID = UUID.randomUUID().toString();
-                }
-                genValues = new QValue[]{qValueFactory.create(uniqueID, PropertyType.REFERENCE)};
+                genValues = getQValues(parent.getUniqueID(), qValueFactory);
+
+    private static QValue[] getQValues(String uniqueID, QValueFactory factory) {
+        if (uniqueID == null) {
+            uniqueID = UUID.randomUUID().toString();
+        }
+        return new QValue[] {factory.create(uniqueID, PropertyType.STRING)};
+    }

* Remove fieldType. this attribute is not used in the object mapping. 
* Review one constructor in ObjectContentManagerImpl.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@563252 13f79535-47bb-0310-9956-ffa450edef68

-        this.jcrNodeType = jcrNodeType;
+    	if (jcrNodeType != null && ! jcrNodeType.equals(""))
+    	{
+    	   this.jcrNodeType = jcrNodeType;
+    	}
-        this.jcrSuperTypes = superTypes;
+
+    	if (superTypes != null && ! superTypes.equals(""))
+    	{
+    	   this.jcrSuperTypes = superTypes;
+    	}
+    	
-
+    public void setJcrMixinTypes(String mixinTypes) {                
+    	if (mixinTypes != null && ! mixinTypes.equals(""))
+    	{
+    	    jcrMixinTypes = mixinTypes.split(" *, *");
+    	}
+    }
-        this.superClassName = className;
+        if (className.equals("")) className = null;
+    	this.superClassName = className;
-//            else {
-//                log.warn("Collection name conflict in " + this.className + " - field : " +collectionDescriptor.getFieldName() + " -  this  field name is also defined  in the ancestor class : " + this.getExtend());
-//            }
-    
-//    private List mergeInterfaces(List  existing, Collection superSource) {
-//        if (null == superSource) {
-//            return existing;
-//        }
-//
-//        ArrayList merged = new ArrayList(existing);
-//        for (Iterator it = superSource.iterator(); it.hasNext();)
-//        {
-//             String interfaceName = (String) it.next();
-//             if (! merged.contains(interfaceName))
-//             {
-//            	     merged.add(interfaceName);
-//             }            	 
-//        }
-//        
-//        return merged;
-//    }    
-    
+       

JCR-202: Add configuration options for search manager

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@530696 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.state.ItemStateManager;
+import org.apache.jackrabbit.uuid.UUID;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermDocs;
+import org.xml.sax.SAXException;
+import org.w3c.dom.Element;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.ParserConfigurationException;
+import java.util.HashMap;
+import java.util.Map;
+     * The namespace mappings used internally.
+     */
+    private NamespaceMappings nsMappings;
+
+    /**
+     * The path to the indexing configuration file.
+     */
+    private String indexingConfigPath;
+
+    /**
+     * The DOM with the indexing configuration or <code>null</code> if there
+     * is no such configuration.
+     */
+    private Element indexingConfiguration;
+
+    /**
+     * The indexing configuration.
+     */
+    private IndexingConfiguration indexingConfig;
+
+    /**
+     * The indexing configuration class.
+     * Implements {@link IndexingConfiguration}.
+     */
+    private Class indexingConfigurationClass = IndexingConfigurationImpl.class;
+
+    /**
+        indexingConfig = createIndexingConfiguration();
-        NamespaceMappings nsMappings;
+        final Map aggregateRoots = new HashMap();
+        final Set removedNodeIds = new HashSet();
+        final Set addedNodeIds = new HashSet();
-                return ((NodeId) super.next()).getUUID();
+                NodeId nodeId = (NodeId) super.next();
+                removedNodeIds.add(nodeId);
+                return nodeId.getUUID();
+                addedNodeIds.add(state.getNodeId());
+                removedNodeIds.remove(state.getNodeId());
+                retrieveAggregateRoot(state, aggregateRoots);
+
+        // remove any aggregateRoot nodes that are new
+        // and therefore already up-to-date
+        aggregateRoots.keySet().removeAll(addedNodeIds);
+
+        // based on removed NodeIds get affected aggregate root nodes
+        retrieveAggregateRoot(removedNodeIds, aggregateRoots);
+
+        // update aggregates if there are any affected
+        if (aggregateRoots.size() > 0) {
+            index.update(new AbstractIteratorDecorator(
+                    aggregateRoots.keySet().iterator()) {
+                public Object next() {
+                    return ((NodeId) super.next()).getUUID();
+                }
+            }, new AbstractIteratorDecorator(aggregateRoots.values().iterator()) {
+                public Object next() {
+                    NodeState state = (NodeState) super.next();
+                    try {
+                        return createDocument(state, getNamespaceMappings());
+                    } catch (RepositoryException e) {
+                        log.error("Exception while creating document for node: "
+                                + state.getNodeId() + ": " + e.toString());
+                    }
+                    return null;
+                }
+            });
+        }
-        return index.getNamespaceMappings();
+        return nsMappings;
-        return indexer.createDoc();
+        indexer.setIndexingConfiguration(indexingConfig);
+        Document doc = indexer.createDoc();
+        mergeAggregatedNodeIndexes(node, doc);
+        return doc;
+    /**
+     * @return the fulltext indexing configuration or <code>null</code> if there
+     *         is no configuration.
+     */
+    protected IndexingConfiguration createIndexingConfiguration() {
+        Element docElement = getIndexingConfigurationDOM();
+        if (docElement == null) {
+            return null;
+        }
+        try {
+            IndexingConfiguration idxCfg = (IndexingConfiguration)
+                    indexingConfigurationClass.newInstance();
+            idxCfg.init(docElement, getContext());
+            return idxCfg;
+        } catch (Exception e) {
+            log.warn("Exception initializing indexing configuration from: " +
+                    indexingConfigPath, e);
+        }
+        log.warn(indexingConfigPath + " ignored.");
+        return null;
+    }
+
+    /**
+     * Returns the document element of the indexing configuration or
+     * <code>null</code> if there is no indexing configuration.
+     *
+     * @return the indexing configuration or <code>null</code> if there is
+     *         none.
+     */
+    protected Element getIndexingConfigurationDOM() {
+        if (indexingConfiguration != null) {
+            return indexingConfiguration;
+        }
+        if (indexingConfigPath == null) {
+            return null;
+        }
+        File config = new File(indexingConfigPath);
+        if (!config.exists()) {
+            log.warn("File does not exist: " + indexingConfigPath);
+            return null;
+        } else if (!config.canRead()) {
+            log.warn("Cannot read file: " + indexingConfigPath);
+            return null;
+        }
+        try {
+            DocumentBuilderFactory factory =
+                    DocumentBuilderFactory.newInstance();
+            DocumentBuilder builder = factory.newDocumentBuilder();
+            builder.setEntityResolver(new IndexingConfigurationEntityResolver());
+            indexingConfiguration = builder.parse(config).getDocumentElement();
+        } catch (ParserConfigurationException e) {
+            log.warn("Unable to create XML parser", e);
+        } catch (IOException e) {
+            log.warn("Exception parsing " + indexingConfigPath, e);
+        } catch (SAXException e) {
+            log.warn("Exception parsing " + indexingConfigPath, e);
+        }
+        return indexingConfiguration;
+    }
+
+    /**
+     * Merges the fulltext indexed fields of the aggregated node states into
+     * <code>doc</code>.
+     *
+     * @param state the node state on which <code>doc</code> was created.
+     * @param doc the lucene document with index fields from <code>state</code>.
+     */
+    protected void mergeAggregatedNodeIndexes(NodeState state, Document doc) {
+        if (indexingConfig != null) {
+            AggregateRule aggregateRules[] = indexingConfig.getAggregateRules();
+            if (aggregateRules == null) {
+                return;
+            }
+            try {
+                for (int i = 0; i < aggregateRules.length; i++) {
+                    NodeState[] aggregates = aggregateRules[i].getAggregatedNodeStates(state);
+                    if (aggregates == null) {
+                        continue;
+                    }
+                    for (int j = 0; j < aggregates.length; j++) {
+                        Document aDoc = createDocument(aggregates[j],
+                                getNamespaceMappings());
+                        // transfer fields to doc if there are any
+                        Field[] fulltextFields = aDoc.getFields(FieldNames.FULLTEXT);
+                        if (fulltextFields != null) {
+                            for (int k = 0; k < fulltextFields.length; k++) {
+                                doc.add(fulltextFields[k]);
+                            }
+                            doc.add(new Field(FieldNames.AGGREGATED_NODE_UUID,
+                                    aggregates[j].getNodeId().getUUID().toString(),
+                                    Field.Store.NO,
+                                    Field.Index.NO_NORMS));
+                        }
+                    }
+                    // only use first aggregate definition that matches
+                    break;
+                }
+            } catch (Exception e) {
+                // do not fail if aggregate cannot be created
+                log.warn("Exception while building indexing aggregate for " +
+                        "node with UUID: " + state.getNodeId().getUUID(), e);
+            }
+        }
+    }
+
+    /**
+     * Retrieves the root of the indexing aggregate for <code>state</code> and
+     * puts it into <code>map</code>.
+     *
+     * @param state the node state for which we want to retrieve the aggregate
+     *              root.
+     * @param map   aggregate roots are collected in this map. Key=NodeId,
+     *              value=NodeState.
+     */
+    protected void retrieveAggregateRoot(NodeState state, Map map) {
+        if (indexingConfig != null) {
+            AggregateRule aggregateRules[] = indexingConfig.getAggregateRules();
+            if (aggregateRules == null) {
+                return;
+            }
+            try {
+                for (int i = 0; i < aggregateRules.length; i++) {
+                    NodeState root = aggregateRules[i].getAggregateRoot(state);
+                    if (root != null) {
+                        map.put(root.getNodeId(), root);
+                        break;
+                    }
+                }
+            } catch (Exception e) {
+                log.warn("Unable to get aggregate root for " +
+                        state.getNodeId().getUUID(), e);
+            }
+        }
+    }
+
+    /**
+     * Retrieves the root of the indexing aggregate for <code>removedNodeIds</code>
+     * and puts it into <code>map</code>.
+     *
+     * @param removedNodeIds the ids of removed nodes.
+     * @param map            aggregate roots are collected in this map.
+     *                       Key=NodeId, value=NodeState.
+     */
+    protected void retrieveAggregateRoot(Set removedNodeIds, Map map) {
+        if (indexingConfig != null) {
+            AggregateRule aggregateRules[] = indexingConfig.getAggregateRules();
+            if (aggregateRules == null) {
+                return;
+            }
+            int found = 0;
+            long time = System.currentTimeMillis();
+            try {
+                IndexReader reader = index.getIndexReader();
+                try {
+                    Term aggregateUUIDs = new Term(
+                            FieldNames.AGGREGATED_NODE_UUID, "");
+                    TermDocs tDocs = reader.termDocs();
+                    try {
+                        ItemStateManager ism = getContext().getItemStateManager();
+                        for (Iterator it = removedNodeIds.iterator(); it.hasNext(); ) {
+                            NodeId id = (NodeId) it.next();
+                            aggregateUUIDs = aggregateUUIDs.createTerm(
+                                    id.getUUID().toString());
+                            tDocs.seek(aggregateUUIDs);
+                            while (tDocs.next()) {
+                                Document doc = reader.document(tDocs.doc());
+                                String uuid = doc.get(FieldNames.UUID);
+                                NodeId nId = new NodeId(UUID.fromString(uuid));
+                                map.put(nId, ism.getItemState(nId));
+                                found++;
+                            }
+                        }
+                    } finally {
+                        tDocs.close();
+                    }
+                } finally {
+                    reader.close();
+                }
+            } catch (Exception e) {
+                log.warn("Exception while retrieving aggregate roots", e);
+            }
+            time = System.currentTimeMillis() - time;
+            log.debug("Retrieved {} aggregate roots in {} ms.",
+                    new Integer(found), new Long(time));
+        }
+    }
+
+    /**
+     * Sets the path to the indexing configuration file.
+     *
+     * @param path the path to the configuration file.
+     */
+    public void setIndexingConfiguration(String path) {
+        indexingConfigPath = path;
+    }
+
+    /**
+     * @return the path to the indexing configuration file.
+     */
+    public String getIndexingConfiguration() {
+        return indexingConfigPath;
+    }
+
+    /**
+     * Sets the name of the class that implements {@link IndexingConfiguration}.
+     * The default value is <code>org.apache.jackrabbit.core.query.lucene.IndexingConfigurationImpl</code>.
+     *
+     * @param className the name of the class that implements {@link
+     *                  IndexingConfiguration}.
+     */
+    public void setIndexingConfigurationClass(String className) {
+        try {
+            Class clazz = Class.forName(className);
+            if (IndexingConfiguration.class.isAssignableFrom(clazz)) {
+                indexingConfigurationClass = clazz;
+            } else {
+                log.warn("Invalid value for indexingConfigurationClass, {} " +
+                        "does not implement IndexingConfiguration interface.",
+                        className);
+            }
+        } catch (ClassNotFoundException e) {
+            log.warn("Invalid value for indexingConfigurationClass, class {} " +
+                    "not found.", className);
+        }
+    }
+
+    /**
+     * @return the class name of the indexing configuration implementation.
+     */
+    public String getIndexingConfigurationClass() {
+        return indexingConfigurationClass.getName();
+    }
+

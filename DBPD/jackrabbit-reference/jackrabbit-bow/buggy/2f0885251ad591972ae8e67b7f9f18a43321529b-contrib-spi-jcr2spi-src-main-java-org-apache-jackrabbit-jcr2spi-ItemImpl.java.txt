Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.state.NodeState;
+import org.apache.jackrabbit.jcr2spi.hierarchy.NodeEntry;
-     * @see javax.jcr.Item#getParent()
+     * @see Item#getParent()
-    public abstract Node getParent() throws ItemNotFoundException, AccessDeniedException, RepositoryException;
+    public Node getParent() throws ItemNotFoundException, AccessDeniedException, RepositoryException {
+        checkStatus();
+
+        // special treatment for root node
+        if (state.isNode() && ((NodeState)state).isRoot()) {
+            String msg = "Root node doesn't have a parent.";
+            log.debug(msg);
+            throw new ItemNotFoundException(msg);
+        }
+
+        NodeEntry parentEntry = getItemState().getHierarchyEntry().getParent();
+        return (Node) itemMgr.getItem(parentEntry);
+    }
-        if (state.getParent() == null) {
+        if (state.isNode() && ((NodeState)state).isRoot()) {
-        return session.getHierarchyManager().getDepth(state);
+        return session.getHierarchyManager().getDepth(state.getHierarchyEntry());
-        if (Status.isTerminal(state.getStatus())) {
+        if (Status.isTerminal(state.getStatus()) || Status.EXISTING_REMOVED == state.getStatus()) {
-                state.reload(true);
+                state.getHierarchyEntry().reload(true, true);
-                state.invalidate(true);
+                state.getHierarchyEntry().invalidate(true);
-            state.reload(false);
+            state.getHierarchyEntry().reload(false, false);
+    /**
+     * Returns true if the repository supports level 2 (writing). Note, that
+     * this method does not perform any additional validation tests such as
+     * access restrictions, locking, checkin status or protection that affect
+     * the writing to nodes and properties.
+     *
+     * @throws UnsupportedRepositoryOperationException
+     * @throws RepositoryException if the sanity check on this item fails.
+     * See {@link ItemImpl#checkStatus()}. 
+     * @see ItemStateValidator
+     */
+    protected boolean isWritable() throws RepositoryException {
+        checkStatus();
+        return session.isSupportedOption(Repository.LEVEL_2_SUPPORTED);
+    }
+

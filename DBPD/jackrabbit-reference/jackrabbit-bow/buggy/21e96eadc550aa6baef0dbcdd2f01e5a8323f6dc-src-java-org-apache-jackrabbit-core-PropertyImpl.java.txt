migrating to v0.15 of the jsr 170 spec

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@55516 13f79535-47bb-0310-9956-ffa450edef68

-import javax.jcr.access.AccessDeniedException;
-    public Value[] getValues() throws RepositoryException {
+    public Value[] getValues() throws ValueFormatException, RepositoryException {
-    public Value getValue() throws RepositoryException {
+    public Value getValue() throws ValueFormatException, RepositoryException {
-     * @see Property#hasValue()
-     */
-    public boolean hasValue() {
-        // check state of this instance
-        //checkItemState();
-
-        PropertyState state = (PropertyState) getItemState();
-        InternalValue[] values = state.getValues();
-        return values.length > 0;
-    }
-
-    /**
-    public long getLength() {
+    public long getLength() throws ValueFormatException, RepositoryException {
-        //checkItemState();
+        checkItemState();
+
+        // check multi-value flag
+        if (definition.isMultiple()) {
+            throw new ValueFormatException(safeGetJCRPath() + " is multi-valued");
+        }
-                    log.warn(safeGetJCRPath() + ": the value represents an invalid name", npde);
-                    return -1;
+                    String msg = safeGetJCRPath() + ": the value represents an invalid name";
+                    log.error(msg, npde);
+                    throw new RepositoryException(msg, npde);
-                    log.warn(safeGetJCRPath() + ": the value represents an invalid path", npde);
-                    return -1;
+                    String msg = safeGetJCRPath() + ": the value represents an invalid path";
+                    log.error(msg, npde);
+                    throw new RepositoryException(msg, npde);
+     * @see Property#getLengths
+     */
+    public long[] getLengths() throws ValueFormatException, RepositoryException {
+        // check state of this instance
+        checkItemState();
+
+        // check multi-value flag
+        if (!definition.isMultiple()) {
+            throw new ValueFormatException(safeGetJCRPath() + " is not multi-valued");
+        }
+
+        InternalValue[] values = ((PropertyState) state).getValues();
+        long[] lengths = new long[values.length];
+        for (int i = 0; i < values.length; i++) {
+            long length = -1;
+            InternalValue value = values[i];
+            switch (value.getType()) {
+                case PropertyType.STRING:
+                case PropertyType.LONG:
+                case PropertyType.DOUBLE:
+                    length = value.toString().length();
+
+                case PropertyType.NAME:
+                    QName name = (QName) value.internalValue();
+                    try {
+                        length = name.toJCRName(session.getNamespaceResolver()).length();
+                    } catch (NoPrefixDeclaredException npde) {
+                        // should never happen...
+                        String msg = safeGetJCRPath() + ": the value represents an invalid name";
+                        log.error(msg, npde);
+                        throw new RepositoryException(msg, npde);
+                    }
+
+                case PropertyType.PATH:
+                    Path path = (Path) value.internalValue();
+                    try {
+                        length = path.toJCRPath(session.getNamespaceResolver()).length();
+                    } catch (NoPrefixDeclaredException npde) {
+                        // should never happen...
+                        String msg = safeGetJCRPath() + ": the value represents an invalid path";
+                        log.error(msg, npde);
+                        throw new RepositoryException(msg, npde);
+                    }
+
+                case PropertyType.BINARY:
+                    BLOBFileValue blob = (BLOBFileValue) value.internalValue();
+                    length = blob.getLength();
+            }
+            lengths[i] = length;
+        }
+        return lengths;
+    }
+
+    /**

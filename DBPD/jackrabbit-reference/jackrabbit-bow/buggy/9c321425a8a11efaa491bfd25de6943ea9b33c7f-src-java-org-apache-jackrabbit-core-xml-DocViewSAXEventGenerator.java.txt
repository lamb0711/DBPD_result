reimplemented Session.export* according to latest spec

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@151373 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.state.ItemStateManager;
-import org.apache.jackrabbit.core.state.NodeState;
-import org.apache.jackrabbit.core.state.PropertyState;
+import org.apache.jackrabbit.core.util.ISO9075;
+import org.apache.jackrabbit.core.util.Text;
-import org.apache.xerces.util.XMLChar; 
-import javax.jcr.InvalidSerializedDataException;
+import javax.jcr.Value;
-    protected final HierarchyManager hierMgr;
-
-     * @param nodeState      the node state which should be serialized
-     * @param nodeName       name of the node to be serialized
-     * @param noRecurse      if true, only <code>nodeState</code> and its properties will
+     * @param node           the node state which should be serialized
+     * @param noRecurse      if true, only <code>node</code> and its properties will
-     *                       <code>nodeState</code> will be serialized.
-     * @param binaryAsLink   specifies if binary properties are turned into links
-     * @param stateProvider  item state provider for retrieving child item state
-     * @param nsReg          the namespace registry to be used for namespace declarations
-     * @param accessMgr      the access manager
-     * @param hierMgr        the hierarchy manager used to resolve paths
+     *                       <code>node</code> will be serialized.
+     * @param skipBinary     flag governing whether binary properties are to be serialized.
+     * @param session        the session to be used for resolving namespace mappings
-    public DocViewSAXEventGenerator(NodeState nodeState, QName nodeName,
-                                    boolean noRecurse, boolean binaryAsLink,
-                                    ItemStateManager stateProvider,
-                                    NamespaceRegistryImpl nsReg,
-                                    AccessManagerImpl accessMgr,
-                                    HierarchyManager hierMgr,
+    public DocViewSAXEventGenerator(NodeImpl node, boolean noRecurse,
+                                    boolean skipBinary,
+                                    SessionImpl session,
-        super(nodeState, nodeName, noRecurse, binaryAsLink,
-                stateProvider, nsReg, accessMgr, contentHandler);
-        this.hierMgr = hierMgr;
+        super(node, noRecurse, skipBinary, session, contentHandler);
-     * @see AbstractSAXEventGenerator#entering(NodeState, QName, int)
+     * @see AbstractSAXEventGenerator#entering(NodeImpl, int)
-    protected void entering(NodeState state, QName name, int level)
+    protected void entering(NodeImpl node, int level)
-     * @see AbstractSAXEventGenerator#enteringProperties(NodeState, QName, int)
+     * @see AbstractSAXEventGenerator#enteringProperties(NodeImpl, int)
-    protected void enteringProperties(NodeState state, QName name, int level)
+    protected void enteringProperties(NodeImpl node, int level)
-     * @see AbstractSAXEventGenerator#leavingProperties(NodeState, QName, int)
+     * @see AbstractSAXEventGenerator#leavingProperties(NodeImpl, int)
-    protected void leavingProperties(NodeState state, QName name, int level)
+    protected void leavingProperties(NodeImpl node, int level)
+        QName name = node.getQName();
-                PropertyState propState = (PropertyState) iter.next();
-                QName propName = propState.getName();
+                PropertyImpl prop = (PropertyImpl) iter.next();
+                QName propName = prop.getQName();
-                    InternalValue val = propState.getValues()[0];
-                    char[] chars = val.toJCRValue(nsReg).getString().toCharArray();
+                    // assume jcr:xmlcharacters is single-valued
+                    char[] chars = prop.getValue().getString().toCharArray();
+            // encode node name to make sure it's a valid xml name
+            name = ISO9075.encode(name);
-                if (state.getParentUUIDs().size() == 0) {
+                if (node.isRepositoryRoot()) {
-                    elemName = NODENAME_ROOT.toJCRName(nsReg);
+                    elemName = NODENAME_ROOT.toJCRName(session.getNamespaceResolver());
-                    elemName = name.toJCRName(nsReg);
+                    elemName = name.toJCRName(session.getNamespaceResolver());
-            if (!XMLChar.isValidName(elemName)) {
-                throw new InvalidSerializedDataException("the node name is not a valid xml element name: " + elemName);
-            }
-                PropertyState propState = (PropertyState) iter.next();
-                QName propName = propState.getName();
+                PropertyImpl prop = (PropertyImpl) iter.next();
+                if (prop.getType() == PropertyType.BINARY && skipBinary) {
+                    continue;
+                }
+                QName propName = prop.getQName();
+                // encode property name to make sure it's a valid xml name
+                propName = ISO9075.encode(propName);
-                    attrName = propName.toJCRName(nsReg);
+                    attrName = propName.toJCRName(session.getNamespaceResolver());
-                if (!XMLChar.isValidName(attrName)) {
-                    throw new InvalidSerializedDataException("the property name is not a valid xml attribute name: " + attrName);
-                }
-                String attrValue;
-                int type = propState.getType();
-                // process property value (guaranteed to be single-valued and non-null)
-                InternalValue val = propState.getValues()[0];
-                if (type == PropertyType.BINARY) {
-                    if (binaryAsLink) {
-                        try {
-                            attrValue = hierMgr.getPath(new PropertyId(propState.getParentUUID(), propState.getName())).toJCRPath(nsReg);
-                        } catch (NoPrefixDeclaredException npde) {
-                            // should never get here...
-                            String msg = "internal error: encountered unregistered namespace";
-                            log.debug(msg);
-                            throw new RepositoryException(msg, npde);
-                        }
-                    } else {
+                StringBuffer attrValue = new StringBuffer();
+                // process property value(s)
+                boolean multiValued = prop.getDefinition().isMultiple();
+                Value[] vals;
+                if (multiValued) {
+                    vals = prop.getValues();
+                } else {
+                    vals = new Value[]{prop.getValue()};
+                }
+                for (int i = 0; i < vals.length; i++) {
+                    if (i > 0) {
+                        // use space as delimiter for multi-valued properties
+                        attrValue.append(" ");
+                    }
+                    Value val = vals[i];
+                    String textVal;
+                    if (prop.getType() == PropertyType.BINARY) {
-                        BLOBFileValue blob = (BLOBFileValue) val.internalValue();
-                        InputStream in = blob.getStream();
+                        InputStream in = val.getStream();
-                            in.close();
-                            writer.close();
+                            // no need to close StringWriter
+                            //writer.close();
+                        } finally {
+                            try {
+                                in.close();
+                            } catch (IOException e) {
+                                // ignore
+                            }
-                        attrValue = writer.toString();
+                        textVal = writer.toString();
+                    } else {
+                        textVal = val.getString();
-                } else {
-                    attrValue = val.toJCRValue(nsReg).getString();
+                    // enocde spaces in value
+                    textVal = Text.replace(textVal, " ", "_x0020_");
+                    attrValue.append(textVal);
-                attrs.addAttribute(propName.getNamespaceURI(), propName.getLocalName(), attrName, CDATA_TYPE, attrValue);
+                attrs.addAttribute(propName.getNamespaceURI(), propName.getLocalName(), attrName, CDATA_TYPE, attrValue.toString());
-     * @see AbstractSAXEventGenerator#leaving(NodeState, QName, int)
+     * @see AbstractSAXEventGenerator#leaving(NodeImpl, int)
-    protected void leaving(NodeState state, QName name, int level)
+    protected void leaving(NodeImpl node, int level)
+        QName name = node.getQName();
-            // (already processed in leavingProperties(NodeState, QName, int)
+            // (already processed in leavingProperties(NodeImpl, int)
-            if (state.getParentUUIDs().size() == 0) {
+            if (node.isRepositoryRoot()) {
-                elemName = NODENAME_ROOT.toJCRName(nsReg);
+                elemName = NODENAME_ROOT.toJCRName(session.getNamespaceResolver());
-                elemName = name.toJCRName(nsReg);
+                elemName = name.toJCRName(session.getNamespaceResolver());
-     * @see AbstractSAXEventGenerator#entering(PropertyState, int)
+     * @see AbstractSAXEventGenerator#entering(PropertyImpl, int)
-    protected void entering(PropertyState state, int level)
+    protected void entering(PropertyImpl prop, int level)
-        // @todo should properties declared in the 'jcr:' namespace be skipped in the document view export?
-/*
-	// skip 'system' properties (e.g. jcr:primaryType, jcr:mixinTypes, jcr:uuid)
-	if (NamespaceRegistryImpl.NS_JCR_URI.equals(state.getName().getNamespaceURI())) {
-	    return;
-	}
-*/
-        // collect property state in temporary list (will be processed in leavingProperties(NodeState, QName, int)
-        InternalValue[] values = state.getValues();
-        if (values != null && values.length > 0) {
-            if (values.length != 1) {
-                throw new InvalidSerializedDataException("unable to serialize multi-valued property in document view: " + state.getName().getLocalName());
-            }
-            if (values[0] != null) {
-                props.add(state);
-            }
-        }
+        props.add(prop);
-     * @see AbstractSAXEventGenerator#leaving(PropertyState, int)
+     * @see AbstractSAXEventGenerator#leaving(PropertyImpl, int)
-    protected void leaving(PropertyState state, int level)
+    protected void leaving(PropertyImpl prop, int level)

JCR-1104 : JSR 283 support (security work in progress)

- user API: add distinction between declared and indirect group membership
- user Impl: move group membership to authorizable node type
- javadoc
- minor fixes/improvements

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@651624 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.NodeImpl;
-import org.apache.jackrabbit.core.PropertyImpl;
-import org.apache.jackrabbit.api.security.principal.PrincipalManager;
+import org.apache.jackrabbit.api.security.user.User;
+import org.apache.jackrabbit.core.NodeImpl;
-import javax.jcr.Property;
+import javax.jcr.PropertyIterator;
-import javax.jcr.Value;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
+     * @see Group#getDeclaredMembers()
+     */
+    public Iterator getDeclaredMembers() throws RepositoryException {
+        return getMembers(false).iterator();
+    }
+
+    /**
-        return new MemberIterator(memberUUIDs().iterator());
+        return getMembers(true).iterator();
+            String thisID = getID();
-            String uuid = impl.getNode().getUUID();
-            return memberUUIDs().contains(uuid);
+            for (Iterator it = impl.memberOf(); it.hasNext();) {
+                if (thisID.equals(((GroupImpl) it.next()).getID())) {
+                    return true;
+                }
+            }
+            return false;
-        Node memberNode = ((AuthorizableImpl) authorizable).getNode();
+        AuthorizableImpl authImpl = ((AuthorizableImpl) authorizable);
+        Node memberNode = authImpl.getNode();
-        Value[] values;
-        // TODO: replace by weak-refs
-        Value added = getSession().getValueFactory().createValue(memberNode);
-        NodeImpl node = getNode();
-        if (node.hasProperty(P_MEMBERS)) {
-            Value[] old = node.getProperty(P_MEMBERS).getValues();
-            values = new Value[old.length + 1];
-            System.arraycopy(old, 0, values, 0, old.length);
-        } else {
-            values = new Value[1];
-        }
-        values[values.length - 1] = added;
-        userManager.setProtectedProperty(node, P_MEMBERS, values);
-        return true;
+        // preconditions are met -> delegate to authorizableImpl
+        return authImpl.addToGroup(this);
-        NodeImpl node = getNode();
-        if (!node.hasProperty(P_MEMBERS)) {
-            log.debug("Group has no members -> cannot remove member " + authorizable.getID());
-            return false;
-        }
-
-        Value toRemove = getSession().getValueFactory().createValue(((AuthorizableImpl)authorizable).getNode());
-
-        PropertyImpl property = node.getProperty(P_MEMBERS);
-        List valList = new ArrayList(Arrays.asList(property.getValues()));
-
-        if (valList.remove(toRemove)) {
-            try {
-                if (valList.isEmpty()) {
-                    userManager.removeProtectedItem(property, node);
-                } else {
-                    Value[] values = (Value[]) valList.toArray(new Value[valList.size()]);
-                    userManager.setProtectedProperty(node, P_MEMBERS, values);
-                }
-                return true;
-            } catch (RepositoryException e) {
-                // modification failed -> revert all pending changes.
-                node.refresh(false);
-                throw e;
-            }
-        } else {
-            // nothing changed
-            log.debug("Authorizable " + authorizable.getID() + " was not member of " + getID());
-            return false;
-        }
+        return ((AuthorizableImpl) authorizable).removeFromGroup(this);
-
-    private Collection memberUUIDs() throws RepositoryException {
-        Collection tmp = new HashSet();
-        if (getNode().hasProperty(P_MEMBERS)) {
-            Property prop = getNode().getProperty(P_MEMBERS);
-            Value[] val = prop.getValues();
-            for (int i = 0; i < val.length; i++) {
-                tmp.add(val[i].getString());
+    private Collection getMembers(boolean includeIndirect) throws RepositoryException {
+        // TODO: replace by weak-refs
+        PropertyIterator itr = getNode().getReferences();
+        Collection members = new HashSet((int) itr.getSize());
+        while (itr.hasNext()) {
+            NodeImpl n = (NodeImpl) itr.nextProperty().getParent();
+            if (n.isNodeType(NT_REP_GROUP)) {
+                Group group = create(n, userManager);
+                // only retrieve indirect group-members if the group is not
+                // yet present (detected eventual circular membership).
+                if (members.add(group) && includeIndirect) {
+                    members.addAll(((GroupImpl) group).getMembers(true));
+                }
+            } else if (n.isNodeType(NT_REP_USER)) {
+                User user = UserImpl.create(n, userManager);
+                members.add(user);
-        return tmp;
+        return members;
-     * Since {@link #isMember(Authorizable)} only detects the declared
-     * members of this group, this methods is used to avoid cyclic membership
-     * declarations.
+     * Since {@link #isMember(Authorizable)} detects declared and inherited
+     * membership this method simply checks if the potential new member is
+     * a group that would in turn have <code>this</code> as a member.
-            if (!cyclic) {
-                PrincipalManager pmgr = getSession().getPrincipalManager();
-                for (Iterator it = pmgr.getGroupMembership(getPrincipal());
-                     it.hasNext() && !cyclic;) {
-                    cyclic = newMember.getPrincipal().equals(it.next());
-                }
-            }
-                        // TODO: check again. only add main principal, since
-                        // 'referees' belong to a different provider and should
-                        // not be exposed here
+                        // NOTE: only add main principal, since 'referees' belong
+                        // to a different provider and should not be exposed here

JCR-2209 Versioning operations should be done on the workspace


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@795866 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.NodeImpl;
-import org.apache.jackrabbit.core.PropertyImpl;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import java.util.HashSet;
+import java.util.Collections;
+
+import javax.jcr.PropertyType;
+import javax.jcr.RepositoryException;
+import javax.jcr.version.OnParentVersionAction;
+import javax.jcr.version.VersionException;
+
-import org.apache.jackrabbit.core.nodetype.NodeTypeImpl;
+import org.apache.jackrabbit.core.state.ChildNodeEntry;
-import org.apache.jackrabbit.core.state.ChildNodeEntry;
-import javax.jcr.NodeIterator;
-import javax.jcr.PropertyIterator;
-import javax.jcr.PropertyType;
-import javax.jcr.RepositoryException;
-import javax.jcr.nodetype.NodeType;
-import javax.jcr.version.OnParentVersionAction;
-import javax.jcr.version.VersionException;
-import java.util.ArrayList;
-import java.util.List;
-
-     * checkin mode version.
+     * checkin modes
-    private static final int MODE_VERSION = 0;
+    private static enum Mode {
+        /**
+         * checkin mode version.
+         */
+        VERSION,
+        /**
+         * checkin mode copy. specifies, that the items are always copied.
+         */
+        COPY,
-    /**
-     * checkin mode copy. specifies, that the items are always copied.
-     */
-    private static final int MODE_COPY = 1;
-
-    /**
-     * mode flag specifies, that the mode should be recursed. otherwise i
-     * will be redetermined by the opv.
-     */
-    private static final int MODE_COPY_RECURSIVE = 3;
+        /**
+         * mode flag specifies, that the mode should be recursed. otherwise i
+         * will be redetermined by the opv.
+         */
+        COPY_RECURSE
+    }
-    private Name[] frozenMixinTypes = null;
+    private Set<Name> frozenMixinTypes = null;
-     * @param node
-     * @throws javax.jcr.RepositoryException
+     * @param vMgr version manager
+     * @param node underlying node
+     * @param parent parent item
+     * @throws RepositoryException if an error occurs
+        Set<Name> mixins = new HashSet<Name>();
-                if (values == null) {
-                    frozenMixinTypes = new Name[0];
-                } else {
-                    frozenMixinTypes = new Name[values.length];
-                    for (int j = 0; j < values.length; j++) {
-                        frozenMixinTypes[j] = values[j].getName();
+                if (values != null) {
+                    for (InternalValue value : values) {
+                        mixins.add(value.getName());
-        frozenProperties = (PropertyState[]) propList.toArray(new PropertyState[propList.size()]);
+        frozenProperties = propList.toArray(new PropertyState[propList.size()]);
+        frozenMixinTypes = Collections.unmodifiableSet(mixins);
-        if (frozenMixinTypes == null) {
-            frozenMixinTypes = new Name[0];
-        }
-            for (int i = 0; i < frozen.length; i++) {
-                if (frozen[i] instanceof InternalFrozenVersionHistory
-                        && ((InternalFrozenVersionHistory) frozen[i])
-                            .getVersionHistoryId().equals(id)) {
+            for (InternalFreeze aFrozen : frozen) {
+                if (aFrozen instanceof InternalFrozenVersionHistory
+                        && ((InternalFrozenVersionHistory) aFrozen)
+                        .getVersionHistoryId().equals(id)) {
-    public Name[] getFrozenMixinTypes() {
+    public Set<Name> getFrozenMixinTypes() {
-     * @param parent
-     * @param name
-     * @param src
-     * @return
-     * @throws RepositoryException
+     * @param parent destination parent
+     * @param name new node name
+     * @param src source node state
+     * @return the node node state
+     * @throws RepositoryException if an error occurs
-                                         NodeImpl src)
+                                         NodeStateEx src)
-        return checkin(parent, name, src, MODE_VERSION);
+        try {
+            return checkin(parent, name, src, Mode.VERSION);
+        } catch (ItemStateException e) {
+            throw new RepositoryException(e);
+        }
-     * @param parent
-     * @param name
-     * @param src
-     * @return
-     * @throws RepositoryException
+     * @param parent destination parent
+     * @param name new node name
+     * @param src source node state
+     * @param mode checkin mode
+     * @return the nde node state
+     * @throws RepositoryException if an error occurs
+     * @throws ItemStateException if an error during reading the items occurs
-                                       NodeImpl src, int mode)
-            throws RepositoryException {
+                                       NodeStateEx src, Mode mode)
+            throws RepositoryException, ItemStateException {
-                InternalValue.create(((NodeTypeImpl) src.getPrimaryNodeType()).getQName()));
+                InternalValue.create(src.getState().getNodeTypeName()));
-            NodeType[] mixins = src.getMixinNodeTypes();
-            InternalValue[] ivalues = new InternalValue[mixins.length];
-            for (int i = 0; i < mixins.length; i++) {
-                ivalues[i] = InternalValue.create(((NodeTypeImpl) mixins[i]).getQName());
-            }
-            node.setPropertyValues(NameConstants.JCR_FROZENMIXINTYPES, PropertyType.NAME, ivalues);
+            node.setPropertyValues(NameConstants.JCR_FROZENMIXINTYPES,
+                    PropertyType.NAME, src.getPropertyValues(NameConstants.JCR_MIXINTYPES));
-        PropertyIterator piter = src.getProperties();
-        while (piter.hasNext()) {
-            PropertyImpl prop = (PropertyImpl) piter.nextProperty();
+        for (PropertyState prop: src.getProperties()) {
-            if ((mode & MODE_COPY) > 0) {
+            if (mode != Mode.VERSION) {
-                opv = prop.getDefinition().getOnParentVersion();
+                opv = src.getDefinition(prop).getOnParentVersion();
+            Name propName = prop.getName();
-                throw new VersionException("Checkin aborted due to OPV in " + prop);
+                throw new VersionException("Checkin aborted due to OPV in " + propName);
-                if (!prop.getQName().equals(NameConstants.JCR_PRIMARYTYPE)
-                        && !prop.getQName().equals(NameConstants.JCR_MIXINTYPES)
-                        && !prop.getQName().equals(NameConstants.JCR_UUID)) {
+                if (!propName.equals(NameConstants.JCR_PRIMARYTYPE)
+                        && !propName.equals(NameConstants.JCR_MIXINTYPES)
+                        && !propName.equals(NameConstants.JCR_UUID)) {
-        NodeIterator niter = src.getNodes();
-        while (niter.hasNext()) {
-            NodeImpl child = (NodeImpl) niter.nextNode();
+        for (NodeStateEx child: src.getChildNodes()) {
-            if ((mode & MODE_COPY_RECURSIVE) > 0) {
+            if (mode == Mode.COPY_RECURSE) {
-                if (child.isNodeType(NameConstants.MIX_SIMPLE_VERSIONABLE)) {
+                if (child.getEffectiveNodeType().includesNodeType(NameConstants.MIX_VERSIONABLE)) {
-                    NodeStateEx newChild = node.addNode(child.getQName(), NameConstants.NT_VERSIONEDCHILD, null, false);
+                    NodeId histId = child.getPropertyValue(NameConstants.JCR_VERSIONHISTORY).getNodeId();
+                    NodeStateEx newChild = node.addNode(child.getName(), NameConstants.NT_VERSIONEDCHILD, null, false);
-                            InternalValue.create(new NodeId(child.getVersionHistory().getUUID())));
-                    /*
-                        newChild.setPropertyValue(JCR_BASEVERSION,
-                                InternalValue.create(child.getBaseVersion().getUUID()));
-                     */
+                            InternalValue.create(histId));
-                    checkin(node, child.getQName(), child, MODE_COPY);
+                    checkin(node, child.getName(), child, Mode.COPY);
-                checkin(node, child.getQName(), child, MODE_COPY_RECURSIVE);
+                checkin(node, child.getName(), child, Mode.COPY_RECURSE);

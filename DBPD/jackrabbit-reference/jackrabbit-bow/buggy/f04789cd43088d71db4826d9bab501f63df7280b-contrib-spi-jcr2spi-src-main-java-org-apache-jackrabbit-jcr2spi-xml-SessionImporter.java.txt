work in progress

jcr2spi
- HierarchyManager: fixing methods with ItemId param
- HierarchyManagerImpl(s): removing unused methods
- ItemManagerImpl: replacing NodeId as cacheKey
- ItemImpl: remove ISM field

jcr2spi/xml
- ImporterImpl renamed to SessionImporter (used for s-import only)
- xml import: Use UUID String instead of creating NodeIds
- ReferenceChangeTracker: remove usage of spi NodeId

jcr2spi/state
- SessionItemStateManager: ValueFactory not needed since QPropertyDefinition returns qualified values.

jcr2spi/util
- LogUtil: add 'saveGetJCRName' utility method

jcr2spi/locking
- locking: LockManager to use NodeState instead of NodeId
- locking: removing locktoken from Session checks if Session is lock holder

jcr2spi/query
- NodeIteratorImpl: fix commented code, that allows to retrieve
  search results from IdIterator returned from QueryInfo
- minor reformatting, javadoc

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@430791 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.state.ItemStateValidator;
-import org.apache.jackrabbit.jcr2spi.HierarchyManager;
-import org.apache.jackrabbit.spi.IdFactory;
-import org.apache.jackrabbit.spi.NodeId;
+import org.apache.jackrabbit.spi.NodeId;
- * <code>ImporterImpl</code>...
+ * <code>SessionImporter</code>...
-public class ImporterImpl implements Importer, SessionListener {
+public class SessionImporter implements Importer, SessionListener {
-    private static Logger log = LoggerFactory.getLogger(ImporterImpl.class);
+    private static Logger log = LoggerFactory.getLogger(SessionImporter.class);
-    private final SessionImpl session;
-    private final HierarchyManager hierMgr;
+    private final int uuidBehavior;
+    private final SessionImpl session;
-    private final ItemStateValidator validator;
-    final IdFactory idFactory;
-    private final int uuidBehavior;
-    private final boolean isWspImport;
-
-     * @param validator
-    public ImporterImpl(Path parentPath, SessionImpl session, HierarchyManager hierManager,
-                     SessionItemStateManager stateManager, ItemStateValidator validator,
-                     IdFactory idFactory, int uuidBehavior, boolean isWspImport)
+    public SessionImporter(Path parentPath, SessionImpl session,
+                           SessionItemStateManager stateManager, int uuidBehavior)
-        this.validator = validator;
-        this.hierMgr = hierManager;
-        this.idFactory = idFactory;
-        this.isWspImport = isWspImport;
-            ItemState itemState = hierMgr.getItemState(parentPath);
+            ItemState itemState = session.getHierarchyManager().getItemState(parentPath);
-
-
-
-
-       boolean succeeded = false;
-       try {
-           checkSession();
-           NodeState parent = (NodeState) parents.peek();
-           if (parent == null) {
-               // parent node was skipped, skip this child node also
-               parents.push(null); // push null onto stack for skipped node
-               log.debug("Skipping node '" + nodeInfo.getName() + "'.");
-               return;
-           }
+       checkSession();
+       NodeState parent = (NodeState) parents.peek();
+       if (parent == null) {
+           // parent node was skipped, skip this child node also
+           parents.push(null); // push null onto stack for skipped node
+           log.debug("Skipping node '" + nodeInfo.getName() + "'.");
+           return;
+       }
-           NodeState nodeState = null;
-           if (parent.hasChildNodeEntry(nodeInfo.getName())) {
-               // a node with that name already exists...
-               ChildNodeEntry entry = parent.getChildNodeEntry(nodeInfo.getName(), Path.INDEX_DEFAULT);
-               NodeState existing = null;
-               try {
-                   existing = entry.getNodeState();
-               } catch (ItemStateException e) {
-                   // should not occur. existance has been checked before
-                   throw new RepositoryException(e);
-               }
-               QNodeDefinition def = existing.getDefinition(session.getNodeTypeRegistry());
-               if (!def.allowsSameNameSiblings()) {
-                   // existing doesn't allow same-name siblings, check for conflicts
-                   EffectiveNodeType entExisting = validator.getEffectiveNodeType(existing);
-                   if (def.isProtected() && entExisting.includesNodeType(nodeInfo.getNodeTypeName())) {
-                       // skip protected node
-                       parents.push(null); // push null onto stack for skipped node
-                       log.debug("skipping protected node " + LogUtil.safeGetJCRPath(existing, session.getNamespaceResolver(), hierMgr));
-                       return;
-                   }
-                   if (def.isAutoCreated() && entExisting.includesNodeType(nodeInfo.getNodeTypeName())) {
-                       // this node has already been auto-created, no need to create it
-                       nodeState = existing;
-                   } else {
-                       throw new ItemExistsException(LogUtil.safeGetJCRPath(existing, session.getNamespaceResolver(), hierMgr));
-                   }
-               }
+       NodeState nodeState = null;
+       if (parent.hasChildNodeEntry(nodeInfo.getName())) {
+           // a node with that name already exists...
+           ChildNodeEntry entry = parent.getChildNodeEntry(nodeInfo.getName(), Path.INDEX_DEFAULT);
+           NodeState existing = null;
+           try {
+               existing = entry.getNodeState();
+           } catch (ItemStateException e) {
+               // should not occur. existance has been checked before
+               throw new RepositoryException(e);
-
-           if (nodeState == null) {
-               // node does not exist -> create new one
-               if (nodeInfo.getId() == null) {
-                   // no potential uuid conflict, add new node from given info
-                   nodeState = importNode(nodeInfo, parent);
+           QNodeDefinition def = existing.getDefinition(session.getNodeTypeRegistry());
+           if (!def.allowsSameNameSiblings()) {
+               // existing doesn't allow same-name siblings, check for conflicts
+               EffectiveNodeType entExisting = session.getValidator().getEffectiveNodeType(existing);
+               if (def.isProtected() && entExisting.includesNodeType(nodeInfo.getNodeTypeName())) {
+                   // skip protected node
+                   parents.push(null); // push null onto stack for skipped node
+                   log.debug("skipping protected node " + LogUtil.safeGetJCRPath(existing, session.getNamespaceResolver(), session.getHierarchyManager()));
+                   return;
+               }
+               if (def.isAutoCreated() && entExisting.includesNodeType(nodeInfo.getNodeTypeName())) {
+                   // this node has already been auto-created, no need to create it
+                   nodeState = existing;
-                   // potential uuid conflict
-                   try {
-                       NodeState conflicting = (NodeState) stateMgr.getItemState(nodeInfo.getId());
-                       nodeState = resolveUUIDConflict(parent, conflicting, nodeInfo);
-                   } catch (NoSuchItemStateException e) {
-                       // no conflict: create new with given uuid
-                       nodeState = importNode(nodeInfo, parent);
-                   } catch (ItemStateException e) {
-                       String msg = "Internal error: failed to retrieve state of " + nodeInfo.getId().toString();
-                       log.debug(msg);
-                       throw new RepositoryException(msg, e);
-                   }
+                   throw new ItemExistsException(LogUtil.safeGetJCRPath(existing, session.getNamespaceResolver(), session.getHierarchyManager()));
-
-           // node state may be 'null' if applicable def is protected
-           if (nodeState != null) {
-               // process properties
-               Iterator iter = propInfos.iterator();
-               while (iter.hasNext()) {
-                   PropInfo pi = (PropInfo) iter.next();
-                   importProperty(pi, nodeState, nsContext);
-               }
-           }
-
-           // push current nodeState onto stack of parents
-           parents.push(nodeState);
-           succeeded = true;
-       } finally {
-           // workspace-importer only: abort the import by closing the importer
-           // in case of failure.
-           if (!succeeded && isWspImport) {
-               setClosed(true);
-           }
+
+       if (nodeState == null) {
+           // node does not exist -> create new one
+           if (nodeInfo.getUUID() == null) {
+               // no potential uuid conflict, add new node from given info
+               nodeState = importNode(nodeInfo, parent);
+           } else {
+               // potential uuid conflict
+               try {
+                   NodeId conflictingId = session.getIdFactory().createNodeId(nodeInfo.getUUID());
+                   NodeState conflicting = (NodeState) stateMgr.getItemState(conflictingId);
+                   nodeState = resolveUUIDConflict(parent, conflicting, nodeInfo);
+               } catch (NoSuchItemStateException e) {
+                   // no conflict: create new with given uuid
+                   nodeState = importNode(nodeInfo, parent);
+               } catch (ItemStateException e) {
+                   String msg = "Internal error: failed to retrieve state of " + nodeInfo.getUUID().toString();
+                   log.debug(msg);
+                   throw new RepositoryException(msg, e);
+               }
+           }
+       }
+
+       // node state may be 'null' if applicable def is protected
+       if (nodeState != null) {
+           // process properties
+           Iterator iter = propInfos.iterator();
+           while (iter.hasNext()) {
+               PropInfo pi = (PropInfo) iter.next();
+               importProperty(pi, nodeState, nsContext);
+           }
+       }
+
+       // push current nodeState onto stack of parents
+       parents.push(nodeState);
-                NodeId original = nodeInfo.getId();
+                String originalUUID = nodeInfo.getUUID();
-                nodeInfo.setId(null);
+                nodeInfo.setUUID(null);
-                    EffectiveNodeType ent = validator.getEffectiveNodeType(nodeState);
+                    EffectiveNodeType ent = session.getValidator().getEffectiveNodeType(nodeState);
-                        refTracker.mappedNodeIds(original, nodeState.getNodeId());
+                        refTracker.mappedUUIDs(originalUUID, nodeState.getNodeId().getUUID());
-                String msg = "a node with uuid " + nodeInfo.getId() + " already exists!";
+                String msg = "a node with uuid " + nodeInfo.getUUID() + " already exists!";
-                Path p0 = hierMgr.getQPath(importTarget);
-                Path p1 = hierMgr.getQPath(conflicting);
+                Path p0 = session.getHierarchyManager().getQPath(importTarget);
+                Path p1 = session.getHierarchyManager().getQPath(conflicting);
-                            propDef = validator.getApplicablePropertyDefinition(newName, conflicting.getType(), false, parent);
+                            propDef = session.getValidator().getApplicablePropertyDefinition(newName, conflicting.getType(), false, parent);
-                            propDef = validator.getApplicablePropertyDefinition(newName, conflicting.getType(), true, parent);
+                            propDef = session.getValidator().getApplicablePropertyDefinition(newName, conflicting.getType(), true, parent);
-                        propDef = validator.getApplicablePropertyDefinition(newName, conflicting.getType(), true, parent);
+                        propDef = session.getValidator().getApplicablePropertyDefinition(newName, conflicting.getType(), true, parent);
-                    PropertyId newPId = idFactory.createPropertyId(parent.getNodeId(), newName);
+                    PropertyId newPId = session.getIdFactory().createPropertyId(parent.getNodeId(), newName);
-        QNodeDefinition def = validator.getApplicableNodeDefinition(nodeInfo.getName(), nodeInfo.getNodeTypeName(), parent);
+        QNodeDefinition def = session.getValidator().getApplicableNodeDefinition(nodeInfo.getName(), nodeInfo.getNodeTypeName(), parent);
-            Operation an = AddNode.create(parent, nodeInfo.getName(), nodeInfo.getNodeTypeName(), nodeInfo.getId());
+            NodeId newId = session.getIdFactory().createNodeId(nodeInfo.getUUID());
+            Operation an = AddNode.create(parent, nodeInfo.getName(), nodeInfo.getNodeTypeName(), newId);
-            PropertyId mixinPId = idFactory.createPropertyId(childState.getNodeId(), QName.JCR_MIXINTYPES);
+            PropertyId mixinPId = session.getIdFactory().createPropertyId(childState.getNodeId(), QName.JCR_MIXINTYPES);
-    private void importProperty(PropInfo pi, NodeState nodeState, NamespaceResolver nsResolver) throws RepositoryException, ConstraintViolationException {
+    private void importProperty(PropInfo pi, NodeState parentState, NamespaceResolver nsResolver) throws RepositoryException, ConstraintViolationException {
-        if (nodeState.hasPropertyName(propName)) {
+        if (parentState.hasPropertyName(propName)) {
-                PropertyState existing = nodeState.getPropertyState(propName);
+                PropertyState existing = parentState.getPropertyState(propName);
-                    log.debug("skipping protected property " + LogUtil.safeGetJCRPath(existing, session.getNamespaceResolver(), hierMgr));
+                    log.debug("skipping protected property " + LogUtil.safeGetJCRPath(existing, session.getNamespaceResolver(), session.getHierarchyManager()));
-                    throw new ItemExistsException(LogUtil.safeGetJCRPath(existing, session.getNamespaceResolver(), hierMgr));
+                    throw new ItemExistsException(LogUtil.safeGetJCRPath(existing, session.getNamespaceResolver(), session.getHierarchyManager()));
-                def = validator.getApplicablePropertyDefinition(propName, infoType, nodeState);
+                def = session.getValidator().getApplicablePropertyDefinition(propName, infoType, parentState);
-                def = validator.getApplicablePropertyDefinition(propName, infoType, true, nodeState);
+                def = session.getValidator().getApplicablePropertyDefinition(propName, infoType, true, parentState);
-            PropertyId newPId = idFactory.createPropertyId(nodeState.getNodeId(), propName);
+            PropertyId newPId = session.getIdFactory().createPropertyId(parentState.getNodeId(), propName);
-                propState = nodeState.getPropertyState(propName);
+                propState = parentState.getPropertyState(propName);

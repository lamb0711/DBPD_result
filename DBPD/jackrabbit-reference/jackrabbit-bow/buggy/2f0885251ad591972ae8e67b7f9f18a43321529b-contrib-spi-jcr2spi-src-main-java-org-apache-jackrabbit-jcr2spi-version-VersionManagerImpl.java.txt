Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.state.Status;
-import org.apache.jackrabbit.jcr2spi.state.Status;
+import org.apache.jackrabbit.jcr2spi.hierarchy.NodeEntry;
+import org.apache.jackrabbit.spi.NodeId;
-        Operation ci = Checkin.create(wspState);
+        Operation ci = Checkin.create(wspState, this);
-        Operation co = Checkout.create(wspState);
+        Operation co = Checkout.create(wspState, this);
-        NodeState wspState = getWorkspaceState(nodeState);
+        NodeEntry nodeEntry = nodeState.getNodeEntry();
-            /**
-             * FIXME should not only rely on existence of jcr:isCheckedOut property
-             * but also verify that node.isNodeType("mix:versionable")==true;
-             * this would have a negative impact on performance though...
-             */
-            while (!wspState.hasPropertyName(QName.JCR_ISCHECKEDOUT)) {
-                NodeState parentState = wspState.getParent();
-                if (parentState == null) {
+            // NOTE: since the hierarchy might not be completely loaded or some
+            // entry might even not be accessible, the check may not detect
+            // a checked-in parent. ok, as long as the 'server' find out upon
+            // save or upon executing the workspace operation.
+            while (!nodeEntry.hasPropertyEntry(QName.JCR_ISCHECKEDOUT)) {
+                NodeEntry parent = nodeEntry.getParent();
+                if (parent == null) {
-                wspState = parentState;
+                nodeEntry = parent;
-            PropertyState propState = wspState.getPropertyState(QName.JCR_ISCHECKEDOUT);
+            PropertyState propState = nodeEntry.getPropertyEntry(QName.JCR_ISCHECKEDOUT).getPropertyState();
-            // should not occur
-            throw new RepositoryException(e);
+            // error while accessing jcr:isCheckedOut property state.
+            // -> assume that checkedOut status is ok. see above for general
+            // notes about the capabilities of the jcr2spi implementation.
+        return true;
-        Operation op = RemoveVersion.create(wspVersionState);
+        Operation op = RemoveVersion.create(wspVersionState, getWorkspaceState(versionHistoryState), this);
-        Merge op = Merge.create(wspState, workspaceName, bestEffort);
+        Merge op = Merge.create(wspState, workspaceName, bestEffort, this);
+    public NodeEntry getVersionableNodeState(NodeState versionState) throws RepositoryException {
+        try {
+            NodeState ns = versionState.getChildNodeState(QName.JCR_FROZENNODE, Path.INDEX_DEFAULT);
+            PropertyState ps = ns.getPropertyState(QName.JCR_FROZENUUID);
+            String uniqueID = ps.getValue().toString();
+
+            NodeId versionableId = workspaceManager.getIdFactory().createNodeId(uniqueID);
+            return (NodeEntry) workspaceManager.getHierarchyManager().getHierarchyEntry(versionableId);
+        } catch (ItemStateException e) {
+            throw new RepositoryException(e);
+        }
+    }
+
+    public NodeEntry getVersionHistoryNodeState(NodeState versionableState) throws RepositoryException {
+        try {
+            PropertyState ps = versionableState.getPropertyState(QName.JCR_VERSIONHISTORY);
+            String uniqueID = ps.getValue().toString();
+            NodeId vhId = workspaceManager.getIdFactory().createNodeId(uniqueID);
+            return (NodeEntry) workspaceManager.getHierarchyManager().getHierarchyEntry(vhId);
+        } catch (ItemStateException e) {
+            // should not occur
+            throw new RepositoryException(e);
+        }
+    }
+

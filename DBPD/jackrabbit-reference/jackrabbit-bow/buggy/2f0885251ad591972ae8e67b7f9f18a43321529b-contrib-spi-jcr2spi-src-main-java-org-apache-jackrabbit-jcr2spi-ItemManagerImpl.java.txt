Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.hierarchy.HierarchyManager;
+import org.apache.jackrabbit.jcr2spi.hierarchy.HierarchyEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.NodeEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.PropertyEntry;
-import org.apache.jackrabbit.jcr2spi.state.entry.ChildNodeEntry;
-import org.apache.jackrabbit.jcr2spi.state.entry.ChildPropertyEntry;
+import org.apache.jackrabbit.jcr2spi.state.NoSuchItemStateException;
-import org.apache.jackrabbit.spi.QNodeDefinition;
-import org.apache.jackrabbit.spi.QPropertyDefinition;
-import javax.jcr.nodetype.NodeDefinition;
-import javax.jcr.nodetype.PropertyDefinition;
-import java.util.Collection;
-import java.util.ArrayList;
-import java.util.List;
-            // check sanity of session
-            session.checkIsAlive();
-            // permissions are checked upon itemExists(ItemState)
-
+            // session-sanity & permissions are checked upon itemExists(ItemState)
-     * @see ItemManager#itemExists(ItemState)
+     * @see ItemManager#itemExists(HierarchyEntry)
-    public boolean itemExists(ItemState itemState) {
+    public boolean itemExists(HierarchyEntry hierarchyEntry) {
+        try {
+            // session-sanity & permissions are checked upon itemExists(ItemState)
+            ItemState state = hierarchyEntry.getItemState();
+            return itemExists(state);
+        } catch (NoSuchItemStateException e) {
+            return false;
+        } catch (ItemStateException e) {
+            return false;
+        }
+    }
+
+    /**
+     *
+     * @param itemState
+     * @return
+     */
+    private boolean itemExists(ItemState itemState) {
-
-            // always return true if access rights are granted, existence
-            // of the state has been asserted before
-            return true;
+            // return true, if ItemState is valid. Access rights are granted,
+            // otherwise the state would not have been retrieved.
+            return itemState.isValid();
-        ItemState itemState = hierMgr.getItemState(path);
+        HierarchyEntry itemEntry = hierMgr.getHierarchyEntry(path);
-            return getItem(itemState);
+            return getItem(itemEntry);
-     * @see ItemManager#getItem(ItemState)
+     * @see ItemManager#getItem(HierarchyEntry)
-    public Item getItem(ItemState itemState) throws ItemNotFoundException, AccessDeniedException, RepositoryException {
+    public Item getItem(HierarchyEntry hierarchyEntry) throws ItemNotFoundException, AccessDeniedException, RepositoryException {
+        try {
+            ItemState itemState = hierarchyEntry.getItemState();
+            return getItem(itemState);
+        } catch (NoSuchItemStateException e) {
+            throw new ItemNotFoundException(e);
+        } catch (ItemStateException e) {
+            throw new RepositoryException(e);
+        }
+    }
+
+    /**
+     *
+     * @param itemState
+     * @return
+     * @throws ItemNotFoundException
+     * @throws AccessDeniedException
+     * @throws RepositoryException
+     */
+    private Item getItem(ItemState itemState) throws ItemNotFoundException, AccessDeniedException, RepositoryException {
+        session.checkIsAlive();
+        if (!itemState.isValid()) {
+            throw new ItemNotFoundException();
+        }
-     * @see ItemManager#hasChildNodes(NodeState)
+     * @see ItemManager#hasChildNodes(NodeEntry)
-    public synchronized boolean hasChildNodes(NodeState parentState)
+    public synchronized boolean hasChildNodes(NodeEntry parentEntry)
-        parentState.checkIsSessionState();
-        Iterator iter = parentState.getChildNodeEntries().iterator();
+        Iterator iter = parentEntry.getNodeEntries();
-                // check read access
-                ChildNodeEntry entry = (ChildNodeEntry) iter.next();
-                if (session.getAccessManager().canRead(entry.getNodeState())) {
-                    return true;
-                }
+                // check read access by accessing the nodeState (implicit validation check)
+                NodeEntry entry = (NodeEntry) iter.next();
+                entry.getNodeState();
+                return true;
-     * @see ItemManager#getChildNodes(NodeState)
+     * @see ItemManager#getChildNodes(NodeEntry)
-    public synchronized NodeIterator getChildNodes(NodeState parentState)
+    public synchronized NodeIterator getChildNodes(NodeEntry parentEntry)
-        parentState.checkIsSessionState();
-        Collection nodeEntries = parentState.getChildNodeEntries();
-        List childStates = new ArrayList(nodeEntries.size());
-        for (Iterator it = nodeEntries.iterator(); it.hasNext();) {
-            try {
-                childStates.add(((ChildNodeEntry) it.next()).getNodeState());
-            } catch (ItemStateException e) {
-                // should not occur
-                throw new RepositoryException(e);
-            }
-        }
-        return new LazyItemIterator(this, childStates);
+        Iterator it = parentEntry.getNodeEntries();
+        return new LazyItemIterator(this, it);
-     * @see ItemManager#hasChildProperties(NodeState)
+     * @see ItemManager#hasChildProperties(NodeEntry)
-    public synchronized boolean hasChildProperties(NodeState parentState)
+    public synchronized boolean hasChildProperties(NodeEntry parentEntry)
-        parentState.checkIsSessionState();
-        Iterator iter = parentState.getPropertyEntries().iterator();
+        Iterator iter = parentEntry.getPropertyEntries();
-                ChildPropertyEntry entry = (ChildPropertyEntry) iter.next();
-                // check read access
-                if (session.getAccessManager().canRead(entry.getPropertyState())) {
-                    return true;
-                }
+                PropertyEntry entry = (PropertyEntry) iter.next();
+                // check read access by accessing the propState (also implicit validation).
+                entry.getPropertyState();
+                return true;
-     * @see ItemManager#getChildProperties(NodeState)
+     * @see ItemManager#getChildProperties(NodeEntry)
-    public synchronized PropertyIterator getChildProperties(NodeState parentState)
+    public synchronized PropertyIterator getChildProperties(NodeEntry parentEntry)
-        parentState.checkIsSessionState();
-        Collection propEntries = parentState.getPropertyEntries();
-        List childStates = new ArrayList(propEntries.size());
-        for (Iterator it = propEntries.iterator(); it.hasNext();) {
-            try {
-                childStates.add(((ChildPropertyEntry)it.next()).getPropertyState());
-            } catch (ItemStateException e) {
-                // should not occur
-                throw new RepositoryException(e);
-            }
-        }
-        return new LazyItemIterator(this, childStates);
+        Iterator propEntries = parentEntry.getPropertyEntries();
+        return new LazyItemIterator(this, propEntries);
-        // 1. get definition of the specified node
-        QNodeDefinition qnd = state.getDefinition();
-        NodeDefinition def = session.getNodeTypeManager().getNodeDefinition(qnd);
-
-        // 2. create instance
-            return new VersionImpl(this, session, state, def, listeners);
+            return new VersionImpl(this, session, state, listeners);
-            return new VersionHistoryImpl(this, session, state, def, listeners);
+            return new VersionHistoryImpl(this, session, state, listeners);
-            return new NodeImpl(this, session, state, def, listeners);
+            return new NodeImpl(this, session, state, listeners);
-        // 1. get definition for the specified property
-        QPropertyDefinition qpd = state.getDefinition();
-        PropertyDefinition def = session.getNodeTypeManager().getPropertyDefinition(qpd);
-
-        // 2. create instance
-                // we want to be informed on life cycle changes of the new property object
+        // we want to be informed on life cycle changes of the new property object
-        PropertyImpl prop = new PropertyImpl(this, session, state, def, listeners);
+        PropertyImpl prop = new PropertyImpl(this, session, state, listeners);

JCR-1593 JSR 283: Simple versioning
JCR-2058 JSR 283: VersionManager and new versioning methods


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@765556 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.LinkedHashMap;
-    private HashMap nameCache = new HashMap();
+    private LinkedHashMap/*<Name, NodeId>*/ nameCache = new LinkedHashMap/*<Name, NodeId>*/();
-    private HashMap versionCache = new HashMap();
+    private HashMap/*<NodeId, InternalVersion>*/ versionCache = new HashMap/*<NodeId, InternalVersion>*/();
-    private HashMap tempVersionCache = new HashMap();
+    private HashMap/*<NodeId, InternalVersion>*/ tempVersionCache = new HashMap/*<NodeId, InternalVersion>*/();
+     * @param vMgr version manager
+     * @param node version history node state
+     * @throws RepositoryException if an error occurs
-     * @throws RepositoryException
+     * @throws RepositoryException if an error occurs
+     * @throws RepositoryException if an error occurs
+     * @param name name of the version
+     * @return the new internal version
+     * @throws IllegalArgumentException if the version does not exist
+     * @param child child node state
+     * @return new version instance
+    public Name[] getVersionNames() {
+        return (Name[]) nameCache.keySet().toArray(new Name[nameCache.size()]);
+    }
+    
+    /**
+     * {@inheritDoc}
+     */
-     * @param versionName
-     * @throws VersionException
+     * @param versionName name of the version to remove
+     * @throws VersionException if removal is not possible
-        // remove from persistance state
+        // remove from persistence state
-     * @throws VersionException
+     * @throws VersionException if the version does not exist or if the label is already defined.
-     * @param name
-     * @param src
-     * @return
-     * @throws RepositoryException
+     * @param name new version name
+     * @param src source node to version
+     * @return the newly created version
+     * @throws RepositoryException if an error occurs
-        Value[] preds = src.getProperty(NameConstants.JCR_PREDECESSORS).getValues();
-        InternalValue[] predecessors = new InternalValue[preds.length];
-        for (int i = 0; i < preds.length; i++) {
-            UUID predId = UUID.fromString(preds[i].getString());
-            // check if version exist
-            if (!nameCache.containsValue(new NodeId(predId))) {
-                throw new RepositoryException("invalid predecessor in source node");
+        InternalValue[] predecessors;
+        if (src.hasProperty(NameConstants.JCR_PREDECESSORS)) {
+            Value[] preds = src.getProperty(NameConstants.JCR_PREDECESSORS).getValues();
+            predecessors = new InternalValue[preds.length];
+            for (int i = 0; i < preds.length; i++) {
+                UUID predId = UUID.fromString(preds[i].getString());
+                // check if version exist
+                if (!nameCache.containsValue(new NodeId(predId))) {
+                    throw new RepositoryException("invalid predecessor in source node");
+                }
+                predecessors[i] = InternalValue.create(predId);
-            predecessors[i] = InternalValue.create(predId);
+        } else {
+            // with simple versioning, the node does not contain a predecessors
+            // property and we just use the 'head' version as predecessor
+            Iterator iter = nameCache.values().iterator();
+            NodeId last = null;
+            while (iter.hasNext()) {
+                last = (NodeId) iter.next();
+            }
+            if (last == null) {
+                // should never happen
+                last = rootVersion.getId();
+            }
+            predecessors = new InternalValue[]{InternalValue.create(last.getUUID())};
-     * @param parent
-     * @param name
-     * @return
-     * @throws RepositoryException
+     * @param vMgr version manager
+     * @param parent parent node
+     * @param name history name
+     * @param nodeState node state
+     * @return new node state
+     * @throws RepositoryException if an error occurs

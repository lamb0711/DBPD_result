JCR-1593 JSR 283: Simple versioning
JCR-2058 JSR 283: VersionManager and new versioning methods


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@765556 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.version.InternalVersionHistory;
+import org.apache.jackrabbit.core.version.InternalVersion;
+import org.apache.jackrabbit.api.jsr283.version.VersionManager;
-        // special handling of mix:versionable. since adding the mixin alters
+        // special handling of mix:(simple)versionable. since adding the mixin alters
-        if (NameConstants.MIX_VERSIONABLE.equals(mixinName)) {
+        if (NameConstants.MIX_VERSIONABLE.equals(mixinName)
+                || NameConstants.MIX_SIMPLE_VERSIONABLE.equals(mixinName)) {
-        // special handling of mix:versionable. since adding the mixin alters
+        // special handling of mix:(simple)versionable. since adding the mixin alters
-        if (NameConstants.MIX_VERSIONABLE.equals(ntName)) {
+        if (NameConstants.MIX_VERSIONABLE.equals(ntName)
+                || NameConstants.MIX_SIMPLE_VERSIONABLE.equals(mixinName)) {
-        checkVersionable();
+        boolean isFull = checkVersionable();
-            internalSetProperty(NameConstants.JCR_BASEVERSION, InternalValue.create(new UUID(v.getUUID())));
-            internalSetProperty(NameConstants.JCR_PREDECESSORS, InternalValue.EMPTY_ARRAY, PropertyType.REFERENCE);
+            if (isFull) {
+                internalSetProperty(NameConstants.JCR_BASEVERSION, InternalValue.create(new UUID(v.getUUID())));
+                internalSetProperty(NameConstants.JCR_PREDECESSORS, InternalValue.EMPTY_ARRAY, PropertyType.REFERENCE);
+            }
-        checkVersionable();
+        boolean isFull = checkVersionable();
-            props[1] = internalSetProperty(NameConstants.JCR_PREDECESSORS,
-                    new InternalValue[]{
-                            InternalValue.create(new UUID(getBaseVersion().getUUID()))
-                    });
+            if (isFull) {
+                props[1] = internalSetProperty(NameConstants.JCR_PREDECESSORS,
+                        new InternalValue[]{
+                                InternalValue.create(new UUID(getBaseVersion().getUUID()))
+                        });
+            }
-                    props[i].save();
+                    if (props[i] != null) {
+                        props[i].save();
+                    }
-        internalMerge(srcWorkspaceName, null, false);
+        internalMerge(srcWorkspaceName, null, false, false);
+        return merge(srcWorkspace, bestEffort, false);
+    }
+
+    /**
+     * @see VersionManager#merge(String, String, boolean, boolean)
+     */
+    public NodeIterator merge(String srcWorkspace, boolean bestEffort, boolean isShallow)
+            throws NoSuchWorkspaceException, AccessDeniedException,
+            VersionException, LockException, InvalidItemStateException,
+            RepositoryException {
-        internalMerge(srcWorkspace, failedIds, bestEffort);
+        internalMerge(srcWorkspace, failedIds, bestEffort, isShallow);
-                InternalFrozenNode fn = ((VersionImpl) version).getFrozenNode();
+                InternalFrozenNode fn = ((VersionImpl) version).getInternalFrozenNode();
-                node = addNode(relPath, ((VersionImpl) version).getFrozenNode());
+                node = addNode(relPath, ((VersionImpl) version).getInternalFrozenNode());
-        checkVersionable();
+        boolean isFull = checkVersionable();
-        // transactions workaround.
-        NodeId id = NodeId.valueOf(getProperty(NameConstants.JCR_VERSIONHISTORY).getString());
-        session.getVersionManager().getVersionHistory(id);
-
-        return (VersionHistory) getProperty(NameConstants.JCR_VERSIONHISTORY).getNode();
+        InternalVersionHistory vh;
+        if (isFull) {
+            NodeId id = NodeId.valueOf(getProperty(NameConstants.JCR_VERSIONHISTORY).getString());
+            vh = session.getVersionManager().getVersionHistory(id);
+        } else {
+            vh = session.getVersionManager().getVersionHistoryOfNode((NodeId) id);
+        }
+        return (VersionHistory) session.getNodeById(vh.getId());
-        checkVersionable();
+        boolean isFull = checkVersionable();
-        // transactions workaround.
-        NodeId id = NodeId.valueOf(getProperty(NameConstants.JCR_BASEVERSION).getString());
-        session.getVersionManager().getVersion(id);
+        InternalVersion v;
+        if (isFull) {
+            NodeId id = NodeId.valueOf(getProperty(NameConstants.JCR_BASEVERSION).getString());
+            v = session.getVersionManager().getVersion(id);
+        } else {
+            // note, that the method currently only works for linear version
+            // graphs (i.e. simple versioning)
+            v = session.getVersionManager().getHeadVersionOfNode(((NodeId) id));
+        }
-        return (Version) getProperty(NameConstants.JCR_BASEVERSION).getNode();
+        return (Version) session.getNodeById(v.getId());
-     * Checks if this node is versionable, i.e. has 'mix:versionable'.
-     *
+     * Checks if this node is versionable, i.e. has 'mix:versionable' or a
+     * 'mix:simpleVersionable'.
+     * @return <code>true</code> if this node is full versionable, i.e. is
+     *         of nodetype mix:versionable
-     *          if this node is not versionable
+     *          if this node is not versionable at all
-    private void checkVersionable()
+    private boolean checkVersionable()
-        if (!isNodeType(NameConstants.MIX_VERSIONABLE)) {
-            String msg =
-                "Unable to perform a versioning operation on"
-                + " a non versionable node: " + this;
+        if (isNodeType(NameConstants.MIX_VERSIONABLE)) {
+            return true;
+        } else if (isNodeType(NameConstants.MIX_SIMPLE_VERSIONABLE)) {
+            return false;
+        } else {
+            String msg = "Unable to perform a versioning operation on a " +
+                         "non versionable node: " + this;
-                               List failedIds, boolean bestEffort)
+                               List failedIds, boolean bestEffort,
+                               boolean shallow)
-            internalMerge(srcSession, failedIds, bestEffort, removeExisting, replaceExisting);
+            internalMerge(srcSession, failedIds, bestEffort, removeExisting, replaceExisting, shallow);
-                               boolean bestEffort, boolean removeExisting, boolean replaceExisting)
+                               boolean bestEffort, boolean removeExisting,
+                               boolean replaceExisting, boolean shallow)
+        if (shallow) {
+            throw new UnsupportedRepositoryOperationException("Shallow merge not supported yet");
+        }
+
-                    n.internalMerge(srcSession, failedIds, bestEffort, removeExisting, replaceExisting);
+                    n.internalMerge(srcSession, failedIds, bestEffort, removeExisting, replaceExisting, shallow);
-                dstNode.internalMerge(srcSession, null, bestEffort, removeExisting, replaceExisting);
+                dstNode.internalMerge(srcSession, null, bestEffort, removeExisting, replaceExisting, shallow);
-                dstNode.internalMerge(srcSession, failedIds, bestEffort, removeExisting, replaceExisting);
+                dstNode.internalMerge(srcSession, failedIds, bestEffort, removeExisting, replaceExisting, shallow);
+        boolean isFull = checkVersionable();
+
-        restoreFrozenState(version.getFrozenNode(), vsel, restored, removeExisting);
+        restoreFrozenState(version.getInternalFrozenNode(), vsel, restored, removeExisting);
-        // 2. N's jcr:baseVersion property will be changed to point to V.
-        UUID uuid = ((NodeId) version.getId()).getUUID();
-        internalSetProperty(NameConstants.JCR_BASEVERSION, InternalValue.create(uuid));
+        if (isFull) {
+            // 2. N's jcr:baseVersion property will be changed to point to V.
+            UUID uuid = ((NodeId) version.getId()).getUUID();
+            internalSetProperty(NameConstants.JCR_BASEVERSION, InternalValue.create(uuid));
-        // 4. N's jcr:predecessor property is set to null
-        internalSetProperty(NameConstants.JCR_PREDECESSORS, InternalValue.EMPTY_ARRAY, PropertyType.REFERENCE);
+            // 4. N's jcr:predecessor property is set to null
+            internalSetProperty(NameConstants.JCR_PREDECESSORS, InternalValue.EMPTY_ARRAY, PropertyType.REFERENCE);
-        // also clear mergeFailed
-        internalSetProperty(NameConstants.JCR_MERGEFAILED, (InternalValue[]) null);
+            // also clear mergeFailed
+            internalSetProperty(NameConstants.JCR_MERGEFAILED, (InternalValue[]) null);
+        } else {
+            // with simple versioning, the node is checked in automatically,
+            // thus not allowing any branches
+            session.getVersionManager().checkin(this);
+        }
-                    restoredChild = addNode(child.getName(), v.getFrozenNode());
+                    restoredChild = addNode(child.getName(), v.getInternalFrozenNode());

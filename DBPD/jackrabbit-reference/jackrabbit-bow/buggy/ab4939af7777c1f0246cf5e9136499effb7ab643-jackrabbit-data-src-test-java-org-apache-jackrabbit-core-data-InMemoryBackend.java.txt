JCR-3729 - S3 Datastore optimizations


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1577127 13f79535-47bb-0310-9956-ffa450edef68

-package org.apache.jackrabbit.aws.ext.ds;
+package org.apache.jackrabbit.core.data;
-import java.util.ArrayList;
+import java.util.HashSet;
-import java.util.List;
+import java.util.Set;
+import org.apache.jackrabbit.core.data.AsyncUploadCallback;
-    public void write(final DataIdentifier identifier, final File file)
-            throws DataStoreException {
-        log("write " + identifier + " " + file.length());
-        byte[] buffer = new byte[(int) file.length()];
-        try {
-            DataInputStream din = new DataInputStream(new FileInputStream(file));
-            din.readFully(buffer);
-            din.close();
-            data.put(identifier, buffer);
-            timeMap.put(identifier, System.currentTimeMillis());
-        } catch (IOException e) {
-            throw new DataStoreException(e);
-        }
+    public void writeAsync(final DataIdentifier identifier, final File file,
+            final AsyncUploadCallback callback) throws DataStoreException {
+        this.write(identifier, file, true, callback);
-    /**
-     * Log a message if logging is enabled.
-     * 
-     * @param message the message
-     */
-    private void log(final String message) {
-        // System.out.println(message);
+    @Override
+    public void write(final DataIdentifier identifier, final File file)
+            throws DataStoreException {
+        this.write(identifier, file, false, null);
-    public List<DataIdentifier> deleteAllOlderThan(final long min) {
+    public Set<DataIdentifier> deleteAllOlderThan(final long min) {
-        List<DataIdentifier> tobeDeleted = new ArrayList<DataIdentifier>();
+        Set<DataIdentifier> tobeDeleted = new HashSet<DataIdentifier>();
-    public long getLength(final DataIdentifier identifier) throws DataStoreException {
+    public long getLength(final DataIdentifier identifier)
+            throws DataStoreException {
-    public void touch(final DataIdentifier identifier, final long minModifiedDate)
+    public boolean exists(final DataIdentifier identifier, final boolean touch)
-        if (minModifiedDate > 0 && data.containsKey(identifier)) {
+        boolean retVal = data.containsKey(identifier);
+        if (retVal && touch) {
+        return retVal;
+    }
+
+    private void write(final DataIdentifier identifier, final File file,
+            final boolean async, final AsyncUploadCallback callback)
+            throws DataStoreException {
+        log("write " + identifier + " " + file.length());
+        byte[] buffer = new byte[(int) file.length()];
+        try {
+            if (async && callback == null) {
+                throw new IllegalArgumentException(
+                    "callback parameter cannot be null");
+            }
+            DataInputStream din = new DataInputStream(new FileInputStream(file));
+            din.readFully(buffer);
+            din.close();
+            data.put(identifier, buffer);
+            timeMap.put(identifier, System.currentTimeMillis());
+        } catch (IOException e) {
+            if (async) {
+                callback.call(identifier, file,
+                    AsyncUploadCallback.RESULT.ABORTED);
+            }
+            throw new DataStoreException(e);
+        }
+        if (async) {
+            callback.call(identifier, file, AsyncUploadCallback.RESULT.SUCCESS);
+        }
+    }
+
+    /**
+     * Log a message if logging is enabled.
+     * 
+     * @param message
+     *            the message
+     */
+    private void log(final String message) {
+        // System.out.println(message);

redesigned transaction support & PersistenceManager

orginal code contributed by dominique pfister, required a lot of tweaking to make it run & work; not thoroughly tested

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@126221 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.log4j.Logger;
+    /**
+     * Serial UID
+     */
+     * Logger instance
+     */
+    private static Logger log = Logger.getLogger(NodeReferences.class);
+
+    /**
-    protected List references;
+    protected ArrayList references = new ArrayList();
+
+    /**
+     * New state
+     */
+    public static final int STATUS_NEW = 0;
+
+    /**
+     * Existing state
+     */
+    public static final int STATUS_EXISTING = 1;
+
+    /**
+     * Destroyed state
+     */
+    public static final int STATUS_DESTROYED = 2;
+
+    /**
+     * the internal status of this item state
+     */
+    protected int status = STATUS_NEW;
+
+    /**
+     * Backing state (may be null)
+     */
+    private NodeReferences overlayed;
-        this.targetId = targetId;
-        references = new ArrayList();
+        this.targetId  = targetId;
+    }
+
+    /**
+     * Package private constructor
+     *
+     * @param overlayed overlayed state
+     */
+    public NodeReferences(NodeReferences overlayed) {
+        this.overlayed = overlayed;
+
+        pull();
+    }
+
+    /**
+     * Copy information from another references object into this object
+     * @param refs source references object
+     */
+    void copy(NodeReferences refs) {
+        targetId = refs.targetId;
+        references.clear();
+        references.addAll(refs.getReferences());
+    }
+
+    /**
+     * Pull information from overlayed object.
+     */
+    void pull() {
+        if (overlayed != null) {
+            copy(overlayed);
+        }
+    }
+
+    /**
+     * Push information into overlayed object.
+     */
+    void push() {
+        if (overlayed != null) {
+            overlayed.copy(this);
+        }
+    }
+
+    /**
+     * Connect this object to an underlying overlayed object
+     */
+    void connect(NodeReferences overlayed) {
+        if (this.overlayed != null) {
+            throw new IllegalStateException(
+                    "References object already connected: " + this);
+        }
+        this.overlayed = overlayed;
+    }
+
+    /**
+     * Disconnect this object from the underlying overlayed object.
+     */
+    void disconnect() {
+        if (overlayed != null) {
+            overlayed = null;
+        }
+
+    /**
+     * Returns the status of this item.
+     *
+     * @return the status of this item.
+     */
+    public int getStatus() {
+        return status;
+    }
+
+    /**
+     * Sets the new status of this item.
+     *
+     * @param newStatus the new status
+     */
+    public void setStatus(int newStatus) {
+        switch (newStatus) {
+            case STATUS_NEW:
+            case STATUS_EXISTING:
+            case STATUS_DESTROYED:
+                status = newStatus;
+                return;
+        }
+        String msg = "illegal status: " + newStatus;
+        log.error(msg);
+        throw new IllegalArgumentException(msg);
+    }

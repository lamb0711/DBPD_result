JCR-3115: Versioning fixup leaves persistence in a state where the node can't be made versionable again

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1185691 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Calendar;
-import org.apache.jackrabbit.core.version.InternalVersionManager;
+import org.apache.jackrabbit.core.version.InternalVersionManagerImpl;
+import org.apache.jackrabbit.spi.NameFactory;
+import org.apache.jackrabbit.spi.commons.name.NameFactoryImpl;
+import org.apache.jackrabbit.util.ISO8601;
-    private final InternalVersionManager versionManager;
+    private final ChangeLog vworkspaceChanges;
+
+    private final InternalVersionManagerImpl versionManager;
-            InternalVersionManager versionManager) {
+            InternalVersionManagerImpl versionManager) {
+        this.vworkspaceChanges = new ChangeLog();
-    public void fix() throws RepositoryException {
-        if (workspaceChanges.hasUpdates()) {
-            log.warn("Fixing repository inconsistencies");
+    private void fix(PersistenceManager pm, ChangeLog changes, String store)
+            throws RepositoryException {
+        if (changes.hasUpdates()) {
+            log.warn("Fixing " + store + " inconsistencies");
-                workspace.store(workspaceChanges);
+                pm.store(changes);
-                e.printStackTrace();
-                throw new RepositoryException(
-                        "Failed to fix workspace inconsistencies", e);
+                String message = "Failed to fix " + store + " inconsistencies (aborting)";
+                log.error(message, e);
+                throw new RepositoryException(message, e);
-            log.info("No repository inconsistencies found");
+            log.info("No " + store + "  inconsistencies found");
+    public void fix() throws RepositoryException {
+        fix(workspace, workspaceChanges, "workspace");
+        fix(versionManager.getPersistenceManager(), vworkspaceChanges,
+                "versioning workspace");
+    }
+
+            NodeId vhid = null;
+                vhid = vh.getId();
+                
+            } catch (InconsistentVersioningState e) {
+                log.info(message, e);
+                NodeId nvhid = e.getVersionHistoryNodeId();
+                if (nvhid != null) {
+                    if (vhid != null && !nvhid.equals(vhid)) {
+                        log.error("vhrid returned with InconsistentVersioningState does not match the id we already had: "
+                                + vhid + " vs " + nvhid);
+                    }
+                    vhid = nvhid; 
+                }
+                removeVersionHistoryReferences(node, vhid);
-                removeVersionHistoryReferences(node);
+                removeVersionHistoryReferences(node, vhid);
-    private void removeVersionHistoryReferences(NodeState node) {
+    private void removeVersionHistoryReferences(NodeState node, NodeId vhid) {
+        
+        if (vhid != null) {
+            // attempt to rename the version history, so it doesn't interfere with
+            // a future attempt to put the node under version control again 
+            // (see JCR-3115)
+            
+            log.info("trying to rename version history of node " + node.getId());
+
+            NameFactory nf = NameFactoryImpl.getInstance();
+            
+            // Name of VHR in parent folder is ID of versionable node
+            Name vhrname = nf.create(Name.NS_DEFAULT_URI, node.getId().toString());
+
+            try {
+                NodeState vhrState = versionManager.getPersistenceManager().load(vhid);
+                NodeState vhrParentState = versionManager.getPersistenceManager().load(vhrState.getParentId());
+                
+                if (vhrParentState.hasChildNodeEntry(vhrname)) {
+                    NodeState modifiedParent = (NodeState) vworkspaceChanges.get(vhrState.getParentId());
+                    if (modifiedParent == null) {
+                        modifiedParent = new NodeState(vhrParentState, NodeState.STATUS_EXISTING_MODIFIED, true);
+                    }
+                    
+                    Calendar now = Calendar.getInstance();
+                    String appendme = " (disconnected by RepositoryChecker on "
+                            + ISO8601.format(now) + ")";
+                    modifiedParent.renameChildNodeEntry(vhid,
+                            nf.create(vhrname.getNamespaceURI(), vhrname.getLocalName() + appendme));
+
+                    vworkspaceChanges.modified(modifiedParent);
+                }
+                else {
+                    log.info("child node entry " + vhrname + " for version history not found inside parent folder.");
+                }
+            } catch (Exception ex) {
+                log.error("while trying to rename the version history", ex);
+            }
+        }

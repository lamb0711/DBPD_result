JCR-2700 : Allow for wildcard restriction in resource-based ACEs

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@983906 13f79535-47bb-0310-9956-ffa450edef68

+     * @param permissions
-     * controlled if it is of nodetype
+     * controlled if it is of node type
-        private final Map<NodeId, Boolean> readCache = new LRUMap(1000);
+        // TODO find optimal cache size and ev. make it configurable (see also JCR-2573).
+        private final Map<ItemId, Boolean> readCache = new LRUMap(5000);
-        private Result buildResult(NodeImpl node, boolean existingNode, boolean isAcItem, EntryFilter filter) throws RepositoryException {
+        private Result buildResult(NodeImpl node, boolean isExistingNode, boolean isAcItem, EntryFilterImpl filter) throws RepositoryException {
+            String parentPath = Text.getRelativeParent(filter.getPath(), 1);
+
-                 Determine if the ACE is defined on the node at absPath (locally):
-                 Except for READ-privileges the permissions must be determined
-                 from privileges defined for the parent. Consequently aces
-                 defined locally must be treated different than inherited entries.
+                 Determine if the ACE also takes effect on the parent:
+                 Some permissions (e.g. add-node or removal) must be determined
+                 from privileges defined for the parent.
+                 A 'local' entry defined on the target node never effects the
+                 parent. For inherited ACEs determine if the ACE matches the
+                 parent path.
-                boolean isLocal = existingNode && ace.isLocal(node.getNodeId());
-                if (!isLocal) {
+                boolean isLocal = isExistingNode && ace.isLocal(node.getNodeId());
+                boolean matchesParent = (!isLocal && ace.matches(parentPath));
+                if (matchesParent) {
-            return buildResult(node, existingNode, isAcItem, new EntryFilterImpl(principalNames));
+            return buildResult(node, existingNode, isAcItem, new EntryFilterImpl(principalNames, absPath, session));
-            /* currently READ access cannot be denied to individual properties.
-               if the parent node is readable the properties are as well.
-               this simplifies the canRead test as well as the caching.
-             */
-            boolean existingNode = false;
-            NodeId nodeId;
-            if (id.denotesNode()) {
-                nodeId = (NodeId) id;
-                // since method may only be called for existing nodes the
-                // flag be set to true if the id identifies a node.
-                existingNode = true;
-            } else {
-                nodeId = ((PropertyId) id).getParentId();
-            }
-
+            // no extra check for existence as method may only be called for existing items.
+            boolean isExistingNode = id.denotesNode();
-                if (readCache.containsKey(nodeId)) {
-                    canRead = readCache.get(nodeId);
+                if (readCache.containsKey(id)) {
+                    canRead = readCache.get(id);
+                    NodeId nodeId = (isExistingNode) ? (NodeId) id : ((PropertyId) id).getParentId();
-                    Result result = buildResult(node, existingNode, isAcItem(node), new EntryFilterImpl(principalNames));
+                    // TODO: check again if retrieving the path can be avoided
+                    Path absPath = (path == null) ? session.getHierarchyManager().getPath(id) : path;
+                    Result result = buildResult(node, isExistingNode, isAcItem(node), new EntryFilterImpl(principalNames, absPath, session));
-                    readCache.put(nodeId, canRead);
+                    readCache.put(id, canRead);

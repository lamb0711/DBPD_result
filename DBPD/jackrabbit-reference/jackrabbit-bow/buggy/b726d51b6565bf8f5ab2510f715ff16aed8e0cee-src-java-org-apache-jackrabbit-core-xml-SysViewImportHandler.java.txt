reimplementing Session.importXML & friends due to spec changes 

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@154700 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.*;
-import org.apache.jackrabbit.core.nodetype.NodeTypeImpl;
+import org.apache.jackrabbit.core.BaseException;
+import org.apache.jackrabbit.core.Constants;
+import org.apache.jackrabbit.core.IllegalNameException;
+import org.apache.jackrabbit.core.NamespaceResolver;
+import org.apache.jackrabbit.core.QName;
+import org.apache.jackrabbit.core.UnknownPrefixException;
-import javax.jcr.*;
-import javax.jcr.nodetype.ConstraintViolationException;
-import javax.jcr.nodetype.NodeDef;
-import javax.jcr.nodetype.PropertyDef;
+import javax.jcr.BinaryValue;
+import javax.jcr.InvalidSerializedDataException;
+import javax.jcr.PropertyType;
+import javax.jcr.RepositoryException;
+import javax.jcr.Value;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Stack;
+
-    private SessionImpl session;
+    private final Importer importer;
+    private final NamespaceResolver nsContext;
-    private Stack stateStack = new Stack();
-
-    /**
-     * list of all reference properties that need to be adjusted
-     */
-    private LinkedList references = new LinkedList();
-
-    /**
-     * mapping <original uuid> to <new uuid> of mix:referenceable nodes
-     */
-    private HashMap referees = new HashMap();
+    private final Stack stack = new Stack();
-    private ArrayList currentPropValues;
+    private ArrayList currentPropValues = new ArrayList();
-    SysViewImportHandler(NodeImpl importTargetNode, SessionImpl session) {
-        ImportState state = new ImportState();
-        state.node = importTargetNode;
-        this.session = session;
-        stateStack.push(state);
+    SysViewImportHandler(Importer importer, NamespaceResolver nsContext) {
+        this.importer = importer;
+        this.nsContext = nsContext;
+    }
+
+    private void processNode(ImportState state, boolean start, boolean end)
+            throws SAXException {
+        if (!start && !end) {
+            return;
+        }
+        Importer.NodeInfo node = new Importer.NodeInfo();
+        node.setName(state.nodeName);
+        node.setNodeTypeName(state.nodeTypeName);
+        if (state.mixinNames != null) {
+            QName[] mixins = (QName[]) state.mixinNames.toArray(new QName[state.mixinNames.size()]);
+            node.setMixinNames(mixins);
+        }
+        node.setUUID(state.uuid);
+        // call Importer
+        try {
+            if (start) {
+                importer.startNode(node, state.props, nsContext);
+            }
+            if (end) {
+                importer.endNode(node);
+            }
+        } catch (RepositoryException re) {
+            throw new SAXException(re);
+        }
+     * @see ContentHandler#startDocument()
+     */
+    public void startDocument() throws SAXException {
+        try {
+            importer.start();
+        } catch (RepositoryException re) {
+            throw new SAXException(re);
+        }
+    }
+
+    /**
-        try {
-            String elemName;
-            String nsURI;
-            if (namespaceURI != null && !"".equals(namespaceURI)) {
-                nsURI = namespaceURI;
-                elemName = localName;
-            } else {
-                try {
-                    nsURI = QName.fromJCRName(qName, session.getNamespaceResolver()).getNamespaceURI();
-                    elemName = QName.fromJCRName(qName, session.getNamespaceResolver()).getLocalName();
-                } catch (BaseException e) {
-                    // should never happen...
-                    String msg = "internal error: failed to parse/resolve element name " + qName;
-                    log.debug(msg);
-                    throw new SAXException(msg, e);
-                }
+        String elemName;
+        String nsURI;
+        if (namespaceURI != null && !"".equals(namespaceURI)) {
+            nsURI = namespaceURI;
+            elemName = localName;
+        } else {
+            try {
+                nsURI = QName.fromJCRName(qName, nsContext).getNamespaceURI();
+                elemName = QName.fromJCRName(qName, nsContext).getLocalName();
+            } catch (BaseException e) {
+                // should never happen...
+                String msg = "internal error: failed to parse/resolve element name " + qName;
+                log.debug(msg);
+                throw new SAXException(msg, e);
-            // check namespace
-            if (!NS_SV_URI.equals(nsURI)) {
-                throw new SAXException(new InvalidSerializedDataException("invalid namespace for element in system view xml document: " + nsURI));
+        }
+        // check namespace
+        if (!NS_SV_URI.equals(nsURI)) {
+            throw new SAXException(new InvalidSerializedDataException("invalid namespace for element in system view xml document: " + nsURI));
+        }
+        // check element name
+        if (SysViewSAXEventGenerator.NODE_ELEMENT.equals(elemName)) {
+            // sv:node element
+
+            // node name (value of sv:name attribute)
+            String name = atts.getValue(SysViewSAXEventGenerator.NS_SV_URI, SysViewSAXEventGenerator.NAME_ATTRIBUTE);
+            if (name == null) {
+                // try qualified name
+                name = atts.getValue(SysViewSAXEventGenerator.NS_SV_PREFIX + ":" + SysViewSAXEventGenerator.NAME_ATTRIBUTE);
-            // check element name
-            if (SysViewSAXEventGenerator.NODE_ELEMENT.equals(elemName)) {
-                // sv:node element
-
-                // node name (value of sv:name attribute)
-                String name = atts.getValue(SysViewSAXEventGenerator.NS_SV_URI, SysViewSAXEventGenerator.NAME_ATTRIBUTE);
-                if (name == null) {
-                    // try qualified name
-                    name = atts.getValue(SysViewSAXEventGenerator.NS_SV_PREFIX + ":" + SysViewSAXEventGenerator.NAME_ATTRIBUTE);
-                }
-                if (name == null) {
-                    throw new SAXException(new InvalidSerializedDataException("missing mandatory sv:name attributeof element sv:node"));
-                }
-
-                ImportState current = (ImportState) stateStack.peek();
-                if (current.node == null) {
-                    // need to create current node first
-                    createNode(current);
-                }
-
-                // push new ImportState instance onto the stack
-                ImportState state = new ImportState();
-                state.parent = current.node;
-                try {
-                    state.nodeName = QName.fromJCRName(name, session.getNamespaceResolver());
-                } catch (IllegalNameException ine) {
-                    throw new SAXException(new InvalidSerializedDataException("illegal node name: " + name, ine));
-                } catch (UnknownPrefixException upe) {
-                    throw new SAXException(new InvalidSerializedDataException("illegal node name: " + name, upe));
-                }
-                stateStack.push(state);
-            } else if (SysViewSAXEventGenerator.PROPERTY_ELEMENT.equals(elemName)) {
-                // sv:property element
-
-                // reset temp fields
-                currentPropValues = new ArrayList();
-
-                // property name (value of sv:name attribute)
-                String name = atts.getValue(SysViewSAXEventGenerator.NS_SV_URI, SysViewSAXEventGenerator.NAME_ATTRIBUTE);
-                if (name == null) {
-                    // try qualified name
-                    name = atts.getValue(SysViewSAXEventGenerator.NS_SV_PREFIX + ":" + SysViewSAXEventGenerator.NAME_ATTRIBUTE);
-                }
-                if (name == null) {
-                    throw new SAXException(new InvalidSerializedDataException("missing mandatory sv:name attributeof element sv:property"));
-                }
-                try {
-                    currentPropName = QName.fromJCRName(name, session.getNamespaceResolver());
-                } catch (IllegalNameException ine) {
-                    throw new SAXException(new InvalidSerializedDataException("illegal property name: " + name, ine));
-                } catch (UnknownPrefixException upe) {
-                    throw new SAXException(new InvalidSerializedDataException("illegal property name: " + name, upe));
-                }
-                // property type (sv:type attribute)
-                String type = atts.getValue(SysViewSAXEventGenerator.NS_SV_URI, SysViewSAXEventGenerator.TYPE_ATTRIBUTE);
-                if (type == null) {
-                    // try qualified name
-                    type = atts.getValue(SysViewSAXEventGenerator.NS_SV_PREFIX + ":" + SysViewSAXEventGenerator.TYPE_ATTRIBUTE);
-                }
-                if (type == null) {
-                    throw new SAXException(new InvalidSerializedDataException("missing mandatory sv:type attributeof element sv:property"));
-                }
-                currentPropType = PropertyType.valueFromName(type);
-            } else if (SysViewSAXEventGenerator.VALUE_ELEMENT.equals(elemName)) {
-                // sv:value element
-
-                // reset temp fields
-                currentPropValue = new StringBuffer();
-            } else {
-                throw new SAXException(new InvalidSerializedDataException("unexpected element found in system view xml document: " + elemName));
+            if (name == null) {
+                throw new SAXException(new InvalidSerializedDataException("missing mandatory sv:name attributeof element sv:node"));
-        } catch (RepositoryException re) {
-            throw new SAXException(re);
+
+            if (!stack.isEmpty()) {
+                // process current node first
+                ImportState current = (ImportState) stack.peek();
+                // need to start current node
+                processNode(current, true, false);
+                current.started = true;
+            }
+
+            // push new ImportState instance onto the stack
+            ImportState state = new ImportState();
+            try {
+                state.nodeName = QName.fromJCRName(name, nsContext);
+            } catch (IllegalNameException ine) {
+                throw new SAXException(new InvalidSerializedDataException("illegal node name: " + name, ine));
+            } catch (UnknownPrefixException upe) {
+                throw new SAXException(new InvalidSerializedDataException("illegal node name: " + name, upe));
+            }
+            stack.push(state);
+        } else if (SysViewSAXEventGenerator.PROPERTY_ELEMENT.equals(elemName)) {
+            // sv:property element
+
+            // reset temp fields
+            currentPropValues.clear();
+
+            // property name (value of sv:name attribute)
+            String name = atts.getValue(SysViewSAXEventGenerator.NS_SV_URI, SysViewSAXEventGenerator.NAME_ATTRIBUTE);
+            if (name == null) {
+                // try qualified name
+                name = atts.getValue(SysViewSAXEventGenerator.NS_SV_PREFIX + ":" + SysViewSAXEventGenerator.NAME_ATTRIBUTE);
+            }
+            if (name == null) {
+                throw new SAXException(new InvalidSerializedDataException("missing mandatory sv:name attributeof element sv:property"));
+            }
+            try {
+                currentPropName = QName.fromJCRName(name, nsContext);
+            } catch (IllegalNameException ine) {
+                throw new SAXException(new InvalidSerializedDataException("illegal property name: " + name, ine));
+            } catch (UnknownPrefixException upe) {
+                throw new SAXException(new InvalidSerializedDataException("illegal property name: " + name, upe));
+            }
+            // property type (sv:type attribute)
+            String type = atts.getValue(SysViewSAXEventGenerator.NS_SV_URI, SysViewSAXEventGenerator.TYPE_ATTRIBUTE);
+            if (type == null) {
+                // try qualified name
+                type = atts.getValue(SysViewSAXEventGenerator.NS_SV_PREFIX + ":" + SysViewSAXEventGenerator.TYPE_ATTRIBUTE);
+            }
+            if (type == null) {
+                throw new SAXException(new InvalidSerializedDataException("missing mandatory sv:type attributeof element sv:property"));
+            }
+            currentPropType = PropertyType.valueFromName(type);
+        } else if (SysViewSAXEventGenerator.VALUE_ELEMENT.equals(elemName)) {
+            // sv:value element
+
+            // reset temp fields
+            currentPropValue = new StringBuffer();
+        } else {
+            throw new SAXException(new InvalidSerializedDataException("unexpected element found in system view xml document: " + elemName));
-                    elemName = QName.fromJCRName(qName, session.getNamespaceResolver()).getLocalName();
+                    elemName = QName.fromJCRName(qName, nsContext).getLocalName();
-            ImportState current = (ImportState) stateStack.peek();
+            ImportState state = (ImportState) stack.peek();
-                if (current.node == null) {
-                    // need to create current node first
-                    createNode(current);
+                if (!state.started) {
+                    // need to start & end current node
+                    processNode(state, true, true);
+                    state.started = true;
+                } else {
+                    // need to end current node
+                    processNode(state, false, true);
-                stateStack.pop();
+                stack.pop();
-                        current.primaryType = QName.fromJCRName((String) currentPropValues.get(0), session.getNamespaceResolver());
+                        state.nodeTypeName = QName.fromJCRName((String) currentPropValues.get(0), nsContext);
-                    if (current.mixinTypes == null) {
-                        current.mixinTypes = new ArrayList(currentPropValues.size());
+                    if (state.mixinNames == null) {
+                        state.mixinNames = new ArrayList(currentPropValues.size());
-                            QName mixin = QName.fromJCRName((String) currentPropValues.get(i), session.getNamespaceResolver());
-                            current.mixinTypes.add(mixin);
+                            QName mixin = QName.fromJCRName((String) currentPropValues.get(i), nsContext);
+                            state.mixinNames.add(mixin);
-                    current.uuid = (String) currentPropValues.get(0);
-                    // jcr:uuid is the last system property; we can assume that all
-                    // required system properties have been collected by now
-                    if (current.node == null) {
-                        // now that we've collected all required system properties
-                        // we're ready to create the node
-                        createNode(current);
-                    }
-                } else if (currentPropName.equals(JCR_BASEVERSION)) {
-                    // ignore so far
-                } else if (currentPropName.equals(JCR_VERSIONHISTORY)) {
-                    // ignore so far
-                } else if (currentPropName.equals(JCR_PREDECESSORS)) {
-                    // ignore so far
-                } else if (currentPropName.equals(JCR_ISCHECKEDOUT)) {
-                    // ignore so far
+                    state.uuid = (String) currentPropValues.get(0);
-                    // non-system property encountered; we can assume that all
-                    // required system properties have been collected by now
-                    if (current.node == null) {
-                        // now that we've collected all required system properties
-                        // we're ready to create the node
-                        createNode(current);
-                    }
-
-                    if (current.node.hasProperty(currentPropName)) {
-                        PropertyDef def = current.node.getProperty(currentPropName).getDefinition();
-                        if (def.isProtected()) {
-                            // ignore protected property
-                            // reset temp fields and get outta here
-                            currentPropValues = null;
-                            return;
-                        }
-                    }
-                    // multi- or single-valued property?
-                    if (vals.length == 1) {
-                        // could be single- or multi-valued (n == 1)
-                        try {
-                            // try setting single-value
-                            current.node.setProperty(currentPropName, vals[0]);
-                        } catch (ValueFormatException vfe) {
-                            // try setting value array
-                            current.node.setProperty(currentPropName, vals);
-                        } catch (ConstraintViolationException vfe) {
-                            // try setting value array
-                            current.node.setProperty(currentPropName, vals);
-                        }
-                    } else {
-                        // can only be multi-valued (n == 0 || n > 1)
-                        current.node.setProperty(currentPropName, vals);
-                    }
-                    if (currentPropType == PropertyType.REFERENCE) {
-                        // store reference for later resolution
-                        references.add(current.node.getProperty(currentPropName));
-                    }
+                    Importer.PropInfo prop = new Importer.PropInfo();
+                    prop.setName(currentPropName);
+                    prop.setType(currentPropType);
+                    prop.setValues(vals);
+
+                    state.props.add(prop);
-                currentPropValues = null;
+                currentPropValues.clear();
-            // adjust all reference properties
-            Iterator iter = references.iterator();
-            while (iter.hasNext()) {
-                Property prop = (Property) iter.next();
-                if (prop.getDefinition().isMultiple()) {
-                    Value[] values = prop.getValues();
-                    Value[] newVals = new Value[values.length];
-                    for (int i = 0; i < values.length; i++) {
-                        Value val = values[i];
-                        if (val.getType() == PropertyType.REFERENCE) {
-                            String original = val.getString();
-                            String adjusted = (String) referees.get(original);
-                            if (adjusted == null) {
-                                log.warn("Reference " + original + " of property can not be adjusted! " + prop.getPath());
-                                newVals[i] = val;
-                            } else {
-                                newVals[i] = new ReferenceValue(session.getNodeByUUID(adjusted));
-                            }
-                        } else {
-                            newVals[i] = val;
-                        }
-                    }
-                    prop.setValue(newVals);
-                } else {
-                    Value val = prop.getValue();
-                    if (val.getType() == PropertyType.REFERENCE) {
-                        String original = val.getString();
-                        String adjusted = (String) referees.get(original);
-                        if (adjusted == null) {
-                            log.warn("Reference " + original + " of property can not be adjusted! " + prop.getPath());
-                        } else {
-                            prop.setValue(session.getNodeByUUID(adjusted));
-                        }
-                    }
-                }
-            }
+            importer.end();
-            throw new SAXException("failed to adjust REFERENCE properties", re);
-        }
-    }
-
-    private void createNode(ImportState state) throws RepositoryException {
-        if (state.primaryType == null) {
-            throw new InvalidSerializedDataException("missing mandatory jcr:primaryType property");
-        }
-        if (state.uuid != null) {
-            // @todo what are the semantics of the uuid with respect to import?
-            // move existing node with given uuid to current position?
-            // create with new uuid? what about reference values refering to given uuid?
-        }
-        if (state.parent.hasNode(state.nodeName)) {
-            state.node = state.parent.getNode(state.nodeName);
-            NodeDef def = state.node.getDefinition();
-            if (def.isProtected() || def.isAutoCreate()) {
-                // @todo how to handle protected/auto-created child node?
-                state.node = (NodeImpl) state.parent.getNode(state.nodeName);
-            } else if (!def.allowSameNameSibs()) {
-                throw new ItemExistsException(state.parent.safeGetJCRPath() + "/" + state.nodeName);
-            }
-        }
-        if (state.node == null) {
-            state.node = (NodeImpl) state.parent.addNode(state.nodeName, state.primaryType);
-            if (state.mixinTypes != null) {
-                for (int i = 0; i < state.mixinTypes.size(); i++) {
-                    NodeTypeImpl mixin = session.getNodeTypeManager().getNodeType((QName) state.mixinTypes.get(i));
-                    state.node.addMixin(mixin.getName());
-                }
-            }
-        }
-
-        // check for mix:referenceable
-        if (state.node.isNodeType(MIX_REFERENCEABLE)) {
-            log.info("adding refereee: ori=" + state.uuid + " new=" + state.node.getUUID());
-            referees.put(state.uuid, state.node.getUUID());
+            throw new SAXException(re);
-        QName primaryType = null;
-        ArrayList mixinTypes = null;
-        String uuid = null;
+        /**
+         * name of current node
+         */
+        QName nodeName;
+        /**
+         * primary type of current node
+         */
+        QName nodeTypeName;
+        /**
+         * list of mixin types of current node
+         */
+        ArrayList mixinNames;
+        /**
+         * uuid of current node
+         */
+        String uuid;
-        QName nodeName = null;
-        NodeImpl parent = null;
-        NodeImpl node = null;
+        /**
+         * list of PropInfo instances representing properties of current node
+         */
+        ArrayList props = new ArrayList();
+
+        /**
+         * flag indicating whether startNode() has been called for current node
+         */
+        boolean started = false;

JCR-999  SPI: provide batch read functionality
JCR-1000 JCR2SPI: remove duplicate item states

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@552873 13f79535-47bb-0310-9956-ffa450edef68

-        NodeState nodeState = new NodeState(entry, nodetypeName, QName.EMPTY_ARRAY, definition, Status.NEW, false, this, defProvider);
+        NodeState nodeState = new NodeState(entry, nodetypeName, QName.EMPTY_ARRAY, this, definition, defProvider);
-        PropertyState propState = new PropertyState(entry, definition.isMultiple(), definition, Status.NEW, false, this, defProvider);
+        PropertyState propState = new PropertyState(entry, this, definition, defProvider);
-        // retrieve state to overlay
-        NodeState overlayedState = workspaceStateFactory.createRootState(entry);
-        return buildNodeState(overlayedState, Status.EXISTING);
+        NodeState state = workspaceStateFactory.createRootState(entry);
+        notifyCreated(state);
+
+        return state;
-        // retrieve state to overlay
-        NodeState overlayedState = workspaceStateFactory.createNodeState(nodeId, entry);
-        return buildNodeState(overlayedState, getInitialStatus(entry.getParent()));
+        NodeState state = workspaceStateFactory.createNodeState(nodeId, entry);
+        notifyCreated(state);
+
+        return state;
-        NodeState overlayedState = workspaceStateFactory.createDeepNodeState(nodeId, anyParent);
-        return buildNodeState(overlayedState, getInitialStatus(anyParent));
+        NodeState state = workspaceStateFactory.createDeepNodeState(nodeId, anyParent);
+        notifyCreated(state);
+
+        return state;
-        // retrieve state to overlay
-        PropertyState overlayedState = workspaceStateFactory.createPropertyState(propertyId, entry);
-        return buildPropertyState(overlayedState, getInitialStatus(entry.getParent()));
+
+        PropertyState state = workspaceStateFactory.createPropertyState(propertyId, entry);
+        notifyCreated(state);
+
+        return state;
+
-        PropertyState overlayedState = workspaceStateFactory.createDeepPropertyState(propertyId, anyParent);
-        return buildPropertyState(overlayedState, getInitialStatus(anyParent));
+        PropertyState state = workspaceStateFactory.createDeepPropertyState(propertyId, anyParent);
+        notifyCreated(state);
+
+        return state;
-
-        NodeState workspaceState = (NodeState) nodeState.getWorkspaceState();
-        return workspaceStateFactory.getNodeReferences(workspaceState);
-    }
-
-    //------------------------------------------------------------< private >---
-    /**
-     *
-     * @param overlayed
-     * @return
-     */
-    private NodeState buildNodeState(NodeState overlayed, int initialStatus) {
-        NodeState nodeState = new NodeState(overlayed, initialStatus, this);
-
-        notifyCreated(nodeState);
-        return nodeState;
-    }
-
-
-    /**
-     *
-     * @param overlayed
-     * @return
-     */
-    private PropertyState buildPropertyState(PropertyState overlayed, int initialStatus) {
-        PropertyState propState = new PropertyState(overlayed, initialStatus, this);
-
-        notifyCreated(propState);
-        return propState;
-    }
-
-    /**
-     *
-     * @param parent
-     * @return
-     */
-    private static int getInitialStatus(NodeEntry parent) {
-        int status = Status.EXISTING;
-        // walk up hiearchy and check if any of the parents is transiently
-        // removed, in which case the status must be set to EXISTING_REMOVED.
-        while (parent != null) {
-            if (parent.getStatus() == Status.EXISTING_REMOVED) {
-                status = Status.EXISTING_REMOVED;
-                break;
-            }
-            parent = parent.getParent();
-        }
-        return status;
+        return workspaceStateFactory.getNodeReferences(nodeState);

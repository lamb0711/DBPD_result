JCR-2195 Provide possibility to import protected items using Session/Workspace import functionality (ACL import)


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@810943 13f79535-47bb-0310-9956-ffa450edef68

+import javax.jcr.AccessDeniedException;
+import javax.jcr.security.AccessControlEntry;
+    /**
+     * the ACL for non-principal based
+     */
+    private JackrabbitAccessControlList acl = null;
+
+            acl = getACL(protectedParent.getParent().getPath());
+            if (acl == null) {
+                log.warn("AccessControlImporter cannot be started: no ACL for {}.", parent.getParent().getPath());
+                return false;
+            }
+            acl = null;
+    private JackrabbitAccessControlList getACL(String path) throws RepositoryException, AccessDeniedException {
+        JackrabbitAccessControlList acl = null;
+        for (AccessControlPolicy p: acMgr.getPolicies(path)) {
+            if (p instanceof JackrabbitAccessControlList) {
+                acl = (JackrabbitAccessControlList) p;
+                // don't know if this check is needed
+                if (path.equals(acl.getPath())) {
+                    break;
+                }
+                acl = null;
+            }
+        }
+        if (acl != null) {
+            // clear all existing entries
+            for (AccessControlEntry ace: acl.getAccessControlEntries()) {
+                acl.removeAccessControlEntry(ace);
+            }
+        }
+        return acl;
+    }
+
+            acMgr.setPolicy(acl.getPath(), acl);
+        acl = null;
-
-        // try to access policies
-        List<AccessControlPolicy> policies = new ArrayList<AccessControlPolicy>();
-        if (!principalbased) {
-            // no need to retrieve the applicable policies as the policy node
-            // itself is the start point of the protected import.
-            policies.addAll(Arrays.asList(acMgr.getPolicies(parent.getParent().getPath())));
-        } else {
+        if (principalbased) {
+            // try to access policies
+            List<AccessControlPolicy> policies = new ArrayList<AccessControlPolicy>();
-        }
-
-        for (AccessControlPolicy policy : policies) {
-            if (policy instanceof JackrabbitAccessControlList) {
-                JackrabbitAccessControlList acl = (JackrabbitAccessControlList) policy;
-                // test if this acl can be used to apply the ACE
-                boolean matches;
-                if (!principalbased) {
-                    // resource-based the acl-path must correspond to the path
-                    // of the start-point of the protected import that was the
-                    // policy node itself.
-                    matches = parent.getParent().getPath().equals(acl.getPath());
-                } else {
-                    // principal based acl: just try the first one (TODO: check again)
-                    matches = true;
-                }
-
-                if (matches) {
+            for (AccessControlPolicy policy : policies) {
+                if (policy instanceof JackrabbitAccessControlList) {
+                    JackrabbitAccessControlList acl = (JackrabbitAccessControlList) policy;
-
+        } else {
+            Map<String, Value> restr = new HashMap<String, Value>();
+            for (String restName : acl.getRestrictionNames()) {
+                TextValue txtVal = restrictions.remove(restName);
+                if (txtVal != null) {
+                    restr.put(restName, txtVal.getValue(acl.getRestrictionType(restName), resolver));
+                }
+            }
+            if (!restrictions.isEmpty()) {
+                throw new ConstraintViolationException("ACE childInfo contained restrictions that could not be applied.");
+            }
+            acl.addEntry(principal, privileges, isAllow, restr);
+            return;
+

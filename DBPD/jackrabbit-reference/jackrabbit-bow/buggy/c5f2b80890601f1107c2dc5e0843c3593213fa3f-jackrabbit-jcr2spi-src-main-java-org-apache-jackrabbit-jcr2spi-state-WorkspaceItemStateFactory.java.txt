JCR-1638: Redundant calls to RepositoryService.getChildInfos

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@701388 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.HashMap;
+import java.util.Map;
+import java.util.NoSuchElementException;
-            return createDeepPropertyState(info, anyParent);
+            return createDeepPropertyState(info, anyParent, null);
+     * @param isDeep
-    private synchronized NodeState createItemStates(NodeId nodeId,
-                                                    Iterator itemInfos,
-                                                    NodeEntry entry,
-                                                    boolean isDeep)
+    private synchronized NodeState createItemStates(NodeId nodeId, Iterator itemInfos,
+                                                    NodeEntry entry, boolean isDeep)
+        ItemInfos infos = new ItemInfos(itemInfos);
-                nodeState = createDeepNodeState(first, entry);
+                nodeState = createDeepNodeState(first, entry, infos);
-                    createDeepNodeState((NodeInfo) info, parentEntry);
+                    createDeepNodeState((NodeInfo) info, parentEntry, infos);
-                    createDeepPropertyState((PropertyInfo) info, parentEntry);
+                    createDeepPropertyState((PropertyInfo) info, parentEntry, infos);
-        // this make not be the case, if the hierachy has not been completely
+        // this make not be the case, if the hierarchy has not been completely
-    private NodeState createDeepNodeState(NodeInfo info, NodeEntry anyParent) throws RepositoryException {
+    private NodeState createDeepNodeState(NodeInfo info, NodeEntry anyParent, ItemInfos infos) throws RepositoryException {
-                entry = createIntermediateNodeEntry(entry, name, index);
+                entry = createIntermediateNodeEntry(entry, name, index, infos);
-    private PropertyState createDeepPropertyState(PropertyInfo info, NodeEntry anyParent) throws RepositoryException {
+    private PropertyState createDeepPropertyState(PropertyInfo info, NodeEntry anyParent, ItemInfos infos) throws RepositoryException {
-            Path anyParentPath = anyParent.getPath();
+            Path anyParentPath = anyParent.getWorkspacePath();
+
-                entry = createIntermediateNodeEntry(entry, name, index);
+                entry = createIntermediateNodeEntry(entry, name, index, infos);
-            PropertyEntry propEntry = entry.getPropertyEntry(propName);
-            if (propEntry == null) {
-                propEntry = entry.addPropertyEntry(propName);
-            }
+            PropertyEntry propEntry = entry.getOrAddPropertyEntry(propName);
+
-    private static NodeEntry createIntermediateNodeEntry(NodeEntry parentEntry, Name name, int index) throws RepositoryException {
-        NodeEntry entry;
-        if (parentEntry.hasNodeEntry(name, index)) {
-            entry = parentEntry.getNodeEntry(name, index);
-        } else {
-            entry = parentEntry.addNodeEntry(name, null, index);
+    private static NodeEntry createIntermediateNodeEntry(NodeEntry parentEntry,
+                                                         Name name, int index,
+                                                         ItemInfos infos) throws RepositoryException {
+        if (infos != null && !parentEntry.hasNodeEntry(name, index)) {
+            Iterator childInfos = infos.getChildInfos(parentEntry.getWorkspaceId());
+            if (childInfos != null) {
+                parentEntry.setNodeEntries(childInfos);
+            }
+        NodeEntry entry = parentEntry.getOrAddNodeEntry(name, index, null);
-     *
-     * @return
+     * @return the ancestor entry at the specified degree.
+    //--------------------------------------------------------------------------
+    /**
+     * Iterator
+     */
+    private class ItemInfos implements Iterator {
+
+        private final List prefetchQueue = new ArrayList();
+        private final Map nodeInfos = new HashMap();
+        private final Iterator infos;
+
+        private ItemInfos(Iterator infos) {
+            super();
+            this.infos = infos;
+        }
+
+        // ------------------------------------------------------< Iterator >---
+        /**
+         * @see Iterator#hasNext()
+         */
+        public boolean hasNext() {
+            if (!prefetchQueue.isEmpty()) {
+                return true;
+            } else {
+                return prefetch();
+            }
+        }
+
+        /**
+         * @see Iterator#next()
+         */
+        public Object next() {
+            if (prefetchQueue.isEmpty()) {
+                throw new NoSuchElementException();
+            } else {
+                return prefetchQueue.remove(0);
+            }
+        }
+
+        /**
+         * @see Iterator#remove()
+         */
+        public void remove() {
+            throw new UnsupportedOperationException();
+        }
+
+        // -------------------------------------------------------< private >---
+        /**
+         * @param parentId
+         * @return The children <code>NodeInfo</code>s for the parent identified
+         * by the given <code>parentId</code> or <code>null</code> if the parent
+         * has not been read yet or does not provide child infos.
+         */
+        private Iterator getChildInfos(NodeId parentId) {
+            NodeInfo nodeInfo = (NodeInfo) nodeInfos.get(parentId);
+            while (nodeInfo == null && prefetch()) {
+                nodeInfo = (NodeInfo) nodeInfos.get(parentId);
+            }
+            return nodeInfo == null? null : nodeInfo.getChildInfos();
+        }
+
+        /**
+         * @return <code>true</code> if the next info could be retrieved.
+         */
+        private boolean prefetch() {
+            if (infos.hasNext()) {
+                ItemInfo info = (ItemInfo) infos.next();
+                prefetchQueue.add(info);
+                if (info.denotesNode()) {
+                    NodeInfo nodeInfo = (NodeInfo) info;
+                    nodeInfos.put(nodeInfo.getId(), nodeInfo);
+                }
+                return true;
+            } else {
+                return false;
+            }
+        }
+    }

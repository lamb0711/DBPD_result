JCR-2076: JSR 283: QOM and SQL2
- change return type of QueryInfo.getColumnNames() from Name[] to String[]
- jcr2spi, spi2dav, spi2jcr implementation (work in progress)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@789269 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Map;
+import java.util.HashMap;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Arrays;
+
-import org.apache.jackrabbit.spi.Path;
+import org.apache.jackrabbit.spi.Name;
-import org.apache.jackrabbit.spi.commons.conversion.NameException;
+import javax.jcr.Node;
-     * The node id of the underlying row.
+     * The node ids of the underlying row.
-    private final NodeId nodeId;
+    private final Map<Name, NodeId> nodeIds = new HashMap<Name, NodeId>();
-     * The score value for this row.
+     * The score values for this row.
-    private final double score;
+    private final Map<Name, Double> scores = new HashMap<Name, Double>();
-     * @param scoreName     the name of the jcr:score column.
-     * @param pathName      the name of the jcr:path column
+     * @param selectorNames the selector names.
-     * @param resolver
+     * @param resolver      the name path resolver.
-                              String scoreName,
-                              String pathName,
+                              Name[] selectorNames,
-        String jcrPath = row.getValue(pathName).getString();
-        Path path;
-        try {
-            path = resolver.getQPath(jcrPath);
-        } catch (NameException e) {
-            throw new RepositoryException(e.getMessage(), e);
-        }
-        this.nodeId = idFactory.createNodeId((String) null, path);
-        this.score = row.getValue(scoreName).getDouble();
+        List<Name> selNames = new ArrayList<Name>();
+        selNames.addAll(Arrays.asList(selectorNames));
+        if (selNames.isEmpty()) {
+            selNames.add(null); // default selector
+        }
+        for (Name sn : selNames) {
+            Node n;
+            double score;
+            if (sn == null) {
+                n = row.getNode();
+                score = row.getScore();
+            } else {
+                String selName = resolver.getJCRName(sn);
+                n = row.getNode(selName);
+                score = row.getScore(selName);
+            }
+            NodeId id = null;
+            if (n != null) {
+                id = idFactory.fromJcrIdentifier(n.getIdentifier());
+            }
+            nodeIds.put(sn, id);
+            scores.put(sn, score);
+        }
-    /**
-     * {@inheritDoc}
-     */
-    public NodeId getNodeId() {
-        return nodeId;
+    public NodeId getNodeId(Name selectorName) {
+        NodeId id = nodeIds.get(selectorName);
+        if (id == null) {
+            if (nodeIds.size() == 1) {
+                return nodeIds.values().iterator().next();
+            } else {
+                throw new IllegalArgumentException(selectorName + " is not a valid selectorName");
+            }
+        }
+        return id;
-    /**
-     * {@inheritDoc}
-     */
-    public double getScore() {
+    public double getScore(Name selectorName) {
+        Double score = scores.get(selectorName);
+        if (score == null) {
+            if (scores.size() == 1) {
+                return scores.values().iterator().next();
+            } else {
+                throw new IllegalArgumentException(selectorName + " is not a valid selectorName");
+            }
+        }

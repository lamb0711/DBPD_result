JCR-2715: Improved join query performance

Handle query offset and limit only after sorting.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1025643 13f79535-47bb-0310-9956-ffa450edef68

-        QueryResult result = merger.merge(
-                new RowIteratorAdapter(leftRows), rightRows, offset, limit);
-        return sort(result, orderings);
+        QueryResult result =
+            merger.merge(new RowIteratorAdapter(leftRows), rightRows);
+        return sort(result, orderings, offset, limit);
-        while ((offset-- > 0 || limit == 0) && nodes.hasNext()) {
-            nodes.next();
-        }
-        if (limit > 0) {
-            List<Node> list = new ArrayList<Node>((int) limit);
-            for (int i = 0; i < limit && nodes.hasNext(); i++) {
-                list.add(nodes.nextNode());
-            }
-            nodes = new NodeIteratorAdapter(list);
-        }
-
-        RangeIterator rows = new RangeIteratorAdapter(nodes) {
+        RowIterator rows = new RowIteratorAdapter(nodes) {
-        QueryResult result = new SimpleQueryResult(
-                columnNames, selectorNames, new RowIteratorAdapter(rows));
-        return sort(result, orderings);
+        QueryResult result =
+            new SimpleQueryResult(columnNames, selectorNames, rows);
+        return sort(result, orderings, offset, limit);
+     * @param offset result offset
+     * @param limit result limit
-    public QueryResult sort(QueryResult result, final Ordering[] orderings)
-            throws RepositoryException {
-        if (orderings != null && orderings.length > 0) {
+    public QueryResult sort(
+            QueryResult result, final Ordering[] orderings,
+            long offset, long limit) throws RepositoryException {
+        if ((orderings != null && orderings.length > 0)
+                || offset != 0 || limit >= 0) {
-            Collections.sort(rows, new RowComparator(orderings));
+            if (orderings != null && orderings.length > 0) {
+                Collections.sort(rows, new RowComparator(orderings));
+            }
+
+            if (offset != 0 || limit >= 0) {
+                int from = (int) offset;
+                int to = rows.size();
+                if (limit >= 0 && offset + limit < to) {
+                    to = (int) (offset + limit);
+                }
+                rows = rows.subList(from, to);
+            }

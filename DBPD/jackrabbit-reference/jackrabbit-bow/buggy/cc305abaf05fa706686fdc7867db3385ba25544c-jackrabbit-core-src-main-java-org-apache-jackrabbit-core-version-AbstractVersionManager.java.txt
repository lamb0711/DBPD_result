JCR-1592 - JSR 283: Activities


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@784261 13f79535-47bb-0310-9956-ffa450edef68

+import javax.jcr.ItemNotFoundException;
+import javax.jcr.ReferentialIntegrityException;
+import javax.jcr.RepositoryException;
+import javax.jcr.Session;
+import javax.jcr.Value;
+import javax.jcr.version.VersionException;
+
-import org.apache.jackrabbit.core.state.ItemStateException;
-import org.apache.jackrabbit.core.state.LocalItemStateManager;
-import org.apache.jackrabbit.core.state.NodeState;
+import org.apache.jackrabbit.core.state.ItemStateException;
+import org.apache.jackrabbit.core.state.LocalItemStateManager;
+import org.apache.jackrabbit.core.state.NodeReferences;
+import org.apache.jackrabbit.core.state.NodeReferencesId;
+import org.apache.jackrabbit.core.state.NodeState;
+import org.apache.jackrabbit.uuid.UUID;
-import javax.jcr.RepositoryException;
-import javax.jcr.Session;
-import javax.jcr.Value;
-import javax.jcr.ItemNotFoundException;
-import javax.jcr.version.VersionException;
-
+     * Persistent root node of the activities.
+     */
+    protected NodeStateEx activitiesRoot;
+
+    /**
+    public InternalActivity getActivity(NodeId id) throws RepositoryException {
+        // lock handling via getItem()
+        InternalActivity v = (InternalActivity) getItem(id);
+        if (v == null) {
+            log.warn("Versioning item not found: " + id);
+        }
+        return v;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
-            NodeStateEx parent = getParentNode(uuid, false);
+            NodeStateEx parent = getParentNode(historyRoot, uuid, null);
-            NodeStateEx parent = getParentNode(uuid, false);
+            NodeStateEx parent = getParentNode(historyRoot, uuid, null);
-    NodeStateEx createVersionHistory(NodeState node, NodeId copiedFrom)
+    NodeStateEx internalCreateVersionHistory(NodeState node, NodeId copiedFrom)
-            NodeStateEx parent = getParentNode(uuid, true);
+            NodeStateEx parent = getParentNode(historyRoot, uuid, NameConstants.REP_VERSIONSTORAGE);
+     * Creates a new activity.
+     *
+     * @param title title of the new activity
+     * @return the id of the newly created activity
+     * @throws RepositoryException if an error occurs
+     */
+    NodeStateEx internalCreateActivity(String title)
+            throws RepositoryException {
+        WriteOperation operation = startWriteOperation();
+        try {
+            // create deep path
+            NodeId activityId = new NodeId(UUID.randomUUID());
+            NodeStateEx parent = getParentNode(activitiesRoot, activityId.toString(), NameConstants.REP_ACTIVITIES);
+            Name name = getName(activityId.toString());
+
+            // create new activity node in the persistent state
+            NodeStateEx pNode = InternalActivityImpl.create(parent, name, activityId, title);
+
+            // end update
+            operation.save();
+
+            log.debug("Created new activity " + activityId
+                    + " with title " + title + ".");
+            return pNode;
+        } catch (ItemStateException e) {
+            throw new RepositoryException(e);
+        } finally {
+            operation.close();
+        }
+    }
+
+    /**
+     * Removes the specified activity
+     *
+     * @param activity the acitvity to remove
+     * @throws javax.jcr.RepositoryException if any other error occurs.
+     */
+    protected void internalRemoveActivity(InternalActivityImpl activity)
+            throws RepositoryException {
+        WriteOperation operation = startWriteOperation();
+        try {
+            // check if the activity has any references in the workspaces
+            NodeId nodeId = activity.getId();
+            NodeReferencesId refId = new NodeReferencesId(nodeId);
+            if (stateMgr.hasNodeReferences(refId)) {
+                NodeReferences refs = stateMgr.getNodeReferences(refId);
+                if (refs.hasReferences()) {
+                    throw new ReferentialIntegrityException("Unable to delete activity. still referenced.");
+                }
+            }
+            // TODO:
+            // check if the activity is used in anywhere in the version storage
+            // and reject removal
+
+            // remove activity and possible empty parent directories
+            NodeStateEx act = getNodeStateEx(nodeId);
+            NodeId parentId = act.getParentId();
+            Name name = act.getName();
+            while (parentId != null) {
+                NodeStateEx parent = getNodeStateEx(parentId);
+                parent.removeNode(name);
+                parent.store();
+                if (parent.getChildNodes().length == 0 && !parentId.equals(activitiesRoot.getNodeId())) {
+                    name = parent.getName();
+                    parentId = parent.getParentId();
+                } else {
+                    parentId = null;
+                }
+            }
+            operation.save();
+        } catch (ItemStateException e) {
+            log.error("Error while storing: " + e.toString());
+        } finally {
+            operation.close();
+        }
+    }
+
+    /**
-     * the create flag is set, then the returned parent node and any ancestor
-     * nodes are automatically created if they do not already exist. Otherwise
+     * the <code>interNT</code> is not <code>null</code> then the returned
+     * parent node and any ancestor nodes are automatically created if they do
+     * not already exist. Otherwise
+     * @param parent the parent node
-     * @param create whether to create missing nodes
+     * @param interNT intermediate nodetype.
-    private NodeStateEx getParentNode(String uuid, boolean create)
+    private NodeStateEx getParentNode(NodeStateEx parent, String uuid, Name interNT)
-        NodeStateEx n = historyRoot;
+        NodeStateEx n = parent;
-            } else if (create) {
-                n.addNode(name, NameConstants.REP_VERSIONSTORAGE, null, false);
+            } else if (interNT != null) {
+                n.addNode(name, interNT, null, false);
-    protected InternalVersion checkin(InternalVersionHistoryImpl history,
+    protected InternalVersion internalCheckin(InternalVersionHistoryImpl history,
+
+            // check for jcr:activity
+            if (node.hasProperty(NameConstants.JCR_ACTIVITY)) {
+                NodeId actId = new NodeId(node.getProperty(NameConstants.JCR_ACTIVITY).internalGetValue().getUUID());
+                InternalActivityImpl act = (InternalActivityImpl) getItem(actId);
+                act.addVersion(v);
+            }
+
-    protected void removeVersion(InternalVersionHistoryImpl history, Name name)
+    protected void internalRemoveVersion(InternalVersionHistoryImpl history, Name name)
+                } else if (ntName.equals(NameConstants.NT_ACTIVITY)) {
+                    return new InternalActivityImpl(this, pNode);

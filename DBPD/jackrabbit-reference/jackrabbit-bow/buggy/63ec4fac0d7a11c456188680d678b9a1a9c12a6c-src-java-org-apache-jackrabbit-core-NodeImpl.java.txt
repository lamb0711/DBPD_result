redesigned transaction support & PersistenceManager

orginal code contributed by dominique pfister, required a lot of tweaking to make it run & work; not thoroughly tested

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@126221 13f79535-47bb-0310-9956-ffa450edef68

-                        itemStateMgr.createTransientNodeState((NodeState) state, ItemState.STATUS_EXISTING_MODIFIED);
+                        stateMgr.createTransientNodeState((NodeState) state, ItemState.STATUS_EXISTING_MODIFIED);
-        PropertyId propId = new PropertyId(((NodeState) state).getUUID(), name);
-        if (itemMgr.itemExists(propId)) {
+        NodeState thisState = (NodeState) state;
+        if (thisState.hasPropertyEntry(name)) {
+            /**
+             * the following call will throw ItemNotFoundException if the
+             * current session doesn't have read access
+             */
+
-        // check if versioning allows write (only cheep call)
+        // check if versioning allows write (only cheap call)
-            propState = itemStateMgr.createTransientPropertyState(parentUUID, name, ItemState.STATUS_NEW);
+            propState = stateMgr.createTransientPropertyState(parentUUID, name, ItemState.STATUS_NEW);
-            nodeState = itemStateMgr.createTransientNodeState(uuid, nodeType.getQName(), parentUUID, ItemState.STATUS_NEW);
+            nodeState = stateMgr.createTransientNodeState(uuid, nodeType.getQName(), parentUUID, ItemState.STATUS_NEW);
-            itemStateMgr.disposeTransientItemState(nodeState);
+            stateMgr.disposeTransientItemState(nodeState);
-        // check if versioning allows write (only cheep call)
+        // check if versioning allows write (only cheap call)
-    protected void makePersistent() throws RepositoryException {
+    protected void makePersistent(UpdateOperation update) {
-        try {
-            NodeState transientState = (NodeState) state;
+        NodeState transientState = (NodeState) state;
-            PersistentNodeState persistentState = (PersistentNodeState) transientState.getOverlayedState();
-            if (persistentState == null) {
-                // this node is 'new'
-                persistentState = itemStateMgr.createPersistentNodeState(transientState.getUUID(), transientState.getNodeTypeName(), transientState.getParentUUID());
-            }
-            // copy state from transient state:
-            // parent uuid's
-            persistentState.setParentUUID(transientState.getParentUUID());
-            persistentState.setParentUUIDs(transientState.getParentUUIDs());
-            // mixin types
-            persistentState.setMixinTypeNames(transientState.getMixinTypeNames());
-            // id of definition
-            persistentState.setDefinitionId(transientState.getDefinitionId());
-            // child node entries
-            persistentState.setChildNodeEntries(transientState.getChildNodeEntries());
-            // property entries
-            persistentState.setPropertyEntries(transientState.getPropertyEntries());
-
-            // make state persistent
-            persistentState.store();
-            // remove listener from transient state
-            transientState.removeListener(this);
-            // add listener to persistent state
-            persistentState.addListener(this);
-            // swap transient state with persistent state
-            state = persistentState;
-            // reset status
-            status = STATUS_NORMAL;
-        } catch (ItemStateException ise) {
-            String msg = "failed to persist transient state of " + safeGetJCRPath() + " (" + id + ")";
-            log.error(msg, ise);
-            throw new RepositoryException(msg, ise);
+        NodeState persistentState = (NodeState) transientState.getOverlayedState();
+        if (persistentState == null) {
+            // this node is 'new'
+            persistentState = update.createNew(transientState.getUUID(),
+                    transientState.getNodeTypeName(), transientState.getParentUUID());
+        // copy state from transient state:
+        // parent uuid's
+        persistentState.setParentUUID(transientState.getParentUUID());
+        persistentState.setParentUUIDs(transientState.getParentUUIDs());
+        // mixin types
+        persistentState.setMixinTypeNames(transientState.getMixinTypeNames());
+        // id of definition
+        persistentState.setDefinitionId(transientState.getDefinitionId());
+        // child node entries
+        persistentState.setChildNodeEntries(transientState.getChildNodeEntries());
+        // property entries
+        persistentState.setPropertyEntries(transientState.getPropertyEntries());
+
+        // make state persistent
+        update.store(persistentState);
+        // remove listener from transient state
+        transientState.removeListener(this);
+        // add listener to persistent state
+        persistentState.addListener(this);
+        // swap transient state with persistent state
+        state = persistentState;
+        // reset status
+        status = STATUS_NORMAL;
-                prop.internalSetValue((InternalValue[]) null, type);
+                prop.internalSetValue(null, type);
-        // check if versioning allows write (only cheep call)
+        // check if versioning allows write (only cheap call)
-        WorkspaceImpl wsp = (WorkspaceImpl) session.getWorkspace();
-        ReferenceManager refMgr = wsp.getReferenceManager();
-        synchronized (refMgr) {
-            NodeReferences refs = refMgr.get((NodeId) id);
+        try {
+            NodeReferences refs = stateMgr.getNodeReferences((NodeId) id);
+        } catch (ItemStateException e) {
+            String msg = "Unable to retrieve node references for: " + id;
+            log.error(msg);
+            throw new RepositoryException(msg, e);
-        NodeTypeImpl nt = (NodeTypeImpl) ntMgr.getNodeType(frozen.getFrozenPrimaryType());
+        NodeTypeImpl nt = ntMgr.getNodeType(frozen.getFrozenPrimaryType());
-        NodeTypeImpl nt = (NodeTypeImpl) ntMgr.getNodeType(frozen.getFrozenPrimaryType());
+        NodeTypeImpl nt = ntMgr.getNodeType(frozen.getFrozenPrimaryType());

NodeImpl might reference outdated NodeTypeImpl instance upon changes in NodeTypeRegistry

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@220311 13f79535-47bb-0310-9956-ffa450edef68

-    protected final NodeTypeImpl nodeType;
+    /** same as ((NodeState) state).getNodeTypeName(); cached to avoid type casts */
+    protected final QName primaryTypeName;
-     * @throws RepositoryException
-                       ItemLifeCycleListener[] listeners)
-            throws RepositoryException {
+                       ItemLifeCycleListener[] listeners) {
-        NodeTypeImpl nt;
-        try {
-            nt = session.getNodeTypeManager().getNodeType(state.getNodeTypeName());
-        } catch (NoSuchNodeTypeException e) {
+        // paranoid sanity check
+        NodeTypeRegistry ntReg = session.getNodeTypeManager().getNodeTypeRegistry();
+        if (ntReg.isRegistered(state.getNodeTypeName())) {
+            primaryTypeName = state.getNodeTypeName();
+        } else {
-            nt = session.getNodeTypeManager().getNodeType(NT_UNSTRUCTURED);
+            primaryTypeName = NT_UNSTRUCTURED;
-        this.nodeType = nt;
-                genValues = new InternalValue[]{InternalValue.create(nodeType.getQName())};
+                genValues = new InternalValue[]{InternalValue.create(primaryTypeName)};
-        set.add(nodeType.getQName());
+        set.add(primaryTypeName);
-        if (nodeType.isDerivedFrom(mixinName)) {
+        NodeTypeImpl primaryType = ntMgr.getNodeType(primaryTypeName);
+        if (primaryType.isDerivedFrom(mixinName)) {
-            set.add(nodeType.getQName());
+            set.add(primaryTypeName);
-            set.add(nodeType.getQName());
+            set.add(primaryTypeName);
-        if (ntName.equals(nodeType.getQName())) {
+        if (ntName.equals(primaryTypeName)) {
-        if (nodeType.isDerivedFrom(ntName)) {
-            return true;
-        }
-
-        // check mixin types
-        Set mixinNames = ((NodeState) state).getMixinTypeNames();
-        if (mixinNames.isEmpty()) {
-            return false;
-        }
+        // build effective node type representing primary type incl. mixin's
+        // and check whether it includes the specified node type
+        // mixin's
+        HashSet set = new HashSet(((NodeState) state).getMixinTypeNames());
+        // primary type
+        set.add(primaryTypeName);
-            EffectiveNodeType ent = ntReg.getEffectiveNodeType((QName[]) mixinNames.toArray(new QName[mixinNames.size()]));
+            EffectiveNodeType ent =
+                    ntReg.getEffectiveNodeType((QName[]) set.toArray(new QName[set.size()]));
-            String msg = "internal error: invalid mixin node type(s)";
+            String msg = "internal error: failed to build effective node type of "
+                    + set;
-        if (!nodeType.hasOrderableChildNodes()) {
+        if (!getPrimaryNodeType().hasOrderableChildNodes()) {
-        return nodeType;
+        return session.getNodeTypeManager().getNodeType(primaryTypeName);
-        if (nodeType.isDerivedFrom(ntName)) {
+        NodeTypeImpl primaryType = ntMgr.getNodeType(primaryTypeName);
+        if (primaryType.isDerivedFrom(ntName)) {
-            set.add(nodeType.getQName());
+            set.add(primaryTypeName);
-        String name = nodeType.getPrimaryItemName();
+        String name = getPrimaryNodeType().getPrimaryItemName();
-        if (!freeze.getFrozenPrimaryType().equals(nodeType.getQName())) {
+        if (!freeze.getFrozenPrimaryType().equals(primaryTypeName)) {

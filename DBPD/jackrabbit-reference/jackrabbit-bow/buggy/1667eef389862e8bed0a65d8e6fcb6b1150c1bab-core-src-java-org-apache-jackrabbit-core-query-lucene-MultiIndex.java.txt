JCR-177: Commit volatile index to disc after some configurable idle time

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@231015 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Timer;
+import java.util.TimerTask;
- * the volatile index reaches a certain size (see {@link SearchIndex#setMinMergeDocs(int)} a
- * new persistent index is created with the index data from the volatile index.
- * the new persistent index is then added to the list of already existing
- * persistent indexes. Furhter operations on the new persistent index will
+ * the volatile index reaches a certain size (see {@link SearchIndex#setMinMergeDocs(int)})
+ * a new persistent index is created with the index data from the volatile index,
+ * the same happens when the volatile index has been idle for some time (see
+ * {@link SearchIndex#setVolatileIdleTime(int)}).
+ * The new persistent index is then added to the list of already existing
+ * persistent indexes. Further operations on the new persistent index will
+     * The last time this index was modified. That is, a document was added
+     * or removed.
+     */
+    private long lastModificationTime;
+
+    /**
+     * Timer to schedule commits of the volatile index after some idle time.
+     */
+    private final Timer commitTimer = new Timer(true);
+
+    /**
+        lastModificationTime = System.currentTimeMillis();
+        startCommitTimer();
+        lastModificationTime = System.currentTimeMillis();
+        lastModificationTime = System.currentTimeMillis();
+        lastModificationTime = System.currentTimeMillis();
+        // stop timer
+        commitTimer.cancel();
+
+        // commit / close indexes
+     * Starts the commit timer that periodically checks if the volatile index
+     * should be committed. The timer task will call {@link #checkCommit()}.
+     */
+    private void startCommitTimer() {
+        commitTimer.schedule(new TimerTask() {
+            public void run() {
+                checkCommit();
+            }
+        }, 0, 1000);
+    }
+
+    /**
+     * Checks the duration between the last modification to this index and the
+     * current time and commits the volatile index (if there are changes at all)
+     * if the duration (idle time) is more than {@link SearchIndex#getVolatileIdleTime()}
+     * seconds.
+     */
+    private synchronized void checkCommit() {
+        long idleTime = System.currentTimeMillis() - lastModificationTime;
+        // do not commit if volatileIdleTime is zero or negative
+        if (handler.getVolatileIdleTime() > 0
+                && idleTime > handler.getVolatileIdleTime() * 1000) {
+            try {
+                if (volatileIndex.getRedoLog().hasEntries()) {
+                    log.info("Committing in-memory index after being idle for " +
+                            idleTime + " ms.");
+                    commit();
+                }
+            } catch (IOException e) {
+                log.error("Unable to commit volatile index", e);
+            }
+        }
+    }
+
+    /**

Make locking part of XAResource's transaction support

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@354456 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.ItemId;
-import org.apache.jackrabbit.core.NodeId;
-import org.apache.jackrabbit.core.NodeImpl;
-import org.apache.jackrabbit.core.PathMap;
-import org.apache.jackrabbit.core.SessionImpl;
+import org.apache.jackrabbit.core.*;
-import javax.jcr.AccessDeniedException;
-import javax.jcr.ItemNotFoundException;
+import javax.jcr.ItemNotFoundException;
+import EDU.oswego.cs.dl.util.concurrent.ReentrantLock;
+
-public class LockManagerImpl implements LockManager, SynchronousEventListener {
+public class SharedLockManager implements LockManager, SynchronousEventListener {
-    private static final Logger log = Logger.getLogger(LockManagerImpl.class);
+    private static final Logger log = Logger.getLogger(SharedLockManager.class);
-     * Path map containing all locks at the leaves
+     * Path map containing all locks at the leaves.
+     * Lock to path map.
+     */
+    private final ReentrantLock lockMapLock = new ReentrantLock();
+
+    /**
+     * Flag indicating whether automatic saving is disabled.
+     */
+    private boolean savingDisabled;
+
+    /**
-    public LockManagerImpl(SessionImpl session, FileSystem fs)
+    public SharedLockManager(SessionImpl session, FileSystem fs)
-            LockInfo info = new LockInfo(this, lockToken, false,
+            LockInfo info = new LockInfo(lockToken, false,
+        if (savingDisabled) {
+            return;
+        }
+
-                LockInfo info = (LockInfo) list.get(i);
+                AbstractLockInfo info = (AbstractLockInfo) list.get(i);
-     * Internal <code>lock</code> implementation that takes as parameter
-     * a lock info that will be used inside the path map.<p>
-     * In order to prevent deadlocks from within the synchronous dispatching of
-     * events, content modifications should not be made from within code
-     * sections that hold monitors. (see #JCR-194)
-     *
+     * Internal <code>lock</code> implementation that takes the same parameters
+     * as the public method but will not modify content.
-     * @param info lock info
+     * @param isDeep whether the lock applies to this node only
+     * @param isSessionScoped whether the lock is session scoped
-    Lock lock(NodeImpl node, LockInfo info)
+    Lock internalLock(NodeImpl node, boolean isDeep, boolean isSessionScoped)
-        Lock lock;
+        SessionImpl session = (SessionImpl) node.getSession();
+        LockInfo info = new LockInfo(new LockToken(node.internalGetUUID()),
+                isSessionScoped, isDeep, session.getUserID());
-        synchronized (contentMonitor) {
-            synchronized (lockMap) {
-                // check whether node is already locked
-                Path path = getPath(node.getId());
-                PathMap.Element element = lockMap.map(path, false);
+        acquire();
-                LockInfo other = (LockInfo) element.get();
-                if (other != null) {
-                    if (element.hasPath(path)) {
-                        throw new LockException("Node already locked: " + node.safeGetJCRPath());
-                    } else if (other.deep) {
-                        throw new LockException("Parent node has deep lock.");
-                    }
+        try {
+            // check whether node is already locked
+            Path path = getPath(node.getId());
+            PathMap.Element element = lockMap.map(path, false);
+
+            LockInfo other = (LockInfo) element.get();
+            if (other != null) {
+                if (element.hasPath(path)) {
+                    throw new LockException("Node already locked: " + node.safeGetJCRPath());
+                } else if (other.deep) {
+                    throw new LockException("Parent node has deep lock.");
-                if (info.deep && element.hasPath(path) &&
-                        element.getChildrenCount() > 0) {
-                    throw new LockException("Some child node is locked.");
-                }
+            }
+            if (info.deep && element.hasPath(path) &&
+                    element.getChildrenCount() > 0) {
+                throw new LockException("Some child node is locked.");
+            }
-                // create lock token
-                SessionImpl session = (SessionImpl) node.getSession();
-                info.setLockHolder(session);
-                info.setLive(true);
-                session.addListener(info);
-                session.addLockToken(info.lockToken.toString(), false);
-                lockMap.put(path, info);
-                lock = new LockImpl(info, node);
+            // create lock token
+            info.setLockHolder(session);
+            info.setLive(true);
+            session.addListener(info);
+            session.addLockToken(info.lockToken.toString(), false);
+            lockMap.put(path, info);
-                // persist lockMap
+            if (!info.sessionScoped) {
+                save();
+            }
+            return new LockImpl(info, node);
+
+        } finally {
+            release();
+        }
+    }
+
+    /**
+     * Unlock a node (internal implementation)
+     * @param node node to unlock
+     * @throws LockException       if the node can not be unlocked
+     * @throws RepositoryException if another error occurs
+     */
+    void internalUnlock(NodeImpl node)
+            throws LockException, RepositoryException {
+
+        acquire();
+
+        try {
+            SessionImpl session = (SessionImpl) node.getSession();
+
+            // check whether node is locked by this session
+            PathMap.Element element = lockMap.map(
+                    getPath(node.getId()), true);
+            if (element == null) {
+                throw new LockException("Node not locked: " + node.safeGetJCRPath());
+            }
+            AbstractLockInfo info = (AbstractLockInfo) element.get();
+            if (info == null) {
+                throw new LockException("Node not locked: " + node.safeGetJCRPath());
+            }
+            if (!session.equals(info.getLockHolder())) {
+                throw new LockException("Node not locked by session: " + node.safeGetJCRPath());
+            }
+
+            element.set(null);
+            info.setLive(false);
+
+            if (!info.sessionScoped) {
-            // add properties to content
-            node.internalSetProperty(QName.JCR_LOCKOWNER,
-                    InternalValue.create(node.getSession().getUserID()));
-            node.internalSetProperty(QName.JCR_LOCKISDEEP,
-                    InternalValue.create(info.deep));
-            node.save();
-
-            return lock;
+        } finally {
+            release();
-
-                NodeImpl node = (NodeImpl) session.getItemManager().getItem(new NodeId(info.getUUID()));
+                NodeImpl node = (NodeImpl) session.getItemManager().getItem(
+                        new NodeId(info.getUUID()));
-                synchronized (lockMap) {
+                acquire();
+
+                try {
-
-                    // set live flag to false
+                    if (info.sessionScoped) {
+                        save();
+                    }
-                    // persist lockMap
-                    save();
+                } finally {
+                    release();
-
+    }
+    /**
+     * Return the most appropriate lock information for a node. This is either
+     * the lock info for the node itself, if it is locked, or a lock info for one
+     * of its parents, if that is deep locked.
+     * @return lock info or <code>null</code> if node is not locked
+     * @throws RepositoryException if an error occurs
+     */
+    public AbstractLockInfo getLockInfo(String uuid) throws RepositoryException {
+        acquire();
+
+        try {
+            Path path = getPath(new NodeId(uuid));
+
+            PathMap.Element element = lockMap.map(path, false);
+            AbstractLockInfo info = (AbstractLockInfo) element.get();
+            if (info != null) {
+                if (element.hasPath(path) || info.deep) {
+                    return info;
+                }
+            }
+            return null;
+        } catch (ItemNotFoundException e) {
+            return null;
+        } finally {
+            release();
+        }
-        // create lock info to use and pass to internal implementation
-        LockInfo info = new LockInfo(this, new LockToken(node.internalGetUUID()),
-                isSessionScoped, isDeep, node.getSession().getUserID());
-        return lock(node, info);
+        synchronized (contentMonitor) {
+            Lock lock = internalLock(node, isDeep, isSessionScoped);
+
+            // add properties to content
+            node.internalSetProperty(QName.JCR_LOCKOWNER,
+                    InternalValue.create(node.getSession().getUserID()));
+            node.internalSetProperty(QName.JCR_LOCKISDEEP,
+                    InternalValue.create(isDeep));
+            node.save();
+
+            return lock;
+        }
-        synchronized (lockMap) {
+        acquire();
+
+        try {
+            SessionImpl session = (SessionImpl) node.getSession();
-            LockInfo info = (LockInfo) element.get();
+            AbstractLockInfo info = (AbstractLockInfo) element.get();
-                SessionImpl session = (SessionImpl) node.getSession();
-                Node lockHolder = (Node) session.getItemManager().getItem(new NodeId(info.getUUID()));
+                Node lockHolder = (Node) session.getItemManager().getItem(
+                        new NodeId(info.getUUID()));
+        } catch (ItemNotFoundException e) {
+            throw new LockException("Node not locked: " + node.safeGetJCRPath());
+        } finally {
+            release();
-            synchronized (lockMap) {
-                // check whether node is locked by this session
-                PathMap.Element element = lockMap.map(getPath(node.getId()), true);
-                if (element == null) {
-                    throw new LockException("Node not locked: " + node.safeGetJCRPath());
-                }
-
-                LockInfo info = (LockInfo) element.get();
-                if (info == null) {
-                    throw new LockException("Node not locked: " + node.safeGetJCRPath());
-                }
-                if (!node.getSession().equals(info.getLockHolder())) {
-                    throw new LockException("Node not locked by session: " + node.safeGetJCRPath());
-                }
-
-                // remove lock in path map
-                element.set(null);
-                info.setLive(false);
-            }
+            internalUnlock(node);
-        synchronized (lockMap) {
+        acquire();
+
+        try {
+        } catch (ItemNotFoundException e) {
+            return false;
+        } finally {
+            release();
-        synchronized (lockMap) {
+        acquire();
+
+        try {
-            LockInfo info = (LockInfo) element.get();
+            AbstractLockInfo info = (AbstractLockInfo) element.get();
+        } catch (ItemNotFoundException e) {
+            return false;
+        } finally {
+            release();
-        checkLock(getPath(node.getId()), node.getSession());
+        SessionImpl session = (SessionImpl) node.getSession();
+        checkLock(getPath(node.getId()), session);
-        LockInfo info = (LockInfo) element.get();
+        AbstractLockInfo info = (AbstractLockInfo) element.get();
-                LockInfo info = (LockInfo) element.get();
+                AbstractLockInfo info = (AbstractLockInfo) element.get();
-                LockInfo info = (LockInfo) element.get();
+                AbstractLockInfo info = (AbstractLockInfo) element.get();
-     * item inside the system session and will therefore not find transiently
-     * created but not yet saved items
+     * item inside the systme session.
-    private Path getPath(ItemId id)
-            throws ItemNotFoundException, AccessDeniedException,
-            RepositoryException {
-
+    private Path getPath(ItemId id) throws RepositoryException {
-    
+
+    /**
+     * Acquire lock on the lock map.
+     */
+    private void acquire() {
+        for (;;) {
+            try {
+                lockMapLock.acquire();
+                break;
+            } catch (InterruptedException e) {}
+        }
+    }
+
+    /**
+     * Release lock on the lock map.
+     */
+    private void release() {
+        lockMapLock.release();
+    }
+
+    /**
+     * Start an update operation. This will acquire the lock on the lock map
+     * and disable saving the lock map file.
+     */
+    public void beginUpdate() {
+        acquire();
+        savingDisabled = true;
+    }
+
+    /**
+     * End an update operation. This will save the lock map file and release
+     * the lock on the lock map.
+     */
+    public void endUpdate() {
+        savingDisabled = false;
+        save();
+        release();
+    }
+
+    /**
+     * Cancel an update operation. This will release the lock on the lock map.
+     */
+    public void cancelUpdate() {
+        savingDisabled = false;
+        release();
+    }
+
+     * Refresh a non-empty path element whose children might have changed
+     * its position.
+     */
+    private void refresh(PathMap.Element element) {
+        final ArrayList infos = new ArrayList();
+        boolean needsSave = false;
+
+        // save away non-empty children
+        element.traverse(new PathMap.ElementVisitor() {
+            public void elementVisited(PathMap.Element element) {
+                LockInfo info = (LockInfo) element.get();
+                infos.add(info);
+            }
+        }, false);
+
+        // remove all children
+        element.removeAll();
+
+        // now re-insert at appropriate location or throw away if node
+        // does no longer exist
+        for (int i = 0; i < infos.size(); i++) {
+            LockInfo info = (LockInfo) infos.get(i);
+            try {
+                NodeImpl node = (NodeImpl) session.getItemManager().getItem(
+                        new NodeId(info.getUUID()));
+                lockMap.put(node.getPrimaryPath(), info);
+            } catch (RepositoryException e) {
+                info.setLive(false);
+                if (!info.sessionScoped) {
+                    needsSave = true;
+                }
+            }
+        }
+
+        // save if required
+        if (needsSave) {
+            save();
+        }
+    }
+
+    /**
+        acquire();
+
-            synchronized (lockMap) {
-                PathMap.Element parent = lockMap.map(path.getAncestor(1), true);
-                if (parent != null) {
-                    parent.insert(path.getNameElement());
-                }
+            PathMap.Element parent = lockMap.map(path.getAncestor(1), true);
+            if (parent != null) {
+                refresh(parent);
+        } finally {
+            release();
+     * @param newPath new path
-        synchronized (lockMap) {
-            PathMap.Element element = lockMap.map(oldPath, true);
-            if (element != null) {
-                element.remove();
-            }
+        acquire();
-            try {
-                PathMap.Element parent = lockMap.map(newPath.getAncestor(1), true);
-                if (parent != null) {
-                    parent.insert(newPath.getNameElement());
-                }
-                if (element != null) {
-                    lockMap.put(newPath, element);
-                }
-            } catch (PathNotFoundException e) {
-                log.warn("Unable to determine path of moved node's parent.", e);
-                return;
+        try {
+            PathMap.Element parent = lockMap.map(oldPath.getAncestor(1), true);
+            if (parent != null) {
+                refresh(parent);
+        } catch (PathNotFoundException e) {
+            log.warn("Unable to determine path of moved node's parent.", e);
+            return;
+        } finally {
+            release();
-        synchronized (lockMap) {
-            try {
-                PathMap.Element parent = lockMap.map(path.getAncestor(1), true);
-                if (parent != null) {
-                    PathMap.Element element = parent.remove(path.getNameElement());
-                    if (element != null) {
-                        element.traverse(new PathMap.ElementVisitor() {
-                            public void elementVisited(PathMap.Element element) {
-                                LockInfo info = (LockInfo) element.get();
-                                info.setLive(false);
-                            }
-                        }, false);
+        acquire();
+
+        try {
+            PathMap.Element parent = lockMap.map(path.getAncestor(1), true);
+            if (parent != null) {
+                refresh(parent);
+            }
+        } catch (PathNotFoundException e) {
+            log.warn("Unable to determine path of removed node's parent.", e);
+            return;
+        } finally {
+            release();
+        }
+    }
+
+    /**
+     * Contains information about a lock and gets placed inside the child
+     * information of a {@link org.apache.jackrabbit.core.PathMap}.
+     */
+    class LockInfo extends AbstractLockInfo implements SessionListener {
+
+        /**
+         * Create a new instance of this class.
+         *
+         * @param lockToken     lock token
+         * @param sessionScoped whether lock token is session scoped
+         * @param deep          whether lock is deep
+         * @param lockOwner     owner of lock
+         */
+        public LockInfo(LockToken lockToken, boolean sessionScoped,
+                        boolean deep, String lockOwner) {
+            super(lockToken, sessionScoped, deep, lockOwner);
+        }
+
+        /**
+         * {@inheritDoc}
+         * <p/>
+         * When the owning session is logging out, we have to perform some
+         * operations depending on the lock type.
+         * (1) If the lock was session-scoped, we unlock the node.
+         * (2) If the lock was open-scoped, we remove the lock token
+         *     from the session and set the lockHolder field to <code>null</code>.
+         */
+        public void loggingOut(SessionImpl session) {
+            if (live) {
+                if (sessionScoped) {
+                    unlock(this);
+                } else {
+                    if (session.equals(lockHolder)) {
+                        session.removeLockToken(lockToken.toString());
+                        lockHolder = null;
-            } catch (PathNotFoundException e) {
-                log.warn("Unable to determine path of moved node's parent.", e);
-                return;
+
+        /**
+         * {@inheritDoc}
+         */
+        public void loggedOut(SessionImpl session) {
+        }

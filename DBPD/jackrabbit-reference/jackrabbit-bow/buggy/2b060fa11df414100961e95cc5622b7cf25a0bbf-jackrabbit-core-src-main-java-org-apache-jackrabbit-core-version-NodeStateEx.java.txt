JCR-2209 Versioning operations should be done on the workspace


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@795866 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.List;
+import java.util.Set;
+
+import javax.jcr.ItemExistsException;
+import javax.jcr.PropertyType;
+import javax.jcr.RepositoryException;
+import javax.jcr.UnsupportedRepositoryOperationException;
+import javax.jcr.nodetype.ConstraintViolationException;
+import javax.jcr.nodetype.NoSuchNodeTypeException;
+
+import org.apache.jackrabbit.core.PropertyImpl;
-import org.apache.jackrabbit.core.PropertyImpl;
+import org.apache.jackrabbit.core.state.ChildNodeEntry;
-import org.apache.jackrabbit.core.state.ChildNodeEntry;
-import java.util.List;
-import java.util.Set;
-
-import javax.jcr.RepositoryException;
-import javax.jcr.PropertyType;
-import javax.jcr.nodetype.ConstraintViolationException;
-import javax.jcr.nodetype.NoSuchNodeTypeException;
-
-     * @param stateMgr
-     * @param nodeState
+     * @param stateMgr state manager
+     * @param ntReg node type registry
+     * @param nodeState underlying node state
+     * @param name name (can be null)
+    /**
+     * Creates a new persistent node
+     *
+     * @param stateMgr state manager
+     * @param ntReg node type registry
+     * @param nodeId node id
+     * @throws RepositoryException if the node state can't be loaded
+     */
+    public NodeStateEx(UpdatableItemStateManager stateMgr,
+                       NodeTypeRegistry ntReg,
+                       NodeId nodeId) throws RepositoryException {
+        try {
+            this.ntReg = ntReg;
+            this.stateMgr = stateMgr;
+            this.nodeState = (NodeState) stateMgr.getItemState(nodeId);
+        } catch (ItemStateException e) {
+            throw new RepositoryException(e);
+        }
+    }
+
-                // should never occurr
+                // should never occur
+     * Returns the parent node of this node
+     *
+     * @return the parent node of this node or <code>null</code> if root node
+     * @throws RepositoryException if an error occurs
+     */
+    public NodeStateEx getParent() throws RepositoryException {
+        if (nodeState.getParentId() == null) {
+            return null;
+        }
+        return getNode(nodeState.getParentId());
+    }
+
+    /**
+     * @throws ItemStateException if an error occurs
-     * @param name
+     * @param name name of the property
-     * @param name
+     * @param name name of the property
-     * @param name
+     * @param name name of the property
-     * @param name
-     * @param value
-     * @throws RepositoryException
+     * @param name name of the property
+     * @param value value to set
+     * @throws RepositoryException if an error occurs
-     * @param name
-     * @param type
-     * @param values
-     * @throws RepositoryException
+     * @param name name of the property
+     * @param type property type
+     * @param values values to set
+     * @throws RepositoryException if an error occurs
-     * @param name
-     * @param type
-     * @param values
-     * @throws RepositoryException
+     * @param name name of the property
+     * @param type type of the values
+     * @param values values to set
+     * @param multiple <code>true</code>for MV properties
+     * @return the modified property state
+     * @throws RepositoryException if an error occurs
-    public void setPropertyValues(Name name, int type, InternalValue[] values, boolean multiple)
+    public PropertyState setPropertyValues(Name name, int type, InternalValue[] values, boolean multiple)
-
-        PropertyState prop = getOrCreatePropertyState(name, type, multiple);
-        prop.setValues(values);
-    }
-
-
-    /**
-     * Retrieves or creates a new property state as child property of this node
-     *
-     * @param name
-     * @param type
-     * @param multiValued
-     * @return the property state
-     * @throws RepositoryException
-     */
-    private PropertyState getOrCreatePropertyState(Name name, int type, boolean multiValued)
-            throws RepositoryException {
-
-                // someone calling this method will always alter the property state, so set status to modified
-                // although this is not quite correct, we mark node as modified aswell
+                // although this is not quite correct, we mark node as modified as well
+                propState.setType(type);
+                propState.setValues(values);
+
+            PropDef pd = getEffectiveNodeType().getApplicablePropertyDef(name, type, multiple);
+
-            propState.setMultiValued(multiValued);
-
-            PropDef pd = getEffectiveNodeType().getApplicablePropertyDef(name, type, multiValued);
+            propState.setMultiValued(multiple);
+            propState.setValues(values);
-            // need to store nodestate
+            // need to store node state
-     * @throws RepositoryException
+     * @throws RepositoryException if an error occurs
-     * @param name
+     * @param name name of the node
-     * @param name
+     * @param name name of hte node
-     * @throws RepositoryException
+     * @throws RepositoryException if an error occurs
+     * removes the given child node
+     *
+     * @param node child node to remove
+     * @return <code>true</code> if the child was removed
+     * @throws RepositoryException if an error occurs
+     */
+    public boolean removeNode(NodeStateEx node) throws RepositoryException {
+        // locate child node entry
+        return removeNode(nodeState.getChildNodeEntry(node.getNodeId()));
+    }
+
+
+    /**
-     * @param name
-     * @param index
+     * @param name name of the child node
+     * @param index index of the child node
-     * @throws RepositoryException
+     * @throws RepositoryException if an error occurs
+        return removeNode(nodeState.getChildNodeEntry(name, index));
+    }
+
+    /**
+     * removes the child node with the given child node entry
+     *
+     * @param entry entry to remove
+     * @return <code>true</code> if the child was removed.
+     * @throws RepositoryException if an error occurs
+     */
+    public boolean removeNode(ChildNodeEntry entry) throws RepositoryException {
-            ChildNodeEntry entry = nodeState.getChildNodeEntry(name, index);
-                nodeState.removeChildNodeEntry(name, index);
+                nodeState.removeChildNodeEntry(entry.getId());
-     * @param id
-     * @throws ItemStateException
+     * @param id node id
+     * @throws ItemStateException if an error occurs
-     * @param name
+     * @param name name of the property
-     * @throws RepositoryException
+     * @throws RepositoryException if an error occurs
-     * @param name
-     * @param index
+     * @param name name of hte child node
+     * @param index index of thechild node
-     * @throws RepositoryException
+     * @throws RepositoryException if an error occurs
+     * Returns the node with the given id.
+     * @param id node id
+     * @return the new node state
+     * @throws RepositoryException if an error occurs
+     */
+    public NodeStateEx getNode(NodeId id) throws RepositoryException {
+        try {
+            NodeState state = (NodeState) stateMgr.getItemState(id);
+            return new NodeStateEx(stateMgr, ntReg, state, name);
+        } catch (ItemStateException e) {
+            throw new RepositoryException("Unable to getNode: " + e.toString());
+        }
+    }
+
+    /**
+     * Checks if the given node state exists
+     * @param id node id
+     * @return <code>true</code> if the node state exists
+     */
+    public boolean hasNode(NodeId id) {
+        return stateMgr.hasItemState(id);
+    }
+
+    /**
-     * @param nodeName
-     * @param nodeTypeName
+     * @param nodeName name of the new node
+     * @param nodeTypeName node type name
+     * @param id id of the new node
-     * @throws NoSuchNodeTypeException
-     * @throws ConstraintViolationException
-     * @throws RepositoryException
+     * @throws NoSuchNodeTypeException if the node type does not exist
+     * @throws ConstraintViolationException if there is a constraint violation
+     * @throws RepositoryException if an error occurs
+     */
+    public NodeStateEx addNode(Name nodeName, Name nodeTypeName, NodeId id)
+            throws NoSuchNodeTypeException, ConstraintViolationException, RepositoryException {
+        return addNode(nodeName, nodeTypeName, id,
+                ntReg.getEffectiveNodeType(nodeTypeName).includesNodeType(NameConstants.MIX_REFERENCEABLE));
+    }
+
+    /**
+     * Adds a new child node with the given name
+     *
+     * @param nodeName name of the new node
+     * @param nodeTypeName node type name
+     * @param id id of the new node
+     * @param referenceable if <code>true</code>, a UUID property is created
+     * @return the node state
+     * @throws NoSuchNodeTypeException if the node type does not exist
+     * @throws ConstraintViolationException if there is a constraint violation
+     * @throws RepositoryException if an error occurs
-     * @param name
-     * @param id
+     * @param name name
+     * @param nodeTypeName node type name
+     * @param id id
+     * @throws RepositoryException if an error occurs
+     * Moves the source node to this node using the given name.
+     * @param src shareable source node
+     * @param name name of new node
+     * @param createShare if <code>true</code> a share is created instead.
+     * @return child node
+     * @throws RepositoryException if an error occurs
+     */
+    public NodeStateEx moveFrom(NodeStateEx src, Name name, boolean createShare)
+            throws RepositoryException {
+        if (name == null) {
+            name = src.getName();
+        }
+        // (4) check for name collisions
+        NodeDef def;
+        try {
+            def = getEffectiveNodeType().getApplicableChildNodeDef(name, nodeState.getNodeTypeName(), ntReg);
+        } catch (RepositoryException re) {
+            String msg = "no definition found in parent node's node type for new node";
+            throw new ConstraintViolationException(msg, re);
+        }
+        ChildNodeEntry cne = nodeState.getChildNodeEntry(name, 1);
+        if (cne != null) {
+            // there's already a child node entry with that name;
+            // check same-name sibling setting of new node
+            if (!def.allowsSameNameSiblings()) {
+                throw new ItemExistsException(getNodeId() + "/" + name);
+            }
+            NodeState existingChild;
+            try {
+                // check same-name sibling setting of existing node
+                existingChild = (NodeState) stateMgr.getItemState(cne.getId());
+            } catch (ItemStateException e) {
+                throw new RepositoryException(e);
+            }
+            if (!ntReg.getNodeDef(existingChild.getDefinitionId()).allowsSameNameSiblings()) {
+                throw new ItemExistsException(existingChild.toString());
+            }
+        } else {
+            // check if 'add' is allowed
+            if (getDefinition().isProtected()) {
+                String msg = "not allowed to modify a protected node";
+                throw new ConstraintViolationException(msg);
+            }
+        }
+
+        if (createShare) {
+            // (5) do clone operation
+            NodeId parentId = getNodeId();
+            src.addShareParent(parentId);
+            // attach to this parent
+            nodeState.addChildNodeEntry(name, src.getNodeId());
+            if (nodeState.getStatus() == ItemState.STATUS_EXISTING) {
+                nodeState.setStatus(ItemState.STATUS_EXISTING_MODIFIED);
+            }
+            return new NodeStateEx(stateMgr, ntReg, src.getState(), name);
+        } else {
+            // detach from parent
+            NodeStateEx parent = getNode(src.getParentId());
+            parent.nodeState.removeChildNodeEntry(src.getNodeId());
+            if (parent.nodeState.getStatus() == ItemState.STATUS_EXISTING) {
+                parent.nodeState.setStatus(ItemState.STATUS_EXISTING_MODIFIED);
+            }
+            // attach to this parent
+            nodeState.addChildNodeEntry(name, src.getNodeId());
+            if (nodeState.getStatus() == ItemState.STATUS_EXISTING) {
+                nodeState.setStatus(ItemState.STATUS_EXISTING_MODIFIED);
+            }
+            NodeState srcState = src.getState();
+            srcState.setParentId(getNodeId());
+            srcState.setDefinitionId(def.getId());
+            
+            if (srcState.getStatus() == ItemState.STATUS_EXISTING) {
+                srcState.setStatus(ItemState.STATUS_EXISTING_MODIFIED);
+            }
+            return new NodeStateEx(stateMgr, ntReg, srcState, name);
+        }
+    }
+
+    /**
+     * Adds a share parent id
+     * @param parentId the parent id
+     * @throws RepositoryException if an error occurs
+     */
+    private void addShareParent(NodeId parentId) throws RepositoryException {
+        // verify that we're shareable
+        if (!nodeState.isShareable()) {
+            String msg = this + " is not shareable.";
+            throw new RepositoryException(msg);
+        }
+
+        // detect share cycle (TODO)
+        // NodeId srcId = getNodeId();
+        //HierarchyManager hierMgr = session.getHierarchyManager();
+        //if (parentId.equals(srcId) || hierMgr.isAncestor(srcId, parentId)) {
+        //    String msg = "This would create a share cycle.";
+        //    log.debug(msg);
+        //    throw new RepositoryException(msg);
+        //}
+
+        if (!nodeState.containsShare(parentId)) {
+            if (nodeState.addShare(parentId)) {
+                return;
+            }
+        }
+        String msg = "Adding a shareable node twice to the same parent is not supported.";
+        throw new UnsupportedRepositoryOperationException(msg);
+    }
+
+    /**
-     * @throws RepositoryException
+     * @throws RepositoryException if an error occurs
-     * @throws RepositoryException
+     * @throws RepositoryException if an error occurs
-     * @param state
-     * @throws ItemStateException
+     * @param state node state to store
+     * @throws ItemStateException if an error occurs
-     * @throws RepositoryException
+     * @throws RepositoryException if an error occurs
-            // refetch nodestate if discarded
+            // refetch node state if discarded
-     * @param state
-     * @throws ItemStateException
+     * @param state node state
+     * @throws ItemStateException if an error occurs
-     * @param prop
-     * @throws RepositoryException
+     * @param prop source property
+     * @throws RepositoryException if an error occurs
+    /**
+     * copies a property
+     *
+     * @param prop source property
+     * @throws RepositoryException if an error occurs
+     */
+    public void copyFrom(PropertyState prop) throws RepositoryException {
+        InternalValue[] values = prop.getValues();
+        InternalValue[] copiedValues = new InternalValue[values.length];
+        for (int i = 0; i < values.length; i++) {
+            copiedValues[i] = values[i].createCopy();
+        }
+        setPropertyValues(prop.getName(), prop.getType(), copiedValues, prop.isMultiValued());
+    }
+
+    /**
+     * Returns the NodeDef for this state
+     * @return the node def
+     */
+    public NodeDef getDefinition() {
+        return ntReg.getNodeDef(nodeState.getDefinitionId());
+    }
+
+    /**
+     * Returns the property definition for the property state
+     * @param prop the property state
+     * @return the prop def
+     */
+    public PropDef getDefinition(PropertyState prop) {
+        return ntReg.getPropDef(prop.getDefinitionId());
+    }
+

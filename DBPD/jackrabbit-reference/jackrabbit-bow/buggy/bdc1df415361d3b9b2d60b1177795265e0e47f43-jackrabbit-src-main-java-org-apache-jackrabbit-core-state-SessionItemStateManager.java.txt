JCR-552 Move listeners from item state to item state managers


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@438851 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.PropertyId;
+import java.util.Collection;
- * <code>SessionItemStateManager</code> ...
+ * Item state manager that handles both transient and persistent items.
-        implements UpdatableItemStateManager, Dumpable {
+        implements UpdatableItemStateManager, Dumpable, NodeStateListener {
-    private final UpdatableItemStateManager persistentStateMgr;
-
-    /**
-     * State manager for the transient items
-     */
-    private final TransientItemStateManager transientStateMgr;
+    private final UpdatableItemStateManager stateMgr;
+     * map of those states that have been removed transiently
+     */
+    private final ItemStateStore atticStore;
+
+    /**
+     * map of new or modified transient states
+     */
+    private final ItemStateStore transientStore;
+
+    /**
+     * ItemStateManager view of the states in the attic; lazily instantiated
+     * in {@link #getAttic()}
+     */
+    private AtticItemStateManager attic;
+
+    /**
+     * State change dispatcher.
+     */
+    private final transient StateChangeDispatcher dispatcher = new StateChangeDispatcher();
+
+    /**
-     * @param persistentStateMgr
+     * @param stateMgr
-                                   UpdatableItemStateManager persistentStateMgr,
+                                   LocalItemStateManager stateMgr,
-        this.persistentStateMgr = persistentStateMgr;
-        // create transient item state manager
-        transientStateMgr = new TransientItemStateManager();
+        this.stateMgr = stateMgr;
+        stateMgr.addListener(this);
+
+        addListener(hierMgr);
+
+        transientStore = new ItemStateMap();
+        atticStore = new ItemStateMap();
-        transientStateMgr.dump(ps);
+        ps.print("[transient] ");
+        if (transientStore instanceof Dumpable) {
+            ((Dumpable) transientStore).dump(ps);
+        } else {
+            ps.println(transientStore.toString());
+        }
+        ps.println();
+        ps.print("[attic]     ");
+        if (atticStore instanceof Dumpable) {
+            ((Dumpable) atticStore).dump(ps);
+        } else {
+            ps.println(atticStore.toString());
+        }
-        if (transientStateMgr.getAttic().hasItemState(id)) {
+        if (atticStore.contains(id)) {
-            return transientStateMgr.getItemState(id);
+            return getTransientItemState(id);
-        if (transientStateMgr.hasItemState(id)) {
-            return transientStateMgr.getItemState(id);
+        if (transientStore.contains(id)) {
+            return getTransientItemState(id);
-        if (persistentStateMgr.hasItemState(id)) {
-            return persistentStateMgr.getItemState(id);
+        if (stateMgr.hasItemState(id)) {
+            return stateMgr.getItemState(id);
-        if (transientStateMgr.getAttic().hasItemState(id)) {
+        if (atticStore.contains(id)) {
-            return transientStateMgr.hasItemState(id);
+            return transientStore.contains(id);
-        if (transientStateMgr.hasItemState(id)) {
+        if (transientStore.contains(id)) {
-        return persistentStateMgr.hasItemState(id);
+        return stateMgr.hasItemState(id);
-        return persistentStateMgr.getNodeReferences(id);
+        return stateMgr.getNodeReferences(id);
-        return persistentStateMgr.hasNodeReferences(id);
+        return stateMgr.hasNodeReferences(id);
-        persistentStateMgr.edit();
+        stateMgr.edit();
-        return persistentStateMgr.inEditMode();
+        return stateMgr.inEditMode();
-        return persistentStateMgr.createNew(id, nodeTypeName, parentId);
+        return stateMgr.createNew(id, nodeTypeName, parentId);
-        return persistentStateMgr.createNew(propName, parentId);
+        return stateMgr.createNew(propName, parentId);
-        persistentStateMgr.store(state);
+        stateMgr.store(state);
-        persistentStateMgr.destroy(state);
+        stateMgr.destroy(state);
-        persistentStateMgr.cancel();
+        stateMgr.cancel();
-        persistentStateMgr.update();
+        stateMgr.update();
-        transientStateMgr.disposeAllItemStates();
+        disposeAllTransientItemStates();
-        persistentStateMgr.dispose();
+        stateMgr.dispose();
-        return transientStateMgr.getItemState(id);
+
+        ItemState state = transientStore.get(id);
+        if (state != null) {
+            return state;
+        } else {
+            throw new NoSuchItemStateException(id.toString());
+        }
-        return transientStateMgr.hasAnyItemStates();
+        return !transientStore.isEmpty();
-        if (!transientStateMgr.hasAnyItemStates()) {
+        if (transientStore.isEmpty()) {
-            Iterator iter = transientStateMgr.getEntries();
+            Iterator iter = transientStore.values().iterator();
-        if (!transientStateMgr.hasAnyItemStatesInAttic()) {
+        if (atticStore.isEmpty()) {
-                        transientStateMgr.getAttic(),
+                        getAttic(),
-            Iterator iter = transientStateMgr.getEntriesInAttic();
+            Iterator iter = atticStore.values().iterator();
-        return transientStateMgr.getAttic().hasItemState(id);
+        return atticStore.contains(id);
-        return transientStateMgr.createNodeState(id, nodeTypeName, parentId, initialStatus);
+
+        // check map; synchronized to ensure an entry is not created twice.
+        synchronized (transientStore) {
+            if (transientStore.contains(id)) {
+                String msg = "there's already a node state instance with id " + id;
+                log.debug(msg);
+                throw new ItemStateException(msg);
+            }
+
+            NodeState state = new NodeState(id, nodeTypeName, parentId,
+                    initialStatus, true);
+            // put transient state in the map
+            transientStore.put(state);
+            state.setContainer(this);
+            return state;
+        }
-        NodeState state = transientStateMgr.createNodeState(overlayedState, initialStatus);
-        hierMgr.stateOverlaid(state);
-        return state;
+        ItemId id = overlayedState.getNodeId();
+
+        // check map; synchronized to ensure an entry is not created twice.
+        synchronized (transientStore) {
+            if (transientStore.contains(id)) {
+                String msg = "there's already a node state instance with id " + id;
+                log.debug(msg);
+                throw new ItemStateException(msg);
+            }
+
+            NodeState state = new NodeState(overlayedState, initialStatus, true);
+            // put transient state in the map
+            transientStore.put(state);
+            state.setContainer(this);
+            return state;
+        }
-        return transientStateMgr.createPropertyState(parentId, propName, initialStatus);
+
+        PropertyId id = new PropertyId(parentId, propName);
+
+        // check map; synchronized to ensure an entry is not created twice.
+        synchronized (transientStore) {
+            if (transientStore.contains(id)) {
+                String msg = "there's already a property state instance with id " + id;
+                log.debug(msg);
+                throw new ItemStateException(msg);
+            }
+
+            PropertyState state = new PropertyState(id, initialStatus, true);
+            // put transient state in the map
+            transientStore.put(state);
+            state.setContainer(this);
+            return state;
+        }
-        PropertyState state = transientStateMgr.createPropertyState(overlayedState, initialStatus);
-        hierMgr.stateOverlaid(state);
-        return state;
+        PropertyId id = overlayedState.getPropertyId();
+
+        // check map; synchronized to ensure an entry is not created twice.
+        synchronized (transientStore) {
+            if (transientStore.contains(id)) {
+                String msg = "there's already a property state instance with id " + id;
+                log.debug(msg);
+                throw new ItemStateException(msg);
+            }
+
+            PropertyState state = new PropertyState(overlayedState, initialStatus, true);
+            // put transient state in the map
+            transientStore.put(state);
+            state.setContainer(this);
+            return state;
+        }
-        hierMgr.stateUncovered(state);
-        transientStateMgr.disposeItemState(state);
+        // discard item state, this will invalidate the wrapping Item
+        // instance of the transient state
+        state.discard();
+        // remove from map
+        transientStore.remove(state.getId());
+        // give the instance a chance to prepare to get gc'ed
+        state.onDisposed();
-        transientStateMgr.moveItemStateToAttic(state);
+        // remove from map
+        transientStore.remove(state.getId());
+        // add to attic
+        atticStore.put(state);
-        transientStateMgr.disposeItemStateInAttic(state);
+        // discard item state, this will invalidate the wrapping Item
+        // instance of the transient state
+        state.discard();
+        // remove from attic
+        atticStore.remove(state.getId());
+        // give the instance a chance to prepare to get gc'ed
+        state.onDisposed();
-        transientStateMgr.disposeAllItemStates();
+        // dispose item states in transient map & attic
+        // (use temp collection to avoid ConcurrentModificationException)
+        Collection tmp = new ArrayList(transientStore.values());
+        Iterator iter = tmp.iterator();
+        while (iter.hasNext()) {
+            ItemState state = (ItemState) iter.next();
+            disposeTransientItemState(state);
+        }
+        tmp = new ArrayList(atticStore.values());
+        iter = tmp.iterator();
+        while (iter.hasNext()) {
+            ItemState state = (ItemState) iter.next();
+            disposeTransientItemStateInAttic(state);
+        }
+    }
+
+    /**
+     * Add an <code>ItemStateListener</code>
+     * @param listener the new listener to be informed on modifications
+     */
+    public void addListener(ItemStateListener listener) {
+        dispatcher.addListener(listener);
+    }
+
+    /**
+     * Remove an <code>ItemStateListener</code>
+     * @param listener an existing listener
+     */
+    public void removeListener(ItemStateListener listener) {
+        dispatcher.removeListener(listener);
+    }
+
+    /**
+     * Return the attic item state provider that holds all items
+     * moved into the attic.
+     *
+     * @return attic
+     */
+    ItemStateManager getAttic() {
+        if (attic == null) {
+            attic = new AtticItemStateManager();
+        }
+        return attic;
+    }
+
+    //----------------------------------------------------< ItemStateListener >
+
+    /**
+     * {@inheritDoc}
+     * <p/>
+     * Notification handler gets called for both transient states that this state manager
+     * has created, as well as states that were created by the local state manager
+     * we're listening to.
+     */
+    public void stateCreated(ItemState created) {
+        ItemState visibleState = created;
+        if (created.getContainer() != this) {
+            // local state was created
+            ItemState transientState = transientStore.get(created.getId());
+            if (transientState != null) {
+                // underlying state has been permanently created
+                transientState.pull();
+                transientState.setStatus(ItemState.STATUS_EXISTING);
+                visibleState = transientState;
+            }
+        }
+        dispatcher.notifyStateCreated(visibleState);
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p/>
+     * Notification handler gets called for both transient states that this state manager
+     * has created, as well as states that were created by the local state manager
+     * we're listening to.
+     */
+    public void stateModified(ItemState modified) {
+        ItemState visibleState = modified;
+        if (modified.getContainer() != this) {
+            // local state was modified
+            ItemState transientState = transientStore.get(modified.getId());
+            if (transientState != null) {
+                transientState.setStatus(ItemState.STATUS_STALE_MODIFIED);
+                visibleState = transientState;
+            }
+        }
+        dispatcher.notifyStateModified(visibleState);
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p/>
+     * Notification handler gets called for both transient states that this state manager
+     * has created, as well as states that were created by the local state manager
+     * we're listening to.
+     */
+    public void stateDestroyed(ItemState destroyed) {
+        ItemState visibleState = destroyed;
+        if (destroyed.getContainer() != this) {
+            // local state was destroyed
+            ItemState transientState = transientStore.get(destroyed.getId());
+            if (transientState != null) {
+                transientState.setStatus(ItemState.STATUS_STALE_DESTROYED);
+                visibleState = transientState;
+            }
+        }
+        dispatcher.notifyStateDestroyed(visibleState);
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p/>
+     * Notification handler gets called for both transient states that this state manager
+     * has created, as well as states that were created by the local state manager
+     * we're listening to.
+     */
+    public void stateDiscarded(ItemState discarded) {
+        ItemState visibleState = discarded;
+        if (discarded.getContainer() != this) {
+            // local state was discarded
+            ItemState transientState = transientStore.get(discarded.getId());
+            if (transientState != null) {
+                transientState.setStatus(ItemState.STATUS_UNDEFINED);
+                visibleState = transientState;
+            }
+        }
+        dispatcher.notifyStateDiscarded(visibleState);
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p/>
+     * Pass notification to listeners if a transient state was modified
+     * or if the local state is not overlayed.
+     */
+    public void nodeAdded(NodeState state, QName name, int index, NodeId id) {
+        if (state.getContainer() == this || !transientStore.contains(state.getId())) {
+            dispatcher.notifyNodeAdded(state, name, index, id);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p/>
+     * Pass notification to listeners if a transient state was modified
+     * or if the local state is not overlayed.
+     */
+    public void nodesReplaced(NodeState state) {
+        if (state.getContainer() == this || !transientStore.contains(state.getId())) {
+            dispatcher.notifyNodesReplaced(state);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p/>
+     * Pass notification to listeners if a transient state was modified
+     * or if the local state is not overlayed.
+     */
+    public void nodeRemoved(NodeState state, QName name, int index, NodeId id) {
+        if (state.getContainer() == this || !transientStore.contains(state.getId())) {
+            dispatcher.notifyNodeRemoved(state, name, index, id);
+        }
+    }
+
+    //--------------------------------------------------------< inner classes >
+
+    /**
+     * ItemStateManager view of the states in the attic
+     *
+     * @see SessionItemStateManager#getAttic
+     */
+    private class AtticItemStateManager implements ItemStateManager {
+
+        /**
+         * {@inheritDoc}
+         */
+        public ItemState getItemState(ItemId id)
+                throws NoSuchItemStateException, ItemStateException {
+
+            ItemState state = atticStore.get(id);
+            if (state != null) {
+                return state;
+            } else {
+                throw new NoSuchItemStateException(id.toString());
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public boolean hasItemState(ItemId id) {
+            return atticStore.contains(id);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public NodeReferences getNodeReferences(NodeReferencesId id)
+                throws NoSuchItemStateException, ItemStateException {
+            // n/a
+            throw new ItemStateException("getNodeReferences() not implemented");
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public boolean hasNodeReferences(NodeReferencesId id) {
+            // n/a
+            return false;
+        }

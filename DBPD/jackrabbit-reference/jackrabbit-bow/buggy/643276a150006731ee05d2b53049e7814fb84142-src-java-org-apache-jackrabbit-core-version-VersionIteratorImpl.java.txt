- JCR-17 Creating and saving a mix:versionable node creates two VersionHistory nodes
- JCR-18 Multithreading issue with versioning


git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@76106 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.HashSet;
-import java.util.NoSuchElementException;
-import java.util.Set;
-import java.util.Stack;
+import java.util.*;
- * graph following the successor nodes.
+ * graph following the successor nodes. When this iterator is created, it gathers
+ * the id's of the versions and returns them when iterating. please note, that
+ * a version can be deleted while traversing this iterator and the 'nextVesion'
+ * would produce a  ConcurrentModificationException.
+     * the id's of the versions to return
+     */
+    private LinkedList versions = new LinkedList();
+
+    /**
-     * the traversal stack
-     */
-    private Stack successors = new Stack();
-
-    /**
-     * the set of versions already returned. due to the topology of the version
-     * graph it is possible to reach a version via different paths.
-     */
-    private Set visited = new HashSet();
-
-    /**
-        successors.push(rootVersion);
+
+        addVersion(rootVersion);
-        if (successors.isEmpty()) {
+        if (versions.isEmpty()) {
-        InternalVersion ret = (InternalVersion) successors.pop();
-        visited.add(ret);
+        String id = (String) versions.removeFirst();
-        push(ret.getSuccessors());
-            return (Version) session.getNodeByUUID(ret.getId());
+            return (Version) session.getNodeByUUID(id);
-            throw new NoSuchElementException("Unable to provide element: " + e.toString());
+            throw new ConcurrentModificationException("Unable to provide element: " + e.toString());
-        return -1;
+        return versions.size();
-        return !successors.isEmpty();
+        return !versions.isEmpty();
-     * Pushes the versions on the stack
-     *
-     * @param versions
+     * Adds the version 'v' to the list of versions to return and then calls
+     * it self recursively with all the verions prodecessors.
+     * @param v
-    private void push(InternalVersion[] versions) {
-        for (int i = 0; i < versions.length; i++) {
-            if (!visited.contains(versions[i])) {
-                successors.push(versions[i]);
+    private synchronized void addVersion(InternalVersion v) {
+        String id = v.getId();
+        if (!versions.contains(id)) {
+            versions.add(id);
+            InternalVersion[] vs = v.getSuccessors();
+            for (int i=0; i<vs.length; i++) {
+                addVersion(vs[i]);

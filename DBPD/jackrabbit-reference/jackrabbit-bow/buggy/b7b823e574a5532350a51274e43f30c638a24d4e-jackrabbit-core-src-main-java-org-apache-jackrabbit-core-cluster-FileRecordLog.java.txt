JCR-702: Allow database as backend for clustering
JCR-703: Add signature and major/minor version to the journal files used for clustering 


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@495239 13f79535-47bb-0310-9956-ffa450edef68

+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.InputStream;
- * A file record log is a file containing {@link FileRecord}s. Internally,
- * the first 8 bytes contain the revision this log starts with.
+ * A file record log is a file containing {@link FileRecord}s. Physically,
+ * the first 4 bytes contain a signature, followed by a major and minor version
+ * (2 bytes each). The next 8 bytes contain the revision this log starts with.
+ * After this, zero or more <code>FileRecord</code>s follow.
+     * Logger.
+     */
+    private static Logger log = LoggerFactory.getLogger(FileRecordLog.class);
+
+    /**
+     * Record log signature.
+     */
+    private static final byte[] SIGNATURE = { 'J', 'L', 'O', 'G' };
+
+    /**
+     * Known major version.
+     */
+    private static final short MAJOR_VERSION = 1;
+
+    /**
+     * Known minor version.
+     */
+    private static final short MINOR_VERSION = 0;
+
+    /**
+     * Header size. This is the size of {@link #SIGNATURE}, {@link #MAJOR_VERSION},
+     * {@link #MINOR_VERSION} and first revision (8 bytes).
+     */
+    private static final int HEADER_SIZE = 4 + 2 + 2 + 8;
+
+    /**
+                readHeader(in);
-                maxRevision = minRevision + file.length() - 8;
+                maxRevision = minRevision + file.length() - HEADER_SIZE;
-            String msg = "Seek allowed exactly once.";
+            String msg = "Stream already open: seek() only allowed once.";
-        open();
+        in = new DataInputStream(new BufferedInputStream(
+                new FileInputStream(file)));
+        skip(revision - minRevision + HEADER_SIZE);
+    }
-        long skiplen = revision - minRevision + 8;
+    /**
+     * Skip exactly <code>n</code> bytes. Throws if less bytes are skipped.
+     *
+     * @param n bytes to skip
+     * @throws IOException if an I/O error occurs, or less that <code>n</code> bytes
+     *                     were skipped.
+     */
+    private void skip(long n) throws IOException {
+        long skiplen = n;
-     * Append a record to this log.
+     * Read the file record at the current seek position.
-     * @param record record to add
+     * @return file record
-    public void append(FileRecord record) throws IOException {
+    public FileRecord read() throws IOException {
+        byte[] creator = new byte[in.readUnsignedShort()];
+        in.readFully(creator);
+        int length = in.readInt();
+        return new FileRecord(creator, length, in);
+    }
+
+    /**
+     * Append a record to this log. Returns the revision following this record.
+     *
+     * @param record record to add
+     * @return next available revision
+     * @throws IOException if an I/O error occurs
+     */
+    public long append(long revision, byte[] creator, File record) throws IOException {
+            int recordLength = (int) record.length();
-                out.writeLong(record.getRevision());
+                writeHeader(out);
+                out.writeLong(revision);
-            record.append(out);
+            out.writeShort(creator.length);
+            out.write(creator);
+            out.writeInt(recordLength);
+            append(record, out);
+            return revision + getRecordSize(creator, recordLength);
-     * Open this log.
-     *
-     * @throws IOException if an I/O error occurs
-     */
-    private void open() throws IOException {
-        in = new DataInputStream(new BufferedInputStream(
-                new FileInputStream(file)));
-    }
-
-    /**
-     * Return the underlying input stream.
-     *
-     * @return underlying input stream
-     */
-    protected DataInputStream getInputStream() {
-        if (in == null) {
-            String msg = "Input stream not open.";
-            throw new IllegalStateException(msg);
-        }
-        return in;
-    }
-
-    /**
-     *
-     * @throws IOException if an I/O error occurs
-    public void close() throws IOException {
-        if (in != null) {
+    public void close() {
+        try {
+            if (in != null) {
+                in.close();
+            }
+        } catch (IOException e) {
+            String msg = "Error while closing record log: " + e.getMessage();
+            log.warn(msg);
+        }
+    }
+
+    /**
+     * Return the size of a stored record . A stored record's size is the size of
+     * the length-prefixed creator string plus the size of the length-prefixed data.
+     *
+     * @param creator creator string
+     * @param length data length
+     * @return size of a stored record
+     */
+    public static int getRecordSize(byte[] creator, int length) {
+        return 2 + creator.length + 4 + length;
+    }
+
+    /**
+     * Read signature and major/minor version of file and verify.
+     *
+     * @param in input stream
+     * @throws IOException if an I/O error occurs or the file does
+     *                     not have a valid header.
+     */
+    private void readHeader(DataInputStream in) throws IOException {
+        byte[] signature = new byte[SIGNATURE.length];
+        in.readFully(signature);
+
+        for (int i = 0; i < SIGNATURE.length; i++) {
+            if (signature[i] != SIGNATURE[i]) {
+                String msg = "Record log '" + file.getPath() +
+                        "' has wrong signature: " + toHexString(signature);
+                throw new IOException(msg);
+            }
+        }
+
+        short major = in.readShort();
+        in.readShort(); // minor version not used yet
+
+        if (major > MAJOR_VERSION) {
+            String msg = "Record log '" + file.getPath() +
+                    "' has incompatible major version: " + major;
+            throw new IOException(msg);
+        }
+    }
+
+    /**
+     * Write signature and major/minor.
+     *
+     * @param out input stream
+     * @throws IOException if an I/O error occurs.
+     */
+    private void writeHeader(DataOutputStream out) throws IOException {
+        out.write(SIGNATURE);
+        out.writeShort(MAJOR_VERSION);
+        out.writeShort(MINOR_VERSION);
+    }
+
+    /**
+     * Append a record to this log's output stream.
+     *
+     * @param record record to append
+     * @param out where to append to
+     */
+    private static void append(File record, DataOutputStream out) throws IOException {
+        byte[] buffer = new byte[8192];
+        int len;
+
+        InputStream in = new BufferedInputStream(new FileInputStream(record));
+        try {
+            while ((len = in.read(buffer)) > 0) {
+                out.write(buffer, 0, len);
+            }
+            out.flush();
+        } finally {
+
+    /**
+     * Convert a byte array to its hexadecimal string representation.
+     */
+    private static String toHexString(byte[] b) {
+        StringBuffer buf = new StringBuffer();
+        for (int i = 0; i < b.length; i++) {
+            String s = Integer.toHexString(b[i] & 0xff).toUpperCase();
+            if (s.length() == 1) {
+                buf.append('0');
+            }
+            buf.append(s);
+        }
+        return buf.toString();
+    }

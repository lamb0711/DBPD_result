core.state: 
replaced abstract ItemStateCache with interface of same name and added ItemStateMap, ItemStateReferenceMap, ItemStateReferenceCache & LRUItemStateCache which provide cleaner semantics and improved memory usage behaviour

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@227042 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.collections.map.ReferenceMap;
+import java.util.ArrayList;
+import java.util.Collection;
-class TransientItemStateManager extends ItemStateCache implements ItemStateManager {
+class TransientItemStateManager implements ItemStateManager {
-    private final Attic attic;
+    /**
+     * map of those states that have been removed transiently
+     */
+    private final ItemStateMap atticMap;
+
+    /**
+     * map of new or modified transient states
+     */
+    private final ItemStateMap transientMap;
+
+    /**
+     * ItemStateManager view of the states in the attic; lazily instantiated
+     * in {@link #getAttic()}
+     */
+    private AtticItemStateManager attic;
-        // we're keeping hard references in the cache
-        super(ReferenceMap.HARD, ReferenceMap.HARD);
-        attic = new Attic();
+        transientMap = new ItemStateMap();
+        atticMap = new ItemStateMap();
-        super.dump(ps);
+        transientMap.dump(ps);
-        attic.dump(ps);
+        atticMap.dump(ps);
-        ItemState state = retrieve(id);
+        ItemState state = transientMap.get(id);
-        return isCached(id);
+        return transientMap.contains(id);
-        return !isEmpty();
+        return !transientMap.isEmpty();
-        return !attic.isEmpty();
+        return !atticMap.isEmpty();
-        return size();
+        return transientMap.size();
-        return attic.size();
+        return atticMap.size();
-        return entries();
+        return transientMap.values().iterator();
-        return attic.entries();
+        return atticMap.values().iterator();
-        // check cache. synchronized to ensure an entry is not created twice.
-        synchronized (cacheMonitor) {
-            if (isCached(id)) {
+        // check map; synchronized to ensure an entry is not created twice.
+        synchronized (transientMap) {
+            if (transientMap.contains(id)) {
-            // put it in cache
-            cache(state);
+            // put transient state in the map
+            transientMap.put(state);
-        // check cache. synchronized to ensure an entry is not created twice.
-        synchronized (cacheMonitor) {
-            if (isCached(id)) {
+        // check map; synchronized to ensure an entry is not created twice.
+        synchronized (transientMap) {
+            if (transientMap.contains(id)) {
-            // put it in cache
-            cache(state);
+            // put transient state in the map
+            transientMap.put(state);
-        // check cache. synchronized to ensure an entry is not created twice.
-        synchronized (cacheMonitor) {
-            if (isCached(id)) {
+        // check map; synchronized to ensure an entry is not created twice.
+        synchronized (transientMap) {
+            if (transientMap.contains(id)) {
-            // put it in cache
-            cache(state);
+            // put transient state in the map
+            transientMap.put(state);
-        // check cache. synchronized to ensure an entry is not created twice.
-        synchronized (cacheMonitor) {
-            if (isCached(id)) {
+        // check map; synchronized to ensure an entry is not created twice.
+        synchronized (transientMap) {
+            if (transientMap.contains(id)) {
-            // put it in cache
-            cache(state);
+            // put transient state in the map
+            transientMap.put(state);
-     * Disposes the specified instance, i.e. discards it and clears it from cache.
+     * Disposes the specified instance, i.e. discards it and removes it from
+     * the map.
-        // remove from cache
-        evict(state.getId());
+        // remove from map
+        transientMap.remove(state.getId());
-     * Transfers the specified instance from the 'active' cache to the attic.
+     * Transfers the specified instance from the 'active' map to the attic.
-        // remove from cache
-        evict(state.getId());
+        // remove from map
+        transientMap.remove(state.getId());
-        attic.cache(state);
+        atticMap.put(state);
-        attic.evict(state.getId());
+        atticMap.remove(state.getId());
-        // dispose item states in cache
-        Iterator iter = entries();
+        // dispose item states in transient map & attic
+        // (use temp collection to avoid ConcurrentModificationException)
+        Collection tmp = new ArrayList(transientMap.values());
+        Iterator iter = tmp.iterator();
-        // dispose item states in attic
-        iter = attic.entries();
+        tmp = new ArrayList(atticMap.values());
+        iter = tmp.iterator();
+        if (attic == null) {
+            attic = new AtticItemStateManager();
+        }
-    class Attic extends ItemStateCache implements ItemStateManager {
+    /**
+     * ItemStateManager view of the states in the attic
+     *
+     * @see TransientItemStateManager#getAttic
+     */
+    private class AtticItemStateManager implements ItemStateManager {
-        Attic() {
-            super(ReferenceMap.HARD, ReferenceMap.HARD);
+        AtticItemStateManager() {
-            ItemState state = retrieve(id);
+            ItemState state = atticMap.get(id);
-            return isCached(id);
+            return atticMap.contains(id);
-
+            // n/a
+            // n/a

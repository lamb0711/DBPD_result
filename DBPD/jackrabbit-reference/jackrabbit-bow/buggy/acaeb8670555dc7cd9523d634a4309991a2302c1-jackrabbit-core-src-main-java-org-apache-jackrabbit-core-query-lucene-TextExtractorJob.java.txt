JCR-2219: Improved background text extraction

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@799610 13f79535-47bb-0310-9956-ffa450edef68

-import EDU.oswego.cs.dl.util.concurrent.FutureResult;
-import EDU.oswego.cs.dl.util.concurrent.Callable;
-
-import org.apache.jackrabbit.util.LazyFileInputStream;
-import java.io.IOException;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.OutputStreamWriter;
-import java.io.Writer;
-import java.io.BufferedWriter;
-import java.io.InputStreamReader;
-import java.io.StringReader;
-import java.lang.reflect.InvocationTargetException;
-public class TextExtractorJob extends FutureResult implements Runnable {
-
-    /**
-     * UTF-8 encoding.
-     */
-    private static final String ENCODING_UTF8 = "UTF-8";
+public class TextExtractorJob implements Runnable {
-     * The command of the future result.
+     * The text extractor.
-    private final Runnable cmd;
+    private final TextExtractor extractor;
+
+    /**
+     * The binary stream.
+     */
+    private final InputStream stream;
-     * Set to <code>true</code> if this job timed out.
+     * The encoding of the binary content, or <code>null</code>.
-    private transient boolean timedOut = false;
+    private final String encoding;
-     * <code>true</code> if this extractor job has been flaged as discarded.
+     * The extracted text. Set when the text extraction task completes.
-    private transient boolean discarded = false;
+    private transient String text = null;
-    public TextExtractorJob(final TextExtractor extractor,
-                            final InputStream stream,
-                            final String type,
-                            final String encoding) {
+    public TextExtractorJob(
+            TextExtractor extractor,
+            InputStream stream, String type, String encoding) {
+        this.extractor = extractor;
+        this.stream = stream;
-        this.cmd = setter(new Callable() {
-            public Object call() throws Exception {
-                Reader r = extractor.extractText(stream, type, encoding);
-                if (r != null) {
-                    if (discarded) {
-                        r.close();
-                        r = null;
-                    } else if (timedOut) {
-                        // spool a temp file to save memory
-                        r = getSwappedOutReader(r);
-                    }
-                }
-                return r;
-            }
-        });
+        this.encoding = encoding;
+    }
+
+    public boolean hasExtractedText() {
+        return text != null;
-     * to the constructor of this <code>TextExtractorJob</code>. The caller of
-     * this method is responsible for closing the returned reader. Returns
+     * to the constructor of this <code>TextExtractorJob</code>. Returns
-     * @return the Reader with the extracted text. Returns <code>null</code> if
-     *         a timeout or an exception occured extracting the text.
+     * @return the extracted text, or <code>null</code> if a timeout or
+     *         an exception occurred while extracting the text
-    public Reader getReader(long timeout) {
-        Reader reader = null;
-        try {
-            reader = (Reader) timedGet(timeout);
-        } catch (InterruptedException e) {
-            // also covers TimeoutException
-            // text not extracted within timeout or interrupted
-            if (timeout > 0) {
-                log.debug("Text extraction for {} timed out (>{}ms).",
-                        type, new Long(timeout));
-                timedOut = true;
-            }
-        } catch (InvocationTargetException e) {
-            // extraction failed
-            log.warn("Exception while indexing binary property: " + e.getCause());
-            log.debug("Dump: ", e.getCause());
-        }
-        return reader;
-    }
-
-    /**
-     * Discards this extractor job. If the reader within this job is ready at
-     * the time of this call, it is closed. If the reader is not yet ready this
-     * job will be flaged as discarded and any later call to
-     * {@link #getReader(long)} will return <code>null</code>. The reader that
-     * is about to be constructed by a background thread will be closed
-     * automatically as soon as it becomes ready.
-     */
-    void discard() {
-        discarded = true;
-        Reader r = (Reader) peek();
-        if (r != null) {
+    public synchronized String getExtractedText(long timeout) {
+        if (text == null) {
-                r.close();
-            } catch (IOException e) {
-                log.warn("Exception when trying to discard extractor job: " + e);
+                wait(timeout);
+            } catch (InterruptedException e) {
+                if (text == null) {
+                    log.debug("Text extraction for {} timed out (> {}ms)",
+                            type, timeout);
+                }
+        return text;
-        // forward to command
-        cmd.run();
-    }
-
-    //----------------------------< internal >----------------------------------
-
-    /**
-     * Returns a <code>Reader</code> for <code>r</code> using a temp file.
-     *
-     * @param r the reader to swap out into a temp file.
-     * @return a reader to the temp file.
-     */
-    private Reader getSwappedOutReader(Reader r) {
-        final File temp;
-        try {
-            temp = File.createTempFile("extractor", null);
-        } catch (IOException e) {
-            // unable to create temp file
-            // return reader as is
-            return r;
-        }
-        Writer out;
-        try {
-            out = new BufferedWriter(new OutputStreamWriter(
-                            new FileOutputStream(temp), ENCODING_UTF8));
-        } catch (IOException e) {
-            // should never happend actually
-            if (!temp.delete()) {
-                temp.deleteOnExit();
-            }
-            return r;
-        }
-
-        // spool into temp file
-        InputStream in = null;
-                IOUtils.copy(r, out);
-                out.close();
+                Reader reader = extractor.extractText(stream, type, encoding);
+                this.text = IOUtils.toString(reader);
-                r.close();
+                stream.close();
-            in = new LazyFileInputStream(temp);
-
-            return new InputStreamReader(in, ENCODING_UTF8) {
-                public void close() throws IOException {
-                    super.close();
-                    // delete file
-                    if (!temp.delete()) {
-                        temp.deleteOnExit();
-                    }
-                }
-            };
-        } catch (IOException e) {
-            // do some clean up
-            IOUtils.closeQuietly(out);
-            IOUtils.closeQuietly(in);
-
-            if (!temp.delete()) {
-                temp.deleteOnExit();
-            }
-            // use empty string reader as fallback
-            return new StringReader("");
+        } catch (Throwable e) {
+            log.warn("Text extraction failed for type " + type, e);
+            this.text = "";
+        }
+        synchronized (this) {
+            notifyAll();
+

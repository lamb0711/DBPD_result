JCR-337 - Remove jcr dependency from dav-library
JCR-343 - Report#init limits the Report interface to DeltaV compliant resources
JCR-340 - ValuesProperty missing property type information
JCR-342 - DavResource#getDavSession() missing
JCR-344 - DeltaVResource lists MKWORKSPACE in the method constant.
JCR-345 - DavException does not allow to specify an exception cause

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@385540 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.webdav.property.DavPropertyName;
+import org.apache.jackrabbit.webdav.DavException;
+import org.apache.jackrabbit.webdav.DavServletResponse;
+     * Create a new <code>ValuesProperty</code> from the given single {@link Value}.
+     *
+     * @param value Array of Value objects as obtained from the JCR property.
+     */
+    public ValuesProperty(Value value) {
+        super(JCR_VALUE, false);
+        // finally set the value to the DavProperty
+        jcrValues = (value == null) ? new Value[0] : new Value[] {value};
+    }
+
+    /**
-    public ValuesProperty(Value[] values) throws ValueFormatException, RepositoryException {
-	super(JCR_VALUES, false);
-	// finally set the value to the DavProperty
-	jcrValues = values;
+    public ValuesProperty(Value[] values) {
+        super(JCR_VALUES, false);
+        // finally set the value to the DavProperty
+        jcrValues = (values == null) ? new Value[0] : values;
-    
+
+     * @param defaultType default type of the values to be deserialized. If however
+     * the {@link #XML_VALUE 'value'} elements provide a {@link #ATTR_VALUE_TYPE 'type'}
+     * attribute, the default value is ignored.
-    public ValuesProperty(DavProperty property) throws RepositoryException {
-	super(JCR_VALUES, false);
+    public ValuesProperty(DavProperty property, int defaultType) throws RepositoryException, DavException {
+        super(property.getName(), false);
-	if (!JCR_VALUES.equals(property.getName())) {
-	    throw new IllegalArgumentException("ValuesProperty may only be created with a property that has name="+JCR_VALUES.getName());
-	}
+        if (!(JCR_VALUES.equals(property.getName()) || JCR_VALUE.equals(getName()))) {
+            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "ValuesProperty may only be created with a property that has name="+JCR_VALUES.getName());
+        }
-	List valueElements = new ArrayList();
+        // retrieve jcr-values from child 'value'-element(s)
+        List valueElements = new ArrayList();
-        if (propValue != null) {
+        if (propValue == null) {
+            jcrValues = new Value[0];
+        } else { /* not null propValue */
-	    Iterator elemIt = ((List)property.getValue()).iterator();
-	    while (elemIt.hasNext()) {
-		Object el = elemIt.next();
-		/* make sure, only Elements with name 'value' are used for
-		* the 'value' field. any other content (other elements, text,
-		* comment etc.) is ignored. NO bad-request/conflict error is
-		* thrown.
-		*/
+                Iterator elemIt = ((List)property.getValue()).iterator();
+                while (elemIt.hasNext()) {
+                    Object el = elemIt.next();
+                    /* make sure, only Elements with name 'value' are used for
+                    * the 'value' field. any other content (other elements, text,
+                    * comment etc.) is ignored. NO bad-request/conflict error is
+                    * thrown.
+                    */
-		    valueElements.add(el);
-		}
-	    }
+                        valueElements.add(el);
+                    }
+                }
+            }
+            /* fill the 'value' with the valid 'value' elements found before */
+            Element[] elems = (Element[])valueElements.toArray(new Element[valueElements.size()]);
+            jcrValues = new Value[elems.length];
+            for (int i = 0; i < elems.length; i++) {
+                String value = DomUtil.getText(elems[i]);
+                String typeStr = DomUtil.getAttribute(elems[i], ATTR_VALUE_TYPE, ItemResourceConstants.NAMESPACE);
+                int type = (typeStr == null) ? defaultType : PropertyType.valueFromName(typeStr);
+                jcrValues[i] = ValueHelper.deserialize(value, type, false);
-	    /* fill the 'value' with the valid 'value' elements found before */
-        Element[] elems = (Element[])valueElements.toArray(new Element[valueElements.size()]);
-	jcrValues = new Value[elems.length];
-	for (int i = 0; i < elems.length; i++) {
-            String value = DomUtil.getText(elems[i]);
-	    jcrValues[i] = ValueHelper.deserialize(value, PropertyType.STRING, false);
-	}
-	}
+    }
+    private void checkPropertyName(DavPropertyName reqName) throws ValueFormatException {
+        if (!reqName.equals(getName())) {
+            throw new ValueFormatException("Attempt to retrieve mulitple values from single property '" + getName() + "'.");
+        }
+    }
+
-    public Value[] getValues(int propertyType) throws ValueFormatException {
+    public Value[] getJcrValues(int propertyType) throws ValueFormatException {
+        checkPropertyName(JCR_VALUES);
-	}
-	return jcrValues;
+        }
+        return jcrValues;
+    }
+
+    /**
+     * Returns the internal property value as jcr <code>Value</code> array
+     * 
+     * @return
+     */
+    public Value[] getJcrValues() throws ValueFormatException {
+        checkPropertyName(JCR_VALUES);
+        return jcrValues;
+    }
+
+    /**
+     *
+     * @param propertyType
+     * @return
+     * @throws ValueFormatException
+     */
+    public Value getJcrValue(int propertyType) throws ValueFormatException {
+        checkPropertyName(JCR_VALUE);
+        return (jcrValues.length == 0) ? null : ValueHelper.convert(jcrValues[0], propertyType);
+    }
+
+    /**
+     *
+     * @return
+     * @throws ValueFormatException
+     */
+    public Value getJcrValue() throws ValueFormatException {
+        checkPropertyName(JCR_VALUE);
+        return (jcrValues.length == 0) ? null : jcrValues[0];
+    }
+
+    /**
+     * Returns the type of the {@link Value value}s present in this property
+     * or {@link PropertyType#UNDEFINED} if no values are available.
+     *
+     * @return type of values or {@link PropertyType#UNDEFINED}
+     */
+    public int getValueType() {
+        // TODO: check if correct behaviour if values array is empty
+        return (jcrValues.length > 0) ? jcrValues[0].getType() : PropertyType.UNDEFINED;
-     * @see #getValues(int)
+     * @see #getJcrValues(int)
-	return jcrValues;
+        return jcrValues;
+    /**
+     *
+     * @param document
+     * @return
+     */
-        for (int i = 0; i < jcrValues.length; i++) {
-            try {
-                DomUtil.addChildElement(elem, XML_VALUE, ItemResourceConstants.NAMESPACE, jcrValues[i].getString());
-            } catch (RepositoryException e) {
-                log.error("Unexpected Error while converting jcr value to String: " + e.getMessage());
-    }
+        try {
+            for (int i = 0; i < jcrValues.length; i++) {
+                Value v = jcrValues[i];
+                String type = PropertyType.nameFromValue(v.getType());
+                Element xmlValue = DomUtil.createElement(document, XML_VALUE, ItemResourceConstants.NAMESPACE, v.getString());
+                DomUtil.setAttribute(xmlValue, ATTR_VALUE_TYPE, ItemResourceConstants.NAMESPACE, type);
+                elem.appendChild(xmlValue);
+            }
+        } catch (RepositoryException e) {
+            log.error("Unexpected Error while converting jcr value to String: " + e.getMessage());
-

JCR-2646 : AccessControlManager#getEffectivePolicies(String) may expose AC content without proper permissions
JCR-2657 : DefaultAccessManager#hasPrivileges(String,Set,Privilege[]) doesn't close compiled permissions
JCR-2649 : Provide means to display the effective policies for a given set of principals

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@954964 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.util.ISO9075;
+import org.apache.jackrabbit.util.Text;
+import javax.jcr.AccessDeniedException;
+import javax.jcr.NodeIterator;
+import javax.jcr.query.Query;
+import javax.jcr.query.QueryManager;
+import javax.jcr.query.QueryResult;
+import java.util.LinkedHashSet;
-     * @see org.apache.jackrabbit.core.security.authorization.AccessControlProvider#getEffectivePolicies(Path)
-     * @param absPath absolute path
+     * @see org.apache.jackrabbit.core.security.authorization.AccessControlProvider#getEffectivePolicies(org.apache.jackrabbit.spi.Path,org.apache.jackrabbit.core.security.authorization.CompiledPermissions)
-    public AccessControlPolicy[] getEffectivePolicies(Path absPath) throws ItemNotFoundException, RepositoryException {
+    public AccessControlPolicy[] getEffectivePolicies(Path absPath, CompiledPermissions permissions) throws ItemNotFoundException, RepositoryException {
-        collectAcls(node, acls);
+        collectAcls(node, permissions, acls);
-            // controlled.
+            // controlled. TODO: there should be a default policy in this case (see JCR-2331)
+     * @see org.apache.jackrabbit.core.security.authorization.AccessControlProvider#getEffectivePolicies(java.util.Set, CompiledPermissions)
+     */
+    public AccessControlPolicy[] getEffectivePolicies(Set<Principal> principals, CompiledPermissions permissions) throws RepositoryException {
+        String propName = ISO9075.encode(session.getJCRName(P_PRINCIPAL_NAME));
+
+        StringBuilder stmt = new StringBuilder("/jcr:root");
+        stmt.append("//element(*,");
+        stmt.append(session.getJCRName(NT_REP_ACE));
+        stmt.append(")[");
+        int i = 0;
+        for (Principal principal : principals) {
+            if (i > 0) {
+                stmt.append(" or ");
+            }
+            stmt.append("@");
+            stmt.append(propName);
+            stmt.append("='");
+            stmt.append(principal.getName().replaceAll("'", "''"));
+            stmt.append("'");
+            i++;
+        }
+        stmt.append("]");
+        
+        QueryResult result;
+        try {
+            QueryManager qm = session.getWorkspace().getQueryManager();
+            Query q = qm.createQuery(stmt.toString(), Query.XPATH);
+            result = q.execute();
+        } catch (RepositoryException e) {
+            log.error("Unexpected error while searching effective policies.", e.getMessage());            
+            throw new UnsupportedOperationException("Retrieve effective policies for set of principals not supported.", e);
+        }
+
+        Set<AccessControlPolicy> acls = new LinkedHashSet<AccessControlPolicy>();
+        for (NodeIterator it = result.getNodes(); it.hasNext();) {
+            NodeImpl aclNode = (NodeImpl) it.nextNode().getParent();
+            NodeImpl accessControlledNode = (NodeImpl) aclNode.getParent();
+            
+            if (isAccessControlled(accessControlledNode)) {
+                if (permissions.canRead(aclNode.getPrimaryPath(), aclNode.getNodeId())) {
+                    acls.add(new UnmodifiableAccessControlList(entryCollector.getEntries(accessControlledNode), accessControlledNode.getPath(), Collections.<String, Integer>emptyMap()));
+                } else {
+                    throw new AccessDeniedException("Access denied at " + Text.getRelativeParent(aclNode.getPath(), 1));
+                }
+            }
+        }
+
+        return acls.toArray(new AccessControlPolicy[acls.size()]);
+    }
+
+    /**
-    private void collectAcls(NodeImpl node, List<AccessControlList> acls) throws RepositoryException {
+    private void collectAcls(NodeImpl node, CompiledPermissions permissions, List<AccessControlList> acls) throws RepositoryException {
-            // retrieve the entries for the access controlled node
-            acls.add(new UnmodifiableAccessControlList(entryCollector.getEntries(node), node.getPath(), Collections.<String, Integer>emptyMap()));
+            if (permissions.grants(node.getPrimaryPath(), Permission.READ_AC)) {
+                // retrieve the entries for the access controlled node
+                acls.add(new UnmodifiableAccessControlList(entryCollector.getEntries(node), node.getPath(), Collections.<String, Integer>emptyMap()));
+            } else {
+                throw new AccessDeniedException("Access denied at " + node.getPath());
+            }
-            collectAcls(parentNode, acls);
+            collectAcls(parentNode, permissions, acls);

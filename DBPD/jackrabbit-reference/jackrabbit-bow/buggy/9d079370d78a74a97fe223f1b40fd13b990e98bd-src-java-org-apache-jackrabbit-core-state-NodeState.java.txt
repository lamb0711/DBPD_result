True caching in CachingHierarchyManager

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@190372 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.commons.collections.map.ReferenceMap;
+import org.apache.commons.collections.MapIterator;
-import java.util.Map;
+import java.util.Map;
+     * Listeners (weak references)
+     */
+    private final transient ReferenceMap listeners =
+            new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);
+
+    /**
-        super(overlayedState, initialStatus, isTransient);
+        super(initialStatus, isTransient);
+        connect(overlayedState);
-        return childNodeEntries.add(nodeName, uuid);
+        ChildNodeEntry entry = childNodeEntries.add(nodeName, uuid);
+        notifyNodeAdded(entry);
+        return entry;
+    }
+
+    /**
+     * Renames a new <code>ChildNodeEntry<code>.
+     *
+     * @param oldName <code>QName<code> object specifying the entry's old name
+     * @param index 1-based index if there are same-name child node entries
+     * @param newName <code>QName<code> object specifying the entry's new name
+     * @return <code>true</code> if the entry was sucessfully renamed;
+     *         otherwise <code>false</code>
+     */
+    public synchronized boolean renameChildNodeEntry(QName oldName, int index,
+                                                     QName newName) {
+        ChildNodeEntry oldEntry = childNodeEntries.remove(oldName, index);
+        if (oldEntry != null) {
+            ChildNodeEntry newEntry = addChildNodeEntry(newName, oldEntry.getUUID());
+            notifyNodeAdded(newEntry);
+            notifyNodeRemoved(oldEntry);
+            return true;
+        }
+        return false;
-        return childNodeEntries.remove(nodeName, index);
+        ChildNodeEntry entry = childNodeEntries.remove(nodeName, index);
+        if (entry != null) {
+            notifyNodeRemoved(entry);
+        }
+        return entry != null;
+        notifyNodesReplaced();
+    /**
+     * @see ItemState#addListener
+     *
+     * If the listener passed is at the same time a <code>NodeStateListener</code>
+     * we add it to our list of specialized listeners.
+     */
+    public void addListener(ItemStateListener listener) {
+        if (listener instanceof NodeStateListener) {
+            synchronized (listeners) {
+                if (!listeners.containsKey(listener)) {
+                    listeners.put(listener, listener);
+                }
+            }
+        }
+        super.addListener(listener);
+    }
+
+    /**
+     * @see ItemState#removeListener
+     *
+     * If the listener passed is at the same time a <code>NodeStateListener</code>
+     * we remove it from our list of specialized listeners.
+     */
+    public void removeListener(ItemStateListener listener) {
+        if (listener instanceof NodeStateListener) {
+            synchronized (listeners) {
+                listeners.remove(listener);
+            }
+        }
+        super.removeListener(listener);
+    }
+
+    /**
+     * Notify the listeners that some child node was added
+     */
+    protected void notifyNodeAdded(ChildNodeEntry added) {
+        synchronized (listeners) {
+            MapIterator iter = listeners.mapIterator();
+            while (iter.hasNext()) {
+                NodeStateListener l = (NodeStateListener) iter.next();
+                if (l != null) {
+                    l.nodeAdded(this, added.getName(),
+                            added.getIndex(), added.getUUID());
+                }
+            }
+        }
+    }
+
+    /**
+     * Notify the listeners that the children nodes were replaced
+     */
+    protected void notifyNodesReplaced() {
+        synchronized (listeners) {
+            MapIterator iter = listeners.mapIterator();
+            while (iter.hasNext()) {
+                NodeStateListener l = (NodeStateListener) iter.next();
+                if (l != null) {
+                    l.nodesReplaced(this);
+                }
+            }
+        }
+    }
+
+    /**
+     * Notify the listeners that some child node was removed
+     */
+    protected void notifyNodeRemoved(ChildNodeEntry removed) {
+        synchronized (listeners) {
+            MapIterator iter = listeners.mapIterator();
+            while (iter.hasNext()) {
+                NodeStateListener l = (NodeStateListener) iter.next();
+                if (l != null) {
+                    l.nodeRemoved(this, removed.getName(),
+                            removed.getIndex(), removed.getUUID());
+                }
+            }
+        }
+    }
+
-            return remove(entry.getName(), entry.getIndex());
+            return remove(entry.getName(), entry.getIndex()) != null;
-        public boolean remove(QName nodeName, int index) {
+        public ChildNodeEntry remove(QName nodeName, int index) {
-                return false;
+                return null;
-                return false;
+                return null;
-                return true;
+                return removedEntry;
-            return true;
+            return removedEntry;

JCR-2435: [patch] Fix overly specific casting in core

Patch by Dave Brosius, plus some Java 5 cleanups to ChildNodeEntries

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@891242 13f79535-47bb-0310-9956-ffa450edef68

+    @SuppressWarnings("unchecked")
-        if (obj instanceof ArrayList<?>) {
+        if (obj instanceof List<?>) {
-            return Collections.unmodifiableList((ArrayList<ChildNodeEntry>) obj);
+            return Collections.unmodifiableList((List<ChildNodeEntry>) obj);
+    @SuppressWarnings("unchecked")
-        if (obj instanceof ArrayList<?>) {
+        if (obj instanceof List<?>) {
-            ArrayList<ChildNodeEntry> siblings = (ArrayList<ChildNodeEntry>) obj;
+            List<ChildNodeEntry> siblings = (List<ChildNodeEntry>) obj;
+    @SuppressWarnings("unchecked")
-        List<Object> siblings = null;
+        List<ChildNodeEntry> siblings = null;
-            if (obj instanceof ArrayList<?>) {
+            if (obj instanceof List<?>) {
-                siblings = (ArrayList<Object>) obj;
+                siblings = (List<ChildNodeEntry>) obj;
-                    nodeName = ((ChildNodeEntry) siblings.get(0)).getName();
+                    nodeName = siblings.get(0).getName();
-                siblings = new ArrayList<Object>();
-                siblings.add(obj);
+                siblings = new ArrayList<ChildNodeEntry>();
+                siblings.add((ChildNodeEntry) obj);
+    @SuppressWarnings("unchecked")
-        List<ChildNodeEntry> siblings = (ArrayList<ChildNodeEntry>) obj;
+        List<ChildNodeEntry> siblings = (List<ChildNodeEntry>) obj;
-    public boolean containsAll(Collection c) {
-        Iterator iter = c.iterator();
-        while (iter.hasNext()) {
-            if (!contains(iter.next())) {
+    public boolean containsAll(Collection<?> c) {
+        for (Object entry : c) {
+            if (!contains(entry)) {
+    @SuppressWarnings("unchecked")
-    public boolean addAll(Collection c) {
+    public boolean addAll(Collection<? extends ChildNodeEntry> c) {
-    public boolean addAll(int index, Collection c) {
+    public boolean addAll(int index, Collection<? extends ChildNodeEntry> c) {
-    public boolean removeAll(Collection c) {
+    public boolean removeAll(Collection<?> c) {
-    public boolean retainAll(Collection c) {
+    public boolean retainAll(Collection<?> c) {
-        nameMap = Collections.EMPTY_MAP;
+        nameMap = Collections.emptyMap();
+    @SuppressWarnings("unchecked")
-            nameMap = (Map<Name, Object>) ((HashMap<Name, Object>) nameMap).clone();
-            for (Iterator it = nameMap.entrySet().iterator(); it.hasNext(); ) {
-                Map.Entry entry = (Map.Entry) it.next();
+            nameMap = new HashMap<Name, Object>(nameMap);
+            for (Map.Entry<Name, Object> entry : nameMap.entrySet()) {
-                if (value instanceof ArrayList) {
-                    entry.setValue(((ArrayList) value).clone());
+                if (value instanceof List<?>) {
+                    entry.setValue(new ArrayList<ChildNodeEntry>(
+                            (List<ChildNodeEntry>) value));

JCR-4339 Indexing configuration condition property seems to be broken

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1836620 13f79535-47bb-0310-9956-ffa450edef68

-import javax.jcr.nodetype.NoSuchNodeTypeException;
+import org.apache.jackrabbit.core.nodetype.EffectiveNodeType;
-        IndexingRule rule = getApplicableIndexingRule(state, propertyName);
+        IndexingRule rule = getApplicableIndexingRule(state);
-            return rule.isIndexed(propertyName);
+            return rule.isIndexed(state, propertyName);
-        IndexingRule rule = getApplicableIndexingRule(state, propertyName);
+        IndexingRule rule = getApplicableIndexingRule(state);
-        IndexingRule rule = getApplicableIndexingRule(state, null);
+        IndexingRule rule = getApplicableIndexingRule(state);
-        IndexingRule rule = getApplicableIndexingRule(state, propertyName);
+        IndexingRule rule = getApplicableIndexingRule(state);
-        IndexingRule rule = getApplicableIndexingRule(state, propertyName);
+        IndexingRule rule = getApplicableIndexingRule(state);
-                        perNtConfig.add(new IndexingRule(element, ntReg.getNodeTypeDef(ntName)));
+                        perNtConfig.add(new IndexingRule(element, ntReg.getNodeTypeDef(ntName), ntReg.getEffectiveNodeType(ntName)));
-     * @param propertyName the property name to check.
-    private IndexingRule getApplicableIndexingRule(NodeState state, Name propertyName) {
+    private IndexingRule getApplicableIndexingRule(NodeState state) {
-                if (rule.appliesTo(state, propertyName)) {
+                if (rule.appliesTo(state)) {
-         * The NodeTypeDefinition of this fulltext indexing rule.
+         * The node type of this fulltext indexing rule.
-        private final QNodeTypeDefinition nodeTypeDefinition;
+        private final Name nodeTypeName;
+
+        /**
+         * Indicates if nodetype is a mixin
+         */
+        private boolean mixinNodeType = false;
+
+        /**
+         * The effective node type of this fulltext indexing rule.
+         */
+        private EffectiveNodeType effectiveNodeType;
-         * @param qNodeTypeDefinition the node type for the rule.
+         * @param nodeTypeDef the node type definition for the rule.
+         * @param effectiveNodeType the EffectiveNodeType of the rule
-        IndexingRule(IndexingRule original, QNodeTypeDefinition qNodeTypeDefinition) {
-            this.nodeTypeDefinition = qNodeTypeDefinition;
+        IndexingRule(IndexingRule original, QNodeTypeDefinition nodeTypeDef, EffectiveNodeType effectiveNodeType) {
+            this.nodeTypeName = nodeTypeDef.getName();
+            this.mixinNodeType = nodeTypeDef.isMixin();
+            this.effectiveNodeType = effectiveNodeType;
-         * @throws NoSuchNodeTypeException if the nodeType could not be evaluated
-                throws MalformedPathException, IllegalNameException, NamespaceException, NoSuchNodeTypeException {
-            this.nodeTypeDefinition = getNodeTypeDefinition(config);
+                throws MalformedPathException, IllegalNameException, NamespaceException {
+            this.nodeTypeName = getNodeTypeName(config);
-            return nodeTypeDefinition.getName();
+            return nodeTypeName;
+         * @param state        the node state.
-        public boolean isIndexed(Name propertyName) {
-            return getConfig(propertyName) != null;
+        public boolean isIndexed(NodeState state, Name propertyName) {
+            if (mixinNodeType && effectiveNodeType != null) {
+                QPropertyDefinition[] allPropDefs = effectiveNodeType.getAllPropDefs();
+                for (QPropertyDefinition propertyDefinition : allPropDefs) {
+                    if (propertyDefinition.getName().equals(propertyName)) {
+                        return getConfig(propertyName) != null;
+                    }
+                }
+                return true;
+            } else {
+                return getConfig(propertyName) != null;
+            }
-         * @param propertyName the property name to check.
-        public boolean appliesTo(NodeState state, Name propertyName) {
-        	Name nodeTypeName = getNodeTypeName();
-        	if (propertyName != null) {
-	        	for (QPropertyDefinition propertyDefinition : nodeTypeDefinition.getPropertyDefs()) {
-	        		if (propertyDefinition.getName().equals(propertyName)) {
-	        			return true;
-	        		}
-	        	}
-        	}
+        public boolean appliesTo(NodeState state) {
+            if (state.getMixinTypeNames().contains(nodeTypeName)) {
+                return true;
+            }
-         * @throws NoSuchNodeTypeException if the node type could not be evaluated
-        private QNodeTypeDefinition getNodeTypeDefinition(Node config)
-                throws IllegalNameException, NamespaceException, NoSuchNodeTypeException {
+        private Name getNodeTypeName(Node config)
+                throws IllegalNameException, NamespaceException {
-            return ntReg.getNodeTypeDef(resolver.getQName(ntString));
+            return resolver.getQName(ntString);

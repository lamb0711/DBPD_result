JCR-920: rep:excerpt() should also work on properties

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@537791 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.lucene.index.TermVectorOffsetInfo;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.Token;
+import java.io.StringReader;
+import java.io.Reader;
+import java.util.TreeMap;
+import java.util.SortedMap;
+import java.util.Arrays;
-public abstract class AbstractExcerpt implements ExcerptProvider {
+public abstract class AbstractExcerpt implements HighlightingExcerptProvider {
+     * {@inheritDoc}
+     */
+    public String highlight(String text) throws IOException {
+        return createExcerpt(createTermPositionVector(text),
+                text, 1, (text.length() + 1) * 2);
+    }
+
+    /**
+
+    /**
+     * @param text the text.
+     * @return a <code>TermPositionVector</code> for the given text.
+     */
+    private TermPositionVector createTermPositionVector(String text) {
+        // term -> TermVectorOffsetInfo[]
+        final SortedMap termMap = new TreeMap();
+        Reader r = new StringReader(text);
+        TokenStream ts = index.getTextAnalyzer().tokenStream("", r);
+        Token t;
+        try {
+            while ((t = ts.next()) != null) {
+                TermVectorOffsetInfo[] info =
+                        (TermVectorOffsetInfo[]) termMap.get(t.termText());
+                if (info == null) {
+                    info = new TermVectorOffsetInfo[1];
+                } else {
+                    TermVectorOffsetInfo[] tmp = info;
+                    info = new TermVectorOffsetInfo[tmp.length + 1];
+                    System.arraycopy(tmp, 0, info, 0, tmp.length);
+                }
+                info[info.length - 1] = new TermVectorOffsetInfo(
+                        t.startOffset(), t.endOffset());
+                termMap.put(t.termText(), info);
+            }
+        } catch (IOException e) {
+            // should never happen, we are reading from a string
+        }
+
+        return new TermPositionVector() {
+
+            private String[] terms =
+                    (String[]) termMap.keySet().toArray(new String[termMap.size()]);
+
+            public int[] getTermPositions(int index) {
+                return null;
+            }
+
+            public TermVectorOffsetInfo[] getOffsets(int index) {
+                TermVectorOffsetInfo[] info = TermVectorOffsetInfo.EMPTY_OFFSET_INFO;
+                if (index >= 0 && index < terms.length) {
+                    info = (TermVectorOffsetInfo[]) termMap.get(terms[index]);
+                }
+                return info;
+            }
+
+            public String getField() {
+                return "";
+            }
+
+            public int size() {
+                return terms.length;
+            }
+
+            public String[] getTerms() {
+                return terms;
+            }
+
+            public int[] getTermFrequencies() {
+                int[] freqs = new int[terms.length];
+                for (int i = 0; i < terms.length; i++) {
+                    freqs[i] = ((TermVectorOffsetInfo[]) termMap.get(terms[i])).length;
+                }
+                return freqs;
+            }
+
+            public int indexOf(String term) {
+                int res = Arrays.binarySearch(terms, term);
+                return res >= 0 ? res : -1;
+            }
+
+            public int[] indexesOf(String[] terms, int start, int len) {
+                int res[] = new int[len];
+                for (int i = 0; i < len; i++) {
+                    res[i] = indexOf(terms[i]);
+                }
+                return res;
+            }
+        };
+    }

reimplementing Session.importXML & friends due to spec changes 

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@154700 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.*;
+import org.apache.jackrabbit.core.BaseException;
+import org.apache.jackrabbit.core.Constants;
+import org.apache.jackrabbit.core.IllegalNameException;
+import org.apache.jackrabbit.core.NamespaceResolver;
+import org.apache.jackrabbit.core.QName;
+import org.apache.jackrabbit.core.UnknownPrefixException;
+import org.apache.jackrabbit.core.util.ISO9075;
+import javax.jcr.PropertyType;
+import javax.jcr.Value;
+import java.util.ArrayList;
- * <code>DocViewImportHandler</code>  ...
+ * <code>DocViewImportHandler</code> processes Document View XML SAX events
+ * and 'translates' them into <code>{@link Importer}</code> method calls.
-class DocViewImportHandler extends DefaultHandler {
+class DocViewImportHandler extends DefaultHandler implements Constants {
-    private Stack parents;
-    private SessionImpl session;
+    private final Importer importer;
+    private final NamespaceResolver nsContext;
+
+    /**
+     * stack of NodeInfo instances; an instance is pushed onto the stack
+     * in the startElement method and is popped from the stack in the
+     * endElement method.
+     */
+    private final Stack stack = new Stack();
-    private StringBuffer text;
+    private final StringBuffer text = new StringBuffer();
-    DocViewImportHandler(NodeImpl importTargetNode, SessionImpl session) {
-        this.session = session;
-        parents = new Stack();
-
-        parents.push(importTargetNode);
-
-        text = new StringBuffer();
+    DocViewImportHandler(Importer importer, NamespaceResolver nsContext) {
+        this.importer = importer;
+        this.nsContext = nsContext;
-     * Stores character data encountered in <code>{@link #characters(char[], int, int)}</code>
-     * as <code>jcr:xmlcharacters</code> property of <code>jcr:xmltext</code>
-     * child node.
+     * Translates character data encountered in
+     * <code>{@link #characters(char[], int, int)}</code> into a
+     * <code>jcr:xmltext</code> child node with a <code>jcr:xmlcharacters</code>
+     * property.
-     * @param parent
-    protected void addTextNode(NodeImpl parent, String text) throws SAXException {
+    private void onTextNode(String text)
+            throws SAXException {
+        if (text.trim().length() == 0) {
+            // ignore whitespace-only character data
+            log.debug("ignoring withespace character data: " + text);
+            return;
+        }
-                NodeImpl txtNode = (NodeImpl) parent.addNode(Constants.JCR_XMLTEXT);
-                StringValue val = new StringValue(text.toString());
-                txtNode.setProperty(Constants.JCR_XMLCHARACTERS, val);
+                Importer.NodeInfo node =
+                        new Importer.NodeInfo(JCR_XMLTEXT, null, null, null);
+                Value[] values =
+                        new Value[]{new StringValue(text.toString())};
+                ArrayList props = new ArrayList();
+                Importer.PropInfo prop =
+                        new Importer.PropInfo(JCR_XMLCHARACTERS, PropertyType.STRING, values);
+                props.add(prop);
+                // call Importer
+                importer.startNode(node, props, nsContext);
+                importer.endNode(node);
+     * @see ContentHandler#startDocument()
+     */
+    public void startDocument() throws SAXException {
+        try {
+            importer.start();
+        } catch (RepositoryException re) {
+            throw new SAXException(re);
+        }
+    }
+
+    /**
-    public void startElement(String namespaceURI, String localName, String qName, Attributes atts) throws SAXException {
+    public void startElement(String namespaceURI, String localName,
+                             String qName, Attributes atts)
+            throws SAXException {
-            addTextNode((NodeImpl) parents.peek(), text.toString());
+            onTextNode(text.toString());
-                    nodeName = QName.fromJCRName(qName, session.getNamespaceResolver());
+                    nodeName = QName.fromJCRName(qName, nsContext);
-
-            // @todo how should 'system' properties be handled in document view (e.g. jcr:primaryType,jcr:mixinTypes, jcr:uuid)?
-            NodeImpl currentParent = (NodeImpl) parents.peek();
-            currentParent = (NodeImpl) currentParent.addNode(nodeName, Constants.NT_UNSTRUCTURED);
-            parents.push(currentParent);
+            // decode node name
+            nodeName = ISO9075.decode(nodeName);
+            String uuid = null;
+            QName nodeTypeName = null;
+            QName[] mixinTypes = null;
+
+            ArrayList props = new ArrayList(atts.getLength());
-                        propName = QName.fromJCRName(atts.getQName(i), session.getNamespaceResolver());
+                        propName = QName.fromJCRName(atts.getQName(i), nsContext);
-                StringValue val = new StringValue(atts.getValue(i));
-                currentParent.setProperty(propName, val);
+                // decode property name
+                propName = ISO9075.decode(propName);
+
+                // value(s)
+                String attrValue = atts.getValue(i);
+                Value[] propValues;
+/*
+                // @todo should attribute value be interpreted as LIST type (i.e. multi-valued property)?
+                String[] strings = Text.explode(attrValue, ' ', true);
+                propValues = new Value[strings.length];
+                for (int j = 0; j < strings.length; j++) {
+                    // decode encoded blanks in value
+                    strings[j] = Text.replace(strings[j], "_x0020_", " ");
+                    propValues[j] = new StringValue(strings[j]);
+                }
+*/
+                if (propName.equals(JCR_PRIMARYTYPE)) {
+                    // jcr:primaryType
+                    try {
+                        nodeTypeName = QName.fromJCRName(attrValue, nsContext);
+                    } catch (BaseException be) {
+                        throw new SAXException("illegal jcr:primaryType value: " + attrValue, be);
+                    }
+                } else if (propName.equals(JCR_MIXINTYPES)) {
+                    // jcr:mixinTypes
+                    try {
+                        mixinTypes = new QName[]{QName.fromJCRName(attrValue, nsContext)};
+                    } catch (BaseException be) {
+                        throw new SAXException("illegal jcr:mixinTypes value: " + attrValue, be);
+                    }
+                } else if (propName.equals(JCR_UUID)) {
+                    // jcr:uuid
+                    uuid = attrValue;
+                } else {
+                    propValues = new Value[]{new StringValue(atts.getValue(i))};
+                    props.add(new Importer.PropInfo(propName, PropertyType.STRING, propValues));
+                }
+
+            Importer.NodeInfo nodeInfo =
+                    new Importer.NodeInfo(nodeName, nodeTypeName, mixinTypes, uuid);
+            // all information has been collected, now delegate to importer
+            importer.startNode(nodeInfo, props, nsContext);
+            // push current node data onto stack
+            stack.push(nodeInfo);
-            addTextNode((NodeImpl) parents.peek(), text.toString());
+            onTextNode(text.toString());
-        parents.pop();
+        Importer.NodeInfo node = (Importer.NodeInfo) stack.peek();
+        try {
+            // call Importer
+            importer.endNode(node);
+        } catch (RepositoryException re) {
+            throw new SAXException(re);
+        }
+        // we're done with this node, pop it from stack
+        stack.pop();
+    }
+
+    /**
+     * @see ContentHandler#endDocument()
+     */
+    public void endDocument() throws SAXException {
+        try {
+            importer.end();
+        } catch (RepositoryException re) {
+            throw new SAXException(re);
+        }

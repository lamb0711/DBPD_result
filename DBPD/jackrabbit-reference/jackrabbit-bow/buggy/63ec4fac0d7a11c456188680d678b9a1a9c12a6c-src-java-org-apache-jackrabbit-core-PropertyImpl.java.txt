redesigned transaction support & PersistenceManager

orginal code contributed by dominique pfister, required a lot of tweaking to make it run & work; not thoroughly tested

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@126221 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.state.ItemState;
-import org.apache.jackrabbit.core.state.ItemStateException;
-import org.apache.jackrabbit.core.state.PersistentPropertyState;
-import org.apache.jackrabbit.core.state.PropertyState;
+import org.apache.jackrabbit.core.state.*;
-                        itemStateMgr.createTransientPropertyState((PropertyState) state, ItemState.STATUS_EXISTING_MODIFIED);
+                        stateMgr.createTransientPropertyState((PropertyState) state, ItemState.STATUS_EXISTING_MODIFIED);
-    protected void makePersistent() throws RepositoryException {
+    protected void makePersistent(UpdateOperation update) {
-            String msg = "there's no transient state to persist";
-            log.error(msg);
-            throw new RepositoryException(msg);
+            log.debug(safeGetJCRPath() + " (" + id + "): there's no transient state to persist");
+            return;
-        try {
-            PropertyState transientState = (PropertyState) state;
-            PersistentPropertyState persistentState = (PersistentPropertyState) transientState.getOverlayedState();
-            if (persistentState == null) {
-                // this property is 'new'
-                persistentState = itemStateMgr.createPersistentPropertyState(transientState.getParentUUID(), transientState.getName());
-            }
-            // copy state from transient state
-            persistentState.setDefinitionId(transientState.getDefinitionId());
-            persistentState.setType(transientState.getType());
-            persistentState.setMultiValued(transientState.isMultiValued());
-            persistentState.setValues(transientState.getValues());
-            // make state persistent
-            persistentState.store();
-            // remove listener from transient state
-            transientState.removeListener(this);
-            // add listener to persistent state
-            persistentState.addListener(this);
-            // swap transient state with persistent state
-            state = persistentState;
-            // reset status
-            status = STATUS_NORMAL;
-        } catch (ItemStateException ise) {
-            String msg = "failed to persist transient state of " + safeGetJCRPath();
-            log.error(msg, ise);
-            throw new RepositoryException(msg, ise);
+        PropertyState transientState = (PropertyState) state;
+        PropertyState persistentState = (PropertyState) transientState.getOverlayedState();
+        if (persistentState == null) {
+            // this property is 'new'
+            persistentState = update.createNew(
+                    transientState.getName(),
+                    transientState.getParentUUID());
+        // copy state from transient state
+        persistentState.setDefinitionId(transientState.getDefinitionId());
+        persistentState.setType(transientState.getType());
+        persistentState.setMultiValued(transientState.isMultiValued());
+        persistentState.setValues(transientState.getValues());
+        // make state persistent
+        update.store(persistentState);
+        // remove listener from transient state
+        transientState.removeListener(this);
+        // add listener to persistent state
+        persistentState.addListener(this);
+        // swap transient state with persistent state
+        state = persistentState;
+        // reset status
+        status = STATUS_NORMAL;
-        if (!((NodeImpl) getParent()).isCheckedOut(false)) { // only cheep call yet
+        if (!((NodeImpl) getParent()).isCheckedOut(false)) { // only cheap call yet
-        if (!((NodeImpl) getParent()).isCheckedOut(false)) { // only cheep call yet
+        if (!((NodeImpl) getParent()).isCheckedOut(false)) { // only cheap call yet
-        if (!((NodeImpl) getParent()).isCheckedOut(false)) { // only cheep call yet
+        if (!((NodeImpl) getParent()).isCheckedOut(false)) { // only cheap call yet
-        if (!((NodeImpl) getParent()).isCheckedOut(false)) { // only cheep call yet
+        if (!((NodeImpl) getParent()).isCheckedOut(false)) { // only cheap call yet
-        if (!((NodeImpl) getParent()).isCheckedOut(false)) { // only cheep call yet
+        if (!((NodeImpl) getParent()).isCheckedOut(false)) { // only cheap call yet
-        if (!((NodeImpl) getParent()).isCheckedOut(false)) { // only cheep call yet
+        if (!((NodeImpl) getParent()).isCheckedOut(false)) { // only cheap call yet
-        if (!((NodeImpl) getParent()).isCheckedOut(false)) { // only cheep call yet
+        if (!((NodeImpl) getParent()).isCheckedOut(false)) { // only cheap call yet
-        if (!((NodeImpl) getParent()).isCheckedOut(false)) { // only cheep call yet
+        if (!((NodeImpl) getParent()).isCheckedOut(false)) { // only cheap call yet
-        if (!((NodeImpl) getParent()).isCheckedOut(false)) { // only cheep call yet
+        if (!((NodeImpl) getParent()).isCheckedOut(false)) { // only cheap call yet
-        if (!((NodeImpl) getParent()).isCheckedOut(false)) { // only cheep call yet
+        if (!((NodeImpl) getParent()).isCheckedOut(false)) { // only cheap call yet
-        if (!((NodeImpl) getParent()).isCheckedOut(false)) { // only cheep call yet
+        if (!((NodeImpl) getParent()).isCheckedOut(false)) { // only cheap call yet
-        if (!((NodeImpl) getParent()).isCheckedOut(false)) { // only cheep call yet
+        if (!((NodeImpl) getParent()).isCheckedOut(false)) { // only cheap call yet

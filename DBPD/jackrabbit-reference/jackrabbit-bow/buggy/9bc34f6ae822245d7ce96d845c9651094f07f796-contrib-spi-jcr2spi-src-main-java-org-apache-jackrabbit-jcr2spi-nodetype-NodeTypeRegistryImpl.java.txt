- new interface EffectiveNodeTypeProvider
- new interface ItemDefinitionProvider
- limit access to NodeTypeRegistry and simplify the NodeTypeRegistry
  interface.
- avoid duplicate code dealing with logic of EffectiveNodeType
  and retrieval of QItemDefinitions.


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@520408 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.state.NodeState;
+import org.apache.jackrabbit.jcr2spi.state.Status;
+import org.apache.jackrabbit.jcr2spi.hierarchy.PropertyEntry;
+import javax.jcr.nodetype.ConstraintViolationException;
-public class NodeTypeRegistryImpl implements Dumpable, NodeTypeRegistry {
+public class NodeTypeRegistryImpl implements Dumpable, NodeTypeRegistry, EffectiveNodeTypeProvider {
-
-
+    //---------------------------------------------------< NodeTypeRegistry >---
-     * @inheritDoc
+     * @see NodeTypeRegistry#addListener(NodeTypeRegistryListener)
-     * @inheritDoc
+     * @see NodeTypeRegistry#removeListener(NodeTypeRegistryListener)
-     * @inheritDoc
+     * @see NodeTypeRegistry#getRegisteredNodeTypes()
-     * @inheritDoc
+     * @see NodeTypeRegistry#isRegistered(QName)
-    /**
-     * @inheritDoc
+   /**
+     * @see NodeTypeRegistry#registerNodeType(QNodeTypeDefinition)
-    public QNodeDefinition getRootNodeDef() {
-        return rootNodeDef;
+    public synchronized EffectiveNodeType registerNodeType(QNodeTypeDefinition ntDef)
+            throws InvalidNodeTypeDefException, RepositoryException {
+        // validate the new nodetype definition
+        EffectiveNodeTypeImpl ent = validator.validateNodeTypeDef(ntDef, registeredNTDefs);
+
+        // persist new node type definition
+        storage.registerNodeTypes(new QNodeTypeDefinition[] {ntDef});
+
+        // update internal caches
+        internalRegister(ntDef, ent);
+
+        // notify listeners
+        notifyRegistered(ntDef.getQName());
+        return ent;
-     * @inheritDoc
+     * @see NodeTypeRegistry#registerNodeTypes(Collection)
+     */
+    public synchronized void registerNodeTypes(Collection ntDefs)
+            throws InvalidNodeTypeDefException, RepositoryException {
+
+        // validate new nodetype definitions
+        Map defMap = validator.validateNodeTypeDefs(ntDefs, registeredNTDefs);
+        storage.registerNodeTypes((QNodeTypeDefinition[])ntDefs.toArray(new QNodeTypeDefinition[ntDefs.size()]));
+
+        // update internal cache
+        internalRegister(defMap);
+
+        // notify listeners
+        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
+            QName ntName = ((QNodeTypeDefinition)iter.next()).getQName();
+            notifyRegistered(ntName);
+        }
+    }
+
+    /**
+     * @see NodeTypeRegistry#unregisterNodeType(QName)
+     */
+    public void unregisterNodeType(QName nodeTypeName) throws NoSuchNodeTypeException, RepositoryException {
+        HashSet ntNames = new HashSet();
+        ntNames.add(nodeTypeName);
+        unregisterNodeTypes(ntNames);
+    }
+
+    /**
+     * @see NodeTypeRegistry#unregisterNodeTypes(Collection)
+     */
+    public synchronized void unregisterNodeTypes(Collection nodeTypeNames)
+            throws NoSuchNodeTypeException, RepositoryException {
+        // do some preliminary checks
+        for (Iterator iter = nodeTypeNames.iterator(); iter.hasNext();) {
+            QName ntName = (QName) iter.next();
+            if (!registeredNTDefs.containsKey(ntName)) {
+                throw new NoSuchNodeTypeException(ntName.toString());
+            }
+
+            // check for node types other than those to be unregistered
+            // that depend on the given node types
+            Set dependents = getDependentNodeTypes(ntName);
+            dependents.removeAll(nodeTypeNames);
+            if (dependents.size() > 0) {
+                StringBuffer msg = new StringBuffer();
+                msg.append(ntName
+                        + " can not be removed because the following node types depend on it: ");
+                for (Iterator depIter = dependents.iterator(); depIter.hasNext();) {
+                    msg.append(depIter.next());
+                    msg.append(" ");
+                }
+                throw new RepositoryException(msg.toString());
+            }
+        }
+
+        // persist removal of node type definitions
+        // NOTE: conflict with existing content not asserted on client
+        storage.unregisterNodeTypes((QName[]) nodeTypeNames.toArray(new QName[nodeTypeNames.size()]));
+
+
+        // all preconditions are met, node types can now safely be unregistered
+        internalUnregister(nodeTypeNames);
+
+        // notify listeners
+        for (Iterator iter = nodeTypeNames.iterator(); iter.hasNext();) {
+            QName ntName = (QName) iter.next();
+            notifyUnregistered(ntName);
+        }
+    }
+
+    /**
+     * @see NodeTypeRegistry#reregisterNodeType(QNodeTypeDefinition)
+     */
+    public synchronized EffectiveNodeType reregisterNodeType(QNodeTypeDefinition ntd)
+            throws NoSuchNodeTypeException, InvalidNodeTypeDefException,
+            RepositoryException {
+        QName name = ntd.getQName();
+        if (!registeredNTDefs.containsKey(name)) {
+            throw new NoSuchNodeTypeException(name.toString());
+        }
+        /* validate new node type definition */
+        EffectiveNodeTypeImpl ent = validator.validateNodeTypeDef(ntd, registeredNTDefs);
+
+        // first call reregistering on storage
+        storage.reregisterNodeTypes(new QNodeTypeDefinition[]{ntd});
+
+        // unregister old node type definition
+        internalUnregister(name);
+        // register new definition
+        internalRegister(ntd, ent);
+
+        // notify listeners
+        notifyReRegistered(name);
+        return ent;
+    }
+
+    /**
+     * @see NodeTypeRegistry#getNodeTypeDefinition(QName)
+     */
+    public QNodeTypeDefinition getNodeTypeDefinition(QName nodeTypeName)
+        throws NoSuchNodeTypeException {
+        QNodeTypeDefinition def = (QNodeTypeDefinition) registeredNTDefs.get(nodeTypeName);
+        if (def == null) {
+            throw new NoSuchNodeTypeException(nodeTypeName.toString());
+        }
+        return def;
+    }
+    //------------------------------------------< EffectiveNodeTypeProvider >---
+    /**
+     * @see EffectiveNodeTypeProvider#getEffectiveNodeType(QName)
-     * @inheritDoc
+     * @see EffectiveNodeTypeProvider#getEffectiveNodeType(QName[])
-     * @inheritDoc
+     * @see EffectiveNodeTypeProvider#getEffectiveNodeType(QName[], Map)
+     * @see EffectiveNodeTypeProvider#getEffectiveNodeType(NodeState)
+     * @inheritDoc
+     * In case the status of the given node state is not {@link Status#EXISTING}
+     * the transiently added mixin types are taken into account as well.
+     */
+    public EffectiveNodeType getEffectiveNodeType(NodeState nodeState) throws ConstraintViolationException, NoSuchNodeTypeException {
+        try {
+            QName[] allNtNames;
+            if (nodeState.getStatus() == Status.EXISTING) {
+                allNtNames = nodeState.getNodeTypeNames();
+            } else {
+                // TODO: check if correct (and only used for creating new)
+                QName primaryType = nodeState.getNodeTypeName();
+                allNtNames = new QName[] { primaryType }; // default
+                PropertyEntry mixins = nodeState.getNodeEntry().getPropertyEntry(QName.JCR_MIXINTYPES);
+                if (mixins != null) {
+                    try {
+                        QValue[] values = mixins.getPropertyState().getValues();
+                        allNtNames = new QName[values.length + 1];
+                        for (int i = 0; i < values.length; i++) {
+                            allNtNames[i] = values[i].getQName();
+                        }
+                        allNtNames[values.length] = primaryType;
+                    } catch (RepositoryException e) {
+                        // ignore
+                    }
+                }
+            }
+            return getEffectiveNodeType(allNtNames);
+        } catch (NodeTypeConflictException e) {
+            String msg = "Internal error: failed to build effective node type from node types defined with " + nodeState;
+            log.debug(msg);
+            throw new ConstraintViolationException(msg, e);
+        }
+    }
+
+    /**
-    /**
-     * @inheritDoc
-     */
-    public synchronized EffectiveNodeType registerNodeType(QNodeTypeDefinition ntDef)
-            throws InvalidNodeTypeDefException, RepositoryException {
-        // validate the new nodetype definition
-        EffectiveNodeTypeImpl ent = validator.validateNodeTypeDef(ntDef, registeredNTDefs);
-        // persist new node type definition
-        storage.registerNodeTypes(new QNodeTypeDefinition[] {ntDef});
-
-        // update internal caches
-        internalRegister(ntDef, ent);
-
-        // notify listeners
-        notifyRegistered(ntDef.getQName());
-        return ent;
-    }
-
-    /**
-     * @inheritDoc
-     */
-    public synchronized void registerNodeTypes(Collection ntDefs)
-            throws InvalidNodeTypeDefException, RepositoryException {
-
-        // validate new nodetype definitions
-        Map defMap = validator.validateNodeTypeDefs(ntDefs, registeredNTDefs);
-        storage.registerNodeTypes((QNodeTypeDefinition[])ntDefs.toArray(new QNodeTypeDefinition[ntDefs.size()]));
-
-        // update internal cache
-        internalRegister(defMap);
-
-        // notify listeners
-        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
-            QName ntName = ((QNodeTypeDefinition)iter.next()).getQName();
-            notifyRegistered(ntName);
-        }
-    }
-
-    /**
-     * @inheritDoc
-     */
-    public void unregisterNodeType(QName nodeTypeName) throws NoSuchNodeTypeException, RepositoryException {
-        HashSet ntNames = new HashSet();
-        ntNames.add(nodeTypeName);
-        unregisterNodeTypes(ntNames);
-    }
-
-    /**
-     * @inheritDoc
-     */
-    public synchronized void unregisterNodeTypes(Collection nodeTypeNames)
-            throws NoSuchNodeTypeException, RepositoryException {
-        // do some preliminary checks
-        for (Iterator iter = nodeTypeNames.iterator(); iter.hasNext();) {
-            QName ntName = (QName) iter.next();
-            if (!registeredNTDefs.containsKey(ntName)) {
-                throw new NoSuchNodeTypeException(ntName.toString());
-            }
-
-            // check for node types other than those to be unregistered
-            // that depend on the given node types
-            Set dependents = getDependentNodeTypes(ntName);
-            dependents.removeAll(nodeTypeNames);
-            if (dependents.size() > 0) {
-                StringBuffer msg = new StringBuffer();
-                msg.append(ntName
-                        + " can not be removed because the following node types depend on it: ");
-                for (Iterator depIter = dependents.iterator(); depIter.hasNext();) {
-                    msg.append(depIter.next());
-                    msg.append(" ");
-                }
-                throw new RepositoryException(msg.toString());
-            }
-        }
-
-        // persist removal of node type definitions
-        // NOTE: conflict with existing content not asserted on client
-        storage.unregisterNodeTypes((QName[]) nodeTypeNames.toArray(new QName[nodeTypeNames.size()]));
-
-
-        // all preconditions are met, node types can now safely be unregistered
-        internalUnregister(nodeTypeNames);
-
-        // notify listeners
-        for (Iterator iter = nodeTypeNames.iterator(); iter.hasNext();) {
-            QName ntName = (QName) iter.next();
-            notifyUnregistered(ntName);
-        }
-    }
-
-    /**
-     * @inheritDoc
-     */
-    public synchronized EffectiveNodeType reregisterNodeType(QNodeTypeDefinition ntd)
-            throws NoSuchNodeTypeException, InvalidNodeTypeDefException,
-            RepositoryException {
-        QName name = ntd.getQName();
-        if (!registeredNTDefs.containsKey(name)) {
-            throw new NoSuchNodeTypeException(name.toString());
-        }
-        /* validate new node type definition */
-        EffectiveNodeTypeImpl ent = validator.validateNodeTypeDef(ntd, registeredNTDefs);
-
-        // first call reregistering on storage
-        storage.reregisterNodeTypes(new QNodeTypeDefinition[]{ntd});
-
-        // unregister old node type definition
-        internalUnregister(name);
-        // register new definition
-        internalRegister(ntd, ent);
-
-        // notify listeners
-        notifyReRegistered(name);
-        return ent;
-    }
-
-    /**
-     * @inheritDoc
-     */
-    public QNodeTypeDefinition getNodeTypeDefinition(QName nodeTypeName)
-        throws NoSuchNodeTypeException {
-        QNodeTypeDefinition def = (QNodeTypeDefinition) registeredNTDefs.get(nodeTypeName);
-        if (def == null) {
-            throw new NoSuchNodeTypeException(nodeTypeName.toString());
-        }
-        return def;
-    }

JCR-890: concurrent read-only access to a session

Streamline the new ItemSaveOperation and related classes.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@957189 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Iterator;
+import java.util.SortedMap;
+import java.util.TreeMap;
-import org.apache.commons.collections.iterators.IteratorChain;
-     * Returns an iterator over those transient item state instances that are
-     * direct or indirect descendants of the item state with the given
-     * <code>parentId</code>. The transient item state instance with the given
-     * <code>parentId</code> itself (if there is such) will not be included.
-     * <p/>
+     * Returns a collection of those transient item state instances that are
+     * direct or indirect descendants of the item state with the given parent.
+     * The transient item state instance with the given identifier itself
+     * (if there is such) will not be included.
+     * <p>
-     * @param parentId the id of the common parent of the transient item state
-     *                 instances to be returned.
-     * @return an iterator over descendant transient item state instances
+     * @param id identifier of the common parent of the transient item state
+     *           instances to be returned
+     * @return collection of descendant transient item state instances
-    public Iterator<ItemState> getDescendantTransientItemStates(NodeId parentId)
+    public Collection<ItemState> getDescendantTransientItemStates(ItemId id)
-        if (transientStore.isEmpty()) {
-            List<ItemState> empty = Collections.emptyList();
-            return empty.iterator();
-        }
-
-        // build ordered collection of descendant transient states
-        // sorted by decreasing relative depth
-
-        // use an array of lists to group the descendants by relative depth;
-        // the depth is used as array index
-        List[] la = new List[10];
-            HierarchyManager atticAware = getAtticAwareHierarchyMgr();
-            for (ItemState state : transientStore.values()) {
-                // determine relative depth: > 0 means it's a descendant
-                int depth;
-                try {
-                    depth = atticAware.getShareRelativeDepth(parentId, state.getId());
-                } catch (ItemNotFoundException infe) {
-                    /**
-                     * one of the parents of the specified item has been
-                     * removed externally; as we don't know its path,
-                     * we can't determine if it is a descendant;
-                     * InvalidItemStateException should only be thrown if
-                     * a descendant is affected;
-                     * => throw InvalidItemStateException for now
-                     * todo FIXME
-                     */
-                    // unable to determine relative depth, assume that the item
-                    // (or any of its ancestors) has been removed externally
-                    String msg = state.getId()
-                            + ": the item seems to have been removed externally.";
-                    log.debug(msg);
-                    throw new InvalidItemStateException(msg);
-                }
-
-                if (depth < 1) {
-                    // not a descendant
-                    continue;
-                }
-
-                // ensure capacity
-                if (depth > la.length) {
-                    List[] old = la;
-                    la = new List[depth + 10];
-                    System.arraycopy(old, 0, la, 0, old.length);
-                }
-
-                List list = la[depth - 1];
-                if (list == null) {
-                    list = new ArrayList();
-                    la[depth - 1] = list;
-                }
-                list.add(state);
-            }
-        } catch (RepositoryException re) {
-            log.warn("inconsistent hierarchy state", re);
+            return getDescendantItemStates(
+                    id, transientStore, getAtticAwareHierarchyMgr());
+        } catch (ItemNotFoundException e) {
+            // one of the parents of the specified item has been
+            // removed externally; as we don't know its path,
+            // we can't determine if it is a descendant;
+            // InvalidItemStateException should only be thrown if
+            // a descendant is affected;
+            // => throw InvalidItemStateException for now (FIXME)
+            // unable to determine relative depth, assume that the item
+            // (or any of its ancestors) has been removed externally
+            throw new InvalidItemStateException(
+                    "Item seems to have been removed externally", e);
-        // create an iterator over the collected descendants
-        // in decreasing depth order
-        IteratorChain resultIter = new IteratorChain();
-        for (int i = la.length - 1; i >= 0; i--) {
-            List list = la[i];
-            if (list != null) {
-                resultIter.addIterator(list.iterator());
-            }
-        }
-        /**
-         * if the resulting iterator chain is empty return
-         * EMPTY_LIST.iterator() instead because older versions
-         * of IteratorChain (pre Commons Collections 3.1)
-         * would throw UnsupportedOperationException in this
-         * situation
-         */
-        if (resultIter.getIterators().isEmpty()) {
-            List<ItemState> empty = Collections.emptyList();
-            return empty.iterator();
-        }
-        return resultIter;
-     * @param parentId the id of the common parent of the transient item state
-     *                 instances to be returned.
-     * @return an iterator over descendant transient item state instances in the attic
+     * @param id identifier of the common parent of the transient item state
+     *           instances to be returned
+     * @return collection of descendant transient item state instances
+     *         in the attic
-    public Iterator<ItemState> getDescendantTransientItemStatesInAttic(NodeId parentId) {
-        if (atticStore.isEmpty()) {
-            List<ItemState> empty = Collections.emptyList();
-            return empty.iterator();
-        }
+    public Iterable<ItemState> getDescendantTransientItemStatesInAttic(
+            ItemId id) throws RepositoryException {
+        return getDescendantItemStates(
+                id, atticStore,
+                new ZombieHierarchyManager(hierMgr, this, getAttic()));
+    }
-        // build ordered collection of descendant transient states in attic
-        // sorted by decreasing relative depth
-
-        // use a special attic-aware hierarchy manager
-        ZombieHierarchyManager zombieHierMgr =
-            new ZombieHierarchyManager(hierMgr, this, getAttic());
-
-        // use an array of lists to group the descendants by relative depth;
-        // the depth is used as array index
-        List[] la = new List[10];
-        try {
-            for (ItemState state : atticStore.values()) {
+    /**
+     * Utility method used by the
+     * {@link #getDescendantTransientItemStates(ItemId)} and
+     * {@link #getDescendantTransientItemStatesInAttic(ItemId)} methods
+     * to collect descendant item states from the given item state store.
+     *
+     * @param id identifier of the parent item
+     * @param store item state store
+     * @param hierarchyManager hierarchy manager associated with the store
+     * @return descendants of the identified item
+     * @throws RepositoryException if the descendants could not be accessed
+     */
+    private List<ItemState> getDescendantItemStates(
+            ItemId id, ItemStateStore store, HierarchyManager hierarchyManager)
+            throws RepositoryException {
+        if (id.denotesNode() && !store.isEmpty()) {
+            // Group the descendants by reverse relative depth
+            SortedMap<Integer, Collection<ItemState>> statesByReverseDepth =
+                new TreeMap<Integer, Collection<ItemState>>();
+            for (ItemState state : store.values()) {
-                //int depth = zombieHierMgr.getRelativeDepth(parentId, state.getId());
-                int depth = zombieHierMgr.getShareRelativeDepth(parentId, state.getId());
-                if (depth < 1) {
-                    // not a descendant
-                    continue;
+                int depth = hierarchyManager.getShareRelativeDepth(
+                        (NodeId) id, state.getId());
+                if (depth > 0) {
+                    Collection<ItemState> statesAtDepth =
+                        statesByReverseDepth.get(-depth);
+                    if (statesAtDepth == null) {
+                        statesAtDepth = new ArrayList<ItemState>();
+                        statesByReverseDepth.put(-depth, statesAtDepth);
+                    }
+                    statesAtDepth.add(state);
-
-                // ensure capacity
-                if (depth > la.length) {
-                    List[] old = la;
-                    la = new List[depth + 10];
-                    System.arraycopy(old, 0, la, 0, old.length);
-                }
-
-                List list = la[depth - 1];
-                if (list == null) {
-                    list = new ArrayList();
-                    la[depth - 1] = list;
-                }
-                list.add(state);
-        } catch (RepositoryException re) {
-            log.warn("inconsistent hierarchy state", re);
-        }
-        // create an iterator over the collected descendants
-        // in decreasing depth order
-        IteratorChain resultIter = new IteratorChain();
-        for (int i = la.length - 1; i >= 0; i--) {
-            List list = la[i];
-            if (list != null) {
-                resultIter.addIterator(list.iterator());
+
+            // Collect the descendants in decreasing depth order
+            List<ItemState> descendants = new ArrayList<ItemState>();
+            for (Collection<ItemState> statesAtDepth
+                    : statesByReverseDepth.values()) {
+                descendants.addAll(statesAtDepth);
+            return descendants;
+        } else {
+            return Collections.emptyList();
-        /**
-         * if the resulting iterator chain is empty return
-         * EMPTY_LIST.iterator() instead because older versions
-         * of IteratorChain (pre Commons Collections 3.1)
-         * would throw UnsupportedOperationException in this
-         * situation
-         */
-        if (resultIter.getIterators().isEmpty()) {
-            List<ItemState> empty = Collections.emptyList();
-            return empty.iterator();
-        }
-        return resultIter;

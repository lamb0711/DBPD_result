JCR-314: Fine grained locking in SharedItemStateManager

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@540944 13f79535-47bb-0310-9956-ffa450edef68

-import EDU.oswego.cs.dl.util.concurrent.ReadWriteLock;
-import EDU.oswego.cs.dl.util.concurrent.ReentrantWriterPreferenceReadWriteLock;
-    private final ItemStateReferenceCache cache;
+    private final ItemStateCache cache;
-     * JCR-447: deadlock might occur when this manager is still write-locked and events are dispatched.
-     */
-    private boolean noLockHack = false;
-
-    /**
-     * Read-/Write-Lock to synchronize access on this item state manager.
+     * The locking strategy.
-    private final ReadWriteLock rwLock =
-            new ReentrantWriterPreferenceReadWriteLock() {
-                /**
-                 * Allow reader when there is no active writer, or current
-                 * thread owns the write lock (reentrant).
-                 * <p/>
-                 * the 'noLockHack' is only temporary (hopefully)
-                 */
-                protected boolean allowReader() {
-                    return activeWriter_ == null
-                        || activeWriter_ == Thread.currentThread()
-                        || noLockHack;
-                }
-            };
+    private ISMLocking ismLocking;
+        this.ismLocking = new DefaultISMLocking();
-        this.noLockHack = noLockHack;
+        if (ismLocking instanceof DefaultISMLocking) {
+            ((DefaultISMLocking) ismLocking).setNoLockHack(noLockHack);
+        }
+    /**
+     * Sets a new locking strategy.
+     *
+     * @param ismLocking the locking strategy for this item state manager.
+     */
+    public void setISMLocking(ISMLocking ismLocking) {
+        if (ismLocking == null) {
+            throw new NullPointerException();
+        }
+        this.ismLocking = ismLocking;
+    }
+
-        acquireReadLock();
+        ISMLocking.ReadLock readLock = acquireReadLock(id);
-            rwLock.readLock().release();
+            readLock.release();
+        ISMLocking.ReadLock readLock;
-            acquireReadLock();
+            readLock = acquireReadLock(id);
-            rwLock.readLock().release();
+            readLock.release();
-        acquireReadLock();
+        ISMLocking.ReadLock readLock = acquireReadLock(id.getTargetId());
-            rwLock.readLock().release();
+            readLock.release();
+        ISMLocking.ReadLock readLock;
-            acquireReadLock();
+            readLock = acquireReadLock(id.getTargetId());
-            rwLock.readLock().release();
+            readLock.release();
-        ps.println();
-        ps.print("[referenceCache] ");
-        cache.dump(ps);
+        if (cache instanceof Dumpable) {
+            ps.println();
+            ps.print("[referenceCache] ");
+            ((Dumpable) cache).dump(ps);
+        }
-         * Flag indicating whether we are holding write lock.
+         * The write lock we currently hold or <code>null</code> if none is
+         * hold.
-        private boolean holdingWriteLock;
+        private ISMLocking.WriteLock writeLock;
-                acquireWriteLock();
-                holdingWriteLock = true;
+                writeLock = acquireWriteLock(local);
-                if (!holdingWriteLock && eventChannel != null) {
+                if (writeLock == null && eventChannel != null) {
+            ISMLocking.ReadLock readLock = null;
-                acquireReadLock();
-                rwLock.writeLock().release();
-                holdingWriteLock = false;
+                readLock = writeLock.downgrade();
+                writeLock = null;
+            } catch (InterruptedException e) {
+                throw new ItemStateException("Interrupted while downgrading to read lock");
-                if (holdingWriteLock) {
+                if (writeLock != null) {
-                    rwLock.writeLock().release();
-                    holdingWriteLock = false;
-                } else {
-                    rwLock.readLock().release();
+                    writeLock.release();
+                    writeLock = null;
+                } else if (readLock != null) {
+                    readLock.release();
-                if (holdingWriteLock) {
-                    rwLock.writeLock().release();
-                    holdingWriteLock = false;
+                if (writeLock != null) {
+                    writeLock.release();
+                    writeLock = null;
+        ISMLocking.WriteLock wLock = null;
-            acquireWriteLock();
+            wLock = acquireWriteLock(external);
+        ISMLocking.ReadLock rLock = null;
-            acquireReadLock();
-            rwLock.writeLock().release();
-            holdingWriteLock = false;
-
-            events.dispatch();
-        } catch (ItemStateException e) {
+            if (wLock != null) {
+                rLock = wLock.downgrade();
+                holdingWriteLock = false;
+                events.dispatch();
+            }
+        } catch (InterruptedException e) {
-                rwLock.writeLock().release();
-                holdingWriteLock = false;
+                if (wLock != null) {
+                    wLock.release();
+                }
-                rwLock.readLock().release();
+                if (rLock != null) {
+                    rLock.release();
+                }
+     * @param id the id of the item for which to acquire a read lock.
-    private void acquireReadLock() throws ItemStateException {
+    private ISMLocking.ReadLock acquireReadLock(ItemId id) throws ItemStateException {
-            rwLock.readLock().acquire();
+            return ismLocking.acquireReadLock(id);
+     * @param changeLog the change log for which to acquire a write lock.
-    private void acquireWriteLock() throws ItemStateException {
+    private ISMLocking.WriteLock acquireWriteLock(ChangeLog changeLog) throws ItemStateException {
-            rwLock.writeLock().acquire();
+            return ismLocking.acquireWriteLock(changeLog);

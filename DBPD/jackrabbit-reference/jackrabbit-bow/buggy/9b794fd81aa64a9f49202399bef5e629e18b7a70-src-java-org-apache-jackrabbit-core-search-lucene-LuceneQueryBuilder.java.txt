Added SQL and XPath query implementation. The implementation is not complete yet. Only basic operations are supported.
Also added postGoals to the maven.xml to generate the parser classes for SQL XPath.

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@123135 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.MalformedPathException;
-import org.apache.jackrabbit.core.Path;
+import org.apache.jackrabbit.core.QName;
+import org.apache.jackrabbit.core.NoPrefixDeclaredException;
+import org.apache.jackrabbit.core.NamespaceRegistryImpl;
+    private static QName primaryType = new QName(NamespaceRegistryImpl.NS_JCR_URI, "primaryType");
+
-        Query constraintQuery = (Query) node.getConstraintNode().accept(this, null);
-        if (constraintQuery != null) {
-            root.add(constraintQuery, true, false);
-        }
-        TextsearchQueryNode textsearchNode = node.getTextsearchNode();
-        if (textsearchNode != null) {
-            Query textsearch = (Query) textsearchNode.accept(this, null);
-            if (textsearch != null) {
-                root.add(textsearch, true, false);
-            }
-        }
-
+        try {
+            // first select any node
+            notQuery.add(new MatchAllQuery(primaryType.toJCRName(nsMappings)),
+                    false, false);
+        } catch (NoPrefixDeclaredException e) {
+            // will never happen, prefixes are created when unknown
+        }
+            // then prohibit the nodes from the not clause
-        PathQuery pathQuery = null;
-        try {
-            // FIXME what about relative path?
-            Path p = Path.create(node.getPath(),
-                    session.getNamespaceResolver(), false);
-            pathQuery = new PathQuery(p, nsMappings, node.getType());
-        } catch (MalformedPathException e) {
-            exceptions.add(e);
+        Query context = null;
+        // loop over steps
+        QueryNode[] steps = node.getPathSteps();
+        for (int i = 0; i < steps.length; i++) {
+            context = (Query) steps[i].accept(this, context);
-        if (pathQuery != null && pathQuery.getClauses().length > 0) {
-            BooleanQuery combined = new BooleanQuery();
-            combined.add(pathQuery, true, false);
-            combined.add((Query) data, true, false);
-            return combined;
+        if (data instanceof BooleanQuery) {
+            BooleanQuery constraint = (BooleanQuery) data;
+            if (constraint.getClauses().length > 0) {
+                constraint.add(context, true, false);
+                context = constraint;
+            }
+        }
+        return context;
+    }
+
+    public Object visit(LocationStepQueryNode node, Object data) {
+        if (node.getNameTest() != null && node.getNameTest().length() == 0) {
+            // select root node
+            return new TermQuery(new Term(FieldNames.PARENT, ""));
+        }
+
+        Query context = (Query) data;
+
+        BooleanQuery andQuery = new BooleanQuery();
+        if (context == null) {
+            exceptions.add(new IllegalArgumentException("Unsupported query"));
+        }
+
+        // predicate on step?
+        Object[] predicates = node.acceptOperands(this, data);
+        for (int i = 0; i < predicates.length; i++) {
+            andQuery.add((Query) predicates[i], true, false);
+        }
+
+        TermQuery nameTest = null;
+        if (node.getNameTest() != null) {
+            try {
+                String internalName = nsMappings.translatePropertyName(node.getNameTest(),
+                        session.getNamespaceResolver());
+                nameTest = new TermQuery(new Term(FieldNames.LABEL, internalName));
+            } catch (IllegalNameException e) {
+                exceptions.add(e);
+            } catch (UnknownPrefixException e) {
+                exceptions.add(e);
+            }
+        }
+
+        if (node.getIncludeDescendants()) {
+            if (nameTest != null) {
+                andQuery.add(new DescendantSelfAxisQuery(context, nameTest), true, false);
+            } else {
+                // descendant-or-self with nametest=*
+                if (predicates.length > 0) {
+                    // if we have a predicate attached, the condition acts as
+                    // the sub query.
+                    Query subQuery = new DescendantSelfAxisQuery(context, andQuery);
+                    andQuery = new BooleanQuery();
+                    andQuery.add(subQuery, true, false);
+                } else {
+                    // @todo this will traverse the whole index, optimize!
+                    Query subQuery = new MatchAllQuery(FieldNames.UUID);
+                    andQuery.add(new DescendantSelfAxisQuery(context, subQuery), true, false);
+                }
+            }
-            return data;
+            // select child nodes
+            andQuery.add(new ChildAxisQuery(context), true, false);
+
+            // name test
+            if (nameTest != null) {
+                andQuery.add(nameTest, true, false);
+            }
+
+        return andQuery;
+                // @todo use MatchAllQuery if stringValue is "*" (or "%" ?)
-        return null;
+        return data;
-
-    //---------------------------< internal >-----------------------------------
-

JCR-2028: JSR 283 JCR Path

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@772659 13f79535-47bb-0310-9956-ffa450edef68

+    private static final int STATE_IDENTIFIER = 8;
+    private static final int STATE_URI = 9;
+    private static final int STATE_URI_END = 10;
-     * <code>resolver</code> to convert prefixes into namespace URI's.
+     * <code>resolver</code> to convert prefixes into namespace URI's. If
+     * resolver is <code>null</code> this method only checks the format of the
+     * passed String and returns <code>null</code>.
-     * @return qualified path.
+     * @return A path object.
-     * Parses the give <code>jcrPath</code> and returns a <code>Path</code>. If
+     * Parses <code>jcrPath</code> into a qualified path using
+     * <code>resolver</code> to convert prefixes into namespace URI's. If the
+     * specified <code>jcrPath</code> is an identifier based absolute path
+     * beginning with an identifier segment the specified
+     * <code>IdentifierResolver</code> will be used to resolve it to an
+     * absolute path.<p/>
+     * If <code>namResolver</code> is <code>null</code> or if <code>identifierResolver</code>
+     * is <code>null</code> and the path starts with an identifier segment, this
+     * method only checks the format of the string and returns <code>null</code>.
+     *
+     * @param jcrPath the jcr path.
+     * @param nameResolver the namespace resolver.
+     * @param identifierResolver the resolver to validate any trailing identifier
+     * segment and resolve to an absolute path.
+     * @param factory
+     * @return A path object.
+     * @throws MalformedPathException If the <code>jcrPath</code> is malformed.
+     * @throws IllegalNameException if any of the jcrNames is malformed.
+     * @throws NamespaceException If an unresolvable prefix is encountered.
+     * @since JCR 2.0
+     */
+    public static Path parse(String jcrPath, NameResolver nameResolver,
+                             IdentifierResolver identifierResolver, PathFactory factory)
+            throws MalformedPathException, IllegalNameException, NamespaceException {
+        return parse(null, jcrPath, nameResolver, identifierResolver, factory);
+    }
+
+    /**
+     * Parses <code>jcrPath</code> into a qualified path using
+     * <code>resolver</code> to convert prefixes into namespace URI's. If the
+     * specified <code>jcrPath</code> is an identifier based absolute path
+     * beginning with an identifier segment the specified
+     * <code>IdentifierResolver</code> will be used to resolve it to an
+     * absolute path.<p/>
+     * If <code>namResolver</code> is <code>null</code> or if <code>identifierResolver</code>
+     * is <code>null</code> and the path starts with an identifier segment, this
+     * method only checks the format of the string and returns <code>null</code>.
+     *
+     * @param jcrPath the jcr path.
+     * @param nameResolver the namespace resolver.
+     * @param identifierResolver the resolver to validate any trailing identifier
+     * segment and resolve to an absolute path.
+     * @param factory
+     * @param normalizeIdentifier
+     * @return A path object.
+     * @throws MalformedPathException If the <code>jcrPath</code> is malformed.
+     * @throws IllegalNameException if any of the jcrNames is malformed.
+     * @throws NamespaceException If an unresolvable prefix is encountered.
+     * @since JCR 2.0
+     */
+    public static Path parse(String jcrPath, NameResolver nameResolver,
+                             IdentifierResolver identifierResolver,
+                             PathFactory factory, boolean normalizeIdentifier)
+            throws MalformedPathException, IllegalNameException, NamespaceException {
+        return parse(null, jcrPath, nameResolver, identifierResolver, factory, normalizeIdentifier);
+    }
+
+    /**
+     * Parses the given <code>jcrPath</code> and returns a <code>Path</code>. If
-     * returned list. If <code>resolver</code> is <code>null</code>, this method
-     * only checks the format of the string and returns <code>null</code>.
+     * built path before it is returned. If <code>resolver</code> is
+     * <code>null</code>, this method only checks the format of the string and
+     * returns <code>null</code>.
-     * @return the fully qualified Path.
+     * @return the <code>Path</code> object.
+        return parse(parent, jcrPath, resolver, null, factory);
+    }
+
+    /**
+     * Parses the given <code>jcrPath</code> and returns a <code>Path</code>. If
+     * <code>parent</code> is not <code>null</code>, it is prepended to the
+     * built path before it is returned. If the specifed <code>jcrPath</code>
+     * is an identifier based absolute path beginning with an identifier segment
+     * the given <code>identifierResolver</code> will be used to resolve it to an
+     * absolute path.<p/>
+     * If <code>nameResolver</code> is <code>null</code> or if <code>identifierResolver</code>
+     * is <code>null</code> and the path starts with an identifier segment, this
+     * method only checks the format of the string and returns <code>null</code>.
+     *
+     * @param parent the parent path.
+     * @param jcrPath the jcr path.
+     * @param nameResolver the namespace resolver.
+     * @param identifierResolver the resolver to validate any trailing identifier
+     * segment and resolve it to an absolute path.
+     * @param factory The path factory.
+     * @return the <code>Path</code> object.
+     * @throws MalformedPathException
+     * @throws IllegalNameException
+     * @throws NamespaceException
+     */
+    public static Path parse(Path parent, String jcrPath, NameResolver nameResolver,
+                             IdentifierResolver identifierResolver, PathFactory factory)
+            throws MalformedPathException, IllegalNameException, NamespaceException {
+        return parse(parent, jcrPath, nameResolver, identifierResolver, factory, true);
+    }
+
+    /**
+     * Parses the given <code>jcrPath</code> and returns a <code>Path</code>. If
+     * <code>parent</code> is not <code>null</code>, it is prepended to the
+     * built path before it is returned. If the specifed <code>jcrPath</code>
+     * is an identifier based absolute path beginning with an identifier segment
+     * the given <code>identifierResolver</code> will be used to resolve it to an
+     * absolute path.<p/>
+     * If <code>nameResolver</code> is <code>null</code> or if <code>identifierResolver</code>
+     * is <code>null</code> and the path starts with an identifier segment, this
+     * method only checks the format of the string and returns <code>null</code>.
+     *
+     * @param parent the parent path.
+     * @param jcrPath the jcr path.
+     * @param nameResolver the namespace resolver.
+     * @param identifierResolver the resolver to validate any trailing identifier
+     * segment and resolve it to an absolute path.
+     * @param factory The path factory.
+     * @param normalizeIdentifier
+     * @return the <code>Path</code> object.
+     * @throws MalformedPathException
+     * @throws IllegalNameException
+     * @throws NamespaceException
+     */
+    private static Path parse(Path parent, String jcrPath, NameResolver nameResolver,
+                             IdentifierResolver identifierResolver, PathFactory factory,
+                             boolean normalizeIdentifier)
+            throws MalformedPathException, IllegalNameException, NamespaceException {
+        
-                throw new MalformedPathException("'" + jcrPath + "' is not a relative path");
+                throw new MalformedPathException("'" + jcrPath + "' is not a relative path.");
-        int state = STATE_PREFIX_START;
+        int state;
+        if (jcrPath.charAt(0) == '[') {
+            if (parent != null) {
+                throw new MalformedPathException("'" + jcrPath + "' is not a relative path.");
+            }
+            state = STATE_IDENTIFIER;
+            pos++;
+        } else {
+            state = STATE_PREFIX_START;
+        }
+
+
+
+        boolean checkFormat = (nameResolver == null);
+
-                            || state == STATE_INDEX_END) {
+                            || state == STATE_INDEX_END
+                            || state == STATE_URI_END) {
-                        if (resolver != null) {
-                            Name qName = resolver.getQName(name);
+                        if (checkFormat) {
+                            NameParser.checkFormat(name);
+                        } else {
+                            Name qName = nameResolver.getQName(name);
+                    } else if (state == STATE_IDENTIFIER) {
+                        if (c == EOF) {
+                            // eof identifier reached                            
+                            if (jcrPath.charAt(pos - 2) != ']') {
+                                throw new MalformedPathException("'" + jcrPath + "' is not a valid path: Unterminated identifier segment.");
+                            }
+                            String identifier = jcrPath.substring(lastPos, pos - 2);
+                            if (checkFormat) {
+                                if (identifierResolver != null) {
+                                    identifierResolver.checkFormat(identifier);
+                                } // else ignore. TODO: rather throw?
+                            } else if (identifierResolver == null) {
+                                throw new MalformedPathException("'" + jcrPath + "' is not a valid path: Identifier segments are not supported.");
+                            } else if (normalizeIdentifier) {
+                                builder.addAll(identifierResolver.getPath(identifier).getElements());
+                            } else {
+                                identifierResolver.checkFormat(identifier);
+                                builder.addLast(factory.createElement(identifier));
+                            }
+                            state = STATE_PREFIX_START;
+                            lastPos = pos;
+                        }
-                    } else {
+                    } else if (state != STATE_URI) {
+                    } else if (state == STATE_IDENTIFIER || state == STATE_URI) {
+                        // nothing do
+                    } else if (state == STATE_IDENTIFIER) {
+                        // nothing do
+                    } else if (state == STATE_IDENTIFIER) {
+                        // nothing do
-                    } else if (state == STATE_INDEX_END) {
-                        throw new MalformedPathException("'" + jcrPath + "' is not a valid path. '" + c + "' not valid after index. '/' expected.");
-                    throw new MalformedPathException("'" + jcrPath + "' is not a valid path. Whitespace not a allowed in name.");
-
+                    if (state != STATE_IDENTIFIER) {
+                        throw new MalformedPathException("'" + jcrPath + "' is not a valid path. Whitespace not a allowed in name.");
+                    }
-                    throw new MalformedPathException("'" + jcrPath + "' is not a valid path. '" + c + "' not a valid name character.");
+                    if (state != STATE_IDENTIFIER) {
+                        // TODO for JCR 2.0 remove limitation of ' and "
+                        throw new MalformedPathException("'" + jcrPath + "' is not a valid path. '" + c + "' not a valid name character.");
+                    }
+                case '{':
+                    if (state == STATE_PREFIX_START) {
+                        state = STATE_URI;
+                    }
+                    break;
+                case '}':
+                    if (state == STATE_URI) {
+                        state = STATE_URI_END;
+                    }
+                    break;
+                
-        if (resolver == null) {
+        if (checkFormat) {
-            parse(jcrPath, null, PathFactoryImpl.getInstance());
+            parse(jcrPath, null, null, PathFactoryImpl.getInstance());

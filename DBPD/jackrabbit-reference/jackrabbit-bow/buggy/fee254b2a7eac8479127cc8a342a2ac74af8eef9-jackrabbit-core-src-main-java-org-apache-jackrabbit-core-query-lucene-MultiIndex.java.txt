JCR-2434: Occasional IndexingQueueTest failure

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@889976 13f79535-47bb-0310-9956-ffa450edef68

+     * Only used for testing purpose. Set to <code>true</code> after finished
+     * extraction jobs have been removed from the queue and set to
+     * <code>false</code> again after the affected nodes have been updated in
+     * the index.
+     */
+    private boolean indexingQueueCommitPending;
+
+    /**
+    //-------------------------< testing only >---------------------------------
+
+    void waitUntilIndexingQueueIsEmpty() {
+        IndexingQueue iq = getIndexingQueue();
+        synchronized (iq) {
+            while (iq.getNumPendingDocuments() > 0 || indexingQueueCommitPending) {
+                try {
+                    log.info("waiting for indexing queue to become empty");
+                    iq.wait();
+                    log.info("notified");
+                } catch (InterruptedException e) {
+                    // interrupted, check again if queue is empty
+                }
+            }
+        }
+    }
+
+    void notifyIfIndexingQueueIsEmpty() {
+        IndexingQueue iq = getIndexingQueue();
+        synchronized (iq) {
+            indexingQueueCommitPending = false;
+            if (iq.getNumPendingDocuments() == 0) {
+                iq.notifyAll();
+            }
+        }
+    }
+
-            // remove documents from the queue
-            for (NodeId id : finished.keySet()) {
-                indexingQueue.removeDocument(id.toString());
+            // Only useful for testing
+            synchronized (getIndexingQueue()) {
+                indexingQueueCommitPending = true;
-                if (transactionPresent) {
-                    synchronized (this) {
-                        for (NodeId id : finished.keySet()) {
-                            executeAndLog(new DeleteNode(getTransactionId(), id));
-                        }
-                        for (Document document : finished.values()) {
-                            executeAndLog(new AddNode(getTransactionId(), document));
-                        }
-                    }
-                } else {
-                    update(finished.keySet(), finished.values());
+                // remove documents from the queue
+                for (NodeId id : finished.keySet()) {
+                    indexingQueue.removeDocument(id.toString());
-            } catch (IOException e) {
-                // update failed
-                log.warn("Failed to update index with deferred text extraction", e);
+
+                try {
+                    if (transactionPresent) {
+                        synchronized (this) {
+                            for (NodeId id : finished.keySet()) {
+                                executeAndLog(new DeleteNode(getTransactionId(), id));
+                            }
+                            for (Document document : finished.values()) {
+                                executeAndLog(new AddNode(getTransactionId(), document));
+                            }
+                        }
+                    } else {
+                        update(finished.keySet(), finished.values());
+                    }
+                } catch (IOException e) {
+                    // update failed
+                    log.warn("Failed to update index with deferred text extraction", e);
+                }
+            } finally {
+                // the following method also resets
+                // indexingQueueCommitPending back to false
+                notifyIfIndexingQueueIsEmpty();
+                index.notifyIfIndexingQueueIsEmpty();

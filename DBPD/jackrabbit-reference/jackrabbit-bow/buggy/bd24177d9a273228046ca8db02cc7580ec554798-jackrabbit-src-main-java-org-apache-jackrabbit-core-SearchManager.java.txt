JCR-257: Use separate index for jcr:system tree
- shut down unused query handler when it had been idle for some configurable time

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@358016 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Timer;
+import java.util.TimerTask;
+import java.util.Properties;
+import java.util.WeakHashMap;
+import java.util.Map;
+import java.util.Collections;
+     * Name of the parameter that specifies the idle time for a query handler.
+     */
+    private static final String PARAM_IDLE_TIME = "idleTime";
+
+    /**
+     * Class instance that is shared for all <code>SearchManager</code> instances.
+     * Each workspace will schedule a task to check if the query handler can
+     * be shutdown after it had been idle for some time.
+     */
+    private static final Timer IDLE_TIMER = new Timer(true);
+
+    /**
+     * Idle time in seconds after which the query handler is shut down.
+     */
+    private static final int DEFAULT_IDLE_TIME = -1;
+
+    /**
+     * The time when the query handler was last accessed.
+     */
+    private long lastAccess = System.currentTimeMillis();
+
+    /**
+     * The search configuration.
+     */
+    private final SearchConfig config;
+
+    /**
+     * The node type registry.
+     */
+    private final NodeTypeRegistry ntReg;
+
+    /**
+     * The root node for this search manager.
+     */
+    private final String rootNodeUUID;
+
+    /**
-    private final QueryHandler handler;
+    private QueryHandler handler;
+
+    /**
+     * QueryHandler of the parent search manager or <code>null</code> if there
+     * is none.
+     */
+    private final QueryHandler parentHandler;
+     * UUID of the node that should be excluded from indexing or <code>null</code>
+     * if no node should be excluded.
+     */
+    private final String excludedNodeUUID;
+
+    /**
+     * Task that checks if the query handler can be shut down because it
+     * had been idle for {@link #idleTime} seconds.
+     */
+    private final TimerTask idleChecker;
+
+    /**
+     * Idle time in seconds. After the query handler had been idle for this
+     * amount of time it is shut down. Defaults to -1 and causes the search
+     * manager to never shut down.
+     */
+    private int idleTime;
+
+    /**
+     * Weakly references all {@link javax.jcr.query.Query} instances created
+     * by this <code>SearchManager</code>.
+     * If this map is empty and this search manager had been idle for at least
+     * {@link #idleTime} seconds, then the query handler is shut down.
+     */
+    private final Map activeQueries = Collections.synchronizedMap(new WeakHashMap() {
+
+    });
+
+    /**
-     * @param config           the search configuration.
+     * @param config the search configuration.
-     * @param ntReg            the node type registry.
-     * @param itemMgr          the shared item state manager.
+     * @param ntReg the node type registry.
+     * @param itemMgr the shared item state manager.
+        this.config = config;
+        this.ntReg = ntReg;
+        this.rootNodeUUID = rootNodeUUID;
+        this.parentHandler = (parentMgr != null) ? parentMgr.handler : null;
+        this.excludedNodeUUID = excludedNodeUUID;
-        queryImplClassName = config.getParameters().getProperty(PARAM_QUERY_IMPL, DEFAULT_QUERY_IMPL_CLASS);
-
-        QueryHandler parentHandler = null;
-        if (parentMgr != null) {
-            parentHandler = parentMgr.handler;
+        Properties params = config.getParameters();
+        queryImplClassName = params.getProperty(PARAM_QUERY_IMPL, DEFAULT_QUERY_IMPL_CLASS);
+        String idleTimeString = params.getProperty(PARAM_IDLE_TIME, String.valueOf(DEFAULT_IDLE_TIME));
+        try {
+            idleTime = Integer.decode(idleTimeString).intValue();
+        } catch (NumberFormatException e) {
+            idleTime = DEFAULT_IDLE_TIME;
-        try {
-            handler = (QueryHandler) config.newInstance();
-            QueryHandlerContext context
-                    = new QueryHandlerContext(fs, itemMgr, rootNodeUUID, ntReg,
-                            parentHandler, excludedNodeUUID);
-            handler.init(context);
-        } catch (Exception e) {
-            throw new RepositoryException(e.getMessage(), e);
+        initializeQueryHandler();
+
+        idleChecker = new TimerTask() {
+            public void run() {
+                if (lastAccess + (idleTime * 1000) < System.currentTimeMillis()) {
+                    int inUse = activeQueries.size();
+                    if (inUse == 0) {
+                        try {
+                            shutdownQueryHandler();
+                        } catch (IOException e) {
+                            log.warn("Unable to shutdown idle query handler", e);
+                        }
+                    } else {
+                        log.debug("SearchManager is idle but " + inUse +
+                                " queries are still in use.");
+                    }
+                }
+            }
+        };
+
+        if (idleTime > -1) {
+            IDLE_TIMER.schedule(idleChecker, 0, 1000);
-            handler.close();
+            idleChecker.cancel();
+            shutdownQueryHandler();
+
+        ensureInitialized();
+        ensureInitialized();
-        try {
-            handler.updateNodes(removedNodes.iterator(), addedStates);
-        } catch (RepositoryException e) {
-            log.error("Error indexing node.", e);
-        } catch (IOException e) {
-            log.error("Error indexing node.", e);
+        if (removedNodes.size() > 0 || addedNodes.size() > 0) {
+            try {
+                ensureInitialized();
+                handler.updateNodes(removedNodes.iterator(), addedStates);
+            } catch (RepositoryException e) {
+                log.error("Error indexing node.", e);
+            } catch (IOException e) {
+                log.error("Error indexing node.", e);
+            }
+                // track query instances
+                activeQueries.put(obj, null);
+
+    //------------------------< internal >--------------------------------------
+
+    /**
+     * Initializes the query handler.
+     *
+     * @throws RepositoryException if the query handler cannot be initialized.
+     */
+    private void initializeQueryHandler() throws RepositoryException {
+        // initialize query handler
+        try {
+            handler = (QueryHandler) config.newInstance();
+            QueryHandlerContext context
+                    = new QueryHandlerContext(fs, itemMgr, rootNodeUUID,
+                            ntReg, parentHandler, excludedNodeUUID);
+            handler.init(context);
+        } catch (Exception e) {
+            throw new RepositoryException(e.getMessage(), e);
+        }
+    }
+
+    /**
+     * Shuts down the query handler. If the query handler is already shut down
+     * this method does nothing.
+     *
+     * @throws IOException if an error occurs while shutting down the query
+     *                     handler.
+     */
+    private synchronized void shutdownQueryHandler() throws IOException {
+        if (handler != null) {
+            handler.close();
+            handler = null;
+        }
+    }
+
+    /**
+     * Ensures that the query handler is initialized and updates the last
+     * access to the current time.
+     *
+     * @throws RepositoryException if the query handler cannot be initialized.
+     */
+    private synchronized void ensureInitialized() throws RepositoryException {
+        lastAccess = System.currentTimeMillis();
+        if (handler == null) {
+            initializeQueryHandler();
+        }
+    }

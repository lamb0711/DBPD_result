JCR-1104 : JSR 283 support (security work in progress)

> introduce AccessManager.canRead(Path)
> retrieve Policy/ACE from ACProvider by Path rather than by ID
> add CompiledPermission.canReadAll for optimization
> fix ACLTemplate (various bugs) and add additional tests
> get rid of deprecated AccessManager.isGranted(ItemId, int) wherever possible
  and mark/simplify other usages
  - ItemManager
  - BatchedItemOperations
  - add TODO with QueryResultImpl that still uses the isGranted method.
  - EventConsumer: still uses isGranted. but various calls were replaced by private
    canRead -> simplify later optimization.
> remove unused ACLCache.java
> ItemManager:
  - make getItem consistent with itemExists (check perm even if obtained from cache)
  - replace getItemState by getItemData
  - get rid of duplicate code
  - add canRead(ItemData, Path) which is used (almost) everywhere and avoid permission
    check for NEW,non-protected items
  - consequently getItem(ItemId, boolean) is not required any more.
  - upon building LazyItemIterator for children: omit the duplicate permission
    check while building the set of childIds.
    the perm-check is executed upon the subsequent ItemManager.getItem call anyway 
> NodeImpl: createChildNode called ItemManager.getItem for an new item that has
  not yet been added as CNE to its parent -> replace by ItemManager.createItemInstance
  which omits the permission check.
> ItemImpl: 
  - fix javadoc
  - replace removed method ItemMgr.getItem(ItemId, boolean) by getItem(ItemId)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@649172 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.NodeId;
+import org.apache.jackrabbit.spi.commons.name.PathFactoryImpl;
-import javax.jcr.ItemNotFoundException;
-    // TODO: TOBEFIXED add means to create user-based ACLs (currently editor is not exposed in the API)
-    private String policyName;
-
+
+    //--------------------------------------< AbstractAccessControlProvider >---
+    /**
+     * @see AbstractAccessControlProvider#isAcItem(Path)
+     */
+    protected boolean isAcItem(Path absPath) throws RepositoryException {
+        Path.Element[] elems = absPath.getElements();
+        for (int i = 0; i < elems.length; i++) {
+            if (N_POLICY.equals(elems[i].getName())) {
+                return true;
+            }
+        }
+        return false;
+    }
+
-        policyName = session.getJCRName(AccessControlConstants.N_POLICY);
-
-     * @see AccessControlProvider#getAccessControlEntries(org.apache.jackrabbit.core.NodeId)
+     * @see AccessControlProvider#getAccessControlEntries(Path)
+     * @param absPath
-    public AccessControlEntry[] getAccessControlEntries(NodeId nodeId) throws RepositoryException {
+    public AccessControlEntry[] getAccessControlEntries(Path absPath) throws RepositoryException {
-    public CompiledPermissions compilePermissions(Set principals) throws ItemNotFoundException, RepositoryException {
+    public CompiledPermissions compilePermissions(Set principals) throws RepositoryException {
+        } else if (isReadOnly(principals)) {
+            return getReadOnlyPermissions();
-            // TODO: TOBEFIXED include the resource-based ACLs!
+    /**
+     * @see AccessControlProvider#canAccessRoot(Set)
+     */
+    public boolean canAccessRoot(Set principals) throws RepositoryException {
+        checkInitialized();
+        if (isAdminOrSystem(principals)) {
+            return true;
+        } else {
+            return new CompiledPermissionImpl(principals, false).grants(PathFactoryImpl.getInstance().getRootPath(), Permission.READ);
+        }
+    }
+
+            this(principals, true);
+        }
+
+        /**
+         * @param principals
+         * @throws RepositoryException
+         */
+        private CompiledPermissionImpl(Set principals, boolean listenToEvents) throws RepositoryException {
-            int events = Event.PROPERTY_CHANGED | Event.PROPERTY_ADDED |
-                    Event.PROPERTY_REMOVED | Event.NODE_ADDED | Event.NODE_REMOVED;
-            String[] ntNames = new String[] {
-                    session.getJCRName(NT_REP_ACE)
-            };
-            observationMgr.addEventListener(this, events, acRoot.getPath(), true, null, ntNames, false);
+            if (listenToEvents) {
+                int events = Event.PROPERTY_CHANGED | Event.PROPERTY_ADDED |
+                        Event.PROPERTY_REMOVED | Event.NODE_ADDED | Event.NODE_REMOVED;
+                String[] ntNames = new String[] {
+                        session.getJCRName(NT_REP_ACE)
+                };
+                observationMgr.addEventListener(this, events, acRoot.getPath(), true, null, ntNames, false);
+            }
-            String jcrPath = session.getJCRPath(absPath);
-            boolean isAclItem = false;
-            String[] segments = Text.explode(jcrPath, '/', false);
-            if (segments.length > 0) {
-                for (int i = segments.length - 1; i >= 0 && !isAclItem; i--) {
-                    isAclItem = policyName.equals(segments[i]);
-                }
-            }
-
+            boolean isAclItem = isAcItem(absPath);
+            String jcrPath = session.getJCRPath(absPath);            
-                log.error("Internal error: ", e.getMessage());
+                log.debug("Unable to unregister listener: ", e.getMessage());

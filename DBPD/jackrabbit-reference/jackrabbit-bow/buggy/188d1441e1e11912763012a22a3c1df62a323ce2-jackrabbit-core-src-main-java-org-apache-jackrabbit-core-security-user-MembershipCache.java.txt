JCR-2710: Add support for large number of users in a group 
work in progress

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@984740 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.commons.name.NameConstants;
+import javax.jcr.Session;
+
+    private final boolean useMembersNode;
-    MembershipCache(SessionImpl systemSession, String groupsPath) {
+    @SuppressWarnings("unchecked")
+    MembershipCache(SessionImpl systemSession, String groupsPath, boolean useMembersNode) {
+        this.useMembersNode = useMembersNode;
-            groupNodeIds = collectDeclaredMembership(authorizableNodeIdentifier);
-            cache.put(authorizableNodeIdentifier, Collections.unmodifiableCollection(groupNodeIds));
+            // retrieve a new session with system-subject in order to avoid
+            // concurrent read operations using the system session of this workspace.
+            Session session = getSession();
+            try {
+                groupNodeIds = collectDeclaredMembershipFromReferences(authorizableNodeIdentifier, session);
+                if (groupNodeIds == null) {
+                    groupNodeIds = collectDeclaredMembershipFromTraversal(authorizableNodeIdentifier, session);
+                }
+                cache.put(authorizableNodeIdentifier, Collections.unmodifiableCollection(groupNodeIds));
+            }
+            finally {
+                // release session if it isn't the original system session
+                if (session != systemSession) {
+                    session.logout();
+                }
+            }
-    private Collection<String> collectDeclaredMembership(final String authorizableNodeIdentifier) throws RepositoryException {
-        // retrieve a new session with system-subject in order to avoid
-        // concurrent read operations using the system session of this workspace.
-        final SessionImpl session = getSession();
-        try {
-            final Set<String> groupNodeIdentifiers = new HashSet<String>();
+    private Collection<String> collectDeclaredMembershipFromReferences(String authorizableNodeIdentifier,
+            Session session) throws RepositoryException {
-            // try to retrieve the membership references using JCR API.
-            PropertyIterator refs = getMembershipReferences(authorizableNodeIdentifier, session);
-            if (refs != null) {
-                while (refs.hasNext()) {
-                    try {
-                        NodeImpl n = (NodeImpl) refs.nextProperty().getParent();
-                        if (n.isNodeType(NT_REP_GROUP)) {
-                            String identifier = n.getIdentifier();
-                            if (!groupNodeIdentifiers.contains(identifier)) {
-                                groupNodeIdentifiers.add(identifier);
-                            }
-                        } else {
-                            // weak-ref property 'rep:members' that doesn't reside under an
-                            // group node -> doesn't represent a valid group member.
-                            log.debug("Invalid member reference to '" + this + "' -> Not included in membership set.");
-                        }
-                    } catch (ItemNotFoundException e) {
-                        // group node doesn't exist  -> -> ignore exception
-                        // and skip this reference from membership list.
-                    } catch (AccessDeniedException e) {
-                        // not allowed to see the group node -> ignore exception
-                        // and skip this reference from membership list.
+        Set<String> pIds = new HashSet<String>();
+        Set<String> nIds = new HashSet<String>();
+
+        // Try to get membership information from references
+        PropertyIterator refs = getMembershipReferences(authorizableNodeIdentifier, session);
+        if (refs == null) {
+            return null;
+        }
+
+        while (refs.hasNext()) {
+            try {
+                PropertyImpl pMember = (PropertyImpl) refs.nextProperty();
+                NodeImpl nGroup = (NodeImpl) pMember.getParent();
+
+                Set<String> groupNodeIdentifiers;
+                if (P_MEMBERS.equals(pMember.getQName())) {
+                    // Found membership information in members property
+                    groupNodeIdentifiers = pIds;
+                }
+                else {
+                    // Found membership information in members node
+                    groupNodeIdentifiers = nIds;
+                    while (nGroup.isNodeType(NT_REP_MEMBERS)) {
+                        nGroup = (NodeImpl) nGroup.getParent();
-            } else {
-                // workaround for failure of Node#getWeakReferences
-                // traverse the tree below groups-path and collect membership manually.
-                log.info("Traversing groups tree to collect membership.");
-                ItemVisitor visitor = new TraversingItemVisitor.Default() {
-                    @Override
-                    protected void entering(Property property, int level) throws RepositoryException {
-                        PropertyImpl pImpl = (PropertyImpl) property;
-                        NodeImpl n = (NodeImpl) pImpl.getParent();
-                        if (P_MEMBERS.equals(pImpl.getQName()) && n.isNodeType(NT_REP_GROUP)) {
-                            for (Value value : property.getValues()) {
-                                String v = value.getString();
-                                if (v.equals(authorizableNodeIdentifier)) {
-                                    groupNodeIdentifiers.add(n.getIdentifier());
-                                }
-                            }
-                        }
-                    }
-                };
-                if (session.nodeExists(groupsPath)) {
-                    Node groupsNode = session.getNode(groupsPath);
-                    visitor.visit(groupsNode);
-                } // else: no groups exist -> nothing to do.
-            }
-            return groupNodeIdentifiers;
-
-        } finally {
-            // release session if it isn't the original system session but has
-            // been created for this method call only.
-            if (session != systemSession) {
-                session.logout();
+                if (nGroup.isNodeType(NT_REP_GROUP)) {
+                    groupNodeIdentifiers.add(nGroup.getIdentifier());
+                } else {
+                    // weak-ref property 'rep:members' that doesn't reside under an
+                    // group node -> doesn't represent a valid group member.
+                    log.debug("Invalid member reference to '" + this + "' -> Not included in membership set.");
+                }
+            } catch (ItemNotFoundException e) {
+                // group node doesn't exist  -> -> ignore exception
+                // and skip this reference from membership list.
+            } catch (AccessDeniedException e) {
+                // not allowed to see the group node -> ignore exception
+                // and skip this reference from membership list.
+
+        // Based on the user's setting return either of the found membership informations
+        return select(pIds, nIds);
-   
+
+    private Collection<String> collectDeclaredMembershipFromTraversal(
+            final String authorizableNodeIdentifier, Session session) throws RepositoryException {
+
+        final Set<String> pIds = new HashSet<String>();
+        final Set<String> nIds = new HashSet<String>();
+
+        // workaround for failure of Node#getWeakReferences
+        // traverse the tree below groups-path and collect membership manually.
+        log.info("Traversing groups tree to collect membership.");
+        ItemVisitor visitor = new TraversingItemVisitor.Default() {
+            @Override
+            protected void entering(Property property, int level) throws RepositoryException {
+                PropertyImpl pMember = (PropertyImpl) property;
+                NodeImpl nGroup = (NodeImpl) pMember.getParent();
+                if (P_MEMBERS.equals(pMember.getQName()) && nGroup.isNodeType(NT_REP_GROUP)) {
+                    // Found membership information in members property
+                    for (Value value : property.getValues()) {
+                        String v = value.getString();
+                        if (v.equals(authorizableNodeIdentifier)) {
+                            pIds.add(nGroup.getIdentifier());
+                        }
+                    }
+                }
+                else {
+                    // Found membership information in members node
+                    while (nGroup.isNodeType(NT_REP_MEMBERS)) {
+                        nGroup = (NodeImpl) nGroup.getParent();
+                    }
+
+                    if (nGroup.isNodeType(NT_REP_GROUP) && !NameConstants.JCR_UUID.equals(pMember.getQName())) {
+                        String v = pMember.getString();
+                        if (v.equals(authorizableNodeIdentifier)) {
+                            nIds.add(nGroup.getIdentifier());
+                        }
+                    }
+                }
+            }
+        };
+
+        if (session.nodeExists(groupsPath)) {
+            Node groupsNode = session.getNode(groupsPath);
+            visitor.visit(groupsNode);
+        } // else: no groups exist -> nothing to do.
+
+        // Based on the user's setting return either of the found membership informations
+        return select(pIds, nIds);
+    }
+
+    /**
+     * Return either of both sets depending on the users setting whether
+     * to use the members property or the members node to record membership
+     * information. If both sets are non empty, the one configured in the
+     * settings will take precedence and an warning is logged.
+     * @return
+     */
+    private Set<String> select(Set<String> pIds, Set<String> nIds) {
+        Set<String> result;
+        if (useMembersNode) {
+            if (!nIds.isEmpty() || pIds.isEmpty()) {
+                result = nIds;
+            }
+            else {
+                result = pIds;
+            }
+        }
+        else {
+            if (!pIds.isEmpty() || nIds.isEmpty()) {
+                result = pIds;
+            }
+            else {
+                result = nIds;
+            }
+        }
+
+        if (!pIds.isEmpty() && !nIds.isEmpty()) {
+            log.warn("Found members node and members property. Ignoring {} members",
+                    useMembersNode ? "property" : "node");
+        }
+
+        return result;
+    }
+
+
-    private static PropertyIterator getMembershipReferences(String authorizableNodeIdentifier, SessionImpl session) {
+    private static PropertyIterator getMembershipReferences(String authorizableNodeIdentifier,
+            Session session) {
+
-            refs = session.getNodeByIdentifier(authorizableNodeIdentifier).getWeakReferences(session.getJCRName(P_MEMBERS));
+            refs = session.getNodeByIdentifier(authorizableNodeIdentifier).getWeakReferences(null);

JCR-454: Query with document order fails when result set size > caching hierarchy manager size

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@412712 13f79535-47bb-0310-9956-ffa450edef68

-                    evict(child);
+                    remove(child);
-                    evict(child);
+                    remove(child);
-        evict(destroyed.getId());
+        remove(destroyed.getId());
-        evict(discarded.getId());
+        if (discarded.isTransient() && !discarded.hasOverlayedState()) {
+            // a new node has been discarded -> remove from cache
+            remove(discarded.getId());
+        } else if (provider.hasItemState(discarded.getId())) {
+            evict(discarded.getId());
+        } else {
+            remove(discarded.getId());
+        }
+            if (element.get() != null) {
+                if (!id.equals(((LRUEntry) element.get()).getId())) {
+                    log.warn("overwriting PathMap.Element");
+                }
+            }
+     * Remove item from cache. Removes the associated <code>LRUEntry</code>
+     * and the <code>PathMap.Element</code> with it. Indexes of same name
+     * sibling elements are shifted!
+     *
+     * @param id item id
+     */
+    private void remove(ItemId id) {
+        synchronized (cacheMonitor) {
+            LRUEntry entry = (LRUEntry) idCache.get(id);
+            if (entry != null) {
+                remove(entry, true);
+            }
+        }
+    }
+
+    /**
+     * Remove item from cache. Index of same name sibling items are shifted!
+     *
+     * @param entry               LRU entry
+     * @param removeFromPathCache whether to remove from path cache
+     */
+    private void remove(LRUEntry entry, boolean removeFromPathCache) {
+        synchronized (cacheMonitor) {
+            if (removeFromPathCache) {
+                PathMap.Element element = entry.getElement();
+                remove(element);
+                element.remove();
+            } else {
+                idCache.remove(entry.getId());
+                entry.remove();
+            }
+        }
+    }
+
+    /**
+     * Evict item from cache. Index of same name sibling items are <b>not</b>
+     * shifted!
+     *
+     * @param entry               LRU entry
+     * @param removeFromPathCache whether to remove from path cache
+     */
+    private void evict(LRUEntry entry, boolean removeFromPathCache) {
+        synchronized (cacheMonitor) {
+            if (removeFromPathCache) {
+                PathMap.Element element = entry.getElement();
+                element.traverse(new PathMap.ElementVisitor() {
+                    public void elementVisited(PathMap.Element element) {
+                        evict((LRUEntry) element.get(), false);
+                    }
+                }, false);
+                element.remove(false);
+            } else {
+                idCache.remove(entry.getId());
+                entry.remove();
+            }
+        }
+    }
+
+    /**
+     * and the <code>PathMap.Element</code> with it. Indexes of same name
+     * sibling elements are <b>not</b> shifted!
-     * Evict item from cache
-     *
-     * @param entry               LRU entry
-     * @param removeFromPathCache whether to remove from path cache
-     */
-    private void evict(LRUEntry entry, boolean removeFromPathCache) {
-        synchronized (cacheMonitor) {
-            if (removeFromPathCache) {
-                PathMap.Element element = entry.getElement();
-                evict(element);
-                element.remove();
-            } else {
-                idCache.remove(entry.getId());
-                entry.remove();
-            }
-        }
-    }
-
-    /**
-     * Evict path map element from cache. This will traverse all children
-     * of this element and evict the objects associated with them
+     * Remove path map element from cache. This will traverse all children
+     * of this element and remove the objects associated with them.
+     * Index of same name sibling items are shifted!
-    private void evict(PathMap.Element element) {
+    private void remove(PathMap.Element element) {
-                    evict((LRUEntry) element.get(), false);
+                    remove((LRUEntry) element.get(), false);
-                    evict(element);
+                    remove(element);

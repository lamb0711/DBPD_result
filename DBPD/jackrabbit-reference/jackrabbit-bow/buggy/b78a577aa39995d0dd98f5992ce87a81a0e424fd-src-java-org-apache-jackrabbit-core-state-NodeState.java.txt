JCR-129: applied patch supplied by serge as-is
(http://issues.apache.org/jira/browse/JCR-129)misc. NodeState optimizations:
- removed PropertyEntry class; the relevant
  NodeState methods (e.g. getPropertyEntries())
  now return QName's instead of PropertyEntry
  to avoid unneccessary object creation
- reimplemented internal ChildNodeEntries class
  for improved speed and efficiency


git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@201999 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.commons.collections.map.LinkedMap;
+import org.apache.commons.collections.set.ListOrderedSet;
+import java.util.Collection;
+import java.util.ListIterator;
-    static final long serialVersionUID = -3210487938753054604L;
+    /** Serialization UID of this class. */
+    static final long serialVersionUID = 2387880829766640392L;
+    /** the uuid of this node */
+
+    /** the name of this node's primary type */
+
+    /** the names of this node's mixin types */
+
+    /** id of this node's definition */
-    // insertion-ordered collection of ChildNodeEntry objects
+    /** insertion-ordered collection of ChildNodeEntry objects */
-    // insertion-ordered collection of PropertyEntry objects
-    protected List propertyEntries = new ArrayList();
+
+    /** insertion-ordered set of property names (QName objects) */
+    protected ListOrderedSet propertyNames = new ListOrderedSet();
-        propertyEntries.clear();
-        propertyEntries.addAll(nodeState.getPropertyEntries());
+        propertyNames.clear();
+        propertyNames.addAll(nodeState.getPropertyNames());
+     * Determines if there are any child node entries.
+     *
+     * @return <code>true</code> if there are child node entries,
+     *         <code>false</code> otherwise.
+     */
+    public boolean hasChildNodeEntries() {
+        return !childNodeEntries.isEmpty();
+    }
+
+    /**
+     * specified <code>uuid</code>.
+     *
+     * @param uuid UUID of the child node
+     * @return <code>true</code> if there is a <code>ChildNodeEntry</code> with
+     *         the specified <code>name</code>.
+     */
+    public synchronized boolean hasChildNodeEntry(String uuid) {
+        return childNodeEntries.get(uuid) != null;
+    }
+
+    /**
+     * Determines if there is a <code>ChildNodeEntry</code> with the
-     * Determines if there is a <code>PropertyEntry</code> with the
-     * specified <code>QName</code>.
+     * Determines if there is a property entry with the specified
+     * <code>QName</code>.
-     * @return <code>true</code> if there is a <code>PropertyEntry</code> with
-     *         the specified <code>QName</code>.
+     * @return <code>true</code> if there is a property entry with the specified
+     *         <code>QName</code>.
-    public synchronized boolean hasPropertyEntry(QName propName) {
-        PropertyEntry entry = new PropertyEntry(propName);
-        return propertyEntries.contains(entry);
-    }
-
-    /**
-     * Returns the <code>PropertyEntry</code> with the specified name or
-     * <code>null</code> if there's no such entry.
-     *
-     * @param propName <code>QName</code> object specifying a property name
-     * @return the <code>PropertyEntry</code> with the specified name or
-     *         <code>null</code> if there's no such entry.
-     */
-    public synchronized PropertyEntry getPropertyEntry(QName propName) {
-        Iterator iter = propertyEntries.iterator();
-        while (iter.hasNext()) {
-            PropertyEntry entry = (PropertyEntry) iter.next();
-            if (propName.equals(entry.getName())) {
-                return entry;
-            }
-        }
-        return null;
+    public synchronized boolean hasPropertyName(QName propName) {
+        return propertyNames.contains(propName);
-     * @param uuid UUID of a child node state.
+     * @param uuid UUID of the child node
-        return childNodeEntries.entries();
+        return childNodeEntries;
-     * Removes a <code>ChildNodeEntry<code>.
+     * Removes a <code>ChildNodeEntry</code>.
-     * @param nodeName <code>ChildNodeEntry<code> object specifying a node name
+     * @param nodeName <code>ChildNodeEntry</code> object specifying a node name
-        Iterator iter = childNodeEntries.entries().iterator();
-        while (iter.hasNext()) {
-            ChildNodeEntry entry = (ChildNodeEntry) iter.next();
-            removeChildNodeEntry(entry.getUUID());
-        }
+        childNodeEntries.removeAll();
-     * Returns a list of <code>PropertyEntry</code> objects denoting the
-     * properties of this node.
+     * Returns the names of this node's properties as a list of
+     * <code>QNames</code> objects.
-     * @return list of <code>PropertyEntry</code> objects
-     * @see #addPropertyEntry
-     * @see #removePropertyEntry
+     * @return list of <code>QNames</code> objects
+     * @see #addPropertyName
+     * @see #removePropertyName
-    public synchronized List getPropertyEntries() {
-        return Collections.unmodifiableList(propertyEntries);
+    public synchronized List getPropertyNames() {
+        return propertyNames.asList();
-     * Adds a <code>PropertyEntry</code>.
+     * Adds a property name entry.
-    public synchronized void addPropertyEntry(QName propName) {
-        PropertyEntry entry = new PropertyEntry(propName);
-        propertyEntries.add(entry);
+    public synchronized void addPropertyName(QName propName) {
+        propertyNames.add(propName);
-     * Removes a <code>PropertyEntry</code>.
+     * Removes a property name entry.
-     * @return <code>true</code> if the specified property entry was found
-     *         in the list of property entries and could be removed.
+     * @return <code>true</code> if the specified property name was found
+     *         in the list of property name entries and could be removed.
-    public synchronized boolean removePropertyEntry(QName propName) {
-        PropertyEntry entry = new PropertyEntry(propName);
-        int pos = propertyEntries.indexOf(entry);
-        if (pos == -1) {
-            return false;
-        } else {
-            propertyEntries.remove(pos);
-            return true;
-        }
+    public synchronized boolean removePropertyName(QName propName) {
+        return propertyNames.remove(propName);
-     * Removes all <code>PropertyEntry</code>s.
+     * Removes all property name entries.
-    public synchronized void removeAllPropertyEntries() {
-        propertyEntries.clear();
+    public synchronized void removeAllPropertyNames() {
+        propertyNames.clear();
-     * Sets the list of <code>PropertyEntry</code> objects denoting the
+     * Sets the list of <code>QName</code> objects denoting the
-    public synchronized void setPropertyEntries(List propEntries) {
-        propertyEntries.clear();
-        propertyEntries.addAll(propEntries);
+    public synchronized void setPropertyNames(List propNames) {
+        propertyNames.clear();
+        propertyNames.addAll(propNames);
-     * Returns a list of property entries, that do not exist in the overlayed
-     * node state but have been added to <i>this</i> node state.
+     * Returns a list of <code>QName</code>s denoting those properties that
+     * do not exist in the overlayed node state but have been added to
+     * <i>this</i> node state.
-     * @return list of added property entries
+     * @return list of <code>QName</code>s denoting the properties that have
+     *         been added.
-    public synchronized List getAddedPropertyEntries() {
+    public synchronized List getAddedPropertyNames() {
-            return Collections.unmodifiableList(propertyEntries);
+            return propertyNames.asList();
-        ArrayList list = new ArrayList(propertyEntries);
-        list.removeAll(other.propertyEntries);
+        ArrayList list = new ArrayList(propertyNames);
+        list.removeAll(other.propertyNames);
-     * Returns a list of child node entries, that do not exist in the overlayed
+     * Returns a list of child node entries that do not exist in the overlayed
-            return Collections.unmodifiableList(childNodeEntries.entries());
+            return childNodeEntries;
-     * Returns a list of property entries, that exist in the overlayed node state
-     * but have been removed from <i>this</i> node state.
+     * Returns a list of <code>QName</code>s denoting those properties that
+     * exist in the overlayed node state but have been removed from
+     * <i>this</i> node state.
-     * @return list of removed property entries
+     * @return list of <code>QName</code>s denoting the properties that have
+     *         been removed.
-    public synchronized List getRemovedPropertyEntries() {
+    public synchronized List getRemovedPropertyNames() {
-        ArrayList list = new ArrayList(other.propertyEntries);
-        list.removeAll(propertyEntries);
+        ArrayList list = new ArrayList(other.propertyNames);
+        list.removeAll(propertyNames);
-     * state and in the overlayed node state, but have been reordered.
+     * state and in the overlayed node state but have been reordered.
-     * their context position, the list may include less that this number of
+     * their absolute position the list may include less that this number of
-     * All nodes have changed their context position. The returned list however
+     * All nodes have changed their absolute position. The returned list however
-        others.addAll(((NodeState) getOverlayedState()).childNodeEntries.entries);
+        others.addAll(((NodeState) getOverlayedState()).getChildNodeEntries());
-        ours.addAll(childNodeEntries.entries);
+        ours.addAll(childNodeEntries);
-        // remove added nodes from ours entries
+        // remove added nodes from 'our' entries
-        // remove all removed nodes from others entries
+        // remove all removed nodes from 'other' entries
-        // both entry list now contain the set of nodes that have not
-        // been removed or added. but they may have changed their position
+        // both entry lists now contain the set of nodes that have not
+        // been removed or added, but they may have changed their position.
-                // Note, that this check will not necessarily find the
+                // Note that this check will not necessarily find the
-                // is there a next entry
+                // is there a next entry?
-                    // if entry is the next in the other list, then probably
+                    // if entry is the next in the other list then probably
-                // incremented, because entries will be shifted when the
+                // incremented because entries will be shifted when the
-     * Notify the listeners that some child node was added
+     * Notify the listeners that a child node entry has been added
-     * Notify the listeners that the children nodes were replaced
+     * Notify the listeners that the child node entries have been replaced
-     * Notify the listeners that some child node was removed
+     * Notify the listeners that a child node entry has been removed
+     * <p/>
+     * <code>ChildNodeEntries</code> also provides an unmodifiable
+     * <code>List</code> view.
-    private static class ChildNodeEntries implements Serializable {
+    private static class ChildNodeEntries implements List, Serializable {
-        // insertion-ordered collection of entries
-        List entries;
-        // mapping from names to list of same-name sibling entries
-        Map names;
+        // insertion-ordered map of entries (key=uuid, value=entry)
+        LinkedMap entries;
+        // map used for lookup by name (key=uuid, value=1st same-name sibling entry)
+        Map nameMap;
-            entries = new ArrayList();
-            names = new HashMap();
+            entries = new LinkedMap();
+            nameMap = new HashMap();
-            List siblings = (List) names.get(nodeName);
-            if (siblings == null) {
-                siblings = new ArrayList();
-                names.put(nodeName, siblings);
+            ChildNodeEntry sibling = (ChildNodeEntry) nameMap.get(nodeName);
+            while (sibling != null && sibling.getNextSibling() != null) {
+                sibling = sibling.getNextSibling();
-            int index = siblings.size() + 1;
+            int index = (sibling == null) ? 1 : sibling.getIndex() + 1;
-            siblings.add(entry);
-            entries.add(entry);
+            if (sibling == null) {
+                nameMap.put(nodeName, entry);
+            } else {
+                sibling.setNextSibling(entry);
+            }
+            entries.put(uuid, entry);
-            names.clear();
+            nameMap.clear();
+        }
+
+        ChildNodeEntry remove(String uuid) {
+            ChildNodeEntry entry = (ChildNodeEntry) entries.get(uuid);
+            if (entry != null) {
+                return remove(entry.getName(), entry.getIndex());
+           }
+            return entry;
-            List siblings = (List) names.get(nodeName);
-            if (siblings == null) {
+
+            ChildNodeEntry sibling = (ChildNodeEntry) nameMap.get(nodeName);
+            ChildNodeEntry prevSibling = null;
+            while (sibling != null) {
+                if (sibling.getIndex() == index) {
+                    break;
+                }
+                prevSibling = sibling;
+                sibling = sibling.getNextSibling();
+            }
+            if (sibling == null) {
-            if (index > siblings.size()) {
-                return null;
-            }
-            // remove from siblings list
-            ChildNodeEntry removedEntry = (ChildNodeEntry) siblings.remove(index - 1);
+
-            entries.remove(removedEntry);
+            entries.remove(sibling.getUUID());
-            if (siblings.size() == 0) {
-                // short cut
-                names.remove(nodeName);
-                return removedEntry;
+            // update linked list of siblings & name map entry
+            if (prevSibling != null) {
+                prevSibling.setNextSibling(sibling.getNextSibling());
+            } else {
+                // the head is removed from the linked siblings list,
+                // update name map
+                if (sibling.getNextSibling() == null) {
+                    nameMap.remove(nodeName);
+                } else {
+                    nameMap.put(nodeName, sibling.getNextSibling());
+                }
-
-            for (int i = index - 1; i < siblings.size(); i++) {
-                ChildNodeEntry oldEntry = (ChildNodeEntry) siblings.get(i);
-                ChildNodeEntry newEntry = new ChildNodeEntry(nodeName, oldEntry.getUUID(), oldEntry.getIndex() - 1);
-                // overwrite old entry with updated entry in siblings list
-                siblings.set(i, newEntry);
-                // overwrite old entry with updated entry in entries list
-                entries.set(entries.indexOf(oldEntry), newEntry);
+            ChildNodeEntry nextSibling = sibling.getNextSibling();
+            while (nextSibling != null) {
+                nextSibling.decIndex();
+                nextSibling = nextSibling.getNextSibling();
-            return removedEntry;
+            return sibling;
-            List siblings = (List) names.get(nodeName);
-            if (siblings == null) {
+            ChildNodeEntry sibling = (ChildNodeEntry) nameMap.get(nodeName);
+            if (sibling == null) {
-            } else {
-                return Collections.unmodifiableList(siblings);
-        }
-
-        ChildNodeEntry remove(String uuid) {
-            Iterator iter = entries.iterator();
-            while (iter.hasNext()) {
-                ChildNodeEntry entry = (ChildNodeEntry) iter.next();
-                if (entry.getUUID().equals(uuid)) {
-                    return remove(entry);
-                }
+            List siblings = new ArrayList();
+            while (sibling != null) {
+                siblings.add(sibling);
+                sibling = sibling.getNextSibling();
-            return null;
+            return siblings;
-            Iterator iter = entries.iterator();
-            while (iter.hasNext()) {
-                ChildNodeEntry entry = (ChildNodeEntry) iter.next();
-                if (entry.getUUID().equals(uuid)) {
-                    return entry;
+            return (ChildNodeEntry) entries.get(uuid);
+        }
+
+        ChildNodeEntry get(QName nodeName, int index) {
+            if (index < 1) {
+                throw new IllegalArgumentException("index is 1-based");
+            }
+
+            ChildNodeEntry sibling = (ChildNodeEntry) nameMap.get(nodeName);
+            while (sibling != null) {
+                if (sibling.getIndex() == index) {
+                    return sibling;
+                sibling = sibling.getNextSibling();
-        Iterator iterator() {
-            return entries.iterator();
-        }
-
-        List entries() {
-            return Collections.unmodifiableList(entries);
-        }
-
-         * they have the same name and uuid, i.e. the index is disregarded,
+         * they have the same name and uuid, i.e. the index is disregarded
-         * @return a new list of entries who do only exist in <code>this</code>
-         *         but not in <code>other</code>
+         * @return a new list of those entries that do only exist in
+         *         <code>this</code> but not in <code>other</code>
-            if (other.entries.isEmpty()) {
-                return Collections.unmodifiableList(entries);
+            if (other.isEmpty()) {
+                return this;
-            List result = new ArrayList(entries);
-
-            Iterator otherIter = other.entries.iterator();
-            while (otherIter.hasNext()) {
-                ChildNodeEntry otherEntry = (ChildNodeEntry) otherIter.next();
-                Iterator ourIter = entries.iterator();
-                while (ourIter.hasNext()) {
-                    ChildNodeEntry ourEntry = (ChildNodeEntry) ourIter.next();
-                    if (ourEntry.getName().equals(otherEntry.getName())
-                            && ourEntry.getUUID().equals(otherEntry.getUUID())) {
-                        result.remove(ourEntry);
-                    }
+            List result = new ArrayList();
+            Iterator iter = iterator();
+            while (iter.hasNext()) {
+                ChildNodeEntry entry = (ChildNodeEntry) iter.next();
+                ChildNodeEntry otherEntry = (ChildNodeEntry) other.get(entry.uuid);
+                if (otherEntry == null
+                        || !entry.getName().equals(otherEntry.getName())) {
+                    result.add(entry);
+
-    }
-    /**
-     * base class for <code>PropertyEntry</code> and <code>ChildNodeEntry</code>
-     */
-    private abstract static class ChildEntry implements Serializable {
-        protected QName name;
-
-        protected ChildEntry(QName name) {
-            this.name = name;
-        }
-
-        public QName getName() {
-            return name;
-        }
-    }
-
-    /**
-     * <code>PropertyEntry</code> specifies the name of a property entry.
-     */
-    public static class PropertyEntry extends ChildEntry {
-
-        private int hash = 0;
-
-        protected PropertyEntry(QName propName) {
-            super(propName);
-        }
-
-        public boolean equals(Object obj) {
-            if (this == obj) {
-                return true;
+        //-------------------------------------------< unmodifiable List view >
+        public boolean contains(Object o) {
+            if (o instanceof ChildNodeEntry) {
+                return entries.containsKey(((ChildNodeEntry) o).uuid);
+            } else {
+                return false;
-            if (obj instanceof PropertyEntry) {
-                PropertyEntry other = (PropertyEntry) obj;
-                return name.equals(other.name);
-            }
-            return false;
-        public String toString() {
-            return name.toString();
+        public boolean containsAll(Collection c) {
+            Iterator iter = c.iterator();
+            while (iter.hasNext()) {
+                if (!contains(iter.next())) {
+                    return false;
+                }
+            }
+            return true;
-        public int hashCode() {
-            // PropertyEntry is immutable, we can store the computed hash code value
-            if (hash == 0) {
-                hash = name.hashCode();
+        public Object get(int index) {
+            return entries.getValue(index);
+        }
+
+        public int indexOf(Object o) {
+            if (o instanceof ChildNodeEntry) {
+                return entries.indexOf(((ChildNodeEntry) o).uuid);
+            } else {
+                return -1;
-            return hash;
+        }
+
+        public boolean isEmpty() {
+            return entries.isEmpty();
+        }
+
+        public int lastIndexOf(Object o) {
+            // entries are unique
+            return indexOf(o);
+        }
+
+        public Iterator iterator() {
+            return new OrderedMapIterator(entries.asList().listIterator(), entries);
+        }
+
+        public ListIterator listIterator() {
+            return new OrderedMapIterator(entries.asList().listIterator(), entries);
+        }
+
+        public ListIterator listIterator(int index) {
+            return new OrderedMapIterator(entries.asList().listIterator(index), entries);
+        }
+
+        public int size() {
+            return entries.size();
+        }
+
+        public List subList(int fromIndex, int toIndex) {
+            // @todo FIXME does not fulfil the contract of List.subList(int,int)
+            return Collections.unmodifiableList(new ArrayList(this).subList(fromIndex, toIndex));
+        }
+
+        public Object[] toArray() {
+            ChildNodeEntry[] array = new ChildNodeEntry[size()];
+            return toArray(array);
+        }
+
+        public Object[] toArray(Object a[]) {
+            if (!a.getClass().getComponentType().isAssignableFrom(ChildNodeEntry.class)) {
+                throw new ArrayStoreException();
+            }
+            if (a.length < size()) {
+                a = new ChildNodeEntry[size()];
+            }
+            MapIterator iter = entries.mapIterator();
+            int i = 0;
+            while (iter.hasNext()) {
+                iter.next();
+                a[i] = entries.getValue(i);
+                i++;
+            }
+            while (i < a.length) {
+                a[i++] = null;
+            }
+            return a;
+        }
+
+        public void add(int index, Object element) {
+            throw new UnsupportedOperationException();
+        }
+
+        public boolean add(Object o) {
+            throw new UnsupportedOperationException();
+        }
+
+        public boolean addAll(Collection c) {
+            throw new UnsupportedOperationException();
+        }
+
+        public boolean addAll(int index, Collection c) {
+            throw new UnsupportedOperationException();
+        }
+
+        public void clear() {
+            throw new UnsupportedOperationException();
+        }
+
+        public Object remove(int index) {
+            throw new UnsupportedOperationException();
+        }
+
+        public boolean remove(Object o) {
+            throw new UnsupportedOperationException();
+        }
+
+        public boolean removeAll(Collection c) {
+            throw new UnsupportedOperationException();
+        }
+
+        public boolean retainAll(Collection c) {
+            throw new UnsupportedOperationException();
+        }
+
+        public Object set(int index, Object element) {
+            throw new UnsupportedOperationException();
+        }
+
+        //----------------------------------------------------< inner classes >
+        class OrderedMapIterator implements ListIterator {
+
+            final ListIterator keyIter;
+            final Map entries;
+
+            OrderedMapIterator(ListIterator keyIter, Map entries) {
+                this.keyIter = keyIter;
+                this.entries = entries;
+            }
+
+            public boolean hasNext() {
+                return keyIter.hasNext();
+            }
+
+            public Object next() {
+                return entries.get(keyIter.next());
+            }
+
+            public boolean hasPrevious() {
+                return keyIter.hasPrevious();
+            }
+
+            public int nextIndex() {
+                return keyIter.nextIndex();
+            }
+
+            public Object previous() {
+                return entries.get(keyIter.previous());
+            }
+
+            public int previousIndex() {
+                return keyIter.previousIndex();
+            }
+
+            public void add(Object o) {
+                throw new UnsupportedOperationException();
+            }
+
+            public void remove() {
+                throw new UnsupportedOperationException();
+            }
+
+            public void set(Object o) {
+                throw new UnsupportedOperationException();
+            }
-    public static class ChildNodeEntry extends ChildEntry {
+    public static class ChildNodeEntry {
-        private int hash = 0;
-
+        private QName name;
+        private ChildNodeEntry nextSibling;
-        protected ChildNodeEntry(QName nodeName, String uuid, int index) {
-            super(nodeName);
+        private ChildNodeEntry(QName name, String uuid, int index) {
+            if (name == null) {
+                throw new IllegalArgumentException("name can not be null");
+            }
+            this.name = name;
+
+            nextSibling = null;
+        public QName getName() {
+            return name;
+        }
+
+        public ChildNodeEntry getNextSibling() {
+            return nextSibling;
+        }
+
+        void setNextSibling(ChildNodeEntry nextSibling) {
+            if (nextSibling != null && !nextSibling.getName().equals(name)) {
+                throw new IllegalArgumentException("not a same-name sibling entry");
+            }
+
+            this.nextSibling = nextSibling;
+        }
+
+        int incIndex() {
+            return ++index;
+        }
+
+        int decIndex() {
+            if (index == 1) {
+                throw new IndexOutOfBoundsException();
+            }
+            return --index;
+        }
+
+        //---------------------------------------< java.lang.Object overrides >
+        /**
+         * Returns zero to satisfy the Object equals/hashCode contract.
+         * This class is mutable and not meant to be used as a hash key.
+         *
+         * @return always zero
+         * @see Object#hashCode()
+         */
-            // ChildNodeEntry is immutable, we can store the computed hash code value
-            int h = hash;
-            if (h == 0) {
-                h = 17;
-                h = 37 * h + name.hashCode();
-                h = 37 * h + uuid.hashCode();
-                h = 37 * h + index;
-                hash = h;
-            }
-            return h;
+            return 0;

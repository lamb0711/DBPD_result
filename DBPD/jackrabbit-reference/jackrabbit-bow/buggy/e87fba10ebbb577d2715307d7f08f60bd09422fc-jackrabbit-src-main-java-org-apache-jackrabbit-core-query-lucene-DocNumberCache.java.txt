Improve concurrent query performance

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@350028 13f79535-47bb-0310-9956-ffa450edef68

-     * LRU Map where key=uuid value=reader;docNumber
+     * The number of cache segments.
-    private final LRUMap docNumbers;
+    private static final int CACHE_SEGMENTS = 0x10;
+
+    /**
+     * Mask to calculate segment number.
+     */
+    private static final int CACHE_SEGMENTS_MASK = CACHE_SEGMENTS - 1;
+
+    /**
+     * LRU Maps where key=uuid value=reader;docNumber
+     */
+    private final LRUMap[] docNumbers = new LRUMap[CACHE_SEGMENTS];
-        docNumbers = new LRUMap(size);
+        size = size % CACHE_SEGMENTS;
+        if (size < 0x40) {
+            // minimum size is 0x40 * 0x10 = 1024
+            size = 0x40;
+        }
+        for (int i = 0; i < docNumbers.length; i++) {
+            docNumbers[i] = new LRUMap(size);
+        }
-    synchronized void put(String uuid, CachingIndexReader reader, int n) {
-        Entry e = (Entry) docNumbers.get(uuid);
-        if (e != null) {
-            // existing entry
-            // ignore if reader is older than the one in entry
-            if (reader.getCreationTick() <= e.reader.getCreationTick()) {
-                if (log.isDebugEnabled()) {
-                    log.debug("Ignoring put(). New entry is not from a newer reader. " +
-                            "existing: " + e.reader.getCreationTick() +
-                            ", new: " + reader.getCreationTick());
+    void put(String uuid, CachingIndexReader reader, int n) {
+        LRUMap cacheSegment = docNumbers[getSegmentIndex(uuid.charAt(0))];
+        synchronized (cacheSegment) {
+            Entry e = (Entry) cacheSegment.get(uuid);
+            if (e != null) {
+                // existing entry
+                // ignore if reader is older than the one in entry
+                if (reader.getCreationTick() <= e.reader.getCreationTick()) {
+                    if (log.isDebugEnabled()) {
+                        log.debug("Ignoring put(). New entry is not from a newer reader. " +
+                                "existing: " + e.reader.getCreationTick() +
+                                ", new: " + reader.getCreationTick());
+                    }
+                    e = null;
-                e = null;
+            } else {
+                // entry did not exist
+                e = new Entry(reader, n);
-        } else {
-            // entry did not exist
-            e = new Entry(reader, n);
-        }
-        if (e != null) {
-            docNumbers.put(uuid, e);
+            if (e != null) {
+                cacheSegment.put(uuid, e);
+            }
-    synchronized Entry get(String uuid) {
-        Entry entry = (Entry) docNumbers.get(uuid);
+    Entry get(String uuid) {
+        LRUMap cacheSegment = docNumbers[getSegmentIndex(uuid.charAt(0))];
+        Entry entry;
+        synchronized (cacheSegment) {
+            entry = (Entry) cacheSegment.get(uuid);
+        }
-                statistics.append("size=").append(docNumbers.size());
-                statistics.append("/").append(docNumbers.maxSize());
+                int inUse = 0;
+                for (int i = 0; i < docNumbers.length; i++) {
+                    inUse += docNumbers[i].size();
+                }
+                statistics.append("size=").append(inUse);
+                statistics.append("/").append(docNumbers[0].maxSize() * CACHE_SEGMENTS);
+    /**
+     * Returns the segment index for character c.
+     */
+    private static final int getSegmentIndex(char c) {
+        if (c > '9') {
+            c += 9;
+        }
+        return c & CACHE_SEGMENTS_MASK;
+    }
+

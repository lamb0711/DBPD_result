JCR-1588 - JSR 283: Access Control (work in progress)
JCR-1590 - JSR 283: Locking
JCR-1915 - Node.setPrimaryNodeType should only redefine child-definitions that are not covered by the new effective nt
JCR-1875 - Failing Node.unlock() might leave inconsistent transient state
JCR-538 - Failing Node.checkin() or Node.checkout() might leave inconsistent transient state

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@732693 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.spi.commons.conversion.MalformedPathException;
+import org.apache.jackrabbit.core.ItemValidator;
+import org.apache.jackrabbit.core.PropertyId;
+import org.apache.jackrabbit.core.WorkspaceImpl;
+import org.apache.jackrabbit.core.nodetype.PropDef;
+import org.apache.jackrabbit.core.state.ItemStateException;
+import org.apache.jackrabbit.core.state.NodeState;
+import org.apache.jackrabbit.core.state.PropertyState;
+import org.apache.jackrabbit.core.state.UpdatableItemStateManager;
+import org.apache.jackrabbit.core.value.InternalValue;
+import org.apache.jackrabbit.spi.Path;
+import org.apache.jackrabbit.spi.commons.conversion.MalformedPathException;
-import org.apache.jackrabbit.spi.Path;
+import javax.jcr.PropertyType;
-     * as the public method but will not modify content.
+     * as the public method.
+     *
+     * @param timeoutHint
+     * @param ownerInfo
-    AbstractLockInfo internalLock(NodeImpl node, boolean isDeep, boolean isSessionScoped)
+    AbstractLockInfo internalLock(NodeImpl node, boolean isDeep,
+                                  boolean isSessionScoped, long timeoutHint,
+                                  String ownerInfo)
+        String lockOwner = (ownerInfo != null) ? ownerInfo : session.getUserID();
-                isSessionScoped, isDeep, session.getUserID());
+                isSessionScoped, isDeep, lockOwner, timeoutHint);
-            operation = eventChannel.create(node.getNodeId(), isDeep, session.getUserID());
+            operation = eventChannel.create(node.getNodeId(), isDeep, lockOwner);
-            session.addLockToken(info.lockToken.toString(), false);
+            // TODO: TOBEFIXED for 2.0
+            // TODO  only tokens of open-scoped locks must be added to the session.
+            // if (!info.isSessionScoped()) {
+                session.addLockToken(info.lockToken.toString(), false);
+            //}
-
+
+        return lock(node, isDeep, isSessionScoped, Long.MAX_VALUE, null);
+    }
-        AbstractLockInfo info = internalLock(node, isDeep, isSessionScoped);
+    public Lock lock(NodeImpl node, boolean isDeep, boolean isSessionScoped, long timoutHint, String ownerInfo)
+            throws LockException, RepositoryException {
+        AbstractLockInfo info = internalLock(node, isDeep, isSessionScoped, timoutHint, ownerInfo);
+        writeLockProperties(node, info.lockOwner, info.deep);
+
+        removeLockProperties(node);
+    /**
+     * Add the lock related properties to the target node.
+     *
+     * @param node
+     * @param lockOwner
+     * @param isDeep
+     */
+    protected void writeLockProperties(NodeImpl node, String lockOwner, boolean isDeep) throws RepositoryException {
+        boolean success = false;
+
+        SessionImpl editingSession = (SessionImpl) node.getSession();
+        WorkspaceImpl wsp = (WorkspaceImpl) editingSession.getWorkspace();
+        UpdatableItemStateManager stateMgr = wsp.getItemStateManager();
+        ItemValidator helper = new ItemValidator(editingSession.getNodeTypeManager().getNodeTypeRegistry(), wsp.getHierarchyManager(), editingSession);
+
+        synchronized (stateMgr) {
+            if (stateMgr.inEditMode()) {
+                throw new RepositoryException("Unable to write lock properties.");
+            }
+            stateMgr.edit();
+            try {
+                // add properties to content
+                NodeId nodeId = node.getNodeId();
+                NodeState nodeState = (NodeState) stateMgr.getItemState(nodeId);
+
+                PropertyState propState;
+                if (!nodeState.hasPropertyName(NameConstants.JCR_LOCKOWNER)) {
+                    PropDef def = helper.findApplicablePropertyDefinition(NameConstants.JCR_LOCKOWNER, PropertyType.STRING, false, nodeState);
+                    propState = stateMgr.createNew(NameConstants.JCR_LOCKOWNER, nodeId);
+                    propState.setDefinitionId(def.getId());
+                    propState.setType(PropertyType.STRING);
+                    propState.setMultiValued(false);
+                } else {
+                    propState = (PropertyState) stateMgr.getItemState(new PropertyId(nodeId, NameConstants.JCR_LOCKOWNER));
+                }
+                propState.setValues(new InternalValue[] { InternalValue.create(lockOwner) });
+                nodeState.addPropertyName(NameConstants.JCR_LOCKOWNER);
+                stateMgr.store(nodeState);
+
+                if (!nodeState.hasPropertyName(NameConstants.JCR_LOCKISDEEP)) {
+                    PropDef def = helper.findApplicablePropertyDefinition(NameConstants.JCR_LOCKISDEEP, PropertyType.BOOLEAN, false, nodeState);
+                    propState = stateMgr.createNew(NameConstants.JCR_LOCKISDEEP, nodeId);
+                    propState.setDefinitionId(def.getId());
+                    propState.setType(PropertyType.BOOLEAN);
+                    propState.setMultiValued(false);
+                } else {
+                    propState = (PropertyState) stateMgr.getItemState(new PropertyId(nodeId, NameConstants.JCR_LOCKISDEEP));
+                }
+                propState.setValues(new InternalValue[] { InternalValue.create(isDeep) });
+                nodeState.addPropertyName(NameConstants.JCR_LOCKISDEEP);
+                stateMgr.store(nodeState);
+
+                stateMgr.update();
+                success = true;
+            } catch (ItemStateException e) {
+                throw new RepositoryException("Error while creating lock.", e);
+            } finally {
+                if (!success) {
+                    // failed to set lock meta-data content, cleanup
+                    stateMgr.cancel();
+                    try {
+                        unlock(node);
+                    } catch (RepositoryException e) {
+                        // cleanup failed
+                        log.error("error while cleaning up after failed lock attempt", e);
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     *
+     * @param node
+     * @throws RepositoryException
+     */
+    protected void removeLockProperties(NodeImpl node) throws RepositoryException {
+        boolean success = false;
+
+        SessionImpl editingSession = (SessionImpl) node.getSession();
+        WorkspaceImpl wsp = (WorkspaceImpl) editingSession.getWorkspace();
+        UpdatableItemStateManager stateMgr = wsp.getItemStateManager();
+
+        synchronized (stateMgr) {
+            try {
+                // add properties to content
+                NodeId nodeId = node.getNodeId();
+                NodeState nodeState = (NodeState) stateMgr.getItemState(nodeId);
+
+                if (stateMgr.inEditMode()) {
+                    throw new RepositoryException("Unable to remove lock properties.");
+                }
+                stateMgr.edit();
+                if (nodeState.hasPropertyName(NameConstants.JCR_LOCKOWNER)) {
+                    PropertyState propState = (PropertyState) stateMgr.getItemState(new PropertyId(nodeId, NameConstants.JCR_LOCKOWNER));
+                    nodeState.removePropertyName(NameConstants.JCR_LOCKOWNER);
+                    stateMgr.destroy(propState);
+                    stateMgr.store(nodeState);
+                }
+
+                if (nodeState.hasPropertyName(NameConstants.JCR_LOCKISDEEP)) {
+                    PropertyState propState = (PropertyState) stateMgr.getItemState(new PropertyId(nodeId, NameConstants.JCR_LOCKISDEEP));
+                    nodeState.removePropertyName(NameConstants.JCR_LOCKISDEEP);
+                    stateMgr.destroy(propState);
+                    stateMgr.store(nodeState);
+                }
+
+                stateMgr.update();
+                success = true;
+            } catch (ItemStateException e) {
+                throw new RepositoryException("Error while removing lock.", e);
+            } finally {
+                if (!success) {
+                    // failed to set lock meta-data content, cleanup
+                    stateMgr.cancel();
+                }
+            }
+        }
+    }
-            super(lockToken, sessionScoped, deep, lockOwner);
+            this(lockToken, sessionScoped, deep, lockOwner, Long.MAX_VALUE);
+        }
+
+        /**
+         * Create a new instance of this class.
+         *
+         * @param lockToken     lock token
+         * @param sessionScoped whether lock token is session scoped
+         * @param deep          whether lock is deep
+         * @param lockOwner     owner of lock
+         * @param timeoutHint
+         */
+        public LockInfo(LockToken lockToken, boolean sessionScoped,
+                        boolean deep, String lockOwner, long timeoutHint) {
+            super(lockToken, sessionScoped, deep, lockOwner, timeoutHint);
-                        log.warn("Unable to remove session-scoped lock on node '"
-                                + lockToken + "': " + e.getMessage());
-                        log.debug("Root cause: ", e);
+                        // Session is not allowed/able to unlock.
+                        // Use system session present with lock-mgr as fallback
+                        // in order to make sure, that session-scoped locks are
+                        // properly cleaned.
+                        SessionImpl systemSession = LockManagerImpl.this.session;
+                        setLockHolder(systemSession);
+                        try {
+                            NodeImpl node = (NodeImpl) systemSession.getItemManager().getItem(getId());
+                            node.unlock();
+                        } catch (RepositoryException re) {
+                            log.warn("Unable to remove session-scoped lock on node '" + lockToken + "': " + e.getMessage());
+                            log.debug("Root cause: ", e);
+                        }
-    public void externalLock(NodeId nodeId, boolean isDeep, String userId) throws RepositoryException {
+    public void externalLock(NodeId nodeId, boolean isDeep, String lockOwner) throws RepositoryException {
-            LockInfo info = new LockInfo(new LockToken(nodeId), false, isDeep, userId);
+            LockInfo info = new LockInfo(new LockToken(nodeId), false, isDeep, lockOwner);

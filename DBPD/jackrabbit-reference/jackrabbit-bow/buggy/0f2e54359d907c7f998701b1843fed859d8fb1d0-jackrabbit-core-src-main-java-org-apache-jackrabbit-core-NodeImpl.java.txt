JCR-1588 - JSR 283: Access Control (work in progress)
JCR-1590 - JSR 283: Locking
JCR-1915 - Node.setPrimaryNodeType should only redefine child-definitions that are not covered by the new effective nt
JCR-1875 - Failing Node.unlock() might leave inconsistent transient state
JCR-538 - Failing Node.checkin() or Node.checkout() might leave inconsistent transient state

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@732693 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.lock.LockManager;
+import org.apache.jackrabbit.core.security.authorization.Permission;
+import org.apache.jackrabbit.core.security.AccessManager;
+import org.apache.jackrabbit.api.jsr283.lock.LockManager;
+        } else {
+            // adding a node with explicit specifying the node type name
+            // requires the editing session to have nt_management privilege.
+            session.getAccessManager().checkPermission(nodePath, Permission.NODE_TYPE_MNGMT);
+        // check permissions
+        Path p = getPrimaryPath();
+        AccessManager acMgr = session.getAccessManager();
+        acMgr.checkPermission(p, Permission.NODE_TYPE_MNGMT);
+        // special handling of mix:versionable. since adding the mixin alters
+        // the version storage jcr:versionManagement privilege is required
+        // in addition.
+        if (NameConstants.MIX_VERSIONABLE.equals(mixinName)) {
+            acMgr.checkPermission(p, Permission.VERSION_MNGMT);
+        }
+        // check permission
+        session.getAccessManager().checkPermission(getPrimaryPath(), Permission.NODE_TYPE_MNGMT);
-        // walk through properties and child nodes and remove those that have been
-        // defined by the specified mixin type
-
-        // use temp set to avoid ConcurrentModificationException
-        HashSet set = new HashSet(thisState.getPropertyNames());
-        for (Iterator iter = set.iterator(); iter.hasNext();) {
-            Name propName = (Name) iter.next();
-            PropertyImpl prop = (PropertyImpl) itemMgr.getItem(
-                    new PropertyId(thisState.getNodeId(), propName));
-            // check if property has been defined by mixin type (or one of its supertypes)
-            NodeTypeImpl declaringNT = (NodeTypeImpl) prop.getDefinition().getDeclaringNodeType();
-            if (!entRemaining.includesNodeType(declaringNT.getQName())) {
-                // the remaining effective node type doesn't include the
-                // node type that declared this property, it is thus safe
-                // to remove it
-                removeChildProperty(propName);
+        // walk through properties and child nodes and remove those that have
+        // been defined by the specified mixin type
+        boolean success = false;
+        try {
+            // use temp set to avoid ConcurrentModificationException
+            HashSet set = new HashSet(thisState.getPropertyNames());
+            for (Iterator iter = set.iterator(); iter.hasNext();) {
+                Name propName = (Name) iter.next();
+                PropertyState propState = (PropertyState) stateMgr.getItemState(new PropertyId(thisState.getNodeId(), propName));
+                // check if property has been defined by mixin type (or one of its supertypes)
+                PropertyDefinition def = ntMgr.getPropertyDefinition(propState.getDefinitionId());
+                NodeTypeImpl declaringNT = (NodeTypeImpl) def.getDeclaringNodeType();
+                if (!entRemaining.includesNodeType(declaringNT.getQName())) {
+                    // the remaining effective node type doesn't include the
+                    // node type that declared this property, it is thus safe
+                    // to remove it
+                    removeChildProperty(propName);
+                }
-        }
-        // use temp array to avoid ConcurrentModificationException
-        ArrayList list = new ArrayList(thisState.getChildNodeEntries());
-        // start from tail to avoid problems with same-name siblings
-        for (int i = list.size() - 1; i >= 0; i--) {
-            ChildNodeEntry entry = (ChildNodeEntry) list.get(i);
-            NodeImpl node = (NodeImpl) itemMgr.getItem(entry.getId());
-            // check if node has been defined by mixin type (or one of its supertypes)
-            NodeTypeImpl declaringNT = (NodeTypeImpl) node.getDefinition().getDeclaringNodeType();
-            if (!entRemaining.includesNodeType(declaringNT.getQName())) {
-                // the remaining effective node type doesn't include the
-                // node type that declared this child node, it is thus safe
-                // to remove it
-                removeChildNode(entry.getName(), entry.getIndex());
+            // use temp array to avoid ConcurrentModificationException
+            ArrayList list = new ArrayList(thisState.getChildNodeEntries());
+            // start from tail to avoid problems with same-name siblings
+            for (int i = list.size() - 1; i >= 0; i--) {
+                ChildNodeEntry entry = (ChildNodeEntry) list.get(i);
+                NodeState nodeState = (NodeState) stateMgr.getItemState(entry.getId());
+                NodeDefinition def = ntMgr.getNodeDefinition(nodeState.getDefinitionId());
+                // check if node has been defined by mixin type (or one of its supertypes)
+                NodeTypeImpl declaringNT = (NodeTypeImpl) def.getDeclaringNodeType();
+                if (!entRemaining.includesNodeType(declaringNT.getQName())) {
+                    // the remaining effective node type doesn't include the
+                    // node type that declared this child node, it is thus safe
+                    // to remove it
+                    removeChildNode(entry.getName(), entry.getIndex());
+                }
+            }
+            success = true;
+        } catch (ItemStateException e) {
+            throw new RepositoryException("Failed to clean up child items defined by removed mixin " + session.getJCRName(mixinName));
+        } finally {
+            if (!success) {
+                // TODO revert changes made to the jcr:mixinTypes property
+
+        // check permissions
+        Path p = getPrimaryPath();
+        AccessManager acMgr = session.getAccessManager();
+        if (!acMgr.isGranted(p, Permission.NODE_TYPE_MNGMT)) {
+            return false;
+        }
+        // special handling of mix:versionable. since adding the mixin alters
+        // the version storage jcr:versionManagement privilege is required
+        // in addition.
+        if (NameConstants.MIX_VERSIONABLE.equals(ntName)) {
+            if (!acMgr.isGranted(p, Permission.VERSION_MNGMT)) {
+                return false;
+            }
+        }
+
+        // check permission
+        session.getAccessManager().checkPermission(getPrimaryPath(), Permission.VERSION_MNGMT);
-        internalSetProperty(NameConstants.JCR_ISCHECKEDOUT, InternalValue.create(false));
-        internalSetProperty(NameConstants.JCR_BASEVERSION, InternalValue.create(new UUID(v.getUUID())));
-        internalSetProperty(NameConstants.JCR_PREDECESSORS, InternalValue.EMPTY_ARRAY, PropertyType.REFERENCE);
-        save();
+        boolean success = false;
+        try {
+            internalSetProperty(NameConstants.JCR_ISCHECKEDOUT, InternalValue.create(false));
+            internalSetProperty(NameConstants.JCR_BASEVERSION, InternalValue.create(new UUID(v.getUUID())));
+            internalSetProperty(NameConstants.JCR_PREDECESSORS, InternalValue.EMPTY_ARRAY, PropertyType.REFERENCE);
+            save();
+            success = true;
+        } finally {
+            if (!success) {
+                try {
+                    // TODO: need to revert changes made within the version manager as well.
+                    refresh(false);
+                } catch (RepositoryException e) {
+                    // cleanup failed
+                    log.error("Error while cleaning up after failed Node.checkin", e);
+                }
+            }
+        }
+        // check permission
+        session.getAccessManager().checkPermission(getPrimaryPath(), Permission.VERSION_MNGMT);
-        boolean hasPendingChanges = session.hasPendingChanges();
-
+        boolean hasPendingChanges = hasPendingChanges();
-        props[0] = internalSetProperty(NameConstants.JCR_ISCHECKEDOUT, InternalValue.create(true));
-        props[1] = internalSetProperty(NameConstants.JCR_PREDECESSORS,
-                new InternalValue[]{
-                        InternalValue.create(new UUID(getBaseVersion().getUUID()))
-                });
-        if (hasPendingChanges) {
-            for (int i = 0; i < props.length; i++) {
-                props[i].save();
+        boolean success = false;
+        try {
+            props[0] = internalSetProperty(NameConstants.JCR_ISCHECKEDOUT, InternalValue.create(true));
+            props[1] = internalSetProperty(NameConstants.JCR_PREDECESSORS,
+                    new InternalValue[]{
+                            InternalValue.create(new UUID(getBaseVersion().getUUID()))
+                    });
+            if (hasPendingChanges) {
+                for (int i = 0; i < props.length; i++) {
+                    props[i].save();
+                }
+            } else {
+                save();
-        } else {
-            try {
-                session.save();
-            } catch (RepositoryException e) {
-                session.refresh(false);
-                throw e;
+            success = true;
+        } finally {
+            if (!success) {
+                for (int i = 0; i < props.length; i++) {
+                    if (props[i] != null) {
+                        try {
+                            props[i].refresh(false);
+                        } catch (RepositoryException e) {
+                            log.error("Error while cleaning up after failed Node.checkout", e);
+                        }
+                    }
+                }
-     * {@inheritDoc}
+     * Perform {@link Node#cancelMerge(Version)} or {@link Node#doneMerge(Version)}
+     * depending on the value of <code>cancel</code>.
+        // check permission
+        session.getAccessManager().checkPermission(getPrimaryPath(), Permission.VERSION_MNGMT);
-        // remove version from mergeFailed list
-        internalSetMergeFailed(failed);
+        boolean success = false;
+        try {
+            // remove version from mergeFailed list
+            internalSetMergeFailed(failed);
-        if (!cancel) {
-            // add version to jcr:predecessors list
-            Value[] vals = getProperty(NameConstants.JCR_PREDECESSORS).getValues();
-            InternalValue[] v = new InternalValue[vals.length + 1];
-            for (int i = 0; i < vals.length; i++) {
-                v[i] = InternalValue.create(UUID.fromString(vals[i].getString()));
+            if (!cancel) {
+                // add version to jcr:predecessors list
+                Value[] vals = getProperty(NameConstants.JCR_PREDECESSORS).getValues();
+                InternalValue[] v = new InternalValue[vals.length + 1];
+                for (int i = 0; i < vals.length; i++) {
+                    v[i] = InternalValue.create(UUID.fromString(vals[i].getString()));
+                }
+                v[vals.length] = InternalValue.create(UUID.fromString(version.getUUID()));
+                internalSetProperty(NameConstants.JCR_PREDECESSORS, v);
-            v[vals.length] = InternalValue.create(UUID.fromString(version.getUUID()));
-            internalSetProperty(NameConstants.JCR_PREDECESSORS, v);
-        }
-        // save
-        save();
+            save();
+            success = true;
+        } finally {
+            if (!success) {
+                try {
+                    refresh(false);
+                } catch (RepositoryException e) {
+                    log.error("Error while reverting changes upon failed Node.doneMerge or Node.cancelMerge, respectively.", e);
+                }
+            }
+        }
-     * {@inheritDoc}
+     * Executes the Node#update or Node#merge call.
+     *
+     * @param srcWorkspaceName Name of the source workspace as passed to
+     * {@link Node#merge(String, boolean)} or {@link Node#update(String)}.
+     * @param failedIds List to place the failed ids or <code>null</code> if
+     * {@link Node#update(String)} should be executed.
+     * @param bestEffort Flag passed to {@link Node#merge(String, boolean)} or
+     * false if {@link Node#update(String)} should be executed.
+     * @throws NoSuchWorkspaceException
+     * @throws AccessDeniedException
+     * @throws LockException
+     * @throws InvalidItemStateException
+     * @throws RepositoryException
+        // check permission
+        session.getAccessManager().checkPermission(getPrimaryPath(), Permission.VERSION_MNGMT);
+        boolean success = false;
-            try {
-                internalMerge(srcSession, failedIds, bestEffort, removeExisting, replaceExisting);
-            } catch (RepositoryException e) {
+            internalMerge(srcSession, failedIds, bestEffort, removeExisting, replaceExisting);
+            session.save();
+            success = true;
+        } finally {
+            if (!success) {
-                } catch (RepositoryException e1) {
-                    // ignore
+                } catch (RepositoryException e) {
+                    log.error("Error while cleaning up after failed merge/update", e);
-                throw e;
-            session.save();
-        } finally {
+        boolean success = false;
-        } catch (RepositoryException e) {
-            // revert session
-            try {
-                log.error("reverting changes applied during restore...");
-                session.refresh(false);
-            } catch (RepositoryException e1) {
-                // ignore this
+            session.save();
+            success = true;
+        } finally {
+            if (!success) {
+                // revert session
+                try {
+                    log.debug("reverting changes applied during restore...");
+                    session.refresh(false);
+                } catch (RepositoryException e) {
+                    log.error("Error while reverting changes applied during restore.", e);
+                }
-            throw e;
-        session.save();
+        // check permission
+        session.getAccessManager().checkPermission(getPrimaryPath(), Permission.VERSION_MNGMT);
+
-
-        // check for pending changes
-        if (hasPendingChanges()) {
-            String msg = "Unable to lock node. Node has pending changes: " + this;
-            log.debug(msg);
-            throw new InvalidItemStateException(msg);
-        }
-
-        checkLockable();
-
-        LockManager lockMgr = session.getLockManager();
-        synchronized (lockMgr) {
-            Lock lock = lockMgr.lock(this, isDeep, isSessionScoped);
-
-            boolean succeeded = false;
-
-            try {
-                // add properties to content
-                internalSetProperty(NameConstants.JCR_LOCKOWNER,
-                        InternalValue.create(getSession().getUserID()));
-                internalSetProperty(NameConstants.JCR_LOCKISDEEP,
-                        InternalValue.create(isDeep));
-                save();
-                succeeded = true;
-            } finally {
-                if (!succeeded) {
-                    // failed to set lock meta-data content, cleanup
-                    try {
-                        lockMgr.unlock(this);
-                        refresh(false);
-                    } catch (RepositoryException re) {
-                        // cleanup failed
-                        log.error("error while cleaning up after failed lock attempt", re);
-                    }
-                }
-            }
-
-            return lock;
-        }
+        LockManager lockMgr = ((WorkspaceImpl) session.getWorkspace()).get283LockManager();
+        return lockMgr.lock(getPath(), isDeep, isSessionScoped, Long.MAX_VALUE, null);
-
-        if (isNew()) {
-            throw new LockException("New node can not be locked: " + this);
-        }
-        return session.getLockManager().getLock(this);
+        LockManager lockMgr = ((WorkspaceImpl) session.getWorkspace()).get283LockManager();
+        return lockMgr.getLock(getPath());
-
-        // check for pending changes
-        if (hasPendingChanges()) {
-            String msg = "Unable to unlock node. Node has pending changes: " + this;
-            log.debug(msg);
-            throw new InvalidItemStateException(msg);
-        }
-
-        checkLockable();
-
-        LockManager lockMgr = session.getLockManager();
-        synchronized (lockMgr) {
-            if (lockMgr.isLockHolder(session, this)) {
-                // save first, and unlock later. this guards concurrent access
-
-                // remove properties in content
-                internalSetProperty(NameConstants.JCR_LOCKOWNER, (InternalValue) null);
-                internalSetProperty(NameConstants.JCR_LOCKISDEEP, (InternalValue) null);
-                save();
-            }
-            lockMgr.unlock(this);
-        }
+        LockManager lockMgr = ((WorkspaceImpl) session.getWorkspace()).get283LockManager();
+        lockMgr.unlock(getPath());
-
-        if (!isNodeType(NameConstants.MIX_LOCKABLE) || isNew()) {
-            // a node that is new or not lockable never holds a lock
-            return false;
-        }
-        return session.getLockManager().holdsLock(this);
+        LockManager lockMgr = ((WorkspaceImpl) session.getWorkspace()).get283LockManager();
+        return lockMgr.holdsLock(getPath());
-
-        if (isNew()) {
-            return false;
-        }
-        return session.getLockManager().isLocked(this);
-    }
-
-    /**
-     * Checks if this node is lockable, i.e. has 'mix:lockable'.
-     *
-     * @throws LockException       if this node is not lockable
-     * @throws RepositoryException if another error occurs
-     */
-    private void checkLockable() throws LockException, RepositoryException {
-        if (!isNodeType(NameConstants.MIX_LOCKABLE)) {
-            String msg =
-                "Unable to perform a locking operation on"
-                + " a non-lockable node: " + this;
-            log.debug(msg);
-            throw new LockException(msg);
-        }
+        LockManager lockMgr = ((WorkspaceImpl) session.getWorkspace()).get283LockManager();
+        return lockMgr.isLocked(getPath());
+        // check permission
+        session.getAccessManager().checkPermission(getPrimaryPath(), Permission.NODE_TYPE_MNGMT);
-        EffectiveNodeType entNew, entOld;
+        EffectiveNodeType entNew, entOld, entAll;
-            ntReg.getEffectiveNodeType(ntName, state.getMixinTypeNames());
+            entAll = ntReg.getEffectiveNodeType(ntName, state.getMixinTypeNames());
+        Set allDefs = new HashSet(Arrays.asList(entAll.getAllItemDefs()));
-                if (!newDefs.contains(ntReg.getPropDef(propState.getDefinitionId()))) {
+                if (!allDefs.contains(ntReg.getPropDef(propState.getDefinitionId()))) {
-
-                    PropertyDefinitionImpl pdi = null;
-                        pdi = getApplicablePropertyDefinition(
+                        PropertyDefinitionImpl pdi = getApplicablePropertyDefinition(
-                        // value conversion failed,
-                        // remove it
+                        // value conversion failed, remove it
-                NodeState nodeState =
-                        (NodeState) stateMgr.getItemState(entry.getId());
-                if (!newDefs.contains(ntReg.getNodeDef(nodeState.getDefinitionId()))) {
+                NodeState nodeState = (NodeState) stateMgr.getItemState(entry.getId());
+                if (!allDefs.contains(ntReg.getNodeDef(nodeState.getDefinitionId()))) {
-
-                    NodeDefinitionImpl ndi = null;
-                        NodeImpl node = (NodeImpl) itemMgr.getItem(nodeState.getId());
-                        ndi = getApplicableChildNodeDefinition(
+                        NodeDefinitionImpl ndi = getApplicableChildNodeDefinition(
-                        // redefine property
+                        // redefine node
+                        NodeImpl node = (NodeImpl) itemMgr.getItem(nodeState.getId());
-        // create new 'auto-create' items
+        // create items that are defined as auto-created by the new primary node
+        // type and at the same time were not present with the old nt

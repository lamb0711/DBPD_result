JSR 283: Shareable nodes support in query

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@763188 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.ItemManager;
+                private ItemManager itemMgr = session.getItemManager();
+
+         * Reusable array that holds document numbers of parents.
+         */
+        private int[] pDocs = new int[1];
+
+        /**
+         * Reusable array that holds a single document number.
+         */
+        private final int[] singleDoc = new int[1];
+
+        /**
-                if (isValid(subScorer.doc())) {
-                    return true;
-                } else {
-                    // find next valid
-                    return next();
-                }
+                return isValid(subScorer.doc()) || next();
-            int parentDoc = hResolver.getParent(doc);
+            pDocs = hResolver.getParents(doc, pDocs);
+
+            if (pDocs.length == 0) {
+                return false;
+            }
-            ancestorDocs[ancestorCount++] = parentDoc;
+            // can only remember one parent doc per level
+            ancestorDocs[ancestorCount++] = pDocs[0];
-            while (parentDoc != -1 && (!contextHits.get(parentDoc) || ancestorCount < minLevels)) {
-                parentDoc = hResolver.getParent(parentDoc);
-                // resize array if needed
-                if (ancestorCount == ancestorDocs.length) {
-                    // double the size of the new array
-                    int[] copy = new int[ancestorDocs.length * 2];
-                    System.arraycopy(ancestorDocs, 0, copy, 0, ancestorDocs.length);
-                    ancestorDocs = copy;
+            while (pDocs.length != 0) {
+                boolean valid = false;
+                for (int i = 0; i < pDocs.length; i++) {
+                    if (ancestorCount >= minLevels && contextHits.get(pDocs[i])) {
+                        valid = true;
+                        break;
+                    }
-                ancestorDocs[ancestorCount++] = parentDoc;
+                if (valid) {
+                    break;
+                } else {
+                    // load next level
+                    pDocs = getParents(pDocs, singleDoc);
+                    // resize array if needed
+                    if (ancestorCount == ancestorDocs.length) {
+                        // double the size of the new array
+                        int[] copy = new int[ancestorDocs.length * 2];
+                        System.arraycopy(ancestorDocs, 0, copy, 0, ancestorDocs.length);
+                        ancestorDocs = copy;
+                    }
+                    if (pDocs.length != 0) {
+                        // can only remember one parent doc per level
+                        ancestorDocs[ancestorCount++] = pDocs[0];
+                    }
+                }
-            if (parentDoc != -1) {
-                // since current parentDoc is a descendant of one of the context
+
+            if (pDocs.length > 0) {
+                // since current parentDocs are descendants of one of the context
+
+        /**
+         * Returns the parent document numbers for the given <code>docs</code>.
+         *
+         * @param docs  the current document numbers, for which to get the
+         *              parents.
+         * @param pDocs an array of document numbers for reuse as return value.
+         * @return the parent document number for the given <code>docs</code>.
+         * @throws IOException if an error occurs while reading from the index.
+         */
+        private int[] getParents(int[] docs, int[] pDocs) throws IOException {
+            // optimize single doc
+            if (docs.length == 1) {
+                return hResolver.getParents(docs[0], pDocs);
+            } else {
+                pDocs = new int[0];
+                for (int i = 0; i < docs.length; i++) {
+                    int[] p = hResolver.getParents(docs[i], new int[0]);
+                    int[] tmp = new int[p.length + pDocs.length];
+                    System.arraycopy(pDocs, 0, tmp, 0, pDocs.length);
+                    System.arraycopy(p, 0, tmp, pDocs.length, p.length);
+                    pDocs = tmp;
+                }
+                return pDocs;
+            }
+        }

JCR-1154: Throw DataStoreException instead of IOException

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@591286 13f79535-47bb-0310-9956-ffa450edef68

-                try {
-                    if (USE_DATA_STORE) {
-                        return new InternalValue(getBLOBFileValue(store, value.getStream()));
-                    }
-                    if (value instanceof BLOBFileValue) {
-                        return new InternalValue((BLOBFileValue) value);
-                    } else {
-                        InputStream stream = value.getStream();
+                if (USE_DATA_STORE) {
+                    return new InternalValue(getBLOBFileValue(store, value.getStream()));
+                }
+                if (value instanceof BLOBFileValue) {
+                    return new InternalValue((BLOBFileValue) value);
+                } else {
+                    InputStream stream = value.getStream();
+                    try {
+                        return createTemporary(stream);
+                    } finally {
-                            return createTemporary(stream);
-                        } finally {
-                            try {
-                                stream.close();
-                            } catch (IOException e) {
-                                // ignore
-                            }
+                            stream.close();
+                        } catch (IOException e) {
+                            // ignore
-                } catch (IOException ioe) {
-                    throw new ValueFormatException(ioe.getMessage());
-    public static InternalValue createTemporary(InputStream value) throws IOException {
+    public static InternalValue createTemporary(InputStream value) throws RepositoryException {
-        return new InternalValue(new BLOBValue(value, true));
+        try {
+            return new InternalValue(new BLOBValue(value, true));
+        } catch (IOException e) {
+            throw new RepositoryException("Error creating temporary file", e);
+        }
-    public static InternalValue createTemporary(InputStream value, DataStore store) throws IOException {
+    public static InternalValue createTemporary(InputStream value, DataStore store) throws RepositoryException {
-        return new InternalValue(new BLOBValue(value, true));
+        try {
+            return new InternalValue(new BLOBValue(value, true));
+        } catch (IOException e) {
+            throw new RepositoryException("Error creating temporary file", e);
+        }
-    public static InternalValue create(InputStream value) throws IOException {
+    public static InternalValue create(InputStream value) throws RepositoryException {
-        return new InternalValue(new BLOBValue(value, false));
+        try {
+            return new InternalValue(new BLOBValue(value, false));
+        } catch (IOException e) {
+            throw new RepositoryException("Error creating file", e);
+        }
+            InputStream stream = ((BLOBFileValue) val).getStream();
-                InputStream stream = ((BLOBFileValue) val).getStream();
+                return createTemporary(stream);
+            } finally {
-                    return createTemporary(stream);
-                } finally {
-                    try {
-                        stream.close();
-                    } catch (IOException e) {
-                        // ignore
-                    }
+                    stream.close();
+                } catch (IOException e) {
+                    // ignore
-            } catch (IOException ioe) {
-                throw new RepositoryException("failed to copy binary value", ioe);
-    private static BLOBFileValue getBLOBFileValue(DataStore store, InputStream in) throws IOException {
+    private static BLOBFileValue getBLOBFileValue(DataStore store, InputStream in) throws RepositoryException {
-        while (pos < maxMemorySize) {
-            int l = in.read(buffer, pos, len);
-            if (l < 0) {
-                break;
+        try {
+            while (pos < maxMemorySize) {
+                int l = in.read(buffer, pos, len);
+                if (l < 0) {
+                    break;
+                }
+                pos += l;
+                len -= l;
-            pos += l;
-            len -= l;
+        } catch (IOException e) {
+            throw new RepositoryException("Could not read from stream", e);

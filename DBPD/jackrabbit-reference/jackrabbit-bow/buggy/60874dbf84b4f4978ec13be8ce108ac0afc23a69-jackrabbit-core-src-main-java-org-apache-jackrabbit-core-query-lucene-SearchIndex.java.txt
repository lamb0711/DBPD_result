JCR-1990: Optimize queries with relative path in order by clause

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@746946 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.HierarchyManager;
+import org.apache.jackrabbit.core.state.PropertyState;
+import org.apache.jackrabbit.core.state.ItemStateException;
+import org.apache.lucene.analysis.Token;
+     * The path factory.
+     */
+    protected static final PathFactory PATH_FACTORY = PathFactoryImpl.getInstance();
+
+    /**
-        PathFactory factory = PathFactoryImpl.getInstance();
-        ROOT_PATH = factory.create(NameConstants.ROOT);
+        ROOT_PATH = PATH_FACTORY.create(NameConstants.ROOT);
-            JCR_SYSTEM_PATH = factory.create(ROOT_PATH, NameConstants.JCR_SYSTEM, false);
+            JCR_SYSTEM_PATH = PATH_FACTORY.create(ROOT_PATH, NameConstants.JCR_SYSTEM, false);
+                ItemStateManager ism = getContext().getItemStateManager();
+                    boolean ruleMatched = false;
+                    // node includes
-                    if (aggregates == null) {
-                        continue;
-                    }
-                    for (int j = 0; j < aggregates.length; j++) {
-                        Document aDoc = createDocument(aggregates[j],
-                                getNamespaceMappings(),
-                                index.getIndexFormatVersion());
-                        // transfer fields to doc if there are any
-                        Fieldable[] fulltextFields = aDoc.getFieldables(FieldNames.FULLTEXT);
-                        if (fulltextFields != null) {
-                            for (int k = 0; k < fulltextFields.length; k++) {
-                                doc.add(fulltextFields[k]);
+                    if (aggregates != null) {
+                        ruleMatched = true;
+                        for (int j = 0; j < aggregates.length; j++) {
+                            Document aDoc = createDocument(aggregates[j],
+                                    getNamespaceMappings(),
+                                    index.getIndexFormatVersion());
+                            // transfer fields to doc if there are any
+                            Fieldable[] fulltextFields = aDoc.getFieldables(FieldNames.FULLTEXT);
+                            if (fulltextFields != null) {
+                                for (int k = 0; k < fulltextFields.length; k++) {
+                                    doc.add(fulltextFields[k]);
+                                }
+                                doc.add(new Field(FieldNames.AGGREGATED_NODE_UUID,
+                                        aggregates[j].getNodeId().getUUID().toString(),
+                                        Field.Store.NO,
+                                        Field.Index.NO_NORMS));
-                            doc.add(new Field(FieldNames.AGGREGATED_NODE_UUID,
-                                    aggregates[j].getNodeId().getUUID().toString(),
-                                    Field.Store.NO,
-                                    Field.Index.NO_NORMS));
+                    // property includes
+                    PropertyState[] propStates = aggregateRules[i].getAggregatedPropertyStates(state);
+                    if (propStates != null) {
+                        ruleMatched = true;
+                        for (int j = 0; j < propStates.length; j++) {
+                            PropertyState propState = propStates[j];
+                            String namePrefix = FieldNames.createNamedValue(
+                                    getNamespaceMappings().translateName(propState.getName()), "");
+                            NodeState parent = (NodeState) ism.getItemState(propState.getParentId());
+                            Document aDoc = createDocument(parent, getNamespaceMappings(), getIndex().getIndexFormatVersion());
+                            // find the right fields to transfer
+                            Fieldable[] fields = aDoc.getFieldables(FieldNames.PROPERTIES);
+                            for (int k = 0; k < fields.length; k++) {
+                                Fieldable field = fields[k];
+                                // assume properties fields use SingleTokenStream
+                                Token t = field.tokenStreamValue().next();
+                                String value = new String(t.termBuffer(), 0, t.termLength());
+                                if (value.startsWith(namePrefix)) {
+                                    // extract value
+                                    value = value.substring(namePrefix.length());
+                                    // create new named value
+                                    Path p = getRelativePath(state, propState);
+                                    String path = getNamespaceMappings().translatePath(p);
+                                    value = FieldNames.createNamedValue(path, value);
+                                    t.setTermText(value);
+                                    doc.add(new Field(field.name(), new SingletonTokenStream(t)));
+                                    doc.add(new Field(FieldNames.AGGREGATED_NODE_UUID,
+                                            parent.getNodeId().getUUID().toString(),
+                                            Field.Store.NO,
+                                            Field.Index.NO_NORMS));
+                                }
+                            }
+                        }
+                    }
+
-                    break;
+                    if (ruleMatched) {
+                        break;
+                    }
+     * Returns the relative path from <code>nodeState</code> to
+     * <code>propState</code>.
+     *
+     * @param nodeState a node state.
+     * @param propState a property state.
+     * @return the relative path.
+     * @throws RepositoryException if an error occurs while resolving paths.
+     * @throws ItemStateException  if an error occurs while reading item
+     *                             states.
+     */
+    protected Path getRelativePath(NodeState nodeState, PropertyState propState)
+            throws RepositoryException, ItemStateException {
+        HierarchyManager hmgr = getContext().getHierarchyManager();
+        Path nodePath = hmgr.getPath(nodeState.getId());
+        Path propPath = hmgr.getPath(propState.getId());
+        Path p = nodePath.computeRelativePath(propPath);
+        // make sure it does not contain indexes
+        boolean clean = true;
+        Path.Element[] elements = p.getElements();
+        for (int i = 0; i < elements.length; i++) {
+            if (elements[i].getIndex() != 0) {
+                elements[i] = PATH_FACTORY.createElement(elements[i].getName());
+                clean = false;
+            }
+        }
+        if (!clean) {
+            p = PATH_FACTORY.create(elements);
+        }
+        return p;
+    }
+
+    /**

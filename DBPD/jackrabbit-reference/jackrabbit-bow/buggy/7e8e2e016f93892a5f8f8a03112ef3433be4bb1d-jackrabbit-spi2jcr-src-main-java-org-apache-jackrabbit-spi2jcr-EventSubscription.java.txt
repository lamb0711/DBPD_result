JCR-1204: Redesign SPI observation

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@592356 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.Subscription;
+import org.apache.jackrabbit.spi.commons.EventFilterImpl;
+import javax.jcr.observation.ObservationManager;
+import javax.jcr.RepositoryException;
+import java.util.Arrays;
+import java.util.Collections;
-class EventSubscription implements EventListener {
+class EventSubscription implements Subscription, EventListener {
+    /**
+     * Current list of filters. Copy on write is performed on this list.
+     */
+    private volatile List filters;
+
+    /**
+     * The resolver of the underlying session.
+     */
-    EventSubscription(IdFactory idFactory, SessionInfoImpl sessionInfo) {
+    /**
+     * Set to <code>true</code> if this subscription has been disposed.
+     */
+    private volatile boolean disposed = false;
+
+    /**
+     * Creates a new subscription for the passed session.
+     *
+     * @param idFactory   the id factory.
+     * @param sessionInfo the session info.
+     * @param filters     the filters that should be applied to the generated
+     *                    events.
+     * @throws RepositoryException if an error occurs while an event listener is
+     *                             registered with the session.
+     */
+    EventSubscription(IdFactory idFactory,
+                      SessionInfoImpl sessionInfo,
+                      EventFilter[] filters) throws RepositoryException {
+        setFilters(filters);
+        ObservationManager obsMgr = sessionInfo.getSession().getWorkspace().getObservationManager();
+        obsMgr.addEventListener(this, EventSubscription.ALL_EVENTS,
+                "/", true, null, null, true);
+     * @return the session info associated with this event subscription.
+     */
+    SessionInfoImpl getSessionInfo() {
+        return sessionInfo;
+    }
+
+    /**
+     * Sets a new list of event filters for this subscription.
+     *
+     * @param filters the new filters.
+     * @throws RepositoryException if the filters array contains a unknown
+     *                             implementation of EventFilters.
+     */
+    void setFilters(EventFilter[] filters) throws RepositoryException {
+        // check type
+        for (int i = 0; i < filters.length; i++) {
+            if (!(filters[i] instanceof EventFilterImpl)) {
+                throw new RepositoryException("Unknown filter implementation");
+            }
+        }
+        List tmp = new ArrayList(Arrays.asList(filters));
+        this.filters = Collections.unmodifiableList(tmp);
+
+    }
+
+    /**
+     * Removes this subscription as a listener from the observation manager and
+     * marks itself as disposed.
+     */
+    void dispose() throws RepositoryException {
+        sessionInfo.removeSubscription(this);
+        sessionInfo.getSession().getWorkspace().getObservationManager().removeEventListener(this);
+        disposed = true;
+        synchronized (eventBundles) {
+            eventBundles.notify();
+        }
+    }
+
+    //--------------------------< EventListener >-------------------------------
+
+    /**
-    EventBundle[] getEventBundles(EventFilter[] filters, long timeout) {
+    EventBundle[] getEventBundles(long timeout) {
-            while (eventBundles.isEmpty()) {
+            if (eventBundles.isEmpty()) {
+        EventFilter[] eventFilters = (EventFilter[]) filters.toArray(
+                new EventFilter[filters.size()]);
-                if (filters == null || filters.length == 0) {
+                if (eventFilters == null || eventFilters.length == 0) {
-                    for (int j = 0; j < filters.length; j++) {
-                        if (filters[j].accept(e, bundles[i].isLocal())) {
+                    for (int j = 0; j < eventFilters.length; j++) {
+                        if (eventFilters[j].accept(e, bundles[i].isLocal())) {
+        // do not create events when disposed
+        if (disposed) {
+            return;
+        }

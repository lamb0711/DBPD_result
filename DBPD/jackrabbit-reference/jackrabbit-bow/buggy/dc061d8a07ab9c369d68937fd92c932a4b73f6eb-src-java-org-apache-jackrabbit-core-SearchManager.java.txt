Simplify SearchManager and use SharedItemStateManager instead of SessionItemStateManager of system session.

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@156426 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.state.ItemStateManager;
+import java.util.List;
+import java.util.ArrayList;
- *
- * todo The SearchManager currently uses the system session to obtain an
- * ItemStateManager from where it reads persistent ItemStates. This is kind
- * of nasty, because the system session it is possible to change content through
- * the system session as well.
- * After switch to version 0.16 there is a shared ItemStateManager which
- * represents the persistent view of item states.
-     * HierarchyManager for path resolution
+     * The shared item state manager instance for the workspace.
-    private final HierarchyManager hmgr;
-
-    /**
-     * Session for accessing Nodes
-     */
-    private final SessionImpl session;
+    private final ItemStateManager itemMgr;
-    public SearchManager(SessionImpl session, SearchConfig config, NodeTypeRegistry ntReg)
-            throws RepositoryException {
-        this.session = session;
-        this.hmgr = session.getHierarchyManager();
+    /**
+     * Creates a new <code>SearchManager</code>.
+     * @param session the system session.
+     * @param config the search configuration.
+     * @param ntReg the node type registry.
+     * @param itemMgr the shared item state manager.
+     * @throws RepositoryException
+     */
+    public SearchManager(SessionImpl session,
+                         SearchConfig config,
+                         NodeTypeRegistry ntReg,
+                         ItemStateManager itemMgr) throws RepositoryException {
-
+        this.itemMgr = itemMgr;
-     * @param path the path of the node.
-    public void addNode(NodeState node, Path path)
+    public void addNode(NodeState node)
-        if (log.isDebugEnabled()) {
-            log.debug("add node to index: " + path);
-        }
-     * @param path the path of the node to delete.
-    public void deleteNode(Path path, String uuid) throws IOException {
-        if (log.isDebugEnabled()) {
-            log.debug("remove node from index: " + path.toString());
-        }
+    public void deleteNode(String uuid) throws IOException {
-        Set modified = new HashSet();
-        Set added = new HashSet();
-        // remember nodes we have to index at the end.
-        Set pendingNodes = new HashSet();
+        // nodes that need to be removed from the index.
+        Set removedNodes = new HashSet();
+        // nodes that need to be added to the index.
+        Set addedNodes = new HashSet();
+        // property events
+        List propEvents = new ArrayList();
-        // delete removed and modified nodes from index
-            try {
-                EventImpl e = (EventImpl) events.nextEvent();
-                long type = e.getType();
-                if (type == Event.NODE_ADDED) {
-
-                    // @todo use UUIDs for pending nodes?
-                    Path path = Path.create(e.getPath(),
-                            session.getNamespaceResolver(),
-                            true);
-                    pendingNodes.add(path);
-                    added.add(e.getChildUUID());
-                } else if (type == Event.NODE_REMOVED) {
-
-                    Path path = Path.create(e.getPath(),
-                            session.getNamespaceResolver(),
-                            true);
-                    deleteNode(path, e.getChildUUID());
-
-                } else if (type == Event.PROPERTY_ADDED
-                        || type == Event.PROPERTY_CHANGED
-                        || type == Event.PROPERTY_REMOVED) {
-
-                    Path path = Path.create(e.getPath(),
-                            session.getNamespaceResolver(),
-                            true).getAncestor(1);
-
-                    if (type == Event.PROPERTY_ADDED) {
-                        // do not delete and re-add if associated node got added too
-                        if (!added.contains(e.getParentUUID())) {
-                            deleteNode(path, e.getParentUUID());
-                            modified.add(e.getParentUUID());
-                            pendingNodes.add(path);
-                        }
-                    } else {
-                        if (!modified.contains(e.getParentUUID())) {
-                            deleteNode(path, e.getParentUUID());
-                            modified.add(e.getParentUUID());
-                            pendingNodes.add(path);
-                        } else {
-                            // already deleted
-                        }
-                    }
-
-                }
-            } catch (MalformedPathException e) {
-                log.error("error indexing node.", e);
-            } catch (RepositoryException e) {
-                log.error("error indexing node.", e);
-            } catch (IOException e) {
-                log.error("error indexing node.", e);
+            EventImpl e = (EventImpl) events.nextEvent();
+            long type = e.getType();
+            if (type == Event.NODE_ADDED) {
+                addedNodes.add(e.getChildUUID());
+            } else if (type == Event.NODE_REMOVED) {
+                removedNodes.add(e.getChildUUID());
+            } else {
+                propEvents.add(e);
-        for (Iterator it = pendingNodes.iterator(); it.hasNext();) {
+        // sort out property events
+        for (int i = 0; i < propEvents.size(); i++) {
+            EventImpl event = (EventImpl) propEvents.get(i);
+            String nodeUUID = event.getParentUUID();
+            if (event.getType() == Event.PROPERTY_ADDED) {
+                if (addedNodes.add(nodeUUID)) {
+                    // only property added
+                    // need to re-index
+                    removedNodes.add(nodeUUID);
+                } else {
+                    // the node where this prop belongs to is also new
+                }
+            } else if (event.getType() == Event.PROPERTY_CHANGED) {
+                // need to re-index
+                addedNodes.add(nodeUUID);
+                removedNodes.add(nodeUUID);
+            } else {
+                // property removed event is only generated when node still exists
+                addedNodes.add(nodeUUID);
+                removedNodes.add(nodeUUID);
+            }
+        }
+
+        for (Iterator it = removedNodes.iterator(); it.hasNext();) {
-                Path path = (Path) it.next();
-                ItemId id = hmgr.resolvePath(path);
-                addNode((NodeState) session.getItemStateManager().getItemState(id), path);
-            } catch (ItemStateException e) {
-                log.error("error indexing node.", e);
-            } catch (RepositoryException e) {
-                log.error("error indexing node.", e);
+                deleteNode((String) it.next());
-                log.error("error indexing node.", e);
+                log.error("Error deleting node from index.", e);
+            }
+        }
+        for (Iterator it = addedNodes.iterator(); it.hasNext();) {
+            try {
+                addNode((NodeState) itemMgr.getItemState(new NodeId((String) it.next())));
+            } catch (ItemStateException e) {
+                log.error("Error indexing node.", e);
+            } catch (RepositoryException e) {
+                log.error("Error indexing node.", e);
+            } catch (IOException e) {
+                log.error("Error indexing node.", e);

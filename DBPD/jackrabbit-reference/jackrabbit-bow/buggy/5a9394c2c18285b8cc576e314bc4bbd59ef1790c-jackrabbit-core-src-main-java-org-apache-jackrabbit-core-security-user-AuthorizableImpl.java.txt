JCR-2313 - Improvements to user management (2) [work in progress] 
-> see issue for details

JCR-2333 - ItemImpl#validateTransientItems: Incomplete validation of mandatory child item
-> patch2

JCR-2195 - Provide possibility to import protected items using Session/Workspace import functionality
-> deal with reference properties
-> make import handlers configurable
-> add userimporter

JCR-171 - Make the extraction of Session UserIDs from Subjects configurable
-> extend SecurityManagerConfig and retrieve uid from principal name if configured
     class is present in the subject

JCR-2351 - Make Authorizable.setProperty more noisy in case of failure

JCR-2331 - Configurable DefaultPolicy replacing Initialization within the ACProvider
-> initial steps. remove code that relies on the default-init
-> add TODOs

JCR-2291 - Issues with compiled permissions of ACL provider
-> remove code searching for DENY-read entries in case of default initialization of ac entries

and here and there minor improvement, usage of generics etc....

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@828791 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.PropertyImpl;
+import org.apache.jackrabbit.core.PropertyImpl;
-import javax.jcr.ItemNotFoundException;
-import javax.jcr.PropertyType;
+import javax.jcr.Session;
+import javax.jcr.ItemNotFoundException;
+import javax.jcr.AccessDeniedException;
+import javax.jcr.ItemVisitor;
+import javax.jcr.Node;
+import javax.jcr.util.TraversingItemVisitor;
-import java.util.Arrays;
+import java.util.Set;
+import java.util.HashSet;
+    private int hashCode;
-        if (!node.isNodeType(NT_REP_AUTHORIZABLE)) {
-            throw new IllegalArgumentException("Node argument of NodeType " + NT_REP_AUTHORIZABLE + " required");
-        }
-        List<Group> memberShip = new ArrayList<Group>();
+        Set<Group> memberShip = new HashSet<Group>();
-        List<Group> memberShip = new ArrayList<Group>();
+        Set<Group> memberShip = new HashSet<Group>();
+            // check if the property has already been created as multi valued
+            // property before -> in this case remove in order to avoid valueformatex.
+            if (node.hasProperty(name)) {
+                Property p = node.getProperty(name);
+                if (p.isMultiple()) {
+                    p.remove();
+                }
+            }
-            if (!userManager.batchModus) {
+            if (userManager.isAutoSave()) {
-            log.warn("Failed to set Property " + name + " for Authorizable " + getID());
+            log.warn("Failed to set Property " + name + " for " + this, e);
+            // check if the property has already been created as single valued
+            // property before -> in this case remove in order to avoid valueformatex.
+            if (node.hasProperty(name)) {
+                Property p = node.getProperty(name);
+                if (!p.isMultiple()) {
+                    p.remove();
+                }
+            }
-            if (!userManager.batchModus) {
+            if (userManager.isAutoSave()) {
-            log.warn("Failed to set Property " + name + " for Authorizable " + getID());
+            log.warn("Failed to set Property " + name + " for " + this, e);
-                if (!userManager.batchModus) {
+                if (userManager.isAutoSave()) {
-            log.warn("Failed to remove Property " + name + " from Authorizable " + getID());
+            log.warn("Failed to remove Property " + name + " from " + this, e);
-        userManager.removeProtectedItem(node, node.getParent());
+        Session s = getSession();
+        node.remove();
+        if (userManager.isAutoSave()) {
+            s.save();
+        }
+    }
+
+    //-------------------------------------------------------------< Object >---
+    @Override
+    public int hashCode() {
+        if (hashCode == 0) {
+            try {
+                StringBuilder sb = new StringBuilder();
+                sb.append(isGroup() ? "group:" : "user:");
+                sb.append(getSession().getWorkspace().getName());
+                sb.append(":");
+                sb.append(node.getIdentifier());
+                hashCode = sb.toString().hashCode();
+            } catch (RepositoryException e) {
+            }
+        }
+        return hashCode;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (obj instanceof AuthorizableImpl) {
+            AuthorizableImpl otherAuth = (AuthorizableImpl) obj;
+            try {
+                return isGroup() == otherAuth.isGroup() && node.isSame(otherAuth.node);
+            } catch (RepositoryException e) {
+                // should not occur -> return false in this case.
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public String toString() {
+        try {
+            String typeStr = (isGroup()) ? "Group '" : "User '";
+            return new StringBuilder().append(typeStr).append(getID()).append("'").toString();
+        } catch (RepositoryException e) {
+            return super.toString();
+        }
-    boolean addToGroup(GroupImpl group) throws RepositoryException {
-        try {
-            Value[] values;
-            Value added = getSession().getValueFactory().createValue(group.getNode(), true);
-            NodeImpl node = getNode();
-            if (node.hasProperty(P_GROUPS)) {
-                Value[] old = node.getProperty(P_GROUPS).getValues();
-                values = new Value[old.length + 1];
-                System.arraycopy(old, 0, values, 0, old.length);
-            } else {
-                values = new Value[1];
-            }
-            values[values.length - 1] = added;
-            userManager.setProtectedProperty(node, P_GROUPS, values, PropertyType.WEAKREFERENCE);
-            return true;
-        } catch (RepositoryException e) {
-            // revert all pending changes and rethrow.
-            getSession().refresh(false);
-            throw e;
-        }
-    }
-
-    boolean removeFromGroup(GroupImpl group) throws RepositoryException {
-        NodeImpl node = getNode();
-        String message = "Authorizable " + getID() + " is not member of " + group.getID();
-        if (!node.hasProperty(P_GROUPS)) {
-            log.debug(message);
-            return false;
-        }
-
-        Value toRemove = getSession().getValueFactory().createValue(group.getNode(), true);
-        PropertyImpl property = node.getProperty(P_GROUPS);
-        List<Value> valList = new ArrayList<Value>(Arrays.asList(property.getValues()));
-        if (valList.remove(toRemove)) {
-            try {
-                if (valList.isEmpty()) {
-                    userManager.removeProtectedItem(property, node);
-                } else {
-                    Value[] values = valList.toArray(new Value[valList.size()]);
-                    userManager.setProtectedProperty(node, P_GROUPS, values, PropertyType.WEAKREFERENCE);
+    private void collectMembership(final Set<Group> groups, boolean includeIndirect) throws RepositoryException {
+        PropertyIterator refs = getMembershipReferences();
+        if (refs != null) {
+            while (refs.hasNext()) {
+                try {
+                    NodeImpl n = (NodeImpl) refs.nextProperty().getParent();
+                    if (n.isNodeType(NT_REP_GROUP)) {
+                        Group group = userManager.createGroup(n);
+                        // only retrieve indirect membership if the group is not
+                        // yet present (detected eventual circular membership).
+                        if (groups.add(group) && includeIndirect) {
+                            ((AuthorizableImpl) group).collectMembership(groups, true);
+                        }
+                    } else {
+                        // weak-ref property 'rep:members' that doesn't reside under an
+                        // group node -> doesn't represent a valid group member.
+                        log.debug("Invalid member reference to '" + this + "' -> Not included in membership set.");
+                    }
+                } catch (ItemNotFoundException e) {
+                    // group node doesn't exist  -> -> ignore exception
+                    // and skip this reference from membership list.
+                } catch (AccessDeniedException e) {
+                    // not allowed to see the group node -> ignore exception
+                    // and skip this reference from membership list.
-                return true;
-            } catch (RepositoryException e) {
-                // modification failed -> revert all pending changes.
-                node.refresh(false);
-                throw e;
-            // nothing changed
-            log.debug(message);
-            return false;
+            // workaround for failure of Node#getWeakReferences
+            // traverse the tree below groups-path and collect membership manually.
+            log.info("Traversing groups tree to collect membership.");
+            ItemVisitor visitor = new TraversingItemVisitor.Default() {
+                @Override
+                protected void entering(Property property, int level) throws RepositoryException {
+                    PropertyImpl pImpl = (PropertyImpl) property;
+                    NodeImpl n = (NodeImpl) pImpl.getParent();
+                    if (P_MEMBERS.equals(pImpl.getQName()) && n.isNodeType(NT_REP_GROUP)) {
+                        for (Value value : property.getValues()) {
+                            if (value.getString().equals(node.getIdentifier())) {
+                                Group gr = (Group) userManager.getAuthorizable(n);
+                                groups.add(gr);
+                            }
+                        }
+                    }
+                }
+            };
+            Node groupsNode = getSession().getNode(userManager.getGroupsPath());
+            visitor.visit(groupsNode);
-    private void collectMembership(List<Group> groups, boolean includedIndirect) throws RepositoryException {
-        NodeImpl node = getNode();
-        if (!node.hasProperty(P_GROUPS)) {
-            return;
+    /**
+     * @return the iterator returned by {@link Node#getWeakReferences(String)}
+     * or <code>null</code> if the method call fails with <code>RepositoryException</code>.
+     * See fallback scenario above.
+     */
+    private PropertyIterator getMembershipReferences() {
+        PropertyIterator refs = null;
+        try {
+            refs = node.getWeakReferences(getSession().getJCRName(P_MEMBERS));
+        } catch (RepositoryException e) {
+            log.error("Failed to retrieve membership references of " + this + ".", e);
-        Value[] refs = node.getProperty(P_GROUPS).getValues();
-        for (Value ref : refs) {
-            try {
-                NodeImpl groupNode = (NodeImpl) getSession().getNodeByUUID(ref.getString());
-                Group group = GroupImpl.create(groupNode, userManager);
-                if (groups.add(group) && includedIndirect) {
-                    ((AuthorizableImpl) group).collectMembership(groups, true);
-                }
-            } catch (ItemNotFoundException e) {
-                // groupNode doesn't exist any more
-                log.warn("Group node referenced by " + getID() + " doesn't exist anymore -> Ignored from membership list.");
-                // TODO: possibly clean up list of group memberships
-            }
-        }
+        return refs;
-     * <ul>
-     * <li>rep:userId</li>
-     * <li>rep:referees</li>
-     * <li>rep:groups</li>
+     * <li>rep:members</li>
-                || P_GROUPS.equals(pName)
+                || P_MEMBERS.equals(pName)
-            throw new ConstraintViolationException("Attempt to modify protected property " + propertyName + " of an Authorizable.");
+            throw new ConstraintViolationException("Attempt to modify protected property " + propertyName + " of " + this);

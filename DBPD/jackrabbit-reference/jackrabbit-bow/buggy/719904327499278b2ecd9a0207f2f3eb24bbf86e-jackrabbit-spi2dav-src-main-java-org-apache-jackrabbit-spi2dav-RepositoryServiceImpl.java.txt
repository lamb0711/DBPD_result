JCR-2519: spi2davex: use srcWorkspaceName to build srcPath for clone and copy
JCR-2104: JSR 283 Full Versioning 
- jcr2spi: simplify VersionManager.checkpoint if Node is already checkedin
- spi2dav: implement shallow merge
- spi2dav: fix bug in merge (besteffort <-> DAV:no-auto-merge)
- spi2dav: fix bug in restore (nodeId may point to non-existing node -> extract existing parent + relPath
- jcr-server: implement shallow merge
- jcr-server: fix merge. for 1:1 remoting the MERGE response body should list the failed ids instead of the affected resource [DeltaV specified behaviour that doesn't make sense for remoting over SPI]
- jcr-server: prefer VersionManager over deprecated version methods
- jcr-server: fix restore with relPath



git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@916278 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.commons.httpclient.methods.HeadMethod;
-        return uriResolver.getItemUri(itemId, sessionInfo.getWorkspaceName(), sessionInfo);
+        return getItemUri(itemId, sessionInfo, sessionInfo.getWorkspaceName());
+    }
+
+    protected String getItemUri(ItemId itemId, SessionInfo sessionInfo, String workspaceName) throws RepositoryException {
+        return uriResolver.getItemUri(itemId, workspaceName, sessionInfo);
-            int type = JcrValueType.typeFromContentType(ct);
+            int type;
-            if (type != PropertyType.UNDEFINED) {
+            if (ct.startsWith("jcr-value")) {
+                type = JcrValueType.typeFromContentType(ct);                
+            
-        update(uri, new String[] {workspUri}, UpdateInfo.UPDATE_BY_WORKSPACE, false, sessionInfo);
+        update(uri, null, new String[] {workspUri}, UpdateInfo.UPDATE_BY_WORKSPACE, false, sessionInfo);
-        // TODO
-        throw new UnsupportedOperationException("JCR-2104: JSR 283 Versioning. Implementation missing");
+        if (activityId == null) {
+            checkout(sessionInfo, nodeId);
+        } else {
+            // TODO
+            throw new UnsupportedOperationException("JCR-2104: JSR 283 Versioning. Implementation missing");
+        }
-        // TODO
-        throw new UnsupportedOperationException("JCR-2104: JSR 283 Versioning. Implementation missing");
+        // TODO review again.
+        NodeId vID = checkin(sessionInfo, nodeId);
+        checkout(sessionInfo, nodeId);
+        return vID;
-        update(uri, new String[] {vUri}, UpdateInfo.UPDATE_BY_VERSION, removeExisting, sessionInfo);
+        Path relPath = null;
+        if (!exists(sessionInfo, uri)) {
+            // restore with rel-Path part
+            Path path = nodeId.getPath();
+            if (nodeId.getUniqueID() != null) {
+                uri = getItemUri(idFactory.createNodeId(nodeId.getUniqueID(), null), sessionInfo);
+                relPath = (path.isAbsolute()) ? getPathFactory().getRootPath().computeRelativePath(path) : path;
+            } else {
+                int degree = 0;
+                while (degree < path.getLength()) {
+                    Path ancestorPath = path.getAncestor(degree);
+                    NodeId parentId = idFactory.createNodeId(nodeId.getUniqueID(), ancestorPath);
+                    if (exists(sessionInfo, getItemUri(parentId, sessionInfo))) {
+                        uri = getItemUri(parentId, sessionInfo);
+                        relPath = ancestorPath.computeRelativePath(path);
+                        break;
+                    }
+                    degree++;
+                }
+            }
+        }
+
+        update(uri, relPath, new String[] {vUri}, UpdateInfo.UPDATE_BY_VERSION, removeExisting, sessionInfo);
+    private boolean exists(SessionInfo sInfo, String uri) {
+        HeadMethod method = new HeadMethod(uri);
+        try {
+            int statusCode = getClient(sInfo).executeMethod(method);
+            if (statusCode == DavServletResponse.SC_OK) {
+                return true;
+            }
+        } catch (IOException e) {
+            log.error("Unexpected error while testing existence of item.",e);
+        } catch (RepositoryException e) {
+            log.error(e.getMessage());
+        } finally {
+            method.releaseConnection();
+        }
+        return false;
+    }
+
+
-        update(uri, vUris, UpdateInfo.UPDATE_BY_VERSION, removeExisting, sessionInfo);
+        update(uri, null, vUris, UpdateInfo.UPDATE_BY_VERSION, removeExisting, sessionInfo);
-    private void update(String uri, String[] updateSource, int updateType, boolean removeExisting, SessionInfo sessionInfo) throws RepositoryException {
+    private void update(String uri, Path relPath, String[] updateSource, int updateType, boolean removeExisting, SessionInfo sessionInfo) throws RepositoryException {
-            if (removeExisting) {
+            if (removeExisting || relPath != null) {
-                DomUtil.addChildElement(uElem, ItemResourceConstants.XML_REMOVEEXISTING, ItemResourceConstants.NAMESPACE);
+                if (removeExisting) {
+                    DomUtil.addChildElement(uElem, ItemResourceConstants.XML_REMOVEEXISTING, ItemResourceConstants.NAMESPACE);
+                }
+                if (relPath != null) {
+                    DomUtil.addChildElement(uElem, ItemResourceConstants.XML_RELPATH, ItemResourceConstants.NAMESPACE, getNamePathResolver(sessionInfo).getJCRPath(relPath));
+                }
+
-        if (!isShallow) {
-            try {
-                String wspHref = uriResolver.getWorkspaceUri(srcWorkspaceName);
-                Element mElem = MergeInfo.createMergeElement(new String[] {wspHref}, bestEffort, false, domFactory);
-                MergeInfo mInfo = new MergeInfo(mElem);
-
-                MergeMethod method = new MergeMethod(getItemUri(nodeId, sessionInfo), mInfo);
-                execute(method, sessionInfo);
-
-                MultiStatusResponse[] resps = method.getResponseBodyAsMultiStatus().getResponses();
-                List<NodeId> failedIds = new ArrayList<NodeId>(resps.length);
-                for (MultiStatusResponse resp : resps) {
-                    String href = resp.getHref();
-                    failedIds.add(uriResolver.getNodeId(href, sessionInfo));
-                }
-                return failedIds.iterator();
-            } catch (IOException e) {
-                throw new RepositoryException(e);
-            } catch (DavException e) {
-                throw ExceptionConverter.generate(e);
+        try {
+            String wspHref = uriResolver.getWorkspaceUri(srcWorkspaceName);
+            Element mElem = MergeInfo.createMergeElement(new String[] {wspHref}, !bestEffort, false, domFactory);
+            if (isShallow) {
+                mElem.appendChild(DomUtil.depthToXml(false, domFactory));
-        } else {
-            // TODO
-            throw new UnsupportedOperationException("JCR-2104: JSR 283 Versioning. Implementation missing");
+            MergeInfo mInfo = new MergeInfo(mElem);
+
+            MergeMethod method = new MergeMethod(getItemUri(nodeId, sessionInfo), mInfo);
+            execute(method, sessionInfo);
+
+            MultiStatusResponse[] resps = method.getResponseBodyAsMultiStatus().getResponses();
+            List<NodeId> failedIds = new ArrayList<NodeId>(resps.length);
+            for (MultiStatusResponse resp : resps) {
+                String href = resp.getHref();
+                failedIds.add(uriResolver.getNodeId(href, sessionInfo));
+            }
+            return failedIds.iterator();
+        } catch (IOException e) {
+            throw new RepositoryException(e);
+        } catch (DavException e) {
+            throw ExceptionConverter.generate(e);

JSR 283: Shareable nodes support in query

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@763188 13f79535-47bb-0310-9956-ffa450edef68

+                // 7) shareable node added
+                // 8) shareable node removed
+                // in case 7) parent of added shareable node has new child node
+                // entry.
+                // in case 8) parent of removed shareable node has removed child
+                // node entry.
+
+                // create events if n is shareable
+                createShareableNodeEvents(n, changes, hmgr, stateMgr);
+
+                // create events if n is shareable
+                createShareableNodeEvents(n, changes, hmgr, stateMgr);
+
+                // create events if n is shareable
+                createShareableNodeEvents(n, changes, hmgr, stateMgr);
+    private void createShareableNodeEvents(NodeState n,
+                                           ChangeLog changes,
+                                           ChangeLogBasedHierarchyMgr hmgr,
+                                           ItemStateManager stateMgr)
+            throws ItemStateException {
+        if (n.isShareable()) {
+            // check if a share was added or removed
+            for (Iterator added = n.getAddedShares().iterator(); added.hasNext(); ) {
+                NodeId parentId = (NodeId) added.next();
+                // ignore primary parent id
+                if (n.getParentId().equals(parentId)) {
+                    continue;
+                }
+                NodeState parent = (NodeState) changes.get(parentId);
+                if (parent == null) {
+                    // happens when mix:shareable is added to an existing node
+                    // usually the parent node state is in the change log
+                    // when a node is added to a shared set -> new child node
+                    // entry on parent node state.
+                    parent = (NodeState) stateMgr.getItemState(parentId);
+                }
+                Name ntName = getNodeType(parent, session).getQName();
+                EventState es = EventState.childNodeAdded(parentId,
+                        getPath(parentId, hmgr),
+                        n.getNodeId(),
+                        getNameElement(n.getNodeId(), parentId, hmgr),
+                        ntName,
+                        parent.getMixinTypeNames(),
+                        session);
+                es.setShareableNode(true);
+                events.add(es);
+            }
+            for (Iterator removed = n.getRemovedShares().iterator(); removed.hasNext(); ) {
+                NodeId parentId = (NodeId) removed.next();
+                // if this shareable node is removed, only create events for
+                // parent ids that are not primary
+                if (n.getParentId().equals(parentId)) {
+                    continue;
+                }
+                NodeState parent = (NodeState) changes.get(parentId);
+                if (parent == null) {
+                    // happens when mix:shareable is removed from an existing
+                    // node. Usually the parent node state is in the change log
+                    // when a node is removed to a shared set -> removed child
+                    // node entry on parent node state.
+                    parent = (NodeState) stateMgr.getItemState(parentId);
+                }
+                Name ntName = getNodeType(parent, session).getQName();
+                EventState es = EventState.childNodeRemoved(parentId,
+                        getZombiePath(parentId, hmgr),
+                        n.getNodeId(),
+                        getZombieNameElement(n.getNodeId(), parentId, hmgr),
+                        ntName,
+                        parent.getMixinTypeNames(),
+                        session);
+                es.setShareableNode(true);
+                events.add(es);
+            }
+        }
+    }
+
+     * Returns the name element for the node with the given <code>nodeId</code>
+     * and its parent with <code>parentId</code>. This method is only useful
+     * if <code>nodeId</code> denotes a shareable node.
+     *
+     * @param nodeId the node id of a shareable node.
+     * @param parentId the id of the parent node.
+     * @param hmgr the hierarchy manager.
+     * @return the name element for the node.
+     * @throws ItemStateException if an error occurs while resolving the name.
+     */
+    private Path.Element getNameElement(NodeId nodeId,
+                                        NodeId parentId,
+                                        HierarchyManager hmgr)
+            throws ItemStateException {
+        try {
+            Name name = hmgr.getName(nodeId, parentId);
+            PathBuilder builder = new PathBuilder();
+            builder.addFirst(name);
+            return builder.getPath().getNameElement();
+        } catch (RepositoryException e) {
+            String msg = "Unable to get name for node with id: " + nodeId;
+            throw new ItemStateException(msg, e);
+        }
+    }
+
+    /**
+     * Returns the <i>zombie</i> (i.e. the old) name element for the node with
+     * the given <code>nodeId</code> and its parent with <code>parentId</code>.
+     * This method is only useful if <code>nodeId</code> denotes a shareable
+     * node.
+     *
+     * @param nodeId   the node id of a shareable node.
+     * @param parentId the id of the parent node.
+     * @param hmgr     the hierarchy manager.
+     * @return the name element for the node.
+     * @throws ItemStateException if an error occurs while resolving the name.
+     */
+    private Path.Element getZombieNameElement(NodeId nodeId,
+                                              NodeId parentId,
+                                              ChangeLogBasedHierarchyMgr hmgr)
+            throws ItemStateException {
+        try {
+            Name name = hmgr.getZombieName(nodeId, parentId);
+            PathBuilder builder = new PathBuilder();
+            builder.addFirst(name);
+            return builder.getPath().getNameElement();
+        } catch (RepositoryException e) {
+            // should never happen actually
+            String msg = "Unable to resolve zombie name for item: " + nodeId;
+            log.error(msg);
+            throw new ItemStateException(msg, e);
+        }
+    }
+
+    /**

JCR-2699: Improve read/write concurrency

Even the tiny synchronized block in the LRU cache becomes a source of lock contention, so replace it with a segmented cache that has now single synchronization block over the entire cache. The downside is a slight deviation from the LRU eviction policy.

Replaced the BundleCache and LRUNodeIdCache classes with the new ConcurrentCache implementation. Instead of using a separate data structure, a special MISSING sentinel bundle is used to to mark non-existent bundles.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1004182 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.cache.ConcurrentCache;
-import org.apache.jackrabbit.core.persistence.util.BundleCache;
-import org.apache.jackrabbit.core.persistence.util.LRUNodeIdCache;
- * {@link BundleCache} that caches already loaded bundles. The other is the
+ * bundle cache that caches already loaded bundles. The other is the
+    /** Sentinel instance used to mark a non-existent bundle in the cache */
+    private static final NodePropBundle MISSING =
+        new NodePropBundle(new NodeId());
+
-    private BundleCache bundles;
-
-    /** the cache of non-existent bundles */
-    private LRUNodeIdCache missing;
+    private ConcurrentCache<NodeId, NodePropBundle> bundles;
-            if (state.isNode()) {
-                bundles.remove((NodeId) state.getId());
-            } else {
-                bundles.remove(state.getParentId());
-            }
+            bundles.remove(getBundleId(state));
-            if (state.isNode()) {
-                bundles.remove((NodeId) state.getId());
-            } else {
-                bundles.remove(state.getParentId());
-            }
+            bundles.remove(getBundleId(state));
-            if (state.isNode()) {
-                missing.remove((NodeId) state.getId());
-            } else {
-                missing.remove(state.getParentId());
-            }
+            // There may have been a cache miss entry
+            bundles.remove(getBundleId(state));
+        }
+    }
+
+    private NodeId getBundleId(ItemState state) {
+        if (state.isNode()) {
+            return (NodeId) state.getId();
+        } else {
+            return state.getParentId();
-        bundles = new BundleCache(bundleCacheSize);
-        missing = new LRUNodeIdCache();
+        bundles = new ConcurrentCache<NodeId, NodePropBundle>();
+        bundles.setMaxMemorySize(bundleCacheSize);
-        missing.clear();
-                missing.clear();
-        if (missing.contains(id)) {
-            return null;
-        }
-        if (bundle == null) {
+        if (bundle == MISSING) {
+            return null;
+        } else if (bundle == null) {
-                    bundles.put(bundle);
+                    bundles.put(id, bundle, bundle.getSize());
-                    missing.put(id);
+                    bundles.put(id, MISSING, 16);
-        missing.put(bundle.getId());
+        bundles.put(bundle.getId(), MISSING, 16);
-        missing.remove(bundle.getId());
-        if (bundles.contains(bundle.getId())) {
-            bundles.put(bundle);
+        if (bundles.containsKey(bundle.getId())) {
+            bundles.remove(bundle.getId());
+            bundles.put(bundle.getId(), bundle, bundle.getSize());

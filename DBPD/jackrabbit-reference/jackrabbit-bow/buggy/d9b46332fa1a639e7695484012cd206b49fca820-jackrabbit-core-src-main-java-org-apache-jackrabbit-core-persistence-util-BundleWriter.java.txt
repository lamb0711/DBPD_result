JCR-2762: Optimize bundle serialization

Use a variable-length encoding for internal counts and lengths that are never negative and almost always small.

Optimize the property state header from 12 to 2 bytes in most cases.

Drop serialization of definition identifiers as they are no longer used in Jackrabbit.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1022487 13f79535-47bb-0310-9956-ffa450edef68

-        // definitionId
-        out.writeUTF("");
-
-        out.writeShort(bundle.getModCount());
+        writeInt(bundle.getModCount());
-     * Serializes a <code>PropertyState</code> to the data output stream
+     * Serializes a property entry. The serialization begins with a single
+     * byte that encodes the type and multi-valuedness of the property:
+     * <pre>
+     * +-------------------------------+
+     * |   mv count    |     type      |
+     * +-------------------------------+
+     * </pre>
+     * <p>
+     * The lower four bits encode the property type (0-12 in JCR 2.0) and
+     * higher bits indicate whether this is a multi-valued property and how
+     * many property values there are. A value of 0 is reserved for
+     * single-valued properties (that are guaranteed to always have just a
+     * single value), and all non-zero values indicate a multi-valued property.
+     * <p>
+     * In multi-valued properties the exact value of the "mv count" field is
+     * the number of property values plus one and truncated at 15 (the highest
+     * four-bit value). If there are 14 or more (14 + 1 == 15) property values,
+     * then the number of additional values is serialized as a variable-length
+     * integer (see {@link #writeInt(int)}) right after this byte.
+     * <p>
+     * The modification count of the property state is written next as a
+     * variable-length integer, followed by the serializations of all the
+     * values of this property.
-        // type & mod count
-        out.writeInt(state.getType() | (state.getModCount() << 16));
-        // multiValued
-        out.writeBoolean(state.isMultiValued());
-        // definitionId
-        out.writeUTF("");
-        // values
-        out.writeInt(values.length); // count
+
+        int type = state.getType();
+        assert 0 <= type && type <= 0x0f;
+        if (state.isMultiValued()) {
+            int len = values.length + 1;
+            if (len < 0x0f) {
+                out.writeByte(len << 4 | type);
+            } else {
+                out.writeByte(0xf0 | type);
+                writeInt(len - 0x0f);
+            }
+        } else {
+            assert values.length == 1;
+            out.writeByte(type);
+        }
+
+        writeInt(state.getModCount());
+
+        // values
-                    out.writeInt(bytes.length); // length of byte[]
+                    writeInt(bytes.length); // length of byte[]
+    /**
+     * Serializes an integer using a variable-length encoding that favors
+     * small positive numbers. The serialization consists of one to five
+     * bytes of the following format:
+     * <pre>
+     * +-------------------------------+
+     * | c | 7 least significant bits  |
+     * +-------------------------------+
+     * </pre>
+     * <p>
+     * If the given integer fits in seven bits (i.e. the value between
+     * 0 and 127, inclusive), then it is written as-is in a single byte.
+     * Otherwise the continuation flag <code>c</code> is set and the least
+     * significant seven bits are written together with the flag as a single
+     * byte. The integer is then shifed right seven bits and the process
+     * continues from the beginning.
+     * <p>
+     * This format uses a single byte for values 0-127, two bytes for
+     * 128-16343, three for 16343-2097151, four for 2097152-268435455
+     * and five bytes for all other 32-bit numbers (including negative ones).
+     *
+     * @param integer integer value
+     * @throws IOException if an I/O error occurs
+     */
+    private void writeInt(int value) throws IOException {
+        int b = value & 0x7f;
+        if (b == value) {
+            out.writeByte(b);
+        } else {
+            out.writeByte(b | 0x80);
+            writeInt(value >>> 7);
+        }
+    }
+

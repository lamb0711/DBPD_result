JCR-1516: Add Compact Namespace and Node Type Definition support to spi-commons

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@644745 13f79535-47bb-0310-9956-ffa450edef68

-package org.apache.jackrabbit.jcr2spi.nodetype;
+package org.apache.jackrabbit.spi.commons.nodetype;
-import org.apache.jackrabbit.spi.commons.conversion.IllegalNameException;
+import org.apache.jackrabbit.spi.NameFactory;
-import org.apache.jackrabbit.spi.commons.nodetype.InvalidConstraintException;
+    // TODO improve. don't rely on a specific factory impl
+    static final NameFactory NAME_FACTORY = NameFactoryImpl.getInstance();
+
+     * Check if the specified value matches the this constraint.
-     * @param value
-     * @throws ConstraintViolationException
-     * @throws RepositoryException
+     * @param value The value to be tested.
+     * @throws ConstraintViolationException If the specified value is
+     * <code>null</code> or does not matches the constraint.
+     * @throws RepositoryException If another error occurs.
-
-                return new NameConstraint(qualifiedDefinition);
+                return NameConstraint.create(qualifiedDefinition);
-                return new PathConstraint(qualifiedDefinition);
+                return PathConstraint.create(qualifiedDefinition);
-                return new ReferenceConstraint(qualifiedDefinition);
+                return ReferenceConstraint.create(qualifiedDefinition);
-                return new NameConstraint(definition, resolver);
+                return NameConstraint.create(definition, resolver);
-                return new PathConstraint(definition, resolver);
+                return PathConstraint.create(definition, resolver);
-                return new ReferenceConstraint(definition, resolver);
+                return ReferenceConstraint.create(definition, resolver);
+
-    PathConstraint(String qualifiedDefinition) {
-        super(qualifiedDefinition);
+    static PathConstraint create(String qualifiedDefinition) throws InvalidConstraintException {
-        deep = qualifiedDefinition.endsWith("*");
+        boolean deep = qualifiedDefinition.endsWith("*");
+        Path path;
-        path = PathFactoryImpl.getInstance().create(qualifiedDefinition);
+        if (deep) {
+            path = PathFactoryImpl.getInstance().create(qualifiedDefinition.substring(0, qualifiedDefinition.length() - 1));
+        } else {
+            path = PathFactoryImpl.getInstance().create(qualifiedDefinition);
+        }
+        return new PathConstraint(qualifiedDefinition, path, deep);
-    PathConstraint(String definition, PathResolver resolver)
+    static PathConstraint create(String definition, PathResolver resolver)
-        super(definition);
-
-        // constraint format: absolute or relative path with optional trailing wildcard
-        deep = definition.endsWith("*");
-        if (deep) {
-            // trim trailing wildcard before building path
-            definition = definition.substring(0, definition.length() - 1);
-        }
-            path = resolver.getQPath(definition);
+            StringBuffer qualifiedDefinition = new StringBuffer();
+            // constraint format: absolute or relative path with optional
+            // trailing wildcard
+            boolean deep = definition.endsWith("/*");
+            if (deep) {
+                // trim trailing wildcard before building path
+                if (definition.equals("/*")) {
+                    definition = "/";
+                    qualifiedDefinition.append('*');
+                } else {
+                    definition = definition.substring(0, definition.length() - 2);
+                    qualifiedDefinition.append("/*");
+                }
+            }
+            Path path = resolver.getQPath(definition);
+            qualifiedDefinition.insert(0, path.getString());
+
+            return new PathConstraint(qualifiedDefinition.toString(), path, deep);
+    private PathConstraint(String qualifiedDefinition, Path path, boolean deep) throws InvalidConstraintException {
+        super(qualifiedDefinition);
+        this.path = path;
+        this.deep = deep;
+    }
+
-     * Returns the String representation of the path.
-     *
-     * @return String representation of the path.
-     * @see ValueConstraint#getQualifiedDefinition()
-     */
-    public String getQualifiedDefinition() {
-        return path.toString();
-    }
-
-    /**
-    NameConstraint(String qualifiedDefinition) {
-        super(qualifiedDefinition);
+    static NameConstraint create(String qualifiedDefinition) {
-        // TODO improve. don't rely on a specific factory impl
-        name = NameFactoryImpl.getInstance().create(qualifiedDefinition);
+        return new NameConstraint(qualifiedDefinition, NAME_FACTORY.create(qualifiedDefinition));
-    NameConstraint(String definition, NameResolver resolver)
+    static NameConstraint create(String definition, NameResolver resolver)
-        super(definition);
-            name = resolver.getQName(definition);
+            Name name = resolver.getQName(definition);
+            return new NameConstraint(name.toString(), name);
-            String msg = "invalid name specified as value constraint: "
-                    + definition;
+            String msg = "Invalid name constraint: " + definition;
-            String msg = "invalid name specified as value constraint: "
-                    + definition;
+            String msg = "Invalid name constraint: " + definition;
+    private NameConstraint(String qualifiedDefinition, Name name) {
+        super(qualifiedDefinition);
+        this.name = name;
+    }
+
-     * Returns the String representation of the qualified name
-     *
-     * @return String representation of the qualified name
-     * @see ValueConstraint#getQualifiedDefinition()
-     */
-    public String getQualifiedDefinition() {
-        return name.toString();
-    }
-
-    /**
-    ReferenceConstraint(String qualifiedDefinition) {
-        super(qualifiedDefinition);
-        // format: qualified node type name
-        // TODO improve. don't rely on a specific factory impl
-        ntName = NameFactoryImpl.getInstance().create(qualifiedDefinition);
+    static ReferenceConstraint create(String qualifiedDefinition) {
+        // constraint format: String representation of qualified name
+        return new ReferenceConstraint(qualifiedDefinition, NAME_FACTORY.create(qualifiedDefinition));
-    ReferenceConstraint(String definition, NamePathResolver resolver) throws InvalidConstraintException {
-        super(definition);
-
-        // format: node type name
+    static ReferenceConstraint create(String definition, NameResolver resolver)
+            throws InvalidConstraintException {
+        // constraint format: JCR name in prefix form
-            ntName = resolver.getQName(definition);
-        } catch (IllegalNameException ine) {
-            String msg = "invalid node type name specified as value constraint: "
-                    + definition;
+            Name name = resolver.getQName(definition);
+            return new ReferenceConstraint(name.toString(), name);
+        } catch (NameException e) {
+            String msg = "Invalid name constraint: " + definition;
-            throw new InvalidConstraintException(msg, ine);
+            throw new InvalidConstraintException(msg, e);
-            String msg = "invalid node type name specified as value constraint: "
-                    + definition;
+            String msg = "Invalid name constraint: " + definition;
+    private ReferenceConstraint(String qualifiedDefinition, Name ntName) {
+        super(qualifiedDefinition);
+        this.ntName = ntName;
+    }
+
-     * qualified nodetype name into a JCR name.
+     * qualified <code>Name</code> into a JCR name.
-        } catch (NamespaceException npde) {
+        } catch (NamespaceException e) {
-     * Returns the String representation of the qualified nodetype name.
-     *
-     * @return String representation of the qualified nodetype name.
-     */
-    public String getQualifiedDefinition() {
-        return ntName.toString();
-    }
-
-    /**
+

JCR-940: BundleDbPersistenceManager auto re-connect

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@575734 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager;
-import java.sql.DriverManager;
-import java.sql.Driver;
-import java.util.Iterator;
-import java.util.Collection;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+ * <li>&lt;param name="{@link #setBlockOnConnectionLoss(String) blockOnConnectionLoss}" value="false"/>
+    /** indicates whether to block if the database connection is lost */
+    protected boolean blockOnConnectionLoss = false;
-    /** jdbc conection */
-    protected Connection con;
+    /**
+     * The class that manages statement execution and recovery from connection loss.
+     */
+    protected ConnectionRecoveryManager connectionManager;
-    // shared prepared statements for bundle management
-    protected PreparedStatement bundleInsert;
-    protected PreparedStatement bundleUpdate;
-    protected PreparedStatement bundleSelect;
-    protected PreparedStatement bundleDelete;
+    // SQL statements for bundle management
+    protected String bundleInsertSQL;
+    protected String bundleUpdateSQL;
+    protected String bundleSelectSQL;
+    protected String bundleDeleteSQL;
-    // shared prepared statements for NodeReference management
-    protected PreparedStatement nodeReferenceInsert;
-    protected PreparedStatement nodeReferenceUpdate;
-    protected PreparedStatement nodeReferenceSelect;
-    protected PreparedStatement nodeReferenceDelete;
+    // SQL statements for NodeReference management
+    protected String nodeReferenceInsertSQL;
+    protected String nodeReferenceUpdateSQL;
+    protected String nodeReferenceSelectSQL;
+    protected String nodeReferenceDeleteSQL;
+    public void setBlockOnConnectionLoss(String block) {
+        this.blockOnConnectionLoss = Boolean.valueOf(block).booleanValue();
+    }
+
+    public String getBlockOnConnectionLoss() {
+        return Boolean.toString(blockOnConnectionLoss);
+    }
+
-            Statement stmt = con.createStatement();
+            Statement stmt = connectionManager.getConnection().createStatement();
-        DatabaseMetaData metaData = con.getMetaData();
+        DatabaseMetaData metaData = connectionManager.getConnection().getMetaData();
-    public synchronized void store(ChangeLog changeLog)
-            throws ItemStateException {
-
+    public synchronized void store(ChangeLog changeLog) throws ItemStateException {
+        Connection con = null;
-            con.setAutoCommit(false);
-            super.store(changeLog);
-        } catch (SQLException e) {
-            String msg = "setting autocommit failed.";
-            log.error(msg, e);
-            throw new ItemStateException(msg, e);
-        } catch (ItemStateException e) {
-            // storing the changes failed, rollback changes
+            boolean tryAgain = true;
+            do {
+                try {
+                    con = connectionManager.getConnection();
+                    connectionManager.setAutoReconnect(false);
+                    con.setAutoCommit(false);
+                    super.store(changeLog);
+                    con.commit();
+                    con.setAutoCommit(true);
+                } catch (SQLException e) {
+                    if (tryAgain) {
+                        tryAgain = false;
+                        continue;
+                    }
+                    throw e;
+                }
+            } while(false);
+        } catch (Throwable th) {
-                con.rollback();
-            } catch (SQLException e1) {
-                String msg = "rollback of change log failed";
-                log.error(msg, e1);
+                if (con != null) {
+                    con.rollback();
+                }
+            } catch (SQLException e) {
+                logException("rollback failed", e);
-            // re-throw original exception
-            throw e;
-        }
-
-        // storing the changes succeeded, now commit the changes
-        try {
-            con.commit();
-            con.setAutoCommit(true);
-        } catch (SQLException e) {
-            String msg = "committing change log failed";
-            log.error(msg, e);
-            throw new ItemStateException(msg, e);
+            if (th instanceof SQLException || th.getCause() instanceof SQLException) {
+                connectionManager.close();
+            }
+            throw new ItemStateException(th.getMessage());
+        } finally {
+            connectionManager.setAutoReconnect(true);
-        // setup jdbc connection
-        // Note: Explicit creation of new instance of the driver is required
-        // in order to re-register the driver in the DriverManager after a
-        // repository shutdown.
-        Driver drv = (Driver) Class.forName(driver).newInstance();
-        log.info("JDBC driver created: {}", drv);
-        con = DriverManager.getConnection(url, user, password);
-        
-        DatabaseMetaData meta = con.getMetaData();
-        try {
-            log.info("Database: " + meta.getDatabaseProductName() + " / " + meta.getDatabaseProductVersion());
-            log.info("Driver: " + meta.getDriverName() + " / " + meta.getDriverVersion());
-        } catch (SQLException e) {
-            log.warn("Can not retrieve database and driver name / version", e);
-        }
-        
-        con.setAutoCommit(true);
+        connectionManager = new ConnectionRecoveryManager(blockOnConnectionLoss,
+                getDriver(), getUrl(), getUser(), getPassword());
-        // prepare statements
-        if (getStorageModel() == SM_BINARY_KEYS) {
-            bundleInsert = con.prepareStatement("insert into " + schemaObjectPrefix + "BUNDLE (BUNDLE_DATA, NODE_ID) values (?, ?)");
-            bundleUpdate = con.prepareStatement("update " + schemaObjectPrefix + "BUNDLE set BUNDLE_DATA = ? where NODE_ID = ?");
-            bundleSelect = con.prepareStatement("select BUNDLE_DATA from " + schemaObjectPrefix + "BUNDLE where NODE_ID = ?");
-            bundleDelete = con.prepareStatement("delete from " + schemaObjectPrefix + "BUNDLE where NODE_ID = ?");
+        buildSQLStatements();
-            nodeReferenceInsert = con.prepareStatement("insert into " + schemaObjectPrefix + "REFS (REFS_DATA, NODE_ID) values (?, ?)");
-            nodeReferenceUpdate = con.prepareStatement("update " + schemaObjectPrefix + "REFS set REFS_DATA = ? where NODE_ID = ?");
-            nodeReferenceSelect = con.prepareStatement("select REFS_DATA from " + schemaObjectPrefix + "REFS where NODE_ID = ?");
-            nodeReferenceDelete = con.prepareStatement("delete from " + schemaObjectPrefix + "REFS where NODE_ID = ?");
-        } else {
-            bundleInsert = con.prepareStatement("insert into " + schemaObjectPrefix + "BUNDLE (BUNDLE_DATA, NODE_ID_HI, NODE_ID_LO) values (?, ?, ?)");
-            bundleUpdate = con.prepareStatement("update " + schemaObjectPrefix + "BUNDLE set BUNDLE_DATA = ? where NODE_ID_HI = ? and NODE_ID_LO = ?");
-            bundleSelect = con.prepareStatement("select BUNDLE_DATA from " + schemaObjectPrefix + "BUNDLE where NODE_ID_HI = ? and NODE_ID_LO = ?");
-            bundleDelete = con.prepareStatement("delete from " + schemaObjectPrefix + "BUNDLE where NODE_ID_HI = ? and NODE_ID_LO = ?");
-
-            nodeReferenceInsert = con.prepareStatement("insert into " + schemaObjectPrefix + "REFS (REFS_DATA, NODE_ID_HI, NODE_ID_LO) values (?, ?, ?)");
-            nodeReferenceUpdate = con.prepareStatement("update " + schemaObjectPrefix + "REFS set REFS_DATA = ? where NODE_ID_HI = ? and NODE_ID_LO = ?");
-            nodeReferenceSelect = con.prepareStatement("select REFS_DATA from " + schemaObjectPrefix + "REFS where NODE_ID_HI = ? and NODE_ID_LO = ?");
-            nodeReferenceDelete = con.prepareStatement("delete from " + schemaObjectPrefix + "REFS where NODE_ID_HI = ? and NODE_ID_LO = ?");
-        }
-        return new DbNameIndex(con, schemaObjectPrefix);
+        return new DbNameIndex(connectionManager, schemaObjectPrefix);
-        PreparedStatement stmt = null;
+            String sql;
-                stmt = con.prepareStatement(
-                        "select NODE_ID, BUNDLE_DATA from "
-                        + schemaObjectPrefix + "BUNDLE");
+                sql = "select NODE_ID, BUNDLE_DATA from " + schemaObjectPrefix + "BUNDLE";
-                stmt = con.prepareStatement(
-                        "select NODE_ID_HI, NODE_ID_LO, BUNDLE_DATA from "
-                        + schemaObjectPrefix + "BUNDLE");
+                sql = "select NODE_ID_HI, NODE_ID_LO, BUNDLE_DATA from " + schemaObjectPrefix + "BUNDLE";
-            stmt.execute();
+            Statement stmt = connectionManager.executeStmt(sql, new Object[0]);
-            closeStatement(stmt);
-        DatabaseMetaData metaData = con.getMetaData();
+        DatabaseMetaData metaData = connectionManager.getConnection().getMetaData();
-            // close shared prepared statements
-            closeStatement(bundleInsert);
-            closeStatement(bundleUpdate);
-            closeStatement(bundleSelect);
-            closeStatement(bundleDelete);
-
-            closeStatement(nodeReferenceInsert);
-            closeStatement(nodeReferenceUpdate);
-            closeStatement(nodeReferenceSelect);
-            closeStatement(nodeReferenceDelete);
-
-
-            // close jdbc connection
-            con.close();
-
+            connectionManager.close();
+     * Constructs a parameter list for a PreparedStatement
+     * for the given UUID.
+     *
+     * @param uuid the uuid
+     * @return a list of Objects
+     */
+    protected Object[] getKey(UUID uuid) {
+        if (getStorageModel() == SM_BINARY_KEYS) {
+            return new Object[]{uuid.getRawBytes()};
+        } else {
+            return new Object[]{new Long(uuid.getMostSignificantBits()),
+                    new Long(uuid.getLeastSignificantBits())};
+        }
+    }
+
+    /**
+     * Creates a parameter array for an SQL statement that needs
+     * (i) a UUID, and (2) another parameter.
+     *
+     * @param uuid the UUID
+     * @param p the other parameter
+     * @param before whether the other parameter should be before the uuid parameter
+     * @return an Object array that represents the parameters
+     */
+    protected Object[] createParams(UUID uuid, Object p, boolean before) {
+
+        // Create the key
+        List key = new ArrayList();
+        if (getStorageModel() == SM_BINARY_KEYS) {
+            key.add(uuid.getRawBytes());
+        } else {
+            key.add(new Long(uuid.getMostSignificantBits()));
+            key.add(new Long(uuid.getLeastSignificantBits()));
+        }
+
+        // Create the parameters
+        List params = new ArrayList();
+        if (before) {
+            params.add(p);
+            params.addAll(key);
+        } else {
+            params.addAll(key);
+            params.add(p);
+        }
+
+        return params.toArray();
+    }
+
+    /**
-        PreparedStatement stmt = bundleSelect;
-            setKey(stmt, id.getUUID(), 1);
-            stmt.execute();
+            Statement stmt = connectionManager.executeStmt(bundleSelectSQL, getKey(id.getUUID()));
-            resetStatement(stmt);
-        PreparedStatement stmt = bundleSelect;
-            setKey(stmt, id.getUUID(), 1);
-            stmt.execute();
+            Statement stmt = connectionManager.executeStmt(bundleSelectSQL, getKey(id.getUUID()));
-
-            resetStatement(stmt);
-        PreparedStatement stmt = null;
-            if (bundle.isNew()) {
-                stmt = bundleInsert;
-            } else {
-                stmt = bundleUpdate;
-            }
-            stmt.setBytes(1, out.toByteArray());
-            setKey(stmt, bundle.getId().getUUID(), 2);
-            stmt.execute();
+            String sql = bundle.isNew() ? bundleInsertSQL : bundleUpdateSQL;
+            Object[] params = createParams(bundle.getId().getUUID(), out.toByteArray(), true);
+            connectionManager.executeStmt(sql, params);
-        } finally {
-            resetStatement(stmt);
-        PreparedStatement stmt = bundleDelete;
-            setKey(stmt, bundle.getId().getUUID(), 1);
-            stmt.execute();
+            connectionManager.executeStmt(bundleDeleteSQL, getKey(bundle.getId().getUUID()));
-        } finally {
-            resetStatement(stmt);
-        PreparedStatement stmt = nodeReferenceSelect;
-            setKey(stmt, targetId.getTargetId().getUUID(), 1);
-            stmt.execute();
+            Statement stmt = connectionManager.executeStmt(
+                    nodeReferenceSelectSQL, getKey(targetId.getTargetId().getUUID()));
-            resetStatement(stmt);
-        PreparedStatement stmt = null;
-        try {
-            // check if insert or update
-            if (exists(refs.getId())) {
-                stmt = nodeReferenceUpdate;
-            } else {
-                stmt = nodeReferenceInsert;
-            }
+        // check if insert or update
+        boolean update = exists(refs.getId());
+        String sql = (update) ? nodeReferenceUpdateSQL : nodeReferenceInsertSQL;
-            ByteArrayOutputStream out = new ByteArrayOutputStream(INITIAL_BUFFER_SIZE);
+        try {
+            ByteArrayOutputStream out =
+                    new ByteArrayOutputStream(INITIAL_BUFFER_SIZE);
-            // we are synchronized on this instance, therefore we do not
-            // not have to additionally synchronize on the preparedStatement
-
-            stmt.setBytes(1, out.toByteArray());
-            setKey(stmt, refs.getTargetId().getUUID(), 2);
-            stmt.execute();
+            Object[] params = createParams(refs.getTargetId().getUUID(), out.toByteArray(), true);
+            connectionManager.executeStmt(sql, params);
-            String msg = "failed to write property state: " + refs.getTargetId();
+            String msg = "failed to write node references: " + refs.getId();
-        } finally {
-            resetStatement(stmt);
-        PreparedStatement stmt = nodeReferenceDelete;
-            setKey(stmt, refs.getTargetId().getUUID(), 1);
-            stmt.execute();
+            connectionManager.executeStmt(nodeReferenceDeleteSQL,
+                    getKey(refs.getTargetId().getUUID()));
-        } finally {
-            resetStatement(stmt);
-        PreparedStatement stmt = nodeReferenceSelect;
-            setKey(stmt, targetId.getTargetId().getUUID(), 1);
-            stmt.execute();
+            Statement stmt = connectionManager.executeStmt(nodeReferenceSelectSQL,
+                    getKey(targetId.getTargetId().getUUID()));
-            // a reference exists, if the result has at least one entry
+            // a reference exists if the result has at least one entry
-            String msg = "failed to check existence of node references: " + targetId;
+            String msg = "failed to check existence of node references: "
+                + targetId;
-            resetStatement(stmt);
+     * Initializes the SQL strings.
+     */
+    protected void buildSQLStatements() {
+        // prepare statements
+        if (getStorageModel() == SM_BINARY_KEYS) {
+            bundleInsertSQL = "insert into " + schemaObjectPrefix + "BUNDLE (BUNDLE_DATA, NODE_ID) values (?, ?)";
+            bundleUpdateSQL = "update " + schemaObjectPrefix + "BUNDLE set BUNDLE_DATA = ? where NODE_ID = ?";
+            bundleSelectSQL = "select BUNDLE_DATA from " + schemaObjectPrefix + "BUNDLE where NODE_ID = ?";
+            bundleDeleteSQL = "delete from " + schemaObjectPrefix + "BUNDLE where NODE_ID = ?";
+
+            nodeReferenceInsertSQL = "insert into " + schemaObjectPrefix + "REFS (REFS_DATA, NODE_ID) values (?, ?)";
+            nodeReferenceUpdateSQL = "update " + schemaObjectPrefix + "REFS set REFS_DATA = ? where NODE_ID = ?";
+            nodeReferenceSelectSQL = "select REFS_DATA from " + schemaObjectPrefix + "REFS where NODE_ID = ?";
+            nodeReferenceDeleteSQL = "delete from " + schemaObjectPrefix + "REFS where NODE_ID = ?";
+        } else {
+            bundleInsertSQL = "insert into " + schemaObjectPrefix + "BUNDLE (BUNDLE_DATA, NODE_ID_HI, NODE_ID_LO) values (?, ?, ?)";
+            bundleUpdateSQL = "update " + schemaObjectPrefix + "BUNDLE set BUNDLE_DATA = ? where NODE_ID_HI = ? and NODE_ID_LO = ?";
+            bundleSelectSQL = "select BUNDLE_DATA from " + schemaObjectPrefix + "BUNDLE where NODE_ID_HI = ? and NODE_ID_LO = ?";
+            bundleDeleteSQL = "delete from " + schemaObjectPrefix + "BUNDLE where NODE_ID_HI = ? and NODE_ID_LO = ?";
+
+            nodeReferenceInsertSQL = "insert into " + schemaObjectPrefix + "REFS (REFS_DATA, NODE_ID_HI, NODE_ID_LO) values (?, ?, ?)";
+            nodeReferenceUpdateSQL = "update " + schemaObjectPrefix + "REFS set REFS_DATA = ? where NODE_ID_HI = ? and NODE_ID_LO = ?";
+            nodeReferenceSelectSQL = "select REFS_DATA from " + schemaObjectPrefix + "REFS where NODE_ID_HI = ? and NODE_ID_LO = ?";
+            nodeReferenceDeleteSQL = "delete from " + schemaObjectPrefix + "REFS where NODE_ID_HI = ? and NODE_ID_LO = ?";
+        }
+    }
+
+    /**
-        protected PreparedStatement blobInsert;
-        protected PreparedStatement blobUpdate;
-        protected PreparedStatement blobSelect;
-        protected PreparedStatement blobSelectExist;
-        protected PreparedStatement blobDelete;
+        protected String blobInsertSQL;
+        protected String blobUpdateSQL;
+        protected String blobSelectSQL;
+        protected String blobSelectExistSQL;
+        protected String blobDeleteSQL;
-            blobInsert =
-                    con.prepareStatement("insert into "
-                    + schemaObjectPrefix + "BINVAL (BINVAL_DATA, BINVAL_ID) values (?, ?)");
-            blobUpdate =
-                    con.prepareStatement("update "
-                    + schemaObjectPrefix + "BINVAL set BINVAL_DATA = ? where BINVAL_ID = ?");
-            blobSelect =
-                    con.prepareStatement("select BINVAL_DATA from "
-                    + schemaObjectPrefix + "BINVAL where BINVAL_ID = ?");
-            blobSelectExist =
-                    con.prepareStatement("select 1 from "
-                    + schemaObjectPrefix + "BINVAL where BINVAL_ID = ?");
-            blobDelete =
-                    con.prepareStatement("delete from "
-                    + schemaObjectPrefix + "BINVAL where BINVAL_ID = ?");
+            blobInsertSQL = "insert into " + schemaObjectPrefix + "BINVAL (BINVAL_DATA, BINVAL_ID) values (?, ?)";
+            blobUpdateSQL = "update " + schemaObjectPrefix + "BINVAL set BINVAL_DATA = ? where BINVAL_ID = ?";
+            blobSelectSQL = "select BINVAL_DATA from " + schemaObjectPrefix + "BINVAL where BINVAL_ID = ?";
+            blobSelectExistSQL = "select 1 from " + schemaObjectPrefix + "BINVAL where BINVAL_ID = ?";
+            blobDeleteSQL = "delete from " + schemaObjectPrefix + "BINVAL where BINVAL_ID = ?";
-            PreparedStatement stmt = blobSelect;
-            synchronized (stmt) {
-                try {
-                    stmt.setString(1, blobId);
-                    stmt.execute();
-                    final ResultSet rs = stmt.getResultSet();
-                    if (!rs.next()) {
-                        closeResultSet(rs);
-                        throw new Exception("no such BLOB: " + blobId);
-                    }
-                    InputStream in = rs.getBinaryStream(1);
-                    if (in == null) {
-                        // some databases treat zero-length values as NULL;
-                        // return empty InputStream in such a case
-                        closeResultSet(rs);
-                        return new ByteArrayInputStream(new byte[0]);
-                    }
-
-                    /**
-                     * return an InputStream wrapper in order to
-                     * close the ResultSet when the stream is closed
-                     */
-                    return new FilterInputStream(in) {
-                        public void close() throws IOException {
-                            in.close();
-                            // now it's safe to close ResultSet
-                            closeResultSet(rs);
-                        }
-                    };
-                } finally {
-                    resetStatement(stmt);
-                }
+            Statement stmt = connectionManager.executeStmt(blobSelectSQL, new Object[]{blobId});
+            final ResultSet rs = stmt.getResultSet();
+            if (!rs.next()) {
+                closeResultSet(rs);
+                throw new Exception("no such BLOB: " + blobId);
+            InputStream in = rs.getBinaryStream(1);
+            if (in == null) {
+                // some databases treat zero-length values as NULL;
+                // return empty InputStream in such a case
+                closeResultSet(rs);
+                return new ByteArrayInputStream(new byte[0]);
+            }
+
+            /**
+             * return an InputStream wrapper in order to
+             * close the ResultSet when the stream is closed
+             */
+            return new FilterInputStream(in) {
+                public void close() throws IOException {
+                    in.close();
+                    // now it's safe to close ResultSet
+                    closeResultSet(rs);
+                }
+            };
-            PreparedStatement stmt = blobSelectExist;
-            try {
-                stmt.setString(1, blobId);
-                stmt.execute();
-                ResultSet rs = stmt.getResultSet();
-                // a BLOB exists if the result has at least one entry
-                boolean exists = rs.next();
-                resetStatement(stmt);
-                closeResultSet(rs);
+            Statement stmt = connectionManager.executeStmt(blobSelectExistSQL, new Object[]{blobId});
+            ResultSet rs = stmt.getResultSet();
+            // a BLOB exists if the result has at least one entry
+            boolean exists = rs.next();
+            closeResultSet(rs);
-                stmt = (exists) ? blobUpdate : blobInsert;
-                stmt.setBinaryStream(1, in, (int) size);
-                stmt.setString(2, blobId);
-                stmt.executeUpdate();
-            } finally {
-                resetStatement(stmt);
-            }
+            String sql = (exists) ? blobUpdateSQL : blobInsertSQL;
+            Object[] params = new Object[]{new ConnectionRecoveryManager.StreamWrapper(in, size), blobId};
+            connectionManager.executeStmt(sql, params);
-            PreparedStatement stmt = blobDelete;
-            try {
-                stmt.setString(1, blobId);
-                return stmt.executeUpdate() == 1;
-            } finally {
-                resetStatement(stmt);
-            }
+            Statement stmt = connectionManager.executeStmt(blobDeleteSQL, new Object[]{blobId});
+            return stmt.getUpdateCount() == 1;
-            closeStatement(blobInsert);
-            closeStatement(blobUpdate);
-            closeStatement(blobSelect);
-            closeStatement(blobSelectExist);
-            closeStatement(blobDelete);
+            // closing the database resources of this blobstore is left to the
+            // owning BundleDbPersistenceManager
-

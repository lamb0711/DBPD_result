JCR-1733: add support for WebDAV BIND protocol to simple webdav servlet, includes client compontents and test cases (requires the o.a.j.api.jsr283 extensions for shareable node support as defined in JSR-283)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@700097 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.webdav.bind.BindConstants;
+import org.apache.jackrabbit.webdav.bind.BindableResource;
+import org.apache.jackrabbit.webdav.bind.ParentSet;
+import org.apache.jackrabbit.webdav.bind.ParentElement;
+import javax.jcr.Workspace;
+import java.util.Set;
+import java.util.HashSet;
-public class DavResourceImpl implements DavResource, JcrConstants {
+public class DavResourceImpl implements DavResource, BindableResource, JcrConstants {
+    public static final String METHODS = DavResource.METHODS + ", " + BindConstants.METHODS;
+    public static final String COMPLIANCE_CLASS = DavResource.COMPLIANCE_CLASS + ", " + BindConstants.COMPLIANCE_CLASS;
+
-            if (node.isNodeType("mix:referenceable")) {
+            if (node.isNodeType(MIX_REFERENCEABLE)) {
-        return DavResource.COMPLIANCE_CLASS;
+        return COMPLIANCE_CLASS;
-        return DavResource.METHODS;
+        return METHODS;
-            properties.add(new HrefProperty(DavPropertyName.RESOURCEID, rfc4122Uri, true));
+            properties.add(new HrefProperty(BindConstants.RESOURCEID, rfc4122Uri, true));
+        }
+
+        Set parentElements = this.getParentElements();
+        if (!parentElements.isEmpty()) {
+            properties.add(new ParentSet(parentElements));
-            memItem.remove();
+            //TODO once jcr2 is out: simply call removeShare()
+            if (memItem instanceof org.apache.jackrabbit.api.jsr283.Node) {
+                org.apache.jackrabbit.api.jsr283.Node n = (org.apache.jackrabbit.api.jsr283.Node) memItem;
+                n.removeShare();
+            } else {
+                memItem.remove();
+            }
+
+    /**
+     * @see BindableResource#rebind(DavResource, DavResource)
+     */
+    public void bind(DavResource collection, DavResource newBinding) throws DavException {
+        if (!exists()) {
+            //DAV:bind-source-exists
+            throw new DavException(DavServletResponse.SC_PRECONDITION_FAILED);
+        }
+        if (isLocked(collection)) {
+            //DAV:locked-update-allowed?
+            throw new DavException(DavServletResponse.SC_LOCKED);
+        }
+        if (isFilteredResource(newBinding)) {
+            throw new DavException(DavServletResponse.SC_FORBIDDEN);
+        }
+        checkSameWorkspace(collection.getLocator());
+        try {
+            if (!this.node.isNodeType(MIX_SHAREABLE)) {
+                if (!this.node.canAddMixin(MIX_SHAREABLE)) {
+                    //DAV:binding-allowed
+                    throw new DavException(DavServletResponse.SC_PRECONDITION_FAILED);
+                }
+                this.node.addMixin(MIX_SHAREABLE);
+                this.node.save();
+            }
+            Workspace workspace = this.session.getRepositorySession().getWorkspace();
+            workspace.clone(workspace.getName(), this.node.getPath(), newBinding.getLocator().getRepositoryPath(), false);
+
+        } catch (RepositoryException e) {
+            throw new JcrDavException(e);
+        }
+
+    }
+
+    /**
+     * @see BindableResource#rebind(DavResource, DavResource)
+     */
+    public void rebind(DavResource collection, DavResource newBinding) throws DavException {
+        if (!exists()) {
+            //DAV:rebind-source-exists
+            throw new DavException(DavServletResponse.SC_PRECONDITION_FAILED);
+        }
+        if (isLocked(this)) {
+            //DAV:protected-source-url-deletion.allowed
+            throw new DavException(DavServletResponse.SC_PRECONDITION_FAILED);
+        }
+        if (isLocked(collection)) {
+            //DAV:locked-update-allowed?
+            throw new DavException(DavServletResponse.SC_LOCKED);
+        }
+        if (isFilteredResource(newBinding)) {
+            throw new DavException(DavServletResponse.SC_FORBIDDEN);
+        }
+        checkSameWorkspace(collection.getLocator());
+        try {
+            if (!this.node.isNodeType(MIX_REFERENCEABLE)) {
+                throw new DavException(this.node.canAddMixin(MIX_REFERENCEABLE)?
+                                       DavServletResponse.SC_CONFLICT : DavServletResponse.SC_METHOD_NOT_ALLOWED);
+            }
+            getJcrSession().getWorkspace().move(locator.getRepositoryPath(), newBinding.getLocator().getRepositoryPath());
+        } catch (RepositoryException e) {
+            throw new JcrDavException(e);
+        }
+    }
+
+    /**
+     * @see org.apache.jackrabbit.webdav.bind.BindableResource#getParentElements()
+     */
+    public Set getParentElements() {
+        try {
+            //TODO remove this check once jcr2 is out
+            if (!(this.node instanceof org.apache.jackrabbit.api.jsr283.Node)) {
+                DavResourceLocator loc = this.locator.getFactory().createResourceLocator(
+                        this.locator.getPrefix(), this.locator.getWorkspacePath(), this.node.getParent().getPath(), false);
+                return Collections.singleton(new ParentElement(loc.getHref(true), this.node.getName()));
+            }
+            Set ps = new HashSet();
+            NodeIterator sharedSetIterator = ((org.apache.jackrabbit.api.jsr283.Node) this.node).getSharedSet();
+            while (sharedSetIterator.hasNext()) {
+                Node sharednode = sharedSetIterator.nextNode();
+                DavResourceLocator loc = this.locator.getFactory().createResourceLocator(
+                        this.locator.getPrefix(), this.locator.getWorkspacePath(), sharednode.getParent().getPath(), false);
+                ps.add(new ParentElement(loc.getHref(true), sharednode.getName()));
+            }
+            return ps;
+        } catch (RepositoryException e) {
+            log.warn("unable to calculate parent set", e);
+            return Collections.EMPTY_SET; 
+        }
+    }
+

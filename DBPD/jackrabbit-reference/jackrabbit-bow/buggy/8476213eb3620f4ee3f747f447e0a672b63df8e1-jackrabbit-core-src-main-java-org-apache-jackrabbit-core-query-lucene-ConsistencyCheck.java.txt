JCR-3506 add ability of reverse lucene index check: whether all items in the repository that should be indexed are present in the index. because this check will take more time and resources it must be explicitly enabled using a system property.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1440908 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.HierarchyManager;
+import org.apache.jackrabbit.core.persistence.IterablePersistenceManager;
+import org.apache.jackrabbit.core.persistence.PersistenceManager;
+import org.apache.jackrabbit.core.persistence.check.ConsistencyChecker;
+import org.apache.jackrabbit.core.state.NoSuchItemStateException;
+import org.apache.jackrabbit.spi.Path;
+import javax.jcr.ItemNotFoundException;
+import java.util.Collections;
+import java.util.Iterator;
+     * The number of nodes to fetch at once from the persistence manager. Defaults to 8kb
+     */
+    private static final int NODESATONCE = Integer.getInteger("org.apache.jackrabbit.checker.nodesatonce", 1024 * 8);
+
+    /**
+     * Whether to check whether all the nodes that are in the repository are indexed.
+     * When false only the check is made whether all nodes in the index are also in the repository.
+     */
+    private static final boolean CHECKREVERSE = Boolean.getBoolean("org.apache.jackrabbit.checker.index.reverse");
+
+
+    private final SearchIndex handler;
+
+    /**
+     * The PersistenceManager of the workspace.
+     */
+    private IterablePersistenceManager pm;
+
+    /**
+     * The bundle consistency checker
+     */
+    private ConsistencyChecker checker;
+
+    /**
+     * Paths of nodes that are not be indexed
+     */
+    private Set<Path> excludedPaths;
+
+    /**
-    private ConsistencyCheck(MultiIndex index, ItemStateManager mgr) {
+    private ConsistencyCheck(MultiIndex index, SearchIndex handler, Set<NodeId> excludedIds) {
-        this.stateMgr = mgr;
+        this.handler = handler;
+
+        final HierarchyManager hierarchyManager = handler.getContext().getHierarchyManager();
+        excludedPaths = new HashSet<Path>(excludedIds.size());
+        for (NodeId excludedId : excludedIds) {
+            try {
+                final Path path = hierarchyManager.getPath(excludedId);
+                excludedPaths.add(path);
+            } catch (ItemNotFoundException e) {
+                log.warn("Excluded node does not exist");
+            } catch (RepositoryException e) {
+                log.error("Failed to get excluded path", e);
+            }
+        }
+
+        this.stateMgr = handler.getContext().getItemStateManager();
+        final PersistenceManager pm = handler.getContext().getPersistenceManager();
+        if (pm instanceof IterablePersistenceManager) {
+            this.pm = (IterablePersistenceManager) pm;
+        }
+        if (pm instanceof ConsistencyChecker) {
+            this.checker = (ConsistencyChecker) pm;
+        }
+     *
+     *
-     * @param mgr   the ItemStateManager from where to load content.
+     * @param handler the QueryHandler to use.
+     * @param excludedIds the set of node ids that are not indexed
-    static ConsistencyCheck run(MultiIndex index, ItemStateManager mgr) throws IOException {
-        ConsistencyCheck check = new ConsistencyCheck(index, mgr);
+    static ConsistencyCheck run(MultiIndex index, SearchIndex handler, final Set<NodeId> excludedIds)
+            throws IOException {
+        ConsistencyCheck check = new ConsistencyCheck(index, handler, excludedIds);
-                    log.warn("Exception while reparing: " + e);
+                    log.warn("Exception while repairing: " + e);
+        log.info("Checking index of workspace " + handler.getContext().getWorkspace());
+        checkIndexToItems();
+        checkItemsToIndex();
+    }
+
+    private void checkIndexToItems() throws IOException {
+        log.info("Checking index consistency");
+    private void checkItemsToIndex() {
+        if (!CHECKREVERSE) {
+            return;
+        }
+        if (pm == null) {
+            log.warn("Cannot run reverse index check with this PersistenceManager");
+            return;
+        }
+        log.info("Checking index completeness");
+        try {
+            int count = 0;
+            List<NodeId> batch = pm.getAllNodeIds(null, NODESATONCE);
+            while (!batch.isEmpty()) {
+                NodeId lastId = null;
+                for (NodeId nodeId : batch) {
+                    lastId = nodeId;
+
+                    count++;
+                    if (count % 1000 == 0) {
+                        log.info(pm + ": checked " + count + " node ids...");
+                    }
+
+                    checkNode(nodeId);
+
+                }
+                batch = pm.getAllNodeIds(lastId, NODESATONCE);
+            }
+        } catch (ItemStateException e) {
+            log.error("Exception while loading items to check", e);
+        } catch (RepositoryException e) {
+            log.error("Exception while loading items to check", e);
+        }
+
+    }
+
+    private void checkNode(final NodeId nodeId) {
+        try {
+            if (!documentIds.contains(nodeId) && !isExcluded(nodeId)) {
+                NodeState nodeState = getNodeState(nodeId);
+                if (nodeState != null && !isBrokenNode(nodeId, nodeState)) {
+                    errors.add(new NodeAdded(nodeId));
+                }
+            }
+        } catch (ItemStateException e) {
+            log.error("Failed to check node: " + nodeId, e);
+        }
+    }
+
+    private boolean isExcluded(NodeId id) {
+        try {
+            final HierarchyManager hierarchyManager = handler.getContext().getHierarchyManager();
+            final Path path = hierarchyManager.getPath(id);
+            for (Path excludedPath : excludedPaths) {
+                if (excludedPath.isEquivalentTo(path) || excludedPath.isAncestorOf(path)) {
+                    return true;
+                }
+            }
+        } catch (RepositoryException ignored) {
+        }
+        return false;
+    }
+
+    private NodeState getNodeState(NodeId nodeId) throws ItemStateException {
+        try {
+            return (NodeState) stateMgr.getItemState(nodeId);
+        } catch (NoSuchItemStateException e) {
+            return null;
+        }
+    }
+
+    private boolean isBrokenNode(final NodeId nodeId, final NodeState nodeState) throws ItemStateException {
+        final NodeId parentId = nodeState.getParentId();
+        if (parentId != null) {
+            final NodeState parentState = getNodeState(parentId);
+            if (parentState == null) {
+                log.warn("Node missing from index is orphaned node: " + nodeId);
+                return true;
+            }
+            if (!parentState.hasChildNodeEntry(nodeId)) {
+                log.warn("Node missing from index is abandoned node: " + nodeId);
+                return true;
+            }
+        }
+        return false;
+    }
+
-            super("Node " + id + " does not longer exist.", id);
+            super("Node " + id + " no longer exists.", id);
+
+    private class NodeAdded extends ConsistencyCheckError {
+
+        NodeAdded(final NodeId id) {
+            super("Node " + id + " is missing.", id);
+        }
+
+        @Override
+        public boolean repairable() {
+            return true;
+        }
+
+        @Override
+        void repair() throws IOException {
+            try {
+                NodeState nodeState = (NodeState) stateMgr.getItemState(id);
+                final Iterator<NodeId> remove = Collections.<NodeId>emptyList().iterator();
+                final Iterator<NodeState> add = Collections.singletonList(nodeState).iterator();
+                handler.updateNodes(remove, add);
+            } catch (RepositoryException e) {
+                throw new IOException(e.toString());
+            } catch (ItemStateException e) {
+                throw new IOException(e.toString());
+            }
+        }
+
+    }

remove ItemStateException (and subclasses) and replace their usage with RepositoryException and subclasses respectively

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@520315 13f79535-47bb-0310-9956-ffa450edef68

-import javax.jcr.ItemNotFoundException;
-        RepositoryException, StaleItemStateException, ItemStateException {
+            InvalidItemStateException, RepositoryException {
-     * @throws ItemStateException if undoing changes made to <code>state</code>
+     * @throws ConstraintViolationException
+     * @throws RepositoryException if undoing changes made to <code>state</code>
-    public void undo(ItemState itemState) throws ItemStateException, ConstraintViolationException {
-        ChangeLog changeLog = getChangeLog(itemState, false);
-        if (!changeLog.isEmpty()) {
-            // let changelog revert all changes
-            changeLog.undo();
-            // remove transient states and related operations from the t-statemanager
-            transientStateMgr.dispose(changeLog);
-            changeLog.reset();
+    public void undo(ItemState itemState) throws ConstraintViolationException, RepositoryException {
+        try {
+            ChangeLog changeLog = getChangeLog(itemState, false);
+            if (!changeLog.isEmpty()) {
+                // let changelog revert all changes
+                changeLog.undo();
+                // remove transient states and related operations from the t-statemanager
+                transientStateMgr.dispose(changeLog);
+                changeLog.reset();
+            }
+        } catch (InvalidItemStateException e) {
+            // should never get here
+            String msg = "Unable to undo item.";
+            log.debug(msg);
+            throw new RepositoryException(e);
-        try {
-            // new array of mixinNames to be set on the nodestate (and corresponding property state)
-            PropertyEntry mixinEntry = nEntry.getPropertyEntry(QName.JCR_MIXINTYPES);
-            if (mixinNames != null && mixinNames.length > 0) {
-                // update/create corresponding property state
-                if (mixinEntry != null) {
-                    // execute value of existing property
-                    PropertyState pState = mixinEntry.getPropertyState();
-                    int options = ItemStateValidator.CHECK_LOCK | ItemStateValidator.CHECK_VERSIONING;
-                    setPropertyStateValue(pState, getQValues(mixinNames, qValueFactory), PropertyType.NAME, options);
-                } else {
-                    // create new jcr:mixinTypes property
-                    EffectiveNodeType ent = validator.getEffectiveNodeType(nState);
-                    QPropertyDefinition pd = ent.getApplicablePropertyDefinition(QName.JCR_MIXINTYPES, PropertyType.NAME, true);
-                    QValue[] mixinValue = getQValues(mixinNames, qValueFactory);
-                    int options = ItemStateValidator.CHECK_LOCK | ItemStateValidator.CHECK_VERSIONING;
-                    addPropertyState(nState, pd.getQName(), pd.getRequiredType(), mixinValue, pd, options);
-                }
-                nState.markModified();
-                transientStateMgr.addOperation(operation);
+        // new array of mixinNames to be set on the nodestate (and corresponding property state)
+        PropertyEntry mixinEntry = nEntry.getPropertyEntry(QName.JCR_MIXINTYPES);
+        if (mixinNames != null && mixinNames.length > 0) {
+            // update/create corresponding property state
+            if (mixinEntry != null) {
+                // execute value of existing property
+                PropertyState pState = mixinEntry.getPropertyState();
+                int options = ItemStateValidator.CHECK_LOCK | ItemStateValidator.CHECK_VERSIONING;
+                setPropertyStateValue(pState, getQValues(mixinNames, qValueFactory), PropertyType.NAME, options);
-                // remove the jcr:mixinTypes property state if already present
-                if (mixinEntry != null) {
-                    PropertyState pState = mixinEntry.getPropertyState();
-                    boolean newMixinState = pState.getStatus() == Status.NEW;
-                    int options = ItemStateValidator.CHECK_LOCK | ItemStateValidator.CHECK_VERSIONING;
-                    removeItemState(pState, options);
-                    // only added the remove-mixin operation if it doesn't revert
-                    // a previous 'add-mixin' (which has been removed automatically
-                    // upon notification of removing the prop-state).
-                    if (!newMixinState) {
-                        nState.markModified();
-                        transientStateMgr.addOperation(operation);
-                    }
+                // create new jcr:mixinTypes property
+                EffectiveNodeType ent = validator.getEffectiveNodeType(nState);
+                QPropertyDefinition pd = ent.getApplicablePropertyDefinition(QName.JCR_MIXINTYPES, PropertyType.NAME, true);
+                QValue[] mixinValue = getQValues(mixinNames, qValueFactory);
+                int options = ItemStateValidator.CHECK_LOCK | ItemStateValidator.CHECK_VERSIONING;
+                addPropertyState(nState, pd.getQName(), pd.getRequiredType(), mixinValue, pd, options);
+            }
+            nState.markModified();
+            transientStateMgr.addOperation(operation);
+        } else {
+            // remove the jcr:mixinTypes property state if already present
+            if (mixinEntry != null) {
+                PropertyState pState = mixinEntry.getPropertyState();
+                boolean newMixinState = pState.getStatus() == Status.NEW;
+                int options = ItemStateValidator.CHECK_LOCK | ItemStateValidator.CHECK_VERSIONING;
+                removeItemState(pState, options);
+                // only added the remove-mixin operation if it doesn't revert
+                // a previous 'add-mixin' (which has been removed automatically
+                // upon notification of removing the prop-state).
+                if (!newMixinState) {
+                    nState.markModified();
+                    transientStateMgr.addOperation(operation);
-        } catch (ItemStateException e) {
-            // should not occur, since existance has been asserted before
-            throw new RepositoryException(e);
-        try {
-            parent.reorderChildNodeEntries(operation.getInsertNode(), operation.getBeforeNode());
-        } catch (NoSuchItemStateException e) {
-            // invalid reorder-ids
-            throw new ItemNotFoundException(e);
-        }
+        parent.reorderChildNodeEntries(operation.getInsertNode(), operation.getBeforeNode());
-     * @param throwOnStale Throws StaleItemStateException if either the given
+     * @param throwOnStale Throws InvalidItemStateException if either the given
-     * @throws StaleItemStateException if a stale <code>ItemState</code> is
+     * @throws InvalidItemStateException if a stale <code>ItemState</code> is
-     * @throws ItemStateException if <code>state</code> is a new item state.
+     * @throws RepositoryException if <code>state</code> is a new item state.
-    private ChangeLog getChangeLog(ItemState itemState, boolean throwOnStale) throws StaleItemStateException, ItemStateException, ConstraintViolationException {
+    private ChangeLog getChangeLog(ItemState itemState, boolean throwOnStale) throws InvalidItemStateException, ConstraintViolationException, RepositoryException {
-            throw new ItemStateException(msg);
+            throw new RepositoryException(msg);
-            throw new StaleItemStateException(msg);
+            throw new InvalidItemStateException(msg);
-        } catch (ItemStateException e) {
+        } catch (RepositoryException e) {

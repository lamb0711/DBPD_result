JCR-1104 : JSR 283 support (security work in progress)

> introduce AccessManager.canRead(Path)
> retrieve Policy/ACE from ACProvider by Path rather than by ID
> add CompiledPermission.canReadAll for optimization
> fix ACLTemplate (various bugs) and add additional tests
> get rid of deprecated AccessManager.isGranted(ItemId, int) wherever possible
  and mark/simplify other usages
  - ItemManager
  - BatchedItemOperations
  - add TODO with QueryResultImpl that still uses the isGranted method.
  - EventConsumer: still uses isGranted. but various calls were replaced by private
    canRead -> simplify later optimization.
> remove unused ACLCache.java
> ItemManager:
  - make getItem consistent with itemExists (check perm even if obtained from cache)
  - replace getItemState by getItemData
  - get rid of duplicate code
  - add canRead(ItemData, Path) which is used (almost) everywhere and avoid permission
    check for NEW,non-protected items
  - consequently getItem(ItemId, boolean) is not required any more.
  - upon building LazyItemIterator for children: omit the duplicate permission
    check while building the set of childIds.
    the perm-check is executed upon the subsequent ItemManager.getItem call anyway 
> NodeImpl: createChildNode called ItemManager.getItem for an new item that has
  not yet been added as CNE to its parent -> replace by ItemManager.createItemInstance
  which omits the permission check.
> ItemImpl: 
  - fix javadoc
  - replace removed method ItemMgr.getItem(ItemId, boolean) by getItem(ItemId)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@649172 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.api.JackrabbitSession;
+import org.apache.jackrabbit.api.security.principal.PrincipalManager;
-import org.apache.jackrabbit.api.security.principal.PrincipalManager;
-import org.apache.jackrabbit.api.JackrabbitSession;
-import org.apache.jackrabbit.util.ISO9075;
+import org.apache.jackrabbit.spi.commons.name.PathFactoryImpl;
+import javax.jcr.NodeIterator;
-import javax.jcr.NodeIterator;
+import javax.jcr.Node;
+import java.util.Arrays;
+import java.util.List;
-import java.util.List;
-import java.util.Arrays;
-    private String policyNodeName;
+    //--------------------------------------< AbstractAccessControlProvider >---
+    /**
+     * @see AbstractAccessControlProvider#isAcItem(Path)
+     */
+    protected boolean isAcItem(Path absPath) throws RepositoryException {
+        Path.Element[] elems = absPath.getElements();
+        for (int i = 0; i < elems.length; i++) {
+            if (N_POLICY.equals(elems[i].getName())) {
+                return true;
+            }
+        }
+        return false;
+    }
-        policyNodeName = resolver.getJCRName(N_POLICY);
-     * @see AccessControlProvider#getPolicy(NodeId)
+     * @see AccessControlProvider#getPolicy(Path)
+     * @param absPath
-    public AccessControlPolicy getPolicy(NodeId nodeId) throws ItemNotFoundException, RepositoryException {
+    public AccessControlPolicy getPolicy(Path absPath) throws ItemNotFoundException, RepositoryException {
-        return getACL(nodeId);
+        return getACL(absPath);
-     * @see AccessControlProvider#getAccessControlEntries(NodeId)
+     * @see AccessControlProvider#getAccessControlEntries(Path)
+     * @param absPath
-    public AccessControlEntry[] getAccessControlEntries(NodeId nodeId) throws RepositoryException {
+    public AccessControlEntry[] getAccessControlEntries(Path absPath) throws RepositoryException {
-        ACLImpl acl = getACL(nodeId);
+        ACLImpl acl = getACL(absPath);
-    public CompiledPermissions compilePermissions(Set principals) throws ItemNotFoundException, RepositoryException {
+    public CompiledPermissions compilePermissions(Set principals) throws RepositoryException {
+        } else if (isReadOnly(principals)) {
+            return getReadOnlyPermissions();
+    /**
+     * @see AccessControlProvider#canAccessRoot(Set)
+     */
+    public boolean canAccessRoot(Set principals) throws RepositoryException {
+        checkInitialized();
+        if (isAdminOrSystem(principals)) {
+            return true;
+        } else {
+            return new AclPermissions(principals, false).grants(PathFactoryImpl.getInstance().getRootPath(), Permission.READ);
+        }
+    }
+
-     * Build the ACL that is effective on the Node identified by
-     * <code>nodeId</code>. In contrast to {@link #getACL(NodeId, Set)}
+     * Build the ACL that is effective on the Node at
+     * <code>absPath</code>. In contrast to {@link #getACL(NodeImpl, Set)}
-     * @param nodeId
+     * @param absPath
-    private ACLImpl getACL(NodeId nodeId) throws ItemNotFoundException, RepositoryException {
-        return getACL(nodeId, Collections.EMPTY_SET);
+    private ACLImpl getACL(Path absPath) throws ItemNotFoundException, RepositoryException {
+        return getACL((NodeImpl) session.getNode(session.getJCRPath(absPath)),
+                Collections.EMPTY_SET);
-     * Build the ACL that is effective on the Node identified by
-     * <code>nodeId</code>, but only retrieve those entries that apply to
+     * Build the ACL that is effective on the Node at
+     * <code>absPath</code>, but only retrieve those entries that apply to
-     * @param nodeId
+     * @param node
-    private ACLImpl getACL(NodeId nodeId, Set principalNameFilter) throws ItemNotFoundException, RepositoryException {
-        // -> build the acl for the Node identified by 'id'
-        NodeImpl node = session.getNodeById(nodeId);
+    private ACLImpl getACL(NodeImpl node, Set principalNameFilter) throws ItemNotFoundException, RepositoryException {
+        // -> build the acl for the Node
-            acl = new ACLImpl(nodeId, baseACL, true);
+            acl = new ACLImpl(node.getNodeId(), baseACL, true);
-        private boolean readAllowed;
+
+        /**
+         * flag indicating that there is not 'deny READ'.
+         * -> simplify {@link #grants(Path, int)} in case of permissions == READ
+         */
+        private boolean readAllowed = false;
+        /**
+         * flag indicating if only READ is granted
+         * -> simplify {@link #grants(Path, int)} in case of permissions != READ
+         */
+        private boolean readOnly = false;
+            this(principals, true);
+        }
+        private AclPermissions(Set principals, boolean listenToEvents) throws RepositoryException {
-            /*
-             Determine if there is any 'denyRead' entry (since the default
-             is that everyone can READ everywhere -> makes evaluation for
-             the most common check (can-read) easy.
-            */
-            readAllowed = readAllowedEveryWhere(principalNames);
+            if (listenToEvents) {
+                /*
+                 Determine if there is any 'denyRead' entry (since the default
+                 is that everyone can READ everywhere -> makes evaluation for
+                 the most common check (can-read) easy.
+                */
+                searchReadDeny(principalNames);
+                /*
+                Determine if there is any ACE node that grants another permission
+                than READ.
+                */
+                searchNonReadAllow(principalNames);
-            /*
-             Make sure this AclPermission recalculates the permissions if
-             any ACL concerning it is modified. interesting events are:
-             - new ACE-entry for any of the principals (NODE_ADDED)
-             - changing ACE-entry for any of the principals (PROPERTY_CHANGED)
-               > new permissions granted/denied
-               >
-             - removed ACE-entry for any of the principals (NODE_REMOVED)
-            */
-            int events = Event.PROPERTY_CHANGED | Event.NODE_ADDED | Event.NODE_REMOVED;
-            String[] ntNames = new String[] {
-                    resolver.getJCRName(NT_REP_ACE),
-                    resolver.getJCRName(NT_REP_ACL)
-            };
-            observationMgr.addEventListener(this, events, session.getRootNode().getPath(), true, null, ntNames, true);
+                /*
+                 Make sure this AclPermission recalculates the permissions if
+                 any ACL concerning it is modified. interesting events are:
+                 - new ACE-entry for any of the principals (NODE_ADDED)
+                 - changing ACE-entry for any of the principals (PROPERTY_CHANGED)
+                   > new permissions granted/denied
+                   >
+                 - removed ACE-entry for any of the principals (NODE_REMOVED)
+                */
+                int events = Event.PROPERTY_CHANGED | Event.NODE_ADDED | Event.NODE_REMOVED;
+                String[] ntNames = new String[] {
+                        resolver.getJCRName(NT_REP_ACE),
+                        resolver.getJCRName(NT_REP_ACL)
+                };
+                observationMgr.addEventListener(this, events, session.getRootNode().getPath(), true, null, ntNames, true);
+            }
-         * @return true if read is allowed on all items.
-        private boolean readAllowedEveryWhere(Set principalnames) {
+        private void searchReadDeny(Set principalnames) {
-                stmt.append(")[");
+                stmt.append(")[(");
-                    stmt.append("@");
-                    String pName = resolver.getJCRName(P_PRINCIPAL_NAME);
-                    stmt.append(ISO9075.encode(pName));
-                    stmt.append("='").append(itr.next().toString()).append("'");
+                    stmt.append("@").append(resolver.getJCRName(P_PRINCIPAL_NAME)).append(" eq ");
+                    stmt.append("'").append(itr.next().toString()).append("'");
-                stmt.append(" and jcr:like(@");
-                String pName = resolver.getJCRName(P_PRIVILEGES);
-                stmt.append(ISO9075.encode(pName));
-                stmt.append(",'%").append(Privilege.READ).append("%')");
-                stmt.append("]");
+                stmt.append(") and @ ");
+                stmt.append(resolver.getJCRName(P_PRIVILEGES));
+                stmt.append(" = '").append(Privilege.READ).append("']");
+
-                while (it.hasNext()) {
-                    String path = it.nextNode().getPath();
-                    // if there is a node that AND it is not below /accesscontrol
-                    // we cannot use the short-cut within 'grants'
-                    if (!Text.isDescendantOrEqual("/"+ N_ACCESSCONTROL, path)) {
-                        return false;
-                    }
-                }
-                // didn't find any matching ACE that denies READ for any
-                // of the principals.
-                return true;
+                readAllowed =  !it.hasNext();
-                return false;
+                readAllowed = false;
+            }
+        }
+
+        private void searchNonReadAllow(Set principalnames) {
+            try {
+                QueryManager qm = session.getWorkspace().getQueryManager();
+                StringBuffer stmt = new StringBuffer("/jcr:root");
+                stmt.append("//element(*,");
+                stmt.append(resolver.getJCRName(NT_REP_GRANT_ACE));
+                stmt.append(")[(");
+                // where the rep:principalName property exactly matches any of
+                // the given principalsNames
+                int i = 0;
+                Iterator itr = principalnames.iterator();
+                while (itr.hasNext()) {
+                    stmt.append("@").append(resolver.getJCRName(P_PRINCIPAL_NAME)).append(" eq ");
+                    stmt.append("'").append(itr.next().toString()).append("'");
+                    if (++i < principalnames.size()) {
+                        stmt.append(" or ");
+                    }
+                }
+
+                // AND rep:privileges contains the READ privilege
+                stmt.append(") and @");
+                stmt.append(resolver.getJCRName(P_PRIVILEGES));
+                stmt.append(" ne \"").append(Privilege.READ).append("\"]");
+
+                Query q = qm.createQuery(stmt.toString(), Query.XPATH);
+
+                NodeIterator it = q.execute().getNodes();
+                readOnly =  !it.hasNext();
+            } catch (RepositoryException e) {
+                log.error(e.toString());
+                // unable to determine... -> no shortcut upon grants
+                readOnly = false;
-            NodeId nid = null;
+            Node node = null;
-                nid = session.getHierarchyManager().resolveNodePath(absPath);
+                node = session.getNode(jcrPath);
-                Path parentPath = absPath.getAncestor(1);
-                while (nid == null) {
-                    nid = session.getHierarchyManager().resolveNodePath(parentPath);
-                    if (parentPath.getDepth() == Path.ROOT_DEPTH) {
-                        // root-node reached
+                String parentPath = Text.getRelativeParent(jcrPath, 1);
+                while (parentPath.length() > 0) {
+                    if (session.nodeExists(parentPath)) {
+                        node = session.getNode(parentPath);
-                    } else {
-                        parentPath = parentPath.getAncestor(1);
+                    parentPath = Text.getRelativeParent(parentPath, 1);
-            if (nid == null) {
+            if (node == null) {
-            ACLImpl acl = getACL(nid, principalNames);
+            ACLImpl acl = getACL((NodeImpl) node, principalNames);
-                log.error("Internal error: ", e.getMessage());
+                log.debug("Unable to unregister listener: ", e.getMessage());
+         * @see CompiledPermissions#grants(Path, int)
-            // common check
-            if (permissions == Permission.READ && readAllowed &&
-                    /* easy check if path doesn't point to AC-content */
-                    resolver.getJCRPath(absPath).indexOf(policyNodeName) == -1) {
+            if (permissions == Permission.READ && readAllowed && !isAcItem(absPath)) {
+            } else if (permissions != Permission.READ && readOnly) {
+                return false;
+            } else {
+                return super.grants(absPath, permissions);
-            return super.grants(absPath, permissions);
-                    if (Text.isDescendantOrEqual("/"+ N_ACCESSCONTROL, path)) {
-                        // access control change applies to the 'combined' acls
-                        // -> ignore
-                        continue;
-                    }
+                    // TODO: check if valid. check required.
+                                // if ace is a new ALLOW -> check if obsoletes read-only
+                                if (readOnly && n.isNodeType(NT_REP_GRANT_ACE)) {
+                                    Value[] vs = n.getProperty(P_PRIVILEGES).getValues();
+                                    for (int i = 0; i < vs.length; i++) {
+                                        if (!Privilege.READ.equals(vs[i].getString())) {
+                                            readOnly = false;
+                                        }
+                                    }
+                                }

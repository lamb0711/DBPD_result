- removed @author and @version (i.e. $Revision & $Id) tags
- removed tab characters from java source code

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@47648 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.log4j.Logger;
+import org.apache.log4j.Logger;
- *
- * @author Stefan Guggisberg
- * @version $Revision: 1.2 $, $Date: 2004/09/07 14:39:44 $
-	this.persistentStateMgr = persistentStateMgr;
-	// create transient item state manager
-	transientStateMgr = new TransientItemStateManager();
-	// create hierarchy manager that uses both transient and persistent state
-	hierMgr = new HierarchyManagerImpl(rootNodeUUID, this, nsResolver);
+        this.persistentStateMgr = persistentStateMgr;
+        // create transient item state manager
+        transientStateMgr = new TransientItemStateManager();
+        // create hierarchy manager that uses both transient and persistent state
+        hierMgr = new HierarchyManagerImpl(rootNodeUUID, this, nsResolver);
-	// XXX very inefficient implementation, especially if # of transient states
-	// is relatively small compared to the total # of persistent states
-	if (descendents.size() == transientStateMgr.getEntriesCount()) {
-	    return;
-	}
-	try {
-	    if (id.denotesNode()) {
-		NodeId parentId = (NodeId) id;
-		ItemId[] childIds = hierMgr.listChildren(parentId);
-		for (int i = 0; i < childIds.length; i++) {
-		    ItemId childId = childIds[i];
-		    if (transientStateMgr.hasItemState(childId)) {
-			ItemState state = transientStateMgr.getItemState(childId);
-			if (!descendents.contains(state)) {
-			    descendents.add(state);
-			}
-		    }
-		    if (childId.denotesNode()) {
-			// recurse
-			collectDescendantItemStates(childId, descendents);
-		    }
-		}
-		// also add transient child nodes that have been unlinked from
-		// the specified parent node but are not orphaned yet (i.e.
-		// they are still linked to at least one other parent node)
-		if (transientStateMgr.hasItemState(parentId)) {
-		    NodeState parentState = (NodeState) transientStateMgr.getItemState(parentId);
-		    Iterator iter = parentState.getRemovedChildNodeEntries().iterator();
-		    while (iter.hasNext()) {
-			// removed child nodes
-			NodeState.ChildNodeEntry cne = (NodeState.ChildNodeEntry) iter.next();
-			NodeId removedChildId = new NodeId(cne.getUUID());
-			if (transientStateMgr.hasItemState(removedChildId)) {
-			    ItemState state = transientStateMgr.getItemState(removedChildId);
-			    if (!descendents.contains(state)) {
-				descendents.add(state);
-			    }
-			}
-		    }
-		}
-	    }
-	} catch (ItemStateException ise) {
-	    log.warn("inconsistent hierarchy state", ise);
-	} catch (RepositoryException re) {
-	    log.warn("inconsistent hierarchy state", re);
-	}
+        // XXX very inefficient implementation, especially if # of transient states
+        // is relatively small compared to the total # of persistent states
+        if (descendents.size() == transientStateMgr.getEntriesCount()) {
+            return;
+        }
+        try {
+            if (id.denotesNode()) {
+                NodeId parentId = (NodeId) id;
+                ItemId[] childIds = hierMgr.listChildren(parentId);
+                for (int i = 0; i < childIds.length; i++) {
+                    ItemId childId = childIds[i];
+                    if (transientStateMgr.hasItemState(childId)) {
+                        ItemState state = transientStateMgr.getItemState(childId);
+                        if (!descendents.contains(state)) {
+                            descendents.add(state);
+                        }
+                    }
+                    if (childId.denotesNode()) {
+                        // recurse
+                        collectDescendantItemStates(childId, descendents);
+                    }
+                }
+                // also add transient child nodes that have been unlinked from
+                // the specified parent node but are not orphaned yet (i.e.
+                // they are still linked to at least one other parent node)
+                if (transientStateMgr.hasItemState(parentId)) {
+                    NodeState parentState = (NodeState) transientStateMgr.getItemState(parentId);
+                    Iterator iter = parentState.getRemovedChildNodeEntries().iterator();
+                    while (iter.hasNext()) {
+                        // removed child nodes
+                        NodeState.ChildNodeEntry cne = (NodeState.ChildNodeEntry) iter.next();
+                        NodeId removedChildId = new NodeId(cne.getUUID());
+                        if (transientStateMgr.hasItemState(removedChildId)) {
+                            ItemState state = transientStateMgr.getItemState(removedChildId);
+                            if (!descendents.contains(state)) {
+                                descendents.add(state);
+                            }
+                        }
+                    }
+                }
+            }
+        } catch (ItemStateException ise) {
+            log.warn("inconsistent hierarchy state", ise);
+        } catch (RepositoryException re) {
+            log.warn("inconsistent hierarchy state", re);
+        }
-	// XXX very inefficient implementation, especially if # of transient states
-	// is relatively small compared to the total # of persistent states
-	if (descendents.size() == transientStateMgr.getEntriesInAtticCount()) {
-	    return;
-	}
-	try {
-	    if (id.denotesNode()) {
-		NodeId parentId = (NodeId) id;
+        // XXX very inefficient implementation, especially if # of transient states
+        // is relatively small compared to the total # of persistent states
+        if (descendents.size() == transientStateMgr.getEntriesInAtticCount()) {
+            return;
+        }
+        try {
+            if (id.denotesNode()) {
+                NodeId parentId = (NodeId) id;
-		// traverse zombie children (i.e. children marked as removed)
-		ItemId[] childIds = hierMgr.listZombieChildren(parentId);
-		for (int i = 0; i < childIds.length; i++) {
-		    ItemId childId = childIds[i];
-		    // check attic
-		    if (transientStateMgr.hasItemStateInAttic(childId)) {
-			// found on attic, add to descendents list
-			ItemState state = transientStateMgr.getItemStateInAttic(childId);
-			if (!descendents.contains(state)) {
-			    descendents.add(state);
-			}
-		    }
-		    if (childId.denotesNode()) {
-			// recurse
-			collectDescendantItemStatesInAttic(childId, descendents);
-		    }
-		}
+                // traverse zombie children (i.e. children marked as removed)
+                ItemId[] childIds = hierMgr.listZombieChildren(parentId);
+                for (int i = 0; i < childIds.length; i++) {
+                    ItemId childId = childIds[i];
+                    // check attic
+                    if (transientStateMgr.hasItemStateInAttic(childId)) {
+                        // found on attic, add to descendents list
+                        ItemState state = transientStateMgr.getItemStateInAttic(childId);
+                        if (!descendents.contains(state)) {
+                            descendents.add(state);
+                        }
+                    }
+                    if (childId.denotesNode()) {
+                        // recurse
+                        collectDescendantItemStatesInAttic(childId, descendents);
+                    }
+                }
-		// traverse existing children (because they might have zombie children)
-		childIds = hierMgr.listChildren(parentId);
-		for (int i = 0; i < childIds.length; i++) {
-		    ItemId childId = childIds[i];
-		    if (childId.denotesNode()) {
-			// recurse
-			collectDescendantItemStatesInAttic(childId, descendents);
-		    }
-		}
-	    }
-	} catch (ItemStateException ise) {
-	    log.warn("inconsistent hierarchy state", ise);
-	} catch (RepositoryException re) {
-	    log.warn("inconsistent hierarchy state", re);
-	}
+                // traverse existing children (because they might have zombie children)
+                childIds = hierMgr.listChildren(parentId);
+                for (int i = 0; i < childIds.length; i++) {
+                    ItemId childId = childIds[i];
+                    if (childId.denotesNode()) {
+                        // recurse
+                        collectDescendantItemStatesInAttic(childId, descendents);
+                    }
+                }
+            }
+        } catch (ItemStateException ise) {
+            log.warn("inconsistent hierarchy state", ise);
+        } catch (RepositoryException re) {
+            log.warn("inconsistent hierarchy state", re);
+        }
-	ps.println("SessionItemStateManager (" + this + ")");
-	ps.println();
-	persistentStateMgr.dump(ps);
-	ps.println();
-	transientStateMgr.dump(ps);
-	ps.println();
+        ps.println("SessionItemStateManager (" + this + ")");
+        ps.println();
+        persistentStateMgr.dump(ps);
+        ps.println();
+        transientStateMgr.dump(ps);
+        ps.println();
-	return hierMgr;
+        return hierMgr;
-	    throws NoSuchItemStateException, ItemStateException {
-	// first check if the specified item has been transiently removed
-	if (transientStateMgr.hasItemStateInAttic(id)) {
-	    /**
-	     * check if there's new transient state for the specified item
-	     * (e.g. if a property with name 'x' has been removed and a new
-	     * property with same name has been created);
-	     * this will throw a NoSuchItemStateException if there's no new
-	     * transient state
-	     */
-	    return transientStateMgr.getItemState(id);
-	}
-	try {
-	    // check if there's transient state for the specified item
-	    return transientStateMgr.getItemState(id);
-	} catch (NoSuchItemStateException nsise) {
-	    // check if there's persistent state for the specified item
-	    return persistentStateMgr.getItemState(id);
-	}
+            throws NoSuchItemStateException, ItemStateException {
+        // first check if the specified item has been transiently removed
+        if (transientStateMgr.hasItemStateInAttic(id)) {
+            /**
+             * check if there's new transient state for the specified item
+             * (e.g. if a property with name 'x' has been removed and a new
+             * property with same name has been created);
+             * this will throw a NoSuchItemStateException if there's no new
+             * transient state
+             */
+            return transientStateMgr.getItemState(id);
+        }
+        try {
+            // check if there's transient state for the specified item
+            return transientStateMgr.getItemState(id);
+        } catch (NoSuchItemStateException nsise) {
+            // check if there's persistent state for the specified item
+            return persistentStateMgr.getItemState(id);
+        }
-	try {
-	    getItemState(id);
-	    return true;
-	} catch (ItemStateException ise) {
-	    return false;
-	}
+        try {
+            getItemState(id);
+            return true;
+        } catch (ItemStateException ise) {
+            return false;
+        }
-	    throws NoSuchItemStateException, ItemStateException {
-	return transientStateMgr.getItemStateInAttic(id);
+            throws NoSuchItemStateException, ItemStateException {
+        return transientStateMgr.getItemStateInAttic(id);
-	try {
-	    getItemStateInAttic(id);
-	    return true;
-	} catch (ItemStateException ise) {
-	    return false;
-	}
+        try {
+            getItemStateInAttic(id);
+            return true;
+        } catch (ItemStateException ise) {
+            return false;
+        }
-	    throws NoSuchItemStateException, ItemStateException {
-	return transientStateMgr.getItemState(id);
+            throws NoSuchItemStateException, ItemStateException {
+        return transientStateMgr.getItemState(id);
-	return !transientStateMgr.isEmpty();
+        return !transientStateMgr.isEmpty();
-	// @todo need a more efficient way to find descendents in cache (e.g. using hierarchical index)
-	if (!transientStateMgr.hasAnyItemStates()) {
-	    return Collections.EMPTY_LIST.iterator();
-	}
-	// collection of descendant transient states:
-	// the path serves as key and sort criteria
-	TreeMap descendants = new TreeMap(new PathComparator());
-	try {
-	    Path[] parentPaths = hierMgr.getAllPaths(parentId);
-	    /**
-	     * walk through list of transient states and check if
-	     * they are descendants of the specified parent
-	     */
-	    Iterator iter = transientStateMgr.getEntries();
-	    while (iter.hasNext()) {
-		ItemState state = (ItemState) iter.next();
-		ItemId id = state.getId();
-		Path[] paths = hierMgr.getAllPaths(id);
-		boolean isDescendant = false;
-		/**
-		 * check if any of the paths to the transient state
-		 * is a descendant of any of the specified parentId's paths
-		 */
-		for (int i = 0; i < paths.length; i++) {
-		    Path p0 = paths[i];	// path to transient state
-		    // walk through array of the specified parentId's paths
-		    for (int j = 0; j < parentPaths.length; j++) {
-			Path p1 = parentPaths[j]; // path to specified parentId
-			if (p0.isDescendantOf(p1)) {
-			    // this is a descendant, add it to the list and
-			    // continue with next transient state
-			    descendants.put(p0, state);
+        // @todo need a more efficient way to find descendents in cache (e.g. using hierarchical index)
+        if (!transientStateMgr.hasAnyItemStates()) {
+            return Collections.EMPTY_LIST.iterator();
+        }
+        // collection of descendant transient states:
+        // the path serves as key and sort criteria
+        TreeMap descendants = new TreeMap(new PathComparator());
+        try {
+            Path[] parentPaths = hierMgr.getAllPaths(parentId);
+            /**
+             * walk through list of transient states and check if
+             * they are descendants of the specified parent
+             */
+            Iterator iter = transientStateMgr.getEntries();
+            while (iter.hasNext()) {
+                ItemState state = (ItemState) iter.next();
+                ItemId id = state.getId();
+                Path[] paths = hierMgr.getAllPaths(id);
+                boolean isDescendant = false;
+                /**
+                 * check if any of the paths to the transient state
+                 * is a descendant of any of the specified parentId's paths
+                 */
+                for (int i = 0; i < paths.length; i++) {
+                    Path p0 = paths[i];	// path to transient state
+                    // walk through array of the specified parentId's paths
+                    for (int j = 0; j < parentPaths.length; j++) {
+                        Path p1 = parentPaths[j]; // path to specified parentId
+                        if (p0.isDescendantOf(p1)) {
+                            // this is a descendant, add it to the list and
+                            // continue with next transient state
+                            descendants.put(p0, state);
-			    break;
-			}
-		    }
-		    if (isDescendant) {
-			break;
-		    }
-		}
-		if (!isDescendant && id.denotesNode()) {
-		    /**
-		     * finally check if transient state has been unlinked
-		     * from a parent node (but is not orphaned yet, i.e. is
-		     * still linked to at least one other parent node);
-		     * if that's the case, check if that parent is a
-		     * descendant of/identical with any of the specified
-		     * parentId's paths.
-		     */
-		    NodeState nodeState = (NodeState) state;
-		    Iterator iterUUIDs = nodeState.getRemovedParentUUIDs().iterator();
-		    while (iterUUIDs.hasNext()) {
-			/**
-			 * check if any of the paths to the removed parent
-			 * is a descendant of/identical with any of the
-			 * specified parentId's paths.
-			 */
-			Path[] pa = hierMgr.getAllPaths(new NodeId((String) iterUUIDs.next()));
-			for (int k = 0; k < pa.length; k++) {
-			    Path p0 = pa[k];	// path to removed parent
-			    // walk through array of the specified parentId's paths
-			    for (int j = 0; j < parentPaths.length; j++) {
-				Path p1 = parentPaths[j]; // path to specified parentId
-				if (p0.equals(p1) || p0.isDescendantOf(p1)) {
-				    // this is a descendant, add it to the list and
-				    // continue with next transient state
+                            break;
+                        }
+                    }
+                    if (isDescendant) {
+                        break;
+                    }
+                }
+                if (!isDescendant && id.denotesNode()) {
+                    /**
+                     * finally check if transient state has been unlinked
+                     * from a parent node (but is not orphaned yet, i.e. is
+                     * still linked to at least one other parent node);
+                     * if that's the case, check if that parent is a
+                     * descendant of/identical with any of the specified
+                     * parentId's paths.
+                     */
+                    NodeState nodeState = (NodeState) state;
+                    Iterator iterUUIDs = nodeState.getRemovedParentUUIDs().iterator();
+                    while (iterUUIDs.hasNext()) {
+                        /**
+                         * check if any of the paths to the removed parent
+                         * is a descendant of/identical with any of the
+                         * specified parentId's paths.
+                         */
+                        Path[] pa = hierMgr.getAllPaths(new NodeId((String) iterUUIDs.next()));
+                        for (int k = 0; k < pa.length; k++) {
+                            Path p0 = pa[k];	// path to removed parent
+                            // walk through array of the specified parentId's paths
+                            for (int j = 0; j < parentPaths.length; j++) {
+                                Path p1 = parentPaths[j]; // path to specified parentId
+                                if (p0.equals(p1) || p0.isDescendantOf(p1)) {
+                                    // this is a descendant, add it to the list and
+                                    // continue with next transient state
-				    // FIXME need to create dummy path in order
-				    // to avoid conflicts
-				    Path.PathBuilder pb = new Path.PathBuilder(p0.getElements());
-				    pb.addFirst(NamespaceRegistryImpl.NS_DEFAULT_URI, Integer.toString(new Random().nextInt()));
-				    descendants.put(pb.getPath(), state);
-				    isDescendant = true;
-				    break;
-				}
-			    }
-			    if (isDescendant) {
-				break;
-			    }
-			}
-			if (isDescendant) {
-			    break;
-			}
-		    }
-		}
-		// continue with next transient state
-	    }
-	} catch (MalformedPathException mpe) {
-	    log.warn("inconsistent hierarchy state", mpe);
-	} catch (RepositoryException re) {
-	    log.warn("inconsistent hierarchy state", re);
-	}
+                                    // FIXME need to create dummy path in order
+                                    // to avoid conflicts
+                                    Path.PathBuilder pb = new Path.PathBuilder(p0.getElements());
+                                    pb.addFirst(NamespaceRegistryImpl.NS_DEFAULT_URI, Integer.toString(new Random().nextInt()));
+                                    descendants.put(pb.getPath(), state);
+                                    isDescendant = true;
+                                    break;
+                                }
+                            }
+                            if (isDescendant) {
+                                break;
+                            }
+                        }
+                        if (isDescendant) {
+                            break;
+                        }
+                    }
+                }
+                // continue with next transient state
+            }
+        } catch (MalformedPathException mpe) {
+            log.warn("inconsistent hierarchy state", mpe);
+        } catch (RepositoryException re) {
+            log.warn("inconsistent hierarchy state", re);
+        }
-	return descendants.values().iterator();
+        return descendants.values().iterator();
-	// @todo need a more efficient way to find descendents in attic (e.g. using hierarchical index)
-	if (!transientStateMgr.hasAnyItemStatesInAttic()) {
-	    return Collections.EMPTY_LIST.iterator();
-	}
-	// collection of descendant transient states in attic:
-	// the path serves as key and sort criteria
-	TreeMap descendants = new TreeMap(new PathComparator());
-	try {
-	    Path[] parentPaths = hierMgr.getAllPaths(parentId, true);
-	    /**
-	     * walk through list of transient states in attic and check if
-	     * they are descendants of the specified parent
-	     */
-	    Iterator iter = transientStateMgr.getEntriesInAttic();
-	    while (iter.hasNext()) {
-		ItemState state = (ItemState) iter.next();
-		ItemId id = state.getId();
-		Path[] paths = hierMgr.getAllPaths(id, true);
-		boolean isDescendant = false;
-		/**
-		 * check if any of the paths to the transient state
-		 * is a descendant of any of the specified parentId's paths
-		 */
-		for (int i = 0; i < paths.length; i++) {
-		    Path p0 = paths[i];	// path to transient state in attic
-		    // walk through array of the specified parentId's paths
-		    for (int j = 0; j < parentPaths.length; j++) {
-			Path p1 = parentPaths[j]; // path to specified parentId
-			if (p0.isDescendantOf(p1)) {
-			    // this is a descendant, add it to the list and
-			    // continue with next transient state
-			    descendants.put(p0, state);
+        // @todo need a more efficient way to find descendents in attic (e.g. using hierarchical index)
+        if (!transientStateMgr.hasAnyItemStatesInAttic()) {
+            return Collections.EMPTY_LIST.iterator();
+        }
+        // collection of descendant transient states in attic:
+        // the path serves as key and sort criteria
+        TreeMap descendants = new TreeMap(new PathComparator());
+        try {
+            Path[] parentPaths = hierMgr.getAllPaths(parentId, true);
+            /**
+             * walk through list of transient states in attic and check if
+             * they are descendants of the specified parent
+             */
+            Iterator iter = transientStateMgr.getEntriesInAttic();
+            while (iter.hasNext()) {
+                ItemState state = (ItemState) iter.next();
+                ItemId id = state.getId();
+                Path[] paths = hierMgr.getAllPaths(id, true);
+                boolean isDescendant = false;
+                /**
+                 * check if any of the paths to the transient state
+                 * is a descendant of any of the specified parentId's paths
+                 */
+                for (int i = 0; i < paths.length; i++) {
+                    Path p0 = paths[i];	// path to transient state in attic
+                    // walk through array of the specified parentId's paths
+                    for (int j = 0; j < parentPaths.length; j++) {
+                        Path p1 = parentPaths[j]; // path to specified parentId
+                        if (p0.isDescendantOf(p1)) {
+                            // this is a descendant, add it to the list and
+                            // continue with next transient state
+                            descendants.put(p0, state);
-			    break;
-			}
-		    }
-		    if (isDescendant) {
-			break;
-		    }
-		}
-		// continue with next transient state
-	    }
-	} catch (MalformedPathException mpe) {
-	    log.warn("inconsistent hierarchy state", mpe);
-	} catch (RepositoryException re) {
-	    log.warn("inconsistent hierarchy state", re);
-	}
+                            break;
+                        }
+                    }
+                    if (isDescendant) {
+                        break;
+                    }
+                }
+                // continue with next transient state
+            }
+        } catch (MalformedPathException mpe) {
+            log.warn("inconsistent hierarchy state", mpe);
+        } catch (RepositoryException re) {
+            log.warn("inconsistent hierarchy state", re);
+        }
-	return descendants.values().iterator();
+        return descendants.values().iterator();
-	    throws ItemStateException {
-	return transientStateMgr.createNodeState(uuid, nodeTypeName, parentUUID, initialStatus);
+            throws ItemStateException {
+        return transientStateMgr.createNodeState(uuid, nodeTypeName, parentUUID, initialStatus);
-	    throws ItemStateException {
-	return transientStateMgr.createNodeState(overlayedState, initialStatus);
+            throws ItemStateException {
+        return transientStateMgr.createNodeState(overlayedState, initialStatus);
-	    throws ItemStateException {
-	return transientStateMgr.createPropertyState(parentUUID, propName, initialStatus);
+            throws ItemStateException {
+        return transientStateMgr.createPropertyState(parentUUID, propName, initialStatus);
-	    throws ItemStateException {
-	return transientStateMgr.createPropertyState(overlayedState, initialStatus);
+            throws ItemStateException {
+        return transientStateMgr.createPropertyState(overlayedState, initialStatus);
-	transientStateMgr.disposeItemState(state);
+        transientStateMgr.disposeItemState(state);
-	transientStateMgr.moveItemStateToAttic(state);
+        transientStateMgr.moveItemStateToAttic(state);
-	transientStateMgr.disposeItemStateInAttic(state);
+        transientStateMgr.disposeItemStateInAttic(state);
-	transientStateMgr.disposeAllItemStates();
+        transientStateMgr.disposeAllItemStates();
-	    throws ItemStateException {
-	return persistentStateMgr.createNodeState(uuid, nodeTypeName, parentUUID);
+            throws ItemStateException {
+        return persistentStateMgr.createNodeState(uuid, nodeTypeName, parentUUID);
-	    throws ItemStateException {
-	return persistentStateMgr.createPropertyState(parentUUID, propName);
+            throws ItemStateException {
+        return persistentStateMgr.createPropertyState(parentUUID, propName);
-	/**
-	 *
-	 * @param o1
-	 * @param o2
-	 * @return
-	 */
-	public int compare(Object o1, Object o2) {
-	    Path p1 = (Path) o1;
-	    Path p2 = (Path) o2;
-	    if (p1.equals(p2)) {
-		return 0;
-	    }
-	    try {
-		if (p1.isAncestorOf(p2)) {
-		    return -1;
-		} else if (p1.isDescendantOf(p2)) {
-		    return 1;
-		}
-	    } catch (MalformedPathException mpe) {
-		log.warn("unable to compare non-canonical (i.e. relative) paths", mpe);
-	    }
-	    // the 2 paths are not on the same graph;
-	    // do string comparison of individual path elements
-	    Path.PathElement[] pea1 = p1.getElements();
-	    Path.PathElement[] pea2 = p2.getElements();
-	    for (int i = 0; i < pea1.length; i++) {
-		if (i >= pea2.length) {
-		    return 1;
-		}
-		String s1 = pea1[i].toString();
-		String s2 = pea2[i].toString();
-		int result = s1.compareTo(s2);
-		if (result != 0) {
-		    return result;
-		}
-	    }
-	    return 0;
-	}
+        /**
+         * @param o1
+         * @param o2
+         * @return
+         */
+        public int compare(Object o1, Object o2) {
+            Path p1 = (Path) o1;
+            Path p2 = (Path) o2;
+            if (p1.equals(p2)) {
+                return 0;
+            }
+            try {
+                if (p1.isAncestorOf(p2)) {
+                    return -1;
+                } else if (p1.isDescendantOf(p2)) {
+                    return 1;
+                }
+            } catch (MalformedPathException mpe) {
+                log.warn("unable to compare non-canonical (i.e. relative) paths", mpe);
+            }
+            // the 2 paths are not on the same graph;
+            // do string comparison of individual path elements
+            Path.PathElement[] pea1 = p1.getElements();
+            Path.PathElement[] pea2 = p2.getElements();
+            for (int i = 0; i < pea1.length; i++) {
+                if (i >= pea2.length) {
+                    return 1;
+                }
+                String s1 = pea1[i].toString();
+                String s2 = pea2[i].toString();
+                int result = s1.compareTo(s2);
+                if (result != 0) {
+                    return result;
+                }
+            }
+            return 0;
+        }

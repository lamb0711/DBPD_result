JCR-2509 : Reduce number of compiler warning by adding @Override and generics where appropriate [step 3: jackrabbit-spi2dav]

in addition:
- minor improvements in comments, typos
- use foreach loops where possible
- remove redundant casts
- remove unused field in NodeInfoImp
- remove unused method in ReadTest
- add WeakReference test to BatchTest

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@915358 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.JcrConstants;
-import org.apache.jackrabbit.JcrConstants;
+import org.apache.jackrabbit.spi.ItemInfo;
+import org.apache.jackrabbit.spi.commons.name.NameConstants;
-import org.apache.jackrabbit.spi.commons.name.NameConstants;
-import javax.jcr.NamespaceException;
-    private final Map qvFactories = new HashMap();
+    private final Map<SessionInfo, QValueFactoryImpl> qvFactories = new HashMap<SessionInfo, QValueFactoryImpl>();
-                public int getDepth(Path path, PathResolver resolver)
-                        throws NamespaceException {
+                public int getDepth(Path path, PathResolver resolver) {
-                    // -> search /jcr:root and start substring behind.
+                    // -> search /jcr:root and start sub-string behind.
-             qv = (QValueFactoryImpl) qvFactories.get(sessionInfo);
+             qv = qvFactories.get(sessionInfo);
+    @Override
+    @Override
+    @Override
-    public Iterator getItemInfos(SessionInfo sessionInfo, NodeId nodeId) throws ItemNotFoundException, RepositoryException {
+    @Override
+    public Iterator<? extends ItemInfo> getItemInfos(SessionInfo sessionInfo, NodeId nodeId) throws ItemNotFoundException, RepositoryException {
-                    // no json response -> no such node on the server
+                    // no JSON response -> no such node on the server
-                Iterator it = handler.getItemInfos();
+                Iterator<? extends ItemInfo> it = handler.getItemInfos();
+    @Override
+    @Override
+    @Override
+    @Override
-        private final List parts;
-        private final List diff;
+        private final List<Part> parts;
+        private final List<String> diff;
-        private final Map removed = new HashMap();
+        private final Map<Path, Path> removed = new HashMap<Path, Path>();
-            parts = new ArrayList();
-            diff = new ArrayList();
+            parts = new ArrayList<Part>();
+            diff = new ArrayList<String>();
-            // add locktokens
+            // add lock tokens
-            for (Iterator it = diff.iterator(); it.hasNext();) {
-                buf.append(it.next().toString());
+            for (Iterator<String> it = diff.iterator(); it.hasNext();) {
+                buf.append(it.next());
-                Part[] partArr = (Part[]) parts.toArray(new Part[parts.size()]);
+                Part[] partArr = parts.toArray(new Part[parts.size()]);
-                // ship lock-tokens as if-header to cirvumvent problems with
+                // ship lock-tokens as if-header to circumvent problems with
-            for (Iterator it = diff.iterator(); it.hasNext();) {
-                String entry = it.next().toString();
+            for (Iterator<String> it = diff.iterator(); it.hasNext();) {
+                String entry = it.next();
-            for (Iterator it = parts.iterator(); it.hasNext();) {
-                Part part = (Part) it.next();
+            for (Iterator<Part> it = parts.iterator(); it.hasNext();) {
+                Part part = it.next();
-                        siblingP = (Path) removed.get(siblingP);
+                        siblingP = removed.get(siblingP);

Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.operation.SetMixin;
+import org.apache.jackrabbit.jcr2spi.hierarchy.NodeEntry;
+import org.apache.jackrabbit.name.QName;
-                    // remove add-operation (parent affected) as well
-                    NodeState parent = state.getParent();
-                    if (parent != null && parent.getStatus() != Status.REMOVED) {
-                        for (Iterator it = operations.iterator(); it.hasNext();) {
-                            Operation op = (Operation) it.next();
-                            if ((op instanceof AddNode || op instanceof AddProperty)
-                                && op.getAffectedItemStates().contains(parent)) {
-                                it.remove();
+                    /* remove the add-operation as well:
+                       since the affected state of an 'ADD' operation is the parent
+                       instead of the added-state, the set of operations
+                       need to be searched for the parent state && the proper
+                       operation type.
+                       SET_MIXIN can be is a special case of adding a property */
+                    NodeEntry parentEntry = state.getHierarchyEntry().getParent();
+                    if (parentEntry != null && parentEntry.isAvailable()) {
+                        try {
+                            NodeState parent = parentEntry.getNodeState();
+                            if (parent.getStatus() != Status.REMOVED) {
+                                for (Iterator it = operations.iterator(); it.hasNext();) {
+                                    Operation op = (Operation) it.next();
+                                    if (op instanceof AddNode && ((AddNode)op).getParentState() == parent) {
+                                        it.remove();
+                                        break;
+                                    } else if (op instanceof AddProperty && ((AddProperty)op).getParentState() == parent) {
+                                        it.remove();
+                                        break;
+                                    } else if (op instanceof SetMixin &&
+                                        QName.JCR_MIXINTYPES.equals(state.getQName()) &&
+                                        ((SetMixin)op).getNodeState() == parent) {
+                                        it.remove();
+                                        break;
+                                    }
+                                }
+                        } catch (ItemStateException e) {
+                            // should never occur -> ignore

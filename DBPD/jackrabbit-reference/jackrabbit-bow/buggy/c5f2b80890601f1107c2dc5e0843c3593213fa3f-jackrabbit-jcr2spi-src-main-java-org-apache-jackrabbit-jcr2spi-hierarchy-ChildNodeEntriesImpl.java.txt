JCR-1638: Redundant calls to RepositoryService.getChildInfos

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@701388 13f79535-47bb-0310-9956-ffa450edef68

+    private static final int STATUS_OK = 0;
+    private static final int STATUS_INVALIDATED = 1;
+
+    private boolean complete = false;
-    private final LinkedEntries entries;
+    private final LinkedEntries entries = new LinkedEntries();
-    private final NameMap entriesByName;
+    private final NameMap entriesByName = new NameMap();
-        entriesByName = new NameMap();
-        entries = new LinkedEntries();
-
+
+        /* all child infos have been read from the persistent layer therefore
+           mark this child-node-entries as 'complete' */
+        complete = true;
-    /**
-     * Create a new <code>ChildNodeEntries</code> collection from the given
-     * <code>childNodeInfos</code> instead of retrieving them from the
-     * persistent layer.
-     *
-     * @param parent
-     * @param factory
-     * @param childNodeInfos
-     */
-    ChildNodeEntriesImpl(NodeEntry parent, EntryFactory factory, Iterator childNodeInfos) {
-        entriesByName = new NameMap();
-        entries = new LinkedEntries();
+     /**
+      * Create a new <code>ChildNodeEntries</code> collection from the given
+      * <code>childNodeInfos</code> instead of retrieving them from the
+      * persistent layer.
+      *
+      * @param parent
+      * @param factory
+      * @param childNodeInfos The complete list of child infos or
+      * <code>null</code> if an 'empty' ChildNodeEntriesImpl should be created.
+      * In the latter case, individual child entries will be added on demand
+      * and the complete list will be retrieved only to answer {@link #iterator()}
+      * if the passed boolean is <code>true</code>.
+      */
+     ChildNodeEntriesImpl(NodeEntry parent, EntryFactory factory, Iterator childNodeInfos) {
+         this.parent = parent;
+         this.factory = factory;
-        this.parent = parent;
-        this.factory = factory;
-
-        while (childNodeInfos.hasNext()) {
-            ChildInfo ci = (ChildInfo) childNodeInfos.next();
-            NodeEntry entry = factory.createNodeEntry(parent, ci.getName(), ci.getUniqueID());
-            add(entry, ci.getIndex());
-        }
-    }
+         if (childNodeInfos != null) {
+             while (childNodeInfos.hasNext()) {
+                 ChildInfo ci = (ChildInfo) childNodeInfos.next();
+                 NodeEntry entry = factory.createNodeEntry(parent, ci.getName(), ci.getUniqueID());
+                 add(entry, ci.getIndex());
+             }
+             complete = true;
+         } else {
+             complete = false;
+         }
+     }
-     * Mark <code>ChildNodeEntries</code> in order to force reloading the
-     * entries.
-     *
-     * @see ChildNodeEntries#setStatus(int)
+     * @see ChildNodeEntries#invalidate()
-    public void setStatus(int status) {
-        if (status == STATUS_INVALIDATED || status == STATUS_OK) {
-            this.status = status;
-        } else {
-            throw new IllegalArgumentException();
-        }
+    public void invalidate() {
+        this.status = STATUS_INVALIDATED;
-        if (status == STATUS_OK ||
+        if (status == STATUS_OK && complete ||
-        reload(childNodeInfos);
+        update(childNodeInfos);
-    void reload(Iterator childNodeInfos) {
+    synchronized void update(Iterator childNodeInfos) {
-        setStatus(ChildNodeEntries.STATUS_OK);
+        status = STATUS_OK;
+        complete = true;
-
+    
-     public void add(NodeEntry cne) {
+     public synchronized void add(NodeEntry cne) {
-    public void add(NodeEntry cne, int index) {
+    public synchronized void add(NodeEntry cne, int index) {
-     * @return
+     * @return the <code>LinkNode</code> belonging to the added entry.
-    public void add(NodeEntry entry, NodeEntry beforeEntry) {
+    public synchronized void add(NodeEntry entry, NodeEntry beforeEntry) {
-    public NodeEntry reorder(NodeEntry insertEntry, NodeEntry beforeEntry) {
+    public synchronized NodeEntry reorder(NodeEntry insertEntry, NodeEntry beforeEntry) {
-         * @return
+         * @return true if more than one NodeEnty with the given name exists.
-         * @return
+         * @return list of entries or an empty list.
-         * @return
+         * @return matching entry or <code>null</code>.

JCR-160: Query index not in sync with workspace
Extended consistency check to also include:
- Missing ancestor
- Unknown parent
- Nodes indexed more than once

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@219477 13f79535-47bb-0310-9956-ffa450edef68

- * the volatile index reaches a certain size (see {@link #setMinMergeDocs(int)} a
+ * the volatile index reaches a certain size (see {@link SearchIndex#setMinMergeDocs(int)} a
- * is configurable using the methods: {@link #setMaxMergeDocs(int)},
- * {@link #setMergeFactor(int)} and {@link #setMinMergeDocs(int)}. For detailed
+ * is configurable using the methods: {@link SearchIndex#setMaxMergeDocs(int)},
+ * {@link SearchIndex#setMergeFactor(int)} and {@link SearchIndex#setMinMergeDocs(int)}. For detailed
-     * Compound file flag
-     */
-    private boolean useCompoundFile = true;
-
-    /**
-     * minMergeDocs config parameter
-     */
-    private int minMergeDocs = 1000;
-
-    /**
-     * maxMergeDocs config parameter
-     */
-    private int maxMergeDocs = 100000;
-
-    /**
-     * mergeFactor config parameter
-     */
-    private int mergeFactor = 10;
-
-    /**
-     * Default merge size: 1000
-     */
-    private static final long DEFAULT_MERGE_SIZE = 1000;
-
-    /**
-     * The maximum number of entries in the redo log until the volatile index
-     * is merged into the persistent one.
-     */
-    private long mergeSize = DEFAULT_MERGE_SIZE;
-
-    /**
+     * <code>true</code> if the redo log contained entries on startup.
+     */
+    private boolean redoLogApplied = false;
+
+    /**
-                index.setMaxMergeDocs(maxMergeDocs);
-                index.setMergeFactor(mergeFactor);
-                index.setMinMergeDocs(minMergeDocs);
-                index.setUseCompoundFile(useCompoundFile);
+                index.setMaxMergeDocs(handler.getMaxMergeDocs());
+                index.setMergeFactor(handler.getMergeFactor());
+                index.setMinMergeDocs(handler.getMinMergeDocs());
+                index.setUseCompoundFile(handler.getUseCompoundFile());
+                // when we have entries in the redo log there is no need to reindex
+                doInitialIndex = false;
+
-            }
-
-            // execute integrity check on persistent indexes with locks on startup
-            for (Iterator it = indexes.iterator(); it.hasNext(); ) {
-                PersistentIndex index = (PersistentIndex) it.next();
-                if (index.getLockEncountered()) {
-                    log.info("Running integrity check on index: " + index.getName());
-                    index.integrityCheck(stateMgr);
-                }
+                redoLogApplied = true;
+            volatileIndex.setBufferSize(handler.getBufferSize());
-        if (volatileIndex.getRedoLog().getSize() >= mergeSize) {
+        if (volatileIndex.getRedoLog().getSize() >= handler.getMinMergeDocs()) {
-    //-----------------------< properties >-------------------------------------
-
-     * The lucene index writer property: useCompoundFile
+     * Returns a lucene Document for the <code>node</code>.
+     * @param node the node to index.
+     * @return the index document.
+     * @throws RepositoryException if an error occurs while reading from the
+     *   workspace.
-    void setUseCompoundFile(boolean b) {
-        useCompoundFile = b;
-        // apply to all persistent indexes
-        for (int i = 0; i < indexes.size(); i++) {
-            ((PersistentIndex) indexes.get(i)).setUseCompoundFile(b);
-        }
+    Document createDocument(NodeState node) throws RepositoryException {
+        return handler.createDocument(node, nsMappings);
-     * The lucene index writer property: minMergeDocs
+     * Returns <code>true</code> if the redo log contained entries while
+     * this index was instantiated; <code>false</code> otherwise.
+     * @return <code>true</code> if the redo log contained entries.
-    void setMinMergeDocs(int minMergeDocs) {
-        this.minMergeDocs = minMergeDocs;
-        // apply to all persistent indexes
-        for (int i = 0; i < indexes.size(); i++) {
-            ((PersistentIndex) indexes.get(i)).setMinMergeDocs(minMergeDocs);
-        }
-    }
-
-    /**
-     * The lucene index writer property: maxMergeDocs
-     */
-    void setMaxMergeDocs(int maxMergeDocs) {
-        this.maxMergeDocs = maxMergeDocs;
-        // apply to all persistent indexes
-        for (int i = 0; i < indexes.size(); i++) {
-            ((PersistentIndex) indexes.get(i)).setMaxMergeDocs(maxMergeDocs);
-        }
-    }
-
-    /**
-     * The lucene index writer property: mergeFactor
-     */
-    void setMergeFactor(int mergeFactor) {
-        this.mergeFactor = mergeFactor;
-        // apply to all persistent indexes
-        for (int i = 0; i < indexes.size(); i++) {
-            ((PersistentIndex) indexes.get(i)).setMergeFactor(mergeFactor);
-        }
-    }
-
-    public void setBufferSize(int size) {
-        volatileIndex.setBufferSize(size);
+    boolean getRedoLogApplied() {
+        return redoLogApplied;
-            index.setMaxMergeDocs(maxMergeDocs);
-            index.setMergeFactor(mergeFactor);
-            index.setMinMergeDocs(minMergeDocs);
-            index.setUseCompoundFile(useCompoundFile);
+            index.setMaxMergeDocs(handler.getMaxMergeDocs());
+            index.setMergeFactor(handler.getMergeFactor());
+            index.setMinMergeDocs(handler.getMinMergeDocs());
+            index.setUseCompoundFile(handler.getUseCompoundFile());
+        volatileIndex.setBufferSize(handler.getBufferSize());
-        addDocument(handler.createDocument(node, nsMappings));
+        addDocument(createDocument(node));
-            doc = handler.createDocument(node, nsMappings);
+            doc = createDocument(node);
-                index.setMaxMergeDocs(maxMergeDocs);
-                index.setMergeFactor(mergeFactor);
-                index.setMinMergeDocs(minMergeDocs);
-                index.setUseCompoundFile(useCompoundFile);
+                index.setMaxMergeDocs(handler.getMaxMergeDocs());
+                index.setMergeFactor(handler.getMergeFactor());
+                index.setMinMergeDocs(handler.getMinMergeDocs());
+                index.setUseCompoundFile(handler.getUseCompoundFile());
-     * properties: {@link #setMaxMergeDocs(int)}, {@link #setMergeFactor(int)}
-     * and {@link #setMinMergeDocs(int)}.
+     * properties: {@link SearchIndex#setMaxMergeDocs(int)}, {@link
+     * SearchIndex#setMergeFactor(int)} and {@link SearchIndex#setMinMergeDocs(int)}.
-        if (indexes.size() >= mergeFactor) {
-            long targetMergeDocs = minMergeDocs;
-            while (targetMergeDocs <= maxMergeDocs) {
+        if (indexes.size() >= handler.getMergeFactor()) {
+            long targetMergeDocs = handler.getMinMergeDocs();
+            while (targetMergeDocs <= handler.getMaxMergeDocs()) {
-                if (indexes.size() - (minIndex + 1) >= mergeFactor && mergeDocs < maxMergeDocs) {
+                if (indexes.size() - (minIndex + 1) >= handler.getMergeFactor()
+                        && mergeDocs < handler.getMaxMergeDocs()) {
-                targetMergeDocs *= mergeFactor;
+                targetMergeDocs *= handler.getMergeFactor();
-            index.setMaxMergeDocs(maxMergeDocs);
-            index.setMergeFactor(mergeFactor);
-            index.setMinMergeDocs(minMergeDocs);
-            index.setUseCompoundFile(useCompoundFile);
+            index.setMaxMergeDocs(handler.getMaxMergeDocs());
+            index.setMergeFactor(handler.getMergeFactor());
+            index.setMinMergeDocs(handler.getMinMergeDocs());
+            index.setUseCompoundFile(handler.getUseCompoundFile());
-     * <b>Note: This check will be removed when Jackrabbit 1.0 is final.</b>
+     * <b>todo: This check will be removed when Jackrabbit 1.0 is final.</b>

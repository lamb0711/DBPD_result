JCR-927: DatabaseJournal needs connection reestablishment logic


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@541244 13f79535-47bb-0310-9956-ffa450edef68

+ * <li><code>reconnectDelayMs</code>: number of milliseconds to wait before
+ * trying to reconnect to the database.
+     * Default reconnect delay in milliseconds.
+     */
+    private static final long DEFAULT_RECONNECT_DELAY_MS = 10000;
+
+    /**
+     * Reconnect delay in milliseconds, bean property.
+     */
+    private long reconnectDelayMs;
+
+    /**
-    private Connection con;
+    private Connection connection;
+     * Next time in milliseconds to reattempt connecting to the database.
+     */
+    private long reconnectTimeMs;
+
+    /**
+        // Provide valid defaults for arguments
+        if (schemaObjectPrefix == null) {
+            schemaObjectPrefix = "";
+        }
+        if (reconnectDelayMs == 0) {
+            reconnectDelayMs = DEFAULT_RECONNECT_DELAY_MS;
+        }
+
+        init();
+
+        try {
+            connection = getConnection();
+            connection.setAutoCommit(true);
+            checkSchema();
+            prepareStatements();
+        } catch (Exception e) {
+            String msg = "Unable to create connection.";
+            throw new JournalException(msg, e);
+        }
+        log.info("DatabaseJournal initialized.");
+    }
+
+    /**
+     * Completes initialization of this database journal. Base implementation
+     * checks whether the required bean properties <code>driver</code> and
+     * <code>url</code> have been specified and optionally deduces a valid
+     * schema. Should be overridden by subclasses that use a different way to
+     * create a connection and therefore require other arguments.
+     *
+     * @see #getConnection()
+     * @throws JournalException if initialization fails
+     */
+    protected void init() throws JournalException {
-        try {
-            if (schema == null) {
+
+        if (schema == null) {
+            try {
+            } catch (IllegalArgumentException e) {
+                String msg = "Unable to derive schema from URL: " + e.getMessage();
+                throw new JournalException(msg);
-            if (schemaObjectPrefix == null) {
-                schemaObjectPrefix = "";
-            }
-        } catch (IllegalArgumentException e) {
-            String msg = "Unable to derive schema from URL: " + e.getMessage();
-            throw new JournalException(msg);
+
-            con = DriverManager.getConnection(url, user, password);
-            con.setAutoCommit(true);
-
-            checkSchema();
-            prepareStatements();
-        } catch (Exception e) {
-            String msg = "Unable to initialize connection.";
+        } catch (ClassNotFoundException e) {
+            String msg = "Unable to load JDBC driver class.";
-        log.info("DatabaseJournal initialized at URL: " + url);
+    }
+
+    /**
+     * Creates a new database connection. This method is called inside
+     * {@link #init()} or when a connection has been dropped and must be
+     * reacquired. Base implementation uses <code>java.sql.DriverManager</code>
+     * to get the connection. May be overridden by subclasses.
+     *
+     * @see #init()
+     * @return new connection
+     * @throws SQLException if an error occurs
+     */
+    protected Connection getConnection() throws SQLException {
+        return DriverManager.getConnection(url, user, password);
-    private String getSchemaFromURL(String url) throws IllegalArgumentException {
+    private static String getSchemaFromURL(String url) throws IllegalArgumentException {
+            checkConnection();
+
+            close(true);
+
-            con.setAutoCommit(false);
+            checkConnection();
+
+            connection.setAutoCommit(false);
+            close(true);
+
+            close(true);
+
-                rollback(con);
-
-                try {
-                    con.setAutoCommit(true);
-                } catch (SQLException e) {
-                    String msg = "Unable to set autocommit to true.";
-                    log.warn(msg, e);
-                }
+                rollback(connection);
+                setAutoCommit(connection, true);
-            rollback(con);
+            rollback(connection);
-        try {
-            con.setAutoCommit(true);
-        } catch (SQLException e) {
-            String msg = "Unable to set autocommit to true.";
-            log.warn(msg, e);
-        }
+        setAutoCommit(connection, true);
+            checkConnection();
+
-                con.commit();
+                connection.commit();
-                try {
-                    con.setAutoCommit(true);
-                } catch (SQLException e) {
-                    String msg = "Unable to set autocommit to true.";
-                    log.warn(msg, e);
-                }
+                setAutoCommit(connection, true);
+            close(true);
+
-        try {
-            con.close();
-        } catch (SQLException e) {
-            String msg = "Error while closing connection: " + e.getMessage();
-            log.warn(msg);
+        close(false);
+    }
+
+    /**
+     * Close database connections and statements. If closing was due to an
+     * error that occurred, calculates the next time a reconnect should
+     * be attempted.
+     *
+     * @param failure whether closing is due to a failure
+     */
+    private void close(boolean failure) {
+        if (failure) {
+            reconnectTimeMs = System.currentTimeMillis() + reconnectDelayMs;
+        }
+
+        close(selectRevisionsStmt);
+        selectRevisionsStmt = null;
+        close(updateGlobalStmt);
+        updateGlobalStmt = null;
+        close(selectGlobalStmt);
+        selectGlobalStmt = null;
+        close(insertRevisionStmt);
+        insertRevisionStmt = null;
+
+        close(connection);
+        connection = null;
+    }
+
+    /**
+     * Set the autocommit flag of a connection. Does nothing if the connection
+     * passed is <code>null</code> and logs any exception as warning.
+     *
+     * @param connection database connection
+     * @param autoCommit where to enable or disable autocommit
+     */
+    private static void setAutoCommit(Connection connection, boolean autoCommit) {
+        if (connection != null) {
+            try {
+                connection.setAutoCommit(autoCommit);
+            } catch (SQLException e) {
+                String msg = "Unable to set autocommit flag to " + autoCommit;
+                log.warn(msg, e);
+            }
-     * Close some input stream.
+     * Rollback a connection. Does nothing if the connection passed is
+     * <code>null</code> and logs any exception as warning.
+     *
+     * @param connection connection.
+     */
+    private static void rollback(Connection connection) {
+        if (connection != null) {
+            try {
+                connection.rollback();
+            } catch (SQLException e) {
+                String msg = "Error while rolling back connection: " + e.getMessage();
+                log.warn(msg);
+            }
+        }
+    }
+
+    /**
+     * Closes the given database connection. Does nothing if the connection
+     * passed is <code>null</code> and logs any exception as warning.
+     *
+     * @param connection database connection
+     */
+    private static void close(Connection connection) {
+        if (connection != null) {
+            try {
+                connection.close();
+            } catch (SQLException e) {
+                String msg = "Error while closing connection: " + e.getMessage();
+                log.warn(msg);
+            }
+        }
+    }
+
+    /**
+     * Close some input stream.  Does nothing if the input stream
+     * passed is <code>null</code> and logs any exception as warning.
-    private void close(InputStream in) {
-        try {
-            if (in != null) {
+    private static void close(InputStream in) {
+        if (in != null) {
+            try {
+            } catch (IOException e) {
+                String msg = "Error while closing input stream: " + e.getMessage();
+                log.warn(msg);
-        } catch (IOException e) {
-            String msg = "Error while closing input stream: " + e.getMessage();
-            log.warn(msg);
-     * Close some statement.
+     * Close some statement.  Does nothing if the statement
+     * passed is <code>null</code> and logs any exception as warning.
-    private void close(Statement stmt) {
-        try {
-            if (stmt != null) {
+    private static void close(Statement stmt) {
+        if (stmt != null) {
+            try {
+            } catch (SQLException e) {
+                String msg = "Error while closing statement: " + e.getMessage();
+                log.warn(msg);
-        } catch (SQLException e) {
-            String msg = "Error while closing statement: " + e.getMessage();
-            log.warn(msg);
-     * Close some resultset.
+     * Close some resultset.  Does nothing if the result set
+     * passed is <code>null</code> and logs any exception as warning.
-    private void close(ResultSet rs) {
-        try {
-            if (rs != null) {
+    private static void close(ResultSet rs) {
+        if (rs != null) {
+            try {
+            } catch (SQLException e) {
+                String msg = "Error while closing result set: " + e.getMessage();
+                log.warn(msg);
-        } catch (SQLException e) {
-            String msg = "Error while closing result set: " + e.getMessage();
-            log.warn(msg);
-     * Rollback a connection.
-     *
-     * @param con connection.
+     * Checks the currently established connection. If the connection no longer
+     * exists, waits until at least <code>reconnectTimeMs</code> have passed
+     * since the error occurred and recreates the connection.
-    private void rollback(Connection con) {
-        try {
-            con.rollback();
-        } catch (SQLException e) {
-            String msg = "Error while rolling back connection: " + e.getMessage();
-            log.warn(msg);
+    private void checkConnection() throws SQLException {
+        if (connection == null) {
+            long delayMs = reconnectTimeMs - System.currentTimeMillis();
+            if (delayMs > 0) {
+                try {
+                    Thread.sleep(delayMs);
+                } catch (InterruptedException e) {
+                    /* ignore */
+                }
+            }
+            connection = getConnection();
+            prepareStatements();
-        DatabaseMetaData metaData = con.getMetaData();
+        DatabaseMetaData metaData = connection.getMetaData();
-            Statement stmt = con.createStatement();
+            Statement stmt = connection.createStatement();
-        selectRevisionsStmt = con.prepareStatement(
+        selectRevisionsStmt = connection.prepareStatement(
-        updateGlobalStmt = con.prepareStatement(
+        updateGlobalStmt = connection.prepareStatement(
-        selectGlobalStmt = con.prepareStatement(
+        selectGlobalStmt = connection.prepareStatement(
-        insertRevisionStmt = con.prepareStatement(
+        insertRevisionStmt = connection.prepareStatement(
+    public long getReconnectDelayMs() {
+        return reconnectDelayMs;
+    }
+
+
+    public void setReconnectDelayMs(long reconnectDelayMs) {
+        this.reconnectDelayMs = reconnectDelayMs;
+    }

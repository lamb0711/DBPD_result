JCR-1590: JSR 283: Locking

Added a timeout handler to LockManagerImpl. It runs as a scheduled task (at one second intervals) inside a new repository-wide ScheduledExecutorService instance.

Adjusted the TCK test for this and fixed some jcr2spi assumptions about this (the lock can expire from under the SPI layer).

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@805431 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
+     * The periodically invoked lock timeout handler.
+     */
+    private final ScheduledFuture<?> timeoutHandler;
+
+    /**
-     * @param session system session
-     * @param fs      file system for persisting locks
+     * @param session  system session
+     * @param fs       file system for persisting locks
+     * @param executor scheduled executor service for handling lock timeouts
-    public LockManagerImpl(SessionImpl session, FileSystem fs)
-            throws RepositoryException {
+    public LockManagerImpl(
+            SessionImpl session, FileSystem fs,
+            ScheduledExecutorService executor) throws RepositoryException {
+
+        timeoutHandler = executor.scheduleWithFixedDelay(
+                new TimeoutHandler(), 1, 1, TimeUnit.SECONDS);
+        timeoutHandler.cancel(false);
+     * Periodically (at one second delay) invoked timeout handler. Traverses
+     * all locks and unlocks those that have expired.
+     *
+     * @see <a href="https://issues.apache.org/jira/browse/JCR-1590">JCR-1590</a>:
+     *      JSR 283: Locking
+     */
+    private class TimeoutHandler implements Runnable {
+        public void run() {
+            lockMap.traverse(new PathMap.ElementVisitor<LockInfo>() {
+                public void elementVisited(PathMap.Element<LockInfo> element) {
+                    LockInfo info = element.get();
+                    if (info != null && info.isLive() && info.isExpired()) {
+                        NodeId id = info.getId();
+                        SessionImpl holder = info.getLockHolder();
+                        if (holder == null) {
+                            info.setLockHolder(sysSession);
+                            holder = sysSession;
+                        }
+                        try {
+                            // FIXME: This session access is not thread-safe!
+                            unlock(holder.getNodeById(id));
+                        } catch (RepositoryException e) {
+                            log.warn("Unable to expire the lock " + id, e);
+                        }
+                    }
+                }
+            }, false);
+        }
+    }
+
+    /**

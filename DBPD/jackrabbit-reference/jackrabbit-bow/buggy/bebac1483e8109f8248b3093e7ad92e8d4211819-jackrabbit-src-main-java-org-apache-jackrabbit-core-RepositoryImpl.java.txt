JCR-623 Clustering


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@471760 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.config.ClusterConfig;
+import org.apache.jackrabbit.core.observation.EventStateCollection;
+import org.apache.jackrabbit.core.state.ChangeLog;
+import org.apache.jackrabbit.core.cluster.ClusterNode;
+import org.apache.jackrabbit.core.cluster.ClusterException;
+import org.apache.jackrabbit.core.cluster.ClusterContext;
+import org.apache.jackrabbit.core.cluster.LockEventChannel;
+import org.apache.jackrabbit.core.cluster.UpdateEventChannel;
+import org.apache.jackrabbit.core.cluster.UpdateEventListener;
+import org.apache.jackrabbit.name.NamespaceResolver;
+import java.util.List;
+     * Clustered node used, <code>null</code> if clustering is not configured.
+     */
+    private ClusterNode clusterNode;
+
+    /**
+        // initialize optional clustering
+        // put here before setting up any other external event source that a cluster node
+        // will be interested in
+        if (repConfig.getClusterConfig() != null) {
+            clusterNode = createClusterNode();
+        }
+
-        // todo FIXME it seems odd that the *global* virtual node type manager
+        // todo FIXME it  odd that the *global* virtual node type manager
+        // now start cluster node as last step
+        if (clusterNode != null) {
+            try {
+                clusterNode.start();
+            } catch (ClusterException e) {
+                String msg = "Unable to start clustered node, forcing shutdown...";
+                log.error(msg, e);
+                shutdown();
+                throw new RepositoryException(msg, e);
+            }
+        }
+
+
+
-        return new VersionManagerImpl(pm, fs, ntReg, delegatingDispatcher,
+
+        VersionManagerImpl vMgr = new VersionManagerImpl(pm, fs, ntReg, delegatingDispatcher,
+        if (clusterNode != null) {
+            vMgr.setEventChannel(clusterNode.createUpdateChannel());
+        }
+        return vMgr;
+    /**
+     * Creates the cluster node.
+     *
+     * @return clustered node
+     */
+    private ClusterNode createClusterNode() throws RepositoryException {
+        try {
+            ClusterNode clusterNode = new ClusterNode();
+            clusterNode.init(new ExternalEventListener());
+            return clusterNode;
+        } catch (Exception e) {
+            throw new RepositoryException(e);
+        }
+    }
+
+        // stop optional cluster node
+        if (clusterNode != null) {
+            clusterNode.stop();
+        }
+
-    protected class WorkspaceInfo {
+    protected class WorkspaceInfo implements UpdateEventListener {
+         * Update event channel, used in clustered environment.
+         */
+        private UpdateEventChannel updateChannel;
+
+        /**
+         * Lock event channel, used in clustered environment.
+         */
+        private LockEventChannel lockChannel;
+
+        /**
+                    if (clusterNode != null) {
+                        lockChannel = clusterNode.createLockChannel(getName());
+                        lockMgr.setEventChannel(lockChannel);
+                    }
+                    if (clusterNode != null) {
+                        updateChannel = clusterNode.createUpdateChannel(getName());
+                        itemStateMgr.setEventChannel(updateChannel);
+                        updateChannel.setListener(this);
+                    }
+                // inform cluster node about disposal
+                if (updateChannel != null) {
+                    updateChannel.setListener(null);
+                }
+                if (lockChannel != null) {
+                    lockChannel.setListener(null);
+                }
+
+
+        //----------------------------------------------< UpdateEventListener >
+
+        /**
+         * {@inheritDoc}
+         */
+        public void externalUpdate(ChangeLog external, List events) throws RepositoryException {
+            try {
+                EventStateCollection esc = new EventStateCollection(
+                        getObservationDispatcher(), null, null);
+                esc.addAll(events);
+
+                getItemStateProvider().externalUpdate(external, esc);
+            } catch (IllegalStateException e) {
+                String msg = "Unable to deliver events: " + e.getMessage();
+                throw new RepositoryException(msg);
+            }
+        }
+
+    /**
+     * Cluster context passed to a <code>ClusterNode</code>.
+     */
+    class ExternalEventListener implements ClusterContext {
+
+        /**
+         * {@inheritDoc}
+         */
+        public ClusterConfig getClusterConfig() {
+            return getConfig().getClusterConfig();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public NamespaceResolver getNamespaceResovler() {
+            return getNamespaceRegistry();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public void updateEventsReady(String workspace) throws RepositoryException {
+            // toggle the initialization of some workspace
+            getWorkspaceInfo(workspace);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public void lockEventsReady(String workspace) throws RepositoryException {
+            // toggle the initialization of some workspace's lock manager
+            getWorkspaceInfo(workspace).getLockManager();
+        }
+    }

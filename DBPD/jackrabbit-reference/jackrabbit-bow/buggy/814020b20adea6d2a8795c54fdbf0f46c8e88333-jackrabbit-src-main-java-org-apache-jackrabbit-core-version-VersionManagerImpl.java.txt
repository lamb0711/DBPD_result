JCR-455: InternalXAResource.rollback() can be called twice and without prepare
JCR-414: jcr:successors property not persisted correctly within a transaction


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@412995 13f79535-47bb-0310-9956-ffa450edef68

-public class VersionManagerImpl extends AbstractVersionManager
-        /*implements EventStateCollectionFactory*/ {
+public class VersionManagerImpl extends AbstractVersionManager {
-
-        return stateMgr.hasItemState(id);
+        aquireReadLock();
+        try {
+            return stateMgr.hasItemState(id);
+        } finally {
+            releaseReadLock();
+        }
-            InternalVersionItem item = (InternalVersionItem) versionItems.get(id);
-            if (item == null) {
-                if (stateMgr.hasItemState(id)) {
-                    NodeState state = (NodeState) stateMgr.getItemState(id);
-                    NodeStateEx pNode = new NodeStateEx(stateMgr, ntReg, state, null);
-                    NodeId parentId = pNode.getParentId();
-                    InternalVersionItem parent = getItem(parentId);
-                    QName ntName = state.getNodeTypeName();
-                    if (ntName.equals(QName.NT_FROZENNODE)) {
-                        item = new InternalFrozenNodeImpl(this, pNode, parent);
-                    } else if (ntName.equals(QName.NT_VERSIONEDCHILD)) {
-                        item = new InternalFrozenVHImpl(this, pNode, parent);
-                    } else if (ntName.equals(QName.NT_VERSION)) {
-                        item = ((InternalVersionHistory) parent).getVersion(id);
-                    } else if (ntName.equals(QName.NT_VERSIONHISTORY)) {
-                        item = new InternalVersionHistoryImpl(this, pNode);
-                    } else {
-                        return null;
+            synchronized (versionItems) {
+                InternalVersionItem item = (InternalVersionItem) versionItems.get(id);
+                if (item == null) {
+                    if (stateMgr.hasItemState(id)) {
+                        NodeState state = (NodeState) stateMgr.getItemState(id);
+                        NodeStateEx pNode = new NodeStateEx(stateMgr, ntReg, state, null);
+                        NodeId parentId = pNode.getParentId();
+                        InternalVersionItem parent = getItem(parentId);
+                        QName ntName = state.getNodeTypeName();
+                        if (ntName.equals(QName.NT_FROZENNODE)) {
+                            item = new InternalFrozenNodeImpl(this, pNode, parent);
+                        } else if (ntName.equals(QName.NT_VERSIONEDCHILD)) {
+                            item = new InternalFrozenVHImpl(this, pNode, parent);
+                        } else if (ntName.equals(QName.NT_VERSION)) {
+                            item = ((InternalVersionHistory) parent).getVersion(id);
+                        } else if (ntName.equals(QName.NT_VERSIONHISTORY)) {
+                            item = new InternalVersionHistoryImpl(this, pNode);
+                        } else {
+                            return null;
+                        }
+                    versionItems.put(id, item);
-                versionItems.put(id, item);
+                return item;
-            return item;
-     * versions tree were updated. Version manager should flush its own
-     * caches.
+     * versions tree were updated. Version histories are reloaded if possible.
+     * Matching items are removed from the cache.
+     *
-        Iterator iter = items.iterator();
-        while (iter.hasNext()) {
-            itemUpdated((InternalVersionItem) iter.next());
-        }
-    }
-
-    /**
-     * Update internal version item. Version histories are reloaded if possible.
-     * Matching items are removed from the cache.
-     * @param item item updated
-     */
-    private void itemUpdated(InternalVersionItem item) {
+        aquireReadLock();
-            aquireReadLock();
-            InternalVersionItem cached = (InternalVersionItem) versionItems.remove(item.getId());
-            if (cached != null) {
-                if (cached instanceof InternalVersionHistoryImpl) {
-                    InternalVersionHistoryImpl vh = (InternalVersionHistoryImpl) cached;
-                    try {
-                        vh.reload();
-                        versionItems.put(vh.getId(), vh);
-                    } catch (RepositoryException e) {
-                        log.warn("Unable to update version history: " + e.toString());
+            synchronized (versionItems) {
+                Iterator iter = items.iterator();
+                while (iter.hasNext()) {
+                    InternalVersionItem item = (InternalVersionItem) iter.next();
+                    InternalVersionItem cached = (InternalVersionItem) versionItems.remove(item.getId());
+                    if (cached != null) {
+                        if (cached instanceof InternalVersionHistoryImpl) {
+                            InternalVersionHistoryImpl vh = (InternalVersionHistoryImpl) cached;
+                            try {
+                                vh.reload();
+                                versionItems.put(vh.getId(), vh);
+                            } catch (RepositoryException e) {
+                                log.warn("Unable to update version history: " + e.toString());
+                            }
+                        }
+        aquireWriteLock();
+        } finally {
+            releaseWriteLock();
+        aquireReadLock();
+        } finally {
+            releaseReadLock();

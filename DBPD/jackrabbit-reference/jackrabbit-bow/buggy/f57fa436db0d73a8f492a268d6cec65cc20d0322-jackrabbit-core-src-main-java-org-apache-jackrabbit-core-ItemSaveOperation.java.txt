JCR-890: concurrent read-only access to a session

Make SessionContext an argument of SessionOperation.perform(). The ultimate goal is to be able to have the SessionOperation classes be the only place where the SessionContext can be accessed.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@962485 13f79535-47bb-0310-9956-ffa450edef68

-class ItemSaveOperation extends SessionOperation {
+class ItemSaveOperation implements SessionOperation {
-    public ItemSaveOperation(SessionContext context, ItemState state) {
-        super("item save", context);
+    public ItemSaveOperation(ItemState state) {
-    @Override
-    public void perform() throws RepositoryException {
+    public void perform(SessionContext context) throws RepositoryException {
-            dirty = getTransientStates();
+            dirty = getTransientStates(context.getItemStateManager());
-        Collection<ItemState> removed = getRemovedStates();
+        Collection<ItemState> removed =
+            getRemovedStates(context.getItemStateManager());
-        validateTransientItems(dirty, removed);
+        validateTransientItems(context, dirty, removed);
-            removeTransientItems(removed);
+            removeTransientItems(context.getItemStateManager(), removed);
-            processShareableNodes(dirty);
+            processShareableNodes(
+                    context.getRepositoryContext().getNodeTypeRegistry(),
+                    dirty);
-            if (initVersionHistories(dirty)) {
+            if (initVersionHistories(context, dirty)) {
-                dirty = getTransientStates();
+                dirty = getTransientStates(context.getItemStateManager());
-            persistTransientItems(dirty);
+            persistTransientItems(context.getItemManager(), dirty);
-                restoreTransientItems(dirty);
+                restoreTransientItems(context, dirty);
-    private Collection<ItemState> getTransientStates()
+    private Collection<ItemState> getTransientStates(
+            SessionItemStateManager sism)
-                    : context.getItemStateManager().getDescendantTransientItemStates(state.getId())) {
+                    : sism.getDescendantTransientItemStates(state.getId())) {
-    private Collection<ItemState> getRemovedStates()
+    private Collection<ItemState> getRemovedStates(
+            SessionItemStateManager sism)
-                    : context.getItemStateManager().getDescendantTransientItemStatesInAttic(state.getId())) {
+                    : sism.getDescendantTransientItemStatesInAttic(state.getId())) {
+            SessionContext context,
-                EffectiveNodeType ent = getEffectiveNodeType(nodeState);
+                EffectiveNodeType ent = getEffectiveNodeType(
+                        context.getRepositoryContext().getNodeTypeRegistry(),
+                        nodeState);
-    private void removeTransientItems(Iterable<ItemState> states) {
+    private void removeTransientItems(
+            SessionItemStateManager sism, Iterable<ItemState> states) {
-            context.getItemStateManager().destroy(persistentState);
+            sism.destroy(persistentState);
-    private void processShareableNodes(Iterable<ItemState> states)
+    private void processShareableNodes(
+            NodeTypeRegistry registry, Iterable<ItemState> states)
-                    EffectiveNodeType ntOld = getEffectiveNodeType(old);
+                    EffectiveNodeType ntOld = getEffectiveNodeType(registry, old);
-                EffectiveNodeType ntNew = getEffectiveNodeType(ns);
+                EffectiveNodeType ntNew = getEffectiveNodeType(registry, ns);
-    private boolean initVersionHistories(Iterable<ItemState> states)
+    private boolean initVersionHistories(
+            SessionContext context, Iterable<ItemState> states)
-                EffectiveNodeType nt = getEffectiveNodeType(nodeState);
+                EffectiveNodeType nt = getEffectiveNodeType(
+                        context.getRepositoryContext().getNodeTypeRegistry(),
+                        nodeState);
-    private void persistTransientItems(Iterable<ItemState> states)
+    private void persistTransientItems(
+            ItemManager itemMgr, Iterable<ItemState> states)
-        ItemManager itemMgr = context.getItemManager();
-    private void restoreTransientItems(Iterable<ItemState> items) {
+    private void restoreTransientItems(
+            SessionContext context, Iterable<ItemState> items) {
-    private EffectiveNodeType getEffectiveNodeType(NodeState state)
+    private EffectiveNodeType getEffectiveNodeType(
+            NodeTypeRegistry registry, NodeState state)
-            NodeTypeRegistry registry =
-                context.getRepositoryContext().getNodeTypeRegistry();

optimized performance of Item.save() 

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@208759 13f79535-47bb-0310-9956-ffa450edef68

-        // collection of descendant transient states:
+/*
+        // build ordered collection of descendant transient states:
-         */
+         * /
-                     */
+                     * /
+*/
+        // build ordered collection of descendant transient states
+        // sorted by decreasing relative depth
+
+        // use an array of lists to group the descendants by relative depth;
+        // the depth is used as array index
+        List[] la = new List[10];
+        try {
+            Iterator iter = transientStateMgr.getEntries();
+            while (iter.hasNext()) {
+                ItemState state = (ItemState) iter.next();
+                // determine relative depth: > 0 means it's a descendant
+                int depth;
+                try {
+                    depth = hierMgr.getRelativeDepth(parentId, state.getId());
+                } catch (ItemNotFoundException infe) {
+                    /**
+                     * one of the parents of the specified item has been
+                     * removed externally; as we don't know its path,
+                     * we can't determine if it is a descendant;
+                     * InvalidItemStateException should only be thrown if
+                     * a descendant is affected;
+                     * => throw InvalidItemStateException for now
+                     * todo FIXME
+                     */
+                    // unable to determine relative depth, assume that the item
+                    // (or any of its ancestors) has been removed externally
+                    String msg = state.getId()
+                            + ": the item seems to have been removed externally.";
+                    log.debug(msg);
+                    throw new InvalidItemStateException(msg);
+                }
+
+                if (depth < 1) {
+                    // not a descendant
+                    continue;
+                }
+
+                // ensure capacity
+                if (depth > la.length) {
+                    List old[] = la;
+                    la = new List[depth + 10];
+                    System.arraycopy(old, 0, la, 0, old.length);
+                }
+
+                List list = la[depth - 1];
+                if (list == null) {
+                    list = new ArrayList();
+                    la[depth - 1] = list;
+                }
+                list.add(state);
+            }
+        } catch (RepositoryException re) {
+            log.warn("inconsistent hierarchy state", re);
+        }
+        // create an iterator over the collected descendants
+        // in decreasing depth order
+        IteratorChain resultIter = new IteratorChain();
+        for (int i = la.length - 1; i >= 0; i--) {
+            List list = la[i];
+            if (list != null) {
+                resultIter.addIterator(list.iterator());
+            }
+        }
+        return resultIter;
-

JCR-2700 : Allow for wildcard restriction in resource-based ACEs

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@983906 13f79535-47bb-0310-9956-ffa450edef68

+import javax.jcr.NamespaceException;
-import org.apache.jackrabbit.core.security.authorization.AccessControlConstants;
+import org.apache.jackrabbit.core.security.authorization.GlobPattern;
+import org.apache.jackrabbit.spi.commons.conversion.NamePathResolver;
+import org.apache.jackrabbit.spi.commons.conversion.NameResolver;
-     * List containing the entries of this ACL Template with maximal one
-     * grant and one deny ACE per principal.
+     * List containing the entries of this ACL Template.
+     * The name resolver
+     */
+    private final NameResolver resolver;
+
+    /**
+     *
+     */
+    private final String jcrRepGlob;
+
+    /**
+     * @param resolver
+     * @throws javax.jcr.NamespaceException
-                PrivilegeRegistry privilegeRegistry, ValueFactory valueFactory) {
+                PrivilegeRegistry privilegeRegistry, ValueFactory valueFactory,
+                NamePathResolver resolver) throws NamespaceException {
+        this.resolver = resolver;
+
+        jcrRepGlob = resolver.getJCRName(P_GLOB);
-        if (aclNode == null || !AccessControlConstants.NT_REP_ACL.equals(((NodeTypeImpl)aclNode.getPrimaryNodeType()).getQName())) {
+        if (aclNode == null || !NT_REP_ACL.equals(((NodeTypeImpl)aclNode.getPrimaryNodeType()).getQName())) {
+        this.resolver = sImpl;
+        jcrRepGlob = sImpl.getJCRName(P_GLOB);
-                String principalName = aceNode.getProperty(AccessControlConstants.P_PRINCIPAL_NAME).getString();
+                String principalName = aceNode.getProperty(P_PRINCIPAL_NAME).getString();
-                Value[] privValues = aceNode.getProperty(AccessControlConstants.P_PRIVILEGES).getValues();
+                Value[] privValues = aceNode.getProperty(P_PRIVILEGES).getValues();
+
+                Map<String,Value> restrictions = null;
+                if (aceNode.hasProperty(P_GLOB)) {
+                    restrictions = Collections.singletonMap(jcrRepGlob, aceNode.getProperty(P_GLOB).getValue());
+                }
-                        AccessControlConstants.NT_REP_GRANT_ACE.equals(((NodeTypeImpl) aceNode.getPrimaryNodeType()).getQName()));
+                        NT_REP_GRANT_ACE.equals(((NodeTypeImpl) aceNode.getPrimaryNodeType()).getQName()),
+                        restrictions);
-     * @return
+     * @param restrictions
+     * @return A new entry
-    Entry createEntry(Principal principal, Privilege[] privileges, boolean isAllow) throws AccessControlException {
-        return new Entry(principal, privileges, isAllow);
+    Entry createEntry(Principal principal, Privilege[] privileges, boolean isAllow, Map<String,Value> restrictions) throws RepositoryException {
+        return new Entry(principal, privileges, isAllow, restrictions);
+    }
+
+    Entry createEntry(Entry base, Privilege[] newPrivileges, boolean isAllow) throws RepositoryException {
+        return new Entry(base, newPrivileges, isAllow);
-    private synchronized boolean internalAdd(Entry entry) throws AccessControlException {
+    private synchronized boolean internalAdd(Entry entry) throws RepositoryException {
-                if (entry.isAllow() == e.isAllow()) {
-                    int existingPrivs = e.getPrivilegeBits();
-                    if ((existingPrivs | ~entry.getPrivilegeBits()) == -1) {
-                        // all privileges to be granted/denied are already present
-                        // in the existing entry -> not modified
-                        return false;
+                if (equalRestriction(entry, e)) {
+                    if (entry.isAllow() == e.isAllow()) {
+                        // need to update an existing entry
+                        int existingPrivs = e.getPrivilegeBits();
+                        if ((existingPrivs | ~entry.getPrivilegeBits()) == -1) {
+                            // all privileges to be granted/denied are already present
+                            // in the existing entry -> not modified
+                            return false;
+                        }
+
+                        // remember the index of the existing entry to be updated later on.
+                        updateIndex = entries.indexOf(e);
+
+                        // remove the existing entry and create a new that includes
+                        // both the new privileges and the existing ones.
+                        entries.remove(e);
+                        int mergedBits = e.getPrivilegeBits() | entry.getPrivilegeBits();
+                        Privilege[] mergedPrivs = privilegeRegistry.getPrivileges(mergedBits);
+                        // omit validation check.
+                        entry = createEntry(entry, mergedPrivs, entry.isAllow());
+                    } else {
+                        complementEntry = e;
-
-                    // remember the index of the existing entry to be updated later on.
-                    updateIndex = entries.indexOf(e);
-
-                    // remove the existing entry and create a new that includes
-                    // both the new privileges and the existing ones.
-                    entries.remove(e);
-                    int mergedBits = e.getPrivilegeBits() | entry.getPrivilegeBits();
-                    Privilege[] mergedPrivs = privilegeRegistry.getPrivileges(mergedBits);
-                    // omit validation check.
-                    entry = createEntry(entry.getPrincipal(), mergedPrivs, entry.isAllow());
-                } else {
-                    complementEntry = e;
-                    Entry tmpl = createEntry(entry.getPrincipal(),
+                    Entry tmpl = createEntry(entry,
+    private boolean equalRestriction(Entry entry1, Entry entry2) throws RepositoryException {
+        Value v1 = entry1.getRestriction(jcrRepGlob);
+        Value v2 = entry2.getRestriction(jcrRepGlob);
+
+        return (v1 == null) ? v2 == null : v1.equals(v2);
+    }
+
-        if (restrictions != null && !restrictions.isEmpty()) {
-            throw new AccessControlException("This AccessControlList does not allow for additional restrictions.");
-        }
-     * Returns an empty String array.
-     *
-     * @see org.apache.jackrabbit.api.security.JackrabbitAccessControlList#getRestrictionType(String)
+     * @see JackrabbitAccessControlList#getRestrictionNames()
-        return new String[0];
+        return new String[] {jcrRepGlob};
-     * Always returns {@link PropertyType#UNDEFINED} as no restrictions are
-     * supported.
-     *
-        return PropertyType.UNDEFINED;
+        if (jcrRepGlob.equals(restrictionName) || P_GLOB.toString().equals(restrictionName)) {
+            return PropertyType.STRING;
+        } else {
+            return PropertyType.UNDEFINED;
+        }
+     * The only known restriction is:
+     * <pre>
+     *   rep:glob (optional)  value-type: STRING
+     * </pre>
+     *
-        Entry ace = createEntry(principal, privileges, isAllow);
+        Entry ace = createEntry(principal, privileges, isAllow, restrictions);
-        private Entry(Principal principal, Privilege[] privileges, boolean allow)
-                throws AccessControlException {
-            super(principal, privileges, allow, Collections.<String, Value>emptyMap(), valueFactory);
+        private final GlobPattern pattern;
+
+        private Entry(Principal principal, Privilege[] privileges, boolean allow, Map<String,Value> restrictions)
+                throws RepositoryException {
+            super(principal, privileges, allow, restrictions);
+            Value glob = getRestrictions().get(P_GLOB);
+            if (glob != null) {
+                pattern = GlobPattern.create(path, glob.getString());
+            } else {
+                pattern = GlobPattern.create(path);
+            }
+        private Entry(Entry base, Privilege[] newPrivileges, boolean isAllow) throws RepositoryException {
+            super(base, newPrivileges, isAllow);
+            Value glob = getRestrictions().get(P_GLOB);
+            if (glob != null) {
+                pattern = GlobPattern.create(path, glob.getString());
+            } else {
+                pattern = GlobPattern.create(path);
+            }
+        }
+        
+
+        /**
+         * 
+         * @param jcrPath
+         * @return
+         */
+        boolean matches(String jcrPath) {
+            return pattern.matches(jcrPath);
+        }
+
+        @Override
+        protected NameResolver getResolver() {
+            return resolver;
+        }
+
+        @Override
+        protected ValueFactory getValueFactory() {
+            return valueFactory;
+        }

work in progress

- ChangeLog: add target (item to be saved)
- TransientItemStateManager: changing itemstate from new to existing => needs to connect to overlayed state
- TransientISFactory move out of TransientISM
- RepositoryServiceImpl: simplify execution of wsp-operations
- Initial draft for observation
- WorkspaceManager: seperate notification of events resulting from transient modifications.
- WorkspaceManager: don't report events from wsp-operations as external mods.
- IteratorHelper; add EMPTY constant
- Event: add constant for ALL events

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@451313 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.httpclient.UsernamePasswordCredentials;
-import org.apache.commons.httpclient.HttpState;
+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;
-import org.apache.commons.collections.map.LRUMap;
+import org.apache.jackrabbit.webdav.client.methods.SubscribeMethod;
+import org.apache.jackrabbit.webdav.client.methods.UnSubscribeMethod;
+import org.apache.jackrabbit.webdav.client.methods.PollMethod;
+import org.apache.jackrabbit.webdav.DavMethods;
+import org.apache.jackrabbit.webdav.observation.EventDiscovery;
-import org.apache.jackrabbit.util.Text;
-import org.apache.jackrabbit.name.NamespaceResolver;
+import org.apache.jackrabbit.util.Text;
-import javax.jcr.SimpleCredentials;
+import java.util.HashMap;
-// TODO: improve handling of HttpClient
+
+    private static final EventType[] ALL_EVENTS = new EventType[5];
+    static {
+        ALL_EVENTS[0] = SubscriptionImpl.getEventType(javax.jcr.observation.Event.NODE_ADDED);
+        ALL_EVENTS[1] = SubscriptionImpl.getEventType(javax.jcr.observation.Event.NODE_REMOVED);
+        ALL_EVENTS[2] = SubscriptionImpl.getEventType(javax.jcr.observation.Event.PROPERTY_ADDED);
+        ALL_EVENTS[3] = SubscriptionImpl.getEventType(javax.jcr.observation.Event.PROPERTY_CHANGED);
+        ALL_EVENTS[4] = SubscriptionImpl.getEventType(javax.jcr.observation.Event.PROPERTY_REMOVED);
+    }
+    private static final SubscriptionInfo S_INFO = new SubscriptionInfo(ALL_EVENTS, true, DavConstants.INFINITE_TIMEOUT);
+
+    private static long POLL_INTERVAL = 30000;  // TODO: make configurable
+
-    private final HostConfiguration hostConfig;
-    // remember most frequently used http clients
-    private final Map clientCache = Collections.synchronizedMap(new LRUMap());
+    private final HttpClient client;
+            domFactory = DomUtil.BUILDER_FACTORY.newDocumentBuilder().newDocument();
+        } catch (ParserConfigurationException e) {
+            throw new RepositoryException(e);
+        }
+
+        try {
-            hostConfig = new HostConfiguration();
+            HostConfiguration hostConfig = new HostConfiguration();
-            domFactory = DomUtil.BUILDER_FACTORY.newDocumentBuilder().newDocument();
+            client = new HttpClient(new MultiThreadedHttpConnectionManager());
+            client.setHostConfiguration(hostConfig);
+            // always send authentication not waiting for 401
+            client.getParams().setAuthenticationPreemptive(true);
-        } catch (ParserConfigurationException e) {
-            throw new RepositoryException(e);
-    private HttpClient getClient(Credentials credentials) {
-        if (clientCache.containsKey(credentials)) {
-            return (HttpClient) clientCache.get(credentials);
-        } else {
-            HttpClient client = new HttpClient();
-            client.setHostConfiguration(hostConfig);
-            UsernamePasswordCredentials creds;
-            if (credentials == null) {
-                // NOTE: null credentials only work if 'missing-auth-mapping' param is set on the server
-                creds = null;
-            } else if (credentials instanceof SimpleCredentials) {
-                SimpleCredentials sCred = (SimpleCredentials) credentials;
-                creds = new UsernamePasswordCredentials(sCred.getUserID(),
-                    String.valueOf(sCred.getPassword()));
-            } else {
-                creds = new UsernamePasswordCredentials(credentials.toString());
-            }
-            HttpState httpState = client.getState();
-
-            // set authentication scope and credentials
-            AuthScope authscope = new AuthScope(hostConfig.getHost(), hostConfig.getPort());
-            httpState.setCredentials(authscope, creds);
-
-            // always send authentication not waiting for 401
-            client.getParams().setAuthenticationPreemptive(true);
-
-            clientCache.put(credentials, client);
-            return client;
+    private static void checkSessionInfo(SessionInfo sessionInfo) throws RepositoryException {
+        if (!(sessionInfo instanceof SessionInfoImpl)) {
+            throw new RepositoryException("Unknown SessionInfo implementation.");
-    HttpClient getClient(SessionInfo sessionInfo) {
-        Credentials credentials = null;
-        if (sessionInfo instanceof SessionInfoImpl) {
-            credentials = ((SessionInfoImpl) sessionInfo).getCredentials();
-        } else {
-            log.warn("Unexpected SessionInfo implementation. Using 'null' credentials for connection.");
-        }
-        return getClient(credentials);
+    private static boolean isLockMethod(DavMethod method) {
+        int code = DavMethods.getMethodCode(method.getName());
+        return DavMethods.DAV_LOCK == code || DavMethods.DAV_UNLOCK == code;
-        if (sessionInfo instanceof SessionInfoImpl) {
-            String txId = ((SessionInfoImpl) sessionInfo).getBatchId();
-            if (txId != null) {
-                CodedUrlHeader ch = new CodedUrlHeader(TransactionConstants.HEADER_TRANSACTIONID, txId);
-                method.setRequestHeader(ch.getHeaderName(), ch.getHeaderValue());
-            }
-        }
-    private URIResolver getURIResolver() {
-        return uriResolver;
+    private HttpClient getClient(org.apache.commons.httpclient.Credentials credentials) {
+        // NOTE: null credentials only work if 'missing-auth-mapping' param is
+        // set on the server
+        client.getState().setCredentials(AuthScope.ANY, credentials);
+        return client;
-    private NamespaceResolver getNamespaceResolver() {
-        return nsResolver;
-    }
-
-    private String getRepositoryUri() {
-        return uriResolver.getRepositoryUri();
-    }
-
-    private String getWorkspaceUri(String workspaceName) {
-        return uriResolver.getWorkspaceUri(workspaceName);
-    }
-
-    private String getRootItemUri(String workspaceName) {
-        return uriResolver.getRootItemUri(workspaceName);
+    HttpClient getClient(SessionInfo sessionInfo) throws RepositoryException {
+        checkSessionInfo(sessionInfo);
+        return getClient(((SessionInfoImpl) sessionInfo).getCredentials().getCredentials());
-    private String getItemUri(ItemId itemId, String workspaceName, SessionInfo sessionInfo) throws RepositoryException {
-        return uriResolver.getItemUri(itemId, workspaceName, sessionInfo);
-    }
-
-            return parentUri + NameFormat.format(childName, getNamespaceResolver());
+            return parentUri + NameFormat.format(childName, nsResolver);
-                parentId = getURIResolver().getNodeId(parentHref, sessionInfo);
+                parentId = uriResolver.getNodeId(parentHref, sessionInfo);
-    private EventIterator retrieveEvents() {
-        // todo
-        return null;
+    /**
+     * Execute a 'Workspace' operation that immediately needs to return events.
+     *
+     * @param method
+     * @param sessionInfo
+     * @return
+     * @throws RepositoryException
+     */
+    private EventIterator execute(DavMethod method, SessionInfo sessionInfo) throws RepositoryException {
+        // TODO: build specific subscrUri
+        // TODO: check if 'all event' subscription is ok
+        String subscrUri = uriResolver.getRootItemUri(sessionInfo.getWorkspaceName());
+        String subscrId = subscribe(subscrUri, S_INFO, null, sessionInfo);
+        try {
+            if (isLockMethod(method)) {
+                initMethod(method, sessionInfo, false);
+            } else {
+                initMethod(method, sessionInfo, true);
+            }
+            getClient(sessionInfo).executeMethod(method);
+            method.checkSuccess();
+
+            EventIterator events = poll(subscrUri, subscrId, sessionInfo);
+            return events;
+        } catch (IOException e) {
+            throw new RepositoryException(e);
+        } catch (DavException e) {
+            throw ExceptionConverter.generate(e);
+        } finally {
+            if (method != null) {
+                method.releaseConnection();
+            }
+            unsubscribe(subscrUri, subscrId, sessionInfo);
+        }
-            method = new ReportMethod(getRepositoryUri(), info);
+            method = new ReportMethod(uriResolver.getRepositoryUri(), info);
-            getClient((Credentials) null).executeMethod(method);
+            getClient((org.apache.commons.httpclient.Credentials) null).executeMethod(method);
-        if (credentials == null) {
-            // no credentials provided, use JAAS
-            throw new RepositoryException("JAAS authentication not implemented");
-        }
-
-        // interested in workspace href property only, which allows to retrieve the
-        // name of the workspace in case 'workspaceName' is 'null'.
-        DavPropertyNameSet nameSet = new DavPropertyNameSet();
-        nameSet.add(DeltaVConstants.WORKSPACE);
+        // check if the workspace with the given name is accessible
-            method = new PropFindMethod(getWorkspaceUri(workspaceName), nameSet, DavConstants.DEPTH_0);
-            getClient(credentials).executeMethod(method);
+            DavPropertyNameSet nameSet = new DavPropertyNameSet();
+            nameSet.add(DeltaVConstants.WORKSPACE);
+            method = new PropFindMethod(uriResolver.getWorkspaceUri(workspaceName), nameSet, DavConstants.DEPTH_0);
+            CredentialsWrapper dc = new CredentialsWrapper(credentials);
+            getClient(dc.getCredentials()).executeMethod(method);
+
-                throw new RepositoryException("Unable to retrieve default workspace name.");
+                throw new LoginException("Login failed: Unknown workspace '" + workspaceName+ " '.");
+
-                String wspName = Text.getName(wspHref, true);
-                return new SessionInfoImpl(credentials, wspName);
+                String wspName = Text.unescape(Text.getName(wspHref, true));
+                if (!wspName.equals(workspaceName)) {
+                    throw new LoginException("Login failed: Invalid workspace name " + workspaceName);
+                }
+                return new SessionInfoImpl(dc, workspaceName, new SubscriptionMgrImpl());
-                throw new RepositoryException("Unable to retrieve default workspace name.");
+                throw new LoginException("Login failed: Unknown workspace '" + workspaceName+ " '.");
-            method = new PropFindMethod(getRepositoryUri(), nameSet, DEPTH_1);
+            method = new PropFindMethod(uriResolver.getRepositoryUri(), nameSet, DEPTH_1);
-            method = new ReportMethod(getWorkspaceUri(sessionInfo.getWorkspaceName()), reportInfo);
+            method = new ReportMethod(uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName()), reportInfo);
-        String rootUri = getRootItemUri(sessionInfo.getWorkspaceName());
-        return getURIResolver().getNodeId(rootUri, sessionInfo);
+        String rootUri = uriResolver.getRootItemUri(sessionInfo.getWorkspaceName());
+        return uriResolver.getNodeId(rootUri, sessionInfo);
-                throw new ItemNotFoundException("Unable to retrieve the item with id " + itemId);
+                throw new ItemNotFoundException("Unable to retrieve the item definition for " + itemId);
-            // todo: make sure the server only sent a single response...
-            // todo: make sure the resourcetype matches the itemId type
-            QItemDefinition definition = null;
+            if (responses.length > 1) {
+                throw new RepositoryException("Internal error: ambigous item definition found '" + itemId + "'.");
+            }
+
+            // check if definition matches the type of the id
+            DavProperty rType = propertySet.get(DavPropertyName.RESOURCETYPE);
+            if (rType.getValue() == null && itemId.denotesNode()) {
+                throw new RepositoryException("Internal error: requested node definition and got property definition.");
+            }
+
+            // build the definition
+            QItemDefinition definition = null;
-                        definition = new QNodeDefinitionImpl(null, idfElem, getNamespaceResolver());
+                        definition = new QNodeDefinitionImpl(null, idfElem, nsResolver);
-                        definition = new QPropertyDefinitionImpl(null, idfElem, getNamespaceResolver());
+                        definition = new QPropertyDefinitionImpl(null, idfElem, nsResolver);
-            NodeInfoImpl nInfo = new NodeInfoImpl(id, parentId, propSet, getNamespaceResolver());
+            NodeInfoImpl nInfo = new NodeInfoImpl(id, parentId, propSet, nsResolver);
-                    PropertyId propertyId = getURIResolver().getPropertyId(propertyHref, sessionInfo);
+                    PropertyId propertyId = uriResolver.getPropertyId(propertyHref, sessionInfo);
-                //method.releaseConnection();
+                method.releaseConnection();
-            PropertyInfo pInfo = new PropertyInfoImpl(id, parentId, propSet, getNamespaceResolver(), valueFactory);
+            PropertyInfo pInfo = new PropertyInfoImpl(id, parentId, propSet, nsResolver, valueFactory);
-     * @see RepositoryService#createBatch(SessionInfo)
+     * @see RepositoryService#createBatch(ItemId, SessionInfo)
-    public Batch createBatch(SessionInfo sessionInfo) throws RepositoryException {
-        if (sessionInfo instanceof SessionInfoImpl) {
-            return new BatchImpl((SessionInfoImpl)sessionInfo);
-        } else {
-            throw new RepositoryException("Unknown SessionInfo implementation.");
-        }
+    public Batch createBatch(ItemId itemId, SessionInfo sessionInfo) throws RepositoryException {
+        return new BatchImpl(itemId, sessionInfo);
-            // TODO build empty eventIterator
-            return null;
+            return IteratorHelper.EMPTY;
+            EventIterator events;
+                    // add batchId as separate header
+                    CodedUrlHeader ch = new CodedUrlHeader(TransactionConstants.HEADER_TRANSACTIONID, batchImpl.batchId);
+                    method.setRequestHeader(ch.getHeaderName(), ch.getHeaderValue());
-                    if (!(success = method.succeeded())) {
-                        throw method.getResponseException();
-                    }
+                    method.checkSuccess();
+                success = true;
-                batchImpl.end(client, success);
+                events = batchImpl.end(client, success);
-            return retrieveEvents();
+            return events;
-        MkColMethod method = null;
-        try {
-            // TODO: improve. currently random name is built instead of retrieving name of new resource from top-level xml element within stream
-            QName nodeName = new QName(QName.NS_DEFAULT_URI, UUID.randomUUID().toString());
-            String uri = getItemUri(parentId, nodeName, sessionInfo);
-            method = new MkColMethod(uri);
-            initMethod(method, sessionInfo, true);
-            method.setRequestEntity(new InputStreamRequestEntity(xmlStream, "text/xml"));
+        // TODO: improve. currently random name is built instead of retrieving name of new resource from top-level xml element within stream
+        QName nodeName = new QName(QName.NS_DEFAULT_URI, UUID.randomUUID().toString());
+        String uri = getItemUri(parentId, nodeName, sessionInfo);
+        MkColMethod method = new MkColMethod(uri);
+        method.setRequestEntity(new InputStreamRequestEntity(xmlStream, "text/xml"));
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
-
-            return retrieveEvents();
-        } catch (IOException e) {
-            throw new RepositoryException(e);
-        } catch (DavException e) {
-            throw ExceptionConverter.generate(e);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        }
+        return execute(method, sessionInfo);
-        MoveMethod method = null;
-        try {
-            String uri = getItemUri(srcNodeId, sessionInfo);
-            String destUri = getItemUri(destParentNodeId, destName, sessionInfo);
-            method = new MoveMethod(uri, destUri, true);
-            initMethod(method, sessionInfo, true);
-
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
-
-            return retrieveEvents();
-        } catch (IOException e) {
-            throw new RepositoryException(e);
-        } catch (DavException e) {
-            throw ExceptionConverter.generate(e);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        }
+        String uri = getItemUri(srcNodeId, sessionInfo);
+        String destUri = getItemUri(destParentNodeId, destName, sessionInfo);
+        MoveMethod method = new MoveMethod(uri, destUri, true);
+        return execute(method, sessionInfo);
-        CopyMethod method = null;
-        try {
-            String uri = getItemUri(srcNodeId, srcWorkspaceName, sessionInfo);
-            String destUri = getItemUri(destParentNodeId, destName, sessionInfo);
-            method = new CopyMethod(uri, destUri, true, false);
-            initMethod(method, sessionInfo, true);
-
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
-
-            return retrieveEvents();
-        } catch (IOException e) {
-            throw new RepositoryException(e);
-        } catch (DavException e) {
-            throw ExceptionConverter.generate(e);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        }
+        String uri = uriResolver.getItemUri(srcNodeId, srcWorkspaceName, sessionInfo);
+        String destUri = getItemUri(destParentNodeId, destName, sessionInfo);
+        CopyMethod method = new CopyMethod(uri, destUri, true, false);
+        return execute(method, sessionInfo);
-        String workspUri = getWorkspaceUri(srcWorkspaceName);
+        String workspUri = uriResolver.getWorkspaceUri(srcWorkspaceName);
-        return null;
+        throw new UnsupportedOperationException("Missing implementation");
-        LockMethod method = null;
-            method = new LockMethod(uri, Scope.EXCLUSIVE, Type.WRITE, null, DavConstants.INFINITE_TIMEOUT, true);
-            initMethod(method, sessionInfo, false);
-
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
+            LockMethod method = new LockMethod(uri, Scope.EXCLUSIVE, Type.WRITE, null, DavConstants.INFINITE_TIMEOUT, true);
+            EventIterator events = execute(method, sessionInfo);
+            return events;
-            return retrieveEvents();
-        } catch (DavException e) {
-            throw ExceptionConverter.generate(e);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        LockMethod method = null;
-        try {
-            String uri = getItemUri(nodeId, sessionInfo);
-            // since sessionInfo does not allow to retrieve token by NodeId,
-            // pass all available lock tokens to the LOCK method (TODO: correct?)
-            method = new LockMethod(uri, DavConstants.INFINITE_TIMEOUT, sessionInfo.getLockTokens());
-            initMethod(method, sessionInfo, false);
-
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
-
-            return retrieveEvents();
-        } catch (IOException e) {
-            throw new RepositoryException(e);
-        } catch (DavException e) {
-            throw ExceptionConverter.generate(e);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        }
+        String uri = getItemUri(nodeId, sessionInfo);
+        // since sessionInfo does not allow to retrieve token by NodeId,
+        // pass all available lock tokens to the LOCK method (TODO: correct?)
+        LockMethod method = new LockMethod(uri, DavConstants.INFINITE_TIMEOUT, sessionInfo.getLockTokens());
+        return execute(method, sessionInfo);
-        UnLockMethod method = null;
-        try {
-            String uri = getItemUri(nodeId, sessionInfo);
-            // Note: since sessionInfo does not allow to identify the id of the
-            // lock holding node, we need to access the token via lockInfo
-            // TODO: review this.
-            LockInfo lInfo = getLockInfo(sessionInfo, nodeId);
-            String lockToken = lInfo.getLockToken();
+        String uri = getItemUri(nodeId, sessionInfo);
+        // Note: since sessionInfo does not allow to identify the id of the
+        // lock holding node, we need to access the token via lockInfo
+        // TODO: review this.
+        LockInfo lInfo = getLockInfo(sessionInfo, nodeId);
+        String lockToken = lInfo.getLockToken();
-            // TODO: ev. additional check if lt is present on the sessionInfo?
+        // TODO: ev. additional check if lt is present on the sessionInfo?
-            method = new UnLockMethod(uri, lockToken);
-            initMethod(method, sessionInfo, false);
+        UnLockMethod method = new UnLockMethod(uri, lockToken);
+        EventIterator events = execute(method, sessionInfo);
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
-
-            sessionInfo.removeLockToken(lockToken);
-
-            return retrieveEvents();
-        } catch (IOException e) {
-            throw new RepositoryException(e);
-        } catch (DavException e) {
-            throw ExceptionConverter.generate(e);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        }
+        sessionInfo.removeLockToken(lockToken);
+        return events;
-        CheckinMethod method = null;
-        try {
-            String uri = getItemUri(nodeId, sessionInfo);
-            method = new CheckinMethod(uri);
-            initMethod(method, sessionInfo, true);
+        String uri = getItemUri(nodeId, sessionInfo);
+        CheckinMethod method = new CheckinMethod(uri);
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
-
-            return retrieveEvents();
-        } catch (IOException e) {
-            throw new RepositoryException(e);
-        } catch (DavException e) {
-            throw ExceptionConverter.generate(e);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        }
+        return execute(method, sessionInfo);
-        CheckoutMethod method = null;
-        try {
-            String uri = getItemUri(nodeId, sessionInfo);
-            method = new CheckoutMethod(uri);
-            initMethod(method, sessionInfo, true);
+        String uri = getItemUri(nodeId, sessionInfo);
+        CheckoutMethod method = new CheckoutMethod(uri);
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
-
-            return retrieveEvents();
-        } catch (IOException e) {
-            throw new RepositoryException(e);
-        } catch (DavException e) {
-            throw ExceptionConverter.generate(e);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        }
+        return execute(method, sessionInfo);
-        String uri = getWorkspaceUri(sessionInfo.getWorkspaceName());
+        String uri = uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName());
-        UpdateMethod method = null;
-            method = new UpdateMethod(uri, uInfo);
-            initMethod(method, sessionInfo, true);
-
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
-
-            return retrieveEvents();
+            UpdateMethod method = new UpdateMethod(uri, uInfo);
+            return execute(method, sessionInfo);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        MergeMethod method = null;
-            String wspHref = getWorkspaceUri(srcWorkspaceName);
+            String wspHref = uriResolver.getWorkspaceUri(srcWorkspaceName);
-            method = new MergeMethod(getItemUri(nodeId, sessionInfo), mInfo);
-            initMethod(method, sessionInfo, true);
-
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
-
+            MergeMethod method = new MergeMethod(getItemUri(nodeId, sessionInfo), mInfo);
-            return retrieveEvents();
+            return execute(method, sessionInfo);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        PropPatchMethod method = null;
-            method = new PropPatchMethod(getItemUri(nodeId, sessionInfo), changeList);
-            initMethod(method, sessionInfo, true);
-
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
-
+            PropPatchMethod method = new PropPatchMethod(getItemUri(nodeId, sessionInfo), changeList);
-            return retrieveEvents();
+            return execute(method, sessionInfo);
-        } catch (DavException e) {
-            throw ExceptionConverter.generate(e);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        LabelMethod method = null;
-        try {
+         try {
-            method = new LabelMethod(uri, NameFormat.format(label, getNamespaceResolver()), (moveLabel) ? LabelInfo.TYPE_SET : LabelInfo.TYPE_ADD);
-            initMethod(method, sessionInfo, true);
-
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
-
-            return retrieveEvents();
+            LabelMethod method = new LabelMethod(uri, NameFormat.format(label, nsResolver), (moveLabel) ? LabelInfo.TYPE_SET : LabelInfo.TYPE_ADD);
+            return execute(method, sessionInfo);
-        } catch (DavException e) {
-            throw ExceptionConverter.generate(e);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        LabelMethod method = null;
-            method = new LabelMethod(uri, NameFormat.format(label, getNamespaceResolver()), LabelInfo.TYPE_REMOVE);
-            initMethod(method, sessionInfo, true);
-
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
-
-            return retrieveEvents();
+            LabelMethod method = new LabelMethod(uri, NameFormat.format(label, nsResolver), LabelInfo.TYPE_REMOVE);
+            return execute(method, sessionInfo);
-        } catch (DavException e) {
-            throw ExceptionConverter.generate(e);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        OptionsMethod method = new OptionsMethod(getWorkspaceUri(sessionInfo.getWorkspaceName()));
+        OptionsMethod method = new OptionsMethod(uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName()));
+        } finally {
+            if (method != null) {
+                method.releaseConnection();
+            }
+        SearchMethod method = null;
-            SearchMethod method = new SearchMethod(getWorkspaceUri(sessionInfo.getWorkspaceName()), statement, language);
+            String uri = uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName());
+            method = new SearchMethod(uri, statement, language);
-            return new QueryInfoImpl(ms, sessionInfo, getURIResolver(),
-                getNamespaceResolver(), valueFactory);
+            return new QueryInfoImpl(ms, sessionInfo, uriResolver,
+                nsResolver, valueFactory);
+        }  finally {
+            if (method != null) {
+                method.releaseConnection();
+            }
-     * @see RepositoryService#addEventListener(SessionInfo, NodeId, EventListener, int, boolean, String[], QName[])
+     * @see RepositoryService#addEventListener(SessionInfo,NodeId,EventListener,int,boolean,String[],QName[])
-        for (int i = 0; i < uuids.length; i++) {
+        for (int i = 0; uuids != null && i < uuids.length; i++) {
-        for (int i = 0; i < nodeTypeIds.length; i++) {
+        for (int i = 0; nodeTypeIds != null && i < nodeTypeIds.length; i++) {
-                String ntName = NameFormat.format(nodeTypeIds[i], getNamespaceResolver());
+                String ntName = NameFormat.format(nodeTypeIds[i], nsResolver);
-        // always 'noLocal' since local changes are reported by return values
+
-
+        String uri = getItemUri(nodeId, sessionInfo);
-        // TODO: missing implementation
+        checkSessionInfo(sessionInfo);
+        SubscriptionManager sMgr = ((SessionInfoImpl)sessionInfo).getSubscriptionManager();
+
+        if (sMgr.subscriptionExists(listener)) {
+            String subscriptionId = sMgr.getSubscriptionId(listener);
+            subscribe(uri, subscriptionInfo, subscriptionId, sessionInfo);
+            log.debug("Subscribed on server for listener " + listener);
+        } else {
+            String subscriptionId = subscribe(uri, subscriptionInfo, null, sessionInfo);
+            log.debug("Subscribed on server for listener " + listener);
+            sMgr.addSubscription(uri, subscriptionId, listener);
+            log.debug("Added subscription for listener " + listener);
+        }
-        // TODO: missing implementation
+        checkSessionInfo(sessionInfo);
+        SubscriptionManager sMgr = ((SessionInfoImpl)sessionInfo).getSubscriptionManager();
+        String subscriptionId = sMgr.getSubscriptionId(listener);
+
+        String uri = getItemUri(nodeId, sessionInfo);
+        sMgr.removeSubscription(listener);
+        log.debug("Removed subscription for listener " + listener);
+        unsubscribe(uri, subscriptionId, sessionInfo);
+        log.debug("Unsubscribed on server for listener " + listener);
+    }
+
+
+    private String subscribe(String uri, SubscriptionInfo subscriptionInfo, String subscriptionId, SessionInfo sessionInfo) throws RepositoryException {
+        SubscribeMethod method = null;
+        try {
+            if (subscriptionId != null) {
+                method = new SubscribeMethod(uri, subscriptionInfo, subscriptionId);
+            } else {
+                method = new SubscribeMethod(uri, subscriptionInfo);
+            }
+            getClient(sessionInfo).executeMethod(method);
+            method.checkSuccess();
+            return method.getSubscriptionId();
+        } catch (IOException e) {
+            throw new RepositoryException(e);
+        } catch (DavException e) {
+            throw ExceptionConverter.generate(e);
+        }  finally {
+            if (method != null) {
+                method.releaseConnection();
+            }
+        }
+    }
+
+    private void unsubscribe(String uri, String subscriptionId, SessionInfo sessionInfo) throws RepositoryException {
+        UnSubscribeMethod method = null;
+        try {
+            method = new UnSubscribeMethod(uri, subscriptionId);
+            getClient(sessionInfo).executeMethod(method);
+            method.checkSuccess();
+        } catch (IOException e) {
+            throw new RepositoryException(e);
+        } catch (DavException e) {
+            throw ExceptionConverter.generate(e);
+        }  finally {
+            if (method != null) {
+                method.releaseConnection();
+            }
+        }
+    }
+
+    private EventIterator poll(String uri, String subscriptionId,  SessionInfo sessionInfo) throws RepositoryException {
+        PollMethod method = null;
+        try {
+            method = new PollMethod(uri, subscriptionId);
+            getClient(sessionInfo).executeMethod(method);
+            method.checkSuccess();
+
+            EventDiscovery disc = method.getResponseAsEventDiscovery();
+            if (disc.isEmpty()) {
+                return IteratorHelper.EMPTY;
+            } else {
+                Element discEl = disc.toXml(domFactory);
+                return new EventIteratorImpl(discEl, uriResolver, sessionInfo);
+            }
+        } catch (IOException e) {
+            throw new RepositoryException(e);
+        } catch (DavException e) {
+            throw ExceptionConverter.generate(e);
+        }  finally {
+            if (method != null) {
+                method.releaseConnection();
+            }
+        }
-            method = new ReportMethod(getWorkspaceUri(sessionInfo.getWorkspaceName()), info);
+            method = new ReportMethod(uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName()), info);
-            String uri = getWorkspaceUri(sessionInfo.getWorkspaceName());
+            String uri = uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName());
-            method = new ReportMethod(getWorkspaceUri(sessionInfo.getWorkspaceName()), info);
+            String workspaceUri = uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName());
+            method = new ReportMethod(workspaceUri, info);
-                ntDefs.add(new QNodeTypeDefinitionImpl(it.nextElement(), getNamespaceResolver()));
+                ntDefs.add(new QNodeTypeDefinitionImpl(it.nextElement(), nsResolver));
+    /**
+     * The XML elements and attributes used in serialization
+     */
+    private static final Namespace SV_NAMESPACE = Namespace.getNamespace(QName.NS_SV_PREFIX, QName.NS_SV_URI);
+    private static final String NODE_ELEMENT = "node";
+    private static final String PROPERTY_ELEMENT = "property";
+    private static final String VALUE_ELEMENT = "value";
+    private static final String NAME_ATTRIBUTE = "name";
+    private static final String TYPE_ATTRIBUTE = "type";
+
-        private final SessionInfoImpl sessionInfo;
+        private final SessionInfo sessionInfo;
+        private final ItemId targetId;
+        private String batchId;
+        private String subscriptionId;
+
-        private BatchImpl(SessionInfoImpl sessionInfo) {
+        private BatchImpl(ItemId targetId, SessionInfo sessionInfo) {
+            this.targetId = targetId;
-                String uri = getRootItemUri(sessionInfo.getWorkspaceName());
+                String uri = getItemUri(targetId, sessionInfo);
+                // start special 'lock'
-                String batchId = method.getLockToken();
-                sessionInfo.setBatchId(batchId);
+                batchId = method.getLockToken();
+
+                // register subscription
+                String subscrUri = (targetId.denotesNode() ? uri : getItemUri(((PropertyId) targetId).getParentId(), sessionInfo));
+                subscriptionId = subscribe(subscrUri, S_INFO, null, sessionInfo);
-        private void end(HttpClient client, boolean discard) throws RepositoryException {
+        private EventIterator end(HttpClient client, boolean commit) throws RepositoryException {
-                String uri = getRootItemUri(sessionInfo.getWorkspaceName());
-                UnLockMethod method = new UnLockMethod(uri, sessionInfo.getBatchId());
+                String uri = getItemUri(targetId, sessionInfo);
+                UnLockMethod method = new UnLockMethod(uri, batchId);
-                method.setRequestBody(new TransactionInfo(!discard));
+                method.setRequestBody(new TransactionInfo(commit));
-                // make sure the batchId on the sessionInfo is reset.
-                sessionInfo.setBatchId(null);
+
+                // retrieve events && unsubscribe
+                String subscrUri = (targetId.denotesNode() ? uri : getItemUri(((PropertyId) targetId).getParentId(), sessionInfo));
+                EventIterator events = poll(subscrUri, subscriptionId, sessionInfo);
+                unsubscribe(subscrUri, subscriptionId, sessionInfo);
+
+                return events;
-         * The XML elements and attributes used in serialization
-         */
-        private final Namespace SV_NAMESPACE = Namespace.getNamespace(QName.NS_SV_PREFIX, QName.NS_SV_URI);
-        private final String NODE_ELEMENT = "node";
-        private final String PROPERTY_ELEMENT = "property";
-        private final String VALUE_ELEMENT = "value";
-        private final String NAME_ATTRIBUTE = "name";
-        private final String TYPE_ATTRIBUTE = "type";
-
-        /**
-                        DomUtil.setAttribute(propElement, NAME_ATTRIBUTE, SV_NAMESPACE, NameFormat.format(QName.JCR_PRIMARYTYPE, getNamespaceResolver()));
+                        DomUtil.setAttribute(propElement, NAME_ATTRIBUTE, SV_NAMESPACE, NameFormat.format(QName.JCR_PRIMARYTYPE, nsResolver));
-                        DomUtil.addChildElement(propElement, VALUE_ELEMENT, SV_NAMESPACE, NameFormat.format(nodetypeName, getNamespaceResolver()));
+                        DomUtil.addChildElement(propElement, VALUE_ELEMENT, SV_NAMESPACE, NameFormat.format(nodetypeName, nsResolver));
-                        DomUtil.setAttribute(propElement, NAME_ATTRIBUTE, SV_NAMESPACE, NameFormat.format(QName.JCR_UUID, getNamespaceResolver()));
+                        DomUtil.setAttribute(propElement, NAME_ATTRIBUTE, SV_NAMESPACE, NameFormat.format(QName.JCR_UUID, nsResolver));
-            Value jcrValue = ValueFormat.getJCRValue(qV, getNamespaceResolver(), valueFactory);
+            Value jcrValue = ValueFormat.getJCRValue(qV, nsResolver, valueFactory);
-                jcrValues[i] = ValueFormat.getJCRValue(v, getNamespaceResolver(), valueFactory);
+                jcrValues[i] = ValueFormat.getJCRValue(v, nsResolver, valueFactory);
-                Value jcrValue = ValueFormat.getJCRValue(qV, getNamespaceResolver(), valueFactory);
+                Value jcrValue = ValueFormat.getJCRValue(qV, nsResolver, valueFactory);
-                    jcrValues[i] = ValueFormat.getJCRValue(qV, getNamespaceResolver(), valueFactory);
+                    jcrValues[i] = ValueFormat.getJCRValue(qV, nsResolver, valueFactory);
-                Value jcrValue = ValueFormat.getJCRValue(qV, getNamespaceResolver(), valueFactory);
+                Value jcrValue = ValueFormat.getJCRValue(qV, nsResolver, valueFactory);
-                    jcrValues[i] = ValueFormat.getJCRValue(qV, getNamespaceResolver(), valueFactory);
+                    jcrValues[i] = ValueFormat.getJCRValue(qV, nsResolver, valueFactory);
-                    Value jcrValue = ValueFormat.getJCRValue(qV, getNamespaceResolver(), valueFactory);
+                    Value jcrValue = ValueFormat.getJCRValue(qV, nsResolver, valueFactory);
-                        jcrValues[i] = ValueFormat.getJCRValue(qV, getNamespaceResolver(), valueFactory);
+                        jcrValues[i] = ValueFormat.getJCRValue(qV, nsResolver, valueFactory);
-                        ntNames[i] = NameFormat.format(mixinNodeTypeIds[i], getNamespaceResolver());
+                        ntNames[i] = NameFormat.format(mixinNodeTypeIds[i], nsResolver);
+
+    /**
+     * <code>SubscriptionManager</code>...
+     */
+    private class SubscriptionMgrImpl implements SubscriptionManager {
+
+        private SessionInfo sessionInfo;
+
+        private final Map subscriptions = new HashMap();
+        private final Object subscriptionsLock = new Object();
+        private Map currentSubscriptions;
+
+        private Thread t;
+
+        public void setSessionInfo(SessionInfo sessionInfo) {
+            this.sessionInfo = sessionInfo;
+        }
+
+        public boolean subscriptionExists(EventListener listener) {
+            return getSubscriptions().containsKey(listener);
+        }
+
+        public String getSubscriptionId(EventListener listener) {
+            if (getSubscriptions().containsKey(listener)) {
+                return ((String[]) getSubscriptions().get(listener))[1];
+            } else {
+                return null;
+            }
+        }
+
+        public void addSubscription(String uri, String subscriptionId, EventListener listener) {
+            synchronized (subscriptionsLock) {
+                boolean doStart = subscriptions.isEmpty();
+                subscriptions.put(listener, new String[] {uri,subscriptionId});
+                currentSubscriptions = null;
+                if (doStart) {
+                    startPolling();
+                }
+            }
+        }
+
+        public synchronized void removeSubscription(EventListener listener) {
+            synchronized (subscriptionsLock) {
+                subscriptions.remove(listener);
+                currentSubscriptions = null;
+                if (subscriptions.isEmpty()) {
+                    stopPolling();
+                }
+            }
+        }
+
+        private Map getSubscriptions() {
+            synchronized (subscriptionsLock) {
+                if (currentSubscriptions == null) {
+                    currentSubscriptions = Collections.unmodifiableMap(new HashMap(subscriptions));
+                }
+                return currentSubscriptions;
+            }
+        }
+
+        private void startPolling() {
+            Runnable r = new Runnable() {
+                public void run() {
+                    while (t == Thread.currentThread()) {
+                        try {
+                            // sleep
+                            Thread.sleep(POLL_INTERVAL);
+                            // poll
+                            Iterator lstnIterator = getSubscriptions().keySet().iterator();
+                            while (lstnIterator.hasNext()) {
+                                EventListener listener = (EventListener) lstnIterator.next();
+                                String[] value = (String[]) getSubscriptions().get(listener);
+                                String uri = value[0];
+                                String subscriptionId = value[1];
+                                EventIterator eventIterator = poll(uri, subscriptionId, sessionInfo);
+                                listener.onEvent(eventIterator);
+                            }
+                        } catch (InterruptedException e) {
+                            log.debug("Polling thread interrupted: " + e.getMessage());
+                            return;
+                        } catch (RepositoryException e) {
+                            log.warn("Polling failed: ", e.getMessage());
+                        }
+                    }
+                }
+            };
+            t = new Thread(r);
+            t.start();
+        }
+
+        private void stopPolling() {
+            t.interrupt();
+        }
+    }

work in progress

- removeVersion missing
- LockManager/VersionManager: should not rely on observation (todo added)
- Add Operation.persisted() (Impl. still missing) in analogy to ChangeLog.persisted.
- ItemImpl.refresh behaves according to CacheBehaviour flag.
- NodeState: fix classcastexception when accessing state from propertiesInAttic
- ItemState: rename 'refresh()' to 'reload()
- ItemState: move code common to PropertyState and NodeState to ItemState
- ItemState: rename 'reset' to 'merge'
- add common interface ChildItemEntry
- SessionItemStateManager: avoid traversing twice during 'undo'

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@477095 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.operation.RemoveVersion;
+import javax.jcr.ReferentialIntegrityException;
-        Sync eventSignal;
-        synchronized (updateMonitor) {
+        if (cacheBehaviour == CacheBehaviour.OBSERVATION) {
+            Sync eventSignal;
+            synchronized (updateMonitor) {
+                new OperationVisitorImpl(sessionInfo).execute(operation);
+                eventSignal = getEventPollingRequest();
+            }
+            try {
+                eventSignal.acquire();
+            } catch (InterruptedException e) {
+                Thread.interrupted();
+                log.warn("Interrupted while waiting for events from RepositoryService");
+            }
+        } else {
+            // execute operation and delegate invalidation of affected item
+            // states to the operation.
-            eventSignal = getEventPollingRequest();
-        }
-        try {
-            eventSignal.acquire();
-        } catch (InterruptedException e) {
-            Thread.interrupted();
-            log.warn("Interrupted while waiting for events from RepositoryService");
+            operation.persisted();
-        Sync eventSignal;
-        synchronized (updateMonitor) {
+        if (cacheBehaviour == CacheBehaviour.OBSERVATION) {
+            // TODO: TOBEFIXED. processing events after changelog may lead to consistency problems (duplicate processing) (e.g. removal of SNSs).
+            // TODO: filtering of events required according to information present in the changelog.
+            Sync eventSignal;
+            synchronized (updateMonitor) {
+                new OperationVisitorImpl(sessionInfo).execute(changes);
+                changes.persisted();
+                eventSignal = getEventPollingRequest();
+            }
+            try {
+                eventSignal.acquire();
+            } catch (InterruptedException e) {
+                Thread.interrupted();
+                log.warn("Interrupted while waiting for events from RepositoryService");
+            }
+        } else {
-            eventSignal = getEventPollingRequest();
-        }
-        try {
-            eventSignal.acquire();
-        } catch (InterruptedException e) {
-            Thread.interrupted();
-            log.warn("Interrupted while waiting for events from RepositoryService");
+    /**
+     * Dispose this <code>WorkspaceManager</code>
+     */
-     * @param events the events generated by the repository service as the
-     *               effect of a change.
+     * @param eventBundles the event bundles generated by the repository service
+     * as the effect of an local or external change.
-    private void onEventReceived(EventBundle[] events) {
+    private void onEventReceived(EventBundle[] eventBundles) {
-        for (int i = 0; i < events.length; i++) {
+        for (int i = 0; i < eventBundles.length; i++) {
-                lstnrs[j].onEvent(events[i]);
+                lstnrs[j].onEvent(eventBundles[i]);
+
+        public void visit(RemoveVersion operation) throws VersionException, AccessDeniedException, ReferentialIntegrityException, RepositoryException {
+            NodeState versionState = (NodeState) operation.getRemoveState();
+            NodeState vhState = operation.getParentState();
+            service.removeVersion(sessionInfo, vhState.getNodeId(), versionState.getNodeId());
+        }
-
-
+                        long timeout = 0;
-                        EventBundle[] bundles = service.getEvents(sessionInfo,
-                                0, (EventFilter[]) filters.toArray(
-                                        new EventFilter[filters.size()]));
+                        EventFilter[] filtArr = (EventFilter[]) filters.toArray(new EventFilter[filters.size()]);
+
+                        EventBundle[] bundles = service.getEvents(sessionInfo, timeout, filtArr);

JCR-131: simplifying internal data model (NodeState) by limiting a node to *one* parent



git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@191499 13f79535-47bb-0310-9956-ffa450edef68

-    protected NodeImpl createChildNodeLink(QName nodeName, String targetUUID)
-            throws RepositoryException {
-        // modify the state of 'this', i.e. the parent node
-        NodeState thisState = (NodeState) getOrCreateTransientItemState();
-
-        NodeId targetId = new NodeId(targetUUID);
-        NodeImpl targetNode = (NodeImpl) itemMgr.getItem(targetId);
-        // notify target of link
-        targetNode.onLink(thisState);
-
-        thisState.addChildNodeEntry(nodeName, targetUUID);
-
-        return (NodeImpl) itemMgr.getItem(targetId);
-    }
-
-    protected void renameChildNodeLink(QName oldName, int index, String uuid,
-                                       QName newName)
+    protected void renameChildNode(QName oldName, int index, String uuid,
+                                   QName newName)
-        NodeId childId = new NodeId(entry.getUUID());
-        NodeImpl childNode = (NodeImpl) itemMgr.getItem(childId);
-        // notify target of removal/unlink
-        childNode.onUnlink(thisState);
-
-        // remove child entry
+        // remove the child node entry
+
+        // notify target of removal
+        NodeId childId = new NodeId(entry.getUUID());
+        NodeImpl childNode = (NodeImpl) itemMgr.getItem(childId);
+        childNode.onRemove();
-    protected void onLink(NodeState parentState) throws RepositoryException {
-        // modify the state of 'this', i.e. the target node
-        NodeState thisState = (NodeState) getOrCreateTransientItemState();
-        // add uuid of this node to target's parent list
-        thisState.addParentUUID(parentState.getUUID());
-    }
-
-    protected void onUnlink(NodeState parentState) throws RepositoryException {
+    protected void onRemove() throws RepositoryException {
-        // check if this node would be orphaned after unlinking it from parent
-        ArrayList parentUUIDs = new ArrayList(thisState.getParentUUIDs());
-        parentUUIDs.remove(parentState.getUUID());
-        boolean orphaned = parentUUIDs.isEmpty();
-
-        if (orphaned) {
-            // remove child nodes (recursive)
-            // use temp array to avoid ConcurrentModificationException
-            ArrayList tmp = new ArrayList(thisState.getChildNodeEntries());
-            // remove from tail to avoid problems with same-name siblings
-            for (int i = tmp.size() - 1; i >= 0; i--) {
-                NodeState.ChildNodeEntry entry =
-                        (NodeState.ChildNodeEntry) tmp.get(i);
-                removeChildNode(entry.getName(), entry.getIndex());
-            }
-
-            // remove properties
-            // use temp array to avoid ConcurrentModificationException
-            tmp = new ArrayList(thisState.getPropertyEntries());
-            for (int i = 0; i < tmp.size(); i++) {
-                NodeState.PropertyEntry entry =
-                        (NodeState.PropertyEntry) tmp.get(i);
-                removeChildProperty(entry.getName());
-            }
+        // remove child nodes
+        // use temp array to avoid ConcurrentModificationException
+        ArrayList tmp = new ArrayList(thisState.getChildNodeEntries());
+        // remove from tail to avoid problems with same-name siblings
+        for (int i = tmp.size() - 1; i >= 0; i--) {
+            NodeState.ChildNodeEntry entry =
+                    (NodeState.ChildNodeEntry) tmp.get(i);
+            // remove the child node entry
+            thisState.removeChildNodeEntry(entry.getName(), entry.getIndex());
+            // recursively remove child node
+            NodeId childId = new NodeId(entry.getUUID());
+            NodeImpl childNode = (NodeImpl) itemMgr.getItem(childId);
+            childNode.onRemove();
-        // now actually do unlink this node from specified parent node
-        // (i.e. remove uuid of parent node from this node's parent list)
-        thisState.removeParentUUID(parentState.getUUID());
-
-        if (orphaned) {
-            // remove this node
-            itemMgr.getItem(id).setRemoved();
+        // remove properties
+        // use temp array to avoid ConcurrentModificationException
+        tmp = new ArrayList(thisState.getPropertyEntries());
+        for (int i = 0; i < tmp.size(); i++) {
+            NodeState.PropertyEntry entry =
+                    (NodeState.PropertyEntry) tmp.get(i);
+            // remove the property entry
+            thisState.removePropertyEntry(entry.getName());
+            // remove property
+            PropertyId propId = new PropertyId(thisState.getUUID(), entry.getName());
+            itemMgr.getItem(propId).setRemoved();
+
+        // finally remove this node
+        thisState.setParentUUID(null);
+        itemMgr.getItem(id).setRemoved();
-        persistentState.setParentUUIDs(transientState.getParentUUIDs());
-        } catch (NodeTypeConflictException ntce) {
+        } catch  (NodeTypeConflictException ntce) {
-    public Lock lock(boolean isDeep, boolean isSessionScoped)
+        public Lock lock(boolean isDeep, boolean isSessionScoped)

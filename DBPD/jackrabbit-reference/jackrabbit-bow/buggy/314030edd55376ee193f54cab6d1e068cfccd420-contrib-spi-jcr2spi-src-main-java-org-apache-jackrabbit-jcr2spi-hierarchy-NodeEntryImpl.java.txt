improve memory consumption of the current hierarchy implementation

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@542571 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.spi.ChildInfo;
-     * insertion-ordered collection of NodeEntry objects
+     * Insertion-ordered collection of NodeEntry objects.
-     * Map of properties. Key = {@link QName} of property. Value = {@link
-     * PropertyEntry}.
+     * Map of properties.<br>
+     * Key = {@link QName} of property,<br>
+     * Value = {@link PropertyEntry}.
-    private final HashMap properties = new HashMap();
+    private final ChildPropertyEntries properties;
-    private final HashMap propertiesInAttic = new HashMap();
+    private final Map propertiesInAttic;
-    NodeEntryImpl(NodeEntryImpl parent, QName name, String uniqueID, EntryFactory factory) {
+    private NodeEntryImpl(NodeEntryImpl parent, QName name, String uniqueID, EntryFactory factory) {
-        this.childNodeAttic = new ChildNodeAttic();
+
+        properties = new ChildPropertyEntriesImpl(this, factory);
+
+        propertiesInAttic = new HashMap();
+        childNodeAttic = new ChildNodeAttic();
+    /**
+     *
+     * @param parent
+     * @param name
+     * @param uniqueId
+     * @param factory
+     * @return
+     */
+    static NodeEntry createNodeEntry(NodeEntryImpl parent, QName name, String uniqueId, EntryFactory factory) {
+        return new NodeEntryImpl(parent, name, uniqueId, factory);
+    }
+
-            for (Iterator it = getAllChildEntries(false, true); it.hasNext();) {
+            for (Iterator it = getAllChildEntries(true); it.hasNext();) {
-            for (Iterator it = getAllChildEntries(true, true); it.hasNext();) {
+            for (Iterator it = getAllChildEntries(true); it.hasNext();) {
-            properties.putAll(propertiesInAttic);
+            properties.addAll(propertiesInAttic.values());
-        for (Iterator it = getAllChildEntries(true, false); it.hasNext();) {
+        for (Iterator it = getAllChildEntries(false); it.hasNext();) {
-            properties.putAll(propertiesInAttic);
+            properties.addAll(propertiesInAttic.values());
-        for (Iterator it = getAllChildEntries(true, true); it.hasNext();) {
+        for (Iterator it = getAllChildEntries(true); it.hasNext();) {
-        for (Iterator it = getAllChildEntries(true, true); it.hasNext();) {
+        for (Iterator it = getAllChildEntries(true); it.hasNext();) {
-                } else {
-                    continue;
+                continue;
-            // first try to resolve to nodeEntry or property entry
-            NodeEntry cne = (entry.childNodeEntries == null) ? null : entry.childNodeEntries.get(name, index);
+            // first try to resolve to known node or property entry
+            NodeEntry cne = (entry.childNodeEntries == null) ? null : entry.getNodeEntry(name, index, false);
-            } else if (index == Path.INDEX_DEFAULT && entry.properties.containsKey(name)
-                && i == path.getLength() - 1) {
+            } else if (index == Path.INDEX_DEFAULT && i == path.getLength() - 1 && entry.properties.contains(name)) {
-                return (PropertyEntry) entry.properties.get(name);
+                return entry.properties.get(name);
-                // -> check if child points to a removed sns
-                if (entry.childNodeAttic.contains(name, index)) {
-                    throw new PathNotFoundException(path.toString());
-                } else if (entry.childNodeEntries != null) {
-                    int noSNS = entry.childNodeEntries.get(name).size() + entry.childNodeAttic.get(name).size();
-                    if (index <= noSNS) {
+                // -> check if child points to a removed/moved sns
+                if (entry.childNodeEntries != null) {
+                    List siblings = entry.childNodeEntries.get(name);
+                    if (entry.containsAtticChild(siblings, name, index)) {
-                NodeId anyId = entry.getId();
+                NodeId parentId = entry.getId();
-                NodeId nodeId = idFactory.createNodeId(anyId, remainingPath);
-                try {
-                    NodeState state = entry.factory.getItemStateFactory().createDeepNodeState(nodeId, entry);
-                    return state.getHierarchyEntry();
-                } catch (ItemNotFoundException e) {
+
+                NodeId nodeId = idFactory.createNodeId(parentId, remainingPath);
+                NodeEntry ne = entry.loadNodeEntry(nodeId);
+                if (ne != null) {
+                    return ne;
+                } else {
-                        throw new PathNotFoundException(path.toString(), e);
+                        throw new PathNotFoundException(path.toString());
-                    // possibly  propstate
-                    try {
-                        nodeId = (remainingPath.getLength() == 1) ? anyId : idFactory.createNodeId(anyId, remainingPath.getAncestor(1));
-                        PropertyId id = idFactory.createPropertyId(nodeId, remainingPath.getNameElement().getName());
-                        PropertyState state = entry.factory.getItemStateFactory().createDeepPropertyState(id, entry);
-                        return state.getHierarchyEntry();
-                    } catch (ItemNotFoundException ise) {
+                    // maybe a property entry exists
+                    parentId = (remainingPath.getLength() == 1) ? parentId : idFactory.createNodeId(parentId, remainingPath.getAncestor(1));
+                    PropertyId propId = idFactory.createPropertyId(parentId, remainingPath.getNameElement().getName());
+                    PropertyEntry pe = entry.loadPropertyEntry(propId);
+                    if (pe != null) {
+                        return pe;
+                    } else {
-                } else {
-                    continue;
+                continue;
-            NodeEntry cne = entry.lookupNodeEntry(childName, index);
+            NodeEntry cne = entry.lookupNodeEntry(null, childName, index);
-                // copy list since during validation the childNodeEntries may be
-                // modified if upon NodeEntry.getItemState the entry is removed.
-                List l = new ArrayList(namedEntries.size());
-                l.addAll(namedEntries);
-                return EntryValidation.containsValidNodeEntry(l.iterator());
+                return EntryValidation.containsValidNodeEntry(namedEntries.iterator());
-            return EntryValidation.isValidNodeEntry(childNodeEntries().get(nodeName, index));
+            return getNodeEntry(nodeName, index) != null;
-        NodeEntry cne = childNodeEntries().get(nodeName, index);
-        if (EntryValidation.isValidNodeEntry(cne)) {
-            return cne;
-        } else {
-            return null;
-        }
+        return getNodeEntry(nodeName, index, false);
-
-     * @see NodeEntry#getNodeEntry(NodeId)
+     * @see NodeEntry#getNodeEntry(QName, int, boolean)
-    public synchronized NodeEntry getNodeEntry(NodeId childId) throws RepositoryException {
-        String uid = childId.getUniqueID();
-        Path path = childId.getPath();
-        NodeEntry cne;
-        if (uid != null && path == null) {
-            // retrieve child-entry by uid
-            cne = childNodeEntries().get(null, uid);
-        } else {
-           // retrieve child-entry by name and index
-            Path.PathElement nameElement = path.getNameElement();
-            cne = childNodeEntries().get(nameElement.getName(), nameElement.getIndex());
+    public NodeEntry getNodeEntry(QName nodeName, int index, boolean loadIfNotFound) throws RepositoryException {
+        List entries = childNodeEntries().get(nodeName);
+        NodeEntry cne = null;
+        if (entries.size() >= index) {
+            // position of entry might differ from index-1 if a SNS with lower
+            // index has been transiently removed.
+            for (int i = index-1; i < entries.size() && cne == null; i++) {
+                NodeEntry ne = (NodeEntry) entries.get(i);
+                if (EntryValidation.isValidNodeEntry(ne)) {
+                    cne = ne;
+                }
+            }
+        } else if (loadIfNotFound && !containsAtticChild(entries, nodeName, index)) {
+            NodeId cId = factory.getIdFactory().createNodeId(getId(), Path.create(nodeName, index));
+            cne = loadNodeEntry(cId);
-
-        if (EntryValidation.isValidNodeEntry(cne)) {
-            return cne;
-        } else {
-            return null;
-        }
+        return cne;
-        Object[] arr = childNodeEntries().toArray();
-        for (int i = 0; i < arr.length; i++) {
-            NodeEntry cne = (NodeEntry) arr[i];
-            if (EntryValidation.isValidNodeEntry(cne)) {
-                entries.add(cne);
+        for (Iterator it = childNodeEntries().iterator(); it.hasNext();) {
+            NodeEntry entry = (NodeEntry) it.next();
+            if (EntryValidation.isValidNodeEntry(entry)) {
+                entries.add(entry);
-        NodeEntryImpl entry = internalAddNodeEntry(nodeName, uniqueID, Path.INDEX_UNDEFINED, childNodeEntries());
+        NodeEntry entry = internalAddNodeEntry(nodeName, uniqueID, Path.INDEX_UNDEFINED, childNodeEntries());
-        entry.internalSetItemState(state);
+        ((NodeEntryImpl) entry).internalSetItemState(state);
-    private NodeEntryImpl internalAddNodeEntry(QName nodeName, String uniqueID,
+    private NodeEntry internalAddNodeEntry(QName nodeName, String uniqueID,
-        NodeEntryImpl entry = new NodeEntryImpl(this, nodeName, uniqueID, factory);
+        NodeEntry entry = factory.createNodeEntry(this, nodeName, uniqueID);
-        PropertyEntry entry = (PropertyEntry) properties.get(propName);
+        PropertyEntry entry = properties.get(propName);
-        PropertyEntry entry = (PropertyEntry) properties.get(propName);
+        PropertyEntry entry = properties.get(propName);
+     * @see NodeEntry#getPropertyEntry(QName, boolean)
+     */
+    public PropertyEntry getPropertyEntry(QName propName, boolean loadIfNotFound) throws RepositoryException {
+        PropertyEntry entry = properties.get(propName);
+        if (entry == null && loadIfNotFound) {
+            PropertyId propId = factory.getIdFactory().createPropertyId(getId(), propName);
+            entry = loadPropertyEntry(propId);
+        } else if (!EntryValidation.isValidPropertyEntry(entry)) {
+            entry = null;
+        }
+        return entry;
+    }
+
+    /**
+     * @inheritDoc
-            Object[] arr = properties.values().toArray();
+            Object[] arr = properties.getPropertyEntries().toArray();
-            props = properties.values();
+            props = properties.getPropertyEntries();
-        PropertyEntry entry = PropertyEntryImpl.create(this, propName, factory);
-        properties.put(propName, entry);
+        PropertyEntry entry = factory.createPropertyEntry(this, propName);
+        properties.add(entry);
-        diff.addAll(properties.keySet());
+        diff.addAll(properties.getPropertyNames());
-            if (!properties.containsKey(propName)) {
+            if (!properties.contains(propName)) {
-                PropertyEntry pEntry = (PropertyEntry) properties.get(propName);
+                PropertyEntry pEntry = properties.get(propName);
-        PropertyEntry existing = (PropertyEntry) properties.get(propName);
+        PropertyEntry existing = properties.get(propName);
-        PropertyEntry entry = PropertyEntryImpl.create(this, propName, factory);
-        properties.put(propName, entry);
+        PropertyEntry entry = factory.createPropertyEntry(this, propName);
+        properties.add(entry);
-    PropertyEntry internalRemovePropertyEntry(QName propName) {
-        PropertyEntry cpe = (PropertyEntry) properties.remove(propName);
-        if (cpe == null) {
-            cpe = (PropertyEntry) propertiesInAttic.remove(propName);
+    void internalRemovePropertyEntry(QName propName) {
+        if (!properties.remove(propName)) {
+            propertiesInAttic.remove(propName);
-        return cpe;
+                if (childNodeEntries == null) {
+                    // childNodeEntries not yet loaded -> ignore
+                    return;
+                }
+
-                // first check if no matching child entry exists.
+
-                if (childNodeEntries != null) {
-                    NodeEntry cne;
-                    if (uniqueChildID != null) {
-                        cne = childNodeEntries.get(eventName, uniqueChildID);
-                    } else {
+                // first check if no matching child entry exists.
+                NodeEntry cne;
+                if (uniqueChildID != null) {
+                    cne = childNodeEntries.get(eventName, uniqueChildID);
+                    if (cne == null) {
+                        // entry may exist but without having uniqueID resolved
-                    if (cne == null) {
-                        internalAddNodeEntry(eventName, uniqueChildID, index, childNodeEntries);
-                    } else {
-                        // child already exists -> deal with NEW entries, that were
-                        // added by some other session.
-                        // TODO: TOBEFIXED
-                    }
-                } // else: childNodeEntries not yet loaded -> ignore
+                } else {
+                    cne = childNodeEntries.get(eventName, index);
+                }
+                if (cne == null) {
+                    internalAddNodeEntry(eventName, uniqueChildID, index, childNodeEntries);
+                } else {
+                    // child already exists -> deal with NEW entries, that were
+                    // added by some other session.
+                    // TODO: TOBEFIXED
+                }
-        // TODO: check again. special treatment for index 0 for consistency with PathFormat.parse
+        // TODO: check again. special treatment for default index for consistency with PathFormat.parse
-            properties.put(propName, propertiesInAttic.remove(propName));
+            properties.add((PropertyEntry) propertiesInAttic.remove(propName));
+     *
+     * @param childId
+     * @return
+     */
+    private NodeEntry loadNodeEntry(NodeId childId) throws RepositoryException {
+        try {
+            NodeState state = factory.getItemStateFactory().createDeepNodeState(childId, this);
+            return state.getNodeEntry();
+        } catch (ItemNotFoundException e) {
+            return null;
+        }
+    }
+
+    /**
+     *
+     * @param childId
+     * @return
+     * @throws ItemNotFoundException
+     * @throws RepositoryException
+     */
+    private PropertyEntry loadPropertyEntry(PropertyId childId) throws RepositoryException {
+        try {
+            PropertyState state = factory.getItemStateFactory().createDeepPropertyState(childId, this);
+            return (PropertyEntry) state.getHierarchyEntry();
+        } catch (ItemNotFoundException e) {
+            return null;
+        }
+    }
+
+    /**
-        HierarchyEntry child = null;
+        HierarchyEntry child;
-            // for external node-removal the attic must be consulted first
-            // in order to be able to apply the changes to the proper node-entry.
-            if (uniqueChildID != null) {
-                child = childNodeAttic.get(uniqueChildID);
-                if (child == null && childNodeEntries != null) {
-                    child = childNodeEntries.get(childName, uniqueChildID);
-                }
-            }
-            if (child == null) {
-                int index = eventPath.getNameElement().getNormalizedIndex();
-                child = lookupNodeEntry(childName, index);
-            }
+            int index = eventPath.getNameElement().getNormalizedIndex();
+            child = lookupNodeEntry(uniqueChildID, childName, index);
-        if (child != null) {
-            // a NEW hierarchyEntry may never be affected by an external
-            // modification -> return null.
-            ItemState state = ((HierarchyEntryImpl) child).internalGetItemState();
-            if (state != null && state.getStatus() == Status.NEW) {
-                return null;
-            }
-        }
-        return child;
+        // a NEW hierarchyEntry may never be affected by an external modification
+        // -> return null.
+        return (child == null || child.getStatus() == Status.NEW) ? null : child;
-    private NodeEntryImpl lookupNodeEntry(QName childName, int index) {
-        NodeEntryImpl child = (NodeEntryImpl) childNodeAttic.get(childName, index);
-        if (child == null && childNodeEntries != null) {
-            List namedChildren = childNodeEntries.get(childName);
-            for (Iterator it = namedChildren.iterator(); it.hasNext(); ) {
-                NodeEntryImpl c = (NodeEntryImpl) it.next();
-                if (c.matches(childName, index)) {
-                    child = c;
-                    break;
+    private NodeEntry lookupNodeEntry(String uniqueChildId, QName childName, int index) {
+        NodeEntry child = null;
+        if (uniqueChildId != null) {
+            child = childNodeAttic.get(uniqueChildId);
+            if (child == null && childNodeEntries != null) {
+                child = childNodeEntries.get(childName, uniqueChildId);
+            }
+        }
+        if (child == null) {
+            child = childNodeAttic.get(childName, index);
+            if (child == null && childNodeEntries != null) {
+                List namedChildren = childNodeEntries.get(childName);
+                for (Iterator it = namedChildren.iterator(); it.hasNext(); ) {
+                    NodeEntryImpl c = (NodeEntryImpl) it.next();
+                    if (c.matches(childName, index)) {
+                        child = c;
+                        break;
+                    }
-            child = (PropertyEntry) properties.get(childName);
+            child = properties.get(childName);
-     *
-     * @return
+     * @return The <code>ChildNodeEntries</code> defined for this
+     * <code>NodeEntry</code>. Please note, that this method never returns
+     * <code>null</code>, since the child node entries are loaded/reloaded
+     * in case they have not been loaded yet.
-                childNodeEntries = new ChildNodeEntries(this);
-                loadChildNodeEntries();
+                childNodeEntries = new ChildNodeEntriesImpl(this, factory);
-                reloadChildNodeEntries(childNodeEntries);
-                childNodeEntries.setStatus(ChildNodeEntries.STATUS_OK);
+                childNodeEntries.reload();
-    private void loadChildNodeEntries() throws ItemNotFoundException, RepositoryException {
-
-        if (getStatus() == Status.NEW || Status.isTerminal(getStatus())) {
-            return; // cannot retrieve child-entries from persistent layer
-        }
-
-        NodeId id = getWorkspaceId();
-        Iterator it = factory.getItemStateFactory().getChildNodeInfos(id);
-        // simply add all child entries to the empty collection
-        while (it.hasNext()) {
-            ChildInfo ci = (ChildInfo) it.next();
-            internalAddNodeEntry(ci.getName(), ci.getUniqueID(), ci.getIndex(), childNodeEntries);
-        }
-    }
-
-    private void reloadChildNodeEntries(ChildNodeEntries cnEntries) throws ItemNotFoundException, RepositoryException {
-        if (getStatus() == Status.NEW || Status.isTerminal(getStatus())) {
-            // nothing to do
-            return;
-        }
-        NodeId id = getWorkspaceId();
-        Iterator it = factory.getItemStateFactory().getChildNodeInfos(id);
-        // create list from all ChildInfos (for multiple loop)
-        List cInfos = new ArrayList();
-        while (it.hasNext()) {
-            cInfos.add((ChildInfo) it.next());
-        }
-        // first make sure the ordering of all existing entries is ok
-        NodeEntry entry = null;
-        for (it = cInfos.iterator(); it.hasNext();) {
-            ChildInfo ci = (ChildInfo) it.next();
-            NodeEntry nextEntry = cnEntries.get(ci);
-            if (nextEntry != null) {
-                if (entry != null) {
-                    cnEntries.reorder(entry, nextEntry);
-                }
-                entry = nextEntry;
-            }
-        }
-        // then insert the 'new' entries
-        List newEntries = new ArrayList();
-        for (it = cInfos.iterator(); it.hasNext();) {
-            ChildInfo ci = (ChildInfo) it.next();
-            NodeEntry beforeEntry = cnEntries.get(ci);
-            if (beforeEntry == null) {
-                NodeEntry ne = new NodeEntryImpl(this, ci.getName(), ci.getUniqueID(), factory);
-                newEntries.add(ne);
-            } else {
-                // insert all new entries from the list BEFORE the existing
-                // 'nextEntry'. Then clear the list.
-                for (int i = 0; i < newEntries.size(); i++) {
-                    cnEntries.add((NodeEntry) newEntries.get(i), beforeEntry);
-                }
-                newEntries.clear();
-            }
-        }
-        // deal with new entries at the end
-        for (int i = 0; i < newEntries.size(); i++) {
-            cnEntries.add((NodeEntry) newEntries.get(i));
-        }
-    }
-
-    private Iterator getAllChildEntries(boolean createNewList, boolean includeAttic) {
-        Iterator[] its;
-        if (createNewList) {
-            List props = new ArrayList(properties.values());
-            List children = (childNodeEntries == null) ? Collections.EMPTY_LIST : new ArrayList(childNodeEntries);
-            if (includeAttic) {
-                List attic = new ArrayList(propertiesInAttic.values());
-                its = new Iterator[] {attic.iterator(), props.iterator(), children.iterator()};
-            } else {
-                its = new Iterator[] {props.iterator(), children.iterator()};
-            }
-        } else {
-            Iterator children = (childNodeEntries == null) ? Collections.EMPTY_LIST.iterator() : childNodeEntries.iterator();
-            if (includeAttic) {
-                its = new Iterator[] {propertiesInAttic.values().iterator(), properties.values().iterator(), children};
-            } else {
-                its = new Iterator[] {properties.values().iterator(), children};
-            }
+    private Iterator getAllChildEntries(boolean includeAttic) {
+        IteratorChain chain = new IteratorChain();
+        // attic
+        if (includeAttic) {
+            Collection attic = propertiesInAttic.values();
+            chain.addIterator(new ArrayList(attic).iterator());
-        return new IteratorChain(its);
+        // add props
+        synchronized (properties) {
+            Collection props = properties.getPropertyEntries();
+            chain.addIterator(props.iterator());
+        }
+        // add childNodeEntries
+        if (childNodeEntries != null) {
+            chain.addIterator(childNodeEntries.iterator());
+        }
+        return chain;
+     * Returns true if the attic contains a matching child entry or if any of
+     * the remaining child entries present in the siblings list has been modified
+     * in a way that its original index is equal to the given child index.
+     *
+     * @param siblings
+     * @param childName
+     * @param childIndex
+     * @return
+     */
+    private boolean containsAtticChild(List siblings, QName childName, int childIndex) {
+        // check if a matching entry exists in the attic
+        if (childNodeAttic.contains(childName, childIndex)) {
+            return true;
+        }
+        // in case of reordered/moved SNSs we also have to look for a child
+        // entry, which hold the given index before
+        if (getStatus() == Status.EXISTING_MODIFIED) {
+            for (Iterator it = siblings.iterator(); it.hasNext();) {
+                NodeEntryImpl child = (NodeEntryImpl) it.next();
+                if (!EntryValidation.isValidNodeEntry(child) || (child.revertInfo != null && child.revertInfo.oldIndex == childIndex)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+    /**

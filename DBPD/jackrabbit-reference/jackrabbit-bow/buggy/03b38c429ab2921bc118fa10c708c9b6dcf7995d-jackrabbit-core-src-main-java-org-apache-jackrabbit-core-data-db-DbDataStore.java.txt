JCR-1456: Database connection pooling

Merge back all changes from the JCR-1456 sandbox branch.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@886191 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager;
-import org.apache.jackrabbit.core.persistence.bundle.util.TrackingInputStream;
-import org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager.StreamWrapper;
+import org.apache.jackrabbit.core.persistence.pool.util.TrackingInputStream;
+import org.apache.jackrabbit.core.util.db.CheckSchemaOperation;
+import org.apache.jackrabbit.core.util.db.ConnectionFactory;
+import org.apache.jackrabbit.core.util.db.ConnectionHelper;
+import org.apache.jackrabbit.core.util.db.DatabaseAware;
+import org.apache.jackrabbit.core.util.db.DbUtility;
+import org.apache.jackrabbit.core.util.db.StreamWrapper;
-import java.sql.DatabaseMetaData;
-import java.sql.PreparedStatement;
+import javax.sql.DataSource;
-public class DbDataStore implements DataStore {
+public class DbDataStore implements DataStore, DatabaseAware {
-     * The default value for the maximum connections.
-     */
-    public static final int DEFAULT_MAX_CONNECTIONS = 3;
-    
-    /**
-     * The maximum number of open connections.
-     */
-    protected int maxConnections = DEFAULT_MAX_CONNECTIONS;
-
-    /**
-     * A list of connections
-     */
-    protected Pool connectionPool;
-
-    /**
+     * The logical name of the DataSource to use.
+     */
+    protected String dataSourceName;
+
+    /**
+     * The {@link ConnectionHelper} set in the {@link #init(String)} method.
+     * */
+    protected ConnectionHelper conHelper;
+
+    /**
+     * The repositories {@link ConnectionFactory}.
+     */
+    private ConnectionFactory connectionFactory;
+
+    /**
+     * {@inheritDoc}
+     */
+    public void setConnectionFactory(ConnectionFactory connnectionFactory) {
+        this.connectionFactory = connnectionFactory;
+    }
+
+    /**
-        ConnectionRecoveryManager conn = getConnection();
-            for (int i = 0; i < ConnectionRecoveryManager.TRIALS; i++) {
+            while(true) {
-                    PreparedStatement prep = conn.executeStmt(selectMetaSQL, new Object[]{tempId});
-                    rs = prep.getResultSet();
+                    rs = conHelper.exec(selectMetaSQL, new Object[]{tempId}, false, 0);
-                    conn.executeStmt(insertTempSQL, new Object[]{tempId, new Long(now)});
+                    conHelper.exec(insertTempSQL, new Object[]{tempId, new Long(now)});
-                    DatabaseHelper.closeSilently(rs);
+                    DbUtility.close(rs);
-            conn.executeStmt(updateDataSQL, new Object[]{wrapper, tempId});
+            conHelper.exec(updateDataSQL, new Object[]{wrapper, tempId});
-            PreparedStatement prep = conn.executeStmt(updateSQL, new Object[]{
+            int count = conHelper.update(updateSQL, new Object[]{
-            int count = prep.getUpdateCount();
+            rs = null; // prevent that rs.close() is called in finally block if count != 0 (rs is closed above)
-                conn.executeStmt(deleteSQL, new Object[]{tempId});
+                conHelper.exec(deleteSQL, new Object[]{tempId});
-                prep = conn.executeStmt(selectMetaSQL, new Object[]{id});
-                rs = prep.getResultSet();
+                rs = conHelper.exec(selectMetaSQL, new Object[]{id}, false, 0);
-            DatabaseHelper.closeSilently(rs);
-            putBack(conn);
+            DbUtility.close(rs);
-        ConnectionRecoveryManager conn = getConnection();
-            PreparedStatement prep = conn.executeStmt(deleteOlderSQL, new Long[]{new Long(min)});
-            return prep.getUpdateCount();
+            return conHelper.update(deleteOlderSQL, new Long[]{new Long(min)});
-        } finally {
-            putBack(conn);
-        ConnectionRecoveryManager conn = getConnection();
-            PreparedStatement prep = conn.executeStmt(selectAllSQL, new Object[0]);
-            rs = prep.getResultSet();
+            rs = conHelper.exec(selectAllSQL, new Object[0], false, 0);
-            DatabaseHelper.closeSilently(rs);
-            putBack(conn);
+            DbUtility.close(rs);
-        ConnectionRecoveryManager conn = getConnection();
-            PreparedStatement prep = conn.executeStmt(selectMetaSQL, new Object[]{id});
-            rs = prep.getResultSet();
+            rs = conHelper.exec(selectMetaSQL, new Object[]{id}, false, 0);
-            DatabaseHelper.closeSilently(rs);
-            putBack(conn);
+            DbUtility.close(rs);
-        ConnectionRecoveryManager conn = null;
-            conn = getConnection();
-            PreparedStatement prep = conn.executeStmt(selectDataSQL, new Object[]{identifier.toString()});
-            rs = prep.getResultSet();
+            rs = conHelper.exec(selectDataSQL, new Object[]{identifier.toString()}, false, 0);
-                DatabaseHelper.closeSilently(rs);
-                putBack(conn);
+                DbUtility.close(rs);
-                DatabaseHelper.closeSilently(rs);
-                putBack(conn);
+                DbUtility.close(rs);
-                inputStream.setConnection(conn);
-            DatabaseHelper.closeSilently(rs);
-            putBack(conn);
+            DbUtility.close(rs);
-            connectionPool = new Pool(this, maxConnections);
-            ConnectionRecoveryManager conn = getConnection();
-            DatabaseMetaData meta = conn.getConnection().getMetaData();
-            log.info("Using JDBC driver " + meta.getDriverName() + " " + meta.getDriverVersion());
-            meta.getDriverVersion();
-            ResultSet rs = meta.getTables(null, null, schemaObjectPrefix + tableSQL, null);
-            boolean exists = rs.next();
-            rs.close();
-            if (!exists && isSchemaCheckEnabled()) {
-                // CREATE TABLE DATASTORE(ID VARCHAR(255) PRIMARY KEY, 
-                // LENGTH BIGINT, LAST_MODIFIED BIGINT, DATA BLOB)
-                conn.executeStmt(createTableSQL, null);
+
+            conHelper = createConnectionHelper(getDataSource());
+
+            if (isSchemaCheckEnabled()) {
+                createCheckSchemaOperation().run();
-            putBack(conn);
+    private DataSource getDataSource() throws Exception {
+        if (getDataSourceName() == null || "".equals(getDataSourceName())) {
+            return connectionFactory.getDataSource(getDriver(), getUrl(), getUser(), getPassword());
+        } else {
+            return connectionFactory.getDataSource(dataSourceName);
+        }
+    }
+
+    /**
+     * This method is called from the {@link #init(String)} method of this class and returns a
+     * {@link ConnectionHelper} instance which is assigned to the {@code conHelper} field. Subclasses may
+     * override it to return a specialized connection helper.
+     * 
+     * @param dataSrc the {@link DataSource} of this persistence manager
+     * @return a {@link ConnectionHelper}
+     * @throws Exception on error
+     */
+    protected ConnectionHelper createConnectionHelper(DataSource dataSrc) throws Exception {
+        return new ConnectionHelper(dataSrc, false);
+    }
+
+    /**
+     * This method is called from {@link #init(String)} after the
+     * {@link #createConnectionHelper(DataSource)} method, and returns a default {@link CheckSchemaOperation}.
+     * 
+     * @return a new {@link CheckSchemaOperation} instance
+     */
+    protected final CheckSchemaOperation createCheckSchemaOperation() {
+        String tableName = tablePrefix + schemaObjectPrefix + tableSQL;
+        return new CheckSchemaOperation(conHelper, new ByteArrayInputStream(createTableSQL.getBytes()), tableName);
+    }
+
-        boolean failIfNotFound;
+        boolean failIfNotFound = false;
-            if (!url.startsWith("jdbc:")) {
-                return;
+            if (dataSourceName != null) {
+                try {
+                    databaseType = connectionFactory.getDataBaseType(dataSourceName);
+                } catch (RepositoryException e) {
+                    throw new DataStoreException(e);
+                }
+            } else {
+                if (!url.startsWith("jdbc:")) {
+                    return;
+                }
+                int start = "jdbc:".length();
+                int end = url.indexOf(':', start);
+                databaseType = url.substring(start, end);
-            failIfNotFound = false;
-            int start = "jdbc:".length();
-            int end = url.indexOf(':', start);
-            databaseType = url.substring(start, end);
-            ConnectionRecoveryManager conn = getConnection();
-                conn.executeStmt(updateLastModifiedSQL, new Object[]{
+                conHelper.exec(updateLastModifiedSQL, new Object[]{
-            } finally {
-                putBack(conn);
-        ArrayList<ConnectionRecoveryManager> list = connectionPool.getAll();
-        for (ConnectionRecoveryManager conn : list) {
-            conn.close();
-        }
-        list.clear();
-    protected ConnectionRecoveryManager getConnection() throws DataStoreException {
-        try {
-            ConnectionRecoveryManager conn = (ConnectionRecoveryManager) connectionPool.get();
-            conn.setAutoReconnect(true);
-            return conn;
-        } catch (InterruptedException e) {
-            throw new DataStoreException("Interrupted", e);
-        } catch (RepositoryException e) {
-            throw new DataStoreException("Can not open a new connection", e);
-        }
-    }
-
-    protected void putBack(ConnectionRecoveryManager conn) throws DataStoreException {
-        try {
-            connectionPool.add(conn);
-        } catch (InterruptedException e) {
-            throw new DataStoreException("Interrupted", e);
-        }
-    }
-
+     * @deprecated
-        return maxConnections;
+        return -1;
+     *@deprecated
-        this.maxConnections = maxConnections;
-    }
-
-    /**
-     * Create a new connection.
-     *
-     * @return the new connection
-     */
-    public ConnectionRecoveryManager createNewConnection() throws RepositoryException {
-        ConnectionRecoveryManager conn = new ConnectionRecoveryManager(false, driver, url, user, password);
-        return conn;
+    public String getDataSourceName() {
+        return dataSourceName;
+    }
+
+    public void setDataSourceName(String dataSourceName) {
+        this.dataSourceName = dataSourceName;
+    }

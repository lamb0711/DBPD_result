JCR-196: jcr:like() does not scale well on large value ranges

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@239404 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.regex.Matcher;
+ * Implements a wildcard term enum that supports embedded property names in
+ * lucene term texts.
-    private final Pattern pattern;
+    /**
+     * The pattern matcher.
+     */
+    private final Matcher pattern;
+    /**
+     * The lucene field to search.
+     */
+    /**
+     * The term prefix without wildcards
+     */
+    private final String prefix;
+
+    /**
+     * Flag that indicates the end of the term enum.
+     */
-    public WildcardTermEnum(IndexReader reader, Term term) throws IOException {
-        pattern = createRegexp(term.text());
-        field = term.field();
+    /**
+     * The input for the pattern matcher.
+     */
+    private final OffsetCharSequence input;
+
+    /**
+     * Creates a new <code>WildcardTermEnum</code>.
+     *
+     * @param reader the index reader.
+     * @param field the lucene field to search.
+     * @param propName the embedded jcr property name.
+     * @param pattern the pattern to match the values.
+     * @throws IOException if an error occurs while reading from the index.
+     */
+    public WildcardTermEnum(IndexReader reader,
+                            String field,
+                            String propName,
+                            String pattern) throws IOException {
+        this.field = field;
-        while (idx < term.text().length()
-                && Character.isLetterOrDigit(term.text().charAt(idx))) {
+        while (idx < pattern.length()
+                && Character.isLetterOrDigit(pattern.charAt(idx))) {
-        // because IndexReader.terms() starts with the term after the given
-        // one start with idx - 1
-        if (idx > 0) {
-            idx--;
-        }
-        setEnum(reader.terms(new Term(term.field(), term.text().substring(0, idx))));
+
+        prefix = FieldNames.createNamedValue(propName, pattern.substring(0, idx));
+
+        // initialize with prefix as dummy value
+        input = new OffsetCharSequence(prefix.length(), prefix);
+        this.pattern = createRegexp(pattern.substring(idx)).matcher(input);
+
+        setEnum(reader.terms(new Term(field, prefix)));
+    /**
+     * @inheritDoc
+     */
-        if (term.field() == field) {
-            return pattern.matcher(term.text()).matches();
+        if (term.field() == field && term.text().startsWith(prefix)) {
+            input.setBase(term.text());
+            return pattern.reset().matches();
+    /**
+     * @inheritDoc
+     */
+    /**
+     * @inheritDoc
+     */
+    /**
+     * Creates a regexp from <code>likePattern</code>.
+     *
+     * @param likePattern the pattern.
+     * @return the regular expression <code>Pattern</code>.
+     */
+
+    /**
+     * CharSequence that applies an offset to a base CharSequence. The base
+     * CharSequence can be replaced without creating a new CharSequence.
+     */
+    private static final class OffsetCharSequence implements CharSequence {
+
+        /**
+         * The offset to apply to the base CharSequence
+         */
+        private final int offset;
+
+        /**
+         * The base character sequence
+         */
+        private CharSequence base;
+
+        /**
+         * Creates a new OffsetCharSequence with an <code>offset</code>.
+         *
+         * @param offset the offset
+         * @param base the base CharSequence
+         */
+        OffsetCharSequence(int offset, CharSequence base) {
+            this.offset = offset;
+            this.base = base;
+        }
+
+        /**
+         * Sets a new base sequence.
+         *
+         * @param base the base character sequence
+         */
+        public void setBase(CharSequence base) {
+            this.base = base;
+        }
+
+        /**
+         * @inheritDoc
+         */
+        public int length() {
+            return base.length() - offset;
+        }
+
+        /**
+         * @inheritDoc
+         */
+        public char charAt(int index) {
+            return base.charAt(index + offset);
+        }
+
+        /**
+         * @inheritDoc
+         */
+        public CharSequence subSequence(int start, int end) {
+            return base.subSequence(start + offset, end + offset);
+        }
+
+        /**
+         * @inheritDoc
+         */
+        public String toString() {
+            return base.subSequence(offset, base.length()).toString();
+        }
+    }

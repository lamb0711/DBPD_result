work in progress

- removeVersion missing
- LockManager/VersionManager: should not rely on observation (todo added)
- Add Operation.persisted() (Impl. still missing) in analogy to ChangeLog.persisted.
- ItemImpl.refresh behaves according to CacheBehaviour flag.
- NodeState: fix classcastexception when accessing state from propertiesInAttic
- ItemState: rename 'refresh()' to 'reload()
- ItemState: move code common to PropertyState and NodeState to ItemState
- ItemState: rename 'reset' to 'merge'
- add common interface ChildItemEntry
- SessionItemStateManager: avoid traversing twice during 'undo'

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@477095 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.operation.RemoveVersion;
+import org.apache.commons.collections.iterators.IteratorChain;
-import java.util.LinkedHashSet;
-        ChangeLog changeLog = getChangeLog(state);
+        ChangeLog changeLog = getChangeLog(state, true);
-        }
-        // remove operations just processed
-        transientStateMgr.disposeOperations(changeLog.getOperations());
-        // now its save to clear the changeLog
-        changeLog.reset();
+            // remove states and operations just processed from the transient ISM
+            transientStateMgr.dispose(changeLog);
+            // now its save to clear the changeLog
+            changeLog.reset();
+        }
-        // check if self contained
-        ChangeLog changeLog = new ChangeLog(itemState);
-        collectTransientStates(itemState, changeLog, false);
-        changeLog.checkIsSelfContained();
-        changeLog.collectOperations(transientStateMgr.getOperations());
+        ChangeLog changeLog = getChangeLog(itemState, false);
+        if (!changeLog.isEmpty()) {
+            // now do it for real
+            // TODO: check if states are reverted in correct order
+            Iterator[] its = new Iterator[] {changeLog.addedStates(), changeLog.deletedStates(), changeLog.modifiedStates()};
+            IteratorChain chain = new IteratorChain(its);
+            while (chain.hasNext()) {
+                ItemState state = (ItemState) chain.next();
+                state.revert();
+            }
-        // now do it for real
-        Set affectedItemStates = new HashSet();
-        itemState.revert(affectedItemStates);
-
-        // remove all canceled operations
-        transientStateMgr.disposeOperations(changeLog.getOperations());
+            // remove transient states and related operations from the t-statemanager
+            transientStateMgr.dispose(changeLog);
+            changeLog.reset();
+        }
+     * @param throwOnStale Throws StaleItemStateException if either the given
+     * <code>ItemState</code> or any of its decendants is stale and the flag is true.
-     * @throws StaleItemStateException
-     * @throws ItemStateException
-     */
-    private ChangeLog getChangeLog(ItemState itemState) throws StaleItemStateException, ItemStateException, ConstraintViolationException {
-        // build changelog for affected and decendant states only
-        ChangeLog changeLog = new ChangeLog(itemState);
-        collectTransientStates(itemState, changeLog, true);
-        changeLog.collectOperations(transientStateMgr.getOperations());
-
-        changeLog.checkIsSelfContained();
-        return changeLog;
-    }
-
-    /**
-     * Builds a <code>ChangeLog</code> of transient (i.e. new, modified or
-     * deleted) item states that are within the scope of <code>state</code>.
-     *
-     *                                 encountered while traversing the state
-     *                                 hierarchy. The <code>changeLog</code>
-     *                                 might have been populated with some
-     *                                 transient item states. A client should
-     *                                 therefore not reuse the <code>changeLog</code>
-     *                                 if such an exception is thrown.
+     * encountered while traversing the state hierarchy. The <code>changeLog</code>
+     * might have been populated with some transient item states. A client should
+     * therefore not reuse the <code>changeLog</code> if such an exception is thrown.
-    private void collectTransientStates(ItemState state, ChangeLog changeLog, boolean throwOnStale)
-            throws StaleItemStateException, ItemStateException {
+    private ChangeLog getChangeLog(ItemState itemState, boolean throwOnStale) throws StaleItemStateException, ItemStateException, ConstraintViolationException {
+        // build changelog for affected and decendant states only
+        ChangeLog changeLog = new ChangeLog(itemState);
-        if (state.getStatus() == Status.NEW) {
-            String msg = LogUtil.safeGetJCRPath(state, nsResolver) + ": cannot save a new item.";
+        if (itemState.getStatus() == Status.NEW) {
+            String msg = "Cannot save an item with status NEW (" +LogUtil.safeGetJCRPath(itemState, nsResolver)+ ").";
-
-        if (throwOnStale && Status.isStale(state.getStatus())) {
-            String msg = LogUtil.safeGetJCRPath(state, nsResolver) + ": the item cannot be saved because it has been modified/removed externally.";
+        if (throwOnStale && Status.isStale(itemState.getStatus())) {
+            String msg =  "Attempt to save an item, that has been externally modified (" +LogUtil.safeGetJCRPath(itemState, nsResolver)+ ").";
+        // collect transient/stale states that should be persisted or reverted
+        itemState.collectStates(changeLog, throwOnStale);
-        // Set of transient states that should be persisted
-        Set transientStates = new LinkedHashSet();
-        state.collectTransientStates(transientStates);
-
-        for (Iterator it = transientStates.iterator(); it.hasNext();) {
-            ItemState transientState = (ItemState) it.next();
-            // fail-fast test: check status of transient state
-            switch (transientState.getStatus()) {
-                case Status.NEW:
-                    changeLog.added(transientState);
-                    break;
-                case Status.EXISTING_MODIFIED:
-                    changeLog.modified(transientState);
-                    break;
-                case Status.EXISTING_REMOVED:
-                    changeLog.deleted(transientState);
-                    break;
-                case Status.STALE_MODIFIED:
-                    if (throwOnStale) {
-                        String msg = transientState.getId() + ": the item cannot be saved because it has been modified externally.";
-                        log.debug(msg);
-                        throw new StaleItemStateException(msg);
-                    } else {
-                        changeLog.modified(transientState);
-                    }
-                case Status.STALE_DESTROYED:
-                    if (throwOnStale) {
-                        String msg = transientState.getId() + ": the item cannot be saved because it has been deleted externally.";
-                        log.debug(msg);
-                        throw new StaleItemStateException(msg);
-                    }
-                default:
-                    log.debug("unexpected state status (" + transientState.getStatus() + ")");
-                    // ignore
-                    break;
-            }
-        }
+        changeLog.collectOperations(transientStateMgr.getOperations());
+        changeLog.checkIsSelfContained();
+        return changeLog;
+    public void visit(RemoveVersion operation) throws VersionException, AccessDeniedException, ReferentialIntegrityException, RepositoryException {
+        throw new UnsupportedOperationException("Internal error: RemoveVersion cannot be handled by session ItemStateManager.");
+    }
+
-        // recursively remove the complete tree including the given node state.
+        // recursively remove the given state and all child states.
+            // TODO: defaults???

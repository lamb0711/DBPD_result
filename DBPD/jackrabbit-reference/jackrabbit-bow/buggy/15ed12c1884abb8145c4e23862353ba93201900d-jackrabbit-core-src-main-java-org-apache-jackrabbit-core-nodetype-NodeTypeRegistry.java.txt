JCR-726: Improve NodeTypeRegistry.effectiveNodeType()


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@502223 13f79535-47bb-0310-9956-ffa450edef68

+import EDU.oswego.cs.dl.util.concurrent.ConcurrentReaderHashMap;
+import org.apache.jackrabbit.core.cluster.NodeTypeEventChannel;
+import org.apache.jackrabbit.core.cluster.NodeTypeEventListener;
-import org.apache.jackrabbit.core.cluster.NodeTypeEventChannel;
-import org.apache.jackrabbit.core.cluster.NodeTypeEventListener;
-import javax.jcr.NamespaceRegistry;
-import javax.jcr.PropertyType;
-import javax.jcr.RepositoryException;
-import javax.jcr.nodetype.ConstraintViolationException;
-import javax.jcr.nodetype.NoSuchNodeTypeException;
-import javax.jcr.version.OnParentVersionAction;
-import java.util.ArrayList;
-import EDU.oswego.cs.dl.util.concurrent.ConcurrentReaderHashMap;
+import javax.jcr.NamespaceRegistry;
+import javax.jcr.PropertyType;
+import javax.jcr.RepositoryException;
+import javax.jcr.nodetype.ConstraintViolationException;
+import javax.jcr.nodetype.NoSuchNodeTypeException;
+import javax.jcr.version.OnParentVersionAction;
-    private final EffectiveNodeTypeCache entCache;
+    private EffectiveNodeTypeCache entCache;
-     * @throws InvalidNodeTypeDefException
-     * @throws RepositoryException
+     * @throws InvalidNodeTypeDefException if the given node type definition is invalid.
+     * @throws RepositoryException if a repository error occurs.
-     * @throws InvalidNodeTypeDefException
-     * @throws RepositoryException
+     * @throws InvalidNodeTypeDefException if the given node type definition is invalid.
+     * @throws RepositoryException if a repository error occurs.
-                msg.append(ntName
-                        + " can not be removed because the following node types depend on it: ");
+                msg.append(ntName).append(" can not be removed because the following node types depend on it: ");
-        entCache = new EffectiveNodeTypeCache();
+        // use the improved node type cache
+        // (replace with: entCache = new EffectiveNodeTypeCacheImpl();
+        // for the old one)
+        entCache = new BitsetENTCacheImpl();
-        EffectiveNodeType ent = entCache.get(new QName[]{ntName});
+        EffectiveNodeTypeCache.Key key = entCache.getKey(new QName[]{ntName});
+        EffectiveNodeType ent = entCache.get(key);
-     * @return
+     * @return the desired effective node type
-        EffectiveNodeTypeCache.WeightedKey key =
-                new EffectiveNodeTypeCache.WeightedKey(ntNames);
+        EffectiveNodeTypeCache.Key key = entCache.getKey(ntNames);
+        EffectiveNodeTypeCache.Key requested = key;
-            ArrayList tmpResults = new ArrayList();
-                // check if we've already built this aggregate
-                if (entCache.contains(key)) {
-                    tmpResults.add(entCache.get(key));
-                    // subtract the result from the temporary key
-                    // (which is 'empty' now)
-                    key = key.subtract(key);
-                    break;
-                }
-                /**
-                 * walk list of existing aggregates sorted by 'weight' of
-                 * aggregate (i.e. the cost of building it)
-                 */
-                boolean foundSubResult = false;
-                Iterator iter = entCache.keyIterator();
-                while (iter.hasNext()) {
-                    EffectiveNodeTypeCache.WeightedKey k =
-                            (EffectiveNodeTypeCache.WeightedKey) iter.next();
-                    /**
-                     * check if the existing aggregate is a 'subset' of the one
-                     * we're looking for
-                     */
-                    if (key.contains(k)) {
-                        tmpResults.add(entCache.get(k));
-                        // subtract the result from the temporary key
-                        key = key.subtract(k);
-                        foundSubResult = true;
-                        break;
+                // find the (sub) key that matches the current key the best
+                EffectiveNodeTypeCache.Key subKey = entCache.findBest(key);
+                if (subKey != null) {
+                    EffectiveNodeType ent = entCache.get(subKey);
+                    if (result == null) {
+                        result = ent;
+                    } else {
+                        result = result.merge(ent);
+                        // store intermediate result
+                        entCache.put(result);
-                }
-                if (!foundSubResult) {
+                    // subtract the result from the temporary key
+                    key = key.subtract(subKey);
+                } else {
-                    // add aggregate of remaining node types to result list
-                    tmpResults.add(result);
-            // merge the sub-aggregates into new effective node type
-            for (int i = 0; i < tmpResults.size(); i++) {
-                if (result == null) {
-                    result = (EffectiveNodeType) tmpResults.get(i);
-                } else {
-                    result = result.merge((EffectiveNodeType) tmpResults.get(i));
-                    // store intermediate result
-                    entCache.put(result);
-                }
-            }
+        }
+        // also put the requested key, since the merge could have removed some
+        // the redundant nodetypes
+        if (!entCache.contains(requested)) {
+            entCache.put(requested, result);
-                    validateNodeTypeDef(ntd, tmpENTCache, tmpNTDefCache, nsReg, lenient);
+                    validateNodeTypeDef(ntd, tmpENTCache, tmpNTDefCache, nsReg,
+                            lenient);
-        // since no exception was thrown so far the definitions are assumed to be valid
+        // since no exception was thrown so far the definitions are assumed to
+        // be valid
-        for (Iterator it = tmpENTCache.keyIterator(); it.hasNext(); ) {
-            EffectiveNodeTypeCache.WeightedKey k =
-                    (EffectiveNodeTypeCache.WeightedKey) it.next();
-            if (!entCache.contains(k)) {
-                entCache.put(tmpENTCache.get(k));
-            }
-        }
+        entCache = tmpENTCache;
-        /**
-         * remove all affected effective node types from aggregates cache
-         * (copy keys first to prevent ConcurrentModificationException)
-         */
-        ArrayList keys = new ArrayList(entCache.keySet());
-        for (Iterator keysIter = keys.iterator(); keysIter.hasNext();) {
-            EffectiveNodeTypeCache.WeightedKey k =
-                    (EffectiveNodeTypeCache.WeightedKey) keysIter.next();
-            EffectiveNodeType ent = entCache.get(k);
-            if (ent.includesNodeType(name)) {
-                entCache.remove(k);
-            }
-        }
+        entCache.invalidate(name);

JCR-2425: Session.save() and Session.refresh(boolean) rely on accessibility of the root node

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@887279 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.LinkedList;
-import javax.jcr.nodetype.NoSuchNodeTypeException;
-import org.apache.jackrabbit.core.nodetype.NodeTypeConflictException;
+import org.apache.jackrabbit.spi.Path;
+import org.apache.jackrabbit.spi.PathFactory;
+import org.apache.jackrabbit.spi.commons.name.PathFactoryImpl;
-     * <code>parentId</code> itself (if there is such)                                                                            not be included.
+     * <code>parentId</code> itself (if there is such) will not be included.
-            Iterator iter = transientStore.values().iterator();
-            while (iter.hasNext()) {
-                ItemState state = (ItemState) iter.next();
+            for (ItemState state : transientStore.values()) {
+     * Returns the id of the root of the minimal subtree including all
+     * transient states.
+     *
+     * @return id of nearest common ancestor of all transient states or null
+     *         if there's no transient state.
+     * @throws RepositoryException if an error occurs
+     */
+    public NodeId getIdOfRootTransientNodeState() throws RepositoryException {
+        if (transientStore.isEmpty()) {
+            return null;
+        }
+
+        // short cut
+        if (transientStore.contains(hierMgr.getRootNodeId())) {
+            return hierMgr.getRootNodeId();
+        }
+
+        // the nearest common ancestor of all transient states
+        // must be either
+        // a) a node state with STATUS_EXISTING_MODIFIED, or
+        // b) the parent node of a property state with STATUS_EXISTING_MODIFIED 
+
+        // collect all candidates based on above criteria
+        Collection<NodeId> candidateIds = new LinkedList<NodeId>();
+        try {
+            HierarchyManager hierMgr = getHierarchyMgr();
+            for (ItemState state : transientStore.values()) {
+                if (state.getStatus() == ItemState.STATUS_EXISTING_MODIFIED) {
+                    NodeId nodeId;
+                    if (state.isNode()) {
+                        nodeId = (NodeId) state.getId();
+                    } else {
+                        nodeId = state.getParentId();
+                    }
+                    // remove any descendant candidates
+                    boolean skip = false;
+                    for (NodeId id : candidateIds) {
+                        if (nodeId.equals(id) || hierMgr.isAncestor(id, nodeId)) {
+                            // already a candidate or a descendant thereof
+                            // => skip
+                            skip = true;
+                            break;
+                        }
+                        if (hierMgr.isAncestor(nodeId, id)) {
+                            // candidate is a descendant => remove
+                            candidateIds.remove(id);
+                        }
+                    }
+                    if (!skip) {
+                        // add to candidates
+                        candidateIds.add(nodeId);
+                    }
+                }
+            }
+
+            if (candidateIds.size() == 1) {
+                return candidateIds.iterator().next();
+            }
+
+            // pick (any) candidate with shortest path to start with
+            NodeId candidateId = null;
+            for (NodeId id : candidateIds) {
+                if (candidateId == null) {
+                    candidateId = id;
+                } else {
+                    if (hierMgr.getDepth(id) < hierMgr.getDepth(candidateId)) {
+                        candidateId = id;
+                    }
+                }
+            }
+
+            // starting with this candidate closest to root, find first parent
+            // which is an ancestor of all candidates
+            NodeState state = (NodeState) getItemState(candidateId);
+            NodeId parentId = state.getParentId();
+            boolean continueWithParent = false;
+            while (parentId != null) {
+                for (NodeId id : candidateIds) {
+                    if (hierMgr.getRelativeDepth(parentId, id) == -1) {
+                        continueWithParent = true;
+                        break;
+                    }
+                }
+                if (continueWithParent) {
+                    state = (NodeState) getItemState(candidateId);
+                    parentId = state.getParentId();
+                    continueWithParent = false;
+                } else {
+                    break;
+                }
+            }
+            return parentId;
+        } catch (ItemStateException e) {
+            throw new RepositoryException("failed to determine common root of transient changes", e);
+        }
+    }
+
+    /**

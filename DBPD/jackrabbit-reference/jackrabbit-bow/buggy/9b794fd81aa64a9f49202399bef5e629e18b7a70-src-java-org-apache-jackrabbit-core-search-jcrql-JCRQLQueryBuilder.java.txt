Added SQL and XPath query implementation. The implementation is not complete yet. Only basic operations are supported.
Also added postGoals to the maven.xml to generate the parser classes for SQL XPath.

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@123135 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.log4j.Logger;
+import java.util.Arrays;
+    private static final Logger log = Logger.getLogger(JCRQLQueryBuilder.class);
+
+    /**
+     * Match path exact
+     */
+    public static final int TYPE_EXACT = 1;
+
+    /**
+     * Match child nodes of path
+     */
+    public static final int TYPE_CHILDREN = 2;
+
+    /**
+     * Match descendant nodes or self of path
+     */
+    public static final int TYPE_DESCENDANT_SELF = 3;
+
+    private AndQueryNode constraintNode = new AndQueryNode(null);
+
+        root.setLocationNode(new PathQueryNode(root));
-        node.childrenAccept(this, root);
+        node.childrenAccept(this, root);
+
+        // use //* if no path has been set
+        PathQueryNode pathNode = root.getLocationNode();
+        if (pathNode.getPathSteps().length == 0) {
+            pathNode.addPathStep(new LocationStepQueryNode(pathNode, "", false));
+            pathNode.addPathStep(new LocationStepQueryNode(pathNode, null, true));
+        }
+
+        // attach constraint to last path step
+        LocationStepQueryNode[] steps = pathNode.getPathSteps();
+        steps[steps.length - 1].addPredicate(constraintNode);
+
-        QueryRootNode root = (QueryRootNode) data;
-        // add node type query to parent
-        node.childrenAccept(this, root.getConstraintNode());
+        node.childrenAccept(this, constraintNode);
-        root.setLocationNode(new PathQueryNode(root, node.getStringLocation(),
-                node.getType()));
+        PathQueryNode pathNode = root.getLocationNode();
+
+        String path = node.getStringLocation();
+        String[] names = path.split("/");
+        for (int i = 0; i < names.length; i++) {
+            if (names[i].length() == 0) {
+                if (i == 0) {
+                    // root
+                    pathNode.addPathStep(new LocationStepQueryNode(pathNode, "", false));
+                } else {
+                    log.error("Internal error: descendant-or-self axis not allowed here");
+                }
+            } else {
+                int idx = names[i].indexOf('[');
+                String name = null;
+                int index = 0;
+                if (idx > -1) {
+                    // contains index
+                    name = names[i].substring(0, idx);
+                    String suffix = names[i].substring(idx);
+                    try {
+                        index = Integer.parseInt(suffix.substring(1, suffix.length() - 1));
+                    } catch (NumberFormatException e) {
+                        log.warn("Unable to parse index for path element: " + names[i]);
+                    }
+                } else {
+                    // no index
+                    name = names[i];
+                }
+                if (name.equals("%") || name.equals("*")) {
+                    name = null;
+                }
+                LocationStepQueryNode step = new LocationStepQueryNode(pathNode, name, false);
+                if (index > 0) {
+                    step.setIndex(index);
+                }
+                pathNode.addPathStep(step);
+            }
+        }
+
+        if (node.getType() == TYPE_CHILDREN) {
+            pathNode.addPathStep(new LocationStepQueryNode(pathNode, null, false));
+        } else if (node.getType() == TYPE_DESCENDANT_SELF) {
+            //LocationStepQueryNode[] steps = pathNode.getPathSteps();
+            //steps[steps.length - 1].setIncludeDescendants(true);
+            pathNode.addPathStep(new LocationStepQueryNode(pathNode, null, true));
+        }
+
-        QueryRootNode root = (QueryRootNode) data;
-        return node.childrenAccept(this, root.getConstraintNode());
+        return node.childrenAccept(this, constraintNode);
-        if (type == Constants.TYPE_DATE) {
+        if (type == Constants.TYPE_TIMESTAMP) {
-        QueryRootNode root = (QueryRootNode) data;
-        root.setTextsearchNode(new TextsearchQueryNode(root, node.getQuery()));
-        return root;
+        constraintNode.addOperand(new TextsearchQueryNode(constraintNode, node.getQuery()));
+        return data;
-        root.setOrderNode(new OrderQueryNode(root, node.getProperties(), node.isAscending()));
+        String[] props = node.getProperties();
+        boolean[] orders = new boolean[props.length];
+        Arrays.fill(orders, node.isAscending());
+        root.setOrderNode(new OrderQueryNode(root, props, orders));

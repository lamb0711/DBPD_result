JCR-1365: Query path constraints like foo//*/bar do not scale
- more performance improvements

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@629453 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.Sort;
+import org.apache.jackrabbit.core.SessionImpl;
+import javax.jcr.Node;
+import javax.jcr.RepositoryException;
+import java.util.Map;
+import java.util.TreeMap;
+import java.util.Iterator;
-class DescendantSelfAxisQuery extends Query {
+class DescendantSelfAxisQuery extends Query implements JackrabbitQuery {
+     * Returns the minimal levels required between context and sub nodes for a
+     * sub node to match.
+     * <ul>
+     * <li><code>0</code>: a sub node <code>S</code> matches if it is a context
+     * node or one of the ancestors of <code>S</code> is a context node.</li>
+     * <li><code>1</code>: a sub node <code>S</code> matches if one of the
+     * ancestors of <code>S</code> is a context node.</li>
+     * <li><code>n</code>: a sub node <code>S</code> matches if
+     * <code>S.getAncestor(S.getDepth() - n)</code> is a context node.</li>
+     * </ul>
+     *
-    //------------------------< DescendantSelfAxisWeight >--------------------------
+    //------------------------< JackrabbitQuery >-------------------------------
+
+    /**
+     * {@inheritDoc}
+     */
+    public QueryHits execute(final JackrabbitIndexSearcher searcher,
+                             final SessionImpl session,
+                             final Sort sort) throws IOException {
+        if (sort.getSort().length == 0 && subQueryMatchesAll()) {
+            // maps path String to NodeId
+            Map startingPoints = new TreeMap();
+            QueryHits result = searcher.execute(getContextQuery(), sort);
+            try {
+                // minLevels 0 and 1 are handled with a series of
+                // NodeTraversingQueryHits directly on result. For minLevels >= 2
+                // intermediate ChildNodesQueryHits are required.
+                for (int i = 2; i <= getMinLevels(); i++) {
+                    result = new ChildNodesQueryHits(result, session);
+                }
+
+                ScoreNode sn;
+                try {
+                    while ((sn = result.nextScoreNode()) != null) {
+                        Node node = session.getNodeById(sn.getNodeId());
+                        startingPoints.put(node.getPath(), sn);
+                    }
+                } catch (RepositoryException e) {
+                    IOException ex = new IOException(e.getMessage());
+                    ex.initCause(e);
+                    throw ex;
+                }
+            } finally {
+                result.close();
+            }
+
+            // prune overlapping starting points
+            String previousPath = null;
+            for (Iterator it = startingPoints.keySet().iterator(); it.hasNext(); ) {
+                String path = (String) it.next();
+                // if the previous path is a prefix of this path then the
+                // current path is obsolete
+                if (previousPath != null && path.startsWith(previousPath)) {
+                    it.remove();
+                } else {
+                    previousPath = path;
+                }
+            }
+
+            final Iterator scoreNodes = startingPoints.values().iterator();
+            return new AbstractQueryHits() {
+
+                private NodeTraversingQueryHits currentTraversal;
+
+                {
+                    fetchNextTraversal();
+                }
+
+                public void close() throws IOException {
+                    if (currentTraversal != null) {
+                        currentTraversal.close();
+                    }
+                }
+
+                public ScoreNode nextScoreNode() throws IOException {
+                    while (currentTraversal != null) {
+                        ScoreNode sn = currentTraversal.nextScoreNode();
+                        if (sn != null) {
+                            return sn;
+                        } else {
+                            fetchNextTraversal();
+                        }
+                    }
+                    // if we get here there are no more score nodes
+                    return null;
+                }
+
+                private void fetchNextTraversal() throws IOException {
+                    if (currentTraversal != null) {
+                        currentTraversal.close();
+                    }
+                    if (scoreNodes.hasNext()) {
+                        ScoreNode sn = (ScoreNode) scoreNodes.next();
+                        try {
+                            Node node = session.getNodeById(sn.getNodeId());
+                            currentTraversal = new NodeTraversingQueryHits(node,
+                                    getMinLevels() == 0);
+                        } catch (RepositoryException e) {
+                            IOException ex = new IOException(e.getMessage());
+                            ex.initCause(e);
+                            throw ex;
+                        }
+                    } else {
+                        currentTraversal = null;
+                    }
+                }
+            };
+        } else {
+            return null;
+        }
+    }
+
+    //--------------------< DescendantSelfAxisWeight >--------------------------

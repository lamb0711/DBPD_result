JCR-255 Workspace operations (copy/clone) do not handle references correctly

consolidated code that maintains/enforces referential integrity (RI):
SharedItemStateManager.store(ChangeLog) is now the only place where
RI is maintained and enforced

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@326916 13f79535-47bb-0310-9956-ffa450edef68

-     * @throws RepositoryException
+     * @throws RepositoryException if an error occurs
-        // existing mixin's
-        HashSet set = new HashSet(((NodeState) state).getMixinTypeNames());
+        // mixin types
+        Set set = ((NodeState) state).getMixinTypeNames();
+        QName[] types = new QName[set.size() + 1];
+        set.toArray(types);
-        set.add(primaryTypeName);
+        types[types.length - 1] = primaryTypeName;
-            return ntReg.getEffectiveNodeType((QName[]) set.toArray(new QName[set.size()]));
+            return ntReg.getEffectiveNodeType(types);
-            String msg = "internal error: failed to build effective node type for node " + safeGetJCRPath();
+            String msg = "internal error: failed to build effective node type for node "
+                    + safeGetJCRPath();
-     * Same as {@link Node#addMixin(String)}, but takes a <code>QName</code>
-     * instad of a <code>String</code>.
+     * Same as {@link Node#addMixin(String)} except that it takes a
+     * <code>QName</code> instead of a <code>String</code>.
-     * Same as {@link Node#removeMixin(String)}, but takes a <code>QName</code>
-     * instad of a <code>String</code>.
+     * Same as {@link Node#removeMixin(String)} except that it takes a
+     * <code>QName</code> instead of a <code>String</code>.
-     * Same as {@link Node#isNodeType(String)}, but takes a <code>QName</code>
-     * instad of a <code>String</code>.
+     * Same as {@link Node#isNodeType(String)} except that it takes a
+     * <code>QName</code> instead of a <code>String</code>.
-
-        // build effective node type representing primary type incl. mixin's
-        // and check whether it includes the specified node type
-        NodeTypeRegistry ntReg = session.getNodeTypeManager().getNodeTypeRegistry();
-        // mixin's
-        Set typeSet = ((NodeState) state).getMixinTypeNames();
-        QName[] types = new QName[typeSet.size() + 1];
-        typeSet.toArray(types);
-        // primary type
-        types[types.length - 1] = primaryTypeName;
-
-        try {
-            EffectiveNodeType ent =
-                    ntReg.getEffectiveNodeType(types);
-            return ent.includesNodeType(ntName);
-        } catch (NodeTypeConflictException ntce) {
-            String msg = "internal error: failed to build effective node type of "
-                    + Arrays.asList(types);
-            log.debug(msg);
-            throw new RepositoryException(msg, ntce);
-        }
+        // check effective node type
+        return getEffectiveNodeType().includesNodeType(ntName);
-            NodeReferences refs = getOrCreateNodeReferences(targetId);
-            // refs.getReferences() returns a list of PropertyId's
-            List idList = refs.getReferences();
-            return new LazyItemIterator(itemMgr, idList);
+            if (stateMgr.hasNodeReferences(targetId)) {
+                NodeReferences refs = stateMgr.getNodeReferences(targetId);
+                // refs.getReferences() returns a list of PropertyId's
+                List idList = refs.getReferences();
+                return new LazyItemIterator(itemMgr, idList);
+            } else {
+                // there are no references, return empty iterator
+                return IteratorHelper.EMPTY;
+            }

reverting commits r884535 & r884562

there are still isssues/failing test cases (regression of JCR-2170)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@884602 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Map;
-import java.util.HashMap;
-import org.apache.jackrabbit.core.state.NoSuchItemStateException;
-        NodeState thisState = (NodeState) getOrCreateTransientItemState();
-
-        // collect information about properties and nodes which require
-        // further action as a result of the mixin removal;
-        // we need to do this *before* actually changing the assigned the mixin types,
-        // otherwise we wouldn't be able to retrieve the current definition
-        // of an item.
-        Map<PropertyId, PropertyDefinition> affectedProps = new HashMap<PropertyId, PropertyDefinition>();
-        Map<ChildNodeEntry, NodeDefinition> affectedNodes = new HashMap<ChildNodeEntry, NodeDefinition>();
-        try {
-            Set<Name> names = thisState.getPropertyNames();
-            for (Name propName : names) {
-                PropertyId propId = new PropertyId(thisState.getNodeId(), propName);
-                PropertyState propState = (PropertyState) stateMgr.getItemState(propId);
-                PropertyDefinition oldDef = itemMgr.getDefinition(propState);
-                // check if property has been defined by mixin type (or one of its supertypes)
-                NodeTypeImpl declaringNT = (NodeTypeImpl) oldDef.getDeclaringNodeType();
-                if (!entResulting.includesNodeType(declaringNT.getQName())) {
-                    // the resulting effective node type doesn't include the
-                    // node type that declared this property
-                    affectedProps.put(propId, oldDef);
-                }
-            }
-
-            List<ChildNodeEntry> entries = thisState.getChildNodeEntries();
-            for (ChildNodeEntry entry : entries) {
-                NodeState nodeState = (NodeState) stateMgr.getItemState(entry.getId());
-                NodeDefinition oldDef = itemMgr.getDefinition(nodeState);
-                // check if node has been defined by mixin type (or one of its supertypes)
-                NodeTypeImpl declaringNT = (NodeTypeImpl) oldDef.getDeclaringNodeType();
-                if (!entResulting.includesNodeType(declaringNT.getQName())) {
-                    // the resulting effective node type doesn't include the
-                    // node type that declared this child node
-                    affectedNodes.put(entry, oldDef);
-                }
-            }
-        } catch (ItemStateException e) {
-            throw new RepositoryException("Internal Error: Failed to determine effect of removing mixin " + session.getJCRName(mixinName), e);
-        }
+        NodeState thisState = (NodeState) getOrCreateTransientItemState();
+
-        // process affected nodes & properties:
-        // 1. try to redefine item based on the resulting
-        //    new effective node type (see JCR-2130)
-        // 2. remove item if 1. fails
+        // shortcut
+        if (mixin.getChildNodeDefinitions().length == 0
+                && mixin.getPropertyDefinitions().length == 0) {
+            // the node type has neither property nor child node definitions,
+            // i.e. we're done
+            return;
+        }
+
+        // walk through properties and child nodes and remove those that aren't
+        // accomodated by the resulting new effective node type (see JCR-2130)
-            for (PropertyId id : affectedProps.keySet()) {
-                PropertyImpl prop = (PropertyImpl) itemMgr.getItem(id);
-                PropertyDefinition oldDef = affectedProps.get(id);
+            // use temp set to avoid ConcurrentModificationException
+            HashSet<Name> set = new HashSet<Name>(thisState.getPropertyNames());
+            for (Name propName : set) {
+                PropertyState propState = (PropertyState) stateMgr.getItemState(new PropertyId(thisState.getNodeId(), propName));
+                // check if property has been defined by mixin type (or one of its supertypes)
+                PropertyDefinition def = itemMgr.getDefinition(propState);
+                NodeTypeImpl declaringNT = (NodeTypeImpl) def.getDeclaringNodeType();
+                if (!entResulting.includesNodeType(declaringNT.getQName())) {
+                    // the resulting effective node type doesn't include the
+                    // node type that declared this property
-                if (oldDef.isProtected()) {
-                    // remove 'orphaned' protected properties immediately
-                    removeChildProperty(id.getName());
-                    continue;
-                }
-                // try to find new applicable definition first and
-                // redefine property if possible (JCR-2130)
-                try {
-                    PropertyDefinitionImpl newDef = getApplicablePropertyDefinition(
-                            id.getName(), prop.getType(),
-                            oldDef.isMultiple(), false);
-                    if (newDef.getRequiredType() != PropertyType.UNDEFINED
-                            && newDef.getRequiredType() != prop.getType()) {
-                        // value conversion required
-                        if (oldDef.isMultiple()) {
-                            // convert value
-                            Value[] values =
-                                    ValueHelper.convert(
-                                            prop.getValues(),
-                                            newDef.getRequiredType(),
-                                            session.getValueFactory());
-                            // redefine property
-                            prop.onRedefine(newDef.unwrap());
-                            // set converted values
-                            prop.setValue(values);
-                        } else {
-                            // convert value
-                            Value value =
-                                    ValueHelper.convert(
-                                            prop.getValue(),
-                                            newDef.getRequiredType(),
-                                            session.getValueFactory());
-                            // redefine property
-                            prop.onRedefine(newDef.unwrap());
-                            // set converted values
-                            prop.setValue(value);
+                    // try to find new applicable definition first and
+                    // redefine property if possible (JCR-2130)
+                    try {
+                        PropertyImpl prop = (PropertyImpl) itemMgr.getItem(propState.getId());
+                        if (prop.getDefinition().isProtected()) {
+                            // remove 'orphaned' protected properties immediately
+                            removeChildProperty(propName);
+                            continue;
-                    } else {
-                        // redefine property
-                        prop.onRedefine(newDef.unwrap());
+                        PropertyDefinitionImpl pdi = getApplicablePropertyDefinition(
+                                propName, propState.getType(),
+                                propState.isMultiValued(), false);
+                        if (pdi.getRequiredType() != PropertyType.UNDEFINED
+                                && pdi.getRequiredType() != propState.getType()) {
+                            // value conversion required
+                            if (propState.isMultiValued()) {
+                                // convert value
+                                Value[] values =
+                                        ValueHelper.convert(
+                                                prop.getValues(),
+                                                pdi.getRequiredType(),
+                                                session.getValueFactory());
+                                // redefine property
+                                prop.onRedefine(pdi.unwrap());
+                                // set converted values
+                                prop.setValue(values);
+                            } else {
+                                // convert value
+                                Value value =
+                                        ValueHelper.convert(
+                                                prop.getValue(),
+                                                pdi.getRequiredType(),
+                                                session.getValueFactory());
+                                // redefine property
+                                prop.onRedefine(pdi.unwrap());
+                                // set converted values
+                                prop.setValue(value);
+                            }
+                        } else {
+                            // redefine property
+                            prop.onRedefine(pdi.unwrap());
+                        }
+                    } catch (ValueFormatException vfe) {
+                        // value conversion failed, remove it
+                        removeChildProperty(propName);
+                    } catch (ConstraintViolationException cve) {
+                        // no suitable definition found for this property,
+                        // remove it
+                        removeChildProperty(propName);
-                } catch (ValueFormatException vfe) {
-                    // value conversion failed, remove it
-                    removeChildProperty(id.getName());
-                } catch (ConstraintViolationException cve) {
-                    // no suitable definition found for this property,
-                    // remove it
-                    removeChildProperty(id.getName());
-
-            for (ChildNodeEntry entry : affectedNodes.keySet()) {
+            // use temp array to avoid ConcurrentModificationException
+            ArrayList<ChildNodeEntry> list = new ArrayList<ChildNodeEntry>(thisState.getChildNodeEntries());
+            // start from tail to avoid problems with same-name siblings
+            for (int i = list.size() - 1; i >= 0; i--) {
+                ChildNodeEntry entry = list.get(i);
-                NodeImpl node = (NodeImpl) itemMgr.getItem(entry.getId());
-                NodeDefinition oldDef = affectedNodes.get(entry);
+                NodeDefinition def = itemMgr.getDefinition(nodeState);
+                // check if node has been defined by mixin type (or one of its supertypes)
+                NodeTypeImpl declaringNT = (NodeTypeImpl) def.getDeclaringNodeType();
+                if (!entResulting.includesNodeType(declaringNT.getQName())) {
+                    // the resulting effective node type doesn't include the
+                    // node type that declared this child node
-                if (oldDef.isProtected()) {
-                    // remove 'orphaned' protected child node immediately
-                    removeChildNode(entry.getName(), entry.getIndex());
-                    continue;
-                }
-
-                // try to find new applicable definition first and
-                // redefine node if possible (JCR-2130)
-                try {
-                    NodeDefinitionImpl newDef = getApplicableChildNodeDefinition(
-                            entry.getName(),
-                            nodeState.getNodeTypeName());
-                    // redefine node
-                    node.onRedefine(newDef.unwrap());
-                } catch (ConstraintViolationException cve) {
-                    // no suitable definition found for this child node,
-                    // remove it
-                    removeChildNode(entry.getName(), entry.getIndex());
+                    try {
+                        NodeImpl node = (NodeImpl) itemMgr.getItem(nodeState.getId());
+                        if (node.getDefinition().isProtected()) {
+                            // remove 'orphaned' protected child node immediately
+                            removeChildNode(entry.getName(), entry.getIndex());
+                            continue;
+                        }
+                        NodeDefinitionImpl ndi = getApplicableChildNodeDefinition(
+                                entry.getName(),
+                                nodeState.getNodeTypeName());
+                        // redefine node
+                        node.onRedefine(ndi.unwrap());
+                    } catch (ConstraintViolationException cve) {
+                        // no suitable definition found for this child node,
+                        // remove it
+                        removeChildNode(entry.getName(), entry.getIndex());
+                    }
-            throw new RepositoryException("Failed to clean up child items defined by removed mixin " + session.getJCRName(mixinName), e);
+            throw new RepositoryException("Failed to clean up child items defined by removed mixin " + session.getJCRName(mixinName));
-                // TODO JCR-1914: revert any changes made so far
+                // TODO JCR-1914: revert changes made to jcr:mixinTypes

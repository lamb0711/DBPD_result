JCR-257: Use separate index for jcr:system tree

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@357961 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.query.QueryHandler;
+import org.apache.lucene.index.MultiReader;
+import java.util.HashSet;
+import java.util.Set;
+
+        Set excludedUUIDs = new HashSet();
+        if (context.getExcludedNodeUUID() != null) {
+            excludedUUIDs.add(context.getExcludedNodeUUID());
+        }
+
-                context.getItemStateManager(), context.getRootUUID());
+                context.getItemStateManager(), context.getRootUUID(), excludedUUIDs);
+        QueryHandler parentHandler = getContext().getParentHandler();
+        IndexReader parentReader = null;
+        if (parentHandler instanceof SearchIndex) {
+            parentReader = ((SearchIndex) parentHandler).index.getIndexReader();
+        }
+
+        if (parentReader != null) {
+            // todo FIXME not type safe
+            CachingMultiReader[] readers = {(CachingMultiReader) reader,
+                                            (CachingMultiReader) parentReader};
+            reader = new CombinedIndexReader(readers);
+        }
+
+    //----------------------------< internal >----------------------------------
+
+    /**
+     * Combines multiple {@link CachingMultiReader} into a <code>MultiReader</code>
+     * with {@link HierarchyResolver} support.
+     */
+    protected static final class CombinedIndexReader extends MultiReader implements HierarchyResolver {
+
+        /**
+         * The sub readers.
+         */
+        private CachingMultiReader[] subReaders;
+
+        /**
+         * Doc number starts for each sub reader
+         */
+        private int[] starts;
+
+        public CombinedIndexReader(CachingMultiReader[] indexReaders) throws IOException {
+            super(indexReaders);
+            this.subReaders = indexReaders;
+            this.starts = new int[subReaders.length + 1];
+
+            int maxDoc = 0;
+            for (int i = 0; i < subReaders.length; i++) {
+                starts[i] = maxDoc;
+                maxDoc += subReaders[i].maxDoc();
+            }
+            starts[subReaders.length] = maxDoc;
+        }
+
+        /**
+         * @inheritDoc
+         */
+        public int getParent(int n) throws IOException {
+            int i = readerIndex(n);
+            DocId id = subReaders[i].getParentDocId(n - starts[i]);
+            id = id.applyOffset(starts[i]);
+            return id.getDocumentNumber(this);
+        }
+
+        /**
+         * Returns the reader index for document <code>n</code>.
+         * Implementation copied from lucene MultiReader class.
+         *
+         * @param n document number.
+         * @return the reader index.
+         */
+        final private int readerIndex(int n) {
+            int lo = 0;                                      // search starts array
+            int hi = subReaders.length - 1;                  // for first element less
+
+            while (hi >= lo) {
+                int mid = (lo + hi) >> 1;
+                int midValue = starts[mid];
+                if (n < midValue) {
+                    hi = mid - 1;
+                } else if (n > midValue) {
+                    lo = mid + 1;
+                } else {                                      // found a match
+                    while (mid + 1 < subReaders.length && starts[mid + 1] == midValue) {
+                        mid++;                                  // scan to last match
+                    }
+                    return mid;
+                }
+            }
+            return hi;
+        }
+
+    }
+

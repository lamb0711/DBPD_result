JCR-131: simplifying internal data model (NodeState) by limiting a node to *one* parent



git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@191499 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.commons.collections.map.ReferenceMap;
-import org.apache.commons.collections.map.ReferenceMap;
-import java.util.List;
-import java.util.Iterator;
+import java.util.Iterator;
+import java.util.List;
-    private final ReferenceMap idCache = new ReferenceMap(
-            ReferenceMap.HARD, ReferenceMap.HARD);
+    private final ReferenceMap idCache = new ReferenceMap(ReferenceMap.HARD, ReferenceMap.HARD);
-     * Create a new instance of this class. This hierarchy manager will not
-     * check for item states that have been moved into attic space
+     * Create a new instance of this class.
+     *
-     * @param provider item state manager
-     * @param nsResolver namespace resolver
+     * @param provider     item state manager
+     * @param nsResolver   namespace resolver
-        this(rootNodeUUID, provider, nsResolver, null);
+        super(rootNodeUUID, provider, nsResolver);
+        upperLimit = DEFAULT_UPPER_LIMIT;
-    /**
-     * Create a new instance of this class.
-     * @param rootNodeUUID root node UUID
-     * @param provider item state manager
-     * @param nsResolver namespace resolver
-     * @param attic item state manager for states in the attic space
-     */
-    public CachingHierarchyManager(String rootNodeUUID,
-                                   ItemStateManager provider,
-                                   NamespaceResolver nsResolver,
-                                   ItemStateManager attic) {
-
-        super(rootNodeUUID, provider, nsResolver, attic);
-
-        this.upperLimit = DEFAULT_UPPER_LIMIT;
-    }
-
-    //-----------------------------------------------------< HierarchyManager >
-
+    //-------------------------------------------------< base class overrides >
-     *
-     * Check the item indicated inside our path cache first.
-     */
-    public NodeId[] listParents(ItemId id)
-            throws ItemNotFoundException, RepositoryException {
-
-        if (id.denotesNode()) {
-            PathMap.Element element = get(id);
-            if (element != null) {
-                PathMap.Element parent = element.getParent();
-                if (parent != null) {
-                    LRUEntry entry = (LRUEntry) element.get();
-                    if (entry != null) {
-                        return new NodeId[] { (NodeId) entry.getId() };
-                    }
-                }
-            }
-        }
-        return super.listParents(id);
-    }
-
-    /**
-     * {@inheritDoc}
-     *
-     * Check the path indicated inside our cache first.
-     */
-    public ItemId resolvePath(Path path)
-            throws PathNotFoundException, RepositoryException {
-
-        PathMap.Element element = map(path);
-        if (element == null) {
-            return super.resolvePath(path);
-        }
-        LRUEntry entry = (LRUEntry) element.get();
-        if (element.hasPath(path)) {
-            entry.touch();
-            return entry.getId();
-        }
-        return super.resolvePath(path, entry.getId(), element.getDepth() + 1);
-    }
-
-    /**
-     * {@inheritDoc}
-     *
+     * <p/>
-     *
-     * Overridden method simply checks whether we have an item matching the id
-     * and returns its path, otherwise calls base implementation.
-     */
-    public synchronized Path getPath(ItemId id)
-            throws ItemNotFoundException, RepositoryException {
-
-        if (id.denotesNode()) {
-            PathMap.Element element = get(id);
-            if (element != null) {
-                try {
-                    return element.getPath();
-                } catch (MalformedPathException mpe) {
-                    String msg = "Failed to build path of " + id;
-                    log.debug(msg);
-                    throw new RepositoryException(msg, mpe);
-                }
-            }
-        }
-        return super.getPath(id);
-    }
-
-    /**
-     * {@inheritDoc}
-     *
+     * <p/>
-    protected void getPath(Path.PathBuilder builder, ItemState state)
+    protected void buildPath(Path.PathBuilder builder, ItemState state)
-        super.getPath(builder, state);
+        super.buildPath(builder, state);
+    //-----------------------------------------------------< HierarchyManager >
+    /**
+     * {@inheritDoc}
+     * <p/>
+     * Check the path indicated inside our cache first.
+     */
+    public ItemId resolvePath(Path path)
+            throws PathNotFoundException, RepositoryException {
+
+        PathMap.Element element = map(path);
+        if (element == null) {
+            return super.resolvePath(path);
+        }
+        LRUEntry entry = (LRUEntry) element.get();
+        if (element.hasPath(path)) {
+            entry.touch();
+            return entry.getId();
+        }
+        return super.resolvePath(path, entry.getId(), element.getDepth() + 1);
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p/>
+     * Overridden method simply checks whether we have an item matching the id
+     * and returns its path, otherwise calls base implementation.
+     */
+    public synchronized Path getPath(ItemId id)
+            throws ItemNotFoundException, RepositoryException {
+
+        if (id.denotesNode()) {
+            PathMap.Element element = get(id);
+            if (element != null) {
+                try {
+                    return element.getPath();
+                } catch (MalformedPathException mpe) {
+                    String msg = "Failed to build path of " + id;
+                    log.debug(msg);
+                    throw new RepositoryException(msg, mpe);
+                }
+            }
+        }
+        return super.getPath(id);
+    }
+
-    /**
-     * {@inheritDoc}
-     */
-    public Path[] getAllPaths(ItemId id, boolean includeZombies)
-            throws ItemNotFoundException, RepositoryException {
-
-        if (!includeZombies) {
-            return new Path[] { getPath(id) };
-        }
-        return super.getAllPaths(id, includeZombies);
-    }
-
-     *        item state. To get the overlaid state, invoke
-     *        {@link ItemState#getOverlayedState()}
+     *                  item state. To get the overlaid state, invoke
+     *                  {@link ItemState#getOverlayedState()}
-        } catch(ItemNotFoundException e) {
+        } catch (ItemNotFoundException e) {
-        } catch(RepositoryException e) {
+        } catch (RepositoryException e) {
-     *
+     * <p/>
-            NodeState.ChildNodeEntry old = null;
+            NodeState.ChildNodeEntry old =
+                    ((NodeState) state.getOverlayedState()).getChildNodeEntry(now.getUUID());;
-            List list = ((NodeState) state.getOverlayedState()).
-                    getChildNodeEntries(now.getUUID());
-            if (list.size() > 0) {
-                old = (NodeState.ChildNodeEntry) list.get(0);
-            }
-        } catch(ItemNotFoundException e) {
+        } catch (ItemNotFoundException e) {
-        } catch(RepositoryException e) {
+        } catch (RepositoryException e) {
-    //-------------------------------------------------------< private methods >
+    //------------------------------------------------------< private methods >
+     *
+     *
+     *
-     * @param path path to item
+     * @param path  path to item
+     *
+     *
-     * @param entry LRU entry
+     *
+     * @param entry               LRU entry
+     *
+     *
-     * @param id node id
+     * @param id   node id
+     *
-     * @param id node id
+     * @param id   node id
+         *
+         *
+         *
+         *
+         *

JCR-1104 : JSR 283 support (security work in progress)

> introduce AccessManager.canRead(Path)
> retrieve Policy/ACE from ACProvider by Path rather than by ID
> add CompiledPermission.canReadAll for optimization
> fix ACLTemplate (various bugs) and add additional tests
> get rid of deprecated AccessManager.isGranted(ItemId, int) wherever possible
  and mark/simplify other usages
  - ItemManager
  - BatchedItemOperations
  - add TODO with QueryResultImpl that still uses the isGranted method.
  - EventConsumer: still uses isGranted. but various calls were replaced by private
    canRead -> simplify later optimization.
> remove unused ACLCache.java
> ItemManager:
  - make getItem consistent with itemExists (check perm even if obtained from cache)
  - replace getItemState by getItemData
  - get rid of duplicate code
  - add canRead(ItemData, Path) which is used (almost) everywhere and avoid permission
    check for NEW,non-protected items
  - consequently getItem(ItemId, boolean) is not required any more.
  - upon building LazyItemIterator for children: omit the duplicate permission
    check while building the set of childIds.
    the perm-check is executed upon the subsequent ItemManager.getItem call anyway 
> NodeImpl: createChildNode called ItemManager.getItem for an new item that has
  not yet been added as CNE to its parent -> replace by ItemManager.createItemInstance
  which omits the permission check.
> ItemImpl: 
  - fix javadoc
  - replace removed method ItemMgr.getItem(ItemId, boolean) by getItem(ItemId)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@649172 13f79535-47bb-0310-9956-ffa450edef68

-     * Retrieves state of item with given <code>id</code>. If the specified item
-     * doesn't exist an <code>ItemNotFoundException</code> will be thrown.
+     * Common implementation for all variants of item/node/propertyExists
+     * with both itemId or path param.
+     *
+     * @param itemId The id of the item to test.
+     * @param path Path of the item to check if known or <code>null</code>. In
+     * the latter case the test for access permission is executed using the
+     * itemId.
+     * @return true if the item with the given <code>itemId</code> exists AND
+     * can be read by this session.
+     */
+    private boolean itemExists(ItemId itemId, Path path) {
+        try {
+            // check sanity of session
+            session.sanityCheck();
+
+            // check if state exists for the given item
+            if (!itemStateProvider.hasItemState(itemId)) {
+                return false;
+            }
+
+            ItemData data = getItemData(itemId, path);
+            return data != null;
+        } catch (ItemNotFoundException infe) {
+            return false;
+        } catch (RepositoryException re) {
+            return false;
+        }
+    }
+
+    /**
+     * Common implementation for all variants of getItem/getNode/getProperty
+     * with both itemId or path parameter.
+     *
+     * @param itemId
+     * @param path Path of the item to retrieve or <code>null</code>. In
+     * the latter case the test for access permission is executed using the
+     * itemId.
+     * @return The item identified by the given <code>itemId</code>.
+     * @throws ItemNotFoundException
+     * @throws AccessDeniedException
+     * @throws RepositoryException
+     */
+    private ItemImpl getItem(ItemId itemId, Path path) throws ItemNotFoundException, AccessDeniedException, RepositoryException {
+        // check sanity of session
+        session.sanityCheck();
+
+        ItemData data = getItemData(itemId, path);
+        if (data == null) {
+            throw new AccessDeniedException("cannot read item " + itemId);
+        }
+        return createItemInstance(data);
+    }
+
+    /**
+     * Retrieves the data of the item with given <code>id</code>. If the
+     * specified item doesn't exist an <code>ItemNotFoundException</code> will
+     * be thrown.
-     * @param id id of item to be retrieved
+     * @param itemId id of item to be retrieved
+     * @param path The path of the item to retrieve the data for or
+     * <code>null</code>. In the latter case the id (instead of the path) is
+     * used to test if READ permission is granted.
-    private ItemState getItemState(ItemId id)
+    private ItemData getItemData(ItemId itemId, Path path)
-        // check privileges
-        if (!canRead(id)) {
-            // clear cache
-            evictItems(id);
-            throw new AccessDeniedException("cannot read item " + id);
+        ItemData data = retrieveItem(itemId);
+        if (data == null) {
+            // not yet in cache, need to create instance:
+            // - retrieve item state
+            // - create instance of item data
+            // NOTE: permission check & caching within createItemData
+            ItemState state;
+            try {
+                state = itemStateProvider.getItemState(itemId);
+            } catch (NoSuchItemStateException nsise) {
+                throw new ItemNotFoundException(itemId.toString());
+            } catch (ItemStateException ise) {
+                String msg = "failed to retrieve item state of item " + itemId;
+                log.error(msg, ise);
+                throw new RepositoryException(msg, ise);
+            }
+            // create item data including: perm check and caching.
+            data = createItemData(state, path);
+        } else {
+            // already cached: check if read-permission is granted in order
+            // to have a consistent behaviour to 'itemExists' above.
+            if (!canRead(data, path)) {
+                // item exists but read-perm has been revoked in the mean time.
+                // -> remove from cache
+                evictItems(itemId);
+                return null;
+            }
+        return data;
+    }
-        try {
-            return itemStateProvider.getItemState(id);
-        } catch (NoSuchItemStateException nsise) {
-            String msg = "no such item: " + id;
-            log.debug(msg);
-            throw new ItemNotFoundException(msg);
-        } catch (ItemStateException ise) {
-            String msg = "failed to retrieve item state of " + id;
-            log.error(msg);
-            throw new RepositoryException(msg, ise);
+    /**
+     * @param data
+     * @param path Path to be used for the permission check or <code>null</code>
+     * in which case the itemId present with the specified <code>data</code> is used.
+     * @return true if the item with the given <code>data</code> can be read;
+     * <code>false</code> otherwise.
+     * @throws AccessDeniedException
+     * @throws RepositoryException
+     */
+    private boolean canRead(ItemData data, Path path) throws AccessDeniedException, RepositoryException {
+        if (data.getState().getStatus() == ItemState.STATUS_NEW &&
+                !data.getDefinition().isProtected()) {
+            // NEW items can always be read as long they have been added
+            // through the API and NOT by the system (i.e. protected props).
+            return true;
+        } else {
+            return (path == null) ?
+                    canRead(data.getId()) :
+                    session.getAccessManager().canRead(path);
+    /**
+     * @param id
+     * @return true if the item with the given <code>id</code> can be read;
+     * <code>false</code> otherwise.
+     * @throws RepositoryException
+     */
-            return (id != null) && itemExists(id);
+            return (id != null) && itemExists(id, path);
-            return (id != null) && itemExists(id);
+            return (id != null) && itemExists(id, path);
-            return (id != null) && itemExists(id);
+            return (id != null) && itemExists(id, path);
-        try {
-            // check sanity of session
-            session.sanityCheck();
-
-            // check if state exists for the given item
-            if (!itemStateProvider.hasItemState(id)) {
-                return false;
-            }
-
-            // check privileges
-            if (!canRead(id)) {
-                // clear cache
-                evictItems(id);
-                // item exists but the session has not been granted read access
-                return false;
-            }
-            return true;
-        } catch (ItemNotFoundException infe) {
-            return false;
-        } catch (RepositoryException re) {
-            return false;
-        }
+        return itemExists(id, null);
-            return getItem(id);
+            return getItem(id, path);
-            return (NodeImpl) getItem(id);
+            return (NodeImpl) getItem(id, path);
-            return (PropertyImpl) getItem(id);
+            return (PropertyImpl) getItem(id, path);
-        // check sanity of session
-        session.sanityCheck();
-
-        ItemData data = retrieveItem(id);
-        if (data == null) {
-            // not yet in cache, need to create instance:
-            // check privileges
-            if (!canRead(id)) {
-                throw new AccessDeniedException("cannot read item " + id);
-            }
-            // create instance of item data
-            data = createItemData(id);
-            cacheItem(data);
-        }
-        return createItemInstance(data);
+        return getItem(id, null);
-
-            data = (AbstractNodeData) createItemData(id);
-            cacheItem(data);
+            data = (AbstractNodeData) getItemData(id, null);
+            // TODO: ev. need to check if read perm. is granted.
-     * Returns the item instance for the given item id.
-     *
-     * @param state the item state
-     * @param checkAccess whether to check access
-     * @return the item instance for the given item <code>state</code>.
-     * @throws RepositoryException
-     */
-    synchronized ItemImpl getItem(ItemId id, boolean isNew)
-            throws ItemNotFoundException, AccessDeniedException, RepositoryException {
-        // check sanity of session
-        session.sanityCheck();
-
-        // check cache
-        ItemData data = retrieveItem(id);
-        if (data == null) {
-            // not yet in cache, need to create instance:
-            // only check privileges if state is not new
-            if (!isNew && !canRead(id)) {
-                throw new AccessDeniedException("cannot read item " + id);
-            }
-            // create instance of item
-            data = createItemData(id);
-            cacheItem(data);
-        }
-        return createItemInstance(data);
-    }
-
-    /**
-     * new <code>ItemData</code> instance without looking at the cache and
-     * returns a new item instance.
+     * new <code>ItemData</code> instance without looking at the cache nor
+     * testing if the item can be read and returns a new item instance.
-
-        ItemData data = createItemData(state);
-        cacheItem(data);
+        ItemData data = createItemData(state, null, false);
-        ItemState state = getItemState(parentId);
-        if (!state.isNode()) {
+        ItemData data = getItemData(parentId, null);
+        if (!data.isNode()) {
-        NodeState nodeState = (NodeState) state;
-        Iterator iter = nodeState.getChildNodeEntries().iterator();
+        Iterator iter = ((NodeState) data.getState()).getChildNodeEntries().iterator();
-            // check read access
+            // make sure any of the properties can be read.
-        ItemState state = getItemState(parentId);
-        if (!state.isNode()) {
+        ItemData data = getItemData(parentId, null);
+        if (!data.isNode()) {
-        NodeState nodeState = (NodeState) state;
-        Iterator iter = nodeState.getChildNodeEntries().iterator();
+        Iterator iter = ((NodeState) data.getState()).getChildNodeEntries().iterator();
-            // check read access
-            if (canRead(entry.getId())) {
-                childIds.add(entry.getId());
-            }
+            // delay check for read-access until item is being built
+            // thus avoid duplicate check
+            childIds.add(entry.getId());
-        ItemState state = getItemState(parentId);
-        if (!state.isNode()) {
+        ItemData data = getItemData(parentId, null);
+        if (!data.isNode()) {
-        NodeState nodeState = (NodeState) state;
-        Iterator iter = nodeState.getPropertyNames().iterator();
+        Iterator iter = ((NodeState) data.getState()).getPropertyNames().iterator();
-            // check read access
+            // make sure any of the properties can be read.
-        ItemState state = getItemState(parentId);
-        if (!state.isNode()) {
+        ItemData data = getItemData(parentId, null);
+        if (!data.isNode()) {
-        NodeState nodeState = (NodeState) state;
-        Iterator iter = nodeState.getPropertyNames().iterator();
+        Iterator iter = ((NodeState) data.getState()).getPropertyNames().iterator();
-            // check read access
-            if (canRead(id)) {
-                childIds.add(id);
-            }
+            // delay check for read-access until item is being built
+            // thus avoid duplicate check
+            childIds.add(id);
-
-    private ItemData createItemData(ItemId id)
-            throws ItemNotFoundException, RepositoryException {
-
-        ItemState state;
-        try {
-            state = itemStateProvider.getItemState(id);
-        } catch (NoSuchItemStateException nsise) {
-            throw new ItemNotFoundException(id.toString());
-        } catch (ItemStateException ise) {
-            String msg = "failed to retrieve item state of item " + id;
-            log.error(msg, ise);
-            throw new RepositoryException(msg, ise);
-        }
-        return createItemData(state);
+    /**
+     * Same as {@link #createItemData(ItemState, Path, boolean)} where the
+     * permissionCheck flag is 'true'. This method will throw
+     * <code>AccessDeniedException</code> if reading the item data is not
+     * allowed.
+     *
+     * @param state
+     * @return
+     * @throws RepositoryException
+     */
+    private ItemData createItemData(ItemState state, Path path) throws RepositoryException {
+        return createItemData(state, path, true);
-    private ItemData createItemData(ItemState state) throws RepositoryException {
+    /**
+     * Builds the <code>ItemData</code> for the specified <code>state</code>.
+     * If <code>permissionCheck</code> is <code>true</code>, the access manager
+     * is used to determine if reading that item would be granted. If this is
+     * not the case an <code>AccessDeniedException</code> is thrown.
+     * Before returning the created <code>ItemData</code> it is put into the
+     * cache. In order to benefit from the cache {@link #getItemData(ItemId, Path)}
+     * should be called
+     *
+     * @param state
+     * @return
+     * @throws RepositoryException
+     */
+    private ItemData createItemData(ItemState state, Path path, boolean permissionCheck) throws RepositoryException {
+        ItemData data;
-            return new NodeData((NodeState) state, rootNodeDef);
+            data = new NodeData((NodeState) state, rootNodeDef);
-            return new NodeData(nodeState, getDefinition(nodeState));
+            data = new NodeData(nodeState, getDefinition(nodeState));
-            return new PropertyData(propertyState, getDefinition(propertyState));
+            data = new PropertyData(propertyState, getDefinition(propertyState));
+        // make sure read-perm. is granted before returning the data.
+        if (permissionCheck && !canRead(data, path)) {
+            throw new AccessDeniedException("cannot read item " + state.getId());
+        }
+        // before returning the data: put them into the cache.
+        cacheItem(data);
+        return data;
-     * @param item the item to cache
+     * @param data the item data to cache
-     * @param id id of the item to remove from the cache
+     * @param data The item data to remove from the cache

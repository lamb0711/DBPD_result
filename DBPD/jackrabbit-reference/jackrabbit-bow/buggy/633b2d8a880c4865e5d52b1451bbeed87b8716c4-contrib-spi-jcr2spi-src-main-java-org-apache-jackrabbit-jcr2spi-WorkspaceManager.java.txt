fixed: move, reorder (work in progress)
fixed: locktoken transfer
fixed: recursive transient removal of invalidated tree fails (restoreTests)
improve: simplify usage of workspace operations
fixed: store original itemId with transient operations in order to properly reflect the changelog upon batch creation
fixed: workspace import doesn't invalidate
fixed: session import uuid handling




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@513279 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.state.ItemStateException;
-import org.apache.jackrabbit.jcr2spi.state.PropertyState;
+import org.apache.jackrabbit.jcr2spi.state.Status;
+import org.apache.jackrabbit.jcr2spi.operation.WorkspaceImport;
-import java.io.InputStream;
-     * TODO: check if throwing an exception would be more appropriate
-     *
-        sessionInfo.removeLockToken(lt);
+        String[] tokems = sessionInfo.getLockTokens();
+        for (int i = 0; i < tokems.length; i++) {
+            if (tokems[i].equals(lt)) {
+                sessionInfo.removeLockToken(lt);
+                return;
+            }
+        }
+        // sessionInfo doesn't contain the given lock token and is therefore
+        // not the lock holder
+        throw new RepositoryException("Unable to remove locktoken '" + lt + "' from Session.");
+        // TODO: correct?
+        if (parentState.getStatus() == Status.NEW) {
+            return true;
+        }
-        ItemState wspState = itemState.getWorkspaceState();
-        if (wspState == null) {
+        if (itemState.getStatus() == Status.NEW) {
-        return service.isGranted(sessionInfo, wspState.getId(), actions);
+        return service.isGranted(sessionInfo, itemState.getId(), actions);
-        ItemState wspState = itemState.getWorkspaceState();
-        if (wspState == null) {
+        if (itemState.getStatus() == Status.NEW) {
-        return service.isGranted(sessionInfo, wspState.getId(), AccessManager.READ);
+        return service.isGranted(sessionInfo, itemState.getId(), AccessManager.READ);
-        ItemState wspState = itemState.getWorkspaceState();
-        if (wspState == null) {
+        if (itemState.getStatus() == Status.NEW) {
-        return service.isGranted(sessionInfo, wspState.getId(), AccessManager.REMOVE);
+        return service.isGranted(sessionInfo, itemState.getId(), AccessManager.REMOVE);
-    //---------------------------------------------------------< XML import >---
-    public void importXml(NodeState parentState, InputStream xmlStream, int uuidBehaviour) throws RepositoryException, LockException, ConstraintViolationException, AccessDeniedException, UnsupportedRepositoryOperationException, ItemExistsException, VersionException {
-        NodeId parentId = parentState.getNodeId();
-        service.importXml(sessionInfo, parentId, xmlStream, uuidBehaviour);
-    }
-
-            NodeId parentId = operation.getParentState().getNodeId();
+            NodeId parentId = operation.getParentId();
-            NodeId parentId = operation.getParentState().getNodeId();
+            NodeId parentId = operation.getParentId();
-            NodeId nId = operation.getNodeState().getNodeId();
-            NodeId destParentId = operation.getDestinationParentState().getNodeId();
+            NodeId nId = operation.getNodeId();
+            NodeId destParentId = operation.getDestinationParentId();
-            NodeId nId = operation.getNodeState().getNodeId();
-            NodeId destParentId = operation.getDestinationParentState().getNodeId();
+            NodeId nId = operation.getNodeId();
+            NodeId destParentId = operation.getDestinationParentId();
-            NodeId destParentId = operation.getDestinationParentState().getNodeId();
+            NodeId destParentId = operation.getDestinationParentId();
+
-            NodeId nId = operation.getNodeState().getNodeId();
+            NodeId nId = operation.getNodeId();
-            ItemId id = operation.getRemoveState().getId();
-            batch.remove(id);
+            batch.remove(operation.getRemoveId());
-            batch.setMixins(operation.getNodeState().getNodeId(), operation.getMixinNames());
+            batch.setMixins(operation.getNodeId(), operation.getMixinNames());
-            PropertyState pState = operation.getPropertyState();
-            PropertyId id = pState.getPropertyId();
-            if (pState.isMultiValued()) {
+            PropertyId id = operation.getPropertyId();
+            if (operation.isMultiValued()) {
-            NodeId parentId = operation.getParentState().getNodeId();
-            NodeId insertId = operation.getInsertNode().getNodeId();
-            NodeId beforeId = null;
-            if (operation.getBeforeNode() != null) {
-                beforeId = operation.getBeforeNode().getNodeId() ;
-            }
+            NodeId parentId = operation.getParentId();
+            NodeId insertId = operation.getInsertId();
+            NodeId beforeId = operation.getBeforeId();
-            service.checkout(sessionInfo, operation.getNodeState().getNodeId());
+            service.checkout(sessionInfo, operation.getNodeId());
-            service.checkin(sessionInfo, operation.getNodeState().getNodeId());
+            service.checkin(sessionInfo, operation.getNodeId());
-            NodeState nState = operation.getNodeState();
-            NodeState[] versionStates = operation.getVersionStates();
-            if (versionStates == null || versionStates.length == 0) {
-                throw new IllegalArgumentException("Restore must specify at least a singe version.");
-            }
-
-            NodeId[] vIds = new NodeId[versionStates.length];
-            for (int i = 0; i < vIds.length; i++) {
-                vIds[i] = versionStates[i].getNodeId();
-            }
-
-            if (nState == null) {
-                service.restore(sessionInfo, vIds, operation.removeExisting());
+            NodeId nId = operation.getNodeId();
+            if (nId == null) {
+                service.restore(sessionInfo, operation.getVersionIds(), operation.removeExisting());
-                if (vIds.length > 1) {
-                    throw new IllegalArgumentException("Restore from a single node must specify but one single Version.");
-                }
-
-                    targetId = getIdFactory().createNodeId(nState.getNodeId(), relPath);
+                    targetId = getIdFactory().createNodeId(nId, relPath);
-                    targetId = nState.getNodeId();
+                    targetId = nId;
-                service.restore(sessionInfo, targetId, vIds[0], operation.removeExisting());
+                NodeId versionId = operation.getVersionIds()[0];
+                service.restore(sessionInfo, targetId, versionId, operation.removeExisting());
-            NodeId nId = operation.getNodeState().getNodeId();
+            NodeId nId = operation.getNodeId();
-            try {
-                NodeState nState = operation.getNodeState();
-                NodeId nId = nState.getNodeId();
-                NodeId vId = operation.getVersionState().getNodeId();
-
-                PropertyState mergeFailedState = nState.getPropertyState(QName.JCR_MERGEFAILED);
-                QValue[] vs = mergeFailedState.getValues();
-
-                NodeId[] mergeFailedIds = new NodeId[vs.length - 1];
-                for (int i = 0, j = 0; i < vs.length; i++) {
-                    NodeId id = getIdFactory().createNodeId(vs[i].getString());
-                    if (!id.equals(vId)) {
-                        mergeFailedIds[j] = id;
-                        j++;
-                    }
-                    // else: the version id is being solved by this call and not
-                    // part of 'jcr:mergefailed' any more
-                }
-
-                PropertyState predecessorState = nState.getPropertyState(QName.JCR_PREDECESSORS);
-                vs = predecessorState.getValues();
-
-                boolean resolveDone = operation.resolveDone();
-                int noOfPredecessors = (resolveDone) ? vs.length + 1 : vs.length;
-                NodeId[] predecessorIds = new NodeId[noOfPredecessors];
-
-                int i = 0;
-                while (i < vs.length) {
-                    predecessorIds[i] = getIdFactory().createNodeId(vs[i].getString());
-                    i++;
-                }
-                if (resolveDone) {
-                    predecessorIds[i] = vId;
-                }
-                service.resolveMergeConflict(sessionInfo, nId, mergeFailedIds, predecessorIds);
-            } catch (ItemStateException e) {
-                // should not occur.
-                throw new RepositoryException(e);
-            }
+            NodeId nId = operation.getNodeId();
+            NodeId[] mergedFailedIds = operation.getMergeFailedIds();
+            NodeId[] predecessorIds = operation.getPredecessorIds();
+            service.resolveMergeConflict(sessionInfo, nId, mergedFailedIds, predecessorIds);
-            NodeId nId = operation.getNodeState().getNodeId();
-            LockInfo lInfo = service.lock(sessionInfo, nId, operation.isDeep(), operation.isSessionScoped());
+            LockInfo lInfo = service.lock(sessionInfo, operation.getNodeId(), operation.isDeep(), operation.isSessionScoped());
-            NodeId nId = operation.getNodeState().getNodeId();
-            service.refreshLock(sessionInfo, nId);
+            service.refreshLock(sessionInfo, operation.getNodeId());
-            NodeId nId = operation.getNodeState().getNodeId();
-            service.unlock(sessionInfo, nId);
+            service.unlock(sessionInfo, operation.getNodeId());
-            NodeId vhId = operation.getVersionHistoryState().getNodeId();
-            NodeId vId = operation.getVersionState().getNodeId();
+            NodeId vhId = operation.getVersionHistoryId();
+            NodeId vId = operation.getVersionId();
-            NodeId vhId = operation.getVersionHistoryState().getNodeId();
-            NodeId vId = operation.getVersionState().getNodeId();
+            NodeId vhId = operation.getVersionHistoryId();
+            NodeId vId = operation.getVersionId();
-            NodeState versionState = (NodeState) operation.getRemoveState();
+            NodeId versionId = (NodeId) operation.getRemoveId();
-            service.removeVersion(sessionInfo, vhState.getNodeId(), versionState.getNodeId());
+            service.removeVersion(sessionInfo, vhState.getNodeId(), versionId);
+        }
+
+        /**
+         * @inheritDoc
+         * @see OperationVisitor#visit(WorkspaceImport)
+         */
+        public void visit(WorkspaceImport operation) throws RepositoryException {
+            service.importXml(sessionInfo, operation.getNodeId(), operation.getXmlStream(), operation.getUuidBehaviour());

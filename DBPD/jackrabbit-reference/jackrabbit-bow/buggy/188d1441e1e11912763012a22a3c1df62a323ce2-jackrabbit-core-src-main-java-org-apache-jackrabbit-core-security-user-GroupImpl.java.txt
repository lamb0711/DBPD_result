JCR-2710: Add support for large number of users in a group 
work in progress

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@984740 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.JcrConstants;
+import org.apache.jackrabbit.commons.flat.BTreeManager;
+import org.apache.jackrabbit.commons.flat.ItemSequence;
+import org.apache.jackrabbit.commons.flat.PropertySequence;
+import org.apache.jackrabbit.commons.flat.Rank;
+import org.apache.jackrabbit.commons.flat.TreeManager;
+import org.apache.jackrabbit.util.Text;
+import javax.jcr.ItemNotFoundException;
+import javax.jcr.Property;
+import javax.jcr.PropertyType;
-import javax.jcr.ItemNotFoundException;
-import javax.jcr.PropertyType;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Comparator;
-import java.util.Set;
-import java.util.ArrayList;
-import java.util.Arrays;
+import java.util.Set;
-        if (authorizable == null || !(authorizable instanceof AuthorizableImpl)) {
+        if (!(authorizable instanceof AuthorizableImpl)) {
+            log.warn("Invalid Authorizable: {}", authorizable);
-            String msg = "Attempt to add a Group as member of itself (" + getID() + ").";
+            String msg = "Attempt to add a group as member of itself (" + getID() + ").";
-        Value[] values;
-        Value toAdd = getSession().getValueFactory().createValue(memberNode, true);
-        NodeImpl node = getNode();
-        if (node.hasProperty(P_MEMBERS)) {
-            Value[] old = node.getProperty(P_MEMBERS).getValues();
-            for (Value v : old) {
-                if (v.equals(toAdd)) {
-                    log.debug("Authorizable " + authImpl + " is already member of " + this);
-                    return false;
-                }
-            }
-
-            values = new Value[old.length + 1];
-            System.arraycopy(old, 0, values, 0, old.length);
-        } else {
-            values = new Value[1];
-        }
-        values[values.length - 1] = toAdd;
-
-        userManager.setProtectedProperty(node, P_MEMBERS, values, PropertyType.WEAKREFERENCE);
-        userManager.getMembershipCache().clear();
-        return true;
+        return getMembershipProvider(getNode()).addMember(authImpl);
+
-            return false;
-        }
-        NodeImpl node = getNode();
-        if (!node.hasProperty(P_MEMBERS)) {
-            log.debug("Group has no members -> cannot remove member " + authorizable.getID());
+            log.warn("Invalid Authorizable: {}", authorizable);
-        Value toRemove = getSession().getValueFactory().createValue(((AuthorizableImpl)authorizable).getNode(), true);
-
-        PropertyImpl property = node.getProperty(P_MEMBERS);
-        List<Value> valList = new ArrayList<Value>(Arrays.asList(property.getValues()));
-
-        if (valList.remove(toRemove)) {
-            try {
-                if (valList.isEmpty()) {
-                    userManager.removeProtectedItem(property, node);
-                } else {
-                    Value[] values = valList.toArray(new Value[valList.size()]);
-                    userManager.setProtectedProperty(node, P_MEMBERS, values);
-                }
-                userManager.getMembershipCache().clear();
-                return true;
-            } catch (RepositoryException e) {
-                // modification failed -> revert all pending changes.
-                node.refresh(false);
-                throw e;
-            }
-        } else {
-            // nothing changed
-            log.debug("Authorizable " + authorizable.getID() + " was not member of " + getID());
-            return false;
-        }
+        return getMembershipProvider(getNode()).removeMember((AuthorizableImpl) authorizable);
+
+    private MembershipProvider getMembershipProvider(NodeImpl node) throws RepositoryException {
+        MembershipProvider msp;
+        if (userManager.getGroupMembershipSplitSize() > 0) {
+            if (node.hasNode(N_MEMBERS) || !node.hasProperty(P_MEMBERS)) {
+                msp = new NodeBasedMembershipProvider(node);
+            }
+            else {
+                msp = new PropertyBasedMembershipProvider(node);
+            }
+        }
+        else {
+            if (node.hasProperty(P_MEMBERS) || !node.hasNode(N_MEMBERS)) {
+                msp = new PropertyBasedMembershipProvider(node);
+            }
+            else {
+                msp = new NodeBasedMembershipProvider(node);
+            }
+        }
+
+        if (node.hasProperty(P_MEMBERS) && node.hasNode(N_MEMBERS)) {
+            log.warn("Found members node and members property on node {}. Ignoring {} members", node,
+                    userManager.getGroupMembershipSplitSize() > 0 ? "property" : "node");
+        }
+
+        return msp;
+    }
+
-        Collection<Authorizable> members = new HashSet<Authorizable>();
-        if (getNode().hasProperty(P_MEMBERS)) {
-            Value[] vs = getNode().getProperty(P_MEMBERS).getValues();
-            for (Value v : vs) {
-                try {
-                    NodeImpl n = (NodeImpl) getSession().getNodeByIdentifier(v.getString());
-                    if (n.isNodeType(NT_REP_GROUP)) {
-                        if (type != UserManager.SEARCH_TYPE_USER) {
-                            Group group = userManager.createGroup(n);
-                            // only retrieve indirect group-members if the group is not
-                            // yet present (detected eventual circular membership).
-                            if (members.add(group) && includeIndirect) {
-                                members.addAll(((GroupImpl) group).getMembers(true, type));
-                            }
-                        } // else: groups are ignored
-                    } else if (n.isNodeType(NT_REP_USER)) {
-                        if (type != UserManager.SEARCH_TYPE_GROUP) {
-                            User user = userManager.createUser(n);
-                            members.add(user);
-                        }
-                    } else {
-                        // reference does point to an authorizable node -> not a
-                        // member of this group -> ignore
-                        log.debug("Group member entry with invalid node type " + n.getPrimaryNodeType().getName() + " -> Not included in member set.");
-                    }
-                } catch (ItemNotFoundException e) {
-                    // dangling weak reference -> clean upon next write.
-                    log.debug("Authorizable node referenced by " + getID() + " doesn't exist any more -> Ignored from member list.");
-                }
-            }
-        } // no rep:member property
-        return members;
+        return getMembershipProvider(getNode()).getMembers(includeIndirect, type);
+    private PropertySequence getPropertySequence(Node nMembers) throws RepositoryException {
+        Comparator<String> order = Rank.comparableComparator();
+        int maxChildren = userManager.getGroupMembershipSplitSize();
+        int minChildren = maxChildren/2;
+
+        TreeManager treeManager = new BTreeManager(nMembers, minChildren, maxChildren, order,
+                userManager.isAutoSave());
+
+        treeManager.getIgnoredProperties().addAll(Arrays.asList(
+                JcrConstants.JCR_CREATED,
+                "jcr:createdBy"));
+
+        return ItemSequence.createPropertySequence(treeManager);
+    }
+
+    private void collectMembers(Value memberRef, Collection<Authorizable> members, boolean includeIndirect,
+            int type) throws RepositoryException {
+
+        try {
+            NodeImpl member = (NodeImpl) getSession().getNodeByIdentifier(memberRef.getString());
+            if (member.isNodeType(NT_REP_GROUP)) {
+                if (type != UserManager.SEARCH_TYPE_USER) {
+                    Group group = userManager.createGroup(member);
+                    // only retrieve indirect group-members if the group is not
+                    // yet present (detected eventual circular membership).
+                    if (members.add(group) && includeIndirect) {
+                        members.addAll(((GroupImpl) group).getMembers(true, type));
+                    }
+                } // else: groups are ignored
+            } else if (member.isNodeType(NT_REP_USER)) {
+                if (type != UserManager.SEARCH_TYPE_GROUP) {
+                    User user = userManager.createUser(member);
+                    members.add(user);
+                }
+            } else {
+                // reference does point to an authorizable node -> not a
+                // member of this group -> ignore
+                log.debug("Group member entry with invalid node type {} -> " +
+                        "Not included in member set.", member.getPrimaryNodeType().getName());
+            }
+        } catch (ItemNotFoundException e) {
+            // dangling weak reference -> clean upon next write.
+            log.debug("Authorizable node referenced by {} doesn't exist any more -> " +
+            "Ignored from member list.", getID());
+        }
+    }
+
-    /**
-     *
-     */
+
+
+    private interface MembershipProvider {
+        boolean addMember(AuthorizableImpl authorizable) throws RepositoryException;
+        boolean removeMember(AuthorizableImpl authorizable) throws RepositoryException;
+        Collection<Authorizable> getMembers(boolean includeIndirect, int type) throws RepositoryException;
+    }
+
+    private class PropertyBasedMembershipProvider implements MembershipProvider {
+        private final NodeImpl node;
+
+        public PropertyBasedMembershipProvider(NodeImpl node) {
+            super();
+            this.node = node;
+        }
+
+        public boolean addMember(AuthorizableImpl authorizable) throws RepositoryException {
+            Node memberNode = authorizable.getNode();
+
+            Value[] values;
+            Value toAdd = getSession().getValueFactory().createValue(memberNode, true);
+            if (node.hasProperty(P_MEMBERS)) {
+                Value[] old = node.getProperty(P_MEMBERS).getValues();
+                for (Value v : old) {
+                    if (v.equals(toAdd)) {
+                        log.debug("Authorizable {} is already member of {}", authorizable, this);
+                        return false;
+                    }
+                }
+
+                values = new Value[old.length + 1];
+                System.arraycopy(old, 0, values, 0, old.length);
+            } else {
+                values = new Value[1];
+            }
+            values[values.length - 1] = toAdd;
+
+            userManager.setProtectedProperty(node, P_MEMBERS, values, PropertyType.WEAKREFERENCE);
+            userManager.getMembershipCache().clear();
+            return true;
+        }
+
+        public boolean removeMember(AuthorizableImpl authorizable) throws RepositoryException {
+            if (!node.hasProperty(P_MEMBERS)) {
+                log.debug("Group has no members -> cannot remove member {}", authorizable.getID());
+                return false;
+            }
+
+            Value toRemove = getSession().getValueFactory().createValue((authorizable).getNode(), true);
+
+            PropertyImpl property = node.getProperty(P_MEMBERS);
+            List<Value> valList = new ArrayList<Value>(Arrays.asList(property.getValues()));
+
+            if (valList.remove(toRemove)) {
+                try {
+                    if (valList.isEmpty()) {
+                        userManager.removeProtectedItem(property, node);
+                    } else {
+                        Value[] values = valList.toArray(new Value[valList.size()]);
+                        userManager.setProtectedProperty(node, P_MEMBERS, values);
+                    }
+                    userManager.getMembershipCache().clear();
+                    return true;
+                } catch (RepositoryException e) {
+                    // modification failed -> revert all pending changes.
+                    node.refresh(false);
+                    throw e;
+                }
+            } else {
+                // nothing changed
+                log.debug("Authorizable {} was not member of {}", authorizable.getID(), getID());
+                return false;
+            }
+        }
+
+        public Collection<Authorizable> getMembers(boolean includeIndirect, int type) throws RepositoryException {
+            Collection<Authorizable> members = new HashSet<Authorizable>();
+            if (node.hasProperty(P_MEMBERS)) {
+                for (Value member : node.getProperty(P_MEMBERS).getValues()) {
+                    collectMembers(member, members, includeIndirect, type);
+                }
+            }
+            return members;
+        }
+
+    }
+
+    private class NodeBasedMembershipProvider implements MembershipProvider {
+        private final NodeImpl node;
+
+        public NodeBasedMembershipProvider(NodeImpl node) {
+            super();
+            this.node = node;
+        }
+
+        public boolean addMember(AuthorizableImpl authorizable) throws RepositoryException {
+            NodeImpl nMembers = (node.hasNode(N_MEMBERS)
+                    ? node.getNode(N_MEMBERS)
+                    : userManager.addProtectedNode(node, N_MEMBERS, NT_REP_MEMBERS));
+
+            try {
+                PropertySequence properties = getPropertySequence(nMembers);
+                String propName = Text.escapeIllegalJcrChars(authorizable.getID());
+                if (properties.hasItem(propName)) {
+                    log.debug("Authorizable {} is already member of {}", authorizable, this);
+                    return false;
+                }
+                else {
+                    Value newMember = getSession().getValueFactory().createValue(authorizable.getNode(), true);
+                    properties.addProperty(propName, newMember);
+                }
+
+                if (userManager.isAutoSave()) {
+                    node.save();
+                }
+                userManager.getMembershipCache().clear();
+                return true;
+            }
+            catch (RepositoryException e) {
+                log.debug("addMember failed. Reverting changes", e);
+                nMembers.refresh(false);
+                throw e;
+            }
+        }
+
+        public boolean removeMember(AuthorizableImpl authorizable) throws RepositoryException {
+            if (!node.hasNode(N_MEMBERS)) {
+                log.debug("Group has no members -> cannot remove member {}", authorizable.getID());
+                return false;
+            }
+
+            NodeImpl nMembers = node.getNode(N_MEMBERS);
+            try {
+                PropertySequence properties = getPropertySequence(nMembers);
+                String propName = Text.escapeIllegalJcrChars(authorizable.getID());
+                if (properties.hasItem(propName)) {
+                    properties.removeProperty(propName);
+                    if (!properties.iterator().hasNext()) {
+                        userManager.removeProtectedItem(nMembers, node);
+                    }
+                }
+                else {
+                    log.debug("Authorizable {} was not member of {}", authorizable.getID(), getID());
+                    return false;
+                }
+
+                if (userManager.isAutoSave()) {
+                    node.save();
+                }
+                userManager.getMembershipCache().clear();
+                return true;
+            }
+            catch (RepositoryException e) {
+                log.debug("removeMember failed. Reverting changes", e);
+                nMembers.refresh(false);
+                throw e;
+            }
+        }
+
+        public Collection<Authorizable> getMembers(boolean includeIndirect, int type)
+                throws RepositoryException {
+
+            Collection<Authorizable> members = new HashSet<Authorizable>();
+            if (node.hasNode(N_MEMBERS)) {
+                for (Property member : getPropertySequence(node.getNode(N_MEMBERS))) {
+                    collectMembers(member.getValue(), members, includeIndirect, type);
+                }
+            }
+
+            return members;
+        }
+
+    }

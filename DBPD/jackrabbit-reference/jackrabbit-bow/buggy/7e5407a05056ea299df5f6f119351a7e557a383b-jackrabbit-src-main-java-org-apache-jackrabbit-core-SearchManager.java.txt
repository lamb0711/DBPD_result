[JCR-317] replace UUID strings by UUID classes in NodeId, etc..

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@378221 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.collections.iterators.AbstractIteratorDecorator;
+import org.apache.jackrabbit.core.query.AbstractQueryImpl;
-import org.apache.jackrabbit.core.query.AbstractQueryImpl;
-import org.apache.jackrabbit.core.state.ItemState;
+import org.apache.jackrabbit.core.state.NodeState;
+import org.apache.jackrabbit.core.state.NodeStateIterator;
-import org.apache.jackrabbit.name.Path;
+import org.apache.jackrabbit.name.Path;
+import java.util.Collections;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Properties;
-import java.util.Properties;
-import java.util.Map;
-import java.util.Collections;
-    private final String rootNodeUUID;
+    private final NodeId rootNodeId;
-     * UUID of the node that should be excluded from indexing or <code>null</code>
+     * ID of the node that should be excluded from indexing or <code>null</code>
-    private final String excludedNodeUUID;
+    private final NodeId excludedNodeId;
-     * @param rootNodeUUID     the uuid of the root node.
+     * @param rootNodeId     the id of the root node.
-     * @param excludedNodeUUID uuid of the node that should be excluded from
+     * @param excludedNodeId id of the node that should be excluded from
-                         String rootNodeUUID,
+                         NodeId rootNodeId,
-                         String excludedNodeUUID) throws RepositoryException {
+                         NodeId excludedNodeId) throws RepositoryException {
-        this.rootNodeUUID = rootNodeUUID;
+        this.rootNodeId = rootNodeId;
-        this.excludedNodeUUID = excludedNodeUUID;
+        this.excludedNodeId = excludedNodeId;
-        if (excludedNodeUUID != null) {
-            HierarchyManagerImpl hmgr = new HierarchyManagerImpl(rootNodeUUID, itemMgr, nsResolver);
-            excludePath = hmgr.getPath(new NodeId(excludedNodeUUID));
+        if (excludedNodeId != null) {
+            HierarchyManagerImpl hmgr = new HierarchyManagerImpl(rootNodeId, itemMgr, nsResolver);
+            excludePath = hmgr.getPath(excludedNodeId);
-        Set removedNodes = new HashSet();
+        final Set removedNodes = new HashSet();
-        Set addedNodes = new HashSet();
+        final Set addedNodes = new HashSet();
-                addedNodes.add(e.getChildUUID());
+                addedNodes.add(e.getChildId());
-                removedNodes.add(e.getChildUUID());
+                removedNodes.add(e.getChildId());
-            String nodeUUID = event.getParentUUID();
+            NodeId nodeId = event.getParentId();
-                if (addedNodes.add(nodeUUID)) {
+                if (addedNodes.add(nodeId)) {
-                    removedNodes.add(nodeUUID);
+                    removedNodes.add(nodeId);
-                addedNodes.add(nodeUUID);
-                removedNodes.add(nodeUUID);
+                addedNodes.add(nodeId);
+                removedNodes.add(nodeId);
-                addedNodes.add(nodeUUID);
-                removedNodes.add(nodeUUID);
+                addedNodes.add(nodeId);
+                removedNodes.add(nodeId);
-        Iterator addedStates = new AbstractIteratorDecorator(addedNodes.iterator()) {
+        NodeStateIterator addedStates = new NodeStateIterator() {
+            private final Iterator iter = addedNodes.iterator();
+
+            public void remove() {
+                throw new UnsupportedOperationException();
+            }
+
+            public boolean hasNext() {
+                return iter.hasNext();
+            }
+
-                ItemState item = null;
-                String uuid = (String) super.next();
+                return nextNodeState();
+            }
+
+            public NodeState nextNodeState() {
+                NodeState item = null;
+                NodeId id= (NodeId) iter.next();
-                    item = itemMgr.getItemState(new NodeId(uuid));
+                    item = (NodeState) itemMgr.getItemState(id);
-                    log.error("Unable to index node " + uuid + ": does not exist");
+                    log.error("Unable to index node " + id + ": does not exist");
+        NodeIdIterator removedIds = new NodeIdIterator() {
+            private final Iterator iter = removedNodes.iterator();
+
+            public NodeId nextNodeId() throws NoSuchElementException {
+                return (NodeId) iter.next();
+            }
+
+            public void remove() {
+                throw new UnsupportedOperationException();
+            }
+
+            public boolean hasNext() {
+                return iter.hasNext();
+            }
+
+            public Object next() {
+                return nextNodeId();
+            }
+        };
+
-                handler.updateNodes(removedNodes.iterator(), addedStates);
+                handler.updateNodes(removedIds, addedStates);
-                    = new QueryHandlerContext(fs, itemMgr, rootNodeUUID,
-                            ntReg, parentHandler, excludedNodeUUID);
+                    = new QueryHandlerContext(fs, itemMgr, rootNodeId,
+                            ntReg, parentHandler, excludedNodeId);

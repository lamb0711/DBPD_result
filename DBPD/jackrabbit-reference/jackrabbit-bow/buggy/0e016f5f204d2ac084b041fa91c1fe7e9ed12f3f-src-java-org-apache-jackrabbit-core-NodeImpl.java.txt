fixed bug in Node.removeMixin(): mix:referenceable could be indirectly removed even if there existed references to the target node

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@155627 13f79535-47bb-0310-9956-ffa450edef68

-        if (MIX_REFERENCEABLE.equals(mixinName)) {
-            /**
-             * mix:referenceable needs special handling because it has
-             * special semantics:
-             * it can only be removed if there no more references to this node
-             */
-            PropertyIterator iter = getReferences();
-            if (iter.hasNext()) {
-                throw new ConstraintViolationException(mixinName + " can not be removed: the node is being referenced through at least one property of type REFERENCE");
-            }
-        }
-
-        // modify the state of this node
-        NodeState thisState = (NodeState) getOrCreateTransientItemState();
-        // remove mixin name
-        Set mixins = new HashSet(thisState.getMixinTypeNames());
-        mixins.remove(mixinName);
-        thisState.setMixinTypeNames(mixins);
-
-        // set jcr:mixinTypes property
-        setMixinTypesProperty(mixins);
-
-        // build effective node type of remaining mixin's & primary type
+
+        // build effective node type of remaining mixin's & primary type
+        Set remainingMixins = new HashSet(((NodeState) state).getMixinTypeNames());
+        // remove name of target mixin
+        remainingMixins.remove(mixinName);
-            HashSet set = new HashSet(mixins);
+            HashSet set = new HashSet(remainingMixins);
-        NodeTypeImpl mixin = session.getNodeTypeManager().getNodeType(mixinName);
+        /**
+         * mix:referenceable needs special handling because it has
+         * special semantics:
+         * it can only be removed if there no more references to this node
+         */
+        NodeTypeImpl mixin = ntMgr.getNodeType(mixinName);
+        if ((MIX_REFERENCEABLE.equals(mixinName) ||
+                mixin.isDerivedFrom(MIX_REFERENCEABLE)) &&
+                !entRemaining.includesNodeType(MIX_REFERENCEABLE)) {
+            // removing this mixin would effectively remove mix:referenceable:
+            // make sure no references exist
+            PropertyIterator iter = getReferences();
+            if (iter.hasNext()) {
+                throw new ConstraintViolationException(mixinName + " can not be removed: the node is being referenced through at least one property of type REFERENCE");
+            }
+        }
+
+        // modify the state of this node
+        NodeState thisState = (NodeState) getOrCreateTransientItemState();
+        thisState.setMixinTypeNames(remainingMixins);
+
+        // set jcr:mixinTypes property
+        setMixinTypesProperty(remainingMixins);

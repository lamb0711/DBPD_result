JCR-3506 only load nodes once in batches. Because now despite the additional check overall performance has actually increased it is not necessary to be able to skip the reverse check anymore.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1442061 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.HashMap;
+import java.util.Map;
-    /**
-     * Whether to check whether all the nodes that are in the repository are indexed.
-     * When false only the check is made whether all nodes in the index are also in the repository.
-     */
-    private static final boolean CHECKREVERSE = Boolean.getBoolean("org.apache.jackrabbit.checker.index.reverse");
-
-     * All the document ids within the index.
+     * All the node ids and whether they were found in the index.
-    private Set<NodeId> documentIds;
+    private Map<NodeId, Boolean> nodeIds;
-        checkIndexToItems();
-        checkItemsToIndex();
+        loadNodes();
+        if (nodeIds != null) {
+            checkIndexConsistency();
+            checkIndexCompleteness();
+        }
-    private void checkIndexToItems() throws IOException {
+    private void loadNodes() {
+        log.info("Loading nodes");
+        try {
+            int count = 0;
+            Map<NodeId, Boolean> nodeIds = new HashMap<NodeId, Boolean>();
+            List<NodeId> batch = pm.getAllNodeIds(null, NODESATONCE);
+            while (!batch.isEmpty()) {
+                NodeId lastId = null;
+                for (NodeId nodeId : batch) {
+                    lastId = nodeId;
+
+                    count++;
+                    if (count % 1000 == 0) {
+                        log.info(pm + ": loaded " + count + " node ids...");
+                    }
+
+                    nodeIds.put(nodeId, Boolean.FALSE);
+
+                }
+                batch = pm.getAllNodeIds(lastId, NODESATONCE);
+            }
+            this.nodeIds = nodeIds;
+        } catch (ItemStateException e) {
+            log.error("Exception while loading items to check", e);
+        } catch (RepositoryException e) {
+            log.error("Exception while loading items to check", e);
+        }
+    }
+
+    private void checkIndexConsistency() throws IOException {
-        // collect all documents ids
-        documentIds = new HashSet<NodeId>();
-                if (stateMgr.hasItemState(id)) {
-                    if (!documentIds.add(id)) {
+                Boolean alreadyIndexed = nodeIds.put(id, Boolean.TRUE);
+                boolean nodeExists = alreadyIndexed != null;
+                if (nodeExists) {
+                    if (alreadyIndexed) {
-                if (parentId == null || documentIds.contains(parentId)) {
+
+                boolean parentExists = parentId != null && nodeIds.containsKey(parentId);
+                boolean parentIndexed = parentExists && nodeIds.get(parentId);
+                if (parentId == null || parentIndexed) {
+
-                if (stateMgr.hasItemState(parentId)) {
+                if (parentExists) {
+
-    private void checkItemsToIndex() {
-        if (!CHECKREVERSE) {
-            return;
-        }
-        if (pm == null) {
-            log.warn("Cannot run reverse index check with this PersistenceManager");
-            return;
-        }
+    private void checkIndexCompleteness() {
-        try {
-            int count = 0;
-            List<NodeId> batch = pm.getAllNodeIds(null, NODESATONCE);
-            while (!batch.isEmpty()) {
-                NodeId lastId = null;
-                for (NodeId nodeId : batch) {
-                    lastId = nodeId;
-
-                    count++;
-                    if (count % 1000 == 0) {
-                        log.info(pm + ": checked " + count + " node ids...");
+        int i = 0;
+        int size = nodeIds.size();
+        for (Map.Entry<NodeId, Boolean> entry : nodeIds.entrySet()) {
+            // check whether all nodes in the repository are indexed
+            NodeId nodeId = entry.getKey();
+            boolean indexed = entry.getValue();
+            try {
+                if (++i > 10 && i % (size / 10) == 0) {
+                    long progress = Math.round((100.0 * (float) i) / (float) size);
+                    log.info("progress: " + progress + "%");
+                }
+                if (!indexed && !isExcluded(nodeId)) {
+                    NodeState nodeState = getNodeState(nodeId);
+                    if (nodeState != null && !isBrokenNode(nodeId, nodeState)) {
+                        errors.add(new NodeAdded(nodeId));
-
-                    checkNode(nodeId);
-
-                batch = pm.getAllNodeIds(lastId, NODESATONCE);
+            } catch (ItemStateException e) {
+                log.error("Failed to check node: " + nodeId, e);
-        } catch (ItemStateException e) {
-            log.error("Exception while loading items to check", e);
-        } catch (RepositoryException e) {
-            log.error("Exception while loading items to check", e);
-        }
-
-    }
-
-    private void checkNode(final NodeId nodeId) {
-        try {
-            if (!documentIds.contains(nodeId) && !isExcluded(nodeId)) {
-                NodeState nodeState = getNodeState(nodeId);
-                if (nodeState != null && !isBrokenNode(nodeId, nodeState)) {
-                    errors.add(new NodeAdded(nodeId));
-                }
-            }
-        } catch (ItemStateException e) {
-            log.error("Failed to check node: " + nodeId, e);
-        StringBuffer path = new StringBuffer();
+        StringBuilder path = new StringBuilder();
-            while (ancestorId != null && !documentIds.contains(ancestorId)) {
+            while (ancestorId != null && nodeIds.containsKey(ancestorId) && nodeIds.get(ancestorId)) {
-                    documentIds.add(n.getNodeId());
+                    nodeIds.put(n.getNodeId(), Boolean.TRUE);
-                documentIds.add(node.getNodeId());
+                nodeIds.put(node.getNodeId(), Boolean.TRUE);

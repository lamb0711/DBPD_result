JCR-623 Clustering


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@471760 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.cluster.UpdateEventChannel;
+     * Update event channel.
+     */
+    private UpdateEventChannel eventChannel;
+
+    /**
+    /**
+     * Set an update event channel
+     *
+     * @param eventChannel update event channel
+     */
+    public void setEventChannel(UpdateEventChannel eventChannel) {
+        this.eventChannel = eventChannel;
+    }
+
-                events.createEventStates(rootNodeId, local,
-                        SharedItemStateManager.this);
+                events.createEventStates(rootNodeId, local, SharedItemStateManager.this);
+
+                /* let listener know about change */
+                if (eventChannel != null) {
+                    eventChannel.updateCreated(local, events);
+                }
+
+                //todo check whether local states are now stale...
+                /* let listener know about preparation */
+                if (eventChannel != null) {
+                    eventChannel.updatePrepared();
+                }
+
+                /* let listener know about finished operation */
+                if (eventChannel != null) {
+                    eventChannel.updateCommitted();
+                }
+
+                /* let listener know about cancelled operation */
+                if (eventChannel != null) {
+                    eventChannel.updateCancelled();
+                }
+
+     * Handle an external update.
+     *
+     * @param external external change containing only node and property ids.
+     * @param events events to deliver
+     */
+    public void externalUpdate(ChangeLog external, EventStateCollection events) {
+        boolean holdingWriteLock = false;
+
+        ChangeLog shared = new ChangeLog();
+
+        try {
+            acquireWriteLock();
+            holdingWriteLock = true;
+
+            Iterator modifiedStates = external.modifiedStates();
+            while (modifiedStates.hasNext()) {
+                ItemState state = (ItemState) modifiedStates.next();
+                state = cache.retrieve(state.getId());
+                if (state != null) {
+                    try {
+                        state.copy(loadItemState(state.getId()));
+                        shared.modified(state);
+                    } catch (ItemStateException e) {
+                        String msg = "Unable to retrieve state: " + state.getId();
+                        log.warn(msg, e);
+                        state.discard();
+                    }
+                }
+            }
+            Iterator deletedStates = external.deletedStates();
+            while (deletedStates.hasNext()) {
+                ItemState state = (ItemState) deletedStates.next();
+                state = cache.retrieve(state.getId());
+                if (state != null) {
+                    shared.deleted(state);
+                }
+            }
+            shared.persisted();
+
+        } catch (ItemStateException e) {
+            String msg = "Unable to acquire write lock.";
+            log.error(msg);
+        }
+
+        try {
+            acquireReadLock();
+            rwLock.writeLock().release();
+            holdingWriteLock = false;
+
+            events.dispatch();
+        } catch (ItemStateException e) {
+            String msg = "Unable to downgrade to read lock.";
+            log.error(msg);
+        } finally {
+            if (holdingWriteLock) {
+                rwLock.writeLock().release();
+                holdingWriteLock = false;
+            } else {
+                rwLock.readLock().release();
+            }
+        }
+
+    }
+
+    /**

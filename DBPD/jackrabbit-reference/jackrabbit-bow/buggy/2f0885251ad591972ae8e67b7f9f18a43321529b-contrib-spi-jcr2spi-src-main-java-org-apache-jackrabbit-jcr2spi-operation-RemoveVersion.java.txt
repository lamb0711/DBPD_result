Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.hierarchy.NodeEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.PropertyEntry;
+import org.apache.jackrabbit.jcr2spi.config.CacheBehaviour;
+import org.apache.jackrabbit.jcr2spi.version.VersionManager;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import java.util.Iterator;
-    protected RemoveVersion(ItemState removeState) {
-        super(removeState);
+    private static Logger log = LoggerFactory.getLogger(RemoveVersion.class);
+
+    private NodeEntry versionableEntry = null;
+
+    protected RemoveVersion(ItemState removeState, NodeState parent, VersionManager mgr) {
+        super(removeState, parent);
+        try {
+            versionableEntry = mgr.getVersionableNodeState((NodeState) removeState);
+        } catch (RepositoryException e) {
+            log.warn("Internal error", e);
+        }
-     * @see Operation#persisted()
+     * @see Operation#persisted(CacheBehaviour)
+     * @param cacheBehaviour
-    public void persisted() {
-        NodeState parent = removeState.getParent();
-        removeState.invalidate(true);
-        parent.invalidate(false);
+    public void persisted(CacheBehaviour cacheBehaviour) {
+        if (cacheBehaviour == CacheBehaviour.INVALIDATE) {
+            // invaliate the versionable node as well (version related properties)
+            if (versionableEntry != null) {
+                Iterator propEntries = versionableEntry.getPropertyEntries();
+                while (propEntries.hasNext()) {
+                    PropertyEntry pe = (PropertyEntry) propEntries.next();
+                    pe.invalidate(false);
+                }
+                versionableEntry.invalidate(false);
+            }
+
+            // invalidate the versionhistory entry and all its children
+            // in order to the the v-graph recalculated
+            removeState.getHierarchyEntry().getParent().invalidate(true);
+        }
-    public static Operation create(NodeState versionState) {
-        RemoveVersion rm = new RemoveVersion(versionState);
+    public static Operation create(NodeState versionState, NodeState vhState, VersionManager mgr) {
+        RemoveVersion rm = new RemoveVersion(versionState, vhState, mgr);

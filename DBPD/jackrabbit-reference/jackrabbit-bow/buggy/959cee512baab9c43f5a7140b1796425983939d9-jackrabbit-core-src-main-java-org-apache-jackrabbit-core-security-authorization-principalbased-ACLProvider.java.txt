 JCR-1588: JSR 283: Access Control

- align principalbased ac editing with latest changes made to JSR 283
   -> getApplicablePolicies(Principal) only returns policies that have not yet been set
   -> getPolicies(Principal) added -> used to modify policies that have been set before

- WorkspaceAccessManagerImpl.grants throws NoSuchWorkspaceException if an invalid
   wspName gets passed... TCK tests would fail if not executed with admin user that
   is covered by shortcut.

- Various improvements to AccessControlProvider handling
   > prevent closure of used provider
   > add AccessControlProvider#isLive that allows to rebuild the provider if it was closed before

- Simplify WriteTest and add test for changes made to principal-based ACLEditor

JCR-2087 Upgrade to Java 5 as the base platform
- use generics in security code (work in progress)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@788450 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.security.authorization.UnmodifiableAccessControlList;
-import org.apache.jackrabbit.core.security.principal.PrincipalImpl;
+import javax.jcr.security.AccessControlException;
+
+    private static final AccessControlPolicy effectivePolicy = EffectivePrincipalBasedPolicy.getInstance();
+
+                // initial default permissions for the administrators group                
+                    installDefaultPermissions(administrators,
+                        new Privilege[] {acMgr.privilegeFromName(Privilege.JCR_ALL)},
+                        restrictions, editor);
-                    log.warn("Administrators principal group is missing.");
-                    administrators = new PrincipalImpl(pName);
-                }
-                AccessControlPolicy[] acls = editor.editAccessControlPolicies(administrators);
-                ACLTemplate acl = (ACLTemplate) acls[0];
-                if (acl.isEmpty()) {
-                    log.debug("... Privilege.ALL for administrators principal.");
-                    acl.addEntry(administrators,
-                            new Privilege[] {acMgr.privilegeFromName(Privilege.JCR_ALL)},
-                            true, restrictions);
-                    editor.setPolicy(acl.getPath(), acl);
-                } else {
-                    log.debug("... policy for administrators principal already present.");
+                    log.warn("Administrators principal group is missing -> Not adding default permissions.");
-                Principal everyone = pMgr.getEveryone();
-                acls = editor.editAccessControlPolicies(everyone);
-                acl = (ACLTemplate) acls[0];
-                if (acl.isEmpty()) {
-                    log.debug("... Privilege.READ for everyone principal.");
-                    acl.addEntry(everyone,
-                            new Privilege[] {acMgr.privilegeFromName(Privilege.JCR_READ)},
-                            true, restrictions);
-                    editor.setPolicy(acl.getPath(), acl);
-                } else {
-                    log.debug("... policy for everyone principal already present.");
-                }
+                // initialize default permissions for the everyone group
+                installDefaultPermissions(pMgr.getEveryone(),
+                        new Privilege[] {acMgr.privilegeFromName(Privilege.JCR_READ)},
+                        restrictions, editor);
+    private static void installDefaultPermissions(Principal principal, Privilege[] privs, Map restrictions, AccessControlEditor editor) throws RepositoryException, AccessControlException {
+        AccessControlPolicy[] acls = editor.editAccessControlPolicies(principal);
+        if (acls.length > 0) {
+            ACLTemplate acl = (ACLTemplate) acls[0];
+            if (acl.isEmpty()) {
+                acl.addEntry(principal, privs, true, restrictions);
+                editor.setPolicy(acl.getPath(), acl);
+            } else {
+                log.debug("... policy for principal '"+principal.getName()+"' already present.");
+            }
+        } else {
+            log.debug("... policy for principal  '"+principal.getName()+"'  already present.");
+        }
+    }
+
-           TODO review
-           rep:nodePath restriction, returning the principal-based
-           policy at 'absPath' probably doesn't reveal what the caller expects.
-           Maybe it would be better not to return an empty array as
-           {@link AccessControlManager#getEffectivePolicies(String)
-           is defined to express a best-effor estimate only.
+           rep:nodePath restriction present with the individual access control
+           entries, returning the principal-based policy at 'absPath' (which for
+           most nodes in the repository isn't available anyway) doesn't
+           provide the desired information.
+           As tmp. solution some default policy is returned indicating.
+           TODO: add proper evalution and return a set of ACLs that take effect on the node at abspath
-        AccessControlPolicy[] tmpls = editor.getPolicies(session.getJCRPath(absPath));
-        AccessControlPolicy[] effectives = new AccessControlPolicy[tmpls.length];
-        for (int i = 0; i < tmpls.length; i++) {
-            effectives[i] = new UnmodifiableAccessControlList((ACLTemplate) tmpls[i]);
-        }
-        return effectives;
+        return new AccessControlPolicy[] {effectivePolicy};
+
+    /**
+     * Dummy effective policy 
+     */
+    private static final class EffectivePrincipalBasedPolicy implements AccessControlPolicy {
+
+        private static EffectivePrincipalBasedPolicy INSTANCE = new EffectivePrincipalBasedPolicy();
+        private EffectivePrincipalBasedPolicy() {
+        }
+
+        private static EffectivePrincipalBasedPolicy getInstance() {
+            return INSTANCE;
+        }
+    }

work in progress

- NodeInfo does not load information about child-node-entries
  -> add separate SPI call
  -> add initial draft ChildInfo interface
  -> ChildNodeEntries are not built upon creation of the NodeState
  -> ItemStateFactory: add method to retrieve ChildNodeEntries

- respect CacheBehaviour while persisting transient modifications

- LockInfo.getNodeId() -> not used so far -> remove

- SessionItemStateManager: getHierarchyManager() only used by SessionImpl -> moved

- Improve TODO comments
- Javadoc


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@482657 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.config.CacheBehaviour;
-    private ChildNodeEntries childNodeEntries = new ChildNodeEntries(this);
+    private ChildNodeEntries childNodeEntries;
-                init(wspState.getMixinTypeNames(), wspState.getChildNodeEntries(), wspState.getPropertyNames(), wspState.getNodeReferences());
+                init(wspState.getMixinTypeNames(), wspState.getPropertyNames(), wspState.getNodeReferences());
-     * @param childEntries
-    void init(QName[] mixinTypeNames, Collection childEntries, Collection propertyNames, NodeReferences references) {
+    void init(QName[] mixinTypeNames, Collection propertyNames, NodeReferences references) {
-        // add child node entries
-        childNodeEntries.removeAll();
-        it = childEntries.iterator();
-        while (it.hasNext()) {
-            ChildNodeEntry cne = (ChildNodeEntry) it.next();
-            childNodeEntries.add(cne.getName(), cne.getUUID(), cne.getIndex());
-        }
+    private ChildNodeEntries childNodeEntries() {
+        if (childNodeEntries == null) {
+            try {
+                childNodeEntries = isf.getChildNodeEntries(this);
+            } catch (ItemStateException e) {
+                // TODO improve
+                throw new IllegalStateException();
+            }
+        }
+        return childNodeEntries;
+    }
-                NodeState tmp = isf.createNodeState(getNodeId(), parent);
+                NodeState tmp = isf.createNodeState(getNodeId(), getParent());
-                parent.childNodeEntries.remove(this);
+                getParent().childNodeEntries().remove(this);
-                // todo rather throw? remove from parent?
+                // TODO rather throw? remove from parent?
-                    if (!childNodeEntries.contains(childName, index, cne.getUUID())) {
+                    if (!childNodeEntries().contains(childName, index, cne.getUUID())) {
-                        childNodeEntries.add(childName, cne.getUUID(), index);
+                        childNodeEntries().add(childName, cne.getUUID(), index);
-                        toRemove = !nState.childNodeEntries.contains(childName, index, cne.getUUID());
+                        toRemove = !nState.childNodeEntries().contains(childName, index, cne.getUUID());
-                            childNodeEntries.remove(childName, ((ChildNodeEntry)ce).getIndex());
+                            childNodeEntries().remove(childName, ((ChildNodeEntry)ce).getIndex());
-            for (Iterator it = getAllChildEntries(false, false); it.hasNext();) {
+            // invalidate all child entries including properties present in the
+            // attic (removed props shadowed by a new property with the same name).
+            for (Iterator it = getAllChildEntries(false, true); it.hasNext();) {
-            // TODO: props-in-attic?
-            // todo only invalidate if existing?
+            // TODO only invalidate if existing?
-        NodeState parent = getParent();
-        } else if (parent != null) {
+        }
+
+        NodeState parent = getParent();
+        if (parent == null) {
+           // root node
+            return idFactory.createNodeId((String) null, Path.ROOT);
+        } else {
-            for (Iterator it = parent.childNodeEntries.get(name).iterator(); it.hasNext(); ) {
+            for (Iterator it = parent.childNodeEntries().get(name).iterator(); it.hasNext(); ) {
-        } else {
-            // root node
-            return idFactory.createNodeId((String) null, Path.ROOT);
-                getParent().childNodeEntries.replaceEntry(this);
+                getParent().childNodeEntries().replaceEntry(this);
-        if (parent == null) {
+        if (getParent() == null) {
-            ChildNodeEntry entry = getParent().childNodeEntries.get(this);
+            ChildNodeEntry entry = getParent().childNodeEntries().get(this);
-        return containsValidChildNodeEntry(childNodeEntries);
+        return containsValidChildNodeEntry(childNodeEntries());
-        return containsValidChildNodeEntry(childNodeEntries.get(name));
+        return containsValidChildNodeEntry(childNodeEntries().get(name));
-        return isValidChildNodeEntry(childNodeEntries.get(name, index));
+        return isValidChildNodeEntry(childNodeEntries().get(name, index));
-        ChildNodeEntry cne = childNodeEntries.get(nodeName, index);
+        ChildNodeEntry cne = childNodeEntries().get(nodeName, index);
-            cne = childNodeEntries.get(null, uuid);
+            cne = childNodeEntries().get(null, uuid);
-            cne = childNodeEntries.get(nameElement.getName(), nameElement.getIndex());
+            cne = childNodeEntries().get(nameElement.getName(), nameElement.getIndex());
-        for (Iterator it = childNodeEntries.iterator(); it.hasNext();) {
+        for (Iterator it = childNodeEntries().iterator(); it.hasNext();) {
-        for (Iterator it = childNodeEntries.get(nodeName).iterator(); it.hasNext();) {
+        for (Iterator it = childNodeEntries().get(nodeName).iterator(); it.hasNext();) {
-        List sns = childNodeEntries.get(cne.getName());
+        List sns = childNodeEntries().get(cne.getName());
-                ChildNodeEntry cne = (uuid != null) ? childNodeEntries.get(name, uuid) : childNodeEntries.get(name, index);
+                ChildNodeEntry cne = (uuid != null) ? childNodeEntries().get(name, uuid) : childNodeEntries().get(name, index);
-                    cne = childNodeEntries.add(name, uuid, index);
+                    cne = childNodeEntries().add(name, uuid, index);
-                    childNodeEntries.remove(name, index);
+                    childNodeEntries().remove(name, index);
-     * @see ItemState#persisted(ChangeLog)
+     * @see ItemState#persisted(ChangeLog, CacheBehaviour)
-    void persisted(ChangeLog changeLog) throws IllegalStateException {
-        // TODO: review...in case of CacheBehaviour.MANUAL and .INVALIDATION, some states must be invalidate (e.g. autocreated)
+    void persisted(ChangeLog changeLog, CacheBehaviour cacheBehaviour)
+        throws IllegalStateException {
+        checkIsSessionState();
+
-                    overlayedParent.childNodeEntries.remove((NodeState)state.overlayedState);
+                    overlayedParent.childNodeEntries().remove((NodeState)state.overlayedState);
-            // TODO: only retrieve overlayed state, if necessary
+            // TODO: improve. only retrieve overlayed state, if necessary
-                    int index = parent.childNodeEntries.get((NodeState)addedState).getIndex();
+                    int index = parent.childNodeEntries().get((NodeState)addedState).getIndex();
-                        cne = overlayedParent.childNodeEntries.add(addedState.getQName(), null, index);
+                        cne = overlayedParent.childNodeEntries().add(addedState.getQName(), null, index);
-                        overlayedParent.childNodeEntries.replaceEntry(overlayed);
+                        overlayedParent.childNodeEntries().replaceEntry(overlayed);
-                    NodeState newParent = (NodeState) modState.parent.overlayedState;
+                    NodeState newParent = (NodeState) modState.getParent().overlayedState;
-                        overlayed.parent.moveEntry(newParent, overlayed, modNodeState.getQName(), modNodeState.getDefinition());
+                        overlayed.getParent().moveEntry(newParent, overlayed, modNodeState.getQName(), modNodeState.getDefinition());
-            adjustNodeState(parent, (PropertyState[]) l.toArray(new PropertyState[l.size()]));
+            if (cacheBehaviour == CacheBehaviour.OBSERVATION) {
+                adjustNodeState(parent, (PropertyState[]) l.toArray(new PropertyState[l.size()]));
+            } else {
+                // TODO: improve. invalidate necessary states only
+                parent.invalidate(false);
+            }
-                // error: state has not been processed
-                // TODO: discard state and force reload of all data
+                // should not occur: state has not been processed
+                log.error("State " + state + " has not been processed upon ChangeLog.persisted => invalidate");
+                state.invalidate(false);
-        childNodeEntries.add(child);
+        childNodeEntries().add(child);
-                    childNodeEntries.remove((NodeState) childState);
+                    childNodeEntries().remove((NodeState) childState);
-                // TODO: not correct. removing a NEW state may even remove the 'modified'
+                // TODO: TOBEFIXED. removing a NEW state may even remove the 'modified'
-        childNodeEntries.reorder(insertNode, beforeNode);
+        childNodeEntries().reorder(insertNode, beforeNode);
-        ChildNodeEntry oldEntry = childNodeEntries.remove(childState);
+        ChildNodeEntry oldEntry = childNodeEntries().remove(childState);
-            newParent.childNodeEntries.add(childState);
+            newParent.childNodeEntries().add(childState);
-            List children = new ArrayList(childNodeEntries);
+            List children = new ArrayList(childNodeEntries());
-                its = new Iterator[] {propertiesInAttic.values().iterator(), properties.values().iterator(), childNodeEntries.iterator()};
+                its = new Iterator[] {propertiesInAttic.values().iterator(), properties.values().iterator(), childNodeEntries().iterator()};
-                its = new Iterator[] {properties.values().iterator(),
-                    childNodeEntries.iterator()};
+                its = new Iterator[] {properties.values().iterator(), childNodeEntries().iterator()};
-        if (modState.parent == null) {
+        if (modState.getParent() == null) {
-            return modState.overlayedState.parent != modState.parent.overlayedState;
+            return modState.overlayedState.getParent() != modState.getParent().overlayedState;

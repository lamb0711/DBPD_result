- fixed/tweaked ItemState Serializable support
- fixed minor issue in ChangeLog.merge
- tweaked SimpleDbPersistenceManager.store(PropertyState) and .store(NodeState) methods

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@330828 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.util.Base64;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.StringWriter;
-    /** Serialization UID of this class. */
-    static final long serialVersionUID = 8960688206140247183L;
+    /**
+     * Serialization UID of this class.
+     */
+    static final long serialVersionUID = 4569719974514326906L;
-        //out.writeObject(name);
-            out.writeObject(null);
+            out.writeShort(-1);
-            String[] strings = new String[values.length];
+            out.writeShort(values.length);
-                        // use 32k initial buffer size as binary data is
-                        // probably not just a couple of bytes
-                        StringWriter writer = new StringWriter(32768);
+                        out.writeLong(blob.getLength());
+                        byte[] buf = new byte[0x2000];
-                            Base64.encode(in, writer);
+                            int read;
+                            while ((read = in.read(buf)) > 0) {
+                                out.write(buf, 0, read);
+                            }
-                            writer.close();
-                        strings[i] = writer.toString();
-                        strings[i] = val.toString();
+                        out.writeUTF(val.toString());
-            out.writeObject(strings);
-    private void readObject(ObjectInputStream in)
-            throws IOException, ClassNotFoundException {
+    private void readObject(ObjectInputStream in) throws IOException {
-        //name = (QName) in.readObject();
-        Object obj = in.readObject();
-        if (obj == null) {
+        short count = in.readShort(); // # of values
+        if (count < 0) {
-            String[] strings = (String[]) obj;
-            values = new InternalValue[strings.length];
-            for (int i = 0; i < strings.length; i++) {
-                String str = strings[i];
+            values = new InternalValue[count];
+            for (int i = 0; i < values.length; i++) {
-                    ByteArrayOutputStream bos = new ByteArrayOutputStream(str.length());
-                    Base64.decode(str, bos);
-                    bos.close();
-                    values[i] = InternalValue.create(new ByteArrayInputStream(bos.toByteArray()));
+                    final long length = in.readLong();
+                    final InputStream stream = in;
+                    // create InputStream wrapper of size 'length'
+                    values[i] = InternalValue.create(new InputStream() {
+
+                        long consumed = 0;
+
+                        public int read() throws IOException {
+                            if (consumed >= length) {
+                                return -1;  // eof
+                            }
+                            int b = stream.read();
+                            consumed++;
+                            return b;
+                        }
+
+                        public int read(byte b[], int off, int len) throws IOException {
+                            if (consumed >= length) {
+                                return -1;  // eof
+                            }
+                            if ((consumed + len) > length) {
+                                len = (int) (length - consumed);
+                            }
+                            int read = super.read(b, off, len);
+                            consumed += read;
+                            return read;
+                        }
+
+                        public long skip(long n) throws IOException {
+                            if (consumed >= length && n > 0) {
+                                return -1;  // eof
+                            }
+                            if ((consumed + n) > length) {
+                                n = length - consumed;
+                            }
+                            long skipped = super.skip(n);
+                            consumed += skipped;
+                            return skipped;
+                        }
+
+                        public void close() {
+                            // nop
+                        }
+                    });
-                    values[i] = InternalValue.valueOf(str, type);
+                    values[i] = InternalValue.valueOf(in.readUTF(), type);

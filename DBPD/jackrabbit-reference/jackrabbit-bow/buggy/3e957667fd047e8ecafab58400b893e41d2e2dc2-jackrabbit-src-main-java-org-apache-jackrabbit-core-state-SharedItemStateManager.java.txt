Make versioning transactional
- Added specialized XAVersion and XAVersionHistory objects that refresh their internal state when needed
- Defined new observation interface in order to have VersionManagerImpl use standard event dispatching
  instead of writing its own
- Added test cases verifying isolation of versioning operations in transactions


git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@368026 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.observation.ObservationManagerImpl;
+import org.apache.jackrabbit.core.observation.EventStateCollectionFactory;
+import javax.jcr.RepositoryException;
+     * Flag indicating whether this item state manager uses node references to
+     * verify integrity of its reference properties.
+     */
+    private final boolean usesReferences;
+
+    /**
-                                  NodeTypeRegistry ntReg)
+                                  NodeTypeRegistry ntReg,
+                                  boolean usesReferences)
+        this.usesReferences = usesReferences;
-     * Store modifications registered in a <code>ChangeLog</code>. The items
-     * contained in the <tt>ChangeLog</tt> are not states returned by this
-     * item state manager but rather must be reconnected to items provided
-     * by this state manager.<p/>
-     * After successfully storing the states the observation manager is informed
-     * about the changes, if an observation manager is passed to this method.<p/>
-     * NOTE: This method is not synchronized, because all methods it invokes
-     * on instance members (such as {@link PersistenceManager#store} are
-     * considered to be thread-safe. Should this ever change, the
-     * synchronization status has to be re-examined.
-     *
-     * @param local  change log containing local items
-     * @param obsMgr the observation manager to inform, or <code>null</code> if
-     *               no observation manager should be informed.
-     * @throws ReferentialIntegrityException if a new or modified REFERENCE
-     *                                       property refers to a non-existent
-     *                                       target or if a removed node is still
-     *                                       being referenced
-     * @throws StaleItemStateException       if at least one of the affected item
-     *                                       states has become stale
-     * @throws ItemStateException            if another error occurs
+     * Object representing a single update operation.
-    public void store(ChangeLog local, ObservationManagerImpl obsMgr)
-            throws ReferentialIntegrityException, StaleItemStateException,
-            ItemStateException {
-
-        ChangeLog shared = new ChangeLog();
+    class Update {
-         * array of lists of dirty virtual node references per virtual provider.
-         * since NV-type references must be persisted via the respective VISP
-         * and not by the SISM, they are filtered out below.
-         *
-         * todo: FIXME handling of virtual node references is erm...  messy
-         *       VISP are eventually replaced by a more general 'mounting'
-         *       mechanism, probably on the API level and not on the item state
-         *       layer.
+         * Local change log.
-        List[] virtualNodeReferences = new List[virtualProviders.length];
+        private final ChangeLog local;
-        EventStateCollection events = null;
-        if (obsMgr != null) {
-            events = obsMgr.createEventStateCollection();
-            events.prepareDeleted(local);
+        /**
+         * Event state collection factory.
+         */
+        private final EventStateCollectionFactory factory;
+
+        /**
+         * Virtual provider containing references to be left out when updating
+         * references.
+         */
+        private final VirtualItemStateProvider virtualProvider;
+
+        /**
+         * Shared change log.
+         */
+        private ChangeLog shared;
+
+        /**
+         * Virtual node references.
+         */
+        private List[] virtualNodeReferences;
+
+        /**
+         * Events to dispatch.
+         */
+        private EventStateCollection events;
+
+        /**
+         * Create a new instance of this class.
+         */
+        public Update(ChangeLog local, EventStateCollectionFactory factory,
+                      VirtualItemStateProvider virtualProvider) {
+            this.local = local;
+            this.factory = factory;
+            this.virtualProvider = virtualProvider;
-        acquireWriteLock();
-        boolean holdingWriteLock = true;
+        /**
+         * Begin update operation. Prepares everything upto the point where
+         * the persistence manager's <code>store</code> method may be invoked.
+         * If this method succeeds, a write lock will have been acquired on the
+         * item state manager and either {@link #end()} or {@link #cancel()} has
+         * to be called in order to release it.
+         */
+        public void begin() throws ItemStateException, ReferentialIntegrityException {
+            shared = new ChangeLog();
-        try {
-            /**
-             * Update node references based on modifications in change log
-             * (added/modified/removed REFERENCE properties)
-             */
-            updateReferences(local);
-            /**
-             * Check whether reference targets exist/were not removed
-             */
-            checkReferentialIntegrity(local);
+            virtualNodeReferences = new List[virtualProviders.length];
+
+            try {
+                events = factory.createEventStateCollection();
+            } catch (RepositoryException e) {
+                String msg = "Unable to create event state collection.";
+                log.error(msg);
+                throw new ItemStateException(msg, e);
+            }
+
+            acquireWriteLock();
+                if (usesReferences) {
+                    /**
+                     * Update node references based on modifications in change log
+                     * (added/modified/removed REFERENCE properties)
+                     */
+                    updateReferences(local, virtualProvider);
+                }
+
+                /**
+                 * Check whether reference targets exist/were not removed
+                 */
+                checkReferentialIntegrity(local);
+
-                if (events != null) {
-                    events.createEventStates(rootNodeUUID, local, this);
-                }
+                events.createEventStates(rootNodeUUID, local,
+                        SharedItemStateManager.this);
+                succeeded = true;
+
+            } finally {
+                if (!succeeded) {
+                    cancel();
+                }
+            }
+        }
+
+        /**
+         * End update operation. This will store the changes to the associated
+         * <code>PersistenceManager</code>. At the end of this operation, an
+         * eventual read or write lock on the item state manager will have
+         * been released.
+         * @throws ItemStateException if some error occurs
+         */
+        public void end() throws ItemStateException {
+            boolean succeeded = false;
+
+            try {
+            } finally {
+                if (!succeeded) {
+                    cancel();
+                }
+            }
+
+            boolean holdingWriteLock = true;
+
+            try {
+                /* Let the shared item listeners know about the change */
+                shared.persisted();
+
+                /* notify virtual providers about node references */
+                for (int i = 0; i < virtualNodeReferences.length; i++) {
+                    List virtualRefs = virtualNodeReferences[i];
+                    if (virtualRefs != null) {
+                        for (Iterator iter = virtualRefs.iterator(); iter.hasNext();) {
+                            NodeReferences refs = (NodeReferences) iter.next();
+                            virtualProviders[i].setNodeReferences(refs);
+                        }
+                    }
+                }
+
+                // downgrade to read lock
+                acquireReadLock();
+                rwLock.writeLock().release();
+                holdingWriteLock = false;
+
+                /* dispatch the events */
+                events.dispatch();
-
-                /**
-                 * If some store operation was unsuccessful, we have to reload
-                 * the state of modified and deleted items from persistent
-                 * storage.
-                 */
-                if (!succeeded) {
-                    local.disconnect();
-
-                    for (Iterator iter = shared.modifiedStates(); iter.hasNext();) {
-                        ItemState state = (ItemState) iter.next();
-                        try {
-                            state.copy(loadItemState(state.getId()));
-                        } catch (ItemStateException e) {
-                            state.discard();
-                        }
-                    }
-                    for (Iterator iter = shared.deletedStates(); iter.hasNext();) {
-                        ItemState state = (ItemState) iter.next();
-                        try {
-                            state.copy(loadItemState(state.getId()));
-                        } catch (ItemStateException e) {
-                            state.discard();
-                        }
-                    }
-                    for (Iterator iter = shared.addedStates(); iter.hasNext();) {
-                        ItemState state = (ItemState) iter.next();
-                        state.discard();
-                    }
+                if (holdingWriteLock) {
+                    // exception occured before downgrading lock
+                    rwLock.writeLock().release();
+                } else {
+                    rwLock.readLock().release();
-
-            /* Let the shared item listeners know about the change */
-            shared.persisted();
-
-            /* notify virtual providers about node references */
-            for (int i = 0; i < virtualNodeReferences.length; i++) {
-                List virtualRefs = virtualNodeReferences[i];
-                if (virtualRefs != null) {
-                    for (Iterator iter = virtualRefs.iterator(); iter.hasNext();) {
-                        NodeReferences refs = (NodeReferences) iter.next();
-                        virtualProviders[i].setNodeReferences(refs);
-                    }
-                }
-            }
-
-            // downgrade to read lock
-            acquireReadLock();
-            rwLock.writeLock().release();
-            holdingWriteLock = false;
-
-            /* dispatch the events */
-            if (events != null) {
-                events.dispatch();
-            }
-        } finally {
-            if (holdingWriteLock) {
-                // exception occured before downgrading lock
-                rwLock.writeLock().release();
-            } else {
-                rwLock.readLock().release();
-            }
+
+        /**
+         * Cancel update operation. At the end of this operation, the write lock
+         * on the item state manager will have been released.
+         */
+        public void cancel() {
+            local.disconnect();
+
+            for (Iterator iter = shared.modifiedStates(); iter.hasNext();) {
+                ItemState state = (ItemState) iter.next();
+                try {
+                    state.copy(loadItemState(state.getId()));
+                } catch (ItemStateException e) {
+                    state.discard();
+                }
+            }
+            for (Iterator iter = shared.deletedStates(); iter.hasNext();) {
+                ItemState state = (ItemState) iter.next();
+                try {
+                    state.copy(loadItemState(state.getId()));
+                } catch (ItemStateException e) {
+                    state.discard();
+                }
+            }
+            for (Iterator iter = shared.addedStates(); iter.hasNext();) {
+                ItemState state = (ItemState) iter.next();
+                state.discard();
+            }
+            rwLock.writeLock().release();
+        }
+    }
+
+    /**
+     * Begin update operation. This will return an object that can itself be
+     * ended/cancelled.
+     */
+    public Update beginUpdate(ChangeLog local, EventStateCollectionFactory factory,
+                              VirtualItemStateProvider virtualProvider)
+            throws ReferentialIntegrityException, StaleItemStateException,
+                   ItemStateException {
+
+        Update update = new Update(local, factory, virtualProvider);
+        update.begin();
+        return update;
+    }
+
+    /**
+     * Store modifications registered in a <code>ChangeLog</code>. The items
+     * contained in the <tt>ChangeLog</tt> are not states returned by this
+     * item state manager but rather must be reconnected to items provided
+     * by this state manager.<p/>
+     * After successfully storing the states the observation manager is informed
+     * about the changes, if an observation manager is passed to this method.<p/>
+     * NOTE: This method is not synchronized, because all methods it invokes
+     * on instance members (such as {@link PersistenceManager#store} are
+     * considered to be thread-safe. Should this ever change, the
+     * synchronization status has to be re-examined.
+     *
+     * @param local   change log containing local items
+     * @param factory event state collection factory
+     * @throws ReferentialIntegrityException if a new or modified REFERENCE
+     *                                       property refers to a non-existent
+     *                                       target or if a removed node is still
+     *                                       being referenced
+     * @throws StaleItemStateException       if at least one of the affected item
+     *                                       states has become stale
+     * @throws ItemStateException            if another error occurs
+     */
+    public void update(ChangeLog local, EventStateCollectionFactory factory)
+            throws ReferentialIntegrityException, StaleItemStateException,
+                   ItemStateException {
+
+        beginUpdate(local, factory, null).end();
+     * @param virtualProvider virtual provider that may already contain a
+     *                        node references object
-    protected void updateReferences(ChangeLog changes) throws ItemStateException {
+    protected void updateReferences(ChangeLog changes, 
+                                    VirtualItemStateProvider virtualProvider) 
+            throws ItemStateException {
+                        if (virtualProvider != null && 
+                                virtualProvider.hasNodeReferences(refsId)) {
+                            continue;
+                        }
+                        if (virtualProvider != null && 
+                                virtualProvider.hasNodeReferences(refsId)) {
+                            continue;
+                        }
+                        if (virtualProvider != null && 
+                                virtualProvider.hasNodeReferences(refsId)) {
+                            continue;
+                        }
+                        if (virtualProvider != null && 
+                                virtualProvider.hasNodeReferences(refsId)) {
+                            continue;
+                        }

JCR-2715: Improved join query performance

Fix all remaining TCK test failures with the new QOM/SQL2 implementation
and enable it for all QOM/SQL2 queries

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1039888 13f79535-47bb-0310-9956-ffa450edef68

-import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_OPERATOR_EQUAL_TO;
-import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_OPERATOR_GREATER_THAN;
-import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_OPERATOR_GREATER_THAN_OR_EQUAL_TO;
-import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_OPERATOR_LESS_THAN;
-import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_OPERATOR_LESS_THAN_OR_EQUAL_TO;
-import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_OPERATOR_LIKE;
-import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_OPERATOR_NOT_EQUAL_TO;
+import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_JOIN_TYPE_LEFT_OUTER;
+import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_JOIN_TYPE_RIGHT_OUTER;
+import java.io.IOException;
-import java.util.Locale;
-import javax.jcr.Node;
-import javax.jcr.NodeIterator;
-import javax.jcr.PropertyType;
-import javax.jcr.RangeIterator;
+import javax.jcr.nodetype.NoSuchNodeTypeException;
-import javax.jcr.query.Query;
-import javax.jcr.query.QueryManager;
+import javax.jcr.query.InvalidQueryException;
-import javax.jcr.query.qom.And;
-import javax.jcr.query.qom.BindVariableValue;
-import javax.jcr.query.qom.ChildNode;
-import javax.jcr.query.qom.Comparison;
-import javax.jcr.query.qom.DescendantNode;
-import javax.jcr.query.qom.FullTextSearch;
-import javax.jcr.query.qom.Literal;
-import javax.jcr.query.qom.LowerCase;
-import javax.jcr.query.qom.Not;
-import javax.jcr.query.qom.Or;
-import javax.jcr.query.qom.PropertyExistence;
-import javax.jcr.query.qom.SameNode;
-import javax.jcr.query.qom.UpperCase;
-import org.apache.jackrabbit.commons.iterator.NodeIteratorAdapter;
-import org.apache.jackrabbit.commons.iterator.RangeIteratorAdapter;
+import org.apache.jackrabbit.core.query.lucene.LuceneQueryFactory;
-    private final Session session;
+    private final LuceneQueryFactory lqf;
-    public QueryEngine(Session session, Map<String, Value> variables)
-            throws RepositoryException {
-        this.session = session;
+    public QueryEngine(
+            Session session, LuceneQueryFactory lqf,
+            Map<String, Value> variables) throws RepositoryException {
+        this.lqf = lqf;
+            if (join.getJoinType() == JCR_JOIN_TYPE_RIGHT_OUTER) {
+                // Swap the join sources to normalize all outer joins to left
+                join = qomFactory.join(
+                        join.getRight(), join.getLeft(),
+                        JCR_JOIN_TYPE_LEFT_OUTER, join.getJoinCondition());
+            }
-    private String toSqlConstraint(Constraint constraint)
-            throws RepositoryException {
-        if (constraint instanceof And) {
-            And and = (And) constraint;
-            String c1 = toSqlConstraint(and.getConstraint1());
-            String c2 = toSqlConstraint(and.getConstraint2());
-            return "(" + c1 + ") AND (" + c2 + ")";
-        } else if (constraint instanceof Or) {
-            Or or = (Or) constraint;
-            String c1 = toSqlConstraint(or.getConstraint1());
-            String c2 = toSqlConstraint(or.getConstraint2());
-            return "(" + c1 + ") OR (" + c2 + ")";
-        } else if (constraint instanceof Not) {
-            Not or = (Not) constraint;
-            return "NOT (" + toSqlConstraint(or.getConstraint()) + ")";
-        } else if (constraint instanceof Comparison) {
-            Comparison c = (Comparison) constraint;
-            String left = toSqlOperand(c.getOperand1());
-            String right = toSqlOperand(c.getOperand2());
-            if (c.getOperator().equals(JCR_OPERATOR_EQUAL_TO)) {
-                return left + " = " + right;
-            } else if (c.getOperator().equals(JCR_OPERATOR_GREATER_THAN)) {
-                return left + " > " + right;
-            } else if (c.getOperator().equals(JCR_OPERATOR_GREATER_THAN_OR_EQUAL_TO)) {
-                return left + " >= " + right;
-            } else if (c.getOperator().equals(JCR_OPERATOR_LESS_THAN)) {
-                return left + " < " + right;
-            } else if (c.getOperator().equals(JCR_OPERATOR_LESS_THAN_OR_EQUAL_TO)) {
-                return left + " <= " + right;
-            } else if (c.getOperator().equals(JCR_OPERATOR_LIKE)) {
-                return left + " LIKE " + right;
-            } else if (c.getOperator().equals(JCR_OPERATOR_NOT_EQUAL_TO)) {
-                return left + " <> " + right;
-            } else {
-                throw new RepositoryException("Unsupported comparison: " + c);
-            }
-        } else if (constraint instanceof SameNode) {
-            SameNode sn = (SameNode) constraint;
-            return "jcr:path = '" + sn.getPath() + "'";
-        } else if (constraint instanceof ChildNode) {
-            ChildNode cn = (ChildNode) constraint;
-            return "jcr:path LIKE '" + cn.getParentPath() + "/%'";
-        } else if (constraint instanceof DescendantNode) {
-            DescendantNode dn = (DescendantNode) constraint;
-            return "jcr:path LIKE '" + dn.getAncestorPath() + "/%'";
-        } else if (constraint instanceof PropertyExistence) {
-            PropertyExistence pe = (PropertyExistence) constraint;
-            return pe.getPropertyName() + " IS NOT NULL";
-        } else if (constraint instanceof FullTextSearch) {
-            FullTextSearch fts = (FullTextSearch) constraint;
-            String expr = toSqlOperand(fts.getFullTextSearchExpression());
-            return "CONTAINS(" + fts.getPropertyName() + ", " + expr + ")";
-        } else  {
-            throw new RepositoryException("Unsupported constraint: " + constraint);
-        }
-    }
-
-    private static enum Transform {
-        NONE,
-        UPPER,
-        LOWER
-    }
-
-    private String toSqlOperand(Operand operand) throws RepositoryException {
-        return toSqlOperand(operand, Transform.NONE);
-    }
-
-    private String toSqlOperand(Operand operand, Transform transform)
-            throws RepositoryException {
-        if (operand instanceof PropertyValue) {
-            PropertyValue pv = (PropertyValue) operand;
-            switch (transform) {
-            case UPPER:
-                return "UPPER(" + pv.getPropertyName() + ")";
-            case LOWER:
-                return "LOWER(" + pv.getPropertyName() + ")";
-            default:
-                return pv.getPropertyName();
-            } 
-        } else if (operand instanceof LowerCase) {
-            LowerCase lc = (LowerCase) operand;
-            if (transform == Transform.NONE) {
-                transform = Transform.LOWER;
-            }
-            return toSqlOperand(lc.getOperand(), transform);
-        } else if (operand instanceof UpperCase) {
-            UpperCase uc = (UpperCase) operand;
-            if (transform == Transform.NONE) {
-                transform = Transform.UPPER;
-            }
-            return toSqlOperand(uc.getOperand(), transform);
-        } else if ((operand instanceof Literal)
-                || (operand instanceof BindVariableValue)) {
-            Value value = evaluator.getValue(operand, null);
-            int type = value.getType();
-            if (type == PropertyType.LONG || type == PropertyType.DOUBLE) {
-                return value.getString();
-            } else if (type == PropertyType.DATE && transform == Transform.NONE) {
-                return "TIMESTAMP '" + value.getString() + "'";
-            } else if (transform == Transform.UPPER) {
-                return "'" + value.getString().toUpperCase(Locale.ENGLISH) + "'";
-            } else if (transform == Transform.LOWER) {
-                return "'" + value.getString().toLowerCase(Locale.ENGLISH) + "'";
-            } else {
-                return "'" + value.getString() + "'";
-            }
-        } else {
-            throw new RepositoryException("Uknown operand type: " + operand);
-        }
-    }
-
-        StringBuilder builder = new StringBuilder();
-        builder.append("SELECT * FROM ");
-        builder.append(selector.getNodeTypeName());
-        if (constraint != null) {
-            builder.append(" WHERE ");
-            builder.append(toSqlConstraint(constraint));
-        }
-
-        QueryManager manager = session.getWorkspace().getQueryManager();
-        Query query = manager.createQuery(builder.toString(), Query.SQL);
-
-        final String[] selectorNames =
+        String[] selectorNames =
-        final Map<String, PropertyValue> columnMap =
+        Map<String, PropertyValue> columnMap =
-        final String[] columnNames =
+        String[] columnNames =
-        NodeIterator nodes = query.execute().getNodes();
-        final String selectorName = selector.getSelectorName();
-        RowIterator rows = new RowIteratorAdapter(nodes) {
-            @Override
-            public Object next() {
-                Node node = (Node) super.next();
-                return new SelectorRow(
-                        columnMap, evaluator, selectorName, node, 1.0);
-            }
-        };
-
-        QueryResult result =
-            new SimpleQueryResult(columnNames, selectorNames, rows);
-        return sort(result, orderings, offset, limit);
+        try {
+            RowIterator rows = new RowIteratorAdapter(lqf.execute(
+                    columnMap, selector, constraint));
+            QueryResult result =
+                new SimpleQueryResult(columnNames, selectorNames, rows);
+            return sort(result, orderings, offset, limit);
+        } catch (IOException e) {
+            throw new RepositoryException(
+                    "Failed to access the query index", e);
+        }
-                    selector.getSelectorName(),
-                    ntManager.getNodeType(selector.getNodeTypeName()));
+                    selector.getSelectorName(), getNodeType(selector));
+    private NodeType getNodeType(Selector selector) throws RepositoryException {
+        try {
+            return ntManager.getNodeType(selector.getNodeTypeName());
+        } catch (NoSuchNodeTypeException e) {
+            throw new InvalidQueryException(
+                    "Selected node type does not exist: " + selector, e);
+        }
+    }
+
-            if (offset != 0 || limit >= 0) {
-                int from = (int) offset;
-                int to = rows.size();
-                if (limit >= 0 && offset + limit < to) {
-                    to = (int) (offset + limit);
-                }
-                rows = rows.subList(from, to);
+            if (offset > 0) {
+                int size = rows.size();
+                rows = rows.subList((int) Math.min(offset, size), size);
+            }
+            if (limit >= 0) {
+                int size = rows.size();
+                rows = rows.subList(0, (int) Math.min(limit, size));

JCR-1855: Update to Lucene 2.4.1

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@756444 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.lucene.search.Hits;
-import org.apache.lucene.index.IndexReader;
-import org.apache.jackrabbit.core.NodeId;
-
-/**
- * Wraps the lucene <code>Hits</code> object and adds a close method that allows
- * to release resources after a query has been executed and the results have
- * been read completely.
- */
-public class LuceneQueryHits extends AbstractQueryHits {
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.index.IndexReader;
+import org.apache.jackrabbit.core.NodeId;
+import org.apache.jackrabbit.uuid.UUID;
-    /**
-     * The lucene hits we wrap.
-     */
-    private final Hits hits;
+/**
+ * Wraps a lucene query result and adds a close method that allows to release
+ * resources after a query has been executed and the results have been read
+ * completely.
+ */
+public class LuceneQueryHits implements QueryHits {
-     * The index of the current hit. Initially invalid.
+     * The scorer for the query.
-    private int hitIndex = -1;
+    private final Scorer scorer;
-    /**
-     * Creates a new <code>QueryHits</code> instance wrapping <code>hits</code>.
-     * @param hits the lucene hits.
-     * @param reader the IndexReader in use by <code>hits</code>.
-     */
-    public LuceneQueryHits(Hits hits, IndexReader reader) {
-        this.hits = hits;
+    public LuceneQueryHits(IndexReader reader,
+                           IndexSearcher searcher,
+                           Query query)
+            throws IOException {
+        this.scorer = query.weight(searcher).scorer(reader);
-    public final int getSize() {
-      return hits.length();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public final ScoreNode nextScoreNode() throws IOException {
-        if (++hitIndex >= hits.length()) {
+    public ScoreNode nextScoreNode() throws IOException {
+        if (!scorer.next()) {
-        String uuid = reader.document(id(hitIndex), FieldSelectors.UUID).get(FieldNames.UUID);
-        return new ScoreNode(NodeId.valueOf(uuid), hits.score(hitIndex));
+        String uuid = reader.document(scorer.doc()).get(FieldNames.UUID);
+        NodeId id = new NodeId(UUID.fromString(uuid));
+        return new ScoreNode(id, scorer.score());
-     * Skips <code>n</code> hits.
-     *
-     * @param n the number of hits to skip.
-     * @throws IOException if an error occurs while skipping.
+     * {@inheritDoc}
+     */
+    public void close() throws IOException {
+        // make sure scorer frees resources
+        scorer.skipTo(Integer.MAX_VALUE);
+    }
+
+    /**
+     * @return always -1.
+     */
+    public int getSize() {
+        return -1;
+    }
+
+    /**
+     * {@inheritDoc}
-        hitIndex += n;
-    }
-
-    //-------------------------------< internal >-------------------------------
-
-    /**
-     * Returns the document number for the <code>n</code><sup>th</sup> document
-     * in this QueryHits.
-     *
-     * @param n index.
-     * @return the document number for the <code>n</code><sup>th</sup>
-     *         document.
-     * @throws IOException if an error occurs.
-     */
-    private final int id(int n) throws IOException {
-        return hits.id(n);
+        while (n-- > 0) {
+            if (nextScoreNode() == null) {
+                return;
+            }
+        }

JCR-131: simplifying internal data model (NodeState) by limiting a node to *one* parent



git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@191499 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.Constants;
+import org.apache.jackrabbit.core.ZombieHierarchyManager;
-import java.util.Random;
-        hierMgr = new CachingHierarchyManager(rootNodeUUID, this,
-                nsResolver, transientStateMgr.getAttic());
-    }
-
-    /**
-     * En-/Disable chaching of path values.
-     * <p/>
-     * Paths are always cached, therefore this method has no implementation.
-     * @param enable <code>true</code> to enable caching;
-     *               <code>false</code> to disable
-     */
-    public void enablePathCaching(boolean enable) {
+        hierMgr = new CachingHierarchyManager(rootNodeUUID, this, nsResolver);
-        // @todo need a more efficient way to find descendents in cache (e.g. using hierarchical index)
-        Path[] parentPaths;
+        Path parentPath;
-            parentPaths = hierMgr.getAllPaths(parentId);
+            parentPath = hierMgr.getPath(parentId);
-                Path[] paths;
+                Path path;
-                    paths = hierMgr.getAllPaths(id);
+                    path = hierMgr.getPath(id);
-                boolean isDescendant = false;
-                /**
-                 * check if any of the paths to the transient state
-                 * is a descendant of any of the specified parentId's paths
-                 */
-                for (int i = 0; i < paths.length; i++) {
-                    Path p0 = paths[i]; // path to transient state
-                    // walk through array of the specified parentId's paths
-                    for (int j = 0; j < parentPaths.length; j++) {
-                        Path p1 = parentPaths[j]; // path to specified parentId
-                        if (p0.isDescendantOf(p1)) {
-                            // this is a descendant, add it to the list and
-                            // continue with next transient state
-                            descendants.put(p0, state);
-                            isDescendant = true;
-                            break;
-                        }
-                    }
-                    if (isDescendant) {
-                        break;
-                    }
-                }
-                if (!isDescendant && id.denotesNode()) {
-                    /**
-                     * finally check if transient state has been unlinked
-                     * from a parent node (but is not orphaned yet, i.e. is
-                     * still linked to at least one other parent node);
-                     * if that's the case, check if that parent is a
-                     * descendant of/identical with any of the specified
-                     * parentId's paths.
-                     */
-                    NodeState nodeState = (NodeState) state;
-                    Iterator iterUUIDs = nodeState.getRemovedParentUUIDs().iterator();
-                    while (iterUUIDs.hasNext()) {
-                        /**
-                         * check if any of the paths to the removed parent
-                         * is a descendant of/identical with any of the
-                         * specified parentId's paths.
-                         */
-                        String uuid = (String) iterUUIDs.next();
-                        Path[] pa;
-                        try {
-                            pa = hierMgr.getAllPaths(new NodeId(uuid));
-                        } catch (ItemNotFoundException infe) {
-                            /**
-                             * one of the parents of the specified item has been
-                             * removed externally; as we don't know its path,
-                             * we can't determine if it is a descendant;
-                             * ItemNotFoundException should only be thrown if
-                             * a descendant is affected;
-                             * => log warning and ignore for now
-                             * todo FIXME
-                             */
-                            log.warn(id + ": inconsistent hierarchy state", infe);
-                            continue;
-                        }
-                        for (int k = 0; k < pa.length; k++) {
-                            Path p0 = pa[k];   // path to removed parent
-                            // walk through array of the specified parentId's paths
-                            for (int j = 0; j < parentPaths.length; j++) {
-                                Path p1 = parentPaths[j]; // path to specified parentId
-                                if (p0.equals(p1) || p0.isDescendantOf(p1)) {
-                                    // this is a descendant, add it to the list and
-                                    // continue with next transient state
-
-                                    /**
-                                     * FIXME need to create dummy path by
-                                     * appending a random integer in order to
-                                     * avoid potential conflicts
-                                     */
-                                    QName dummyName = new QName(Constants.NS_DEFAULT_URI, Integer.toString(new Random().nextInt()));
-                                    Path dummy = Path.create(p0, Path.create(dummyName, 0), true);
-                                    descendants.put(dummy, state);
-                                    isDescendant = true;
-                                    break;
-                                }
-                            }
-                            if (isDescendant) {
-                                break;
-                            }
-                        }
-                        if (isDescendant) {
-                            break;
-                        }
-                    }
+                if (path.isDescendantOf(parentPath)) {
+                    // this is a descendant, add it to the list
+                    descendants.put(path, state);
-                // continue with next transient state
-        // @todo need a more efficient way to find descendents in attic (e.g. using hierarchical index)
+
+        // we have to use a special attic-aware hierarchy manager
+        ZombieHierarchyManager zombieHierMgr =
+                new ZombieHierarchyManager(hierMgr.getRootNodeId().getUUID(),
+                        this,
+                        transientStateMgr.getAttic(),
+                        hierMgr.getNamespaceResolver());
+
-            Path[] parentPaths = hierMgr.getAllPaths(parentId, true);
+            Path parentPath = zombieHierMgr.getPath(parentId);
-                Path[] paths = hierMgr.getAllPaths(id, true);
-                boolean isDescendant = false;
-                /**
-                 * check if any of the paths to the transient state
-                 * is a descendant of any of the specified parentId's paths
-                 */
-                for (int i = 0; i < paths.length; i++) {
-                    Path p0 = paths[i]; // path to transient state in attic
-                    // walk through array of the specified parentId's paths
-                    for (int j = 0; j < parentPaths.length; j++) {
-                        Path p1 = parentPaths[j]; // path to specified parentId
-                        if (p0.isDescendantOf(p1)) {
-                            // this is a descendant, add it to the list and
-                            // continue with next transient state
-                            descendants.put(p0, state);
-                            isDescendant = true;
-                            break;
-                        }
-                    }
-                    if (isDescendant) {
-                        break;
-                    }
+                Path path = zombieHierMgr.getPath(id);
+                if (path.isDescendantOf(parentPath)) {
+                    // this is a descendant, add it to the list
+                    descendants.put(path, state);
-        NodeState state = transientStateMgr.createNodeState(
-                overlayedState, initialStatus);
+        NodeState state = transientStateMgr.createNodeState(overlayedState, initialStatus);
-        PropertyState state = transientStateMgr.createPropertyState(
-                overlayedState, initialStatus);
+        PropertyState state = transientStateMgr.createPropertyState(overlayedState, initialStatus);
+     *

JCR-1526: Various improvements to Path and PathImpl

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@646802 13f79535-47bb-0310-9956-ffa450edef68

+    private static final Path CURRENT_PATH = new PathImpl(new Path.Element[]{CURRENT_ELEMENT}, true);
+    private static final Path PARENT_PATH = new PathImpl(new Path.Element[]{PARENT_ELEMENT}, true);
-        public Path getNormalizedPath() throws RepositoryException {
+        public Path getNormalizedPath() {
-                    if (last.denotesRoot()) {
-                        // the first element is the root element;
-                        // ".." would refer to the parent of root
-                        throw new RepositoryException("Path can not be canonicalized: unresolvable '..' element");
-                    }
-                throw new RepositoryException("Path can not be normalized: would result in an empty path.");
+                return CURRENT_PATH;
-                Builder pb = new Builder(new Path.Element[] {CURRENT_ELEMENT});
-                return pb.getPath();
+                return CURRENT_PATH;
-                return this;
+                return this.getNormalizedPath();
-            int length = elements.length - degree;
-            if (length < 1) {
-                throw new PathNotFoundException("no such ancestor path of degree " + degree);
+
+            if (isAbsolute()) {
+                Path.Element[] normElems = getNormalizedPath().getElements();
+                int length = normElems.length - degree;
+                if (length < 1) {
+                    throw new PathNotFoundException("no such ancestor path of degree " + degree);
+                }
+                Path.Element[] ancestorElements = new Element[length];
+                System.arraycopy(normElems, 0, ancestorElements, 0, length);
+                return new PathImpl(ancestorElements, true);
+            } else {
+                Path.Element[] ancestorElements = new Element[elements.length + degree];
+                System.arraycopy(elements, 0, ancestorElements, 0, elements.length);
+
+                for (int i = elements.length; i < ancestorElements.length; i++) {
+                    ancestorElements[i] = PARENT_ELEMENT;
+                }
+                return new PathImpl(ancestorElements, false).getNormalizedPath();
-            Path.Element[] elements = new Element[length];
-            System.arraycopy(this.elements, 0, elements, 0, length);
-            return new PathImpl(elements, normalized);
-            return getDepth() - 1;
+            return (isAbsolute()) ? getDepth() : -1;
-                } else if (!elements[i].denotesCurrent()) {
+                } else if (elements[i].denotesName()) {
+                    // don't count root/current element.
+         * @see Path#isEquivalentTo(Path)
+         */
+        public boolean isEquivalentTo(Path other) throws RepositoryException {
+            if (other == null) {
+                throw new IllegalArgumentException("null argument");
+            }
+            if (isAbsolute() != other.isAbsolute()) {
+                throw new IllegalArgumentException("Cannot compare a relative path with an absolute path");
+            }
+
+            if (getDepth() != other.getDepth()) {
+                return false;
+            }
+
+            Element[] elems0 = getNormalizedPath().getElements();
+            Element[] elems1 = other.getNormalizedPath().getElements();
+
+            if (elems0.length != elems1.length)
+                return false;
+
+            for (int k = 0; k < elems0.length; k++) {
+                if (!elems0[k].equals(elems1[k]))
+                    return false;
+            }
+            return true;
+        }
+
+        /**
-            // make sure we're comparing normalized paths
-            Path p0 = getNormalizedPath();
-            Path p1 = other.getNormalizedPath();
-            if (p0.equals(p1)) {
+            int delta = other.getDepth() - getDepth();
+            if (delta <= 0)
-            }
-            // calculate depth of paths (might be negative)
-            if (p0.getDepth() >= p1.getDepth()) {
-                return false;
-            }
-            Path.Element[] elems0 = p0.getElements();
-            Path.Element[] elems1 = p1.getElements();
-            for (int i = 0; i < elems0.length; i++) {
-                if (!elems0[i].equals(elems1[i])) {
-                    return false;
-                }
-            }
-            return true;
+
+            return isEquivalentTo(other.getAncestor(delta));
-            if (from < 0 || to >= elements.length || from >= to) {
+            if (from < 0 || to > elements.length || from >= to) {
-        private boolean isNormalized = true;
-
-        /**
-         * flag indicating if the current path has leading parent '..' elements
-         */
-        private boolean leadingParent = true;
+        private boolean isNormalized;
+
-            for (int i = 0; i < elements.length; i++) {
-                Path.Element elem = elements[i];
-                leadingParent &= elem.denotesParent();
-                isNormalized &= !elem.denotesCurrent() && (leadingParent || !elem.denotesParent());
+            if (elements.length == 1) {
+                isNormalized = true;
+            } else {
+                boolean absolute = elements[0].denotesRoot();
+                isNormalized = true;
+                int parents = 0;
+                int named = 0;
+                for (int i = 0; i < elements.length; i++) {
+                    Path.Element elem = elements[i];
+                    if (elem.denotesName()) {
+                        named++;
+                    } else if (elem.denotesRoot()) {
+                        if (i > 0) {
+                            throw new IllegalArgumentException("Invalid path: The root element may only occur at the beginning.");
+                        }
+                    } else  if (elem.denotesParent()) {
+                        parents++;
+                        if (absolute || named > 0) {
+                            isNormalized = false;
+                        }
+                    } else /* current element */ {
+                        isNormalized = false;
+                    }
+                }
+                if (absolute && parents > named) {
+                    throw new IllegalArgumentException("Invalid path: Too many parent elements.");
+                }
+            // special path with a single element
+            if (elements.length == 1) {
+                if (elements[0].denotesRoot()) {
+                    return PathFactoryImpl.ROOT;
+                }
+                if (elements[0].denotesParent()) {
+                    return PathFactoryImpl.PARENT_PATH;
+                }
+                if (elements[0].denotesCurrent()) {
+                    return PathFactoryImpl.CURRENT_PATH;
+                }
+            }
+
+            // default: build a new path
-}
+}

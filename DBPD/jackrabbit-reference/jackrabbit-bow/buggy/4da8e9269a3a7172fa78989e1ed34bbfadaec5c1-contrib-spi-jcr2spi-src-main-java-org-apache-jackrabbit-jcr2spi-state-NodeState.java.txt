work in progress

- operations: rename getAffectedIds to getAffectedStates
- operations: return ItemState params instead of ids whereever possible and
  let OperationVisitor deal with all kind of issues arising with SPI ids.
- AddNode/AddProperty operations: don't list state to be created as affected. Not required since operations are collected upon refresh/save, in which case a 'new' item can never be the starting point.
- transient move: let parent NodeState handle the move/renaming of child states
- transient reorder: let parent NodeState handle the reorder logic
- NodeState: remove unused methods and mark setParent private
- NodeImpl: protected getNodeId() no more used by subclasses in version package.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@431887 13f79535-47bb-0310-9956-ffa450edef68

-                     QName nodeTypeName, int initialStatus, boolean isTransient,
-                     ItemStateFactory isf, IdFactory idFactory) {
+                        QName nodeTypeName, int initialStatus, boolean isTransient,
+                        ItemStateFactory isf, IdFactory idFactory) {
-                     int initialStatus, boolean isTransient,
-                     ItemStateFactory isf, IdFactory idFactory) {
+                        int initialStatus, boolean isTransient,
+                        ItemStateFactory isf, IdFactory idFactory) {
-    // TODO: change to private and only let new parent node state set the parent.
-    void setParent(NodeState parent) {
+    private void setParent(NodeState parent) {
-     * @see #removeChildNodeEntry
-     * @see #removeChildNodeEntry
-     * @see #removeChildNodeEntry
-    synchronized ChildNodeEntry addChildNodeEntry(QName nodeName,
-                                                  NodeId id) {
+    synchronized ChildNodeEntry addChildNodeEntry(QName nodeName, NodeId id) {
-     * Renames a new <code>ChildNodeEntry</code>.
-     *
-     * @param oldName <code>QName</code> object specifying the entry's old name
-     * @param index 1-based index if there are same-name child node entries
-     * @param newName <code>QName</code> object specifying the entry's new name
-     * @return <code>true</code> if the entry was sucessfully renamed;
-     *         otherwise <code>false</code>
-     */
-    synchronized boolean renameChildNodeEntry(QName oldName, int index,
-                                                     QName newName) {
-        ChildNodeEntry oldEntry = childNodeEntries.remove(oldName, index);
-        if (oldEntry != null) {
-            ChildNodeEntry newEntry = childNodeEntries.add(newName, oldEntry.getId());
-            notifyNodeAdded(newEntry);
-            notifyNodeRemoved(oldEntry);
-            return true;
-        }
-        return false;
-    }
-
-    /**
-     * Removes a <code>ChildNodeEntry</code>.
-     *
-     * @param nodeName <code>ChildNodeEntry</code> object specifying a node name
-     * @param index    1-based index if there are same-name child node entries
-     * @return <code>true</code> if the specified child node entry was found
-     *         in the list of child node entries and could be removed.
-     */
-    synchronized boolean removeChildNodeEntry(QName nodeName, int index) {
-        ChildNodeEntry entry = childNodeEntries.remove(nodeName, index);
-        if (entry != null) {
-            notifyNodeRemoved(entry);
-        }
-        return entry != null;
-    }
-
-    /**
-     * Removes a <code>ChildNodeEntry</code>.
-     *
-     * @param id the id of the entry to be removed
-     * @return <code>true</code> if the specified child node entry was found
-     *         in the list of child node entries and could be removed.
-     */
-    synchronized boolean removeChildNodeEntry(NodeId id) {
-        ChildNodeEntry entry = childNodeEntries.remove(id);
-        if (entry != null) {
-            notifyNodeRemoved(entry);
-        }
-        return entry != null;
-    }
-
-    /**
-     * Removes all <code>ChildNodeEntry</code>s.
-     */
-    synchronized void removeAllChildNodeEntries() {
-        childNodeEntries.removeAll();
-    }
-
-    /**
-    synchronized void childNodeStateRemoved(NodeState nodeState) {
+    private synchronized void childNodeStateRemoved(NodeState nodeState) {
-     * Sets the list of <code>ChildNodeEntry</code> objects denoting the
-     * child nodes of this node.
-     */
-    synchronized void setChildNodeEntries(List nodeEntries) {
-        // re-create child node entries
-        childNodeEntries.clear(); // TODO: any mre cleanup work to do? try some kind of merging?
-        for (Iterator it = nodeEntries.iterator(); it.hasNext(); ) {
-            ChildNodeEntry cne = (ChildNodeEntry) it.next();
-            childNodeEntries.add(cne.getName(), cne.getId());
-        }
-        notifyNodesReplaced();
-    }
-
-    /**
-
-     * @see #removePropertyName
-     * @see #removePropertyName
-     * Removes a property name entry.
-     *
-     * @param propName <code>QName</code> object specifying the property name
-     * @return <code>true</code> if the specified property name was found
-     *         in the list of property name entries and could be removed.
-     */
-    synchronized boolean removePropertyName(QName propName) {
-        return properties.remove(propName) != null;
-    }
-
-    /**
-    /**
-     * Removes all property name entries.
-     */
-    synchronized void removeAllPropertyNames() {
-        properties.clear();
-    }
-
-    /**
-     * Sets the set of <code>QName</code> objects denoting the
-     * properties of this node.
-     */
-    synchronized void setPropertyNames(Set propNames) {
-        removeAllPropertyNames();
-        for (Iterator it = propNames.iterator(); it.hasNext(); ) {
-            addPropertyName((QName) it.next());
-        }
-    }
-
-    /**
+    /*
+     *
+     * @param insertNodeId
+     * @param beforeNodeId
+     */
+    synchronized void reorderChildNodeEntries(NodeId insertNodeId, NodeId beforeNodeId)
+        throws NoSuchItemStateException {
+        // validate existance of child node entries even if this has been
+        // checked within NodeImpl.
+        if (childNodeEntries.get(insertNodeId) == null) {
+            throw new NoSuchItemStateException("No such child node entry: " + insertNodeId);
+        }
+        if (beforeNodeId != null && childNodeEntries.get(insertNodeId) == null) {
+            throw new NoSuchItemStateException("No such child node entry: " + beforeNodeId);
+        }
+
+        // TODO: check again. Reorder with SPI-Id
+        ArrayList nodeEntries = new ArrayList(childNodeEntries);
+        int srcInd = -1, destInd = -1;
+        for (int i = 0; i < nodeEntries.size(); i++) {
+            ChildNodeEntry entry = (ChildNodeEntry) nodeEntries.get(i);
+            if (srcInd == -1) {
+                if (entry.getId().equals(insertNodeId)) {
+                    srcInd = i;
+                }
+            }
+            if (destInd == -1 && beforeNodeId != null) {
+                if (entry.getId().equals(beforeNodeId)) {
+                    destInd = i;
+                    if (srcInd != -1) {
+                        break;
+                    }
+                }
+            } else {
+                if (srcInd != -1) {
+                    break;
+                }
+            }
+        }
+
+        // check if resulting order would be different to current order
+        if (destInd == -1) {
+            if (srcInd == nodeEntries.size() - 1) {
+                // no change, we're done
+                return;
+            }
+        } else {
+            if ((destInd - srcInd) == Path.INDEX_DEFAULT) {
+                // no change, we're done
+                return;
+            }
+        }
+        // reorder list
+        if (destInd == -1) {
+            nodeEntries.add(nodeEntries.remove(srcInd));
+        } else {
+            if (srcInd < destInd) {
+                nodeEntries.add(destInd, nodeEntries.get(srcInd));
+                nodeEntries.remove(srcInd);
+            } else {
+                nodeEntries.add(destInd, nodeEntries.remove(srcInd));
+            }
+        }
+
+        // re-create child node entries
+        childNodeEntries.clear(); // TODO: any mre cleanup work to do? try some kind of merging?
+        for (Iterator it = nodeEntries.iterator(); it.hasNext(); ) {
+            ChildNodeEntry cne = (ChildNodeEntry) it.next();
+            childNodeEntries.add(cne.getName(), cne.getId());
+        }
+        // TODO: correct?
+        notifyNodesReplaced();
+    }
+
+    /**
+     * Renames a new <code>ChildNodeEntry</code>.
+     *
+     * @param newParent
+     * @param childState
+     * @param newName
+     * @param newName <code>QName</code> object specifying the entry's new name
+     * @throws RepositoryException if the given child state is not a child
+     * of this node state.
+     */
+    // TODO: review. move with SPI Ids
+    synchronized void moveChildNodeEntry(NodeState newParent, NodeState childState, QName newName)
+        throws RepositoryException {
+        NodeId childId = childState.getNodeId();
+        // rename only
+        ChildNodeEntry oldEntry = childNodeEntries.remove(childId);
+        if (oldEntry != null) {
+            if (newParent == this) {
+                ChildNodeEntry newEntry = childNodeEntries.add(name, oldEntry.getId());
+                notifyNodeAdded(newEntry);
+                notifyNodeRemoved(oldEntry);
+            } else {
+                notifyNodeRemoved(oldEntry);
+                // re-parent target node
+                childState.setParent(newParent);
+                // add child node entry to new parent
+                newParent.addChildNodeEntry(newName, childId);
+            }
+        } else {
+            throw new RepositoryException("Unexpected error: Child state to be renamed does not exist.");
+        }
+    }
+    
+    /**
-    protected void notifyNodeAdded(ChildNodeEntry added) {
+    private void notifyNodeAdded(ChildNodeEntry added) {
-    protected void notifyNodesReplaced() {
+    private void notifyNodesReplaced() {
-    protected void notifyNodeRemoved(ChildNodeEntry removed) {
+    private void notifyNodeRemoved(ChildNodeEntry removed) {

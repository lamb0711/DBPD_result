True caching in CachingHierarchyManager

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@190372 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.HierarchyManagerImpl;
-    private HierarchyManager hierMgr;
+    private CachingHierarchyManager hierMgr;
-        hierMgr = new HierarchyManagerImpl(rootNodeUUID, this, nsResolver,
-                transientStateMgr.getAttic());
+        hierMgr = new CachingHierarchyManager(rootNodeUUID, this,
+                nsResolver, transientStateMgr.getAttic());
-     * Please keep in mind that the cache of <code>Path</code>s is not automatically
-     * updated when the underlying hierarchy is changing. Therefore it should only be
-     * turned on with caution and in special situations (usually only locally
-     * within a narrow scope) where the underlying hierarchy is not expected to
-     * change.
-     *
-     * @param enable
+     * Paths are always cached, therefore this method has no implementation.
+     * @param enable <code>true</code> to enable caching;
+     *               <code>false</code> to disable
-        if (enable) {
-            if (!(hierMgr instanceof CachingHierarchyManager)) {
-                hierMgr = new CachingHierarchyManager(hierMgr);
-            }
-        } else {
-            if (hierMgr instanceof CachingHierarchyManager) {
-                CachingHierarchyManager chm = (CachingHierarchyManager) hierMgr;
-                chm.clearCache();
-                hierMgr = chm.unwrap();
-            }
-        }
+     * Customized variant of {@link #createNew(String, QName, String)} that
+     * connects the newly created persistent state with the transient state.
+     */
+    public NodeState createNew(NodeState transientState)
+            throws IllegalStateException {
+
+        NodeState persistentState = createNew(transientState.getUUID(),
+                transientState.getNodeTypeName(),
+                transientState.getParentUUID());
+        transientState.connect(persistentState);
+        return persistentState;
+    }
+
+    /**
+     * Customized variant of {@link #createNew(String, QName, String)} that
+     * connects the newly created persistent state with the transient state.
+     */
+    public PropertyState createNew(PropertyState transientState)
+            throws IllegalStateException {
+
+        PropertyState persistentState = createNew(transientState.getName(),
+                transientState.getParentUUID());
+        transientState.connect(persistentState);
+        return persistentState;
+    }
+
+
+    /**
-        return transientStateMgr.createNodeState(overlayedState, initialStatus);
+
+        NodeState state = transientStateMgr.createNodeState(
+                overlayedState, initialStatus);
+        hierMgr.stateOverlaid(state);
+        return state;
-        return transientStateMgr.createPropertyState(overlayedState, initialStatus);
+
+        PropertyState state = transientStateMgr.createPropertyState(
+                overlayedState, initialStatus);
+        hierMgr.stateOverlaid(state);
+        return state;
+    }
+
+    /**
+     * Disconnect a transient item state from its underlying persistent state.
+     * Notifies the <code>HierarchyManager</code> about the changed identity.
+     * @param state the transient <code>ItemState</code> instance that should
+     *              be disconnected
+     */
+    public void disconnectTransientItemState(ItemState state) {
+        hierMgr.stateUncovered(state);
+        state.disconnect();

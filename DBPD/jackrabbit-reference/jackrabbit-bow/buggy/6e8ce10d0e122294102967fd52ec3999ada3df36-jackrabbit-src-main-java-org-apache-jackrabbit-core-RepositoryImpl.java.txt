JCR-305: provide option to automatically dispose idle workspaces

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@370144 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Set;
+import java.util.HashSet;
+    /**
+     * workspace janitor thread that is responsible for temporarily
+     * shutting down workspaces that have been idle for a specific
+     * amount of time
+     */
+    private Thread wspJanitor;
+
+        log.info("Starting repository...");
+
-        this.acquireRepositoryLock() ;
+        acquireRepositoryLock() ;
-        // init virtual nodetype manager
+        // init virtual node type manager
+        // amount of time in seconds before an idle workspace is automatically
+        // shut down
+        int maxIdleTime = repConfig.getWorkspaceMaxIdleTime();
+        if (maxIdleTime != 0) {
+            // start workspace janitor thread
+            wspJanitor = new WorkspaceJanitor(maxIdleTime * 1000);
+            wspJanitor.start();
+        }
+
+
+        log.info("Repository started");
-                    " deteteced. Repository was not shutdown properly.");
+                    " deteteced. Repository was not shut down properly.");
-            // add nodetypes
+            // add node types
-    protected final SessionImpl createSession(AuthContext loginContext,
+    protected synchronized final SessionImpl createSession(AuthContext loginContext,
+        // reset idle timestamp
+        wspInfo.setIdleTimestamp(0);
-    protected final SessionImpl createSession(Subject subject,
+    protected synchronized final SessionImpl createSession(Subject subject,
+        // reset idle timestamp
+        wspInfo.setIdleTimestamp(0);
+        log.info("Shutting down repository...");
+
+        if (wspJanitor != null) {
+            wspJanitor.interrupt();
+            wspJanitor = null;
+        }
+
+
+        log.info("Repository has been shutdown");
-    private static PersistenceManager createPersistenceManager(File homeDir, FileSystem fs, PersistenceManagerConfig pmConfig,
-                                                               String rootNodeUUID, NamespaceRegistry nsReg, NodeTypeRegistry ntReg)
+    private static PersistenceManager createPersistenceManager(File homeDir,
+                                                               FileSystem fs,
+                                                               PersistenceManagerConfig pmConfig,
+                                                               String rootNodeUUID,
+                                                               NamespaceRegistry nsReg,
+                                                               NodeTypeRegistry ntReg)
-    public void loggedOut(SessionImpl session) {
+    public synchronized void loggedOut(SessionImpl session) {
+         * timestamp when the workspace has been determined being idle
+         */
+        private long idleTimestamp;
+
+        /**
+            idleTimestamp = 0;
+         * Returns the timestamp when the workspace has become idle or zero
+         * if the workspace is currently not idle.
+         *
+         * @return the timestamp when the workspace has become idle or zero if
+         *         the workspace is not idle.
+         */
+        long getIdleTimestamp() {
+            return idleTimestamp;
+        }
+
+        /**
+         * Sets the timestamp when the workspace has become idle. if
+         * <code>ts == 0</code> the workspace is marked as being currently
+         * active.
+         *
+         * @param ts timestamp when workspace has become idle.
+         */
+        void setIdleTimestamp(long ts) {
+            idleTimestamp = ts;
+        }
+
+        /**
+            log.info("initializing workspace '" + getName() + "'...");
+
+
+            log.info("workspace '" + getName() + "' initialized");
+            log.info("shutting down workspace '" + getName() + "'...");
+
+
+            // reset idle timestamp
+            idleTimestamp = 0;
+
+            initialized = false;
+
+            log.info("workspace '" + getName() + "' has been shutdown");
+        }
+    }
+
+    /**
+     * The workspace janitor thread that will shutdown workspaces that have
+     * been idle for a certain amount of time.
+     */
+    private class WorkspaceJanitor extends Thread {
+
+        /**
+         * amount of time in mmilliseconds before an idle workspace is
+         * automatically shutdown.
+         */
+        private long maxIdleTime;
+        /**
+         * interval in mmilliseconds between checks for idle workspaces.
+         */
+        private long checkInterval;
+
+        /**
+         * Creates a new <code>WorkspaceJanitor</code> instance responsible for
+         * shutting down idle workspaces.
+         *
+         * @param maxIdleTime amount of time in mmilliseconds before an idle
+         *                    workspace is automatically shutdown.
+         */
+        WorkspaceJanitor(long maxIdleTime) {
+            super("WorkspaceJanitor");
+            setPriority(Thread.MIN_PRIORITY);
+            setDaemon(true);
+            this.maxIdleTime = maxIdleTime;
+            // compute check interval as 10% of maxIdleTime
+            checkInterval = (long) (0.1 * maxIdleTime);
+        }
+
+        /**
+         * {@inheritDoc}
+         * <p/>
+         * Performs the following tasks in a <code>while (true)</code> loop:
+         * <ol>
+         * <li>wait for <code>checkInterval</code> milliseconds</li>
+         * <li>build list of initialized but currently inactive workspaces
+         *     (excluding the default workspace)</li>
+         * <li>shutdown those workspaces that have been idle for at least
+         *     <code>maxIdleTime</code> milliseconds</li>
+         * </ol>
+         */
+        public void run() {
+            while (!disposed) {
+                try {
+                    Thread.sleep(checkInterval);
+                } catch (InterruptedException e) {
+                    /* ignore */
+                }
+
+                synchronized (RepositoryImpl.this) {
+                    if (disposed) {
+                        return;
+                    }
+                    // get names of workspaces
+                    Set wspNames = new HashSet(wspInfos.keySet());
+                    // remove default workspace (will never be shutdown when idle)
+                    wspNames.remove(repConfig.getDefaultWorkspaceName());
+                    // remove workspaces with active sessions
+                    for (Iterator it = activeSessions.values().iterator(); it.hasNext();) {
+                        SessionImpl ses = (SessionImpl) it.next();
+                        wspNames.remove(ses.getWorkspace().getName());
+                    }
+                    // remove uninitialized workspaces
+                    for (Iterator it = wspInfos.values().iterator(); it.hasNext();) {
+                        WorkspaceInfo wspInfo = (WorkspaceInfo) it.next();
+                        if (!wspInfo.isInitialized()) {
+                            wspNames.remove(wspInfo.getName());
+                        }
+                    }
+
+                    // remaining names denote workspaces which are currently idle
+                    for (Iterator it = wspNames.iterator(); it.hasNext();) {
+                        WorkspaceInfo wspInfo = (WorkspaceInfo) wspInfos.get(it.next());
+                        long currentTS = System.currentTimeMillis();
+                        long idleTS = wspInfo.getIdleTimestamp();
+                        if (idleTS == 0) {
+                            // set idle timestamp
+                            wspInfo.setIdleTimestamp(currentTS);
+                        } else {
+                            if ((currentTS - idleTS) > maxIdleTime) {
+                                // temporarily shutdown workspace
+                                wspInfo.dispose();
+                            }
+                        }
+                    }
+                }
+            }

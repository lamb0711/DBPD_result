- Removed JCRQL implementation
- Added proper QName support to search
- redesigned parsing and formating of queries (better separation of abstract query tree and concrete syntax)
- Some improvements in SQL: colon is now supported in identifier without having to use double quotes, LIKE now supports escaping

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@125778 13f79535-47bb-0310-9956-ffa450edef68

-        String[] props = node.getSelectProperties();
+        QName[] props = node.getSelectProperties();
-            String prop = props[i];
-                prop = nsMappings.translatePropertyName(prop, session.getNamespaceResolver());
-            } catch (IllegalNameException e) {
-                exceptions.add(e);
-            } catch (UnknownPrefixException e) {
+                String prop = props[i].toJCRName(nsMappings);
+                // @todo really search nodes that have non null values?
+                root.add(new MatchAllQuery(prop), true, false);
+            } catch (NoPrefixDeclaredException e) {
+                // should never happen actually. prefixes are dynamically created
-            root.add(new MatchAllQuery(prop), true, false);
-        String field = node.getPropertyName();
+        String field = "";
+        String value = "";
-            field = nsMappings.translatePropertyName(node.getPropertyName(),
-                    session.getNamespaceResolver());
-        } catch (IllegalNameException e) {
-            exceptions.add(e);
-        } catch (UnknownPrefixException e) {
-            exceptions.add(e);
+            field = node.getPropertyName().toJCRName(nsMappings);
+            value = node.getValue().toJCRName(nsMappings);
+        } catch (NoPrefixDeclaredException e) {
+            // will never happen, prefixes are created when unknown
-        String value = node.getValue();
-        String field = node.getPropertyName();
+        String field = "";
-            field = nsMappings.getPrefix(NodeTypeRegistry.JCR_PRIMARY_TYPE.getNamespaceURI())
-                    + ":" + NodeTypeRegistry.JCR_PRIMARY_TYPE.getLocalName();
-
-            values.add(nsMappings.translatePropertyName(node.getValue(),
-                    session.getNamespaceResolver()));
+            field = NodeTypeRegistry.JCR_PRIMARY_TYPE.toJCRName(nsMappings);
+            values.add(node.getValue().toJCRName(nsMappings));
-            NodeType base = ntMgr.getNodeType(node.getValue());
+            NodeType base = ntMgr.getNodeType(node.getValue().toJCRName(session.getNamespaceResolver()));
+        } catch (NoPrefixDeclaredException e) {
+            // should never happen
+            exceptions.add(e);
-        if (node.getNameTest() != null && node.getNameTest().length() == 0) {
+        if (node.getNameTest() != null && node.getNameTest().getLocalName().length() == 0) {
-                String internalName = nsMappings.translatePropertyName(node.getNameTest(),
-                        session.getNamespaceResolver());
+                String internalName = node.getNameTest().toJCRName(nsMappings);
-            } catch (IllegalNameException e) {
-                exceptions.add(e);
-            } catch (UnknownPrefixException e) {
+            } catch (NoPrefixDeclaredException e) {
+                // should never happen
-        String field = node.getProperty();
+        String field = "";
-            field = nsMappings.translatePropertyName(node.getProperty(),
-                    session.getNamespaceResolver());
-        } catch (IllegalNameException e) {
-            exceptions.add(e);
-        } catch (UnknownPrefixException e) {
+            field = node.getProperty().toJCRName(nsMappings);
+        } catch (NoPrefixDeclaredException e) {
+            // should never happen
-                // @todo use MatchAllQuery if stringValue is "*" (or "%" ?)
-                query = new WildcardQuery(new Term(field, stringValue));
+                if (stringValue.equals("%")) {
+                    query = new MatchAllQuery(field);
+                } else {
+                    query = new WildcardQuery(new Term(field, stringValue));
+                }

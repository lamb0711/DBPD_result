JCR-2313 - Improvements to user management (2) [work in progress] 
-> see issue for details

JCR-2333 - ItemImpl#validateTransientItems: Incomplete validation of mandatory child item
-> patch2

JCR-2195 - Provide possibility to import protected items using Session/Workspace import functionality
-> deal with reference properties
-> make import handlers configurable
-> add userimporter

JCR-171 - Make the extraction of Session UserIDs from Subjects configurable
-> extend SecurityManagerConfig and retrieve uid from principal name if configured
     class is present in the subject

JCR-2351 - Make Authorizable.setProperty more noisy in case of failure

JCR-2331 - Configurable DefaultPolicy replacing Initialization within the ACProvider
-> initial steps. remove code that relies on the default-init
-> add TODOs

JCR-2291 - Issues with compiled permissions of ACL provider
-> remove code searching for DENY-read entries in case of default initialization of ac entries

and here and there minor improvement, usage of generics etc....

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@828791 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.api.security.user.User;
-import org.apache.jackrabbit.core.config.BeanConfig;
+import org.apache.jackrabbit.core.config.UserManagerConfig;
-     * session on the system workspace.
+     * System session.
-    private SystemSession securitySession;
+    private SystemSession systemSession;
-     * System Sessions PrincipalMangager used for internal access to Principals
-     */
-    private PrincipalManager systemPrincipalManager;
-
-    /**
-    private String anonymousId;
+    protected String anonymousId;
-        securitySession = (SystemSession) systemSession;
+        this.systemSession = (SystemSession) systemSession;
-        systemUserManager = createUserManager(securitySession);
-        createSystemUsers(systemUserManager, adminId, anonymousId);
+        systemUserManager = createUserManager(this.systemSession);
+        createSystemUsers(systemUserManager, this.systemSession, adminId, anonymousId);
-        acProviderFactory.init(securitySession);
+        acProviderFactory.init(this.systemSession);
-            workspaceAccessManager = new WorkspaceAccessManagerImpl();
+            workspaceAccessManager = createDefaultWorkspaceAccessManager();
-        workspaceAccessManager.init(securitySession);
+        workspaceAccessManager.init(this.systemSession);
-        PrincipalProvider defaultPP = new DefaultPrincipalProvider(securitySession, (UserManagerImpl) systemUserManager);
-        defaultPP.init(new Properties());
+        PrincipalProvider defaultPP = createDefaultPrincipalProvider();
-        // create the principal manager for the security workspace
-        systemPrincipalManager = new PrincipalManagerImpl(securitySession, principalProviderRegistry.getProviders());
-
-     * Creates a {@link UserManagerImpl} for the given session. May be overridden
-     * to return a custom implementation.
-     *
-     * @param session session
-     * @return user manager
-     * @throws RepositoryException if an error occurs
-     */
-    protected UserManagerImpl createUserManager(SessionImpl session) throws RepositoryException {
-        BeanConfig umc = repository.getConfig().getSecurityConfig().getSecurityManagerConfig().getUserManagerConfig();
-        Properties config = null;
-        if (umc != null) {
-            // TODO: deal with other user manager implementations.
-            String clName = umc.getClassName();
-            if (clName != null && !(UserManagerImpl.class.getName().equals(clName) || clName.length() == 0)) {
-                log.warn("Unsupported custom UserManager implementation: '" + clName + "' -> Ignored.");
-            }
-            config = umc.getParameters();
-        }
-        return new UserManagerImpl(session, adminId, config);
-    }
-
-    /**
-        if (session == securitySession) {
-            return systemPrincipalManager;
-        } else if (session instanceof SessionImpl) {
+        if (session instanceof SessionImpl) {
-            return new PrincipalManagerImpl(sImpl, principalProviderRegistry.getProviders());
+            return createPrincipalManager(sImpl);
-        if (session == securitySession) {
+        if (session == systemSession) {
-            String workspaceName = securitySession.getWorkspace().getName();
+            String workspaceName = systemSession.getWorkspace().getName();
-     * @see JackrabbitSecurityManager#getUserID(Subject)
+     * @see JackrabbitSecurityManager#getUserID(javax.security.auth.Subject, String)
-    public String getUserID(Subject subject) throws RepositoryException {
+    public String getUserID(Subject subject, String workspaceName) throws RepositoryException {
+
+        /* if there is a configure principal class that should be used to
+           determine the UserID -> try this one. */
+        Class cl = getConfig().getUserIdClass();
+        if (cl != null) {
+            Set<Principal> s = subject.getPrincipals(cl);
+            if (!s.isEmpty()) {
+                for (Principal p : s) {
+                    if (!(p instanceof java.security.acl.Group)) {
+                        return p.getName();
+                    }
+                }
+                // all principals found with the given p-Class were Group principals
+                log.debug("Only Group principals found with class '" + cl.getName() + "' -> Not used for UserID.");
+            } else {
+                log.debug("No principal found with class '" + cl.getName() + "'.");
+            }
+        }
+
-         Retrieve userID from the subject.
+         Fallback szenario to retrieve userID from the subject:
-         name must not be equals to the UserID by definition, the userID
-         may either be obtained from the login-credentials or from the
-         user manager. in the latter case the set of principals present with
-         the specified subject is used to search for the user.
+         name may not be equals to the UserID, the id is retrieved by
+         searching for the corresponding authorizable and if this doesn't
+         succeed an attempt is made to obtained it from the login-credentials.
-        // try simple access to userID over SimpleCredentials first.
-        Iterator<SimpleCredentials> creds = subject.getPublicCredentials(
-                SimpleCredentials.class).iterator();
-        if (creds.hasNext()) {
-            SimpleCredentials sc = creds.next();
-            uid = sc.getUserID();
-        } else {
-            // no SimpleCredentials: retrieve authorizables corresponding to
-            // a non-group principal. the first one present is used to determine
-            // the userID.
+
+        // first try to retrieve an authorizable corresponding to
+        // a non-group principal. the first one present is used
+        // to determine the userID.
+        try {
+            UserManager umgr = getSystemUserManager(workspaceName);
-                    Authorizable authorz = systemUserManager.getAuthorizable(p);
+                    Authorizable authorz = umgr.getAuthorizable(p);
+        } catch (RepositoryException e) {
+            // failed to access userid via user manager -> use fallback 2.
+            log.error("Unexpected error while retrieving UserID.", e);
+
+        // 2. if no matching user is found try simple access to userID over
+        // SimpleCredentials.
+        if (uid == null) {
+            Iterator<SimpleCredentials> creds = subject.getPublicCredentials(
+                    SimpleCredentials.class).iterator();
+            if (creds.hasNext()) {
+                SimpleCredentials sc = creds.next();
+                uid = sc.getUserID();
+            }
+        }
+
-     * {@link Subject}.<br>
+     * {@link Subject}. The workspace name is ignored and users are
+     * stored and retrieved from a specific (separate) workspace.<br>
-    public AuthContext getAuthContext(Credentials creds, Subject subject)
+    public AuthContext getAuthContext(Credentials creds, Subject subject, String workspaceName)
-        return authContextProvider.getAuthContext(creds, subject, securitySession,
-                principalProviderRegistry, adminId, anonymousId);
+        return getAuthContextProvider().getAuthContext(creds, subject, systemSession,
+                getPrincipalProviderRegistry(), adminId, anonymousId);
+    //----------------------------------------------------------< protected >---    
+    /**
+     * @return The <code>SecurityManagerConfig</code> configured for the
+     * repository this manager has been created for.
+     */
+    protected SecurityManagerConfig getConfig() {
+        return repository.getConfig().getSecurityConfig().getSecurityManagerConfig();
+    }   
+
+    /**
+     * @param workspaceName
+     * @return The system user manager. Since this implementation stores users
+     * in a dedicated workspace the system user manager is the same for all
+     * sessions irrespective of the workspace.
+     */
+    protected UserManager getSystemUserManager(String workspaceName) throws RepositoryException {
+        return systemUserManager;
+    }
+
+    /**
+     * Creates a {@link UserManagerImpl} for the given session. May be overridden
+     * to return a custom implementation.
+     *
+     * @param session session
+     * @return user manager
+     * @throws RepositoryException if an error occurs
+     */
+    protected UserManagerImpl createUserManager(SessionImpl session) throws RepositoryException {
+        UserManagerConfig umc = getConfig().getUserManagerConfig();
+        Properties params = (umc == null) ? null : umc.getParameters();
+
+        // since users are stored in and retrieved from a dedicated workspace
+        // only the system session assigned with that workspace will get the
+        // system user manager (special implementation that asserts the existance
+        // of the admin user).
+        if (session == systemSession) {
+            return new SystemUserManager(systemSession, params);
+        } else {
+            UserManagerImpl um;
+            if (umc != null) {
+                Class<?>[] paramTypes = new Class[] { SessionImpl.class, String.class, Properties.class };
+                um = (UserManagerImpl) umc.getUserManager(UserManagerImpl.class, paramTypes, (SessionImpl) session, adminId, params);
+                // TODO: should we make sure the implementation doesn't allow
+                // TODO: to change the autosave behavior? since the user manager
+                // TODO: writes to a separate workspace this would cause troubles.
+            } else {
+                um = new UserManagerImpl(session, adminId, params);
+            }
+            return um;
+        }
+    }
+
+    /**
+     * @param session The session used to create the principal manager.
+     * @return A new instance of PrincipalManagerImpl
+     * @throws javax.jcr.RepositoryException If an error occurs.
+     */
+    protected PrincipalManager createPrincipalManager(SessionImpl session) throws RepositoryException {
+        return new PrincipalManagerImpl(session, getPrincipalProviderRegistry().getProviders());
+    }
+
+    /**
+     * @return A nwe instance of WorkspaceAccessManagerImpl to be used as
+     * default workspace access manager if the configuration doesn't specify one.
+     */
+    protected WorkspaceAccessManager createDefaultWorkspaceAccessManager() {
+        return new WorkspaceAccessManagerImpl();
+    }
+
+    /**
+     * Creates the default principal provider used to create the
+     * {@link PrincipalProviderRegistry}.
+     * 
+     * @return An new instance of <code>DefaultPrincipalProvider</code>.
+     * @throws RepositoryException If an error occurs.
+     */
+    protected PrincipalProvider createDefaultPrincipalProvider() throws RepositoryException {
+        PrincipalProvider defaultPP = new DefaultPrincipalProvider(this.systemSession, (UserManagerImpl) systemUserManager);
+        defaultPP.init(new Properties());
+        return defaultPP;
+    }
+
+    /**
+     * @return The PrincipalProviderRegistry created during initialization.
+     */
+    protected PrincipalProviderRegistry getPrincipalProviderRegistry() {
+        return principalProviderRegistry;
+    }
+
+    /**
+     * @return The AuthContextProvider created during initialization.
+     */
+    protected AuthContextProvider getAuthContextProvider() {
+        return authContextProvider;
+    }
+
+    /**
+     * Throws <code>IllegalStateException</code> if this manager hasn't been
+     * initialized.
+     */
+    protected void checkInitialized() {
+        if (!initialized) {
+            throw new IllegalStateException("Not initialized");
+        }
+    }
+
+    /**
+     * @return The system session used to initialize this SecurityManager.
+     */
+    protected Session getSystemSession() {
+        return systemSession;
+    }
+
+    /**
+     * @return The repository used to initialize this SecurityManager.
+     */
+    protected Repository getRepository() {
+        return repository;
+    }
+     * @param session
-    private static void createSystemUsers(UserManager userManager,
-                                          String adminId,
-                                          String anonymousId) throws RepositoryException {
-        Principal pr = new PrincipalImpl(SecurityConstants.ADMINISTRATORS_NAME);
-        Group admins = (Group) userManager.getAuthorizable(pr);
-        if (admins == null) {
-            admins = userManager.createGroup(new PrincipalImpl(SecurityConstants.ADMINISTRATORS_NAME));
-            log.debug("...created administrators group with name '"+SecurityConstants.ADMINISTRATORS_NAME+"'");
-        }
+    static void createSystemUsers(UserManager userManager,
+                                  SystemSession session,
+                                  String adminId,
+                                  String anonymousId) throws RepositoryException {
+        Authorizable admin = null;
-            Authorizable admin = userManager.getAuthorizable(adminId);
+            admin = userManager.getAuthorizable(adminId);
-                log.info("...created admin-user with id \'" + adminId + "\' ...");
-                admins.addMember(admin);
-                log.info("...added admin \'" + adminId + "\' as member of the administrators group.");
+                if (!userManager.isAutoSave()) {
+                    session.save();
+                }
+                log.info("... created admin-user with id \'" + adminId + "\' ...");
+        // assume administrators groupID and principalName are the same.
+        // and avoid retrieving group by principal.
+        Group admins = (Group) userManager.getAuthorizable(SecurityConstants.ADMINISTRATORS_NAME);
+        if (admins == null) {
+            admins = userManager.createGroup(new PrincipalImpl(SecurityConstants.ADMINISTRATORS_NAME));
+            if (!userManager.isAutoSave()) {
+                session.save();
+            }
+            log.info("... created administrators group with name '"+SecurityConstants.ADMINISTRATORS_NAME+"'");
+        }
+
+        try {
+            if (admins != null && admins.addMember(admin)) {
+                if (!userManager.isAutoSave()) {
+                    session.save();
+                }
+                log.info("... added admin '" + adminId + "' as member of the administrators group.");
+            }
+        } catch (RepositoryException e) {
+            // administrator has full permissions anyway. just log a
+            // warning and ignore the error.
+            log.warn("Unexpected error while adding admin to the administrators group", e);
+        }
+
-                log.info("...created anonymous-user with id \'" + anonymousId + "\' ...");
+                if (!userManager.isAutoSave()) {
+                    session.save();
+                }
+                log.info("... created anonymous-user with id \'" + anonymousId + "\' ...");
-    private void checkInitialized() {
-        if (!initialized) {
-            throw new IllegalStateException("Not initialized");
-        }
-    }
-
-    private class WorkspaceAccessManagerImpl implements SecurityConstants, WorkspaceAccessManager {
+    private final class WorkspaceAccessManagerImpl implements SecurityConstants, WorkspaceAccessManager {
-         * @param securitySession
-        public void init(Session securitySession) throws RepositoryException {
+        public void init(Session systemSession) throws RepositoryException {
+
+    /**
+     * System user manager that (re) creates the admin user in case it doesn't
+     * exist yet (upon initial startup) or has been deleted.
+     */
+    protected final class  SystemUserManager extends UserManagerImpl {
+
+        private final SystemSession session;
+        private String adminPw;
+
+        protected SystemUserManager(SystemSession session, Properties config) throws RepositoryException {
+            super(session, adminId, config);
+            this.session = session;
+            adminPw = adminId; // The default value as defined upon #createSystemUsers
+        }
+
+        @Override
+        public Authorizable getAuthorizable(String id) throws RepositoryException {
+            Authorizable a = super.getAuthorizable(id);
+            if (a == null && adminId.equals(id)) {
+                log.info("Admin user does not exist.");
+                a = createAdmin(adminId, adminPw);
+            }
+            return a;
+        }
+
+        private User createAdmin(String adminId, String pw) throws RepositoryException {
+            User admin = createUser(adminId, pw);
+            if (!isAutoSave()) {
+                session.save();
+            }
+            log.info("... created admin user with id \'" + adminId + "\' and default pw.");
+            return admin;
+        }
+    }

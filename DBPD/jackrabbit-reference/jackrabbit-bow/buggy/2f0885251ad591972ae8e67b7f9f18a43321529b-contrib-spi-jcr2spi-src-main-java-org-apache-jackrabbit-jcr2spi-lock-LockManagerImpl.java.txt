Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.observation.InternalEventListener;
+import org.apache.jackrabbit.jcr2spi.config.CacheBehaviour;
+import org.apache.jackrabbit.jcr2spi.hierarchy.NodeEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.HierarchyEntry;
-import org.apache.jackrabbit.name.QName;
-import org.apache.jackrabbit.spi.Event;
+import org.apache.jackrabbit.jcr2spi.state.ItemStateException;
+import org.apache.jackrabbit.jcr2spi.state.ItemStateLifeCycleListener;
+import org.apache.jackrabbit.jcr2spi.state.ItemState;
+import org.apache.jackrabbit.jcr2spi.state.PropertyState;
-import org.apache.jackrabbit.spi.EventBundle;
-import org.apache.jackrabbit.spi.EventFilter;
+import org.apache.jackrabbit.spi.NodeId;
+import org.apache.jackrabbit.name.QName;
-import javax.jcr.UnsupportedRepositoryOperationException;
-import java.util.Collection;
-import java.util.Collections;
+    private final CacheBehaviour cacheBehaviour;
-    public LockManagerImpl(WorkspaceManager wspManager, ItemManager itemManager) {
+    public LockManagerImpl(WorkspaceManager wspManager, ItemManager itemManager,
+                           CacheBehaviour cacheBehaviour) {
+        this.cacheBehaviour = cacheBehaviour;
-        // TODO: TOBEFIXED
-        if (nodeState.isWorkspaceState()) {
-            throw new RepositoryException("Internal error: Cannot create Lock for 'workspace' state.");
-        }
+        nodeState.checkIsSessionState();
-        // the overlayed workspace nodestate. See below.
-        Item item = itemManager.getItem(nodeState);
+        // the overlayed workspace nodestate.
+        Item item = itemManager.getItem(nodeState.getHierarchyEntry());
-        NodeState wspNodeState = getWorkspaceState(nodeState);
-        LockOperation op = LockOperation.create(wspNodeState, isDeep, isSessionScoped);
+        LockOperation op = LockOperation.create(nodeState, isDeep, isSessionScoped);
-        Lock lock = new LockImpl(new LockState(wspNodeState, op.getLockInfo()), lhNode);
+        Lock lock = new LockImpl(new LockState(nodeState, op.getLockInfo()), lhNode);
-        NodeState wspNodeState = getWorkspaceState(nodeState);
-        Operation op = LockRelease.create(wspNodeState);
+        Operation op = LockRelease.create(nodeState);
-        if (lockMap.containsKey(wspNodeState)) {
-            LockImpl l = (LockImpl) lockMap.remove(wspNodeState);
+        if (lockMap.containsKey(nodeState)) {
+            LockImpl l = (LockImpl) lockMap.remove(nodeState);
-        LockImpl l = getLockImpl(nodeState);
+        LockImpl l = getLockImpl(nodeState, false);
-        if (nodeState.isWorkspaceState()) {
-            LockState lSt = getLockState(nodeState);
-            return lSt != null;
-        } else {
-            LockImpl l = getLockImpl(nodeState);
-            return l != null;
-        }
+        nodeState.checkIsSessionState();
+
+        LockImpl l = getLockImpl(nodeState, false);
+        return l != null;
+        nodeState.checkIsSessionState();
+
-        if (nodeState.isWorkspaceState()) {
-            LockState lSt = getLockState(nodeState);
-            if (lSt != null && lSt.lockInfo.getLockToken() == null) {
-                // lock is present and token is null -> session is not lock-holder.
-                throw new LockException("Node with id '" + nodeState + "' is locked.");
-            } // else: state is not locked at all || session is lock-holder
-        } else {
-            LockImpl l = getLockImpl(nodeState);
-            if (l != null && l.getLockToken() == null) {
-                // lock is present and token is null -> session is not lock-holder.
-                throw new LockException("Node with id '" + nodeState + "' is locked.");
-            } // else: state is not locked at all || session is lock-holder
-        }
+        LockImpl l = getLockImpl(nodeState, true);
+        if (l != null && l.getLockToken() == null) {
+            // lock is present and token is null -> session is not lock-holder.
+            throw new LockException("Node with id '" + nodeState + "' is locked.");
+        } // else: state is not locked at all || session is lock-holder
-    /**
-     * The workspace state of the given node is returned. If the state is a new
-     * state (no overlayed state and not being workspace state itself), an
-     * <code>IllegalArgumentException</code> is thrown.
-     *
-     * @param nodeState
-     * @return The overlayed state or the given state, if this one does not have
-     * an overlayed state.
-     */
-    private NodeState getWorkspaceState(NodeState nodeState) {
-        NodeState wspState = (NodeState) nodeState.getWorkspaceState();
-        if (wspState == null) {
-            throw new IllegalArgumentException("NodeState " + nodeState + " has no overlayed state.");
-        }
-        return wspState;
-    }
+     * Note, that in certain cases it might not be possible to detect a lock
+     * being present due to the fact that the hierarchy might be imcomplete or
+     * not even readable completely.
-        while (!nodeState.hasPropertyName(QName.JCR_LOCKISDEEP)) {
-            NodeState parentState = nodeState.getParent();
-            if (parentState == null) {
+        NodeEntry entry = nodeState.getNodeEntry();
+        while (!entry.hasPropertyEntry(QName.JCR_LOCKISDEEP)) {
+            NodeEntry parent = entry.getParent();
+            if (parent == null) {
-            nodeState = parentState;
+            entry = parent;
-        return nodeState;
+        try {
+            return entry.getNodeState();
+        } catch (ItemStateException e) {
+            // may occur if the nodeState is not accessible
+            // for this case, assume that no lock exists and delegate final
+            // validation to the spi-implementation.
+            log.warn("Error while accessing lock holding NodeState", e);
+            return null;
+        }
-    private LockState getLockState(NodeState wspState) throws LockException, RepositoryException {
-        wspState.checkIsWorkspaceState();
-
-        if (lockMap.containsKey(wspState)) {
-            LockImpl lock = (LockImpl) lockMap.get(wspState);
-            return lock.lockState;
+    private LockState buildLockState(NodeState nodeState) throws RepositoryException {
+        NodeState lockHoldingState = null;
+        LockInfo lockInfo;
+        try {
+            lockInfo = wspManager.getLockInfo(nodeState.getNodeId());
+        } catch (LockException e) {
+            // no lock present
+            return null;
-        // try to retrieve a state (ev. a parent state) that holds a lock.
-        NodeState lockHoldingWspState = getLockHoldingState(wspState);
-        if (lockHoldingWspState == null) {
-            // no lock
+        NodeId lockNodeId = lockInfo.getNodeId();
+        if (lockNodeId.equals(nodeState.getId())) {
+            lockHoldingState = nodeState;
+        } else {
+            HierarchyEntry lockedEntry = wspManager.getHierarchyManager().getHierarchyEntry(lockNodeId);
+            if (lockedEntry.denotesNode()) {
+                try {
+                    lockHoldingState = ((NodeEntry) lockedEntry).getNodeState();
+                } catch (ItemStateException e) {
+                    log.warn("Cannot build LockState");
+                    throw new RepositoryException("Cannot build LockState", e);
+                }
+            } else {
+                // should never occur
+                throw new RepositoryException("Internal error.");
+            }
+        }
+
+        if (lockHoldingState == null) {
-            if (lockMap.containsKey(lockHoldingWspState)) {
-                LockImpl lock = (LockImpl) lockMap.get(lockHoldingWspState);
-                return lock.lockState;
-            }
-
-            LockState st = new LockState(lockHoldingWspState);
-            if (st.appliesToNodeState(wspState)) {
-                return st;
-            } else {
-                // lock exists but does not apply to the workspace node state
-                // passed to this method.
-                return null;
-            }
+            return new LockState(lockHoldingState, lockInfo);
+     * @param lazyLockDiscovery If true, no extra check with the server is made in order to
+     * determine, whether there is really no lock present. Otherwise, the server
+     * is asked if a lock is present.
-    private LockImpl getLockImpl(NodeState nodeState) throws RepositoryException {
+    private LockImpl getLockImpl(NodeState nodeState, boolean lazyLockDiscovery) throws RepositoryException {
+        nodeState.checkIsSessionState();
+
-        NodeState wspSt = (NodeState) nodeState.getWorkspaceState();
-        if (wspSt != null && lockMap.containsKey(nodeState)) {
+        if (lockMap.containsKey(nodeState)) {
-        // try to retrieve a state (ev. a parent state) that holds a lock.
-        NodeState lockHoldingState = getLockHoldingState(nodeState);
-        if (lockHoldingState == null) {
-            // no lock
-            return null;
-        } else {
-            NodeState lockHoldingWspState = getWorkspaceState(lockHoldingState);
-            // check lockMap again with the lockholding state
-            if (lockMap.containsKey(lockHoldingWspState)) {
-                return (LockImpl) lockMap.get(lockHoldingWspState);
-            }
-
-            if (lockHoldingWspState == lockHoldingState) {
-                // TODO: TOBEFIXED the Lock cannot be builded from a wsp-state since the Node cannot be retrieved.
-                throw new RepositoryException("Internal error: Cannot retrieve Lock for 'workspace' state " + nodeState);
-            }
-            LockState lstate = new LockState(lockHoldingWspState);
-            // Lock has never been access -> build the lock object
-            // retrieve lock holding node. note that this may fail if the session
-            // does not have permission to see this node.
-            Item lockHoldingNode = itemManager.getItem(lockHoldingState);
-            LockImpl l = new LockImpl(lstate, (Node)lockHoldingNode);
-
-            if (l.lockState.appliesToNodeState(nodeState)) {
-                return l;
-            } else {
-                // lock exists but does not apply to the workspace node state
-                // passed to this method.
+        LockState lState;
+        if (lazyLockDiscovery) {
+            // try to retrieve a state (ev. a parent state) that holds a lock.
+            NodeState lockHoldingState = getLockHoldingState(nodeState);
+            if (lockHoldingState == null) {
+                // no lock
+            } else {
+                // check lockMap again with the lockholding state
+                if (lockMap.containsKey(lockHoldingState)) {
+                    return (LockImpl) lockMap.get(lockHoldingState);
+                }
+                lState = buildLockState(lockHoldingState);
+        } else {
+            lState = buildLockState(nodeState);
+        }
+
+        // Lock has never been access -> build the lock object
+        // retrieve lock holding node. note that this may fail if the session
+        // does not have permission to see this node.
+        if (lState != null && lState.appliesToNodeState(nodeState)) {
+            Item lockHoldingNode = itemManager.getItem(lState.lockHoldingState.getHierarchyEntry());
+            return new LockImpl(lState, (Node)lockHoldingNode);
+        } else {
+            // lock exists but does not apply to the given node state
+            // passed to this method.
+            return null;
-    private class LockState implements InternalEventListener{
+    private class LockState implements ItemStateLifeCycleListener {
-        private EventFilter eventFilter;
-        private LockState(NodeState lockHoldingState, LockInfo lockInfo)
-            throws LockException, RepositoryException{
-            lockHoldingState.checkIsWorkspaceState();
+        private LockState(NodeState lockHoldingState, LockInfo lockInfo) {
+            lockHoldingState.checkIsSessionState();
-            if (lockInfo == null) {
-                // retrieve lock info from wsp-manager, in order to get the complete
-                // lockInfo including lock-token, which is not available from the
-                // child properties nor from the original lock request.
-                this.lockInfo = wspManager.getLockInfo(lockHoldingState.getNodeId());
-            } else {
-                this.lockInfo = lockInfo;
-            }
-
-            try {
-                // register as internal listener to the wsp manager in order to get
-                // informed if this lock ends his life.
-                eventFilter = wspManager.createEventFilter(Event.PROPERTY_REMOVED,
-                    lockHoldingState.getQPath(), false, null, null, true);
-                wspManager.addEventListener(this);
-            } catch (UnsupportedRepositoryOperationException e) {
-                eventFilter = null;
-            }
-        }
-
-        private LockState(NodeState lockHoldingState) throws LockException, RepositoryException {
-            this(lockHoldingState, null);
+            this.lockInfo = lockInfo;
-                NodeState wspState = getWorkspaceState(nodeState);
-                if (lockHoldingState == wspState) {
+                if (lockHoldingState == nodeState) {
-            wspManager.removeEventListener(this);
+            stopListening();
-        //------------------------------------------< InternalEventListener >---
-
-        /**
-         * @see InternalEventListener#getEventFilters()
-         */
-        public Collection getEventFilters() {
-            return (eventFilter == null) ?  Collections.EMPTY_LIST : Collections.singletonList(eventFilter);
+        private void startListening() {
+            if (cacheBehaviour == CacheBehaviour.OBSERVATION) {
+                try {
+                    PropertyState ps = lockHoldingState.getPropertyState(QName.JCR_LOCKISDEEP);
+                    ps.addListener(this);
+                } catch (ItemStateException e) {
+                    log.warn("Internal error", e);
+                }
+            }
-        /**
-         * @see InternalEventListener#onEvent(EventBundle)
-         */
-        public void onEvent(EventBundle eventBundle) {
+        private void stopListening() {
+            if (cacheBehaviour == CacheBehaviour.OBSERVATION) {
+                try {
+                    PropertyState ps = lockHoldingState.getPropertyState(QName.JCR_LOCKISDEEP);
+                    ps.removeListener(this);
+                } catch (ItemStateException e) {
+                    log.warn("Internal error", e);
+                }
+            }
+        }
+
+        //-------------------------------------< ItemStateLifeCycleListener >---
+        public void statusChanged(ItemState state, int previousStatus) {
-            // this lock has been release by someone else (and not by
-            // a call to LockManager#unlock -> clean up and set isLive
-            // flag to false.
-            unlocked();
+            switch (state.getStatus()) {
+                case Status.REMOVED:
+                    // this lock has been release by someone else (and not by
+                    // a call to LockManager#unlock -> clean up and set isLive
+                    // flag to false.
+                    unlocked();
+               default:
+                   // not interested (Todo correct?)
+            }
-            // if observation is supported -> store lock in the map
-            if (lockState.eventFilter != null) {
+            // if observation is supported OR if this is a session-scoped lock
+            // holded by this session -> store lock in the map
+            if (cacheBehaviour == CacheBehaviour.OBSERVATION) {
+                lockMap.put(lockState.lockHoldingState, this);
+                lockState.startListening();
+            } else if (isSessionScoped() && isHoldBySession()) {
+        //--------------------------------------------------------< private >---
+        private boolean isHoldBySession() {
+            return lockState.lockInfo.getLockToken() != null;
+        }
-}
+}

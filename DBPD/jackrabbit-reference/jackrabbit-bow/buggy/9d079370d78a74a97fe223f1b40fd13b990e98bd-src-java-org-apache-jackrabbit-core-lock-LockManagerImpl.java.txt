True caching in CachingHierarchyManager

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@190372 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.commons.collections.SequencedHashMap;
-import java.util.Map;
-import java.util.HashMap;
+import java.util.Iterator;
-    /**`
-     * Map of nodes that been removed and may be re-added as result
-     * of a move operation
-     */
-    private final Map zombieNodes = new HashMap();
-
-        lockMap.traverse(new PathMap.ChildVisitor() {
-            public void childVisited(PathMap.Child child) {
-                LockInfo info = (LockInfo) child.get();
+        lockMap.traverse(new PathMap.ElementVisitor() {
+            public void elementVisited(PathMap.Element element) {
+                LockInfo info = (LockInfo) element.get();
-        PathMap.Child child = lockMap.map(path, false);
+        PathMap.Element element = lockMap.map(path, false);
-        LockInfo other = (LockInfo) child.get();
+        LockInfo other = (LockInfo) element.get();
-            if (child.hasPath(path)) {
+            if (element.hasPath(path)) {
-        if (info.deep && child.hasPath(path)) {
+        if (info.deep && element.hasPath(path)) {
-            PathMap.Child child = lockMap.map(path, true);
-            if (child != null) {
-                child.set(null);
+            PathMap.Element element = lockMap.map(path, true);
+            if (element != null) {
+                element.set(null);
-        PathMap.Child child = lockMap.map(path, false);
-        LockInfo info = (LockInfo) child.get();
+        PathMap.Element element = lockMap.map(path, false);
+        LockInfo info = (LockInfo) element.get();
-        if (child.hasPath(path) || info.deep) {
+        if (element.hasPath(path) || info.deep) {
-        PathMap.Child child = lockMap.map(path, true);
-        if (child == null) {
+        PathMap.Element element = lockMap.map(path, true);
+        if (element == null) {
-        LockInfo info = (LockInfo) child.get();
+        LockInfo info = (LockInfo) element.get();
-        child.set(null);
+        element.set(null);
-        PathMap.Child child = lockMap.map(node.getPrimaryPath(), true);
-        if (child == null) {
+        PathMap.Element element = lockMap.map(node.getPrimaryPath(), true);
+        if (element == null) {
-        return child.get() != null;
+        return element.get() != null;
-        PathMap.Child child = lockMap.map(path, false);
-        LockInfo info = (LockInfo) child.get();
+        PathMap.Element element = lockMap.map(path, false);
+        LockInfo info = (LockInfo) element.get();
-        if (child.hasPath(path)) {
+        if (element.hasPath(path)) {
-        PathMap.Child child = lockMap.map(path, false);
-        LockInfo info = (LockInfo) child.get();
+        PathMap.Element element = lockMap.map(path, false);
+        LockInfo info = (LockInfo) element.get();
-            if (child.hasPath(path) || info.deep) {
+            if (element.hasPath(path) || info.deep) {
-            PathMap.Child child = lockMap.map(node.getPrimaryPath(), true);
-            if (child != null) {
-                LockInfo info = (LockInfo) child.get();
+            PathMap.Element element = lockMap.map(node.getPrimaryPath(), true);
+            if (element != null) {
+                LockInfo info = (LockInfo) element.get();
-            PathMap.Child child = lockMap.map(node.getPrimaryPath(), true);
-            if (child != null) {
-                LockInfo info = (LockInfo) child.get();
+            PathMap.Element element = lockMap.map(node.getPrimaryPath(), true);
+            if (element != null) {
+                LockInfo info = (LockInfo) element.get();
+     * Internal event class that holds old and new paths for moved nodes
+     */
+    private class HierarchyEvent {
+
+        /**
+         * UUID recorded in event
+         */
+        public final String uuid;
+
+        /**
+         * Path recorded in event
+         */
+        public final Path path;
+
+        /**
+         * Old path in move operation
+         */
+        private Path oldPath;
+
+        /**
+         * New path in move operation
+         */
+        private Path newPath;
+
+        /**
+         * Event type, may be {@link Event#NODE_ADDED},
+         * {@link Event#NODE_REMOVED} or a combination of both
+         */
+        private int type;
+
+        /**
+         * Create a new instance of this class.
+         * @param uuid uuid
+         * @param path path
+         * @param type event type
+         */
+        public HierarchyEvent(String uuid, Path path, int type) {
+            this.uuid = uuid;
+            this.path = path;
+            this.type = type;
+        }
+
+        /**
+         * Merge this event with another event. The result will be stored in
+         * this event
+         * @param event other event to merge with
+         */
+        public void merge(HierarchyEvent event) {
+            type |= event.type;
+            if (event.type == Event.NODE_ADDED) {
+                newPath = event.path;
+                oldPath = path;
+            } else {
+                oldPath = event.path;
+                newPath = path;
+            }
+        }
+
+        /**
+         * Return the event type. May be {@link Event#NODE_ADDED},
+         * {@link Event#NODE_REMOVED} or a combination of both.\
+         * @return event type
+         */
+        public int getType() {
+            return type;
+        }
+
+        /**
+         * Return the old path if this is a move operation
+         * @return old path
+         */
+        public Path getOldPath() {
+            return oldPath;
+        }
+
+        /**
+         * Return the new path if this is a move operation
+         * @return new path
+         */
+        public Path getNewPath() {
+            return newPath;
+        }
+    }
+
+    /**
-        while (events.hasNext()) {
-            EventImpl event = (EventImpl) events.nextEvent();
-            switch (event.getType()) {
+        Iterator iter = consolidateEvents(events);
+        while (iter.hasNext()) {
+            HierarchyEvent event = (HierarchyEvent) iter.next();
+            switch (event.type) {
-                    try {
-                        nodeAdded(event.getChildUUID(),
-                                Path.create(event.getPath(), nsResolver, true));
-                    } catch (MalformedPathException e) {
-                        log.info("Unable to get event's path: " + e.getMessage());
-                    } catch (RepositoryException e) {
-                        log.info("Unable to get event's path: " + e.getMessage());
-                    }
+                    nodeAdded(event.path);
-                    try {
-                        nodeRemoved(event.getChildUUID(),
-                                Path.create(event.getPath(), nsResolver, true));
-                    } catch (MalformedPathException e) {
-                        log.info("Unable to get event's path: " + e.getMessage());
-                    } catch (RepositoryException e) {
-                        log.info("Unable to get event's path: " + e.getMessage());
-                    }
+                    nodeRemoved(event.path);
+                    break;
+                case Event.NODE_ADDED | Event.NODE_REMOVED:
+                    nodeMoved(event.getOldPath(), event.getNewPath());
-     * Invoked when some node has been added. Relink the child inside our
-     * zombie map to the new parent. Revitalize all locks inside the
-     * zombie child hierarchy.
+     * Consolidate an event iterator obtained from observation, merging
+     * add and remove operations on nodes with the same UUID into a move
+     * operation.
-    private synchronized void nodeAdded(String uuid, Path path) {
-        try {
-            PathMap.Child parent = lockMap.map(path.getAncestor(1), true);
-            if (parent != null) {
-                parent.insertChild(path.getNameElement());
+    private Iterator consolidateEvents(EventIterator events) {
+        SequencedHashMap eventMap = new SequencedHashMap();
+
+        while (events.hasNext()) {
+            EventImpl event = (EventImpl) events.nextEvent();
+            HierarchyEvent he;
+
+            try {
+                he = new HierarchyEvent(event.getChildUUID(),
+                        Path.create(event.getPath(), nsResolver, true),
+                        event.getType());
+            } catch (MalformedPathException e) {
+                log.info("Unable to get event's path: " + e.getMessage());
+                continue;
+            } catch (RepositoryException e) {
+                log.info("Unable to get event's path: " + e.getMessage());
+                continue;
-            PathMap.Child zombie = (PathMap.Child) zombieNodes.remove(uuid);
-            if (zombie != null) {
-                zombie.traverse(new PathMap.ChildVisitor() {
-                    public void childVisited(PathMap.Child child) {
-                        LockInfo info = (LockInfo) child.get();
-                        info.setLive(true);
-                    }
-                }, false);
-                lockMap.resurrect(path, zombie);
+
+            HierarchyEvent heExisting = (HierarchyEvent) eventMap.get(he.uuid);
+            if (heExisting != null) {
+                heExisting.merge(he);
+            } else {
+                eventMap.put(he.uuid, he);
+            }
+        }
+        return eventMap.values().iterator();
+    }
+
+    /**
+     * Invoked when some node has been added. If the parent of that node
+     * exists, shift all name siblings of the new node having an index greater
+     * or equal.
+     * @param path path of added node
+     */
+    private synchronized void nodeAdded(Path path) {
+        try {
+            PathMap.Element parent = lockMap.map(path.getAncestor(1), true);
+            if (parent != null) {
+                parent.insert(path.getNameElement());
-            log.warn("Added node does not have parent, ignoring event.");
+            log.warn("Unable to determine path of added node's parent.", e);
+            return;
-     * Invoked when some node has been removed. Unlink the child inside
-     * our path map corresponding to that node. Disable all locks contained
-     * in that subtree.
+     * Invoked when some node has been moved. Relink the child inside our
+     * map to the new parent.
+     * @param oldPath old path
-    private synchronized void nodeRemoved(String uuid, Path path) {
+    private synchronized void nodeMoved(Path oldPath, Path newPath) {
+        PathMap.Element element = lockMap.map(oldPath, true);
+        if (element != null) {
+            element.remove();
+        }
+
-            PathMap.Child parent = lockMap.map(path.getAncestor(1), true);
+            PathMap.Element parent = lockMap.map(newPath.getAncestor(1), true);
-                PathMap.Child child = parent.removeChild(path.getNameElement());
-                if (child != null) {
-                    child.traverse(new PathMap.ChildVisitor() {
-                        public void childVisited(PathMap.Child child) {
-                            LockInfo info = (LockInfo) child.get();
+                parent.insert(newPath.getNameElement());
+            }
+            if (element != null) {
+                lockMap.put(newPath, element);
+            }
+        } catch (PathNotFoundException e) {
+            log.warn("Unable to determine path of moved node's parent.", e);
+            return;
+        }
+    }
+
+    /**
+     * Invoked when some node has been removed. Remove the child from our
+     * path map. Disable all locks contained in that subtree.
+     * @param path path of removed node
+     */
+    private synchronized void nodeRemoved(Path path) {
+        try {
+            PathMap.Element parent = lockMap.map(path.getAncestor(1), true);
+            if (parent != null) {
+                PathMap.Element element = parent.remove(path.getNameElement());
+                if (element != null) {
+                    element.traverse(new PathMap.ElementVisitor() {
+                        public void elementVisited(PathMap.Element element) {
+                            LockInfo info = (LockInfo) element.get();
-                    zombieNodes.put(uuid, child);
-            log.warn("Removed node does not have parent, ignoring event.");
+            log.warn("Unable to determine path of moved node's parent.", e);
+            return;

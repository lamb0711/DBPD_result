JCR-1111 patch applied

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@592947 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.state.NodeState.ChildNodeEntry;
-     * value = version
+     * value = version name
+    
+    /**
+     * the hashmap of all versions names
+     * key = version name
+     * value = version id (NodeId)
+     */  
+    private HashMap nameCache = new HashMap();
-     * key = versionId (NodeId)
+     * key = version id (NodeId)
-
+    
-
+    
+        nameCache.clear();
-
+        
-
-        // get entries
-        NodeStateEx[] children = node.getChildNodes();
-        for (int i = 0; i < children.length; i++) {
-            NodeStateEx child = children[i];
-            if (child.getName().equals(NameConstants.JCR_VERSIONLABELS)) {
-                labelNode = child;
-                continue;
-            }
-            InternalVersionImpl v = createVersionInstance(child);
-            versionCache.put(v.getId(), v);
-            if (v.isRootVersion()) {
-                rootVersion = v;
-            }
-            vMgr.versionCreated(v);
-        }
-
-        // check for legacy version nodes that had 'virtual' jcr:successor property
-        if (rootVersion.getSuccessors().length==0 && versionCache.size()>1) {
-            // resolve successors and predecessors
-            Iterator iter = versionCache.values().iterator();
-            while (iter.hasNext()) {
-                InternalVersionImpl v = (InternalVersionImpl) iter.next();
-                v.legacyResolveSuccessors();
-            }
-        }
-
-        try {
-            // init label cache
+        
+        // get label node
+        labelNode = node.getNode(NameConstants.JCR_VERSIONLABELS, 1);
+        
+        // init label cache
+        try {  
-                    Name name = pState.getName();
+                    Name labelName = pState.getName();
-                    InternalVersionImpl v = (InternalVersionImpl) getVersion(new NodeId(ref));
-                    if (v != null) {
-                        labelCache.put(name, v);
-                        v.internalAddLabel(name);
+                    NodeId id = new NodeId(ref);
+                    if (node.getState().hasChildNodeEntry(id)) {
+                        labelCache.put(labelName, node.getState().getChildNodeEntry(id).getName());
+        
+        // get root version
+        rootVersion = createVersionInstance(NameConstants.JCR_ROOTVERSION);
+        
+        // get version entries
+        ChildNodeEntry[] children = (ChildNodeEntry[])node.getState().getChildNodeEntries().toArray();
+        for (int i = 0; i < children.length; i++) {
+            ChildNodeEntry child = children[i];
+            if (child.getName().equals(NameConstants.JCR_VERSIONLABELS)) {
+                continue;
+            }
+            nameCache.put(child.getName(), child.getId());
+        }
+        
+        // fix legacy
+        if (rootVersion.getSuccessors().length==0) {		
+            Iterator iter = nameCache.keySet().iterator();
+            while (iter.hasNext()) {
+                Name versionName = (Name)iter.next();
+                InternalVersionImpl v = (InternalVersionImpl)createVersionInstance(versionName);
+                v.legacyResolveSuccessors();
+            }
+        }
-
+    
+    /**
+     * Create a version instance.
+     */
+    InternalVersionImpl createVersionInstance(Name name) {
+        try {
+            NodeStateEx nodeStateEx = node.getNode(name, 1);      
+            InternalVersionImpl v = createVersionInstance(nodeStateEx);	
+            versionCache.put(v.getId(), v);
+            vMgr.versionCreated(v);
+            
+            // add labels
+            Iterator iter = labelCache.keySet().iterator();
+            while (iter.hasNext()) {
+                Name labelName = (Name)iter.next();
+                Name versionName = (Name)labelCache.get(labelName);
+                if (v.getName().equals(versionName)) {
+                    v.internalAddLabel(labelName);
+                }
+            }
+            return v;
+        } catch (RepositoryException e) {
+            throw new IllegalArgumentException("Failed to create version " + name + ".");
+        }  
+    }
+    
-    public InternalVersion getVersion(Name versionName) throws VersionException {
-        // maybe add cache by name?
-        Iterator iter = versionCache.values().iterator();
-        while (iter.hasNext()) {
-            InternalVersion v = (InternalVersion) iter.next();
-            if (v.getName().equals(versionName)) {
-                return v;
-            }
-        }
-        throw new VersionException("Version " + versionName + " does not exist.");
+    public InternalVersion getVersion(Name versionName) throws VersionException {   	
+        NodeId versionId = (NodeId)nameCache.get(versionName);   	
+        if (versionId == null) {
+            throw new VersionException("Version " + versionName + " does not exist.");
+        }                      
+        
+        InternalVersion v = (InternalVersion)versionCache.get(versionId);
+        if (v == null) {
+            v = createVersionInstance(versionName);
+        }  
+        return v;
-        // maybe add cache?
-        Iterator iter = versionCache.values().iterator();
-        while (iter.hasNext()) {
-            InternalVersion v = (InternalVersion) iter.next();
-            if (v.getName().equals(versionName)) {
-                return true;
-            }
-        }
-        return false;
+        return nameCache.containsKey(versionName);
-        return versionCache.containsKey(id);
+        return nameCache.containsValue(id);
-        return (InternalVersion) versionCache.get(id);
+        InternalVersion v = (InternalVersion)versionCache.get(id);
+        if (v == null) {
+            Iterator iter = nameCache.keySet().iterator();
+            while (iter.hasNext()) {
+                Name versionName = (Name)iter.next();
+                if (nameCache.get(versionName).equals(id)) {
+                    v = createVersionInstance(versionName);
+                    break;
+                }
+            }
+        }
+        return v;
-        return (InternalVersion) labelCache.get(label);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public Iterator getVersions() {
-        return versionCache.values().iterator();
+        Name versionName = (Name)labelCache.get(label);
+        if (versionName == null) {
+            return null;
+        }
+    	
+        NodeId id = (NodeId)nameCache.get(versionName);
+        InternalVersion v = (InternalVersion)versionCache.get(id);
+        if (v == null) {
+            v = createVersionInstance(versionName);
+        }
+        return v;
-        return versionCache.size();
+        return nameCache.size();
+        nameCache.remove(versionName);
-
-        InternalVersionImpl prev = (InternalVersionImpl) labelCache.get(label);
-        if (prev == null) {
+        Name prevName = (Name) labelCache.get(label);
+        InternalVersionImpl prev = null;
+        if (prevName == null) {
+            prev = (InternalVersionImpl)getVersion(prevName);
-            labelCache.put(label, version);
+            labelCache.put(label, version.getName());
-            if (!versionCache.containsKey(new NodeId(predId))) {
+            if (!nameCache.containsValue(new NodeId(predId))) {
+        nameCache.put(version.getName(), version.getId());

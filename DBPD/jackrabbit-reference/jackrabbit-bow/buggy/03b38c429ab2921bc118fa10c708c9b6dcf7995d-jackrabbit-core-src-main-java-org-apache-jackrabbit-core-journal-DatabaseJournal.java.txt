JCR-1456: Database connection pooling

Merge back all changes from the JCR-1456 sandbox branch.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@886191 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.persistence.bundle.util.ConnectionFactory;
+import org.apache.commons.io.IOUtils;
+import org.apache.jackrabbit.core.util.db.CheckSchemaOperation;
+import org.apache.jackrabbit.core.util.db.ConnectionFactory;
+import org.apache.jackrabbit.core.util.db.ConnectionHelper;
+import org.apache.jackrabbit.core.util.db.DatabaseAware;
+import org.apache.jackrabbit.core.util.db.DbUtility;
+import org.apache.jackrabbit.core.util.db.StreamWrapper;
-import org.apache.jackrabbit.util.Text;
+import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.sql.Connection;
-import java.sql.DatabaseMetaData;
-import java.sql.PreparedStatement;
-import java.sql.Statement;
+import javax.sql.DataSource;
-public class DatabaseJournal extends AbstractJournal {
-
-    /**
-     * Schema object prefix.
-     */
-    private static final String SCHEMA_OBJECT_PREFIX_VARIABLE =
-            "${schemaObjectPrefix}";
-
-    /**
-     * Default DDL script name.
-     */
-    private static final String DEFAULT_DDL_NAME = "default.ddl";
+public class DatabaseJournal extends AbstractJournal implements DatabaseAware {
-     * Default reconnect delay in milliseconds.
-     */
-    private static final long DEFAULT_RECONNECT_DELAY_MS = 10000;
-
-    /**
-     * Reconnect delay in milliseconds, bean property.
+     * DataSource logical name, bean property.
-    private long reconnectDelayMs;
+    private String dataSourceName;
-     * JDBC Connection used.
+     * The connection helper
-    private Connection connection;
-
-    /**
-     * Statement returning all revisions within a range.
-     */
-    private PreparedStatement selectRevisionsStmt;
-
-    /**
-     * Statement updating the global revision.
-     */
-    private PreparedStatement updateGlobalStmt;
-
-    /**
-     * Statement returning the global revision.
-     */
-    private PreparedStatement selectGlobalStmt;
-
-    /**
-     * Statement appending a new record.
-     */
-    private PreparedStatement insertRevisionStmt;
-
-    /**
-     * Statement returning the minimum of the local revisions.
-     */
-    private PreparedStatement selectMinLocalRevisionStmt;
-
-    /**
-     * Statement removing a set of revisions with from the journal table.
-     */
-    private PreparedStatement cleanRevisionStmt;
-
-    /**
-     * Statement returning the local revision of this cluster node.
-     */
-    private PreparedStatement getLocalRevisionStmt;
-
-    /**
-     * Statement for inserting the local revision of this cluster node.
-     */
-    private PreparedStatement insertLocalRevisionStmt;
-
-    /**
-     * Statement for updating the local revision of this cluster node.
-     */
-    private PreparedStatement updateLocalRevisionStmt;
+    private ConnectionHelper conHelper;
-     * Next time in milliseconds to reattempt connecting to the database.
-     */
-    private long reconnectTimeMs;
-
-    /**
-    private boolean janitorEnabled;
+    private boolean janitorEnabled = false;
+
-
+    
-
+    
-     * SQL statement for inserting the local revision of this cluster node.
+     * SQL statement for inserting the local revision of this cluster node. 
-     * SQL statement for updating the local revision of this cluster node.
+     * SQL statement for updating the local revision of this cluster node. 
+     * The repositories {@link ConnectionFactory}.
+     */
+    private ConnectionFactory connectionFactory;
+
+    public DatabaseJournal() {
+        databaseType = "default";
+        schemaObjectPrefix = "";
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void setConnectionFactory(ConnectionFactory connnectionFactory) {
+        this.connectionFactory = connnectionFactory;
+    }
+
+    /**
-        // Provide valid defaults for arguments
-        if (schemaObjectPrefix == null) {
-            schemaObjectPrefix = "";
-        }
-        if (reconnectDelayMs == 0) {
-            reconnectDelayMs = DEFAULT_RECONNECT_DELAY_MS;
-        }
-
-            connection = getConnection();
-            setAutoCommit(connection, true);
+            conHelper = createConnectionHelper(getDataSource());
+
+            // make sure schemaObjectPrefix consists of legal name characters only
+            schemaObjectPrefix = conHelper.prepareDbIdentifier(schemaObjectPrefix);
+
+            // check if schema objects exist and create them if necessary
-                checkSchema();
+                createCheckSchemaOperation().run();
+
-            prepareStatements();
+    private DataSource getDataSource() throws Exception {
+        if (getDataSourceName() == null || "".equals(getDataSourceName())) {
+            return connectionFactory.getDataSource(getDriver(), getUrl(), getUser(), getPassword());
+        } else {
+            return connectionFactory.getDataSource(dataSourceName);
+        }
+    }
+
+    /**
+     * This method is called from the {@link #init(String, NamespaceResolver)} method of this class and
+     * returns a {@link ConnectionHelper} instance which is assigned to the {@code conHelper} field.
+     * Subclasses may override it to return a specialized connection helper.
+     * 
+     * @param dataSrc the {@link DataSource} of this persistence manager
+     * @return a {@link ConnectionHelper}
+     * @throws Exception on error
+     */
+    protected ConnectionHelper createConnectionHelper(DataSource dataSrc) throws Exception {
+        return new ConnectionHelper(dataSrc, false);
+    }
+
+    /**
+     * This method is called from {@link #init(String, NamespaceResolver)} after the
+     * {@link #createConnectionHelper(DataSource)} method, and returns a default {@link CheckSchemaOperation}.
+     * Subclasses can overrride this implementation to get a customized implementation.
+     * 
+     * @return a new {@link CheckSchemaOperation} instance
+     */
+    protected CheckSchemaOperation createCheckSchemaOperation() {
+        InputStream in = DatabaseJournal.class.getResourceAsStream(databaseType + ".ddl");
+        return new CheckSchemaOperation(conHelper, in, schemaObjectPrefix + DEFAULT_JOURNAL_TABLE).addVariableReplacement(
+            CheckSchemaOperation.SCHEMA_OBJECT_PREFIX_VARIABLE, schemaObjectPrefix);
+    }
+
-        if (driver == null) {
+        if (driver == null && dataSourceName == null) {
-        if (url == null) {
+        if (url == null && dataSourceName == null) {
-
+        if (dataSourceName != null) {
+            try {
+                String configuredDatabaseType = connectionFactory.getDataBaseType(dataSourceName);
+                if (DatabaseJournal.class.getResourceAsStream(configuredDatabaseType + ".ddl") != null) {
+                    setDatabaseType(configuredDatabaseType);
+                }
+            } catch (RepositoryException e) {
+                throw new JournalException("failed to get database type", e);
+            }
+        }
-
-        try {
-            Class.forName(driver);
-        } catch (ClassNotFoundException e) {
-            String msg = "Unable to load driver class.";
-            throw new JournalException(msg, e);
-        }
-     * Creates a new database connection. This method is called inside
-     * {@link #init(String, org.apache.jackrabbit.spi.commons.namespace.NamespaceResolver)} or
-     * when a connection has been dropped and must be reacquired. Base
-     * implementation uses <code>java.sql.DriverManager</code> to get the
-     * connection. May be overridden by subclasses.
-     *
-     * @see #init()
-     * @return new connection
-     * @throws JournalException if the driver could not be loaded
-     * @throws SQLException if the connection could not be established
-     */
-    protected Connection getConnection() throws SQLException, JournalException {
-        try {
-            return ConnectionFactory.getConnection(driver, url, user, password);
-        } catch (RepositoryException e) {
-            String msg = "Unable to load driver class.";
-            throw new JournalException(msg, e);
-        }
-    }
-
-    /**
-    public RecordIterator getRecords(long startRevision)
-            throws JournalException {
-
+    public RecordIterator getRecords(long startRevision) throws JournalException {
-            checkConnection();
-
-            selectRevisionsStmt.clearParameters();
-            selectRevisionsStmt.clearWarnings();
-            selectRevisionsStmt.setLong(1, startRevision);
-            selectRevisionsStmt.execute();
-
-            return new DatabaseRecordIterator(
-                    selectRevisionsStmt.getResultSet(), getResolver(), getNamePathResolver());
+            return new DatabaseRecordIterator(conHelper.exec(selectRevisionsStmtSQL, new Object[]{new Long(
+                    startRevision)}, false, 0), getResolver(), getNamePathResolver());
-            close(true);
-
-            String msg = "Unable to return record iterator.";
-            throw new JournalException(msg, e);
+            throw new JournalException("Unable to return record iterator.", e);
-            checkConnection();
-
-            selectRevisionsStmt.clearParameters();
-            selectRevisionsStmt.clearWarnings();
-            selectRevisionsStmt.setLong(1, Long.MIN_VALUE);
-            selectRevisionsStmt.execute();
-
-            return new DatabaseRecordIterator(
-                    selectRevisionsStmt.getResultSet(), getResolver(), getNamePathResolver());
+            return new DatabaseRecordIterator(conHelper.exec(selectRevisionsStmtSQL, new Object[]{new Long(
+                    Long.MIN_VALUE)}, false, 0), getResolver(), getNamePathResolver());
-            close(true);
-
-            String msg = "Unable to return record iterator.";
-            throw new JournalException(msg, e);
+            throw new JournalException("Unable to return record iterator.", e);
-            checkConnection();
-                setAutoCommit(connection, false);
+                conHelper.startBatch();
-            close(true);
-
-            String msg = "Unable to set autocommit to false.";
-            throw new JournalException(msg, e);
+            throw new JournalException("Unable to set autocommit to false.", e);
-            updateGlobalStmt.clearParameters();
-            updateGlobalStmt.clearWarnings();
-            updateGlobalStmt.execute();
-
-            selectGlobalStmt.clearParameters();
-            selectGlobalStmt.clearWarnings();
-            selectGlobalStmt.execute();
-
-            rs = selectGlobalStmt.getResultSet();
+            conHelper.exec(updateGlobalStmtSQL);
+            rs = conHelper.exec(selectGlobalStmtSQL, null, false, 0);
-            close(true);
-
-            String msg = "Unable to lock global revision table.";
-            throw new JournalException(msg, e);
+            throw new JournalException("Unable to lock global revision table.", e);
-            close(rs);
+            DbUtility.close(rs);
-            if (successful) {
-                commit(connection);
-            } else {
-                rollback(connection);
+            try {
+                conHelper.endBatch(successful);;
+            } catch (SQLException e) {
+                log.error("failed to end batch", e);
-            setAutoCommit(connection, true);
-            checkConnection();
-
-            insertRevisionStmt.clearParameters();
-            insertRevisionStmt.clearWarnings();
-            insertRevisionStmt.setLong(1, record.getRevision());
-            insertRevisionStmt.setString(2, getId());
-            insertRevisionStmt.setString(3, record.getProducerId());
-            insertRevisionStmt.setBinaryStream(4, in, length);
-            insertRevisionStmt.execute();
+            conHelper.exec(insertRevisionStmtSQL, record.getRevision(), getId(), record.getProducerId(),
+                new StreamWrapper(in, length));
-            close(true);
-
-        close(false);
-     * Close database connections and statements. If closing was due to an
-     * error that occurred, calculates the next time a reconnect should
-     * be attempted.
-     *
-     * @param failure whether closing is due to a failure
-     */
-    private void close(boolean failure) {
-        if (failure) {
-            reconnectTimeMs = System.currentTimeMillis() + reconnectDelayMs;
-        }
-
-        close(selectRevisionsStmt);
-        selectRevisionsStmt = null;
-        close(updateGlobalStmt);
-        updateGlobalStmt = null;
-        close(selectGlobalStmt);
-        selectGlobalStmt = null;
-        close(insertRevisionStmt);
-        insertRevisionStmt = null;
-        close(selectMinLocalRevisionStmt);
-        selectMinLocalRevisionStmt = null;
-        close(cleanRevisionStmt);
-        cleanRevisionStmt = null;
-        close(getLocalRevisionStmt);
-        getLocalRevisionStmt = null;
-        close(insertLocalRevisionStmt);
-        insertLocalRevisionStmt = null;
-        close(updateLocalRevisionStmt);
-        updateLocalRevisionStmt = null;
-
-        close(connection);
-        connection = null;
-    }
-
-    /**
-     * Set the autocommit flag of a connection. Does nothing if the connection
-     * passed is <code>null</code> and logs any exception as warning.
-     *
-     * @param connection database connection
-     * @param autoCommit where to enable or disable autocommit
-     */
-    private static void setAutoCommit(Connection connection, boolean autoCommit) {
-        if (connection != null) {
-            try {
-                // JCR-1013: Setter may fail on a managed connection
-                if (connection.getAutoCommit() != autoCommit) {
-                    connection.setAutoCommit(autoCommit);
-                }
-            } catch (SQLException e) {
-                String msg = "Unable to set autocommit flag to " + autoCommit;
-                log.warn(msg, e);
-            }
-        }
-    }
-
-    /**
-     * Commit a connection. Does nothing if the connection passed is
-     * <code>null</code> and logs any exception as warning.
-     *
-     * @param connection connection.
-     */
-    private static void commit(Connection connection) {
-        if (connection != null) {
-            try {
-                connection.commit();
-            } catch (SQLException e) {
-                String msg = "Error while committing connection: " + e.getMessage();
-                log.warn(msg);
-            }
-        }
-    }
-
-    /**
-     * Rollback a connection. Does nothing if the connection passed is
-     * <code>null</code> and logs any exception as warning.
-     *
-     * @param connection connection.
-     */
-    private static void rollback(Connection connection) {
-        if (connection != null) {
-            try {
-                connection.rollback();
-            } catch (SQLException e) {
-                String msg = "Error while rolling back connection: " + e.getMessage();
-                log.warn(msg);
-            }
-        }
-    }
-
-    /**
-     * Closes the given database connection. Does nothing if the connection
-     * passed is <code>null</code> and logs any exception as warning.
-     *
-     * @param connection database connection
-     */
-    private static void close(Connection connection) {
-        if (connection != null) {
-            try {
-                connection.close();
-            } catch (SQLException e) {
-                String msg = "Error while closing connection: " + e.getMessage();
-                log.warn(msg);
-            }
-        }
-    }
-
-    /**
-     * Close some input stream.  Does nothing if the input stream
-     * passed is <code>null</code> and logs any exception as warning.
-     *
-     * @param in input stream, may be <code>null</code>.
-     */
-    private static void close(InputStream in) {
-        if (in != null) {
-            try {
-                in.close();
-            } catch (IOException e) {
-                String msg = "Error while closing input stream: " + e.getMessage();
-                log.warn(msg);
-            }
-        }
-    }
-
-    /**
-     * Close some statement.  Does nothing if the statement
-     * passed is <code>null</code> and logs any exception as warning.
-     *
-     * @param stmt statement, may be <code>null</code>.
-     */
-    private static void close(Statement stmt) {
-        if (stmt != null) {
-            try {
-                stmt.close();
-            } catch (SQLException e) {
-                String msg = "Error while closing statement: " + e.getMessage();
-                log.warn(msg);
-            }
-        }
-    }
-
-    /**
-     * Close some resultset.  Does nothing if the result set
-     * passed is <code>null</code> and logs any exception as warning.
-     *
-     * @param rs resultset, may be <code>null</code>.
-     */
-    private static void close(ResultSet rs) {
-        if (rs != null) {
-            try {
-                rs.close();
-            } catch (SQLException e) {
-                String msg = "Error while closing result set: " + e.getMessage();
-                log.warn(msg);
-            }
-        }
-    }
-
-    /**
-     * Checks the currently established connection. If the connection no longer
-     * exists, waits until at least <code>reconnectTimeMs</code> have passed
-     * since the error occurred and recreates the connection.
-     */
-    private void checkConnection() throws SQLException, JournalException {
-        if (connection == null) {
-            long delayMs = reconnectTimeMs - System.currentTimeMillis();
-            if (delayMs > 0) {
-                try {
-                    Thread.sleep(delayMs);
-                } catch (InterruptedException e) {
-                    /* ignore */
-                }
-            }
-            connection = getConnection();
-            prepareStatements();
-        }
-    }
-
-    /**
-     * Checks if the required schema objects exist and creates them if they
-     * don't exist yet.
-     *
-     * @throws Exception if an error occurs
-     */
-    private void checkSchema() throws Exception {
-        if (!tableExists(connection.getMetaData(), schemaObjectPrefix + DEFAULT_JOURNAL_TABLE)) {            // read ddl from resources
-            InputStream in = DatabaseJournal.class.getResourceAsStream(databaseType + ".ddl");
-            if (in == null) {
-                String msg = "No database-specific DDL found: '" + databaseType + ".ddl"
-                    + "', falling back to '" + DEFAULT_DDL_NAME + "'.";
-                log.info(msg);
-                in = DatabaseJournal.class.getResourceAsStream(DEFAULT_DDL_NAME);
-                if (in == null) {
-                    msg = "Unable to load '" + DEFAULT_DDL_NAME + "'.";
-                    throw new JournalException(msg);
-                }
-            }
-            BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-            Statement stmt = connection.createStatement();
-            try {
-                String sql = reader.readLine();
-                while (sql != null) {
-                    // Skip comments and empty lines
-                    if (!sql.startsWith("#") && sql.length() > 0) {
-                        // replace prefix variable
-                        sql = createSchemaSQL(sql);
-                        // execute sql stmt
-                        stmt.executeUpdate(sql);
-                    }
-                    // read next sql stmt
-                    sql = reader.readLine();
-                }
-            } finally {
-                close(in);
-                close(stmt);
-            }
-        }
-    }
-
-    /**
-        if (!tableExists(connection.getMetaData(), schemaObjectPrefix + LOCAL_REVISIONS_TABLE)) {
-            log.info("Creating " + schemaObjectPrefix + LOCAL_REVISIONS_TABLE + " table");
-            // read ddl from resources
-            InputStream in = DatabaseJournal.class.getResourceAsStream(databaseType + ".ddl");
-            if (in == null) {
-                String msg = "No database-specific DDL found: '" + databaseType + ".ddl" +
-                        "', falling back to '" + DEFAULT_DDL_NAME + "'.";
-                log.info(msg);
-                in = DatabaseJournal.class.getResourceAsStream(DEFAULT_DDL_NAME);
-                if (in == null) {
-                    msg = "Unable to load '" + DEFAULT_DDL_NAME + "'.";
-                    throw new JournalException(msg);
-                }
-            }
-            BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-            Statement stmt = connection.createStatement();
-            try {
-                String sql = reader.readLine();
-                while (sql != null) {
-                    // Skip comments and empty lines, and select only the statement
-                    // to create the LOCAL_REVISIONS table.
-                    if (!sql.startsWith("#") && sql.length() > 0
-                            && sql.indexOf(LOCAL_REVISIONS_TABLE) != -1) {
-                        // replace prefix variable
-                        sql = createSchemaSQL(sql);
-                        // execute sql stmt
-                        stmt.executeUpdate(sql);
-                    }
-                    // read next sql stmt
-                    sql = reader.readLine();
-                }
-            } finally {
-                close(in);
-                close(stmt);
-            }
-        }
-    }
-
-    /**
-     * Checks whether the required table(s) exist in the schema. May be
-     * overridden by subclasses to allow different table names.
-     *
-     * @param metaData database meta data
-     * @return <code>true</code> if the schema exists
-     * @throws SQLException if an SQL error occurs
-     */
-    protected boolean tableExists(DatabaseMetaData metaData, String tableName)
-        throws SQLException {
-
-        if (metaData.storesLowerCaseIdentifiers()) {
-            tableName = tableName.toLowerCase();
-        } else if (metaData.storesUpperCaseIdentifiers()) {
-            tableName = tableName.toUpperCase();
-        }
-
-        ResultSet rs = metaData.getTables(null, null, tableName, null);
-
+        InputStream localRevisionDDLStream = null;
+        InputStream in = DatabaseJournal.class.getResourceAsStream(databaseType + ".ddl");
-            return rs.next();
+            BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+            String sql = reader.readLine();
+            while (sql != null) {
+                // Skip comments and empty lines, and select only the statement to create the LOCAL_REVISIONS
+                // table.
+                if (!sql.startsWith("#") && sql.length() > 0 && sql.indexOf(LOCAL_REVISIONS_TABLE) != -1) {
+                    localRevisionDDLStream = new ByteArrayInputStream(sql.getBytes());
+                    break;
+                }
+                // read next sql stmt
+                sql = reader.readLine();
+            }
-            rs.close();
+            IOUtils.closeQuietly(in);
-    }
-
-    /**
-     * Creates an SQL statement for schema creation by variable substitution.
-     *
-     * @param sql a SQL string which may contain variables to substitute
-     * @return a valid SQL string
-     */
-    protected String createSchemaSQL(String sql) {
-        return Text.replace(sql, SCHEMA_OBJECT_PREFIX_VARIABLE, schemaObjectPrefix);
+        // Run the schema check for the single table
+        new CheckSchemaOperation(conHelper, localRevisionDDLStream, schemaObjectPrefix
+                + LOCAL_REVISIONS_TABLE).addVariableReplacement(
+            CheckSchemaOperation.SCHEMA_OBJECT_PREFIX_VARIABLE, schemaObjectPrefix).run();
-     * Prepares the SQL statements.
-     *
-     * @throws SQLException if an error occurs
-     */
-    private void prepareStatements() throws SQLException {
-        selectRevisionsStmt = connection.prepareStatement(selectRevisionsStmtSQL);
-        updateGlobalStmt = connection.prepareStatement(updateGlobalStmtSQL);
-        selectGlobalStmt = connection.prepareStatement(selectGlobalStmtSQL);
-        insertRevisionStmt = connection.prepareStatement(insertRevisionStmtSQL);
-        selectMinLocalRevisionStmt = connection.prepareStatement(selectMinLocalRevisionStmtSQL);
-        cleanRevisionStmt = connection.prepareStatement(cleanRevisionStmtSQL);
-        getLocalRevisionStmt = connection.prepareStatement(getLocalRevisionStmtSQL);
-        insertLocalRevisionStmt = connection.prepareStatement(insertLocalRevisionStmtSQL);
-        updateLocalRevisionStmt = connection.prepareStatement(updateLocalRevisionStmtSQL);
-    }
-
-    /**
-     *
+     * 
-     *
+     * 
-    public long getReconnectDelayMs() {
-        return reconnectDelayMs;
-    }
-
-     *
+     * 
-    * This method is deprecated; {@link #setDatabaseType} should be used instead.
-     *
+    * This method is deprecated; {@link #getDatabaseType} should be used instead.
+     * 
-    public void setReconnectDelayMs(long reconnectDelayMs) {
-        this.reconnectDelayMs = reconnectDelayMs;
-    }
-
+    public String getDataSourceName() {
+        return dataSourceName;
+    }
+
+    public void setDataSourceName(String dataSourceName) {
+        this.dataSourceName = dataSourceName;
+    }
+
-         * Indicates whether the init method has been called.
+         * Indicates whether the init method has been called. 
-        private boolean initialized;
+        private boolean initialized = false;
+            ResultSet rs = null;
-                // Check whether the connection is available
-                checkConnection();
-
-                getLocalRevisionStmt.clearParameters();
-                getLocalRevisionStmt.clearWarnings();
-                getLocalRevisionStmt.setString(1, getId());
-                getLocalRevisionStmt.execute();
-                ResultSet rs = getLocalRevisionStmt.getResultSet();
+                rs = conHelper.exec(getLocalRevisionStmtSQL, new Object[]{getId()}, false, 0);
-                rs.close();
-                    insertLocalRevisionStmt.clearParameters();
-                    insertLocalRevisionStmt.clearWarnings();
-                    insertLocalRevisionStmt.setLong(1, revision);
-                    insertLocalRevisionStmt.setString(2, getId());
-                    insertLocalRevisionStmt.execute();
+                    conHelper.exec(insertLocalRevisionStmtSQL, revision, getId());
-                DatabaseJournal.this.close(true);
+            } finally {
+                DbUtility.close(rs);
-                // Check whether the connection is available
-                checkConnection();
-                updateLocalRevisionStmt.clearParameters();
-                updateLocalRevisionStmt.clearWarnings();
-                updateLocalRevisionStmt.setLong(1, localRevision);
-                updateLocalRevisionStmt.setString(2, getId());
-                updateLocalRevisionStmt.execute();
+                conHelper.exec(updateLocalRevisionStmtSQL, localRevision, getId());
-                DatabaseJournal.this.close(true);
+                throw new JournalException("Failed to update local revision.", e);
-
+        
-        public synchronized void close() {
-            // Do nothing: The statements are closed in DatabaseJournal.close()
+        public void close() {
-
+        
+            ResultSet rs = null;
-
-                // Check whether the connection is available
-                checkConnection();
-
-                // Find the minimal local revision
-                selectMinLocalRevisionStmt.clearParameters();
-                selectMinLocalRevisionStmt.clearWarnings();
-                selectMinLocalRevisionStmt.execute();
-                ResultSet rs = selectMinLocalRevisionStmt.getResultSet();
+                rs = conHelper.exec(selectMinLocalRevisionStmtSQL, null, false, 0);
-                rs.close();
-                    cleanRevisionStmt.clearParameters();
-                    cleanRevisionStmt.clearWarnings();
-                    cleanRevisionStmt.setLong(1, minRevision);
-                    cleanRevisionStmt.execute();
+                    conHelper.exec(cleanRevisionStmtSQL, minRevision);
-                close(true);
+            } finally {
+                DbUtility.close(rs);

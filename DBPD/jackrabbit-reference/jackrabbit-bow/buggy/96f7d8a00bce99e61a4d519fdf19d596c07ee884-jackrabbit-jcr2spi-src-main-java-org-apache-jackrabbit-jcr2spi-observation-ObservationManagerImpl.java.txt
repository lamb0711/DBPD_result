JCR-2108: JSR 283 Observation

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@790826 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Iterator;
-import javax.jcr.UnsupportedRepositoryOperationException;
+import org.apache.jackrabbit.spi.Event;
-    private final Map subscriptions = new HashMap();
+    private final Map<EventListener, EventFilter> subscriptions = new HashMap<EventListener, EventFilter>();
-    private Map readOnlySubscriptions;
+    private Map<EventListener, EventFilter> readOnlySubscriptions;
+     *
-     * @param resolver
+     * @param resolver   the name path resolver for this session.
-     * @param valueFactory
-    public ObservationManagerImpl(WorkspaceManager wspManager, NamePathResolver resolver,
+    public ObservationManagerImpl(WorkspaceManager wspManager,
+                                  NamePathResolver resolver,
-        Path path;
-        try {
-            path = resolver.getQPath(absPath).getCanonicalPath();
-        } catch (NameException e) {
-            throw new RepositoryException("Malformed path: " + absPath);
-        }
-
-        // create NodeType instances from names
-        Name[] qNodeTypeNames;
-        if (nodeTypeNames == null) {
-            qNodeTypeNames = null;
-        } else {
-            try {
-                qNodeTypeNames = new Name[nodeTypeNames.length];
-                for (int i = 0; i < nodeTypeNames.length; i++) {
-                    Name ntName = resolver.getQName(nodeTypeNames[i]);
-                    if (!ntRegistry.isRegistered(ntName)) {
-                        throw new RepositoryException("unknown node type: " + nodeTypeNames[i]);
-                    }
-                    qNodeTypeNames[i] = ntName;
-                }
-            } catch (NameException e) {
-                throw new RepositoryException(e.getMessage());
-            }
-        }
-
-        EventFilter filter = wspManager.createEventFilter(eventTypes, path, isDeep, uuids, qNodeTypeNames, noLocal);
+        EventFilter filter = createEventFilter(eventTypes, absPath,
+                isDeep, uuids, nodeTypeNames, noLocal);
-        // TODO
-        throw new UnsupportedRepositoryOperationException("JCR-2108");
+        return getEventJournal(Event.ALL_TYPES, "/", true, null, null);
+    /**
+     * @see javax.jcr.observation.ObservationManager#getEventJournal(int, String, boolean, String[], String[])
+     */
-        throw new UnsupportedRepositoryOperationException("JCR-2108");
+        EventFilter filter = createEventFilter(eventTypes, absPath, isDeep, uuid, nodeTypeName, false);
+        return new EventJournalImpl(wspManager, filter, resolver);
-    public Collection getEventFilters() {
-        List filters = new ArrayList();
+    public Collection<EventFilter> getEventFilters() {
+        List<EventFilter> filters = new ArrayList<EventFilter>();
-        Map activeListeners;
+        Map<EventListener, EventFilter> activeListeners;
-        for (Iterator it = activeListeners.entrySet().iterator(); it.hasNext(); ) {
-            Map.Entry entry = (Map.Entry) it.next();
-            EventListener listener = (EventListener) entry.getKey();
-            EventFilter filter = (EventFilter) entry.getValue();
-            FilteredEventIterator eventIter = new FilteredEventIterator(eventBundle, filter, resolver, wspManager.getIdFactory());
+        for (Map.Entry<EventListener, EventFilter> entry : activeListeners.entrySet()) {
+            EventListener listener = entry.getKey();
+            EventFilter filter = entry.getValue();
+            FilteredEventIterator eventIter = new FilteredEventIterator(
+                    eventBundle.getEvents(), eventBundle.isLocal(), filter,
+                    resolver, wspManager.getIdFactory());
-            readOnlySubscriptions = new HashMap(subscriptions);
+            readOnlySubscriptions = new HashMap<EventListener, EventFilter>(subscriptions);
+    /**
+     * Creates an SPI event filter from the given list of constraints.
+     *
+     * @param eventTypes    the event types.
+     * @param absPath       an absolute path.
+     * @param isDeep        whether to include events for descendant items of
+     *                      the node at absPath.
+     * @param uuids         uuid filters.
+     * @param nodeTypeNames node type filters.
+     * @param noLocal       whether to exclude changes from the local session.
+     * @return the SPI event filter instance.
+     * @throws RepositoryException if an error occurs while creating the event
+     *                             filter.
+     */
+    private EventFilter createEventFilter(int eventTypes,
+                                          String absPath,
+                                          boolean isDeep,
+                                          String[] uuids,
+                                          String[] nodeTypeNames,
+                                          boolean noLocal)
+            throws RepositoryException {
+        Path path;
+        try {
+            path = resolver.getQPath(absPath).getCanonicalPath();
+        } catch (NameException e) {
+            throw new RepositoryException("Malformed path: " + absPath);
+        }
+
+        // create NodeType instances from names
+        Name[] qNodeTypeNames;
+        if (nodeTypeNames == null) {
+            qNodeTypeNames = null;
+        } else {
+            try {
+                qNodeTypeNames = new Name[nodeTypeNames.length];
+                for (int i = 0; i < nodeTypeNames.length; i++) {
+                    Name ntName = resolver.getQName(nodeTypeNames[i]);
+                    if (!ntRegistry.isRegistered(ntName)) {
+                        throw new RepositoryException("unknown node type: " + nodeTypeNames[i]);
+                    }
+                    qNodeTypeNames[i] = ntName;
+                }
+            } catch (NameException e) {
+                throw new RepositoryException(e.getMessage());
+            }
+        }
+
+        return wspManager.createEventFilter(eventTypes, path, isDeep,
+                uuids, qNodeTypeNames, noLocal);
+    }

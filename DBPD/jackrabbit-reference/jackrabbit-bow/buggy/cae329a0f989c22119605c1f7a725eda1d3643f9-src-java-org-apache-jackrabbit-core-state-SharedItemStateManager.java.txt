reworked transaction support, contributed by dominique

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@151380 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.collections.ReferenceMap;
-     * A cache for <code>NodeReferences</code> objects.
-     */
-    private Map refsCache = new ReferenceMap(ReferenceMap.HARD, ReferenceMap.SOFT);
-
-    /**
-     * Creates a new <code>DefaultItemStateManager</code> instance.
+     * Creates a new <code>SharedItemStateManager</code> instance.
-        ArrayList states = new ArrayList();
-        states.add(rootState);
-        states.add(prop);
+        ChangeLog changeLog = new ChangeLog();
+        changeLog.added(rootState);
+        changeLog.added(prop);
-        // do persist root node (incl. properties)
-        store(states, Collections.EMPTY_LIST);
+        persistMgr.store(changeLog);
+        changeLog.persisted();
-        NodeState state = persistMgr.load(id.getUUID());
+        NodeState state = persistMgr.load(id);
-        PropertyState state = persistMgr.load(id.getName(), id.getParentUUID());
+        PropertyState state = persistMgr.load(id);
-    public boolean hasItemState(ItemId id) {
+    public synchronized boolean hasItemState(ItemId id) {
-            return persistMgr.exists(id);
+            if (id.denotesNode()) {
+                return persistMgr.exists((NodeId) id);
+            } else {
+                return persistMgr.exists((PropertyId) id);
+            }
-    public synchronized NodeReferences getNodeReferences(NodeId targetId)
+    public synchronized NodeReferences getNodeReferences(NodeReferencesId id)
-        if (refsCache.containsKey(targetId)) {
-            return (NodeReferences) refsCache.get(targetId);
-        }
-
-            refs = persistMgr.load(targetId);
+            refs = persistMgr.load(id);
-            refs = new NodeReferences(targetId);
+            refs = new NodeReferences(id);
-        refsCache.put(targetId, refs);
-    /**
-     * @see ItemStateManager#beginUpdate
-     */
-    public UpdateOperation beginUpdate() throws ItemStateException {
-        throw new ItemStateException("Update not available.");
-    }
-
-    NodeState createInstance(String uuid, QName nodeTypeName,
-                             String parentUUID) {
+    private NodeState createInstance(String uuid, QName nodeTypeName,
+                                     String parentUUID) {
-        NodeState state = persistMgr.createNew(uuid, nodeTypeName, parentUUID);
+        NodeState state = persistMgr.createNew(new NodeId(uuid));
+        state.setNodeTypeName(nodeTypeName);
+        state.setParentUUID(parentUUID);
+     * Create a new node state instance
+     * @param other other state associated with new instance
+     * @return new node state instance
+     */
+    private ItemState createInstance(ItemState other) {
+        if (other.isNode()) {
+            NodeState ns = (NodeState) other;
+            return createInstance(ns.getUUID(), ns.getNodeTypeName(), ns.getParentUUID());
+        } else {
+            PropertyState ps = (PropertyState) other;
+            return createInstance(ps.getName(), ps.getParentUUID());
+        }
+    }
+
+    /**
-        PropertyState state = persistMgr.createNew(propName, parentUUID);
+        PropertyState state = persistMgr.createNew(
+                new PropertyId(parentUUID, propName));
-     * Store modified states and node references, atomically.
-     *
-     * @param states         states that have been modified
-     * @param refsCollection collection of refs to store
+     * Store modifications registered in a <code>ChangeLog</code>. The items
+     * contained in the <tt>ChangeLog</tt> are not states returned by this
+     * item state manager but rather must be reconnected to items provided
+     * by this state manager.
+     * @param local change log containing local items
-    void store(Collection states, Collection refsCollection)
-            throws ItemStateException {
+    public synchronized void store(ChangeLog local) throws ItemStateException {
+        ChangeLog shared = new ChangeLog();
-        persistMgr.store(states.iterator(), refsCollection.iterator());
-
-        Iterator iter = states.iterator();
+        /**
+         * Reconnect all items contained in the change log to their
+         * respective shared item and add the shared items to a
+         * new change log.
+         */
+        Iterator iter = local.addedStates();
-            int status = state.getStatus();
-            // @todo FIXME need to notify listeners on underlying (shared) state
-            if (state.getOverlayedState() != null) {
-                state = state.getOverlayedState();
-            }
-            switch (status) {
-                case ItemState.STATUS_NEW:
-                    state.notifyStateCreated();
-                    state.setStatus(ItemState.STATUS_EXISTING);
-                    break;
-
-                case ItemState.STATUS_EXISTING_REMOVED:
-                    state.notifyStateDestroyed();
-                    state.discard();
-                    break;
-
-                default:
-                    state.notifyStateUpdated();
-                    state.setStatus(ItemState.STATUS_EXISTING);
-                    break;
-            }
+            state.connect(createInstance(state));
+            shared.added(state.getOverlayedState());
-    }
+        iter = local.modifiedStates();
+        while (iter.hasNext()) {
+            ItemState state = (ItemState) iter.next();
+            state.connect(getItemState(state.getId()));
+            shared.modified(state.getOverlayedState());
+        }
+        iter = local.deletedStates();
+        while (iter.hasNext()) {
+            ItemState state = (ItemState) iter.next();
+            state.connect(getItemState(state.getId()));
+            shared.deleted(state.getOverlayedState());
+        }
+        iter = local.modifiedRefs();
+        while (iter.hasNext()) {
+            shared.modified((NodeReferences) iter.next());
+        }
+        /* Push all changes from the local items to the shared items */
+        local.push();
+
+        /* Store items in the underlying persistence manager */
+        persistMgr.store(shared);
+
+        /* Let the shared item listeners know about the change */
+        shared.persisted();
+    }

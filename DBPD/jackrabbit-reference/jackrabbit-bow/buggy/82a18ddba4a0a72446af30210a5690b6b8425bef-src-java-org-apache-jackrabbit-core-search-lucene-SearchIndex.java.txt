Redesign of query index to allow for generations of PersistentIndex instances. Indexing a lot of content is now faster and pauses during indexing are less frequent. At the same time less lucene IndexReader/Writer changes occur.

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@160385 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.fs.FileSystemResource;
-import org.apache.jackrabbit.core.state.ItemStateException;
-import org.apache.jackrabbit.core.state.ItemStateManager;
-import org.apache.jackrabbit.core.state.NoSuchItemStateException;
-import org.apache.jackrabbit.core.NodeId;
-import org.apache.jackrabbit.core.virtual.VirtualNodeState;
-import org.apache.lucene.index.MultiReader;
-import org.apache.lucene.index.IndexReader;
-import java.util.List;
-import java.util.Iterator;
-    /** Name of the write lock file */
-    private static final String WRITE_LOCK = "write.lock";
-
-    /** Default name of the redo log file */
-    private static final String REDO_LOG = "redo.log";
-
-    /** Name of the file to persist search internal namespace mappings */
-    private static final String NS_MAPPING_FILE = "ns_mappings.properties";
-
-     * Default merge size: 1000
+     * The actual index
-    private static final long DEFAULT_MERGE_SIZE = 1000;
-
-    /**
-     * The maximum number of entries in the redo log until the volatile index
-     * is merged into the persistent one.
-     */
-    private long mergeSize = DEFAULT_MERGE_SIZE;
-
-    /**
-     * The persistent index.
-     */
-    private PersistentIndex persistentIndex;
-
-    /**
-     * The in-memory index.
-     */
-    private VolatileIndex volatileIndex;
+    private MultiIndex index;
-     * Internal namespace mappings.
-     */
-    private NamespaceMappings nsMappings;
-
-    /**
-            // check if index is locked, probably from an unclean repository
-            // shutdown
-            if (getFileSystem().exists(WRITE_LOCK)) {
-                log.warn("Removing write lock on search index.");
-                try {
-                    getFileSystem().deleteFile(WRITE_LOCK);
-                } catch (FileSystemException e) {
-                    log.error("Unable to remove write lock on search index.");
-                }
-            }
-
-            boolean create = !getFileSystem().exists("segments");
-            persistentIndex = new PersistentIndex(getFileSystem(), create, analyzer);
-            persistentIndex.setUseCompoundFile(true);
-            FileSystemResource mapFile = new FileSystemResource(getFileSystem(), NS_MAPPING_FILE);
-            nsMappings = new NamespaceMappings(mapFile);
-            if (create) {
-                // index root node
-                NodeState rootState = (NodeState) getItemStateProvider().getItemState(new NodeId(getRootUUID()));
-                createIndex(rootState);
-            }
-
-            // init volatile index
-            RedoLog redoLog = new RedoLog(new FileSystemResource(getFileSystem(), REDO_LOG));
-            if (redoLog.hasEntries()) {
-                log.warn("Found uncommitted redo log. Applying changes now...");
-                ItemStateManager itemMgr = getItemStateProvider();
-                // apply changes to persistent index
-                Iterator it = redoLog.getEntries().iterator();
-                while (it.hasNext()) {
-                    RedoLog.Entry entry = (RedoLog.Entry) it.next();
-                    if (entry.type == RedoLog.Entry.NODE_ADDED) {
-                        try {
-                            NodeState state = (NodeState) itemMgr.getItemState(new NodeId(entry.uuid));
-                            addNodePersistent(state);
-                        } catch (NoSuchItemStateException e) {
-                            // item does not exist anymore
-                        }
-                    } else {
-                        deleteNodePersistent(entry.uuid);
-                    }
-                }
-                log.warn("Redo changes applied.");
-                redoLog.clear();
-            }
-            volatileIndex = new VolatileIndex(analyzer, redoLog);
-            volatileIndex.setUseCompoundFile(false);
-        } catch (ItemStateException e) {
-            throw new IOException("Error indexing root node: " + e.getMessage());
+            index = new MultiIndex(getFileSystem(),
+                    this, getItemStateProvider(), getRootUUID());
-        } catch (RepositoryException e) {
-            throw new IOException("Error indexing root node: " + e.getMessage());
-        Document doc = createDocument(node, nsMappings);
+        Document doc = createDocument(node, getNamespaceMappings());
-            volatileIndex.addDocument(doc);
-            if (volatileIndex.getRedoLog().getSize() > mergeSize) {
-                log.info("Merging in-memory index");
-                persistentIndex.mergeIndex(volatileIndex);
-                // reset redo log
-                try {
-                    volatileIndex.getRedoLog().clear();
-                } catch (FileSystemException e) {
-                    log.error("Internal error: Unable to clear redo log.", e);
-                }
-                // create new volatile index
-                volatileIndex = new VolatileIndex(analyzer, volatileIndex.getRedoLog());
-                volatileIndex.setUseCompoundFile(false);
-            }
+            index.addDocument(doc);
-            // if the document cannot be deleted from the volatile index
-            // delete it from the persistent index.
-            if (volatileIndex.removeDocument(idTerm) == 0) {
-                persistentIndex.removeDocument(idTerm);
-            }
+            index.removeDocument(idTerm);
-        try {
-            if (volatileIndex.getRedoLog().hasEntries()) {
-                persistentIndex.mergeIndex(volatileIndex);
-                volatileIndex.getRedoLog().clear();
-            }
-        } catch (IOException e) {
-            log.error("Exception while closing search index.", e);
-        } catch (FileSystemException e) {
-            log.error("Exception while closing search index.", e);
-        }
-        volatileIndex.close();
-        persistentIndex.close();
+        index.close();
-                        prop = orderProps[i].toJCRName(nsMappings);
+                        prop = orderProps[i].toJCRName(getNamespaceMappings());
-            MultiReader multiReader = new MultiReader(new IndexReader[]{ persistentIndex.getIndexReader(), volatileIndex.getIndexReader()});
-                hits = new IndexSearcher(multiReader).search(query, new Sort(sortFields));
+                hits = new IndexSearcher(index.getIndexReader()).search(query, new Sort(sortFields));
-                hits = new IndexSearcher(multiReader).search(query);
+                hits = new IndexSearcher(index.getIndexReader()).search(query);
-        return nsMappings;
-    }
-
-    //---------------------------< internal >-----------------------------------
-
-    /**
-     * Recursively creates an index starting with the NodeState <code>node</code>.
-     * @param node the current NodeState.
-     * @throws IOException if an error occurs while writing to the index.
-     * @throws ItemStateException if an node state cannot be found.
-     * @throws RepositoryException if any other error occurs
-     */
-    private void createIndex(NodeState node)
-            throws IOException, ItemStateException, RepositoryException {
-        addNodePersistent(node);
-        List children = node.getChildNodeEntries();
-        ItemStateManager isMgr = getItemStateProvider();
-        for (Iterator it = children.iterator(); it.hasNext();) {
-            NodeState.ChildNodeEntry child = (NodeState.ChildNodeEntry) it.next();
-            NodeState childState = (NodeState) isMgr.getItemState(new NodeId(child.getUUID()));
-            createIndex(childState);
-        }
-    }
-
-    /**
-     * Adds a node to the persistent index. This method will <b>not</b> aquire a
-     * write lock while writing!
-     * @param node the node to add.
-     * @throws IOException if an error occurs while writing to the index.
-     * @throws RepositoryException if any other error occurs
-     */
-    private void addNodePersistent(NodeState node)
-            throws IOException, RepositoryException {
-        Document doc = createDocument(node, nsMappings);
-        persistentIndex.addDocument(doc);
-    }
-
-    /**
-     * Removes a node from the persistent index. This method will <b>not</b>
-     * aquire a write lock while writing!
-     * @param uuid the uuid of the node to remove.
-     * @throws IOException if an error occurs while writing to the index.
-     */
-    private void deleteNodePersistent(String uuid) throws IOException {
-        Term idTerm = new Term(FieldNames.UUID, uuid);
-        persistentIndex.removeDocument(idTerm);
+        return index.getNamespaceMappings();
-        persistentIndex.setUseCompoundFile(b);
+        index.setUseCompoundFile(b);
-        persistentIndex.setMinMergeDocs(minMergeDocs);
+        index.setMinMergeDocs(minMergeDocs);
-        persistentIndex.setMaxMergeDocs(maxMergeDocs);
+        index.setMaxMergeDocs(maxMergeDocs);
-        persistentIndex.setMergeFactor(mergeFactor);
+        index.setMergeFactor(mergeFactor);
+    /**
+     * @deprecated redo size is equivalent to minMergeDocs. Use
+     * {@link #setMinMergeDocs(int)} to set the size of the redo log.
+     */
-        mergeSize = size;
-        volatileIndex.setBufferSize(size);
+        index.setBufferSize(size);

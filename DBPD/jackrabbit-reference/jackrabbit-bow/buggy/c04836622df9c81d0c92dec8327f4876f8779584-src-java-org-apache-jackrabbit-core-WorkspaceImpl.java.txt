- fixed restore bugs
- implemented Workspace.restore() [not tested yet]

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@157553 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.version.VersionSelector;
+import org.apache.jackrabbit.core.version.VersionImpl;
+import org.apache.jackrabbit.core.version.GenericVersionSelector;
+import org.apache.jackrabbit.core.version.InternalVersion;
+import javax.jcr.version.VersionHistory;
+import java.util.HashMap;
+        // todo: perform restore operations direct on the node states
+
-        // @todo implement Workspace#restore
-        throw new UnsupportedRepositoryOperationException();
+        // add all versions to map of versions to restore
+        final HashMap toRestore = new HashMap();
+        for (int i=0; i<versions.length; i++) {
+            VersionImpl v = (VersionImpl) versions[i];
+            VersionHistory vh = v.getContainingVersionHistory();
+            // check for collision
+            if (toRestore.containsKey(vh.getUUID())) {
+                throw new VersionException("Unable to restore. Two ore more versions have same version history.");
+            }
+            toRestore.put(vh.getUUID(), v);
+        }
+
+        // create a version selector to the set of versions
+        VersionSelector vsel = new VersionSelector() {
+            public Version select(VersionHistory versionHistory) throws RepositoryException {
+                // try to select version as specified
+                Version v = (Version) toRestore.get(versionHistory.getUUID());
+                if (v == null) {
+                    // select latest one
+                    v = GenericVersionSelector.selectByDate(versionHistory, null);
+                }
+                return v;
+            }
+        };
+
+        // check for pending changes
+        if (session.hasPendingChanges()) {
+            String msg = "Unable to restore version. Session has pending changes.";
+            log.debug(msg);
+            throw new InvalidItemStateException(msg);
+        }
+
+        try {
+            // now restore all versions that have a node in the ws
+            int numRestored = 0;
+            while (toRestore.size()>0) {
+                InternalVersion[] restored = null;
+                Iterator iter = toRestore.values().iterator();
+                while (iter.hasNext()) {
+                    VersionImpl v = (VersionImpl) iter.next();
+                    try {
+                        NodeImpl node = (NodeImpl) session.getNodeByUUID(v.getFrozenNode().getFrozenUUID());
+                        restored = node.internalRestore(v.getInternalVersion(), vsel, removeExisting);
+                        // remove restored versions from set
+                        for (int i=0; i<restored.length; i++) {
+                            toRestore.remove(restored[i].getVersionHistory().getId());
+                        }
+                        numRestored += restored.length;
+                        break;
+                    } catch (ItemNotFoundException e) {
+                        // ignore
+                    }
+                }
+                if (restored == null) {
+                    if (numRestored == 0) {
+                        throw new VersionException("Unable to restore. At least one version needs existing versionable node in workspace.");
+                    } else {
+                        throw new VersionException("Unable to restore. All versions with non existing versionable nodes need parent.");
+                    }
+                }
+            }
+        } catch (RepositoryException e) {
+            // revert session
+            try {
+                log.error("reverting changes applied during restore...");
+                session.refresh(false);
+            } catch (RepositoryException e1) {
+                // ignore this
+            }
+            throw e;
+        }
+        session.save();

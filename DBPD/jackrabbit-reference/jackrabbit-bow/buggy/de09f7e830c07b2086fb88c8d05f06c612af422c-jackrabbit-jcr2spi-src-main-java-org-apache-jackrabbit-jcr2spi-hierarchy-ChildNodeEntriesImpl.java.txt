JCR-1576  Remove RepositoryService exists()  
JCR-1577  Remove RepositoryService.getRootId()  
JCR-1405  SPI: Introduce NodeInfo.getChildInfos()  

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@654826 13f79535-47bb-0310-9956-ffa450edef68

-     * Create a new <code>ChildNodeEntries</code> collection
+     * Create a new <code>ChildNodeEntries</code> collection and retrieve
+     * the entries from the persistent layer if the parent is neither
+     * NEW nor in a terminal status.
-        if (parent.getStatus() == Status.NEW || Status.isTerminal(parent.getStatus())) {
-            return; // cannot retrieve child-entries from persistent layer
-        }
+        if (parent.getStatus() != Status.NEW && !Status.isTerminal(parent.getStatus())) {
+            NodeId id = parent.getWorkspaceId();
+            Iterator childNodeInfos = factory.getItemStateFactory().getChildNodeInfos(id);
+            // simply add all child entries to the empty collection
+            while (childNodeInfos.hasNext()) {
+                ChildInfo ci = (ChildInfo) childNodeInfos.next();
+                NodeEntry entry = factory.createNodeEntry(parent, ci.getName(), ci.getUniqueID());
+                add(entry, ci.getIndex());
+            }
+        } /* else: cannot retrieve child-entries from persistent layer. the parent
+           * is NEW (transient only) or already removed from the persistent layer.
+           */
+    }
-        NodeId id = parent.getWorkspaceId();
-        Iterator it = factory.getItemStateFactory().getChildNodeInfos(id);
-        // simply add all child entries to the empty collection
-        while (it.hasNext()) {
-            ChildInfo ci = (ChildInfo) it.next();
+    /**
+     * Create a new <code>ChildNodeEntries</code> collection from the given
+     * <code>childNodeInfos</code> instead of retrieving them from the
+     * persistent layer.
+     *
+     * @param parent
+     * @param factory
+     * @param childNodeInfos
+     */
+    ChildNodeEntriesImpl(NodeEntry parent, EntryFactory factory, Iterator childNodeInfos) {
+        entriesByName = new NameMap();
+        entries = new LinkedEntries();
+
+        this.parent = parent;
+        this.factory = factory;
+
+        while (childNodeInfos.hasNext()) {
+            ChildInfo ci = (ChildInfo) childNodeInfos.next();
-        Iterator it = factory.getItemStateFactory().getChildNodeInfos(id);
+        Iterator childNodeInfos = factory.getItemStateFactory().getChildNodeInfos(id);
+        reload(childNodeInfos);
+    }
+
+    void reload(Iterator childNodeInfos) {
+        // TODO: should existing (not-new) entries that are not present in the childInfos be removed?
-        while (it.hasNext()) {
-            cInfos.add(it.next());
+        while (childNodeInfos.hasNext()) {
+            cInfos.add(childNodeInfos.next());
-        for (it = cInfos.iterator(); it.hasNext();) {
+        for (Iterator it = cInfos.iterator(); it.hasNext();) {
-        for (it = cInfos.iterator(); it.hasNext();) {
+        for (Iterator it = cInfos.iterator(); it.hasNext();) {
-     * @param insertNode the NodeEntry to move.
-     * @param beforeNode the NodeEntry where <code>insertNode</code> is
+     * @param insertEntry the NodeEntry to move.
+     * @param beforeEntry the NodeEntry where <code>insertNode</code> is
-     * @param insertObj
+     * @param insertName
-    private void reorder(Name insertName, LinkedEntries.LinkNode insertLN, LinkedEntries.LinkNode beforeLN) {
+    private void reorder(Name insertName, LinkedEntries.LinkNode insertLN,
+                         LinkedEntries.LinkNode beforeLN) {
-         * @param checkValidity

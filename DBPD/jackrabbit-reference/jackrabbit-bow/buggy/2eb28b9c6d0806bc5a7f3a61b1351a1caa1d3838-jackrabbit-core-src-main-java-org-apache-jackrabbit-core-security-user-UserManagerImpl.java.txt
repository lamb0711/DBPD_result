JCR-2199: Improvements to user management

- change content structure to allow for fast lookup by ID
- groupID: unescaped before being exposed in the API.
- adjust defautl ac-provider on the security workspace according to the new structure
- same for impl tests
- extend security config. user mgr impl defines a couple of config options

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@794702 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.collections.map.LRUMap;
-import java.util.Map;
+import java.util.Properties;
- * UserManagerImpl
+ * Default implementation of the <code>UserManager</code> interface with the
+ * following characteristics:
+ *
+ * <ul>
+ * <li>Users and Groups are stored in the repository as JCR nodes.</li>
+ * <li>Users are created below {@link UserConstants#USERS_PATH},<br>Groups are
+ * created below {@link UserConstants#GROUPS_PATH}.</li>
+ * <li>In order to structure the users and groups tree and void creating a flat
+ * hierarchy, additional hierarchy nodes of type "rep:AuthorizableFolder" are
+ * introduced.</li>
+ * <li>The names of the hierarchy folders is determined from ID of the
+ * authorizable to be created, consisting of the leading N chars where N is
+ * the relative depth starting from the node at {@link UserConstants#USERS_PATH}
+ * or {@link UserConstants#GROUPS_PATH}.</li>
+ * <li>By default 2 levels (depth == 2) are created.</li>
+ * <li>Searching authorizables by ID always starts looking at that specific
+ * hierarchy level. Parent nodes are expected to consist of folder structure only.</li>
+ * <li>If the ID contains invalid JCR chars that would prevent the creation of
+ * a Node with that name, the names of authorizable node and the intermediate
+ * hierarchy nodes are {@link Text#escapeIllegalJcrChars(String) escaped}.</li>
+ * <li>Any intermediate path passed to either
+ * {@link #createUser(String, String, Principal, String) createUser} or
+ * {@link #createGroup(Principal, String) createGroup} are ignored. This allows
+ * to directly find authorizables by ID without having to search or traverse
+ * the complete tree.<br>
+ * See also {@link #PARAM_COMPATIBILE_JR16}.
+ * </li>
+ * </ul>
+ * Example: Creating an non-existing authorizable with ID 'aSmith' would result
+ * in the following structure:
+ * 
+ * <pre>
+ * + rep:security            [nt:unstructured]
+ *   + rep:authorizables     [rep:AuthorizableFolder]
+ *     + rep:users           [rep:AuthorizableFolder]
+ *       + a                 [rep:AuthorizableFolder]
+ *         + aS              [rep:AuthorizableFolder]
+ *           + aSmith        [rep:User]
+ * </pre>
+ *
+ * This <code>UserManager</code> is able to handle the following configuration
+ * options:
+ *
+ * <ul>
+ * <li>{@link #PARAM_COMPATIBILE_JR16}: If the param is present and its
+ * value is <code>true</code> looking up authorizables by ID will use the
+ * <code>NodeResolver</code> if not found otherwise.<br>
+ * If the parameter is missing (or false) users and groups created
+ * with a Jackrabbit repository &lt; v2.0 will not be found any more.<br>
+ * By default this option is disabled.</li>
+ * <li>{@link #PARAM_DEFAULT_DEPTH}: Parameter used to change the number of
+ * levels that are used by default store authorizable nodes.<br>The default
+ * number of levels is 2.
+ * <p/>
+ * <strong>NOTE:</strong> Changing the default depth once users and groups
+ * have been created in the repository will cause inconsistencies, due to
+ * the fact that the resolution of ID to an authorizable relies on the
+ * structure defined by the default depth.<br>
+ * It is recommended to remove all authorizable nodes that will not be
+ * reachable any more, before this config option is changed.
+ * <ul>
+ * <li>If default depth is increased:<br>
+ * All authorizables on levels &lt; default depth are not reachable any more.</li>
+ * <li>If default depth is decreased:<br>
+ * All authorizables on levels &gt; default depth aren't reachable any more
+ * unless the {@link #PARAM_AUTO_EXPAND_TREE} flag is set to <code>true</code>.</li>
+ * </ul>
+ * </li>
+ * <li>{@link #PARAM_AUTO_EXPAND_TREE}: If this parameter is present and its
+ * value is <code>true</code>, the trees containing user and group nodes will
+ * automatically created additional hierarchy levels if the number of nodes
+ * on a given level exceeds the maximal allowed {@link #PARAM_AUTO_EXPAND_SIZE size}.
+ * <br>By default this option is disabled.</li>
+ * <li>{@link #PARAM_AUTO_EXPAND_SIZE}: This parameter only takes effect
+ * if {@link #PARAM_AUTO_EXPAND_TREE} is enabled.<br>The default value is
+ * 1000.</li>
+ * </ul>
-public class UserManagerImpl extends ProtectedItemModifier implements UserManager, UserConstants, SessionListener {
+public class UserManagerImpl extends ProtectedItemModifier
+        implements UserManager, UserConstants, SessionListener {
+
+    /**
+     * Flag to enable a minimal backwards compatibility with Jackrabbit &lt;
+     * v2.0<br>
+     * If the param is present and its value is <code>true</code> looking up
+     * authorizables by ID will use the <code>NodeResolver</code> if not found
+     * otherwise.<br>
+     * If the parameter is missing (or false) users and groups created
+     * with a Jackrabbit repository &lt; v2.0 will not be found any more.<br>
+     * By default this option is disabled.
+     */
+    public static final String PARAM_COMPATIBILE_JR16 = "compatibleJR16";
+
+    /**
+     * Parameter used to change the number of levels that are used by default
+     * store authorizable nodes.<br>The default number of levels is 2.
+     * <p/>
+     * <strong>NOTE:</strong> Changing the default depth once users and groups
+     * have been created in the repository will cause inconsistencies, due to
+     * the fact that the resolution of ID to an authorizable relies on the
+     * structure defined by the default depth.<br>
+     * It is recommended to remove all authorizable nodes that will not be
+     * reachable any more, before this config option is changed.
+     * <ul>
+     * <li>If default depth is increased:<br>
+     * All authorizables on levels &lt; default depth are not reachable any more.</li>
+     * <li>If default depth is decreased:<br>
+     * All authorizables on levels &gt; default depth aren't reachable any more
+     * unless the {@link #PARAM_AUTO_EXPAND_TREE} flag is set to <code>true</code>.</li>
+     * </ul>
+     */
+    public static final String PARAM_DEFAULT_DEPTH = "defaultDepth";
+
+    /**
+     * If this parameter is present and its value is <code>true</code>, the trees
+     * containing user and group nodes will automatically created additional
+     * hierarchy levels if the number of nodes on a given level exceeds the
+     * maximal allowed {@link #PARAM_AUTO_EXPAND_SIZE size}.
+     * <br>By default this option is disabled.
+     */
+    public static final String PARAM_AUTO_EXPAND_TREE = "autoExpandTree";
+
+    /**
+     * This parameter only takes effect if {@link #PARAM_AUTO_EXPAND_TREE} is
+     * enabled.<br>The default value is 1000.
+     */
+    public static final String PARAM_AUTO_EXPAND_SIZE = "autoExpandSize";
+    private final IdResolver idResolver;
-     * Simple unmanaged map from authorizableID to nodePath (node representing
-     * the authorizable) used limit the number of calls to the
-     * <code>NodeResolver</code> in order to find authorizable nodes by the
-     * authorizable id.
+     * Flag indicating if {@link #getAuthorizable(String)} should find users or
+     * groups created with Jackrabbit < 2.0.<br>
+     * As of 2.0 authorizables are created using a defined logic that allows
+     * to retrieve them without searching/traversing. If this flag is
+     * <code>true</code> this method will try to find authorizables using the
+     * <code>authResolver</code> if not found otherwise.
-    private final Map idPathMap = new LRUMap(1000);
+    private final boolean compatibleJR16;
+    /**
+     * Create a new <code>UserManager</code> with the default configuration.
+     *
+     * @param session
+     * @param adminId
+     * @throws RepositoryException
+     */
-        super();
+        this(session, adminId, null);
+    }
+
+    /**
+     * Create a new <code>UserManager</code> for the given <code>session</code>.
+     * Currently the following configuration options are respected:
+     *
+     * <ul>
+     * <li>{@link #PARAM_COMPATIBILE_JR16}. By default this option is disabled.</li>
+     * <li>{@link #PARAM_DEFAULT_DEPTH}. The default number of levels is 2.</li>
+     * <li>{@link #PARAM_AUTO_EXPAND_TREE}. By default this option is disabled.</li>
+     * <li>{@link #PARAM_AUTO_EXPAND_SIZE}. The default value is 1000.</li>
+     * </ul>
+     *
+     * See the overall {@link UserManagerImpl introduction} for details.
+     *
+     * @param session
+     * @param adminId
+     * @param config
+     * @throws RepositoryException
+     */
+    public UserManagerImpl(SessionImpl session, String adminId, Properties config) throws RepositoryException {
-            log.debug("UserManger: no QueryManager available for workspace '" + session.getWorkspace().getName() + "' -> Use traversing node resolver.");
+            log.debug("UserManager: no QueryManager available for workspace '" + session.getWorkspace().getName() + "' -> Use traversing node resolver.");
+
+        idResolver = new IdResolver(config);
+        boolean compatMode = false;
+        if (config != null && config.containsKey(PARAM_COMPATIBILE_JR16)) {
+            compatMode = Boolean.parseBoolean(config.get(PARAM_COMPATIBILE_JR16).toString());
+        }
+        compatibleJR16 = compatMode;
-     * @inheritDoc
-     * @param intermediatePath
+     * @param intermediatePath Is always ignored.
+        if (intermediatePath != null) {
+            log.debug("Intermediate path param " + intermediatePath + " is ignored.");
+        }
-            String parentPath = getParentPath(intermediatePath, getCurrentUserPath());
-            parent = createParentNode(parentPath);
-
-            Name nodeName = session.getQName(Text.escapeIllegalJcrChars(userID));
-            NodeImpl userNode = addNode(parent, nodeName, NT_REP_USER);
+            NodeImpl userNode = (NodeImpl) idResolver.createUserNode(userID);
-            parent.save();
+            session.save();
-            if (parent != null) {
-                parent.refresh(false);
-                log.debug("Failed to create new User, reverting changes.");
-            }
+            session.refresh(false);
+            log.debug("Failed to create new User, reverting changes.");
-     * @param intermediatePath
+     * @param intermediatePath Is always ignored.
-
+        if (intermediatePath != null) {
+            log.debug("Intermediate path param " + intermediatePath + " is ignored.");
+        }
+        
-            String parentPath = getParentPath(intermediatePath, GROUPS_PATH);
-            parent = createParentNode(parentPath);
-            Name groupID = getGroupId(principal.getName());
+            String groupID = getGroupId(principal.getName());
+            NodeImpl groupNode = (NodeImpl) idResolver.createGroupNode(groupID);
-            NodeImpl groupNode = addNode(parent, groupID, NT_REP_GROUP);
-            parent.save();
+            session.save();
-            if (parent != null) {
-                parent.refresh(false);
-                log.debug("newInstance new Group failed, revert changes on parent");
-            }
+            session.refresh(false);
+            log.debug("newInstance new Group failed, revert changes on parent");
-     * Escape illegal JCR characters and test if a user exists that has the
-     * principals name as userId, which might happen if userID != principal-name.
+     * Test if a user or group exists that has the given principals name as ID,
+     * which might happen if userID != principal-name.
-    private Name getGroupId(String principalName) throws RepositoryException {
-        String escHint = Text.escapeIllegalJcrChars(principalName);
+    private String getGroupId(String principalName) throws RepositoryException {
+        String escHint = principalName;
-        return session.getQName(groupID);
+        return groupID;
+     * @param userID
-        return (adminId == null) ? false : adminId.equals(userID);
+        return (adminId != null) && adminId.equals(userID);
-        idPathMap.put(user.getID(), userNode.getPath());
-        idPathMap.put(group.getID(), groupNode.getPath());
-     * @param userID
+     * Resolve the given <code>userID</code> to an rep:user node in the repository.
+     *
+     * @param userID A valid userID.
+     * @throws RepositoryException If an error occurs.
-        NodeImpl n = null;
-        if (idPathMap.containsKey(userID)) {
-            String path = idPathMap.get(userID).toString();
-            if (session.itemExists(path)) {
-                Item itm = session.getItem(path);
-                // make sure the item really represents the node associated with
-                // the given userID. if not the search below is execute.
-                if (itm.isNode()) {
-                    NodeImpl tmp = (NodeImpl) itm;
-                    if (tmp.isNodeType(NT_REP_USER) && userID.equals(((NodeImpl) itm).getProperty(P_USERID).getString())) {
-                        n = (NodeImpl) itm;
-                    }
-                }
-            }
-        }
-
-        if (n == null) {
-            // clear eventual previous entry
-            idPathMap.remove(userID);
+        NodeImpl n = (NodeImpl) idResolver.findNode(userID, false);
+        if (n == null && compatibleJR16) {
+            // backwards-compatibiltiy with JR < 2.0 user structure that doesn't
+            // allow to determine the auth-path from the id directly.
-        }
-        return n;
-    }
-
-    private NodeImpl getGroupNode(String groupID) throws RepositoryException {
-        NodeImpl n = null;
-        if (idPathMap.containsKey(groupID)) {
-            String path = idPathMap.get(groupID).toString();
-            if (session.itemExists(path)) {
-                Item itm = session.getItem(path);
-                // make sure the item really represents the node associated with
-                // the given userID. if not the search below is execute.
-                if (itm.isNode()) {
-                    NodeImpl tmp = (NodeImpl) itm;
-                    if (tmp.isNodeType(NT_REP_GROUP) && groupID.equals(tmp.getName())) {
-                        n = (NodeImpl) itm;
-                    }
-                }
-            }
-        }
-        if (n == null) {
-            // clear eventual previous entry
-            idPathMap.remove(groupID);
-            // search for it the node belonging to that groupID
-            Name nodeName = session.getQName(groupID);
-            n = (NodeImpl) authResolver.findNode(nodeName, NT_REP_GROUP);
-        }
+        } // else: no such user -> return null.
-     * @return the path refering to the node associated with the user this
-     * <code>UserManager</code> has been built for.
+     * Resolve the given <code>groupID</code> to an rep:group node in the repository.
+     *
+     * @param groupID A valid groupID.
+     * @return the node associated with the given userID or <code>null</code>.
+     * @throws RepositoryException If an error occurs.
-    private String getCurrentUserPath() {
-        // fallback: default user-path
-        String currentUserPath = USERS_PATH;
-        String userId = session.getUserID();
-
-        if (idPathMap.containsKey(userId)) {
-            currentUserPath = idPathMap.get(userId).toString();
-        } else {
-            try {
-                Node n = getUserNode(userId);
-                if (n != null) {
-                    currentUserPath = n.getPath();
-                }
-            } catch (RepositoryException e) {
-                // should never get here
-                log.error("Internal error: unable to build current user path.", e.getMessage());
-            }
-        }
-        return currentUserPath;
+    private NodeImpl getGroupNode(String groupID) throws RepositoryException {
+        NodeImpl n = (NodeImpl) idResolver.findNode(groupID, true);
+        if (n == null && compatibleJR16) {
+            // backwards-compatibiltiy with JR < 2.0 group structure that doesn't
+            // allow to determine the auth-path from the id directly
+            // search for it the node belonging to that groupID.
+            // NOTE: JR < 2.0 always returned groupIDs that didn't contain any
+            // illegal JCR chars. Since Group.getID() now unescapes the node
+            // name additional escaping is required.
+            Name nodeName = session.getQName(Text.escapeIllegalJcrChars(groupID));
+            n = (NodeImpl) authResolver.findNode(nodeName, NT_REP_GROUP);
+        } // else: no such group -> return null.
+        return n;
-    private static String getParentPath(String hint, String root) {
-        StringBuffer b = new StringBuffer();
-        if (hint == null || !hint.startsWith(root)) {
-            b.append(root);
-        }
-        if (hint != null && hint.length() > 1) {
-            if (!hint.startsWith("/")) {
-                b.append("/");
-            }
-            b.append(hint);
-        }
-        return b.toString();
-    }
-
-    /**
-     * @param path to the authorizable node to be created
-     * @return
-     * @throws RepositoryException
-     */
-    private NodeImpl createParentNode(String path) throws RepositoryException {
-        NodeImpl parent = (NodeImpl) session.getRootNode();
-        String[] elem = path.split("/");
-        for (int i = 0; i < elem.length; i++) {
-            String name = elem[i];
-            if (name.length() < 1) {
-                continue;
-            }
-            Name nName = session.getQName(name);
-            if (!parent.hasNode(nName)) {
-                Name ntName;
-                if (i == 0) {
-                    // rep:security node
-                    ntName = NameConstants.NT_UNSTRUCTURED;
-                } else {
-                    ntName = NT_REP_AUTHORIZABLE_FOLDER;
-                }
-                NodeImpl added = addNode(parent, nName, ntName);
-                parent.save();
-                parent = added;
-            } else {
-                parent = parent.getNode(nName);
-            }
-        }
-        return parent;
-    }
-
-        // clear the map
-        idPathMap.clear();
+
+    //--------------------------------------------------------------------------
+    /**
+     * Inner class creating and finding the JCR nodes corresponding the a given
+     * authorizable ID with the following behavior:
+     * <ul>
+     * <li>Users are created below /rep:security/rep:authorizables/rep:users</li>
+     * <li>Groups are created below /rep:security/rep:authorizables/rep:users</li>
+     * <li>Below each category authorizables are created within a human readable
+     * structure, whose depth is defined by the <code>defaultDepth</code> config
+     * option.<br>
+     * E.g. creating a user node for an ID 'aSmith' would result in the following
+     * structure assuming defaultDepth == 2 is used:
+     * <pre>
+     * + rep:security            [nt:unstructured]
+     *   + rep:authorizables     [rep:AuthorizableFolder]
+     *     + rep:users           [rep:AuthorizableFolder]
+     *       + a                 [rep:AuthorizableFolder]
+     *         + aS              [rep:AuthorizableFolder]
+     * ->        + aSmith        [rep:User]
+     * </pre>
+     * </li>
+     * <li>In case of a user the node name is calculated from the specified UserID
+     * {@link Text#escapeIllegalJcrChars(String) escaping} any illegal JCR chars.
+     * In case of a Group the node name is calculated from the specified principal
+     * name circumventing any conflicts with existing ids and escaping illegal chars.</li>
+     * <li>The names of the intermediate folders are caculated from the leading
+     * chars of the escaped node name.</li>
+     * <li>If the escaped node name is shorter than the <code>defaultDepth</code>
+     * the last char is repeated.<br>
+     * E.g. creating a user node for an ID 'a' would result in the following
+     * structure assuming defaultDepth == 2 is used:
+     * <pre>
+     * + rep:security            [nt:unstructured]
+     *   + rep:authorizables     [rep:AuthorizableFolder]
+     *     + rep:users           [rep:AuthorizableFolder]
+     *       + a                 [rep:AuthorizableFolder]
+     *         + aa              [rep:AuthorizableFolder]
+     * ->        + a             [rep:User]
+     * </pre>
+     * </li>
+     * <li>If the <code>autoExpandTree</code> option is <code>true</code> the
+     * user tree will be automatically expanded using additional levels if
+     * <code>autoExpandSize</code> is exceeded within a given level.</li>
+     * </ul>
+     *
+     * The auto-expansion of the authorizable tree is defined by the following
+     * steps and exceptional cases:
+     * <ul>
+     * <li>As long as <code>autoExpandSize</code> isn't reached authorizable
+     * nodes are created within the structure defined by the
+     * <code>defaultDepth</code>. (see above)</li>
+     * <li>If <code>autoExpandSize</code> is reached additional intermediate
+     * folders will be created.<br>
+     * E.g. creating a user node for an ID 'aSmith1001' would result in the
+     * following structure:
+     * <pre>
+     * + rep:security            [nt:unstructured]
+     *   + rep:authorizables     [rep:AuthorizableFolder]
+     *     + rep:users           [rep:AuthorizableFolder]
+     *       + a                 [rep:AuthorizableFolder]
+     *         + aS              [rep:AuthorizableFolder]
+     *           + aSmith1       [rep:User]
+     *           + aSmith2       [rep:User]
+     *           [...]
+     *           + aSmith1000    [rep:User]
+     * ->        + aSm           [rep:AuthorizableFolder]
+     * ->          + aSmith1001  [rep:User]
+     * </pre>
+     * </li>
+     * <li>Conflicts: In order to prevent any conflicts that would arise from
+     * creating a authorizable node that upon later expansion could conflict
+     * with an authorizable folder, intermediate levels are always created if
+     * the node name equals any of the names reserved for the next level of
+     * folders.<br>
+     * In the example above any attempt to create a user with ID 'aSm' would
+     * result in an intermediate level irrespective if max-size has been
+     * reached or not:
+     * <pre>
+     * + rep:security            [nt:unstructured]
+     *   + rep:authorizables     [rep:AuthorizableFolder]
+     *     + rep:users           [rep:AuthorizableFolder]
+     *       + a                 [rep:AuthorizableFolder]
+     *         + aS              [rep:AuthorizableFolder]
+     * ->        + aSm           [rep:AuthorizableFolder]
+     * ->          + aSm         [rep:User]
+     * </pre>
+     * </li>
+     * <li>Special case: If the name of the authorizable node to be created is
+     * shorter or equal to the length of the folder at level N, the authorizable
+     * node is created even if max-size has been reached before.<br>
+     * An attempt to create the users 'aS' and 'aSm' in a structure containing
+     * tons of 'aSmith' users will therefore result in:
+     * <pre>
+     * + rep:security            [nt:unstructured]
+     *   + rep:authorizables     [rep:AuthorizableFolder]
+     *     + rep:users           [rep:AuthorizableFolder]
+     *       + a                 [rep:AuthorizableFolder]
+     *         + aS              [rep:AuthorizableFolder]
+     *           + aSmith1       [rep:User]
+     *           + aSmith2       [rep:User]
+     *           [...]
+     *           + aSmith1000    [rep:User]
+     * ->        + aS            [rep:User]
+     *           + aSm           [rep:AuthorizableFolder]
+     *             + aSmith1001  [rep:User]
+     * ->          + aSm         [rep:User]
+     * </pre>
+     * </li>
+     * </ul>
+     *
+     * The configuration options:
+     * <ul>
+     * <li><strong>defaultDepth</strong>:<br>
+     * <code>integer</code> defining the depth of the default structure that is
+     * always created.<br>
+     * Default value: 2</li>
+     * <li><strong>autoExpandTree</strong>:<br>
+     * <code>boolean</code> defining if the tree gets automatically expanded
+     * if within a level the maximum number of child nodes is reached.<br>
+     * Default value: <code>false</code></li>
+     * <li><strong>autoExpandSize</strong>:<br>
+     * <code>long</code> defining the maximum number of child nodes that are
+     * allowed at a given level.<br>
+     * Default value: 1000<br>
+     * NOTE: that total number of child nodes may still be greater that
+     * autoExpandSize.</li>
+     * </ul>
+     */
+    private class IdResolver {
+
+        private static final String DELIMITER = "/";
+        private static final int DEFAULT_DEPTH = 2;
+        private static final long DEFAULT_SIZE = 1000;
+        
+        private final int defaultDepth;
+        private final boolean autoExpandTree;
+        // best effort max-size of authorizables per folder. there may be
+        // more nodes created if the editing session isn't allowed to see
+        // all child nodes.
+        private final long autoExpandSize;
+
+        private IdResolver(Properties config) {
+            int d = DEFAULT_DEPTH;
+            boolean expand = false;
+            long size = DEFAULT_SIZE;
+
+            if (config != null) {
+                if (config.containsKey(PARAM_DEFAULT_DEPTH)) {
+                    try {
+                        d = Integer.parseInt(config.get(PARAM_DEFAULT_DEPTH).toString());
+                    } catch (NumberFormatException e) {
+                        log.warn("Unable to parse defaultDepth config option", e);
+                    }
+                }
+                if (config.containsKey(PARAM_AUTO_EXPAND_TREE)) {
+                    expand = Boolean.parseBoolean(config.get(PARAM_AUTO_EXPAND_TREE).toString());
+                }
+                if (config.containsKey(PARAM_AUTO_EXPAND_SIZE)) {
+                    try {
+                        size = Integer.parseInt(config.get(PARAM_AUTO_EXPAND_SIZE).toString());
+                    } catch (NumberFormatException e) {
+                        log.warn("Unable to parse autoExpandSize config option", e);
+                    }
+                }
+            }
+
+            defaultDepth = d;
+            autoExpandTree = expand;
+            autoExpandSize = size;
+        }
+
+        public Node createUserNode(String userID) throws RepositoryException {
+            return createAuthorizableNode(userID, false);
+        }
+
+        public Node createGroupNode(String groupID) throws RepositoryException {
+            return createAuthorizableNode(groupID, true);
+        }
+
+        public Node findNode(String id, boolean isGroup) throws RepositoryException {
+            String defaultFolderPath = getDefaultFolderPath(id, isGroup);
+            String escapedId = Text.escapeIllegalJcrChars(id);
+
+            if (session.nodeExists(defaultFolderPath)) {
+                Node folder = session.getNode(defaultFolderPath);
+                Name expectedNt = (isGroup) ? NT_REP_GROUP : NT_REP_USER;
+
+                // traverse the potentially existing hierarchy looking for the
+                // authorizable node.
+                int segmLength = defaultDepth +1;
+                while (folder != null) {
+                    if (folder.hasNode(escapedId)) {
+                        NodeImpl aNode = (NodeImpl) folder.getNode(escapedId);
+                        if (aNode.isNodeType(expectedNt)) {
+                            // done. found the right auth-node
+                            return aNode;
+                        } else {
+                            folder = aNode;
+                        }
+                    } else {
+                        // no child node with name 'escapedId' -> look for
+                        // additional levels that may exist.
+                        Node parent = folder;
+                        folder = null;
+                        if (id.length() >= segmLength) {
+                            String folderName = Text.escapeIllegalJcrChars(id.substring(0, segmLength));
+                            if (parent.hasNode(folderName)) {
+                                NodeImpl f = (NodeImpl) parent.getNode(folderName);
+                                if (f.isNodeType(NT_REP_AUTHORIZABLE_FOLDER)) {
+                                    folder = f;
+                                } // else: matching node isn't an authorizable-folder
+                            } // else: failed to find a suitable next level
+                        } // else: id is shorter than required length at the current level.
+                    }
+                    segmLength++;
+                }
+            } // else: no node at default-path
+
+            // no matching node found -> authorizable doesn't exist.
+            return null;
+        }
+
+        private Node createAuthorizableNode(String id, boolean isGroup) throws RepositoryException {
+            String escapedId = Text.escapeIllegalJcrChars(id);
+
+            // first create the default folder nodes, that are always present.
+            Node folder = createDefaultFolderNodes(id, escapedId, isGroup);
+            // eventually create additional intermediate folders.
+            folder = createIntermediateFolderNodes(id, escapedId, folder);
+
+            // finally create the authorizable node
+            Name nodeName = session.getQName(escapedId);
+            Name ntName = (isGroup) ? NT_REP_GROUP : NT_REP_USER;
+            Node authNode = addNode((NodeImpl) folder, nodeName, ntName);
+
+            return authNode;
+        }
+
+        private Node createDefaultFolderNodes(String id, String escapedId, boolean isGroup) throws RepositoryException {
+            NodeImpl folder;
+            // first create the levels that are always present -> see #getDefaultFolderPath
+            String defaultPath = getDefaultFolderPath(id, isGroup);
+            if (session.nodeExists(defaultPath)) {
+                folder = (NodeImpl) session.getNode(defaultPath);
+            } else {
+                String[] segmts = defaultPath.split("/");
+                folder = (NodeImpl) session.getRootNode();
+                String repSecurity = SECURITY_ROOT_PATH.substring(1);
+
+                for (String segment : segmts) {
+                    if (segment.length() < 1) {
+                        continue;
+                    }
+                    if (folder.hasNode(segment)) {
+                        folder = (NodeImpl) folder.getNode(segment);
+                    } else {
+                        Name ntName;
+                        if (repSecurity.equals(segment)) {
+                            // rep:security node
+                            ntName = NameConstants.NT_UNSTRUCTURED;
+                        } else {
+                            ntName = NT_REP_AUTHORIZABLE_FOLDER;
+                        }
+                        NodeImpl added = addNode(folder, session.getQName(segment), ntName);
+                        folder.save();
+                        folder = added;
+                    }
+                }
+            }
+
+            // validation check if authorizable to be create doesn't conflict.
+            checkExists(escapedId, folder);
+            return folder;
+        }
+
+        private String getDefaultFolderPath(String id, boolean isGroup) {
+            StringBuilder bld = new StringBuilder();
+            if (isGroup) {
+                bld.append(GROUPS_PATH);
+            } else {
+                bld.append(USERS_PATH);
+            }
+            StringBuilder lastSegment = new StringBuilder(defaultDepth);
+            int idLength = id.length();
+            for (int i = 0; i < defaultDepth; i++) {
+                if (idLength > i) {
+                    lastSegment.append(id.charAt(i));
+                } else {
+                    // escapedID is too short -> append the last char again
+                    lastSegment.append(id.charAt(idLength-1));
+                }
+                bld.append(DELIMITER).append(Text.escapeIllegalJcrChars(lastSegment.toString()));
+            }
+            return bld.toString();
+        }
+
+        private Node createIntermediateFolderNodes(String id, String escapedId, Node folder) throws RepositoryException {
+            if (!autoExpandTree) {
+                // additional folders are never created
+                return folder;
+            }
+
+            // additional folders needs be created if
+            // - the maximal size of child nodes is reached
+            // - if the auth-node to be created potentially collides with any
+            //   of the intermediate nodes.
+            int segmLength = defaultDepth +1;
+            int idLength = id.length();
+
+            while (intermediateFolderNeeded(escapedId, folder)) {
+                String folderName = Text.escapeIllegalJcrChars(id.substring(0, segmLength));
+                // validation check on each intermediate level if authorizable
+                // to be created doesn't conflict.
+                checkExists(folderName, folder);
+
+                if (folder.hasNode(folderName)) {
+                    folder = folder.getNode(folderName);
+                } else {
+                    folder = addNode((NodeImpl) folder, session.getQName(folderName), NT_REP_AUTHORIZABLE_FOLDER);
+                }
+                segmLength++;
+            }
+
+            // final validation check if authorizable to be created doesn't conflict.
+            checkExists(escapedId, folder);
+            return folder;
+        }
+
+        private void checkExists(String nodeName, Node folder) throws RepositoryException {
+            if (folder.hasNode(nodeName) &&
+                    folder.getNode(nodeName).isNodeType(session.getJCRName(NT_REP_AUTHORIZABLE))) {
+                throw new AuthorizableExistsException("Unable to create Group/User: Collision with existing authorizable.");
+            }
+        }
+
+        private boolean intermediateFolderNeeded(String nodeName, Node folder) throws RepositoryException {
+            // don't create additional intermediate folders for ids that are
+            // shorter or equally long as the folder name. In this case the
+            // MAX_SIZE flag is ignored.
+            if (nodeName.length() <= folder.getName().length()) {
+                return false;
+            }
+
+            // test for potential (or existing) collision in which case the
+            // intermediate node is created irrespective of the MAX_SIZE and the
+            // existing number of children.
+            if (nodeName.length() == folder.getName().length()+1) {
+                // max-size may not yet be reached yet on folder but the node to
+                // be created potentially collides with an intermediate folder.
+                // e.g.:
+                // existing folder structure: a/ab
+                // authID to be created     : abt
+                // OR
+                // existing collition that would result from
+                // existing folder structure: a/ab/abt
+                // authID to be create      : abt
+                return true;
+            }
+
+            // last possibility: max-size is reached.
+            if (folder.getNodes().getSize() >= autoExpandSize) {
+                return true;
+            }
+            
+            // no collision and no need to create an additional intermediate
+            // folder due to max-size reached
+            return false;
+        }
+    }

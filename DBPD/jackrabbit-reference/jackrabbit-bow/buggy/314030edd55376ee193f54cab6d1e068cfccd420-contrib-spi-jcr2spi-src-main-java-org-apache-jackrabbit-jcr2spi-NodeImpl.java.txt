improve memory consumption of the current hierarchy implementation

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@542571 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.state.PropertyState;
-     * Retrieves all mixins currently present on this node including those,
-     * that have been transiently added and excluding those, that have been
-     * transiently removed.<br>
+     * Retrieves the value of the jcr:mixinTypes property present with this
+     * Node including those that have been transiently added and excluding
+     * those, that have been transiently removed.<br>
-     * mixin-types that currently affect this node. Instead if represents the
-     * current value of the jcr:mixinTypes property.
-     *
+     * mixin-types that currently affect this node.
+     * 
-        QName[] mixinValue = new QName[0];
-        if (hasProperty(QName.JCR_MIXINTYPES)) {
-            if (getNodeState().getStatus() == Status.EXISTING) {
-                mixinValue = getNodeState().getMixinTypeNames();
-            } else {
-                // possibility that a mixin has been transient added
-                try {
-                    PropertyState ps = getNodeState().getPropertyState(QName.JCR_MIXINTYPES);
-                    mixinValue = StateUtility.getMixinNames(ps);
-                } catch (RepositoryException e) {
-                    // should never occur
-                    log.error("Internal error", e);
+        QName[] mixinValue;
+        if (getNodeState().getStatus() == Status.EXISTING) {
+            // jcr:mixinTypes must correspond to the mixins present on the nodestate.
+            mixinValue = getNodeState().getMixinTypeNames();
+        } else {
+            try {
+                PropertyEntry pe = getNodeEntry().getPropertyEntry(QName.JCR_MIXINTYPES);
+                if (pe != null) {
+                    // prop entry exists (and ev. has been transiently mod.)
+                    // -> retrieve mixin types from prop
+                    mixinValue = StateUtility.getMixinNames(pe.getPropertyState());
+                } else {
+                    // prop entry has not been loaded yet -> not modified
+                    mixinValue = getNodeState().getMixinTypeNames();
-            } // else: no mixins present
+            } catch (RepositoryException e) {
+                // should never occur
+                log.warn("Internal error", e);
+                mixinValue = new QName[0];
+            }
-            PropertyEntry pEntry = getNodeEntry().getPropertyEntry(qName);
+            PropertyEntry pEntry = getNodeEntry().getPropertyEntry(qName, true);
-                    targetEntry = getNodeEntry().getNodeEntry(pe.getName(), pe.getNormalizedIndex());
+                    // try to get child entry + force loading of not known yet
+                    targetEntry = getNodeEntry().getNodeEntry(pe.getName(), pe.getNormalizedIndex(), true);
-            }
-            if (targetEntry == null) {
-                // rp length > 1 OR child entry has not yet been loaded.
+            } else {
+                // rp length > 1
-            if (rp.getLength() == 1) {
+            if (rp.getLength() == 1 && rp.getNameElement().denotesName()) {
-                // will never point to a property.
-                if (rp.getNameElement().denotesName()) {
-                    QName propName = rp.getNameElement().getName();
-                    // check if property entry exists
-                    targetEntry = getNodeEntry().getPropertyEntry(propName);
-                } // else: entry may not have been loaded yet -> try via H-Mgr
-            }
-
-            if (targetEntry == null) {
+                // will never point to a property. If the NodeEntry does not
+                // contain such a pe, the targetEntry is 'null;
+                QName propName = rp.getNameElement().getName();
+                // check if property entry exists
+                targetEntry = getNodeEntry().getPropertyEntry(propName, true);
+            } else {

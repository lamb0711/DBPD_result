JCR-2689: Improve equals for binary values

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@980437 13f79535-47bb-0310-9956-ffa450edef68

+
+import static org.apache.jackrabbit.webdav.DavConstants.HEADER_ETAG;
+import static org.apache.jackrabbit.webdav.DavConstants.HEADER_LAST_MODIFIED;
+
-import org.apache.jackrabbit.spi.commons.value.ValueFactoryQImpl;
+import org.apache.jackrabbit.spi.commons.value.ValueFactoryQImpl;
+
+import java.util.Map;
+        private Map<String, String> headers;
+
-        private String uri;
-        private long length;
+        private final String uri;
+        private final long length;
-                // for both the value has not been loaded yet
-                if (!initialized) {
-                    if (other.uri != null) {
-                        return other.uri.equals(uri);
-                    } else {
-                        // need to load the binary value in order to be able
-                        // to compare the 2 values.
-                        try {
-                            loadBinary();
-                        } catch (RepositoryException e) {
-                            return false;
-                        } catch (IOException e) {
+
+                // Consider unequal urls as unequal values and both urls null as equal values
+                if (this.uri == null) {
+                    return other.uri == null;
+                }
+                if (!this.uri.equals(other.uri)) {
+                    return false;
+                }
+
+                // Consider both uninitialized as equal values
+                if (!this.preInitialized() && !other.preInitialized()) {
+                    return true;
+                }
+
+                try {
+                    // Initialized the one which is not
+                    if (!this.preInitialized()) {
+                        this.preInitialize(new String[] {HEADER_ETAG, HEADER_LAST_MODIFIED});
+                    } else if (!other.preInitialized()) {
+                        other.preInitialize(new String[] {HEADER_ETAG, HEADER_LAST_MODIFIED});
+                    }
+                } catch (RepositoryException e) {
+                    return false;
+                } catch (IOException e) {
+                    return false;
+                }
+
+                // If we have headers try to determine equality from them
+                if (headers != null && !headers.isEmpty()) {
+
+                    // Values are (un)equal if we have equal Etags
+                    if (containKey(HEADER_ETAG, this.headers, other.headers)) {
+                        return equalValue(HEADER_ETAG, this.headers, other.headers);
+                    }
+
+                    // Values are unequal if we have different Last-modified values
+                    if (containKey(HEADER_LAST_MODIFIED, this.headers, other.headers)) {
+                        if (!equalValue(HEADER_LAST_MODIFIED, this.headers, other.headers)) {
+
+                // Otherwise compare binaries
+                } else {
+                    return ((file == null ? other.file == null : file.equals(other.file))
+                        && Arrays.equals(buffer, other.buffer));
-                // both have been loaded
-                return ((file == null ? other.file == null : file.equals(other.file))
-                    && Arrays.equals(buffer, other.buffer));
+
+        /**
+         * Load the header with the given names. If none of the named headers exist, load binary.
+         */
+        private void preInitialize(String[] headerNames) throws IOException, RepositoryException {
+            headers = loader.loadHeaders(uri, headerNames);
+            if (headers.isEmpty()) {
+                loadBinary();
+            }
+        }
+
+        /**
+         * @return <code>true</code> if either initialized or headers have been
+         *         loaded, <code>false</code> otherwise.
+         */
+        private boolean preInitialized() {
+            return initialized || headers != null;
+        }
+
+        /**
+         * @return <code>true</code> if both maps contain the same value for
+         *         <code>key</code>, <code>false</code> otherwise. The
+         *         <code>key</code> must not map to <code>null</code> in either
+         *         map.
+         */
+        private boolean equalValue(String key, Map<String, String> map1, Map<String, String> map2) {
+            return map1.get(key).equals(map2.get(key));
+        }
+
+        /**
+         * @return <code>true</code> if both maps contains the <code>key</code>,
+         *         <code>false</code> otherwise.
+         */
+        private boolean containKey(String key, Map<String, String> map1, Map<String, String> map2) {
+            return map1.containsKey(key) && map2.containsKey(key);
+        }
+

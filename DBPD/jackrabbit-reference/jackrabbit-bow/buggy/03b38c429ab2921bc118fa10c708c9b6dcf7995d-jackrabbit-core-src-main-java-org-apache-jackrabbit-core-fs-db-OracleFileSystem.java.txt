JCR-1456: Database connection pooling

Merge back all changes from the JCR-1456 sandbox branch.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@886191 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.io.IOUtils;
-import org.apache.jackrabbit.util.Text;
-import org.apache.jackrabbit.util.TransientFileFactory;
-import org.apache.jackrabbit.core.fs.FileSystemException;
-import org.apache.jackrabbit.core.fs.FileSystemPathUtil;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import org.apache.jackrabbit.core.util.db.CheckSchemaOperation;
+import org.apache.jackrabbit.core.util.db.ConnectionHelper;
+import org.apache.jackrabbit.core.util.db.Oracle10R1ConnectionHelper;
-import javax.jcr.RepositoryException;
-import java.sql.DatabaseMetaData;
-import java.sql.ResultSet;
-import java.sql.Statement;
-import java.sql.Blob;
-import java.sql.Connection;
-import java.io.InputStream;
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.io.IOException;
-import java.io.File;
-import java.io.FilterOutputStream;
-import java.io.FileOutputStream;
-import java.io.FileInputStream;
-import java.lang.reflect.Method;
+import javax.sql.DataSource;
-    /**
-     * Logger instance
-     */
-    private static Logger log = LoggerFactory.getLogger(OracleFileSystem.class);
-
-    private Class< ? > blobClass;
-    private Integer durationSessionConstant;
-    private Integer modeReadWriteConstant;
-
-    /** the variable for the Oracle table space */
-    public static final String TABLE_SPACE_VARIABLE =
-        "${tableSpace}";
-
-    protected String tableSpace;
+    protected String tableSpace = "";
-        if (tableSpace != null) {
-            this.tableSpace = tableSpace.trim();
+        if (tableSpace != null && tableSpace.trim().length() > 0) {
+            this.tableSpace = "tablespace " + tableSpace.trim();
-            this.tableSpace = null;
+            this.tableSpace = "";
+
-     * <p/>
-     * Retrieve the <code>oracle.sql.BLOB</code> class via reflection, and
-     * initialize the values for the <code>DURATION_SESSION</code> and
-     * <code>MODE_READWRITE</code> constants defined there.
-     * @see oracle.sql.BLOB#DURATION_SESSION
-     * @see oracle.sql.BLOB#MODE_READWRITE
-    public void init() throws FileSystemException {
-        super.init();
-
-        // initialize oracle.sql.BLOB class & constants
-
-        // use the Connection object for using the exact same
-        // class loader that the Oracle driver was loaded with
-        try {
-            blobClass = con.getClass().getClassLoader().loadClass("oracle.sql.BLOB");
-            durationSessionConstant =
-                    new Integer(blobClass.getField("DURATION_SESSION").getInt(null));
-            modeReadWriteConstant =
-                    new Integer(blobClass.getField("MODE_READWRITE").getInt(null));
-        } catch (Exception e) {
-            String msg = "failed to load/introspect oracle.sql.BLOB";
-            log.error(msg, e);
-            throw new FileSystemException(msg, e);
-        }
+    @Override
+    protected ConnectionHelper createConnectionHelper(DataSource dataSrc) throws Exception {
+        Oracle10R1ConnectionHelper helper = new Oracle10R1ConnectionHelper(dataSrc, false);
+        helper.init();
+        return helper;
-     * <p/>
-     * Overridden in order to support multiple oracle schemas. Note that
-     * schema names in Oracle correspond to the username of the connection.
-     * See http://issues.apache.org/jira/browse/JCR-582
-     *
-     * @throws Exception if an error occurs
-    protected void checkSchema() throws Exception {
-        DatabaseMetaData metaData = con.getMetaData();
-        String tableName = schemaObjectPrefix + "FSENTRY";
-        if (metaData.storesLowerCaseIdentifiers()) {
-            tableName = tableName.toLowerCase();
-        } else if (metaData.storesUpperCaseIdentifiers()) {
-            tableName = tableName.toUpperCase();
-        }
-        String userName = metaData.getUserName();
-
-        ResultSet rs = metaData.getTables(null, userName, tableName, null);
-        boolean schemaExists;
-        try {
-            schemaExists = rs.next();
-        } finally {
-            rs.close();
-        }
-
-        if (!schemaExists) {
-            // read ddl from resources
-            InputStream in = OracleFileSystem.class.getResourceAsStream(schema + ".ddl");
-            if (in == null) {
-                String msg = "Configuration error: unknown schema '" + schema + "'";
-                log.debug(msg);
-                throw new RepositoryException(msg);
-            }
-            BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-            Statement stmt = con.createStatement();
-            try {
-                String sql = reader.readLine();
-                while (sql != null) {
-                    // Skip comments and empty lines
-                    if (!sql.startsWith("#") && sql.length() > 0) {
-                        // replace prefix variable
-                        sql = Text.replace(sql, SCHEMA_OBJECT_PREFIX_VARIABLE, schemaObjectPrefix);
-
-                        // set the tablespace if it is defined
-                        String tspace;
-                        if (tableSpace == null || "".equals(tableSpace)) {
-                            tspace = "";
-                        } else {
-                            tspace = "tablespace " + tableSpace;
-                        }
-                        sql = Text.replace(sql, TABLE_SPACE_VARIABLE, tspace).trim();
-
-                        // execute sql stmt
-                        stmt.executeUpdate(sql);
-                    }
-                    // read next sql stmt
-                    sql = reader.readLine();
-                }
-            } finally {
-                IOUtils.closeQuietly(in);
-                closeStatement(stmt);
-            }
-        }
+    @Override
+    protected CheckSchemaOperation createCheckSchemaOperation() {
+        return super.createCheckSchemaOperation().addVariableReplacement(
+            CheckSchemaOperation.TABLE_SPACE_VARIABLE, tableSpace);
+    //-----------------------------------------< DatabaseFileSystem overrides >
+    
-
-
-    /**
-     * {@inheritDoc}
-     * <p/>
-     * Overridden because we need to use <code>oracle.sql.BLOB</code>
-     * and <code>PreparedStatement#setBlob</code> instead of just
-     * <code>PreparedStatement#setBinaryStream</code>.
-     */
-    public OutputStream getOutputStream(final String filePath) throws FileSystemException {
-        if (!initialized) {
-            throw new IllegalStateException("not initialized");
-        }
-
-        FileSystemPathUtil.checkFormat(filePath);
-
-        final String parentDir = FileSystemPathUtil.getParentDir(filePath);
-        final String name = FileSystemPathUtil.getName(filePath);
-
-        if (!isFolder(parentDir)) {
-            throw new FileSystemException("path not found: " + parentDir);
-        }
-
-        if (isFolder(filePath)) {
-            throw new FileSystemException("path denotes folder: " + filePath);
-        }
-
-        try {
-            TransientFileFactory fileFactory = TransientFileFactory.getInstance();
-            final File tmpFile = fileFactory.createTransientFile("bin", null, null);
-
-            return new FilterOutputStream(new FileOutputStream(tmpFile)) {
-
-                public void write(byte[] bytes, int off, int len) throws IOException {
-                    out.write(bytes, off, len);
-                }
-
-                public void close() throws IOException {
-                    out.flush();
-                    ((FileOutputStream) out).getFD().sync();
-                    out.close();
-
-                    InputStream in = null;
-                    Blob blob = null;
-                    try {
-                        if (isFile(filePath)) {
-                            synchronized (updateDataSQL) {
-                                long length = tmpFile.length();
-                                in = new FileInputStream(tmpFile);
-                                blob = createTemporaryBlob(in);
-                                executeStmt(updateDataSQL,
-                                        new Object[]{
-                                            blob,
-                                            new Long(System.currentTimeMillis()),
-                                            new Long(length),
-                                            parentDir,
-                                            name
-                                        });
-                            }
-                        } else {
-                            synchronized (insertFileSQL) {
-                                long length = tmpFile.length();
-                                in = new FileInputStream(tmpFile);
-                                blob = createTemporaryBlob(in);
-                                executeStmt(insertFileSQL,
-                                        new Object[]{
-                                            parentDir,
-                                            name,
-                                            blob,
-                                            new Long(System.currentTimeMillis()),
-                                            new Long(length)
-                                        });
-                            }
-                        }
-                    } catch (Exception e) {
-                        IOException ioe = new IOException(e.getMessage());
-                        ioe.initCause(e);
-                        throw ioe;
-                    } finally {
-                        if (blob != null) {
-                            try {
-                                freeTemporaryBlob(blob);
-                            } catch (Exception e1) {
-                            }
-                        }
-                        IOUtils.closeQuietly(in);
-                        // temp file can now safely be removed
-                        tmpFile.delete();
-                    }
-                }
-            };
-        } catch (Exception e) {
-            String msg = "failed to open output stream to file: " + filePath;
-            log.error(msg, e);
-            throw new FileSystemException(msg, e);
-        }
-    }
-
-    //----------------------------------------< oracle-specific blob handling >
-    /**
-     * Creates a temporary oracle.sql.BLOB instance via reflection and spools
-     * the contents of the specified stream.
-     */
-    protected Blob createTemporaryBlob(InputStream in) throws Exception {
-        /*
-        BLOB blob = BLOB.createTemporary(con, false, BLOB.DURATION_SESSION);
-        blob.open(BLOB.MODE_READWRITE);
-        OutputStream out = blob.getBinaryOutputStream();
-        ...
-        out.flush();
-        out.close();
-        blob.close();
-        return blob;
-        */
-        Method createTemporary = blobClass.getMethod("createTemporary",
-                new Class[]{Connection.class, Boolean.TYPE, Integer.TYPE});
-        Object blob = createTemporary.invoke(null,
-                new Object[]{con, Boolean.FALSE, durationSessionConstant});
-        Method open = blobClass.getMethod("open", new Class[]{Integer.TYPE});
-        open.invoke(blob, new Object[]{modeReadWriteConstant});
-        Method getBinaryOutputStream =
-                blobClass.getMethod("getBinaryOutputStream", new Class[0]);
-        OutputStream out = (OutputStream) getBinaryOutputStream.invoke(blob);
-        try {
-            IOUtils.copy(in, out);
-        } finally {
-            try {
-                out.flush();
-            } catch (IOException ioe) {
-            }
-            out.close();
-        }
-        Method close = blobClass.getMethod("close", new Class[0]);
-        close.invoke(blob);
-        return (Blob) blob;
-    }
-
-    /**
-     * Frees a temporary oracle.sql.BLOB instance via reflection.
-     */
-    protected void freeTemporaryBlob(Object blob) throws Exception {
-        // blob.freeTemporary();
-        Method freeTemporary = blobClass.getMethod("freeTemporary", new Class[0]);
-        freeTemporary.invoke(blob);
-    }

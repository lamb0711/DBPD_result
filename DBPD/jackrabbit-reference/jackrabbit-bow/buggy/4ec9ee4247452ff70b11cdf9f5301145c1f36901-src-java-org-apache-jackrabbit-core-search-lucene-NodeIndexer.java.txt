- removed @author and @version (i.e. $Revision & $Id) tags
- removed tab characters from java source code

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@47648 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.search.NamespaceMappings;
-import org.apache.jackrabbit.core.util.uuid.UUID;
-import org.apache.jackrabbit.core.state.NodeState;
-import org.apache.jackrabbit.core.state.ItemStateProvider;
-import org.apache.jackrabbit.core.state.PropertyState;
-import org.apache.jackrabbit.core.state.NoSuchItemStateException;
-import org.apache.jackrabbit.core.state.ItemStateException;
-import org.apache.jackrabbit.core.PropertyId;
-import org.apache.jackrabbit.core.QName;
+import org.apache.jackrabbit.core.PropertyId;
+import org.apache.jackrabbit.core.QName;
+import org.apache.jackrabbit.core.search.NamespaceMappings;
+import org.apache.jackrabbit.core.state.*;
+import org.apache.jackrabbit.core.util.uuid.UUID;
-import javax.jcr.PropertyType;
-import java.util.List;
-import java.util.Iterator;
+import javax.jcr.PropertyType;
+import java.util.Iterator;
+import java.util.List;
- * @author Marcel Reutegger
- * @version $Revision:  $, $Date:  $
-			ItemStateProvider stateMgr,
-			String path,
-			NamespaceMappings mappings) {
-	this.node = node;
-	this.stateProvider = stateMgr;
-	this.path = path;
-	this.mappings = mappings;
+                        ItemStateProvider stateMgr,
+                        String path,
+                        NamespaceMappings mappings) {
+        this.node = node;
+        this.stateProvider = stateMgr;
+        this.path = path;
+        this.mappings = mappings;
-				   ItemStateProvider stateMgr,
-				   String path,
-				   NamespaceMappings mappings) {
-	NodeIndexer indexer = new NodeIndexer(node, stateMgr, path, mappings);
-	return indexer.createDoc();
+                                          ItemStateProvider stateMgr,
+                                          String path,
+                                          NamespaceMappings mappings) {
+        NodeIndexer indexer = new NodeIndexer(node, stateMgr, path, mappings);
+        return indexer.createDoc();
-	Document doc = new Document();
+        Document doc = new Document();
-	// special fields
-	// UUID
-	doc.add(new Field(FieldNames.UUID, node.getUUID(), true, true, false));
-	// Path
-	doc.add(new Field(FieldNames.PATH, path, true, true, false));
+        // special fields
+        // UUID
+        doc.add(new Field(FieldNames.UUID, node.getUUID(), true, true, false));
+        // Path
+        doc.add(new Field(FieldNames.PATH, path, true, true, false));
-	List props = node.getPropertyEntries();
-	for (Iterator it = props.iterator(); it.hasNext();) {
-	    NodeState.PropertyEntry prop = (NodeState.PropertyEntry) it.next();
-	    PropertyId id = new PropertyId(node.getUUID(), prop.getName());
-	    try {
-		PropertyState propState = (PropertyState) stateProvider.getItemState(id);
-		InternalValue[] values = propState.getValues();
-		for (int i = 0; i < values.length; i++) {
-		    addValue(doc, values[i], propState.getName());
-		}
-	    } catch (NoSuchItemStateException e) {
-		// FIXME do logging? throw?
-	    } catch (ItemStateException e) {
-		// FIXME do logging? throw?
-	    }
-	}
-	return doc;
+        List props = node.getPropertyEntries();
+        for (Iterator it = props.iterator(); it.hasNext();) {
+            NodeState.PropertyEntry prop = (NodeState.PropertyEntry) it.next();
+            PropertyId id = new PropertyId(node.getUUID(), prop.getName());
+            try {
+                PropertyState propState = (PropertyState) stateProvider.getItemState(id);
+                InternalValue[] values = propState.getValues();
+                for (int i = 0; i < values.length; i++) {
+                    addValue(doc, values[i], propState.getName());
+                }
+            } catch (NoSuchItemStateException e) {
+                // FIXME do logging? throw?
+            } catch (ItemStateException e) {
+                // FIXME do logging? throw?
+            }
+        }
+        return doc;
-	String fieldName = name.toString();
-	try {
-	    fieldName = mappings.getPrefix(name.getNamespaceURI()) + ":" + name.getLocalName();
-	} catch (NamespaceException e) {
-	    // will never happen
-	}
-	Object internalValue = value.internalValue();
-	switch (value.getType()) {
-	    case PropertyType.BINARY:
-		// don't know how to index -> ignore
-		break;
-	    case PropertyType.BOOLEAN:
-		doc.add(new Field(fieldName,
-			internalValue.toString(),
-			false,
-			true,
-			false));
-		break;
-	    case PropertyType.DATE:
+        String fieldName = name.toString();
+        try {
+            fieldName = mappings.getPrefix(name.getNamespaceURI()) + ":" + name.getLocalName();
+        } catch (NamespaceException e) {
+            // will never happen
+        }
+        Object internalValue = value.internalValue();
+        switch (value.getType()) {
+            case PropertyType.BINARY:
+                // don't know how to index -> ignore
+                break;
+            case PropertyType.BOOLEAN:
+                doc.add(new Field(fieldName,
+                        internalValue.toString(),
+                        false,
+                        true,
+                        false));
+                break;
+            case PropertyType.DATE:
-		doc.add(new Field(fieldName,
-			DateField.timeToString(millis),
-			false,
-			true,
-			false));
-		break;
-	    case PropertyType.DOUBLE:
-		double doubleVal = ((Double) internalValue).doubleValue();
-		doc.add(new Field(fieldName,
-			DoubleField.doubleToString(doubleVal),
-			false,
-			true,
-			false));
-		break;
-	    case PropertyType.LONG:
-		long longVal = ((Long) internalValue).longValue();
-		doc.add(new Field(fieldName,
-			LongField.longToString(longVal),
-			false,
-			true,
-			false));
-		break;
-	    case PropertyType.REFERENCE:
-		String uuid = ((UUID) internalValue).toString();
-		doc.add(new Field(fieldName,
-			uuid,
-			false,
-			true,
-			false));
-		break;
-	    case PropertyType.PATH:
+                doc.add(new Field(fieldName,
+                        DateField.timeToString(millis),
+                        false,
+                        true,
+                        false));
+                break;
+            case PropertyType.DOUBLE:
+                double doubleVal = ((Double) internalValue).doubleValue();
+                doc.add(new Field(fieldName,
+                        DoubleField.doubleToString(doubleVal),
+                        false,
+                        true,
+                        false));
+                break;
+            case PropertyType.LONG:
+                long longVal = ((Long) internalValue).longValue();
+                doc.add(new Field(fieldName,
+                        LongField.longToString(longVal),
+                        false,
+                        true,
+                        false));
+                break;
+            case PropertyType.REFERENCE:
+                String uuid = ((UUID) internalValue).toString();
+                doc.add(new Field(fieldName,
+                        uuid,
+                        false,
+                        true,
+                        false));
+                break;
+            case PropertyType.PATH:
-		doc.add(new Field(fieldName,
-			path,
-			false,
-			true,
-			false));
-		break;
-	    case PropertyType.STRING:
-		// simple String
-		doc.add(new Field(fieldName,
-			internalValue.toString(),
-			false,
-			true,
-			false));
-		// also create fulltext index of this value
-		doc.add(new Field(FieldNames.FULLTEXT,
-			internalValue.toString(),
-			false,
-			true,
-			true));
-		break;
-	    case PropertyType.NAME:
-		QName qualiName = (QName) internalValue;
-		String normValue = internalValue.toString();
-		try {
-		    normValue = mappings.getPrefix(qualiName.getNamespaceURI())
-			    + ":" + qualiName.getLocalName();
-		} catch (NamespaceException e) {
-		    // will never happen
-		}
-		doc.add(new Field(fieldName,
-			normValue,
-			false,
-			true,
-			false));
-		break;
-	    default:
-		throw new IllegalArgumentException("illegal internal value type");
-	}
+                doc.add(new Field(fieldName,
+                        path,
+                        false,
+                        true,
+                        false));
+                break;
+            case PropertyType.STRING:
+                // simple String
+                doc.add(new Field(fieldName,
+                        internalValue.toString(),
+                        false,
+                        true,
+                        false));
+                // also create fulltext index of this value
+                doc.add(new Field(FieldNames.FULLTEXT,
+                        internalValue.toString(),
+                        false,
+                        true,
+                        true));
+                break;
+            case PropertyType.NAME:
+                QName qualiName = (QName) internalValue;
+                String normValue = internalValue.toString();
+                try {
+                    normValue = mappings.getPrefix(qualiName.getNamespaceURI())
+                            + ":" + qualiName.getLocalName();
+                } catch (NamespaceException e) {
+                    // will never happen
+                }
+                doc.add(new Field(fieldName,
+                        normValue,
+                        false,
+                        true,
+                        false));
+                break;
+            default:
+                throw new IllegalArgumentException("illegal internal value type");
+        }

Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.HierarchyManager;
+import org.apache.jackrabbit.jcr2spi.hierarchy.HierarchyManager;
+import org.apache.jackrabbit.jcr2spi.hierarchy.NodeEntry;
-import org.apache.jackrabbit.jcr2spi.state.entry.ChildNodeEntry;
+import org.apache.jackrabbit.jcr2spi.config.CacheBehaviour;
-     * @see Operation#persisted()
+     * @see Operation#persisted(CacheBehaviour)
+     * @param cacheBehaviour
-    public void persisted() {
-        if (srcState.isWorkspaceState()) {
-            srcParentState.invalidate(false);
-            destParentState.invalidate(false);
-            srcState.invalidate(false);
-        } else {
-            throw new UnsupportedOperationException("persisted() not implemented for transient modification.");
+    public void persisted(CacheBehaviour cacheBehaviour) {
+        if (cacheBehaviour == CacheBehaviour.INVALIDATE) {
+            if (srcState.isWorkspaceState()) {
+                // non-recursive invalidation
+                srcParentState.getHierarchyEntry().invalidate(false);
+                destParentState.getHierarchyEntry().invalidate(false);
+                srcState.getHierarchyEntry().invalidate(false);
+            } else {
+                throw new UnsupportedOperationException("persisted() not implemented for transient modification.");
+            }
-        if (destParentState.hasPropertyName(destName)) {
+        NodeEntry destEntry = (NodeEntry) destParentState.getHierarchyEntry();
+        if (destEntry.hasPropertyEntry(destName)) {
-        } else if (destParentState.hasChildNodeEntry(destName)) {
-            ChildNodeEntry existing = destParentState.getChildNodeEntry(destName, Path.INDEX_DEFAULT);
+        } else if (destEntry.hasNodeEntry(destName)) {
+            NodeEntry existing = destEntry.getNodeEntry(destName, Path.INDEX_DEFAULT);

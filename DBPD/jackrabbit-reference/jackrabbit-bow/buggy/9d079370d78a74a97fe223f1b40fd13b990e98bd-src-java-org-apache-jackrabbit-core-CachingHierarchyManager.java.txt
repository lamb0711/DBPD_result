True caching in CachingHierarchyManager

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@190372 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.collections.ReferenceMap;
+import org.apache.jackrabbit.core.state.ItemState;
+import org.apache.jackrabbit.core.state.ItemStateException;
+import org.apache.jackrabbit.core.state.ItemStateManager;
+import org.apache.jackrabbit.core.state.NodeState;
+import org.apache.jackrabbit.core.state.NodeStateListener;
+import org.apache.log4j.Logger;
+import org.apache.commons.collections.map.ReferenceMap;
-import java.util.Map;
+import java.util.List;
+import java.util.Iterator;
+import java.util.HashSet;
+import java.util.Set;
- * <code>CachingHierarchyManager</code> is a simple wrapper for a
- * <code>HierarchyManager</code> that caches the <code>ItemId</code> to <code>Path</code>
- * mappings returned by the underlying <code>HierarchyManager</code> for better
- * performance.
- * <p/>
- * Please keep in mind that this cache of <code>Path</code>s is not automatically
- * updated when the underlying hierarchy is changing. Therefore it should only be
- * used with caution and in special situations (usually only locally within a
- * narrow scope) where the underlying hierarchy is not expected to change.
+ * Implementation of a <code>HierarchyManager</code> that caches paths of
+ * items.
-public class CachingHierarchyManager implements HierarchyManager {
-
-    private final HierarchyManager delegatee;
-
-    // map of item id to list of paths
-    private Map pathCache = new ReferenceMap(ReferenceMap.HARD, ReferenceMap.HARD);
-    private Map zombiePathCache = new ReferenceMap(ReferenceMap.HARD, ReferenceMap.HARD);
-
-    // map of path to item id
-    private Map idCache = new ReferenceMap(ReferenceMap.HARD, ReferenceMap.HARD);
+public class CachingHierarchyManager extends HierarchyManagerImpl
+        implements NodeStateListener {
-     * @param hierMgr
+     * Default upper limit of cached states
-    public CachingHierarchyManager(HierarchyManager hierMgr) {
-        delegatee = hierMgr;
+    public static final int DEFAULT_UPPER_LIMIT = 100;
+
+    /**
+     * Logger instance
+     */
+    private static Logger log = Logger.getLogger(CachingHierarchyManager.class);
+
+    /**
+     * Mapping of paths to children in the path map
+     */
+    private final PathMap pathCache = new PathMap();
+
+    /**
+     * Mapping of item ids to <code>LRUEntry</code> in the path map
+     */
+    private final ReferenceMap idCache = new ReferenceMap(
+            ReferenceMap.HARD, ReferenceMap.HARD);
+
+    /**
+     * Set of items that were moved
+     */
+    private final Set movedIds = new HashSet();
+
+    /**
+     * Cache monitor object
+     */
+    private final Object cacheMonitor = new Object();
+
+    /**
+     * Upper limit
+     */
+    private final int upperLimit;
+
+    /**
+     * Head of LRU
+     */
+    private LRUEntry head;
+
+    /**
+     * Tail of LRU
+     */
+    private LRUEntry tail;
+
+    /**
+     * Create a new instance of this class. This hierarchy manager will not
+     * check for item states that have been moved into attic space
+     * @param rootNodeUUID root node UUID
+     * @param provider item state manager
+     * @param nsResolver namespace resolver
+     */
+    public CachingHierarchyManager(String rootNodeUUID,
+                                   ItemStateManager provider,
+                                   NamespaceResolver nsResolver) {
+        this(rootNodeUUID, provider, nsResolver, null);
-     * Returns the wrapped <code>HierarchyManager</code> instance
-     *
-     * @return the wrapped <code>HierarchyManager</code> instance
+     * Create a new instance of this class.
+     * @param rootNodeUUID root node UUID
+     * @param provider item state manager
+     * @param nsResolver namespace resolver
+     * @param attic item state manager for states in the attic space
-    public HierarchyManager unwrap() {
-        return delegatee;
-    }
+    public CachingHierarchyManager(String rootNodeUUID,
+                                   ItemStateManager provider,
+                                   NamespaceResolver nsResolver,
+                                   ItemStateManager attic) {
-    /**
-     * Clears the cache.
-     */
-    public synchronized void clearCache() {
-        pathCache.clear();
-        zombiePathCache.clear();
-        idCache.clear();
+        super(rootNodeUUID, provider, nsResolver, attic);
+
+        this.upperLimit = DEFAULT_UPPER_LIMIT;
+
+     *
+     * Check the item indicated inside our path cache first.
-        return delegatee.listParents(id);
-    }
-    /**
-     * {@inheritDoc}
-     */
-    public ItemId[] listChildren(NodeId id)
-            throws ItemNotFoundException, RepositoryException {
-        return delegatee.listChildren(id);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public ItemId[] listZombieChildren(NodeId id)
-            throws ItemNotFoundException, RepositoryException {
-        return delegatee.listZombieChildren(id);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public synchronized ItemId resolvePath(Path path)
-            throws PathNotFoundException, RepositoryException {
-        // check cache first
-        ItemId id = (ItemId) idCache.get(path);
-        if (id != null) {
-            return id;
+        if (id.denotesNode()) {
+            PathMap.Element element = get(id);
+            if (element != null) {
+                PathMap.Element parent = element.getParent();
+                if (parent != null) {
+                    LRUEntry entry = (LRUEntry) element.get();
+                    if (entry != null) {
+                        return new NodeId[] { (NodeId) entry.getId() };
+                    }
+                }
+            }
-        id = delegatee.resolvePath(path);
-        idCache.put(path, id);
-        return id;
+        return super.listParents(id);
+     *
+     * Check the path indicated inside our cache first.
+     */
+    public ItemId resolvePath(Path path)
+            throws PathNotFoundException, RepositoryException {
+
+        PathMap.Element element = map(path);
+        if (element == null) {
+            return super.resolvePath(path);
+        }
+        LRUEntry entry = (LRUEntry) element.get();
+        if (element.hasPath(path)) {
+            entry.touch();
+            return entry.getId();
+        }
+        return super.resolvePath(path, entry.getId(), element.getDepth() + 1);
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * Cache the intermediate item inside our cache.
+     */
+    protected ItemId resolvePath(Path path, ItemState state, int next)
+            throws PathNotFoundException, ItemStateException {
+
+        if (state.isNode() && !isCached(state.getId())) {
+            try {
+                Path.PathBuilder builder = new Path.PathBuilder();
+                Path.PathElement[] elements = path.getElements();
+                for (int i = 0; i < next; i++) {
+                    builder.addLast(elements[i]);
+                }
+                Path parentPath = builder.getPath();
+                cache(state, parentPath);
+            } catch (MalformedPathException mpe) {
+                log.warn("Failed to build path of " + state.getId(), mpe);
+            }
+        }
+        return super.resolvePath(path, state, next);
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * Overridden method simply checks whether we have an item matching the id
+     * and returns its path, otherwise calls base implementation.
-        return getAllPaths(id, false)[0];
+
+        if (id.denotesNode()) {
+            PathMap.Element element = get(id);
+            if (element != null) {
+                try {
+                    return element.getPath();
+                } catch (MalformedPathException mpe) {
+                    String msg = "Failed to build path of " + id;
+                    log.debug(msg);
+                    throw new RepositoryException(msg, mpe);
+                }
+            }
+        }
+        return super.getPath(id);
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * Overridden method tries to find a mapping for the intermediate item
+     * <code>state</code> and add its path elements to the builder currently
+     * being used. If no mapping is found, the item is cached instead after
+     * the base implementation has been invoked.
+     */
+    protected void getPath(Path.PathBuilder builder, ItemState state)
+            throws ItemStateException, RepositoryException {
+
+        if (state.isNode()) {
+            PathMap.Element element = get(state.getId());
+            if (element != null) {
+                try {
+                    Path.PathElement[] elements = element.getPath().getElements();
+                    for (int i = elements.length - 1; i >= 0; i--) {
+                        builder.addFirst(elements[i]);
+                    }
+                    return;
+                } catch (MalformedPathException mpe) {
+                    String msg = "Failed to build path of " + state.getId();
+                    log.debug(msg);
+                    throw new RepositoryException(msg, mpe);
+                }
+            }
+        }
+
+        super.getPath(builder, state);
+
+        if (state.isNode()) {
+            try {
+                cache(state, builder.getPath());
+            } catch (MalformedPathException mpe) {
+                log.warn("Failed to build path of " + state.getId());
+            }
+        }
-    public QName getName(ItemId itemId)
+    public QName getName(ItemId id)
-        if (itemId.denotesNode()) {
-            return getPath(itemId).getNameElement().getName();
-        } else {
-            PropertyId propId = (PropertyId) itemId;
-            return propId.getName();
+
+        if (id.denotesNode()) {
+            PathMap.Element element = get(id);
+            if (element != null) {
+                return element.getName();
+            }
+        return super.getName(id);
-        if (pathCache.containsKey(id)) {
-            return getPath(id).getAncestorCount();
-        } else {
-            return delegatee.getDepth(id);
+
+        if (id.denotesNode()) {
+            PathMap.Element element = get(id);
+            if (element != null) {
+                return element.getDepth();
+            }
+        return super.getDepth(id);
-        if (pathCache.containsKey(nodeId) && pathCache.containsKey(itemId)) {
-            // use cached Path objects rather than calling delegatee
-            try {
-                return getPath(nodeId).isAncestorOf(getPath(itemId));
-            } catch (MalformedPathException mpe) {
-                // should never get here...
-                String msg = "failed to determine degree of relationship of "
-                        + nodeId + " and " + itemId;
-                throw new ItemNotFoundException(msg, mpe);
+
+        if (itemId.denotesNode()) {
+            PathMap.Element element = get(nodeId);
+            if (element != null) {
+                PathMap.Element child = get(itemId);
+                if (child != null) {
+                    return element.isAncestorOf(child);
+                }
-        } else {
-            return delegatee.isAncestor(nodeId, itemId);
+        }
+        return super.isAncestor(nodeId, itemId);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public Path[] getAllPaths(ItemId id, boolean includeZombies)
+            throws ItemNotFoundException, RepositoryException {
+
+        if (!includeZombies) {
+            return new Path[] { getPath(id) };
+        }
+        return super.getAllPaths(id, includeZombies);
+    }
+
+    //----------------------------------------------------< ItemStateListener >
+
+    /**
+     * {@inheritDoc}
+     */
+    public void stateCreated(ItemState created) {
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void stateModified(ItemState modified) {
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void stateDestroyed(ItemState destroyed) {
+        destroyed.removeListener(this);
+        evict(destroyed.getId());
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void stateDiscarded(ItemState discarded) {
+        discarded.removeListener(this);
+        evict(discarded.getId());
+    }
+
+    /**
+     * Called when an <code>ItemState</code> has been overlaid by some
+     * other state that now takes its identity. This notification is sent
+     * on the state being overlaid.
+     *
+     * @param overlayer the <code>ItemState</code> that overlays this state
+     */
+    public void stateOverlaid(ItemState overlayer) {
+        if (overlayer.isNode()) {
+            overlayer.getOverlayedState().removeListener(this);
+            overlayer.addListener(this);
+        }
+    }
+
+    /**
+     * Called when an <code>ItemState</code> no longer overlayes some other
+     * item state. This notification is sent on the state overlaying another
+     * state.
+     *
+     * @param overlayer the <code>ItemState</code> that overlaid another
+     *        item state. To get the overlaid state, invoke
+     *        {@link ItemState#getOverlayedState()}
+     */
+    public void stateUncovered(ItemState overlayer) {
+        if (overlayer.isNode()) {
+            overlayer.removeListener(this);
+            overlayer.getOverlayedState().addListener(this);
-    public synchronized Path[] getAllPaths(ItemId id)
-            throws ItemNotFoundException, RepositoryException {
-        return getAllPaths(id, false);
+    public void nodeAdded(NodeState state, QName name, int index, String uuid) {
+        try {
+            Path path = Path.create(getPath(state.getId()), name, index, true);
+            insert(path, new NodeId(uuid));
+        } catch (PathNotFoundException e) {
+            log.warn("Added node does not have parent, ignoring event.");
+        } catch (MalformedPathException e) {
+            log.warn("Unable to create path of " + uuid, e);
+        } catch(ItemNotFoundException e) {
+            log.warn("Unable to get path of " + state.getId(), e);
+        } catch(RepositoryException e) {
+            log.warn("Unable to get path of " + state.getId(), e);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * Generate subsequent add and remove notifications for every replacement.
+     */
+    public void nodesReplaced(NodeState state) {
+        List entries = state.getReorderedChildNodeEntries();
+        if (entries.size() == 0) {
+            return;
+        }
+
+        Iterator iter = entries.iterator();
+        while (iter.hasNext()) {
+            NodeState.ChildNodeEntry now = (NodeState.ChildNodeEntry) iter.next();
+            NodeState.ChildNodeEntry old = null;
+
+            List list = ((NodeState) state.getOverlayedState()).
+                    getChildNodeEntries(now.getUUID());
+            if (list.size() > 0) {
+                old = (NodeState.ChildNodeEntry) list.get(0);
+            }
+            if (old == null) {
+                log.warn("Reordered child node not found in old list.");
+                continue;
+            }
+
+            nodeAdded(state, now.getName(), now.getIndex(), now.getUUID());
+            nodeRemoved(state, old.getName(), old.getIndex(), old.getUUID());
+        }
-    public synchronized Path[] getAllPaths(ItemId id, boolean includeZombies)
-            throws ItemNotFoundException, RepositoryException {
-        // check cache first
-        Path[] paths;
-        if (includeZombies) {
-            paths = (Path[]) zombiePathCache.get(id);
-            if (paths != null) {
-                return paths;
-            }
-            paths = delegatee.getAllPaths(id, includeZombies);
-            zombiePathCache.put(id, paths);
-        } else {
-            paths = (Path[]) pathCache.get(id);
-            if (paths != null) {
-                return paths;
-            }
-            paths = delegatee.getAllPaths(id, includeZombies);
-            pathCache.put(id, paths);
+    public void nodeRemoved(NodeState state, QName name, int index, String uuid) {
+        try {
+            Path path = Path.create(getPath(state.getId()), name, index, true);
+            remove(path, new NodeId(uuid));
+        } catch (PathNotFoundException e) {
+            log.warn("Added node does not have parent, ignoring event.");
+        } catch (MalformedPathException e) {
+            log.warn("Unable to create path of " + uuid, e);
+        } catch(ItemNotFoundException e) {
+            log.warn("Unable to get path of " + state.getId(), e);
+        } catch(RepositoryException e) {
+            log.warn("Unable to get path of " + state.getId(), e);
-        return paths;
+    }
+
+    //-------------------------------------------------------< private methods >
+
+    /**
+     * Return a cached element in the path map, given its id
+     * @param id node id
+     * @return cached element, <code>null</code> if not found
+     */
+    private PathMap.Element get(ItemId id) {
+        synchronized (cacheMonitor) {
+            LRUEntry entry = (LRUEntry) idCache.get(id);
+            if (entry != null) {
+                entry.touch();
+                return entry.getElement();
+            }
+            return null;
+        }
+    }
+
+    /**
+     * Return the nearest cached element in the path map, given a path.
+     * The returned element is guaranteed to have an associated object that
+     * is not <code>null</code>.
+     * @param path path
+     * @return cached element, <code>null</code> if not found
+     */
+    private PathMap.Element map(Path path) {
+        synchronized (cacheMonitor) {
+            PathMap.Element element = pathCache.map(path, false);
+            while (element != null) {
+                LRUEntry entry = (LRUEntry) element.get();
+                if (entry != null) {
+                    entry.touch();
+                    return element;
+                }
+                element = element.getParent();
+            }
+            return null;
+        }
+    }
+
+    /**
+     * Cache an item in the hierarchy given its id and path. Adds a listener
+     * for this item state to get notified about changes.
+     * @param state item state, may be <code>null</code>
+     * @param path path to item
+     */
+    private void cache(ItemState state, Path path) {
+        ItemId id = state.getId();
+
+        synchronized (cacheMonitor) {
+            if (idCache.get(id) != null) {
+                return;
+            }
+            if (idCache.size() >= upperLimit) {
+                removeLRU();
+            }
+
+            PathMap.Element element = pathCache.put(path);
+            LRUEntry entry = new LRUEntry(id, element);
+            element.set(entry);
+            idCache.put(id, entry);
+
+            state.addListener(this);
+        }
+    }
+
+    /**
+     * Remove least recently used item. Scans the LRU list from head to tail
+     * and removes the first item that has no children.
+     */
+    private void removeLRU() {
+        synchronized (cacheMonitor) {
+            LRUEntry entry = head;
+            while (entry != null) {
+                PathMap.Element element = entry.getElement();
+                if (element.getChildrenCount() == 0) {
+                    evict(entry, true);
+                    return;
+                }
+                entry = entry.getNext();
+            }
+        }
+    }
+
+    /**
+     * Return a flag indicating whether a certain element is cached.
+     * @param id item id
+     * @return <code>true</code> if the item is already cached;
+     *         <code>false</code> otherwise
+     */
+    private boolean isCached(ItemId id) {
+        synchronized (cacheMonitor) {
+            return idCache.get(id) != null;
+        }
+    }
+
+    /**
+     * Evict item from cache. Evicts the associated <code>LRUEntry</code>
+     * @param id item id
+     */
+    private void evict(ItemId id) {
+        synchronized (cacheMonitor) {
+            LRUEntry entry = (LRUEntry) idCache.get(id);
+            if (entry != null) {
+                evict(entry, true);
+            }
+        }
+    }
+
+    /**
+     * Evict item from cache
+     * @param entry LRU entry
+     * @param removeFromPathCache whether to remove from path cache
+     */
+    private void evict(LRUEntry entry, boolean removeFromPathCache) {
+        synchronized (cacheMonitor) {
+            if (removeFromPathCache) {
+                PathMap.Element element = entry.getElement();
+                evict(element);
+                element.remove();
+            } else {
+                idCache.remove(entry.getId());
+                entry.remove();
+            }
+        }
+    }
+
+    /**
+     * Evict path map element from cache. This will traverse all children
+     * of this element and evict the objects associated with them
+     * @param element path map element
+     */
+    private void evict(PathMap.Element element) {
+        synchronized (cacheMonitor) {
+            element.traverse(new PathMap.ElementVisitor() {
+                public void elementVisited(PathMap.Element element) {
+                    evict((LRUEntry) element.get(), false);
+                }
+            }, false);
+        }
+    }
+
+    /**
+     * Insert a node into the cache. This will automatically shift
+     * all indexes of sibling nodes having index greater or equal.
+     * @param path child path
+     * @param id node id
+     */
+    private void insert(Path path, ItemId id) throws PathNotFoundException {
+        synchronized (cacheMonitor) {
+            PathMap.Element element = null;
+
+            LRUEntry entry = (LRUEntry) idCache.get(id);
+            if (entry != null) {
+                element = entry.getElement();
+                element.remove();
+            }
+
+            PathMap.Element parent = pathCache.map(path.getAncestor(1), true);
+            if (parent != null) {
+                parent.insert(path.getNameElement());
+            }
+            if (element != null) {
+                pathCache.put(path, element);
+
+                /* Remember this as a move */
+                movedIds.add(id);
+            }
+        }
+    }
+
+    /**
+     * Remove an item from the cache in order to shift the indexes
+     * of items following this item.
+     * @param path child path
+     * @param id node id
+     */
+    private void remove(Path path, ItemId id) throws PathNotFoundException {
+        synchronized (cacheMonitor) {
+            /* If we remembered this as a move, ignore this event */
+            if (movedIds.remove(id)) {
+                return;
+            }
+            PathMap.Element parent = pathCache.map(path.getAncestor(1), true);
+            if (parent != null) {
+                PathMap.Element element = parent.remove(path.getNameElement());
+                if (element != null) {
+                    evict(element);
+                }
+            }
+        }
+    }
+
+    /**
+     * Entry in the LRU list
+     */
+    private class LRUEntry {
+
+        /**
+         * Previous entry
+         */
+        private LRUEntry previous;
+
+        /**
+         * Next entry
+         */
+        private LRUEntry next;
+
+        /**
+         * Item id
+         */
+        private final ItemId id;
+
+        /**
+         * Element in path map
+         */
+        private final PathMap.Element element;
+
+        /**
+         * Create a new instance of this class
+         * @param id item id
+         */
+        public LRUEntry(ItemId id, PathMap.Element element) {
+            this.id = id;
+            this.element = element;
+
+            append();
+        }
+
+        /**
+         * Append entry to end of LRU list
+         */
+        public void append() {
+            if (tail == null) {
+                head = tail = this;
+            } else {
+                previous = tail;
+                tail.next = this;
+                tail = this;
+            }
+        }
+
+        /**
+         * Remove entry from LRU list
+         */
+        public void remove() {
+            if (previous != null) {
+                previous.next = next;
+            }
+            if (next != null) {
+                next.previous = previous;
+            }
+            if (head == this) {
+                head = next;
+            }
+            if (tail == this) {
+                tail = previous;
+            }
+            previous = next = null;
+        }
+
+        /**
+         * Touch entry. Removes it from its current position in the LRU list
+         * and moves it to the end.
+         */
+        public void touch() {
+            remove();
+            append();
+        }
+
+        /**
+         * Return previous LRU entry
+         * @return previous LRU entry
+         */
+        public LRUEntry getPrevious() {
+            return previous;
+        }
+
+        /**
+         * Return next LRU entry
+         * @return next LRU entry
+         */
+        public LRUEntry getNext() {
+            return next;
+        }
+
+        /**
+         * Return item ID
+         * @return item ID
+         */
+        public ItemId getId() {
+            return id;
+        }
+
+        /**
+         * Return element in path map
+         * @return element in path map
+         */
+        public PathMap.Element getElement() {
+            return element;
+        }
-

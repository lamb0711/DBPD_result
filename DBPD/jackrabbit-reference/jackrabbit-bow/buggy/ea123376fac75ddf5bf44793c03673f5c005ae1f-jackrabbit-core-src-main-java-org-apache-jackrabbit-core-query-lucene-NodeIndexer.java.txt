JCR-1878: Use Apache Tika for text extraction

Replace jackrabbit-text-extractors with a direct Apache Tika dependency.

A simple backwards compatibility layer is included for existing textFilterClasses="..." configurations. Only the org.apache.jackrabbit.extractor classes are recognized and mapped to Tika alternatives.

Added two simple text extraction integration tests.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@815774 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.id.PropertyId;
-import org.apache.jackrabbit.core.id.NodeId;
-import org.apache.jackrabbit.core.state.ItemStateException;
-import org.apache.jackrabbit.core.state.ItemStateManager;
-import org.apache.jackrabbit.core.state.NoSuchItemStateException;
-import org.apache.jackrabbit.core.state.NodeState;
-import org.apache.jackrabbit.core.state.PropertyState;
-import org.apache.jackrabbit.core.state.ChildNodeEntry;
-import org.apache.jackrabbit.core.value.InternalValue;
-import org.apache.jackrabbit.extractor.TextExtractor;
-import org.apache.jackrabbit.spi.commons.conversion.NamePathResolver;
-import org.apache.jackrabbit.spi.Path;
-import org.apache.jackrabbit.spi.Name;
-import org.apache.jackrabbit.spi.commons.name.NameConstants;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.document.Fieldable;
+import java.math.BigDecimal;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.Executor;
-import java.io.InputStream;
-import java.io.Reader;
-import java.util.Calendar;
-import java.util.Set;
-import java.util.List;
-import java.util.ArrayList;
-import java.util.Date;
-import java.net.URI;
-import java.math.BigDecimal;
+import org.apache.jackrabbit.core.id.NodeId;
+import org.apache.jackrabbit.core.id.PropertyId;
+import org.apache.jackrabbit.core.state.ChildNodeEntry;
+import org.apache.jackrabbit.core.state.ItemStateException;
+import org.apache.jackrabbit.core.state.ItemStateManager;
+import org.apache.jackrabbit.core.state.NoSuchItemStateException;
+import org.apache.jackrabbit.core.state.NodeState;
+import org.apache.jackrabbit.core.state.PropertyState;
+import org.apache.jackrabbit.core.value.InternalValue;
+import org.apache.jackrabbit.spi.Name;
+import org.apache.jackrabbit.spi.Path;
+import org.apache.jackrabbit.spi.commons.conversion.NamePathResolver;
+import org.apache.jackrabbit.spi.commons.name.NameConstants;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.Fieldable;
+import org.apache.tika.metadata.Metadata;
+import org.apache.tika.parser.Parser;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
-     * Content extractor.
+     * Background task executor used for full text extraction.
-    protected final TextExtractor extractor;
+    private final Executor executor;
+
+    /**
+     * Parser used for extracting text content from binary properties
+     * for full text indexing.
+     */
+    private final Parser parser;
-     * @param extractor     content extractor
+     * @param executor      background task executor for text extraction
+     * @param parser        parser for binary properties
-    public NodeIndexer(NodeState node,
-                       ItemStateManager stateProvider,
-                       NamespaceMappings mappings,
-                       TextExtractor extractor) {
+    public NodeIndexer(
+            NodeState node, ItemStateManager stateProvider,
+            NamespaceMappings mappings, Executor executor, Parser parser) {
-        this.extractor = extractor;
+        this.executor = executor;
+        this.parser = parser;
-            InternalValue typeValue = getValue(NameConstants.JCR_MIMETYPE);
-            if (typeValue != null) {
-                String type = typeValue.getString();
+            InternalValue type = getValue(NameConstants.JCR_MIMETYPE);
+            if (type != null) {
+                Metadata metadata = new Metadata();
+                metadata.set(Metadata.CONTENT_TYPE, type.getString());
-                String encoding = null;
-                InternalValue encodingValue = getValue(NameConstants.JCR_ENCODING);
-                if (encodingValue != null) {
-                    encoding = encodingValue.getString();
+                InternalValue encoding = getValue(NameConstants.JCR_ENCODING);
+                if (encoding != null) {
+                    metadata.set(
+                            Metadata.CONTENT_ENCODING, encoding.getString());
-                InputStream stream = internalValue.getStream();
-                Reader reader = extractor.extractText(stream, type, encoding);
-                doc.add(createFulltextField(reader));
+                doc.add(createFulltextField(internalValue, metadata));
-     * @param value the reader value.
+     * @param value the binary value
+     * @param metadata document metatadata
-    protected Fieldable createFulltextField(Reader value) {
-        if (supportHighlighting) {
-            return new LazyTextExtractorField(FieldNames.FULLTEXT, value, true, true);
-        } else {
-            return new LazyTextExtractorField(FieldNames.FULLTEXT, value, false, false);
-        }
+    protected Fieldable createFulltextField(
+            InternalValue value, Metadata metadata) {
+        return new LazyTextExtractorField(
+                parser, value, metadata, executor, supportHighlighting);

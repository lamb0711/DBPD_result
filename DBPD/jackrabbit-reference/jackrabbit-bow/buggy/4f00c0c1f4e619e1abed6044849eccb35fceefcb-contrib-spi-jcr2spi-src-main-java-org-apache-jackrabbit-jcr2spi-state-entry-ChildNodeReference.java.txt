work in progress

JCR2SPI
--------------------------------------------------------------

- reorder ItemState/NodeState/PropertyState in order to group
  methods by state types (overlayed workspace state vs. session/transient states)
- add utility methods that allow to determine and validate the
  type of ItemState.
- move childitementry classes to separate package and force usage
  of interface methods
- add checks for state type to ItemManager implementation
- add checks for state type to LockManager
- fix Node.getMixinTypes()
- rename ItemState.pull to 'reset'. remove todo asking for a careful
  merging of wsp-State and introduce a new method 'merge'.

SPI
--------------------------------------------------------------------

- rename login as suggested by julian
- add method dispose(SessionInfo) 
- rename ItemId.getRelativePath to getPath

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@454423 13f79535-47bb-0310-9956-ffa450edef68

-package org.apache.jackrabbit.jcr2spi.state;
+package org.apache.jackrabbit.jcr2spi.state.entry;
+import org.apache.jackrabbit.jcr2spi.state.NodeState;
+import org.apache.jackrabbit.jcr2spi.state.ItemStateFactory;
+import org.apache.jackrabbit.jcr2spi.state.NoSuchItemStateException;
+import org.apache.jackrabbit.jcr2spi.state.ItemStateException;
-abstract class ChildNodeReference extends ChildItemReference implements ChildNodeEntry {
-
-    /**
-     * Creates a new <code>ChildNodeReference</code> with the given parent
-     * <code>NodeState</code>.
-     *
-     * @param parent the <code>NodeState</code> that owns this child node
-     *               reference.
-     * @param name   the name of the child item.
-     * @param isf    the item state factory to create the item state.
-     */
-    public ChildNodeReference(NodeState parent, QName name, ItemStateFactory isf) {
-        super(parent, name, isf);
-    }
+public abstract class ChildNodeReference extends ChildItemReference implements ChildNodeEntry {
+     * @return
+     * Creates a <code>ChildNodeEntry</code> instance based on
+     *  <code>nodeName</code> and an optional <code>uuid</code>.
+     *
+     * @param parent
+     * @param childName
+     * @param childUUID
+     * @param isf
+     * @param idFactory
+     * @return
+     */
+    public static ChildNodeEntry create(NodeState parent, QName childName,
+                                        String childUUID, ItemStateFactory isf,
+                                        IdFactory idFactory) {
+        if (childUUID == null) {
+            return new PathElementReference(parent, childName, isf, idFactory);
+        } else {
+            return new UUIDReference(parent, idFactory.createNodeId(childUUID), isf, childName);
+        }
+    }
+
+    /**
+     * Creates a new <code>ChildNodeReference</code> with the given parent
+     * <code>NodeState</code>.
+     *
+     * @param parent the <code>NodeState</code> that owns this child node
+     *               reference.
+     * @param name   the name of the child item.
+     * @param isf    the item state factory to create the item state.
+     */
+    ChildNodeReference(NodeState parent, QName name, ItemStateFactory isf) {
+        super(parent, name, isf);
+    }
+
+
+    /**
-    protected ChildNodeReference(NodeState child, ItemStateFactory isf) {
-        super(child.getParent(), child, child.getName(), isf);
+    ChildNodeReference(NodeState child, ItemStateFactory isf) {
+        super(child.getParent(), child, child.getQName(), isf);

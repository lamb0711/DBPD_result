JCR-1972: Preserving UUID and document version history on repository migration

Prepare to add the new checkin() signatures by cleaning up the deprecated versioning methods in NodeImpl.

Added a NodeImpl.getNodeState() method to avoid extra type casting.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@800478 13f79535-47bb-0310-9956-ffa450edef68

+import javax.jcr.version.VersionManager;
+import static org.apache.jackrabbit.spi.commons.name.NameConstants.JCR_ISCHECKEDOUT;
+     * Returns the node-state associated with this node.
+     *
+     * @return state associated with this node
+     */
+    NodeState getNodeState() {
+        return data.getNodeState();
+    }
+
+    /**
-        ChildNodeEntry entry = ((NodeState) parentNode.getItemState()).
-                getChildNodeEntry(getNodeId());
+        ChildNodeEntry entry =
+            parentNode.getNodeState().getChildNodeEntry(getNodeId());
-    public void update(String srcWorkspaceName)
-            throws NoSuchWorkspaceException, AccessDeniedException,
-            LockException, InvalidItemStateException, RepositoryException {
-        ((VersionManagerImpl) session.getWorkspace().getVersionManager()).update(this, srcWorkspaceName);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    public Version checkin()
-            throws VersionException, UnsupportedRepositoryOperationException,
-            InvalidItemStateException, LockException, RepositoryException {
-        return session.getWorkspace().getVersionManager().checkin(getPath());
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    public void checkout()
-            throws UnsupportedRepositoryOperationException, LockException,
-            RepositoryException {
-        session.getWorkspace().getVersionManager().checkout(getPath());
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    public NodeIterator merge(String srcWorkspace, boolean bestEffort)
-            throws NoSuchWorkspaceException, AccessDeniedException,
-            VersionException, LockException, InvalidItemStateException,
-            RepositoryException {
-        return session.getWorkspace().getVersionManager().merge(getPath(), srcWorkspace, bestEffort);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    public void cancelMerge(Version version)
-            throws VersionException, InvalidItemStateException,
-            UnsupportedRepositoryOperationException, RepositoryException {
-        session.getWorkspace().getVersionManager().cancelMerge(getPath(), version);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    public void doneMerge(Version version) throws VersionException,
-            InvalidItemStateException, UnsupportedRepositoryOperationException,
-            RepositoryException {
-        session.getWorkspace().getVersionManager().doneMerge(getPath(), version);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-        return internalIsCheckedOut();
-    }
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    public void restore(String versionName, boolean removeExisting)
-            throws VersionException, ItemExistsException,
-            UnsupportedRepositoryOperationException, LockException,
-            InvalidItemStateException, RepositoryException {
-
-        // checks
-        sanityCheck();
-        session.getWorkspace().getVersionManager().restore(getPath(), versionName, removeExisting);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    public void restore(Version version, boolean removeExisting)
-            throws VersionException, ItemExistsException,
-            UnsupportedRepositoryOperationException, LockException,
-            RepositoryException {
-
-        // do checks
-        sanityCheck();
-        session.getWorkspace().getVersionManager().restore(getPath(), version, removeExisting);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    public void restore(Version version, String relPath, boolean removeExisting)
-            throws PathNotFoundException, ItemExistsException, VersionException,
-            ConstraintViolationException, UnsupportedRepositoryOperationException,
-            LockException, InvalidItemStateException, RepositoryException {
-
-        // do checks
-        sanityCheck();
-        String path = getPath() + "/" + relPath;
-        session.getWorkspace().getVersionManager().restore(path, version, removeExisting);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    public void restoreByLabel(String versionLabel, boolean removeExisting)
-            throws VersionException, ItemExistsException,
-            UnsupportedRepositoryOperationException, LockException,
-            InvalidItemStateException, RepositoryException {
-
-        // do checks
-        sanityCheck();
-        session.getWorkspace().getVersionManager().restoreByLabel(getPath(), versionLabel, removeExisting);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    public VersionHistory getVersionHistory()
-            throws UnsupportedRepositoryOperationException, RepositoryException {
-        sanityCheck();
-        return session.getWorkspace().getVersionManager().getVersionHistory(getPath());
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    public Version getBaseVersion()
-            throws UnsupportedRepositoryOperationException, RepositoryException {
-        // check state of this instance
-        sanityCheck();
-        return session.getWorkspace().getVersionManager().getBaseVersion(getPath());
-    }
-
-    //-----------------------------------< versioning support: implementation >
-    /**
-     * Determines the checked-out status of this node.
-     * <p/>
-     * A node is considered <i>checked-out</i> if it is versionable and
-     * checked-out, or is non-versionable but its nearest versionable ancestor
-     * is checked-out, or is non-versionable and there are no versionable
-     * ancestors.
-     *
-     * @return a boolean
-     * @see Node#isCheckedOut()
-     * @throws RepositoryException if an error occurs
-     */
-    protected boolean internalIsCheckedOut() throws RepositoryException {
-        /**
-         * try shortcut first:
-         * if current node is 'new' we can safely consider it checked-out
-         * since otherwise it would had been impossible to add it in the first
-         * place
-         */
+        // try shortcut first:
+        // if current node is 'new' we can safely consider it checked-out since
+        // otherwise it would had been impossible to add it in the first place
-        /**
-         * FIXME should not only rely on existence of jcr:isCheckedOut property
-         * but also verify that node.isNodeType("mix:versionable")==true;
-         * this would have a negative impact on performance though...
-         */
+        // FIXME should not only rely on existence of jcr:isCheckedOut property
+        // but also verify that node.isNodeType("mix:versionable")==true;
+        // this would have a negative impact on performance though...
-            NodeState state = (NodeState) getItemState();
-            while (!state.hasPropertyName(NameConstants.JCR_ISCHECKEDOUT)) {
+            NodeState state = getNodeState();
+            while (!state.hasPropertyName(JCR_ISCHECKEDOUT)) {
-                state = (NodeState) session.getItemStateManager().getItemState(parentId);
+                state = (NodeState)
+                    session.getItemStateManager().getItemState(parentId);
-            PropertyState ps = (PropertyState) session.getItemStateManager().getItemState(new PropertyId(state.getNodeId(), NameConstants.JCR_ISCHECKEDOUT));
+            PropertyId id = new PropertyId(state.getNodeId(), JCR_ISCHECKEDOUT);
+            PropertyState ps =
+                (PropertyState) session.getItemStateManager().getItemState(id);
-            throw new RepositoryException(e.getMessage());
+            throw new RepositoryException(e);
+    /**
+     * Returns the version manager of this workspace.
+     */
+    private VersionManagerImpl getVersionManagerImpl() {
+        return session.getWorkspaceImpl().getVersionManagerImpl();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void update(String srcWorkspaceName) throws RepositoryException {
+        getVersionManagerImpl().update(this, srcWorkspaceName);
+    }
+
+    /**
+     * Use {@link VersionManager#checkin(String)} instead
+     */
+    @Deprecated
+    public Version checkin() throws RepositoryException {
+        return getVersionManagerImpl().checkin(getPath());
+    }
+
+    /**
+     * Use {@link VersionManager#checkout(String)} instead
+     */
+    @Deprecated
+    public void checkout() throws RepositoryException {
+        getVersionManagerImpl().checkout(getPath());
+    }
+
+    /**
+     * Use {@link VersionManager#merge(String, String, boolean)} instead
+     */
+    @Deprecated
+    public NodeIterator merge(String srcWorkspace, boolean bestEffort)
+            throws RepositoryException {
+        return getVersionManagerImpl().merge(
+                getPath(), srcWorkspace, bestEffort);
+    }
+
+    /**
+     * Use {@link VersionManager#cancelMerge(String, Version)} instead
+     */
+    @Deprecated
+    public void cancelMerge(Version version) throws RepositoryException {
+        getVersionManagerImpl().cancelMerge(getPath(), version);
+    }
+
+    /**
+     * Use {@link VersionManager#doneMerge(String, Version)} instead
+     */
+    @Deprecated
+    public void doneMerge(Version version) throws RepositoryException {
+        getVersionManagerImpl().doneMerge(getPath(), version);
+    }
+
+    /**
+     * Use {@link VersionManager#restore(String, String, boolean)} instead
+     */
+    @Deprecated
+    public void restore(String versionName, boolean removeExisting)
+            throws RepositoryException {
+        getVersionManagerImpl().restore(getPath(), versionName, removeExisting);
+    }
+
+    /**
+     * Use {@link VersionManager#restore(String, Version, boolean)} instead
+     */
+    @Deprecated
+    public void restore(Version version, boolean removeExisting)
+            throws RepositoryException {
+        getVersionManagerImpl().restore(getPath(), version, removeExisting);
+    }
+
+    /**
+     * Use {@link VersionManager#restore(String, Version, boolean)} instead
+     */
+    @Deprecated
+    public void restore(Version version, String relPath, boolean removeExisting)
+            throws RepositoryException {
+        getVersionManagerImpl().restore(
+                getPath() + "/" + relPath, version, removeExisting);
+    }
+
+    /**
+     * Use {@link VersionManager#restoreByLabel(String, String, boolean)}
+     * instead
+     */
+    @Deprecated
+    public void restoreByLabel(String versionLabel, boolean removeExisting)
+            throws RepositoryException {
+        getVersionManagerImpl().restoreByLabel(
+                getPath(), versionLabel, removeExisting);
+    }
+
+    /**
+     * Use {@link VersionManager#getVersionHistory(String)} instead
+     */
+    @Deprecated
+    public VersionHistory getVersionHistory() throws RepositoryException {
+        return getVersionManagerImpl().getVersionHistory(getPath());
+    }
+
+    /**
+     * Use {@link VersionManager#getBaseVersion(String)} instead
+     */
+    @Deprecated
+    public Version getBaseVersion() throws RepositoryException {
+        return getVersionManagerImpl().getBaseVersion(getPath());
+    }
+

Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.state.entry.ChildNodeEntry;
-import org.apache.jackrabbit.jcr2spi.state.PropertyState;
-import org.apache.jackrabbit.jcr2spi.state.ItemState;
-import org.apache.jackrabbit.jcr2spi.state.ItemStateManager;
+import org.apache.jackrabbit.jcr2spi.state.NodeReferences;
+import org.apache.jackrabbit.jcr2spi.state.Status;
+import org.apache.jackrabbit.jcr2spi.state.PropertyState;
+import org.apache.jackrabbit.jcr2spi.util.StateUtility;
+import org.apache.jackrabbit.jcr2spi.hierarchy.NodeEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.PropertyEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.HierarchyEntry;
-import org.apache.jackrabbit.spi.ItemId;
-import javax.jcr.Repository;
-import java.util.Collection;
-    private NodeDefinition definition;
-                       NodeState state, NodeDefinition definition,
-                       ItemLifeCycleListener[] listeners) {
+                       NodeState state, ItemLifeCycleListener[] listeners) {
-        this.definition = definition;
-     * @see Item#getParent()
-     */
-    public Node getParent() throws ItemNotFoundException, AccessDeniedException, RepositoryException {
-        checkStatus();
-
-        NodeState parentState = getItemState().getParent();
-        // special treatment for root node
-        if (parentState == null) {
-            String msg = "Root node doesn't have a parent.";
-            log.debug(msg);
-            throw new ItemNotFoundException(msg);
-        }
-
-        return (Node) itemMgr.getItem(parentState);
-    }
-
-    /**
-                // create and remove property is a nop.
-                // TODO: check if is correct to avoid any validation exception
-                prop = null;
+                // create and remove property is not valid // TODO: correct?
+                throw new ItemNotFoundException("Cannot remove a non-existing property.");
-                // TODO: check if is correct to avoid any validation exception
-                prop = null;
+                throw new ItemNotFoundException("Cannot remove a non-existing property.");
-        NodeState state = resolveRelativeNodePath(relPath);
-        if (state == null) {
+        NodeEntry nodeEntry = resolveRelativeNodePath(relPath);
+        if (nodeEntry == null) {
-        return (Node) itemMgr.getItem(state);
+        try {
+            return (Node) itemMgr.getItem(nodeEntry);
+        } catch (ItemNotFoundException e) {
+            throw new PathNotFoundException(relPath, e);
+        }
-            return itemMgr.getChildNodes(getNodeState());
+            return itemMgr.getChildNodes(getNodeEntry());
-        PropertyState state = resolveRelativePropertyPath(relPath);
-        if (state == null) {
+        PropertyEntry entry = resolveRelativePropertyPath(relPath);
+        if (entry == null) {
-        return (Property) itemMgr.getItem(state);
+        try {
+            return (Property) itemMgr.getItem(entry);
+        } catch (AccessDeniedException e) {
+            throw new PathNotFoundException(relPath.toString());
+        } catch (ItemNotFoundException e) {
+            throw new PathNotFoundException(relPath.toString());
+        }
-            return itemMgr.getChildProperties(getNodeState());
+            return itemMgr.getChildProperties(getNodeEntry());
-        return getNodeState().getIndex();
+        int index = getNodeEntry().getIndex();
+        if (index == Path.INDEX_UNDEFINED) {
+            throw new RepositoryException("Error while retrieving index.");
+        }
+        return index;
+        NodeReferences refs = getNodeState().getNodeReferences();
+        if (refs.isEmpty()) {
+            // there are no references, return empty iterator
+            return IteratorHelper.EMPTY;
+        } else {
+            return new LazyItemIterator(itemMgr, session.getHierarchyManager(), refs.iterator());
+        }
+        /*
+        */
-        NodeState childState = resolveRelativeNodePath(relPath);
-        return (childState != null) ? itemMgr.itemExists(childState) : false;
+        NodeEntry nodeEntry = resolveRelativeNodePath(relPath);
+        return (nodeEntry != null) ? itemMgr.itemExists(nodeEntry) : false;
-        PropertyState childState = resolveRelativePropertyPath(relPath);
-        return (childState != null) ? itemMgr.itemExists(childState) : false;
+        PropertyEntry childEntry = resolveRelativePropertyPath(relPath);
+        return (childEntry != null) ? itemMgr.itemExists(childEntry) : false;
-        return getNodeState().hasPropertyName(propertyName);
+        return getNodeEntry().hasPropertyEntry(propertyName);
-        return itemMgr.hasChildNodes(getNodeState());
+        return itemMgr.hasChildNodes(getNodeEntry());
-        return itemMgr.hasChildProperties(getNodeState());
+        return itemMgr.hasChildProperties(getNodeEntry());
-        checkStatus();        
+        checkStatus();
-            if (!isValidMixin(mixinQName)) {
+            if (!canAddMixin(mixinQName)) {
-        // merge existing mixins and new mixins to one Array without modifying
-        // the node state.
-        QName[] currentMixins = getNodeState().getMixinTypeNames();
-        QName[] allMixins = new QName[currentMixins.length + 1];
-        System.arraycopy(currentMixins, 0, allMixins, 0, currentMixins.length);
-        allMixins[currentMixins.length] = mixinQName;
-        // perform the operation
-        Operation op = SetMixin.create(getNodeState(), allMixins);
-        session.getSessionItemStateManager().execute(op);
+        // get mixin types present in the jcr:mixintypes property without
+        // modifying the NodeState.
+        List mixinValue = getMixinTypes();
+        if (mixinValue.contains(mixinQName)) {
+            log.warn("Mixin " + mixinName + " has already been transiently added -> Ignored.");
+            return;
+        } else {
+            mixinValue.add(mixinQName);
+            // perform the operation
+            Operation op = SetMixin.create(getNodeState(), (QName[]) mixinValue.toArray(new QName[mixinValue.size()]));
+            session.getSessionItemStateManager().execute(op);
+        }
-        List remainingMixins = new ArrayList(Arrays.asList(getNodeState().getMixinTypeNames()));
+        List mixinValue = getMixinTypes();
-        if (!remainingMixins.remove(ntName)) {
+        if (!mixinValue.remove(ntName)) {
-        // build effective node type of remaining mixin's & primary type
-        NodeTypeManagerImpl ntMgr = session.getNodeTypeManager();
-        EffectiveNodeType entRemaining;
-
-        // build effective node type representing primary type including remaining mixin's
-        QName[] allRemaining = (QName[]) remainingMixins.toArray(new QName[remainingMixins.size() + 1]);
-        allRemaining[remainingMixins.size()] = primaryTypeName;
-        try {
-            entRemaining = session.getValidator().getEffectiveNodeType(allRemaining);
-        } catch (NodeTypeConflictException e) {
-            throw new ConstraintViolationException(e);
-        }
-
-        NodeTypeImpl mixin = ntMgr.getNodeType(ntName);
-        if (mixin.isNodeType(QName.MIX_REFERENCEABLE) && !entRemaining.includesNodeType(QName.MIX_REFERENCEABLE)) {
-            PropertyIterator iter = getReferences();
-            if (iter.hasNext()) {
-                throw new ConstraintViolationException("Mixin type " + mixinName + " can not be removed: the node is being referenced through at least one property of type REFERENCE");
+        NodeTypeImpl mixin = session.getNodeTypeManager().getNodeType(ntName);
+        if (mixin.isNodeType(QName.MIX_REFERENCEABLE)) {
+            // build effective node type of remaining mixin's & primary type
+            EffectiveNodeType entRemaining;
+            QName[] allRemaining = (QName[]) mixinValue.toArray(new QName[mixinValue.size() + 1]);
+            allRemaining[mixinValue.size()] = primaryTypeName;
+            try {
+                entRemaining = session.getValidator().getEffectiveNodeType(allRemaining);
+            } catch (NodeTypeConflictException e) {
+                throw new ConstraintViolationException(e);
+            }
+
+            if (!entRemaining.includesNodeType(QName.MIX_REFERENCEABLE)) {
+                PropertyIterator iter = getReferences();
+                if (iter.hasNext()) {
+                    throw new ConstraintViolationException("Mixin type " + mixinName + " can not be removed: the node is being referenced through at least one property of type REFERENCE");
+                }
-        QName[] mixins = (QName[]) remainingMixins.toArray(new QName[remainingMixins.size()]);
+        QName[] mixins = (QName[]) mixinValue.toArray(new QName[mixinValue.size()]);
+     * Retrieves all mixins currently present on this node including those,
+     * that have been transiently added and excluding those, that have been
+     * transiently removed.<br>
+     * NOTE, that the result of this method, does NOT represent the list of
+     * mixin-types that currently affect this node. Instead if represents the
+     * current value of the jcr:mixinTypes property.
+     *
+     * @return
+     */
+    private List getMixinTypes() {
+        QName[] mixinValue = new QName[0];
+        if (getNodeEntry().hasPropertyEntry(QName.JCR_MIXINTYPES)) {
+            if (getNodeState().getStatus() == Status.EXISTING) {
+                mixinValue = getNodeState().getMixinTypeNames();
+            } else {
+                // possibility that a mixin has been transient added
+                try {
+                    PropertyState ps = getNodeState().getPropertyState(QName.JCR_MIXINTYPES);
+                    mixinValue = StateUtility.getMixinNames(ps);
+                } catch (ItemStateException e) {
+                    // should never occur
+                    log.error("Internal error", e);
+                }
+            } // else: no mixins present
+        }
+        List l = new ArrayList();
+        l.addAll(Arrays.asList(mixinValue));
+        return l;
+    }
+
+    /**
-        checkStatus();
-        if (!isSupportedOption(Repository.LEVEL_2_SUPPORTED)) {
+        if (!isWritable()) {
-            return isValidMixin(getQName(mixinName));
+            return canAddMixin(getQName(mixinName));
-        return definition;
+        QNodeDefinition qnd = getNodeState().getDefinition();
+        return session.getNodeTypeManager().getNodeDefinition(qnd);
-        // make sure the specified workspace is visible for the current session.
-        session.checkAccessibleWorkspace(srcWorkspaceName);
+        // test if the corresponding node exists in the src-workspace which includes
+        // a check if the specified source workspace is accessible
+        try {
+            getCorrespondingNodePath(srcWorkspaceName);
+        } catch (ItemNotFoundException e) {
+            // no corresponding node exists -> method has not effect
+            return;
+        }
-            List failedStates = new ArrayList();
-            while (failedIds.hasNext()) {
-                try {
-                    ItemId id = failedIds.nextId();
-                    ItemState state = session.getItemStateManager().getItemState(id);
-                    if (state.isNode()) {
-                        failedStates.add(state);
-                    } else {
-                        // should not occur
-                        throw new RepositoryException("Merge failed with internal error: NodeState expected.");
-                    }
-                } catch (ItemStateException e) {
-                    // should not occur
-                    throw new RepositoryException(e);
-                }
-            }
-            if (failedStates.isEmpty()) {
-                return IteratorHelper.EMPTY;
-            } else {
-                return new LazyItemIterator(itemMgr, failedStates);
-            }
+            return new LazyItemIterator(itemMgr, session.getHierarchyManager(), failedIds);
+        // NEW nodes with inherited-mixins -> mixin not yet active
+        if (getNodeState().getStatus() == Status.NEW &&
+            session.getNodeTypeManager().getNodeType(qName).isMixin()) {
+            return false;
+        }
+
-        if (getNodeState().getParent() == null) {
+        if (getNodeState().isRoot()) {
-        NodeState childState;
-        try {
-            List cne = getNodeState().getChildNodeEntries(nodeName);
-            if (definition.allowsSameNameSiblings()) {
-                // TODO TOBEFIXED find proper solution. problem with SNSs
-                childState = ((ChildNodeEntry)cne.get(cne.size()-1)).getNodeState();
-            } else {
-                childState = ((ChildNodeEntry)cne.get(0)).getNodeState();
-            }
-        } catch (ItemStateException e) {
-            // should not occur
-            throw new RepositoryException(e);
+        NodeEntry entry;
+        List cne = getNodeEntry().getNodeEntries(nodeName);
+        if (definition.allowsSameNameSiblings()) {
+            // TODO TOBEFIXED find proper solution. problem with SNSs
+            entry = ((NodeEntry)cne.get(cne.size()-1));
+        } else {
+            entry = ((NodeEntry)cne.get(0));
-        return (Node) itemMgr.getItem(childState);
+        return (Node) itemMgr.getItem(entry);
-            PropertyState pState = getNodeState().getPropertyState(qName);
-            return (Property) itemMgr.getItem(pState);
-        } catch (AccessDeniedException ade) {
-            throw new ItemNotFoundException(qName.toString());
-        } catch (NoSuchItemStateException e) {
+            PropertyEntry pEntry = getNodeEntry().getPropertyEntry(qName);
+            if (pEntry == null) {
+                throw new PathNotFoundException(qName.toString());
+            }
+            return (Property) itemMgr.getItem(pEntry);
+        } catch (AccessDeniedException e) {
-        } catch (ItemStateException e) {
-            String msg = "Error while accessing property " + qName.toString();
-            throw new RepositoryException(msg, e);
+        } catch (ItemNotFoundException e) {
+            throw new PathNotFoundException(qName.toString());
-    private boolean isValidMixin(QName mixinName) throws NoSuchNodeTypeException, NodeTypeConflictException {
+    private boolean canAddMixin(QName mixinName) throws NoSuchNodeTypeException,
+        NodeTypeConflictException {
-        // get list of existing nodetypes
-        QName[] existingNts = getNodeState().getNodeTypeNames();
-        // build effective node type representing primary type including existing mixin's
-        EffectiveNodeType entExisting = session.getValidator().getEffectiveNodeType(existingNts);
-
+
+        // get list of existing nodetypes
+        QName[] existingNts = getNodeState().getNodeTypeNames();
+        // build effective node type representing primary type including existing mixin's
+        EffectiveNodeType entExisting = session.getValidator().getEffectiveNodeType(existingNts);
+
+     * @return <code>NodeEntry</code> of this <code>Node</code>
+     */
+    private NodeEntry getNodeEntry() {
+        return (NodeEntry) getItemState().getHierarchyEntry();
+    }
+
+    /**
-     * Returns the id of the node at <code>relPath</code> or <code>null</code>
-     * if no node exists at <code>relPath</code>.
+     * Returns the <code>NodeEntry</code> at <code>relPath</code> or
+     * <code>null</code> if no node exists at <code>relPath</code>.
-     * @return the state of the node at <code>relPath</code> or <code>null</code>
-     * if no node exists at <code>relPath</code>.
+     * @return the HierarchyEntry of the node at <code>relPath</code> or
+     * <code>null</code> if no node exists at <code>relPath</code>.
-    private NodeState resolveRelativeNodePath(String relPath) throws RepositoryException {
-        NodeState targetState = null;
+    private NodeEntry resolveRelativeNodePath(String relPath) throws RepositoryException {
+        NodeEntry targetEntry = null;
-                    targetState = getNodeState();
+                    targetEntry = getNodeEntry();
-                    targetState = getNodeState().getParent();
-                } else if (pe.denotesName()) {
-                    // if relative path is just a 'name' -> retrieve the corresponding
-                    // child-node (if existing).
-                    int index = pe.getNormalizedIndex();
-                    ChildNodeEntry cne = getNodeState().getChildNodeEntry(pe.getName(), index);
-                    if (cne != null) {
-                        targetState = cne.getNodeState();
-                    } // else: there's no child node with that name
+                    targetEntry = getNodeEntry().getParent();
+                } else {
+                    targetEntry = getNodeEntry().getNodeEntry(pe.getName(), pe.getNormalizedIndex());
-            } else {
+            }
+            if (targetEntry == null) {
+                // rp length > 1 OR child entry has not yet been loaded.
-                ItemState itemState = session.getHierarchyManager().getItemState(p.getCanonicalPath());
-                if (itemState.isNode()) {
-                    targetState = (NodeState) itemState;
+                HierarchyEntry entry = session.getHierarchyManager().getHierarchyEntry(p.getCanonicalPath());
+                if (entry.denotesNode()) {
+                    targetEntry = (NodeEntry) entry;
-        } catch (ItemStateException e) {
-            // should not occure
-            String msg = "Invalid relative path: " + relPath;
-            log.debug(msg);
-            throw new RepositoryException(msg, e);
-        return targetState;
+        return targetEntry;
-     * @return the state of the property at <code>relPath</code> or
+     * @return the PropertyEntry of the property at <code>relPath</code> or
-    private PropertyState resolveRelativePropertyPath(String relPath) throws RepositoryException {
-        PropertyState targetState = null;
+    private PropertyEntry resolveRelativePropertyPath(String relPath) throws RepositoryException {
+        PropertyEntry targetEntry = null;
-                    if (getNodeState().hasPropertyName(propName)) {
-                        try {
-                            targetState = getNodeState().getPropertyState(propName);
-                        } catch (ItemStateException e) {
-                            // should not occur due, since existance has been checked
-                            throw new RepositoryException(e);
-                        } // else: there's no property with that name
-                    }
-                } // else: return null.
-            } else {
+                    targetEntry = getNodeEntry().getPropertyEntry(propName);
+                } // else: entry may not have been loaded yet -> try via H-Mgr
+            }
+
+            if (targetEntry == null) {
-                    ItemState itemState = session.getHierarchyManager().getItemState(p);
-                    if (!itemState.isNode()) {
-                        targetState = (PropertyState) itemState;
+                    HierarchyEntry entry = session.getHierarchyManager().getHierarchyEntry(p);
+                    if (!entry.denotesNode()) {
+                        targetEntry = (PropertyEntry) entry;
-        return targetState;
+        return targetEntry;

JCR-2028: JSR 283 JCR Path

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@772659 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.QValue;
-import org.apache.jackrabbit.value.BooleanValue;
-import org.apache.jackrabbit.value.DateValue;
-import org.apache.jackrabbit.value.DoubleValue;
-import org.apache.jackrabbit.value.LongValue;
-import org.apache.jackrabbit.value.NameValue;
-import org.apache.jackrabbit.value.PathValue;
-import org.apache.jackrabbit.value.ReferenceValue;
+import org.apache.jackrabbit.spi.commons.value.ValueFactoryQImpl;
+import org.apache.jackrabbit.spi.commons.value.AbstractQValue;
+import org.apache.jackrabbit.spi.commons.value.QValueValue;
+import javax.jcr.Session;
+import javax.jcr.ValueFactory;
+import java.io.UnsupportedEncodingException;
-public class InternalValue {
+public class InternalValue extends AbstractQValue {
-    private Object val;
-    private final int type;
-
-        if (value == null) {
-            throw new IllegalArgumentException("null value");
-        }
-                    return create(resolver.getQName(value.getString()));
+                    if (value instanceof QValueValue) {
+                        QValue qv = ((QValueValue) value).getQValue();
+                        if (qv instanceof InternalValue) {
+                            return (InternalValue) qv;
+                        } else {
+                            return create(qv.getName());
+                        }
+                    } else {
+                        return create(resolver.getQName(value.getString()));
+                    }
-                    return create(resolver.getQPath(value.getString()));
+                    if (value instanceof QValueValue) {
+                        QValue qv = ((QValueValue) value).getQValue();
+                        if (qv instanceof InternalValue) {
+                            return (InternalValue) qv;
+                        } else {
+                            return create(qv.getPath());
+                        }
+                    } else {
+                        return create(resolver.getQPath(value.getString(), false));
+                    }
+     * @deprecated
-        switch (type) {
-            case PropertyType.BINARY:
-                return new BinaryValueImpl((BLOBFileValue) val);
-            case PropertyType.BOOLEAN:
-                return new BooleanValue(((Boolean) val));
-            case PropertyType.DATE:
-                return new DateValue((Calendar) val);
-            case PropertyType.DOUBLE:
-                return new DoubleValue((Double) val);
-            case PropertyType.LONG:
-                return new LongValue((Long) val);
-            case PropertyType.REFERENCE:
-                return ReferenceValue.valueOf(val.toString());
-            case PropertyType.PATH:
-                return PathValue.valueOf(resolver.getJCRPath((Path) val));
-            case PropertyType.NAME:
-                return NameValue.valueOf(resolver.getJCRName((Name) val), false);
-            case PropertyType.STRING:
-                return new StringValue((String) val);
-            default:
-                throw new RepositoryException("illegal internal value type");
+        ValueFactory vf;
+        if (resolver instanceof Session) {
+            vf = ((Session) resolver).getValueFactory();
+        } else {
+            vf = new ValueFactoryImpl(resolver);
+        }
+
+        if (vf instanceof ValueFactoryQImpl) {
+            return ((ValueFactoryQImpl) vf).createValue(this);
+        } else {
+            switch (type) {
+                case PropertyType.BINARY:
+                    return vf.createValue(((BLOBFileValue) val).getStream());
+                case PropertyType.BOOLEAN:
+                    return vf.createValue(((Boolean) val).booleanValue());
+                case PropertyType.DATE:
+                    return vf.createValue((Calendar) val);
+                case PropertyType.DOUBLE:
+                    return vf.createValue(((Double) val).doubleValue());
+                case PropertyType.LONG:
+                    return vf.createValue(((Long) val).longValue());
+                case PropertyType.REFERENCE:
+                    return vf.createValue(val.toString(), PropertyType.REFERENCE);
+                case PropertyType.PATH:
+                    return vf.createValue(resolver.getJCRPath((Path) val), PropertyType.PATH);
+                case PropertyType.NAME:
+                    return vf.createValue(resolver.getJCRName((Name) val), PropertyType.NAME);
+                case PropertyType.STRING:
+                    return new StringValue((String) val);
+                default:
+                    throw new RepositoryException("illegal internal value type");
+            }
-    public boolean getBoolean() {
-        assert val != null && type == PropertyType.BOOLEAN;
-        return ((Boolean) val).booleanValue();
-    }
-
-    public Path getPath() {
-        assert val != null && type == PropertyType.PATH;
-        return (Path) val;
-    }
-
-    public long getLong() {
-        assert val != null && type == PropertyType.LONG;
-        return ((Long) val).longValue();
-    }
-
-    public double getDouble() {
-        assert val != null && type == PropertyType.DOUBLE;
-        return ((Double) val).doubleValue();
-    }
-
-    public String getString() {
-        assert val != null && type == PropertyType.STRING;
-        return (String) val;
-    }
-
-    /**
-     * Get the type of this value.
-     *
-     * @return the type
-     */
-    public int getType() {
-        return type;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean equals(Object obj) {
-        if (this == obj) {
-            return true;
-        }
-        if (obj instanceof InternalValue) {
-            InternalValue other = (InternalValue) obj;
-            return val.equals(other.val);
-        }
-        return false;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public int hashCode() {
-        return val.hashCode();
-    }
-        val = value;
-        type = PropertyType.STRING;
+        super(value, PropertyType.STRING);
-        val = value;
-        type = PropertyType.NAME;
+        super(value);
-        val = new Long(value);
-        type = PropertyType.LONG;
+        super(new Long(value));
-        val = new Double(value);
-        type = PropertyType.DOUBLE;
+        super(new Double(value));
-        val = value;
-        type = PropertyType.DATE;
+        super(value, PropertyType.DATE);
-        val = Boolean.valueOf(value);
-        type = PropertyType.BOOLEAN;
+        super(Boolean.valueOf(value));
-        val = value;
-        type = PropertyType.BINARY;
+        super(value, PropertyType.BINARY);
-        val = value;
-        type = PropertyType.PATH;
+        super(value);
-        val = value;
-        type = PropertyType.REFERENCE;
+        super(value, PropertyType.REFERENCE);
+    //-------------------------------------------------------------< QValue >---
+    /**
+     * @see org.apache.jackrabbit.spi.QValue#getLength()
+     */
+    public long getLength() throws RepositoryException {
+        if (PropertyType.BINARY == type) {
+            return ((BLOBFileValue) val).getLength();
+        } else {
+            return super.getLength();
+        }
+    }
+
+    /**
+     * @see org.apache.jackrabbit.spi.QValue#getString()
+     */
+    public String getString() throws RepositoryException {
+        if (type == PropertyType.BINARY) {
+            return ((BLOBFileValue) val).getString();
+        } else if (type == PropertyType.DATE) {
+            return ISO8601.format(((Calendar) val));
+        } else {
+            return toString();
+        }
+    }
+
+    /**
+     * @see org.apache.jackrabbit.spi.QValue#getStream()
+     */
+    public InputStream getStream() throws RepositoryException {
+        if (type == PropertyType.BINARY) {
+            return ((BLOBFileValue) val).getStream();
+        } else {
+            try {
+                // convert via string
+                return new ByteArrayInputStream(getString().getBytes(InternalValueFactory.DEFAULT_ENCODING));
+            } catch (UnsupportedEncodingException e) {
+                throw new RepositoryException(InternalValueFactory.DEFAULT_ENCODING + " is not supported encoding on this platform", e);
+            }
+        }
+    }

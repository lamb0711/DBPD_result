- use seperate persistence manager for versioning

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@125924 13f79535-47bb-0310-9956-ffa450edef68

+        // check if versionable
+        checkVersionable();
+
+        // check if checked out
-            String msg = "Unable to checkin node. Is not checked-out. " + safeGetJCRPath();
+            String msg = safeGetJCRPath() + ": Node is already checked-in. ignoring.";
-            throw new VersionException(msg);
+            return getBaseVersion();
+
-            throw new IllegalStateException(msg);
+            throw new InvalidItemStateException(msg);
+
+        // check if not merge failed
+        if (hasProperty(ItemImpl.PROPNAME_MERGE_FAILED) && getProperty(ItemImpl.PROPNAME_MERGE_FAILED).getValues().length>0) {
+            String msg = "Unable to checkin node. Clear 'jcr:mergeFailed' first. " + safeGetJCRPath();
+            log.debug(msg);
+            throw new VersionException(msg);
+        }
+
+        // check if versionable
+        checkVersionable();
+
+        // check if already checked out
-            String msg = "Unable to checkout node. Is not checked-in. " + safeGetJCRPath();
+            String msg = safeGetJCRPath() + ": Node is already checked-out. ignoring.";
-            throw new VersionException(msg);
+            return;
+
+        // check transient state
+        if (isModified()) {
+            String msg = "Unable to checkout node. Not allowed on transient node. " + safeGetJCRPath();
+            log.debug(msg);
+            throw new InvalidItemStateException(msg);
+        }
+
-            if (node.isRepositoryRoot() || !inherit) {
+            if (!inherit || node.isRepositoryRoot()) {
+        boolean removeExisting = true;
-        if (!isCheckedOut()) {
-            String msg = "Unable to restore version. Node is not checked-out " + safeGetJCRPath();
-            log.debug(msg);
-            throw new VersionException(msg);
+        // check if transient
+        if (session.hasPendingChanges()) {
+            String msg = "Unable to restore version. Session has pending changes.";
+            log.error(msg);
+            throw new InvalidItemStateException(msg);
-        internalRestore(getVersionHistory().getVersion(versionName), gvs);
+        internalRestore(getVersionHistory().getVersion(versionName), gvs, removeExisting);
+        boolean removeExisting = true;
-        if (!isCheckedOut()) {
-            String msg = "Unable to restore version. Node is not checked-out " + safeGetJCRPath();
-            log.debug(msg);
-            throw new VersionException(msg);
+        // check if transient
+        if (session.hasPendingChanges()) {
+            String msg = "Unable to restore version. Session has pending changes.";
+            log.error(msg);
+            throw new InvalidItemStateException(msg);
-        internalRestore(version, new GenericVersionSelector(version.getCreated()));
+        internalRestore(version, new GenericVersionSelector(version.getCreated()), removeExisting);
+        boolean removeExisting = true;
+
+        // check if transient
+        if (session.hasPendingChanges()) {
+            String msg = "Unable to restore version. Session has pending changes.";
+            log.error(msg);
+            throw new InvalidItemStateException(msg);
+        }
+        } else {
+            // recreate node from frozen state
+            NodeImpl node = addNode(relPath, ((VersionImpl) version).getFrozenNode());
+            node.internalRestore(version, new GenericVersionSelector(version.getCreated()), removeExisting);
+            node.getParent().save();
-
-        // recreate node from frozen state
-        NodeImpl node = addNode(relPath, ((VersionImpl) version).getFrozenNode());
-        if (!node.isCheckedOut()) {
-            String msg = "Unable to restore version. Node is not checked-out " + node.safeGetJCRPath();
-            log.debug(msg);
-            throw new VersionException(msg);
-        }
-
-        node.internalRestore(version, new GenericVersionSelector(version.getCreated()));
-        node.getParent().save();
+        boolean removeExisting = false;
-        if (!isCheckedOut()) {
-            String msg = "Unable to restore version. Node is not checked-out " + safeGetJCRPath();
-            log.debug(msg);
-            throw new VersionException(msg);
+        // check if transient
+        if (session.hasPendingChanges()) {
+            String msg = "Unable to restore version. Session has pending changes.";
+            log.error(msg);
+            throw new InvalidItemStateException(msg);
-        internalRestore(v, new GenericVersionSelector(versionLabel));
+        internalRestore(v, new GenericVersionSelector(versionLabel), removeExisting);
-    private void internalRestore(Version version, VersionSelector vsel)
+    private void internalRestore(Version version, VersionSelector vsel, boolean removeExisting)
-        internalRestore(((VersionImpl) version).getInternalVersion(), vsel);
+        internalRestore(((VersionImpl) version).getInternalVersion(), vsel, removeExisting);
+    }
+
+    /**
+     * Checks if any frozen uuid in the given frozen node or its descendants
+     * collides with the one in the workspace. if 'removeExisting' is true,
+     * collisions will be removed, otherwise an ItemExistsException is thrown.
+     * If a frozen version history is already restored outside this nodes
+     * subtree, a exception is thrown, too, if the removeExisting is true.
+     * @param f
+     * @param removeExisting
+     * @throws RepositoryException
+     */
+    private void checkUUIDCollisions(InternalFrozenNode f, boolean removeExisting)
+            throws RepositoryException {
+
+        if (itemMgr.itemExists(new NodeId(f.getFrozenUUID()))) {
+            NodeImpl node = (NodeImpl) session.getNodeByUUID(f.getFrozenUUID());
+            if (removeExisting) {
+                node.remove();
+            } else {
+                throw new ItemExistsException("Unable to restore. UUID collides with " + node.safeGetJCRPath());
+            }
+        }
+        InternalFreeze[] fs = f.getFrozenChildNodes();
+        for (int i=0; i<fs.length; i++) {
+            if (fs[i] instanceof InternalFrozenNode) {
+                checkUUIDCollisions((InternalFrozenNode) fs[i], removeExisting);
+            } else if (!removeExisting) {
+                InternalFrozenVersionHistory fh = (InternalFrozenVersionHistory) fs[i];
+                VersionHistory history = (VersionHistory) session.getNodeByUUID(fh.getVersionHistoryId());
+                String nodeId = history.getName(); // this is implementation detail!
+
+                // check if representing vh already exists somewhere
+                if (itemMgr.itemExists(new NodeId(nodeId))) {
+                    NodeImpl n = (NodeImpl) session.getNodeByUUID(nodeId);
+                    try {
+                        if (!n.getPrimaryPath().isDescendantOf(getPrimaryPath())) {
+                            throw new ItemExistsException("Unable to restore. Same node already restored at " + n.safeGetJCRPath());
+                        }
+                    } catch (MalformedPathException e) {
+                        throw new RepositoryException(e);
+                    }
+                }
+            }
+        }
-     * @throws UnsupportedRepositoryOperationException
+     * @param removeExisting
-    private void internalRestore(InternalVersion version, VersionSelector vsel)
-            throws UnsupportedRepositoryOperationException, RepositoryException {
+    private void internalRestore(InternalVersion version, VersionSelector vsel, boolean removeExisting)
+            throws RepositoryException {
+
+        // first check, if any uuid conflicts would occurr
+        checkUUIDCollisions(version.getFrozenNode(), removeExisting);
+
+        // set jcr:isCheckedOut property to true, in order to avoid any conflicts
+        internalSetProperty(VersionManager.PROPNAME_IS_CHECKED_OUT, InternalValue.create(true));
-        restoreFrozenState(version.getFrozenNode(), vsel);
+        restoreFrozenState(version.getFrozenNode(), vsel, removeExisting);
-    void restoreFrozenState(InternalFrozenNode freeze, VersionSelector vsel)
+    void restoreFrozenState(InternalFrozenNode freeze, VersionSelector vsel, boolean removeExisting)
-            if (prop.getValues().length == 1) {
-                try {
-                    internalSetProperty(props[i].getName(), prop.getValues()[0]);
-                    continue;
-                } catch (RepositoryException e) {
-                    // ignore and try multiple below
-                }
+            if (prop.isMultiValued()) {
+                internalSetProperty(props[i].getName(), prop.getValues());
+            } else {
+                internalSetProperty(props[i].getName(), prop.getValues()[0]);
-            internalSetProperty(props[i].getName(), prop.getValues());
+
+        // first delete all non frozen version histories
+        NodeIterator iter = getNodes();
+        while (iter.hasNext()) {
+            NodeImpl n = (NodeImpl) iter.nextNode();
+            // this is a bit lousy
+            boolean found = false;
+            for (int i=0; i<frozenNodes.length; i++) {
+                InternalFreeze child = frozenNodes[i];
+                if (child instanceof InternalFrozenVersionHistory) {
+                    if (n.internalGetUUID().equals(child.getId())) {
+                        found = true;
+                        break;
+                    }
+                }
+            }
+            if (!found) {
+                n.remove();
+            }
+        }
-                // if frozen node exist, replace
-                // todo: make work for same name siblings
-                if (hasNode(f.getName())) {
-                    getNode(f.getName()).remove();
-                }
-                n.restoreFrozenState(f, vsel);
+                n.restoreFrozenState(f, vsel, removeExisting);
-                // check if child already exists
-                if (hasNode(child.getName())) {
-                    // do nothing
+                InternalFrozenVersionHistory f = (InternalFrozenVersionHistory) child;
+                VersionHistory history = (VersionHistory) session.getNodeByUUID(f.getVersionHistoryId());
+                String nodeId = history.getName(); // this is implementation detail!
+
+                // check if representing vh already exists somewhere
+                if (itemMgr.itemExists(new NodeId(nodeId))) {
+                    NodeImpl n = (NodeImpl) session.getNodeByUUID(nodeId);
+                    if (hasNode(n.getQName())) {
+                        // so order at end
+                        orderBefore(n.getName(), "");
+                    } else {
+                        session.move(n.getPath(), getPath()+ "/" + n.getName());
+                    }
-                    VersionHistory history = (VersionHistory) session.getNodeByUUID(((InternalFrozenVersionHistory) child).getVersionHistoryId());
-                    node.internalRestore(v, vsel);
+                    node.internalRestore(v, vsel, removeExisting);

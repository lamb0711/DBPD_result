- JCR-17 Creating and saving a mix:versionable node creates two VersionHistory nodes
- JCR-18 Multithreading issue with versioning


git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@76106 13f79535-47bb-0310-9956-ffa450edef68

-import javax.jcr.Workspace;
-import java.util.Iterator;
+import java.util.*;
-    public VirtualItemStateProvider getVirtualItemStateProvider(SessionImpl session, ItemStateProvider base) {
+    public synchronized VirtualItemStateProvider getVirtualItemStateProvider(SessionImpl session, ItemStateProvider base) {
-    public Version checkin(NodeImpl node) throws RepositoryException {
-        try {
-            InternalVersion version = vMgr.checkin(node);
-            vMgr.onVersionHistoryModified(version.getVersionHistory());
+    public synchronized Version checkin(NodeImpl node) throws RepositoryException {
+        InternalVersion version = vMgr.checkin(node);
+        vMgr.onVersionHistoryModified(version.getVersionHistory());
-            VirtualNodeState vhNode = (VirtualNodeState) virtProvider.getItemState(new NodeId(version.getVersionHistory().getId()));
-
-            // invalidate predecessors 'sucessors' properties
-            InternalVersion[] pred = version.getPredecessors();
-            for (int i=0; i<pred.length; i++) {
-                onVersionModified(pred[i]);
-            }
-            return (Version) node.getSession().getNodeByUUID(version.getId());
-        } catch (NoSuchItemStateException e) {
-            throw new RepositoryException(e);
+        // invalidate predecessors 'sucessors' properties
+        InternalVersion[] pred = version.getPredecessors();
+        for (int i=0; i<pred.length; i++) {
+            onVersionModified(pred[i]);
+        return (Version) node.getSession().getNodeByUUID(version.getId());
-    protected void onVersionModified(InternalVersion v) throws RepositoryException {
+    protected synchronized void onVersionModified(InternalVersion v)
+            throws RepositoryException {
-    protected void onVersionHistoryModified(InternalVersionHistory vh) throws RepositoryException {
+    protected synchronized void onVersionHistoryModified(InternalVersionHistory vh)
+            throws RepositoryException {
+                    //mapFrozenProperties(vNode, fNode);
+    private void mapFrozenProperties(VirtualNodeState  node, InternalFrozenNode fNode)
+            throws RepositoryException {
+        try {
+            // initialize the content
+            PersistentProperty[] props = fNode.getFrozenProperties();
+            for (int i=0; i<props.length; i++) {
+                virtProvider.setPropertyValues(node, props[i].getName(), props[i].getType(), props[i].getValues(), props[i].isMultiple());
+            }
+            InternalFreeze[] freezes = fNode.getFrozenChildNodes();
+            for (int i=0; i<freezes.length; i++) {
+                if (freezes[i] instanceof InternalFrozenVersionHistory) {
+                    InternalFrozenVersionHistory vh = (InternalFrozenVersionHistory) freezes[i];
+                    VirtualNodeState fChild = virtProvider.addNode(node.getId(), vh.getName(), null, NodeTypeRegistry.NT_FROZEN_VERSIONABLE_CHILD);
+                    virtProvider.setPropertyValue(fChild, VersionManager.PROPNAME_VERSION_HISTORY, InternalValue.create(UUID.fromString(vh.getVersionHistoryId())));
+                } else { // instance of InternalFrozenNode
+                    InternalFrozenNode fn = (InternalFrozenNode) freezes[i];
+                    mapFrozenNode(node, fn.getName(), fn);
+                }
+            }
+        } catch (ItemStateException e) {
+            throw new RepositoryException(e);
+        }
+    }
+

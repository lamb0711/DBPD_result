Improve performance for complex path queries involving descendant-or-self axis. e.g: //foo//bar//*[@prop='bla']

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@164208 13f79535-47bb-0310-9956-ffa450edef68

+        } else if (term.field() == FieldNames.PARENT) {
+            TermDocs[] termDocs = new TermDocs[subReaders.length];
+            for (int i = 0; i < subReaders.length; i++) {
+                termDocs[i] = subReaders[i].termDocs(term);
+            }
+            return new MultiTermDocs(termDocs, starts);
-         * @throws UnsupportedOperationException always
+         * {@inheritDoc}
+
+    /**
+     * Implements a <code>TermDocs</code> which spans multiple other
+     * <code>TermDocs</code>.
+     */
+    private static final class MultiTermDocs implements TermDocs {
+
+        /**
+         * The actual <code>TermDocs</code>.
+         */
+        private final TermDocs[] termDocs;
+
+        /**
+         * The document number offsets for each <code>TermDocs</code>.
+         */
+        private final int[] starts;
+
+        /**
+         * The current <code>TermDocs</code> instance. If <code>null</code>
+         * there are no more documents.
+         */
+        private TermDocs current;
+
+        /**
+         * The current index into {@link #termDocs} and {@link #starts}.
+         */
+        private int idx = 0;
+
+        /**
+         * Creates a new <code>MultiTermDocs</code> instance.
+         * @param termDocs the actual <code>TermDocs</code>.
+         * @param starts the document number offsets for each
+         *  <code>TermDocs</code>
+         */
+        MultiTermDocs(TermDocs[] termDocs, int[] starts) {
+            this.termDocs = termDocs;
+            this.starts = starts;
+            current = termDocs[idx];
+        }
+
+        /**
+         * @throws UnsupportedOperationException always
+         */
+        public void seek(Term term) {
+            throw new UnsupportedOperationException();
+        }
+
+        /**
+         * @throws UnsupportedOperationException always
+         */
+        public void seek(TermEnum termEnum) {
+            throw new UnsupportedOperationException();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public int doc() {
+            return starts[idx] + current.doc();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public int freq() {
+            return current.freq();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public boolean next() throws IOException {
+            while (current != null && !current.next()) {
+                if (++idx >= termDocs.length) {
+                    // no more TermDocs
+                    current = null;
+                } else {
+                    // move to next TermDocs
+                    current = termDocs[idx];
+                }
+            }
+            return current != null;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public int read(int[] docs, int[] freqs) throws IOException {
+            int count = 0;
+            for (int i = 0; i < docs.length && next(); i++, count++) {
+                docs[i] = doc();
+                freqs[i] = freq();
+            }
+            return count;
+        }
+
+        /**
+         * @throws UnsupportedOperationException always
+         */
+        public boolean skipTo(int target) {
+            throw new UnsupportedOperationException();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public void close() throws IOException {
+            for (int i = 0; i < termDocs.length; i++) {
+                termDocs[i].close();
+            }
+        }
+    }

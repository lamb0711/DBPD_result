minor improvement

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1022857 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.collections.map.LRUMap;
-import org.apache.jackrabbit.core.ItemImpl;
-import org.apache.jackrabbit.core.ItemManager;
-import org.apache.jackrabbit.core.id.ItemId;
-import org.apache.jackrabbit.core.id.PropertyId;
-import org.apache.jackrabbit.core.security.authorization.AccessControlListener;
-import org.apache.jackrabbit.core.security.authorization.AbstractCompiledPermissions;
-import org.apache.jackrabbit.core.security.authorization.AccessControlModifications;
-import org.apache.jackrabbit.core.security.authorization.PrivilegeRegistry;
-import javax.jcr.security.AccessControlEntry;
-import java.util.Iterator;
-     * the system acl editor.
-     */
-    private ACLEditor systemEditor;
-
-    /**
-        systemEditor = new ACLEditor(systemSession, this);
+        ACLEditor systemEditor = new ACLEditor(systemSession, this);
-            return new AclPermissions(principals);
+            return new CompiledPermissionsImpl(principals, session, entryCollector, this, true);
-            CompiledPermissions cp = new AclPermissions(principals, false);
-            return cp.canRead(null, rootNodeId);
+            CompiledPermissions cp = new CompiledPermissionsImpl(principals, session, entryCollector, this, false);
+            try {
+                return cp.canRead(null, rootNodeId);
+            } finally {
+                cp.close();
+            }
-     * @see #retrieveResultEntries(NodeImpl, EntryFilter)
-        return new CachingEntryCollector(systemSession, systemEditor, rootNodeId);
-    }
-
-    /**
-     * Retrieve an iterator of <code>AccessControlEntry</code> to be evaluated
-     * upon {@link AbstractCompiledPermissions#buildResult}.
-     *
-     * @param node Target node.
-     * @param filter The entry filter used to collect the access control entries.
-     * @return an iterator of <code>AccessControlEntry</code>.
-     * @throws RepositoryException If an error occurs.
-     */
-    protected Iterator<AccessControlEntry> retrieveResultEntries(NodeImpl node, EntryFilter filter) throws RepositoryException {
-        Iterator<AccessControlEntry> itr = entryCollector.collectEntries(node, filter).iterator();
-        return itr;
+        return new CachingEntryCollector(systemSession, rootNodeId);
-     * Returns the given <code>targetNode</code> unless the node itself stores
-     * access control information in which case it's nearest non-ac-parent is
-     * searched and returned.
-     *
-     * @param targetNode The node for which AC information needs to be retrieved.
-     * @param isAcItem true if the specified target node defines access control
-     * content; false otherwise.
-     * @return the given <code>targetNode</code> or the nearest non-ac-parent
-     * in case the <code>targetNode</code> itself defines access control content.
-     * @throws RepositoryException if an error occurs
-     */
-    private NodeImpl getNode(NodeImpl targetNode, boolean isAcItem) throws RepositoryException {
-        NodeImpl node;
-        if (isAcItem) {
-            Name ntName = ((NodeTypeImpl) targetNode.getPrimaryNodeType()).getQName();
-            if (ntName.equals(NT_REP_ACL)) {
-                node = (NodeImpl) targetNode.getParent();
-            } else {
-                node = (NodeImpl) targetNode.getParent().getParent();
-            }
-        } else {
-            node = targetNode;
-        }
-        return node;
-    }
-
-    /**
-    //------------------------------------------------< CompiledPermissions >---
+     * Returns the given <code>targetNode</code> unless the node itself stores
+     * access control information in which case it's nearest non-ac-parent is
+     * searched and returned.
+     * @param targetNode The node for which AC information needs to be retrieved.
+     * @param isAcItem true if the specified target node defines access control
+     * content; false otherwise.
+     * @return the given <code>targetNode</code> or the nearest non-ac-parent
+     * in case the <code>targetNode</code> itself defines access control content.
+     * @throws RepositoryException if an error occurs
-    private class AclPermissions extends AbstractCompiledPermissions implements AccessControlListener {
-
-        private final List<String> principalNames;
-        // TODO find optimal cache size and ev. make it configurable (see also JCR-2573).
-        private final Map<ItemId, Boolean> readCache = new LRUMap(5000);
-        private final Object monitor = new Object();
-
-        private AclPermissions(Set<Principal> principals) throws RepositoryException {
-            this(principals, true);
-        }
-
-        private AclPermissions(Set<Principal> principals, boolean listenToEvents) throws RepositoryException {
-            principalNames = new ArrayList<String>(principals.size());
-            for (Principal princ : principals) {
-                principalNames.add(princ.getName());
+    static NodeImpl getNode(NodeImpl targetNode, boolean isAcItem) throws RepositoryException {
+        NodeImpl node;
+        if (isAcItem) {
+            Name ntName = ((NodeTypeImpl) targetNode.getPrimaryNodeType()).getQName();
+            if (ntName.equals(NT_REP_ACL)) {
+                node = (NodeImpl) targetNode.getParent();
+            } else {
+                node = (NodeImpl) targetNode.getParent().getParent();
-
-            if (listenToEvents) {
-                /*
-                 Make sure this AclPermission recalculates the permissions if
-                 any ACL concerning it is modified.
-                 */
-                 entryCollector.addListener(this);
-            }
+        } else {
+            node = targetNode;
-
-        private Result buildResult(NodeImpl node, boolean isExistingNode, boolean isAcItem, EntryFilterImpl filter) throws RepositoryException {
-            // retrieve all ACEs at path or at the direct ancestor of path that
-            // apply for the principal names.
-            Iterator<AccessControlEntry> entries = retrieveResultEntries(getNode(node, isAcItem), filter);
-
-            /*
-             Calculate privileges and permissions:
-             Since the ACEs only define privileges on a node and do not allow
-             to add additional restrictions, the permissions can be determined
-             without taking the given target name or target item into account.
-             */
-            int allows = Permission.NONE;
-            int denies = Permission.NONE;
-
-            int allowPrivileges = PrivilegeRegistry.NO_PRIVILEGE;
-            int denyPrivileges = PrivilegeRegistry.NO_PRIVILEGE;
-            int parentAllows = PrivilegeRegistry.NO_PRIVILEGE;
-            int parentDenies = PrivilegeRegistry.NO_PRIVILEGE;
-
-            String parentPath = Text.getRelativeParent(filter.getPath(), 1);
-
-            while (entries.hasNext()) {
-                ACLTemplate.Entry ace = (ACLTemplate.Entry) entries.next();
-                /*
-                 Determine if the ACE also takes effect on the parent:
-                 Some permissions (e.g. add-node or removal) must be determined
-                 from privileges defined for the parent.
-                 A 'local' entry defined on the target node never effects the
-                 parent. For inherited ACEs determine if the ACE matches the
-                 parent path.
-                 */
-                int entryBits = ace.getPrivilegeBits();
-                boolean isLocal = isExistingNode && ace.isLocal(node.getNodeId());
-                boolean matchesParent = (!isLocal && ace.matches(parentPath));
-                if (matchesParent) {
-                    if (ace.isAllow()) {
-                        parentAllows |= Permission.diff(entryBits, parentDenies);
-                    } else {
-                        parentDenies |= Permission.diff(entryBits, parentAllows);
-                    }
-                }
-                if (ace.isAllow()) {
-                    allowPrivileges |= Permission.diff(entryBits, denyPrivileges);
-                    int permissions = PrivilegeRegistry.calculatePermissions(allowPrivileges, parentAllows, true, isAcItem);
-                    allows |= Permission.diff(permissions, denies);
-                } else {
-                    denyPrivileges |= Permission.diff(entryBits, allowPrivileges);
-                    int permissions = PrivilegeRegistry.calculatePermissions(denyPrivileges, parentDenies, false, isAcItem);
-                    denies |= Permission.diff(permissions, allows);
-                }
-            }
-            return new Result(allows, denies, allowPrivileges, denyPrivileges);
-        }
-
-        //------------------------------------< AbstractCompiledPermissions >---
-        /**
-         * @see AbstractCompiledPermissions#buildResult(Path)
-         */
-        @Override
-        protected Result buildResult(Path absPath) throws RepositoryException {
-            boolean existingNode = false;
-            NodeImpl node;
-
-            ItemManager itemMgr = session.getItemManager();
-            try {
-                ItemImpl item = itemMgr.getItem(absPath);
-                if (item.isNode()) {
-                    node = (NodeImpl) item;
-                    existingNode = true;
-                } else {
-                    node = (NodeImpl) item.getParent();
-                }
-            } catch (RepositoryException e) {
-                // path points to a non-persisted item.
-                // -> find the nearest persisted node starting from the root.
-                Path.Element[] elems = absPath.getElements();
-                NodeImpl parent = (NodeImpl) session.getRootNode();
-                for (int i = 1; i < elems.length - 1; i++) {
-                    Name name = elems[i].getName();
-                    int index = elems[i].getIndex();
-                    if (!parent.hasNode(name, index)) {
-                        // last persisted node reached
-                        break;
-                    }
-                    parent = parent.getNode(name, index);
-
-                }
-                node = parent;
-            }
-
-            if (node == null) {
-                // should never get here
-                throw new ItemNotFoundException("Item out of hierarchy.");
-            }
-
-            boolean isAcItem = isAcItem(absPath);
-            return buildResult(node, existingNode, isAcItem, new EntryFilterImpl(principalNames, absPath, session));
-        }
-
-        /**
-         * @see AbstractCompiledPermissions#clearCache()
-         */
-        @Override
-        protected void clearCache() {
-            synchronized (monitor) {
-                readCache.clear();
-            }
-            super.clearCache();
-        }
-
-        //--------------------------------------------< CompiledPermissions >---
-        /**
-         * @see CompiledPermissions#close()
-         */
-        @Override
-        public void close() {
-            entryCollector.removeListener(this);
-            super.close();
-        }
-
-        /**
-         * @see CompiledPermissions#canRead(Path, ItemId)
-         */
-        public boolean canRead(Path path, ItemId itemId) throws RepositoryException {
-            ItemId id = (itemId == null) ? session.getHierarchyManager().resolvePath(path) : itemId;
-            // no extra check for existence as method may only be called for existing items.
-            boolean isExistingNode = id.denotesNode();
-            boolean canRead;
-            synchronized (monitor) {
-                if (readCache.containsKey(id)) {
-                    canRead = readCache.get(id);
-                } else {
-                    ItemManager itemMgr = session.getItemManager();
-                    NodeId nodeId = (isExistingNode) ? (NodeId) id : ((PropertyId) id).getParentId();
-                    NodeImpl node = (NodeImpl) itemMgr.getItem(nodeId);
-                    // TODO: check again if retrieving the path can be avoided
-                    Path absPath = (path == null) ? session.getHierarchyManager().getPath(id) : path;
-                    Result result = buildResult(node, isExistingNode, isAcItem(node), new EntryFilterImpl(principalNames, absPath, session));
-
-                    canRead = result.grants(Permission.READ);
-                    readCache.put(id, canRead);
-                }
-            }
-            return canRead;
-        }
-
-        //----------------------------------------< ACLModificationListener >---
-        /**
-         * @see org.apache.jackrabbit.core.security.authorization.AccessControlListener#acModified(AccessControlModifications)
-         */
-        public void acModified(AccessControlModifications modifications) {
-            // ignore the details of the modifications and clear all caches.
-            clearCache();
-        }
+        return node;

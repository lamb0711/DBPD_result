- added Path.computeRelativePath method
- removed NodeImpl.isRepositoryRoot and replaced calls with with n.getDepth()==0

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@156060 13f79535-47bb-0310-9956-ffa450edef68

-import javax.jcr.Session;
-     * Checks if this node is the root node.
-     * todo: is this the root node of this workspace?
-     *
-     * @return
-     */
-    public boolean isRepositoryRoot() {
-        return ((NodeState) state).getUUID().equals(rep.getRootNodeUUID());
-    }
-
-    /**
-        while (!m1.isRepositoryRoot() && !m1.isNodeType(MIX_REFERENCEABLE)) {
+        while (m1.getDepth() != 0 && !m1.isNodeType(MIX_REFERENCEABLE)) {
-        if (m1.isRepositoryRoot()) {
-            return getPath();
+        if (m1.getDepth() == 0) {
+            // check existence
+            if (!srcSession.getItemManager().itemExists(getPrimaryPath())) {
+                throw new ItemNotFoundException(safeGetJCRPath());
+            } else {
+                return getPath();
+            }
-        // calculate relative path from the referenceable ancestor to this node.
-        // please note, that this cannot be done
-        // iteratively in the 'while' loop above, since getName() does not
-        // return the relative path, but just the name (without path indices)
-        // n1.getPath() = /foo/bar/something[1]
-        // m1.getPath() = /foo
-        //      relpath = bar/something[1]
+        String relPath;
+        try {
+            Path p = m1.getPrimaryPath().computeRelativePath(getPrimaryPath());
+            // use prefix mappings of srcSession
+            relPath = p.toJCRPath(srcSession.getNamespaceResolver());
+        } catch (BaseException be) {
+            // should never get here...
+            String msg = "internal error: failed to determine relative path";
+            log.error(msg, be);
+            throw new RepositoryException(msg, be);
+        }
-        // @todo: replace as soon as implemented
-        // Path relPath = m1.getPrimaryPath().getRelativePath(getPrimaryPath());
-
-        String relPath = getPath().substring(m1.getPath().length() + 1);
-        return m2.getNode(relPath).getPath();
+        if (!m2.hasNode(relPath)) {
+            throw new ItemNotFoundException();
+        } else {
+            return m2.getNode(relPath).getPath();
+        }
-     * @throws NoSuchWorkspaceException If <code>srcWorkspace</code> does not exist.
-     * @throws AccessDeniedException    If the current session does not have sufficient rights to perform the operation.
-     * @throws RepositoryException      If another error occurs.
+     * @throws RepositoryException If another error occurs.
-    private NodeImpl getCorrespondingNode(Session srcSession)
+    private NodeImpl getCorrespondingNode(SessionImpl srcSession)
-        while (!m1.isRepositoryRoot() && !m1.isNodeType(MIX_REFERENCEABLE)) {
+        while (m1.getDepth() != 0 && !m1.isNodeType(MIX_REFERENCEABLE)) {
-            // get corresponding ancestor
+            // get corresponding ancestor (might throw ItemNotFoundException)
-            // return path of m2, if m1 == n1
+            // return m2, if m1 == n1
-            // calculate relative path from the referenceable ancestor to this node.
-            // please note, that this cannot be done
-            // iteratively in the 'while' loop above, since getName() does not
-            // return the relative path, but just the name (without path indices)
-            // n1.getPath() = /foo/bar/something[1]
-            // m1.getPath() = /foo
-            //      relpath = bar/something[1]
-
-            // @todo: replace as soon as implemented
-            // Path relPath = m1.getPrimaryPath().getRelativePath(getPrimaryPath());
-
-            String relPath = getPath().substring(m1.getPath().length() + 1);
-            return (NodeImpl) m2.getNode(relPath);
-
+            String relPath;
+            try {
+                Path p = m1.getPrimaryPath().computeRelativePath(getPrimaryPath());
+                // use prefix mappings of srcSession
+                relPath = p.toJCRPath(srcSession.getNamespaceResolver());
+            } catch (BaseException be) {
+                // should never get here...
+                String msg = "internal error: failed to determine relative path";
+                log.error(msg, be);
+                throw new RepositoryException(msg, be);
+            }
+            if (!m2.hasNode(relPath)) {
+                return null;
+            } else {
+                return (NodeImpl) m2.getNode(relPath);
+            }
-    private NodeImpl doMergeTest(Session srcSession, boolean bestEffort)
+    private NodeImpl doMergeTest(SessionImpl srcSession, boolean bestEffort)
-            if (node.isRepositoryRoot()) {
+            if (node.getDepth() == 0) {

JCR-1799 updating events swallowed (CacheBehavior.OBSERVATION)   	
JCR-1783 incomplete changelog when combining move with removal of new destination parent

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@704361 13f79535-47bb-0310-9956-ffa450edef68

-            return createDeepPropertyState(info, anyParent, null);
+            PropertyState propState = createDeepPropertyState(info, anyParent, null);
+            assertValidState(propState, info);
+            return propState;
-                assertMatchingPath(first, nodeState.getNodeEntry());
+                assertValidState(nodeState, first);
-        // now build the nodestate itself
-        NodeState state = new NodeState(entry, info, this, definitionProvider);
-        state.setMixinTypeNames(info.getMixins());
+        if (Status.isTransient(entry.getStatus()) || Status.isStale(entry.getStatus())) {
+            log.debug("Node has pending changes; omit resetting the state.");
+            return entry.getNodeState();
+        }
-            entry.addPropertyEntries(propNames);
+            entry.setPropertyEntries(propNames);
-        notifyCreated(state);
-        return state;
+        // now build or update the nodestate itself
+        NodeState tmp = new NodeState(entry, info, this, definitionProvider);
+        entry.setItemState(tmp);
+
+        NodeState nState = entry.getNodeState();
+        if (nState == tmp) {
+            // tmp state was used as resolution for the given entry i.e. the
+            // entry was not available before. otherwise the 2 states were
+            // merged. see HierarchyEntryImpl#setItemState
+            notifyCreated(nState);
+        }
+        return nState;
-    private PropertyState createPropertyState(PropertyInfo info, PropertyEntry entry) {
+    private PropertyState createPropertyState(PropertyInfo info, PropertyEntry entry)
+            throws RepositoryException {
-        // build the PropertyState
-        PropertyState state = new PropertyState(entry, info, this, definitionProvider);
+        if (Status.isTransient(entry.getStatus()) || Status.isStale(entry.getStatus())) {
+            log.debug("Property has pending changes; omit resetting the state.");
+            return entry.getPropertyState();
+        }
-        notifyCreated(state);
-        return state;
+        // now build or update the nodestate itself
+        PropertyState tmp = new PropertyState(entry, info, this, definitionProvider);
+        entry.setItemState(tmp);
+
+        PropertyState pState = entry.getPropertyState();
+        if (pState == tmp) {
+            // tmp state was used as resolution for the given entry i.e. the
+            // entry was not available before. otherwise the 2 states were
+            // merged. see HierarchyEntryImpl#setItemState
+            notifyCreated(pState);
+        }
+        return pState;
-            Path anyParentPath = anyParent.getPath();
+            Path anyParentPath = anyParent.getWorkspacePath();
+            if (startsWithIllegalElement(missingElems)) {
+                log.error("Relative path to NodeEntry starts with illegal element -> ignore NodeInfo with path " + info.getPath());
+                return null;
+            }
+
-            NodeEntry entry = anyParent;
+            // make sure the missing elements don't start with . or .. in which
+            // case the info is not within the tree as it is expected
+            // (see also JCR-1797)
+            if (startsWithIllegalElement(missingElems)) {
+                log.error("Relative path to PropertyEntry starts with illegal element -> ignore PropertyInfo with path " + info.getPath());
+                return null;
+            }
+
+            NodeEntry entry = anyParent;
+     * Validation check: make sure the state is not null (was really created)
+     * and matches with the specified ItemInfo (path).
+     *
+     * @param state
+     * @param info
+     * @throws ItemNotFoundException
+     * @throws RepositoryException
+     */
+    private static void assertValidState(ItemState state, ItemInfo info)
+            throws ItemNotFoundException, RepositoryException {
+        if (state == null) {
+            throw new ItemNotFoundException("HierarchyEntry does not belong to any existing ItemInfo. No ItemState was created.");
+        }
+        assertMatchingPath(info, state.getHierarchyEntry());
+    }
+
+    /**
+     * Returns true if the given <code>missingElems</code> start with a parent (..),
+     * a current (.) or the root element, in which case the info is not within
+     * the tree as it is expected.
+     * See also #JCR-1797 for the corresponding enhancement request.
+     *
+     * @param missingElems
+     * @return
+     */
+    private static boolean startsWithIllegalElement(Path.Element[] missingElems) {
+        if (missingElems.length > 0) {
+            return !missingElems[0].denotesName();
+        }
+        return false;
+    }
+
+    /**

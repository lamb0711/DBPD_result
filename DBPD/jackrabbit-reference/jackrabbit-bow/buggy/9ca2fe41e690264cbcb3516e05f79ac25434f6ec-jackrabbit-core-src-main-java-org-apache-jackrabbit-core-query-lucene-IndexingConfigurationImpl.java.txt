JCR-2087: Upgrade to Java 5 as the base platform

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@801565 13f79535-47bb-0310-9956-ffa450edef68

-    private Map configElements = new HashMap();
+    private Map<Name, List<IndexingRule>> configElements = new HashMap<Name, List<IndexingRule>>();
-    private Map analyzers = new HashMap();
+    private Map<String, Analyzer> analyzers = new HashMap<String, Analyzer>();
-        List idxAggregates = new ArrayList();
+        List<AggregateRule> idxAggregates = new ArrayList<AggregateRule>();
-                for (int n = 0; n < ntNames.length; n++) {
-                    if (ntReg.getEffectiveNodeType(ntNames[n]).includesNodeType(element.getNodeTypeName())) {
-                        List perNtConfig = (List) configElements.get(ntNames[n]);
+                for (Name ntName : ntNames) {
+                    if (ntReg.getEffectiveNodeType(ntName).includesNodeType(element.getNodeTypeName())) {
+                        List<IndexingRule> perNtConfig = configElements.get(ntName);
-                            perNtConfig = new ArrayList();
-                            configElements.put(ntNames[n], perNtConfig);
+                            perNtConfig = new ArrayList<IndexingRule>();
+                            configElements.put(ntName, perNtConfig);
-                        log.debug("Registering it for name '{}'", ntNames[n]);
-                        perNtConfig.add(new IndexingRule(element, ntNames[n]));
+                        log.debug("Registering it for name '{}'", ntName);
+                        perNtConfig.add(new IndexingRule(element, ntName));
-        aggregateRules = (AggregateRule[]) idxAggregates.toArray(
-                new AggregateRule[idxAggregates.size()]);
+        aggregateRules = idxAggregates.toArray(new AggregateRule[idxAggregates.size()]);
-            return (Analyzer) analyzers.get(fieldName);
+            return analyzers.get(fieldName);
-        List rules = null;
-        List r = (List) configElements.get(state.getNodeTypeName());
+        List<IndexingRule> rules = null;
+        List<IndexingRule> r = configElements.get(state.getNodeTypeName());
-            rules = new ArrayList();
+            rules = new ArrayList<IndexingRule>();
-        Iterator it = state.getMixinTypeNames().iterator();
-        while (it.hasNext()) {
-            r = (List) configElements.get(it.next());
+        for (Name name : state.getMixinTypeNames()) {
+            r = configElements.get(name);
-                    rules = new ArrayList();
+                    rules = new ArrayList<IndexingRule>();
-            it = rules.iterator();
-            while (it.hasNext()) {
-                IndexingRule ir = (IndexingRule) it.next();
-                if (ir.appliesTo(state)) {
-                    return ir;
+            for (IndexingRule rule : rules) {
+                if (rule.appliesTo(state)) {
+                    return rule;
-                                       Map propConfigs,
-                                       List namePatterns)
+                                       Map<Name, PropertyConfig> propConfigs,
+                                       List<NamePattern> namePatterns)
-                    nodeScopeIndex = Boolean.valueOf(
-                            nsIndex.getNodeValue()).booleanValue();
+                    nodeScopeIndex = Boolean.valueOf(nsIndex.getNodeValue());
-                    isRegexp = Boolean.valueOf(
-                            regexp.getNodeValue()).booleanValue();
+                    isRegexp = Boolean.valueOf(regexp.getNodeValue());
-                    useInExcerpt = Boolean.valueOf(
-                            excerpt.getNodeValue()).booleanValue();
+                    useInExcerpt = Boolean.valueOf(excerpt.getNodeValue());
-        private final Map propConfigs;
+        private final Map<Name, PropertyConfig> propConfigs;
-        private final List namePatterns;
+        private final List<NamePattern> namePatterns;
-            this.propConfigs = new HashMap();
-            this.namePatterns = new ArrayList();
+            this.propConfigs = new HashMap<Name, PropertyConfig>();
+            this.namePatterns = new ArrayList<NamePattern>();
-            if (config != null) {
-                return config.nodeScopeIndex;
-            } else {
-                return false;
-            }
+            return config != null && config.nodeScopeIndex;
-            if (config != null) {
-                return config.useInExcerpt;
-            } else {
-                return true;
-            }
+            return config == null || config.useInExcerpt;
-            if (condition == null) {
-                return true;
-            } else {
-                return condition.evaluate(state);
-            }
+            return condition == null || condition.evaluate(state);
-            PropertyConfig config = (PropertyConfig) propConfigs.get(propertyName);
+            PropertyConfig config = propConfigs.get(propertyName);
-                for (Iterator it = namePatterns.iterator(); it.hasNext(); ) {
-                    NamePattern np = (NamePattern) it.next();
+                for (NamePattern np : namePatterns) {
-                    for (int i = 0; i < values.length; i++) {
-                        if (values[i].toString().equals(propertyValue)) {
+                    for (InternalValue value : values) {
+                        if (value.toString().equals(propertyValue)) {

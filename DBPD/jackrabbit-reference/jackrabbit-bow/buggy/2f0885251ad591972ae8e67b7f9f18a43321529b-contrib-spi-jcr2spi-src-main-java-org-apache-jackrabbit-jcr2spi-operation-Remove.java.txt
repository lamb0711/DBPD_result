Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.state.ItemStateException;
+import org.apache.jackrabbit.jcr2spi.config.CacheBehaviour;
+    protected NodeState parent;
-    protected Remove(ItemState removeState) {
+    protected Remove(ItemState removeState, NodeState parent) {
+        this.parent = parent;
-        addAffectedItemState(removeState.getParent());
+        addAffectedItemState(parent);
-     * @see Operation#persisted()
+     * @see Operation#persisted(CacheBehaviour)
+     * @param cacheBehaviour
-    public void persisted() {
+    public void persisted(CacheBehaviour cacheBehaviour) {
-        return removeState.getParent();
+        return parent;
-    public static Operation create(ItemState state) {
-        Remove rm = new Remove(state);
+    public static Operation create(ItemState state) throws RepositoryException {
+        try {
+            Remove rm = new Remove(state, state.getParent());
+            return rm;
+        } catch (ItemStateException e) {
+            throw new RepositoryException(e);
+        }
+    }
+
+    public static Operation create(ItemState state, NodeState parent) {
+        Remove rm = new Remove(state, parent);

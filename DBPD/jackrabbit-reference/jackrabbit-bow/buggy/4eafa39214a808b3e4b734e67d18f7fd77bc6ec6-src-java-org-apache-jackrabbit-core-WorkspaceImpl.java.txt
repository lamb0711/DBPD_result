- re-implementing Workspace methods (-> work in progress!)
- avoiding "#import bla.*" stmts (in accordance with checkstyle settings)

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@156666 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.state.UpdatableItemStateManager;
-    //-----------< misc. static helper methods for cross-workspace operations >
-    /**
-     * @param nodePath
-     * @param nsResolver
-     * @param hierMgr
-     * @param stateMgr
-     * @return
-     * @throws PathNotFoundException
-     * @throws RepositoryException
-     */
-    protected static NodeState getNodeState(String nodePath,
-                                            NamespaceResolver nsResolver,
-                                            HierarchyManagerImpl hierMgr,
-                                            ItemStateManager stateMgr)
-            throws PathNotFoundException, RepositoryException {
-        try {
-            return getNodeState(Path.create(nodePath, nsResolver, true), hierMgr, stateMgr);
-        } catch (MalformedPathException mpe) {
-            String msg = "invalid path: " + nodePath;
-            log.debug(msg);
-            throw new RepositoryException(msg, mpe);
-        }
-    }
-
-    /**
-     * @param path
-     * @param nsResolver
-     * @param hierMgr
-     * @param stateMgr
-     * @return
-     * @throws PathNotFoundException
-     * @throws RepositoryException
-     */
-    protected static NodeState getParentNodeState(String path,
-                                                  NamespaceResolver nsResolver,
-                                                  HierarchyManagerImpl hierMgr,
-                                                  ItemStateManager stateMgr)
-
-            throws PathNotFoundException, RepositoryException {
-        try {
-            return getNodeState(Path.create(path, nsResolver, true).getAncestor(1), hierMgr, stateMgr);
-        } catch (MalformedPathException mpe) {
-            String msg = "invalid path: " + path;
-            log.debug(msg);
-            throw new RepositoryException(msg, mpe);
-        }
-    }
-
-    /**
-     * @param nodePath
-     * @param hierMgr
-     * @param stateMgr
-     * @return
-     * @throws PathNotFoundException
-     * @throws RepositoryException
-     */
-    protected static NodeState getNodeState(Path nodePath,
-                                            HierarchyManagerImpl hierMgr,
-                                            ItemStateManager stateMgr)
-            throws PathNotFoundException, RepositoryException {
-        try {
-            ItemId id = hierMgr.resolvePath(nodePath);
-            if (!id.denotesNode()) {
-                throw new PathNotFoundException(hierMgr.safeGetJCRPath(nodePath));
-            }
-            return getNodeState((NodeId) id, stateMgr);
-        } catch (NoSuchItemStateException nsise) {
-            throw new PathNotFoundException(hierMgr.safeGetJCRPath(nodePath));
-        } catch (ItemStateException ise) {
-            String msg = "internal error: failed to retrieve state of " + hierMgr.safeGetJCRPath(nodePath);
-            log.debug(msg);
-            throw new RepositoryException(msg, ise);
-        }
-    }
-
-    /**
-     * @param id
-     * @param stateMgr
-     * @return
-     * @throws NoSuchItemStateException
-     * @throws ItemStateException
-     */
-    protected static NodeState getNodeState(NodeId id,
-                                            ItemStateManager stateMgr)
-            throws NoSuchItemStateException, ItemStateException {
-        return (NodeState) stateMgr.getItemState(id);
-    }
-
-    /**
-     * Verifies that the node at <code>nodePath</code> is checked-out; throws a
-     * <code>VersionException</code> if that's not the case.
-     * <p/>
-     * A node is considered <i>checked-out</i> if it is versionable and
-     * checked-out, or is non-versionable but its nearest versionable ancestor
-     * is checked-out, or is non-versionable and there are no versionable
-     * ancestors.
-     *
-     * @param nodePath
-     * @param hierMgr
-     * @param stateMgr
-     * @throws VersionException
-     * @throws RepositoryException
-     */
-    protected static void verifyCheckedOut(Path nodePath,
-                                           HierarchyManagerImpl hierMgr,
-                                           ItemStateManager stateMgr)
-            throws VersionException, RepositoryException {
-        // search nearest ancestor that is versionable, start with node at nodePath
-        /**
-         * FIXME should not only rely on existence of jcr:isCheckedOut property
-         * but also verify that node.isNodeType("mix:versionable")==true;
-         * this would have a negative impact on performance though...
-         */
-        NodeState nodeState = getNodeState(nodePath, hierMgr, stateMgr);
-        while (!nodeState.hasPropertyEntry(JCR_ISCHECKEDOUT)) {
-            if (nodePath.denotesRoot()) {
-                return;
-            }
-            nodePath = nodePath.getAncestor(1);
-            nodeState = getNodeState(nodePath, hierMgr, stateMgr);
-        }
-        PropertyId propId =
-                new PropertyId(nodeState.getUUID(), JCR_ISCHECKEDOUT);
-        PropertyState propState;
-        try {
-            propState = (PropertyState) stateMgr.getItemState(propId);
-        } catch (ItemStateException ise) {
-            String msg = "internal error: failed to retrieve state of "
-                    + hierMgr.safeGetJCRPath(propId);
-            log.debug(msg);
-            throw new RepositoryException(msg, ise);
-        }
-        boolean checkedOut = ((Boolean) propState.getValues()[0].internalValue()).booleanValue();
-        if (!checkedOut) {
-            throw new VersionException(hierMgr.safeGetJCRPath(nodePath) + " is checked-in");
-        }
-    }
-
-     * @param ntReg
-     * @param accessMgr
-     * @param hierMgr
-     * @param stateMgr
-    protected static void checkAddNode(Path nodePath, QName nodeTypeName,
-                                       NodeTypeRegistry ntReg,
-                                       AccessManager accessMgr,
-                                       HierarchyManagerImpl hierMgr,
-                                       ItemStateManager stateMgr)
+    protected void checkAddNode(Path nodePath, QName nodeTypeName)
+        AccessManager accessMgr = session.getAccessManager();
+
-        NodeState parentState = getNodeState(parentPath, hierMgr, stateMgr);
+        NodeState parentState = getNodeState(parentPath);
-            String msg = "internal error: failed to check access rights for " + hierMgr.safeGetJCRPath(parentPath);
+            String msg = "internal error: failed to check access rights for "
+                    + hierMgr.safeGetJCRPath(parentPath);
+        NodeTypeRegistry ntReg = rep.getNodeTypeRegistry();
-        EffectiveNodeType entParent = getEffectiveNodeType(parentState, ntReg);
+        EffectiveNodeType entParent = getEffectiveNodeType(parentState);
-        ChildNodeDef newNodeDef = findApplicableDefinition(nodeName.getName(), nodeTypeName, parentState, ntReg);
+        ChildNodeDef newNodeDef =
+                findApplicableDefinition(nodeName.getName(), nodeTypeName, parentState);
-     * @param ntReg
-     * @param accessMgr
-     * @param hierMgr
-     * @param stateMgr
-    protected static void checkRemoveNode(Path nodePath,
-                                          NodeTypeRegistry ntReg,
-                                          AccessManager accessMgr,
-                                          HierarchyManagerImpl hierMgr,
-                                          ItemStateManager stateMgr)
+    protected void checkRemoveNode(Path nodePath)
-        NodeState targetState = getNodeState(nodePath, hierMgr, stateMgr);
+        AccessManager accessMgr = session.getAccessManager();
+
+        NodeState targetState = getNodeState(nodePath);
-        NodeState parentState = getNodeState(parentPath, hierMgr, stateMgr);
+        NodeState parentState = getNodeState(parentPath);
+        NodeTypeRegistry ntReg = rep.getNodeTypeRegistry();
+     * Verifies that the node at <code>nodePath</code> is checked-out; throws a
+     * <code>VersionException</code> if that's not the case.
+     * <p/>
+     * A node is considered <i>checked-out</i> if it is versionable and
+     * checked-out, or is non-versionable but its nearest versionable ancestor
+     * is checked-out, or is non-versionable and there are no versionable
+     * ancestors.
+     *
+     * @param nodePath
+     * @throws VersionException
+     * @throws RepositoryException
+     */
+    protected void verifyCheckedOut(Path nodePath)
+            throws VersionException, RepositoryException {
+        // search nearest ancestor that is versionable, start with node at nodePath
+        /**
+         * FIXME should not only rely on existence of jcr:isCheckedOut property
+         * but also verify that node.isNodeType("mix:versionable")==true;
+         * this would have a negative impact on performance though...
+         */
+        NodeState nodeState = getNodeState(nodePath);
+        while (!nodeState.hasPropertyEntry(JCR_ISCHECKEDOUT)) {
+            if (nodePath.denotesRoot()) {
+                return;
+            }
+            nodePath = nodePath.getAncestor(1);
+            nodeState = getNodeState(nodePath);
+        }
+        PropertyId propId =
+                new PropertyId(nodeState.getUUID(), JCR_ISCHECKEDOUT);
+        PropertyState propState;
+        try {
+            propState = (PropertyState) stateMgr.getItemState(propId);
+        } catch (ItemStateException ise) {
+            String msg = "internal error: failed to retrieve state of "
+                    + hierMgr.safeGetJCRPath(propId);
+            log.debug(msg);
+            throw new RepositoryException(msg, ise);
+        }
+        boolean checkedOut = ((Boolean) propState.getValues()[0].internalValue()).booleanValue();
+        if (!checkedOut) {
+            throw new VersionException(hierMgr.safeGetJCRPath(nodePath) + " is checked-in");
+        }
+    }
+
+    /**
+     * @param nodePath
+     * @return
+     * @throws PathNotFoundException
+     * @throws RepositoryException
+     */
+    protected NodeState getNodeState(Path nodePath)
+            throws PathNotFoundException, RepositoryException {
+        try {
+            ItemId id = hierMgr.resolvePath(nodePath);
+            if (!id.denotesNode()) {
+                throw new PathNotFoundException(hierMgr.safeGetJCRPath(nodePath));
+            }
+            return (NodeState) stateMgr.getItemState(id);
+        } catch (NoSuchItemStateException nsise) {
+            throw new PathNotFoundException(hierMgr.safeGetJCRPath(nodePath));
+        } catch (ItemStateException ise) {
+            String msg = "internal error: failed to retrieve state of "
+                    + hierMgr.safeGetJCRPath(nodePath);
+            log.debug(msg);
+            throw new RepositoryException(msg, ise);
+        }
+    }
+
+    /**
-     * @param ntReg
-    protected static EffectiveNodeType getEffectiveNodeType(NodeState state,
-                                                            NodeTypeRegistry ntReg)
+    protected EffectiveNodeType getEffectiveNodeType(NodeState state)
+        NodeTypeRegistry ntReg = rep.getNodeTypeRegistry();
-            String msg = "internal error: failed to build effective node type for node " + state.getUUID();
+            String msg =
+                    "internal error: failed to build effective node type for node "
+                    + state.getUUID();
-     * @param ntReg
-    protected static ChildNodeDef findApplicableDefinition(QName name,
-                                                           QName nodeTypeName,
-                                                           NodeState parentState,
-                                                           NodeTypeRegistry ntReg)
+    protected ChildNodeDef findApplicableDefinition(QName name,
+                                                    QName nodeTypeName,
+                                                    NodeState parentState)
-        EffectiveNodeType entParent = getEffectiveNodeType(parentState, ntReg);
+        EffectiveNodeType entParent = getEffectiveNodeType(parentState);
-    private static NodeState copyNodeState(NodeState srcState,
-                                           String parentUUID,
-                                           NodeTypeRegistry ntReg,
-                                           HierarchyManagerImpl srcHierMgr,
-                                           ItemStateManager srcStateMgr,
-                                           UpdatableItemStateManager destStateMgr,
-                                           boolean clone)
+    private NodeState copyNodeState(NodeState srcState,
+                                    String parentUUID,
+                                    ItemStateManager srcStateMgr,
+                                    boolean clone)
+                /**
+                 * todo FIXME check mix:referenceable
+                 * make sure that copied reference properties are
+                 * refering to new uuid
+                 */
-            newState = destStateMgr.createNew(uuid, srcState.getNodeTypeName(), parentUUID);
+            newState = stateMgr.createNew(uuid, srcState.getNodeTypeName(), parentUUID);
-                NodeState srcChildState = (NodeState) srcStateMgr.getItemState(new NodeId(entry.getUUID()));
+                NodeState srcChildState =
+                        (NodeState) srcStateMgr.getItemState(new NodeId(entry.getUUID()));
-                        ntReg, srcHierMgr, srcStateMgr, destStateMgr, clone);
+                        srcStateMgr, clone);
-                destStateMgr.store(newChildState);
+                stateMgr.store(newChildState);
-                PropertyState srcChildState = (PropertyState) srcStateMgr.getItemState(new PropertyId(srcState.getUUID(), entry.getName()));
-                PropertyState newChildState = copyPropertyState(srcChildState, uuid, entry.getName(),
-                        ntReg, srcHierMgr, srcStateMgr, destStateMgr);
+                PropertyState srcChildState =
+                        (PropertyState) srcStateMgr.getItemState(new PropertyId(srcState.getUUID(), entry.getName()));
+                PropertyState newChildState =
+                        copyPropertyState(srcChildState, uuid, entry.getName());
-                destStateMgr.store(newChildState);
+                stateMgr.store(newChildState);
-            String msg = "internal error: failed to copy state of " + srcHierMgr.safeGetJCRPath(srcState.getId());
+            String msg = "internal error: failed to copy state of " + srcState.getId();
-    private static PropertyState copyPropertyState(PropertyState srcState,
-                                                   String parentUUID,
-                                                   QName propName,
-                                                   NodeTypeRegistry ntReg,
-                                                   HierarchyManagerImpl srcHierMgr,
-                                                   ItemStateManager srcStateMgr,
-                                                   UpdatableItemStateManager destStateMgr)
+    private PropertyState copyPropertyState(PropertyState srcState,
+                                            String parentUUID,
+                                            QName propName)
-        PropertyState newState = destStateMgr.createNew(propName, parentUUID);
+        PropertyState newState = stateMgr.createNew(propName, parentUUID);
-                PropDef def = ntReg.getPropDef(defId);
+                PropDef def = rep.getNodeTypeRegistry().getPropDef(defId);
-    private static void internalCopy(String srcAbsPath,
-                                     ItemStateManager srcStateMgr,
-                                     HierarchyManagerImpl srcHierMgr,
-                                     String destAbsPath,
-                                     UpdatableItemStateManager destStateMgr,
-                                     HierarchyManagerImpl destHierMgr,
-                                     AccessManager accessMgr,
-                                     NamespaceResolver nsResolver,
-                                     NodeTypeRegistry ntReg,
-                                     boolean clone)
+    private void internalCopy(String srcAbsPath,
+                              WorkspaceImpl srcWsp,
+                              String destAbsPath,
+                              boolean clone)
-            srcPath = Path.create(srcAbsPath, nsResolver, true);
-            srcState = getNodeState(srcPath, srcHierMgr, srcStateMgr);
+            srcPath = Path.create(srcAbsPath, session.getNamespaceResolver(), true);
+            srcState = srcWsp.getNodeState(srcPath);
-            destPath = Path.create(destAbsPath, nsResolver, true);
+            destPath = Path.create(destAbsPath, session.getNamespaceResolver(), true);
-            destParentState = getNodeState(destParentPath, destHierMgr, destStateMgr);
+            destParentState = getNodeState(destParentPath);
-            String msg = destAbsPath + ": invalid destination path (subscript in name element is not allowed)";
+            String msg = destAbsPath
+                    + ": invalid destination path (subscript in name element is not allowed)";
-        verifyCheckedOut(destParentPath, destHierMgr, destStateMgr);
+        verifyCheckedOut(destParentPath);
-            if (!accessMgr.isGranted(srcState.getId(), AccessManager.READ)) {
+            if (!session.getAccessManager().isGranted(srcState.getId(), AccessManager.READ)) {
-        checkAddNode(destPath, srcState.getNodeTypeName(), ntReg, accessMgr, destHierMgr, destStateMgr);
+        checkAddNode(destPath, srcState.getNodeTypeName());
+
-            destStateMgr.edit();
+            stateMgr.edit();
-                    ntReg, srcHierMgr, srcStateMgr, destStateMgr, clone);
+                    srcWsp.getItemStateManager(), clone);
-            ChildNodeDef newNodeDef = findApplicableDefinition(destName.getName(), srcState.getNodeTypeName(), destParentState, ntReg);
+            ChildNodeDef newNodeDef =
+                    findApplicableDefinition(destName.getName(),
+                            srcState.getNodeTypeName(), destParentState);
-            destStateMgr.store(newState);
-            destStateMgr.store(destParentState);
+            stateMgr.store(newState);
+            stateMgr.store(destParentState);
-            destStateMgr.update();
+            stateMgr.update();
-        // @todo reimplement Workspace#clone according to new spec
+        // check workspace name
+        if (getName().equals(srcWorkspace)) {
+            // same as current workspace
+            String msg = srcWorkspace + ": illegal workspace (same as current)";
+            log.debug(msg);
+            throw new RepositoryException(msg);
+        }
+
+        // @todo re-implement Workspace#clone (respect new removeExisting flag, etc)
-        ItemStateManager srcStateMgr = rep.getWorkspaceStateManager(srcWorkspace);
-        // FIXME need to setup a hierarchy manager for source workspace
-        HierarchyManagerImpl srcHierMgr =
-                new HierarchyManagerImpl(rep.getRootNodeUUID(), srcStateMgr, session.getNamespaceResolver());
+
+        // aquire session on other workspace (throws NoSuchWorkspaceException)
+        // @todo FIXME need to get session with same credentials as current
+        SessionImpl srcSession = rep.getSystemSession(srcWorkspace);
+        WorkspaceImpl srcWsp = (WorkspaceImpl) srcSession.getWorkspace();
+
-        internalCopy(srcAbsPath, srcStateMgr, srcHierMgr,
-                destAbsPath, stateMgr, hierMgr,
-                session.getAccessManager(), session.getNamespaceResolver(),
-                rep.getNodeTypeRegistry(), true);
+        internalCopy(srcAbsPath, srcWsp, destAbsPath, true);
-        internalCopy(srcAbsPath, stateMgr, hierMgr,
-                destAbsPath, stateMgr, hierMgr,
-                session.getAccessManager(), session.getNamespaceResolver(),
-                rep.getNodeTypeRegistry(), false);
+        internalCopy(srcAbsPath, this, destAbsPath, false);
+        // check workspace name
+        if (getName().equals(srcWorkspace)) {
+            // same as current workspace, delegate to intra-workspace copy method
+            copy(srcAbsPath, destAbsPath);
+            return;
+        }
+
-        ItemStateManager srcStateMgr = rep.getWorkspaceStateManager(srcWorkspace);
-        // FIXME need to setup a hierarchy manager for source workspace
-        HierarchyManagerImpl srcHierMgr = new HierarchyManagerImpl(rep.getRootNodeUUID(), srcStateMgr, session.getNamespaceResolver());
+
+        // aquire session on other workspace (throws NoSuchWorkspaceException)
+        // @todo FIXME need to get session with same credentials as current
+        SessionImpl srcSession = rep.getSystemSession(srcWorkspace);
+        WorkspaceImpl srcWsp = (WorkspaceImpl) srcSession.getWorkspace();
+
-        internalCopy(srcAbsPath, srcStateMgr, srcHierMgr,
-                destAbsPath, stateMgr, hierMgr,
-                session.getAccessManager(), session.getNamespaceResolver(),
-                rep.getNodeTypeRegistry(), false);
+        internalCopy(srcAbsPath, srcWsp, destAbsPath, false);
-            targetState = getNodeState(srcPath, hierMgr, stateMgr);
-            srcParentState = getNodeState(srcParentPath, hierMgr, stateMgr);
+            targetState = getNodeState(srcPath);
+            srcParentState = getNodeState(srcParentPath);
-            destParentState = getNodeState(destParentPath, hierMgr, stateMgr);
+            destParentState = getNodeState(destParentPath);
-        verifyCheckedOut(srcParentPath, hierMgr, stateMgr);
-        verifyCheckedOut(destParentPath, hierMgr, stateMgr);
+        verifyCheckedOut(srcParentPath);
+        verifyCheckedOut(destParentPath);
-        checkRemoveNode(srcPath, rep.getNodeTypeRegistry(),
-                session.getAccessManager(), hierMgr, stateMgr);
-        checkAddNode(destPath, targetState.getNodeTypeName(),
-                rep.getNodeTypeRegistry(), session.getAccessManager(),
-                hierMgr, stateMgr);
+        checkRemoveNode(srcPath);
+        checkAddNode(destPath, targetState.getNodeTypeName());
-            ChildNodeDef newTargetDef = findApplicableDefinition(destName.getName(), targetState.getNodeTypeName(), destParentState, rep.getNodeTypeRegistry());
+            ChildNodeDef newTargetDef = findApplicableDefinition(destName.getName(), targetState.getNodeTypeName(), destParentState);
+        // check path & retrieve state
+        Path targetPath;
+        NodeState targetState;
+
+        try {
+            targetPath = Path.create(parentAbsPath, session.getNamespaceResolver(), true);
+            targetState = getNodeState(targetPath);
+        } catch (MalformedPathException mpe) {
+            String msg = "invalid path: " + parentAbsPath;
+            log.debug(msg);
+            throw new RepositoryException(msg, mpe);
+        }
+
+        // make sure target node is checked-out
+        verifyCheckedOut(targetPath);
+
+        // @todo check locked-status
+
+        // check node type constraints & access rights
+        checkAddNode(targetPath, targetState.getNodeTypeName());
+

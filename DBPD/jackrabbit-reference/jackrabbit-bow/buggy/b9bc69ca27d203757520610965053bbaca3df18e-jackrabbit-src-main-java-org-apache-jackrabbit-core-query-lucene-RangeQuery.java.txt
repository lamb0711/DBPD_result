JCR-638: Support lower-/upper-case functions

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@475677 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.List;
+import java.util.ArrayList;
+import java.util.Iterator;
-public class RangeQuery extends Query {
+public class RangeQuery extends Query implements TransformConstants {
+     * How the term enum is transformed before it is compared to lower and upper
+     * term.
+     */
+    private final int transform;
+
+    /**
+     * @param transform how term enums are transformed when read from the index.
-    public RangeQuery(Term lowerTerm, Term upperTerm, boolean inclusive) {
+    public RangeQuery(Term lowerTerm, Term upperTerm, boolean inclusive, int transform) {
+        this.transform = transform;
-        Query stdRangeQueryImpl
-                = new org.apache.lucene.search.RangeQuery(lowerTerm, upperTerm, inclusive);
-        try {
-            return stdRangeQueryImpl.rewrite(reader);
-        } catch (BooleanQuery.TooManyClauses e) {
-            log.debug("Too many terms to enumerate, using custom RangeQuery");
-            // failed, use own implementation
+        if (transform == TRANSFORM_NONE) {
+            Query stdRangeQueryImpl
+                    = new org.apache.lucene.search.RangeQuery(lowerTerm, upperTerm, inclusive);
+            try {
+                return stdRangeQueryImpl.rewrite(reader);
+            } catch (BooleanQuery.TooManyClauses e) {
+                log.debug("Too many terms to enumerate, using custom RangeQuery");
+                // failed, use own implementation
+                return this;
+            }
+        } else {
+            // always use our implementation when we need to transform the
+            // term enum
+            key.append('\uFFFF');
+            key.append(transform);
-            TermEnum enumerator = reader.terms(lowerTerm);
+            String testField = getField();
-            try {
-                boolean checkLower = false;
-                if (!inclusive) {
-                    // make adjustments to set to exclusive
-                    checkLower = true;
-                }
+            boolean checkLower = false;
+            if (!inclusive || transform != TRANSFORM_NONE) {
+                // make adjustments to set to exclusive
+                checkLower = true;
+            }
-                String testField = getField();
+            int propNameLength = FieldNames.getNameLength(lowerTerm.text());
+            String namePrefix = "";
+            if (propNameLength > 0) {
+                namePrefix = lowerTerm.text().substring(0, propNameLength);
+            }
+            List startTerms = new ArrayList(2);
-                TermDocs docs = reader.termDocs();
+            if (transform == TRANSFORM_NONE || lowerTerm.text().length() <= propNameLength) {
+                // use lowerTerm as is
+                startTerms.add(lowerTerm);
+            } else {
+                // first enumerate terms using lower case start character
+                StringBuffer termText = new StringBuffer(propNameLength + 1);
+                termText.append(lowerTerm.text().subSequence(0, propNameLength));
+                char startCharacter = lowerTerm.text().charAt(propNameLength);
+                termText.append(Character.toLowerCase(startCharacter));
+                startTerms.add(new Term(lowerTerm.field(), termText.toString()));
+                // second enumerate terms using upper case start character
+                termText.setCharAt(termText.length() - 1, Character.toUpperCase(startCharacter));
+                startTerms.add(new Term(lowerTerm.field(), termText.toString()));
+            }
+
+            for (Iterator it = startTerms.iterator(); it.hasNext(); ) {
+                Term startTerm = (Term) it.next();
+
+                TermEnum terms = reader.terms(startTerm);
-                    do {
-                        Term term = enumerator.term();
-                        if (term != null && term.field() == testField) {
-                            if (!checkLower || term.text().compareTo(lowerTerm.text()) > 0) {
-                                checkLower = false;
+                    TermDocs docs = reader.termDocs();
+                    try {
+                        do {
+                            Term term = terms.term();
+                            if (term != null && term.field() == testField) {
+                                if (checkLower) {
+                                    int compare = termCompare(term.text(), lowerTerm.text(), propNameLength);
+                                    if (compare > 0 || compare == 0 && inclusive) {
+                                        // do not check lower term anymore if no
+                                        // transformation is done on the term enum
+                                        checkLower = transform == TRANSFORM_NONE ? false : true;
+                                    } else {
+                                        // continue with next term
+                                        continue;
+                                    }
+                                }
-                                    int compare = upperTerm.text().compareTo(term.text());
+                                    int compare = termCompare(term.text(), upperTerm.text(), propNameLength);
-                                    // this is equal to the upper term, break out
-                                    if ((compare < 0) || (!inclusive && compare == 0)) {
-                                        break;
+                                    // this is equal to the upper term
+                                    if ((compare > 0) || (!inclusive && compare == 0)) {
+                                        // only break out if no transformation
+                                        // was done on the term from the enum
+                                        if (transform == TRANSFORM_NONE) {
+                                            break;
+                                        } else {
+                                            // because of the transformation
+                                            // it is possible that the next
+                                            // term will be included again if
+                                            // we still enumerate on the same
+                                            // property name
+                                            if (term.text().startsWith(namePrefix)) {
+                                                continue;
+                                            } else {
+                                                break;
+                                            }
+                                        }
-                                docs.seek(enumerator);
+                                docs.seek(terms);
+                            } else {
+                                break;
-                        } else {
-                            break;
-                        }
-                    } while (enumerator.next());
+                        } while(terms.next());
+                    } finally {
+                        docs.close();
+                    }
-                    docs.close();
+                    terms.close();
-            } finally {
-                enumerator.close();
+
+
+        /**
+         * Compares the <code>text</code> with the <code>other</code> String. This
+         * implementation behaves like {@link String#compareTo(Object)} but also
+         * respects the {@link RangeQuery#transform} property.
+         *
+         * @param text   the text to compare to <code>other</code>. The
+         *               transformation function is applied to this parameter before
+         *               it is compared to <code>other</code>.
+         * @param other  the other String.
+         * @param offset start comparing the two strings at <code>offset</code>.
+         * @return see {@link String#compareTo(Object)}. But also respects {@link
+         *         #transform}.
+         */
+        private int termCompare(String text, String other, int offset) {
+            OffsetCharSequence seq1 = new OffsetCharSequence(offset, text, transform);
+            OffsetCharSequence seq2 = new OffsetCharSequence(offset, other);
+            return seq1.compareTo(seq2);
+        }

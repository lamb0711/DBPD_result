work in progress

- replace ItemImpl by Item in ItemManager interface and adjust
  usages.
- change all setters on ItemState and derived classes from public to
  package private
- NodeState: use collection return value instead of set/list whereever possible
- WorkspaceManager: put ItemStateFactory to a separate class and
  remove unused inner class NodeReferenceImpl 
- add methods to NodeState/PropertyState that avoids return a null
  QItemDefinition and remove corresponding methods from NodeTypeManagerImpl
- remove ItemDefinitionManager.
- VersionHistoryImpl: add safety check if cne for root version really exists
- Fix ImporterImpl: ItemState.getDefinition() may return 'null' value.
  use method instead, that sets the definition if it is still missing.
- javadoc and code formatting


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@430031 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeConflictException;
+import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeRegistry;
+import org.apache.jackrabbit.jcr2spi.nodetype.EffectiveNodeType;
+import javax.jcr.RepositoryException;
-    
+
-            def = nodeState.getDefinition();
+            def = nodeState.def;
-            for (Iterator it = nodeState.getPropertyNames().iterator(); it.hasNext(); ) {
+            Iterator it = nodeState.getPropertyNames().iterator();
+            while (it.hasNext()) {
-            for (Iterator it = nodeState.getChildNodeEntries().iterator(); it.hasNext(); ) {
+            it = nodeState.getChildNodeEntries().iterator();
+            while (it.hasNext()) {
-    //-----------------------------------------------------< public methods >---
+    //----------------------< public READ methods and package private WRITE >---
+     * Sets the the parent <code>NodeState</code>.
+     *
+     * @param parent the parent <code>NodeState</code> or <code>null</code>
+     * if either this node state should represent the root node or this node
+     * state should be 'free floating', i.e. detached from the repository's
+     * hierarchy.
+     */
+    void setParent(NodeState parent) {
+        this.parent = parent;
+    }
+
+    /**
-     * Sets the Id of the parent <code>NodeState</code>.
-     *
-     * @param parent the parent <code>NodeState</code> or <code>null</code>
-     * if either this node state should represent the root node or this node
-     * state should be 'free floating', i.e. detached from the repository's
-     * hierarchy.
-     */
-    public void setParent(NodeState parent) {
-        this.parent = parent;
-    }
-
-    /**
+     * Set the node type name. Needed for deserialization and should therefore
+     * not change the internal status.
+     *
+     * @param nodeTypeName node type name
+     */
+    synchronized void setNodeTypeName(QName nodeTypeName) {
+        this.nodeTypeName = nodeTypeName;
+    }
+
+    /**
-    public synchronized void setMixinTypeNames(QName[] mixinTypeNames) {
+    synchronized void setMixinTypeNames(QName[] mixinTypeNames) {
-     * Returns the id of the definition applicable to this node state.
+     * Returns the {@link QNodeDefinition definition} defined for this
+     * node state or <code>null</code> if the definition has not been
+     * set before (i.e. the corresponding item has not been accessed before).
-     * @return the id of the definition
+     * @return definition of this state
+     * @see #getDefinition(NodeTypeRegistry) for the corresponding method
+     * that never returns <code>null</code>.
+     * Returns the definition applicable to this node state. Since the definition
+     * is not defined upon state creation this state may have to retrieve
+     * the definition from the given <code>NodeTypeRegistry</code> first.
+     *
+     * @param ntRegistry
+     * @return the definition of this state
+     * @see #getDefinition()
+     */
+    public QNodeDefinition getDefinition(NodeTypeRegistry ntRegistry)
+        throws RepositoryException {
+        // make sure the state has the definition set now
+        if (def == null) {
+            NodeState parentState = getParent();
+            try {
+                if (parentState == null) {
+                    // special case for root state
+                    def = ntRegistry.getRootNodeDef();
+                } else {
+                    ChildNodeEntry cne = parentState.getChildNodeEntry(getNodeId());
+                    EffectiveNodeType ent = ntRegistry.getEffectiveNodeType(parentState.getNodeTypeNames());
+                    setDefinition(ent.getApplicableNodeDefinition(cne.getName(), getNodeTypeName()));
+                }
+            } catch (NodeTypeConflictException e) {
+                String msg = "internal error: failed to build effective node type.";
+                log.debug(msg);
+                throw new RepositoryException(msg, e);
+            }
+
+        }
+        return def;
+    }
+
+    /**
-    public void setDefinition(QNodeDefinition def) {
+    void setDefinition(QNodeDefinition def) {
-     * specified <code>NodeId</code>.
-     *
-     * @param id the id of the child node
-     * @return <code>true</code> if there is a <code>ChildNodeEntry</code> with
-     *         the specified <code>name</code>.
-     */
-    public synchronized boolean hasChildNodeEntry(NodeId id) {
-        return childNodeEntries.get(id) != null;
-    }
-
-    /**
-     * Determines if there is a <code>ChildNodeEntry</code> with the
-     * Determines if there is a property entry with the specified
-     * <code>QName</code>.
-     *
-     * @param propName <code>QName</code> object specifying a property name
-     * @return <code>true</code> if there is a property entry with the specified
-     *         <code>QName</code>.
-     */
-    public synchronized boolean hasPropertyName(QName propName) {
-        return properties.containsKey(propName);
-    }
-
-    /**
-     * Returns a list of <code>ChildNodeEntry</code> objects denoting the
-     * child nodes of this node.
+     * Returns a unmodifiable collection of <code>ChildNodeEntry</code> objects
+     * denoting the child nodes of this node.
-     * @return list of <code>ChildNodeEntry</code> objects
+     * @return collection of <code>ChildNodeEntry</code> objects
-    public synchronized List getChildNodeEntries() {
-        return Collections.unmodifiableList(childNodeEntries);
+    public synchronized Collection getChildNodeEntries() {
+        // NOTE: List representation of 'ChildNodeEntries' is already unmodifiable
+        return childNodeEntries;
-     * Returns a list of <code>ChildNodeEntry</code>s with the specified name.
+     * Returns a unmodifiable list of <code>ChildNodeEntry</code>s with the
+     * specified name.
-        return Collections.unmodifiableList(childNodeEntries.get(nodeName));
+        // NOTE: SubList retrieved from 'ChildNodeEntries' is already unmodifiable
+        return childNodeEntries.get(nodeName);
-    public synchronized ChildNodeEntry addChildNodeEntry(QName nodeName,
+    synchronized ChildNodeEntry addChildNodeEntry(QName nodeName,
-    public synchronized boolean renameChildNodeEntry(QName oldName, int index,
+    synchronized boolean renameChildNodeEntry(QName oldName, int index,
-    public synchronized boolean removeChildNodeEntry(QName nodeName, int index) {
+    synchronized boolean removeChildNodeEntry(QName nodeName, int index) {
-    public synchronized boolean removeChildNodeEntry(NodeId id) {
+    synchronized boolean removeChildNodeEntry(NodeId id) {
-    public synchronized void removeAllChildNodeEntries() {
+    synchronized void removeAllChildNodeEntries() {
-    public synchronized void setChildNodeEntries(List nodeEntries) {
+    synchronized void setChildNodeEntries(List nodeEntries) {
+     * Determines if there is a property entry with the specified
+     * <code>QName</code>.
+     *
+     * @param propName <code>QName</code> object specifying a property name
+     * @return <code>true</code> if there is a property entry with the specified
+     *         <code>QName</code>.
+     */
+    public synchronized boolean hasPropertyName(QName propName) {
+        return properties.containsKey(propName);
+    }
+
+    /**
-    public synchronized Set getPropertyNames() {
+    public synchronized Collection getPropertyNames() {
-    public synchronized void addPropertyName(QName propName) {
+    synchronized void addPropertyName(QName propName) {
-    public synchronized boolean removePropertyName(QName propName) {
+    synchronized boolean removePropertyName(QName propName) {
-    public synchronized void removeAllPropertyNames() {
+    synchronized void removeAllPropertyNames() {
-    public synchronized void setPropertyNames(Set propNames) {
+    synchronized void setPropertyNames(Set propNames) {
-     * Set the node type name. Needed for deserialization and should therefore
-     * not change the internal status.
-     *
-     * @param nodeTypeName node type name
-     */
-    public synchronized void setNodeTypeName(QName nodeTypeName) {
-        this.nodeTypeName = nodeTypeName;
-    }
-
-    /**
-        return (PropertyState) propRef.resolve();
-    }
-
-    /**
-     * Returns the node state with the given relative path.
-     *
-     * @param relPath the relative path (actually PathElement) of the child node
-     *                state.
-     * @return the child node state
-     * @throws NoSuchItemStateException if there is no node state with the given
-     *                                  <code>relPath</code>.
-     * @throws ItemStateException       if an error occurs while retrieving the
-     *                                  node state.
-     */
-    public synchronized NodeState getNodeState(Path.PathElement relPath)
-            throws NoSuchItemStateException, ItemStateException {
-        ChildNodeEntry cne = childNodeEntries.get(relPath.getName(), relPath.getNormalizedIndex());
-        if (cne == null) {
-            Path p = Path.create(relPath.getName(), relPath.getIndex());
-            NodeId id = idFactory.createNodeId(getNodeId(), p);
-            throw new NoSuchItemStateException(id.toString());
-        }
-        return cne.getNodeState();
+        return propRef.getPropertyState();
-    //--------------------------------------------------< ItemState overrides >
+    /**
+     * TODO: find a better way to provide the index of a child node entry
+     * Returns the index of the given <code>ChildNodeEntry</code> and with
+     * <code>name</code>.
+     *
+     * @param name the name of the child node.
+     * @param cne  the <code>ChildNodeEntry</code> instance.
+     * @return the index of the child node entry or <code>0</code> if it is not
+     *         found in this <code>NodeState</code>.
+     */
+    int getChildNodeIndex(QName name, ChildNodeEntry cne) {
+        List sns = childNodeEntries.get(name);
+        return sns.indexOf(cne) + 1;
+    }
+
+    //---------------------------------------------------< Listener support >---
-    /**
-     * TODO: find a better way to provide the index of a child node entry
-     * Returns the index of the given <code>ChildNodeEntry</code> and with
-     * <code>name</code>.
-     *
-     * @param name the name of the child node.
-     * @param cne  the <code>ChildNodeEntry</code> instance.
-     * @return the index of the child node entry or <code>0</code> if it is not
-     *         found in this <code>NodeState</code>.
-     */
-    int getChildNodeIndex(QName name, ChildNodeEntry cne) {
-        List sns = childNodeEntries.get(name);
-        return sns.indexOf(cne) + 1;
-    }
-
-    //-------------------------------------------------< misc. helper methods >
+    //----------------------------------------------< Listener notification >---
-    //--------------------------------------------------------< inner classes >
+    //------------------------------------------------------< inner classes >---
-

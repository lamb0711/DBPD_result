JCR-977: jcr:deref in xpath predicates

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@791737 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.spi.commons.conversion.MalformedPathException;
+import org.apache.jackrabbit.spi.PathFactory;
-import org.apache.jackrabbit.spi.commons.name.PathBuilder;
+import org.apache.jackrabbit.spi.commons.name.PathFactoryImpl;
+import org.apache.lucene.queryParser.ParseException;
+import org.apache.lucene.queryParser.QueryParser;
-import org.apache.lucene.queryParser.QueryParser;
-import org.apache.lucene.queryParser.ParseException;
+     * The path factory instance.
+     */
+    private static final PathFactory PATH_FACTORY = PathFactoryImpl.getInstance();
+
+    /**
+     * The name of a parent path element.
+     */
+    private static final Name PARENT_ELEMENT_NAME = PATH_FACTORY.getParentElement().getName();
+
+    /**
+            if (node.getNameTest().equals(PARENT_ELEMENT_NAME)) {
+                andQuery.add(new ParentAxisQuery(context, null, indexFormatVersion, nsMappings), Occur.MUST);
+                return andQuery;
+            }
+        PathQueryNode relPath = node.getRelativePath();
+        if (relPath == null
+                && node.getOperation() != QueryConstants.OPERATION_SIMILAR
+                && node.getOperation() != QueryConstants.OPERATION_SPELLCHECK) {
+            exceptions.add(new InvalidQueryException("@* not supported in predicate"));
+            return data;
+        }
+        LocationStepQueryNode[] steps = relPath.getPathSteps();
+        Name propertyName = steps[steps.length - 1].getNameTest();
+        
-                    Name propertyName = node.getRelativePath().getNameElement().getName();
-        if (node.getRelativePath() == null
-                && node.getOperation() != QueryConstants.OPERATION_SIMILAR
-                && node.getOperation() != QueryConstants.OPERATION_SPELLCHECK) {
-            exceptions.add(new InvalidQueryException("@* not supported in predicate"));
-            return data;
-        }
-
-        Path relPath = node.getRelativePath();
-            // add the name of a dummy property because relPath actually
+            // use the name of a dummy property because relPath actually
-            PathBuilder builder;
-            if (relPath == null) {
-                builder = new PathBuilder();
-            } else {
-                builder = new PathBuilder(relPath);
-            }
-            builder.addLast(NameConstants.JCR_PRIMARYTYPE);
-            try {
-                relPath = builder.getPath();
-            } catch (MalformedPathException e) {
-                // will never happen
-            }
+            propertyName = NameConstants.JCR_PRIMARYTYPE;
-            field = resolver.getJCRName(relPath.getNameElement().getName());
+            field = resolver.getJCRName(propertyName);
-        Name propName = relPath.getNameElement().getName();
-        if (propName.getNamespaceURI().equals(SearchManager.NS_FN_URI)
-                && propName.getLocalName().equals("name()")) {
+        if (propertyName.getNamespaceURI().equals(SearchManager.NS_FN_URI)
+                && propertyName.getLocalName().equals("name()")) {
-        if (relPath.getLength() > 1) {
+        if (steps.length > 1) {
-            Path.Element[] elements = relPath.getElements();
-            for (int i = elements.length - 2; i >= 0; i--) {
+            boolean selectParent = true; 
+            for (int i = steps.length - 2; i >= 0; i--) {
+                LocationStepQueryNode step = steps[i];
-                if (!elements[i].getName().equals(RelationQueryNode.STAR_NAME_TEST)) {
-                    name = elements[i].getName();
+                if (!RelationQueryNode.STAR_NAME_TEST.equals(steps[i].getNameTest())) {
+                    name = steps[i].getNameTest();
-                if (i == elements.length - 2) {
-                    // join name test with property query if there is one
-                    if (name != null) {
-                        Query nameTest = new NameQuery(name,
-                                indexFormatVersion, nsMappings);
-                        BooleanQuery and = new BooleanQuery();
-                        and.add(query, Occur.MUST);
-                        and.add(nameTest, Occur.MUST);
-                        query = and;
-                    } else {
-                        // otherwise the query can be used as is
+                if (i == steps.length - 2) {
+                    if (step instanceof DerefQueryNode) {
+                        query = createPredicateDeref(query, (DerefQueryNode) step, data);
+                        if (steps.length == 2) {
+                            selectParent = false;
+                        }
+                    } else if (step instanceof LocationStepQueryNode) {
+                        // join name test with property query if there is one
+                        if (name != null) {
+                            if (!name.equals(PARENT_ELEMENT_NAME)) {
+                                Query nameTest = new NameQuery(name,
+                                        indexFormatVersion, nsMappings);
+                                BooleanQuery and = new BooleanQuery();
+                                and.add(query, Occur.MUST);
+                                and.add(nameTest, Occur.MUST);
+    
+                                query = and;
+                            } else {
+                                // If we're searching the parent, we want to return the child axis,
+                                // not the parent because this is part of the predicate. For instance,
+                                // if the query is //child[../base], this part of the code is operating
+                                // on the "../base" portion. So we want to return all the child nodes
+                                // of "base", which will then be matched against the non predicate part.
+                                query = new ChildAxisQuery(sharedItemMgr,
+                                                           query,
+                                                           null,
+                                                           indexFormatVersion,
+                                                           nsMappings);
+                                selectParent = false;
+                            }
+                        } else {
+                            // otherwise the query can be used as is
+                        }
+                } else if (name != null && name.equals(PARENT_ELEMENT_NAME)) {
+                    // We need to select one of the properties if we haven't already.
+                    if (selectParent) { 
+                        query = new ParentAxisQuery(query, null,
+                                                    indexFormatVersion, nsMappings);
+
+                        selectParent = false;
+                    }
+
+                    // See the note above on searching parents
+                    query = new ChildAxisQuery(sharedItemMgr,
+                                               query,
+                                               null,
+                                               indexFormatVersion,
+                                               nsMappings);
-                    query = new ParentAxisQuery(query, name,
-                            indexFormatVersion, nsMappings);
+                    if (step instanceof LocationStepQueryNode) {
+                        query = new ParentAxisQuery(query, name, indexFormatVersion, nsMappings);
+                    } else {
+                        throw new UnsupportedOperationException();
+                    }
-            query = new ParentAxisQuery(query, null,
-                    indexFormatVersion, nsMappings);
+            if (selectParent) {
+                query = new ParentAxisQuery(query, null, indexFormatVersion, nsMappings);
+            }
+    
+    public Query createPredicateDeref(Query subQuery, DerefQueryNode node, Object data) throws RepositoryException {
+        Query context = (Query) data;
+        
+        if (context == null) {
+            exceptions.add(new IllegalArgumentException("Unsupported query"));
+        }
+
+        try {
+            String refProperty = resolver.getJCRName(node.getRefProperty());
+
+            context = new PredicateDerefQuery(subQuery, refProperty, node.getNameTest(),
+                    indexFormatVersion, nsMappings);
+
+            // attach predicates
+            Object[] predicates = node.acceptOperands(this, data);
+            if (predicates.length > 0) {
+                BooleanQuery andQuery = new BooleanQuery();
+                for (int i = 0; i < predicates.length; i++) {
+                    andQuery.add((Query) predicates[i], Occur.MUST);
+                }
+                andQuery.add(context, Occur.MUST);
+                context = andQuery;
+            }
+            
+        } catch (NamespaceException e) {
+            // should never happen
+            exceptions.add(e);
+        }
+
+        return context;
+    }

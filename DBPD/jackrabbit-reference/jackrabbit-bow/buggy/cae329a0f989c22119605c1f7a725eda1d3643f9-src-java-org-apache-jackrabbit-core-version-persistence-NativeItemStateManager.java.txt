reworked transaction support, contributed by dominique

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@151380 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.collections.ReferenceMap;
-import java.util.*;
-import java.io.PrintStream;
-        implements ItemStateManager, ItemStateListener {
+        implements UpdatableItemStateManager, ItemStateListener {
-     * A cache for <code>NodeReferences</code> objects.
+     * Flag indicating whether this item state manager is in edit mode
-    private Map refsCache = new ReferenceMap(ReferenceMap.HARD, ReferenceMap.SOFT);
+    private boolean editMode;
+
+    /**
+     * Change log
+     */
+    private ChangeLog changeLog;
-        ArrayList states = new ArrayList();
-        states.add(rootState);
-        states.add(prop);
-
-        // do persist root node (incl. properties)
-        store(states, Collections.EMPTY_LIST);
+        ChangeLog changeLog = new ChangeLog();
+        changeLog.added(rootState);
+        changeLog.added(prop);
+        store(changeLog);
-        NodeState state = persistMgr.load(id.getUUID());
+        NodeState state = persistMgr.load(id);
-        PropertyState state = persistMgr.load(id.getName(), id.getParentUUID());
+        PropertyState state = persistMgr.load(id);
-            return persistMgr.exists(id);
+            if (id.denotesNode()) {
+                return persistMgr.exists((NodeId) id);
+            } else {
+                return persistMgr.exists((PropertyId) id);
+            }
-    public synchronized NodeReferences getNodeReferences(NodeId targetId)
+    public synchronized NodeReferences getNodeReferences(NodeReferencesId id)
-        if (refsCache.containsKey(targetId)) {
-            return (NodeReferences) refsCache.get(targetId);
-        }
-
-            refs = persistMgr.load(targetId);
+            refs = persistMgr.load(id);
-            refs = new NodeReferences(targetId);
+            refs = new NodeReferences(id);
-        refsCache.put(targetId, refs);
-     * @see ItemStateManager#beginUpdate
+     * @see UpdatableItemStateManager#edit
-    public UpdateOperation beginUpdate() throws ItemStateException {
-        return new Update();
+    public void edit() throws ItemStateException {
+        if (editMode) {
+            throw new ItemStateException("Already in edit mode.");
+        }
+        editMode = true;
+
+        changeLog = new ChangeLog();
+    }
+
+    /**
+     * @see UpdatableItemStateManager#createNew
+     */
+    public NodeState createNew(String uuid, QName nodeTypeName,
+                               String parentUUID) {
+
+        if (!editMode) {
+            throw new IllegalStateException("Not in edit mode");
+        }
+        return createInstance(uuid, nodeTypeName, parentUUID);
+    }
+
+    /**
+     * @see UpdatableItemStateManager#createNew
+     */
+    public PropertyState createNew(QName propName, String parentUUID) {
+        if (!editMode) {
+            throw new IllegalStateException("Not in edit mode");
+        }
+        return createInstance(propName, parentUUID);
+    }
+
+    /**
+     * @see UpdatableItemStateManager#store
+     */
+    public void store(ItemState state) {
+        if (!editMode) {
+            throw new IllegalStateException("Not in edit mode");
+        }
+        changeLog.modified(state);
+    }
+
+    /**
+     * @see UpdatableItemStateManager#store
+     */
+    public void store(NodeReferences refs) {
+        if (!editMode) {
+            throw new IllegalStateException("Not in edit mode");
+        }
+        changeLog.modified(refs);
+    }
+
+    /**
+     * @see UpdatableItemStateManager#destroy
+     */
+    public void destroy(ItemState state) {
+        if (!editMode) {
+            throw new IllegalStateException("Not in edit mode");
+        }
+        changeLog.deleted(state);
+    }
+
+    /**
+     * @see UpdatableItemStateManager#cancel
+     */
+    public void cancel() {
+        editMode = false;
+
+        changeLog.discard();
+    }
+
+    /**
+     * @see UpdatableItemStateManager#update
+     */
+    public void update() throws ItemStateException {
+        store(changeLog);
+
+        editMode = false;
-        NodeState state = persistMgr.createNew(uuid, nodeTypeName, parentUUID);
+        NodeState state = persistMgr.createNew(new NodeId(uuid));
+        state.setNodeTypeName(nodeTypeName);
+        state.setParentUUID(parentUUID);
-        PropertyState state = persistMgr.createNew(propName, parentUUID);
+        PropertyState state = persistMgr.createNew(new PropertyId(parentUUID, propName));
-     * Store modified states and node references, atomically.
-     *
-     * @param states         states that have been modified
-     * @param refsCollection collection of refs to store
+     * Save all states and node references, atomically.
+     * @param changeLog change log containing states that were changed
-    private void store(Collection states, Collection refsCollection)
+    private synchronized void store(ChangeLog changeLog)
-        persistMgr.store(states.iterator(), refsCollection.iterator());
-
-        Iterator iter = states.iterator();
-        while (iter.hasNext()) {
-            ItemState state = (ItemState) iter.next();
-            int status = state.getStatus();
-
-            switch (status) {
-                case ItemState.STATUS_NEW:
-                    //state.notifyStateCreated();
-                    state.setStatus(ItemState.STATUS_EXISTING);
-                    break;
-
-                case ItemState.STATUS_EXISTING_REMOVED:
-                    //state.notifyStateDestroyed();
-                    state.discard();
-                    break;
-
-                default:
-                    //state.notifyStateUpdated();
-                    state.setStatus(ItemState.STATUS_EXISTING);
-                    break;
-            }
-        }
+        persistMgr.store(changeLog);
+        changeLog.persisted();
-
-
-    class Update implements UpdateOperation {
-
-        /**
-         * Modified states
-         */
-        private final List states = new ArrayList();
-
-        /**
-         * Modified references
-         */
-        private final List refsCollection = new ArrayList();
-
-        /**
-         * @see UpdateOperation#createNew
-         */
-        public NodeState createNew(String uuid, QName nodeTypeName,
-                                   String parentUUID) {
-            return createInstance(uuid, nodeTypeName, parentUUID);
-        }
-
-        /**
-         * @see UpdateOperation#createNew
-         */
-        public PropertyState createNew(QName propName, String parentUUID) {
-            return createInstance(propName, parentUUID);
-        }
-
-        /**
-         * @see UpdateOperation#store
-         */
-        public void store(ItemState state) {
-            states.add(state);
-        }
-
-        /**
-         * @see UpdateOperation#store
-         */
-        public void store(NodeReferences refs) {
-            refsCollection.add(refs);
-        }
-
-        /**
-         * @see UpdateOperation#destroy
-         */
-        public void destroy(ItemState state) {
-            state.setStatus(ItemState.STATUS_EXISTING_REMOVED);
-            states.add(state);
-        }
-
-        /**
-         * @see UpdateOperation#end
-         */
-        public void end() throws ItemStateException {
-            NativeItemStateManager.this.store(states, refsCollection);
-        }
-    }
-

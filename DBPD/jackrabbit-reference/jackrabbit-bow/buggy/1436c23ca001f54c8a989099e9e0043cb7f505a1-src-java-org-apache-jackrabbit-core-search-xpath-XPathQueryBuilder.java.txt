- Removed JCRQL implementation
- Added proper QName support to search
- redesigned parsing and formating of queries (better separation of abstract query tree and concrete syntax)
- Some improvements in SQL: colon is now supported in identifier without having to use double quotes, LIKE now supports escaping

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@125778 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.search.TextsearchQueryNode;
+import org.apache.jackrabbit.core.search.NodeTypeQueryNode;
+import org.apache.jackrabbit.core.IllegalNameException;
+import org.apache.jackrabbit.core.UnknownPrefixException;
+import org.apache.jackrabbit.core.nodetype.NodeTypeRegistry;
-    private static final QName FN_NOT = new QName(SearchManager.NS_FN_URI, "not");
+    static final QName FN_NOT = new QName(SearchManager.NS_FN_URI, "not");
-    private static final QName FN_NOT_10 = new QName("", "not");
+    static final QName FN_NOT_10 = new QName("", "not");
-    private static final QName XS_DATETIME = new QName(SearchManager.NS_XS_URI, "dateTime");
+    static final QName XS_DATETIME = new QName(SearchManager.NS_XS_URI, "dateTime");
+
+    /** QName for jcrfn:like */
+    static final QName JCRFN_LIKE = new QName(SearchManager.NS_JCRFN_URI, "like");
+
+    /** QName for jcrfn:contains */
+    static final QName JCRFN_CONTAINS = new QName(SearchManager.NS_JCRFN_URI, "contains");
-            String nameTest = steps[0].getNameTest();
-            if (nameTest == null || nameTest.length() > 0) {
+            QName nameTest = steps[0].getNameTest();
+            if (nameTest == null || nameTest.getLocalName().length() > 0) {
+     * Creates a String representation of the query node tree in XPath syntax.
+     * @param root the root of the query node tree.
+     * @param resolver to resolve QNames.
+     * @return a String representation of the query node tree.
+     * @throws InvalidQueryException if the query node tree cannot be converted
+     *   into a String representation due to restrictions in XPath.
+     */
+    public static String toString(QueryRootNode root, NamespaceResolver resolver)
+            throws InvalidQueryException {
+        return QueryFormat.toString(root, resolver);
+    }
+
+    /**
-                ((PathQueryNode) data).addPathStep(new LocationStepQueryNode((QueryNode) data, "", false));
+                ((PathQueryNode) data).addPathStep(new LocationStepQueryNode((QueryNode) data, new QName("", ""), false));
-                ((PathQueryNode) data).addPathStep(new LocationStepQueryNode((QueryNode) data, "", false));
+                ((PathQueryNode) data).addPathStep(new LocationStepQueryNode((QueryNode) data, new QName("", ""), false));
-                    // @todo do what?
-                        || data instanceof RelationQueryNode) {
+                        || data instanceof RelationQueryNode
+                        || data instanceof PathQueryNode) {
-                if (queryNode instanceof LocationStepQueryNode) {
-                    ((LocationStepQueryNode) queryNode).setNameTest(child.getValue());
-                } else if (queryNode instanceof RelationQueryNode) {
-                    ((RelationQueryNode) queryNode).setProperty(child.getValue());
+                try {
+                    if (queryNode instanceof LocationStepQueryNode) {
+                        QName name = ISO9075.decode(QName.fromJCRName(child.getValue(), resolver));
+                        ((LocationStepQueryNode) queryNode).setNameTest(name);
+                    } else if (queryNode instanceof RelationQueryNode) {
+                        QName name = ISO9075.decode(QName.fromJCRName(child.getValue(), resolver));
+                        ((RelationQueryNode) queryNode).setProperty(name);
+                    } else if (queryNode instanceof PathQueryNode) {
+                        QName name = ISO9075.decode(QName.fromJCRName(child.getValue(), resolver));
+                        root.addSelectProperty(name);
+                    }
+                } catch (IllegalNameException e) {
+                    exceptions.add(new InvalidQueryException("Illegal name: " + child.getValue()));
+                } catch (UnknownPrefixException e) {
+                    exceptions.add(new InvalidQueryException("Unknown prefix: " + child.getValue()));
-        queryNode.addOperand(rqn);
+
+        // if property name is jcr:primaryType treat special
+        if (rqn.getProperty().equals(NodeTypeRegistry.JCR_PRIMARY_TYPE)) {
+            if (rqn.getType() == RelationQueryNode.TYPE_STRING) {
+                try {
+                    QName ntName = QName.fromJCRName(rqn.getStringValue(), resolver);
+                    NodeTypeQueryNode ntNode = new NodeTypeQueryNode(queryNode, ntName);
+                    queryNode.addOperand(ntNode);
+                } catch (IllegalNameException e) {
+                    exceptions.add(new InvalidQueryException("Not a valid name: " + rqn.getStringValue()));
+                } catch (UnknownPrefixException e) {
+                    exceptions.add(new InvalidQueryException("Unknown prefix in name: " + rqn.getStringValue()));
+                }
+            } else {
+                // value is not of type string
+                exceptions.add(new InvalidQueryException("Invalid type: jcr:primaryType must be a string"));
+            }
+        } else {
+            // property name is <> jcr:primaryType
+            queryNode.addOperand(rqn);
+        }
+                    // @todo is this needed?
+            } else if (JCRFN_CONTAINS.toJCRName(resolver).equals(fName)) {
+                // check number of arguments
+                if (node.jjtGetNumChildren() == 2) {
+                    SimpleNode literal = (SimpleNode) node.jjtGetChild(1).jjtGetChild(0);
+                    if (queryNode instanceof NAryQueryNode) {
+                        if (literal.getId() == XPathTreeConstants.JJTSTRINGLITERAL) {
+                            String value = literal.getValue();
+                            // strip quotes
+                            value = value.substring(1, value.length() - 1);
+                            TextsearchQueryNode contains = new TextsearchQueryNode(queryNode, value);
+                            ((NAryQueryNode) queryNode).addOperand(contains);
+                        } else {
+                            exceptions.add(new InvalidQueryException("Wrong argument type for jcrfn:contains"));
+                        }
+                    } else {
+                        exceptions.add(new InvalidQueryException("Unsupported location for function jcrfn:contains"));
+                    }
+                } else {
+                    // wrong number of arguments
+                    exceptions.add(new InvalidQueryException("Wrong number of arguments for jcrfn:contains"));
+                }
+            } else if (JCRFN_LIKE.toJCRName(resolver).equals(fName)) {
+                // check number of arguments
+                if (node.jjtGetNumChildren() == 3) {
+                    if (queryNode instanceof NAryQueryNode) {
+                        RelationQueryNode like = new RelationQueryNode(queryNode, RelationQueryNode.OPERATION_LIKE);
+                        ((NAryQueryNode) queryNode).addOperand(like);
+
+                        // assign property name
+                        node.jjtGetChild(1).jjtAccept(this, like);
+                        // check property name
+                        if (like.getProperty() == null) {
+                            exceptions.add(new InvalidQueryException("Wrong first argument type for jcrfn:like"));
+                        }
+
+                        SimpleNode literal = (SimpleNode) node.jjtGetChild(2).jjtGetChild(0);
+                        if (literal.getId() == XPathTreeConstants.JJTSTRINGLITERAL) {
+                            String value = literal.getValue();
+                            // strip quotes
+                            value = value.substring(1, value.length() - 1);
+                            like.setStringValue(value);
+                        } else {
+                            exceptions.add(new InvalidQueryException("Wrong second argument type for jcrfn:like"));
+                        }
+                    } else {
+                        exceptions.add(new InvalidQueryException("Unsupported location for function jcrfn:like"));
+                    }
+                } else {
+                    // wrong number of arguments
+                    exceptions.add(new InvalidQueryException("Wrong number of arguments for jcrfn:like"));
+                }

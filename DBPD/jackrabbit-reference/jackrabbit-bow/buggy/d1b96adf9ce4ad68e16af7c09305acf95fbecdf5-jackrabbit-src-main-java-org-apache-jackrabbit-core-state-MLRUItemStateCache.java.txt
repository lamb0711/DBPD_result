JCR-619: CacheManager (Memory Management in Jackrabbit)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@475223 13f79535-47bb-0310-9956-ffa450edef68

-public class MLRUItemStateCache implements ItemStateCache {
+public class MLRUItemStateCache implements ItemStateCache, Cache {
-    private final long maxMem;
+    private long maxMem;
+    /** the access count */
+    private long accessCount = 0;
+
+    /** the cache access listeners */
+    private CacheAccessListener accessListener;
+
-    public MLRUItemStateCache(int maxMem) {
+    private MLRUItemStateCache(int maxMem) {
+            touch();
+            touch();
+            touch();
-            // remove items, if too many
-            while (totalMem > maxMem) {
-                id = (ItemId) cache.firstKey();
-                evict(id);
-            }
+            shrinkIfRequired();
+    private void shrinkIfRequired() {
+        // remove items, if too many
+        while (totalMem > maxMem) {
+            ItemId id = (ItemId) cache.firstKey();
+            evict(id);
+        }
+    }
+
+            touch();
+    private void touch() {
+        accessCount++;
+        if ((accessCount % CacheAccessListener.ACCESS_INTERVAL) == 0) {
+            if (accessListener != null) {
+                accessListener.cacheAccessed();
+            }
+        }
+    }
+
-     * Internal cache entry
+     * {@inheritDoc}
+     */
+    public long getAccessCount() {
+        return accessCount;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public long getMaxMemorySize() {
+        return maxMem;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public long getMemoryUsed() {
+        synchronized (cache) {
+            totalMem = 0;
+            Iterator iter = cache.values().iterator();
+            while (iter.hasNext()) {
+                Entry entry = (Entry) iter.next();
+                entry.recalc();
+                totalMem += entry.size;
+            }
+        }
+        return totalMem;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void resetAccessCount() {
+        synchronized (cache) {
+            accessCount = 0;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void setMaxMemorySize(long size) {
+        synchronized (cache) {
+            this.maxMem = size;
+            shrinkIfRequired();
+        }
+    }
+
+    /**
+     * Set the cache access listener. Only one listener per cache is supported.
+     *
+     * @param listener the new listener
+     */
+    public void setAccessListener(CacheAccessListener listener) {
+        this.accessListener = listener;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void dispose() {
+        synchronized (cache) {
+            if(accessListener != null) {
+                accessListener.disposeCache(this);
+            }
+        }
+    }
+
+
+    /**
+     * Internal cache entry.
+

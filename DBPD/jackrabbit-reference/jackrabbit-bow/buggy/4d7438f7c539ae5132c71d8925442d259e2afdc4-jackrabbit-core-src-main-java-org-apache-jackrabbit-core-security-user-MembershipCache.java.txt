JCR-2706 - Evaluate if membershipcache (JCR-2703) obsoletes the cache in DefaultPrincipalProvider

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@985147 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.SessionListener;
+import org.apache.jackrabbit.core.nodetype.NodeTypeImpl;
+import org.apache.jackrabbit.core.observation.SynchronousEventListener;
+import org.apache.jackrabbit.spi.Name;
+import org.apache.jackrabbit.util.Text;
+import javax.jcr.observation.Event;
+import javax.jcr.observation.EventIterator;
-
-public class MembershipCache implements UserConstants {
+public class MembershipCache implements UserConstants, SynchronousEventListener, SessionListener {
+    private final String pMembers;
-    MembershipCache(SessionImpl systemSession, String groupsPath, boolean useMembersNode) {
+    MembershipCache(SessionImpl systemSession, String groupsPath, boolean useMembersNode) throws RepositoryException {
+
+        pMembers = systemSession.getJCRName(UserManagerImpl.P_MEMBERS);
+                
+        String[] ntNames = new String[] {
+                systemSession.getJCRName(UserConstants.NT_REP_GROUP),
+                systemSession.getJCRName(UserConstants.NT_REP_MEMBERS)
+        };
+        // register event listener to be informed about membership changes.
+        systemSession.getWorkspace().getObservationManager().addEventListener(this,
+                Event.PROPERTY_ADDED | Event.PROPERTY_CHANGED | Event.PROPERTY_REMOVED,
+                groupsPath,
+                true,
+                null,
+                ntNames,
+                false);
+        // make sure the membership cache is informed if the system session is
+        // logged out in order to stop listening to events.
+        systemSession.addListener(this);
-    synchronized void clear() {
-        cache.clear();
+
+    //------------------------------------------------------< EventListener >---
+    /**
+     * @see javax.jcr.observation.EventListener#onEvent(javax.jcr.observation.EventIterator)
+     */
+    public void onEvent(EventIterator eventIterator) {
+        // evaluate if the membership cache needs to be cleared;
+        boolean clear = false;
+        while (eventIterator.hasNext() && !clear) {
+            Event ev = eventIterator.nextEvent();
+            try {
+                if (pMembers.equals(Text.getName(ev.getPath()))) {
+                    // simple case: a rep:members property that is affected
+                    clear = true;
+                } else if (useMembersNode) {
+                    // test if it affects a property defined by rep:Members node type.
+                    int type = ev.getType();
+                    if (type == Event.PROPERTY_ADDED || type == Event.PROPERTY_CHANGED) {
+                        Property p = systemSession.getProperty(ev.getPath());
+                        Name declNtName = ((NodeTypeImpl) p.getDefinition().getDeclaringNodeType()).getQName();
+                        clear = NT_REP_MEMBERS.equals(declNtName);
+                    } else {
+                        // PROPERTY_REMOVED
+                        // test if the primary node type of the parent node is rep:Members
+                        // this could potentially by some other property as well as the
+                        // rep:Members node are not protected and could changed by
+                        // adding a mixin type.
+                        // ignoring this and simply clear the cache
+                        String parentId = ev.getIdentifier();
+                        Node n = systemSession.getNodeByIdentifier(parentId);
+                        Name ntName = ((NodeTypeImpl) n.getPrimaryNodeType()).getQName();
+                        clear = (UserConstants.NT_REP_MEMBERS.equals(ntName));
+                    }
+                }
+            } catch (RepositoryException e) {
+                log.warn(e.getMessage());
+                // exception while processing the event -> clear the cache to
+                // be sure it isn't outdated.
+                clear = true;
+            }
+        }
+
+        if (clear) {
+            synchronized (cache) {
+                cache.clear();
+            }
+        }
+    //----------------------------------------------------< SessionListener >---
+    /**
+     * @see SessionListener#loggingOut(org.apache.jackrabbit.core.SessionImpl)
+     */
+    public void loggingOut(SessionImpl session) {
+        try {
+            systemSession.getWorkspace().getObservationManager().removeEventListener(this);
+        } catch (RepositoryException e) {
+            log.error("Unexpected error: Failed to stop event listening of MembershipCache.", e);
+        }
+
+    }
+
+    /**
+     * @see SessionListener#loggedOut(org.apache.jackrabbit.core.SessionImpl)
+     */
+    public void loggedOut(SessionImpl session) {
+        // nothing to do
+    }
+
+    //--------------------------------------------------------------------------
+    /**
+     * @param authorizableNodeIdentifier The identifier of the node representing
+     * the authorizable to retrieve the declared membership for.
+     * @return A collection of node identifiers of those group nodes the
+     * authorizable in question is declared member of.
+     * @throws RepositoryException If an error occurs.
+     */
+    /**
+     * @param authorizableNodeIdentifier The identifier of the node representing
+     * the authorizable to retrieve the membership for.
+     * @return A collection of node identifiers of those group nodes the
+     * authorizable in question is a direct or indirect member of.
+     * @throws RepositoryException If an error occurs.
+     */
-     * @param authorizableNodeIdentifier
-     * @param session
-     * @return
-     * @throws RepositoryException
+     * @param authorizableNodeIdentifier The identifier of the node representing
+     * the authorizable to retrieve the membership for.
+     * @param session The session to be used to read the membership information.
+     * @return @return A collection of node identifiers of those group nodes the
+     * authorizable in question is a direct member of.
+     * @throws RepositoryException If an error occurs.
-     * @param authorizableNodeIdentifier
-     * @param session
-     * @return
-     * @throws RepositoryException
+     * @param authorizableNodeIdentifier The identifier of the node representing
+     * the authorizable to retrieve the membership for.
+     * @param session The session to be used to read the membership information.
+     * @return A collection of node identifiers of those group nodes the
+     * authorizable in question is a direct or indirect member of.
+     * @throws RepositoryException If an error occurs.

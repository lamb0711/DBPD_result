JCR-2959 SQL2 QueryEngine should use Lucene for sort
 - work in progress

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1161475 13f79535-47bb-0310-9956-ffa450edef68

-import static javax.jcr.query.qom.QueryObjectModelConstants.JCR_ORDER_DESCENDING;
+import java.util.HashMap;
-import javax.jcr.query.qom.Operand;
+import javax.jcr.query.qom.QueryObjectModelConstants;
+import org.apache.jackrabbit.JcrConstants;
+import org.apache.jackrabbit.core.query.lucene.sort.DynamicOperandFieldComparatorSource;
+import org.apache.jackrabbit.core.query.lucene.sort.RowComparator;
+import org.apache.lucene.search.Sort;
+import org.apache.lucene.search.SortField;
+    
+    //TODO remove this when the implementation is stable
+    public static final String NATIVE_SORT_SYSTEM_PROPERTY = "useNativeSort";
+
+    private static final boolean NATIVE_SORT = Boolean.valueOf(System
+            .getProperty(NATIVE_SORT_SYSTEM_PROPERTY, "false"));
-
-    /**
-     * Row comparator.
-     */
-    private static class RowComparator implements Comparator<Row> {
-
-        private final ValueComparator comparator = new ValueComparator();
-
-        private final Ordering[] orderings;
-
-        private final OperandEvaluator evaluator;
-
-        private RowComparator(Ordering[] orderings, OperandEvaluator evaluator) {
-            this.orderings = orderings;
-            this.evaluator = evaluator;
-        }
-
-        public int compare(Row a, Row b) {
-            try {
-                for (Ordering ordering : orderings) {
-                    Operand operand = ordering.getOperand();
-                    Value[] va = evaluator.getValues(operand, a);
-                    Value[] vb = evaluator.getValues(operand, b);
-                    int d = compare(va, vb);
-                    if (d != 0) {
-                        if (JCR_ORDER_DESCENDING.equals(ordering.getOrder())) {
-                            return -d;
-                        } else {
-                            return d;
-                        }
-                    }
-                }
-                return 0;
-            } catch (RepositoryException e) {
-                throw new RuntimeException("Unable to compare rows " + a
-                        + " and " + b, e);
-            }
-        }
-
-        private int compare(Value[] a, Value[] b) {
-            for (int i = 0; i < a.length && i < b.length; i++) {
-                int d = comparator.compare(a[i], b[i]);
-                if (d != 0) {
-                    return d;
-                }
-            }
-            return a.length - b.length;
-        }
-
-    }
+    
+    private final Session session;
+        this.session = session;
-
-        log.debug("SQL2 QUERY execute took {} ms.", System.currentTimeMillis()
-                - time);
+        log.debug("SQL2 QUERY execute took {} ms. native sort is {}.",
+                System.currentTimeMillis() - time, NATIVE_SORT);
-        
+
+        Sort sort = new Sort();
+        if (NATIVE_SORT) {
+            sort = new Sort(createSortFields(orderings, session));
+        }
+
+        // if true it means that the LuceneQueryFactory should just let the
+        // QueryEngine take care of sorting and applying offset and limit
+        // constraints
+        boolean externalSort = !NATIVE_SORT;
+        RowIterator rows = null;
-            RowIterator rows = new RowIteratorAdapter(lqf.execute(columnMap,
-                    selector, constraint));
-            QueryResult result = new SimpleQueryResult(columnNames,
-                    selectorNames, rows);
-            return sort(result, orderings, evaluator, offset, limit);
+            rows = new RowIteratorAdapter(lqf.execute(columnMap, selector,
+                    constraint, sort, externalSort, offset, limit));
-            if (log.isDebugEnabled()) {
-                time = System.currentTimeMillis() - time;
-                log.debug(genString(printIndentation) + "SQL2 SELECT took "
-                        + time + " ms. selector: " + selector + ", columns: "
-                        + Arrays.toString(columnNames) + ", constraint: "
-                        + constraint);
+            log.debug(
+                    "{}SQL2 SELECT took {} ms. selector: {}, columns: {}, constraint: {}, offset {}, limit {}",
+                    new Object[] { genString(printIndentation),
+                            System.currentTimeMillis() - time, selector,
+                            Arrays.toString(columnNames), constraint, offset,
+                            limit });
+        }
+        QueryResult result = new SimpleQueryResult(columnNames, selectorNames,
+                rows);
+        if (NATIVE_SORT) {
+            return result;
+        }
+
+        long timeSort = System.currentTimeMillis();
+        QueryResult sorted = sort(result, orderings, evaluator, offset, limit);
+        log.debug("{}SQL2 SORT took {} ms.", genString(printIndentation),
+                System.currentTimeMillis() - timeSort);
+        return sorted;
+    }
+
+    public SortField[] createSortFields(Ordering[] orderings, Session session)
+            throws RepositoryException {
+
+        if (orderings == null || orderings.length == 0) {
+            return new SortField[] { SortField.FIELD_SCORE };
+        }
+        // orderings[] -> (property, ordering)
+        Map<String, Ordering> orderByProperties = new HashMap<String, Ordering>();
+        for (Ordering o : orderings) {
+            final String p = o.toString();
+            if (!orderByProperties.containsKey(p)) {
+                orderByProperties.put(p, o);
+        final DynamicOperandFieldComparatorSource dofcs = new DynamicOperandFieldComparatorSource(
+                session, evaluator, orderByProperties);
+
+        List<SortField> sortFields = new ArrayList<SortField>();
+
+        // as it turn out, orderByProperties.keySet() doesn't keep the original
+        // insertion order
+        for (Ordering o : orderings) {
+            final String p = o.toString();
+            // order on jcr:score does not use the natural order as
+            // implemented in lucene. score ascending in lucene means that
+            // higher scores are first. JCR specs that lower score values
+            // are first.
+            boolean isAsc = QueryObjectModelConstants.JCR_ORDER_ASCENDING
+                    .equals(o.getOrder());
+            if (JcrConstants.JCR_SCORE.equals(p)) {
+                sortFields.add(new SortField(null, SortField.SCORE, !isAsc));
+            } else {
+                // TODO use native sort if available
+                sortFields.add(new SortField(p, dofcs, isAsc));
+            }
+        }
+        return sortFields.toArray(new SortField[sortFields.size()]);

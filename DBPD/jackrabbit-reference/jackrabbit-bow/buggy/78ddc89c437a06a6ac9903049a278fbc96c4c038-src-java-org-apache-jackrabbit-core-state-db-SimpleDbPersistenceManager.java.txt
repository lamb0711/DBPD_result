- cleaned up persistence manager code in core
- improved space efficiency of simple serialization format as
  used by ObjectPersistenceManager, InMemPersistenceManager
  and SimpleDbPersistenceManager
- added configuration option to SimpleDbPersistenceManager
  whether BLOBs should be stored externally in the file system
  (default) or if they should be stored inline in the db
- prepared persistence managers for coming data model change 
  (new ItemState#modCount field)

see http://thread.gmane.org/gmane.comp.apache.jackrabbit.devel/4137

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@329224 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.fs.FileSystemPathUtil;
-import org.apache.jackrabbit.core.fs.FileSystemResource;
-import org.apache.jackrabbit.core.state.obj.BLOBStore;
-import org.apache.jackrabbit.core.state.obj.ObjectPersistenceManager;
+import org.apache.jackrabbit.core.state.util.BLOBStore;
+import org.apache.jackrabbit.core.state.util.FileSystemBLOBStore;
+import org.apache.jackrabbit.core.state.util.Serializer;
-import org.apache.jackrabbit.name.QName;
-import java.io.BufferedOutputStream;
+import java.io.BufferedReader;
-import java.io.OutputStream;
-import java.io.BufferedReader;
- * simple custom serialization format and a very basic non-normalized database
- * schema (in essence tables with one 'key' and one 'data' column).
+ * simple custom binary serialization format (see {@link Serializer}) and a
+ * very basic non-normalized database schema (in essence tables with one 'key'
+ * and one 'data' column).
+ * <li><code>externalBLOBs</code>: if <code>true</code> (the default) BINARY
+ * values (BLOBs) are stored in the local file system;
+ * if <code>false</code> BLOBs are stored in the database</li>
- *  &lt;/PersistenceManager&gt;
+ *       &lt;param name="externalBLOBs" value="false"/&gt;
+ *   &lt;/PersistenceManager&gt;
- *  &lt;/PersistenceManager&gt;
+ *       &lt;param name="externalBLOBs" value="false"/&gt;
+ *   &lt;/PersistenceManager&gt;
+ * See also {@link DerbyPersistenceManager}.
-public class SimpleDbPersistenceManager extends AbstractPersistenceManager
-        implements BLOBStore {
+public class SimpleDbPersistenceManager extends AbstractPersistenceManager {
-    /** Logger instance */
+    /**
+     * Logger instance
+     */
+    protected boolean externalBLOBs;
+
+    protected PreparedStatement nodeStateSelectExist;
+    protected PreparedStatement propertyStateSelectExist;
+    protected PreparedStatement nodeReferenceSelectExist;
-    /** file system where BLOB data is stored */
+    // shared prepared statements for BLOB management
+    // (if <code>externalBLOBs==false</code>)
+    protected PreparedStatement blobInsert;
+    protected PreparedStatement blobUpdate;
+    protected PreparedStatement blobSelect;
+    protected PreparedStatement blobSelectExist;
+    protected PreparedStatement blobDelete;
+
+    /**
+     * file system where BLOB data is stored
+     * (if <code>externalBLOBs==true</code>)
+     */
+    /**
+     * BLOBStore that manages BLOB data in the file system
+     * (if <code>externalBLOBs==true</code>)
+     */
+    protected BLOBStore blobStore;
+        externalBLOBs = true;
-    //------------------------------------------------------------< BLOBStore >
-    /**
-     * {@inheritDoc}
-     */
-    public FileSystemResource get(String blobId) throws Exception {
-        return new FileSystemResource(blobFS, blobId);
+    public boolean isExternalBLOBs() {
+        return externalBLOBs;
-    /**
-     * {@inheritDoc}
-     */
-    public String put(PropertyId id, int index, InputStream in, long size)
-            throws Exception {
-        String path = buildBlobFilePath(id.getParentUUID(), id.getName(), index);
-        OutputStream out = null;
-        FileSystemResource internalBlobFile = new FileSystemResource(blobFS, path);
-        internalBlobFile.makeParentDirs();
-        try {
-            out = new BufferedOutputStream(internalBlobFile.getOutputStream());
-            byte[] buffer = new byte[8192];
-            int read;
-            while ((read = in.read(buffer)) > 0) {
-                out.write(buffer, 0, read);
-            }
-        } finally {
-            out.close();
-        }
-        return path;
+    public void setExternalBLOBs(boolean externalBLOBs) {
+        this.externalBLOBs = externalBLOBs;
-    /**
-     * {@inheritDoc}
-     */
-    public boolean remove(String blobId) throws Exception {
-        FileSystemResource res = new FileSystemResource(blobFS, blobId);
-        if (!res.exists()) {
-            return false;
-        }
-        // delete resource and prune empty parent folders
-        res.delete(true);
-        return true;
+    public void setExternalBLOBs(String externalBLOBs) {
+        this.externalBLOBs = Boolean.valueOf(externalBLOBs).booleanValue();
-        /**
-         * store blob's in local file system in a sub directory
-         * of the workspace home directory
-         */
-        LocalFileSystem blobFS = new LocalFileSystem();
-        blobFS.setRoot(new File(context.getHomeDir(), "blobs"));
-        blobFS.init();
-        this.blobFS = blobFS;
-
+        nodeStateSelectExist =
+                con.prepareStatement("select 1 from "
+                + schemaObjectPrefix + "NODE where NODE_ID = ?");
+        propertyStateSelectExist =
+                con.prepareStatement("select 1 from "
+                + schemaObjectPrefix + "PROP where PROP_ID = ?");
+        nodeReferenceSelectExist =
+                con.prepareStatement("select 1 from "
+                + schemaObjectPrefix + "REFS where NODE_ID = ?");
+        if (externalBLOBs) {
+            /**
+             * store BLOBs in local file system in a sub directory
+             * of the workspace home directory
+             */
+            LocalFileSystem blobFS = new LocalFileSystem();
+            blobFS.setRoot(new File(context.getHomeDir(), "blobs"));
+            blobFS.init();
+            this.blobFS = blobFS;
+            blobStore = new FileSystemBLOBStore(blobFS);
+        } else {
+            /**
+             * store BLOBs in db
+             */
+            blobStore = new DbBLOBStore();
+
+            blobInsert =
+                    con.prepareStatement("insert into "
+                    + schemaObjectPrefix + "BINVAL (BINVAL_DATA, BINVAL_ID) values (?, ?)");
+            blobUpdate =
+                    con.prepareStatement("update "
+                    + schemaObjectPrefix + "BINVAL set BINVAL_DATA = ? where BINVAL_ID = ?");
+            blobSelect =
+                    con.prepareStatement("select BINVAL_DATA from "
+                    + schemaObjectPrefix + "BINVAL where BINVAL_ID = ?");
+            blobSelectExist =
+                    con.prepareStatement("select 1 from "
+                    + schemaObjectPrefix + "BINVAL where BINVAL_ID = ?");
+            blobDelete =
+                    con.prepareStatement("delete from "
+                    + schemaObjectPrefix + "BINVAL where BINVAL_ID = ?");
+        }
+
+            closeStatement(nodeStateSelectExist);
+            closeStatement(propertyStateSelectExist);
+            closeStatement(nodeReferenceSelectExist);
+            if (!externalBLOBs) {
+                closeStatement(blobInsert);
+                closeStatement(blobUpdate);
+                closeStatement(blobSelect);
+                closeStatement(blobSelectExist);
+                closeStatement(blobDelete);
+            } else {
+                // close BLOB file system
+                blobFS.close();
+                blobFS = null;
+            }
+            blobStore = null;
+
-            // close blob store
-            blobFS.close();
-            blobFS = null;
+
-            ObjectPersistenceManager.deserialize(state, in);
+            Serializer.deserialize(state, in);
-            ObjectPersistenceManager.deserialize(state, in, this);
+            Serializer.deserialize(state, in, blobStore);
-            ObjectPersistenceManager.serialize(state, out);
+            Serializer.serialize(state, out);
-            stmt.execute();
+            stmt.executeUpdate();
-            ObjectPersistenceManager.serialize(state, out, this);
+            Serializer.serialize(state, out, blobStore);
-            stmt.execute();
+            stmt.executeUpdate();
-            stmt.execute();
+            stmt.executeUpdate();
-        // delete binary values (stored as files)
+        // make sure binary values (BLOBs) are properly removed
-                        // delete blob file and prune empty parent folders
+                        // delete internal resource representation of BLOB value
+                        // also remove from BLOBStore
+                        String blobId = blobStore.createId((PropertyId) state.getId(), i);
+                        try {
+                            blobStore.remove(blobId);
+                        } catch (Exception e) {
+                            log.warn("failed to remove from BLOBStore: " + blobId, e);
+                        }
-            stmt.execute();
+            stmt.executeUpdate();
-            ObjectPersistenceManager.deserialize(refs, in);
+            Serializer.deserialize(refs, in);
-            ObjectPersistenceManager.serialize(refs, out);
+            Serializer.serialize(refs, out);
-            stmt.execute();
+            stmt.executeUpdate();
-            stmt.execute();
+            stmt.executeUpdate();
-        PreparedStatement stmt = nodeStateSelect;
+        PreparedStatement stmt = nodeStateSelectExist;
-        PreparedStatement stmt = propertyStateSelect;
+        PreparedStatement stmt = propertyStateSelectExist;
-        PreparedStatement stmt = nodeReferenceSelect;
+        PreparedStatement stmt = nodeReferenceSelectExist;
-    protected static String buildBlobFilePath(String parentUUID,
-                                              QName propName, int index) {
-        StringBuffer sb = new StringBuffer();
-        char[] chars = parentUUID.toCharArray();
-        int cnt = 0;
-        for (int i = 0; i < chars.length; i++) {
-            if (chars[i] == '-') {
-                continue;
-            }
-            //if (cnt > 0 && cnt % 4 == 0) {
-            if (cnt == 2 || cnt == 4) {
-                sb.append(FileSystem.SEPARATOR_CHAR);
-            }
-            sb.append(chars[i]);
-            cnt++;
-        }
-        sb.append(FileSystem.SEPARATOR_CHAR);
-        sb.append(FileSystemPathUtil.escapeName(propName.toString()));
-        sb.append('.');
-        sb.append(index);
-        sb.append(".bin");
-        return sb.toString();
-    }
-
+     *
-                    stmt.execute(sql);
+                    stmt.executeUpdate(sql);
+
+    //--------------------------------------------------------< inner classes >
+    class DbBLOBStore implements BLOBStore {
+        /**
+         * {@inheritDoc}
+         */
+        public String createId(PropertyId id, int index) {
+            // the blobId is a simple string concatenation of id plus index
+            StringBuffer sb = new StringBuffer();
+            sb.append(id.toString());
+            sb.append('[');
+            sb.append(index);
+            sb.append(']');
+            return sb.toString();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public synchronized InputStream get(String blobId) throws Exception {
+            PreparedStatement stmt = blobSelect;
+            try {
+                stmt.setString(1, blobId);
+                stmt.execute();
+                final ResultSet rs = stmt.getResultSet();
+                if (!rs.next()) {
+                    throw new Exception("no such BLOB: " + blobId);
+                }
+                final InputStream in = rs.getBinaryStream(1);
+
+                /**
+                 * return an InputStream wrapper in order to
+                 * close the ResultSet when the stream is closed
+                 */
+                return new InputStream() {
+                    public int read() throws IOException {
+                        return in.read();
+                    }
+
+                    public void close() throws IOException {
+                        in.close();
+                        // close ResultSet
+                        closeResultSet(rs);
+                    }
+
+                    public int available() throws IOException {
+                        return in.available();
+                    }
+
+                    public void mark(int readlimit) {
+                        in.mark(readlimit);
+                    }
+
+                    public boolean markSupported() {
+                        return in.markSupported();
+                    }
+
+                    public int read(byte b[]) throws IOException {
+                        return in.read(b);
+                    }
+
+                    public int read(byte b[], int off, int len) throws IOException {
+                        return in.read(b, off, len);
+                    }
+
+                    public void reset() throws IOException {
+                        in.reset();
+                    }
+
+                    public long skip(long n) throws IOException {
+                        return in.skip(n);
+                    }
+                };
+            } finally {
+                resetStatement(stmt);
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public synchronized void put(String blobId, InputStream in, long size)
+                throws Exception {
+            PreparedStatement stmt = blobSelectExist;
+            try {
+                stmt.setString(1, blobId);
+                stmt.execute();
+                ResultSet rs = stmt.getResultSet();
+                // a BLOB exists if the result has at least one entry
+                boolean exists = rs.next();
+                resetStatement(stmt);
+                closeResultSet(rs);
+
+                stmt = (exists) ? blobUpdate : blobInsert;
+                stmt.setBinaryStream(1, in, (int) size);
+                stmt.setString(2, blobId);
+                stmt.executeUpdate();
+            } finally {
+                resetStatement(stmt);
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public synchronized boolean remove(String blobId) throws Exception {
+            PreparedStatement stmt = blobDelete;
+            try {
+                stmt.setString(1, blobId);
+                return stmt.executeUpdate() == 1;
+            } finally {
+                resetStatement(stmt);
+            }
+        }
+    }

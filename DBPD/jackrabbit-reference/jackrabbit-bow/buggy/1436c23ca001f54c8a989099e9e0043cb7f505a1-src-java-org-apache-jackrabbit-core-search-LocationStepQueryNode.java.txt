- Removed JCRQL implementation
- Added proper QName support to search
- redesigned parsing and formating of queries (better separation of abstract query tree and concrete syntax)
- Some improvements in SQL: colon is now supported in identifier without having to use double quotes, LIKE now supports escaping

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@125778 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Iterator;
+import org.apache.jackrabbit.core.QName;
-    private String nameTest;
+    private QName nameTest;
-    private int index = -1;
+    private int index = 0;
-    public LocationStepQueryNode(QueryNode parent, String nameTest, boolean descendants) {
+    public LocationStepQueryNode(QueryNode parent, QName nameTest, boolean descendants) {
-    public String getNameTest() {
+    public QName getNameTest() {
-    public void setNameTest(String nameTest) {
+    public void setNameTest(QName nameTest) {
-     * Sets the position index for this step.
+     * Sets the position index for this step. A value of 0 (zero) indicates
+     * that this location step has no position index assigned. That is, the
+     * step selects all same name siblings.
+     * @exception IllegalArgumentException if index < 0.
+        if (index < 0) {
+            throw new IllegalArgumentException("index < 0");
+        }
-     * Returns the position index for this step.
+     * Returns the position index for this step. A value of 0 (zero) indicates
+     * that this location step has no position index assigned. That is, the
+     * step selects all same name siblings.
-    /**
-     * Returns a JCRQL representation for this query node.
-     *
-     * @return a JCRQL representation for this query node.
-     */
-    public String toJCRQLString() {
-        StringBuffer sb = new StringBuffer();
-        if (nameTest == null) {
-            sb.append("*");
-        } else {
-            sb.append(nameTest);
-        }
-        if (index > -1) {
-            sb.append('[').append(index).append(']');
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Returns a JCR SQL representation for this query node.
-     *
-     * @return a JCR SQL representation for this query node.
-     */
-    public String toJCRSQLString() {
-        StringBuffer sb = new StringBuffer();
-        if (nameTest == null) {
-            sb.append("*");
-        } else {
-            sb.append(nameTest);
-        }
-        if (index > -1) {
-            sb.append('[').append(index).append(']');
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Returns an XPath representation for this query node.
-     *
-     * @return an XPath representation for this query node.
-     */
-    public String toXPathString() {
-        StringBuffer sb = new StringBuffer();
-        if (includeDescendants) {
-            sb.append('/');
-        }
-        if (nameTest == null) {
-            sb.append("*");
-        } else {
-            sb.append(nameTest);
-        }
-        if (index > -1) {
-            sb.append('[').append(index).append(']');
-        }
-        if (operands != null) {
-            for (Iterator it = operands.iterator(); it.hasNext();) {
-                QueryNode predicate = (QueryNode) it.next();
-                sb.append('[').append(predicate.toXPathString()).append(']');
-            }
-        }
-        return sb.toString();
-    }

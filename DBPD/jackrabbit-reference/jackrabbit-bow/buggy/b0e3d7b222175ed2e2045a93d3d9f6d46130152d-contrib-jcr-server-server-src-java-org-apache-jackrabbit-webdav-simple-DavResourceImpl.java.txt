JCR-193, JCR-216, JCR-203, JCR 184 + various minor fixes

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@293331 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.util.ISO9075;
-    /** the default logger */
+    /**
+     * the default logger
+     */
+
-    /** is created on initProperties */
+    /**
+     * is created on initProperties
+     */
-                           DavSession session, ResourceFilter filter)
-        throws RepositoryException, DavException {
+                           DavSession session, ResourceConfig config)
+            throws RepositoryException, DavException {
-        this.filter = filter;
+        this.filter = config.getResourceFilter();
+
-                init(session.getRepositorySession().getItem(locator.getResourcePath()));
+                Item item = session.getRepositorySession().getItem(locator.getJcrPath());
+                if (item != null && item.isNode()) {
+                    node = (Node) item;
+                    if (isFilteredNode(node)) {
+                        log.debug("Cannot to access resource based on a filtered repository item: " + locator.getResourcePath());
+                        throw new DavException(DavServletResponse.SC_FORBIDDEN);
+                    }
+                    // define what is a resource in webdav
+                    isCollection = config.isCollectionResource(node);
+                }
-     * Init the webdav resource and retrieve the relevant property.
-     *
-     * @param repositoryItem
-     * @throws RepositoryException
-     */
-    private void init(Item repositoryItem) throws RepositoryException, DavException {
-        if (repositoryItem == null || !repositoryItem.isNode()) {
-            return;
-        }
-        node = (Node)repositoryItem;
-        if (isFilteredNode(node)) {
-            log.debug("Cannot to access resource based on a filtered repository item: " + locator.getResourcePath());
-            throw new DavException(DavServletResponse.SC_FORBIDDEN);
-        }
-        // define what is a resource in webdav
-        if (node.isNodeType(NT_RESOURCE) || node.isNodeType(NT_FILE)) {
-            isCollection = false;
-        }
-    }
-
-    /**
+     * Returns the the last segment of the resource path.<p>
+     * Note that this must not correspond to the name of the underlaying
+     * repository item for two reasons:<ul>
+     * <li>SameNameSiblings have an index appended to their item name.</li>
+     * <li>the resource path may differ from the item path.</li>
+     * </ul>
+     * Using the item name as DAV:displayname caused problems with XP built-in
+     * client in case of resources representing SameNameSibling nodes.
+     *
-        String name = null;
-        if (exists()) {
-            try {
-                name = node.getName();
-            } catch (RepositoryException e) {
-                // ignore
-            }
-        }
-        if (name == null && getResourcePath() != null) {
-            name = Text.getName(getResourcePath());
-        }
-        return name;
+        String resPath = getResourcePath();
+        return (resPath != null) ? Text.getName(resPath) : resPath;
-	initProperties();
-	return nodeResource == null ? 0 : nodeResource.getModificationTime();
+        initProperties();
+        return nodeResource == null ? 0 : nodeResource.getModificationTime();
-	initProperties();
-	return nodeResource == null ? null : nodeResource.getStream();
+        initProperties();
+        return nodeResource == null ? null : nodeResource.getStream();
-        if (exists()) {
-            try {
-                nodeResource = new NodeResource(this, node);
-                properties.add(new DefaultDavProperty(DavPropertyName.GETCONTENTLENGTH, nodeResource.getContentLength()+""));
-                properties.add(new DefaultDavProperty(DavPropertyName.CREATIONDATE, nodeResource.getCreationDate()));
-                properties.add(new DefaultDavProperty(DavPropertyName.GETLASTMODIFIED, nodeResource.getLastModified()));
-                setContentType(nodeResource.getContentType());
-                setContentLanguage(nodeResource.getContentLanguage());
-                properties.add(new DefaultDavProperty(DavPropertyName.GETETAG, nodeResource.getETag()));
-            } catch (RepositoryException e) {
-                // should not occure....
-            }
+        if (!exists() || nodeResource != null) {
+            return;
+        }
-            if (getDisplayName() != null) {
-                properties.add(new DefaultDavProperty(DavPropertyName.DISPLAYNAME, getDisplayName()));
-            }
-            if (isCollection()) {
-                properties.add(new ResourceType(ResourceType.COLLECTION));
-                // Windows XP support
-                properties.add(new DefaultDavProperty(DavPropertyName.ISCOLLECTION, "1"));
-            } else {
-                properties.add(new ResourceType(ResourceType.DEFAULT_RESOURCE));
-                // Windows XP support
-                properties.add(new DefaultDavProperty(DavPropertyName.ISCOLLECTION, "0"));
-            }
+        try {
+            nodeResource = new NodeResource(this, node);
+            properties.add(new DefaultDavProperty(DavPropertyName.GETCONTENTLENGTH, nodeResource.getContentLength() + ""));
+            properties.add(new DefaultDavProperty(DavPropertyName.CREATIONDATE, nodeResource.getCreationDate()));
+            properties.add(new DefaultDavProperty(DavPropertyName.GETLASTMODIFIED, nodeResource.getLastModified()));
+            setContentType(nodeResource.getContentType());
+            setContentLanguage(nodeResource.getContentLanguage());
+            properties.add(new DefaultDavProperty(DavPropertyName.GETETAG, nodeResource.getETag()));
+        } catch (RepositoryException e) {
+            // should not occure....
+        }
-            /* set current lock information. If no lock is set to this resource,
-            an empty lockdiscovery will be returned in the response. */
-            properties.add(new LockDiscovery(getLock(Type.WRITE, Scope.EXCLUSIVE)));
+        if (getDisplayName() != null) {
+            properties.add(new DefaultDavProperty(DavPropertyName.DISPLAYNAME, getDisplayName()));
+        }
+        if (isCollection()) {
+            properties.add(new ResourceType(ResourceType.COLLECTION));
+            // Windows XP support
+            properties.add(new DefaultDavProperty(DavPropertyName.ISCOLLECTION, "1"));
+        } else {
+            properties.add(new ResourceType(ResourceType.DEFAULT_RESOURCE));
+            // Windows XP support
+            properties.add(new DefaultDavProperty(DavPropertyName.ISCOLLECTION, "0"));
+        }
-            /* lock support information: all locks are lockable. */
-            SupportedLock supportedLock = new SupportedLock();
-            supportedLock.addEntry(Type.WRITE, Scope.EXCLUSIVE);
-            properties.add(supportedLock);
+        /* set current lock information. If no lock is set to this resource,
+        an empty lockdiscovery will be returned in the response. */
+        properties.add(new LockDiscovery(getLock(Type.WRITE, Scope.EXCLUSIVE)));
-            // non-protected JCR properties defined on the underlaying jcr node
-            try {
-                // todo: should filter be respected for properties as well?
-                PropertyIterator it = node.getProperties();
-                while (it.hasNext()) {
-                    Property p = it.nextProperty();
-                    String pName = p.getName();
-                    PropertyDefinition def = p.getDefinition();
-                    if (def.isMultiple()) {
-                        log.debug("Multivalue property '" +  pName + "' not added to webdav property set.");
-                        continue;
-                    }
-                    DavPropertyName name = getDavName(pName, node.getSession());
-                    String value = p.getValue().getString();
-                    properties.add(new DefaultDavProperty(name, value, def.isProtected()));
+        /* lock support information: all locks are lockable. */
+        SupportedLock supportedLock = new SupportedLock();
+        supportedLock.addEntry(Type.WRITE, Scope.EXCLUSIVE);
+        properties.add(supportedLock);
+
+        // non-protected JCR properties defined on the underlaying jcr node
+        try {
+            // todo: should filter be respected for properties as well?
+            PropertyIterator it = node.getProperties();
+            while (it.hasNext()) {
+                Property p = it.nextProperty();
+                String pName = p.getName();
+                PropertyDefinition def = p.getDefinition();
+                if (def.isMultiple()) {
+                    log.debug("Multivalue property '" + pName + "' not added to webdav property set.");
+                    continue;
-            } catch (RepositoryException e) {
-                log.error("Unexpected error while retrieving properties: " + e.getMessage());
+                DavPropertyName name = getDavName(pName, node.getSession());
+                String value = p.getValue().getString();
+                properties.add(new DefaultDavProperty(name, value, def.isProtected()));
+        } catch (RepositoryException e) {
+            log.error("Unexpected error while retrieving properties: " + e.getMessage());
+            JcrDavException je = new JcrDavException(e);
-                throw new JcrDavException(e);
+                // should not happen...
-            throw new JcrDavException(e);
+            throw je;
-            throw new JcrDavException(e);
+            JcrDavException je = new JcrDavException(e);
+            try {
+                node.refresh(false);
+            } catch (RepositoryException re) {
+                // should not happen...
+            }
+            throw je;
-    public void alterProperties(DavPropertySet setProperties,
-                                DavPropertyNameSet removePropertyNames)
-        throws DavException {
+    /**
+     * @see DavResource#alterProperties(org.apache.jackrabbit.webdav.property.DavPropertySet, org.apache.jackrabbit.webdav.property.DavPropertyNameSet)
+     */
+    public MultiStatusResponse alterProperties(DavPropertySet setProperties,
+                                               DavPropertyNameSet removePropertyNames)
+            throws DavException {
-        try {
-            DavPropertyIterator setIter = setProperties.iterator();
-            while (setIter.hasNext()) {
-                DavProperty prop = setIter.nextProperty();
+
+        MultiStatusResponse msr = new MultiStatusResponse(getHref());
+        boolean success = true;
+
+        // loop over set and remove Sets and remember all properties and propertyNames
+        // that have successfully been altered
+        List successList = new ArrayList();
+        DavPropertyIterator setIter = setProperties.iterator();
+        while (setIter.hasNext()) {
+            DavProperty prop = setIter.nextProperty();
+            try {
+                successList.add(prop);
+            } catch (RepositoryException e) {
+                msr.add(prop.getName(), new JcrDavException(e).getErrorCode());
+                success = false;
-            Iterator remNameIter = removePropertyNames.iterator();
-            while (remNameIter.hasNext()) {
-                DavPropertyName propName = (DavPropertyName) remNameIter.next();
+        }
+
+        Iterator remNameIter = removePropertyNames.iterator();
+        while (remNameIter.hasNext()) {
+            DavPropertyName propName = (DavPropertyName) remNameIter.next();
+            try {
+                successList.add(propName);
+            } catch (RepositoryException e) {
+                msr.add(propName, new JcrDavException(e).getErrorCode());
+                success = false;
-            // save all changes together (reverted in case this fails)
-            node.save();
+        }
+
+        try {
+            if (success) {
+                // save all changes together (reverted in case this fails)
+                node.save();
+            } else {
+                // set/remove of at least a single prop failed: undo modifications.
+                node.refresh(false);
+            }
+            /* loop over list of properties/names that were successfully altered
+               and them to the multistatus response respecting the resulte of the
+               complete action. in case of failure set the status to 'failed-dependency'
+               in order to indicate, that altering those names/properties would
+               have succeeded, if no other error occured.*/
+            Iterator it = successList.iterator();
+            while (it.hasNext()) {
+                Object o = it.next();
+                int status = (success) ? DavServletResponse.SC_OK : DavServletResponse.SC_FAILED_DEPENDENCY;
+                if (o instanceof DavProperty) {
+                    msr.add(((DavProperty) o).getName(), status);
+                } else {
+                    msr.add((DavPropertyName) o, status);
+                }
+            }
+            return msr;
-                throw new JcrDavException(e);
+                // should not happen
-                parentPath="/";
+                parentPath = "/";
-                while(it.hasNext()) {
+                while (it.hasNext()) {
-                        list.add(buildResourceFromItem(n));
+                        DavResourceLocator resourceLocator = locator.getFactory().createResourceLocator(locator.getPrefix(), locator.getWorkspacePath(), n.getPath(), false);
+                        DavResource childRes = factory.createResource(resourceLocator, session);
+                        list.add(childRes);
-        if (isLocked(this)) {
+        if (isLocked(this) || isLocked(member)) {
-            ctx.setSystemId(member.getDisplayName());
+            String sysId = Text.getName(member.getLocator().getJcrPath());
+            ctx.setSystemId(sysId);
+        } catch (DavException e) {
+            // TODO: hack needed in order not to fall into the general Exception
+            throw e;
+            // TODO: remove this! why do the commands throw an unspecific exception?
-	    ActiveLock lock = getLock(Type.WRITE, Scope.EXCLUSIVE);
-	    if (lock != null && lockManager.hasLock(lock.getToken(), member)) {
-		lockManager.releaseLock(lock.getToken(), member);
-	    }
+            ActiveLock lock = getLock(Type.WRITE, Scope.EXCLUSIVE);
+            if (lock != null && lockManager.hasLock(lock.getToken(), member)) {
+                lockManager.releaseLock(lock.getToken(), member);
+            }
-            Session s = session.getRepositorySession();
-            Item memItem = s.getItem(member.getResourcePath());
+            String itemPath = member.getLocator().getJcrPath();
+            Item memItem = session.getRepositorySession().getItem(itemPath);
-            s.save();
+            session.getRepositorySession().save();
-            session.getRepositorySession().getWorkspace().move(getResourcePath(), destination.getResourcePath());
+            String destItemPath = destination.getLocator().getJcrPath();
+            session.getRepositorySession().getWorkspace().move(locator.getJcrPath(), destItemPath);
-            session.getRepositorySession().getWorkspace().copy(getResourcePath(), destination.getResourcePath());
+            String destItemPath = destination.getLocator().getJcrPath();
+            session.getRepositorySession().getWorkspace().copy(locator.getJcrPath(), destItemPath);
-	    if (isJsrLockable()) {
-                try {
+            try {
+                if (node.isLocked()) {
-                } catch (RepositoryException e) {
-                    // LockException: no lock applies to this node >> ignore
-                    // RepositoryException, AccessDeniedException or another error >> ignore
+            } catch (RepositoryException e) {
+                // LockException (no lock applies) >> should never occur
+                // RepositoryException, AccessDeniedException or another error >> ignore
-            // could not retrieve jcr-lock (either not jcr-lockable or the lock has
-            // been created before the node was made jcr-lockable. test if a simple
-            // webdav lock is present.
+            // could not retrieve a jcr-lock. test if a simple webdav lock is present.
-        return (writeLock != null) ? new ActiveLock[] {writeLock} : new ActiveLock[0];
+        return (writeLock != null) ? new ActiveLock[]{writeLock} : new ActiveLock[0];
-	ActiveLock lock = null;
+        ActiveLock lock = null;
-            // todo: deal with existing locks, that may have been created, before the node was jcr-lockable...            
+            // TODO: deal with existing locks, that may have been created, before the node was jcr-lockable...
-		try {
-		    // try to execute the lock operation
-		    Lock jcrLock = node.lock(lockInfo.isDeep(), false);
-		    if (jcrLock != null) {
-			lock = new JcrActiveLock(jcrLock);
-		    }
-		} catch (RepositoryException e) {
-		    throw new JcrDavException(e);
-		}
-	    } else {
-		// create a new webdav lock
-		lock = lockManager.createLock(lockInfo, this);
-	    }
-	} else {
-	    throw new DavException(DavServletResponse.SC_PRECONDITION_FAILED, "Unsupported lock type or scope.");
-	}
-	return lock;
+                try {
+                    // try to execute the lock operation
+                    Lock jcrLock = node.lock(lockInfo.isDeep(), false);
+                    if (jcrLock != null) {
+                        lock = new JcrActiveLock(jcrLock);
+                    }
+                } catch (RepositoryException e) {
+                    throw new JcrDavException(e);
+                }
+            } else {
+                // create a new webdav lock
+                lock = lockManager.createLock(lockInfo, this);
+            }
+        } else {
+            throw new DavException(DavServletResponse.SC_PRECONDITION_FAILED, "Unsupported lock type or scope.");
+        }
+        return lock;
-    public ActiveLock refreshLock(LockInfo lockInfo, String lockToken) throws DavException{
+    public ActiveLock refreshLock(LockInfo lockInfo, String lockToken) throws DavException {
-           throw new DavException(DavServletResponse.SC_PRECONDITION_FAILED, "No lock with the given type/scope present on resource " + getResourcePath());
+            throw new DavException(DavServletResponse.SC_PRECONDITION_FAILED, "No lock with the given type/scope present on resource " + getResourcePath());
-        
+
+     *
-    
+
-     * Returns true, if this webdav resource allows for locking without checking
-     * its current lock status.
+     * Returns true, if the underlaying node is nodetype jcr:lockable,
+     * without checking its current lock status. If the node is not jcr-lockable
+     * an attempt is made to add the mix:lockable mixin type.
-                lockable =  node.isNodeType(MIX_LOCKABLE);
+                lockable = node.isNodeType(MIX_LOCKABLE);
+                // not jcr-lockable: try to make the node jcr-lockable
+                if (!lockable && node.canAddMixin(MIX_LOCKABLE)) {
+                    node.addMixin(MIX_LOCKABLE);
+                    node.save();
+                    lockable = true;
+                }
-                // not jcr-lockable
+                // -> node is definitely not jcr-lockable.
-                   return false;
+                    return false;
-     * @param item
-     * @return
-     * @throws DavException
-     * @throws RepositoryException
-     */
-    private DavResource buildResourceFromItem(Item item) throws DavException, RepositoryException {
-        DavResourceLocator parentloc = locator.getFactory().createResourceLocator(locator.getPrefix(), locator.getWorkspacePath(), item.getPath());
-        return factory.createResource(parentloc, session);
-    }
-
-    /**
-     * webdav namespaces a new prefix is assigned.
+     * webdav namespaces a new prefix is assigned.<br>
+     * Please note, that the local part of the jcrName is checked for XML
+     * compatibility by calling {@link ISO9075#encode(String)}
-     * @return namespace
+     * @param session
+     * @return a <code>DavPropertyName</code> for the given jcr name.
+        // make sure the local name is xml compliant
+        String localName = ISO9075.encode(Text.getLocalName(jcrName));
-        DavPropertyName name = DavPropertyName.create(Text.getLocalName(jcrName), namespace);
+        DavPropertyName name = DavPropertyName.create(localName, namespace);
-     * extra effort is made to generated a unique prefix. 
+     * extra effort is made to generated a unique prefix.
-        String pName = propName.getName();
+        // remove any encoding necessary for xml compliance
+        String pName = ISO9075.decode(propName.getName());
-
+                // avoid trouble with default namespace
+                if (prefix == null || "".equals(prefix)) {
+                    prefix = "_pre" + nsReg.getPrefixes().length + 1;
+                }
-     *
-        node.getProperty(getJcrName(propertyName)).remove();
+        String jcrName = getJcrName(propertyName);
+        if (node.hasProperty(jcrName)) {
+            node.getProperty(jcrName).remove();
+        }
+        // removal of non existing property succeeds
-        // todo: filtered nodetypes should be checked as well in order to prevent problems.
+        // TODO: filtered nodetypes should be checked as well in order to prevent problems.

JCR-275: added NodeTypeRegistry.unregisterNodeTypes(Collection)
- some additional cleaning up of implementation

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@376692 13f79535-47bb-0310-9956-ffa450edef68

+        primaryItemName = null;
-    public Object clone() throws CloneNotSupportedException {
-        // create a shallow copy
-        NodeTypeDef clone = (NodeTypeDef) super.clone();
-        // clear dependencies (will be lazily built)
-        clone.resetDependencies();
-        return clone;
-    }
-
-    public boolean equals(Object obj) {
-        if (this == obj) {
-            return true;
-        }
-        if (obj instanceof NodeTypeDef) {
-            NodeTypeDef other = (NodeTypeDef) obj;
-            return (name == null ? other.name == null : name.equals(other.name))
-                    && (primaryItemName == null ? other.primaryItemName == null : primaryItemName.equals(other.primaryItemName))
-                    && Arrays.equals(supertypes, other.supertypes)
-                    && mixin == other.mixin
-                    && orderableChildNodes == other.orderableChildNodes
-                    && Arrays.equals(propDefs, other.propDefs)
-                    && Arrays.equals(nodeDefs, other.nodeDefs);
-        }
-        return false;
-    }
-
-    /**
-     * Returns zero to satisfy the Object equals/hashCode contract.
-     * This class is mutable and not meant to be used as a hash key.
-     *
-     * @return always zero
-     * @see Object#hashCode()
-     */
-    public int hashCode() {
-        return 0;
-    }
-
+    //----------------------------------------------------< setters & getters >
+        resetDependencies();
+
+    //-------------------------------------------< java.lang.Object overrides >
+    public Object clone() {
+        NodeTypeDef clone = new NodeTypeDef();
+        clone.name = name;
+        clone.primaryItemName = primaryItemName;
+        clone.supertypes = (QName[]) supertypes.clone();
+        clone.mixin = mixin;
+        clone.orderableChildNodes = orderableChildNodes;
+        clone.nodeDefs = (NodeDef[]) nodeDefs.clone();
+        clone.propDefs = (PropDef[]) propDefs.clone();
+        return clone;
+    }
+
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj instanceof NodeTypeDef) {
+            NodeTypeDef other = (NodeTypeDef) obj;
+            return (name == null ? other.name == null : name.equals(other.name))
+                    && (primaryItemName == null ? other.primaryItemName == null : primaryItemName.equals(other.primaryItemName))
+                    && Arrays.equals(supertypes, other.supertypes)
+                    && mixin == other.mixin
+                    && orderableChildNodes == other.orderableChildNodes
+                    && Arrays.equals(propDefs, other.propDefs)
+                    && Arrays.equals(nodeDefs, other.nodeDefs);
+        }
+        return false;
+    }
+
+    /**
+     * Returns zero to satisfy the Object equals/hashCode contract.
+     * This class is mutable and not meant to be used as a hash key.
+     *
+     * @return always zero
+     * @see Object#hashCode()
+     */
+    public int hashCode() {
+        return 0;
+    }

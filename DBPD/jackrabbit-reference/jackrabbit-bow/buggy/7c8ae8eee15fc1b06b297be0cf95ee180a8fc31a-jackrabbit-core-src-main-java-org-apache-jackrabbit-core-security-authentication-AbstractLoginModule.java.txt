JCR-1588: 283 Access Control

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@689499 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.api.security.principal.PrincipalIterator;
+import org.apache.jackrabbit.api.jsr283.GuestCredentials;
- * This Abstract class provides the means for the common Authentication tasks,
- * within the Repository.<p />
- * It implements an authentication by User-ID / Password - Credentials
- * {@link SimpleCredentials}<p />
- * On successfull authentication it relates this credentials to principals
- * by the use of * the {@link PrincipalProvider} configured for this LoginModule<p />
- * Jackrabbit knows about two typs of Login, the one for its "own" Credentials and one
- * for Impersonation.<br>
- * {@link #login()}-method dispatches to
+ * <code>AbstractLoginModule</code> provides the means for the common
+ * authentication tasks within the Repository.
+ * <p/>
+ * On successfull authentication it associates the credentials to principals
+ * using the {@link PrincipalProvider} configured for this LoginModule<p />
+ * Jackrabbit distinguishes between Login and Impersonation dispatching the
+ * the correspoding Repository/Session methods to
- * {@link #impersonate(java.security.Principal, javax.jcr.Credentials)} for the
- * two cases for implemenations.<br>
- * This LoginModule imlements default behaviours for this methods.
+ * {@link #impersonate(java.security.Principal, javax.jcr.Credentials)}, respectively.
+ * <br>
+ * This LoginModule implements default behaviors for both methods.
-    private static final String KEY_SIMPLE_CREDENTIALS = "org.apache.jackrabbit.credentials.simple";
+    private static final String KEY_CREDENTIALS = "org.apache.jackrabbit.credentials";
-    protected String defaultUserId;
+    private String principalProviderClassName;
-     * <li>{@link LoginModuleConfig#PARAM_DEFAULT_USERID} option is evaluated</li>
+        // common jaas state variables
+        this.callbackHandler = callbackHandler;
+        this.subject = subject;
+        this.sharedState = sharedState;
+
+        // initialize the login module
-            //Properties configProps = new Properties();
-            //configProps.putAll(options);
-            // retrieve the principal-provider configured for this module
+            // retrieve the principal-provider configured for this module.
+            // if not configured -> retrieve the provider from the callback.
-                String providerName = (String) options.get(LoginModuleConfig.PARAM_PRINCIPAL_PROVIDER_CLASS);
-                principalProvider = registry.getProvider(providerName);
+                principalProviderClassName = (String) options.get(LoginModuleConfig.PARAM_PRINCIPAL_PROVIDER_CLASS);
+                principalProvider = registry.getProvider(principalProviderClassName);
+            } else if (principalProviderClassName != null) {
+                principalProvider = registry.getProvider(principalProviderClassName);
-            //call implementation for additional setup
+            // call implementation for additional setup
+            // adminId: if not present in options -> retrieve from callback
+            if (adminId == null) {
+                adminId = repositoryCb.getAdminId();
+            }
+            // anonymousId: if not present in options -> retrieve from callback
-            if (options.containsKey(LoginModuleConfig.PARAM_DEFAULT_USERID)) {
-                defaultUserId = (String) options.get(LoginModuleConfig.PARAM_DEFAULT_USERID);
+            if (anonymousId == null) {
+                anonymousId = repositoryCb.getAnonymousId();
-            //common jaas state variables
-            this.callbackHandler = callbackHandler;
-            this.subject = subject;
-
-
-            this.sharedState = sharedState;
-        //check for availablity of Credentials;
+        // check for availablity of Credentials;
-            // process authenticated user or return false
+            // process authenticated user
-     * <p> This method is called if the LoginContext's overall authentication
+     * This method is called if the LoginContext's overall authentication
-     * <p> If this LoginModule's own authentication attempt succeeded (checked
+     * If this LoginModule's own authentication attempt succeeded (checked
-     * there is no principalstate. the login is considered as ignored.
+     * there is no principal set the login is considered as ignored.
-     * to login is set to the Subject's public Credentials
+     * to login is set to the Subject's public Credentials.
-        subject.getPrincipals().addAll(getPrincipals());
+        Set principals = getPrincipals();
+        subject.getPrincipals().addAll(principals);
-            sharedState.remove(KEY_SIMPLE_CREDENTIALS);
+            sharedState.remove(KEY_CREDENTIALS);
-     * @return a Collection of principals that contains the current user
-     * principal and all groups it is member of.
-     */
-    protected Set getPrincipals() {
-        // use ListOrderedSet instead of Hashset in order to maintain the order
-        // of principals (as in the Subject).
-        Set principals = new ListOrderedSet();
-        principals.add(principal);
-        Iterator groups = principalProvider.getGroupMembership(principal);
-        while (groups.hasNext()) {
-            principals.add(groups.next());
-        }
-        return principals;
-    }
-
-    /**
-    //------------------------------------------------------------< private >---
-     * into account, that an authentication-extension of an allready
-     * authenticate {@link Subject} could take place<p/> Therefore the
-     * credentials are searchred for in the following search-order: <ol> <li>
-     * Ask CallbackHandler for Credentials with use of {@link
+     * authentication-extension of an already authenticated {@link Subject} into
+     * accout.
+     * <p/>
+     * Therefore the credentials are searchred as follows:
+     * <ol>
+     * <li>Test if the shared state contains credentials.</li>
+     * <li>Ask CallbackHandler for Credentials with using a {@link
-     * to return an instance of {@link SimpleCredentials}.</li> <li> Ask the
-     * Subject for its public credentials {@link Subject#getPublicCredentials(Class)},
-     * with {@link SimpleCredentials#getClass()} as argument.<p> This enables to
-     * preauthenticate the Subject.</li> </ol> NOTE: While the method signiture
-     * works with {@link Credentials} it actually searches and returns {@link
-     * SimpleCredentials}.<br> This is done to allow implementations to make use
-     * of this abstract class, without beeing bound to a {@link Credentials}
-     * implementation.
+     * to return an instance of {@link Credentials}.</li>
+     * <li>Ask the Subject for its public <code>SimpleCredentials</code> see
+     * {@link Subject#getPublicCredentials(Class)}, thus enabling to
+     * preauthenticate the Subject.</li>
+     * </ol>
-    private Credentials getCredentials() {
-        SimpleCredentials credentials = null;
-        if (sharedState.containsKey(KEY_SIMPLE_CREDENTIALS)) {
-            credentials = (SimpleCredentials) sharedState.get(KEY_SIMPLE_CREDENTIALS);
+    protected Credentials getCredentials() {
+        Credentials credentials = null;
+        if (sharedState.containsKey(KEY_CREDENTIALS)) {
+            credentials = (Credentials) sharedState.get(KEY_CREDENTIALS);
-                if (null != creds && creds instanceof SimpleCredentials) {
-                    credentials = (SimpleCredentials) creds;
-                    sharedState.put(KEY_SIMPLE_CREDENTIALS, credentials);
+                if (null != creds) {
+                    if (creds instanceof SimpleCredentials) {
+                       credentials = (SimpleCredentials) creds;
+                    } else if (creds instanceof GuestCredentials) {
+                       credentials = (GuestCredentials) creds;
+                    }
+                    sharedState.put(KEY_CREDENTIALS, credentials);
+            // try if subject contains SimpleCredentials
-                credentials = (SimpleCredentials) subject.getPublicCredentials(SimpleCredentials.class).iterator().next();
+                credentials = (Credentials) preAuthCreds.iterator().next();
-     * Method supports tries to acquire a UserID in the follwing order: <ol>
+     * Method supports tries to acquire a UserID in the follwing order:
+     * <ol>
+     * <li>If passed credentials are {@link GuestCredentials} the anonymous user id
+     * is returned.</li>
-     * <li>Test a defaultUserID is present in the LoginModule configuration.</li>
-    private String getUserID(Credentials credentials) {
+    protected String getUserID(Credentials credentials) {
-            if (credentials instanceof SimpleCredentials) {
+            if (credentials instanceof GuestCredentials) {
+                userId = anonymousId;
+            } else if (credentials instanceof SimpleCredentials) {
-        // still no userId -> if a defaultUserID has been specified or return
-        // the anonymous UserID.
+        // still no userId -> anonymousID if its has been defined.
-            if (defaultUserId != null) {
-                userId = defaultUserId;
-            } else {
-                userId = anonymousId;
-            }
+            userId = anonymousId;
-
-    private boolean isAnonymous(Credentials credentials) {
-        // TODO: check again. former simple-login-module treated 'null' as anonymous and had no anonymous config entry.
-        String userId = getUserID(credentials);
-        if (anonymousId == null) {
-            return userId == null;
+    protected boolean isAnonymous(Credentials credentials) {
+        if (credentials instanceof GuestCredentials) {
+            return true;
-            return anonymousId.equals(userId);
+            // TODO: review again. former simple-login-module treated 'null' as anonymous (probably wrong).
+            String userId = getUserID(credentials);
+            return (anonymousId == null) ? userId == null : anonymousId.equals(userId);
+
-     * This method resolves the Principal for the given Credentials. If there
-     * is no Principal for the Credentials, the LoginModule should be ignored.<p>
-     * This Abstract implementation uses the {@link PrincipalProvider} configured
-     * for it, to resolve this association.
-     * It takes the {@link PrincipalProvider#findPrincipals(String)} for the User-ID
-     * resolved by  {@link #getUserID(Credentials)}
+     * This method resolves the Principal for the given Credentials. If no valid
+     * Principal can be determined, the LoginModule should be ignored.
-     * @return if credentials are associated to one or null if none found
+     * @return the principal associated with the given credentials or <code>null</code>.
-    private Principal getPrincipal(Credentials credentials) {
-        Principal principal = null;
-        String userId = isAnonymous(credentials) ? anonymousId : getUserID(credentials);
-        PrincipalIterator res = principalProvider.findPrincipals(userId, PrincipalManager.SEARCH_TYPE_NOT_GROUP);
-        if (res.hasNext()) {
-            principal = res.nextPrincipal();
-        } // no matching principal -> return null
-        return principal;
+    protected abstract Principal getPrincipal(Credentials credentials);
+
+    /**
+     * @return a Collection of principals that contains the current user
+     * principal and all groups it is member of.
+     */
+    protected Set getPrincipals() {
+        // use ListOrderedSet instead of Hashset in order to maintain the order
+        // of principals (as in the Subject).
+        Set principals = new ListOrderedSet();
+        principals.add(principal);
+        Iterator groups = principalProvider.getGroupMembership(principal);
+        while (groups.hasNext()) {
+            principals.add(groups.next());
+        }
+        return principals;
-     * Returns the default user id.
+     * Returns the configured name of the principal provider class.
-     * @return default user id
+     * @return name of the principal provider class.
-    public String getDefaultUserId() {
-        return defaultUserId;
+    public String getPrincipalProvider() {
+        return principalProviderClassName;
-     * Sets the default user id to be used when no login credentials
-     * are presented.
+     * Sets the configured name of the principal provider class
-     * @param defaultUserId default user id
+     * @param principalProvider Name of the principal provider class.
-    public void setDefaultUserId(String defaultUserId) {
-        this.defaultUserId = defaultUserId;
+    public void setPrincipalProvider(String principalProvider) {
+        this.principalProviderClassName = principalProvider;

Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.hierarchy.NodeEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.PropertyEntry;
-import org.apache.jackrabbit.jcr2spi.state.entry.ChildNodeEntry;
-import org.apache.jackrabbit.jcr2spi.state.PropertyState;
-import javax.jcr.nodetype.NodeDefinition;
-import java.util.Collection;
-    private final NodeState vhState;
-    private final NodeState labelNodeState;
+    private final NodeEntry vhEntry;
+    private final NodeEntry labelNodeEntry;
-                              NodeState state, NodeDefinition definition,
-                              ItemLifeCycleListener[] listeners) throws VersionException {
-        super(itemMgr, session, state, definition, listeners);
-        this.vhState = state;
+                              NodeState state, ItemLifeCycleListener[] listeners)
+        throws VersionException {
+        super(itemMgr, session, state, listeners);
+        this.vhEntry = (NodeEntry) state.getHierarchyEntry();
-        if (state.hasChildNodeEntry(QName.JCR_VERSIONLABELS)) {
-            ChildNodeEntry lnEntry = state.getChildNodeEntry(QName.JCR_VERSIONLABELS, Path.INDEX_DEFAULT);
-            try {
-                labelNodeState = lnEntry.getNodeState();
-            } catch (ItemStateException e) {
-                throw new VersionException("nt:versionHistory requires a mandatory, autocreated child node jcr:versionLabels.");
-            }
+        if (vhEntry.hasNodeEntry(QName.JCR_VERSIONLABELS)) {
+            labelNodeEntry = vhEntry.getNodeEntry(QName.JCR_VERSIONLABELS, Path.INDEX_DEFAULT);
-        try {
-            if (vhState.hasChildNodeEntry(QName.JCR_ROOTVERSION)) {
-                NodeState vState = vhState.getChildNodeEntry(QName.JCR_ROOTVERSION, Path.INDEX_DEFAULT).getNodeState();
-                return (Version) itemMgr.getItem(vState);
-            } else {
-                String msg = "Unexpected error: VersionHistory state does not contain a root version child node entry.";
-                log.error(msg);
-                throw new RepositoryException(msg);
-            }
-        } catch (ItemStateException e) {
-            throw new RepositoryException(e);
+        if (vhEntry.hasNodeEntry(QName.JCR_ROOTVERSION)) {
+            NodeEntry vEntry = vhEntry.getNodeEntry(QName.JCR_ROOTVERSION, Path.INDEX_DEFAULT);
+            return (Version) itemMgr.getItem(vEntry);
+        } else {
+            String msg = "Unexpected error: VersionHistory state does not contain a root version child node entry.";
+            log.error(msg);
+            throw new RepositoryException(msg);
-        Iterator childIter = vhState.getChildNodeEntries().iterator();
-        List versionStates = new ArrayList();
+        refreshEntry(vhEntry);
+        Iterator childIter = vhEntry.getNodeEntries();
+        List versionEntries = new ArrayList();
-            ChildNodeEntry entry = (ChildNodeEntry) childIter.next();
-            if (!QName.JCR_VERSIONLABELS.equals(entry.getName())) {
-                try {
-                    versionStates.add(entry.getNodeState());
-                } catch (ItemStateException e) {
-                    throw new RepositoryException(e);
-                }
+            NodeEntry entry = (NodeEntry) childIter.next();
+            if (!QName.JCR_VERSIONLABELS.equals(entry.getQName())) {
+                versionEntries.add(entry);
-        return new LazyItemIterator(itemMgr, versionStates);
+        return new LazyItemIterator(itemMgr, versionEntries.iterator());
-        return (Version) itemMgr.getItem(vState);
+        return (Version) itemMgr.getItem(vState.getHierarchyEntry());
-        return (Version) itemMgr.getItem(vState);
+        return (Version) itemMgr.getItem(vState.getHierarchyEntry());
-        session.getVersionManager().addVersionLabel(vhState, vState, qLabel, moveLabel);
+        session.getVersionManager().addVersionLabel((NodeState) getItemState(), vState, qLabel, moveLabel);
-        session.getVersionManager().removeVersionLabel(vhState, vState, qLabel);
+        session.getVersionManager().removeVersionLabel((NodeState) getItemState(), vState, qLabel);
-        session.getVersionManager().removeVersion(vhState, vState);
+        session.getVersionManager().removeVersion((NodeState) getItemState(), vState);
-            return vhState.getUniqueID().equals(other.vhState.getUniqueID());
+            return vhEntry.getUniqueID().equals(other.vhEntry.getUniqueID());
+    /**
+     * Always returns false
+     *
+     * @throws RepositoryException
+     * @see NodeImpl#isWritable()
+     */
+    protected boolean isWritable() throws RepositoryException {
+        super.isWritable();
+        return false;
+    }
-    private QName[] getQLabels() {
-        Collection labelQNames = labelNodeState.getPropertyNames();
+    private QName[] getQLabels() throws RepositoryException {
+        refreshEntry(labelNodeEntry);
+        List labelQNames = new ArrayList();
+        Iterator it = labelNodeEntry.getPropertyEntries();
+        while (it.hasNext()) {
+            PropertyEntry pe = (PropertyEntry) it.next();
+            if (QName.JCR_PRIMARYTYPE.equals(pe.getQName())) {
+                continue;
+            }
+            labelQNames.add(pe.getQName());
+        }
-            ChildNodeEntry vEntry = vhState.getChildNodeEntry(vQName, Path.INDEX_DEFAULT);
+            refreshEntry(vhEntry);
+            NodeEntry vEntry = vhEntry.getNodeEntry(vQName, Path.INDEX_DEFAULT);
-        if (labelNodeState.hasPropertyName(qLabel)) {
-            // retrieve reference property value -> and convert it to a NodeId
-            try {
-                PropertyState pState = labelNodeState.getPropertyState(qLabel);
-                Node version = ((Property) itemMgr.getItem(pState)).getNode();
-                return getVersionState(version.getName());
-            } catch (ItemStateException e) {
-                // should not occur. existance of property state has been checked
-                throw new RepositoryException(e);
-            }
+        refreshEntry(labelNodeEntry);
+        if (labelNodeEntry.hasPropertyEntry(qLabel)) {
+            // retrieve reference property value -> and retrieve referenced node
+            PropertyEntry pEntry = labelNodeEntry.getPropertyEntry(qLabel);
+            Node version = ((Property) itemMgr.getItem(pEntry)).getNode();
+            return getVersionState(version.getName());
+
+    private void refreshEntry(NodeEntry entry) throws RepositoryException {
+        // TODO: check again.. is this correct? or should NodeEntry be altered
+        try {
+            entry.getNodeState();
+        } catch (ItemStateException e) {
+            throw new RepositoryException(e);
+        }
+    }

JCR-2509 : Reduce number of compiler warning by adding @Override and generics where appropriate [step 2: jackrabbit-jcr-server]

in addition:
- minor improvements in comments, typos
- use foreach loops where possible
- remove redundant Tika imports in server/io package
- remove redundant casts
- add missing index increment in SubscriptionManagerImpl.SubscriptionMap

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@915339 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Iterator;
-        LinkedList queue = new LinkedList();
+        LinkedList<String> queue = new LinkedList<String>();
-        for (int i = 0; i < elems.length; i++) {
-            String segm = elems[i];
+        for (String segm : elems) {
-                    last = queue.getLast().toString();
+                    last = queue.getLast();
-        return "/" + Text.implode((String[]) queue.toArray(new String[queue.size()]), "/");
+        return "/" + Text.implode(queue.toArray(new String[queue.size()]), "/");
-            for (int i = 0; i < mixins.length; i++) {
-                String mixinName = mixins[i].getName();
+            for (NodeType mixin : mixins) {
+                String mixinName = mixin.getName();
-            List newMixins = new ArrayList(values.length);
-            for (int i = 0; i < values.length; i++) {
-                newMixins.add(values[i].getString());
+            List<String> newMixins = new ArrayList<String>(values.length);
+            for (Value value : values) {
+                newMixins.add(value.getString());
-            for (int i = 0; i < mixins.length; i++) {
-                String mixinName = mixins[i].getName();
+            for (NodeType mixin : mixins) {
+                String mixinName = mixin.getName();
-            for (Iterator mixIt = newMixins.iterator(); mixIt.hasNext();) {
-                n.addMixin(mixIt.next().toString());
+            for (String newMixinName : newMixins) {
+                n.addMixin(newMixinName);
-                List valList = new ArrayList(strs.length);
+                List<Value> valList = new ArrayList<Value>(strs.length);
-                vs = (Value[]) valList.toArray(new Value[valList.size()]);
+                vs = valList.toArray(new Value[valList.size()]);
-        // surround diffvalue { key : } to make it parsable
+        // surround diff value { key : } to make it parsable
-        // surround diffvalue { key : } to make it parsable
+        // surround diff value { key : } to make it parsable
-        private List values = new ArrayList();
+        private List<Value> values = new ArrayList<Value>();
-            return (Value[]) values.toArray(new Value[values.size()]);
+            return values.toArray(new Value[values.size()]);
-        private Stack st = new Stack();
+        private Stack<ImportItem> st = new Stack<ImportItem>();
-                Object obj = st.peek();
+                ImportItem obj = st.peek();
-                    ((ImportNode)obj).addNode(n);
+                    ((ImportNode) obj).addNode(n);
-            Object obj = st.pop();
+            ImportItem obj = st.pop();
-                    ((ImportNode) obj).createItem(parent);                    
+                    obj.createItem(parent);                    
-            Object obj = st.peek();
+            ImportItem obj = st.peek();
-            Object obj = st.pop();
+            ImportItem obj = st.pop();
-            Object obj = st.peek();
+            ImportItem obj = st.peek();
-        private List childN = new ArrayList();
-        private List childP = new ArrayList();
+        private List<ImportNode> childN = new ArrayList<ImportNode>();
+        private List<ImportItem> childP = new ArrayList<ImportItem>();
+        @Override
-            for (Iterator it = childP.iterator(); it.hasNext();) {
-                ImportItem obj = (ImportItem) it.next();
+            for (ImportItem obj : childP) {
-            // recursivly create all child nodes
-            for (Iterator it = childN.iterator(); it.hasNext();) {
-                ImportItem obj = (ImportItem) it.next();
+            // recursively create all child nodes
+            for (ImportItem obj : childN) {
+        @Override
-        private List values = new ArrayList();
+        private List<Value> values = new ArrayList<Value>();
+        @Override
-            Value[] vls = (Value[]) values.toArray(new Value[values.size()]);
+            Value[] vls = values.toArray(new Value[values.size()]);

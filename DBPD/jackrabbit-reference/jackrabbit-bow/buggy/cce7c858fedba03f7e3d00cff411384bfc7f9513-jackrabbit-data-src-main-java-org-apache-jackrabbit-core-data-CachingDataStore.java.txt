JCR-3816: [aws-ext]S3DS not able update lastModified of record > 5GB
JCR-3817: [jackrabbit-aws-ext] Performance of operation degrades while running DS GC

Applying patch from Shashank Gupta

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1632482 13f79535-47bb-0310-9956-ffa450edef68

+ *     &lt;param name="{@link #setTouchAsync(boolean) touchAsync}" value="false"/>
-        MultiDataStoreAware, AsyncUploadCallback {
+        MultiDataStoreAware, AsyncUploadCallback, AsyncTouchCallback {
+    
+    /**
+     * In memory map to hold in-progress asynchronous touch. Once touch is
+     * successful corresponding entry is flushed from the map.
+     */
+    protected final Map<DataIdentifier, Long> asyncTouchCache = new ConcurrentHashMap<DataIdentifier, Long>(5);
+    
+    /**
+     * Flag to indicate if lastModified is updated asynchronously.
+     */
+    private boolean touchAsync = false;
-        boolean touch = minModifiedDate > 0 ? true : false;
-        synchronized (this) {
-            try {
-                if (asyncWriteCache.hasEntry(fileName, touch)) {
-                    usesIdentifier(identifier);
-                    return new CachingDataRecord(this, identifier);
-                } else if (cache.getFileIfStored(fileName) != null) {
-                    if (touch) {
-                        backend.exists(identifier, touch);
-                    }
-                    usesIdentifier(identifier);
-                    return new CachingDataRecord(this, identifier);
-                } else if (backend.exists(identifier, touch)) {
-                    usesIdentifier(identifier);
-                    return new CachingDataRecord(this, identifier);
-                }
-
-            } catch (IOException ioe) {
-                throw new DataStoreException("error in getting record ["
-                    + identifier + "]", ioe);
+        try {
+            if (asyncWriteCache.hasEntry(fileName, minModifiedDate > 0)) {
+                LOG.debug("[{}] record retrieved from asyncUploadmap",
+                    identifier);
+                usesIdentifier(identifier);
+                return new CachingDataRecord(this, identifier);
+            } else if (cache.getFileIfStored(fileName) != null
+                || backend.exists(identifier)) {
+                LOG.debug("[{}] record retrieved from local cache or backend",
+                    identifier);
+                touchInternal(identifier);
+                usesIdentifier(identifier);
+                return new CachingDataRecord(this, identifier);
+
+        } catch (IOException ioe) {
+            throw new DataStoreException("error in getting record ["
+                + identifier + "]", ioe);
-
+    
-     * @param identifier
-     *            identifier of record.
+     * @param identifier identifier of record.
-        boolean touch = minModifiedDate > 0 ? true : false;
-        synchronized (this) {
-            try {
-                if (asyncWriteCache.hasEntry(fileName, touch)
-                    || backend.exists(identifier, touch)) {
-                    usesIdentifier(identifier);
-                    return new CachingDataRecord(this, identifier);
-                }
-            } catch (IOException ioe) {
-                throw new DataStoreException(ioe);
+        try {
+            if (asyncWriteCache.hasEntry(fileName, minModifiedDate > 0)) {
+                LOG.debug("[{}] record retrieved from asyncuploadmap",
+                    identifier);
+                usesIdentifier(identifier);
+                return new CachingDataRecord(this, identifier);
+            } else if (backend.exists(identifier)) {
+                LOG.debug("[{}] record retrieved from backend", identifier);
+                touchInternal(identifier);
+                usesIdentifier(identifier);
+                return new CachingDataRecord(this, identifier);
+        } catch (IOException ioe) {
+            throw new DataStoreException(ioe);
-                "identifier [{}]'s lastModified retrireved from AsyncUploadCache ",
-                identifier);
+                "identifier [{}], lastModified=[{}] retrireved from AsyncUploadCache ",
+                identifier, lastModified);
+        } else if (asyncTouchCache.get(identifier) != null) {
+            lastModified = asyncTouchCache.get(identifier);
+            LOG.debug(
+                "identifier [{}], lastModified=[{}] retrireved from asyncTouchCache ",
+                identifier, lastModified);
-            lastModified =  backend.getLastModified(identifier);
+            lastModified = backend.getLastModified(identifier);
+            LOG.debug(
+                "identifier [{}], lastModified=[{}] retrireved from backend ",
+                identifier, lastModified);
-        LOG.debug("identifier= [{}], lastModified=[{}]", identifier,
-            lastModified);
-            InputStream in = null;
-            InputStream cachedStream = null;
-            try {
-                in = backend.read(identifier);
-                cachedStream = cache.store(fileName, in);
-            } catch (IOException e) {
-                throw new DataStoreException("IO Exception: " + identifier, e);
-            } finally {
-                IOUtils.closeQuietly(in);
-                IOUtils.closeQuietly(cachedStream);
-            }
-            length = cache.getFileLength(fileName);
-            if (length != null) {
-                return length.longValue();
-            }
+            return backend.getLength(identifier);
-        return backend.getLength(identifier);
+            } else {
+                // async upload took lot of time.
+                // getRecord to touch if required.
+                getRecord(identifier);
+            // remove from failed upload map if any.
+            uploadRetryMap.remove(identifier);
+    
+    @Override
+    public void onSuccess(AsyncTouchResult result) {
+        asyncTouchCache.remove(result.getIdentifier());
+        LOG.debug(" Async Touch succeed. Removed [{}] from asyncTouchCache",
+            result.getIdentifier());
+
+    }
+    
+    @Override
+    public void onFailure(AsyncTouchResult result) {
+        LOG.warn(" Async Touch failed. Not removing [{}] from asyncTouchCache",
+            result.getIdentifier());
+        if (result.getException() != null) {
+            LOG.debug(" Async Touch failed. exception", result.getException());
+        }
+    }
+    
+    @Override
+    public void onAbort(AsyncTouchResult result) {
+        asyncTouchCache.remove(result.getIdentifier());
+        LOG.debug(" Async Touch aborted. Removed [{}] from asyncTouchCache",
+            result.getIdentifier());
+    }
+    
+    /**
+     * Method to confirm that identifier can be deleted from {@link Backend}
+     * 
+     * @param identifier
+     * @return
+     */
+    public boolean confirmDelete(DataIdentifier identifier) {
+        if (isInUse(identifier)) {
+            LOG.debug("identifier [{}] is inUse confirmDelete= false ",
+                identifier);
+            return false;
+        }
+
+        String fileName = getFileName(identifier);
+        long lastModified = asyncWriteCache.getLastModified(fileName);
+        if (lastModified != 0) {
+            LOG.debug(
+                "identifier [{}] is asyncWriteCache map confirmDelete= false ",
+                identifier);
+            return false;
+
+        }
+        if (asyncTouchCache.get(identifier) != null) {
+            LOG.debug(
+                "identifier [{}] is asyncTouchCache confirmDelete = false ",
+                identifier);
+            return false;
+        }
+
+        return true;
+    }
+    
+    /**
+     * Internal method to touch identifier in @link {@link Backend}. if
+     * {@link #touchAsync}, the record is updated asynchronously.
+     * 
+     * @param identifier
+     * @throws DataStoreException
+     */
+    private void touchInternal(DataIdentifier identifier)
+            throws DataStoreException {
+
+        if (touchAsync) {
+            Long lastModified = asyncTouchCache.put(identifier,
+                System.currentTimeMillis());
+
+            if (lastModified == null) {
+                LOG.debug("Async touching [{}] ", identifier);
+                backend.touchAsync(identifier, minModifiedDate, this);
+            } else {
+                LOG.debug( "Touched in asyncTouchMap [{}]", identifier);
+            }
+                
+        } else {
+            backend.touch(identifier, minModifiedDate);
+        }
+    }
+    
+    
+    
+
+    public void setTouchAsync(boolean touchAsync) {
+        this.touchAsync = touchAsync;
+    }

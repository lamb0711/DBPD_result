Redesigned query manager to support pluggable implementation for search index.

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@124906 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.*;
+import org.apache.jackrabbit.core.search.OrderQueryNode;
+import org.apache.jackrabbit.core.QName;
+import org.apache.jackrabbit.core.NamespaceRegistryImpl;
+import org.apache.jackrabbit.core.SessionImpl;
+import org.apache.jackrabbit.core.ItemManager;
+import org.apache.jackrabbit.core.Path;
+import org.apache.jackrabbit.core.MalformedPathException;
+import org.apache.jackrabbit.core.NoPrefixDeclaredException;
+import org.apache.jackrabbit.core.AccessManagerImpl;
+import org.apache.jackrabbit.core.NodeId;
+import org.apache.jackrabbit.core.AccessManager;
+import org.apache.jackrabbit.core.NamespaceResolver;
+import org.apache.lucene.search.Hits;
+import org.apache.lucene.search.Query;
-import javax.jcr.*;
-import javax.jcr.query.Query;
+import javax.jcr.ItemNotFoundException;
+import javax.jcr.RepositoryException;
+import javax.jcr.Node;
+import javax.jcr.ItemExistsException;
+import javax.jcr.PathNotFoundException;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.io.IOException;
-public class QueryImpl implements Query {
+class QueryImpl implements javax.jcr.query.Query {
+    private final SearchIndex index;
+
-    private final SearchManager searchMgr;
-
-                     SearchManager searchMgr,
+                     SearchIndex index,
-        this.searchMgr = searchMgr;
+        this.index = index;
-                     SearchManager searchMgr,
+                     SearchIndex index,
-        this.searchMgr = searchMgr;
+        this.index = index;
-        return searchMgr.execute(itemMgr, root, session);
+        // build lucene query
+        Query query = LuceneQueryBuilder.createQuery(root,
+                session, index.getNamespaceMappings(), index.getAnalyzer());
+
+        OrderQueryNode orderNode = root.getOrderNode();
+        // FIXME according to spec this should be descending
+        // by default. this contrasts to standard sql semantics
+        // where default is ascending.
+        boolean[] orderSpecs = null;
+        String[] orderProperties = null;
+        if (orderNode != null) {
+            orderProperties = orderNode.getOrderByProperties();
+            orderSpecs = orderNode.getOrderBySpecs();
+        } else {
+            orderProperties = new String[0];
+            orderSpecs = new boolean[0];
+        }
+
+
+        List uuids;
+        AccessManagerImpl accessMgr = session.getAccessManager();
+
+        // execute it
+        try {
+            Hits result = index.executeQuery(query, orderProperties, orderSpecs);
+            uuids = new ArrayList(result.length());
+            for (int i = 0; i < result.length(); i++) {
+                String uuid = result.doc(i).get(FieldNames.UUID);
+                // check access
+                if (accessMgr.isGranted(new NodeId(uuid), AccessManager.READ)) {
+                    uuids.add(uuid);
+                }
+            }
+        } catch (IOException e) {
+            uuids = Collections.EMPTY_LIST;
+        }
+
+        // return QueryResult
+        return new QueryResultImpl(itemMgr,
+                (String[]) uuids.toArray(new String[uuids.size()]),
+                root.getSelectProperties());

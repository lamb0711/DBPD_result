Redesign of query index to allow for generations of PersistentIndex instances. Indexing a lot of content is now faster and pauses during indexing are less frequent. At the same time less lucene IndexReader/Writer changes occur.

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@160385 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.fs.FileSystemException;
-import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexReader;
+import org.apache.log4j.Logger;
+    /** The logger instance for this class */
+    private static final Logger log = Logger.getLogger(PersistentIndex.class);
+
+    /** Name of the write lock file */
+    private static final String WRITE_LOCK = "write.lock";
+
+    /** The name of this persistent index */
+    private final String name;
+
+     * @param name the name of this index.
-     * index.
+     *  index.
+     * @throws FileSystemException if an error occurs while opening / creating
+     *  the index.
-    PersistentIndex(FileSystem fs, boolean create, Analyzer analyzer)
-            throws IOException {
+    PersistentIndex(String name, FileSystem fs, boolean create, Analyzer analyzer)
+            throws FileSystemException, IOException {
+        this.name = name;
+
+        // check if index is locked, probably from an unclean repository
+        // shutdown
+        if (fs.exists(WRITE_LOCK)) {
+            log.warn("Removing write lock on search index.");
+            try {
+                fs.deleteFile(WRITE_LOCK);
+            } catch (FileSystemException e) {
+                log.error("Unable to remove write lock on search index.");
+            }
+        }
-     * Merges another index into this persistent index.
+     * Merges another index into this persistent index. Before <code>index</code>
+     * is merged, {@link AbstractIndex#commit()} is called on that
+     * <code>index</code>.
+     *
+
+    /**
+     * Returns <code>true</code> if this index has valid documents. Returns
+     * <code>false</code> if all documents are deleted, or the index does not
+     * contain any documents.
+     * @return
+     * @throws IOException
+     */
+    boolean hasDocuments() throws IOException {
+        if (getIndexReader().numDocs() == 0) {
+            return false;
+        }
+        IndexReader reader = getIndexReader();
+        for (int i = 0; i < reader.maxDoc(); i++) {
+            if (!reader.isDeleted(i)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Returns the name of this index.
+     * @return the name of this index.
+     */
+    String getName() {
+        return name;
+    }

JCR-2064 Add new JSR283 features to CND reader/writer
JCR-2153 Introduce QValueConstraint and change return type of QPropertyDefinition.getValueConstraints()
JCR-2158 Consolidate CND related classes from SPI and Core


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@785777 13f79535-47bb-0310-9956-ffa450edef68

+import javax.jcr.nodetype.PropertyDefinition;
+import javax.jcr.nodetype.ItemDefinition;
+import javax.jcr.nodetype.NodeTypeDefinition;
+import org.apache.jackrabbit.spi.QValueConstraint;
+import org.apache.jackrabbit.spi.commons.query.qom.Operator;
+     * @return the created name
-    public abstract Name createName(String namespaceURI, String localName) throws IllegalArgumentException;
+    public abstract Name createName(String namespaceURI, String localName)
+            throws IllegalArgumentException;
+        private boolean isAbstract;
+        private boolean isQueryable = true;
-         * @param name
+         * @param name the name
+         * @see NodeTypeDefinition#getName()
-         * @return the name of the node type definition being built or <code>null</code> if not set.
+         * @return the name of the node type definition being built or
+         * <code>null</code> if not set.
+         * @see NodeTypeDefinition#getName()
-         * @param supertypes
+         * @param supertypes the supertypes
+         * @see NodeTypeDefinition#getDeclaredSupertypeNames()
-         * Returns an array containing the names of the supertypes of the node type definition being
-         * built.
+         * Returns an array containing the names of the supertypes of the node
+         * type definition being built.
+         * @see NodeTypeDefinition#getDeclaredSupertypeNames()
-         * @param isMixin true if building a mixin node type definition; false otherwise.
+         * @param isMixin <code>true</code> if building a mixin node type
+         * definition; <code>false</code> otherwise.
+         * @see NodeTypeDefinition#isMixin()
-         * @return true if building a mixin node type definition; false otherwise.
+         * @return <code>true</code> if building a mixin node type definition;
+         * <code>false</code> otherwise.
+         * @see NodeTypeDefinition#isMixin()
-         * @param isOrderable true if building a node type having orderable child nodes; false
-         *                otherwise.
+         * @param isOrderable <code>true</code> if building a node type having
+         * orderable child nodes; <code>false</code> otherwise.
+         * @see NodeTypeDefinition#hasOrderableChildNodes()
-         * @return true if building a node type having orderable child nodes; false otherwise.
+         * @return <code>true</code> if building a node type having orderable
+         * child nodes; <code>false</code> otherwise.
+         * @see NodeTypeDefinition#hasOrderableChildNodes()
-         * @param primaryItemName  the name of the primary item or <code>null</code> if not set.
+         * @param primaryItemName the name of the primary item or
+         * <code>null</code> if not set.
+         * @see NodeTypeDefinition#getPrimaryItemName()
+         * @see NodeTypeDefinition#getPrimaryItemName()
+         * @return <code>true</code> if the node type is abstract.
+         * @see NodeTypeDefinition#isAbstract()
+         */
+        public boolean getAbstract() {
+            return isAbstract;
+        }
+
+        /**
+         * @param isAbstract <code>true</code> if building a node type that is abstract.
+         * @see NodeTypeDefinition#isAbstract()
+         */
+        public void setAbstract(boolean isAbstract) {
+            this.isAbstract = isAbstract;
+        }
+
+        /**
+         * @return <code>true</code> if the node type is queryable
+         * @see NodeTypeDefinition#isQueryable()
+         */
+        public boolean getQueryable() {
+            return isQueryable;
+        }
+
+        /**
+         * @param queryable <code>true</code> if building a node type that is queryable
+         * @see NodeTypeDefinition#isQueryable()
+         */
+        public void setQueryable(boolean queryable) {
+            isQueryable = queryable;
+        }
+
+        /**
+         * @see NodeTypeDefinition#getDeclaredPropertyDefinitions()
+         * @see NodeTypeDefinition#getDeclaredPropertyDefinitions()
+         * @see NodeTypeDefinition#getDeclaredChildNodeDefinitions()
+         * @see NodeTypeDefinition#getDeclaredChildNodeDefinitions()
+         * @see ItemDefinition#getName()
+         * @see ItemDefinition#getName()
+         * @see ItemDefinition#getDeclaringNodeType()
+         * @see ItemDefinition#getDeclaringNodeType()
-         * @param autocreate  true if building a 'autocreate' child item definition, false otherwise.
+         * @param autocreate <code>true</code> if building a 'autocreate' child item 
+         * definition, false otherwise.
+         * @see ItemDefinition#isAutoCreated()
-         * @return true if building a 'autocreate' child item definition, false otherwise.
+         * @return <code>true</code> if building a 'autocreate' child item
+         * definition, false otherwise.
+         * @see ItemDefinition#isAutoCreated()
+         * @see ItemDefinition#getOnParentVersion()
+         * @see ItemDefinition#getOnParentVersion()
-         * @param isProtected true if building a 'protected' child item definition, false otherwise.
+         * @param isProtected <code>true</code> if building a 'protected' child
+         * item definition, false otherwise.
+         * @see ItemDefinition#isProtected()
-         * @return  true if building a 'protected' child item definition, false otherwise.
+         * @return <code>true</code> if building a 'protected' child item
+         * definition, false otherwise.
+         * @see ItemDefinition#isProtected()
-         * @param isMandatory true if building a 'mandatory' child item definition, false otherwise.
+         * @param isMandatory <code>true</code> if building a 'mandatory' child
+         * item definition, false otherwise.
+         * @see ItemDefinition#isMandatory()
-         * @return  true if building a 'mandatory' child item definition, false otherwise.
+         * @return <code>true</code> if building a 'mandatory' child item
+         * definition, false otherwise.
+         * @see ItemDefinition#isMandatory()
-     * A builder for a {@link QNodeDefinition}
+     * A builder for a {@link QPropertyDefinition}
+     * @see PropertyDefinition
+
-        private String[] valueConstraints;
+        private QValueConstraint[] valueConstraints;
+        private boolean fullTextSearchable = true;
+        private boolean queryOrderable = true;
+        private String[] queryOperators = Operator.getAllQueryOperators();
+         * @see PropertyDefinition#getRequiredType()
+         * @see PropertyDefinition#getRequiredType()
+         * @see PropertyDefinition#getValueConstraints()
-        public void setValueConstraints(String[] constraints) {
+        public void setValueConstraints(QValueConstraint[] constraints) {
+         * @see PropertyDefinition#getValueConstraints()
-        public String[] getValueConstraints() {
+        public QValueConstraint[] getValueConstraints() {
+         * @see PropertyDefinition#getDefaultValues()
+         * @see PropertyDefinition#getDefaultValues()
+         * @see PropertyDefinition#isMultiple()
+         * @see PropertyDefinition#isMultiple()
+         * @return <code>true</code> if the property is fulltext searchable
+         * @see PropertyDefinition#isFullTextSearchable()
+         */
+        public boolean getFullTextSearchable() {
+            return fullTextSearchable;
+        }
+
+        /**
+         * @param fullTextSearchable <code>true</code> if building a
+         * 'fulltext searchable' property definition
+         * @see PropertyDefinition#isFullTextSearchable()
+         */
+        public void setFullTextSearchable(boolean fullTextSearchable) {
+            this.fullTextSearchable = fullTextSearchable;
+        }
+
+        /**
+         * @return <code>true</code> if the property is orderable in a query
+         * @see PropertyDefinition#isQueryOrderable()
+         */
+        public boolean getQueryOrderable() {
+            return queryOrderable;
+        }
+
+        /**
+         * @param queryOrderable <code>true</code> if the property is orderable
+         *        in a query
+         * @see PropertyDefinition#isQueryOrderable()
+         */
+        public void setQueryOrderable(boolean queryOrderable) {
+            this.queryOrderable = queryOrderable;
+        }
+
+        /**
+         * @return the query operators of the property
+         * @see PropertyDefinition#getAvailableQueryOperators()
+         */
+        public String[] getAvailableQueryOperators() {
+            return queryOperators;
+        }
+
+        /**
+         * @param queryOperators the query operators of the property
+         * @see PropertyDefinition#getAvailableQueryOperators()
+         */
+        public void setAvailableQueryOperators(String[] queryOperators) {
+            this.queryOperators = queryOperators;
+        }
+
+        /**
-         * @param constraint
-         * @param resolver
+         * @param constraint the contraint
+         * @param resolver the resolver
-        public abstract String createValueConstraint(String constraint, NamePathResolver resolver)
+        public abstract QValueConstraint createValueConstraint(String constraint, NamePathResolver resolver)
-         * @param value
-         * @param resolver
+         * @param value the value
+         * @param resolver the resolver

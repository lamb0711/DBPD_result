JCR-258 - remove JDOM dependency from jcr-server contribution
JCR-295 - usage of Cache-Control header 
JCR-297 - log output while parsing xml
minor consistency issues and improvements

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@368683 13f79535-47bb-0310-9956-ffa450edef68

-import org.jdom.Element;
-import org.jdom.Document;
-import org.jdom.output.XMLOutputter;
-import org.jdom.output.Format;
-import org.apache.jackrabbit.webdav.lock.*;
-import org.apache.jackrabbit.webdav.observation.*;
+import org.apache.jackrabbit.webdav.xml.XmlSerializable;
+import org.apache.jackrabbit.webdav.property.DavPropertySet;
+import org.apache.jackrabbit.webdav.lock.ActiveLock;
+import org.apache.jackrabbit.webdav.lock.LockDiscovery;
+import org.apache.jackrabbit.webdav.observation.Subscription;
+import org.apache.jackrabbit.webdav.observation.SubscriptionDiscovery;
+import org.apache.jackrabbit.webdav.observation.EventDiscovery;
+import org.apache.xml.serialize.OutputFormat;
+import org.apache.xml.serialize.XMLSerializer;
+import org.w3c.dom.Document;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.parsers.DocumentBuilderFactory;
-import java.io.ByteArrayOutputStream;
+import java.io.ByteArrayOutputStream;
+    private static final DocumentBuilderFactory BUILDER_FACTORY = DocumentBuilderFactory.newInstance();
+
-        this.httpResponse = httpResponse;
-
-        /* set cache control headers in order to deal with non-webdav complient
-        * http1.1 or http1.0 proxies. >> see RFC2518 9.4.5 */
-        addHeader("Pragma", "No-cache");  // http1.0
-        addHeader("Cache-Control", "no-cache"); // http1.1
+        this(httpResponse, false);
+     * Create a new <code>WebdavResponse</code>
+     *
+     * @param httpResponse
+     * @param noCache
+     */
+    public WebdavResponseImpl(HttpServletResponse httpResponse, boolean noCache) {
+        this.httpResponse = httpResponse;
+        if (noCache) {
+            /* set cache control headers */
+        addHeader("Pragma", "No-cache");  // http1.0
+        addHeader("Cache-Control", "no-cache"); // http1.1
+    }
+    }
+
+    /**
+     * If the specifid exception provides an error condition an Xml response body
+     * is sent providing more detailed information about the error. Otherwise only
+     * the error code and status phrase is sent back.
+     * @see #sendError(int, String)
+     * @see #sendXmlResponse(XmlSerializable, int)
-        Element errorElem = exception.getError();
-        if (errorElem == null || errorElem.getChildren().size() == 0) {
+        if (!exception.hasErrorCondition()) {
-            sendXmlResponse(new Document(exception.getError()), exception.getErrorCode());
+            sendXmlResponse(exception, exception.getErrorCode());
-        sendXmlResponse(multistatus.toXml(), SC_MULTI_STATUS);
+        sendXmlResponse(multistatus, SC_MULTI_STATUS);
-
-        Element propElem = new Element(DavConstants.XML_PROP, DavConstants.NAMESPACE);
-	propElem.addContent(new LockDiscovery(lock).toXml());
-	sendXmlResponse(new Document(propElem), SC_OK);
+	DavPropertySet propSet = new DavPropertySet();
+        propSet.add(new LockDiscovery(lock));
+        sendXmlResponse(propSet, SC_OK);
-        Element propElem = new Element(DavConstants.XML_PROP, DavConstants.NAMESPACE);
-        propElem.addContent(new LockDiscovery(locks).toXml());
-        sendXmlResponse(new Document(propElem), SC_OK);
+        DavPropertySet propSet = new DavPropertySet();
+        propSet.add(new LockDiscovery(locks));
+        sendXmlResponse(propSet, SC_OK);
-     * @param xmlDoc
+     * @param serializable
-     * @see DavServletResponse#sendXmlResponse(Document, int);
+     * @see DavServletResponse#sendXmlResponse(XmlSerializable, int);
-    public void sendXmlResponse(Document xmlDoc, int status) throws IOException {
+    public void sendXmlResponse(XmlSerializable serializable, int status) throws IOException {
-        if (xmlDoc != null) {
+        if (serializable != null) {
-            // Write dom tree into byte array output stream
-            XMLOutputter xmli = new XMLOutputter(Format.getRawFormat());
-            xmli.output(xmlDoc, out);
+            try {
+                Document doc = BUILDER_FACTORY.newDocumentBuilder().newDocument();
+                doc.appendChild(serializable.toXml(doc));
+                
+                OutputFormat format = new OutputFormat("xml", "UTF-8", true);
+                XMLSerializer serializer = new XMLSerializer(out, format);
+                serializer.setNamespaces(true);
+                serializer.asDOMSerializer().serialize(doc);
+
-            out.close();
-            out.flush();
+
+            } catch (ParserConfigurationException e) {
+                log.error(e.getMessage());
+                throw new IOException(e.getMessage());
+            }
-        Element propElem = new Element(DavConstants.XML_PROP, DavConstants.NAMESPACE);
-	propElem.addContent(new SubscriptionDiscovery(subscription).toXml());
-	Document doc = new Document(propElem);
-	sendXmlResponse(doc, SC_OK);
+	DavPropertySet propSet = new DavPropertySet();
+        propSet.add(new SubscriptionDiscovery(subscription));
+        sendXmlResponse(propSet, SC_OK);
-        Document pollDoc = new Document(eventDiscovery.toXml());
-        sendXmlResponse(pollDoc, SC_OK);
+        sendXmlResponse(eventDiscovery, SC_OK);

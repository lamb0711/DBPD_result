cleaning up NodeTypeRegistry and EffectiveNodeType code:
- removing NodeTypeRegistry field from EffectiveNodeType
- reviewing access modifiers
- make those methods static that don't affect the state of an instance
- etc etc

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@414843 13f79535-47bb-0310-9956-ffa450edef68

-    // node type registry
-    private final NodeTypeRegistry ntReg;
-
-    private EffectiveNodeType(NodeTypeRegistry ntReg) {
-        this.ntReg = ntReg;
+    private EffectiveNodeType() {
-     * Factory method: creates an effective node type representation of an
-     * existing (i.e. registered) node type.
-     *
-     * @param ntReg
-     * @param nodeTypeName
-     * @return
-     * @throws NodeTypeConflictException
-     * @throws NoSuchNodeTypeException
-     */
-    static EffectiveNodeType create(NodeTypeRegistry ntReg, QName nodeTypeName)
-            throws NodeTypeConflictException, NoSuchNodeTypeException {
-        return create(ntReg, ntReg.getNodeTypeDef(nodeTypeName));
-    }
-
-    /**
-     * Factory method: creates an effective node type representation of a
-     * node type definition. Whereas all referenced node types must exist
-     * (i.e. must be registered), the definition itself is not required to be
-     * registered.
-     *
-     * @param ntReg
-     * @param ntd
-     * @return
-     * @throws NodeTypeConflictException
-     * @throws NoSuchNodeTypeException
-     */
-    public static EffectiveNodeType create(NodeTypeRegistry ntReg, NodeTypeDef ntd)
-            throws NodeTypeConflictException, NoSuchNodeTypeException {
-        return create(ntReg, ntd, null, null);
-    }
-
-    /**
-     * Whereas all referenced node types must exist (i.e. must be registered),
-     * the definition itself is not required to be registered.
-     * todo check javadoc/param names
-     * @param ntReg
-     * @param ntd
-     * @param anEntCache
-     * @param aRegisteredNTDefCache
-     * @return
-     * @throws NodeTypeConflictException
-     * @throws NoSuchNodeTypeException
+     * Note that the definitions of all referenced node types must be contained
+     * in <code>ntdCache</code>.
+     *
+     * @param ntd      node type defintion
+     * @param entCache cache of already-built effective node types
+     * @param ntdCache cache of node type definitions, used to resolve dependencies
+     * @return an effective node type representation of the given node type definition.
+     * @throws NodeTypeConflictException if the node type definition is invalid,
+     *                                   e.g. due to ambiguous child definitions.
+     * @throws NoSuchNodeTypeException if a node type reference (e.g. a supertype)
+     *                                 could not be resolved.
-    static EffectiveNodeType create(NodeTypeRegistry ntReg,
-                                    NodeTypeDef ntd,
-                                    EffectiveNodeTypeCache anEntCache,
-                                    Map aRegisteredNTDefCache)
+    static EffectiveNodeType create(NodeTypeDef ntd,
+                                    EffectiveNodeTypeCache entCache,
+                                    Map ntdCache)
-        EffectiveNodeType ent = new EffectiveNodeType(ntReg);
+        EffectiveNodeType ent = new EffectiveNodeType();
-            if (anEntCache == null || aRegisteredNTDefCache == null) {
-                ent.internalMerge(ntReg.getEffectiveNodeType(supertypes), true);
-            } else {
-                ent.internalMerge(ntReg.getEffectiveNodeType(supertypes, anEntCache, aRegisteredNTDefCache), true);
-            }
+            ent.internalMerge(NodeTypeRegistry.getEffectiveNodeType(supertypes, entCache, ntdCache), true);
-    static EffectiveNodeType create(NodeTypeRegistry ntReg) {
-        return new EffectiveNodeType(ntReg);
+    static EffectiveNodeType create() {
+        return new EffectiveNodeType();
+     * Determines whether this effective node type representation includes
+     * (either through inheritance or aggregation) all of the given node types.
+     *
+     * @param nodeTypeNames array of node type names
+     * @return <code>true</code> if all of the given node types are included,
+     *         otherwise <code>false</code>
+     */
+    public boolean includesNodeTypes(QName[] nodeTypeNames) {
+        return allNodeTypes.containsAll(Arrays.asList(nodeTypeNames));
+    }
+
+    /**
-            getApplicableChildNodeDef(name, null);
+            getApplicableChildNodeDef(name, null, null);
+     * @param ntReg
-    public void checkAddNodeConstraints(QName name, QName nodeTypeName)
+    public void checkAddNodeConstraints(QName name, QName nodeTypeName,
+                                        NodeTypeRegistry ntReg)
-        NodeDef nd = getApplicableChildNodeDef(name, nodeTypeName);
+        NodeDef nd = getApplicableChildNodeDef(name, nodeTypeName, ntReg);
+     * @param ntReg
-    public NodeDef getApplicableChildNodeDef(QName name, QName nodeTypeName)
+    public NodeDef getApplicableChildNodeDef(QName name, QName nodeTypeName,
+                                             NodeTypeRegistry ntReg)
+        EffectiveNodeType entTarget;
+        if (nodeTypeName != null) {
+            entTarget = ntReg.getEffectiveNodeType(nodeTypeName);
+        } else {
+            entTarget = null;
+        }
+
-                    if (nodeTypeName != null) {
-                        try {
-                            // check node type constraints
-                            checkRequiredPrimaryType(nodeTypeName, nd.getRequiredPrimaryTypes());
-                        } catch (ConstraintViolationException cve) {
-                            // ignore and try next
+                    if (entTarget != null && nd.getRequiredPrimaryTypes() != null) {
+                        // check 'required primary types' constraint
+                        if (!entTarget.includesNodeTypes(nd.getRequiredPrimaryTypes())) {
-                        // found node definition
+                        // found named node definition
-            if (nodeTypeName != null) {
-                try {
-                    // check node type constraint
-                    checkRequiredPrimaryType(nodeTypeName, nd.getRequiredPrimaryTypes());
-                } catch (ConstraintViolationException e) {
-                    // ignore and try next
+            if (entTarget != null && nd.getRequiredPrimaryTypes() != null) {
+                // check 'required primary types' constraint
+                if (!entTarget.includesNodeTypes(nd.getRequiredPrimaryTypes())) {
-     * @param nodeTypeName
-     * @param requiredPrimaryTypes
-     * @throws ConstraintViolationException
-     * @throws NoSuchNodeTypeException
-     */
-    public void checkRequiredPrimaryType(QName nodeTypeName,
-                                         QName[] requiredPrimaryTypes)
-            throws ConstraintViolationException, NoSuchNodeTypeException {
-        if (requiredPrimaryTypes == null) {
-            // no constraint
-            return;
-        }
-        EffectiveNodeType ent;
-        try {
-            ent = ntReg.getEffectiveNodeType(nodeTypeName);
-        } catch (RepositoryException re) {
-            String msg = "failed to check node type constraint";
-            log.debug(msg);
-            throw new ConstraintViolationException(msg, re);
-        }
-        for (int i = 0; i < requiredPrimaryTypes.length; i++) {
-            if (!ent.includesNodeType(requiredPrimaryTypes[i])) {
-                throw new ConstraintViolationException("node type constraint not satisfied: " + requiredPrimaryTypes[i]);
-            }
-        }
-    }
-
-    /**
-        EffectiveNodeType clone = new EffectiveNodeType(ntReg);
+        EffectiveNodeType clone = new EffectiveNodeType();

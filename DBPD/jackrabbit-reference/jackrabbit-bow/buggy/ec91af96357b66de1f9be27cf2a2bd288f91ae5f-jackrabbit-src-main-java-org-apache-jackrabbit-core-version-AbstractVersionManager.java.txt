JCR-449 inconsistency in internal version items during commits


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@411154 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.NodeImpl;
+import EDU.oswego.cs.dl.util.concurrent.ReadWriteLock;
+import EDU.oswego.cs.dl.util.concurrent.ReentrantWriterPreferenceReadWriteLock;
+import org.apache.jackrabbit.core.NodeImpl;
-import javax.jcr.Value;
+import javax.jcr.Value;
+    /**
+     * the lock on this version manager
+     */
+    private final ReadWriteLock rwLock =
+            new ReentrantWriterPreferenceReadWriteLock() {
+                /**
+                 * Allow reader when there is no active writer, or current
+                 * thread owns the write lock (reentrant).
+                 * <p/>
+                 * the 'noLockHack' is only temporary (hopefully)
+                 */
+                protected boolean allowReader() {
+                    return activeWriter_ == null
+                        || activeWriter_ == Thread.currentThread();
+                }
+            };
+
+     * aquires the write lock on this version manager.
+     */
+    protected void aquireWriteLock() {
+        while (true) {
+            try {
+                rwLock.writeLock().acquire();
+                return;
+            } catch (InterruptedException e) {
+                // ignore
+            }
+        }
+    }
+
+    /**
+     * releases the write lock on this version manager.
+     */
+    protected void releaseWriteLock() {
+        rwLock.writeLock().release();
+    }
+
+    /**
+     * aquires the read lock on this version manager.
+     */
+    protected void aquireReadLock() {
+        while (true) {
+            try {
+                rwLock.readLock().acquire();
+                return;
+            } catch (InterruptedException e) {
+                // ignore
+            }
+        }
+    }
+
+    /**
+     * releases the read lock on this version manager.
+     */
+    protected void releaseReadLock() {
+        rwLock.readLock().release();
+    }
+
+    /**
+        aquireWriteLock();
+            releaseWriteLock();
+            releaseWriteLock();
-        // 1. search a predecessor, suitable for generating the new name
-        Value[] values = node.getProperty(QName.JCR_PREDECESSORS).getValues();
-        InternalVersion best = null;
-        for (int i = 0; i < values.length; i++) {
-            InternalVersion pred = history.getVersion(NodeId.valueOf(values[i].getString()));
-            if (best == null || pred.getSuccessors().length < best.getSuccessors().length) {
-                best = pred;
-            }
-        }
-
-        // 2. generate version name (assume no namespaces in version names)
-        String versionName = best.getName().getLocalName();
-        int pos = versionName.lastIndexOf('.');
-        if (pos > 0) {
-            versionName = versionName.substring(0, pos + 1)
-                + (Integer.parseInt(versionName.substring(pos + 1)) + 1);
-        } else {
-            versionName = String.valueOf(best.getSuccessors().length + 1) + ".0";
-        }
-
-        // 3. check for colliding names
-        while (history.hasVersion(new QName("", versionName))) {
-            versionName += ".1";
-        }
-
+        aquireReadLock();
+        String versionName;
+            // 1. search a predecessor, suitable for generating the new name
+            Value[] values = node.getProperty(QName.JCR_PREDECESSORS).getValues();
+            InternalVersion best = null;
+            for (int i = 0; i < values.length; i++) {
+                InternalVersion pred = history.getVersion(NodeId.valueOf(values[i].getString()));
+                if (best == null || pred.getSuccessors().length < best.getSuccessors().length) {
+                    best = pred;
+                }
+            }
+
+            // 2. generate version name (assume no namespaces in version names)
+            versionName = best.getName().getLocalName();
+            int pos = versionName.lastIndexOf('.');
+            if (pos > 0) {
+                versionName = versionName.substring(0, pos + 1)
+                    + (Integer.parseInt(versionName.substring(pos + 1)) + 1);
+            } else {
+                versionName = String.valueOf(best.getSuccessors().length + 1) + ".0";
+            }
+
+            // 3. check for colliding names
+            while (history.hasVersion(new QName("", versionName))) {
+                versionName += ".1";
+            }
+
+            releaseReadLock();
+            aquireWriteLock();
+            releaseReadLock();
+
+            releaseWriteLock();
+        aquireWriteLock();
+            releaseWriteLock();
+            releaseWriteLock();
+        aquireWriteLock();
+            releaseWriteLock();
+            releaseWriteLock();

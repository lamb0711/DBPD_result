work in progress

- SPI: replace String/Stream for values by QValue interface
- SPI: add factory for QValue
  > adjust commons and add implementation
  > adjust usages of former QValue object with jcr2spi, spi2dav
- RepositoryService.getChildInfos returns Iterator instead of Collection
- spi2dav: add implementation for new query interfaces

- TODO: 
  improve conversion of jcr-value to q-value and vice-versa




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@497885 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.value.QValue;
+import org.apache.jackrabbit.spi.QValue;
+import org.apache.jackrabbit.spi.QValueFactory;
-import java.io.IOException;
-    /**
-     * Hierarchy manager
-     */
-    //private final HierarchyManager hierMgr;
-    //private final NamespaceResolver nsResolver;
+    private final QValueFactory qValueFactory;
+
-                                   ItemStateValidator validator) {
+                                   ItemStateValidator validator,
+                                   QValueFactory qValueFactory) {
+        this.qValueFactory = qValueFactory;
-                QValue adjusted = refTracker.getMappedReference(val);
+                QValue adjusted = refTracker.getMappedReference(val, qValueFactory);
-                    setPropertyStateValue(pState, QValue.create(mixinNames), PropertyType.NAME, options);
+                    setPropertyStateValue(pState, getQValues(mixinNames, qValueFactory), PropertyType.NAME, options);
-                QValue[] mixinValue = QValue.create(mixinNames);
+                QValue[] mixinValue = getQValues(mixinNames, qValueFactory);
-        String[] qDefaultValues = def.getDefaultValues();
+        QValue[] qDefaultValues = def.getDefaultValues();
-            if (def.getRequiredType() == PropertyType.BINARY) {
-                try {
-                    genValues = QValue.create(def.getDefaultValuesAsStream(), def.getRequiredType());
-                } catch (IOException e) {
-                    log.error("Internal error while build QValue from property definition: ", e.getMessage());
-                    return null;
-                }
-            } else {
-               genValues = QValue.create(qDefaultValues, def.getRequiredType());
-            }
+            genValues = qDefaultValues;
-                genValues = new QValue[]{QValue.create(uniqueID)};
+                genValues = new QValue[]{qValueFactory.create(uniqueID, PropertyType.REFERENCE)};
-                    genValues = new QValue[]{QValue.create(parent.getNodeTypeName())};
+                    genValues = new QValue[]{qValueFactory.create(parent.getNodeTypeName())};
-                    genValues = new QValue[mixins.length];
-                    for (int i = 0; i < mixins.length; i++) {
-                        genValues[i] = QValue.create(mixins[i]);
-                    }
+                    genValues = getQValues(mixins, qValueFactory);
-                genValues = new QValue[]{QValue.create(Calendar.getInstance())};
+                genValues = new QValue[]{qValueFactory.create(Calendar.getInstance())};
-                genValues = new QValue[]{QValue.create(Calendar.getInstance())};
+                genValues = new QValue[]{qValueFactory.create(Calendar.getInstance())};
-                genValues = new QValue[]{QValue.create(Calendar.getInstance())};
+                genValues = new QValue[]{qValueFactory.create(Calendar.getInstance())};
+
+    /**
+     * @param qNames
+     * @param factory
+     * @return An array of QValue objects from the given <code>QName</code>s
+     */
+    private static QValue[] getQValues(QName[] qNames, QValueFactory factory) {
+        QValue[] ret = new QValue[qNames.length];
+        for (int i = 0; i < qNames.length; i++) {
+            ret[i] = factory.create(qNames[i]);
+        }
+        return ret;
+    }

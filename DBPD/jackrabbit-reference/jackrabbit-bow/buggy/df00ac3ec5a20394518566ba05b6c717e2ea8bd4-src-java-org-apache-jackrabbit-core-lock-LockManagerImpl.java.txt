- fixing latest locking issues
- fixing version items refresh

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@157083 13f79535-47bb-0310-9956-ffa450edef68

-            LockInfo info = new LockInfo(lockToken, false,
+            LockInfo info = new LockInfo(this, lockToken, false,
+            info.setLive(true);
+    /**
+     * Internal <code>lock</code> implementation that takes as parameter
+     * a lock info that will be used inside the path map.
+     * @param node node to lock
+     * @param info lock info
+     * @throws LockException if the node is already locked
+     * @throws RepositoryException if another error occurs
+     * @return lock
+     */
+    Lock lock(NodeImpl node, LockInfo info)
+            throws LockException,  RepositoryException {
+
+        // check whether node is already locked
+        Path path = node.getPrimaryPath();
+        PathMap.Child child = lockMap.map(path, false);
+
+        LockInfo other = (LockInfo) child.get();
+        if (other != null) {
+            if (child.hasPath(path)) {
+                throw new LockException("Node already locked: " + node.safeGetJCRPath());
+            } else if (other.deep) {
+                throw new LockException("Parent node has deep lock.");
+            }
+        }
+        if (info.deep && child.hasPath(path)) {
+            throw new LockException("Some child node is locked.");
+        }
+
+        // add properties to content
+        node.internalSetProperty(Constants.JCR_LOCKOWNER,
+                InternalValue.create(node.getSession().getUserId()));
+        node.internalSetProperty(Constants.JCR_LOCKISDEEP,
+                InternalValue.create(info.deep));
+        node.save();
+
+        // create lock token
+        SessionImpl session = (SessionImpl) node.getSession();
+        info.setLockHolder(session);
+        info.setLive(true);
+        if (info.sessionScoped) {
+            session.addListener(info);
+        }
+        session.addLockToken(info.lockToken.toString(), false);
+        lockMap.put(path, info);
+        return new LockImpl(info, node);
+    }
+
+    /**
+     * Unlock a node given by its info. Invoked when a session logs out and
+     * all session scoped locks of that session must be unlocked.
+     * @param info lock info
+     */
+    void unlock(LockInfo info) {
+        // if no session currently holds lock, take system session
+        SessionImpl session = info.getLockHolder();
+        if (session == null) {
+            session = this.session;
+        }
+
+        try {
+            // get node's path and remove child in path map
+            NodeImpl node = (NodeImpl) session.getItemManager().getItem(
+                    new NodeId(info.getUUID()));
+            Path path = node.getPrimaryPath();
+
+            PathMap.Child child = lockMap.map(path, true);
+            if (child != null) {
+                child.set(null);
+            }
+
+            // set live flag to false
+            info.setLive(false);
+
+            // remove properties in content
+            node.removeChildProperty(Constants.JCR_LOCKOWNER);
+            node.removeChildProperty(Constants.JCR_LOCKISDEEP);
+            node.save();
+            
+        } catch (RepositoryException e) {
+            log.warn("Unable to unlock session-scoped lock on node '" +
+                    info.lockToken + "': " + e.getMessage());
+            log.debug("Root cause: ", e);
+        }
+
+    }
+
-        Path path = node.getPrimaryPath();
-        PathMap.Child child = lockMap.map(path, false);
-
-        LockInfo info = (LockInfo) child.get();
-        if (info != null) {
-            if (child.hasPath(path)) {
-                throw new LockException("Node already locked: " + node.safeGetJCRPath());
-            } else if (info.deep) {
-                throw new LockException("Parent node has deep lock.");
-            }
-        }
-        if (isDeep && child.hasPath(path)) {
-            throw new LockException("Some child node is locked.");
-        }
-
-        SessionImpl session = (SessionImpl) node.getSession();
-        info = new LockInfo(new LockToken(node.internalGetUUID()),
-                isSessionScoped, isDeep, session.getUserId());
-        info.setLockHolder(session);
-        if (isSessionScoped) {
-            session.addListener(info);
-        }
-        session.addLockToken(info.lockToken.toString(), false);
-        lockMap.put(path, info);
-        return new LockImpl(info, node);
+        // create lock info to use and pass to internal implementation
+        LockInfo info = new LockInfo(this, new LockToken(node.internalGetUUID()),
+                isSessionScoped, isDeep, node.getSession().getUserId());
+        return lock(node, info);
+        // check whether node is locked by this session
-        child.set(null);
+        // remove lock in path map
+        child.set(null);
-        info.setLockHolder(null);
-        session.removeLockToken(info.lockToken.toString(), false);
+
+        // remove properties in content
+        node.removeChildProperty(Constants.JCR_LOCKOWNER);
+        node.removeChildProperty(Constants.JCR_LOCKISDEEP);
+        node.save();
-                        childAdded(event.getChildUUID(),
+                        nodeAdded(event.getChildUUID(),
-                        childRemoved(event.getChildUUID(),
+                        nodeRemoved(event.getChildUUID(),
-     * Invoked when some child has been added.
+     * Invoked when some node has been added. Relink the child inside our
+     * zombie map to the new parent. Revitalize all locks inside the
+     * zombie child hierarchy.
-    private synchronized void childAdded(String uuid, Path path) {
+    private synchronized void nodeAdded(String uuid, Path path) {
+                zombie.traverse(new PathMap.ChildVisitor() {
+                    public void childVisited(PathMap.Child child) {
+                        LockInfo info = (LockInfo) child.get();
+                        info.setLive(true);
+                    }
+                }, false);
-            log.warn("Added child does not have parent, ignoring event.");
+            log.warn("Added node does not have parent, ignoring event.");
-     * Invoked when some child has been removed.
+     * Invoked when some node has been removed. Unlink the child inside
+     * our path map corresponding to that node. Disable all locks contained
+     * in that subtree.
-    private synchronized void childRemoved(String uuid, Path path) {
+    private synchronized void nodeRemoved(String uuid, Path path) {
+                    child.traverse(new PathMap.ChildVisitor() {
+                        public void childVisited(PathMap.Child child) {
+                            LockInfo info = (LockInfo) child.get();
+                            info.setLive(false);
+                        }
+                    }, false);
-            log.warn("Added child does not have parent, ignoring event.");
+            log.warn("Removed node does not have parent, ignoring event.");

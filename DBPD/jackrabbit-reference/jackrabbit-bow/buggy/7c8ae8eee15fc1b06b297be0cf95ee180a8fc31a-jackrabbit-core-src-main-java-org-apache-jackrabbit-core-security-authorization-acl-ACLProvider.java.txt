JCR-1588: 283 Access Control

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@689499 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.api.JackrabbitSession;
-import org.apache.jackrabbit.api.jsr283.security.AccessControlEntry;
+import org.apache.jackrabbit.api.jsr283.security.AccessControlList;
+import org.apache.jackrabbit.api.jsr283.security.AccessControlManager;
+import org.apache.jackrabbit.core.ItemImpl;
+import org.apache.jackrabbit.core.SessionImpl;
-import org.apache.jackrabbit.core.security.authorization.PolicyEntry;
-import org.apache.jackrabbit.core.security.authorization.PolicyTemplate;
+import org.apache.jackrabbit.core.security.authorization.UnmodifiableAccessControlList;
+import org.apache.jackrabbit.core.security.authorization.AccessControlEntryIterator;
+import org.apache.jackrabbit.core.security.authorization.JackrabbitAccessControlEntry;
+import org.apache.commons.collections.map.ListOrderedMap;
-import javax.jcr.Node;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.HashSet;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Arrays;
-    private AccessControlEditor systemEditor;
+    /**
+     * the system acl editor.
+     */
+    private ACLEditor systemEditor;
-    //--------------------------------------< AbstractAccessControlProvider >---
+    /**
+     * Flag indicating whether or not this provider should be create the default
+     * ACLs upon initialization.
+     */
+    private boolean initializedWithDefaults;
+
+    //-------------------------------------------------< AccessControlUtils >---
-    protected boolean isAcItem(Path absPath) throws RepositoryException {
+    public boolean isAcItem(Path absPath) throws RepositoryException {
+    /**
+     * Test if the given node is itself a rep:ACL or a rep:ACE node.
+     * @see AbstractAccessControlProvider#isAcItem(ItemImpl)
+     */
+    public boolean isAcItem(ItemImpl item) throws RepositoryException {
+        NodeImpl n = ((item.isNode()) ? (NodeImpl) item : (NodeImpl) item.getParent());
+        return n.isNodeType(NT_REP_ACL) || n.isNodeType(NT_REP_ACE);
+    }
+
-    public void init(Session systemSession, Map options) throws RepositoryException {
-        super.init(systemSession, options);
+    public void init(Session systemSession, Map configuration) throws RepositoryException {
+        super.init(systemSession, configuration);
-        systemEditor = new ACLEditor(systemSession);
-
-        if (!isAccessControlled(root)) {
+        systemEditor = new ACLEditor(systemSession, this);
+        initializedWithDefaults = !configuration.containsKey(PARAM_OMIT_DEFAULT_PERMISSIONS);
+        if (initializedWithDefaults && !isAccessControlled(root)) {
-     * @see AccessControlProvider#getPolicy(Path)
+     * @see AccessControlProvider#getEffectivePolicies(Path)
-    public AccessControlPolicy getPolicy(Path absPath) throws ItemNotFoundException, RepositoryException {
+    public AccessControlPolicy[] getEffectivePolicies(Path absPath) throws ItemNotFoundException, RepositoryException {
-        return getACL(absPath);
-    }
-    /**
-     * @see AccessControlProvider#getAccessControlEntries(Path)
-     * @param absPath
-     */
-    public AccessControlEntry[] getAccessControlEntries(Path absPath) throws RepositoryException {
-        checkInitialized();
-        ACLImpl acl = getACL(absPath);
+        NodeImpl targetNode = (NodeImpl) session.getNode(session.getJCRPath(absPath));
+        NodeImpl node = getNode(targetNode);
+        List acls = new ArrayList();
-        // TODO: check again what the expected return value would be.
-        // TODO: check again if correct. call probably expensive.
-        Map allowed = new HashMap();
-        Map denied = new HashMap();
-        for (Iterator it = acl.getEntries(); it.hasNext();) {
-            ACEImpl ace = (ACEImpl) it.next();
-            Principal pc = ace.getPrincipal();
-
-            int pv = ace.getPrivilegeBits();
-
-            int allowPv = (allowed.containsKey(pc)) ? ((Integer) allowed.get(pc)).intValue() : 0;
-            int denyPv = (denied.containsKey(pc)) ? ((Integer) denied.get(pc)).intValue() : 0;
-
-            // shortcut:
-            if (allowPv == PrivilegeRegistry.ALL) {
-                continue;
-            }
-
-            // if the ace is a granting ACE -> make sure the permissions
-            // it grants are not denied by another ACE
-            if (ace.isAllow()) {
-                // determined those allow-priv from the current ace, that have
-                // not been denied by an ace ealier in the evaluation.
-                allowPv |= PrivilegeRegistry.diff(pv, denyPv);
-                allowed.put(pc, new Integer(allowPv));
-            } else {
-                // determined those deny-priv from the current ace, that have
-                // not been granted by an ace ealier in the evaluation.
-                denyPv |= PrivilegeRegistry.diff(pv, allowPv);
-                denied.put(pc, new Integer(denyPv));
-            }
+        // collect all ACLs effective at node
+        collectAcls(node, acls);
+        // if no effective ACLs are present -> add a default, empty acl.
+        if (acls.isEmpty()) {
+            // no access control information can be retrieved for the specified
+            // node, since neither the node nor any of its parents is access
+            // controlled -> build a default policy.
+            log.warn("No access controlled node present in item hierarchy starting from " + targetNode.getPath());
+            acls.add(new UnmodifiableAccessControlList(Collections.EMPTY_LIST));
-
-        Set s = new HashSet();
-        for (Iterator it = allowed.keySet().iterator(); it.hasNext();) {
-            Principal p = (Principal) it.next();
-            s.add(new ACEImpl(p, ((Integer) allowed.get(p)).intValue(), true));
-        }
-        return (AccessControlEntry[]) s.toArray(new AccessControlEntry[s.size()]);
+        return (AccessControlList[]) acls.toArray(new AccessControlList[acls.size()]);
-        try {
-            return new ACLEditor(session);
-        } catch (RepositoryException e) {
-            log.debug("Unable to create AccessControlEditor.", e.getMessage());
-            return null;
-        }
+        return new ACLEditor(session, this);
-            return new AclPermissions(principals, false).grants(PathFactoryImpl.getInstance().getRootPath(), Permission.READ);
+            CompiledPermissions cp = new AclPermissions(principals, false);
+            return cp.grants(PathFactoryImpl.getInstance().getRootPath(), Permission.READ);
-    /**
-     * Build the ACL that is effective on the Node at
-     * <code>absPath</code>. In contrast to {@link #getACL(NodeImpl, Set)}
-     * the returned ACL contains all entries that apply to that node.
-     *
-     * @param absPath
-     * @return
-     * @throws ItemNotFoundException
-     * @throws RepositoryException
-     */
-    private ACLImpl getACL(Path absPath) throws ItemNotFoundException, RepositoryException {
-        return getACL((NodeImpl) session.getNode(session.getJCRPath(absPath)),
-                Collections.EMPTY_SET);
-    }
-     * Build the ACL that is effective on the Node at
-     * <code>absPath</code>, but only retrieve those entries that apply to
-     * any of the principals whose name is present in the given
-     * <code>principalNameFilter</code>.
+     * Returns the given <code>targetNode</code> unless the node itself stores
+     * access control information in which case it's nearest non-ac-parent is
+     * searched and returned.
-     * @param node
-     * @param principalNameFilter
+     * @param targetNode The node for which AC information needs to be retrieved.
-     * @throws ItemNotFoundException
-    private ACLImpl getACL(NodeImpl node, Set principalNameFilter) throws ItemNotFoundException, RepositoryException {
-        // -> build the acl for the Node
-        ACLImpl acl;
-        // check for special ACL building item
-        if (protectsNode(node)) {
-            NodeImpl parentNode;
-            if (node.isNodeType(NT_REP_ACL)) {
-                parentNode = (NodeImpl) node.getParent();
+    private NodeImpl getNode(NodeImpl targetNode) throws RepositoryException {
+        NodeImpl node;
+        if (isAcItem(targetNode)) {
+            if (targetNode.isNodeType(NT_REP_ACL)) {
+                node = (NodeImpl) targetNode.getParent();
-                parentNode = (NodeImpl) node.getParent().getParent();
+                node = (NodeImpl) targetNode.getParent().getParent();
-            ACLImpl baseACL = buildAcl(parentNode, principalNameFilter);
-            acl = new ACLImpl(node.getNodeId(), baseACL, true);
-            // build Acl for non-protection node.
-            acl = buildAcl(node, principalNameFilter);
+            node = targetNode;
-        return acl;
+        return node;
-     * Constructs the ACLImpl for a regular node, i.e. a node that does not
-     * store itself ACL-related information. The ACL to be returned combines both
-     * the base-ACL containing the inherited access control information
-     * and the access control information provided with the given node itself.
+     * Recursively collects all ACLs that are effective on the specified node.
-     * @param node the Node to build the ACL for, which must NOT be part of the
+     * @param node the Node to collect the ACLs for, which must NOT be part of the
-     * @param principalNameFilter
-     * @return acl or <code>DefaultACL</code> if neither the node nor any of it's
-     * parents is access controlled.
+     * @param acls List used to collect the effective acls.
-    private ACLImpl buildAcl(NodeImpl node, Set principalNameFilter) throws RepositoryException {
-        // preconditions:
-        // - node is not null
-        // - node is never an ACL building item
-        NodeId id = (NodeId) node.getId();
-        // retrieve the base-ACL (i.e. the ACL that belongs to parentNode)
-        // for this find nearest access controlled parent.
-        ACLImpl baseACL = null;
-        NodeImpl parentNode = id.equals(rootNodeId) ? null : (NodeImpl) node.getParent();
-        while (parentNode != null && baseACL == null) {
-            if (isAccessControlled(parentNode)) {
-                baseACL = buildAcl(parentNode, principalNameFilter);
-            } else {
-                parentNode = (rootNodeId.equals(parentNode.getId())) ? null
-                        : (NodeImpl) parentNode.getParent();
-            }
-        }
-        // the build the effective ACL from the specified Node and the base ACL
-        ACLImpl acl;
+    private void collectAcls(NodeImpl node, List acls) throws RepositoryException {
+        // if the given node is access-controlled, construct a new ACL and add
+        // it to the list
-            // build acl from access controlled node
+            // build acl for the access controlled node
-            PolicyTemplate tmpl = new ACLTemplate(aclNode, principalNameFilter);
-            List localEntries = Arrays.asList(tmpl.getEntries());
-
-            acl = new ACLImpl(aclNode.getNodeId(), localEntries, baseACL, false);
-        } else if (baseACL != null) {
-            // build acl for a non-access controlled item that has a base acl
-            acl = new ACLImpl(id, baseACL, false);
-        } else {
-            // no access control information can be retrieved for the specified
-            // node, since neither the node nor any of its parents is access
-            // controlled -> build a default policy.
-            log.warn("No access controlled node present in item hierarchy starting from " + id);
-            acl = new DefaultACL(id);
+            AccessControlList acl = systemEditor.getACL(aclNode);
+            acls.add(new UnmodifiableAccessControlList(acl));
-        return acl;
+        // then, recursively look for access controlled parents up the hierarchy.
+        if (!rootNodeId.equals(node.getId())) {
+            NodeImpl parentNode = (NodeImpl) node.getParent();
+            collectAcls(parentNode, acls);
+        }
-    private static void initRootACL(JackrabbitSession session, AccessControlEditor editor) throws RepositoryException {
+    private static void initRootACL(SessionImpl session, AccessControlEditor editor) throws RepositoryException {
-            PolicyTemplate tmpl = editor.editPolicyTemplate(rootPath);
+            AccessControlPolicy[] acls = editor.editAccessControlPolicies(rootPath);
+            ACLTemplate acl = (ACLTemplate) acls[0];
+
+            AccessControlManager acMgr = session.getAccessControlManager();
-            PolicyEntry entr = new ACEImpl(administrators, PrivilegeRegistry.ALL, true);
-            tmpl.setEntry(entr);
+            Privilege[] privs = new Privilege[]{acMgr.privilegeFromName(Privilege.JCR_ALL)};
+            acl.addAccessControlEntry(administrators, privs);
-            // TODO: to be improved. how to define where everyone has read-access
-            entr = new ACEImpl(everyone, PrivilegeRegistry.READ, true);
-            tmpl.setEntry(entr);
+            privs = new Privilege[]{acMgr.privilegeFromName(Privilege.JCR_READ)};
+            acl.addAccessControlEntry(everyone, privs);
-            editor.setPolicyTemplate(rootPath, tmpl);
+            editor.setPolicy(rootPath, acl);
-    /**
-     * Test if the given node is itself a rep:ACL or a rep:ACE node.
-     *
-     * @param node
-     * @return
-     * @throws RepositoryException
-     */
-    static boolean protectsNode(NodeImpl node) throws RepositoryException {
-        return node.isNodeType(NT_REP_ACL) || node.isNodeType(NT_REP_ACE);
-    }
-
-        private final Set principalNames;
+        private final List principalNames;
+        private final String jcrReadPrivilegeName;
-        /**
-         * flag indicating if only READ is granted
-         * -> simplify {@link #grants(Path, int)} in case of permissions != READ
-         */
-        private boolean readOnly = false;
+
-            principalNames = new HashSet(principals.size());
+            principalNames = new ArrayList(principals.size());
+            jcrReadPrivilegeName = session.getAccessControlManager().privilegeFromName(Privilege.JCR_READ).getName();
-                searchReadDeny(principalNames);
-                /*
-                Determine if there is any ACE node that grants another permission
-                than READ.
-                */
-                searchNonReadAllow(principalNames);
+                readAllowed = isReadAllowed(principalNames);
-         * Search if there is any ACE that defines permissions for any of the
-         * principals AND denies-READ.
+         * If this provider defines read-permission for everyone (defined upon
+         * init with default values), search if there is any ACE that defines
+         * permissions for any of the principals AND denies-READ. Otherwise
+         * this shortcut is not possible.
-        private void searchReadDeny(Set principalnames) {
-            try {
-                QueryManager qm = session.getWorkspace().getQueryManager();
-                StringBuffer stmt = new StringBuffer("/jcr:root");
-                stmt.append("//element(*,");
-                stmt.append(resolver.getJCRName(NT_REP_DENY_ACE));
-                stmt.append(")[(");
+        private boolean isReadAllowed(Collection principalnames) {
+            boolean isReadAllowed = false;
+            if (initializedWithDefaults) {
+                try {
+                    QueryManager qm = session.getWorkspace().getQueryManager();
+                    StringBuffer stmt = new StringBuffer("/jcr:root");
+                    stmt.append("//element(*,");
+                    stmt.append(resolver.getJCRName(NT_REP_DENY_ACE));
+                    stmt.append(")[(");
-                // where the rep:principalName property exactly matches any of
-                // the given principalsNames
-                int i = 0;
-                Iterator itr = principalnames.iterator();
-                while (itr.hasNext()) {
-                    stmt.append("@").append(resolver.getJCRName(P_PRINCIPAL_NAME)).append(" eq ");
-                    stmt.append("'").append(itr.next().toString()).append("'");
-                    if (++i < principalnames.size()) {
-                        stmt.append(" or ");
+                    // where the rep:principalName property exactly matches any of
+                    // the given principalsNames
+                    int i = 0;
+                    Iterator itr = principalnames.iterator();
+                    while (itr.hasNext()) {
+                        stmt.append("@").append(resolver.getJCRName(P_PRINCIPAL_NAME)).append(" eq ");
+                        stmt.append("'").append(itr.next().toString()).append("'");
+                        if (++i < principalnames.size()) {
+                            stmt.append(" or ");
+                        }
+                    // AND rep:privileges contains the READ privilege
+                    stmt.append(") and @");
+                    stmt.append(resolver.getJCRName(P_PRIVILEGES));
+                    stmt.append(" = '").append(jcrReadPrivilegeName).append("']");
+
+                    Query q = qm.createQuery(stmt.toString(), Query.XPATH);
+
+                    NodeIterator it = q.execute().getNodes();
+                    isReadAllowed =  !it.hasNext();
+                } catch (RepositoryException e) {
+                    log.error(e.toString());
+                    // unable to determine... -> no shortcut upon grants
-                // AND rep:privileges contains the READ privilege
-                stmt.append(") and @ ");
-                stmt.append(resolver.getJCRName(P_PRIVILEGES));
-                stmt.append(" = '").append(Privilege.READ).append("']");
-
-                Query q = qm.createQuery(stmt.toString(), Query.XPATH);
-
-                NodeIterator it = q.execute().getNodes();
-                readAllowed =  !it.hasNext();
-            } catch (RepositoryException e) {
-                log.error(e.toString());
-                // unable to determine... -> no shortcut upon grants
-                readAllowed = false;
-        }
-
-        private void searchNonReadAllow(Set principalnames) {
-            try {
-                QueryManager qm = session.getWorkspace().getQueryManager();
-                StringBuffer stmt = new StringBuffer("/jcr:root");
-                stmt.append("//element(*,");
-                stmt.append(resolver.getJCRName(NT_REP_GRANT_ACE));
-                stmt.append(")[(");
-                // where the rep:principalName property exactly matches any of
-                // the given principalsNames
-                int i = 0;
-                Iterator itr = principalnames.iterator();
-                while (itr.hasNext()) {
-                    stmt.append("@").append(resolver.getJCRName(P_PRINCIPAL_NAME)).append(" eq ");
-                    stmt.append("'").append(itr.next().toString()).append("'");
-                    if (++i < principalnames.size()) {
-                        stmt.append(" or ");
-                    }
-                }
-
-                // AND rep:privileges contains the READ privilege
-                stmt.append(") and @");
-                stmt.append(resolver.getJCRName(P_PRIVILEGES));
-                stmt.append(" ne \"").append(Privilege.READ).append("\"]");
-
-                Query q = qm.createQuery(stmt.toString(), Query.XPATH);
-
-                NodeIterator it = q.execute().getNodes();
-                readOnly =  !it.hasNext();
-            } catch (RepositoryException e) {
-                log.error(e.toString());
-                // unable to determine... -> no shortcut upon grants
-                readOnly = false;
-            }
+            return isReadAllowed;
-            Node node = null;
+            NodeImpl node = null;
-                node = session.getNode(jcrPath);
+                node = (NodeImpl) session.getNode(jcrPath);
-                        node = session.getNode(parentPath);
+                        node = (NodeImpl) session.getNode(parentPath);
-            // build the ACL for the specified principals at path or at the
-            // direct ancestor of path (that must be definition exist).
-            ACLImpl acl = getACL((NodeImpl) node, principalNames);
+            boolean isAcItem = isAcItem(absPath);
-            // privileges to expose
-            int privileges = acl.getPrivileges();
-
-            // calculate the permissions
-            int permissions;
-            if (existingNode || session.propertyExists(jcrPath)) {
-                permissions = acl.getPermissions(session.getItem(jcrPath));
+            // retrieve all ACEs at path or at the direct ancestor of path that
+            // apply for the principal names.
+            AccessControlEntryIterator entries = new Entries(getNode(node), principalNames).iterator();
+            // build a list of ACEs that are defined locally at the node
+            List localACEs;
+            if (existingNode && isAccessControlled(node)) {
+                NodeImpl aclNode = node.getNode(N_POLICY);
+                localACEs = Arrays.asList(systemEditor.getACL(aclNode).getAccessControlEntries());
-                String name = resolver.getJCRName(absPath.getNameElement().getName());
-                permissions = acl.getPermissions(name);
+                localACEs = Collections.EMPTY_LIST;
-            return new Result(permissions, privileges);
+            /*
+             Calculate privileges and permissions:
+             Since the ACEs only define privileges on a node and do not allow
+             to add additional restrictions, the permissions can be determined
+             without taking the given target name or target item into account.
+             */
+            int allows = Permission.NONE;
+            int denies = Permission.NONE;
+
+            int allowPrivileges = PrivilegeRegistry.NO_PRIVILEGE;
+            int denyPrivileges = PrivilegeRegistry.NO_PRIVILEGE;
+            int parentAllows = PrivilegeRegistry.NO_PRIVILEGE;
+            int parentDenies = PrivilegeRegistry.NO_PRIVILEGE;
+
+            while (entries.hasNext() && allows != PrivilegeRegistry.ALL) {
+                JackrabbitAccessControlEntry ace = (JackrabbitAccessControlEntry) entries.next();
+                // Determine if the ACE is defined on the node at absPath (locally):
+                // Except for READ-privileges the permissions must be determined
+                // from privileges defined for the parent. Consequently aces
+                // defined locally must be treated different than inherited entries.
+                int entryBits = ace.getPrivilegeBits();
+                boolean isLocal = localACEs.contains(ace);
+                if (!isLocal) {
+                    if (ace.isAllow()) {
+                        parentAllows |= Permission.diff(entryBits, parentDenies);
+                    } else {
+                        parentDenies |= Permission.diff(entryBits, parentAllows);
+                    }
+                }
+                if (ace.isAllow()) {
+                    allowPrivileges |= Permission.diff(entryBits, denyPrivileges);
+                    int permissions = Permission.calculatePermissions(allowPrivileges, parentAllows, true, isAcItem);
+                    allows |= Permission.diff(permissions, denies);
+                } else {
+                    denyPrivileges |= Permission.diff(entryBits, allowPrivileges);
+                    int permissions = Permission.calculatePermissions(denyPrivileges, parentDenies, false, isAcItem);
+                    denies |= Permission.diff(permissions, allows);
+                }
+            }
+            return new Result(allows, denies, allowPrivileges, denyPrivileges);
-            } else if (permissions != Permission.READ && readOnly) {
-                return false;
-        public void onEvent(EventIterator events) {
+        public synchronized void onEvent(EventIterator events) {
-                    // TODO: check if valid. check required.
-
-                            // test if the new ACE-nodes affects the permission
-                            // of any of the 'principals'.
+                            // test if the new node is an ACE node that affects
+                            // the permission of any of the principals listed in
+                            // principalNames.
-                            String pName = n.getProperty(P_PRINCIPAL_NAME).getString();
-                            if (principalNames.contains(pName)) {
-                                // new ACE entry for the principals -> clear cache
-                                clearCache = true;
-                                // if ace is a new DENY -> check if denies reading
+                            if (n.isNodeType(NT_REP_ACE) &&
+                                    principalNames.contains(n.getProperty(P_PRINCIPAL_NAME).getString())) {
+                                // and reset the readAllowed flag, if the new
+                                // ACE denies READ.
-                                        if (Privilege.READ.equals(vs[i].getString())) {
+                                        if (jcrReadPrivilegeName.equals(vs[i].getString())) {
-                                // if ace is a new ALLOW -> check if obsoletes read-only
-                                if (readOnly && n.isNodeType(NT_REP_GRANT_ACE)) {
-                                    Value[] vs = n.getProperty(P_PRIVILEGES).getValues();
-                                    for (int i = 0; i < vs.length; i++) {
-                                        if (!Privilege.READ.equals(vs[i].getString())) {
-                                            readOnly = false;
-                                        }
-                                    }
-                                }
+                                clearCache = true;
+                        case Event.PROPERTY_REMOVED:
+                            readAllowed = isReadAllowed(principalNames);
+                        case Event.PROPERTY_ADDED:
-                            // test if the changed ACE_prop affects the permission
-                            // of any of the 'principals' (most interesting are
-                            // changed privileges.
+                            // test if the added/changed prop belongs to an ACe
+                            // node and affects the permission of any of the
+                            // principals listed in principalNames.
-                            if (P_PRIVILEGES.equals(p.getQName())) {
-                                // test if principal-name sibling-prop matches
-                                pName = ((NodeImpl) p.getParent()).getProperty(P_PRINCIPAL_NAME).toString();
-                                clearCache = principalNames.contains(pName);
-                            } else if (P_PRINCIPAL_NAME.equals(p.getQName())) {
-                                // an ace change its principal-name. that should
-                                // not happen. -> clear cache to be on the safe side.
-                                clearCache = true;
+                            NodeImpl parent = (NodeImpl) p.getParent();
+                            if (parent.isNodeType(NT_REP_ACE)) {
+                                String principalName = null;
+                                if (P_PRIVILEGES.equals(p.getQName())) {
+                                    // test if principal-name sibling-prop matches
+                                    principalName = parent.getProperty(P_PRINCIPAL_NAME).getString();
+                                } else if (P_PRINCIPAL_NAME.equals(p.getQName())) {
+                                    // a new ace or an ace change its principal-name.
+                                    principalName = p.getString();
+                                }
+                                if (principalName != null &&
+                                        principalNames.contains(principalName)) {
+                                    readAllowed = isReadAllowed(principalNames);
+                                    clearCache = true;
+                                }
+
+    private class Entries {
+
+        private final ListOrderedMap principalNamesToEntries;
+
+        private Entries(NodeImpl node, Collection principalNames) throws RepositoryException {
+            principalNamesToEntries = new ListOrderedMap();
+            for (Iterator it = principalNames.iterator(); it.hasNext();) {
+                principalNamesToEntries.put(it.next(), new ArrayList());
+            }
+            collectEntries(node);
+        }
+
+        private void collectEntries(NodeImpl node) throws RepositoryException {
+            // if the given node is access-controlled, construct a new ACL and add
+            // it to the list
+            if (isAccessControlled(node)) {
+                // build acl for the access controlled node
+                NodeImpl aclNode = node.getNode(N_POLICY);
+                ACLTemplate.collectEntries(aclNode, principalNamesToEntries);
+            }
+            // then, recursively look for access controlled parents up the hierarchy.
+            if (!rootNodeId.equals(node.getId())) {
+                NodeImpl parentNode = (NodeImpl) node.getParent();
+                collectEntries(parentNode);
+            }
+        }
+
+        private AccessControlEntryIterator iterator() {
+            List entries = new ArrayList();
+            for (Iterator it =
+                    principalNamesToEntries.asList().iterator(); it.hasNext();) {
+                Object key = it.next();
+                entries.addAll((List) principalNamesToEntries.get(key));
+            }
+            return new AccessControlEntryIterator(entries);
+        }
+    }
+

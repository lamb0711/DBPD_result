JCR-2170: Remove PropDefId and NodeDefId
- merged changes from sandbox branch

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@816343 13f79535-47bb-0310-9956-ffa450edef68

-import javax.jcr.nodetype.NodeDefinition;
-import javax.jcr.nodetype.PropertyDefinition;
-import org.apache.jackrabbit.core.nodetype.NodeDefId;
-import org.apache.jackrabbit.core.nodetype.NodeDefinitionImpl;
-import org.apache.jackrabbit.core.nodetype.PropDefId;
-import org.apache.jackrabbit.core.nodetype.PropertyDefinitionImpl;
+import org.apache.jackrabbit.core.nodetype.NodeTypeRegistry;
+import org.apache.jackrabbit.core.nodetype.EffectiveNodeType;
+import org.apache.jackrabbit.core.nodetype.NodeTypeConflictException;
-import org.apache.jackrabbit.core.state.ItemStateManager;
+import org.apache.jackrabbit.spi.QPropertyDefinition;
+import org.apache.jackrabbit.spi.QNodeDefinition;
-    private final NodeDefinition rootNodeDef;
+    private final org.apache.jackrabbit.spi.commons.nodetype.NodeDefinitionImpl rootNodeDef;
-    private final ItemStateManager itemStateProvider;
+    private final SessionItemStateManager sism;
-     * @param itemStateProvider the item state provider associated with
-     *                          the new instance
-     * @param hierMgr           the hierarchy manager
-     * @param session           the session associated with the new instance
-     * @param rootNodeDef       the definition of the root node
-     * @param rootNodeId        the id of the root node
+     * @param sism        the item state manager associated with the new
+     *                    instance
+     * @param hierMgr     the hierarchy manager
+     * @param session     the session associated with the new instance
+     * @param rootNodeDef the definition of the root node
+     * @param rootNodeId  the id of the root node
-    protected ItemManager(SessionItemStateManager itemStateProvider, HierarchyManager hierMgr,
-                          SessionImpl session, NodeDefinition rootNodeDef,
+    protected ItemManager(SessionItemStateManager sism,
+                          HierarchyManager hierMgr,
+                          SessionImpl session,
+                          org.apache.jackrabbit.spi.commons.nodetype.NodeDefinitionImpl rootNodeDef,
-        this.itemStateProvider = itemStateProvider;
+        this.sism = sism;
-            NodeDefinition rootNodeDef,
+            org.apache.jackrabbit.spi.commons.nodetype.NodeDefinitionImpl rootNodeDef,
-    NodeDefinition getDefinition(NodeState state)
+    org.apache.jackrabbit.spi.commons.nodetype.NodeDefinitionImpl getDefinition(NodeState state)
-        NodeDefId defId = state.getDefinitionId();
-        NodeDefinitionImpl def = session.getNodeTypeManager().getNodeDefinition(defId);
-        if (def == null) {
-            /**
-             * todo need proper way of handling inconsistent/corrupt definition
-             * e.g. 'flag' items that refer to non-existent definitions
-             */
-            log.warn("node at " + safeGetJCRPath(state.getNodeId())
-                    + " has invalid definitionId (" + defId + ")");
-
-            // fallback: try finding applicable definition
-            NodeImpl parent = (NodeImpl) getItem(state.getParentId());
-            NodeState parentState = parent.getNodeState();
-            ChildNodeEntry cne = parentState.getChildNodeEntry(state.getNodeId());
-            def = parent.getApplicableChildNodeDefinition(cne.getName(), state.getNodeTypeName());
-            state.setDefinitionId(def.unwrap().getId());
+        NodeId parentId = state.getParentId();
+        if (parentId == null) {
+            // removed state has parentId set to null
+            // get from overlayed state
+            parentId = state.getOverlayedState().getParentId();
-        return def;
+        NodeState parentState;
+        try {
+            NodeImpl parent = (NodeImpl) getItem(parentId);
+            parentState = parent.getNodeState();
+            if (state.getParentId() == null) {
+                // indicates state has been removed, must use
+                // overlayed state of parent, otherwise child node entry
+                // cannot be found
+                parentState = (NodeState) parentState.getOverlayedState();
+            }
+        } catch (ItemNotFoundException e) {
+            // parent probably removed, get it from attic
+            try {
+                // use overlayed state if available
+                parentState = (NodeState) sism.getAttic().getItemState(
+                        parentId).getOverlayedState();
+            } catch (ItemStateException ex) {
+                throw new RepositoryException(ex);
+            }
+        }
+        // get child node entry
+        ChildNodeEntry cne = parentState.getChildNodeEntry(state.getNodeId());
+        NodeTypeRegistry ntReg = session.getNodeTypeManager().getNodeTypeRegistry();
+        try {
+            EffectiveNodeType ent = ntReg.getEffectiveNodeType(
+                    parentState.getNodeTypeName(), parentState.getMixinTypeNames());
+            QNodeDefinition def = ent.getApplicableChildNodeDef(
+                    cne.getName(), state.getNodeTypeName(), ntReg);
+            return session.getNodeTypeManager().getNodeDefinition(def);
+        } catch (NodeTypeConflictException e) {
+            throw new RepositoryException(e);
+        }
-    PropertyDefinition getDefinition(PropertyState state)
+    org.apache.jackrabbit.spi.commons.nodetype.PropertyDefinitionImpl getDefinition(PropertyState state)
-        PropDefId defId = state.getDefinitionId();
-        PropertyDefinitionImpl def = session.getNodeTypeManager().getPropertyDefinition(defId);
-        if (def == null) {
-            /**
-             * todo need proper way of handling inconsistent/corrupt definition
-             * e.g. 'flag' items that refer to non-existent definitions
-             */
-            log.warn("property at " + safeGetJCRPath(state.getPropertyId())
-                    + " has invalid definitionId (" + defId + ")");
-
-            // fallback: try finding applicable definition
+        try {
-            def = parent.getApplicablePropertyDefinition(
+            return parent.getApplicablePropertyDefinition(
-            state.setDefinitionId(def.unwrap().getId());
+        } catch (ItemNotFoundException e) {
+            // parent probably removed, get it from attic
-        return def;
+        try {
+            NodeState parent = (NodeState) sism.getAttic().getItemState(
+                    state.getParentId()).getOverlayedState();
+            NodeTypeRegistry ntReg = session.getNodeTypeManager().getNodeTypeRegistry();
+            EffectiveNodeType ent = ntReg.getEffectiveNodeType(
+                    parent.getNodeTypeName(), parent.getMixinTypeNames());
+            QPropertyDefinition def = ent.getApplicablePropertyDef(
+                    state.getName(), state.getType(), state.isMultiValued());
+            return session.getNodeTypeManager().getPropertyDefinition(def);
+        } catch (ItemStateException e) {
+            throw new RepositoryException(e);
+        } catch (NodeTypeConflictException e) {
+            throw new RepositoryException(e);
+        }
-            if (!itemStateProvider.hasItemState(itemId)) {
+            if (!sism.hasItemState(itemId)) {
-                state = itemStateProvider.getItemState(itemId);
+                state = sism.getItemState(itemId);

- Remove immediate event request after operation executed. Executing operations is not tied to observation anymore, even when CacheBehaviour = Observation.
- Event polling in spi2dav now implements timeout (blocking until event or timeout occurs)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@509151 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.EventIterator;
+import org.apache.jackrabbit.spi.Event;
-import EDU.oswego.cs.dl.util.concurrent.Channel;
-import EDU.oswego.cs.dl.util.concurrent.Latch;
-import EDU.oswego.cs.dl.util.concurrent.LinkedQueue;
+import EDU.oswego.cs.dl.util.concurrent.Mutex;
-     * Monitor object to synchronize the feed thread with client
+     * Mutex to synchronize the feed thread with client
-    private final Object updateMonitor = new Object();
-
-    /**
-     * A producer for this channel can request an immediate poll for events
-     * by placing a Sync into the channel. The Sync is released when the event
-     * poll finished.
-     */
-    private final Channel immediateEventRequests = new LinkedQueue();
+    private final Sync updateSync = new Mutex();
-                            CacheBehaviour cacheBehaviour, int pollingInterval)
+                            CacheBehaviour cacheBehaviour, int pollTimeout)
-        changeFeed = createChangeFeed(pollingInterval);
+        changeFeed = createChangeFeed(pollTimeout);
-     * @param pollingInterval the polling interval in milliseconds.
+     * @param pollTimeout the polling timeout in milliseconds.
-    private Thread createChangeFeed(int pollingInterval) {
+    private Thread createChangeFeed(int pollTimeout) {
-                t = new Thread(new ChangePolling(pollingInterval));
+                t = new Thread(new ChangePolling(pollTimeout));
-        if (cacheBehaviour == CacheBehaviour.OBSERVATION) {
-            Sync eventSignal;
-            synchronized (updateMonitor) {
-                new OperationVisitorImpl(sessionInfo).execute(operation);
-                eventSignal = getEventPollingRequest();
-            }
-            try {
-                eventSignal.acquire();
-            } catch (InterruptedException e) {
-                Thread.interrupted();
-                log.warn("Interrupted while waiting for events from RepositoryService");
-            }
-        } else {
+        // block event delivery while changes are executed
+        try {
+            updateSync.acquire();
+        } catch (InterruptedException e) {
+            throw new RepositoryException(e);
+        }
+        try {
-            operation.persisted(cacheBehaviour);
+            // TODO: remove parameter CacheBehaviour
+            operation.persisted(CacheBehaviour.INVALIDATE);
+        } finally {
+            updateSync.release();
-        if (cacheBehaviour == CacheBehaviour.OBSERVATION) {
-            // TODO: TOBEFIXED. processing events after changelog may lead to consistency problems (duplicate processing) (e.g. removal of SNSs).
-            // TODO: filtering of events required according to information present in the changelog.
-            Sync eventSignal;
-            synchronized (updateMonitor) {
-                new OperationVisitorImpl(sessionInfo).execute(changes);
-                changes.persisted(cacheBehaviour);
-                eventSignal = getEventPollingRequest();
-            }
-            try {
-                // wait at most 10 seconds
-                if (!eventSignal.attempt(10 * 1000)) {
-                    log.warn("No events received for batch");
-                }
-            } catch (InterruptedException e) {
-                Thread.interrupted();
-                log.warn("Interrupted while waiting for events from RepositoryService");
-            }
-        } else {
+        // block event delivery while changes are executed
+        try {
+            updateSync.acquire();
+        } catch (InterruptedException e) {
+            throw new RepositoryException(e);
+        }
+        try {
-            changes.persisted(cacheBehaviour);
+            // TODO: remove parameter CacheBehaviour
+            changes.persisted(CacheBehaviour.INVALIDATE);
+        } finally {
+            updateSync.release();
-            try {
-                changeFeed.join();
-            } catch (InterruptedException e) {
-                log.warn("Interrupted while waiting for external change thread to terminate.");
-            }
-        // notify listener
-        InternalEventListener[] lstnrs = (InternalEventListener[]) listeners.toArray(new InternalEventListener[listeners.size()]);
-        for (int i = 0; i < eventBundles.length; i++) {
-            for (int j = 0; j < lstnrs.length; j++) {
-                lstnrs[j].onEvent(eventBundles[i]);
+        if (log.isDebugEnabled()) {
+            log.debug("received {} event bundles.", new Integer(eventBundles.length));
+            for (int i = 0; i < eventBundles.length; i++) {
+                log.debug("BundleId: {}", eventBundles[i].getBundleId());
+                log.debug("IsLocal:  {}", new Boolean(eventBundles[i].isLocal()));
+                for (EventIterator it = eventBundles[i].getEvents(); it.hasNext(); ) {
+                    Event e = it.nextEvent();
+                    String type;
+                    switch (e.getType()) {
+                        case Event.NODE_ADDED:
+                            type = "NodeAdded";
+                            break;
+                        case Event.NODE_REMOVED:
+                            type = "NodeRemoved";
+                            break;
+                        case Event.PROPERTY_ADDED:
+                            type = "PropertyAdded";
+                            break;
+                        case Event.PROPERTY_CHANGED:
+                            type = "PropertyChanged";
+                            break;
+                        case Event.PROPERTY_REMOVED:
+                            type = "PropertyRemoved";
+                            break;
+                        default:
+                            type = "Unknown";
+                    }
+                    log.debug("  {}; {}", e.getQPath(), type);
+                }
+        // do not deliver events while an operation executes
+        try {
+            updateSync.acquire();
+        } catch (InterruptedException e) {
+            log.warn("Unable to acquire update mutext");
+            return;
+        }
+        try {
+            // notify listener
+            InternalEventListener[] lstnrs = (InternalEventListener[]) listeners.toArray(new InternalEventListener[listeners.size()]);
+            for (int i = 0; i < eventBundles.length; i++) {
+                for (int j = 0; j < lstnrs.length; j++) {
+                    lstnrs[j].onEvent(eventBundles[i]);
+                }
+            }
+        } finally {
+            updateSync.release();
+        }
-     * Requests an immediate poll for events. The returned Sync will be
-     * released by the event polling thread when events have been retrieved.
-     */
-    private Sync getEventPollingRequest() {
-        Sync signal;
-        if (changeFeed != null) {
-            // observation supported
-            signal = new Latch();
-            try {
-                immediateEventRequests.put(signal);
-            } catch (InterruptedException e) {
-                log.warn("Unable to request immediate event poll: " + e);
-            }
-        } else {
-            // no observation, return a dummy sync which can be acquired immediately
-            signal = new Sync() {
-                public void acquire() {
-                }
-                public boolean attempt(long l) {
-                    return true;
-                }
-                public void release() {
-                    throw new UnsupportedOperationException();
-                }
-            };
-        }
-        return signal;
-    }
-
-    /**
-         * The polling interval in milliseconds.
+         * The polling timeout in milliseconds.
-        private final int pollingInterval;
+        private final int pollTimeout;
-         * Creates a new change polling with a given polling interval.
+         * Creates a new change polling with a given polling timeout.
-         * @param pollingInterval the interval in milliseconds.
+         * @param pollTimeout the timeout in milliseconds.
-        private ChangePolling(int pollingInterval) {
-            this.pollingInterval = pollingInterval;
+        private ChangePolling(int pollTimeout) {
+            this.pollTimeout = pollTimeout;
-                    // wait for a signal to do an immediate poll but wait at
-                    // most EXTERNAL_EVENT_POLLING_INTERVAL
-                    Sync signal = (Sync) immediateEventRequests.poll(pollingInterval);
+                    // get filters from listeners
+                    List filters = new ArrayList();
+                    InternalEventListener[] iel = (InternalEventListener[]) listeners.toArray(new InternalEventListener[0]);
+                    for (int i = 0; i < iel.length; i++) {
+                        filters.addAll(iel[i].getEventFilters());
+                    }
+                    EventFilter[] filtArr = (EventFilter[]) filters.toArray(new EventFilter[filters.size()]);
-                    synchronized (updateMonitor) {
-                        // if this thread was waiting for updateMonitor and now
-                        // enters this synchronized block, then a user thread
-                        // has just finished an operation and will probably
-                        // request an immediate event poll. That's why we
-                        // check here again for a sync signal
-                        if (signal == null) {
-                            signal = (Sync) immediateEventRequests.poll(0);
-                        }
-
-                        if (signal != null) {
-                            log.debug("Request for immediate event poll");
-                        }
-
-                        long timeout = 0;
-                        // get filters from listeners
-                        List filters = new ArrayList();
-                        InternalEventListener[] iel = (InternalEventListener[]) listeners.toArray(new InternalEventListener[0]);
-                        for (int i = 0; i < iel.length; i++) {
-                            filters.addAll(iel[i].getEventFilters());
-                        }
-                        EventFilter[] filtArr = (EventFilter[]) filters.toArray(new EventFilter[filters.size()]);
-
-                        EventBundle[] bundles = service.getEvents(sessionInfo, timeout, filtArr);
-                        try {
-                            if (bundles.length > 0) {
-                                onEventReceived(bundles);
-                            }
-                        } finally {
-                            if (signal != null) {
-                                log.debug("About to signal that events have been delivered");
-                                signal.release();
-                                log.debug("Event delivery signaled");
-                            }
-                        }
+                    log.debug("calling getEvents() (Workspace={})",
+                            sessionInfo.getWorkspaceName());
+                    EventBundle[] bundles = service.getEvents(sessionInfo, pollTimeout, filtArr);
+                    log.debug("returned from getEvents() (Workspace={})",
+                            sessionInfo.getWorkspaceName());
+                    // check if thread had been interrupted while
+                    // getting events
+                    if (Thread.interrupted()) {
+                        log.debug("Thread interrupted, terminating...");
+                        break;
+                    }
+                    if (bundles.length > 0) {
+                        onEventReceived(bundles);
-                    log.warn("Exception while retrieving event bundles: " + e);
+                    log.info("Workspace=" + sessionInfo.getWorkspaceName() +
+                            ": Exception while retrieving event bundles: " + e);

JCR-1612: Reintroduce NamespaceStorage and namespace-caching

Make NamespaceRegistryImpl implement StringIndex and simplify the downstream classes accordingly.

To make this happen I modified the StringIndex contract a bit, allowing (and, for indexToString, requiring) implementations to throw exceptions if an unknown index is requested. Modified implementing classes accordingly.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@681121 13f79535-47bb-0310-9956-ffa450edef68

-    public String indexToString(int idx) {
+    public String indexToString(int idx) throws IllegalArgumentException {
-            if (s == null) {
-                throw new IllegalStateException("String empty???");
-            }
-        ResultSet rs = null;
+        int result = -1;
-            Statement stmt = connectionManager.executeStmt(nameInsertSQL, new Object[]{string}, true, 0);
-            rs = stmt.getGeneratedKeys();
-            if (!rs.next()) {
-                return -1;
-            } else {
-                return rs.getInt(1);
+            Statement stmt = connectionManager.executeStmt(
+                    nameInsertSQL, new Object[] { string }, true, 0);
+            ResultSet rs = stmt.getGeneratedKeys();
+            try {
+                if (rs.next()) {
+                    result = rs.getInt(1);
+                }
+            } finally {
+                rs.close();
-            IllegalStateException ise = new IllegalStateException("Unable to insert index for string: " + string);
+            IllegalStateException ise = new IllegalStateException(
+                    "Unable to insert index for string: " + string);
-        } finally {
-            closeResultSet(rs);
+        }
+        if (result != -1) {
+            return result;
+        } else {
+            // Could not get the index with getGeneratedKeys, try with SELECT
+            return getIndex(string);
-        ResultSet rs = null;
-            Statement stmt = connectionManager.executeStmt(indexSelectSQL, new Object[]{string});
-            rs = stmt.getResultSet();
-            if (!rs.next()) {
-                return -1;
-            } else {
-                return rs.getInt(1);
+            Statement stmt = connectionManager.executeStmt(
+                    indexSelectSQL, new Object[] { string });
+            ResultSet rs = stmt.getResultSet();
+            try {
+                if (rs.next()) {
+                    return rs.getInt(1);
+                } else {
+                    return -1;
+                }
+            } finally {
+                rs.close();
-            IllegalStateException ise = new IllegalStateException("Unable to read index for string: " + string);
+            IllegalStateException ise = new IllegalStateException(
+                    "Unable to read index for string: " + string);
-        } finally {
-            closeResultSet(rs);
-     * @return the string or <code>null</code> if not found.
+     * @return the string
+     * @throws IllegalArgumentException if the string is not found
-    protected String getString(int index) {
-        ResultSet rs = null;
+    protected String getString(int index)
+            throws IllegalArgumentException, IllegalStateException {
+        String result = null;
-            Statement stmt = connectionManager.executeStmt(nameSelectSQL, new Object[]{new Integer(index)});
-            rs = stmt.getResultSet();
-            if (!rs.next()) {
-                return null;
-            } else {
-                return rs.getString(1);
+            Statement stmt = connectionManager.executeStmt(
+                    nameSelectSQL, new Object[] { new Integer(index) });
+            ResultSet rs = stmt.getResultSet();
+            try {
+                if (rs.next()) {
+                    result = rs.getString(1);
+                }
+            } finally {
+                rs.close();
-            IllegalStateException ise = new IllegalStateException("Unable to read name for index: " + index);
+            IllegalStateException ise = new IllegalStateException(
+                    "Unable to read name for index: " + index);
-        } finally {
-            closeResultSet(rs);
+        if (result == null) {
+            throw new IllegalArgumentException("Index not found: " + index);
+        }
+        return result;
-    /**
-     * Closes the result set
-     * @param rs the result set.
-     */
-    protected void closeResultSet(ResultSet rs) {
-        if (rs != null) {
-            try {
-                rs.close();
-            } catch (SQLException se) {
-                // ignore
-            }
-        }
-    }

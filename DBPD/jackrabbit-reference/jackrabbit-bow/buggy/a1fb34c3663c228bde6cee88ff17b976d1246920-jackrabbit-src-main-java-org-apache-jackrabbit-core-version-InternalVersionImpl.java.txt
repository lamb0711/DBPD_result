JCR-414 jcr:successors property not persisted correctly within a transaction

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@398589 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.List;
-     * the list/cache of predecessors (values == InternalVersion)
-     */
-    private ArrayList predecessors = new ArrayList();
-
-    /**
-     * the list of successors (values == InternalVersion)
-     */
-    private ArrayList successors = new ArrayList();
-
-    /**
-        return (InternalVersionImpl[]) successors.toArray(new InternalVersionImpl[successors.size()]);
+        InternalValue[] values = node.getPropertyValues(QName.JCR_SUCCESSORS);
+        if (values != null) {
+            InternalVersion[] versions = new InternalVersion[values.length];
+            for (int i = 0; i < values.length; i++) {
+                NodeId vId = new NodeId((UUID) values[i].internalValue());
+                versions[i] = versionHistory.getVersion(vId);
+            }
+            return versions;
+        } else {
+            return new InternalVersion[0];
+        }
-        return (InternalVersionImpl[]) predecessors.toArray(new InternalVersionImpl[predecessors.size()]);
+        InternalValue[] values = node.getPropertyValues(QName.JCR_PREDECESSORS);
+        if (values != null) {
+            InternalVersion[] versions = new InternalVersion[values.length];
+            for (int i = 0; i < values.length; i++) {
+                NodeId vId = new NodeId((UUID) values[i].internalValue());
+                versions[i] = versionHistory.getVersion(vId);
+            }
+            return versions;
+        } else {
+            return new InternalVersion[0];
+        }
-        for (int i = 0; i < predecessors.size(); i++) {
-            InternalVersion pred = (InternalVersion) predecessors.get(i);
+        InternalVersion[] preds = getPredecessors();
+        for (int i = 0; i < preds.length; i++) {
+            InternalVersion pred = preds[i];
-     * resolves the predecessors property and indirectly adds it self to their
-     * successor list.
-     */
-    void resolvePredecessors() {
-        InternalValue[] values = node.getPropertyValues(QName.JCR_PREDECESSORS);
-        if (values != null) {
-            for (int i = 0; i < values.length; i++) {
-                NodeId vId = new NodeId((UUID) values[i].internalValue());
-                InternalVersionImpl v = (InternalVersionImpl) versionHistory.getVersion(vId);
-                predecessors.add(v);
-                v.addSuccessor(this);
-            }
-        }
-    }
-
-    /**
-        successors.clear();
-        predecessors.clear();
-     * adds a successor version to the internal cache
-     *
-     * @param successor
-     */
-    private void addSuccessor(InternalVersion successor) {
-        successors.add(successor);
-    }
-
-    /**
-     * stores the internal predecessor cache to the persistance node
+     * stores the given successors or predecessors to the persistance node
-    private void storePredecessors() throws RepositoryException {
-        InternalValue[] values = new InternalValue[predecessors.size()];
+    private void storeXCessors(List cessors, QName propname, boolean store)
+            throws RepositoryException {
+        InternalValue[] values = new InternalValue[cessors.size()];
-                    ((InternalVersion) predecessors.get(i)).getId().getUUID());
+                    ((InternalVersion) cessors.get(i)).getId().getUUID());
-        node.setPropertyValues(QName.JCR_PREDECESSORS, PropertyType.STRING, values);
+        node.setPropertyValues(propname, PropertyType.STRING, values);
+        if (store) {
+            node.store();
+        }
-        InternalVersionImpl[] succ = (InternalVersionImpl[]) getSuccessors();
+        InternalVersion[] succ = getSuccessors();
-            succ[i].internalDetachPredecessor(this);
+            ((InternalVersionImpl) succ[i]).internalDetachPredecessor(this, true);
-        InternalVersionImpl[] preds = (InternalVersionImpl[]) getPredecessors();
+        InternalVersion[] preds = getPredecessors();
-            preds[i].internalDetachSuccessor(this);
+            ((InternalVersionImpl) preds[i]).internalDetachSuccessor(this, true);
+     * Attaches this version as successor to all predecessors. assuming that the
+     * predecessors are already set.
+     *
+     * @throws RepositoryException
+     */
+    void internalAttach() throws RepositoryException {
+        InternalVersion[] preds = getPredecessors();
+        for (int i = 0; i < preds.length; i++) {
+            ((InternalVersionImpl) preds[i]).internalAddSuccessor(this, true);
+        }
+    }
+
+    /**
+     * Adds a version to the set of successors.
+     *
+     * @param succ
+     * @param store
+     * @throws RepositoryException
+     */
+    private void internalAddSuccessor(InternalVersionImpl succ, boolean store)
+            throws RepositoryException {
+        List l = new ArrayList(Arrays.asList(getSuccessors()));
+        if (!l.contains(succ)) {
+            l.add(succ);
+            storeXCessors(l, QName.JCR_SUCCESSORS, store);
+        }
+    }
+
+    /**
-    private void internalDetachPredecessor(InternalVersionImpl v) throws RepositoryException {
+    private void internalDetachPredecessor(InternalVersionImpl v, boolean store)
+            throws RepositoryException {
-        for (int i = 0; i < predecessors.size(); i++) {
-            if (predecessors.get(i).equals(v)) {
-                predecessors.remove(i);
-                break;
-            }
-        }
+        List l = new ArrayList(Arrays.asList(getPredecessors()));
+        l.remove(v);
+
-        predecessors.addAll(Arrays.asList(v.getPredecessors()));
-        storePredecessors();
-        node.store();
+        l.addAll(Arrays.asList(v.getPredecessors()));
+        storeXCessors(l, QName.JCR_PREDECESSORS, store);
-    private void internalDetachSuccessor(InternalVersionImpl v) {
+    private void internalDetachSuccessor(InternalVersionImpl v, boolean store)
+            throws RepositoryException {
-        for (int i = 0; i < successors.size(); i++) {
-            if (successors.get(i).equals(v)) {
-                successors.remove(i);
-                break;
-            }
-        }
+        List l = new ArrayList(Arrays.asList(getSuccessors()));
+        l.remove(v);
+
-        successors.addAll(Arrays.asList(v.getSuccessors()));
+        l.addAll(Arrays.asList(v.getSuccessors()));
+        storeXCessors(l, QName.JCR_SUCCESSORS, store);
+
+    /**
+     * Resolves jcr:successor properties that are missing.
+     *
+     * @throws RepositoryException
+     */
+    void legacyResolveSuccessors() throws RepositoryException {
+        InternalValue[] values = node.getPropertyValues(QName.JCR_PREDECESSORS);
+        if (values != null) {
+            for (int i = 0; i < values.length; i++) {
+                NodeId vId = new NodeId((UUID) values[i].internalValue());
+                InternalVersionImpl v = (InternalVersionImpl) versionHistory.getVersion(vId);
+                v.internalAddSuccessor(this, false);
+            }
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj instanceof InternalVersionImpl) {
+            InternalVersionImpl v = (InternalVersionImpl) obj;
+            return v.getId().equals(getId());
+        }
+        return false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public int hashCode() {
+        return getId().hashCode();
+    }

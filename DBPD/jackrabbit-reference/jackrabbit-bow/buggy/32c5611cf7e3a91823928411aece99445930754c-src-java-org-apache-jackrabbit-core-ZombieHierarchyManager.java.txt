fixed ZombieHierarchyManager: 
resolvePath(), getDepth() and getName() did not allow 
for removed/moved items

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@202206 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.state.PropertyState;
-import javax.jcr.ItemNotFoundException;
-import javax.jcr.RepositoryException;
- *
+ * <p/>
-                                 ItemStateManager provider,
-                                 ItemStateManager attic,
-                                 NamespaceResolver nsResolver) {
+                                  ItemStateManager provider,
+                                  ItemStateManager attic,
+                                  NamespaceResolver nsResolver) {
-     *
-     * Checks attic first.
+     * <p/>
+     * Delivers state from attic if such exists, otherwise calls base class.
-     *
-     * Checks attic first.
+     * <p/>
+     * Returns <code>true</code>  if there's state on the attic for the
+     * requested item; otherwise delegates to base class.
-     *
-     * Also allows for removed/renamed parent-child links.
+     * <p/>
+     * Also allows for removed items.
-    protected void buildPath(Path.PathBuilder builder, ItemState state)
-            throws ItemStateException, RepositoryException {
-
-        // shortcut
-        if (state.getId().equals(rootNodeId)) {
-            builder.addRoot();
-            return;
-        }
-
-        String parentUUID;
+    protected String getParentUUID(ItemState state) {
-            parentUUID = state.getOverlayedState().getParentUUID();
-        } else {
-            parentUUID = state.getParentUUID();
+            return state.getOverlayedState().getParentUUID();
-        if (parentUUID == null) {
-            String msg = "failed to build path of " + state.getId() + ": orphaned item";
-            log.debug(msg);
-            throw new ItemNotFoundException(msg);
-        }
+        // delegate to base class
+        return super.getParentUUID(state);
+    }
-        NodeState parent = (NodeState) getItemState(new NodeId(parentUUID));
-        // recursively build path of parent
-        buildPath(builder, parent);
-
-        if (state.isNode()) {
-            NodeState nodeState = (NodeState) state;
-            String uuid = nodeState.getUUID();
-            NodeState.ChildNodeEntry parentEntry = null;
-            // check removed child node entries first
-            Iterator iter = parent.getRemovedChildNodeEntries().iterator();
-            while (iter.hasNext()) {
-                NodeState.ChildNodeEntry entry =
-                        (NodeState.ChildNodeEntry) iter.next();
-                if (entry.getUUID().equals(uuid)) {
-                    parentEntry = entry;
-                    break;
-                }
+    /**
+     * {@inheritDoc}
+     * <p/>
+     * Also allows for removed/renamed child node entries.
+     */
+    protected NodeState.ChildNodeEntry getChildNodeEntry(NodeState parent,
+                                                         QName name,
+                                                         int index) {
+        // check removed child node entries first
+        Iterator iter = parent.getRemovedChildNodeEntries().iterator();
+        while (iter.hasNext()) {
+            NodeState.ChildNodeEntry entry =
+                    (NodeState.ChildNodeEntry) iter.next();
+            if (entry.getName().equals(name)
+                    && entry.getIndex() == index) {
+                return entry;
-            if (parentEntry == null) {
-                // no removed child node entry found in parent,
-                // check current child node entries
-                parentEntry = parent.getChildNodeEntry(uuid);
-            }
-            if (parentEntry == null) {
-                String msg = "failed to build path of " + state.getId() + ": "
-                        + parent.getUUID() + " has no child entry for "
-                        + uuid;
-                log.debug(msg);
-                throw new ItemNotFoundException(msg);
-            }
-            // add to path
-            if (parentEntry.getIndex() == 1) {
-                builder.addLast(parentEntry.getName());
-            } else {
-                builder.addLast(parentEntry.getName(), parentEntry.getIndex());
-            }
-        } else {
-            PropertyState propState = (PropertyState) state;
-            QName name = propState.getName();
-            // add to path
-            builder.addLast(name);
+        // no matching removed child node entry found in parent,
+        // delegate to base class
+        return super.getChildNodeEntry(parent, name, index);
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p/>
+     * Also allows for removed child node entries.
+     */
+    protected NodeState.ChildNodeEntry getChildNodeEntry(NodeState parent,
+                                                         String uuid) {
+        // check removed child node entries first
+        Iterator iter = parent.getRemovedChildNodeEntries().iterator();
+        while (iter.hasNext()) {
+            NodeState.ChildNodeEntry entry =
+                    (NodeState.ChildNodeEntry) iter.next();
+            if (entry.getUUID().equals(uuid)) {
+                return entry;
+            }
+        }
+        // no matching removed child node entry found in parent,
+        // delegate to base class
+        return super.getChildNodeEntry(parent, uuid);

JCR-1152: JCR2SPI: use own ValueFactory, wrapping the SPI's QValueFactory: spi-commons: add implementations of ValueFactory wrapping QValueFactory and Value wrapping a QValue. QValueFactoryImpl: Fix conversions that weren't called before. ValueFormat: take advantage of known ValueFactory/Value implementations.


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@590140 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.TimeZone;
+    /**
+     * the default encoding
+     */
+    private static final String DEFAULT_ENCODING = "UTF-8";
+
-    public QValue create(String value, int type) {
+    public QValue create(String value, int type) throws RepositoryException {
-        switch (type) {
-            case PropertyType.BOOLEAN:
-                return new QValueImpl(Boolean.valueOf(value));
-            case PropertyType.DATE:
-                return new DateQValue(value);
-            case PropertyType.DOUBLE:
-                return new QValueImpl(Double.valueOf(value));
-            case PropertyType.LONG:
-                return new QValueImpl(Long.valueOf(value));
-            case PropertyType.PATH:
-                return new QValueImpl(PATH_FACTORY.create(value));
-            case PropertyType.NAME:
-                return new QValueImpl(NAME_FACTORY.create(value));
-            case PropertyType.STRING:
-            case PropertyType.REFERENCE:
-                return new QValueImpl(value, type);
-            case PropertyType.BINARY:
-                throw new IllegalArgumentException("this method does not support the type PropertyType.BINARY");
-            default:
-                throw new IllegalArgumentException("illegal type");
+        
+        try {
+            switch (type) {
+                case PropertyType.BOOLEAN:
+                    return new QValueImpl(Boolean.valueOf(value));
+                case PropertyType.DATE: {
+                        Calendar cal = ISO8601.parse(value);
+                        if (cal == null) {
+                            throw new ValueFormatException("not a valid date: " + value);
+                        }
+                        return new DateQValue(cal);
+                    }
+                case PropertyType.DOUBLE:
+                    return new QValueImpl(Double.valueOf(value));
+                case PropertyType.LONG:
+                    return new QValueImpl(Long.valueOf(value));
+                case PropertyType.PATH:
+                    return new QValueImpl(PATH_FACTORY.create(value));
+                case PropertyType.NAME:
+                    return new QValueImpl(NAME_FACTORY.create(value));
+                case PropertyType.STRING:
+                case PropertyType.REFERENCE:
+                    return new QValueImpl(value, type);
+                case PropertyType.BINARY:
+                    return new BinaryQValue(value.getBytes(DEFAULT_ENCODING));
+                default:
+                    throw new IllegalArgumentException("illegal type");
+            }
+        } catch (NumberFormatException ex) {
+            throw new ValueFormatException(ex);
+        } catch (UnsupportedEncodingException ex) {
+            throw new RepositoryException(ex);
-        /**
-         * the default encoding
-         */
-        private static final String DEFAULT_ENCODING = "UTF-8";
-                return new ByteArrayInputStream(getString().getBytes(QValueImpl.DEFAULT_ENCODING));
+                return new ByteArrayInputStream(getString().getBytes(QValueFactoryImpl.DEFAULT_ENCODING));
-                throw new RepositoryException(QValueImpl.DEFAULT_ENCODING + " is not supported encoding on this platform", e);
+                throw new RepositoryException(QValueFactoryImpl.DEFAULT_ENCODING + " is not supported encoding on this platform", e);
+            } else if (type == PropertyType.DOUBLE) {
+                Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("GMT+00:00"));
+                cal.setTimeInMillis(((Double) val).longValue());
+                return cal;
+            } else if (type == PropertyType.LONG) {
+                Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("GMT+00:00"));
+                cal.setTimeInMillis(((Long) val).longValue());
+                return cal;
-                return ISO8601.parse(getString());
+                Calendar cal = ISO8601.parse(getString());
+                if (cal == null) {
+                    throw new ValueFormatException("not a date string: " + getString());
+                }
+                else {
+                    return cal;
+                }
+            } else if (type == PropertyType.DATE) {
+                return ((Calendar) val).getTimeInMillis(); 
-                return Double.parseDouble(getString());
+                try {
+                    return Double.parseDouble(getString());
+                } catch (NumberFormatException ex) {
+                    throw new ValueFormatException("not a double: " + getString(), ex);
+                }
+            } else if (type == PropertyType.DOUBLE) {
+                return ((Double) val).longValue();
+            } else if (type == PropertyType.DATE) {
+                return ((Calendar) val).getTimeInMillis(); 
-                return Long.parseLong(getString());
+                try {
+                    return Long.parseLong(getString());
+                } catch (NumberFormatException ex) {
+                    throw new ValueFormatException("not a long: " + getString(), ex);
+                }
-         * @return
-        private DateQValue(String value) {
-            super(ISO8601.parse(value), PropertyType.DATE);
-            formattedStr = value;
-        }
-
-                    text = new String(data, QValueImpl.DEFAULT_ENCODING);
+                    text = new String(data, QValueFactoryImpl.DEFAULT_ENCODING);
-                    throw new RepositoryException(QValueImpl.DEFAULT_ENCODING
+                    throw new RepositoryException(QValueFactoryImpl.DEFAULT_ENCODING
-           throw new UnsupportedOperationException();
+             Calendar cal = ISO8601.parse(getString());
+             if (cal == null) {
+                 throw new ValueFormatException("not a date string: " + getString());
+             } else {
+                 return cal;
+             }
-            return Double.parseDouble(getString());
+            try {
+                return Double.parseDouble(getString());
+            } catch (NumberFormatException ex) {
+                throw new ValueFormatException(ex);
+            }
-            return Long.parseLong(getString());
+            try {
+                return Long.parseLong(getString());
+            } catch (NumberFormatException ex) {
+                throw new ValueFormatException(ex);
+            }

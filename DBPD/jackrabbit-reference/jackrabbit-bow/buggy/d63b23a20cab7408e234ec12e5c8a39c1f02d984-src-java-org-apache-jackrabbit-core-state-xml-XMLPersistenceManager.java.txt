changed XMLPersistenceManager back to store everything in (less efficient but human readable) xml format (as its name would suggest); 
ObjectPersistenceManager can be used for a more efficient 
filesystem-based serialization format


git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@57040 13f79535-47bb-0310-9956-ffa450edef68

+import org.jdom.filter.ContentFilter;
+import org.jdom.filter.Filter;
-    private static final String COUNT_ATTRIBUTE = "count";
+
+    private static final String VALUES_ELEMENT = "values";
+    private static final String VALUE_ELEMENT = "value";
+    private static final String NODEREFERENCES_ELEMENT = "references";
+    private static final String TARGETID_ATTRIBUTE = "targetId";
+    private static final String NODEREFERENCE_ELEMENT = "reference";
+    private static final String PROPERTYID_ATTRIBUTE = "propertyId";
+
-    private static final String NODEREFSFILENAME = ".references";
+    private static final String NODEREFSFILENAME = ".references.xml";
-            //fileName = new String(chars) + ".xml";
-            fileName = new String(chars);
+            fileName = new String(chars) + ".xml";
-            String msg = "MD5 not available: ";
+            String msg = "MD5 not available";
-    private void readState(Properties props, PersistentPropertyState state)
+    private void readState(Element propElement, PersistentPropertyState state)
+        // first do some paranoid sanity checks
+        if (!propElement.getName().equals(PROPERTY_ELEMENT)) {
+            String msg = "invalid serialization format (unexpected element: " + propElement.getName() + ")";
+            log.error(msg);
+            throw new ItemStateException(msg);
+        }
+        // check name
+        if (!state.getName().equals(QName.valueOf(propElement.getAttributeValue(NAME_ATTRIBUTE)))) {
+            String msg = "invalid serialized state: name mismatch";
+            log.error(msg);
+            throw new ItemStateException(msg);
+        }
+        // check parentUUID
+        String parentUUID = propElement.getAttributeValue(PARENTUUID_ATTRIBUTE);
+        if (!parentUUID.equals(state.getParentUUID())) {
+            String msg = "invalid serialized state: parentUUID mismatch";
+            log.error(msg);
+            throw new ItemStateException(msg);
+        }
+
+        // now we're ready to read state
+
-        String typeName = props.getProperty(TYPE_ATTRIBUTE);
+        String typeName = propElement.getAttributeValue(TYPE_ATTRIBUTE);
-        if (props.containsKey(DEFINITIONID_ATTRIBUTE)) {
-            state.setDefinitionId(PropDefId.valueOf(props.getProperty(DEFINITIONID_ATTRIBUTE)));
-        }
-
-        // # of values
-        int cnt = Integer.parseInt(props.getProperty(COUNT_ATTRIBUTE));
+        String definitionId = propElement.getAttributeValue(DEFINITIONID_ATTRIBUTE);
+        state.setDefinitionId(PropDefId.valueOf(definitionId));
-        InternalValue[] values = new InternalValue[cnt];
-        Enumeration names = props.propertyNames();
-        while (names.hasMoreElements()) {
-            String name = (String) names.nextElement();
-            if (TYPE_ATTRIBUTE.equals(name) || COUNT_ATTRIBUTE.equals(name)
-                    || DEFINITIONID_ATTRIBUTE.equals(name)) {
-                continue;
-            }
-            int i = Integer.parseInt(name);
+        Iterator iter = propElement.getChild(VALUES_ELEMENT).getChildren(VALUE_ELEMENT).iterator();
+        ArrayList values = new ArrayList();
+        while (iter.hasNext()) {
+            Element valueElement = (Element) iter.next();
+            Filter filter = new ContentFilter(ContentFilter.TEXT | ContentFilter.CDATA);
+            List content = valueElement.getContent(filter);
+
-            String text = props.getProperty(name);
-            if (text != null) {
+            if (!content.isEmpty()) {
+                // read serialized value
+                String text = valueElement.getTextTrim();
-                        String msg = "error while reading serialized binary value";
+                        String msg = "error while reading serialized binary valuey";
+                values.add(val);
-                // null value
-                val = null;
+                continue;
-            values[i] = val;
-        state.setValues(values);
+        state.setValues((InternalValue[]) values.toArray(new InternalValue[values.size()]));
+    }
+
+    private void readState(Element refsElement, NodeReferences refs)
+            throws ItemStateException {
+        // first do some paranoid sanity checks
+        if (!refsElement.getName().equals(NODEREFERENCES_ELEMENT)) {
+            String msg = "invalid serialization format (unexpected element: " + refsElement.getName() + ")";
+            log.error(msg);
+            throw new ItemStateException(msg);
+        }
+        // check targetId
+        if (!refs.getTargetId().equals(NodeId.valueOf(refsElement.getAttributeValue(TARGETID_ATTRIBUTE)))) {
+            String msg = "invalid serialized state: targetId  mismatch";
+            log.error(msg);
+            throw new ItemStateException(msg);
+        }
+
+        // now we're ready to read the references data
+
+        // property id's
+        refs.clearAllReferences();
+        Iterator iter = refsElement.getChildren(NODEREFERENCE_ELEMENT).iterator();
+        while (iter.hasNext()) {
+            Element elem = (Element) iter.next();
+            refs.addReference(PropertyId.valueOf(elem.getAttributeValue(PROPERTYID_ATTRIBUTE)));
+        }
-                Properties props = new Properties();
-                props.load(in);
-                readState(props, state);
+                SAXBuilder builder = new SAXBuilder();
+                Element rootElement = builder.build(in).getRootElement();
+
+                readState(rootElement, state);
+        } catch (JDOMException jde) {
+            e = jde;
+            // fall through
-
-/*
-	    Writer writer = null;
-	    try {
-		String encoding = DEFAULT_ENCODING;
-		try {
-		    writer = new BufferedWriter(new OutputStreamWriter(os, encoding));
-		} catch (UnsupportedEncodingException e) {
-		    // should never get here!
-		    OutputStreamWriter osw = new OutputStreamWriter(os);
-		    encoding = osw.getEncoding();
-		    writer = new BufferedWriter(osw);
-		}
-
-		String typeName;
-		int type = state.getType();
-		try {
-		    typeName = PropertyType.nameFromValue(type);
-		} catch (IllegalArgumentException iae) {
-		    // should never be getting here
-		    throw new ItemStateException("unexpected property-type ordinal: " + type, iae);
-		}
-
-		writer.write("<?xml version=\"1.0\" encoding=\"" + encoding + "\"?>\n");
-		writer.write("<" + PROPERTY_ELEMENT + " " +
-			NAME_ATTRIBUTE + "=\"" + state.getName() + "\" " +
-			PARENTUUID_ATTRIBUTE + "=\"" + state.getParentUUID() + "\" " +
-	    		DEFINITIONID_ATTRIBUTE + "=\"" + state.getDefinitionId().toString() + "\" " +
-			TYPE_ATTRIBUTE + "=\"" + typeName + "\">\n");
-		// values
-		writer.write("\t<" + VALUES_ELEMENT + ">\n");
-		InternalValue[] values = state.getValues();
-		if (values != null) {
-		    for (int i = 0; i < values.length; i++) {
-			writer.write("\t\t<" + VALUE_ELEMENT + ">");
-			InternalValue val = values[i];
-			if (val != null) {
-			    if (type == PropertyType.BINARY) {
-				// special handling required for binary value:
-				// spool binary value to file in blob store
-				BLOBFileValue blobVal = (BLOBFileValue) val.internalValue();
-				String binPath = buildBlobFilePath(state.getParentUUID(), state.getName(), i);
-				OutputStream binOut = null;
-			        FileSystemResource internalBlobFile = new FileSystemResource(blobStore, binPath);
-				internalBlobFile.makeParentDirs();
-				try {
-				    binOut = internalBlobFile.getOutputStream();
-				    blobVal.spool(binOut);
-				} finally {
-				    try {
-					if (binOut != null) {
-					    binOut.close();
-					}
-				    } catch (IOException ioe) {
-				    }
-				}
-				// store path to binary file as property value
-				writer.write(binPath);
-				// FIXME: hack!
-				// replace value instance with value
-				// backed by internal file and delete temp file
-				values[i] = InternalValue.create(internalBlobFile);
-				if (blobVal.isTempFile()) {
-				    blobVal.delete();
-				    blobVal = null;
-				}
-			    } else {
-				// escape '<' and '&'
-				char chars[] = val.toString().toCharArray();
-				int j = 0, last = 0;
-				while (j < chars.length) {
-				    char c = chars[j];
-				    if (c == '<') {
-					writer.write(chars, last, j - last);
-					writer.write("&lt;");
-					last = j + 1;
-				    } else if (c == '&') {
-					writer.write(chars, last, j - last);
-					writer.write("&amp;");
-					last = j + 1;
-				    }
-				    j++;
-				}
-				writer.write(chars, last, j - last);
-			    }
-			}
-			writer.write("</" + VALUE_ELEMENT + ">\n");
-		    }
-		}
-		writer.write("\t</" + VALUES_ELEMENT + ">\n");
-		writer.write("</" + PROPERTY_ELEMENT + ">\n");
-	    } finally {
-		writer.close();
-	    }
-*/
-            // write property state to java.util.Properties file
-            Properties props = new Properties();
-
-            // type
-            String typeName;
-            int type = state.getType();
+            Writer writer = null;
-                typeName = PropertyType.nameFromValue(type);
-            } catch (IllegalArgumentException iae) {
-                // should never be getting here
-                throw new ItemStateException("unexpected property-type ordinal: " + type, iae);
-            }
-            props.setProperty(TYPE_ATTRIBUTE, typeName);
+                String encoding = DEFAULT_ENCODING;
+                try {
+                    writer = new BufferedWriter(new OutputStreamWriter(os, encoding));
+                } catch (UnsupportedEncodingException e) {
+                    // should never get here!
+                    OutputStreamWriter osw = new OutputStreamWriter(os);
+                    encoding = osw.getEncoding();
+                    writer = new BufferedWriter(osw);
+                }
-            // definition id
-            props.setProperty(DEFINITIONID_ATTRIBUTE, state.getDefinitionId().toString());
+                String typeName;
+                int type = state.getType();
+                try {
+                    typeName = PropertyType.nameFromValue(type);
+                } catch (IllegalArgumentException iae) {
+                    // should never be getting here
+                    throw new ItemStateException("unexpected property-type ordinal: " + type, iae);
+                }
-            InternalValue[] values = state.getValues();
-
-            // # of values
-            props.setProperty(COUNT_ATTRIBUTE, Integer.toString(values == null ? 0 : values.length));
-
-            // values
-            if (values != null) {
-                for (int i = 0; i < values.length; i++) {
-                    InternalValue val = values[i];
-                    if (val != null) {
-                        if (type == PropertyType.BINARY) {
-                            // special handling required for binary value:
-                            // spool binary value to file in blob store
-                            BLOBFileValue blobVal = (BLOBFileValue) val.internalValue();
-
-                            String binPath = buildBlobFilePath(state.getParentUUID(), state.getName(), i);
-                            OutputStream binOut = null;
-                            FileSystemResource internalBlobFile = new FileSystemResource(blobStore, binPath);
-                            internalBlobFile.makeParentDirs();
-                            try {
-                                binOut = internalBlobFile.getOutputStream();
-                                blobVal.spool(binOut);
-                            } finally {
+                writer.write("<?xml version=\"1.0\" encoding=\"" + encoding + "\"?>\n");
+                writer.write("<" + PROPERTY_ELEMENT + " " +
+                        NAME_ATTRIBUTE + "=\"" + state.getName() + "\" " +
+                        PARENTUUID_ATTRIBUTE + "=\"" + state.getParentUUID() + "\" " +
+                        DEFINITIONID_ATTRIBUTE + "=\"" + state.getDefinitionId().toString() + "\" " +
+                        TYPE_ATTRIBUTE + "=\"" + typeName + "\">\n");
+                // values
+                writer.write("\t<" + VALUES_ELEMENT + ">\n");
+                InternalValue[] values = state.getValues();
+                if (values != null) {
+                    for (int i = 0; i < values.length; i++) {
+                        writer.write("\t\t<" + VALUE_ELEMENT + ">");
+                        InternalValue val = values[i];
+                        if (val != null) {
+                            if (type == PropertyType.BINARY) {
+                                // special handling required for binary value:
+                                // spool binary value to file in blob store
+                                BLOBFileValue blobVal = (BLOBFileValue) val.internalValue();
+                                String binPath = buildBlobFilePath(state.getParentUUID(), state.getName(), i);
+                                OutputStream binOut = null;
+                                FileSystemResource internalBlobFile = new FileSystemResource(blobStore, binPath);
+                                internalBlobFile.makeParentDirs();
-                                    if (binOut != null) {
-                                        binOut.close();
+                                    binOut = internalBlobFile.getOutputStream();
+                                    blobVal.spool(binOut);
+                                } finally {
+                                    try {
+                                        if (binOut != null) {
+                                            binOut.close();
+                                        }
+                                    } catch (IOException ioe) {
-                                } catch (IOException ioe) {
+                                // store path to binary file as property value
+                                writer.write(binPath);
+                                // FIXME: hack!
+                                // replace value instance with value
+                                // backed by internal file and delete temp file
+                                values[i] = InternalValue.create(internalBlobFile);
+                                if (blobVal.isTempFile()) {
+                                    blobVal.delete();
+                                    blobVal = null;
+                                }
+                            } else {
+                                // escape '<' and '&'
+                                char chars[] = val.toString().toCharArray();
+                                int j = 0, last = 0;
+                                while (j < chars.length) {
+                                    char c = chars[j];
+                                    if (c == '<') {
+                                        writer.write(chars, last, j - last);
+                                        writer.write("&lt;");
+                                        last = j + 1;
+                                    } else if (c == '&') {
+                                        writer.write(chars, last, j - last);
+                                        writer.write("&amp;");
+                                        last = j + 1;
+                                    }
+                                    j++;
+                                }
+                                writer.write(chars, last, j - last);
-                            // store path to binary file as property value
-                            props.setProperty(Integer.toString(i), binPath);
-                            // replace value instance with value
-                            // backed by internal file and delete temp file
-                            values[i] = InternalValue.create(internalBlobFile);
-                            if (blobVal.isTempFile()) {
-                                blobVal.delete();
-                                blobVal = null;
-                            }
-                        } else {
-                            props.setProperty(Integer.toString(i), val.toString());
-                    } else {
-                        // null value
-                        props.setProperty(Integer.toString(i), null);
+                        writer.write("</" + VALUE_ELEMENT + ">\n");
-            }
-
-            try {
-                props.store(os, null);
+                writer.write("\t</" + VALUES_ELEMENT + ">\n");
+                writer.write("</" + PROPERTY_ELEMENT + ">\n");
-                // make sure stream is closed
-                os.close();
+                writer.close();
-            BufferedReader reader = null;
-            try {
-                String encoding = DEFAULT_ENCODING;
-                try {
-                    reader = new BufferedReader(new InputStreamReader(in, encoding));
-                } catch (UnsupportedEncodingException uee) {
-                    // should never get here!
-                    InputStreamReader isw = new InputStreamReader(in);
-                    encoding = isw.getEncoding();
-                    reader = new BufferedReader(isw);
-                }
-                // read references (i.e. the id's of the REFERENCE properties)
-                String s;
-                while ((s = reader.readLine()) != null) {
-                    if (s.length() > 0) {
-                        PropertyId propId = PropertyId.valueOf(s);
-                        refs.addReference(propId);
-                    }
-                }
-                return;
+            try {
+                SAXBuilder builder = new SAXBuilder();
+                Element rootElement = builder.build(in).getRootElement();
+
+                readState(rootElement, refs);
+                return;
-                reader.close();
+                in.close();
+        } catch (JDOMException jde) {
+            e = jde;
+            // fall through
+                writer.write("<?xml version=\"1.0\" encoding=\"" + encoding + "\"?>\n");
+                writer.write("<" + NODEREFERENCES_ELEMENT + " "
+                        + TARGETID_ATTRIBUTE + "=\"" + refs.getTargetId() + "\">\n");
-                    writer.write(propId.toString());
-                    writer.newLine();
+                    writer.write("\t<" + NODEREFERENCE_ELEMENT + " "
+                    + PROPERTYID_ATTRIBUTE+ "=\"" + propId +  "\"/>\n");
+                writer.write("</" + NODEREFERENCES_ELEMENT + ">\n");

JCR-926: global data store: new in-memory, data store, and temp file BLOB

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@571094 13f79535-47bb-0310-9956-ffa450edef68

+
+import java.io.ByteArrayInputStream;
+import java.io.SequenceInputStream;
+    /**
+     * Byte arrays smaller or equal this size are always kept in memory
+     */
+    private final static int MIN_BLOB_FILE_SIZE = Integer.parseInt(System.getProperty("org.jackrabbit.minBlobFileSize", "100"));
+
-     * @param value
-     * @param nsResolver
-     * @return
-     * @throws ValueFormatException
-     * @throws RepositoryException
+     * Create a new internal value from the given JCR value.
+     * Large binary values are stored in a temporary file.
+     * 
+     * @param value the JCR value
+     * @param nsResolver the namespace resolver
+     * @return the created internal value
-    public static InternalValue create(Value value, NamespaceResolver nsResolver, DataStore store)
+    public static InternalValue create(Value value, NamespaceResolver nsResolver)
-        return create(value, nsResolver);
+        return create(value, nsResolver, null);
-     * @param value
-     * @param nsResolver
-     * @return
-     * @throws ValueFormatException
-     * @throws RepositoryException
+     * Create a new internal value from the given JCR value.
+     * If the data store is enabled, large binary values are stored in the data store.
+     * 
+     * @param value the JCR value
+     * @param nsResolver the namespace resolver
+     * @param store the data store
+     * @return the created internal value
-    public static InternalValue create(Value value, NamespaceResolver nsResolver)
+    public static InternalValue create(Value value, NamespaceResolver nsResolver, DataStore store)
-
+                    if(USE_DATA_STORE) {
+                        if(store == null) {
+                            return new InternalValue(BLOBInTempFile.getInstance(value.getStream()));
+                        } else {
+                            return new InternalValue(getBLOBFileValue(store, value.getStream()));
+                        }
+                    }
+        if(USE_DATA_STORE) {        
+            return new InternalValue(BLOBInMemory.getInstance(value));
+        }
-     * @param value
-     * @return
-     * @throws IOException
+     * Create an internal value that is backed by a temporary file.
+     * 
+     * @param value the stream
+     * @param store the data store
+     * @return the internal value
+        if(USE_DATA_STORE) {        
+            return new InternalValue(BLOBInTempFile.getInstance(value));
+        }
-    }    
+    }
+    
+    /**
+     * Create an internal value that is backed by a temporary file (if data store usage is disabled)
+     * or (if it is enabled) in the data store.
+     * 
+     * @param value the stream
+     * @param store the data store
+     * @return the internal value
+     */
+    public static InternalValue createTemporary(InputStream value, DataStore store) throws IOException {
+        if(USE_DATA_STORE) {
+            return new InternalValue(getBLOBFileValue(store, value));
+        }
+        return new InternalValue(new BLOBValue(value, true));
+    }
+    
+    /**
+     * Create a binary object with the given identifier.
+     * 
+     * @param store the data store
+     * @param id the identifier
+     * @return the value
+     */    
+    public static InternalValue create(DataStore store, String id) {
+        assert USE_DATA_STORE;
+        return new InternalValue(getBLOBFileValue(store, id));
+    }
+        if(USE_DATA_STORE) {
+            return this;
+        }
+    
+    private static BLOBFileValue getBLOBFileValue(DataStore store, InputStream in) throws IOException {
+        byte[] buffer = new byte[MIN_BLOB_FILE_SIZE];
+        int pos = 0, len = MIN_BLOB_FILE_SIZE;
+        while(pos < MIN_BLOB_FILE_SIZE) {
+            int l = in.read(buffer, pos, len);
+            if(l < 0) {
+                break;
+            }
+            pos += l;
+            len -= l;
+        }
+        if(pos < MIN_BLOB_FILE_SIZE) {
+            // shrink the buffer
+            byte[] data = new byte[pos];
+            System.arraycopy(buffer, 0, data, 0, pos);
+            return BLOBInMemory.getInstance(data);
+        } else {
+            // a few bytes are already read, need to re-build the input stream
+            in = new SequenceInputStream(new ByteArrayInputStream(buffer, 0, pos), in);
+            return BLOBInDataStore.getInstance(store, in);
+        }
+    }
+
+    private static BLOBFileValue getBLOBFileValue(DataStore store, String id) {
+        if(BLOBInMemory.isInstance(id)) {
+            return BLOBInMemory.getInstance(id);
+        } else if(BLOBInDataStore.isInstance(id)) {
+            return BLOBInDataStore.getInstance(store, id);
+        } else {
+            throw new IllegalArgumentException("illegal binary id: " + id);
+        }
+    }
+

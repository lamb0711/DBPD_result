JCR-1819 : Add specific deep loading of Nodes and Properties
JCR-1843 : wrong status change upon conflicting removal (CacheBehaviour.OBSERVATION)
JCR-1293 : ReorderReferenceableSNSTest failure
JCR-1811 : ExportSysViewTest#testExportSysView_handler_session_saveBinary_occasionally failing


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@709211 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.util.ChildrenCollectorFilter;
-import org.apache.jackrabbit.value.ValueHelper;
-import org.apache.jackrabbit.spi.commons.value.ValueFormat;
-import org.apache.jackrabbit.spi.commons.conversion.NameException;
-import org.apache.jackrabbit.spi.Name;
-import org.apache.jackrabbit.spi.Path;
-import org.apache.jackrabbit.jcr2spi.state.NodeState;
-import org.apache.jackrabbit.jcr2spi.state.ItemStateValidator;
-import org.apache.jackrabbit.jcr2spi.state.Status;
-import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeManagerImpl;
-import org.apache.jackrabbit.jcr2spi.nodetype.EffectiveNodeType;
-import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeImpl;
-import org.apache.jackrabbit.jcr2spi.operation.SetMixin;
-import org.apache.jackrabbit.jcr2spi.operation.AddProperty;
-import org.apache.jackrabbit.jcr2spi.operation.AddNode;
-import org.apache.jackrabbit.jcr2spi.operation.ReorderNodes;
-import org.apache.jackrabbit.jcr2spi.operation.Operation;
-import org.apache.jackrabbit.jcr2spi.operation.Update;
-import org.apache.jackrabbit.jcr2spi.lock.LockManager;
-import org.apache.jackrabbit.jcr2spi.util.LogUtil;
-import org.apache.jackrabbit.jcr2spi.util.StateUtility;
-import org.apache.jackrabbit.jcr2spi.hierarchy.HierarchyEntry;
-import org.apache.jackrabbit.spi.QPropertyDefinition;
+import org.apache.jackrabbit.jcr2spi.lock.LockManager;
+import org.apache.jackrabbit.jcr2spi.nodetype.EffectiveNodeType;
+import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeImpl;
+import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeManagerImpl;
+import org.apache.jackrabbit.jcr2spi.operation.AddNode;
+import org.apache.jackrabbit.jcr2spi.operation.AddProperty;
+import org.apache.jackrabbit.jcr2spi.operation.Operation;
+import org.apache.jackrabbit.jcr2spi.operation.ReorderNodes;
+import org.apache.jackrabbit.jcr2spi.operation.SetMixin;
+import org.apache.jackrabbit.jcr2spi.operation.Update;
+import org.apache.jackrabbit.jcr2spi.state.ItemStateValidator;
+import org.apache.jackrabbit.jcr2spi.state.NodeState;
+import org.apache.jackrabbit.jcr2spi.state.Status;
+import org.apache.jackrabbit.jcr2spi.state.ItemState;
+import org.apache.jackrabbit.jcr2spi.util.LogUtil;
+import org.apache.jackrabbit.jcr2spi.util.StateUtility;
+import org.apache.jackrabbit.spi.Name;
+import org.apache.jackrabbit.spi.Path;
+import org.apache.jackrabbit.spi.QPropertyDefinition;
+import org.apache.jackrabbit.spi.commons.conversion.NameException;
+import org.apache.jackrabbit.spi.commons.value.ValueFormat;
+import org.apache.jackrabbit.util.ChildrenCollectorFilter;
+import org.apache.jackrabbit.value.ValueHelper;
-import javax.jcr.Item;
-import javax.jcr.Node;
-import javax.jcr.Property;
-import javax.jcr.RepositoryException;
-import javax.jcr.ItemNotFoundException;
-import javax.jcr.ItemVisitor;
+import javax.jcr.InvalidItemStateException;
+import javax.jcr.Item;
+import javax.jcr.ItemNotFoundException;
+import javax.jcr.ItemVisitor;
+import javax.jcr.NoSuchWorkspaceException;
+import javax.jcr.Node;
+import javax.jcr.NodeIterator;
+import javax.jcr.Property;
+import javax.jcr.PropertyIterator;
+import javax.jcr.PropertyType;
+import javax.jcr.RepositoryException;
-import javax.jcr.PropertyType;
-import javax.jcr.NodeIterator;
-import javax.jcr.PropertyIterator;
-import javax.jcr.InvalidItemStateException;
-import javax.jcr.NoSuchWorkspaceException;
+import javax.jcr.lock.Lock;
+import javax.jcr.lock.LockException;
-import javax.jcr.nodetype.NodeType;
-import javax.jcr.lock.LockException;
-import javax.jcr.lock.Lock;
-import javax.jcr.version.VersionException;
+import javax.jcr.nodetype.NodeType;
+import javax.jcr.version.VersionException;
-
-import java.util.Calendar;
-import java.util.List;
+import java.util.Calendar;
+import java.util.List;
-    protected NodeImpl(ItemManager itemMgr, SessionImpl session,
-                       NodeState state, ItemLifeCycleListener[] listeners) {
-        super(itemMgr, session, state, listeners);
+    protected NodeImpl(SessionImpl session, NodeState state, ItemLifeCycleListener[] listeners) {
+        super(session, state, listeners);
-        Path nodePath = getQPath(relPath);
+        Path nodePath = getQPath(relPath).getNormalizedPath();
-        Path parentPath = nodePath.getAncestor(1);
+
-        try {
-            Item parent = itemMgr.getItem(parentPath);
-            if (!parent.isNode()) {
+        if (nodePath.getLength() == 1) {
+            parentNode = this;
+        } else {
+            Path parentPath = nodePath.getAncestor(1);
+            ItemManager itemMgr = getItemManager();
+            if (itemMgr.nodeExists(parentPath)) {
+                parentNode = (NodeImpl) itemMgr.getNode(parentPath);
+            } else if (itemMgr.propertyExists(parentPath)) {
-            } else if (!(parent instanceof NodeImpl)) {
-                // should never occur
-                String msg = "Incompatible Node object: " + parent + "(" + safeGetJCRPath() + ")";
-                log.debug(msg);
-                throw new RepositoryException(msg);
-                parentNode = (NodeImpl) parent;
+                throw new PathNotFoundException("Cannot add a new node to a non-existing parent at " + LogUtil.safeGetJCRPath(parentPath, session.getPathResolver()));
-        } catch (AccessDeniedException ade) {
-            throw new PathNotFoundException(relPath);
-            return (Node) itemMgr.getItem(nodeEntry);
+            return (Node) getItemManager().getItem(nodeEntry);
-            return itemMgr.getChildNodes(getNodeEntry());
+            return getItemManager().getChildNodes(getNodeEntry());
-            return (Property) itemMgr.getItem(entry);
+            return (Property) getItemManager().getItem(entry);
-            return itemMgr.getChildProperties(getNodeEntry());
+            return getItemManager().getChildProperties(getNodeEntry());
-        return new LazyItemIterator(itemMgr, session.getHierarchyManager(), refs.iterator());
+        return new LazyItemIterator(getItemManager(), session.getHierarchyManager(), refs.iterator());
-        return (nodeEntry != null) && itemMgr.itemExists(nodeEntry);
+        return (nodeEntry != null) && getItemManager().itemExists(nodeEntry);
-        return (childEntry != null) && itemMgr.itemExists(childEntry);
+        return (childEntry != null) && getItemManager().itemExists(childEntry);
-        return itemMgr.hasChildNodes(getNodeEntry());
+        return getItemManager().hasChildNodes(getNodeEntry());
-        return itemMgr.hasChildProperties(getNodeEntry());
+        return getItemManager().hasChildProperties(getNodeEntry());
-            return (Version) itemMgr.getItem(newVersion);
+            return (Version) getItemManager().getItem(newVersion);
-        return new LazyItemIterator(itemMgr, session.getHierarchyManager(), failedIds);
+        return new LazyItemIterator(getItemManager(), session.getHierarchyManager(), failedIds);
-                if (!srcSession.getItemManager().itemExists(getQPath())) {
+                if (!srcSession.getItemManager().nodeExists(getQPath())) {
-            if (itemMgr.itemExists(parentPath)) {
-                Item parent = itemMgr.getItem(parentPath);
-                if (parent.isNode()) {
-                    Path relQPath = parentPath.computeRelativePath(nPath);
-                    NodeImpl parentNode = ((NodeImpl)parent);
-                    // call the restore
-                    restore(parentNode, relQPath, version, removeExisting);
-                } else {
-                    // the item at parentParentPath is Property
-                    throw new ConstraintViolationException("Cannot restore to a parent presenting a property (relative path = '" + relPath + "'");
-                }
+            ItemManager itemMgr = getItemManager();
+            if (itemMgr.nodeExists(parentPath)) {
+                Node parent = itemMgr.getNode(parentPath);
+                Path relQPath = parentPath.computeRelativePath(nPath);
+                NodeImpl parentNode = ((NodeImpl)parent);
+                // call the restore
+                restore(parentNode, relQPath, version, removeExisting);
+            } else if (itemMgr.propertyExists(parentPath)) {
+                // the item at parentParentPath is Property
+                throw new ConstraintViolationException("Cannot restore to a parent presenting a property (relative path = '" + relPath + "'");
-        return (Node) itemMgr.getItem(((NodeState) addedStates.get(0)).getHierarchyEntry());
+        ItemState nState = (ItemState) addedStates.get(0);
+        return (Node) getItemManager().getItem(nState.getHierarchyEntry());
-            return (Property) itemMgr.getItem(pEntry);
+            return (Property) getItemManager().getItem(pEntry);
-                HierarchyEntry entry = session.getHierarchyManager().getHierarchyEntry(p.getCanonicalPath());
-                if (entry.denotesNode()) {
-                    targetEntry = (NodeEntry) entry;
-                } // else:  not a node
+                targetEntry = session.getHierarchyManager().getNodeEntry(p.getCanonicalPath());
-                    HierarchyEntry entry = session.getHierarchyManager().getHierarchyEntry(p);
-                    if (!entry.denotesNode()) {
-                        targetEntry = (PropertyEntry) entry;
-                    } // else: not a property
+                    targetEntry = session.getHierarchyManager().getPropertyEntry(p);

fixed checking checked-out status according to spec

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@149506 13f79535-47bb-0310-9956-ffa450edef68

- *                     as applicable.
+  *                     as applicable.
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
+     * Same as {@link Node#isNodeType(String)}, but takes a <code>QName</code>
+     * instad of a <code>String</code>.
+     * @param ntName name of node type
+     * @return <code>true</code> if this node is of the specified node type;
+     *         otherwise <code>false</code>
+     */
+    public boolean isNodeType(QName ntName) throws RepositoryException {
+        // no need to perform sanity check; assume this has
+        // already been done by calling method
+
+        if (ntName.equals(nodeType.getQName())) {
+            return true;
+        }
+
+        if (nodeType.isDerivedFrom(ntName)) {
+            return true;
+        }
+
+        // check mixin types
+        Set mixinNames = ((NodeState) state).getMixinTypeNames();
+        if (mixinNames.isEmpty()) {
+            return false;
+        }
+        NodeTypeRegistry ntReg = session.getNodeTypeManager().getNodeTypeRegistry();
+        try {
+            EffectiveNodeType ent = ntReg.getEffectiveNodeType((QName[]) mixinNames.toArray(new QName[mixinNames.size()]));
+            return ent.includesNodeType(ntName);
+        } catch (NodeTypeConflictException ntce) {
+            String msg = "internal error: invalid mixin node type(s)";
+            log.error(msg, ntce);
+            throw new RepositoryException(msg, ntce);
+        }
+    }
+
+    /**
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-     * @see Node#isNodeType(String)
-     */
-    public boolean isNodeType(QName ntName) throws RepositoryException {
-        // check state of this instance
-        sanityCheck();
-
-        if (ntName.equals(nodeType.getQName())) {
-            return true;
-        }
-
-        if (nodeType.isDerivedFrom(ntName)) {
-            return true;
-        }
-
-        // check mixin types
-        Set mixinNames = ((NodeState) state).getMixinTypeNames();
-        if (mixinNames.isEmpty()) {
-            return false;
-        }
-        NodeTypeRegistry ntReg = session.getNodeTypeManager().getNodeTypeRegistry();
-        try {
-            EffectiveNodeType ent = ntReg.getEffectiveNodeType((QName[]) mixinNames.toArray(new QName[mixinNames.size()]));
-            return ent.includesNodeType(ntName);
-        } catch (NodeTypeConflictException ntce) {
-            String msg = "internal error: invalid mixin node type(s)";
-            log.error(msg, ntce);
-            throw new RepositoryException(msg, ntce);
-        }
-    }
-
-
-    /**
-        // check if versioning allows write
-        if (!isCheckedOut(true)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write
-        if (!isCheckedOut(true)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write
-        if (!isCheckedOut(true)) {
+        // check checked-out status
+        if (!internalIsCheckedOut()) {
-        // check if already checked out
-        if (isCheckedOut(false)) {
+        // check checked-out status
+        if (internalIsCheckedOut()) {
-        return isCheckedOut(true);
+        return internalIsCheckedOut();
-     * Same as {@link Node#isCheckedOut()} but if <code>inherit</code>
-     * is <code>true</code>, a non-versionable node will return the checked out
-     * state of its parent.
-     *
-     * @param inherit
+     * Determines the checked-out status of this node.
+     * @return a boolean
-    protected boolean isCheckedOut(boolean inherit) throws RepositoryException {
+    protected boolean internalIsCheckedOut() throws RepositoryException {
+        /**
+         * FIXME should not only rely on existence of jcr:isCheckedOut property
+         * but also verify that node.isNodeType("mix:versionable")==true;
+         * this would have a negative impact on performance though...
+         */
-            if (!inherit || node.isRepositoryRoot()) {
+            if (node.isRepositoryRoot()) {

Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.state.ItemState;
-import org.slf4j.LoggerFactory;
+import org.slf4j.LoggerFactory;
+import org.apache.jackrabbit.jcr2spi.hierarchy.HierarchyEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.HierarchyManager;
+import org.apache.jackrabbit.spi.ItemId;
-import javax.jcr.Item;
-import javax.jcr.Node;
-import javax.jcr.Property;
-import javax.jcr.RepositoryException;
+import javax.jcr.Item;
+import javax.jcr.RepositoryException;
+import javax.jcr.Node;
+import javax.jcr.Property;
+import javax.jcr.PathNotFoundException;
-import java.util.List;
-import java.util.Collection;
-import java.util.ArrayList;
+import java.util.List;
+import java.util.ArrayList;
-    /** the list of item states */
-    private final List stateList;
+    /** Iterator over HierarchyEntry elements */
+    private final Iterator iter;
-     * @param itemStates Collection of item states
+     * @param hierarchyEntryIterator Iterator over HierarchyEntries
-    public LazyItemIterator(ItemManager itemMgr, Collection itemStates) {
+    public LazyItemIterator(ItemManager itemMgr, Iterator hierarchyEntryIterator) {
-        this.stateList = new ArrayList(itemStates);
+        this.iter = hierarchyEntryIterator;
-        prefetchNext();
+        next = prefetchNext();
+    }
+
+    /**
+     * Creates a new <code>LazyItemIterator</code> instance.
+     *
+     * @param itemMgr
+     * @param hierarchyMgr
+     * @param itemIds
+     */
+    public LazyItemIterator(ItemManager itemMgr, HierarchyManager hierarchyMgr,
+                            Iterator itemIds)
+        throws PathNotFoundException, RepositoryException {
+        this.itemMgr = itemMgr;
+        List entries = new ArrayList();
+        while (itemIds.hasNext()) {
+            ItemId id = (ItemId) itemIds.next();
+            entries.add(hierarchyMgr.getHierarchyEntry(id));
+        }
+        this.iter = entries.iterator();
+
+        // prefetch first item
+        pos = 0;
+        next = prefetchNext();
-    private void prefetchNext() {
-        // reset
-        next = null;
-        while (next == null && pos < stateList.size()) {
-            ItemState state = (ItemState) stateList.get(pos);
+    private Item prefetchNext() {
+        Item nextItem = null;
+        while (nextItem == null && iter.hasNext()) {
+            HierarchyEntry entry = (HierarchyEntry) iter.next();
-                next = itemMgr.getItem(state);
+                nextItem = itemMgr.getItem(entry);
-                log.debug("ignoring nonexistent item " + state);
-                // remove invalid id
-                stateList.remove(pos);
-                // try next
+                log.debug("Ignoring nonexistent item " + entry);
+                // try the next
-                log.error("failed to fetch item " + state + ", skipping...", e);
-                // remove invalid id
-                stateList.remove(pos);
-                // try next
+                log.error("failed to fetch item " + entry + ", skipping...", e);
+                // try the next
+        return nextItem;
-        // Always returns -1, since the original list may contains items that
+        // Always returns -1, since the entry-iterator may contains items that
-        return UNDEFINED_SIZE;
+        return LazyItemIterator.UNDEFINED_SIZE;
-        // reset
-        next = null;
-            if (pos >= stateList.size()) {
-                // skipped past last item
-                throw new NoSuchElementException();
-            }
-            ItemState state = (ItemState) stateList.get(pos);
-            // eliminate invalid items from this iterator
-            while (!itemMgr.itemExists(state)) {
-                log.debug("ignoring nonexistent item " + state);
-                // remove invalid id
-                stateList.remove(pos);
-                if (pos >= stateList.size()) {
-                    // skipped past last item
-                    throw new NoSuchElementException();
-                }
-                state = (ItemState) stateList.get(pos);
-                // try next
-                continue;
+            HierarchyEntry entry = (HierarchyEntry) iter.next();
+            // check if item exists but don't build Item instance.
+            while (!itemMgr.itemExists(entry)) {
+                log.debug("Ignoring nonexistent item " + entry);
+                entry = (HierarchyEntry) iter.next();
-        prefetchNext();
+        next = prefetchNext();
-        prefetchNext();
+        next = prefetchNext();

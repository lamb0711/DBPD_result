JCR-1588 - JSR 283: Access Control (work in progress)
JCR-1590 - JSR 283: Locking
JCR-1915 - Node.setPrimaryNodeType should only redefine child-definitions that are not covered by the new effective nt
JCR-1875 - Failing Node.unlock() might leave inconsistent transient state
JCR-538 - Failing Node.checkin() or Node.checkout() might leave inconsistent transient state

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@732693 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.state.ChildNodeEntry;
-import org.apache.jackrabbit.core.state.ChildNodeEntry;
-                                "Item cannot be saved because it has been"
+                                "Item cannot be saved because it has been "
-                                "Item cannot be saved because it has been"
+                                "Item cannot be saved because it has been "
-                                "Item cannot be saved; it seems to have been"
+                                "Item cannot be saved; it seems to have been "
-         * - if it is 'modified' check the WRITE permission
+         * - if it is 'modified' or 'new' check the corresponding write permission.
-
-
-            if (itemState.getStatus() != ItemState.STATUS_NEW) {
-                /* transient item is not 'new', therefore it has to be 'modified'
-                   detect the effective set of modification:
-                   - child additions -> add_node perm on the child
-                   - property additions, modifications or removals -> set_property permission
+            ItemDefinition def;
+            if (itemState.isNode()) {
+                def = ntMgr.getNodeDefinition(((NodeState) itemState).getDefinitionId());
+            } else {
+                def = ntMgr.getPropertyDefinition(((PropertyState) itemState).getDefinitionId());
+            }
+            /* check permissions for non-protected items. protected items are
+               only added through API methods which need to assert that
+               permissions are not violated.
+             */
+            if (!def.isProtected()) {
+                /* detect the effective set of modification:
+                   - new added node -> add_node perm on the child
+                   - new property added -> set_property permission
+                   - property modified -> set_property permission
+                   - modified nodes can be ignored for changes only included
+                     child-item addition or removal or changes of protected
+                     properties such as mixin-types which are covered separately
-                // check WRITE permission
-                    // modified node state -> check possible modifications
-                    NodeState nState = (NodeState) itemState;
-                    for (Iterator it = nState.getAddedChildNodeEntries().iterator();
-                         it.hasNext() && isGranted;) {
-                        Name nodeName = ((ChildNodeEntry) it.next()).getName();
-                        isGranted = accessMgr.isGranted(path, nodeName, Permission.ADD_NODE);
-                    }
-                    for (Iterator it = nState.getAddedPropertyNames().iterator();
-                         it.hasNext() && isGranted;) {
-                        Name propName = (Name) it.next();
-                        isGranted = accessMgr.isGranted(path, propName, Permission.SET_PROPERTY);
-                    }
+                    if (itemState.getStatus() == ItemState.STATUS_NEW) {
+                        isGranted = accessMgr.isGranted(path, Permission.ADD_NODE);
+                    } // else: modified node (see comment above)
+                    // modified or new property: set_property permission
-                    String msg = itemMgr.safeGetJCRPath(path) + ": not allowed to modify item";
+                    String msg = itemMgr.safeGetJCRPath(path) + ": not allowed to add or modify item";
-                NodeDefinition def = ntMgr.getNodeDefinition(nodeState.getDefinitionId());
+                NodeDefinition nodeDef = (NodeDefinition) def;
-                    NodeType[] nta = def.getRequiredPrimaryTypes();
+                    NodeType[] nta = nodeDef.getRequiredPrimaryTypes();
-                PropertyDefinitionImpl def =
-                        ntMgr.getPropertyDefinition(propState.getDefinitionId());
+                PropertyDefinitionImpl propDef = (PropertyDefinitionImpl) def;
-                    String[] constraints = def.getValueConstraints();
+                    String[] constraints = propDef.getValueConstraints();
-                                    def.unwrap(), values);
+                                    propDef.unwrap(), values);
-                                && def.getRequiredType() == PropertyType.REFERENCE) {
+                                && propDef.getRequiredType() == PropertyType.REFERENCE) {
-            Path path = stateMgr.getAtticAwareHierarchyMgr().getPath(itemState.getId());
-            // check REMOVE permission
-            int permission = (itemState.isNode()) ? Permission.REMOVE_NODE : Permission.REMOVE_PROPERTY;
-            if (!accessMgr.isGranted(path, permission)) {
-                String msg = itemMgr.safeGetJCRPath(path)
-                        + ": not allowed to remove item";
-                log.debug(msg);
-                throw new AccessDeniedException(msg);
+            ItemDefinition def;
+            if (itemState.isNode()) {
+                def = ntMgr.getNodeDefinition(((NodeState) itemState).getDefinitionId());
+            } else {
+                def = ntMgr.getPropertyDefinition(((PropertyState) itemState).getDefinitionId());
+            }
+            if (!def.isProtected()) {
+                Path path = stateMgr.getAtticAwareHierarchyMgr().getPath(itemState.getId());
+                // check REMOVE permission
+                int permission = (itemState.isNode()) ? Permission.REMOVE_NODE : Permission.REMOVE_PROPERTY;
+                if (!accessMgr.isGranted(path, permission)) {
+                    String msg = itemMgr.safeGetJCRPath(path)
+                            + ": not allowed to remove item";
+                    log.debug(msg);
+                    throw new AccessDeniedException(msg);
+                }
-                        ChildNodeEntry cne =
-                                (ChildNodeEntry) cneIt.next();
+                        ChildNodeEntry cne = (ChildNodeEntry) cneIt.next();
-                        ChildNodeEntry cne =
-                                (ChildNodeEntry) cneIt.next();
+                        ChildNodeEntry cne = (ChildNodeEntry) cneIt.next();

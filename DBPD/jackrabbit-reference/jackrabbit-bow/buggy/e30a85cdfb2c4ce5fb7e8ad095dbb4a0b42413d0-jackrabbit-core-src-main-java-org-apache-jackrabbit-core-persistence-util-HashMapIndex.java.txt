JCR-2762: Optimize bundle serialization

Split HashMapIndex to an in-memory base class and a file-based subclass for easier testing.

Add basic test cases for HashMapIndex and BundleBinding. The goal is to ensure backwards compatibility of potential bundle serialization improvements.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1002775 13f79535-47bb-0310-9956-ffa450edef68

-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.util.Iterator;
-import java.util.Properties;
-
-import org.apache.jackrabbit.core.fs.FileSystemException;
-import org.apache.jackrabbit.core.fs.FileSystemResource;
- * Implements a {@link StringIndex} that is based on a hashmap and persists
- * the names as property file.
- * <p/>
- * Please note that this class is not synchronized and the calls need to ensure
- * thread safeness.
+ * Implements a {@link StringIndex} that is based on a hashmap. Subclasses
+ * can override the protected {@link #load()} and {@link #save()} methods
+ * to implement persistent storage of the string index.
+ * <p>
+ * This class is thread-safe.
-    private final HashMap<String, Integer> stringToIndex = new HashMap<String, Integer>();
+    protected final HashMap<String, Integer> stringToIndex =
+        new HashMap<String, Integer>();
-    private final HashMap<Integer, String> indexToString = new HashMap<Integer, String>();
+    protected final HashMap<Integer, String> indexToString =
+        new HashMap<Integer, String>();
-     * a copy of the {@link #stringToIndex} as properties class for faster
-     * storing.
+     * Loads the lookup table.
-    private final Properties stringToIndexProps = new Properties();
-
-    /**
-     * the filesystem resource that stores the lookup tables.
-     */
-    private FileSystemResource file;
-
-    /**
-     * the time when the resource was last modified.
-     */
-    private long lastModified = -1;
-
-    /**
-     * Creates a new hashmap index and loads the lookup tables from the
-     * filesystem resource. If it does not exist yet, it will create a new one.
-     *
-     * @param file the filesystem resource that stores the lookup tables.
-     *
-     * @throws IOException if an I/O error occurs.
-     * @throws FileSystemException if an I/O error occurs.
-     */
-    public HashMapIndex(FileSystemResource file)
-            throws FileSystemException, IOException {
-        this.file = file;
-        if (!file.exists()) {
-            file.makeParentDirs();
-            file.getOutputStream().close();
-        }
-        load();
+    protected void load() {
-     * Loads the lookup table from the filesystem resource.
-     *
-     * @throws IOException if an I/O error occurs.
-     * @throws FileSystemException if an I/O error occurs.
+     * Saves the lookup table.
-    private void load() throws IOException, FileSystemException {
-        long modTime = file.lastModified();
-        if (modTime > lastModified) {
-            InputStream in = file.getInputStream();
-            stringToIndexProps.clear();
-            stringToIndexProps.load(in);
-            Iterator<Object> iter = stringToIndexProps.keySet().iterator();
-            while (iter.hasNext()) {
-                String uri = (String) iter.next();
-                String prop = stringToIndexProps.getProperty(uri);
-                Integer idx = Integer.valueOf(prop);
-                stringToIndex.put(uri, idx);
-                indexToString.put(idx, uri);
-            }
-            in.close();
-        }
-        lastModified = modTime;
-    }
-
-    /**
-     * Saves the lookup table to the filesystem resource.
-     *
-     * @throws IOException if an I/O error occurs.
-     * @throws FileSystemException if an I/O error occurs.
-     */
-    private void save() throws IOException, FileSystemException {
-        OutputStream out = file.getOutputStream();
-        stringToIndexProps.store(out, "string index");
-        out.close();
-        lastModified = file.lastModified();
+    protected void save() {
-    public int stringToIndex(String nsUri) {
+    public synchronized int stringToIndex(String nsUri) {
-            try {
-                load();
-            } catch (Exception e) {
-                IllegalStateException ise = new IllegalStateException("Unable to load lookup table for uri: " + nsUri);
-                ise.initCause(e);
-                throw ise;
-            }
+            load();
-            stringToIndexProps.put(nsUri, idx.toString());
-            try {
-                save();
-            } catch (Exception e) {
-                IllegalStateException ise = new IllegalStateException("Unable to store lookup table for uri: "  + nsUri);
-                ise.initCause(e);
-                throw ise;
-            }
+            save();
-    public String indexToString(int i) {
+    public synchronized String indexToString(int i) {
-            try {
-                load();
-            } catch (Exception e) {
-                IllegalStateException ise = new IllegalStateException("Unable to load lookup table for index: " + i);
-                ise.initCause(e);
-                throw ise;
-            }
+            load();
+

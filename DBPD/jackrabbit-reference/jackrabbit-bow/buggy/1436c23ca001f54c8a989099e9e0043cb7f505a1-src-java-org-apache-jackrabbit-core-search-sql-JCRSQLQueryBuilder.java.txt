- Removed JCRQL implementation
- Added proper QName support to search
- redesigned parsing and formating of queries (better separation of abstract query tree and concrete syntax)
- Some improvements in SQL: colon is now supported in identifier without having to use double quotes, LIKE now supports escaping

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@125778 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.IllegalNameException;
+import org.apache.jackrabbit.core.UnknownPrefixException;
+import org.apache.jackrabbit.core.nodetype.NodeTypeRegistry;
-    private static final QName JCR_PATH = new QName(NamespaceRegistryImpl.NS_JCR_URI, "path");
+    static final QName JCR_PATH = new QName(NamespaceRegistryImpl.NS_JCR_URI, "path");
+    /** To resolve QNames */
+    private NamespaceResolver resolver;
+
-    /**
-     * The resolved jcr:path QName using the NamespaceResolver passed in the
-     * constructor.
-     */
-    private final String jcrPathResolved;
+    public JCRSQLQueryBuilder() {
+        stmt = null;
+    }
-     * @throws NoPrefixDeclaredException if a prefix in the statement cannot
-     *   be resolved.
-    private JCRSQLQueryBuilder(ASTQuery statement, NamespaceResolver resolver)
-            throws NoPrefixDeclaredException {
+    private JCRSQLQueryBuilder(ASTQuery statement, NamespaceResolver resolver) {
-        jcrPathResolved = JCR_PATH.toJCRName(resolver);
+        this.resolver = resolver;
-            JCRSQLQueryBuilder builder = new JCRSQLQueryBuilder(JCRSQLParser.parse(statement), resolver);
+            JCRSQLQueryBuilder builder = new JCRSQLQueryBuilder(JCRSQLParser.parse(statement, resolver), resolver);
-        } catch (NoPrefixDeclaredException e) {
+        } catch (IllegalArgumentException e) {
+     * Creates a String representation of the query node tree in SQL syntax.
+     * @param root the root of the query node tree.
+     * @param resolver to resolve QNames.
+     * @return a String representation of the query node tree.
+     * @throws InvalidQueryException if the query node tree cannot be converted
+     *   into a String representation due to restrictions in SQL.
+     */
+    public static String toString(QueryRootNode root, NamespaceResolver resolver)
+            throws InvalidQueryException {
+        return QueryFormat.toString(root, resolver);
+    }
+
+    /**
-            pathNode.addPathStep(new LocationStepQueryNode(pathNode, "", false));
+            pathNode.addPathStep(new LocationStepQueryNode(pathNode, new QName("", ""), false));
-                // node is either primary or mixin node type
-                NodeTypeQueryNode nodeType
-                        = new NodeTypeQueryNode(constraintNode, node.getName());
-                constraintNode.addOperand(nodeType);
+                try {
+                    if (!node.getName().equals(NodeTypeRegistry.NT_BASE.toJCRName(resolver))) {
+                        // node is either primary or mixin node type
+                        NodeTypeQueryNode nodeType
+                                = new NodeTypeQueryNode(constraintNode, node.getName());
+                        constraintNode.addOperand(nodeType);
+                    }
+                } catch (NoPrefixDeclaredException e) {
+                    throw new IllegalArgumentException("No prefix declared for name: " + node.getName());
+                }
-        String identifier = ((ASTIdentifier) node.children[0]).getName();
-        if (identifier.equals(jcrPathResolved)) {
-            if (node.children[1] instanceof ASTIdentifier) {
-                // simply ignore, this is a join of a mixin node type
-            } else {
-                createPathQuery(((ASTLiteral) node.children[1]).getValue());
-            }
-            // done
-            return data;
-        }
-
+            QName identifier = ((ASTIdentifier) node.children[0]).getName();
+            if (identifier.equals(JCR_PATH)) {
+                if (node.children[1] instanceof ASTIdentifier) {
+                    // simply ignore, this is a join of a mixin node type
+                } else {
+                    createPathQuery(((ASTLiteral) node.children[1]).getValue());
+                }
+                // done
+                return data;
+            }
+
-                    || type == Constants.OPERATION_LIKE
+            } else if (type == Constants.OPERATION_LIKE) {
+                ASTLiteral pattern = (ASTLiteral) node.children[1];
+                if (node.getEscapeString() != null) {
+                    if (node.getEscapeString().length() == 1) {
+                        // backslash is the escape character we use internally
+                        pattern.setValue(translateEscaping(pattern.getValue(), node.getEscapeString().charAt(0), '\\'));
+                    } else {
+                        throw new IllegalArgumentException("ESCAPE string value must have length 1: '" + node.getEscapeString() + "'");
+                    }
+                } else {
+                    // no escape character specified.
+                    // if the pattern contains any backslash characters we need
+                    // to escape them.
+                    pattern.setValue(pattern.getValue().replaceAll("\\\\", "\\\\\\\\"));
+                }
+                predicateNode = createRelationQueryNode(parent,
+                        identifier, type, pattern);
-                star.setValue("*");
+                star.setValue("%");
-        } catch (IllegalArgumentException e) {
-            log.error(e.toString());
-            log.error("Too few arguments");
+            throw new IllegalArgumentException("Too few arguments in predicate");
+        // list of QNames
+
-        String[] props = (String[]) identifiers.toArray(new String[identifiers.size()]);
+        QName[] props = (QName[]) identifiers.toArray(new QName[identifiers.size()]);
-                                                      String propertyName,
+                                                      QName propertyName,
-                // @todo convert % and _ into * and ? if opType is LIKE
-                // @todo take care of escaping!
-                    pathNode.addPathStep(new LocationStepQueryNode(pathNode, "", false));
+                    pathNode.addPathStep(new LocationStepQueryNode(pathNode, new QName("", ""), false));
-                    try {
-                        index = Integer.parseInt(suffix.substring(1, suffix.length() - 1));
-                    } catch (NumberFormatException e) {
-                        log.warn("Unable to parse index for path element: " + names[i]);
+                    String indexStr = suffix.substring(1, suffix.length() - 1);
+                    if (indexStr.equals("%")) {
+                        // select all same name siblings
+                        index = 0;
+                    } else {
+                        try {
+                            index = Integer.parseInt(indexStr);
+                        } catch (NumberFormatException e) {
+                            log.warn("Unable to parse index for path element: " + names[i]);
+                        }
+                    // in SQL this means index 1
+                    index = 1;
+                QName qName = null;
+                if (name != null) {
+                    try {
+                        qName = QName.fromJCRName(name, resolver);
+                    } catch (IllegalNameException e) {
+                        throw new IllegalArgumentException("Illegal name: " + name);
+                    } catch (UnknownPrefixException e) {
+                        throw new IllegalArgumentException("Unknown prefix: " + name);
+                    }
+                }
-                LocationStepQueryNode step = new LocationStepQueryNode(pathNode, name, false);
+                LocationStepQueryNode step = new LocationStepQueryNode(pathNode, qName, false);
+    /**
+     * Translates a pattern using the escape character <code>from</code> into
+     * a pattern using the escape character <code>to</code>.
+     * @param pattern the pattern to translate
+     * @param from the currently used escape character.
+     * @param to the new escape character to use.
+     * @return the new pattern using the escape character <code>to</code>.
+     */
+    private static String translateEscaping(String pattern, char from, char to) {
+        // if escape characters are the same OR pattern does not contain any
+        // escape characters -> simply return pattern as is.
+        if (from == to || (pattern.indexOf(from) < 0 && pattern.indexOf(to) < 0)) {
+            return pattern;
+        }
+        StringBuffer translated = new StringBuffer(pattern.length());
+        boolean escaped = false;
+        for (int i = 0; i < pattern.length(); i++) {
+            if (pattern.charAt(i) == from) {
+                if (escaped) {
+                    translated.append(from);
+                    escaped = false;
+                } else {
+                    escaped = true;
+                }
+            } else if (pattern.charAt(i) == to) {
+                if (escaped) {
+                    translated.append(to).append(to);
+                    escaped = false;
+                } else {
+                    translated.append(to).append(to);
+                }
+            } else {
+                if (escaped) {
+                    translated.append(to);
+                    escaped = false;
+                }
+                translated.append(pattern.charAt(i));
+            }
+        }
+        return translated.toString();
+    }
+

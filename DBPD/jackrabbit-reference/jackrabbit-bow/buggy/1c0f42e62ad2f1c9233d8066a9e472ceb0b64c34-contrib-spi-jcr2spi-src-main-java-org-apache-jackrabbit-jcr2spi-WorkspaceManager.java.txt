- replace all EventIterator return values in RepositoryService with EventBundle[]
- remove RepositoryService.addEventListener()/removeEventListener() and introduce getEvents() instead
- added quick description of new design: see org/apache/jackrabbit/spi/package.html
- update spi/project.properties with correct links to external javadoc
- fix package in spi/project.xml


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@468388 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.util.IteratorHelper;
-import org.apache.jackrabbit.spi.EventListener;
-import org.apache.jackrabbit.spi.EventIterator;
-import org.apache.jackrabbit.spi.Event;
+import org.apache.jackrabbit.spi.EventBundle;
+    /**
+     * TODO: make configurable
+     */
+    private static final int EXTERNAL_EVENT_POLLING_INTERVAL = 3 * 1000;
+
-     * This is the event listener that listens on the repository service
-     * for external changes. If <code>null</code> then the underlying repository
-     * service does not support observation.
+     * Monitor object to synchronize the external feed thread with client
+     * threads that call {@link #execute(Operation)} or {@link
+     * #execute(ChangeLog)}.
-    private final EventListener externalChangeListener;
+    private final Object updateMonitor = new Object();
+
+    /**
+     * This is the event polling for external changes. If <code>null</code>
+     * then the underlying repository service does not support observation.
+     */
+    private final Thread externalChangeFeed;
-        externalChangeListener = createChangeListener(repositoryDescriptors);
+        externalChangeFeed = createChangeFeed(repositoryDescriptors, EXTERNAL_EVENT_POLLING_INTERVAL);
-     * Creates and registers an EventListener on the RepositoryService that
-     * listens for external changes.
+     * Creates a background thread which polls for external changes on the
+     * RepositoryService.
-     * @param descriptors the repository descriptors
-     * @return the listener or <code>null</code> if the underlying
+     * @param descriptors the repository descriptors.
+     * @param pollingInterval the polling interval in milliseconds.
+     * @return the background polling thread or <code>null</code> if the underlying
-     * @throws RepositoryException if an error occurs while registering the
-     *                             event listener.
-    private EventListener createChangeListener(Properties descriptors) throws RepositoryException {
+    private Thread createChangeFeed(Properties descriptors, int pollingInterval) {
-        EventListener l = null;
+        Thread t = null;
-            l = new EventListener() {
-                public void onEvent(EventIterator events) {
-                    // external change
-                    onEventReceived(events, false, null);
-                }
-            };
-            // register for all non-local events
-            service.addEventListener(sessionInfo, service.getRootId(sessionInfo),
-                l, Event.ALL_TYPES, true, null, null);
+            t = new Thread(new ExternalChangePolling(pollingInterval));
+            t.setName("External Change Polling");
+            t.setDaemon(true);
+            t.start();
-        return l;
+        return t;
-        new OperationVisitorImpl(sessionInfo).execute(operation);
+        synchronized (updateMonitor) {
+            new OperationVisitorImpl(sessionInfo).execute(operation);
+        }
-        new OperationVisitorImpl(sessionInfo).execute(changes);
+        synchronized (updateMonitor) {
+            new OperationVisitorImpl(sessionInfo).execute(changes);
+        }
-        if (externalChangeListener != null) {
+        if (externalChangeFeed != null) {
+            externalChangeFeed.interrupt();
-                service.removeEventListener(sessionInfo, service.getRootId(sessionInfo), externalChangeListener);
-            } catch (RepositoryException e) {
-                log.warn("Exception while disposing workspace manager: " + e);
+                externalChangeFeed.join();
+            } catch (InterruptedException e) {
+                log.warn("Interrupted while waiting for external change thread to terminate.");
+     *                  response to the executed operation(s).
-    private void onEventReceived(EventIterator events, boolean isLocal,
-                                 ChangeLog changeLog) {
+    private void onEventReceived(EventBundle[] events, ChangeLog changeLog) {
-        // need to copy events into a list because we notify multiple listeners
-        List eventList = new ArrayList();
-        while (events.hasNext()) {
-            Event e = events.nextEvent();
-            eventList.add(e);
-        }
-        if (eventList.isEmpty()) {
-            return;
-        }
-
-        if (changeLog == null) {
-            for (int i = 0; i < lstnrs.length; i++) {
-                lstnrs[i].onEvent(new EventIteratorImpl(eventList), isLocal);
-            }
-        } else {
-            for (int i = 0; i < lstnrs.length; i++) {
-                lstnrs[i].onEvent(new EventIteratorImpl(eventList), changeLog);
+        for (int i = 0; i < events.length; i++) {
+            EventBundle bundle = events[i];
+            if (bundle.isLocal() && changeLog != null) {
+                // local change from batch operation
+                for (int j = 0; j < lstnrs.length; j++) {
+                    lstnrs[j].onEvent(bundle, changeLog);
+                }
+            } else {
+                // external change or workspace operation
+                for (int j = 0; j < lstnrs.length; j++) {
+                    lstnrs[j].onEvent(bundle);
+                }
-        private EventIterator events;
+        private EventBundle[] events;
-                    onEventReceived(events, true, changeLog);
+                    onEventReceived(events, changeLog);
-                    onEventReceived(events, true, null);
+                    onEventReceived(events, null);
-            // todo: improve.... inform operation about modified items (build mergefailed iterator)
-            operation.getEventListener().onEvent(events, true);
+            List externalEventBundles = new ArrayList();
+            for (int i = 0; i < events.length; i++) {
+                if (events[i].isLocal()) {
+                    // todo: improve.... inform operation about modified items (build mergefailed iterator)
+                    operation.getEventListener().onEvent(events[i]);
+                } else {
+                    // otherwise dispatch as external event
+                    externalEventBundles.add(events[i]);
+                }
+            }
+            if (!externalEventBundles.isEmpty()) {
+                EventBundle[] bundles = (EventBundle[]) externalEventBundles.toArray(new EventBundle[externalEventBundles.size()]);
+                onEventReceived(bundles, null);
+            }
-    private static final class EventIteratorImpl extends IteratorHelper implements EventIterator {
+    /**
+     * Implements the polling for external changes on the repository service.
+     */
+    private final class ExternalChangePolling implements Runnable {
-        public EventIteratorImpl(Collection c) {
-            super(c);
+        /**
+         * The polling interval in milliseconds.
+         */
+        private final int pollingInterval;
+
+        /**
+         * Creates a new external change polling with a given polling interval.
+         *
+         * @param pollingInterval the interval in milliseconds.
+         */
+        private ExternalChangePolling(int pollingInterval) {
+            this.pollingInterval = pollingInterval;
-        public Event nextEvent() {
-            return (Event) next();
+        public void run() {
+            while (!Thread.interrupted()) {
+                try {
+                    Thread.sleep(pollingInterval);
+                } catch (InterruptedException e) {
+                    // terminate
+                    break;
+                }
+                try {
+                    synchronized (updateMonitor) {
+                        EventBundle[] bundles = service.getEvents(sessionInfo, 0);
+                        if (bundles.length > 0) {
+                            onEventReceived(bundles, null);
+                        }
+                    }
+                } catch (RepositoryException e) {
+                    log.warn("Exception while retrieving event bundles: " + e);
+                    log.debug("Dump:", e);
+                }
+            }

JCR-131: simplifying internal data model (NodeState) by limiting a node to *one* parent



git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@191499 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.List;
-
-        // remove from old parent
+            // change child node entry
-            target.removeParentUUID(srcParent.getUUID());
-            target.addParentUUID(destParent.getUUID());
-
-            destParent.addChildNodeEntry(destName.getName(), target.getUUID());
+            // remove child node entry from old parent
+            // re-parent target node
+            target.setParentUUID(destParent.getUUID());
+            // add child node entry to new parent
+            destParent.addChildNodeEntry(destName.getName(), target.getUUID());
-        NodeState parent = getNodeState(parentId);
-        // 3. do remove operation (modify and store affected states)
+        // 3. do remove operation
-        // unlink node state from its parent
-        unlinkNodeState(target, target.getParentUUID());
-        // remove child node entries
-        // use temp array to avoid ConcurrentModificationException
-        ArrayList tmp =
-                new ArrayList(parent.getChildNodeEntries(target.getUUID()));
-        // remove from tail to avoid problems with same-name siblings
-        for (int i = tmp.size() - 1; i >= 0; i--) {
-            NodeState.ChildNodeEntry entry = (NodeState.ChildNodeEntry) tmp.get(i);
-            parent.removeChildNodeEntry(entry.getName(), entry.getIndex());
-        }
-        // store parent
-        stateMgr.store(parent);
+        removeNodeState(target);
-     * Checks if removing the given target node entirely (i.e. unlinking from
-     * all its parents) is allowed in the current context.
+     * Checks if removing the given target node is allowed in the current context.
-        List parentUUIDs = targetState.getParentUUIDs();
-        Iterator iter = parentUUIDs.iterator();
-        while (iter.hasNext()) {
-            NodeId parentId = new NodeId((String) iter.next());
-            checkRemoveNode(targetState, parentId, options);
-        }
+        NodeId parentId = new NodeId(targetState.getParentUUID());
+        checkRemoveNode(targetState, parentId, options);
-     * Unlinks the specified node state from all its parents and recursively
+     * Unlinks the specified node state from its parent and recursively
-     * Note that access rights are <b><i>not</i></b> enforced!
+     * Note that no checks (access rights etc.) are performed on the specified
+     * target node state. Those checks have to be performed beforehand by the
+     * caller. However, the (recursive) removal of target node's child nodes are
+     * subject to the following checks: access rights, locking, versioning.
-     * @param targetState
+     * @param target
-    public void removeNodeState(NodeState targetState)
+    public void removeNodeState(NodeState target)
-        // copy list to avoid ConcurrentModificationException
-        ArrayList parentUUIDs = new ArrayList(targetState.getParentUUIDs());
-        Iterator iter = parentUUIDs.iterator();
-        while (iter.hasNext()) {
-            String parentUUID = (String) iter.next();
-            NodeId parentId = new NodeId(parentUUID);
-
-            // unlink node state from this parent
-            unlinkNodeState(targetState, parentUUID);
-
-            // remove child node entries
-            NodeState parent = getNodeState(parentId);
-            // use temp array to avoid ConcurrentModificationException
-            ArrayList tmp =
-                    new ArrayList(parent.getChildNodeEntries(targetState.getUUID()));
-            // remove from tail to avoid problems with same-name siblings
-            for (int i = tmp.size() - 1; i >= 0; i--) {
-                NodeState.ChildNodeEntry entry = (NodeState.ChildNodeEntry) tmp.get(i);
-                parent.removeChildNodeEntry(entry.getName(), entry.getIndex());
-            }
-            // store parent
-            stateMgr.store(parent);
+        String parentUUID = target.getParentUUID();
+        if (parentUUID == null) {
+            String msg = "root node cannot be removed";
+            log.debug(msg);
+            throw new RepositoryException(msg);
+        NodeId parentId = new NodeId(parentUUID);
+
+        NodeState parent = getNodeState(parentId);
+        // remove child node entry from parent
+        parent.removeChildNodeEntry(target.getUUID());
+        // store parent
+        stateMgr.store(parent);
+
+        // remove target
+        recursiveRemoveNodeState(target);
-     * Unlinks the given node state from the specified parent i.e. removes
-     * <code>parentUUID</code> from its list of parents. If as a result
-     * the given node state would be orphaned it will be recursively removed
-     * including its properties and child nodes.
+     * Recursively removes the given node state including its properties and
+     * child nodes.
+     * <p/>
+     * The removal of child nodes is subject to the following checks:
+     * access rights, locking & versioning status. Referential integrity
+     * (references) is checked on commit.
-     * parent denoted by <code>parentUUID</code>.
+     * parent.
-     * @param parentUUID
-    private void unlinkNodeState(NodeState targetState, String parentUUID)
+    private void recursiveRemoveNodeState(NodeState targetState)
-        // check if this node state would be orphaned after unlinking it from parent
-        ArrayList parentUUIDs = new ArrayList(targetState.getParentUUIDs());
-        parentUUIDs.remove(parentUUID);
-        boolean orphaned = parentUUIDs.isEmpty();
-
-        if (orphaned) {
-            // remove child nodes
-            // use temp array to avoid ConcurrentModificationException
-            ArrayList tmp = new ArrayList(targetState.getChildNodeEntries());
-            // remove from tail to avoid problems with same-name siblings
-            for (int i = tmp.size() - 1; i >= 0; i--) {
-                NodeState.ChildNodeEntry entry = (NodeState.ChildNodeEntry) tmp.get(i);
-                NodeId nodeId = new NodeId(entry.getUUID());
-                try {
-                    NodeState nodeState = (NodeState) stateMgr.getItemState(nodeId);
-                    // check if child node can be removed
-                    // (access rights, locking & versioning status)
-                    checkRemoveNode(nodeState, (NodeId) targetState.getId(),
-                            CHECK_ACCESS | CHECK_LOCK | CHECK_VERSIONING);
-                    // unlink child node (recursive)
-                    unlinkNodeState(nodeState, targetState.getUUID());
-                } catch (ItemStateException ise) {
-                    String msg = "internal error: failed to retrieve state of "
-                            + nodeId;
-                    log.debug(msg);
-                    throw new RepositoryException(msg, ise);
-                }
-                // remove child node entry
-                targetState.removeChildNodeEntry(entry.getName(), entry.getIndex());
+        // remove child nodes
+        // use temp array to avoid ConcurrentModificationException
+        ArrayList tmp = new ArrayList(targetState.getChildNodeEntries());
+        // remove from tail to avoid problems with same-name siblings
+        for (int i = tmp.size() - 1; i >= 0; i--) {
+            NodeState.ChildNodeEntry entry = (NodeState.ChildNodeEntry) tmp.get(i);
+            NodeId nodeId = new NodeId(entry.getUUID());
+            try {
+                NodeState nodeState = (NodeState) stateMgr.getItemState(nodeId);
+                // check if child node can be removed
+                // (access rights, locking & versioning status);
+                // referential integrity (references) is checked
+                // on commit
+                checkRemoveNode(nodeState, (NodeId) targetState.getId(),
+                        CHECK_ACCESS
+                        | CHECK_LOCK
+                        | CHECK_VERSIONING);
+                // remove child node
+                recursiveRemoveNodeState(nodeState);
+            } catch (ItemStateException ise) {
+                String msg = "internal error: failed to retrieve state of "
+                        + nodeId;
+                log.debug(msg);
+                throw new RepositoryException(msg, ise);
+            // remove child node entry
+            targetState.removeChildNodeEntry(entry.getName(), entry.getIndex());
+        }
-            // remove properties
-            // use temp array to avoid ConcurrentModificationException
-            tmp = new ArrayList(targetState.getPropertyEntries());
-            for (int i = 0; i < tmp.size(); i++) {
-                NodeState.PropertyEntry entry = (NodeState.PropertyEntry) tmp.get(i);
-                PropertyId propId =
-                        new PropertyId(targetState.getUUID(), entry.getName());
-                try {
-                    PropertyState propState =
-                            (PropertyState) stateMgr.getItemState(propId);
-                    // remove property entry
-                    targetState.removePropertyEntry(propId.getName());
-                    // destroy property state
-                    stateMgr.destroy(propState);
-                } catch (ItemStateException ise) {
-                    String msg = "internal error: failed to retrieve state of "
-                            + propId;
-                    log.debug(msg);
-                    throw new RepositoryException(msg, ise);
-                }
+        // remove properties
+        // use temp array to avoid ConcurrentModificationException
+        tmp = new ArrayList(targetState.getPropertyEntries());
+        for (int i = 0; i < tmp.size(); i++) {
+            NodeState.PropertyEntry entry = (NodeState.PropertyEntry) tmp.get(i);
+            PropertyId propId =
+                    new PropertyId(targetState.getUUID(), entry.getName());
+            try {
+                PropertyState propState =
+                        (PropertyState) stateMgr.getItemState(propId);
+                // remove property entry
+                targetState.removePropertyEntry(propId.getName());
+                // destroy property state
+                stateMgr.destroy(propState);
+            } catch (ItemStateException ise) {
+                String msg = "internal error: failed to retrieve state of "
+                        + propId;
+                log.debug(msg);
+                throw new RepositoryException(msg, ise);
-        // now actually do unlink target state from specified parent state
-        // (i.e. remove uuid of parent state from target state's parent list)
-        targetState.removeParentUUID(parentUUID);
-
-        if (orphaned) {
-            // destroy target state (pass overlayed state since target state
-            // might have been modified during unlinking)
-            stateMgr.destroy(targetState.getOverlayedState());
-        } else {
-            // store target state
-            stateMgr.store(targetState);
-        }
+        // now actually do unlink target state
+        targetState.setParentUUID(null);
+        // destroy target state (pass overlayed state since target state
+        // might have been modified during unlinking)
+        stateMgr.destroy(targetState.getOverlayedState());
-                        checkRemoveNode(existingState, CHECK_ACCESS | CHECK_LOCK
-                                | CHECK_VERSIONING | CHECK_CONSTRAINTS);
-
+                        // (access rights, locking & versioning status,
+                        // node type constraints)
+                        checkRemoveNode(existingState,
+                                CHECK_ACCESS
+                                | CHECK_LOCK
+                                | CHECK_VERSIONING
+                                | CHECK_CONSTRAINTS);

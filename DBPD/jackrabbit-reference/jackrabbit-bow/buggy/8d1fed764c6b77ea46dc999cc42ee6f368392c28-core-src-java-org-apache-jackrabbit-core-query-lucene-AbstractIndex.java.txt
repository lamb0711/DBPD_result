JCR-178: Allow concurrent index updates and queries

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@232801 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.BitSet;
+ * <p/>
+ * Note on synchronization: This class is not entirely thread-safe. Certain
+ * concurrent access is however allowed. Read-only access on this index using
+ * {@link #getReadOnlyIndexReader()} is thread-safe. That is, multiple threads
+ * my call that method concurrently and use the returned IndexReader at the same
+ * time.<br/>
+ * Modifying threads must be synchronized externally in a way that only one
+ * thread is using the returned IndexReader and IndexWriter instances returned
+ * by {@link #getIndexReader()} and {@link #getIndexWriter()} at a time.<br/>
+ * Concurrent access by <b>one</b> modifying thread and multiple read-only
+ * threads is safe!
-    /** The currently set IndexReader of <code>null</code> if none is set */
-    private IndexReader indexReader;
+    /** The currently set IndexReader or <code>null</code> if none is set */
+    private CommittableIndexReader indexReader;
+    /** The shared IndexReader for all read-only IndexReaders */
+    private SharedIndexReader sharedReader;
+
-     * Adds a document to this index.
+     * Adds a document to this index and invalidates the shared reader.
+     *
+        invalidateSharedReader();
-     * Removes the document from this index.
+     * Removes the document from this index. This call will not invalidate
+     * the shared reader. If a subclass whishes to do so, it should overwrite
+     * this method and call {@link #invalidateSharedReader()}.
+     *
-     * Returns an <code>IndexReader</code> on this index.
+     * Returns an <code>IndexReader</code> on this index. This index reader
+     * may be used to delete documents.
+     *
-            indexReader = IndexReader.open(getDirectory());
-            if (useCachingReader()) {
-                indexReader = new CachingIndexReader(indexReader);
-            }
+            indexReader = new CommittableIndexReader(IndexReader.open(getDirectory()));
+     * Returns a read-only index reader, that can be used concurrently with
+     * other threads writing to this index. The returned index reader is
+     * read-only, that is, any attempt to delete a document from the index
+     * will throw an <code>UnsupportedOperationException</code>.
+     *
+     * @return a read-only index reader.
+     * @throws IOException if an error occurs while obtaining the index reader.
+     */
+    protected synchronized ReadOnlyIndexReader getReadOnlyIndexReader()
+            throws IOException {
+        // get current modifiable index reader
+        IndexReader modifiableReader = getIndexReader();
+        // capture snapshot of deleted documents
+        BitSet deleted = new BitSet(modifiableReader.maxDoc());
+        for (int i = 0; i < modifiableReader.maxDoc(); i++) {
+            if (modifiableReader.isDeleted(i)) {
+                deleted.set(i);
+            }
+        }
+        if (sharedReader == null) {
+            // create new shared reader
+            sharedReader = new SharedIndexReader(new CachingIndexReader(IndexReader.open(getDirectory())));
+        }
+        return new ReadOnlyIndexReader(sharedReader, deleted);
+    }
+
+
+    /**
-            if (indexReader instanceof CachingIndexReader) {
-                // only commit changes, do not close
-                log.debug("committing IndexReader.");
-                ((CachingIndexReader) indexReader).commitDeleted();
-            } else {
-                indexReader.close();
-                indexReader = null;
-            }
+            indexReader.commitDeleted();
-    void close() {
+    synchronized void close() {
+        if (sharedReader != null) {
+            try {
+                sharedReader.close();
+            } catch (IOException e) {
+                log.warn("Exception closing index reader: " + e.toString());
+            }
+        }
-     * Returns <code>true</code> if this index should use a
-     * {@link CachingIndexReader}, <code>false</code> otherwise.
-     * @return <code>true</code> if index reader should use caching.
+     * Closes the shared reader.
+     *
+     * @throws IOException if an error occurs while closing the reader.
-    protected boolean useCachingReader() {
-        return false;
+    protected synchronized void invalidateSharedReader() throws IOException {
+        // invalidate shared reader
+        if (sharedReader != null) {
+            sharedReader.close();
+            sharedReader = null;
+        }

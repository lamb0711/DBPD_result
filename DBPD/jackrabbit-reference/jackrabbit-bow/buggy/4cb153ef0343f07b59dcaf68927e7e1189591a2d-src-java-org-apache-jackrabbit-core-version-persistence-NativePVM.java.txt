- adding versioning configuratuin
- adapting versioning to new persistence manager api

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@126386 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.collections.ReferenceMap;
-import org.apache.jackrabbit.core.*;
-import org.apache.jackrabbit.core.nodetype.NodeDefId;
-import org.apache.jackrabbit.core.nodetype.NodeTypeManagerImpl;
-import org.apache.jackrabbit.core.nodetype.NodeTypeRegistry;
-import org.apache.jackrabbit.core.state.ItemStateException;
-import org.apache.jackrabbit.core.state.ItemStateManager;
-import org.apache.jackrabbit.core.state.NodeState;
-import org.apache.jackrabbit.core.state.UpdateOperation;
-import org.apache.jackrabbit.core.util.uuid.UUID;
-import org.apache.jackrabbit.core.version.*;
+import org.apache.jackrabbit.core.version.*;
+import org.apache.jackrabbit.core.*;
+import org.apache.jackrabbit.core.util.uuid.UUID;
+import org.apache.jackrabbit.core.nodetype.NodeTypeRegistry;
+import org.apache.jackrabbit.core.state.*;
+import org.apache.commons.collections.ReferenceMap;
+import javax.jcr.version.VersionException;
-import java.util.Iterator;
+import java.util.Iterator;
- * <p/>
+ * <p>
- * <p/>
+ * <p>
- * <p/>
+ * <p>
-    private ItemStateManager stateMgr;
-
-    /**
-     * the nodetype manager for the version storage
-     */
-    private NodeTypeManagerImpl ntMgr;
+    private NativeItemStateManager stateMgr;
-    private HashMap idsByInternal = new HashMap();
+    private HashMap idsByInternal= new HashMap();
-     * @param session
+     * @param pMgr
+     * @param ntReg
-    public NativePVM(SessionImpl session) throws RepositoryException {
-        this.stateMgr = ((WorkspaceImpl) session.getWorkspace()).getItemStateManager();
-        this.ntMgr = session.getNodeTypeManager();
-
+    public NativePVM(PersistenceManager pMgr, NodeTypeRegistry ntReg) throws RepositoryException {
-            NodeImpl systemRoot = ((RepositoryImpl) session.getRepository()).getSystemRootNode(session);
-            // enable this to make the persistence storage visible
-            if (true) {
-                // check for versionhistory root
-                if (!systemRoot.hasNode(VERSION_HISTORY_ROOT_NAME)) {
-                    // if not exist, create
-                    systemRoot.addNode(VERSION_HISTORY_ROOT_NAME, NodeTypeRegistry.NT_UNSTRUCTURED);
-                    systemRoot.save();
-                }
-                NodeState nodeState = (NodeState) stateMgr.getItemState(new NodeId(systemRoot.getNode(VERSION_HISTORY_ROOT_NAME).internalGetUUID()));
-                historyRoot = new PersistentNode(stateMgr, ntMgr, nodeState);
-            } else {
-                if (!stateMgr.hasItemState(PERSISTENT_ROOT_ID)) {
-                    UpdateOperation update = stateMgr.beginUpdate();
-                    NodeState nodeState = update.createNew(PERSISTENT_ROOT_ID.getUUID(), NodeTypeRegistry.NT_UNSTRUCTURED, null);
-                    nodeState.setDefinitionId(new NodeDefId(ntMgr.getRootNodeDefinition().unwrap()));
-                    // persist state
-                    update.store(nodeState);
-                    // finish update operation
-                    update.end();
-                    historyRoot = new PersistentNode(stateMgr, ntMgr, nodeState);
-                } else {
-                    NodeState nodeState = (NodeState) stateMgr.getItemState(PERSISTENT_ROOT_ID);
-                    historyRoot = new PersistentNode(stateMgr, ntMgr, nodeState);
-                }
-            }
+            this.stateMgr = new NativeItemStateManager(pMgr, PERSISTENT_ROOT_ID.getUUID(), ntReg);
+            NodeState nodeState = (NodeState) stateMgr.getItemState(PERSISTENT_ROOT_ID);
+            historyRoot = new PersistentNode(stateMgr, nodeState);
-     *
-     *
-            synchronized (idsByExternal) {
+            synchronized(idsByExternal) {
-     *
-        synchronized (idsByExternal) {
+        synchronized(idsByExternal) {
-     *
-     *
-        synchronized (idsByExternal) {
+        synchronized(idsByExternal) {
-        if (hist != null) {
+        if (hist!=null) {
-        // create deep path
-        String uuid = UUID.randomUUID().toString();
-        PersistentNode root = historyRoot;
-        for (int i = 0; i < 3; i++) {
-            QName name = new QName(NamespaceRegistryImpl.NS_DEFAULT_URI, uuid.substring(i * 2, i * 2 + 2));
-            if (!root.hasNode(name)) {
-                root.addNode(name, NodeTypeRegistry.NT_UNSTRUCTURED);
-                root.store();
-            }
-            root = root.getNode(name, 1);
-        }
-        QName historyNodeName = new QName(NamespaceRegistryImpl.NS_DEFAULT_URI, uuid);
-
-        // create new history node in the persistent state
-        hist = InternalVersionHistoryImpl.create(this, root, uuid, historyNodeName, node);
+            UpdateOperation upd = stateMgr.beginUpdate();
+
+            // create deep path
+            String uuid = UUID.randomUUID().toString();
+            PersistentNode root = historyRoot;
+            for (int i=0; i<3; i++) {
+                QName name = new QName(NamespaceRegistryImpl.NS_DEFAULT_URI, uuid.substring(i*2, i*2+2));
+                if (!root.hasNode(name)) {
+                    root.addNode(upd, name, NodeTypeRegistry.NT_UNSTRUCTURED);
+                    root.store(upd);
+                }
+                root = root.getNode(name, 1);
+            }
+            QName historyNodeName = new QName(NamespaceRegistryImpl.NS_DEFAULT_URI, uuid);
+
+            // create new history node in the persistent state
+            hist = InternalVersionHistoryImpl.create(upd, this, root, uuid, historyNodeName, node);
+
+            // end update
+            upd.end();
+
-        log.info("Created new version history " + uuid + ". NumHistories=" + histories.size());
+        log.info("Created new version history " + hist.getId()+ " for " + node.safeGetJCRPath() + ". NumHistories=" + histories.size());
-        return pid == null ? null : (InternalVersionHistory) getItem(pid);
+        return pid==null ? null : (InternalVersionHistory) getItem(pid);
-        return pid == null ? null : (InternalVersion) getItem(pid);
+        return pid==null ? null : (InternalVersion) getItem(pid);
-     *
-     *
-        return pid == null ? null : getItem(pid);
+        return pid==null ? null : getItem(pid);
-     *
-        return pid == null ? null : getItem(pid);
+        return pid==null ? null : getItem(pid);
-     *
-        InternalVersionItem item = (InternalVersionItem) items.get(pid);
-        if (item == null) {
+        InternalVersionItem item =(InternalVersionItem) items.get(pid);
+        if (item==null) {
-            if (pNode != null) {
+            if (pNode!=null) {
-            if (item != null) {
+            if (item!=null) {
-        InternalVersionImpl v = history.checkin(new QName("", versionName), node);
+            UpdateOperation upd = stateMgr.beginUpdate();
+            InternalVersionImpl v = history.checkin(upd, new QName("", versionName), node);
+            upd.end();
+
+
+            return v;
-        return v;
+    }
+
+    public void removeVersion(InternalVersionHistory hist, QName name) throws VersionException {
+        try {
+            UpdateOperation upd = stateMgr.beginUpdate();
+            ((InternalVersionHistoryImpl) hist).removeVersion(upd, name);
+            upd.end();
+        } catch (ItemStateException e) {
+            throw new VersionException(e);
+        }
+
+    }
+
+    public InternalVersion addVersionLabel(InternalVersionHistory hist, QName versionName, String label, boolean move) throws VersionException {
+        try {
+            UpdateOperation upd = stateMgr.beginUpdate();
+            InternalVersion v =
+                    ((InternalVersionHistoryImpl) hist).addVersionLabel(upd, versionName, label, move);
+            upd.end();
+            return v;
+        } catch (ItemStateException e) {
+            throw new VersionException(e);
+        }
+    }
+
+    public InternalVersion removeVersionLabel(InternalVersionHistory hist, String label) throws VersionException {
+        try {
+            UpdateOperation upd = stateMgr.beginUpdate();
+            InternalVersion v =
+                    ((InternalVersionHistoryImpl) hist).removeVersionLabel(upd, label);
+            upd.end();
+            return v;
+        } catch (ItemStateException e) {
+            throw new VersionException(e);
+        }
-        /**
-         * the type of the persistent node
-         */
+        /** the type of the persistent node */
-        /**
-         * the persistent uuid of the node
-         */
+        /** the persistent uuid of the node */
-        /**
-         * the persistent uuid of the node
-         */
+        /** the persistent uuid of the node */
+    private class Update implements UpdateOperation {
+
+        public NodeState createNew(String uuid, QName nodeTypeName, String parentUUID) {
+            return null;  //To change body of implemented methods use File | Settings | File Templates.
+        }
+
+        public PropertyState createNew(QName propName, String parentUUID) {
+            return null;  //To change body of implemented methods use File | Settings | File Templates.
+        }
+
+        public void store(ItemState state) {
+            //To change body of implemented methods use File | Settings | File Templates.
+        }
+
+        public void store(NodeReferences refs) {
+            //To change body of implemented methods use File | Settings | File Templates.
+        }
+
+        public void destroy(ItemState state) {
+            //To change body of implemented methods use File | Settings | File Templates.
+        }
+
+        public void end() throws ItemStateException {
+            //To change body of implemented methods use File | Settings | File Templates.
+        }
+    }
+

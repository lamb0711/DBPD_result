- add commons-codec dependency to client project.xml
- add concurrent dependency to jcr2spi project.xml
- remove events again from operation methods on RepositoryService.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@472888 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.EventFilter;
+import java.util.Collections;
+import EDU.oswego.cs.dl.util.concurrent.Channel;
+import EDU.oswego.cs.dl.util.concurrent.Sync;
+import EDU.oswego.cs.dl.util.concurrent.Latch;
+import EDU.oswego.cs.dl.util.concurrent.LinkedQueue;
+
+     * A producer for this channel can request an immediate poll for events
+     * by placing a Sync into the channel. The Sync is released when the event
+     * poll finished.
+     */
+    private final Channel immediateEventRequests = new LinkedQueue();
+
+    /**
-    private Set listeners = new HashSet();
+    private final Set listeners = Collections.synchronizedSet(new HashSet());
+    /**
+     * Creates an event filter based on the parameters available in {@link
+     * javax.jcr.observation.ObservationManager#addEventListener}.
+     *
+     * @param eventTypes   A combination of one or more event type constants
+     *                     encoded as a bitmask.
+     * @param path         an absolute path.
+     * @param isDeep       a <code>boolean</code>.
+     * @param uuids        array of UUIDs.
+     * @param nodeTypes    array of node type names.
+     * @param noLocal      a <code>boolean</code>.
+     * @return the event filter instance with the given parameters.
+     * @throws UnsupportedRepositoryOperationException
+     *          if this implementation does not support observation.
+     */
+    public EventFilter createEventFilter(int eventTypes,
+                                         Path path,
+                                         boolean isDeep,
+                                         String[] uuids,
+                                         QName[] nodeTypes,
+                                         boolean noLocal)
+            throws UnsupportedRepositoryOperationException {
+        return service.createEventFilter(eventTypes, path, isDeep, uuids, nodeTypes, noLocal);
+    }
+
-        WorkspaceItemStateManager ism = new WorkspaceItemStateManager(isf, service.getIdFactory());
+        WorkspaceItemStateManager ism = new WorkspaceItemStateManager(this, isf, service.getIdFactory());
+        Sync eventSignal;
+            eventSignal = getEventPollingRequest();
+        }
+        try {
+            eventSignal.acquire();
+        } catch (InterruptedException e) {
+            Thread.interrupted();
+            log.warn("Interrupted while waiting for events from RepositoryService");
+        Sync eventSignal;
+            changes.persisted();
+            eventSignal = getEventPollingRequest();
+        }
+        try {
+            eventSignal.acquire();
+        } catch (InterruptedException e) {
+            Thread.interrupted();
+            log.warn("Interrupted while waiting for events from RepositoryService");
-     * changes have been applied to the repository. Depending on <code>changeLog</code>
-     * this method is called as a result of:
-     * <ul>
-     * <li>a local <code>save</code> of transient changes. In this case
-     * <code>changeLog</code> is non-<code>null</code>.</li>
-     * <li>an execution of a workspace operation. In this case
-     * <code>changeLog</code> is <code>null</code></li>
-     * <li>an external change to the workspace (another session modified the
-     * workspace). In this case <code>changeLog</code> is <code>null</code></li>
-     * </ul>
+     * changes have been applied to the repository.
-     * @param events    the events generated by the repository service as a
-     *                  response to the executed operation(s).
-     * @param changeLog the local <code>ChangeLog</code> which contains the
-     *                  affected transient <code>ItemState</code>s and the
-     *                  relevant {@link Operation}s that lead to the
-     *                  modifications. If <code>null</code> this method is
-     *                  called as a consequence of an external change or a call
-     *                  of a workspace operation. In that case there are no
-     *                  local transient changes.
+     * @param events the events generated by the repository service as the
+     *               effect of a change.
-    private void onEventReceived(EventBundle[] events, ChangeLog changeLog) {
+    private void onEventReceived(EventBundle[] events) {
-            EventBundle bundle = events[i];
-            if (bundle.isLocal() && changeLog != null) {
-                // local change from batch operation
-                for (int j = 0; j < lstnrs.length; j++) {
-                    lstnrs[j].onEvent(bundle, changeLog);
-                }
-            } else {
-                // external change or workspace operation
-                for (int j = 0; j < lstnrs.length; j++) {
-                    lstnrs[j].onEvent(bundle);
-                }
+            for (int j = 0; j < lstnrs.length; j++) {
+                lstnrs[j].onEvent(events[i]);
-        private EventBundle[] events;
-                    events = service.submit(batch);
-                    onEventReceived(events, changeLog);
+                    service.submit(batch);
-            boolean success = false;
-            try {
-                log.info("executing: " + workspaceOperation);
-                workspaceOperation.accept(this);
-                success = true;
-            } finally {
-                if (success && events != null) {
-                    // a workspace operation is like an external change: there
-                    // is no changelog to persist. but still the events must
-                    // be reported as local changes.
-                    onEventReceived(events, null);
-                }
-            }
+            log.info("executing: " + workspaceOperation);
+            workspaceOperation.accept(this);
-            events = service.clone(sessionInfo, operation.getWorkspaceName(), nId, destParentId, operation.getDestinationName(), operation.isRemoveExisting());
+            service.clone(sessionInfo, operation.getWorkspaceName(), nId, destParentId, operation.getDestinationName(), operation.isRemoveExisting());
-            events = service.copy(sessionInfo, operation.getWorkspaceName(), nId, destParentId, operation.getDestinationName());
+            service.copy(sessionInfo, operation.getWorkspaceName(), nId, destParentId, operation.getDestinationName());
-                events = service.move(sessionInfo, moveId, destParentId, operation.getDestinationName());
+                service.move(sessionInfo, moveId, destParentId, operation.getDestinationName());
-            events = service.update(sessionInfo, nId, operation.getSourceWorkspaceName());
+            service.update(sessionInfo, nId, operation.getSourceWorkspaceName());
-            events = service.checkout(sessionInfo, operation.getNodeState().getNodeId());
+            service.checkout(sessionInfo, operation.getNodeState().getNodeId());
-            events = service.checkin(sessionInfo, operation.getNodeState().getNodeId());
+            service.checkin(sessionInfo, operation.getNodeState().getNodeId());
-                events = service.restore(sessionInfo, vIds, operation.removeExisting());
+                service.restore(sessionInfo, vIds, operation.removeExisting());
-                events = service.restore(sessionInfo, targetId, vIds[0], operation.removeExisting());
+                service.restore(sessionInfo, targetId, vIds[0], operation.removeExisting());
-            events = service.merge(sessionInfo, nId, operation.getSourceWorkspaceName(), operation.bestEffort());
-            List externalEventBundles = new ArrayList();
-            for (int i = 0; i < events.length; i++) {
-                if (events[i].isLocal()) {
-                    // todo: improve.... inform operation about modified items (build mergefailed iterator)
-                    operation.getEventListener().onEvent(events[i]);
-                } else {
-                    // otherwise dispatch as external event
-                    externalEventBundles.add(events[i]);
-                }
-            }
-            if (!externalEventBundles.isEmpty()) {
-                EventBundle[] bundles = (EventBundle[]) externalEventBundles.toArray(new EventBundle[externalEventBundles.size()]);
-                onEventReceived(bundles, null);
-            }
+            // todo service should return ids of failed nodes
+            service.merge(sessionInfo, nId, operation.getSourceWorkspaceName(), operation.bestEffort());
-                events = service.resolveMergeConflict(sessionInfo, nId, mergeFailedIds, predecessorIds);
+                service.resolveMergeConflict(sessionInfo, nId, mergeFailedIds, predecessorIds);
-            events = service.lock(sessionInfo, nId, operation.isDeep(), operation.isSessionScoped());
+            service.lock(sessionInfo, nId, operation.isDeep(), operation.isSessionScoped());
-            events = service.refreshLock(sessionInfo, nId);
+            service.refreshLock(sessionInfo, nId);
-            events = service.unlock(sessionInfo, nId);
+            service.unlock(sessionInfo, nId);
-            events = service.addVersionLabel(sessionInfo, vhId, vId, operation.getLabel(), operation.moveLabel());
+            service.addVersionLabel(sessionInfo, vhId, vId, operation.getLabel(), operation.moveLabel());
-            events = service.removeVersionLabel(sessionInfo, vhId, vId, operation.getLabel());
+            service.removeVersionLabel(sessionInfo, vhId, vId, operation.getLabel());
+     * Requests an immediate poll for events. The returned Sync will be
+     * released by the event polling thread when events have been retrieved.
+     */
+    private Sync getEventPollingRequest() {
+        Sync signal;
+        if (externalChangeFeed != null) {
+            // observation supported
+            signal = new Latch();
+            try {
+                immediateEventRequests.put(signal);
+            } catch (InterruptedException e) {
+                log.warn("Unable to request immediate event poll: " + e);
+            }
+        } else {
+            // no observation, return a dummy sync which can be acquired immediately
+            signal = new Sync() {
+                public void acquire() {
+                }
+
+                public boolean attempt(long l) {
+                    return true;
+                }
+
+                public void release() {
+                    throw new UnsupportedOperationException();
+                }
+            };
+        }
+        return signal;
+    }
+
+    /**
-                    Thread.sleep(pollingInterval);
-                } catch (InterruptedException e) {
-                    // terminate
-                    break;
-                }
-                try {
+                    // wait for a signal to do an immediate poll but wait at
+                    // most EXTERNAL_EVENT_POLLING_INTERVAL
+                    Sync signal = (Sync) immediateEventRequests.poll(pollingInterval);
+
-                        EventBundle[] bundles = service.getEvents(sessionInfo, 0);
+                        // if this thread was waiting for updateMonitor and now
+                        // enters this synchronized block, then a user thread
+                        // has just finished an operation and will probably
+                        // request an immediate event poll. That's why we
+                        // check here again for a sync signal
+                        if (signal == null) {
+                            signal = (Sync) immediateEventRequests.poll(0);
+                        }
+
+                        if (signal != null) {
+                            log.debug("Request for immediate event poll");
+                        }
+
+                        // get filters from listeners
+                        List filters = new ArrayList();
+                        InternalEventListener[] iel = (InternalEventListener[]) listeners.toArray(new InternalEventListener[0]);
+                        for (int i = 0; i < iel.length; i++) {
+                            filters.addAll(iel[i].getEventFilters());
+                        }
+                        EventBundle[] bundles = service.getEvents(sessionInfo,
+                                0, (EventFilter[]) filters.toArray(
+                                        new EventFilter[filters.size()]));
-                            onEventReceived(bundles, null);
+                            onEventReceived(bundles);
+                        }
+                        if (signal != null) {
+                            log.debug("About to signal that events have been delivered");
+                            signal.release();
+                            log.debug("Event delivery signaled");
+                } catch (InterruptedException e) {
+                    // terminate
+                    break;

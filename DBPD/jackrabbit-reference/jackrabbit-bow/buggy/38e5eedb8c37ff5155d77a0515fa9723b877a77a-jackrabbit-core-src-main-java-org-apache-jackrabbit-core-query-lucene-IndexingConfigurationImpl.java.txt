JCR-1369: indexing-rules should allow wildcards for (global) property names

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@677952 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.commons.name.Pattern;
+import org.apache.jackrabbit.spi.commons.name.PathFactoryImpl;
+import org.apache.jackrabbit.spi.PathFactory;
+import org.apache.jackrabbit.spi.Path;
+     * The path factory instance.
+     */
+    private static final PathFactory PATH_FACTORY = PathFactoryImpl.getInstance();
+
+    /**
-                                                    + FieldNames.FULLTEXT_PREFIX + fieldName.substring(idx + 1);;
+                                                    + FieldNames.FULLTEXT_PREFIX + fieldName.substring(idx + 1);
-     * @return the property configurations defined in the <code>config</code>.
+     * @param propConfigs will be filled with exact <code>Name</code> to
+     *                    <code>PropertyConfig</code> mappings.
+     * @param namePatterns will be filled with <code>NamePattern</code>s.
-    private Map getPropertyConfigs(Node config)
+    private void createPropertyConfigs(Node config,
+                                       Map propConfigs,
+                                       List namePatterns)
-        Map configs = new HashMap();
-                // get property name
-                Name propName = resolver.getQName(getTextContent(n));
+                // get isRegexp flag
+                boolean isRegexp = false;
+                Node regexp = attributes.getNamedItem("isRegexp");
+                if (regexp != null) {
+                    isRegexp = Boolean.valueOf(
+                            regexp.getNodeValue()).booleanValue();
+                }
-                configs.put(propName, new PropertyConfig(boost, nodeScopeIndex));
+                PropertyConfig pc = new PropertyConfig(boost, nodeScopeIndex);
+
+                if (isRegexp) {
+                    namePatterns.add(new NamePattern(
+                            getTextContent(n), pc, resolver));
+                } else {
+                    Name propName = resolver.getQName(getTextContent(n));
+                    propConfigs.put(propName, pc);
+                }
-        return configs;
+    /**
+     * A property name pattern.
+     */
+    private static final class NamePattern {
+
+        /**
+         * The pattern to match.
+         */
+        private final Pattern pattern;
+
+        /**
+         * The associated configuration.
+         */
+        private final PropertyConfig config;
+
+        /**
+         * Creates a new name pattern.
+         *
+         * @param pattern the pattern as read from the configuration file.
+         * @param config the associated configuration.
+         * @param resolver a namespace resolver for parsing name from the
+         *                 configuration.
+         * @throws IllegalNameException if the prefix of the name pattern is
+         *                              illegal.
+         * @throws NamespaceException if the prefix of the name pattern cannot
+         *                            be resolved.
+         */
+        private NamePattern(String pattern,
+                            PropertyConfig config,
+                            NameResolver resolver)
+                throws IllegalNameException, NamespaceException {
+            String uri = Name.NS_DEFAULT_URI;
+            String localPattern = pattern;
+            int idx = pattern.indexOf(':');
+            if (idx != -1) {
+                // use a dummy local name to get namespace uri
+                uri = resolver.getQName(pattern.substring(0, idx) + ":a").getNamespaceURI();
+                localPattern = pattern.substring(idx + 1);
+            }
+            this.pattern = Pattern.name(uri, localPattern);
+            this.config = config;
+        }
+
+        /**
+         * @param path the path to match.
+         * @return <code>true</code> if <code>path</code> matches this name
+         *         pattern; <code>false</code> otherwise.
+         */
+        boolean matches(Path path) {
+            return pattern.match(path).isFullMatch();
+        }
+
+        /**
+         * @return the property configuration for this name pattern.
+         */
+        PropertyConfig getConfig() {
+            return config;
+        }
+    }
+
-        private final Map propConfigs;
+        private final Map propConfigs = new HashMap();
+
+        /**
+         * List of {@link NamePattern}s.
+         */
+        private final List namePatterns = new ArrayList();
-            this.propConfigs = getPropertyConfigs(config);
+            createPropertyConfigs(config, propConfigs, namePatterns);
-            return propConfigs.containsKey(propertyName);
+            return getConfig(propertyName) != null;
-            PropertyConfig config = (PropertyConfig) propConfigs.get(propertyName);
+            PropertyConfig config = getConfig(propertyName);
-         * be included in the node scope fulltext index. If there is not
+         * be included in the node scope fulltext index. If there is no
-            PropertyConfig config = (PropertyConfig) propConfigs.get(propertyName);
+            PropertyConfig config = getConfig(propertyName);
+         * @param propertyName name of a property.
+         * @return the property configuration or <code>null</code> if this
+         *         indexing rule does not contain a configuration for the given
+         *         property.
+         */
+        private PropertyConfig getConfig(Name propertyName) {
+            PropertyConfig config = (PropertyConfig) propConfigs.get(propertyName);
+            if (config != null) {
+                return config;
+            } else if (namePatterns.size() > 0) {
+                Path path = PATH_FACTORY.create(propertyName);
+                // check patterns
+                for (Iterator it = namePatterns.iterator(); it.hasNext(); ) {
+                    NamePattern np = (NamePattern) it.next();
+                    if (np.matches(path)) {
+                        return np.getConfig();
+                    }
+                }
+            }
+            return null;
+        }
+
+        /**
-                            return (NodeState) ism.getItemState(cne.getId());
+                            return ism.getItemState(cne.getId());

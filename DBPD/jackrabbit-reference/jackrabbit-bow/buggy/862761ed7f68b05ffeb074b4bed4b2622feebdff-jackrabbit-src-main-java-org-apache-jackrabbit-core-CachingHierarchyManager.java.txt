[JCR-614] Weird locking behaviour in CachingHierarchyManager


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@469853 13f79535-47bb-0310-9956-ffa450edef68

-import javax.jcr.ItemNotFoundException;
-import javax.jcr.PathNotFoundException;
-import javax.jcr.RepositoryException;
+import javax.jcr.ItemNotFoundException;
+import javax.jcr.PathNotFoundException;
+import javax.jcr.RepositoryException;
+
-                removeLRU();
+                /**
+                 * Remove least recently used item. Scans the LRU list from head to tail
+                 * and removes the first item that has no children.
+                 */
+                LRUEntry entry = head;
+                while (entry != null) {
+                    PathMap.Element element = entry.getElement();
+                    if (element.getChildrenCount() == 0) {
+                        evict(entry, true);
+                        return;
+                    }
+                    entry = entry.getNext();
+                }
-     * Remove least recently used item. Scans the LRU list from head to tail
-     * and removes the first item that has no children.
-     */
-    private void removeLRU() {
-        synchronized (cacheMonitor) {
-            LRUEntry entry = head;
-            while (entry != null) {
-                PathMap.Element element = entry.getElement();
-                if (element.getChildrenCount() == 0) {
-                    evict(entry, true);
-                    return;
-                }
-                entry = entry.getNext();
-            }
-        }
-    }
-
-    /**
-        synchronized (cacheMonitor) {
-            if (removeFromPathCache) {
-                PathMap.Element element = entry.getElement();
-                remove(element);
-                element.remove();
-            } else {
-                idCache.remove(entry.getId());
-                entry.remove();
-            }
+        // assert: synchronized (cacheMonitor)
+        if (removeFromPathCache) {
+            PathMap.Element element = entry.getElement();
+            remove(element);
+            element.remove();
+        } else {
+            idCache.remove(entry.getId());
+            entry.remove();
-        synchronized (cacheMonitor) {
-            if (removeFromPathCache) {
-                PathMap.Element element = entry.getElement();
-                element.traverse(new PathMap.ElementVisitor() {
-                    public void elementVisited(PathMap.Element element) {
-                        evict((LRUEntry) element.get(), false);
-                    }
-                }, false);
-                element.remove(false);
-            } else {
-                idCache.remove(entry.getId());
-                entry.remove();
-            }
+        // assert: synchronized (cacheMonitor)
+        if (removeFromPathCache) {
+            PathMap.Element element = entry.getElement();
+            element.traverse(new PathMap.ElementVisitor() {
+                public void elementVisited(PathMap.Element element) {
+                    evict((LRUEntry) element.get(), false);
+                }
+            }, false);
+            element.remove(false);
+        } else {
+            idCache.remove(entry.getId());
+            entry.remove();
-        synchronized (cacheMonitor) {
-            element.traverse(new PathMap.ElementVisitor() {
-                public void elementVisited(PathMap.Element element) {
-                    remove((LRUEntry) element.get(), false);
-                }
-            }, false);
-        }
+        // assert: synchronized (cacheMonitor)
+        element.traverse(new PathMap.ElementVisitor() {
+            public void elementVisited(PathMap.Element element) {
+                remove((LRUEntry) element.get(), false);
+            }
+        }, false);

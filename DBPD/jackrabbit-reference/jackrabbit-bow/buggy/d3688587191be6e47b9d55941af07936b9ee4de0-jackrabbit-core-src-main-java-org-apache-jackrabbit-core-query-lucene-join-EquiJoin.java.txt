JCR-2718: Incorrect results from joins on multivalued properties

Use full term lookups in EquiJoin instead of relying on comparators for the equality tests.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@986686 13f79535-47bb-0310-9956-ffa450edef68

-import java.io.IOException;
+import static org.apache.jackrabbit.core.query.lucene.FieldNames.PROPERTIES;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.jackrabbit.core.query.lucene.FieldNames;
+import org.apache.jackrabbit.core.query.lucene.NamespaceMappings;
+import org.apache.jackrabbit.spi.commons.conversion.IllegalNameException;
-import org.apache.lucene.search.SortComparatorSource;
-import org.apache.lucene.search.ScoreDocComparator;
-import org.apache.lucene.search.ScoreDoc;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermDocs;
+import org.apache.lucene.index.TermEnum;
-     * Reusable score doc for value lookups.
-     */
-    private final ScoreDoc sDoc = new ScoreDoc(-1, 1.0f);
-
-    /**
-    /**
-     * Map of inner score nodes indexed by the value of their join property.
-     */
-    private final ScoreNodeMap innerScoreNodes = new ScoreNodeMap();
+    private final Term outerTerm;
-    /**
-     * The score doc comparator for the outer query hits.
-     */
-    private final ScoreDocComparator outerLookup;
+    private final Map<String, List<ScoreNode[]>> rowsByInnerNodeValue =
+        new HashMap<String, List<ScoreNode[]>>();
+     * @throws IllegalNameException 
-    public EquiJoin(MultiColumnQueryHits inner,
-                    int innerScoreNodeIndex,
-                    SortComparatorSource scs,
-                    IndexReader reader,
-                    Name innerProperty,
-                    Name outerProperty) throws IOException {
+    public EquiJoin(
+            MultiColumnQueryHits inner, int innerScoreNodeIndex,
+            NamespaceMappings nsMappings, IndexReader reader,
+            Name innerProperty, Name outerProperty)
+            throws IOException, IllegalNameException {
-        this.outerLookup = scs.newComparator(reader, outerProperty.toString());
-        ScoreDocComparator comparator = scs.newComparator(reader, innerProperty.toString());
-        ScoreNode[] nodes;
+
+        Term innerTerm = new Term(PROPERTIES, FieldNames.createNamedValue(
+                nsMappings.translateName(innerProperty), ""));
+        this.outerTerm = new Term(PROPERTIES, FieldNames.createNamedValue(
+                nsMappings.translateName(outerProperty), ""));
+
-        while ((nodes = inner.nextScoreNodes()) != null) {
-            sDoc.doc = nodes[innerScoreNodeIndex].getDoc(reader);
-            Comparable value = comparator.sortValue(sDoc);
-            if (value != null) {
-                innerScoreNodes.addScoreNodes(value, nodes);
+        Map<Integer, List<ScoreNode[]>> rowsByInnerDocument =
+            new HashMap<Integer, List<ScoreNode[]>>();
+        ScoreNode[] row = inner.nextScoreNodes();
+        while (row != null) {
+            int document = row[innerScoreNodeIndex].getDoc(reader);
+            List<ScoreNode[]> rows = rowsByInnerDocument.get(document);
+            if (rows == null) {
+                rows = new ArrayList<ScoreNode[]>();
+                rowsByInnerDocument.put(document, rows);
+            rows.add(row);
+            row = inner.nextScoreNodes();
+
+        // Build the rowsByInnerNodeValue map for efficient lookup in
+        // the getMatchingScoreNodes() method
+        TermEnum terms = reader.terms(innerTerm);
+        do {
+            Term term = terms.term();
+            if (term == null
+                    || !term.field().equals(innerTerm.field())
+                    || !term.text().startsWith(innerTerm.text())) {
+                break;
+            }
+
+            String value = term.text().substring(innerTerm.text().length());
+            TermDocs docs = reader.termDocs(terms.term());
+            while (docs.next()) {
+                List<ScoreNode[]> match = rowsByInnerDocument.get(docs.doc());
+                if (match != null) {
+                    List<ScoreNode[]> rows = rowsByInnerNodeValue.get(value); 
+                    if (rows == null) {
+                        rows = new ArrayList<ScoreNode[]>();
+                        rowsByInnerNodeValue.put(value, rows);
+                    }
+                    rows.addAll(match);
+                }
+            }
+        } while (terms.next());
-        sDoc.doc = outer.getDoc(reader);
-        Comparable value = outerLookup.sortValue(sDoc);
-        return innerScoreNodes.getScoreNodes(value);
+        List<ScoreNode[]> list = new ArrayList<ScoreNode[]>();
+
+        int document = outer.getDoc(reader);
+        TermEnum terms = reader.terms(outerTerm);
+        do {
+            Term term = terms.term();
+            if (term == null
+                    || !term.field().equals(outerTerm.field())
+                    || !term.text().startsWith(outerTerm.text())) {
+                break;
+            }
+
+            List<ScoreNode[]> rows = rowsByInnerNodeValue.get(
+                    terms.term().text().substring(outerTerm.text().length()));
+            if (rows != null) {
+                TermDocs docs = reader.termDocs(terms.term());
+                while (docs.next()) {
+                    if (docs.doc() == document) {
+                        list.addAll(rows);
+                        break;
+                    }
+                }
+            }
+        } while (terms.next());
+
+        return list.toArray(new ScoreNode[list.size()][]);
+

JCR-1588: 283 Access Control

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@689499 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.api.jsr283.security.AccessControlPolicy;
+import org.apache.jackrabbit.core.ItemImpl;
+import org.apache.jackrabbit.core.security.authorization.AccessControlEditor;
+import org.apache.jackrabbit.core.security.authorization.NamedAccessControlPolicyImpl;
-import javax.jcr.PathNotFoundException;
-import javax.jcr.Property;
-import java.util.Arrays;
-import java.util.List;
- *
- * TODO: allow for editing of additional ac that extends the default permission evaluted by this provided.
+    private final AccessControlPolicy policy;
+
-        super("Access control policy for the 'security' workspace.",
-              "Policy that defines the general access control rules for the security workspace.");
+        policy = new NamedAccessControlPolicyImpl("userPolicy");
-    //--------------------------------------< AbstractAccessControlProvider >---
+    //-------------------------------------------------< AccessControlUtils >---
-     * @see AbstractAccessControlProvider#isAcItem(Path)
+     * @see org.apache.jackrabbit.core.security.authorization.AccessControlUtils#isAcItem(Path)
-    protected boolean isAcItem(Path absPath) throws RepositoryException {
+    public boolean isAcItem(Path absPath) throws RepositoryException {
+        return false;
+    }
+
+    /**
+     * Always returns false, since this ac provider does not use content stored
+     * in items to evaluate AC information.
+     *
+     * @see org.apache.jackrabbit.core.security.authorization.AccessControlUtils#isAcItem(ItemImpl)
+     */
+    public boolean isAcItem(ItemImpl item) throws RepositoryException {
-    public void init(Session systemSession, Map options) throws RepositoryException {
-        super.init(systemSession, options);
+    public void init(Session systemSession, Map configuration) throws RepositoryException {
+        super.init(systemSession, configuration);
-             userAdminGroup = (options.containsKey(USER_ADMIN_GROUP_NAME)) ? options.get(USER_ADMIN_GROUP_NAME).toString() : USER_ADMIN_GROUP_NAME;
-             groupAdminGroup = (options.containsKey(GROUP_ADMIN_GROUP_NAME)) ? options.get(GROUP_ADMIN_GROUP_NAME).toString() : GROUP_ADMIN_GROUP_NAME;
+             userAdminGroup = (configuration.containsKey(USER_ADMIN_GROUP_NAME)) ? configuration.get(USER_ADMIN_GROUP_NAME).toString() : USER_ADMIN_GROUP_NAME;
+             groupAdminGroup = (configuration.containsKey(GROUP_ADMIN_GROUP_NAME)) ? configuration.get(GROUP_ADMIN_GROUP_NAME).toString() : GROUP_ADMIN_GROUP_NAME;
-             // TODO: review again.
-
+    /**
+     * @see AccessControlProvider#getEffectivePolicies(Path)
+     */
+    public AccessControlPolicy[] getEffectivePolicies(Path absPath) throws ItemNotFoundException, RepositoryException {
+        checkInitialized();
+        return new AccessControlPolicy[] {policy};
+    }
+
+    /**
+     * Always returns <code>null</code>.
+     *
+     * @see AccessControlProvider#getEditor(Session)
+     */
+    public AccessControlEditor getEditor(Session session) {
+        checkInitialized();
+        // not editable at all: policy is always the default and cannot be
+        // changed using the JCR API.
+        return null;
+    }
+
+    /**
+     * @see AccessControlProvider#compilePermissions(Set)
+     */
+    /**
+     * @see AccessControlProvider#canAccessRoot(Set)
+     */
-    private boolean isMember(Node userNode, Path memberPath) throws RepositoryException, PathNotFoundException {
-        // precondition: memberPath points to a rep:members property
-        String propPath = session.getJCRPath(memberPath);
-        if (session.propertyExists(propPath)) {
-            // check if any of the ref-values equals to the value created from
-            // the user-Node (which must be present if the user is member of the group)
-            Property membersProp = session.getProperty(propPath);
-            List values = Arrays.asList(membersProp.getValues());
-            return values.contains(session.getValueFactory().createValue(userNode));
-        } else {
-            return false;
-        }
-    }
-
-    /**
-     * Determine if for the given <code>path</code>, the set of privileges
-     * must be calculated.
-     *
-     * @param path
-     * @return true if <code>path</code> denotes an existing <code>Node</code>,
-     * false otherwise.
-     * @throws RepositoryException
-     */
-    private boolean doCalculatePrivileges(Path path) throws RepositoryException {
-        String absPath = resolver.getJCRPath(path.getNormalizedPath());
-        // privileges can only be determined for existing nodes.
-        // not for properties and neither for non-existing nodes.
-        return session.nodeExists(absPath);
-    }
-
-            // default permission and default privileges
-            int perms = Permission.READ;
+            // no explicit denied permissions:
+            int denies = Permission.NONE;
+            // default allow permission and default privileges
+            int allows = Permission.READ;
-            boolean calcPrivs = doCalculatePrivileges(path);
+            // Determine if for path, the set of privileges must be calculated:
+            // Generally, privileges can only be determined for existing nodes.
+            boolean calcPrivs = session.nodeExists(resolver.getJCRPath(path.getNormalizedPath()));
-                privs = 0;
+                privs = PrivilegeRegistry.NO_PRIVILEGE;
-            //
-                                perms = Permission.ALL;
+                                allows = Permission.ALL;
-                                perms |= (Permission.SET_PROPERTY | Permission.REMOVE_PROPERTY);
+                                allows |= (Permission.SET_PROPERTY | Permission.REMOVE_PROPERTY);
-                                perms = Permission.ALL;
+                                allows = Permission.ALL;
-                    perms = Permission.ALL;
+                    allows = Permission.ALL;
-
-            return new Result(perms, privs);
+            return new Result(allows, denies, privs, PrivilegeRegistry.NO_PRIVILEGE);
-                                // TODO: improve

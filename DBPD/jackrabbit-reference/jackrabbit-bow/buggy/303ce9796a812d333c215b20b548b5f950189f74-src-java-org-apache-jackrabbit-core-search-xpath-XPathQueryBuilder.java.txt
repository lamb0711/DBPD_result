Implement 'order by' syntax for XPath and SQL. Actual ordering on the query result is not yet done.

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@126598 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.search.OrderQueryNode;
-public class XPathQueryBuilder implements XPathVisitor {
+public class XPathQueryBuilder implements XPathVisitor, XPathTreeConstants {
+            // create an XQuery statement because we're actually using an
+            // XQuery parser.
+            statement = "for $v in " + statement + " return $v";
-            case XPathTreeConstants.JJTXPATH:
+            case JJTXPATH2:
-            case XPathTreeConstants.JJTROOT:
+            case JJTROOT:
-            case XPathTreeConstants.JJTROOTDESCENDANTS:
+            case JJTROOTDESCENDANTS:
-            case XPathTreeConstants.JJTSTEPEXPR:
+            case JJTSTEPEXPR:
-                    if (data instanceof RelationQueryNode) {
+                    if (data instanceof RelationQueryNode
+                            || data instanceof OrderQueryNode) {
-            case XPathTreeConstants.JJTNAMETEST:
+            case JJTNAMETEST:
+                } else if (data instanceof OrderQueryNode) {
+                    data = createOrderSpec(node, (OrderQueryNode) data);
-            case XPathTreeConstants.JJTOREXPR:
+            case JJTOREXPR:
-            case XPathTreeConstants.JJTANDEXPR:
+            case JJTANDEXPR:
-            case XPathTreeConstants.JJTCOMPARISONEXPR:
+            case JJTCOMPARISONEXPR:
-            case XPathTreeConstants.JJTSTRINGLITERAL:
-            case XPathTreeConstants.JJTDECIMALLITERAL:
-            case XPathTreeConstants.JJTDOUBLELITERAL:
-            case XPathTreeConstants.JJTINTEGERLITERAL:
+            case JJTSTRINGLITERAL:
+            case JJTDECIMALLITERAL:
+            case JJTDOUBLELITERAL:
+            case JJTINTEGERLITERAL:
-            case XPathTreeConstants.JJTFUNCTIONCALL:
+            case JJTFUNCTIONCALL:
+            case JJTORDERBYCLAUSE:
+                root.setOrderNode(new OrderQueryNode(root));
+                data = root.getOrderNode();
+                node.childrenAccept(this, data);
+                break;
+            case JJTORDERMODIFIER:
+                if (node.jjtGetNumChildren() > 0
+                        && ((SimpleNode) node.jjtGetChild(0)) .getId() == JJTDESCENDING) {
+                    OrderQueryNode.OrderSpec[] specs = ((OrderQueryNode) data).getOrderSpecs();
+                    specs[specs.length - 1].setAscending(false);
+                }
+                break;
-            descenant = (c.getId() == XPathTreeConstants.JJTSLASHSLASH
-                    || c.getId() == XPathTreeConstants.JJTROOTDESCENDANTS);
+            descenant = (c.getId() == JJTSLASHSLASH
+                    || c.getId() == JJTROOTDESCENDANTS);
-            if (child.getId() == XPathTreeConstants.JJTQNAME) {
+            if (child.getId() == JJTQNAME) {
+                    } else if (queryNode instanceof OrderQueryNode) {
+                        QName name = ISO9075.decode(QName.fromJCRName(child.getValue(), resolver));
+                        // todo implement properly
+                        root.getOrderNode().addOrderSpec(name, true);
-            } else if (child.getId() == XPathTreeConstants.JJTSTAR) {
+            } else if (child.getId() == JJTSTAR) {
-        if (node.getId() != XPathTreeConstants.JJTCOMPARISONEXPR) {
+        if (node.getId() != JJTCOMPARISONEXPR) {
-        if (node.getId() == XPathTreeConstants.JJTSTRINGLITERAL) {
+        if (node.getId() == JJTSTRINGLITERAL) {
-        } else if (node.getId() == XPathTreeConstants.JJTDECIMALLITERAL) {
+        } else if (node.getId() == JJTDECIMALLITERAL) {
-        } else if (node.getId() == XPathTreeConstants.JJTDOUBLELITERAL) {
+        } else if (node.getId() == JJTDOUBLELITERAL) {
-        } else if (node.getId() == XPathTreeConstants.JJTINTEGERLITERAL) {
+        } else if (node.getId() == JJTINTEGERLITERAL) {
-                        if (literal.getId() == XPathTreeConstants.JJTSTRINGLITERAL) {
+                        if (literal.getId() == JJTSTRINGLITERAL) {
-                        if (literal.getId() == XPathTreeConstants.JJTSTRINGLITERAL) {
+                        if (literal.getId() == JJTSTRINGLITERAL) {
-                        if (literal.getId() == XPathTreeConstants.JJTSTRINGLITERAL) {
+                        if (literal.getId() == JJTSTRINGLITERAL) {
+    private OrderQueryNode.OrderSpec createOrderSpec(SimpleNode node,
+                                                     OrderQueryNode queryNode) {
+        SimpleNode child = (SimpleNode) node.jjtGetChild(0);
+        OrderQueryNode.OrderSpec spec = null;
+        try {
+            QName name = ISO9075.decode(QName.fromJCRName(child.getValue(), resolver));
+            spec = new OrderQueryNode.OrderSpec(name, true);
+            queryNode.addOrderSpec(spec);
+        } catch (IllegalNameException e) {
+            exceptions.add(new InvalidQueryException("Illegal name: " + child.getValue()));
+        } catch (UnknownPrefixException e) {
+            exceptions.add(new InvalidQueryException("Unknown prefix: " + child.getValue()));
+        }
+        return spec;
+    }
+
-            if (((SimpleNode) node.jjtGetChild(i)).getId() == XPathTreeConstants.JJTAT) {
+            if (((SimpleNode) node.jjtGetChild(i)).getId() == JJTAT) {

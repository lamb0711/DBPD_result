- fixed restore bugs
- implemented Workspace.restore() [not tested yet]

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@157553 13f79535-47bb-0310-9956-ffa450edef68

-        // TODO: change if Version.getContainingVersionHistory() is introduced
-        if (!version.getParent().isSame(getVersionHistory())) {
+        if (!((VersionImpl) version).getContainingVersionHistory().isSame(getVersionHistory())) {
+            NodeImpl node;
+            try {
+                // check if versionable node exists
+                InternalFrozenNode fn = ((VersionImpl) version).getFrozenNode();
+                node = (NodeImpl) session.getNodeByUUID(fn.getFrozenUUID());
+                if (removeExisting) {
+                    try {
+                        Path dstPath = Path.create(getPrimaryPath(), relPath, session.getNamespaceResolver(), true);
+                        // move to respective location
+                        session.move(node.getPath(), dstPath.toJCRPath(session.getNamespaceResolver()));
+                        // need to refetch ?
+                        node = (NodeImpl) session.getNodeByUUID(fn.getFrozenUUID());
+                    } catch (MalformedPathException e) {
+                        throw new RepositoryException(e);
+                    } catch (NoPrefixDeclaredException e) {
+                        throw new RepositoryException("InternalError.", e);
+                    }
+                } else {
+                    throw new ItemExistsException("Unable to restore version. Versionable node already exists.");
+                }
+            } catch (ItemNotFoundException e) {
+                // not found, create new one
+                node = addNode(relPath, ((VersionImpl) version).getFrozenNode());
+            }
+
-            NodeImpl node = addNode(relPath, ((VersionImpl) version).getFrozenNode());
-        save();
+        // session.save/revert is done in internal restore
-    private void internalRestore(InternalVersion version, VersionSelector vsel,
+    protected InternalVersion[] internalRestore(InternalVersion version, VersionSelector vsel,
-        restoreFrozenState(version.getFrozenNode(), vsel, removeExisting);
+        HashSet restored = new HashSet();
+        restoreFrozenState(version.getFrozenNode(), vsel, restored, removeExisting);
+        restored.add(version);
+
+        return (InternalVersion[]) restored.toArray(new InternalVersion[restored.size()]);
-    void restoreFrozenState(InternalFrozenNode freeze, VersionSelector vsel, boolean removeExisting)
+    void restoreFrozenState(InternalFrozenNode freeze, VersionSelector vsel, Set restored, boolean removeExisting)
-        // restore the frozen nodes
-        InternalFreeze[] frozenNodes = freeze.getFrozenChildNodes();
-
-        // first delete all non frozen version histories, ie. all OPV!=Version
+        // first delete all non frozen version histories
-            if (n.getDefinition().getOnParentVersion() == OnParentVersionAction.COPY) {
-                n.remove();
+            if (!freeze.hasFrozenHistory(n.internalGetUUID())) {
+                n.internalRemove(true);
-        // now restore the frozen ones
+        // restore the frozen nodes
+        InternalFreeze[] frozenNodes = freeze.getFrozenChildNodes();
+                        // check if one of this restoretrees node
-                n.restoreFrozenState(f, vsel, removeExisting);
+                n.restoreFrozenState(f, vsel, restored, removeExisting);
-                // check if representing vh already exists somewhere
+                // check if representing versionable already exists somewhere
-                    if (hasNode(n.getQName())) {
+                    if (n.getParent().isSame(this)) {
-                    } else {
+                    } else if (removeExisting) {
+                    } else {
+                        // since we delete the OPV=Copy children beforehand, all
+                        // found nodes must be outside of this tree
+                        throw new ItemExistsException("Unable to restore node, item already exists outside of restored tree: " + n.safeGetJCRPath());
+                    // add this version to set
+                    restored.add(v);

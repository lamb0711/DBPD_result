JCR-1990: Optimize queries with relative path in order by clause

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@746946 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.lucene.index.TermDocs;
+import org.apache.lucene.index.TermPositions;
+import org.apache.lucene.index.TermDocs;
+import javax.jcr.PropertyType;
+
-    public static class StringIndex {
+    public static class ValueIndex {
-         * Terms indexed by document id.
+         * Values indexed by document id.
-        private final String[] terms;
+        private final Comparable[] values;
-         * Terms map indexed by document id.
+         * Values (Comparable) map indexed by document id.
-        public final Map termsMap;
+        public final Map valuesMap;
-         * Boolean indicating whether the hashMap impl has to be used
+         * Boolean indicating whether the {@link #valuesMap} impl has to be used
-        public StringIndex(String[] terms, int setValues) {
-            if (isSparse(terms, setValues)) {
+        public ValueIndex(Comparable[] values, int setValues) {
+            if (isSparse(values, setValues)) {
-                this.terms = null;
+                this.values = null;
-                    this.termsMap = null;
+                    this.valuesMap = null;
-                    this.termsMap = getTermsMap(terms, setValues);
+                    this.valuesMap = getValuesMap(values, setValues);
-                this.terms = terms;
-                this.termsMap = null;
+                this.values = values;
+                this.valuesMap = null;
-        public String getTerm(int i) {
+        public Comparable getValue(int i) {
-                return termsMap == null ? null : (String) termsMap.get(new Integer(i));
+                return valuesMap == null ? null : (Comparable) valuesMap.get(new Integer(i));
-                return terms[i];
+                return values[i];
-        private Map getTermsMap(String[] terms, int setValues) {
+        private Map getValuesMap(Comparable[] values, int setValues) {
-            for (int i = 0; i < terms.length && setValues > 0; i++) {
-                if (terms[i] != null) {
-                    map.put(new Integer(i), terms[i]);
+            for (int i = 0; i < values.length && setValues > 0; i++) {
+                if (values[i] != null) {
+                    map.put(new Integer(i), values[i]);
-        private boolean isSparse(String[] terms, int setValues) {
+        private boolean isSparse(Comparable[] values, int setValues) {
-            if (setValues * SPARSE_FACTOR < terms.length) {
+            if (setValues * SPARSE_FACTOR < values.length) {
-     * Creates a <code>StringIndex</code> for a <code>field</code> and a term
+     * Creates a <code>ValueIndex</code> for a <code>field</code> and a term
-     * The returned string index will <b>not</b> have a term lookup array!
-     * See {@link SharedFieldSortComparator} for more info.
-     * @return a StringIndex that contains the field values and order
+     * @return a ValueIndex that contains the field values and order
-    public SharedFieldCache.StringIndex getStringIndex(IndexReader reader,
-                                                 String field,
-                                                 String prefix,
-                                                 SortComparator comparator)
+    public ValueIndex getValueIndex(IndexReader reader,
+                                    String field,
+                                    String prefix,
+                                    SortComparator comparator)
-        SharedFieldCache.StringIndex ret = lookup(reader, field, prefix, comparator);
+        ValueIndex ret = lookup(reader, field, prefix, comparator);
-            final String[] retArray = new String[reader.maxDoc()];
+            Comparable[] retArray = new Comparable[reader.maxDoc()];
-                TermDocs termDocs = reader.termDocs();
+                IndexFormatVersion version = IndexFormatVersion.getVersion(reader);
+                boolean hasPayloads = version.isAtLeast(IndexFormatVersion.V3);
+                TermDocs termDocs;
+                byte[] payload = null;
+                int type;
+                if (hasPayloads) {
+                    termDocs = reader.termPositions();
+                    payload = new byte[1];
+                } else {
+                    termDocs = reader.termDocs();
+                }
+                            type = PropertyType.UNDEFINED;
+                            if (hasPayloads) {
+                                TermPositions termPos = (TermPositions) termDocs;
+                                termPos.nextPosition();
+                                if (termPos.isPayloadAvailable()) {
+                                    payload = termPos.getPayload(payload, 0);
+                                    type = PropertyMetaData.fromByteArray(payload).getPropertyType();
+                                }
+                            }
-                            retArray[termDocs.doc()] = value;
+                            retArray[termDocs.doc()] = getValue(value, type);
-            SharedFieldCache.StringIndex value = new SharedFieldCache.StringIndex(retArray, setValues);
+            ValueIndex value = new ValueIndex(retArray, setValues);
-     * See if a <code>StringIndex</code> object is in the cache.
+     * See if a <code>ValueIndex</code> object is in the cache.
-    SharedFieldCache.StringIndex lookup(IndexReader reader, String field,
+    ValueIndex lookup(IndexReader reader, String field,
-            return (SharedFieldCache.StringIndex) readerCache.get(key);
+            return (ValueIndex) readerCache.get(key);
-     * Put a <code>StringIndex</code> <code>value</code> to cache.
+     * Put a <code>ValueIndex</code> <code>value</code> to cache.
-                 SortComparator comparer, SharedFieldCache.StringIndex value) {
+                 SortComparator comparer, ValueIndex value) {
+     * Returns a comparable for the given <code>value</code> that is read from
+     * the index.
+     *
+     * @param value the value as read from the index.
+     * @param type the property type.
+     * @return a comparable for the <code>value</code>.
+     */
+    private Comparable getValue(String value, int type) {
+        switch (type) {
+            case PropertyType.BOOLEAN:
+                return ComparableBoolean.valueOf(Boolean.valueOf(value).booleanValue());
+            case PropertyType.DATE:
+                return new Long(DateField.stringToTime(value));
+            case PropertyType.LONG:
+                return new Long(LongField.stringToLong(value));
+            case PropertyType.DOUBLE:
+                return new Double(DoubleField.stringToDouble(value));
+            default:
+                return value;
+        }
+    }
+
+    /**
-         * Creates <code>Key</code> for StringIndex lookup.
+         * Creates <code>Key</code> for ValueIndex lookup.

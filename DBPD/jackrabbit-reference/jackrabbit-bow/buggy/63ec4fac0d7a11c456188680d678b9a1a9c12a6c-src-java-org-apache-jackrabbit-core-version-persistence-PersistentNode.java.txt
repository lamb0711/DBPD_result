redesigned transaction support & PersistenceManager

orginal code contributed by dominique pfister, required a lot of tweaking to make it run & work; not thoroughly tested

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@126221 13f79535-47bb-0310-9956-ffa450edef68

- * Copyright 2004-2005 The Apache Software Foundation or its licensors,
- *                     as applicable.
+ * Copyright 2004 The Apache Software Foundation.
+import javax.jcr.nodetype.NodeDef;
+import javax.jcr.nodetype.PropertyDef;
-class PersistentNode {
+public class PersistentNode {
-    private PersistentNodeState nodeState;
+    private NodeState nodeState;
-    private final PersistentItemStateProvider stateMgr;
+    private final ItemStateManager stateMgr;
+
+    /**
+     * the node type manager
+     */
+    private final NodeTypeManagerImpl ntMgr;
-     * @param statemgr
+     * @param stateMgr
+     * @param ntMgr
-    protected PersistentNode(PersistentItemStateProvider statemgr,
-                             PersistentNodeState nodeState) {
+    protected PersistentNode(ItemStateManager stateMgr,
+                             NodeTypeManagerImpl ntMgr,
+                             NodeState nodeState) {
-        this.stateMgr = statemgr;
+        this.stateMgr = stateMgr;
+        this.ntMgr = ntMgr;
-    protected PersistentNodeState getState() {
+    protected NodeState getState() {
-        PersistentPropertyState prop = getOrCreatePropertyState(name, type, multiple);
+
+        PropertyState prop = getOrCreatePropertyState(name, type, multiple);
-    private PersistentPropertyState getOrCreatePropertyState(QName name, int type, boolean multiValued)
+    private PropertyState getOrCreatePropertyState(QName name, int type, boolean multiValued)
-                PersistentPropertyState propState = (PersistentPropertyState) stateMgr.getItemState(propId);
+                PropertyState propState = (PropertyState) stateMgr.getItemState(propId);
-                if (propState.getStatus()==ItemState.STATUS_EXISTING) {
-                    propState.setStatus(ItemState.STATUS_EXISTING_MODIFIED);
-                }
-                // although this is not quite correct, we mark node as modified aswell
-                if (nodeState.getStatus()==ItemState.STATUS_EXISTING) {
-                    nodeState.setStatus(ItemState.STATUS_EXISTING_MODIFIED);
-                }
+                propState.setStatus(ItemState.STATUS_EXISTING_MODIFIED);
-            try {
-                PersistentPropertyState propState = stateMgr.createPropertyState(nodeState.getUUID(), name);
-                propState.setType(type);
-                propState.setMultiValued(multiValued);
-                propState.setDefinitionId(PropDefId.valueOf("0"));
-                // need to store nodestate
-                nodeState.addPropertyEntry(name);
-                if (nodeState.getStatus()==ItemState.STATUS_EXISTING) {
-                    nodeState.setStatus(ItemState.STATUS_EXISTING_MODIFIED);
-                }
-                return propState;
-            } catch (ItemStateException e) {
-                throw new RepositoryException("Unable to store property: " + e.toString());
-            }
+            PropertyDefImpl def = getApplicablePropertyDef(name, type, multiValued);
+            //@todo create property state inside an update
+            PropertyState propState = new PropertyState(name, nodeState.getUUID(),
+                    PropertyState.STATUS_NEW, false);
+            propState.setType(type);
+            propState.setMultiValued(multiValued);
+            propState.setDefinitionId(new PropDefId(def.unwrap()));
+
+            // need to store nodestate
+            nodeState.addPropertyEntry(name);
+            nodeState.setStatus(ItemState.STATUS_EXISTING_MODIFIED);
+            return propState;
+        }
+    }
+
+    /**
+     * retrieves the property definition for the given contraints
+     *
+     * @param propertyName
+     * @param type
+     * @param multiValued
+     * @return
+     * @throws RepositoryException
+     */
+    protected PropertyDefImpl getApplicablePropertyDef(QName propertyName,
+                                                       int type, boolean multiValued)
+            throws RepositoryException {
+        PropDef pd = getEffectiveNodeType().getApplicablePropertyDef(propertyName, type, multiValued);
+        return ntMgr.getPropDef(new PropDefId(pd));
+    }
+
+    /**
+     * Retrieves the node definition for the given contraints.
+     *
+     * @param nodeName
+     * @param nodeTypeName
+     * @return
+     * @throws RepositoryException
+     */
+    protected NodeDefImpl getApplicableChildNodeDef(QName nodeName, QName nodeTypeName)
+            throws RepositoryException {
+        ChildNodeDef cnd = getEffectiveNodeType().getApplicableChildNodeDef(nodeName, nodeTypeName);
+        return ntMgr.getNodeDef(new NodeDefId(cnd));
+    }
+
+    /**
+     * Returns the effective (i.e. merged and resolved) node type representation
+     * of this node's primary and mixin node types.
+     *
+     * @return the effective node type
+     * @throws RepositoryException
+     */
+    protected EffectiveNodeType getEffectiveNodeType() throws RepositoryException {
+        // build effective node type of mixins & primary type
+        NodeTypeRegistry ntReg = ntMgr.getNodeTypeRegistry();
+        // existing mixin's
+        HashSet set = new HashSet(nodeState.getMixinTypeNames());
+        // primary type
+        set.add(nodeState.getNodeTypeName());
+        try {
+            return ntReg.getEffectiveNodeType((QName[]) set.toArray(new QName[set.size()]));
+        } catch (NodeTypeConflictException ntce) {
+            String msg = "internal error: failed to build effective node type for node " + nodeState.getUUID();
+            throw new RepositoryException(msg, ntce);
-            if (nodeState.getStatus()==ItemState.STATUS_EXISTING) {
-                nodeState.setStatus(ItemState.STATUS_EXISTING_MODIFIED);
-            }
+            nodeState.setStatus(ItemState.STATUS_EXISTING_MODIFIED);
-            PersistentNodeState state = (PersistentNodeState) stateMgr.getItemState(new NodeId(entry.getUUID()));
-            return new PersistentNode(stateMgr, state);
+            NodeState state = (NodeState) stateMgr.getItemState(new NodeId(entry.getUUID()));
+            return new PersistentNode(stateMgr, ntMgr, state);
-            PersistentNodeState state = (PersistentNodeState) stateMgr.getItemState(new NodeId(uuid));
-            return new PersistentNode(stateMgr, state);
+            NodeState state = (NodeState) stateMgr.getItemState(new NodeId(uuid));
+            return new PersistentNode(stateMgr, ntMgr, state);
-        return createChildNode(nodeName, nodeTypeName, null);
+        NodeTypeImpl nodeType = ntMgr.getNodeType(nodeTypeName);
+        NodeDefImpl def;
+        try {
+            def = getApplicableChildNodeDef(name, nodeType == null ? null : nodeType.getQName());
+        } catch (RepositoryException re) {
+            // hack, use nt:unstructured as parent
+            try {
+                NodeTypeRegistry ntReg = ntMgr.getNodeTypeRegistry();
+                EffectiveNodeType ent = ntReg.getEffectiveNodeType(new QName[]{NodeTypeRegistry.NT_UNSTRUCTURED});
+                ChildNodeDef cnd = ent.getApplicableChildNodeDef(name, nodeTypeName);
+                def = ntMgr.getNodeDef(new NodeDefId(cnd));
+            } catch (NodeTypeConflictException e) {
+                String msg = "no definition found in parent node's node type for new node";
+                throw new ConstraintViolationException(msg, re);
+            }
+        }
+
+        if (nodeType == null) {
+            // use default node type
+            nodeType = (NodeTypeImpl) def.getDefaultPrimaryType();
+        }
+        return createChildNode(nodeName, def, nodeType, null);
+     * @param def
+     * @param nodeType
-    private PersistentNode createChildNode(QName name, QName nodeTypeName, String uuid)
+    private PersistentNode createChildNode(QName name, NodeDefImpl def,
+                                           NodeTypeImpl nodeType, String uuid)
-        PersistentNodeState state = null;
-        try {
-            if (uuid == null) {
-                uuid = UUID.randomUUID().toString();	// version 4 uuid
-            }
-            state = stateMgr.createNodeState(uuid, nodeTypeName, parentUUID);
-            state.setDefinitionId(NodeDefId.valueOf("0"));
-        } catch (ItemStateException ise) {
-            String msg = "failed to add child node " + name + " to " + parentUUID;
-            throw new RepositoryException(msg, ise);
+        NodeState state = null;
+        if (uuid == null) {
+            uuid = UUID.randomUUID().toString();	// version 4 uuid
+        //@todo create node state inside an update
+        state = new NodeState(uuid, nodeType.getQName(), parentUUID,
+                NodeState.STATUS_NEW, false);
+        state.setDefinitionId(new NodeDefId(def.unwrap()));
-        PersistentNode node = new PersistentNode(stateMgr, state);
+        PersistentNode node = new PersistentNode(stateMgr, ntMgr, state);
-        if (nodeState.getStatus()==ItemState.STATUS_EXISTING) {
-            nodeState.setStatus(ItemState.STATUS_EXISTING_MODIFIED);
+        nodeState.setStatus(ItemState.STATUS_EXISTING_MODIFIED);
+
+        // add 'auto-create' properties defined in node type
+        PropertyDef[] pda = nodeType.getAutoCreatePropertyDefs();
+        for (int i = 0; i < pda.length; i++) {
+            PropertyDefImpl pd = (PropertyDefImpl) pda[i];
+            node.getOrCreatePropertyState(pd.getQName(), pd.getRequiredType(), pd.isMultiple());
+
+        // recursively add 'auto-create' child nodes defined in node type
+        NodeDef[] nda = nodeType.getAutoCreateNodeDefs();
+        for (int i = 0; i < nda.length; i++) {
+            NodeDefImpl nd = (NodeDefImpl) nda[i];
+            node.createChildNode(nd.getQName(), nd, (NodeTypeImpl) nd.getDefaultPrimaryType(), null);
+        }
+
+        // store primary type
+        node.setPropertyValue(ItemImpl.PROPNAME_PRIMARYTYPE, InternalValue.create(nodeType.getQName()));
-                PersistentNodeState state = (PersistentNodeState) stateMgr.getItemState(new NodeId(entry.getUUID()));
-                children[i] = new PersistentNode(stateMgr, state);
+                NodeState state = (NodeState) stateMgr.getItemState(new NodeId(entry.getUUID()));
+                children[i] = new PersistentNode(stateMgr, ntMgr, state);
-            store(nodeState);
+            UpdateOperation update = stateMgr.beginUpdate();
+            store(nodeState, update);
+            update.end();
+     * @param update update operation
-    private void store(PersistentNodeState state) throws ItemStateException {
+    private void store(NodeState state, UpdateOperation update)
+            throws ItemStateException {
+
-                PersistentPropertyState pstate = (PersistentPropertyState) stateMgr.getItemState(new PropertyId(state.getUUID(), entry.getName()));
+                PropertyState pstate = (PropertyState) stateMgr.getItemState(new PropertyId(state.getUUID(), entry.getName()));
-                    pstate.store();
+                    update.store(pstate);
-                PersistentNodeState nstate = (PersistentNodeState) stateMgr.getItemState(new NodeId(entry.getUUID()));
-                store(nstate);
+                NodeState nstate = (NodeState) stateMgr.getItemState(new NodeId(entry.getUUID()));
+                store(nstate, update);
-            state.store();
+            update.store(state);
-            nodeState = (PersistentNodeState) stateMgr.getItemState(nodeState.getId());
+            nodeState = (NodeState) stateMgr.getItemState(nodeState.getId());
-    private void reload(PersistentNodeState state) throws ItemStateException {
+    private void reload(NodeState state) throws ItemStateException {
-                PersistentPropertyState pstate = (PersistentPropertyState) stateMgr.getItemState(new PropertyId(state.getUUID(), entry.getName()));
+                PropertyState pstate = (PropertyState) stateMgr.getItemState(new PropertyId(state.getUUID(), entry.getName()));
-                PersistentNodeState nstate = (PersistentNodeState) stateMgr.getItemState(new NodeId(entry.getUUID()));
+                NodeState nstate = (NodeState) stateMgr.getItemState(new NodeId(entry.getUUID()));
-            setPropertyValues(prop.getQName(), values[0].getType(), values);
+            int type = values.length>0 ? values[0].getType() : prop.getDefinition().getRequiredType();
+            setPropertyValues(prop.getQName(), type, values);

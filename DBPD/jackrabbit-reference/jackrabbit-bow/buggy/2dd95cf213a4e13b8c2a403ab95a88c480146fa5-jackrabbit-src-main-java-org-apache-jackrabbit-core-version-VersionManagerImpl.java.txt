[JCR-335] Deadlock caused by versioning operations within transaction

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@393004 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.collections.map.ReferenceMap;
-import org.apache.jackrabbit.core.NodeId;
-import org.apache.jackrabbit.core.NodeImpl;
-import org.apache.jackrabbit.core.PropertyId;
-import org.apache.jackrabbit.core.SessionImpl;
-import org.apache.jackrabbit.core.fs.FileSystem;
-import org.apache.jackrabbit.core.nodetype.NodeTypeRegistry;
-import org.apache.jackrabbit.core.observation.DelegatingObservationDispatcher;
-import org.apache.jackrabbit.core.observation.EventStateCollection;
-import org.apache.jackrabbit.core.observation.EventStateCollectionFactory;
-import org.apache.jackrabbit.core.state.ChangeLog;
-import org.apache.jackrabbit.core.state.ItemStateException;
-import org.apache.jackrabbit.core.state.LocalItemStateManager;
-import org.apache.jackrabbit.core.state.NodeReferences;
-import org.apache.jackrabbit.core.state.NodeReferencesId;
-import org.apache.jackrabbit.core.state.NodeState;
-import org.apache.jackrabbit.core.state.PersistenceManager;
-import org.apache.jackrabbit.core.state.PropertyState;
-import org.apache.jackrabbit.core.state.SharedItemStateManager;
-import org.apache.jackrabbit.core.value.InternalValue;
-import org.apache.jackrabbit.core.virtual.VirtualItemStateProvider;
-import org.apache.jackrabbit.name.QName;
-import org.apache.jackrabbit.name.Path;
-import org.apache.jackrabbit.name.MalformedPathException;
+import org.apache.commons.collections.map.ReferenceMap;
+import org.apache.jackrabbit.core.observation.EventStateCollection;
+import org.apache.jackrabbit.core.observation.DelegatingObservationDispatcher;
+import org.apache.jackrabbit.core.observation.EventStateCollectionFactory;
+import org.apache.jackrabbit.core.SessionImpl;
+import org.apache.jackrabbit.core.NodeId;
+import org.apache.jackrabbit.core.PropertyId;
+import org.apache.jackrabbit.core.NodeImpl;
+import org.apache.jackrabbit.core.virtual.VirtualItemStateProvider;
+import org.apache.jackrabbit.core.value.InternalValue;
+import org.apache.jackrabbit.core.nodetype.NodeTypeRegistry;
+import org.apache.jackrabbit.core.fs.FileSystem;
+import org.apache.jackrabbit.core.state.PersistenceManager;
+import org.apache.jackrabbit.core.state.SharedItemStateManager;
+import org.apache.jackrabbit.core.state.LocalItemStateManager;
+import org.apache.jackrabbit.core.state.PropertyState;
+import org.apache.jackrabbit.core.state.NodeState;
+import org.apache.jackrabbit.core.state.ChangeLog;
+import org.apache.jackrabbit.core.state.ItemStateException;
+import org.apache.jackrabbit.core.state.NodeReferences;
+import org.apache.jackrabbit.core.state.NodeReferencesId;
+import org.apache.jackrabbit.name.Path;
+import org.apache.jackrabbit.name.QName;
+import org.apache.jackrabbit.name.MalformedPathException;
-import javax.jcr.PropertyType;
-import javax.jcr.ReferentialIntegrityException;
+import javax.jcr.PropertyType;
-import javax.jcr.version.Version;
-import javax.jcr.version.VersionException;
+import javax.jcr.ReferentialIntegrityException;
-import java.util.ArrayList;
+import javax.jcr.version.VersionException;
+import javax.jcr.version.Version;
-import java.util.Collections;
+import java.util.ArrayList;
+import java.util.Collections;
-        implements EventStateCollectionFactory {
+        /*implements EventStateCollectionFactory*/ {
-     * the observation manager
+     * the dynamic event state collection factory
-    private DelegatingObservationDispatcher obsMgr;
+    private final DynamicESCFactory escFactory;
-     * Session to be used when creating observation events.
-     */
-    private transient SessionImpl eventSource;
-
-    /**
-     * workaround for potential deadlock
-     */
-    private final Object eventSourceLock = new Object();
-
-    /**
-            this.obsMgr = obsMgr;
+            this.escFactory = new DynamicESCFactory(obsMgr);
-            stateMgr = new LocalItemStateManager(sharedStateMgr, this);
+            stateMgr = new LocalItemStateManager(sharedStateMgr, escFactory);
+     * Returns the event state collection factory.
+     * @return the event state collection factory.
+     */
+    public DynamicESCFactory getEscFactory() {
+        return escFactory;
+    }
+
+    /**
-    public VersionHistory createVersionHistory(Session session, NodeState node)
+    public VersionHistory createVersionHistory(Session session, final NodeState node)
-        InternalVersionHistory history;
-        synchronized (eventSourceLock) {
-            // This needs to be synchronized since it sets the event source
-            // to be used when creating the events to be dispatched later on.
-            eventSource = (SessionImpl) session;
-
-            history = createVersionHistory(node);
-        }
+        InternalVersionHistory history = (InternalVersionHistory)
+                escFactory.doSourced((SessionImpl) session, new SourcedTarget(){
+            public Object run() throws RepositoryException {
+                return createVersionHistory(node);
+            }
+        });
-    public Version checkin(NodeImpl node) throws RepositoryException {
-        InternalVersion version;
+    public Version checkin(final NodeImpl node) throws RepositoryException {
+        InternalVersion version = (InternalVersion)
+                escFactory.doSourced((SessionImpl) node.getSession(), new SourcedTarget(){
+            public Object run() throws RepositoryException {
+                String histUUID = node.getProperty(QName.JCR_VERSIONHISTORY).getString();
+                InternalVersion version = checkin((InternalVersionHistoryImpl)
+                        getVersionHistory(NodeId.valueOf(histUUID)), node);
-        synchronized (eventSourceLock) {
-            // This  needs to be synchronized since it sets the event source
-            // to be used when creating the events to be dispatched later on.
-            eventSource = (SessionImpl) node.getSession();
-
-            String histUUID = node.getProperty(QName.JCR_VERSIONHISTORY).getString();
-            version = checkin((InternalVersionHistoryImpl)
-                    getVersionHistory(NodeId.valueOf(histUUID)), node);
-
-            // invalidate predecessors successor properties
-            InternalVersion[] preds = version.getPredecessors();
-            for (int i = 0; i < preds.length; i++) {
-                PropertyId propId = new PropertyId(preds[i].getId(), QName.JCR_SUCCESSORS);
-                versProvider.onPropertyChanged(propId);
+                // invalidate predecessors successor properties
+                InternalVersion[] preds = version.getPredecessors();
+                for (int i = 0; i < preds.length; i++) {
+                    PropertyId propId = new PropertyId(preds[i].getId(), QName.JCR_SUCCESSORS);
+                    versProvider.onPropertyChanged(propId);
+                }
+                return version;
-        }
-        return (AbstractVersion) eventSource.getNodeById(version.getId());
+        });
+
+        return (AbstractVersion)
+                ((SessionImpl) node.getSession()).getNodeById(version.getId());
-    public void removeVersion(VersionHistory history, QName name)
+    public void removeVersion(VersionHistory history, final QName name)
-        AbstractVersionHistory historyImpl = (AbstractVersionHistory) history;
+        final AbstractVersionHistory historyImpl = (AbstractVersionHistory) history;
-        synchronized (eventSourceLock) {
-            // This needs to be synchronized since it sets the event source
-            // to be used when creating the events to be dispatched later on.
-            eventSource = (SessionImpl) history.getSession();
+        escFactory.doSourced((SessionImpl) history.getSession(), new SourcedTarget(){
+            public Object run() throws RepositoryException {
+                AbstractVersion version = (AbstractVersion) historyImpl.getNode(name);
+                InternalVersion[] preds = version.getInternalVersion().getPredecessors();
-            // save away predecessors before removing version
-            AbstractVersion version = (AbstractVersion) historyImpl.getNode(name);
-            InternalVersion[] preds = version.getInternalVersion().getPredecessors();
+                InternalVersionHistoryImpl vh = (InternalVersionHistoryImpl)
+                        historyImpl.getInternalVersionHistory();
+                removeVersion(vh, name);
-            InternalVersionHistoryImpl vh = (InternalVersionHistoryImpl)
-                    historyImpl.getInternalVersionHistory();
-            removeVersion(vh, name);
-
-            // invalidate predecessors successor properties
-            for (int i = 0; i < preds.length; i++) {
-                PropertyId propId = new PropertyId(preds[i].getId(), QName.JCR_SUCCESSORS);
-                versProvider.onPropertyChanged(propId);
+                // invalidate predecessors successor properties
+                for (int i = 0; i < preds.length; i++) {
+                    PropertyId propId = new PropertyId(preds[i].getId(), QName.JCR_SUCCESSORS);
+                    versProvider.onPropertyChanged(propId);
+                }
+                return null;
-        }
+        });
-    public Version setVersionLabel(VersionHistory history,
-                                                QName version, QName label,
-                                                boolean move)
+    public Version setVersionLabel(final VersionHistory history,
+                                   final QName version, final QName label,
+                                   final boolean move)
-        AbstractVersionHistory historyImpl = (AbstractVersionHistory) history;
-        InternalVersion v;
-        synchronized (eventSourceLock) {
-            // This  needs to be synchronized since it sets the event source
-            // to be used when creating the events to be dispatched later on.
-            eventSource = (SessionImpl) history.getSession();
+        InternalVersion v = (InternalVersion)
+                escFactory.doSourced((SessionImpl) history.getSession(), new SourcedTarget(){
+            public Object run() throws RepositoryException {
+                InternalVersionHistoryImpl vh = (InternalVersionHistoryImpl)
+                        ((AbstractVersionHistory) history).getInternalVersionHistory();
+                return setVersionLabel(vh, version, label, move);
+            }
+        });
-            InternalVersionHistoryImpl vh = (InternalVersionHistoryImpl)
-                    historyImpl.getInternalVersionHistory();
-            v = setVersionLabel(vh, version, label, move);
-        }
-            return (Version) eventSource.getNodeByUUID(v.getId().getUUID());
+            return (Version)
+                    ((SessionImpl) history.getSession()).getNodeByUUID(v.getId().getUUID());
-    //------------------------------------------< EventStateCollectionFactory >
-
-    /**
-     * {@inheritDoc}
-     * <p/>
-     * This object uses one instance of a <code>LocalItemStateManager</code>
-     * to update data on behalf of many sessions. In order to maintain the
-     * association between update operation and session who actually invoked
-     * the update, an internal event source is used.
-     */
-    public synchronized EventStateCollection createEventStateCollection()
-            throws RepositoryException {
-
-        if (eventSource == null) {
-            throw new RepositoryException("Unknown event source.");
-        }
-        return createEventStateCollection(eventSource);
-    }
-
-    /**
-     * Creates an {@link EventStateCollection} using the given <code>source</code>.
-     * @param source the Session that did the changes.
-     * @return <code>EventStateCollection</code>.
-     */
-    EventStateCollection createEventStateCollection(SessionImpl source) {
-        return obsMgr.createEventStateCollection(source, VERSION_STORAGE_PATH);
-    }
-
+
+    public static final class DynamicESCFactory implements EventStateCollectionFactory {
+
+        /**
+         * the observation manager
+         */
+        private DelegatingObservationDispatcher obsMgr;
+
+        /**
+         * the current event source
+         */
+        private SessionImpl source;
+
+
+        /**
+         * Creates a new event state collection factory
+         * @param obsMgr
+         */
+        public DynamicESCFactory(DelegatingObservationDispatcher obsMgr) {
+            this.obsMgr = obsMgr;
+        }
+
+        /**
+         * {@inheritDoc}
+         * <p/>
+         * This object uses one instance of a <code>LocalItemStateManager</code>
+         * to update data on behalf of many sessions. In order to maintain the
+         * association between update operation and session who actually invoked
+         * the update, an internal event source is used.
+         */
+        public synchronized EventStateCollection createEventStateCollection()
+                throws RepositoryException {
+            if (source == null) {
+                throw new RepositoryException("Unknown event source.");
+            }
+            return createEventStateCollection(source);
+        }
+
+        /**
+         * {@inheritDoc}
+         * <p/>
+         * This object uses one instance of a <code>LocalItemStateManager</code>
+         * to update data on behalf of many sessions. In order to maintain the
+         * association between update operation and session who actually invoked
+         * the update, an internal event source is used.
+         */
+        public EventStateCollection createEventStateCollection(SessionImpl source) {
+            return obsMgr.createEventStateCollection(source, VERSION_STORAGE_PATH);
+        }
+
+        /**
+         * Executes the given runnable using the given event source.
+         *
+         * @param eventSource
+         * @param runnable
+         * @throws RepositoryException
+         */
+        public synchronized Object doSourced(SessionImpl eventSource, SourcedTarget runnable)
+                throws RepositoryException {
+            this.source = eventSource;
+            try {
+                return runnable.run();
+            } finally {
+                this.source = null;
+            }
+        }
+    }
+
+    private abstract class SourcedTarget {
+        public abstract Object run() throws RepositoryException;
+    }

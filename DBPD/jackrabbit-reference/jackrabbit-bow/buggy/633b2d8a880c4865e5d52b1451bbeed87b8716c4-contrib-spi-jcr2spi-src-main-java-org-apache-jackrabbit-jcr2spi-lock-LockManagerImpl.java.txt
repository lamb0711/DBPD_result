fixed: move, reorder (work in progress)
fixed: locktoken transfer
fixed: recursive transient removal of invalidated tree fails (restoreTests)
improve: simplify usage of workspace operations
fixed: store original itemId with transient operations in order to properly reflect the changelog upon batch creation
fixed: workspace import doesn't invalidate
fixed: session import uuid handling




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@513279 13f79535-47bb-0310-9956-ffa450edef68

+ * TODO: TOBEFIXED. Lock objects obtained through this mgr are not informed if another session is or becomes lock-holder and removes the lock again.
-     * delegated to {@link WorkspaceManager#removeLockToken(String)} and
-     * all locks stored in the local lock map are notified by the removed
-     * token in order to give them the chance to update their lock information.
+     * delegated to {@link WorkspaceManager#removeLockToken(String)}.
+     * All locks stored in the local lock map are notified by the removed
+     * token in order have them updated their lock information.
-        if (!found) {
-            String msg = "Unable to remove lock token: lock is held by another session.";
-            log.warn(msg);
-            throw new RepositoryException(msg);
-        }
-
-        // remove lock token from sessionInfo
+        // remove lock token from sessionInfo. call will fail, if the session
+        // is not lock holder.
-     * not even readable completely.
+     * not even readable completely. For this reason it seem equally reasonable
+     * to search for jcr:lockIsDeep property only and omitting all kind of
+     * verification regarding nodetypes present.
-        /**
-         * TODO: should not only rely on existence of jcr:lockIsDeep property
-         * but also verify that node.isNodeType("mix:lockable")==true;
-         * this would have a negative impact on performance though...
-         */
+        NodeId nId = nodeState.getNodeId();
-            lockInfo = wspManager.getLockInfo(nodeState.getNodeId());
+            lockInfo = wspManager.getLockInfo(nId);
-        if (lockNodeId.equals(nodeState.getId())) {
+        if (lockNodeId.equals(nId)) {
+        NodeState nState = nodeState;
+        // access first non-NEW state
+        while (nState.getStatus() == Status.NEW) {
+            try {
+                nState = nState.getParent();
+            } catch (ItemStateException e) {
+                // should never occur, since NEW states must have an accessible parent
+                throw new RepositoryException("Intenal error", e);
+            }
+        }
-        // accessed before (thus is known to the manager) irrespective if the
-        // current session is the lock holder or not.
-        if (lockMap.containsKey(nodeState)) {
-            return (LockImpl) lockMap.get(nodeState);
+        // store in the lock map. see below (LockImpl) for the conditions that
+        // must be met in order a lock can be stored.
+        if (lockMap.containsKey(nState)) {
+            return (LockImpl) lockMap.get(nState);
-            NodeState lockHoldingState = getLockHoldingState(nodeState);
+            NodeState lockHoldingState = getLockHoldingState(nState);
-                // no lock
+                // assume no lock is present (might not be correct due to incomplete hierarchy)
-            lState = buildLockState(nodeState);
+            // need correct information about lock status -> retrieve lockInfo
+            // from the persistent layer.
+            lState = buildLockState(nState);
-        // Lock has never been access -> build the lock object
-        // retrieve lock holding node. note that this may fail if the session
-        // does not have permission to see this node.
-        if (lState != null && lState.appliesToNodeState(nodeState)) {
-            Item lockHoldingNode = itemManager.getItem(lState.lockHoldingState.getHierarchyEntry());
-            return new LockImpl(lState, (Node)lockHoldingNode);
+        if (lState != null) {
+            // Test again if a Lock object is stored in the lockmap. Otherwise
+            // build the lock object and retrieve lock holding node. note that this
+            // may fail if the session does not have permission to see this node.
+            LockImpl lock;
+            if (lockMap.containsKey(lState.lockHoldingState)) {
+                lock = (LockImpl) lockMap.get(lState.lockHoldingState);
+                lock.lockState.lockInfo = lState.lockInfo;
+            } else {
+                Item lockHoldingNode = itemManager.getItem(lState.lockHoldingState.getHierarchyEntry());
+                lock = new LockImpl(lState, (Node)lockHoldingNode);
+            }
+            // test if lock applies to the original nodestate
+            if (lState.appliesToNodeState(nodeState)) {
+                return lock;
+            } else {
+                return null; // lock exists but doesn't apply to the given state
+            }
-            // lock exists but does not apply to the given node state
-            // passed to this method.
+            // no lock at all
-            } else if (isSessionScoped() && isHoldBySession()) {
+            } else if (isHoldBySession()) {
+                // TODO: TOBEFIXED. since another session may become lock-holder for
+                // an open-scoped lock, the map entry and the lock information
+                // stored therein may become outdated.

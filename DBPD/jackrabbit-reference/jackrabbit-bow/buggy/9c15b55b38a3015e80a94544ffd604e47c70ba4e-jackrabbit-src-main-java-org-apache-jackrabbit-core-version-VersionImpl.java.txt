Removing superfluous AbstractVersion and AbstractVersionHistory


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@424021 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.NodeImpl;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import javax.jcr.InvalidItemStateException;
+import javax.jcr.Item;
+import javax.jcr.NodeIterator;
+import javax.jcr.RepositoryException;
+import javax.jcr.nodetype.ConstraintViolationException;
+import javax.jcr.version.Version;
+import javax.jcr.version.VersionHistory;
+import java.util.Calendar;
- * This Class implements a Version that extends the node interface
+ * Base implementation of the {@link javax.jcr.version.Version} interface.
-public class VersionImpl extends AbstractVersion {
+public class VersionImpl extends NodeImpl implements Version {
-     * creates a new version node
-     *
-     * @param itemMgr
-     * @param session
-     * @param id
-     * @param state
-     * @param definition
-     * @param listeners
-     * @param version
+     * Logger instance.
+     */
+    private static Logger log = LoggerFactory.getLogger(VersionImpl.class);
+
+    /**
+     * Create a new instance of this class.
+     * @param itemMgr item manager
+     * @param session session
+     * @param id node id
+     * @param state node state
+     * @param definition node definition
+     * @param listeners life cycle listeners
-                       NodeState state, NodeDefinition definition,
-                       ItemLifeCycleListener[] listeners,
-                       InternalVersion version) {
+                          NodeState state, NodeDefinition definition,
+                          ItemLifeCycleListener[] listeners) {
+    /**
+     * Returns the internal version. Subclass responsibility.
+     * @return internal version
+     * @throws RepositoryException if the internal version is not available
+     */
+    protected InternalVersion getInternalVersion() throws RepositoryException {
+        InternalVersion version =
+                session.getVersionManager().getVersion((NodeId) id);
+        if (version == null) {
+            throw new InvalidItemStateException(id + ": the item does not exist anymore");
+        }
+        return version;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public Calendar getCreated() throws RepositoryException {
+        return getInternalVersion().getCreated();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public Version[] getSuccessors() throws RepositoryException {
+        // need to wrap it around proper node
+        InternalVersion[] suc = getInternalVersion().getSuccessors();
+        Version[] ret = new Version[suc.length];
+        for (int i = 0; i < suc.length; i++) {
+            ret[i] = (Version) session.getNodeById(suc[i].getId());
+        }
+        return ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public Version[] getPredecessors() throws RepositoryException {
+        // need to wrap it around proper node
+        InternalVersion[] pred = getInternalVersion().getPredecessors();
+        Version[] ret = new Version[pred.length];
+        for (int i = 0; i < pred.length; i++) {
+            ret[i] = (Version) session.getNodeById(pred[i].getId());
+        }
+        return ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public VersionHistory getContainingHistory() throws RepositoryException {
+        return (VersionHistory) getParent();
+    }
+
+    /**
+     * Returns the frozen node of this version
+     *
+     * @return
+     * @throws javax.jcr.RepositoryException
+     */
+    public InternalFrozenNode getFrozenNode() throws RepositoryException {
+        return getInternalVersion().getFrozenNode();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean isSame(Item otherItem) {
+        if (otherItem instanceof VersionImpl) {
+            // since all versions live in the same workspace, we can compare the uuids
+            try {
+                InternalVersion other = ((VersionImpl) otherItem).getInternalVersion();
+                return other.getId().equals(getInternalVersion().getId());
+            } catch (RepositoryException e) {
+                log.warn("Unable to retrieve internal version objects: " + e.getMessage());
+                log.debug("Stack dump:", e);
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Checks if this version is more recent than the given version <code>v</code>.
+     * A version is more recent if and only if it is a successor (or a successor
+     * of a successor, etc., to any degree of separation) of the compared one.
+     *
+     * @param v the version to check
+     * @return <code>true</code> if the version is more recent;
+     *         <code>false</code> otherwise.
+     */
+    public boolean isMoreRecent(VersionImpl v) throws RepositoryException {
+        return getInternalVersion().isMoreRecent(v.getInternalVersion());
+    }
+
+    /**
+     * Checks if this is the root version.
+     * @return <code>true</code> if this version is the root version;
+     *         <code>false</code> otherwise.
+     */
+    public boolean isRootVersion() throws RepositoryException {
+        return getInternalVersion().isRootVersion();
+    }
+
+    //--------------------------------------< Overwrite "protected" methods >---
+
+
+    /**
+     * Always throws a {@link javax.jcr.nodetype.ConstraintViolationException} since this node
+     * is protected.
+     *
+     * @throws javax.jcr.nodetype.ConstraintViolationException
+     */
+    public void update(String srcWorkspaceName) throws ConstraintViolationException {
+        String msg = "update operation not allowed on a version node: " + safeGetJCRPath();
+        log.debug(msg);
+        throw new ConstraintViolationException(msg);
+    }
+
+    /**
+     * Always throws a {@link javax.jcr.nodetype.ConstraintViolationException} since this node
+     * is protected.
+     *
+     * @throws javax.jcr.nodetype.ConstraintViolationException
+     */
+    public NodeIterator merge(String srcWorkspace, boolean bestEffort)
+            throws ConstraintViolationException {
+        String msg = "merge operation not allowed on a version node: " + safeGetJCRPath();
+        log.debug(msg);
+        throw new ConstraintViolationException(msg);
+    }
+

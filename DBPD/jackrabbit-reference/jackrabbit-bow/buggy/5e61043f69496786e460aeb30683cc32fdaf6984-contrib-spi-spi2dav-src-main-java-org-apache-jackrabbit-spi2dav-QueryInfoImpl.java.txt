work in progress

- SPI: replace String/Stream for values by QValue interface
- SPI: add factory for QValue
  > adjust commons and add implementation
  > adjust usages of former QValue object with jcr2spi, spi2dav
- RepositoryService.getChildInfos returns Iterator instead of Collection
- spi2dav: add implementation for new query interfaces

- TODO: 
  improve conversion of jcr-value to q-value and vice-versa




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@497885 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.AbstractCollection;
+import javax.jcr.Value;
+import org.apache.jackrabbit.spi.QValueFactory;
+import org.apache.jackrabbit.spi.QueryResultRow;
+import org.apache.jackrabbit.spi.QValue;
+import org.apache.jackrabbit.value.ValueFormat;
-    private final Map results = new LinkedHashMap();
+    private static final double UNDEFINED_SCORE = -1;
-    private final NamespaceResolver nsResolver;
+    private int scoreIndex = -1;
+    private final Map results = new LinkedHashMap();
-                         NamespaceResolver nsResolver, ValueFactory valueFactory)
+                         NamespaceResolver nsResolver, ValueFactory valueFactory,
+                         QValueFactory qValueFactory)
-        this.nsResolver = nsResolver;
+                    if (QName.JCR_SCORE.equals(columnNames[i])) {
+                        scoreIndex = i;
+                    }
+            Value[] values = resultProp.getValues();
+            QValue[] qValues = new QValue[values.length];
+            for (int j = 0; j < values.length; j++) {
+                try {
+                    qValues[j] = (values[j] == null) ?  null : ValueFormat.getQValue(values[j], nsResolver, qValueFactory);
+                } catch (RepositoryException e) {
+                    // should not occur
+                    log.error("Malformed value: " + values[j].toString());
+                }
+            }
-            this.results.put(nodeId, resultProp);
+            results.put(nodeId, qValues);
+    /**
+     * @see QueryInfo#getRows()
+     */
-      // TODO: objects need to implement QueryResultRow
-      
-      return new IteratorHelper(new AbstractCollection() {
-            public int size() {
-                return results.size();
-            }
-
-            public Iterator iterator() {
-                return results.keySet().iterator();
-            }
-        });
+        return new QueryResultRowIteratorImpl();
+    /**
+     * @see QueryInfo#getColumnNames()
+     */
-//    public String[] getValues(NodeId nodeId) {
-//        SearchResultProperty prop = (SearchResultProperty) results.get(nodeId);
-//        if (prop == null) {
-//            throw new NoSuchElementException();
-//        } else {
-//            Value[] values = prop.getValues();
-//            String[] ret = new String[values.length];
-//            for (int i = 0; i < values.length; i++) {
-//                try {
-//                    QValue qValue = (values[i] == null) ?  null : ValueFormat.getQValue(values[i], nsResolver);
-//                    ret[i] = qValue.getString();
-//                } catch (RepositoryException e) {
-//                    // should not occur
-//                    log.error("malformed value: " + values[i].toString());
-//                }
-//            }
-//            return ret;
-//        }
-//    }
-//
-//    public InputStream[] getValuesAsStream(NodeId nodeId) {
-//        SearchResultProperty prop = (SearchResultProperty) results.get(nodeId);
-//        if (prop == null) {
-//            throw new NoSuchElementException();
-//        } else {
-//            Value[] values = prop.getValues();
-//            InputStream[] ret = new InputStream[values.length];
-//            for (int i = 0; i < ret.length; i++) {
-//                try {
-//                    // make sure we return the qualified value if the type is
-//                    // name or path.
-//                    if (values[i].getType() == PropertyType.NAME || values[i].getType() == PropertyType.PATH) {
-//                        ret[i] = ValueFormat.getQValue(values[i], nsResolver).getStream();
-//                    } else {
-//                        ret[i] = values[i].getStream();
-//                    }
-//                } catch (RepositoryException e) {
-//                    // ignore this value
-//                    log.warn("unable to get stream value: " + values[i].toString());
-//                }
-//            }
-//            return ret;
-//        }
-//    }
+    private class QueryResultRowIteratorImpl implements QueryResultRowIterator {
+        private final Iterator keyIterator;
+        private long pos = 0;
+
+        private QueryResultRowIteratorImpl() {
+            keyIterator = results.keySet().iterator();
+        }
+
+        public QueryResultRow nextQueryResultRow() {
+            final NodeId nId = (NodeId) keyIterator.next();
+            final QValue[] qValues = (QValue[]) results.get(nId);
+            pos++;
+
+            return new QueryResultRow() {
+                /**
+                 * @see QueryResultRow#getNodeId()
+                 */
+                public NodeId getNodeId() {
+                    return nId;
+                }
+
+                /**
+                 * @see QueryResultRow#getScore()
+                 */
+                public double getScore() {
+                    if (scoreIndex != -1 && qValues[scoreIndex] != null) {
+                        try {
+                            return Double.parseDouble(qValues[scoreIndex].getString());
+                        } catch (RepositoryException e) {
+                            log.error("Error while building query score", e);
+                        }   return UNDEFINED_SCORE;
+                    } else {
+                        log.error("Cannot determined jcr:score from query results.");
+                        return UNDEFINED_SCORE;
+                    }
+                }
+
+                /**
+                 * @see QueryResultRow#getValues()
+                 */
+                public QValue[] getValues() {
+                    return qValues;
+                }
+            };
+        }
+
+        public void skip(long skipNum) {
+            while (skipNum-- > 0) {
+                nextQueryResultRow();
+            }
+        }
+
+        public long getSize() {
+            return results.size();
+        }
+
+        public long getPosition() {
+            return pos;
+        }
+
+        public void remove() {
+            throw new UnsupportedOperationException("Remove not implemented");
+        }
+
+        public boolean hasNext() {
+            return keyIterator.hasNext();
+        }
+
+        public Object next() {
+            return nextQueryResultRow();
+        }
+    }

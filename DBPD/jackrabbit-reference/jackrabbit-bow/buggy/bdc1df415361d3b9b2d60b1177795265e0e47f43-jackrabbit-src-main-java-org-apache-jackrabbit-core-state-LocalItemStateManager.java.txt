JCR-552 Move listeners from item state to item state managers


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@438851 13f79535-47bb-0310-9956-ffa450edef68

-        implements UpdatableItemStateManager, ItemStateListener {
+        implements UpdatableItemStateManager, NodeStateListener {
+     * State change dispatcher.
+     */
+    private final transient StateChangeDispatcher dispatcher = new StateChangeDispatcher();
+
+    /**
+
+        sharedStateMgr.addListener(this);
-        // register as listener
-        state.addListener(this);
+        // set parent container
+        state.setContainer(this);
-        // register as listener
-        state.addListener(this);
+        // set parent container
+        state.setContainer(this);
+        state.setContainer(this);
+        state.setContainer(this);
+        sharedStateMgr.removeListener(this);
+
-            // we're no longer interested in status changes of this item state
-            state.removeListener(this);
-            // discard item state; any remaining listeners will be informed
-            // about this status change
-            state.discard();
+            dispatcher.notifyStateDiscarded(state);
+    /**
+     * Add an <code>ItemStateListener</code>
+     * @param listener the new listener to be informed on modifications
+     */
+    public void addListener(ItemStateListener listener) {
+        dispatcher.addListener(listener);
+    }
+
+    /**
+     * Remove an <code>ItemStateListener</code>
+     * @param listener an existing listener
+     */
+    public void removeListener(ItemStateListener listener) {
+        dispatcher.removeListener(listener);
+    }
+
+
+     * <p/>
+     * Notification handler gets called for both local states that this state manager
+     * has created, as well as states that were created by the shared state manager
+     * we're listening to.
+        ItemState local = null;
+        if (created.getContainer() != this) {
+            // shared state was created
+            try {
+                local = changeLog.get(created.getId());
+                if (local != null) {
+                    // underlying state has been permanently created
+                    local.pull();
+                    local.setStatus(ItemState.STATUS_EXISTING);
+                    cache.cache(local);
+                }
+            } catch (NoSuchItemStateException e) {
+                /* ignore */
+            }
+        } else {
+            // local state was created
+            local = created;
+        }
+        if (local != null) {
+            dispatcher.notifyStateCreated(created);
+        }
+     * <p/>
+     * Notification handler gets called for both local states that this state manager
+     * has created, as well as states that were created by the shared state manager
+     * we're listening to.
+        ItemState local = null;
+        if (modified.getContainer() != this) {
+            // shared state was modified
+            local = cache.retrieve(modified.getId());
+            if (local != null && local.isConnected()) {
+                // this instance represents existing state, update it
+                local.pull();
+            }
+        } else {
+            // local state was modified
+            local = modified;
+        }
+        if (local != null) {
+            dispatcher.notifyStateModified(local);
+        }
+     * <p/>
+     * Notification handler gets called for both local states that this state manager
+     * has created, as well as states that were created by the shared state manager
+     * we're listening to.
-        destroyed.removeListener(this);
-
+        ItemState local = null;
+        if (destroyed.getContainer() != this) {
+            // shared state was destroyed
+            local = cache.retrieve(destroyed.getId());
+            if (local != null && local.isConnected()) {
+                local.setStatus(ItemState.STATUS_EXISTING_REMOVED);
+            }
+        } else {
+            // local state was destroyed
+            local = destroyed;
+        }
+        if (local != null) {
+            dispatcher.notifyStateDestroyed(local);
+        }
+     * <p/>
+     * Notification handler gets called for both local states that this state manager
+     * has created, as well as states that were created by the shared state manager
+     * we're listening to.
-        discarded.removeListener(this);
-
+        ItemState local = null;
+        if (discarded.getContainer() != this) {
+            // shared state was discarded
+            local = cache.retrieve(discarded.getId());
+            if (local != null && local.isConnected()) {
+                local.setStatus(ItemState.STATUS_UNDEFINED);
+            }
+        } else {
+            // local state was discarded
+            local = discarded;
+        }
+        if (local != null) {
+            dispatcher.notifyStateDiscarded(local);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p/>
+     * Optimization: shared state manager we're listening to does not deliver node state changes, therefore the state
+     * concerned must be a local state.
+     */
+    public void nodeAdded(NodeState state, QName name, int index, NodeId id) {
+        dispatcher.notifyNodeAdded(state, name, index, id);
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p/>
+     * Optimization: shared state manager we're listening to does not deliver node state changes, therefore the state
+     * concerned must be a local state.
+     */
+    public void nodesReplaced(NodeState state) {
+        dispatcher.notifyNodesReplaced(state);
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p/>
+     * Optimization: shared state manager we're listening to does not deliver node state changes, therefore the state
+     * concerned must be a local state.
+     */
+    public void nodeRemoved(NodeState state, QName name, int index, NodeId id) {
+        dispatcher.notifyNodeRemoved(state, name, index, id);

JCR-2313 - Improvements to user management (2) [work in progress] 
-> see issue for details

JCR-2333 - ItemImpl#validateTransientItems: Incomplete validation of mandatory child item
-> patch2

JCR-2195 - Provide possibility to import protected items using Session/Workspace import functionality
-> deal with reference properties
-> make import handlers configurable
-> add userimporter

JCR-171 - Make the extraction of Session UserIDs from Subjects configurable
-> extend SecurityManagerConfig and retrieve uid from principal name if configured
     class is present in the subject

JCR-2351 - Make Authorizable.setProperty more noisy in case of failure

JCR-2331 - Configurable DefaultPolicy replacing Initialization within the ACProvider
-> initial steps. remove code that relies on the default-init
-> add TODOs

JCR-2291 - Issues with compiled permissions of ACL provider
-> remove code searching for DENY-read entries in case of default initialization of ac entries

and here and there minor improvement, usage of generics etc....

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@828791 13f79535-47bb-0310-9956-ffa450edef68

-import javax.jcr.Session;
+import javax.jcr.UnsupportedRepositoryOperationException;
- * the relative depth starting from the node at {@link UserConstants#USERS_PATH}
- * or {@link UserConstants#GROUPS_PATH}.</li>
+ * the relative depth starting from the node at {@link #getUsersPath()}
+ * or {@link #getGroupsPath()}.</li>
-     * Flag indicating if {@link #getAuthorizable(String)} should find users or
-     * groups created with Jackrabbit < 2.0.<br>
+     * Flag indicating if {@link #getAuthorizable(String)} should be able to deal
+     * with users or groups created with Jackrabbit < 2.0.<br>
-     * Flat storing the batch modus.
-     * If this option is turned on changes made through this user manager will
-     * only be persisted upon an explicit call to {@link javax.jcr.Session#save()},
-     * which must be the editing session object. Otherwise (default behavior)
-     * changes are immediately persisted.
-     *
-     * @see #setPersistenceModus(boolean, Session)
-     */
-    boolean batchModus = false;
-
-    /**
-     * @param session
-     * @param adminId
-     * @throws RepositoryException
+     * @param session The editing/reading session.
+     * @param adminId The user ID of the administrator.
+     * @throws RepositoryException If an error occurs.
-     * @param session
-     * @param adminId
-     * @param config
-     * @throws RepositoryException
+     * @param session The editing/reading session.
+     * @param adminId The user ID of the administrator.
+     * @param config The configuration parameters.
+     * @throws RepositoryException If an error occurs.
-
-    /**
-     * @param batched If <code>true</code> changes made through this manager and
-     * to authorizables are only persisted upon explict call to {@link
-     * javax.jcr.Session#save()}.
-     * @throws RepositoryException If the passed <code>editingSession</code> is
-     * not the same this UserManager is writing to.
-     */
-    /* COMMENTED. WORK IN PROGRESS
-    public void setPersistenceModus(boolean batched, Session editingSession) throws RepositoryException {
-        if (editingSession != session) {
-            throw new RepositoryException("Cannot change persistence modus: Session mismatch.");
-        }
-        batchModus = batched;
-    }
-    */
-
+    
-        Authorizable authorz = null;
-        NodeId nodeId = buildNodeId(id);        
-        NodeImpl n = null;
-        try {
-            n = session.getNodeById(nodeId);
-        } catch (ItemNotFoundException e) {
-            if (compatibleJR16) {
-                // backwards-compatibility with JR < 2.0 user/group structure that doesn't
-                // allow to determine existance of an authorizable from the id directly.
-                // search for it the node belonging to that id
-                n = (NodeImpl) authResolver.findNode(P_USERID, id, NT_REP_USER);
-                if (n == null) {
-                    // no user -> look for group.
-                    // NOTE: JR < 2.0 always returned groupIDs that didn't contain any
-                    // illegal JCR chars. Since Group.getID() now unescapes the node
-                    // name additional escaping is required.
-                    Name nodeName = session.getQName(Text.escapeIllegalJcrChars(id));
-                    n = (NodeImpl) authResolver.findNode(nodeName, NT_REP_GROUP);
-                }
-            } // else: no matching node found -> ignore exception.
-        }
-
-        if (n != null) {
-            if (n.isNodeType(NT_REP_USER)) {
-                authorz = createUser(n);
-            } else if (n.isNodeType(NT_REP_GROUP)) {
-                authorz = createGroup(n);
-            } // else some other node but not an authorizable -> return null.
-        } // else no matching node -> return null.
-        return authorz;
+        return internalGetAuthorizable(id);
-            // another Principal -> search
-            String name = principal.getName();
+            // another Principal implementation.
+            // a) try short-cut that works in case of ID.equals(principalName) only.
+            // b) execute query in case of pName mismatch or exc. however, query
+            //    requires persisted user nodes (see known issue of UserImporter).
+            String name = principal.getName();           
+            try {
+                Authorizable a = internalGetAuthorizable(name);
+                if (a != null && name.equals(a.getPrincipal().getName())) {
+                    return a;
+                }
+            } catch (RepositoryException e) {
+                // ignore and execute the query.
+            }
+            // shortcut didn't work -> search.
-        if (n != null) {
-            if (n.isNodeType(NT_REP_USER)) {
-               return createUser(n);
-            } else if (n.isNodeType(NT_REP_GROUP)) {
-               return createGroup(n);
-            } else {
-                log.debug("Unexpected user nodetype " + n.getPrimaryNodeType().getName());
-            }
-        }
-        return null;
+        return getAuthorizable(n);
-    public Iterator findAuthorizables(String propertyName, String value) throws RepositoryException {
+    public Iterator<Authorizable> findAuthorizables(String propertyName, String value) throws RepositoryException {
-    public Iterator findAuthorizables(String propertyName, String value, int searchType)
+    public Iterator<Authorizable> findAuthorizables(String propertyName, String value, int searchType)
-        if (!isValidPrincipal(principal)) {
-            throw new IllegalArgumentException("Cannot create user: Principal may not be null and must have a valid name.");
-        }
-        if (getAuthorizable(userID) != null) {
+        if (internalGetAuthorizable(userID) != null) {
-        if (hasAuthorizable(principal)) {
-            throw new AuthorizableExistsException("Authorizable for '" + principal.getName() + "' already exists");
-        }
-
+            setPrincipal(userNode, principal);
-            setProperty(userNode, P_PRINCIPAL_NAME, getValue(principal.getName()), true);
-            if (!batchModus) {
+
+            User user = createUser(userNode);
+            if (isAutoSave()) {
-            return createUser(userNode);
+            return user;
-     * It will be created below the this {@link #GROUPS_PATH group path}.<br>
+     * It will be created below the defined {@link #getGroupsPath() group path}.<br>
-            throw new IllegalArgumentException("Cannot create Group: Principal may not be null and must have a valid name.");
+            throw new IllegalArgumentException("Cannot create group: Principal may not be null and must have a valid name.");
-        if (hasAuthorizable(principal)) {
-            throw new AuthorizableExistsException("Authorizable for '" + principal.getName() + "' already exists: ");
-        }
-        
+            setPrincipal(groupNode, principal);
-            setProperty(groupNode, P_PRINCIPAL_NAME, getValue(principal.getName()));
-            if (!batchModus) {
+            Group group = createGroup(groupNode);
+            if (isAutoSave()) {
-
-            return createGroup(groupNode);
+            return group;
-    //--------------------------------------------------------------------------
+     * Always returns <code>true</code> as by default the autoSave behavior
+     * cannot be altered (see also {@link #autoSave(boolean)}.
-     * @param principal
-     * @return
-     * @throws RepositoryException
+     * @return Always <code>true</code>.
+     * @see org.apache.jackrabbit.api.security.user.UserManager#isAutoSave()
-    private boolean hasAuthorizable(Principal principal) throws RepositoryException {
-        return getAuthorizable(principal) != null;
+    public boolean isAutoSave() {
+        return true;
+    }
+
+    /**
+     * Always throws <code>unsupportedRepositoryOperationException</code> as
+     * modification of the autosave behavior is not supported.
+     *
+     * @see UserManager#autoSave(boolean)
+     */
+    public void autoSave(boolean enable) throws UnsupportedRepositoryOperationException, RepositoryException {
+        throw new UnsupportedRepositoryOperationException("Cannot change autosave behavior.");
+    }
+
+    //--------------------------------------------------------------------------
+    void setPrincipal(NodeImpl node, Principal principal) throws AuthorizableExistsException, RepositoryException {
+        if (!isValidPrincipal(principal)) {
+            throw new IllegalArgumentException("Cannot create Authorizable: Principal may not be null and must have a valid name.");
+        }
+        if (getAuthorizable(principal) != null) {
+            throw new AuthorizableExistsException("Authorizable for '" + principal.getName() + "' already exists: ");
+        }
+        if (!node.isNew() || node.hasProperty(P_PRINCIPAL_NAME)) {
+            throw new RepositoryException("rep:principalName can only be set once on a new node.");
+        }
+        setProperty(node, P_PRINCIPAL_NAME, getValue(principal.getName()), true);
-        if (!batchModus) {
+        if (isAutoSave()) {
-        if (!batchModus) {
+        if (isAutoSave()) {
-        if (!batchModus) {
+        if (isAutoSave()) {
-        if (!batchModus) {
+        if (isAutoSave()) {
+     * Implementation specific method used to retrieve a user/group by Node.
+     * <code>Null</code> is returned if
+     * <pre>
+     * - the passed node is <code>null</code>,
+     * - doesn't have the correct node type or
+     * - isn't placed underneith the configured user/group tree.
+     * </pre>
+     *
+     * @param n
+     * @return An authorizable or <code>null</code>.
+     * @throws RepositoryException
+     */
+    Authorizable getAuthorizable(NodeImpl n) throws RepositoryException {
+        Authorizable authorz = null;
+        if (n != null) {
+            String path = n.getPath();
+            if (n.isNodeType(NT_REP_USER) && Text.isDescendant(usersPath, path)) {
+                authorz = createUser(n);
+            } else if (n.isNodeType(NT_REP_GROUP) && Text.isDescendant(groupsPath, path)) {
+                authorz = createGroup(n);
+            } else {
+                /* else some other node type or outside of the valid user/group
+                   hierarchy  -> return null. */
+                log.debug("Unexpected user nodetype " + n.getPrimaryNodeType().getName());
+            }
+        } /* else no matching node -> return null */
+        return authorz;
+    }
+
+    /**
-        while (getAuthorizable(groupID) != null) {
+        while (internalGetAuthorizable(groupID) != null) {
+    /**
+     * @param id The user or group ID.
+     * @return The authorizable with the given <code>id</code> or <code>null</code>.
+     * @throws RepositoryException If an error occurs.
+     */
+    private Authorizable internalGetAuthorizable(String id) throws RepositoryException {
+        NodeId nodeId = buildNodeId(id);
+        NodeImpl n = null;
+        try {
+            n = session.getNodeById(nodeId);
+        } catch (ItemNotFoundException e) {
+            if (compatibleJR16) {
+                // backwards-compatibility with JR < 2.0 user/group structure that doesn't
+                // allow to determine existance of an authorizable from the id directly.
+                // search for it the node belonging to that id
+                n = (NodeImpl) authResolver.findNode(P_USERID, id, NT_REP_USER);
+                if (n == null) {
+                    // no user -> look for group.
+                    // NOTE: JR < 2.0 always returned groupIDs that didn't contain any
+                    // illegal JCR chars. Since Group.getID() now unescapes the node
+                    // name additional escaping is required.
+                    Name nodeName = session.getQName(Text.escapeIllegalJcrChars(id));
+                    n = (NodeImpl) authResolver.findNode(nodeName, NT_REP_GROUP);
+                }
+            } // else: no matching node found -> ignore exception.
+        }
+
+        return getAuthorizable(n);
+    }
+
-            throw new IllegalArgumentException("User has to be within the User Path");
+            throw new RepositoryException("User has to be within the User Path");
-     * @return user object
+     * @return the user object
-        return GroupImpl.create(groupNode, this);
-    }
-
-    private static boolean isValidPrincipal(Principal principal) {
-        return principal != null && principal.getName() != null && principal.getName().length() > 0;
+        if (groupNode == null || !groupNode.isNodeType(NT_REP_GROUP)) {
+            throw new IllegalArgumentException();
+        }
+        if (!Text.isDescendant(groupsPath, groupNode.getPath())) {
+            throw new RepositoryException("Group has to be within the Group Path");
+        }
+        return doCreateGroup(groupNode);
+     * Build the group object from the given group node. May be overridden to
+     * return a custom implementation.
-     * @param id
-     * @return
-     * @throws RepositoryException
+     * @param node group node
+     * @return A group 
+     * @throws RepositoryException if an error occurs
-    private static NodeId buildNodeId(String id) throws RepositoryException {
+    protected Group doCreateGroup(NodeImpl node) throws RepositoryException {
+        return new GroupImpl(node, this);
+    }
+
+    /**
+     * Creates a UUID from the given <code>id</code> String that is converted
+     * to lower case before.
+     *
+     * @param id The user/group id that needs to be converted to a valid NodeId.
+     * @return a new <code>NodeId</code>.
+     * @throws RepositoryException If an error occurs.
+     */
+    private NodeId buildNodeId(String id) throws RepositoryException {
-            UUID uuid = UUID.nameUUIDFromBytes(id.getBytes("UTF-8"));
+            UUID uuid = UUID.nameUUIDFromBytes(id.toLowerCase().getBytes("UTF-8"));
+    
+    private static boolean isValidPrincipal(Principal principal) {
+        return principal != null && principal.getName() != null && principal.getName().length() > 0;
+    }
-    //--------------------------------------------------------------------------
+    //------------------------------------------------------< inner classes >---
-    private final class AuthorizableIterator implements Iterator {
+    private final class AuthorizableIterator implements Iterator<Authorizable> {
-        public Object next() {
+        public Authorizable next() {
-                        Authorizable authr;
-                        if (node.isNodeType(NT_REP_USER)) {
-                            authr = createUser(node);
-                        } else if (node.isNodeType(NT_REP_GROUP)) {
-                            authr = createGroup(node);
-                        } else {
-                            log.warn("Ignoring unexpected nodetype: " + node.getPrimaryNodeType().getName());
-                            continue;
-                        }
+                        Authorizable authr = getAuthorizable(node);
-                        return authr;
+                        if (authr != null) {
+                            return authr;
+                        }
+            // check if there exists an colliding folder child node.
+            while (((NodeImpl) folder).hasNode(nodeName)) {
+                NodeImpl colliding = ((NodeImpl) folder).getNode(nodeName);
+                if (colliding.isNodeType(NT_REP_AUTHORIZABLE_FOLDER)) {
+                    log.warn("Existing folder node collides with user/group to be created. Expanding path: " + colliding.getPath());
+                    folder = colliding;
+                } else {
+                    // should never get here as folder creation above already
+                    // asserts that only rep:authorizable folders exist.
+                    // similarly collisions with existing authorizable have been
+                    // checked.
+                    String msg = "Failed to create authorizable node: Detected conflicting node of unexpected nodetype '" + colliding.getPrimaryNodeType().getName() + "'.";
+                    log.error(msg);
+                    throw new ConstraintViolationException(msg);
+                }
+            }
-            NodeImpl folder;
-            String defaultPath = getDefaultFolderPath(id, isGroup, intermediatePath);
-            if (session.nodeExists(defaultPath)) {
-                folder = (NodeImpl) session.getNode(defaultPath);
-                if (!folder.isNodeType(NT_REP_AUTHORIZABLE_FOLDER)) {
-                    throw new RepositoryException("Invalid intermediate path. Must be of type rep:AuthorizableFolder.");
-                }
-            } else {
-                String[] segmts = defaultPath.split("/");
-                folder = (NodeImpl) session.getRootNode();
-                for (String segment : segmts) {
-                    if (segment.length() < 1) {
-                        continue;
+            String defaultPath = getDefaultFolderPath(id, isGroup, intermediatePath);
+
+            // make sure users/groups are never nested and exclusively created
+            // under a tree of rep:AuthorizableFolder(s) starting at usersPath
+            // or groupsPath, respectively. ancestors of the usersPath/groupsPath
+            // may or may not be rep:AuthorizableFolder(s).
+            // therefore the shortcut Session.getNode(defaultPath) is omitted.
+            String[] segmts = defaultPath.split("/");
+            NodeImpl folder = (NodeImpl) session.getRootNode();
+            String authRoot = (isGroup) ? groupsPath : usersPath;
+
+            for (String segment : segmts) {
+                if (segment.length() < 1) {
+                    continue;
+                }
+                if (folder.hasNode(segment)) {
+                    folder = (NodeImpl) folder.getNode(segment);
+                    if (Text.isDescendantOrEqual(authRoot, folder.getPath()) &&
+                            !folder.isNodeType(NT_REP_AUTHORIZABLE_FOLDER)) {
+                        throw new ConstraintViolationException("Invalid intermediate path. Must be of type rep:AuthorizableFolder.");
-                    if (folder.hasNode(segment)) {
-                        folder = (NodeImpl) folder.getNode(segment);
-                        if (!folder.isNodeType(NT_REP_AUTHORIZABLE_FOLDER)) {
-                            throw new RepositoryException("Invalid intermediate path. Must be of type rep:AuthorizableFolder.");
-                        }
-                    } else {
-                        folder = addNode(folder, session.getQName(segment), NT_REP_AUTHORIZABLE_FOLDER);
-                    }
+                } else {
+                    folder = addNode(folder, session.getQName(segment), NT_REP_AUTHORIZABLE_FOLDER);
-                        throw new RepositoryException(msg);
+                        throw new ConstraintViolationException(msg);

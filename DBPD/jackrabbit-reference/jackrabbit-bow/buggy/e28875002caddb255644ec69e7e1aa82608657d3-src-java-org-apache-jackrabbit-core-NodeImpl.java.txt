changing javadoc pattern for implementation of interface methods
from  @see ... style to {@inheritDoc}
(old dog learning new trick :)

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@156190 13f79535-47bb-0310-9956-ffa450edef68

-     * @see Item#isNode()
+     * {@inheritDoc}
-     * @see Item#getName
+     * {@inheritDoc}
-     * @see Item#accept(ItemVisitor)
+     * {@inheritDoc}
-     * @see Item#getParent
+     * {@inheritDoc}
-     * @see Node#addNode(String)
+     * {@inheritDoc}
-     * @see Node#addNode(String, String)
+     * {@inheritDoc}
-     * @see Node#orderBefore(String, String)
+     * {@inheritDoc}
-     * @see Node#setProperty(String, Value[])
+     * {@inheritDoc}
-     * @see Node#setProperty(String, Value[], int)
+     * {@inheritDoc}
-     * @see Node#setProperty(String, String[])
+     * {@inheritDoc}
-     * @see Node#setProperty(String, String[], int)
+     * {@inheritDoc}
-     * @see Node#setProperty(String, String)
+     * {@inheritDoc}
-     * @see Node#setProperty(String, Value)
+     * {@inheritDoc}
-     * @see Node#setProperty(String, InputStream)
+     * {@inheritDoc}
-     * @see Node#setProperty(String, boolean)
+     * {@inheritDoc}
-     * @see Node#setProperty(String, double)
+     * {@inheritDoc}
-     * @see Node#setProperty(String, long)
+     * {@inheritDoc}
-     * @see Node#setProperty(String, Calendar)
+     * {@inheritDoc}
-     * @see Node#setProperty(String, Node)
+     * {@inheritDoc}
-     * @see Node#getNode(String)
+     * {@inheritDoc}
-     * @see Node#getNodes()
+     * {@inheritDoc}
-     * @see Node#getProperties()
+     * {@inheritDoc}
-     * @see Node#getProperty(String)
+     * {@inheritDoc}
-     * @see Node#hasNode(String)
+     * {@inheritDoc}
-     * @see Node#hasNodes()
+     * {@inheritDoc}
-     * @see Node#hasProperties()
+     * {@inheritDoc}
-     * @see Node#isNodeType(String)
+     * {@inheritDoc}
-     * @see Node#getPrimaryNodeType()
+     * {@inheritDoc}
-     * @see Node#getMixinNodeTypes()
+     * {@inheritDoc}
-     * @see Node#addMixin(String)
+     * {@inheritDoc}
-     * @see Node#removeMixin(String)
+     * {@inheritDoc}
-     * @see Node#canAddMixin(String)
+     * {@inheritDoc}
-     * @see Node#hasProperty(String)
+     * {@inheritDoc}
-     * @see Node#getReferences()
+     * {@inheritDoc}
-     * @see Node#getDefinition()
+     * {@inheritDoc}
-     * @see Node#getNodes(String)
+     * {@inheritDoc}
-     * @see Node#getProperties(String)
+     * {@inheritDoc}
-     * @see Node#getPrimaryItem()
+     * {@inheritDoc}
-     * @see Node#getUUID()
+     * {@inheritDoc}
-     * @see Node#getCorrespondingNodePath(String)
+     * {@inheritDoc}
-     * @see Node#getIndex()
+     * {@inheritDoc}
-     * @see Node#checkin()
+     * {@inheritDoc}
-     * @see Node#checkout()
+     * {@inheritDoc}
-     * @see Node#update(String)
+     * {@inheritDoc}
-     * updates this node with the state given by <code>srcNode</code>
-     *
-     * @param srcNode
-     * @param removeExisting
-     * @param replaceExisting
-     * @throws RepositoryException
-     */
-    private void internalUpdate(NodeImpl srcNode, boolean removeExisting, boolean replaceExisting)
-            throws RepositoryException {
-        /*
-         * The "state" of the node in this context means the set of properties and
-         * child nodes it has. In other words, when a node is updated, its set of
-         * properties and child nodes is replaced by that of its corresponding node in the
-         * source workspace. One repercussion of this is that if a node further down the
-         * subtree does not have a corresponding node, then that node is removed (thus
-         * aligning the state of its parent with <i>its</i> correspondee in the other
-         * workspace).
-         */
-
-        // update the properties
-        PropertyIterator iter = getProperties();
-        while (iter.hasNext()) {
-            PropertyImpl p = (PropertyImpl) iter.nextProperty();
-            if (!srcNode.hasProperty(p.getQName())) {
-                p.internalRemove(true);
-            }
-        }
-        iter = srcNode.getProperties();
-        while (iter.hasNext()) {
-            PropertyImpl p = (PropertyImpl) iter.nextProperty();
-            // ignore system types
-            if (p.getQName().equals(JCR_PRIMARYTYPE)
-                    || p.getQName().equals(JCR_MIXINTYPES)
-                    || p.getQName().equals(JCR_UUID)) {
-                continue;
-            }
-            if (p.getDefinition().isMultiple()) {
-                internalSetProperty(p.getQName(), p.internalGetValues());
-            } else {
-                internalSetProperty(p.getQName(), p.internalGetValue());
-            }
-        }
-
-        // update the nodes. remove all dst nodes first
-        NodeIterator niter = getNodes();
-        while (niter.hasNext()) {
-            ((NodeImpl) niter.nextNode()).internalRemove(true);
-        }
-        // add src ones
-        niter = srcNode.getNodes();
-        while (niter.hasNext()) {
-            NodeImpl child = (NodeImpl) niter.nextNode();
-            NodeImpl dstNode = null;
-            String uuid = child.internalGetUUID();
-            if (child.isNodeType(MIX_REFERENCEABLE)) {
-                // if child is referenceable, check if correspondance exist in this workspace
-                try {
-                    dstNode = (NodeImpl) session.getNodeByUUID(uuid);
-                    if (removeExisting) {
-                        // get applicable definition of target node at new location
-                        NodeTypeImpl nt = (NodeTypeImpl) dstNode.getPrimaryNodeType();
-                        NodeDefImpl newTargetDef;
-                        try {
-                            newTargetDef = ((NodeImpl) getParent()).getApplicableChildNodeDef(child.getQName(), nt.getQName());
-                        } catch (RepositoryException re) {
-                            String msg = dstNode.safeGetJCRPath() + ": no definition found in parent node's node type for new node";
-                            log.debug(msg);
-                            throw new ConstraintViolationException(msg, re);
-                        }
-
-                        // add target to new parent and remove from old one
-                        createChildNodeLink(child.getQName(), uuid);
-                        ((NodeImpl) dstNode.getParent()).removeChildNode(child.getQName(), child.getIndex() == 0 ? 1 : child.getIndex());
-                        // change definition of target if necessary
-                        NodeDefImpl oldTargetDef = (NodeDefImpl) dstNode.getDefinition();
-                        NodeDefId oldTargetDefId = new NodeDefId(oldTargetDef.unwrap());
-                        NodeDefId newTargetDefId = new NodeDefId(newTargetDef.unwrap());
-                        if (!oldTargetDefId.equals(newTargetDefId)) {
-                            dstNode.onRedefine(newTargetDefId);
-                        }
-                    } else if (replaceExisting) {
-                        // node exists outside of this update tree, so continue there
-                    } else {
-                        throw new ItemExistsException("Unable to update node: " + dstNode.safeGetJCRPath());
-                    }
-                } catch (ItemNotFoundException e) {
-                    // does not exist
-                }
-            } else {
-                // if child is not referenceable, adjust state
-                uuid = null;
-            }
-            if (dstNode == null) {
-                dstNode = internalAddChildNode(child.getQName(), (NodeTypeImpl) child.getPrimaryNodeType(), uuid);
-                // add mixins
-                NodeType[] mixins = child.getMixinNodeTypes();
-                for (int i = 0; i < mixins.length; i++) {
-                    dstNode.addMixin(mixins[i].getName());
-                }
-            }
-            dstNode.internalUpdate(child, removeExisting, replaceExisting);
-        }
-    }
-
-    /**
-     * @see Node#merge(String, boolean)
+     * {@inheritDoc}
-     * @see Node#cancelMerge(Version)
+     * {@inheritDoc}
-     * @see Node#doneMerge(Version)
+     * {@inheritDoc}
-     * @see Node#isCheckedOut()
+     * {@inheritDoc}
-     * @see Node#restore(String, boolean)
+     * {@inheritDoc}
-     * @see Node#restore(Version, boolean)
+     * {@inheritDoc}
-     * @see Node#restore(Version, String, boolean)
+     * {@inheritDoc}
-     * @see Node#restoreByLabel(String, boolean)
+     * {@inheritDoc}
-     * @see Node#getVersionHistory()
+     * {@inheritDoc}
-     * @see Node#getBaseVersion()
+     * {@inheritDoc}
+    /**
+     * updates this node with the state given by <code>srcNode</code>
+     *
+     * @param srcNode
+     * @param removeExisting
+     * @param replaceExisting
+     * @throws RepositoryException
+     */
+    private void internalUpdate(NodeImpl srcNode, boolean removeExisting, boolean replaceExisting)
+            throws RepositoryException {
+        /*
+         * The "state" of the node in this context means the set of properties and
+         * child nodes it has. In other words, when a node is updated, its set of
+         * properties and child nodes is replaced by that of its corresponding node in the
+         * source workspace. One repercussion of this is that if a node further down the
+         * subtree does not have a corresponding node, then that node is removed (thus
+         * aligning the state of its parent with <i>its</i> correspondee in the other
+         * workspace).
+         */
+
+        // update the properties
+        PropertyIterator iter = getProperties();
+        while (iter.hasNext()) {
+            PropertyImpl p = (PropertyImpl) iter.nextProperty();
+            if (!srcNode.hasProperty(p.getQName())) {
+                p.internalRemove(true);
+            }
+        }
+        iter = srcNode.getProperties();
+        while (iter.hasNext()) {
+            PropertyImpl p = (PropertyImpl) iter.nextProperty();
+            // ignore system types
+            if (p.getQName().equals(JCR_PRIMARYTYPE)
+                    || p.getQName().equals(JCR_MIXINTYPES)
+                    || p.getQName().equals(JCR_UUID)) {
+                continue;
+            }
+            if (p.getDefinition().isMultiple()) {
+                internalSetProperty(p.getQName(), p.internalGetValues());
+            } else {
+                internalSetProperty(p.getQName(), p.internalGetValue());
+            }
+        }
+
+        // update the nodes. remove all dst nodes first
+        NodeIterator niter = getNodes();
+        while (niter.hasNext()) {
+            ((NodeImpl) niter.nextNode()).internalRemove(true);
+        }
+        // add src ones
+        niter = srcNode.getNodes();
+        while (niter.hasNext()) {
+            NodeImpl child = (NodeImpl) niter.nextNode();
+            NodeImpl dstNode = null;
+            String uuid = child.internalGetUUID();
+            if (child.isNodeType(MIX_REFERENCEABLE)) {
+                // if child is referenceable, check if correspondance exist in this workspace
+                try {
+                    dstNode = (NodeImpl) session.getNodeByUUID(uuid);
+                    if (removeExisting) {
+                        // get applicable definition of target node at new location
+                        NodeTypeImpl nt = (NodeTypeImpl) dstNode.getPrimaryNodeType();
+                        NodeDefImpl newTargetDef;
+                        try {
+                            newTargetDef = ((NodeImpl) getParent()).getApplicableChildNodeDef(child.getQName(), nt.getQName());
+                        } catch (RepositoryException re) {
+                            String msg = dstNode.safeGetJCRPath() + ": no definition found in parent node's node type for new node";
+                            log.debug(msg);
+                            throw new ConstraintViolationException(msg, re);
+                        }
+
+                        // add target to new parent and remove from old one
+                        createChildNodeLink(child.getQName(), uuid);
+                        ((NodeImpl) dstNode.getParent()).removeChildNode(child.getQName(), child.getIndex() == 0 ? 1 : child.getIndex());
+                        // change definition of target if necessary
+                        NodeDefImpl oldTargetDef = (NodeDefImpl) dstNode.getDefinition();
+                        NodeDefId oldTargetDefId = new NodeDefId(oldTargetDef.unwrap());
+                        NodeDefId newTargetDefId = new NodeDefId(newTargetDef.unwrap());
+                        if (!oldTargetDefId.equals(newTargetDefId)) {
+                            dstNode.onRedefine(newTargetDefId);
+                        }
+                    } else if (replaceExisting) {
+                        // node exists outside of this update tree, so continue there
+                    } else {
+                        throw new ItemExistsException("Unable to update node: " + dstNode.safeGetJCRPath());
+                    }
+                } catch (ItemNotFoundException e) {
+                    // does not exist
+                }
+            } else {
+                // if child is not referenceable, adjust state
+                uuid = null;
+            }
+            if (dstNode == null) {
+                dstNode = internalAddChildNode(child.getQName(), (NodeTypeImpl) child.getPrimaryNodeType(), uuid);
+                // add mixins
+                NodeType[] mixins = child.getMixinNodeTypes();
+                for (int i = 0; i < mixins.length; i++) {
+                    dstNode.addMixin(mixins[i].getName());
+                }
+            }
+            dstNode.internalUpdate(child, removeExisting, replaceExisting);
+        }
+    }
-     * @see Node#lock(boolean, boolean)
+     * {@inheritDoc}
-     * @see Node#getLock()
+     * {@inheritDoc}
-     * @see Node#unlock()
+     * {@inheritDoc}
-     * @see Node#holdsLock()
+     * {@inheritDoc}
-     * @see Node#isLocked()
+     * {@inheritDoc}

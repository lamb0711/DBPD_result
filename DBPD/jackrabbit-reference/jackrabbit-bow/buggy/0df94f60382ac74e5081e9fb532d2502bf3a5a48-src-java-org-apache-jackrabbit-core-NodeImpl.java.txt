- fixing verisoning issues (version labels still missing)

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@151144 13f79535-47bb-0310-9956-ffa450edef68

-        if (isNodeType(NodeTypeRegistry.MIX_REFERENCEABLE)) {
-            String uuid = ((NodeState) state).getUUID();
-        }
-/*
+        // aquire session of other workspace (throws NoSuchWorkspaceException)
-        SessionImpl srcSession = rep.getSystemSession(srcWorkspaceName);
-        Node root = session.getRootNode();
-        // if (isRepositoryRoot()) [don't know, if this works correctly with workspaces]
-        if (isSame(root)) {
-            return (NodeImpl) srcSession.getRootNode();
-        }
-
-        // if this node is referenceable, return the corresponding one
-        if (isNodeType(NodeTypeRegistry.MIX_REFERENCEABLE)) {
-            try {
-                return (NodeImpl) srcSession.getNodeByUUID(getUUID());
-            } catch (ItemNotFoundException e) {
-                return null;
-            }
-        }
+        SessionImpl srcSession = rep.getSystemSession(workspaceName);
-        while (!m1.isSame(root) && !m1.isNodeType(NodeTypeRegistry.MIX_REFERENCEABLE)) {
+        while (!m1.isRepositoryRoot() && !m1.isNodeType(NodeTypeRegistry.MIX_REFERENCEABLE)) {
-        // special treatment for root
-        if (m1.isSame(root)) {
-            return (NodeImpl) srcSession.getItem(getPath());
+
+        // if root is common ancestor, corresponding path is same as ours
+        if (m1.isRepositoryRoot()) {
+            return getPath();
-        // calculate relative path. please note, that this cannot be done
+        // get corresponding ancestor
+        Node m2 = srcSession.getNodeByUUID(m1.getUUID());
+
+        // return path of m2, if m1 == n1
+        if (m1 == this) {
+            return m2.getPath();
+        }
+
+        // calculate relative path from the referenceable ancestor to this node.
+        // please note, that this cannot be done
+
+        // @todo: replace as soon as implemented
+        // Path relPath = m1.getPrimaryPath().getRelativePath(getPrimaryPath());
+
-        try {
-            return (NodeImpl) srcSession.getNodeByUUID(m1.getUUID()).getNode(relPath);
-        } catch (ItemNotFoundException e) {
-            return null;
-        }
-*/
-        // @todo implement Node#getCorrespondingNodePath
-        throw new RepositoryException("not yet implemented");
+        return m2.getNode(relPath).getPath();
-        // @todo FIXME semantics of isCheckedOut() have changed!
-        if (!isCheckedOut()) {
+        if (!internalIsCheckedOut()) {
-            String msg = "Unable to checkin node. Clear 'jcr:mergeFailed' first. " + safeGetJCRPath();
+            String msg = "Unable to checkin node. Node has unresolved merge operation. " + safeGetJCRPath();
-        NodeImpl srcNode = getCorrespondingNode(srcWorkspaceName);
+        // @todo FIXME need to get session with same credentials as current
+        SessionImpl srcSession = rep.getSystemSession(srcWorkspaceName);
+
+        NodeImpl srcNode = getCorrespondingNode(srcSession);
-        NodeImpl srcNode = doMergeTest(srcWorkspace, bestEffort);
+        // if same workspace, ignore
+        if (srcWorkspace.equals(session.getWorkspace().getName())) {
+            return;
+        }
+
+        // @todo FIXME need to get session with same credentials as current
+        SessionImpl srcSession = rep.getSystemSession(srcWorkspace);
+
+        NodeImpl srcNode = doMergeTest(srcSession, bestEffort);
+
-        save();
+        // session.save/revert is done in internal restore
-        if (!version.getParent().getUUID().equals(getVersionHistory().getUUID())) {
+        // TODO: change if Version.getContainingVersionHistory() is introduced
+        if (!version.getParent().isSame(getVersionHistory())) {
+
-        save();
+        // session.save/revert is done in internal restore
-            node.getParent().save();
+            // session.save/revert is done in internal restore
-
-    /**
-     * Returns the corresponding node in the <code>scrWorkspaceName</code> of
-     * this node.
+/**
+     * Returns the corresponding node in the workspace of the given session.
-     * @param srcWorkspaceName
+     * @param srcSession
-    private NodeImpl getCorrespondingNode(String srcWorkspaceName)
-            throws NoSuchWorkspaceException, AccessDeniedException,
-            RepositoryException {
+    private NodeImpl getCorrespondingNode(Session srcSession)
+            throws AccessDeniedException, RepositoryException {
-        // @todo FIXME need to get session with same credentials as current
-        SessionImpl srcSession = rep.getSystemSession(srcWorkspaceName);
-        Node root = session.getRootNode();
-        // if (isRepositoryRoot()) [don't know, if this works correctly with workspaces]
-        if (isSame(root)) {
-            return (NodeImpl) srcSession.getRootNode();
+    // search nearest ancestor that is referenceable
+    NodeImpl m1 = this;
+    while (!m1.isRepositoryRoot() && !m1.isNodeType(NodeTypeRegistry.MIX_REFERENCEABLE)) {
+        m1 = (NodeImpl) m1.getParent();
+    }
+
+    try {
+        // get corresponding ancestor
+        NodeImpl m2 = (NodeImpl) srcSession.getNodeByUUID(m1.getUUID());
+
+        // return path of m2, if m1 == n1
+        if (m1 == this) {
+            return m2;
-        // if this node is referenceable, return the corresponding one
-        if (isNodeType(NodeTypeRegistry.MIX_REFERENCEABLE)) {
-            try {
-                return (NodeImpl) srcSession.getNodeByUUID(getUUID());
-            } catch (ItemNotFoundException e) {
-                return null;
-            }
-        }
-
-        // search nearest ancestor that is referenceable
-        NodeImpl m1 = this;
-        while (!m1.isSame(root) && !m1.isNodeType(NodeTypeRegistry.MIX_REFERENCEABLE)) {
-            m1 = (NodeImpl) m1.getParent();
-        }
-        // special treatment for root
-        if (m1.isSame(root)) {
-            return (NodeImpl) srcSession.getItem(getPath());
-        }
-
-        // calculate relative path. please note, that this cannot be done
+        // calculate relative path from the referenceable ancestor to this node.
+        // please note, that this cannot be done
+
+        // @todo: replace as soon as implemented
+        // Path relPath = m1.getPrimaryPath().getRelativePath(getPrimaryPath());
+
-        try {
-            return (NodeImpl) srcSession.getNodeByUUID(m1.getUUID()).getNode(relPath);
-        } catch (ItemNotFoundException e) {
-            return null;
-        }
+        return (NodeImpl) m2.getNode(relPath);
+
+    } catch (ItemNotFoundException e) {
+        return null;
+}
-     * @param srcWorkspace
+     * @param srcSession
-    private NodeImpl doMergeTest(String srcWorkspace, boolean bestEffort)
+    private NodeImpl doMergeTest(Session srcSession, boolean bestEffort)
-        NodeImpl srcNode = getCorrespondingNode(srcWorkspace);
+        NodeImpl srcNode = getCorrespondingNode(srcSession);
-        internalRestore(((VersionImpl) version).getInternalVersion(), vsel, removeExisting);
-    }
-
-    /**
-     * Checks if any frozen uuid in the given frozen node or its descendants
-     * collides with the one in the workspace. if 'removeExisting' is true,
-     * collisions will be removed, otherwise an ItemExistsException is thrown.
-     * If a frozen version history is already restored outside this nodes
-     * subtree, a exception is thrown, too, if the removeExisting is true.
-     * @param f
-     * @param removeExisting
-     * @throws RepositoryException
-     */
-    private void checkUUIDCollisions(InternalFrozenNode f, boolean removeExisting)
-            throws RepositoryException {
-
-        if (itemMgr.itemExists(new NodeId(f.getFrozenUUID()))) {
-            NodeImpl node = (NodeImpl) session.getNodeByUUID(f.getFrozenUUID());
-            if (removeExisting) {
-                node.remove();
-            } else {
-                throw new ItemExistsException("Unable to restore. UUID collides with " + node.safeGetJCRPath());
+        try {
+            internalRestore(((VersionImpl) version).getInternalVersion(), vsel, removeExisting);
+        } catch (RepositoryException e) {
+            // revert session
+            try {
+                log.error("reverting changes applied during restore...");
+                session.refresh(false);
+            } catch (RepositoryException e1) {
+                // ignore this
+            throw e;
-        InternalFreeze[] fs = f.getFrozenChildNodes();
-        for (int i=0; i<fs.length; i++) {
-            if (fs[i] instanceof InternalFrozenNode) {
-                checkUUIDCollisions((InternalFrozenNode) fs[i], removeExisting);
-            } else if (!removeExisting) {
-                InternalFrozenVersionHistory fh = (InternalFrozenVersionHistory) fs[i];
-                VersionHistoryImpl history = (VersionHistoryImpl) session.getNodeByUUID(fh.getVersionHistoryId());
-                String nodeId = history.getVersionedUUID();
-
-                // check if representing vh already exists somewhere
-                if (itemMgr.itemExists(new NodeId(nodeId))) {
-                    NodeImpl n = (NodeImpl) session.getNodeByUUID(nodeId);
-                    try {
-                        if (!n.getPrimaryPath().isDescendantOf(getPrimaryPath())) {
-                            throw new ItemExistsException("Unable to restore. Same node already restored at " + n.safeGetJCRPath());
-                        }
-                    } catch (MalformedPathException e) {
-                        throw new RepositoryException(e);
-                    }
-                }
-            }
-        }
+        session.save();
-    private void internalRestore(InternalVersion version, VersionSelector vsel, boolean removeExisting)
+    private void internalRestore(InternalVersion version, VersionSelector vsel,
+                                 boolean removeExisting)
-        // first check, if any uuid conflicts would occurr
-        checkUUIDCollisions(version.getFrozenNode(), removeExisting);
-
-        internalSetProperty(VersionManager.PROPNAME_PREDECESSORS, new InternalValue[0]);
+        internalSetProperty(VersionManager.PROPNAME_PREDECESSORS, new InternalValue[0], PropertyType.REFERENCE);
-     * Creates the frozen state from a node
+     * Restores the properties and child nodes from the frozen state.
+     * @param vsel
+     * @param removeExisting
+
+
+
-        // remove additional
+        // remove additional mixins
-        // first delete all non frozen version histories
+        // first delete all non frozen version histories, ie. all OPV!=Version
-            // this is a bit lousy
-            boolean found = false;
-            for (int i=0; i<frozenNodes.length; i++) {
-                InternalFreeze child = frozenNodes[i];
-                if (child instanceof InternalFrozenVersionHistory) {
-                    if (n.internalGetUUID().equals(child.getId())) {
-                        found = true;
-                        break;
-                    }
-                }
-            }
-            if (!found) {
+            if (n.getDefinition().getOnParentVersion()==OnParentVersionAction.COPY) {
+
+        // now restore the frozen ones
+                // check for existing
+                if (f.getFrozenUUID()!=null) {
+                    try {
+                        NodeImpl existing = (NodeImpl) session.getNodeByUUID(f.getFrozenUUID());
+                        if (removeExisting) {
+                            existing.remove();
+                        } else {
+                            // since we delete the OPV=Copy children beforehand, all
+                            // found nodes must be outside of this tree
+                            throw new ItemExistsException("Unable to restore node, item already exists outside of restored tree: " + existing.safeGetJCRPath());
+                        }
+                    } catch (ItemNotFoundException e) {
+                        // ignore, item with uuid does not exist
+                    }
+                }
+
-                String nodeId = history.getVersionedUUID();
+                String nodeId = history.getVersionableUUID();
-                        orderBefore(n.getName(), "");
+                        // orderBefore(n.getName(), "");

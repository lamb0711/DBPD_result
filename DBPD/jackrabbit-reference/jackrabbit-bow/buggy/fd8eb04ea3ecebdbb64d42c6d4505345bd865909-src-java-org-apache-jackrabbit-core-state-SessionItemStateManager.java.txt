optimized the following methods:

Node.addNode
Node.getProperty
Node.hasProperty
Node.getNode
Node.hasNode
Node.save

avoid unnecessary throwing & catching of exceptions
avoid unnecessary building & resolving of paths
avoid unnecessary regexp evaluations




git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@125788 13f79535-47bb-0310-9956-ffa450edef68

+import javax.jcr.InvalidItemStateException;
+import javax.jcr.ItemNotFoundException;
+    private final NodeId rootNodeId;
+        rootNodeId = new NodeId(rootNodeUUID);
-	// first check if the specified item has been transiently removed
-	if (transientStateMgr.hasItemStateInAttic(id)) {
-	    /**
-	     * check if there's new transient state for the specified item
-	     * (e.g. if a property with name 'x' has been removed and a new
-	     * property with same name has been created);
-	     */
-	    return transientStateMgr.hasItemState(id);
-	}
+        // first check if the specified item has been transiently removed
+        if (transientStateMgr.hasItemStateInAttic(id)) {
+            /**
+             * check if there's new transient state for the specified item
+             * (e.g. if a property with name 'x' has been removed and a new
+             * property with same name has been created);
+             */
+            return transientStateMgr.hasItemState(id);
+        }
-	// check if there's transient state for the specified item
-	if (transientStateMgr.hasItemState(id)) {
-	    return true;
-	}
+        // check if there's transient state for the specified item
+        if (transientStateMgr.hasItemState(id)) {
+            return true;
+        }
-	// check if there's persistent state for the specified item
-	if (persistentStateMgr.hasItemState(id)) {
-	    return true;
-	}
+        // check if there's persistent state for the specified item
+        if (persistentStateMgr.hasItemState(id)) {
+            return true;
+        }
-	return false;
+        return false;
+     * @throws InvalidItemStateException if any descendant item state has been
+     *                                   deleted externally
+     * @throws RepositoryException       if another error occurs
-    public Iterator getDescendantTransientItemStates(ItemId parentId) {
+    public Iterator getDescendantTransientItemStates(ItemId parentId)
+            throws InvalidItemStateException, RepositoryException {
-        try {
-            Path[] parentPaths = hierMgr.getAllPaths(parentId);
-            /**
-             * walk through list of transient states and check if
-             * they are descendants of the specified parent
-             */
+
+        // use shortcut if root was specified as parent
+        // (in which case all non-root states are descendents)
+        if (parentId.equals(rootNodeId)) {
-                Path[] paths = hierMgr.getAllPaths(id);
+                if (id.equals(rootNodeId)) {
+                    // skip root
+                    continue;
+                }
+                try {
+                    Path p = hierMgr.getPath(id);
+                    descendants.put(p, state);
+                } catch (ItemNotFoundException infe) {
+                    String msg = id + ": the item has been removed externally.";
+                    log.error(msg);
+                    throw new InvalidItemStateException(msg);
+                }
+            }
+            return descendants.values().iterator();
+        }
+
+        Path[] parentPaths = null;
+        try {
+            parentPaths = hierMgr.getAllPaths(parentId);
+        } catch (ItemNotFoundException infe) {
+            String msg = parentId + ": the item has been removed externally.";
+            log.error(msg);
+            throw new InvalidItemStateException(msg);
+        }
+
+        /**
+         * walk through list of transient states and check if
+         * they are descendants of the specified parent
+         */
+        try {
+            Iterator iter = transientStateMgr.getEntries();
+            while (iter.hasNext()) {
+                ItemState state = (ItemState) iter.next();
+                ItemId id = state.getId();
+                Path[] paths = null;
+                try {
+                    paths = hierMgr.getAllPaths(id);
+                } catch (ItemNotFoundException infe) {
+                    /**
+                     * one of the parents of the specified item has been
+                     * removed externally; as we don't know its path,
+                     * we can't determine if it is a descendant;
+                     * ItemNotFoundException should only be thrown if
+                     * a descendant is affected;
+                     * => log warning and ignore for now
+                     * todo FIXME
+                     */
+                    log.warn(id + ": inconsistent hierarchy state", infe);
+                    continue;
+                }
-                        Path[] pa = hierMgr.getAllPaths(new NodeId((String) iterUUIDs.next()));
+                        String uuid = (String) iterUUIDs.next();
+                        Path[] pa = null;
+                        try {
+                            pa = hierMgr.getAllPaths(new NodeId(uuid));
+                        } catch (ItemNotFoundException infe) {
+                            /**
+                             * one of the parents of the specified item has been
+                             * removed externally; as we don't know its path,
+                             * we can't determine if it is a descendant;
+                             * ItemNotFoundException should only be thrown if
+                             * a descendant is affected;
+                             * => log warning and ignore for now
+                             * todo FIXME
+                             */
+                            log.warn(id + ": inconsistent hierarchy state", infe);
+                            continue;
+                        }
+
-                                    // FIXME need to create dummy path in order
-                                    // to avoid conflicts
-                                    Path.PathBuilder pb = new Path.PathBuilder(p0.getElements());
-                                    pb.addFirst(NamespaceRegistryImpl.NS_DEFAULT_URI, Integer.toString(new Random().nextInt()));
-                                    descendants.put(pb.getPath(), state);
+                                    /**
+                                     * FIXME need to create dummy path by
+                                     * appending a random integer in order to
+                                     * avoid potential conflicts
+                                     */
+                                    Path dummy = Path.create(p0,
+                                            Path.create(new QName(NamespaceRegistryImpl.NS_DEFAULT_URI, Integer.toString(new Random().nextInt())), 0),
+                                            true);
+                                    descendants.put(dummy, state);
-            log.warn("inconsistent hierarchy state", mpe);
-        } catch (RepositoryException re) {
-            log.warn("inconsistent hierarchy state", re);
+            String msg = "inconsistent hierarchy state";
+            log.warn(msg, mpe);
+            throw new RepositoryException(msg, mpe);

workaround for locks that might be unlocked by another session (to be improved)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@521354 13f79535-47bb-0310-9956-ffa450edef68

+import javax.jcr.ItemNotFoundException;
-        if (lockMap.containsKey(nState)) {
-            return (LockImpl) lockMap.get(nState);
+        LockImpl l = getLockFromMap(nState);
+        if (l != null) {
+            return l;
-                if (lockMap.containsKey(lockHoldingState)) {
-                    return (LockImpl) lockMap.get(lockHoldingState);
+                l = getLockFromMap(nState);
+                if (l != null) {
+                    return l;
-            LockImpl lock;
-            if (lockMap.containsKey(lState.lockHoldingState)) {
-                lock = (LockImpl) lockMap.get(lState.lockHoldingState);
+            LockImpl lock = getLockFromMap(lState.lockHoldingState);
+            if (lock != null) {
+    private LockImpl getLockFromMap(NodeState nodeState) {
+        try {
+            LockImpl l = (LockImpl) lockMap.get(nodeState);
+            if (l != null && l.isLive()) {
+                return l;
+            }
+        } catch (RepositoryException e) {
+            // ignore
+        }
+        return null;
+    }
+    
-                    PropertyState ps = lockHoldingState.getPropertyState(QName.JCR_LOCKISDEEP);
-                    ps.removeListener(this);
-                } catch (RepositoryException e) {
-                    log.warn("Internal error", e);
+                    if (lockHoldingState.hasPropertyName(QName.JCR_LOCKISDEEP)) {
+                        PropertyState ps = lockHoldingState.getPropertyState(QName.JCR_LOCKISDEEP);
+                        ps.removeListener(this);
+                    }
+                } catch (ItemNotFoundException e) {
+                    log.debug("jcr:isDeep doesn't exist any more.");
+                } catch (Exception e) {
+                    log.warn(e.getMessage());
+        /**
+         * @see ItemStateLifeCycleListener#statusChanged(ItemState, int)
+         */
+                    break;
-                   // not interested (Todo correct?)
+                   // not interested
+        private boolean reloadInfo = false; // TODO: find better solution
-                // TODO: TOBEFIXED. since another session may become lock-holder for
-                // an open-scoped lock, the map entry and the lock information
-                // stored therein may become outdated.
+                // open-scoped locks: the map entry and the lock information
+                // stored therein may become outdated if the token is transfered
+                // to another session -> info must be reloaded.
+                if (!isSessionScoped()) {
+                    reloadInfo = true;
+                }
+            } else {
+                // foreign lock: info must be reloaded.
+                reloadInfo = true;
+            updateLockInfo();
+            updateLockInfo();
+        /**
+         * @return <code>LockInfo</code> stored within the <code>LockState</code>
+         */
+
+        /**
+         * Make sure the lock info is really up to date.
+         * TODO: find better solution.
+         */
+        private void updateLockInfo() {
+            if (reloadInfo) {
+                try {
+                    lockState.reloadLockInfo();
+                } catch (LockException e) {
+                    lockState.unlocked();
+                } catch (RepositoryException e) {
+                    log.error("Internal error", e);
+                }
+            } // else: nothing to do.
+        }
+        /**
+         * @return true if this lock is hold by this session. false otherwise.
+         */

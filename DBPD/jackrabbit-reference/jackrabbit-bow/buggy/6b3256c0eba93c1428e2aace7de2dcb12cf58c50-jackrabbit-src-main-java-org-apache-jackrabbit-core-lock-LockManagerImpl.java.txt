Locking and XA
- Introduce internal XA resources
- Add rollback thread that runs when transaction timeout has expired
- Make lock's live attribute transaction-aware
- Make NodeImpl's internalSetProperty protected again 



git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@365558 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.value.InternalValue;
-public class SharedLockManager implements LockManager, SynchronousEventListener {
+public class LockManagerImpl implements LockManager, SynchronousEventListener {
-    private static final Logger log = Logger.getLogger(SharedLockManager.class);
+    private static final Logger log = Logger.getLogger(LockManagerImpl.class);
-     * Monitor used when modifying content, too, in order to make modifications
-     * in the lock map and modifications in the content atomic.
-     */
-    private final Object contentMonitor = new Object();
-
-    /**
-    public SharedLockManager(SessionImpl session, FileSystem fs)
+    public LockManagerImpl(SessionImpl session, FileSystem fs)
-    Lock internalLock(NodeImpl node, boolean isDeep, boolean isSessionScoped)
+    AbstractLockInfo internalLock(NodeImpl node, boolean isDeep, boolean isSessionScoped)
-            return new LockImpl(info, node);
+            return info;
-     * Unlock a node given by its info. Invoked when a session logs out and
-     * all session scoped locks of that session must be unlocked.<p>
-     * In order to prevent deadlocks from within the synchronous dispatching of
-     * events, content modifications should not be made from within code
-     * sections that hold monitors. (see #JCR-194)
-     *
-     * @param info lock info
-     */
-    void unlock(LockInfo info) {
-        // if no session currently holds lock, take system session
-        SessionImpl session = info.getLockHolder();
-        if (session == null) {
-            session = this.session;
-        }
-        try {
-            synchronized (contentMonitor) {
-                // get node's path and remove child in path map
-                NodeImpl node = (NodeImpl) session.getItemManager().getItem(
-                        new NodeId(info.getUUID()));
-                Path path = getPath(node.getId());
-
-                acquire();
-
-                try {
-                    PathMap.Element element = lockMap.map(path, true);
-                    if (element != null) {
-                        element.set(null);
-                    }
-                    info.setLive(false);
-                    if (info.sessionScoped) {
-                        save();
-                    }
-
-                } finally {
-                    release();
-                }
-
-                // remove properties in content
-                node.internalSetProperty(QName.JCR_LOCKOWNER, (InternalValue) null);
-                node.internalSetProperty(QName.JCR_LOCKISDEEP, (InternalValue) null);
-                node.save();
-            }
-        } catch (RepositoryException e) {
-            log.warn("Unable to unlock session-scoped lock on node '"
-                    + info.lockToken + "': " + e.getMessage());
-            log.debug("Root cause: ", e);
-        }
-    }
-
-    /**
-        synchronized (contentMonitor) {
-            Lock lock = internalLock(node, isDeep, isSessionScoped);
-
-            // add properties to content
-            node.internalSetProperty(QName.JCR_LOCKOWNER,
-                    InternalValue.create(node.getSession().getUserID()));
-            node.internalSetProperty(QName.JCR_LOCKISDEEP,
-                    InternalValue.create(isDeep));
-            node.save();
-
-            return lock;
-        }
+        AbstractLockInfo info = internalLock(node, isDeep, isSessionScoped);
+        return new LockImpl(info, node);
-        synchronized (contentMonitor) {
-            internalUnlock(node);
-
-            // remove properties in content
-            node.internalSetProperty(QName.JCR_LOCKOWNER, (InternalValue) null);
-            node.internalSetProperty(QName.JCR_LOCKISDEEP, (InternalValue) null);
-            node.save();
-        }
+        internalUnlock(node);
-                    unlock(this);
+                    // if no session currently holds lock, reassign
+                    SessionImpl lockHolder = getLockHolder();
+                    if (lockHolder == null) {
+                        setLockHolder(session);
+                    }
+                    try {
+                        NodeImpl node = (NodeImpl) session.getItemManager().getItem(
+                                new NodeId(getUUID()));
+                        node.unlock();
+                    } catch (RepositoryException e) {
+                        log.warn("Unable to unlock session-scoped lock on node '"
+                                + lockToken + "': " + e.getMessage());
+                        log.debug("Root cause: ", e);
+                    }

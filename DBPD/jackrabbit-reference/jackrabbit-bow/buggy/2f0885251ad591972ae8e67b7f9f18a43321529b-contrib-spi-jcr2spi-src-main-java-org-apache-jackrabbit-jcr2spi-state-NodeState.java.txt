Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.state.entry.ChildNodeEntry;
-import org.apache.jackrabbit.jcr2spi.state.entry.ChildPropertyEntry;
-import org.apache.jackrabbit.jcr2spi.state.entry.PropertyReference;
-import org.apache.jackrabbit.jcr2spi.state.entry.ChildItemEntry;
-import org.apache.jackrabbit.name.Path;
+import org.apache.jackrabbit.jcr2spi.hierarchy.NodeEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.PropertyEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.HierarchyEntry;
+import org.apache.jackrabbit.jcr2spi.util.StateUtility;
+import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeRegistry;
-import org.apache.jackrabbit.spi.IdFactory;
-import org.apache.jackrabbit.spi.Event;
-import org.apache.jackrabbit.spi.QValue;
-import javax.jcr.ItemExistsException;
-import javax.jcr.ItemNotFoundException;
-import java.util.Collection;
-import java.util.Collections;
+
+    private NodeEntry hierarchyEntry;
+
-    private QName nodeTypeName;
-
-    /**
-     * The unique ID of this node state or <code>null</code> if this node state
-     * cannot be identified with a unique ID.
-     */
-    private String uniqueID;
-
-    /**
-     * The name of this node state
-     */
-    private QName name;
+    private final QName nodeTypeName;
-     * insertion-ordered collection of ChildNodeEntry objects
-     */
-    private ChildNodeEntries childNodeEntries;
-
-    /**
-     * Map of properties. Key = {@link QName} of property. Value = {@link
-     * PropertyReference}.
-     */
-    private HashMap properties = new HashMap();
-
-    /**
-     * Map of properties which are deleted and have been re-created as transient
-     * property with the same name.
-     */
-    private HashMap propertiesInAttic = new HashMap();
-
-    /**
-     * NodeReferences for this node state.
-     */
-    private NodeReferences references;
-
-    /**
-     * @param name          the name of this NodeState
-     * @param uniqueID      the uniqueID of this NodeState or <code>null</code> if
-     *                      this node state cannot be identified with a UUID.
-     * @param parent        the parent of this NodeState
-     * @param definition
+     * @param entry
-     * @param isf           the item state factory responsible for creating node
-     *                      states.
-     * @param idFactory     the <code>IdFactory</code> to create new id
-    protected NodeState(QName name, String uniqueID, NodeState parent,
-                        QName nodeTypeName, QNodeDefinition definition,
-                        int initialStatus, ItemStateFactory isf,
-                        IdFactory idFactory, boolean isWorkspaceState) {
-        super(parent, initialStatus, isf, idFactory, isWorkspaceState);
-        this.name = name;
-        this.uniqueID = uniqueID;
+    protected NodeState(NodeEntry entry, QName nodeTypeName, QName[] mixinTypeNames,
+                        QNodeDefinition definition, int initialStatus,
+                        boolean isWorkspaceState,
+                        ItemStateFactory isf, NodeTypeRegistry ntReg) {
+        super(initialStatus, isWorkspaceState, isf, ntReg);
+        this.hierarchyEntry = entry;
+        setMixinTypeNames(mixinTypeNames);
-     * @param parent         the parent of this NodeState
-     * @param idFactory      the <code>IdFactory</code> to create new id
-     *                       instance.
-    protected NodeState(NodeState overlayedState, NodeState parent,
-                        int initialStatus, ItemStateFactory isf,
-                        IdFactory idFactory) {
-        super(overlayedState, parent, initialStatus, isf, idFactory);
-        if (overlayedState != null) {
-            synchronized (overlayedState) {
-                NodeState wspState = overlayedState;
-                name = wspState.name;
-                uniqueID = wspState.uniqueID;
-                nodeTypeName = wspState.nodeTypeName;
-                definition = wspState.definition;
+    protected NodeState(NodeState overlayedState, int initialStatus, ItemStateFactory isf) {
+        super(overlayedState, initialStatus, isf);
-                init(wspState.getMixinTypeNames(), wspState.getPropertyNames(), wspState.getNodeReferences());
+        synchronized (overlayedState) {
+            hierarchyEntry = overlayedState.hierarchyEntry;
+            nodeTypeName = overlayedState.nodeTypeName;
+            definition = overlayedState.definition;
+            if (mixinTypeNames != null) {
+                this.mixinTypeNames = overlayedState.mixinTypeNames;
-    /**
-     *
-     * @param mixinTypeNames
-     * @param propertyNames
-     * @param references
-     */
-    void init(QName[] mixinTypeNames, Collection propertyNames, NodeReferences references) {
-        if (mixinTypeNames != null) {
-            this.mixinTypeNames = mixinTypeNames;
-        }
-        // set the node references
-        this.references = references;
-        // add property references
-        propertiesInAttic.clear();
-        properties.clear();
-        Iterator it = propertyNames.iterator();
-        while (it.hasNext()) {
-            QName propName = (QName) it.next();
-            ChildPropertyEntry pe = PropertyReference.create(this, propName, isf, idFactory);
-            properties.put(propName, pe);
-        }
-    }
-
-    private ChildNodeEntries childNodeEntries() {
-        if (childNodeEntries == null) {
-            try {
-                childNodeEntries = isf.getChildNodeEntries(this);
-            } catch (ItemStateException e) {
-                // TODO improve
-                throw new IllegalStateException();
-            }
-        }
-        return childNodeEntries;
-    }
+     * @see ItemState#getHierarchyEntry()
+     */
+    public HierarchyEntry getHierarchyEntry() {
+        return hierarchyEntry;
+    }
+
+    /**
-     * @see ItemState#getQName()
-     */
-    public final QName getQName() {
-        return name;
-    }
-
-    /**
-
+    
-     * {@inheritDoc}
-     * @see ItemState#reload(boolean)
+     * @see ItemState#merge(ItemState, boolean)
-    public void reload(boolean keepChanges) {
-        // recursivly reload states from peristent storage including props
-        // that are in the attic.
-        for (Iterator it = getAllChildEntries(true, true); it.hasNext();) {
-            ChildItemEntry ce = (ChildItemEntry) it.next();
-            if (ce.isAvailable()) {
-                try {
-                    ce.getItemState().reload(keepChanges);
-                } catch (ItemStateException e) {
-                    // should not occur
-                }
-            }
-        }
-
-        if (isWorkspaceState()) {
-            // reload from persistent storage ('keepChanges' not relevant).
-            try {
-                /* TODO: TOBEFIXED.
-                   recreating nodestate not correct. parent still has entry pointing
-                   to this state and subsequently retrieving the childentries fails,
-                   since id of tmp state cannot be resolved.
-                   -> add workaround until state hierarchy has been modified
-                */
-                NodeState tmp = isf.createNodeState(getNodeId(), getParent());
-                tmp.childNodeEntries = isf.getChildNodeEntries(this);
-
-                if (merge(tmp, false) || getStatus() == Status.INVALIDATED) {
-                    setStatus(Status.MODIFIED);
-                }
-            } catch (NoSuchItemStateException e) {
-                // remove entry from parent
-                getParent().childNodeEntries().remove(this);
-                // inform overlaying state and listeners
-                setStatus(Status.REMOVED);
-            } catch (ItemStateException e) {
-                // TODO rather throw? remove from parent?
-                log.warn("Exception while refreshing property state: " + e);
-                log.debug("Stacktrace: ", e);
-            }
-        } else {
-            /* session-state: if keepChanges is true only existing or invalidated
-               states must be updated. otherwise the state gets updated and might
-               be marked 'Stale' if transient changes are present and the
-               workspace-state is modified. */
-            if (!keepChanges || getStatus() == Status.EXISTING || getStatus() == Status.INVALIDATED) {
-                // calling refresh on the workspace state will in turn reset this state
-                overlayedState.reload(keepChanges);
-            }
-        }
-    }
-
-    boolean merge(ItemState another, boolean keepChanges) {
+    public boolean merge(ItemState another, boolean keepChanges) {
-            name = nState.name;
-            setUniqueID(nState.uniqueID);
-            nodeTypeName = nState.nodeTypeName;
-            definition = nState.definition;
-            // refs, mixin-types can be copied. they are never transiently changed.
-            references = nState.references;
-            List mixN = Arrays.asList(nState.mixinTypeNames);
-            modified = (mixN.size() != mixinTypeNames.length || !mixN.containsAll(Arrays.asList(mixinTypeNames)));
-            mixinTypeNames = nState.mixinTypeNames;
-
-            if (!keepChanges && !propertiesInAttic.isEmpty()) {
-                // remove all entries in the attic
+            if (hierarchyEntry != nState.hierarchyEntry) {
+                hierarchyEntry = nState.hierarchyEntry;
-                propertiesInAttic.clear();
+            }
+            if (nState.definition != null && !nState.definition.equals(definition)) {
+                definition = nState.definition;
+                modified = true;
-            /* merge child entries without loosing valid entries and connected states. */
-            // add all entry from wspState that are missing in this state
-            for (Iterator it = nState.getAllChildEntries(false, false); it.hasNext();) {
-                ChildItemEntry ce = (ChildItemEntry) it.next();
-                QName childName = ce.getName();
-                if (ce.denotesNode()) {
-                    ChildNodeEntry cne = (ChildNodeEntry) ce;
-                    int index = cne.getIndex();
-                    if (!childNodeEntries().contains(childName, index, cne.getUniqueID())) {
-                        modified = true;
-                        childNodeEntries().add(childName, cne.getUniqueID(), index);
-                    }
-                } else {
-                    if (!hasPropertyName(childName)) {
-                        modified = true;
-                        addPropertyEntry(PropertyReference.create(this, childName, isf, idFactory));
-                    }
-                }
-            }
-
-            // if keepChanges is false, remove all entries from this state,
-            // that are missing in the given other state.
-            if (!keepChanges) {
-                for (Iterator it = getAllChildEntries(true, false); it.hasNext();) {
-                    ChildItemEntry ce = (ChildItemEntry) it.next();
-                    QName childName = ce.getName();
-                    boolean toRemove = false;
-                    if (ce.denotesNode()) {
-                        ChildNodeEntry cne = (ChildNodeEntry) ce;
-                        int index = cne.getIndex();
-                        toRemove = !nState.childNodeEntries().contains(childName, index, cne.getUniqueID());
-                    } else {
-                        toRemove = !nState.properties.containsKey(childName);
-                    }
-
-                    if (toRemove) {
-                        modified = true;
-                        if (ce.isAvailable()) {
-                            // TODO: check if correct.
-                            try {
-                                ItemState st = ce.getItemState();
-                                if (st.getStatus() == Status.EXISTING_MODIFIED) {
-                                    st.setStatus(Status.STALE_DESTROYED);
-                                } else {
-                                    st.setStatus(Status.REMOVED);
-                                }
-                            } catch (ItemStateException e) {
-                                log.error("Internal error", e);
-                            }
-                        }
-                        // and remove the corresponding entry
-                        if (ce.denotesNode()) {
-                            childNodeEntries().remove(childName, ((ChildNodeEntry)ce).getIndex());
-                        } else {
-                            properties.remove(childName);
-                        }
-                    }
-                }
+            // since 'mixinTypeNames' are modified upon save only, no special
+            // merging is required here. just reset the mixinTypeNames.
+            List mixN = Arrays.asList(nState.mixinTypeNames);
+            if (mixN.size() != mixinTypeNames.length || !mixN.containsAll(Arrays.asList(mixinTypeNames))) {
+                setMixinTypeNames(nState.mixinTypeNames);
+                modified = true;
-
-    /**
-     * {@inheritDoc}
-     * @see ItemState#invalidate(boolean)
-     */
-    public void invalidate(boolean recursive) {
-        if (recursive) {
-            // invalidate all child entries including properties present in the
-            // attic (removed props shadowed by a new property with the same name).
-            for (Iterator it = getAllChildEntries(false, true); it.hasNext();) {
-                ChildItemEntry ce = (ChildItemEntry) it.next();
-                if (ce.isAvailable()) {
-                    try {
-                        ce.getItemState().invalidate(true);
-                    } catch (ItemStateException e) {
-                        // should not occur
-                    }
-                }
-            }
-        }
-        // ... and invalidate this state
-        if (isWorkspaceState()) {
-            // workspace state
-            setStatus(Status.INVALIDATED);
-        } else {
-            // TODO only invalidate if existing?
-            if (getStatus() == Status.EXISTING) {
-                // set workspace state invalidated, this will in turn invalidate
-                // this (session) state as well
-                overlayedState.setStatus(Status.INVALIDATED);
-            }
-        }
-    }
+     * @return The <code>NodeEntry</code> associated with this state.
+     */
+    public NodeEntry getNodeEntry() {
+        return (NodeEntry) getHierarchyEntry();
+    }
+
+    /**
-        if (uniqueID != null) {
-            return idFactory.createNodeId(uniqueID);
-        }
-
-        NodeState parent = getParent();
-        if (parent == null) {
-           // root node
-            return idFactory.createNodeId((String) null, Path.ROOT);
-        } else {
-            // find this in parent child node entries
-            for (Iterator it = parent.childNodeEntries().get(name).iterator(); it.hasNext(); ) {
-                ChildNodeEntry cne = (ChildNodeEntry) it.next();
-                try {
-                    if (cne.getNodeState() == this) {
-                        Path relPath = Path.create(cne.getName(), cne.getIndex());
-                        return idFactory.createNodeId(parent.getNodeId(), relPath);
-                    }
-                } catch (ItemStateException e) {
-                    log.warn("Unable to access child node entry: " + cne.getId());
-                }
-            }
-        }
-        // TODO: replace with ItemStateException instead of error.
-        throw new InternalError("Unable to retrieve NodeId for NodeState");
+        return getNodeEntry().getId();
-        return uniqueID;
+        return getNodeEntry().getUniqueID();
-     * Modify the uniqueID of this state and make sure, that the parent state
-     * contains a proper childNodeEntry for this state. If the given uniqueID is
-     * not different from the uniqueID of this state, the method returns silently
-     * without changing neither the parent nor this state.
+     * Returns true, if this <code>NodeState</code> represent the root node.
-     * @param uniqueID
+     * @return true if this <code>NodeState</code> represent the root node.
-    private void setUniqueID(String uniqueID) {
-        String oldUniqueID = this.uniqueID;
-        boolean mod = (oldUniqueID == null) ? uniqueID != null : !oldUniqueID.equals(uniqueID);
-        if (mod) {
-            this.uniqueID = uniqueID;
-            if (getParent() != null) {
-                getParent().childNodeEntries().replaceEntry(this);
-            }
-        }
-    }
-
-    /**
-     * Returns the index of this node state.
-     *
-     * @return the index.
-     */
-    public int getIndex() throws ItemNotFoundException {
-        if (getParent() == null) {
-            // the root state may never have siblings
-            return Path.INDEX_DEFAULT;
-        }
-
-        if (getDefinition().allowsSameNameSiblings()) {
-            ChildNodeEntry entry = getParent().childNodeEntries().get(this);
-            if (entry == null) {
-                String msg = "Unable to retrieve index for: " + this;
-                throw new ItemNotFoundException(msg);
-            }
-            return entry.getIndex();
-        } else {
-            return Path.INDEX_DEFAULT;
-        }
+    public boolean isRoot() {
+        return getHierarchyEntry().getParent() == null;
-    public synchronized QName[] getMixinTypeNames() {
+    public QName[] getMixinTypeNames() {
+     * TODO improve
+     * !! Used by NodeEntryImpl and NodeState only
+     *
+     * @param mixinTypeNames
+     */
+    public void setMixinTypeNames(QName[] mixinTypeNames) {
+        if (mixinTypeNames != null) {
+            this.mixinTypeNames = mixinTypeNames;
+        }
+    }
+
+    /**
-    public QNodeDefinition getDefinition() {
+    public QNodeDefinition getDefinition() throws RepositoryException {
+        if (definition == null) {
+            definition = getEffectiveNodeType().getApplicableNodeDefinition(getQName(), getNodeTypeName(), getNodeTypeRegistry());
+        }
-
-    NodeReferences getNodeReferences() {
-        return references;
+    public NodeReferences getNodeReferences() {
+        return isf.getNodeReferences(this);
-     * Determines if there are any valid child node entries.
-     *
-     * @return <code>true</code> if there are child node entries,
-     * <code>false</code> otherwise.
-     */
-    public boolean hasChildNodeEntries() {
-        return containsValidChildNodeEntry(childNodeEntries());
-    }
-
-    /**
-     * Determines if there is a valid <code>ChildNodeEntry</code> with the
-     * specified <code>name</code>.
-     *
-     * @param name <code>QName</code> object specifying a node name
-     * @return <code>true</code> if there is a <code>ChildNodeEntry</code> with
-     *         the specified <code>name</code>.
-     */
-    public synchronized boolean hasChildNodeEntry(QName name) {
-        return containsValidChildNodeEntry(childNodeEntries().get(name));
-    }
-
-    /**
-     * Determines if there is a valid <code>ChildNodeEntry</code> with the
+     * Utility
+     * Determines if there is a valid <code>NodeEntry</code> with the
-     * @return <code>true</code> if there is a <code>ChildNodeEntry</code> with
+     * @return <code>true</code> if there is a <code>NodeEntry</code> with
-    public synchronized boolean hasChildNodeEntry(QName name, int index) {
-        return isValidChildNodeEntry(childNodeEntries().get(name, index));
+    public boolean hasChildNodeEntry(QName name, int index) {
+        return getNodeEntry().hasNodeEntry(name, index);
-     * Returns the valid <code>ChildNodeEntry</code> with the specified name
-     * and index or <code>null</code> if there's no matching entry.
+     * Utility
+     * Returns the child <code>NodeState</code> with the specified name
+     * and index or <code>null</code> if there's no matching, valid entry.
-     * @return The <code>ChildNodeEntry</code> with the specified name and index
-     * or <code>null</code> if there's no matching entry.
+     * @return The <code>NodeState</code> with the specified name and index
+     * @throws NoSuchItemStateException
+     * @throws ItemStateException
-    public synchronized ChildNodeEntry getChildNodeEntry(QName nodeName, int index) {
-        ChildNodeEntry cne = childNodeEntries().get(nodeName, index);
-        if (isValidChildNodeEntry(cne)) {
-            return cne;
+    public NodeState getChildNodeState(QName nodeName, int index) throws NoSuchItemStateException, ItemStateException {
+        NodeEntry child = getNodeEntry().getNodeEntry(nodeName, index);
+        if (child != null) {
+            return child.getNodeState();
-            return null;
+            // TODO: correct?
+            throw new NoSuchItemStateException("Child node "+ nodeName +" with index " + index + " does not exist.");
-     * Returns the <code>ChildNodeEntry</code> with the specified
-     * <code>NodeId</code> or <code>null</code> if there's no matching
-     * entry.
-     *
-     * @param nodeId the id of the child node state.
-     * @return the <code>ChildNodeEntry</code> with the specified
-     * <code>NodeId</code> or <code>null</code> if there's no matching entry.
-     */
-    synchronized ChildNodeEntry getChildNodeEntry(NodeId nodeId) {
-        String uid = nodeId.getUniqueID();
-        Path path = nodeId.getPath();
-        ChildNodeEntry cne;
-        if (uid != null && path == null) {
-            // retrieve child-entry by uid
-            cne = childNodeEntries().get(null, uid);
-        } else {
-           // retrieve child-entry by name and index
-            Path.PathElement nameElement = path.getNameElement();
-            cne = childNodeEntries().get(nameElement.getName(), nameElement.getIndex());
-        }
-
-        if (isValidChildNodeEntry(cne)) {
-            return cne;
-        } else {
-            return null;
-        }
-    }
-
-    /**
-     * Returns a unmodifiable collection of <code>ChildNodeEntry</code> objects
-     * denoting the child nodes of this node.
-     *
-     * @return collection of <code>ChildNodeEntry</code> objects
-     */
-    public synchronized Collection getChildNodeEntries() {
-        Collection entries = new ArrayList();
-        for (Iterator it = childNodeEntries().iterator(); it.hasNext();) {
-            ChildNodeEntry cne = (ChildNodeEntry) it.next();
-            if (isValidChildNodeEntry(cne)) {
-                entries.add(cne);
-            }
-        }
-        return Collections.unmodifiableCollection(entries);
-    }
-
-    /**
-     * Returns a unmodifiable list of <code>ChildNodeEntry</code>s with the
-     * specified name.
-     *
-     * @param nodeName name of the child node entries that should be returned
-     * @return list of <code>ChildNodeEntry</code> objects
-     */
-    public synchronized List getChildNodeEntries(QName nodeName) {
-        List entries = new ArrayList();
-        for (Iterator it = childNodeEntries().get(nodeName).iterator(); it.hasNext();) {
-            ChildNodeEntry cne = (ChildNodeEntry) it.next();
-            if (isValidChildNodeEntry(cne)) {
-                entries.add(cne);
-            }
-        }
-        return Collections.unmodifiableList(entries);
-    }
-
-    /**
-     * Determines if there is a property entry with the specified
-     * <code>QName</code>.
+     * Utility
-     * @return <code>true</code> if there is a property entry with the specified
-     *         <code>QName</code>.
+     * @return <code>true</code> if there is a valid property entry with the
+     * specified <code>QName</code>.
-    public synchronized boolean hasPropertyName(QName propName) {
-        ChildPropertyEntry entry = (ChildPropertyEntry) properties.get(propName);
-        return isValidChildPropertyEntry(entry);
+    public boolean hasPropertyName(QName propName) {
+        return getNodeEntry().hasPropertyEntry(propName);
-     * Returns the names of this node's properties as a set of
-     * <code>QNames</code> objects.
-     *
-     * @return set of <code>QNames</code> objects
-     */
-    public synchronized Collection getPropertyNames() {
-        Collection names;
-        if (getStatus() == Status.EXISTING_MODIFIED) {
-            names = new ArrayList();
-            for (Iterator it = getPropertyEntries().iterator(); it.hasNext(); ) {
-                names.add(((ChildPropertyEntry) it.next()).getName());
-            }
-        } else {
-            // this node state is unmodified, return all
-            names = properties.keySet();
-        }
-        return Collections.unmodifiableCollection(names);
-    }
-
-    /**
-     * Returns the complete collection of {@link ChildPropertyEntry}s.
-     *
-     * @return unmodifiable collection of <code>ChildPropertyEntry</code> objects
-     */
-    public synchronized Collection getPropertyEntries() {
-        Collection props;
-        if (getStatus() == Status.EXISTING_MODIFIED) {
-            // filter out removed properties
-            props = new ArrayList();
-            for (Iterator it = properties.values().iterator(); it.hasNext(); ) {
-                ChildPropertyEntry propEntry = (ChildPropertyEntry) it.next();
-                if (isValidChildPropertyEntry(propEntry)) {
-                    props.add(propEntry);
-                }
-            }
-        } else {
-            // no need to filter out properties, there are no removed properties
-            props = properties.values();
-        }
-        return Collections.unmodifiableCollection(props);
-    }
-
-    /*
-     * Returns the property state with the given name.
+     * Utility method that returns the property state with the given name.
+     *
+     * @see NodeEntry#getPropertyEntry(QName)
+     * @see PropertyEntry#getPropertyState()
-    public synchronized PropertyState getPropertyState(QName propertyName)
-        throws NoSuchItemStateException, ItemStateException {
-
-        ChildPropertyEntry propEntry = (ChildPropertyEntry) properties.get(propertyName);
-        if (propEntry == null) {
-            throw new NoSuchItemStateException(idFactory.createPropertyId(getNodeId(), propertyName).toString());
+    public PropertyState getPropertyState(QName propertyName) throws NoSuchItemStateException, ItemStateException {
+        PropertyEntry child = getNodeEntry().getPropertyEntry(propertyName);
+        if (child != null) {
+            return child.getPropertyState();
-            PropertyState propState = propEntry.getPropertyState();
-            if (propState.isValid()) {
-                return propState;
-            } else {
-                throw new NoSuchItemStateException(idFactory.createPropertyId(getNodeId(), propertyName).toString());
-            }
+            // TODO; correct?
+            throw new NoSuchItemStateException("Child Property with name " + propertyName + " does not exist.");
-     *
-     * @param propEntry
-     */
-    private void addPropertyEntry(ChildPropertyEntry propEntry) {
-        QName propName = propEntry.getName();
-        properties.put(propName, propEntry);
-        try {
-            if (isWorkspaceState() && isUuidOrMixin(propName)) {
-                if (QName.JCR_UUID.equals(propName) && uniqueID == null) {
-                    PropertyState ps = propEntry.getPropertyState();
-                    setUniqueID(ps.getValue().getString());
-                } else if (QName.JCR_MIXINTYPES.equals(propName) && (mixinTypeNames == null || mixinTypeNames.length == 0)) {
-                    PropertyState ps = propEntry.getPropertyState();
-                    mixinTypeNames = getMixinNames(ps);
-                }
-            }
-        } catch (ItemStateException e) {
-            log.error("Internal Error", e);
-        } catch (RepositoryException e) {
-            log.error("Internal Error", e);
-        }
-    }
-
-    /**
-     *
-     * @param propName
-     */
-    private ChildPropertyEntry removePropertyEntry(QName propName) {
-        ChildPropertyEntry cpe = (ChildPropertyEntry) properties.remove(propName);
-        if (cpe != null) {
-            if (isWorkspaceState()) {
-                if (QName.JCR_UUID.equals(propName)) {
-                    setUniqueID(null);
-                } else if (QName.JCR_MIXINTYPES.equals(propName)) {
-                    mixinTypeNames = QName.EMPTY_ARRAY;
-                }
-            }
-        }
-        return cpe;
-    }
-
-    /**
-     * TODO: find a better way to provide the index of a child node entry
-     * Returns the index of the given <code>ChildNodeEntry</code> and with
-     * <code>name</code>.
-     *
-     * @param cne  the <code>ChildNodeEntry</code> instance.
-     * @return the index of the child node entry or <code>Path.INDEX_UNDEFINED</code>
-     * if it is not found in this <code>NodeState</code>.
-     */
-    public int getChildNodeIndex(ChildNodeEntry cne) {
-        List sns = childNodeEntries().get(cne.getName());
-        // index is one based
-        int index = 1;
-        for (Iterator it = sns.iterator(); it.hasNext(); ) {
-            ChildNodeEntry entry = (ChildNodeEntry) it.next();
-            if (entry == cne) {
-                return index;
-            }
-            // skip entries that belong to removed or invalidated states.
-            // NOTE, that in this case the nodestate must be available from the cne.
-            if (isValidChildNodeEntry(entry)) {
-                index++;
-            }
-        }
-        // not found
-        return Path.INDEX_UNDEFINED;
-    }
-    //--------------------------------------------------< Workspace - State >---
-    /**
-     *
-     * @param event
-     * @see ItemState#refresh(Event)
-     */
-    synchronized void refresh(Event event) {
-        checkIsWorkspaceState();
-
-        NodeId id = getNodeId();
-        QName name = event.getQPath().getNameElement().getName();
-        switch (event.getType()) {
-            case Event.NODE_ADDED:
-                int index = event.getQPath().getNameElement().getNormalizedIndex();
-                NodeId evId = (NodeId) event.getItemId();
-                String uniqueID = (evId.getPath() != null) ? null : evId.getUniqueID();
-
-                // add new childNodeEntry if it has not been added by
-                // some earlier 'add' event
-                // TODO: TOBEFIXED for SNSs
-                ChildNodeEntry cne = (uniqueID != null) ? childNodeEntries().get(name, uniqueID) : childNodeEntries().get(name, index);
-                if (cne == null) {
-                    cne = childNodeEntries().add(name, uniqueID, index);
-                }
-                // and let the transiently modified session state now, that
-                // its workspace state has been touched.
-                setStatus(Status.MODIFIED);
-                break;
-
-            case Event.PROPERTY_ADDED:
-                // create a new property reference if it has not been
-                // added by some earlier 'add' event
-                if (!hasPropertyName(name)) {
-                    ChildPropertyEntry re = PropertyReference.create(this, name, isf, idFactory);
-                    addPropertyEntry(re);
-                }
-                // and let the transiently modified session state now, that
-                // its workspace state has been touched.
-                setStatus(Status.MODIFIED);
-                break;
-
-            case Event.NODE_REMOVED:
-                if (id.equals(event.getParentId())) {
-                    index = event.getQPath().getNameElement().getNormalizedIndex();
-                    childNodeEntries().remove(name, index);
-                    setStatus(Status.MODIFIED);
-                } else if (id.equals(event.getItemId())) {
-                    setStatus(Status.REMOVED);
-                } else {
-                    // ILLEGAL
-                    throw new IllegalArgumentException("Illegal event type " + event.getType() + " for NodeState.");
-                }
-                break;
-
-            case Event.PROPERTY_REMOVED:
-                removePropertyEntry(name);
-                setStatus(Status.MODIFIED);
-                break;
-
-            case Event.PROPERTY_CHANGED:
-                if (QName.JCR_UUID.equals(name) || QName.JCR_MIXINTYPES.equals(name)) {
-                    try {
-                        PropertyState ps = getPropertyState(name);
-                        adjustNodeState(this, new PropertyState[] {ps});
-                    } catch (ItemStateException e) {
-                        // should never occur.
-                        log.error("Internal error while updating node state.", e);
-                    }
-                }
-                break;
-            default:
-                // ILLEGAL
-                throw new IllegalArgumentException("Illegal event type " + event.getType() + " for NodeState.");
-        }
-    }
-
-    //----------------------------------------------------< Session - State >---
-    /**
-            ItemState state = (ItemState) it.next();
-            state.setStatus(Status.REMOVED);
-            state.overlayedState.setStatus(Status.REMOVED);
+            ItemState delState = (ItemState) it.next();
+
+            // delState.overlayedState.getHierarchyEntry().remove();
+            delState.getHierarchyEntry().remove();
-            NodeState parent = state.getParent();
-            if (!changeLog.containsDeletedState(parent)) {
-                NodeState overlayedParent = (NodeState) parent.overlayedState;
-                if (state.isNode()) {
-                    overlayedParent.childNodeEntries().remove((NodeState)state.overlayedState);
-                    parent.childNodeEntries().remove((NodeState)state);
-                } else {
-                    overlayedParent.removePropertyEntry(state.overlayedState.getQName());
-                    parent.removePropertyEntry(state.getQName());
+            try {
+                NodeState parent = delState.getParent();
+                if (!changeLog.containsDeletedState(parent)) {
+                    modifiedParent(parent, delState, modParents);
-                modifiedParent(parent, state, modParents);
+            } catch (ItemStateException e) {
+                // ignore. if parent state does not exist it doesn't need to be adjusted
-            NodeState parent = addedState.getParent();
-            // TODO: improve. only retrieve overlayed state, if necessary
-                // adjust parent child-entries
-                NodeState overlayedParent = (NodeState) parent.overlayedState;
-                QName addedName = addedState.getQName();
-                if (addedState.isNode()) {
-                    int index = parent.childNodeEntries().get((NodeState)addedState).getIndex();
-                    ChildNodeEntry cne;
-                    // check for existing, valid child-node-entry
-                    if (overlayedParent.hasChildNodeEntry(addedName, index)) {
-                        cne = overlayedParent.getChildNodeEntry(addedName, index);
-                    } else {
-                        cne = overlayedParent.childNodeEntries().add(addedState.getQName(), null, index);
-                    }
-                    NodeState overlayed = cne.getNodeState();
-                    if (overlayed.getUniqueID() != null) {
-                        overlayedParent.childNodeEntries().replaceEntry(overlayed);
-                    }
-                    addedState.connect(overlayed);
-                } else {
-                    ChildPropertyEntry pe;
-                    if (overlayedParent.hasPropertyName(addedName)) {
-                        pe = (ChildPropertyEntry) overlayedParent.properties.get(addedName);
-                    } else {
-                        pe = PropertyReference.create(overlayedParent, addedName, overlayedParent.isf,  overlayedParent.idFactory);
-                        overlayedParent.addPropertyEntry(pe);
-                    }
-                    addedState.connect(pe.getPropertyState());
-                }
+                NodeState parent = addedState.getParent();
+                // connect the new state to its overlayed state (including update
+                // via merging in order to be aware of autocreated values,
+                // changed definition etc.
+                addedState.reconnect(false);
-                // make sure the new state gets updated (e.g. uniqueID created by server)
-                addedState.merge(addedState.overlayedState, true);
-                // and mark the added-state existing
-                addedState.setStatus(Status.EXISTING);
-                log.error("Internal error.", e);
+                // should never occur
+                log.error("Internal error", e);
-                NodeState modNodeState = (NodeState) modState;
-                // handle moved nodes
-                if (isMovedState(modNodeState)) {
-                    // move overlayed state as well
-                    NodeState newParent = (NodeState) modState.getParent().overlayedState;
+                if (StateUtility.isMovedState((NodeState) modState)) {
+                    // move overlayed state as well by setting NodeEntry and
+                    // definition according to session-state
-                    try {
-                        overlayed.getParent().moveEntry(newParent, overlayed, modNodeState.getQName(), modNodeState.getDefinition());
-                    } catch (RepositoryException e) {
-                        // should never occur
-                        log.error("Internal error while moving childnode entries.", e);
-                    }
+                    overlayed.hierarchyEntry = ((NodeState) modState).hierarchyEntry;
+                    overlayed.definition = ((NodeState) modState).definition;
+
-                    modNodeState.setStatus(Status.EXISTING);
+                    modState.setStatus(Status.EXISTING);
-                    modifiedParent((NodeState)modState, null, modParents);
+                    // remember state as modified only for later processing
+                    if (!modParents.containsKey(modState)) {
+                        modParents.put(modState, new ArrayList(2));
+                    }
-                // push changes down to overlayed state
-                int type = ((PropertyState) modState).getType();
-                QValue[] values = ((PropertyState) modState).getValues();
-                ((PropertyState) modState.overlayedState).init(type, values);
-
+                // Properties: push changes down to overlayed state
+                ((PropertyState) modState.overlayedState).merge(modState, false);
-                // if property state defines a modified jcr:mixinTypes
-                // the parent is listed as modified state and needs to be
-                // processed at the end.
-                if (isUuidOrMixin(modState.getQName())) {
-                    modifiedParent(modState.getParent(), modState, modParents);
+
+                // if property state defines a modified jcr:mixinTypes the parent
+                // is listed as modified state and needs to be processed at the end.
+                if (QName.JCR_MIXINTYPES.equals(modState.getQName())) {
+                    try {
+                        modifiedParent(modState.getParent(), modState, modParents);
+                    } catch (ItemStateException e) {
+                        // should never occur. since parent must be available otherwise
+                        // the mixin could not been added/removed.
+                        log.error("Internal error", e);
+                    }
-            if (cacheBehaviour == CacheBehaviour.OBSERVATION) {
-                adjustNodeState(parent, (PropertyState[]) l.toArray(new PropertyState[l.size()]));
-            } else {
-                // TODO: improve. invalidate necessary states only
-                parent.invalidate(false);
-            }
+            adjustNodeState(parent, (PropertyState[]) l.toArray(new PropertyState[l.size()]), cacheBehaviour);
-                state.invalidate(false);
+                state.setStatus(Status.EXISTING);
-     * Recursively removes all child states and then calls {@link ItemState#remove()}.
-     *
-     * @inheritDoc
-     * @see ItemState#remove()
-     */
-    void remove() throws ItemStateException {
-        checkIsSessionState();
-        if (!isValid()) {
-            throw new ItemStateException("cannot remove an invalid NodeState");
-        }
-        for (Iterator it = getAllChildEntries(true, false); it.hasNext();) {
-            ChildItemEntry ce = (ChildItemEntry) it.next();
-            if (ce.isAvailable()) {
-                ItemState childState = ce.getItemState();
-                if (childState.isValid()) {
-                    childState.remove();
-                } else if (!ce.denotesNode()) {
-                    // remove invalid property state from properties map
-                    it.remove();
-                    // TODO: check if for node-entries no action is required
-                }
-            } else if (!ce.denotesNode()) {
-                // remove unresolved entry from properties map
-                it.remove();
-                // TODO check if for node entries no action required
-            }
-        }
-
-        if (!propertiesInAttic.isEmpty()) {
-            // move all properties from attic back to properties map
-            properties.putAll(propertiesInAttic);
-            propertiesInAttic.clear();
-        }
-
-        // process this state as well.
-        super.remove();
-    }
-
-    /**
-     * Calls {@link ItemState#revert()} and moves all properties from the attic
-     * back into th properties map.
-     *
-     * @inheritDoc
-     * @see ItemState#revert()
-     */
-    void revert() throws ItemStateException {
-        super.revert();
-        if (!propertiesInAttic.isEmpty()) {
-            // move all properties from attic back to properties map
-            properties.putAll(propertiesInAttic);
-            propertiesInAttic.clear();
-        }
-    }
-
-    /**
-     * Adds this state to the changeLog if it is transiently modified, new or stale
-     * and subsequently calls this method on all child states including those
-     * property states that have been moved to the attic.
-     *
-     * @inheritDoc
-     * @see ItemState#collectStates(ChangeLog, boolean)
-     */
-    void collectStates(ChangeLog changeLog, boolean throwOnStale) throws StaleItemStateException {
-        super.collectStates(changeLog, throwOnStale);
-
-        // collect transient child states including properties in attic.
-        for (Iterator it = getAllChildEntries(false, true); it.hasNext();) {
-            ChildItemEntry ce = (ChildItemEntry) it.next();
-            if (ce.isAvailable()) {
-                try {
-                    ce.getItemState().collectStates(changeLog, throwOnStale);
-                } catch (ItemStateException e) {
-                    // should not happen because ref is available
-                }
-            }
-        }
-    }
-
-    /**
-     * Adds a child node state to this node state.
-     *
-     * @param child the node state to add.
-     * @throws IllegalArgumentException if <code>this</code> is not the parent
-     *                                  of <code>child</code>.
-     */
-    synchronized void addChildNodeState(NodeState child) {
-        checkIsSessionState();
-        if (child.getParent() != this) {
-            throw new IllegalArgumentException("This NodeState is not the parent of child");
-        }
-        childNodeEntries().add(child);
-        markModified();
-    }
-
-    /**
-     * Adds a property state to this node state.
-     *
-     * @param propState the property state to add.
-     * @throws ItemExistsException If <code>this</code> node state already
-     * contains a valid property state with the same name as <code>propState</code>.
-     * @throws IllegalArgumentException if <code>this</code> is not the parent
-     *                                  of <code>propState</code>.
-     */
-    synchronized void addPropertyState(PropertyState propState) throws ItemExistsException {
-        checkIsSessionState();
-        if (propState.getParent() != this) {
-            throw new IllegalArgumentException("This NodeState is not the parent of propState");
-        }
-        QName propertyName = propState.getQName();
-        // check for an existing property
-        PropertyReference ref = (PropertyReference) properties.get(propertyName);
-        if (ref != null) {
-            PropertyState existingState = null;
-            try {
-                existingState = ref.getPropertyState();
-            } catch (ItemStateException e) {
-                // probably does not exist anymore, remove from properties map
-                removePropertyEntry(propertyName);
-            }
-            if (existingState != null) {
-                if (existingState.getStatus() == Status.EXISTING_REMOVED) {
-                    // move to attic
-                    propertiesInAttic.put(propertyName, ref);
-                } else {
-                    throw new ItemExistsException(propertyName.toString());
-                }
-            }
-        }
-        addPropertyEntry(PropertyReference.create(propState, isf, idFactory));
-        markModified();
-    }
-
-    /**
-     * Notifies this node state that a child item state has been removed or
-     * otherwise modified.
-     *
-     * @param childState the child item state that has been removed or modified.
-     * @throws IllegalArgumentException if <code>this</code> is not the parent
-     * of the given <code>ItemState</code>.
-     */
-    synchronized void childStatusChanged(ItemState childState, int previousStatus) {
-        checkIsSessionState();
-        if (childState.getParent() != this) {
-            throw new IllegalArgumentException("This NodeState is not the parent of propState");
-        }
-
-        switch (childState.getStatus()) {
-            case Status.EXISTING_REMOVED:
-                markModified();
-                break;
-            case Status.REMOVED:
-                if (childState.isNode()) {
-                    childNodeEntries().remove((NodeState) childState);
-                } else {
-                    removePropertyEntry(childState.getQName());
-                }
-                // TODO: TOBEFIXED. removing a NEW state may even remove the 'modified'
-                // flag from the parent, if this NEW state was the only modification.
-                if (previousStatus != Status.NEW) {
-                    markModified();
-                }
-                break;
-            case Status.EXISTING:
-                if (previousStatus == Status.EXISTING_REMOVED && !childState.isNode()) {
-                    QName propName = childState.getQName();
-                    if (propertiesInAttic.containsKey(propName)) {
-                        properties.put(childState.getQName(), propertiesInAttic.remove(propName));
-                    }
-                }
-        }
-    }
-
-    /**
-     *                   <code>null</code> the child node <code>insertNode</code>
-     *                   is moved to the end of the child node entries.
+     * <code>null</code> the child node <code>insertNode</code> is moved to the
+     * end of the child node entries.
-     *                                  <code>beforeNode</code> is not a child
-     *                                  node of this <code>NodeState</code>.
+     * <code>beforeNode</code> is not a child node of this <code>NodeState</code>.
-        childNodeEntries().reorder(insertNode, beforeNode);
+        NodeEntry before = (beforeNode == null) ? null : beforeNode.getNodeEntry();
+        insertNode.getNodeEntry().orderBefore(before);
-     * Moves a <code>ChildNodeEntry</code> to a new parent. If the new parent
+     * Moves a <code>NodeEntry</code> to a new parent. If the new parent
-        moveEntry(newParent, childState, newName, newDefinition);
+        // move child entry
+        NodeEntry newEntry = getNodeEntry().moveNodeEntry(childState, newName, newParent.getNodeEntry());
+
+        // set new NodeEntry on child state, that differs from the HE of the workspaceState
+        // TODO: check again
+        childState.hierarchyEntry = newEntry;
+        childState.definition = newDefinition;
+
-     * @param newParent
-     * @param newName
-     * @param newDefinition
-     * @throws RepositoryException
+     * @param modParents
-    private void moveEntry(NodeState newParent, NodeState childState, QName newName, QNodeDefinition newDefinition) throws RepositoryException {
-        ChildNodeEntry oldEntry = childNodeEntries().remove(childState);
-        if (oldEntry != null) {
-            childState.name = newName;
-            // re-parent target node
-            childState.parent = newParent;
-            // set definition according to new definition required by the new parent
-            childState.definition = newDefinition;
-            // add child node entry to new parent
-            newParent.childNodeEntries().add(childState);
-        } else {
-            throw new RepositoryException("Unexpected error: Child state to be moved does not exist.");
-        }
-    }
-
-    /**
-     *
-     * @param createNewList if true, both properties and childNodeEntries are
-     * copied to new list, since recursive calls may call this node state to
-     * inform the removal of a child entry.
-     *
-     * @return
-     */
-    private Iterator getAllChildEntries(boolean createNewList, boolean includeAttic) {
-        Iterator[] its;
-        if (createNewList) {
-            List props = new ArrayList(properties.values());
-            List children = new ArrayList(childNodeEntries());
-            if (includeAttic) {
-                List attic = new ArrayList(propertiesInAttic.values());
-                its = new Iterator[] {attic.iterator(), props.iterator(), children.iterator()};
-            } else {
-                its = new Iterator[] {props.iterator(), children.iterator()};
-            }
-        } else {
-            if (includeAttic) {
-                its = new Iterator[] {propertiesInAttic.values().iterator(), properties.values().iterator(), childNodeEntries().iterator()};
-            } else {
-                its = new Iterator[] {properties.values().iterator(), childNodeEntries().iterator()};
-            }
-        }
-        IteratorChain chain = new IteratorChain(its);
-        return chain;
-    }
-    //-------------------------------< internal >-------------------------------
-    /**
-     * Returns <code>true</code> if the collection of child node
-     * <code>entries</code> contains at least one valid <code>ChildNodeEntry</code>.
-     *
-     * @param entries the collection to check.
-     * @return <code>true</code> if one of the entries is valid; otherwise
-     *         <code>false</code>.
-     */
-    private static boolean containsValidChildNodeEntry(Collection entries) {
-        boolean hasValid = false;
-        for (Iterator it = entries.iterator(); it.hasNext() && !hasValid; ) {
-            ChildNodeEntry cne = (ChildNodeEntry) it.next();
-            hasValid = isValidChildNodeEntry(cne);
-        }
-        return hasValid;
-    }
-
-    /**
-     * Returns <code>true</code> if the given childnode entry is not
-     * <code>null</code> and resolves to a NodeState, that is valid or if the
-     * childnode entry has not been resolved up to now (assuming the corresponding
-     * nodestate is still valid).
-     *
-     * @param cne ChildNodeEntry to check.
-     * @return <code>true</code> if the given entry is valid.
-     */
-    private static boolean isValidChildNodeEntry(ChildNodeEntry cne) {
-        // shortcut.
-        if (cne == null) {
-            return false;
-        }
-        boolean isValid = false;
-        if (cne.isAvailable()) {
-            try {
-                isValid = cne.getNodeState().isValid();
-            } catch (ItemStateException e) {
-                // should not occur, if the cne is available.
-            }
-        } else {
-            // then it has never been accessed and must exist
-            // TODO: check if this assumption is correct
-            isValid = true;
-        }
-
-        return isValid;
-    }
-
-    /**
-     * Returns <code>true</code> if the given childproperty entry is not
-     * <code>null</code> and resolves to a PropertyState, that is valid or if the
-     * childproperty entry has not been resolved up to now (assuming the corresponding
-     * PropertyState is still valid).
-     *
-     * @param cpe ChildPropertyEntry to check.
-     * @return <code>true</code> if the given entry is valid.
-     */
-    private static boolean isValidChildPropertyEntry(ChildPropertyEntry cpe) {
-        if (cpe == null) {
-            return false;
-        }
-        boolean isValid = false;
-        if (cpe.isAvailable()) {
-            try {
-                isValid = cpe.getPropertyState().isValid();
-            } catch (ItemStateException e) {
-                // probably deleted in the meantime. should not occur.
-            }
-        } else {
-            // then it must be valid // TODO check if this assumption is correct.
-            isValid = true;
-        }
-        return isValid;
-    }
-
-    /**
-     *
-     * @param ps
-     * @return
-     * @throws RepositoryException
-     */
-    private static QName[] getMixinNames(PropertyState ps) throws RepositoryException {
-        assert QName.JCR_MIXINTYPES.equals(ps.getQName());
-
-        QValue[] values = ps.getValues();
-        QName[] newMixins = new QName[values.length];
-        for (int i = 0; i < values.length; i++) {
-            newMixins[i] = QName.valueOf(values[i].getString());
-        }
-        return newMixins;
-    }
-
-    private static boolean isUuidOrMixin(QName propName) {
-        return QName.JCR_UUID.equals(propName) || QName.JCR_MIXINTYPES.equals(propName);
-    }
-
-    private static void modifiedParent(NodeState parent, ItemState child, Map modParents) {
+    private static void modifiedParent(NodeState parent, ItemState childState, Map modParents) {
-        if (child != null && !child.isNode() && isUuidOrMixin(child.getQName())) {
-            l.add(child);
+        if (childState != null && !childState.isNode() && StateUtility.isUuidOrMixin(childState.getQName())) {
+            l.add(childState);
-    private static void adjustNodeState(NodeState parent, PropertyState[] props) {
-        NodeState overlayed = (parent.isWorkspaceState()) ? parent : (NodeState) parent.overlayedState;
-        NodeState sState = (parent.isWorkspaceState()) ? (NodeState) overlayed.getSessionState() : parent;
-
+    private static void adjustNodeState(NodeState parent, PropertyState[] props,
+                                        CacheBehaviour cacheBehaviour) {
+        NodeState overlayed = (NodeState) parent.overlayedState;
-                try {
-                    if (QName.JCR_UUID.equals(props[i].getQName())) {
-                        String uniqueID = (props[i].getStatus() == Status.REMOVED) ? null : props[i].getValue().getString();
-                        sState.setUniqueID(uniqueID);
-                        overlayed.setUniqueID(uniqueID);
-                    } else if (QName.JCR_MIXINTYPES.equals(props[i].getQName())) {
-                        QName[] mixins = (props[i].getStatus() == Status.REMOVED) ? QName.EMPTY_ARRAY : getMixinNames(props[i]);
-
-                        sState.mixinTypeNames = mixins;
-                        overlayed.mixinTypeNames = mixins;
-                    } // else: ignore.
-                } catch (RepositoryException e) {
-                    // should never occur.
-                    log.error("Internal error while updating node state.", e);
-                }
+                PropertyState propState = props[i];
+                if (QName.JCR_UUID.equals(propState.getQName())) {
+                    if (propState.getStatus() == Status.REMOVED) {
+                        parent.getNodeEntry().setUniqueID(null);
+                    } else {
+                        // retrieve uuid from persistent layer
+                        try {
+                            propState.reconnect(false);
+                        } catch (ItemStateException e) {
+                            // TODO: handle properly
+                            log.error("Internal error", e);
+                        }
+                    }
+                } else if (QName.JCR_MIXINTYPES.equals(propState.getQName())) {
+                    QName[] mixins = StateUtility.getMixinNames(propState);
+                    parent.setMixinTypeNames(mixins);
+                    overlayed.setMixinTypeNames(mixins);
+                } // else: ignore.
-            // make sure all other modifications on the overlayed state are
-            // reflected on the session-state.
-            sState.merge(overlayed, false);
-            // make sure, the session-state gets its status reset to Existing.
-            if (sState.getStatus() == Status.EXISTING_MODIFIED) {
-                sState.setStatus(Status.EXISTING);
+            // set parent status to 'existing'
+            parent.setStatus(Status.EXISTING);
+            if (cacheBehaviour != CacheBehaviour.OBSERVATION) {
+                // TODO: really necessary???
+                try {
+                    parent.reconnect(false);
+                } catch (ItemStateException e) {
+                    // TODO: handle properly
+                    log.error("Internal error", e);
+                }
-
-    private static boolean isMovedState(NodeState modState) {
-        if (modState.getParent() == null) {
-            // the root state cannot be moved
-            return false;
-        } else {
-            return modState.overlayedState.getParent() != modState.getParent().overlayedState;
-        }
-    }

JCR-1588: JSR 283 Access Control (work in progress)

- fixing TraversingNodeResolver and adding tests


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@656595 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.SessionImpl;
+import javax.jcr.Property;
+import javax.jcr.Value;
-        Node root = (Node) getSession().getItem(getSearchRoot(ntName));
-        return collectNode(nodeName, ntName, root.getNodes());
+        String sr = getSearchRoot(ntName);
+        // TODO: remove cast once 283 is released
+        SessionImpl sImpl = (SessionImpl) getSession();
+        if (sImpl.nodeExists(sr)) {
+            try {
+                Node root = sImpl.getNode(sr);
+                return collectNode(nodeName, ntName, root.getNodes());
+            } catch (PathNotFoundException e) {
+                // should not get here
+                log.warn("Error while retrieving node " + sr);
+            }
+        } // else: searchRoot does not exist yet -> omit the search
+        return null;
-        try {
-            Node root = (Node) getSession().getItem(getSearchRoot(ntName));
-            NodeIterator nodes = collectNodes(value, Collections.singleton(propertyName), ntName,
-                    root.getNodes(), true, 1);
-            if (nodes.hasNext()) {
-                return nodes.nextNode();
+        String sr = getSearchRoot(ntName);
+        // TODO: remove cast once 283 is released
+        SessionImpl sImpl = (SessionImpl) getSession();
+        if (sImpl.nodeExists(sr)) {
+            try {
+                Node root = sImpl.getNode(sr);
+                NodeIterator nodes = collectNodes(value,
+                        Collections.singleton(propertyName), ntName,
+                        root.getNodes(), true, 1);
+                if (nodes.hasNext()) {
+                    return nodes.nextNode();
+                }
+            } catch (PathNotFoundException e) {
+                // should not get here
+                log.warn("Error while retrieving node " + sr);
-        } catch (PathNotFoundException e) {
-            log.warn("Error while searching for node having a property " + propertyName + " with value " + value);
-        }
-
+        } // else: searchRoot does not exist yet -> omit the search
-
-        NodeImpl root = (NodeImpl) getSession().getItem(getSearchRoot(ntName));
-        return collectNodes(value, propertyNames, ntName, root.getNodes(), exact, maxSize);
+        String sr = getSearchRoot(ntName);
+        // TODO: remove cast once 283 is released
+        SessionImpl sImpl = (SessionImpl) getSession();
+        if (sImpl.nodeExists(sr)) {
+            try {
+                Node root = sImpl.getNode(sr);
+                return collectNodes(value, propertyNames, ntName, root.getNodes(), exact, maxSize);
+            } catch (PathNotFoundException e) {
+                // should not get here
+                log.warn("Error while retrieving node " + sr);
+            }
+        } // else: searchRoot does not exist yet -> omit the search
+        return NodeIteratorAdapter.EMPTY;
-
+    /**
+     *
+     * @param nodeName
+     * @param ntName
+     * @param nodes
+     * @return The first matching node or <code>null</code>.
+     */
-        while (nodes.hasNext()) {
+        Node match = null;
+        while (match == null && nodes.hasNext()) {
-                    return node;
-                }
-                if (node.hasNodes()) {
-                    return collectNode(nodeName, ntName, node.getNodes());
+                    match = node;
+                } else if (node.hasNodes()) {
+                    match = collectNode(nodeName, ntName, node.getNodes());
-        log.debug("Could not find a node matching name '" + nodeName + " and nodetype " + ntName);
-        return null;
+        return match;
-        Set matches = new HashSet();
-        collectNodes(value, props, ntName, nodes, matches, exact, maxSize);
-        return new NodeIteratorAdapter(matches);
+        Set matchSet = new HashSet();
+        collectNodes(value, props, ntName, nodes, matchSet, exact, maxSize);
+        return new NodeIteratorAdapter(matchSet);
-     * @param matches       Set of found matches to append results
+     * @param matchSet      Set of found matches to append results
-                              Set matches, boolean exact, long maxSize) {
+                              Set matchSet, boolean exact, long maxSize) {
-                    matches.add(node);
+                    matchSet.add(node);
-                            node.getNodes(), matches, exact, maxSize);
+                            node.getNodes(), matchSet, exact, maxSize);
-    private boolean matches(NodeImpl node, Name nodeTypeName,
+    private static boolean matches(NodeImpl node, Name nodeTypeName,
-                            String toMatch = node.getProperty(propertyName).getString();
-                            match = (exact) ?
-                                    toMatch.equals(value) :
-                                    toMatch.matches(".*"+value+".*");
+                            Property prop = node.getProperty(propertyName);
+                            if (prop.getDefinition().isMultiple()) {
+                                Value[] values = prop.getValues();
+                                for (int i = 0; i < values.length && !match; i++) {
+                                    match = matches(value, values[i].getString(), exact);
+                                }
+                            } else {
+                                match = matches(value, prop.getString(), exact);
+                            }
+
+    private static boolean matches(String value, String toMatch, boolean exact) {
+        return (exact) ? toMatch.equals(value) : toMatch.matches(".*"+value+".*");
+    }

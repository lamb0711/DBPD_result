- add commons-codec dependency to client project.xml
- add concurrent dependency to jcr2spi project.xml
- remove events again from operation methods on RepositoryService.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@472888 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.IdIterator;
+import org.apache.jackrabbit.spi.EventFilter;
+import java.util.Collections;
+    private final Map nodeTypeDefinitions = new HashMap();
+
-     * Execute a 'Workspace' operation that immediately needs to return events.
+     * Execute a 'Workspace' operation.
-     * @return
-    private EventBundle[] execute(DavMethod method, SessionInfo sessionInfo) throws RepositoryException {
-        // TODO: build specific subscrUri
-        // TODO: check if 'all event' subscription is ok
-        String subscrUri = uriResolver.getRootItemUri(sessionInfo.getWorkspaceName());
-        String subscrId = subscribe(subscrUri, S_INFO, null, sessionInfo, null);
+    private void execute(DavMethod method, SessionInfo sessionInfo) throws RepositoryException {
-            if (isLockMethod(method)) {
-                initMethod(method, sessionInfo, false);
-            } else {
-                initMethod(method, sessionInfo, true);
-            }
+            initMethod(method, sessionInfo, !isLockMethod(method));
+
-            // TODO: poll until we see our change
-            EventBundle[] events = null;
-            int retries = 10;
-            while ((events == null || events.length == 0) && retries-- > 0) {
-                events = poll(subscrUri, subscrId, sessionInfo);
-            }
-            return events;
-            unsubscribe(subscrUri, subscrId, sessionInfo);
-    public EventBundle[] submit(Batch batch) throws RepositoryException {
+    public void submit(Batch batch) throws RepositoryException {
-            return new EventBundle[]{EventBundleImpl.EMPTY};
+            return;
-            EventBundle[] events;
-                events = batchImpl.end(client, success);
+                batchImpl.end(client, success);
-            return events;
-    public EventBundle[] importXml(SessionInfo sessionInfo, NodeId parentId, InputStream xmlStream, int uuidBehaviour) throws ItemExistsException, PathNotFoundException, VersionException, ConstraintViolationException, LockException, AccessDeniedException, UnsupportedRepositoryOperationException, RepositoryException {
+    public void importXml(SessionInfo sessionInfo, NodeId parentId, InputStream xmlStream, int uuidBehaviour) throws ItemExistsException, PathNotFoundException, VersionException, ConstraintViolationException, LockException, AccessDeniedException, UnsupportedRepositoryOperationException, RepositoryException {
-
-        return execute(method, sessionInfo);
+        execute(method, sessionInfo);
-    public EventBundle[] move(SessionInfo sessionInfo, NodeId srcNodeId, NodeId destParentNodeId, QName destName) throws ItemExistsException, PathNotFoundException, VersionException, ConstraintViolationException, LockException, AccessDeniedException, UnsupportedRepositoryOperationException, RepositoryException {
+    public void move(SessionInfo sessionInfo, NodeId srcNodeId, NodeId destParentNodeId, QName destName) throws ItemExistsException, PathNotFoundException, VersionException, ConstraintViolationException, LockException, AccessDeniedException, UnsupportedRepositoryOperationException, RepositoryException {
-        return execute(method, sessionInfo);
+        execute(method, sessionInfo);
-    public EventBundle[] copy(SessionInfo sessionInfo, String srcWorkspaceName, NodeId srcNodeId, NodeId destParentNodeId, QName destName) throws NoSuchWorkspaceException, ConstraintViolationException, VersionException, AccessDeniedException, PathNotFoundException, ItemExistsException, LockException, UnsupportedRepositoryOperationException, RepositoryException {
+    public void copy(SessionInfo sessionInfo, String srcWorkspaceName, NodeId srcNodeId, NodeId destParentNodeId, QName destName) throws NoSuchWorkspaceException, ConstraintViolationException, VersionException, AccessDeniedException, PathNotFoundException, ItemExistsException, LockException, UnsupportedRepositoryOperationException, RepositoryException {
-        return execute(method, sessionInfo);
+        execute(method, sessionInfo);
-    public EventBundle[] update(SessionInfo sessionInfo, NodeId nodeId, String srcWorkspaceName) throws NoSuchWorkspaceException, AccessDeniedException, LockException, InvalidItemStateException, RepositoryException {
+    public void update(SessionInfo sessionInfo, NodeId nodeId, String srcWorkspaceName) throws NoSuchWorkspaceException, AccessDeniedException, LockException, InvalidItemStateException, RepositoryException {
-        return update(uri, new String[] {workspUri}, UpdateInfo.UPDATE_BY_WORKSPACE, false, sessionInfo);
+        update(uri, new String[] {workspUri}, UpdateInfo.UPDATE_BY_WORKSPACE, false, sessionInfo);
-    public EventBundle[] clone(SessionInfo sessionInfo, String srcWorkspaceName, NodeId srcNodeId, NodeId destParentNodeId, QName destName, boolean removeExisting) throws NoSuchWorkspaceException, ConstraintViolationException, VersionException, AccessDeniedException, PathNotFoundException, ItemExistsException, LockException, UnsupportedRepositoryOperationException, RepositoryException {
+    public void clone(SessionInfo sessionInfo, String srcWorkspaceName, NodeId srcNodeId, NodeId destParentNodeId, QName destName, boolean removeExisting) throws NoSuchWorkspaceException, ConstraintViolationException, VersionException, AccessDeniedException, PathNotFoundException, ItemExistsException, LockException, UnsupportedRepositoryOperationException, RepositoryException {
-    public EventBundle[] lock(SessionInfo sessionInfo, NodeId nodeId, boolean deep, boolean sessionScoped) throws UnsupportedRepositoryOperationException, LockException, AccessDeniedException, InvalidItemStateException, RepositoryException {
+    public void lock(SessionInfo sessionInfo, NodeId nodeId, boolean deep, boolean sessionScoped) throws UnsupportedRepositoryOperationException, LockException, AccessDeniedException, InvalidItemStateException, RepositoryException {
-            EventBundle[] events = execute(method, sessionInfo);
+            execute(method, sessionInfo);
-            return events;
-
-    public EventBundle[] refreshLock(SessionInfo sessionInfo, NodeId nodeId) throws LockException, RepositoryException {
+    public void refreshLock(SessionInfo sessionInfo, NodeId nodeId) throws LockException, RepositoryException {
-        return execute(method, sessionInfo);
+        execute(method, sessionInfo);
-    public EventBundle[] unlock(SessionInfo sessionInfo, NodeId nodeId) throws UnsupportedRepositoryOperationException, LockException, AccessDeniedException, InvalidItemStateException, RepositoryException {
+    public void unlock(SessionInfo sessionInfo, NodeId nodeId) throws UnsupportedRepositoryOperationException, LockException, AccessDeniedException, InvalidItemStateException, RepositoryException {
-        EventBundle[] events = execute(method, sessionInfo);
+        execute(method, sessionInfo);
-        return events;
-    public EventBundle[] checkin(SessionInfo sessionInfo, NodeId nodeId) throws VersionException, UnsupportedRepositoryOperationException, InvalidItemStateException, LockException, RepositoryException {
+    public void checkin(SessionInfo sessionInfo, NodeId nodeId) throws VersionException, UnsupportedRepositoryOperationException, InvalidItemStateException, LockException, RepositoryException {
-
-        return execute(method, sessionInfo);
+        execute(method, sessionInfo);
-    public EventBundle[] checkout(SessionInfo sessionInfo, NodeId nodeId) throws UnsupportedRepositoryOperationException, LockException, RepositoryException {
+    public void checkout(SessionInfo sessionInfo, NodeId nodeId) throws UnsupportedRepositoryOperationException, LockException, RepositoryException {
-
-        return execute(method, sessionInfo);
+        execute(method, sessionInfo);
-    public EventBundle[] restore(SessionInfo sessionInfo, NodeId nodeId, NodeId versionId, boolean removeExisting) throws VersionException, PathNotFoundException, ItemExistsException, UnsupportedRepositoryOperationException, LockException, InvalidItemStateException, RepositoryException {
+    public void restore(SessionInfo sessionInfo, NodeId nodeId, NodeId versionId, boolean removeExisting) throws VersionException, PathNotFoundException, ItemExistsException, UnsupportedRepositoryOperationException, LockException, InvalidItemStateException, RepositoryException {
-        return update(uri, new String[] {vUri}, UpdateInfo.UPDATE_BY_VERSION, removeExisting, sessionInfo);
+        update(uri, new String[] {vUri}, UpdateInfo.UPDATE_BY_VERSION, removeExisting, sessionInfo);
-    public EventBundle[] restore(SessionInfo sessionInfo, NodeId[] versionIds, boolean removeExisting) throws ItemExistsException, UnsupportedRepositoryOperationException, VersionException, LockException, InvalidItemStateException, RepositoryException {
+    public void restore(SessionInfo sessionInfo, NodeId[] versionIds, boolean removeExisting) throws ItemExistsException, UnsupportedRepositoryOperationException, VersionException, LockException, InvalidItemStateException, RepositoryException {
-        return update(uri, vUris, UpdateInfo.UPDATE_BY_VERSION, removeExisting, sessionInfo);
+        update(uri, vUris, UpdateInfo.UPDATE_BY_VERSION, removeExisting, sessionInfo);
-    private EventBundle[] update(String uri, String[] updateSource, int updateType, boolean removeExisting, SessionInfo sessionInfo) throws RepositoryException {
+    private void update(String uri, String[] updateSource, int updateType, boolean removeExisting, SessionInfo sessionInfo) throws RepositoryException {
-            return execute(method, sessionInfo);
+            execute(method, sessionInfo);
-    public EventBundle[] merge(SessionInfo sessionInfo, NodeId nodeId, String srcWorkspaceName, boolean bestEffort) throws NoSuchWorkspaceException, AccessDeniedException, MergeException, LockException, InvalidItemStateException, RepositoryException {
+    public IdIterator merge(SessionInfo sessionInfo, NodeId nodeId, String srcWorkspaceName, boolean bestEffort) throws NoSuchWorkspaceException, AccessDeniedException, MergeException, LockException, InvalidItemStateException, RepositoryException {
-            // TODO: need to evaluate response?
-            return execute(method, sessionInfo);
+            execute(method, sessionInfo);
+            // TODO: need to evaluate response and return merge failed node ids
+            return new IteratorHelper(Collections.EMPTY_LIST);
-    public EventBundle[] resolveMergeConflict(SessionInfo sessionInfo, NodeId nodeId, NodeId[] mergeFailedIds, NodeId[] predecessorIds) throws VersionException, InvalidItemStateException, UnsupportedRepositoryOperationException, RepositoryException {
+    public void resolveMergeConflict(SessionInfo sessionInfo, NodeId nodeId, NodeId[] mergeFailedIds, NodeId[] predecessorIds) throws VersionException, InvalidItemStateException, UnsupportedRepositoryOperationException, RepositoryException {
-            // TODO: ev. evaluate response
-            return execute(method, sessionInfo);
+            // TODO: ev. evaluate response ??? change return type of RepositoryService.resolveMergeConflict()?
+            execute(method, sessionInfo);
-    public EventBundle[] addVersionLabel(SessionInfo sessionInfo, NodeId versionHistoryId, NodeId versionId, QName label, boolean moveLabel) throws VersionException, RepositoryException {
+    public void addVersionLabel(SessionInfo sessionInfo, NodeId versionHistoryId, NodeId versionId, QName label, boolean moveLabel) throws VersionException, RepositoryException {
-            return execute(method, sessionInfo);
+            execute(method, sessionInfo);
-    public EventBundle[] removeVersionLabel(SessionInfo sessionInfo, NodeId versionHistoryId, NodeId versionId, QName label) throws VersionException, RepositoryException {
+    public void removeVersionLabel(SessionInfo sessionInfo, NodeId versionHistoryId, NodeId versionId, QName label) throws VersionException, RepositoryException {
-            return execute(method, sessionInfo);
+            execute(method, sessionInfo);
-     * @see RepositoryService#getEvents(SessionInfo, long)
+     * @see RepositoryService#createEventFilter(int, org.apache.jackrabbit.name.Path, boolean, String[], org.apache.jackrabbit.name.QName[], boolean)
-    public EventBundle[] getEvents(SessionInfo sessionInfo, long timeout)
+    public EventFilter createEventFilter(int eventTypes,
+                                         Path absPath,
+                                         boolean isDeep,
+                                         String[] uuids,
+                                         QName[] nodeTypeNames,
+                                         boolean noLocal)
+            throws UnsupportedRepositoryOperationException {
+        // resolve node type names
+        // todo what if new node types become available while event filter is still in use?
+        Set resolvedTypeNames = null;
+        if (nodeTypeNames != null) {
+            resolvedTypeNames = new HashSet();
+            synchronized (nodeTypeDefinitions) {
+                for (int i = 0; i < nodeTypeNames.length; i++) {
+                    resolveNodeType(resolvedTypeNames, nodeTypeNames[i]);
+                }
+            }
+        }
+        return new EventFilterImpl(eventTypes, absPath, isDeep, uuids,
+                resolvedTypeNames, noLocal);
+    }
+
+    /**
+     * @see RepositoryService#getEvents(SessionInfo, long, EventFilter[])
+     */
+    public EventBundle[] getEvents(SessionInfo sessionInfo, long timeout, EventFilter[] filters)
+        // todo timeout is not respected
+    private void resolveNodeType(Set resolved, QName ntName) {
+        if (!resolved.add(ntName)) {
+            return;
+        }
+        QNodeTypeDefinition def = (QNodeTypeDefinition) nodeTypeDefinitions.get(ntName);
+        if (def != null) {
+            QName[] supertypes = def.getSupertypes();
+            for (int i = 0; i < supertypes.length; i++) {
+                resolveNodeType(resolved, supertypes[i]);
+            }
+        }
+    }
+
+            // refresh node type definitions map
+            synchronized (nodeTypeDefinitions) {
+                nodeTypeDefinitions.clear();
+                for (Iterator defIt = ntDefs.iterator(); it.hasNext(); ) {
+                    QNodeTypeDefinition def = (QNodeTypeDefinition) defIt.next();
+                    nodeTypeDefinitions.put(def.getQName(), def);
+                }
+            }
-        private String subscriptionId;
-                // register subscription
-                String subscrUri = (targetId.denotesNode() ? uri : getItemUri(((PropertyId) targetId).getParentId(), sessionInfo));
-                subscriptionId = subscribe(subscrUri, S_INFO, null, sessionInfo, batchId);
-        private EventBundle[] end(HttpClient client, boolean commit) throws RepositoryException {
+        private void end(HttpClient client, boolean commit) throws RepositoryException {
-            String subscrUri = (targetId.denotesNode() ? uri : getItemUri(((PropertyId) targetId).getParentId(), sessionInfo));
-
-                // retrieve events
-                // TODO: until we see our change!
-                EventBundle[] events = null;
-                int retries = 10;
-                while ((events == null || events.length == 0) && retries-- > 0) {
-                    events = poll(subscrUri, subscriptionId, sessionInfo);
-                }
-                return events;
-                // unsubscribe
-                unsubscribe(subscrUri, subscriptionId, sessionInfo);

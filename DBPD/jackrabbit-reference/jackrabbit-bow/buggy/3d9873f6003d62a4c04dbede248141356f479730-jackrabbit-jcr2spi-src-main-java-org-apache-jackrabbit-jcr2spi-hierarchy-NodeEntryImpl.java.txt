JCR-2498: Implement caching mechanism for ItemInfo batches

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@915810 13f79535-47bb-0310-9956-ffa450edef68

-     * Information regarding the invalidation status of the underlying {@link ItemState}
-     * of this entry. The semantics depend on the {@link EntryFactory.InvalidationStrategy}.
-     */
-    private long invalidationStatus;
-
-    /**
-    @Override
-    public void invalidate(boolean recursive) {
-        getInvalidationStrategy().invalidate(this, recursive);
-    }
-
-    public void calculateStatus() {
-        getInvalidationStrategy().applyPending(this);
-    }
-
-     * attic back into th properties map. If this HierarchyEntry has been
+     * attic back into the properties map. If this HierarchyEntry has been
-       NodeEntryImpl entry = (NodeEntryImpl) parent.childNodeEntries.remove(this);
+       NodeEntry entry = parent.childNodeEntries.remove(this);
-                childNodeAttic.remove((NodeEntryImpl) childEntry);
+                childNodeAttic.remove((NodeEntry) childEntry);
-    private EntryFactory.InvalidationStrategy getInvalidationStrategy() {
-        return factory.getInvalidationStrategy();
-    }
-
-    /**
-     * Invalidates the underlying {@link ItemState}. If <code>recursive</code> is
-     * true also invalidates the underlying item states of all child entries.
-     * @param recursive
-     */
-    private void invalidateInternal(boolean recursive) {
+    @Override
+    protected void invalidateInternal(boolean recursive) {
-        super.invalidate(true);
+        super.invalidateInternal(true);
-        private final NodeEntryImpl oldSuccessor;
-        private final NodeEntryImpl oldPredecessor;
+        private final NodeEntry oldSuccessor;
+        private final NodeEntry oldPredecessor;
-            this.oldSuccessor = (NodeEntryImpl) ((ChildNodeEntriesImpl) parent.childNodeEntries).getNext(NodeEntryImpl.this);
-            this.oldPredecessor = (NodeEntryImpl) ((ChildNodeEntriesImpl) parent.childNodeEntries).getPrevious(NodeEntryImpl.this);
+            this.oldSuccessor = ((ChildNodeEntriesImpl) parent.childNodeEntries).getNext(NodeEntryImpl.this);
+            this.oldPredecessor = ((ChildNodeEntriesImpl) parent.childNodeEntries).getPrevious(NodeEntryImpl.this);
-                NodeEntryImpl ne = NodeEntryImpl.this;
+                NodeEntry ne = NodeEntryImpl.this;
-    // ----------------------------------------------< InvalidationStrategy >---
-    /**
-     * An implementation of <code>InvalidationStrategy</code> which lazily invalidates
-     * the underlying {@link ItemState}s.
-     */
-    static class LazyInvalidation implements EntryFactory.InvalidationStrategy {
-
-        /**
-         * Marker for entries with a pending recursive invalidation.
-         */
-        private static long INVALIDATION_PENDING = -1;
-
-        /**
-         * Time stamp of the last time a recursive invalidation occurred.
-         */
-        private long lastInvalidation;
-
-        /**
-         * A recursive invalidation is being processed if <code>true</code>.
-         * This flag is for preventing re-entrance.
-         */
-        private boolean invalidating;
-
-        /**
-         * Actual time stamp
-         */
-        private long timeStamp;
-
-        /**
-         * @return  time stamp used to mark entries
-         */
-        private long getTimeStamp() {
-            return timeStamp++;
-        }
-
-        /**
-         * Records a pending recursive {@link ItemState#invalidate() invalidation} for
-         * <code>entry</code> if <code>recursive</code> is <code>true</code>. Otherwise
-         * invalidates the entry right away.
-         * {@inheritDoc}
-         */
-        public void invalidate(NodeEntry entry, boolean recursive) {
-            if (recursive) {
-                ((NodeEntryImpl)entry).invalidationStatus = INVALIDATION_PENDING;
-                if (!invalidating) {
-                    lastInvalidation = getTimeStamp();
-                }
-            } else {
-                ((NodeEntryImpl)entry).invalidateInternal(false);
-            }
-        }
-
-        /**
-         * Checks whether <code>entry</code> itself has a invalidation pending.
-         * If so, the <code>entry</code> is invalidated. Otherwise check
-         * whether an invalidation occurred after the entry has last been
-         * invalidated. If so, search the path to the root for an originator of
-         * the pending invalidation.
-         * If such an originator is found, invalidate each entry on the path.
-         * Otherwise this method does nothing.
-         * {@inheritDoc}
-         */
-        public void applyPending(NodeEntry entry) {
-            if (!invalidating) {
-                invalidating = true;
-                try {
-                    NodeEntryImpl ne = (NodeEntryImpl) entry;
-                    if (ne.invalidationStatus == INVALIDATION_PENDING) {
-                        ne.invalidateInternal(true);
-                        ne.invalidationStatus = getTimeStamp();
-                    } else if (ne.invalidationStatus <= lastInvalidation) {
-                        resolvePendingInvalidation(ne);
-                    }
-                } finally {
-                    invalidating = false;
-                }
-            }
-        }
-
-        /**
-         * Search the path to the root for an originator of a pending invalidation of
-         * this <code>entry</code>. If such an originator is found, invalidate each
-         * entry on the path. Otherwise do nothing.
-         *
-         * @param entry
-         */
-        private void resolvePendingInvalidation(NodeEntryImpl entry) {
-            if (entry != null) {
-
-                // First recursively travel up to the first parent node
-                // which has invalidation pending or to the root node if
-                // no such node exists.
-                if (entry.invalidationStatus != INVALIDATION_PENDING) {
-                    resolvePendingInvalidation(entry.parent);
-                }
-
-                // Then travel the path backwards invalidating as required
-                if (entry.invalidationStatus == INVALIDATION_PENDING) {
-                    entry.invalidateInternal(true);
-                }
-                entry.invalidationStatus = getTimeStamp();
-            }
-        }
-    }
-
-    /**
-     * An implementation of <code>InvalidationStrategy</code> which eagerly invalidates
-     * the underlying {@link ItemState}s.
-     */
-    static class EagerInvalidation implements EntryFactory.InvalidationStrategy {
-
-        /**
-         * Calls {@link ItemState#invalidate()} for the underlying item state of this
-         * <code>entry</code> and - if <code>recursive</code> is <code>true</code> -
-         * recursively for all item states of all child entries
-         * {@inheritDoc}
-         */
-        public void invalidate(NodeEntry entry, boolean recursive) {
-            ((NodeEntryImpl) entry).invalidateInternal(recursive);
-        }
-
-        /**
-         * Does nothing since invalidation has occurred already.
-         * {@inheritDoc}
-         */
-        public void applyPending(NodeEntry entry) {
-            // Empty
-        }
-    }

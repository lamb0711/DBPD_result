work in progress

- event processing upon saving transient modifications
- extend ItemState.refresh: add Event and ev. ChangeLog as param
- EventImpl: parentId missing
- remove ItemStateListener
- all state changes are covered by ItemStateLifeCycleListener.statusChanged(ItemState, int)


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@453514 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.Event;
-public abstract class ItemState implements ItemStateListener {
+public abstract class ItemState implements ItemStateLifeCycleListener {
-     * a new state was deleted and is now 'removed'
+     * a state is permanently modified either by saving transient changes or
+     * by wsp operations or be external modification
+     * TODO: improve. status only temporarily used to indicate to a SessionISM-state to pull changes
-    public static final int STATUS_REMOVED = 7;
+    public static final int STATUS_MODIFIED = 7;
+
+    /**
+     * a new state was deleted and is now 'removed'
+     * or an existing item has been removed by a workspace operation or
+     * by an external modification.
+     */
+    public static final int STATUS_REMOVED = 8;
-     * Copy state information from another state into this state
-     * 
-     * @param state source state information
+     * Copy state information from overlayed state to this state
-    abstract void copyFrom(ItemState state);
-
-    /**
-     * Pull state information from overlayed state.
-     */
-    void pull() {
-        if (overlayedState != null) {
-            copyFrom(overlayedState);
-        }
-    }
-
-    /**
-     * Push state information into overlayed state.
-     */
-    void push() {
-        if (overlayedState != null) {
-            overlayedState.copyFrom(this);
-        }
-    }
+    protected abstract void pull();
-    /**
-     * Reconnect this state to the overlayed state that it has been
-     * disconnected from earlier.
-     */
-    protected void reconnect() {
-        if (this.overlayedState == null) {
-            throw new IllegalStateException("Item state cannot be reconnected because there's no underlying state to reconnect to: " + this);
-        }
-        this.overlayedState.addListener(this);
-    }
-    /**
-     * Disconnect this state from the underlying overlayed state.
-     */
-    protected void disconnect() {
-        if (overlayedState != null) {
-            // de-register listener on overlayed state...
-            overlayedState.removeListener(this);
-            overlayedState = null;
-        }
-    }
-
-    /**
-     * Refreshes this item state
-     */
-    protected void refresh() {
-        // TODO: how is this done? where is the new state retrieved from???
-        // TODO: pass in as argument?
-    }
-
-    /**
-     * Notify the listeners that the persistent state this object is
-     * representing has been created.
-     */
-    protected void notifyStateCreated() {
-        // copy listeners to array to avoid ConcurrentModificationException
-        ItemStateListener[] la;
-        synchronized (listeners) {
-            la = (ItemStateListener[]) listeners.toArray(new ItemStateListener[listeners.size()]);
-        }
-        for (int i = 0; i < la.length; i++) {
-            if (la[i] != null) {
-                la[i].stateCreated(this);
-            }
-        }
-    }
-
-    /**
-     * Notify the listeners that the persistent state this object is
-     * representing has been updated.
-     */
-    protected void notifyStateUpdated() {
-        // copy listeners to array to avoid ConcurrentModificationException
-        ItemStateListener[] la;
-        synchronized (listeners) {
-            la = (ItemStateListener[]) listeners.toArray(new ItemStateListener[listeners.size()]);
-        }
-        for (int i = 0; i < la.length; i++) {
-            if (la[i] != null) {
-                la[i].stateModified(this);
-            }
-        }
-    }
-
-    /**
-     * Notify the listeners that the persistent state this object is
-     * representing has been destroyed.
-     */
-    protected void notifyStateDestroyed() {
-        // copy listeners to array to avoid ConcurrentModificationException
-        ItemStateListener[] la;
-        synchronized (listeners) {
-            la = (ItemStateListener[]) listeners.toArray(new ItemStateListener[listeners.size()]);
-        }
-        for (int i = 0; i < la.length; i++) {
-            if (la[i] != null) {
-                la[i].stateDestroyed(this);
-            }
-        }
-    }
+    protected abstract void refresh(Event event, ChangeLog changeLog);
-        ItemStateListener[] la;
+        ItemStateLifeCycleListener[] la;
-            la = (ItemStateListener[]) listeners.toArray(new ItemStateListener[listeners.size()]);
+            la = (ItemStateLifeCycleListener[]) listeners.toArray(new ItemStateLifeCycleListener[listeners.size()]);
+        // only transient states can be marked-modified
+        if (getStatus() != STATUS_NEW && overlayedState == null) {
+            throw new IllegalStateException("persisted cannot be called on workspace state");
+        }
+
-                // should actually get here because item should check before
-                // it modifies an item state. do nothing because item state
-                // is stale anyway.
-                break;
+                // should actually not get here because item should check before
+                // it modifies an item state.
+                throw new IllegalStateException("Cannot mark stale state modified.");
+
-
+            case STATUS_MODIFIED:
-     * Add an <code>ItemStateListener</code>
+     * Add an <code>ItemStateLifeCycleListener</code>
-    public void addListener(ItemStateListener listener) {
+    public void addListener(ItemStateLifeCycleListener listener) {
-     * Remove an <code>ItemStateListener</code>
+     * Remove an <code>ItemStateLifeCycleListener</code>
-    public void removeListener(ItemStateListener listener) {
+    public void removeListener(ItemStateLifeCycleListener listener) {
-    //--------------------------------------------------< ItemStateListener >---
+    //-----------------------------------------< ItemStateLifeCycleListener >---
-     * {@inheritDoc}
+     *
+     * @param state
+     * @param previousStatus
-    public void stateCreated(ItemState created) {
-        // underlying state has been permanently created
-        pull();
-        setStatus(STATUS_EXISTING);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void stateDestroyed(ItemState destroyed) {
-        // underlying state has been permanently destroyed
-        if (isTransient()) {
-            setStatus(STATUS_STALE_DESTROYED);
-        } else {
-            setStatus(STATUS_REMOVED);
-            notifyStateDestroyed();
+    public void statusChanged(ItemState state, int previousStatus) {
+        // workspace-states never are listening to another state
+        if (getStatus() != STATUS_NEW && overlayedState == null) {
+            throw new IllegalStateException("statusChanged cannot be called on workspace state");
-    }
-    /**
-     * {@inheritDoc}
-     */
-    public void stateModified(ItemState modified) {
-        // underlying state has been modified
-        if (isTransient()) {
-            setStatus(STATUS_STALE_MODIFIED);
-        } else {
-            synchronized (this) {
-                // this instance represents existing state, update it
-                pull();
-                notifyStateUpdated();
-            }
+        switch (state.getStatus()) {
+            case STATUS_EXISTING:
+                // nothing to do
+                break;
+            case STATUS_MODIFIED:
+                if (previousStatus == STATUS_EXISTING) {
+                    // change back
+                    state.status = STATUS_EXISTING;
+                    // underlying state has been modified
+                    if (isTransient()) {
+                        setStatus(STATUS_STALE_MODIFIED);
+                    } else {
+                        synchronized (this) {
+                            // this instance represents existing state, update it
+                            pull();
+                            setStatus(STATUS_EXISTING);
+                        }
+                    }
+                } else {
+                    // ILLEGAL
+                    throw new IllegalArgumentException();
+                }
+                break;
+            case STATUS_REMOVED:
+                if (isTransient()) {
+                    setStatus(STATUS_STALE_DESTROYED);
+                } else {
+                    setStatus(STATUS_REMOVED);
+                }
+                break;
+            case STATUS_STALE_MODIFIED:
+            case STATUS_STALE_DESTROYED:
+            case STATUS_EXISTING_REMOVED:
+            case STATUS_EXISTING_MODIFIED:
+            case STATUS_NEW:
+                log.error("Workspace state cannot have its state changed to " + state.getStatus());
+                break;

JCR-1154 A database data store implementation

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@597027 13f79535-47bb-0310-9956-ffa450edef68

-    private static final int TRIALS = 20;
+    public static final int TRIALS = 20;
-    public Statement executeStmt(String sql, Object[] params) throws SQLException, RepositoryException {
+    public PreparedStatement executeStmt(String sql, Object[] params) throws SQLException, RepositoryException {
-    public synchronized Statement executeStmt(String sql, Object[] params, boolean returnGeneratedKeys, int maxRows) throws SQLException, RepositoryException {
+    public synchronized PreparedStatement executeStmt(String sql, Object[] params, boolean returnGeneratedKeys, int maxRows) throws SQLException, RepositoryException {
-    private Statement executeStmtInternal(String sql, Object[] params, boolean returnGeneratedKeys, int maxRows) throws SQLException, RepositoryException {
+    private PreparedStatement executeStmtInternal(String sql, Object[] params, boolean returnGeneratedKeys, int maxRows) throws SQLException, RepositoryException {
-            Class driverClass = Class.forName(driver);
-            // Workaround for Apache Derby:
-            // The JDBC specification recommends the Class.ForName method without the .newInstance() method call, 
-            // but adding the newInstance() guarantees that Derby will be booted on any Java Virtual Machine.
-            driverClass.newInstance();
+            if (driver != null && driver.length() > 0) {
+                Class driverClass = Class.forName(driver);
+                // Workaround for Apache Derby:
+                // The JDBC specification recommends the Class.ForName method without the .newInstance() method call, 
+                // but adding the newInstance() guarantees that Derby will be booted on any Java Virtual Machine.
+                driverClass.newInstance();
+            }
-    private Statement executeStmtInternal(Object[] params, PreparedStatement stmt) throws SQLException {
-        for (int i = 0; i < params.length; i++) {
-            if (params[i] instanceof StreamWrapper) {
-                StreamWrapper wrapper = (StreamWrapper) params[i];
+    private PreparedStatement executeStmtInternal(Object[] params, PreparedStatement stmt) throws SQLException {
+        for (int i = 0; params != null && i < params.length; i++) {
+            Object p = params[i];
+            if (p instanceof StreamWrapper) {
+                StreamWrapper wrapper = (StreamWrapper) p;
+            } else if (p instanceof InputStream) {
+                InputStream stream = (InputStream) p;
+                stmt.setBinaryStream(i + 1, stream, -1);
-                stmt.setObject(i + 1, params[i]);
+                stmt.setObject(i + 1, p);
-         * savely be passed as a parameter to the <code>executeStmt</code>
+         * safely be passed as a parameter to the <code>executeStmt</code>
+
+    public void closeSilently(ResultSet rs) {
+        if (rs != null) {
+            try {
+                rs.close();
+            } catch (SQLException e) {
+                // ignore
+            }
+        }
+    }

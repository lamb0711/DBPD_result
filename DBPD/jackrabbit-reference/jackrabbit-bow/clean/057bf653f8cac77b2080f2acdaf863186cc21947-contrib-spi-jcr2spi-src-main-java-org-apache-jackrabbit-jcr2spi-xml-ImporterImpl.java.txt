work in progress

- remove NodeState.getPropertyId and replace by getPropertyState
- use ChildNodeEntry.getNodeState
- consequently remove utility methods getNodeState, getPropertyState on
  ItemStateValidator, that converted ItemStateExceptions to RepositoryExc.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@429269 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.state.ItemStateException;
+import org.apache.jackrabbit.spi.ItemId;
-
-        // perform preliminary checks
-        importTarget = validator.getNodeState(parentPath);
-        // DIFF JR: remove check for overall writability on target-node.
-
-        refTracker = new ReferenceChangeTracker();
-        parents = new Stack();
-        parents.push(importTarget);
+        // perform preliminary checks
+        try {
+            ItemId id = hierMgr.getItemId(parentPath);
+            if (!id.denotesNode()) {
+                throw new PathNotFoundException(hierMgr.safeGetJCRPath(parentPath));
+            }
+            importTarget = validator.getNodeState((NodeId) id);
+
+            refTracker = new ReferenceChangeTracker();
+            parents = new Stack();
+            parents.push(importTarget);
+        } catch (ItemNotFoundException infe) {
+            throw new PathNotFoundException(hierMgr.safeGetJCRPath(parentPath));
+        }
+
+
+        // DIFF JR: remove check for overall writability on target-node.
+
+
-               NodeState existing = validator.getNodeState(entry.getId());
+               NodeState existing = null;
+               try {
+                   existing = entry.getNodeState();
+               } catch (ItemStateException e) {
+                   // should not occur. existance has been checked before
+                   throw new RepositoryException(e);
+               }
-            PropertyState conflicting = validator.getPropertyState(parent.getNodeId(), nodeInfo.getName());
-            if (conflicting.getStatus() == ItemState.STATUS_NEW) {
-                // assume this property has been imported as well;
-                // rename conflicting property
-                // @todo use better reversible escaping scheme to create unique name
-                QName newName = new QName(nodeInfo.getName().getNamespaceURI(), nodeInfo.getName().getLocalName() + "_");
-                if (parent.hasPropertyName(newName)) {
-                    newName = new QName(newName.getNamespaceURI(), newName.getLocalName() + "_");
-                }
-                // since name changes, need to find new applicable definition
-                QPropertyDefinition propDef;
-                if (conflicting.getValues().length == 1) {
-                    // could be single- or multi-valued (n == 1)
-                    try {
-                        // try single-valued
-                        propDef = validator.getApplicablePropertyDefinition(newName, conflicting.getType(), false, parent);
-                    } catch (ConstraintViolationException cve) {
-                        // try multi-valued
+            try {
+                PropertyState conflicting = parent.getPropertyState(nodeInfo.getName());
+                if (conflicting.getStatus() == ItemState.STATUS_NEW) {
+                    // assume this property has been imported as well;
+                    // rename conflicting property
+                    // @todo use better reversible escaping scheme to create unique name
+                    QName newName = new QName(nodeInfo.getName().getNamespaceURI(), nodeInfo.getName().getLocalName() + "_");
+                    if (parent.hasPropertyName(newName)) {
+                        newName = new QName(newName.getNamespaceURI(), newName.getLocalName() + "_");
+                    }
+                    // since name changes, need to find new applicable definition
+                    QPropertyDefinition propDef;
+                    if (conflicting.getValues().length == 1) {
+                        // could be single- or multi-valued (n == 1)
+                        try {
+                            // try single-valued
+                            propDef = validator.getApplicablePropertyDefinition(newName, conflicting.getType(), false, parent);
+                        } catch (ConstraintViolationException cve) {
+                            // try multi-valued
+                            propDef = validator.getApplicablePropertyDefinition(newName, conflicting.getType(), true, parent);
+                        }
+                    } else {
+                        // can only be multi-valued (n == 0 || n > 1)
-                } else {
-                    // can only be multi-valued (n == 0 || n > 1)
-                    propDef = validator.getApplicablePropertyDefinition(newName, conflicting.getType(), true, parent);
-                }
-                PropertyId newPId = idFactory.createPropertyId(parent.getNodeId(), newName);
-                Operation ap = AddProperty.create(newPId, conflicting.getType(), propDef, conflicting.getValues());
-                stateMgr.execute(ap);
-                Operation rm = Remove.create(conflicting);
-                stateMgr.execute(rm);
+                    PropertyId newPId = idFactory.createPropertyId(parent.getNodeId(), newName);
+                    Operation ap = AddProperty.create(newPId, conflicting.getType(), propDef, conflicting.getValues());
+                    stateMgr.execute(ap);
+                    Operation rm = Remove.create(conflicting);
+                    stateMgr.execute(rm);
+                }
+            } catch (ItemStateException e) {
+                // should not occur. existance has been checked before
+                throw new RepositoryException(e);
-            NodeId childId;
-            List cne = parent.getChildNodeEntries(nodeInfo.getName());
-            if (def.allowsSameNameSiblings()) {
-                // TODO: find proper solution. problem with same-name-siblings
-                childId = ((ChildNodeEntry)cne.get(cne.size()-1)).getId();
-            } else {
-                childId = ((ChildNodeEntry)cne.get(0)).getId();
+            NodeState childState;
+            try {
+                List cne = parent.getChildNodeEntries(nodeInfo.getName());
+                if (def.allowsSameNameSiblings()) {
+                    // TODO: find proper solution. problem with same-name-siblings
+                    childState = ((ChildNodeEntry)cne.get(cne.size()-1)).getNodeState();
+                } else {
+                    childState = ((ChildNodeEntry)cne.get(0)).getNodeState();
+                }
+            } catch (ItemStateException e) {
+                // should not occur, since nodestate is retrieved from cne-list
+                throw new RepositoryException(e);
-            NodeState nodeState = validator.getNodeState(childId);
-            
+
-            PropertyId mixinPId = idFactory.createPropertyId(childId, QName.JCR_MIXINTYPES);
+            PropertyId mixinPId = idFactory.createPropertyId(childState.getNodeId(), QName.JCR_MIXINTYPES);
-            return nodeState;
+            return childState;
-        PropertyState prop = null;
+        PropertyState propState = null;
-            PropertyState existing = validator.getPropertyState(nodeState.getNodeId(), propName);
-            def = existing.getDefinition();
-            if (def.isProtected()) {
-                // skip protected property
-                log.debug("skipping protected property " + hierMgr.safeGetJCRPath(existing.getPropertyId()));
-                return;
-            }
-            if (def.isAutoCreated()
-                && (existing.getType() == infoType || infoType == PropertyType.UNDEFINED)
-                && def.isMultiple() == existing.isMultiValued()) {
-                // this property has already been auto-created, no need to create it
-                prop = existing;
-            } else {
-                throw new ItemExistsException(hierMgr.safeGetJCRPath(existing.getPropertyId()));
+            try {
+                PropertyState existing = nodeState.getPropertyState(propName);
+                def = existing.getDefinition();
+                if (def.isProtected()) {
+                    // skip protected property
+                    log.debug("skipping protected property " + hierMgr.safeGetJCRPath(existing.getPropertyId()));
+                    return;
+                }
+                if (def.isAutoCreated()
+                    && (existing.getType() == infoType || infoType == PropertyType.UNDEFINED)
+                    && def.isMultiple() == existing.isMultiValued()) {
+                    // this property has already been auto-created, no need to create it
+                    propState = existing;
+                } else {
+                    throw new ItemExistsException(hierMgr.safeGetJCRPath(existing.getPropertyId()));
+                }
+            } catch (ItemStateException e) {
+                // should not occur. existance has been checked before
+                throw new RepositoryException(e);
-        if (prop == null) {
+        if (propState == null) {
-            prop = validator.getPropertyState(nodeState.getNodeId(), propName);
+            try {
+                propState = nodeState.getPropertyState(propName);
+            } catch (ItemStateException e) {
+                // should not occur since prop-state has been created before
+                throw new RepositoryException(e);
+            }
-            Operation sp = SetPropertyValue.create(prop, values, targetType);
+            Operation sp = SetPropertyValue.create(propState, values, targetType);
-        if (prop != null && prop.getType() == PropertyType.REFERENCE) {
-            refTracker.processedReference(prop);
+        if (propState != null && propState.getType() == PropertyType.REFERENCE) {
+            refTracker.processedReference(propState);

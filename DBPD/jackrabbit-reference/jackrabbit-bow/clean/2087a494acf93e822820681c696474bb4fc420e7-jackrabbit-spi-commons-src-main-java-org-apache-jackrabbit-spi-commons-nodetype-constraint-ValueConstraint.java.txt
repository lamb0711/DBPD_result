JCR-2064 Add new JSR283 features to CND reader/writer
JCR-2153 Introduce QValueConstraint and change return type of QPropertyDefinition.getValueConstraints()
JCR-2158 Consolidate CND related classes from SPI and Core


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@785777 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.QValueConstraint;
-public abstract class ValueConstraint {
+public abstract class ValueConstraint implements QValueConstraint {
-     * method returns the same result as <code>{@link #getQualifiedDefinition()}</code>.
+     * method returns the same result as <code>{@link #getString()}</code>.
-     * @see #getQualifiedDefinition()
-     * @param resolver
+     * @see #getString ()
+     * @param resolver name-path resolver
-     * @return the qualified definition String
-     * @see #getDefinition(NamePathResolver)
+     * @return the internal definition String
-    public String getQualifiedDefinition() {
+    public String getString() {
+     * Same as {@link #getString()}
+     * @return the internal definition String
+     */
+    public String toString() {
+        return getString();
+    }
+
+    /**
-    abstract void check(QValue value) throws ConstraintViolationException, RepositoryException;
+    public abstract void check(QValue value) throws ConstraintViolationException, RepositoryException;
-        if (other == this) {
-            return true;
-        } else if (other instanceof ValueConstraint) {
-            return qualifiedDefinition.equals(((ValueConstraint) other).qualifiedDefinition);
-        } else {
-            return false;
-        }
+        return other == this
+                || other instanceof ValueConstraint
+                && qualifiedDefinition.equals(((ValueConstraint) other).qualifiedDefinition);
-     * @param type
-     * @param qualifiedDefinition
-     * @return
-     * @throws InvalidConstraintException
+     * @param type required type
+     * @param qualifiedDefinition internal definition string
+     * @return a new value constraint
+     * @throws InvalidConstraintException if the constraint is not valid
-            // constraints which are not qName senstive
+            // constraints which are not qName sensitive
+     * Create a new <code>ValueConstraint</code> array from the String representation.
+     * Note, that the definition must be in the qualified format in case the type
+     * indicates {@link PropertyType#NAME}, {@link PropertyType#PATH} or {@link PropertyType#REFERENCE}
-     * @param type
-     * @param definition
-     * @param resolver
-     * @return
-     * @throws InvalidConstraintException
+     * @param type the required type
+     * @param qualifiedDefinition internal definition strings
+     * @return the array of constraints
+     * @throws InvalidConstraintException if one of the constraints is invalid
+     */
+    public static ValueConstraint[] create(int type, String[] qualifiedDefinition)
+            throws InvalidConstraintException {
+        if (qualifiedDefinition == null || qualifiedDefinition.length == 0) {
+            return ValueConstraint.EMPTY_ARRAY;
+        }
+        ValueConstraint[] ret = new ValueConstraint[qualifiedDefinition.length];
+        for (int i=0; i<ret.length; i++) {
+            ret[i] = ValueConstraint.create(type, qualifiedDefinition[i]);
+        }
+        return ret;
+    }
+
+    /**
+     * Create a new <code>ValueConstraint</code> array from the JCR representation.
+     *
+     * @param type the required type
+     * @param definition definition strings
+     * @param resolver name-path resolver
+     * @return the array of constraints
+     * @throws InvalidConstraintException if one of the constraints is invalid
+     */
+    public static ValueConstraint[] create(int type, String definition[], NamePathResolver resolver)
+            throws InvalidConstraintException {
+        if (definition == null || definition.length == 0) {
+            return ValueConstraint.EMPTY_ARRAY;
+        }
+        ValueConstraint[] ret = new ValueConstraint[definition.length];
+        for (int i=0; i<ret.length; i++) {
+            ret[i] = ValueConstraint.create(type, definition[i], resolver);
+        }
+        return ret;
+    }
+
+    /**
+     *
+     * @param type required type
+     * @param definition JCR definition
+     * @param resolver name-path resolver
+     * @return a new value constraint
+     * @throws InvalidConstraintException if the constraint is invalid
-     * @param pd
-     * @param values
-     * @throws ConstraintViolationException
+     * @param pd propert definition
+     * @param values values to check
+     * @throws ConstraintViolationException if the constraints are violated
-        String[] constraints = pd.getValueConstraints();
+        QValueConstraint[] constraints = pd.getValueConstraints();
-            for (int i = 0; i < values.length; i++) {
+            for (QValue value : values) {
-                        ValueConstraint cnstr = ValueConstraint.create(pd.getRequiredType(), constraints[j]);
-                        cnstr.check(values[i]);
+                        constraints[j].check(value);

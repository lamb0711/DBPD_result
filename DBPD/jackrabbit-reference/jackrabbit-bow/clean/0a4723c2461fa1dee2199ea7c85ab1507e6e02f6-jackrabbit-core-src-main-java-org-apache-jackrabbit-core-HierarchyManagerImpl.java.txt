JCR-3364: Moving of nodes requires read access to all parent nodes of the destination node

Use explicit cycle detection to detect the JCR-3291 case without the need for extra transient items

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1535539 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.HashSet;
+import javax.jcr.InvalidItemStateException;
-     * @param builder builder currently being used
-     * @param state   item to find path of
+     * @param builder  builder currently being used
+     * @param state    item to find path of
+     * @param detector path cycle detector
-    protected void buildPath(PathBuilder builder, ItemState state)
+    protected void buildPath(
+            PathBuilder builder, ItemState state, CycleDetector detector)
+        } else if (detector.checkCycle(parentId)) {
+            throw new InvalidItemStateException(
+                    "Path cycle detected: " + parentId);
-        buildPath(builder, parent);
+        buildPath(builder, parent, detector);
-            buildPath(builder, getItemState(id));
+            buildPath(builder, getItemState(id), new CycleDetector());
+
+    /**
+     * Utility class used to detect path cycles with as little overhead
+     * as possible. The {@link #checkCycle(ItemId)} method is called for
+     * each path element as the
+     * {@link HierarchyManagerImpl#buildPath(PathBuilder, ItemState, CycleDetector)}
+     * method walks up the hierarchy. At first, during the first fifteen
+     * path elements, the detector does nothing in order to avoid
+     * introducing any unnecessary overhead to normal paths that seldom
+     * are deeper than that. After that initial threshold all item
+     * identifiers along the path are tracked, and a cycle is reported
+     * if an identifier is encountered that already occurred along the
+     * same path.
+     */
+    protected static class CycleDetector {
+
+        private int count = 0;
+
+        private Set<ItemId> ids;
+
+        boolean checkCycle(ItemId id) throws InvalidItemStateException {
+            if (count++ >= 15) {
+                if (ids == null) {
+                    ids = new HashSet<ItemId>();
+                } else {
+                    return !ids.add(id);
+                }
+            }
+            return false;
+        }
+
+    }
+

JCR-1104 : JSR 283 support (security work in progress)

- add Authorizable.getPropertyNames()
- User.getCredentials returns Credentials
-> adjust implementation and tests

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@651221 13f79535-47bb-0310-9956-ffa450edef68

-     * Tests if a Value exists for a property at the given name.
-     *
-     * @param name
-     * @return
-     * @throws javax.jcr.RepositoryException
+     * @see Authorizable#getPropertyNames()
+     */
+    public Iterator getPropertyNames() throws RepositoryException {
+        List l = new ArrayList();
+        for (PropertyIterator it = node.getProperties(); it.hasNext();) {
+            String propName = it.nextProperty().getName();
+            l.add(propName);
+        }
+        return l.iterator();
+    }
+
+    /**
-     * @param name
-     * @return the value or <code>null</code> if no value exists for the given name
-     * @throws javax.jcr.RepositoryException
-        checkProtectedProperty(getSession().getQName(name));
+        checkProtectedProperty(name);
-        checkProtectedProperty(getSession().getQName(name));
+        checkProtectedProperty(name);
-        checkProtectedProperty(getSession().getQName(name));
+        checkProtectedProperty(name);
-     * Check if the property to be modified/removed is one of the following that
-     * has a special meaning and must be altered using this user API:
+     * Test if the JCR property to be modified/removed is one of the
+     * following that has a special meaning and must be altered using this
+     * user API:
+     * <ul>
-     * Basically these properties are marked 'protected' in their property
-     * definition. This method is a simple utility in order to save the
-     * extra effort to modify the props just to find out later that they
-     * are in fact protected.
+     * Those properties are 'protected' in their property definition. This
+     * method is a simple utility in order to save the extra effort to modify
+     * the props just to find out later that they are in fact protected.
-     * @param pName
+     * @param propertyName
+     * @return
-    private void checkProtectedProperty(Name pName) throws RepositoryException {
-        if (P_PRINCIPAL_NAME.equals(pName) || P_USERID.equals(pName)
-                || P_REFEREES.equals(pName) || P_MEMBERS.equals(pName)
-                || P_IMPERSONATORS.equals(pName)) {
-            throw new ConstraintViolationException("Attempt to modify protected property " + getSession().getJCRName(pName) + " of an Authorizable.");
-        }
+    private boolean isProtectedProperty(String propertyName) throws RepositoryException {
+        Name pName = getSession().getQName(propertyName);
+         if (P_PRINCIPAL_NAME.equals(pName) || P_USERID.equals(pName)
+                 || P_REFEREES.equals(pName) || P_MEMBERS.equals(pName)
+                 || P_IMPERSONATORS.equals(pName)) {
+             return true;
+         } else {
+             return false;
+         }
+     }
+
+    /**
+     * Throws ConstraintViolationException if {@link #isProtectedProperty(String)}
+     * returns <code>true</code>.
+     *
+     * @param propertyName
+     * @throws RepositoryException
+     */
+    private void checkProtectedProperty(String propertyName) throws RepositoryException {
+        if (isProtectedProperty(propertyName)) {
+             throw new ConstraintViolationException("Attempt to modify protected property " + propertyName + " of an Authorizable.");
+         }

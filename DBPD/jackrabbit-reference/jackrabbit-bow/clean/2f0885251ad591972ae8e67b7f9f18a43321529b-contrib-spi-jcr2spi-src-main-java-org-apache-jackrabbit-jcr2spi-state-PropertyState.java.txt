Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.name.QName;
-import org.apache.jackrabbit.spi.IdFactory;
-import org.apache.jackrabbit.spi.Event;
+import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeRegistry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.PropertyEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.HierarchyEntry;
-     * The name of this property state.
+     * The PropertyEntry associated with the state
-    private final QName name;
+    private final PropertyEntry hierarchyEntry;
-    private final QPropertyDefinition def;
+    private QPropertyDefinition definition;
+     * True if this Property is multiValued
+     */
+    private final boolean multiValued;
+
+    /**
-     * @param parent
-     * @param idFactory
-    protected PropertyState(PropertyState overlayedState, NodeState parent,
-                            int initialStatus, ItemStateFactory isf, IdFactory idFactory) {
-        super(overlayedState, parent, initialStatus, isf, idFactory);
-        this.name = overlayedState.name;
-        this.def = overlayedState.def;
+    protected PropertyState(PropertyState overlayedState, int initialStatus,
+                            ItemStateFactory isf) {
+        super(overlayedState, initialStatus, isf);
+
+        this.hierarchyEntry = overlayedState.hierarchyEntry;
+        this.definition = overlayedState.definition;
+        this.multiValued = overlayedState.multiValued;
-     * @param name
-     * @param parent
-     * @param definition
+     * @param entry
-     * @param idFactory
+     * @param isWorkspaceState
-    protected PropertyState(QName name, NodeState parent, QPropertyDefinition definition,
-                            int initialStatus, ItemStateFactory isf, IdFactory idFactory,
-                            boolean isWorkspaceState) {
-        super(parent, initialStatus, isf, idFactory, isWorkspaceState);
-        this.name = name;
-        this.def = definition;
+    protected PropertyState(PropertyEntry entry, boolean multiValued, QPropertyDefinition definition,
+                            int initialStatus, boolean isWorkspaceState,
+                            ItemStateFactory isf, NodeTypeRegistry ntReg) {
+        super(initialStatus, isWorkspaceState, isf, ntReg);
+
+        this.hierarchyEntry = entry;
+        this.definition = definition;
+        this.multiValued = multiValued;
+
+     * @see ItemState#getHierarchyEntry()
+     */
+    public HierarchyEntry getHierarchyEntry() {
+        return hierarchyEntry;
+    }
+
+    /**
-     * Returns the name of this property.
-     *
-     * @return the name of this property.
-     * @see ItemState#getQName()
-     */
-    public QName getQName() {
-        return name;
-    }
-
-    /**
-     * {@inheritDoc}
-     * @see ItemState#reload(boolean)
-     */
-    public void reload(boolean keepChanges) {
-        if (isWorkspaceState()) {
-            // refresh from persistent storage ('keepChanges' not relevant).
-            try {
-                PropertyState tmp = isf.createPropertyState(getPropertyId(), getParent());
-                if (merge(tmp, false) || getStatus() == Status.INVALIDATED) {
-                    setStatus(Status.MODIFIED);
-                }
-            } catch (NoSuchItemStateException e) {
-                // TODO: improve. make sure the property-entry is removed from the parent state
-                // inform overlaying state and listeners
-                setStatus(Status.REMOVED);
-            } catch (ItemStateException e) {
-                // TODO: rather throw? remove from parent?
-                log.warn("Exception while refreshing property state: " + e);
-                log.debug("Stacktrace: ", e);
-            }
-        } else {
-            /* session-state: if keepChanges is true only existing or invalidated
-               states must be updated. otherwise the state gets updated and might
-               be marked 'Stale' if transient changes are present and the
-               workspace-state is modified. */
-            if (!keepChanges || getStatus() == Status.EXISTING || getStatus() == Status.INVALIDATED) {
-                // calling refresh on the workspace state will in turn reset this state
-                overlayedState.reload(keepChanges);
-            }
-        }
-    }
-
-    /**
-    boolean merge(ItemState another, boolean keepChanges) {
+    public boolean merge(ItemState another, boolean keepChanges) {
-    /**
-     * {@inheritDoc}
-     * @see ItemState#invalidate(boolean)
-     */
-    public void invalidate(boolean recursive) {
-        if (isWorkspaceState()) {
-            // workspace state
-            setStatus(Status.INVALIDATED);
-        } else {
-            // TODO: only invalidate if existing?
-            if (getStatus() == Status.EXISTING) {
-                // set workspace state invalidated, this will in turn invalidate
-                // this (session) state as well
-                overlayedState.invalidate(recursive);
-            }
-        }
-    }
-
-        return idFactory.createPropertyId(getParent().getNodeId(), getQName());
+        return getPropertyEntry().getId();
-        return def.isMultiple();
+        return multiValued;
-    public QPropertyDefinition getDefinition() {
-        return def;
+    public QPropertyDefinition getDefinition() throws RepositoryException {
+        if (definition == null) {
+            definition = getEffectiveNodeType().getApplicablePropertyDefinition(getQName(), getType(), isMultiValued());
+        }
+        return definition;
-    //----------------------------------------------------< Workspace State >---
-    /**
-     * @see ItemState#refresh(Event)
-     */
-    synchronized void refresh(Event event) {
-        checkIsWorkspaceState();
-
-        switch (event.getType()) {
-            case Event.PROPERTY_REMOVED:
-                setStatus(Status.REMOVED);
-                break;
-
-            case Event.PROPERTY_CHANGED:
-                // retrieve modified property value and type from server.
-                reload(false);
-                break;
-
-            case Event.PROPERTY_ADDED:
-            case Event.NODE_ADDED:
-            case Event.NODE_REMOVED:
-            default:
-                throw new IllegalArgumentException("Event type " + event.getType() + " cannot be applied to a PropertyState");
-        }
-    }
-
-    //----------------------------------------------------< Session - State >---
-        validate(values, type, def);
+        validate(values, type, getDefinition());
+    //------------------------------------------------------------< private >---
+    /**
+     *
+     * @return
+     */
+    private PropertyEntry getPropertyEntry() {
+        return (PropertyEntry) getHierarchyEntry();
+    }
+
-        if (definition.getRequiredType() != PropertyType.UNDEFINED && definition.getRequiredType() != propertyType) {
-            throw new ConstraintViolationException("RequiredType constraint is not satisfied");
-        }
+        if (definition.getRequiredType() != PropertyType.UNDEFINED && definition.getRequiredType() != propertyType) {
+            throw new ConstraintViolationException("RequiredType constraint is not satisfied");
+        }

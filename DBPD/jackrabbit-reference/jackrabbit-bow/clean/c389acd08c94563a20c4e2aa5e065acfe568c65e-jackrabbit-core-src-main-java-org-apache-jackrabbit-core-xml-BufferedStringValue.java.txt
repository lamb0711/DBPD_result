JCR-2007 Importing strings with special characters fails

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@752458 13f79535-47bb-0310-9956-ffa450edef68

+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.FileInputStream;
-import java.io.FileReader;
+import java.io.InputStreamReader;
+import java.io.StringWriter;
-     * max size for buffering data in memory
+     * The maximum size for buffering data in memory.
+    
-     * size of increment if capacity buffer needs to be enlarged
+     * The in-memory buffer.
-    private static final int BUFFER_INCREMENT = 0x2000;
+    private StringWriter buffer;
+    
-     * in-memory buffer
+     * The number of characters written so far.
+     * If the in-memory buffer is used, this is position within buffer (size of actual data in buffer)
-    private char[] buffer;
-    /**
-     * current position within buffer (size of actual data in buffer)
-     */
-    private int bufferPos;
+    private long length;
-     * backing temporary file created when size of data exceeds
-     * MAX_BUFFER_SIZE
+     * Backing temporary file created when size of data exceeds
+     * MAX_BUFFER_SIZE.
+    
-     * writer used to write to tmpFile; writer & tmpFile are always
-     * instantiated together, i.e. they are either both null or both not null.
+     * Writer used to write to tmpFile.
+    
+    /**
+     * Whether the value is base64 encoded.
+     */
+    private boolean base64;
-        buffer = new char[0x2000];
-        bufferPos = 0;
+        buffer = new StringWriter();
+        length = 0;
-        if (buffer != null) {
-            return bufferPos;
-        } else if (tmpFile != null) {
-            // flush writer first
-            writer.flush();
-            return tmpFile.length();
-        } else {
-            throw new IOException("this instance has already been disposed");
+        return length;
+    }
+    
+    private String retrieveString() throws IOException {
+        String value = retrieve();
+        if (base64) {
+            ByteArrayOutputStream out = new ByteArrayOutputStream();
+            Base64.decode(value, out);
+            value = new String(out.toByteArray(), "UTF-8");
+        return value;
-            return new String(buffer, 0, bufferPos);
+            return buffer.toString();
-            // flush writer first
-            writer.flush();
+            // close writer first
+            writer.close();
-            StringBuffer sb = new StringBuffer((int) tmpFile.length());
+            StringBuffer sb = new StringBuffer((int) length);
-            int read;
-            Reader reader = new FileReader(tmpFile);
+            Reader reader = openReader();
+                int read;
+    
+    private Reader openReader() throws IOException {
+        return new InputStreamReader(
+                new BufferedInputStream(new FileInputStream(tmpFile)), "UTF-8");
+    }
-            return new StringReader(new String(buffer, 0, bufferPos));
+            return new StringReader(retrieve());
-            // flush writer first
-            writer.flush();
-            return new FileReader(tmpFile);
+            // close writer first
+            writer.close();
+            return openReader();
-     * @param length the number of characters to append
+     * @param len the number of characters to append
-    public void append(char[] chars, int start, int length)
+    public void append(char[] chars, int start, int len)
-            if (bufferPos + length > MAX_BUFFER_SIZE) {
+            if (this.length + len > MAX_BUFFER_SIZE) {
-                final FileOutputStream fout = new FileOutputStream(tmpFile);
-                writer = new OutputStreamWriter(fout) {
-                    public void flush() throws IOException {
-                        // flush this writer
-                        super.flush();
-                        // force synchronization with underlying file
-                        fout.getFD().sync();
-                    }
-                };
-                writer.write(buffer, 0, bufferPos);
-                writer.write(chars, start, length);
-                // reset fields
+                BufferedOutputStream fout = new BufferedOutputStream(new FileOutputStream(tmpFile));
+                writer = new OutputStreamWriter(fout, "UTF-8");
+                writer.write(buffer.toString());
+                writer.write(chars, start, len);
+                // reset the in-memory buffer
-                bufferPos = 0;
-                if (bufferPos + length > buffer.length) {
-                    // reallocate new buffer and spool old buffer contents
-                    int bufferSize =
-                            BUFFER_INCREMENT * (((bufferPos + length) / BUFFER_INCREMENT) + 1);
-                    char[] newBuffer = new char[bufferSize];
-                    System.arraycopy(buffer, 0, newBuffer, 0, bufferPos);
-                    buffer = newBuffer;
-                }
-                System.arraycopy(chars, start, buffer, bufferPos, length);
-                bufferPos += length;
+                buffer.write(chars, start, len);
-            writer.write(chars, start, length);
+            writer.write(chars, start, len);
+        length += len;
-                return ValueHelper.deserialize(retrieve(), targetType, false, ValueFactoryImpl.getInstance());
+                return ValueHelper.deserialize(retrieveString(), targetType, false, ValueFactoryImpl.getInstance());
-                    // using Reader and temporay file
+                    // using Reader and temporary file
-                        retrieve(), type, ValueFactoryImpl.getInstance()), nsContext);
+                        retrieveString(), type, ValueFactoryImpl.getInstance()), nsContext);
+    /**
+     * This class converts the text read Converts a base64 reader to an input stream.
+     */
-            bufferPos = 0;
+
+    /**
+     * Whether this value is base64 encoded
+     * 
+     * @param base64 the flag
+     */
+    public void setBase64(boolean base64) {
+        this.base64 = base64;
+    }
+

work in progress

- version always protected
- versionHistory always protected
- fix Node.getReferences && reference properties
- mixinTypes are 'active' upon save only (and not before). therefore
  cleanup after removeMixin is done only after save.
  adding new states defined by a new mixin are only added after the
  node has been saved.
- nodestates identified by a uuid only were created a second time upon
  ChildNodeEntry.resolve => fix needs to be improved
- Events/ChangeLog are processed by the save-target state
- ChangeLog.persisted not used any more

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@467956 13f79535-47bb-0310-9956-ffa450edef68

-            if (reqType == PropertyType.REFERENCE) {
-                if (value instanceof NodeImpl) {
-                    NodeImpl targetNode = (NodeImpl)value;
-                    if (targetNode.isNodeType(QName.MIX_REFERENCEABLE)) {
-                        QValue qValue = QValue.create(targetNode.getUUID(), PropertyType.REFERENCE);
-                        setInternalValues(new QValue[]{qValue}, reqType);
-                    } else {
-                        throw new ValueFormatException("Target node must be of node type mix:referenceable");
-                    }
-                } else {
-                    String msg = "Incompatible Node object: " + value + "(" + safeGetJCRPath() + ")";
-                    log.debug(msg);
-                    throw new RepositoryException(msg);
-                }
-            } else {
-                throw new ValueFormatException("Property must be of type REFERENCE (" + safeGetJCRPath() + ")");
-            }
+            checkValidReference(value, reqType, this);
+            QValue qValue = QValue.create(((NodeImpl)value).getUUID(), PropertyType.REFERENCE);
+            setInternalValues(new QValue[]{qValue}, reqType);
-        if (isMultiple()) {
+        if (isMultiple()) {                                                            
+
+    /**
+     * 
+     * @param value
+     * @param propertyType
+     * @param itemImpl
+     * @throws ValueFormatException
+     * @throws RepositoryException
+     */
+    static void checkValidReference(Node value, int propertyType, ItemImpl itemImpl) throws ValueFormatException, RepositoryException {
+        if (propertyType == PropertyType.REFERENCE) {
+            if (value instanceof NodeImpl) {
+                NodeImpl targetNode = (NodeImpl)value;
+                if (!targetNode.isNodeType(QName.MIX_REFERENCEABLE)) {
+                    throw new ValueFormatException("Target node must be of node type mix:referenceable");
+                }
+            } else {
+                String msg = "Incompatible Node object: " + value + "(" + itemImpl.safeGetJCRPath() + ")";
+                log.debug(msg);
+                throw new RepositoryException(msg);
+            }
+        } else {
+            throw new ValueFormatException("Property must be of type REFERENCE (" + itemImpl.safeGetJCRPath() + ")");
+        }
+    }

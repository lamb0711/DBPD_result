JCR-2711: BTreeManager needs more flexible mechanism for ignoring (internal) properties

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@984729 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.commons.predicate.Predicate;
+import java.util.Arrays;
+import java.util.HashSet;
-import java.util.NoSuchElementException;
+import java.util.Set;
+    private final Set<String> ignoredProperties = new HashSet<String>(Arrays.asList(
+            JcrConstants.JCR_PRIMARYTYPE,
+            JcrConstants.JCR_MIXINTYPES));
+
+     * Properties to ignore. The default set contains {@link JcrConstants#JCR_PRIMARYTYPE}
+     * and {@link JcrConstants#JCR_MIXINTYPES}.
+     *
+     * @return
+     */
+    public Set<String> getIgnoredProperties() {
+        return ignoredProperties;
+    }
+
+    /**
-            Node parent = node.getParent();
-            node.remove();
-            removeRec(parent);
+            removeRec(node);
-        return !node.hasNodes() && !isRoot(node);
+        return !node.hasNodes();
-        Iterator<Property> filteredIterator = new Iterator<Property>() {
-            Property next = null;
-
-            public boolean hasNext() {
-                while (next == null && properties.hasNext()) {
-                    Property p = properties.nextProperty();
-                    try {
-                        if (!JcrConstants.JCR_PRIMARYTYPE.equals(p.getName())) {
-                            next = p;
-                        }
-                    }
-                    catch (RepositoryException ignore) {
-                        next = p;
-                    }
-                }
-
-                return next != null;
-            }
-
-            public Property next() {
-                if (hasNext()) {
-                    Property property = next;
-                    next = null;
-                    return property;
-                }
-                else {
-                    throw new NoSuchElementException();
-                }
-            }
-
-            public void remove() {
-                throw new UnsupportedOperationException();
-            }
-        };
-
-        return getSizedIterator(filteredIterator, size > 0 ? size - 1 : size);
+        for (Iterator<String> ignored = ignoredProperties.iterator(); size > 0 && ignored.hasNext(); ) {
+            if (node.hasProperty(ignored.next())) {
+                size--;
+            }
+        }
+
+        return getSizedIterator(filterProperties(properties), size);
+    /**
+     * Filtering ignored properties from the given properties.
+     */
+    private Iterator<Property> filterProperties(Iterator<Property> properties) {
+        return new FilterIterator<Property>(properties, new Predicate() {
+            public boolean evaluate(Object object) {
+                try {
+                    Property p = (Property) object;
+                    return !ignoredProperties.contains(p.getName());
+                }
+                catch (RepositoryException ignore) {
+                    return true;
+                }
+            }
+        });
+    }
+

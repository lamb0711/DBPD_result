work in progress.

- nodestates must always be connected to their cne upon creation
  TODO: add some sort of caching to avoid traffic overhead
- add TODO for refresh, that currently doesn't work properly
- ItemState.refresh only takes changelog and returns the ids of the
  processed states. cleanup of events is left to caller.
- move of NodeStates does not work
- PathResolver: force start to be an NodeState
- all MODIFIED status for SessionStates as well in order to make sure
  that listeners are informed about external changes even if the 
  state is EXISTING.

next TODO: make sure, that public getChildNodeEntry/ies and hasChildNodeEntry check for validity of the connected NodeState. don't return entries, where the nodestate is (transiently) removed or stale.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@472818 13f79535-47bb-0310-9956-ffa450edef68

-        assertAvailability();
-        assertAvailability();
-    private void assertAvailability() {
-        // TODO: TOBEFIXED. duality of creating states via ISM or via factory may result in a cached state, that is not connected to its cne.
-        if (uuid != null && parent != null) {
-            // make sure this state is connected to its childNode-entry
-            ChildNodeEntry cne = parent.childNodeEntries.get(name, uuid);
-            if (cne != null && !cne.isAvailable()) {
-                parent.childNodeEntries.replaceEntry(this);
-            }
-        }
-    }
-
-     * Determines if there are any child node entries.
+     * Determines if there are any valid child node entries.
-     *         <code>false</code> otherwise.
+     * <code>false</code> otherwise.
-     * Determines if there is a <code>ChildNodeEntry</code> with the
+     * Determines if there is a valid <code>ChildNodeEntry</code> with the
-     *         the specified <code>name</code> and <code>index</code>.
+     * the specified <code>name</code> and <code>index</code>.
+     * <code>NodeId</code> or <code>null</code> if there's no matching
+     * entry.
+     *
+     * @param nodeId the id of the child node state.
+     * @return the <code>ChildNodeEntry</code> with the specified
+     * <code>NodeId</code> or <code>null</code> if there's no matching entry.
+     */
+    public synchronized ChildNodeEntry getChildNodeEntry(NodeId nodeId) {
+        String uuid = nodeId.getUUID();
+        Path path = nodeId.getPath();
+        if (uuid != null && path == null) {
+            // retrieve child-entry by uuid
+            return childNodeEntries.get(null, uuid);
+        } else {
+           // retrieve child-entry by name and index
+            Path.PathElement nameElement = path.getNameElement();
+            return childNodeEntries.get(nameElement.getName(), nameElement.getIndex());
+        }
+    }
+
+    /**
+     * Returns the <code>ChildNodeEntry</code> with the specified
-     *         <code>NodeState</code> or <code>null</code> if there's no
-     *         matching entry.
+     * <code>NodeState</code> or <code>null</code> if there's no matching entry.
-            // then it must be valid
+            // then it must be valid // TODO check if this assumption is correct.
-     * @param propertyName the name of the property state to return.
-     * @throws NoSuchItemStateException if there is no property state with the
-     *                                  given name.
-     * @throws ItemStateException       if an error occurs while retrieving the
-     *                                  property state.
+     * @param propertyName The name of the property state to return.
+     * @throws NoSuchItemStateException If there is no (valid) property state
+     * with the given name.
+     * @throws ItemStateException If an error occurs while retrieving the
+     * property state.
-            throws NoSuchItemStateException, ItemStateException {
-        PropertyState propState = getAnyPropertyState(propertyName);
-        if (propState.isValid()) {
-            return propState;
-        } else {
-            throw new NoSuchItemStateException(idFactory.createPropertyId(getNodeId(), propertyName).toString());
-        }
-    }
+        throws NoSuchItemStateException, ItemStateException {
-    /**
-     * Returns the property state with the given name and also takes removed
-     * property states into account.
-     *
-     * @param propertyName the name of the property state to return.
-     * @throws NoSuchItemStateException if there is no property state with the
-     *                                  given name.
-     * @throws ItemStateException       if an error occurs while retrieving the
-     *                                  property state.
-     */
-    public synchronized PropertyState getAnyPropertyState(QName propertyName)
-            throws NoSuchItemStateException, ItemStateException {
+        } else {
+            PropertyState propState = propEntry.getPropertyState();
+            if (propState.isValid()) {
+                return propState;
+            } else {
+                throw new NoSuchItemStateException(idFactory.createPropertyId(getNodeId(), propertyName).toString());
+            }
-        return propEntry.getPropertyState();
-     * @return the index of the child node entry or <code>0</code> if it is not
-     *         found in this <code>NodeState</code>.
+     * @return the index of the child node entry or <code>Path.INDEX_UNDEFINED</code>
+     * if it is not found in this <code>NodeState</code>.
+                // TODO: check if assuption is correct
-     * @see ItemState#refresh(Collection,ChangeLog)
+     * @see ItemState#refresh(ChangeLog)
-    void refresh(Collection events, ChangeLog changeLog) throws IllegalStateException {
+    Set refresh(ChangeLog changeLog) throws IllegalStateException {
-        HashMap modParents = new HashMap();
+        Map modParents = new HashMap();
+        Set processedIds = new HashSet();
-            removeEvent(events, state);
+            processedIds.add(state.getId());
-                removeEvent(events, addedState);
+                processedIds.add(addedState.getId());
-                continue;
-            }
-            // push changes down to overlayed state
-            int type = ((PropertyState) modState).getType();
-            QValue[] values = ((PropertyState) modState).getValues();
-            ((PropertyState) modState.overlayedState).init(type, values);
+                NodeState modNodeState = (NodeState) modState;
+                // handle moved nodes
+                if (isMovedState(modNodeState)) {
+                    // move overlayed state as well
+                    NodeState newParent = (NodeState) modState.parent.overlayedState;
+                    NodeState overlayed = (NodeState) modState.overlayedState;
+                    ItemId removedId = overlayed.getId();
+                    try {
+                        overlayed.parent.moveEntry(newParent, overlayed, modNodeState.getQName(), modNodeState.getDefinition());
+                    } catch (RepositoryException e) {
+                        // should never occur
+                        log.error("Internal error while moving childnode entries.", e);
+                    }
+                    // and mark the moved state existing
+                    modNodeState.setStatus(Status.EXISTING);
+                    it.remove();
-            modState.setStatus(Status.EXISTING);
-            // if property state defines a modified jcr:mixinTypes
-            // the parent is listed as modified state and needs to be
-            // processed at the end.
-            if (isUuidOrMixin(modState.getQName())) {
-                modifiedParent(this, modState, modParents);
+                    processedIds.add(removedId);
+                    processedIds.add(modNodeState.getId());
+                } else {
+                    modifiedParent((NodeState)modState, null, modParents);
+                }
+            } else {
+                // push changes down to overlayed state
+                int type = ((PropertyState) modState).getType();
+                QValue[] values = ((PropertyState) modState).getValues();
+                ((PropertyState) modState.overlayedState).init(type, values);
+
+                modState.setStatus(Status.EXISTING);
+                // if property state defines a modified jcr:mixinTypes
+                // the parent is listed as modified state and needs to be
+                // processed at the end.
+                if (isUuidOrMixin(modState.getQName())) {
+                    modifiedParent(modState.getParent(), modState, modParents);
+                }
+                it.remove();
+                // remove the property-modification event from the set
+                processedIds.add(modState.getId());
-            // remove the processed event from the set
-            it.remove();
-            removeEvent(events, modState);
-        /* process all parent states that need their uuid or mixin-types being
-           adjusted because that property has been added or modified */
+        /* process all parent states that are marked modified and eventually
+           need their uuid or mixin-types being adjusted because that property
+           has been added, modified or removed */
+
+        return processedIds;
+        // TODO: TOBEFIXED. revert must include an update with the latest state present on the server
+        moveEntry(newParent, childState, newName, newDefinition);
+        // mark both this and newParent modified
+        markModified();
+        childState.markModified();
+        newParent.markModified();
+    }
+
+    private void moveEntry(NodeState newParent, NodeState childState, QName newName, QNodeDefinition newDefinition) throws RepositoryException {
-            childState.rename(newName);
+            childState.name = newName;
-            throw new RepositoryException("Unexpected error: Child state to be renamed does not exist.");
+            throw new RepositoryException("Unexpected error: Child state to be moved does not exist.");
-        // mark both this and newParent modified
-        markModified();
-        childState.markModified();
-        newParent.markModified();
-    }
-
-    /**
-     * Renames this node to <code>newName</code>.
-     *
-     * @param newName the new name for this node state.
-     * @throws IllegalStateException if this is the root node.
-     */
-    private synchronized void rename(QName newName) {
-        checkIsSessionState();
-        if (getParent() == null) {
-            throw new IllegalStateException("root node cannot be renamed");
-        }
-        name = newName;
+                // TODO: check if this assumption is correct
-    //------------------------------------------------------< inner classes >---
+
+    private static boolean isMovedState(NodeState modState) {
+        return modState.overlayedState.parent != modState.parent.overlayedState;
+    }

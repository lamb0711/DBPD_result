Use new Java 5 Language features where possible


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@786295 13f79535-47bb-0310-9956-ffa450edef68

-import EDU.oswego.cs.dl.util.concurrent.ConcurrentReaderHashMap;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.PrintStream;
+import java.io.Reader;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.Stack;
+
+import javax.jcr.NamespaceRegistry;
+import javax.jcr.PropertyType;
+import javax.jcr.RepositoryException;
+import javax.jcr.nodetype.ConstraintViolationException;
+import javax.jcr.nodetype.NoSuchNodeTypeException;
+import javax.jcr.version.OnParentVersionAction;
+
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.PrintStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Set;
-import java.util.Stack;
-
-import javax.jcr.NamespaceRegistry;
-import javax.jcr.PropertyType;
-import javax.jcr.RepositoryException;
-import javax.jcr.nodetype.ConstraintViolationException;
-import javax.jcr.nodetype.NoSuchNodeTypeException;
-import javax.jcr.version.OnParentVersionAction;
+import EDU.oswego.cs.dl.util.concurrent.ConcurrentReaderHashMap;
-    private final ConcurrentReaderHashMap registeredNTDefs;
+    private final Map<Name, NodeTypeDef> registeredNTDefs;
-    private final ConcurrentReaderHashMap propDefs;
+    private final Map<PropDefId, PropDef> propDefs;
-    private final ConcurrentReaderHashMap nodeDefs;
+    private final Map<NodeDefId, NodeDef> nodeDefs;
-    private final Map listeners =
+    private final Map<NodeTypeRegistryListener, NodeTypeRegistryListener> listeners =
-     * @param nsReg
-     * @param ntStore
+     * @param nsReg namespace registry
+     * @param ntStore node type store
-     * @throws RepositoryException
+     * @throws RepositoryException if an error occurs
-        return (Name[]) registeredNTDefs.keySet().toArray(new Name[registeredNTDefs.size()]);
+        return registeredNTDefs.keySet().toArray(new Name[registeredNTDefs.size()]);
-            HashSet ntDefs = new HashSet();
+            Set<NodeTypeDef> ntDefs = new HashSet<NodeTypeDef>();
-    public void registerNodeTypes(Collection ntDefs)
+    public void registerNodeTypes(Collection<NodeTypeDef> ntDefs)
-    private synchronized void registerNodeTypes(Collection ntDefs, boolean external)
+    private synchronized void registerNodeTypes(Collection<NodeTypeDef> ntDefs,
+                                                boolean external)
-        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
-            NodeTypeDef ntDef = (NodeTypeDef) iter.next();
+        for (NodeTypeDef ntDef: ntDefs) {
-        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
-            NodeTypeDef ntDef = (NodeTypeDef) iter.next();
+        for (NodeTypeDef ntDef : ntDefs) {
-    public void unregisterNodeTypes(Collection ntNames)
+    public void unregisterNodeTypes(Collection<Name> ntNames)
-    private synchronized void unregisterNodeTypes(Collection ntNames, boolean external)
+    private synchronized void unregisterNodeTypes(Collection<Name> ntNames, boolean external)
-        for (Iterator iter = ntNames.iterator(); iter.hasNext();) {
-            Name ntName = (Name) iter.next();
+        for (Name ntName: ntNames) {
-            Set dependents = getDependentNodeTypes(ntName);
+            Set<Name> dependents = getDependentNodeTypes(ntName);
-                for (Iterator depIter = dependents.iterator(); depIter.hasNext();) {
-                    msg.append(depIter.next());
+                for (Name dependent : dependents) {
+                    msg.append(dependent);
-        for (Iterator iter = ntNames.iterator(); iter.hasNext();) {
-            Name ntName = (Name) iter.next();
+        for (Name ntName : ntNames) {
-        for (Iterator iter = ntNames.iterator(); iter.hasNext();) {
-            Name ntName = (Name) iter.next();
+        for (Name ntName : ntNames) {
-        HashSet ntNames = new HashSet();
+        HashSet<Name> ntNames = new HashSet<Name>();
-        NodeTypeDef ntdOld = (NodeTypeDef) registeredNTDefs.get(name);
+        NodeTypeDef ntdOld = registeredNTDefs.get(name);
-     * @param ntName
-     * @return
-     * @throws NoSuchNodeTypeException
+     * @param ntName name
+     * @return effective node type
+     * @throws NoSuchNodeTypeException if node type does not exist
-    public EffectiveNodeType getEffectiveNodeType(Name primary, Set mixins)
+    public EffectiveNodeType getEffectiveNodeType(Name primary, Set<Name> mixins)
-     * @throws NoSuchNodeTypeException
+     * @throws NoSuchNodeTypeException if node type does not exist
-    public Set getDependentNodeTypes(Name nodeTypeName)
+    public Set<Name> getDependentNodeTypes(Name nodeTypeName)
-        HashSet names = new HashSet();
-        Iterator iter = registeredNTDefs.values().iterator();
-        while (iter.hasNext()) {
-            NodeTypeDef ntd = (NodeTypeDef) iter.next();
+        HashSet<Name> names = new HashSet<Name>();
+        for (NodeTypeDef ntd : registeredNTDefs.values()) {
-        NodeTypeDef def = (NodeTypeDef) registeredNTDefs.get(nodeTypeName);
+        NodeTypeDef def = registeredNTDefs.get(nodeTypeName);
-     * @param nodeTypeName
+     * @param nodeTypeName node type name
-     * @param nodeTypeName
+     * @param nodeTypeName node type name
-     * @param id
+     * @param id node def id
-        return (NodeDef) nodeDefs.get(id);
+        return nodeDefs.get(id);
-     * @param id
+     * @param id property def id
-        return (PropDef) propDefs.get(id);
+        return propDefs.get(id);
-        Iterator iter = registeredNTDefs.values().iterator();
-        while (iter.hasNext()) {
-            NodeTypeDef ntd = (NodeTypeDef) iter.next();
+        for (NodeTypeDef ntd : registeredNTDefs.values()) {
-            for (int i = 0; i < supertypes.length; i++) {
-                ps.println("\t\t" + supertypes[i]);
+            for (Name supertype : supertypes) {
+                ps.println("\t\t" + supertype);
-            for (int i = 0; i < pd.length; i++) {
+            for (PropDef aPd : pd) {
-                ps.println(" (declared in " + pd[i].getDeclaringNodeType() + ") id=" + pd[i].getId());
-                ps.println("\t\tName\t\t" + (pd[i].definesResidual() ? "*" : pd[i].getName().toString()));
-                String type = pd[i].getRequiredType() == 0 ? "null" : PropertyType.nameFromValue(pd[i].getRequiredType());
+                ps.println(" (declared in " + aPd.getDeclaringNodeType() + ") id=" + aPd.getId());
+                ps.println("\t\tName\t\t" + (aPd.definesResidual() ? "*" : aPd.getName().toString()));
+                String type = aPd.getRequiredType() == 0 ? "null" : PropertyType.nameFromValue(aPd.getRequiredType());
-                QValueConstraint[] vca = pd[i].getValueConstraints();
+                QValueConstraint[] vca = aPd.getValueConstraints();
-                    for (int n = 0; n < vca.length; n++) {
+                    for (QValueConstraint aVca : vca) {
-                        constraints.append(vca[n].getString());
+                        constraints.append(aVca.getString());
-                InternalValue[] defVals = pd[i].getDefaultValues();
+                InternalValue[] defVals = aPd.getDefaultValues();
-                    for (int n = 0; n < defVals.length; n++) {
+                    for (InternalValue defVal : defVals) {
-                        defaultValues.append(defVals[n].toString());
+                        defaultValues.append(defVal.toString());
-                ps.println("\t\tAutoCreated\t" + pd[i].isAutoCreated());
-                ps.println("\t\tMandatory\t" + pd[i].isMandatory());
-                ps.println("\t\tOnVersion\t" + OnParentVersionAction.nameFromValue(pd[i].getOnParentVersion()));
-                ps.println("\t\tProtected\t" + pd[i].isProtected());
-                ps.println("\t\tMultiple\t" + pd[i].isMultiple());
+                ps.println("\t\tAutoCreated\t" + aPd.isAutoCreated());
+                ps.println("\t\tMandatory\t" + aPd.isMandatory());
+                ps.println("\t\tOnVersion\t" + OnParentVersionAction.nameFromValue(aPd.getOnParentVersion()));
+                ps.println("\t\tProtected\t" + aPd.isProtected());
+                ps.println("\t\tMultiple\t" + aPd.isMultiple());
-            for (int i = 0; i < nd.length; i++) {
+            for (NodeDef aNd : nd) {
-                ps.println(" (declared in " + nd[i].getDeclaringNodeType() + ") id=" + nd[i].getId());
-                ps.println("\t\tName\t\t" + (nd[i].definesResidual() ? "*" : nd[i].getName().toString()));
-                Name[] reqPrimaryTypes = nd[i].getRequiredPrimaryTypes();
+                ps.println(" (declared in " + aNd.getDeclaringNodeType() + ") id=" + aNd.getId());
+                ps.println("\t\tName\t\t" + (aNd.definesResidual() ? "*" : aNd.getName().toString()));
+                Name[] reqPrimaryTypes = aNd.getRequiredPrimaryTypes();
-                    for (int n = 0; n < reqPrimaryTypes.length; n++) {
-                        ps.print("\t\tRequiredPrimaryType\t" + reqPrimaryTypes[n]);
+                    for (Name reqPrimaryType : reqPrimaryTypes) {
+                        ps.print("\t\tRequiredPrimaryType\t" + reqPrimaryType);
-                Name defPrimaryType = nd[i].getDefaultPrimaryType();
+                Name defPrimaryType = aNd.getDefaultPrimaryType();
-                ps.println("\n\t\tAutoCreated\t" + nd[i].isAutoCreated());
-                ps.println("\t\tMandatory\t" + nd[i].isMandatory());
-                ps.println("\t\tOnVersion\t" + OnParentVersionAction.nameFromValue(nd[i].getOnParentVersion()));
-                ps.println("\t\tProtected\t" + nd[i].isProtected());
-                ps.println("\t\tAllowsSameNameSiblings\t" + nd[i].allowsSameNameSiblings());
+                ps.println("\n\t\tAutoCreated\t" + aNd.isAutoCreated());
+                ps.println("\t\tMandatory\t" + aNd.isMandatory());
+                ps.println("\t\tOnVersion\t" + OnParentVersionAction.nameFromValue(aNd.getOnParentVersion()));
+                ps.println("\t\tProtected\t" + aNd.isProtected());
+                ps.println("\t\tAllowsSameNameSiblings\t" + aNd.allowsSameNameSiblings());
-     * @param nsReg
-     * @param ntStore
-     * @throws RepositoryException
+     * @param nsReg name space registry
+     * @param ntStore store
+     * @throws RepositoryException if an error occurs
+    @SuppressWarnings("unchecked")
-     * @param ntName
-     * @param entCache
-     * @param ntdCache
-     * @return
-     * @throws NoSuchNodeTypeException
+     * @param ntName node type name
-     * @return
+     * @return the effective node type
-                                                  Map ntdCache)
+                                                  Map<Name, NodeTypeDef> ntdCache)
-        NodeTypeDef ntd = (NodeTypeDef) ntdCache.get(ntName);
+        NodeTypeDef ntd = ntdCache.get(ntName);
-                                                  Map ntdCache)
+                                                  Map<Name, NodeTypeDef> ntdCache)
-        for (int i = 0; i < ntNames.length; i++) {
-            if (!ntdCache.containsKey(ntNames[i])) {
-                throw new NoSuchNodeTypeException(ntNames[i].toString());
+        for (Name ntName : ntNames) {
+            if (!ntdCache.containsKey(ntName)) {
+                throw new NoSuchNodeTypeException(ntName.toString());
-                    for (int i = 0; i < remainder.length; i++) {
-                        NodeTypeDef ntd = (NodeTypeDef) ntdCache.get(remainder[i]);
+                    for (Name aRemainder : remainder) {
+                        NodeTypeDef ntd = ntdCache.get(aRemainder);
-                                            Stack inheritanceChain,
-                                            Map ntDefCache)
+                                            Stack<Name> inheritanceChain,
+                                            Map<Name, NodeTypeDef> ntDefCache)
-        for (int i = 0; i < supertypes.length; i++) {
-            Name nt = supertypes[i];
+        for (Name nt : supertypes) {
-
-                NodeTypeDef ntd = (NodeTypeDef) ntDefCache.get(nt);
+                NodeTypeDef ntd = ntDefCache.get(nt);
-                                                 Stack definingParentNTs,
+                                                 Stack<Name> definingParentNTs,
-                                                 Map ntDefCache)
+                                                 Map<Name, NodeTypeDef> ntDefCache)
-        for (int i = 0; i < childNodeNTs.length; i++) {
-            Name nt = childNodeNTs[i];
+        for (Name nt : childNodeNTs) {
-        for (int i = 0; i < nodeDefs.length; i++) {
-            Name dnt = nodeDefs[i].getDefaultPrimaryType();
-            Name definingNT = nodeDefs[i].getDeclaringNodeType();
+        for (NodeDef nodeDef : nodeDefs) {
+            Name dnt = nodeDef.getDefaultPrimaryType();
+            Name definingNT = nodeDef.getDeclaringNodeType();
-                        + " defines invalid default node type for child node " + nodeDefs[i].getName();
+                        + " defines invalid default node type for child node " + nodeDef.getName();
-        for (int i = 0; i < pda.length; i++) {
-            propDefs.put(pda[i].getId(), pda[i]);
+        for (PropDef aPda : pda) {
+            propDefs.put(aPda.getId(), aPda);
-        for (int i = 0; i < nda.length; i++) {
-            nodeDefs.put(nda[i].getId(), nda[i]);
+        for (NodeDef aNda : nda) {
+            nodeDefs.put(aNda.getId(), aNda);
-     * @throws InvalidNodeTypeDefException
-     * @throws RepositoryException
+     * @throws InvalidNodeTypeDefException if the node type is not valid
+     * @throws RepositoryException if an error occurs
-    private void internalRegister(Collection ntDefs)
+    private void internalRegister(Collection<NodeTypeDef> ntDefs)
-    private void internalRegister(Collection ntDefs, boolean lenient)
+    private void internalRegister(Collection<NodeTypeDef> ntDefs, boolean lenient)
-        Map tmpNTDefCache = new HashMap(registeredNTDefs);
+        Map<Name, NodeTypeDef> tmpNTDefCache = new HashMap<Name, NodeTypeDef>(registeredNTDefs);
-        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
-            NodeTypeDef ntd = (NodeTypeDef) iter.next();
+        for (NodeTypeDef ntd : ntDefs) {
-        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
-            NodeTypeDef ntd = (NodeTypeDef) iter.next();
-
-            EffectiveNodeType ent =
-                    validateNodeTypeDef(ntd, tmpENTCache, tmpNTDefCache, nsReg,
-                            lenient);
+        for (NodeTypeDef ntd : ntDefs) {
+            EffectiveNodeType ent = validateNodeTypeDef(ntd, tmpENTCache,
+                    tmpNTDefCache, nsReg, lenient);
-        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
-            NodeTypeDef ntd = (NodeTypeDef) iter.next();
-
+        for (NodeTypeDef ntd : ntDefs) {
-            for (int i = 0; i < pda.length; i++) {
-                propDefs.put(pda[i].getId(), pda[i]);
+            for (PropDef aPda : pda) {
+                propDefs.put(aPda.getId(), aPda);
-            for (int i = 0; i < nda.length; i++) {
-                nodeDefs.put(nda[i].getId(), nda[i]);
+            for (NodeDef aNda : nda) {
+                nodeDefs.put(aNda.getId(), aNda);
-        NodeTypeDef ntd = (NodeTypeDef) registeredNTDefs.get(name);
+        NodeTypeDef ntd = registeredNTDefs.get(name);
-        for (int i = 0; i < pda.length; i++) {
-            propDefs.remove(pda[i].getId());
+        for (PropDef aPda : pda) {
+            propDefs.remove(aPda.getId());
-        for (int i = 0; i < nda.length; i++) {
-            nodeDefs.remove(nda[i].getId());
+        for (NodeDef aNda : nda) {
+            nodeDefs.remove(aNda.getId());
-    private void internalUnregister(Collection ntNames)
+    private void internalUnregister(Collection<Name> ntNames)
-        for (Iterator iter = ntNames.iterator(); iter.hasNext();) {
-            Name name = (Name) iter.next();
+        for (Name name : ntNames) {
-     * @param ntd
-     * @param entCache
+     * @param ntd node type definition
+     * @param entCache effective node type cache
-     * @throws InvalidNodeTypeDefException
+     * @throws InvalidNodeTypeDefException if the node type is not valid
-                                                         Map ntdCache,
+                                                         Map<Name, NodeTypeDef> ntdCache,
-            for (int i = 0; i < supertypes.length; i++) {
-                checkNamespace(supertypes[i], nsReg);
+            for (Name supertype : supertypes) {
+                checkNamespace(supertype, nsReg);
-                if (name.equals(supertypes[i])) {
+                if (name.equals(supertype)) {
-                            + supertypes[i] + " (infinite recursion))";
+                            + supertype + " (infinite recursion))";
-                if (!ntdCache.containsKey(supertypes[i])) {
+                if (!ntdCache.containsKey(supertype)) {
-                            + supertypes[i];
+                            + supertype;
-            Stack inheritanceChain = new Stack();
+            Stack<Name> inheritanceChain = new Stack<Name>();
-        for (int i = 0; i < pda.length; i++) {
-            PropDef pd = pda[i];
+        for (PropDef pd : pda) {
-                for (int j = 0; j < defVals.length; j++) {
+                for (InternalValue defVal : defVals) {
-                        reqType = defVals[j].getType();
+                        reqType = defVal.getType();
-                        if (defVals[j].getType() != reqType) {
+                        if (defVal.getType() != reqType) {
-                    for (int j = 0; j < defVals.length; j++) {
+                    for (InternalValue defVal : defVals) {
-                        for (int k = 0; k < constraints.length; k++) {
+                        for (QValueConstraint constraint : constraints) {
-                                constraints[k].check(defVals[j]);
+                                constraint.check(defVal);
-                                continue;
-        for (int i = 0; i < cnda.length; i++) {
-            NodeDef cnd = cnda[i];
+        for (NodeDef cnd : cnda) {
-                        Stack definingNTs = new Stack();
+                        Stack<Name> definingNTs = new Stack<Name>();
-                for (int n = 0; n < reqTypes.length; n++) {
-                    Name rpt = reqTypes[n];
+                for (Name rpt : reqTypes) {
+     * @param ntName node type name
-        NodeTypeRegistryListener[] la =
-                (NodeTypeRegistryListener[]) listeners.values().toArray(
+        NodeTypeRegistryListener[] la = listeners.values().toArray(
-        for (int i = 0; i < la.length; i++) {
-            if (la[i] != null) {
-                la[i].nodeTypeRegistered(ntName);
+        for (NodeTypeRegistryListener aLa : la) {
+            if (aLa != null) {
+                aLa.nodeTypeRegistered(ntName);
+     * @param ntName node type name
-        NodeTypeRegistryListener[] la =
-                (NodeTypeRegistryListener[]) listeners.values().toArray(
+        NodeTypeRegistryListener[] la = listeners.values().toArray(
-        for (int i = 0; i < la.length; i++) {
-            if (la[i] != null) {
-                la[i].nodeTypeReRegistered(ntName);
+        for (NodeTypeRegistryListener aLa : la) {
+            if (aLa != null) {
+                aLa.nodeTypeReRegistered(ntName);
+     * @param ntName node type name
-        NodeTypeRegistryListener[] la =
-                (NodeTypeRegistryListener[]) listeners.values().toArray(
+        NodeTypeRegistryListener[] la = listeners.values().toArray(
-        for (int i = 0; i < la.length; i++) {
-            if (la[i] != null) {
-                la[i].nodeTypeUnregistered(ntName);
+        for (NodeTypeRegistryListener aLa : la) {
+            if (aLa != null) {
+                aLa.nodeTypeUnregistered(ntName);

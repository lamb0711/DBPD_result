work in progress

- Restore: pass NodeState(s) and Path instead of NodeId(s)
- LockManager: make sure lockmanager only remembers workspace states
- LockManager: make sure operations are executed using workspace states
- LockManager: improve isLocked/getLock/checkIsLocked and respect locks that
have been accessed before.
- VersionManager: make sure operations are executed using workspace states
- VersionManager: add checkIsCheckedOut
- VersionManager: force manager to have a WorkspaceManager
- NodeReferences:
  > make interface package protected
  > clarify method naming
  > add implementation to WorkspaceItemStateFactory
  > add NodeReferences field to NodeState
  > TO_IMPROVE: references are currently always retrieve from the SPI.
- ItemStateManager + NodeReferences
  > rename interfaces methods
  > change method signature to take NodeState instead of NodeId
  > 'getReferences' returns the property states directly

- remove some JR DIFFs. 

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@432234 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.state.NodeReferences;
-            if (itemStateMgr.hasNodeReferences(getNodeId())) {
-                NodeReferences refs = itemStateMgr.getNodeReferences(getNodeId());
-                // refs.getReferences() returns a list of Property states
-                Collection refStates = refs.getReferences();
+            if (itemStateMgr.hasReferingStates(getNodeState())) {
+                Collection refStates = itemStateMgr.getReferingStates(getNodeState());
-            throw new RepositoryException("Incompatible Version object :" + version);
+            throw new RepositoryException("Incompatible Version object: " + version.getPath());
-        checkIsWritable();
-        checkIsVersionable();
-        checkIsLocked();
-        restore(getNodeId(), version, removeExisting);
+        restore(this, null, version, removeExisting);
+
-            // node at 'relPath' exists -> call restore on that node
+            // node at 'relPath' exists -> call restore on the target Node
-            NodeId nId;
-                // If the would-be parent of the location relPath is actually a
-                // property, or if a node type restriction would be violated,
-                // then a ConstraintViolationException is thrown.
-                        NodeId parentId = ((NodeImpl)parent).getNodeId();
-                        nId = session.getIdFactory().createNodeId(parentId, relQPath);
+                        NodeImpl parentNode = ((NodeImpl)parent);
+                        // call the restore
+                        restore(parentNode, relQPath, version, removeExisting);
+                    // the item at parentParentPath is Property
-            restore(nId, version, removeExisting);
+     * @see Node#restoreByLabel(String, boolean)
+     */
+    public void restoreByLabel(String versionLabel, boolean removeExisting) throws VersionException, ItemExistsException, UnsupportedRepositoryOperationException, LockException, InvalidItemStateException, RepositoryException {
+        checkSupportedOption(Repository.OPTION_VERSIONING_SUPPORTED);
+        checkSessionHasPendingChanges();
+
+        // check for version-enabled and lock are performed with subsequent calls.
+        Version v = getVersionHistory().getVersionByLabel(versionLabel);
+        if (v == null) {
+            throw new VersionException("No version for label " + versionLabel + " found.");
+        }
+        restore(this, null, v, removeExisting);
+    }
+
+    /**
-     * @param nodeId
+     * @param targetNode
+     * @param relQPath
-    private void restore(NodeId nodeId, Version version, boolean removeExisting) throws PathNotFoundException, ItemExistsException, VersionException, ConstraintViolationException, UnsupportedRepositoryOperationException, LockException, InvalidItemStateException, RepositoryException {
-        if (version instanceof VersionImpl) {
-            NodeId versionId = ((NodeImpl)version).getNodeId();
-            session.getVersionManager().restore(nodeId, versionId, removeExisting);
-        } else {
-            throw new RepositoryException("Unexpected error: Failed to retrieve a valid ID for the given version " + version.getPath());
-        }
-    }
+    private void restore(NodeImpl targetNode, Path relQPath, Version version, boolean removeExisting) throws PathNotFoundException, ItemExistsException, VersionException, ConstraintViolationException, UnsupportedRepositoryOperationException, LockException, InvalidItemStateException, RepositoryException {
+        targetNode.checkIsWritable();
+        targetNode.checkIsLocked();
-    /**
-     * @see Node#restoreByLabel(String, boolean)
-     */
-    public void restoreByLabel(String versionLabel, boolean removeExisting) throws VersionException, ItemExistsException, UnsupportedRepositoryOperationException, LockException, InvalidItemStateException, RepositoryException {
-        checkSupportedOption(Repository.OPTION_VERSIONING_SUPPORTED);
-        checkSessionHasPendingChanges();
-        // check for version-enabled and lock are performed with subsequent calls.
-        Version v = getVersionHistory().getVersionByLabel(versionLabel);
-        if (v == null) {
-            throw new VersionException("No version for label " + versionLabel + " found.");
+
+        if (relQPath == null) {
+            /* restore target already exists. */
+            // target must be versionable
+            targetNode.checkIsVersionable();
+
+            VersionHistory vH = targetNode.getVersionHistory();
+            // version must be a version of the target node
+            if (!vH.isSame(version.getContainingHistory())) {
+                throw new VersionException("Version " + version + " does not correspond to the restore target.");
+            }
+            // version must not be the root version
+            if (vH.getRootVersion().isSame(version)) {
+                throw new VersionException("Attempt to restore root version.");
+            }
+        } else {
+            /* If no node exists at relPath then a VersionException is thrown if
+               the parent node is not checked out. */
+            if (!targetNode.isCheckedOut()) {
+                throw new VersionException("Parent " + targetNode.safeGetJCRPath()
+                    + " for non-existing restore target '"
+                    + LogUtil.safeGetJCRPath(relQPath, session.getNamespaceResolver())
+                    + "' must be checked out.");
+            }
+            // NOTE: check for nodetype constraint violation is left to the 'server'
-        restore(getNodeId(), v, removeExisting);
+
+        if (version instanceof VersionImpl) {
+            NodeState versionState = ((NodeImpl)version).getNodeState();
+            session.getVersionManager().restore(targetNode.getNodeState(), relQPath, versionState, removeExisting);
+        } else {
+            throw new RepositoryException("Incompatible Version object: " + version.getPath());
+        }

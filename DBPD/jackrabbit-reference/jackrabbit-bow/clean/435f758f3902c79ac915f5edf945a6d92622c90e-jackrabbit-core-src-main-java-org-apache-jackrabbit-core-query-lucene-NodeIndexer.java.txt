JCR-415: Enhance indexing of binary content
- Use text-extractor module in jackrabbit-core

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@489000 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.query.TextFilter;
+import org.apache.jackrabbit.core.value.BLOBFileValue;
+import org.apache.jackrabbit.extractor.TextExtractor;
+
+import java.io.InputStream;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-     * List of text filters in use.
+     * Content extractor.
-    protected final List textFilters;
+    protected final TextExtractor extractor;
-     * @param textFilters   List of {@link org.apache.jackrabbit.core.query.TextFilter}s.
+     * @param extractor     content extractor
-                          List textFilters) {
+                          TextExtractor extractor) {
-        this.textFilters = textFilters;
+        this.extractor = extractor;
-     * @param textFilters   list of text filters to use for indexing binary
-     *                      properties.
+     * @param extractor     text extractor
-                                          List textFilters)
+                                          TextExtractor extractor)
-        NodeIndexer indexer = new NodeIndexer(node, stateProvider, mappings, textFilters);
+        NodeIndexer indexer = new NodeIndexer(node, stateProvider, mappings, extractor);
-     * and if that is the case, tries to extract text from the data atom using
-     * the {@link #textFilters}.
+     * and if that is the case, tries to extract text from the binary property
+     * using the {@link #extractor}.
-    protected void addBinaryValue(Document doc, String fieldName, Object internalValue) {
+    protected void addBinaryValue(Document doc,
+                                  String fieldName,
+                                  Object internalValue) {
-            if (node.hasPropertyName(QName.JCR_MIMETYPE)) {
-                PropertyState dataProp = (PropertyState) stateProvider.getItemState(
-                        new PropertyId(node.getNodeId(), QName.JCR_DATA));
-                PropertyState mimeTypeProp =
-                        (PropertyState) stateProvider.getItemState(
-                                new PropertyId(node.getNodeId(), QName.JCR_MIMETYPE));
+
+            InternalValue typeValue = getValue(QName.JCR_MIMETYPE);
+            if (typeValue != null) {
+                String type = typeValue.internalValue().toString();
-                if (node.hasPropertyName(QName.JCR_ENCODING)) {
-                    PropertyState encodingProp =
-                            (PropertyState) stateProvider.getItemState(
-                                    new PropertyId(node.getNodeId(), QName.JCR_ENCODING));
-                    encoding = encodingProp.getValues()[0].internalValue().toString();
+                InternalValue encodingValue = getValue(QName.JCR_ENCODING);
+                if (encodingValue != null) {
+                    encoding = encodingValue.internalValue().toString();
-                String mimeType = mimeTypeProp.getValues()[0].internalValue().toString();
-                Map fields = Collections.EMPTY_MAP;
-                for (Iterator it = textFilters.iterator(); it.hasNext();) {
-                    TextFilter filter = (TextFilter) it.next();
-                    // use the first filter that can handle the mimeType
-                    if (filter.canFilter(mimeType)) {
-                        fields = filter.doFilter(dataProp, encoding);
-                        break;
-                    }
-                }
-
-                for (Iterator it = fields.keySet().iterator(); it.hasNext();) {
-                    String field = (String) it.next();
-                    Reader r = (Reader) fields.get(field);
-                    doc.add(new Field(field, r));
-                }
+                InputStream stream =
+                        ((BLOBFileValue) internalValue).getStream();
+                Reader reader =
+                        new TextExtractorReader(extractor, stream, type, encoding);
+                doc.add(new Field(FieldNames.FULLTEXT, reader));
+     * Utility method that extracts the first value of the named property
+     * of the current node. Returns <code>null</code> if the property does
+     * not exist or contains no values.
+     *
+     * @param name property name
+     * @return value of the named property, or <code>null</code>
+     * @throws ItemStateException if the property can not be accessed
+     */
+    protected InternalValue getValue(QName name) throws ItemStateException {
+        try {
+            PropertyId id = new PropertyId(node.getNodeId(), name);
+            PropertyState property =
+                (PropertyState) stateProvider.getItemState(id);
+            InternalValue[] values = property.getValues();
+            if (values.length > 0) {
+                return values[0];
+            } else {
+                return null;
+            }
+        } catch (NoSuchItemStateException e) {
+            return null;
+        }
+    }
+
+    /**

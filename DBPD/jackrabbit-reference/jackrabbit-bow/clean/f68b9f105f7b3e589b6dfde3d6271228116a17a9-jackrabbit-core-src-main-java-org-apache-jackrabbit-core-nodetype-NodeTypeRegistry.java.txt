JCR-2066 NodeTypeRegistry could auto-subtype from nt:base


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@786319 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Arrays;
+import java.util.TreeSet;
+        checkNtBaseSubtyping(ntd, registeredNTDefs);
+        checkNtBaseSubtyping(ntd, registeredNTDefs);
-        // create working copies of current ent & ntd caches:
-        // cache of pre-built aggregations of node types
-        EffectiveNodeTypeCache tmpENTCache = (EffectiveNodeTypeCache) entCache.clone();
+        // check if all node type defs have proper nt:base subtyping
+        for (NodeTypeDef ntd : ntDefs) {
+            checkNtBaseSubtyping(ntd, tmpNTDefCache);
+        }
+
+        // create working copies of current ent & ntd caches:
+        // cache of pre-built aggregations of node types
+        EffectiveNodeTypeCache tmpENTCache = (EffectiveNodeTypeCache) entCache.clone();
+     * Checks if the given node type def has the correct supertypes in respect
+     * to nt:base. all mixin nodetypes must not have a nt:base, the primary
+     * ones only if they don't inherit it from another supertype.
+     *
+     * @param ntd the node type def to check
+     * @param ntdCache cache for lookup
+     * @return <code>true</code> if the ntd was modified
+     */
+    private static boolean checkNtBaseSubtyping(NodeTypeDef ntd, Map<Name, NodeTypeDef> ntdCache) {
+        if (NameConstants.NT_BASE.equals(ntd.getName())) {
+            return false;
+        }
+        Set<Name> supertypes = new TreeSet<Name>(Arrays.asList(ntd.getSupertypes()));
+        if (supertypes.isEmpty()) {
+            return false;
+        }
+        boolean modified;
+        if (ntd.isMixin()) {
+            // if mixin, remove possible nt:base supertype
+            modified = supertypes.remove(NameConstants.NT_BASE);
+        } else {
+            // check if all supertypes (except nt:base) are mixins
+            boolean allMixins = true;
+            for (Name name: supertypes) {
+                if (!name.equals(NameConstants.NT_BASE)) {
+                    NodeTypeDef def = ntdCache.get(name);
+                    if (def != null && !def.isMixin()) {
+                        allMixins = false;
+                        break;
+                    }
+                }
+            }
+            if (allMixins) {
+                // ntd is a primary node type and has only mixins as supertypes,
+                // so it needs a nt:base
+                modified = supertypes.add(NameConstants.NT_BASE);
+            } else {
+                // ntd is a primary node type and at least one of the supertypes
+                // is too, so ensure that no nt:base is added. note that the
+                // trivial case, where there would be no supertype left is handled
+                // in the NodeTypeDef directly
+                modified = supertypes.remove(NameConstants.NT_BASE);
+            }
+        }
+        if (modified) {
+            ntd.setSupertypes(supertypes.toArray(new Name[supertypes.size()]));
+        }
+        return modified;
+    }
+
+    /**
-                // make sure that all primary types except nt:base extend from nt:base
-                if (!ntd.isMixin() && !NameConstants.NT_BASE.equals(ntd.getName())
-                        && !est.includesNodeType(NameConstants.NT_BASE)) {
-                    // auto-subtype from nt:base
-                    Name[] s = new Name[supertypes.length + 1];
-                    System.arraycopy(supertypes, 0 ,s, 1, supertypes.length);
-                    s[0] = NameConstants.NT_BASE;
-                    supertypes = s;
-                    ntd.setSupertypes(s);
-                }
+                    // skip nt:base required types
+                    if (NameConstants.NT_BASE.equals(rpt)) {
+                        continue;
+                    }

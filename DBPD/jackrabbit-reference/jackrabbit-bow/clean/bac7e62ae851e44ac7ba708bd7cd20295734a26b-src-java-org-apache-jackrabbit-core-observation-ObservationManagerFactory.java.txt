- Redesigned observation to also include workspace modifications
- Extended observation tests and moved them into the api.observation package

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@155583 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.*;
-import org.apache.jackrabbit.core.nodetype.NodeTypeImpl;
-import org.apache.jackrabbit.core.nodetype.NodeTypeManagerImpl;
-import org.apache.jackrabbit.core.state.ItemStateManager;
+import org.apache.jackrabbit.core.SessionImpl;
+import org.apache.jackrabbit.core.HierarchyManager;
+import org.apache.jackrabbit.core.ItemManager;
-import javax.jcr.RepositoryException;
-import javax.jcr.observation.EventListener;
-import javax.jcr.observation.EventListenerIterator;
-import javax.jcr.observation.ObservationManager;
-    private Set getAsynchronousConsumers() {
+    Set getAsynchronousConsumers() {
-    private Set getSynchronousConsumers() {
+    Set getSynchronousConsumers() {
-    public ObservationManager createObservationManager(SessionImpl session,
-                                                       ItemManager itemMgr) {
-        return new SessionLocalObservationManager(session, itemMgr);
-    }
-
-    public EventStateCollection createEventStateCollection(SessionImpl session,
-                                                           ItemStateManager provider,
-                                                           HierarchyManager hmgr) {
-        return new EventStateCollection(this, session, provider, hmgr);
+    public ObservationManagerImpl createObservationManager(SessionImpl session,
+                                                           HierarchyManager hmgr,
+                                                           ItemManager itemMgr) {
+        return new ObservationManagerImpl(this, session, hmgr, itemMgr);
-    void prepareEvents(EventStateCollection events)
-            throws RepositoryException {
+    void prepareEvents(EventStateCollection events) {
-    //----------------------------< adapter class >-----------------------------
-
-     * Each <code>Session</code> instance has its own <code>ObservationManager</code>
-     * instance. The class <code>SessionLocalObservationManager</code> implements
-     * this behaviour.
+     * Adds or replaces an event consumer.
+     * @param consumer the <code>EventConsumer</code> to add or replace.
-    class SessionLocalObservationManager implements ObservationManager {
-
-        /**
-         * The <code>Session</code> this <code>ObservationManager</code>
-         * belongs to.
-         */
-        private SessionImpl session;
-
-        /**
-         * The <code>ItemManager</code> for this <code>ObservationManager</code>.
-         */
-        private ItemManager itemMgr;
-
-        /**
-         * Creates an <code>ObservationManager</code> instance.
-         *
-         * @param session the <code>Session</code> this ObservationManager
-         *                belongs to.
-         * @param itemMgr {@link org.apache.jackrabbit.core.ItemManager} of the passed
-         *                <code>Session</code>.
-         * @throws NullPointerException if <code>session</code> or <code>itemMgr</code>
-         *                              is <code>null</code>.
-         */
-        SessionLocalObservationManager(SessionImpl session,
-                                       ItemManager itemMgr) {
-            if (session == null) {
-                throw new NullPointerException("session");
-            }
-            if (itemMgr == null) {
-                throw new NullPointerException("itemMgr");
-            }
-
-            this.session = session;
-            this.itemMgr = itemMgr;
-        }
-
-        /**
-         * @see ObservationManager#addEventListener
-         */
-        public void addEventListener(EventListener listener,
-                                     int eventTypes,
-                                     String absPath,
-                                     boolean isDeep,
-                                     String[] uuid,
-                                     String[] nodeTypeName,
-                                     boolean noLocal)
-                throws RepositoryException {
-
-            // create NodeType instances from names
-            NodeTypeImpl[] nodeTypes;
-            if (nodeTypeName == null) {
-                nodeTypes = null;
+    void addConsumer(EventConsumer consumer) {
+        synchronized (consumerChange) {
+            if (consumer.getEventListener() instanceof SynchronousEventListener) {
+                // remove existing if any
+                synchronousConsumers.remove(consumer);
+                // re-add it
+                synchronousConsumers.add(consumer);
+                // reset read only consumer set
+                synchronousReadOnlyConsumers = null;
-                NodeTypeManagerImpl ntMgr = session.getNodeTypeManager();
-                nodeTypes = new NodeTypeImpl[nodeTypeName.length];
-                for (int i = 0; i < nodeTypes.length; i++) {
-                    nodeTypes[i] = (NodeTypeImpl) ntMgr.getNodeType(nodeTypeName[i]);
-                }
+                // remove existing if any
+                activeConsumers.remove(consumer);
+                // re-add it
+                activeConsumers.add(consumer);
+                // reset read only consumer set
+                readOnlyConsumers = null;
-
-            Path path;
-            try {
-                path = Path.create(absPath, session.getNamespaceResolver(), true);
-            } catch (MalformedPathException mpe) {
-                String msg = "invalid path syntax: " + absPath;
-                log.debug(msg);
-                throw new RepositoryException(msg, mpe);
-            }
-            // create filter
-            EventFilter filter = new EventFilter(itemMgr,
-                    session,
-                    eventTypes,
-                    path,
-                    isDeep,
-                    uuid,
-                    nodeTypes,
-                    noLocal);
-
-            EventConsumer consumer =
-                    new EventConsumer(session, listener, filter);
-
-            synchronized (consumerChange) {
-                if (listener instanceof SynchronousEventListener) {
-                    // remove existing if any
-                    synchronousConsumers.remove(consumer);
-                    // re-add it
-                    synchronousConsumers.add(consumer);
-                    // reset read only consumer set
-                    synchronousReadOnlyConsumers = null;
-                } else {
-                    // remove existing if any
-                    activeConsumers.remove(consumer);
-                    // re-add it
-                    activeConsumers.add(consumer);
-                    // reset read only consumer set
-                    readOnlyConsumers = null;
-                }
-            }
-        }
-
-        /**
-         * @see ObservationManager#removeEventListener(javax.jcr.observation.EventListener)
-         */
-        public void removeEventListener(EventListener listener)
-                throws RepositoryException {
-            EventConsumer consumer =
-                    new EventConsumer(session, listener, EventFilter.BLOCK_ALL);
-
-            synchronized (consumerChange) {
-                if (listener instanceof SynchronousEventListener) {
-                    synchronousConsumers.remove(consumer);
-                    // reset read only listener set
-                    synchronousReadOnlyConsumers = null;
-                } else {
-                    activeConsumers.remove(consumer);
-                    // reset read only listener set
-                    readOnlyConsumers = null;
-                }
-            }
-        }
-
-        /**
-         * @see ObservationManager#getRegisteredEventListeners()
-         */
-        public EventListenerIterator getRegisteredEventListeners()
-                throws RepositoryException {
-            return new EventListenerIteratorImpl(session,
-                    getSynchronousConsumers(),
-                    getAsynchronousConsumers());
+
+    /**
+     * Unregisters an event consumer from event notification.
+     * @param consumer the consumer to deregister.
+     */
+    void removeConsumer(EventConsumer consumer) {
+        synchronized (consumerChange) {
+            if (consumer.getEventListener() instanceof SynchronousEventListener) {
+                synchronousConsumers.remove(consumer);
+                // reset read only listener set
+                synchronousReadOnlyConsumers = null;
+            } else {
+                activeConsumers.remove(consumer);
+                // reset read only listener set
+                readOnlyConsumers = null;
+            }
+        }
+    }
+

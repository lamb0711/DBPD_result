JCR-3275: Audit log
- add log on external update

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1329195 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.SessionImpl;
+import org.apache.jackrabbit.spi.commons.conversion.CachingPathResolver;
+import org.apache.jackrabbit.spi.commons.conversion.IllegalNameException;
+import org.apache.jackrabbit.spi.commons.conversion.NameResolver;
+import org.apache.jackrabbit.spi.commons.conversion.ParsingPathResolver;
+import org.apache.jackrabbit.spi.commons.conversion.PathResolver;
+import org.apache.jackrabbit.spi.commons.name.PathFactoryImpl;
+
+import javax.jcr.NamespaceException;
+import java.util.List;
+     * The caching path resolver.
+     */
+    private static CachingPathResolver cachingPathResolver;
+
+    /**
+
+    /**
+     * Get the longest common path of all event state paths.
+     *
+     * @param events The list of EventState
+     * @param session The associated session; it can be null
+     * @return the longest common path
+     */
+    public static String getCommonPath(List<EventState> events, SessionImpl session) {
+        String common = null;
+        try {
+            for (int i = 0; i < events.size(); i++) {
+                EventState state = events.get(i);
+                Path parentPath = state.getParentPath();
+                String s;
+                if (session == null) {
+                    s = getJCRPath(parentPath);
+                } else {
+                    s = session.getJCRPath(parentPath);
+                }
+
+                if (common == null) {
+                    common = s;
+                } else if (!common.equals(s)) {
+
+                    // Assign the shorter path to common.
+                    if (s.length() < common.length()) {
+                        String temp = common;
+                        common = s;
+                        s = temp;
+                    }
+
+                    // Find the real common.
+                    while (!s.startsWith(common)) {
+                        int idx = s.lastIndexOf('/');
+                        if (idx < 0) {
+                            break;
+                        }
+                        common = s.substring(0, idx + 1);
+                    }
+                }
+            }
+        } catch (NamespaceException e) {
+            log.debug("Problem in retrieving JCR path", e);
+        }
+        return common;
+    }
+
+    private static String getJCRPath(Path path) {
+ 
+        setupCachingPathResolver();
+
+        String jcrPath;
+        try {
+            jcrPath = cachingPathResolver.getJCRPath(path);
+        } catch (NamespaceException e) {
+            jcrPath = "";
+            log.debug("Problem in retrieving JCR path", e);
+        }
+        return jcrPath;
+    }
+
+    private static void setupCachingPathResolver() {
+        if (cachingPathResolver != null) {
+            return;
+        }
+
+        PathResolver pathResolver = new ParsingPathResolver(PathFactoryImpl.getInstance(), new NameResolver() {
+            public Name getQName(String name) throws IllegalNameException, NamespaceException {
+                return null;
+            }
+
+            public String getJCRName(Name name) throws NamespaceException {
+                return name.getLocalName();
+            }
+        });
+
+        cachingPathResolver = new CachingPathResolver(pathResolver);
+    }

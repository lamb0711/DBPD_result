fixed bug JCR-124: Session.import() fails to resolve proper property definition in some cases


git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@178206 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.value.InternalValue;
+import org.apache.jackrabbit.core.value.InternalValue;
-                                + name + "' in node type '" + ntName + "'";
+                                    + name + "' in node type '" + ntName + "'";
-                                + name + "' in node type '" + ntName + "'";
+                                    + name + "' in node type '" + ntName + "'";
+        if (namedItemDefs.size() == 0 && unnamedItemDefs.size() == 0) {
+            return ItemDef.EMPTY_ARRAY;
+        }
+        if (defs.size() == 0) {
+            return ItemDef.EMPTY_ARRAY;
+        }
+        if (namedItemDefs.size() == 0) {
+            return ItemDef.EMPTY_ARRAY;
+        }
+        if (defs.size() == 0) {
+            return ItemDef.EMPTY_ARRAY;
+        }
+        if (unnamedItemDefs.size() == 0) {
+            return ItemDef.EMPTY_ARRAY;
+        }
-        if (defs == null) {
-            return null;
+        if (defs == null || defs.size() == 0) {
+            return ItemDef.EMPTY_ARRAY;
+        if (namedItemDefs.size() == 0 && unnamedItemDefs.size() == 0) {
+            return NodeDef.EMPTY_ARRAY;
+        }
+        if (defs.size() == 0) {
+            return NodeDef.EMPTY_ARRAY;
+        }
+        if (namedItemDefs.size() == 0) {
+            return NodeDef.EMPTY_ARRAY;
+        }
+        if (defs.size() == 0) {
+            return NodeDef.EMPTY_ARRAY;
+        }
+        return (NodeDef[]) defs.toArray(new NodeDef[defs.size()]);
+    }
+
+    public NodeDef[] getNamedNodeDefs(QName name) {
+        List list = (List) namedItemDefs.get(name);
+        if (list == null || list.size() == 0) {
+            return NodeDef.EMPTY_ARRAY;
+        }
+        ArrayList defs = new ArrayList(list.size());
+        Iterator iter = list.iterator();
+        while (iter.hasNext()) {
+            ItemDef def = (ItemDef) iter.next();
+            if (def.definesNode()) {
+                defs.add(def);
+            }
+        }
+        if (defs.size() == 0) {
+            return NodeDef.EMPTY_ARRAY;
+        }
+        if (unnamedItemDefs.size() == 0) {
+            return NodeDef.EMPTY_ARRAY;
+        }
+        if (defs.size() == 0) {
+            return NodeDef.EMPTY_ARRAY;
+        }
+        if (namedItemDefs.size() == 0) {
+            return NodeDef.EMPTY_ARRAY;
+        }
+        if (defs.size() == 0) {
+            return NodeDef.EMPTY_ARRAY;
+        }
+        if (namedItemDefs.size() == 0 && unnamedItemDefs.size() == 0) {
+            return PropDef.EMPTY_ARRAY;
+        }
+        if (defs.size() == 0) {
+            return PropDef.EMPTY_ARRAY;
+        }
+        if (namedItemDefs.size() == 0) {
+            return PropDef.EMPTY_ARRAY;
+        }
+        if (defs.size() == 0) {
+            return PropDef.EMPTY_ARRAY;
+        }
+        return (PropDef[]) defs.toArray(new PropDef[defs.size()]);
+    }
+
+    public PropDef[] getNamedPropDefs(QName name) {
+        List list = (List) namedItemDefs.get(name);
+        if (list == null || list.size() == 0) {
+            return PropDef.EMPTY_ARRAY;
+        }
+        ArrayList defs = new ArrayList(list.size());
+        Iterator iter = list.iterator();
+        while (iter.hasNext()) {
+            ItemDef def = (ItemDef) iter.next();
+            if (!def.definesNode()) {
+                defs.add(def);
+            }
+        }
+        if (defs.size() == 0) {
+            return PropDef.EMPTY_ARRAY;
+        }
+        if (unnamedItemDefs.size() == 0) {
+            return PropDef.EMPTY_ARRAY;
+        }
+        if (defs.size() == 0) {
+            return PropDef.EMPTY_ARRAY;
+        }
+        if (namedItemDefs.size() == 0) {
+            return PropDef.EMPTY_ARRAY;
+        }
+        if (defs.size() == 0) {
+            return PropDef.EMPTY_ARRAY;
+        }
+        if (namedItemDefs.size() == 0) {
+            return PropDef.EMPTY_ARRAY;
+        }
+        if (defs.size() == 0) {
+            return PropDef.EMPTY_ARRAY;
+        }
+        if (namedItemDefs.size() == 0) {
+            return NodeDef.EMPTY_ARRAY;
+        }
+        if (defs.size() == 0) {
+            return NodeDef.EMPTY_ARRAY;
+        }
-     * specified name, type and multiValued characteristic.
+     * specified name, type and multiValued characteristic. If there more than
+     * one applicable definitions then the following rules are applied:
+     * <ul>
+     * <li>named definitions are preferred to residual definitions</li>
+     * <li>definitions with specific required type are preferred to definitions
+     * with required type UNDEFINED</li>
+     * </ul>
-        ItemDef[] defs = getNamedItemDefs(name);
-        if (defs != null) {
-            for (int i = 0; i < defs.length; i++) {
-                ItemDef def = defs[i];
-                if (!def.definesNode()) {
-                    PropDef pd = (PropDef) def;
-                    int reqType = pd.getRequiredType();
-                    // property definition with that name exists
-                    // match type
-                    if (reqType == PropertyType.UNDEFINED
-                            || type == PropertyType.UNDEFINED
-                            || reqType == type) {
-                        // match multiValued flag
-                        if (multiValued == pd.isMultiple()) {
-                            // found match
+        PropDef match =
+                getMatchingPropDef(getNamedPropDefs(name), type, multiValued);
+        if (match != null) {
+            return match;
+        }
+
+        // no item with that name defined;
+        // try residual property definitions
+        match = getMatchingPropDef(getUnnamedPropDefs(), type, multiValued);
+        if (match != null) {
+            return match;
+        }
+
+        // no applicable definition found
+        throw new ConstraintViolationException("no matching property definition found for " + name);
+    }
+
+    /**
+     * Returns the applicable property definition for a property with the
+     * specified name and type. The multiValued flag is not taken into account
+     * in the selection algorithm. Other than
+     * <code>{@link #getApplicablePropertyDef(QName, int, boolean)}</code>
+     * this method does not take the multiValued flag into account in the
+     * selection algorithm. If there more than one applicable definitions then
+     * the following rules are applied:
+     * <ul>
+     * <li>named definitions are preferred to residual definitions</li>
+     * <li>definitions with specific required type are preferred to definitions
+     * with required type UNDEFINED</li>
+     * <li>single-value definitions are preferred to multiple-value definitions</li>
+     * </ul>
+     *
+     * @param name
+     * @param type
+     * @return
+     * @throws ConstraintViolationException if no applicable property definition
+     *                                      could be found
+     */
+    public PropDef getApplicablePropertyDef(QName name, int type)
+            throws ConstraintViolationException {
+        // try named property definitions first
+        PropDef match = getMatchingPropDef(getNamedPropDefs(name), type);
+        if (match != null) {
+            return match;
+        }
+
+        // no item with that name defined;
+        // try residual property definitions
+        match = getMatchingPropDef(getUnnamedPropDefs(), type);
+        if (match != null) {
+            return match;
+        }
+
+        // no applicable definition found
+        throw new ConstraintViolationException("no matching property definition found for " + name);
+    }
+
+    private PropDef getMatchingPropDef(PropDef[] defs, int type) {
+        PropDef match = null;
+        for (int i = 0; i < defs.length; i++) {
+            ItemDef def = defs[i];
+            if (!def.definesNode()) {
+                PropDef pd = (PropDef) def;
+                int reqType = pd.getRequiredType();
+                // match type
+                if (reqType == PropertyType.UNDEFINED
+                        || type == PropertyType.UNDEFINED
+                        || reqType == type) {
+                    if (match == null) {
+                        match = pd;
+                    } else {
+                        // check if this definition is a better match than
+                        // the one we've already got
+                        if (match.getRequiredType() != pd.getRequiredType()) {
+                            if (match.getRequiredType() == PropertyType.UNDEFINED) {
+                                // found better match
+                                match = pd;
+                            }
+                        } else {
+                            if (match.isMultiple() && !pd.isMultiple()) {
+                                // found better match
+                                match = pd;
+                            }
+                        }
+                    }
+                    if (match.getRequiredType() != PropertyType.UNDEFINED
+                            && !match.isMultiple()) {
+                        // found best possible match, get outta here
+                        return match;
+                    }
+                }
+            }
+        }
+        return match;
+    }
+
+    private PropDef getMatchingPropDef(PropDef[] defs, int type,
+                                       boolean multiValued) {
+        PropDef match = null;
+        for (int i = 0; i < defs.length; i++) {
+            ItemDef def = defs[i];
+            if (!def.definesNode()) {
+                PropDef pd = (PropDef) def;
+                int reqType = pd.getRequiredType();
+                // match type
+                if (reqType == PropertyType.UNDEFINED
+                        || type == PropertyType.UNDEFINED
+                        || reqType == type) {
+                    // match multiValued flag
+                    if (multiValued == pd.isMultiple()) {
+                        // found match
+                        if (pd.getRequiredType() != PropertyType.UNDEFINED) {
+                            // found best possible match, get outta here
+                        } else {
+                            if (match == null) {
+                                match = pd;
+                            }
-
-        // no item with that name defined;
-        // try residual property definitions
-        PropDef[] pda = getUnnamedPropDefs();
-        for (int i = 0; i < pda.length; i++) {
-            PropDef pd = pda[i];
-            int reqType = pd.getRequiredType();
-            // match type
-            if (reqType == PropertyType.UNDEFINED
-                    || type == PropertyType.UNDEFINED
-                    || reqType == type) {
-                // match multiValued flag
-                if (multiValued == pd.isMultiple()) {
-                    // found match
-                    return pd;
-                }
-            }
-        }
-
-        // no applicable definition found
-        throw new ConstraintViolationException("no matching property definition found for " + name);
+        return match;

JCR-1590: JSR 283: Locking

More code cleanup: Inline LockToken into LockInfo and make LockInfo member variables private.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@803535 13f79535-47bb-0310-9956-ffa450edef68

-     * Lock token
+     * Lock holder node id. Used also as the lock token.
-    protected final LockToken lockToken;
+    private final NodeId id;
-    protected final boolean sessionScoped;
+    private final boolean sessionScoped;
-    protected final boolean deep;
+    private final boolean deep;
-    protected final String lockOwner;
+    private final String lockOwner;
-     * @param lockToken     lock token
-     * @param sessionScoped whether lock token is session scoped
-     * @param deep          whether lock is deep
-     * @param lockOwner     owner of lock
-     */
-    protected LockInfo(LockToken lockToken, boolean sessionScoped, boolean deep,
-                    String lockOwner) {
-        this(lockToken, sessionScoped, deep, lockOwner, TIMEOUT_INFINITE);
-    }
-
-    /**
-     * Create a new instance of this class.
-     *
-     * @param lockToken     lock token
+     * @param id            lock holder node id
-    protected LockInfo(LockToken lockToken, boolean sessionScoped, boolean deep,
-                            String lockOwner, long timeoutHint) {
-        this.lockToken = lockToken;
+    protected LockInfo(
+            NodeId id, boolean sessionScoped, boolean deep,
+            String lockOwner, long timeoutHint) {
+        this.id = id;
-    public LockToken getLockToken() {
-        return lockToken;
+    public String getLockToken() {
+        String uuid = id.toString();
+        return uuid + "-" + getLockTokenCheckDigit(uuid);
-        return lockToken.getId();
+        return id;
+    /**
+     * Parse a lock token string representation and return the lock
+     * holder node id.
+     *
+     * @param token string representation of lock token
+     * @return lock holder node id
+     * @throws IllegalArgumentException if some field is illegal
+     */
+    public static NodeId parseLockToken(String token)
+            throws IllegalArgumentException {
+        int sep = token.lastIndexOf('-');
+        if (sep == -1 || sep == token.length() - 1) {
+            throw new IllegalArgumentException("Separator not found.");
+        }
+        String uuid = token.substring(0, sep);
+        if (getLockTokenCheckDigit(uuid) != token.charAt(token.length() - 1)) {
+            throw new IllegalArgumentException("Bad check digit.");
+        }
+        return NodeId.valueOf(uuid);
+    }
+
+    /**
+     * Return the check digit for a lock token, given by its UUID
+     * @param uuid uuid
+     * @return check digit
+     */
+    private static char getLockTokenCheckDigit(String uuid) {
+        int result = 0;
+
+        int multiplier = 36;
+        for (int i = 0; i < uuid.length(); i++) {
+            char c = uuid.charAt(i);
+            if (c >= '0' && c <= '9') {
+                int num = c - '0';
+                result += multiplier * num;
+                multiplier--;
+            } else if (c >= 'A' && c <= 'F') {
+                int num = c - 'A' + 10;
+                result += multiplier * num;
+                multiplier--;
+            } else if (c >= 'a' && c <= 'f') {
+                int num = c - 'a' + 10;
+                result += multiplier * num;
+                multiplier--;
+            }
+        }
+
+        int rem = result % 37;
+        if (rem != 0) {
+            rem = 37 - rem;
+        }
+        if (rem >= 0 && rem <= 9) {
+            return (char) ('0' + rem);
+        } else if (rem >= 10 && rem <= 35) {
+            return (char) ('A' + rem - 10);
+        } else {
+            return '+';
+        }
+    }
+

JCR-325: Applied the xml-refactoring.patch that puts the PropInfo instances in charge of applying the imported property values to content nodes.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@387961 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.nodetype.EffectiveNodeType;
-import org.apache.jackrabbit.core.nodetype.PropDef;
-import org.apache.jackrabbit.core.value.InternalValue;
-import org.apache.jackrabbit.name.NamespaceResolver;
-import org.apache.jackrabbit.value.ValueHelper;
-import javax.jcr.ValueFormatException;
-import java.io.IOException;
-import java.io.Reader;
+
-    public void startNode(NodeInfo nodeInfo, List propInfos,
-                          NamespaceResolver nsContext)
+    public void startNode(NodeInfo nodeInfo, List propInfos)
-            QName propName = pi.getName();
-            TextValue[] tva = pi.getValues();
-            int type = pi.getType();
-
-            // find applicable definition
-            EffectiveNodeType ent = node.getEffectiveNodeType();
-            PropDef def;
-            // multi- or single-valued property?
-            if (tva.length == 1) {
-                // could be single- or multi-valued (n == 1)
-                def = ent.getApplicablePropertyDef(propName, type);
-            } else {
-                // can only be multi-valued (n == 0 || n > 1)
-                def = ent.getApplicablePropertyDef(propName, type, true);
-            }
-
-            if (def.isProtected()) {
-                // skip protected property
-                log.debug("skipping protected property " + propName);
-                continue;
-            }
-
-            // convert serialized values to Value objects
-            Value[] va = new Value[tva.length];
-            int targetType = def.getRequiredType();
-            if (targetType == PropertyType.UNDEFINED) {
-                if (type == PropertyType.UNDEFINED) {
-                    targetType = PropertyType.STRING;
-                } else {
-                    targetType = type;
-                }
-            }
-            for (int i = 0; i < tva.length; i++) {
-                TextValue tv = tva[i];
-
-                if (targetType == PropertyType.NAME
-                        || targetType == PropertyType.PATH) {
-                    // NAME and PATH require special treatment because
-                    // they depend on the current namespace context
-                    // of the xml document
-
-                    // retrieve serialized value
-                    String serValue;
-                    try {
-                        serValue = tv.retrieve();
-                    } catch (IOException ioe) {
-                        String msg = "failed to retrieve serialized value";
-                        log.debug(msg, ioe);
-                        throw new RepositoryException(msg, ioe);
-                    }
-
-                    // convert serialized value to InternalValue using
-                    // current namespace context of xml document
-                    InternalValue ival =
-                            InternalValue.create(serValue, targetType, nsContext);
-                    // convert InternalValue to Value using this
-                    // session's namespace mappings
-                    va[i] = ival.toJCRValue(session.getNamespaceResolver());
-                } else if (targetType == PropertyType.BINARY) {
-                    try {
-                        if (tv.length() < 0x10000) {
-                            // < 65kb: deserialize BINARY type using String
-                            va[i] = ValueHelper.deserialize(tv.retrieve(), targetType, false);
-                        } else {
-                            // >= 65kb: deserialize BINARY type using Reader
-                            Reader reader = tv.reader();
-                            try {
-                                va[i] = ValueHelper.deserialize(reader, targetType, false);
-                            } finally {
-                                reader.close();
-                            }
-                        }
-                    } catch (IOException ioe) {
-                        String msg = "failed to deserialize binary value";
-                        log.debug(msg, ioe);
-                        throw new RepositoryException(msg, ioe);
-                    }
-                } else {
-                    // all other types
-
-                    // retrieve serialized value
-                    String serValue;
-                    try {
-                        serValue = tv.retrieve();
-                    } catch (IOException ioe) {
-                        String msg = "failed to retrieve serialized value";
-                        log.debug(msg, ioe);
-                        throw new RepositoryException(msg, ioe);
-                    }
-
-                    va[i] = ValueHelper.deserialize(serValue, targetType, true);
-                }
-            }
-
-            // multi- or single-valued property?
-            if (va.length == 1) {
-                // could be single- or multi-valued (n == 1)
-                try {
-                    // try setting single-value
-                    node.setProperty(propName, va[0]);
-                } catch (ValueFormatException vfe) {
-                    // try setting value array
-                    node.setProperty(propName, va, type);
-                } catch (ConstraintViolationException cve) {
-                    // try setting value array
-                    node.setProperty(propName, va, type);
-                }
-            } else {
-                // can only be multi-valued (n == 0 || n > 1)
-                node.setProperty(propName, va, type);
-            }
-            if (type == PropertyType.REFERENCE) {
-                // store reference for later resolution
-                refTracker.processedReference(node.getProperty(propName));
-            }
+            pi.apply(node, session.getNamespaceResolver(), refTracker);

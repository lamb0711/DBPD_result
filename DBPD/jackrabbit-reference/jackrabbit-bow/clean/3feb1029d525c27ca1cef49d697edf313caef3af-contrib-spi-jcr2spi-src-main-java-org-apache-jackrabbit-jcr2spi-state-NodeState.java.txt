work in progress

- public NodeState.getChildNodeEntry/ies and
  NodeState.hasChildNodeEntry/ies must assert validity of the cnes.
- NodeState internal retrieval of child states should therefore avoid
  public methods unless only valid entries are of interest.
- ChildNodeEntries: simplify.
- SessionImporter: improve comment

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@473383 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.HashSet;
-     * TODO: cache needs to be notified when a child node entry is traversed or NodeState is created
-            for (Iterator it = parent.getChildNodeEntries(name).iterator(); it.hasNext(); ) {
+            for (Iterator it = parent.childNodeEntries.get(name).iterator(); it.hasNext(); ) {
-            ChildNodeEntry entry = getParent().getChildNodeEntry(this);
+            ChildNodeEntry entry = getParent().childNodeEntries.get(this);
-     * Return all nodetype names that apply to this <code>NodeState</code>
+     * Return all nodetype names that are defined to this <code>NodeState</code>
-     * @return
+     * @return array of NodeType names
-     * Determines if there is a <code>ChildNodeEntry</code> with the
+     * Determines if there is a valid <code>ChildNodeEntry</code> with the
-     * @param name  <code>QName</code> object specifying a node name
-     * @param index 1-based index if there are same-name child node entries
+     * @param name  <code>QName</code> object specifying a node name.
+     * @param index 1-based index if there are same-name child node entries.
-        return childNodeEntries.get(name, index) != null;
+        return isValidChildNodeEntry(childNodeEntries.get(name, index));
-     * Returns the <code>ChildNodeEntry</code> with the specified name and index
-     * or <code>null</code> if there's no matching entry.
+     * Returns the valid <code>ChildNodeEntry</code> with the specified name
+     * and index or <code>null</code> if there's no matching entry.
-     * @param nodeName <code>QName</code> object specifying a node name
-     * @param index    1-based index if there are same-name child node entries
-     * @return the <code>ChildNodeEntry</code> with the specified name and index
-     *         or <code>null</code> if there's no matching entry.
+     * @param nodeName <code>QName</code> object specifying a node name.
+     * @param index 1-based index if there are same-name child node entries.
+     * @return The <code>ChildNodeEntry</code> with the specified name and index
+     * or <code>null</code> if there's no matching entry.
-        return childNodeEntries.get(nodeName, index);
+        ChildNodeEntry cne = childNodeEntries.get(nodeName, index);
+        if (isValidChildNodeEntry(cne)) {
+            return cne;
+        } else {
+            return null;
+        }
-    public synchronized ChildNodeEntry getChildNodeEntry(NodeId nodeId) {
+    synchronized ChildNodeEntry getChildNodeEntry(NodeId nodeId) {
+        ChildNodeEntry cne;
-            return childNodeEntries.get(null, uuid);
+            cne = childNodeEntries.get(null, uuid);
-            return childNodeEntries.get(nameElement.getName(), nameElement.getIndex());
+            cne = childNodeEntries.get(nameElement.getName(), nameElement.getIndex());
-    }
-    /**
-     * Returns the <code>ChildNodeEntry</code> with the specified
-     * <code>NodeState</code> or <code>null</code> if there's no matching
-     * entry.
-     *
-     * @param nodeState the child node state.
-     * @return the <code>ChildNodeEntry</code> with the specified
-     * <code>NodeState</code> or <code>null</code> if there's no matching entry.
-     */
-    private synchronized ChildNodeEntry getChildNodeEntry(NodeState nodeState) {
-        return childNodeEntries.get(nodeState);
+        if (isValidChildNodeEntry(cne)) {
+            return cne;
+        } else {
+            return null;
+        }
-        // NOTE: 'childNodeEntries' are already unmodifiable
-        return childNodeEntries;
+        Collection entries = new ArrayList();
+        for (Iterator it = childNodeEntries.iterator(); it.hasNext();) {
+            ChildNodeEntry cne = (ChildNodeEntry) it.next();
+            if (isValidChildNodeEntry(cne)) {
+                entries.add(cne);
+            }
+        }
+        return Collections.unmodifiableCollection(entries);
-        // NOTE: SubList retrieved from 'ChildNodeEntries' is already unmodifiable
-        return childNodeEntries.get(nodeName);
+        List entries = new ArrayList();
+        for (Iterator it = childNodeEntries.get(nodeName).iterator(); it.hasNext();) {
+            ChildNodeEntry cne = (ChildNodeEntry) it.next();
+            if (isValidChildNodeEntry(cne)) {
+                entries.add(cne);
+            }
+        }
+        return Collections.unmodifiableList(entries);
-        if (entry == null) {
-            return false;
-        }
-        if (entry.isAvailable()) {
-            try {
-                return entry.getPropertyState().isValid();
-            } catch (ItemStateException e) {
-                // probably deleted in the meantime
-                return false;
-            }
-        } else {
-            // then it must be valid // TODO check if this assumption is correct.
-            return true;
-        }
+        return isValidChildPropertyEntry(entry);
-                if (propEntry.isAvailable()) {
-                    try {
-                        if (propEntry.getPropertyState().isValid()) {
-                            props.add(propEntry);
-                        }
-                    } catch (ItemStateException e) {
-                        // removed in the meantime -> ignore
-                    }
-                } else {
-                    // never been accessed before, assume valid
+                if (isValidChildPropertyEntry(propEntry)) {
-            if (entry.isAvailable()) {
-                try {
-                    if (entry.getNodeState().isValid()) {
-                        index++;
-                    }
-                } catch (ItemStateException e) {
-                    // probably removed or stale
-                }
-            } else {
-                // cne has not been resolved yet -> increase counter.
-                // TODO: check if assuption is correct
+            if (isValidChildNodeEntry(entry)) {
-                    int index = parent.getChildNodeEntry((NodeState) addedState).getIndex();
+                    int index = parent.childNodeEntries.get((NodeState)addedState).getIndex();
+                    // check for existing, valid child-node-entry
-    //---------------------------------------------------------< diff methods >
-
-    /**
-     * Returns a set of <code>QName</code>s denoting those properties that
-     * do not exist in the overlayed node state but have been added to
-     * <i>this</i> node state.
-     *
-     * @return set of <code>QName</code>s denoting the properties that have
-     *         been added.
-     */
-    public synchronized Set getAddedPropertyNames() {
-        checkIsSessionState();
-
-        if (getStatus() == Status.NEW) {
-            // state is new -> all
-            return Collections.unmodifiableSet(properties.keySet());
-        }
-
-        NodeState other = (NodeState) getWorkspaceState();
-        HashSet set = new HashSet(properties.keySet());
-        set.removeAll(other.properties.keySet());
-        return set;
-    }
-
-    /**
-     * Returns a collection of child node entries that do not exist in the
-     * overlayed node state but have been added to <i>this</i> node state.
-     *
-     * @return collection of added child node entries
-     */
-    public synchronized Collection getAddedChildNodeEntries() {
-        checkIsSessionState();
-
-        if (getStatus() == Status.NEW) {
-            // state is new -> all child nodes are new too
-            return childNodeEntries;
-        }
-
-        List added = new ArrayList();
-        for (Iterator it = childNodeEntries.iterator(); it.hasNext(); ) {
-            ChildNodeEntry cne = (ChildNodeEntry) it.next();
-            try {
-                if (cne.getNodeState().getStatus() == Status.NEW) {
-                    added.add(cne);
-                }
-            } catch (ItemStateException e) {
-                log.warn("error retrieving child node state: " + e.getMessage());
-            }
-        }
-        return added;
-    }
-
-    /**
-     * Returns a set of <code>QName</code>s denoting those properties that
-     * exist in the overlayed node state but have been removed from
-     * <i>this</i> node state.
-     *
-     * @return set of <code>QName</code>s denoting the properties that have
-     *         been removed.
-     */
-    public synchronized Set getRemovedPropertyNames() {
-        checkIsSessionState();
-
-        if (getStatus() == Status.NEW) {
-            return Collections.EMPTY_SET;
-        }
-
-        NodeState other = (NodeState) getWorkspaceState();
-        HashSet set = new HashSet(other.properties.keySet());
-        set.removeAll(properties.keySet());
-        return set;
-    }
-
-    /**
-     * Returns a collection of child node entries, that exist in the overlayed
-     * node state but have been removed from <i>this</i> node state.
-     *
-     * @return collection of removed child node entries
-     */
-    public synchronized Collection getRemovedChildNodeEntries() {
-        checkIsSessionState();
-
-        if (getStatus() == Status.NEW) {
-            return Collections.EMPTY_LIST;
-        }
-
-        List removed = new ArrayList();
-        for (Iterator it = childNodeEntries.iterator(); it.hasNext(); ) {
-            ChildNodeEntry cne = (ChildNodeEntry) it.next();
-            try {
-                if (cne.getNodeState().getStatus() == Status.EXISTING_REMOVED) {
-                    removed.add(cne);
-                }
-            } catch (ItemStateException e) {
-                log.warn("error retrieving child node state: " + e.getMessage());
-            }
-        }
-        return removed;
-    }
-
-        for (Iterator it = entries.iterator(); it.hasNext(); ) {
+        boolean hasValid = false;
+        for (Iterator it = entries.iterator(); it.hasNext() && !hasValid; ) {
-            if (cne.isAvailable()) {
-                try {
-                    if (cne.getNodeState().isValid()) {
-                        return true;
-                    }
-                } catch (ItemStateException e) {
-                    // probably removed in the meantime, check next
-                }
-            } else {
-                // then it has never been accessed and must exist
-                // TODO: check if this assumption is correct
-                return true;
-            }
+            hasValid = isValidChildNodeEntry(cne);
-        return false;
+        return hasValid;
+    }
+
+    /**
+     * Returns <code>true</code> if the given childnode entry is not
+     * <code>null</code> and resolves to a NodeState, that is valid or if the
+     * childnode entry has not been resolved up to now (assuming the corresponding
+     * nodestate is still valid).
+     *
+     * @param cne ChildNodeEntry to check.
+     * @return <code>true</code> if the given entry is valid.
+     */
+    private static boolean isValidChildNodeEntry(ChildNodeEntry cne) {
+        // shortcut.
+        if (cne == null) {
+            return false;
+        }
+        boolean isValid = false;
+        if (cne.isAvailable()) {
+            try {
+                isValid = cne.getNodeState().isValid();
+            } catch (ItemStateException e) {
+                // should not occur, if the cne is available.
+            }
+        } else {
+            // then it has never been accessed and must exist
+            // TODO: check if this assumption is correct
+            isValid = true;
+        }
+
+        return isValid;
+    }
+
+    /**
+     * Returns <code>true</code> if the given childproperty entry is not
+     * <code>null</code> and resolves to a PropertyState, that is valid or if the
+     * childproperty entry has not been resolved up to now (assuming the corresponding
+     * PropertyState is still valid).
+     *
+     * @param cpe ChildPropertyEntry to check.
+     * @return <code>true</code> if the given entry is valid.
+     */
+    private static boolean isValidChildPropertyEntry(ChildPropertyEntry cpe) {
+        if (cpe == null) {
+            return false;
+        }
+        boolean isValid = false;
+        if (cpe.isAvailable()) {
+            try {
+                isValid = cpe.getPropertyState().isValid();
+            } catch (ItemStateException e) {
+                // probably deleted in the meantime. should not occur.
+            }
+        } else {
+            // then it must be valid // TODO check if this assumption is correct.
+            isValid = true;
+        }
+        return isValid;

JCR-2195 Provide possibility to import protected items using Session/Workspace import functionality

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@808923 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.BatchedItemOperations;
-import org.apache.jackrabbit.core.HierarchyManager;
-import org.apache.jackrabbit.core.id.NodeId;
-import org.apache.jackrabbit.core.SessionImpl;
-import org.apache.jackrabbit.core.WorkspaceImpl;
-import org.apache.jackrabbit.core.nodetype.EffectiveNodeType;
-import org.apache.jackrabbit.core.nodetype.NodeDef;
-import org.apache.jackrabbit.core.nodetype.NodeTypeRegistry;
-import org.apache.jackrabbit.core.nodetype.PropDef;
-import org.apache.jackrabbit.core.state.NodeState;
-import org.apache.jackrabbit.core.state.PropertyState;
-import org.apache.jackrabbit.core.state.ChildNodeEntry;
-import org.apache.jackrabbit.core.util.ReferenceChangeTracker;
-import org.apache.jackrabbit.core.value.InternalValue;
-import org.apache.jackrabbit.core.version.VersionHistoryInfo;
-import org.apache.jackrabbit.core.version.InternalVersionManager;
-import org.apache.jackrabbit.spi.Name;
-import org.apache.jackrabbit.spi.Path;
-import org.apache.jackrabbit.spi.commons.conversion.MalformedPathException;
-import org.apache.jackrabbit.spi.commons.name.NameConstants;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Stack;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Stack;
+
+import org.apache.jackrabbit.core.BatchedItemOperations;
+import org.apache.jackrabbit.core.HierarchyManager;
+import org.apache.jackrabbit.core.SessionImpl;
+import org.apache.jackrabbit.core.WorkspaceImpl;
+import org.apache.jackrabbit.core.id.NodeId;
+import org.apache.jackrabbit.core.id.PropertyId;
+import org.apache.jackrabbit.core.nodetype.EffectiveNodeType;
+import org.apache.jackrabbit.core.nodetype.NodeDef;
+import org.apache.jackrabbit.core.nodetype.NodeTypeRegistry;
+import org.apache.jackrabbit.core.nodetype.PropDef;
+import org.apache.jackrabbit.core.state.ChildNodeEntry;
+import org.apache.jackrabbit.core.state.NodeState;
+import org.apache.jackrabbit.core.state.PropertyState;
+import org.apache.jackrabbit.core.util.ReferenceChangeTracker;
+import org.apache.jackrabbit.core.value.InternalValue;
+import org.apache.jackrabbit.core.version.InternalVersionManager;
+import org.apache.jackrabbit.core.version.VersionHistoryInfo;
+import org.apache.jackrabbit.spi.Name;
+import org.apache.jackrabbit.spi.Path;
+import org.apache.jackrabbit.spi.commons.conversion.MalformedPathException;
+import org.apache.jackrabbit.spi.commons.name.NameConstants;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
-     * @param wsp
-     * @param ntReg
+     * @param wsp the workspace to operate on
+     * @param ntReg the node type registry
-     * @param parent
-     * @param conflicting
-     * @param nodeInfo
-     * @return
-     * @throws RepositoryException
+     * @param parent parent node state
+     * @param conflicting conflicting node state
+     * @param nodeInfo the node info
+     * @return the resolved node state
+     * @throws RepositoryException if an error occurs
-     * @param node
-     * @throws RepositoryException
+     * @param node the node state
+     * @throws RepositoryException if an error occurs
+    protected void processProperty(NodeState node, PropInfo pInfo) throws RepositoryException {
+        PropertyState prop;
+        PropDef def;
+
+        Name name = pInfo.getName();
+        int type = pInfo.getType();
+
+        if (node.hasPropertyName(name)) {
+            // a property with that name already exists...
+            PropertyId idExisting = new PropertyId(node.getNodeId(), name);
+            prop = (PropertyState) itemOps.getItemState(idExisting);
+            def = ntReg.getPropDef(prop.getDefinitionId());
+            if (def.isProtected()) {
+                // skip protected property
+                log.debug("skipping protected property "
+                        + itemOps.safeGetJCRPath(idExisting));
+                return;
+            }
+            if (!def.isAutoCreated()
+                    || (prop.getType() != type && type != PropertyType.UNDEFINED)
+                    || def.isMultiple() != prop.isMultiValued()) {
+                throw new ItemExistsException(itemOps.safeGetJCRPath(prop.getPropertyId()));
+            }
+        } else {
+            // there's no property with that name,
+            // find applicable definition
+            def = pInfo.getApplicablePropertyDef(itemOps.getEffectiveNodeType(node));
+            if (def.isProtected()) {
+                // skip protected property
+                log.debug("skipping protected property " + name);
+                return;
+            }
+
+            // create new property
+            prop = itemOps.createPropertyState(node, name, type, def);
+        }
+
+        // check multi-valued characteristic
+        TextValue[] values = pInfo.getTextValues();
+        if (values.length != 1 && !def.isMultiple()) {
+            throw new ConstraintViolationException(itemOps.safeGetJCRPath(prop.getPropertyId())
+                    + " is not multi-valued");
+        }
+
+        // convert serialized values to InternalValue objects
+        int targetType = pInfo.getTargetType(def);
+        InternalValue[] iva = new InternalValue[values.length];
+        for (int i = 0; i < values.length; i++) {
+            iva[i] = values[i].getInternalValue(targetType);
+        }
+
+        // set values
+        prop.setValues(iva);
+
+        // make sure property is valid according to its definition
+        itemOps.validate(prop);
+
+        if (prop.getType() == PropertyType.REFERENCE
+                || prop.getType() == PropertyType.WEAKREFERENCE) {
+            // store reference for later resolution
+            refTracker.processedReference(prop);
+        }
+
+        // store property
+        itemOps.store(prop);
+    }
+    
-            parent = (NodeState) parents.peek();
+            parent = parents.peek();
-            for (PropInfo pi : propInfos) {
-                pi.apply(node, itemOps, ntReg, refTracker);
+            for (PropInfo propInfo : propInfos) {
+                processProperty(node, propInfo);
-        NodeState node = (NodeState) parents.pop();
+        NodeState node = parents.pop();

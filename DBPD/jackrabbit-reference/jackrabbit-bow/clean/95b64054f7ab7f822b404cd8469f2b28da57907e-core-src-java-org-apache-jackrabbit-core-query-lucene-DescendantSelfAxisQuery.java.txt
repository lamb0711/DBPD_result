JCR-190: Caching in QueryHandler does not scale well

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@234492 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.TermDocs;
-import org.apache.lucene.document.Document;
-import java.util.HashSet;
-import java.util.Set;
-            return new DescendantSelfAxisScorer(searcher.getSimilarity(), reader);
+            CachingMultiReader index = (CachingMultiReader) reader;
+            return new DescendantSelfAxisScorer(searcher.getSimilarity(), index);
-        private final IndexReader reader;
+        private final CachingMultiReader reader;
-        private final BitSet hits;
+        private final BitSet contextHits;
-         * List of UUIDs of selected nodes by the context query
-         */
-        private Set contextUUIDs = null;
-
-        /**
+         * Set <code>true</code> once the sub contextHits have been calculated.
+         */
+        private boolean subHitsCalculated = false;
+
+        /**
-        protected DescendantSelfAxisScorer(Similarity similarity, IndexReader reader) {
+        protected DescendantSelfAxisScorer(Similarity similarity, CachingMultiReader reader) {
-            this.hits = new BitSet(reader.maxDoc());
+            // todo reuse BitSets?
+            this.contextHits = new BitSet(reader.maxDoc());
-                    String uuid = reader.document(nextDoc).get(FieldNames.UUID);
-                    if (contextUUIDs.contains(uuid)) {
+                    if (contextHits.get(nextDoc)) {
-                Document d = reader.document(nextDoc);
-                String parentUUID = d.get(FieldNames.PARENT);
-                while (parentUUID != null && !contextUUIDs.contains(parentUUID)) {
+                int parentDoc = reader.getParent(nextDoc);
+                while (parentDoc != -1 && !contextHits.get(parentDoc)) {
-                    TermDocs ancestor = reader.termDocs(new Term(FieldNames.UUID, parentUUID));
-                    try {
-                        if (ancestor.next()) {
-                            d = reader.document(ancestor.doc());
-                            parentUUID = d.get(FieldNames.PARENT);
-                            if (parentUUID.length() == 0) {
-                                parentUUID = null;
-                            }
-                        } else {
-                            parentUUID = null;
-                        }
-                    } finally {
-                        ancestor.close();
-                    }
+                    parentDoc = reader.getParent(parentDoc);
-                if (parentUUID != null) {
-                    // since current doc is a descendant of one of the context
-                    // docs we can promote uuid of doc to the context uuids
-                    contextUUIDs.add(d.get(FieldNames.UUID));
+
+                if (parentDoc != -1) {
+                    // since current parentDoc is a descendant of one of the context
+                    // docs we can promote parentDoc to the context hits
+                    contextHits.set(parentDoc);
+
-            if (contextUUIDs == null) {
-                contextUUIDs = new HashSet();
+            if (!subHitsCalculated) {
+
-                        // @todo maintain cache of doc id hierarchy
-                        hits.set(doc);
+                        contextHits.set(doc);
-                for (int i = hits.nextSetBit(0); i >= 0; i = hits.nextSetBit(i + 1)) {
-                    contextUUIDs.add(reader.document(i).get(FieldNames.UUID));
+
+                if (contextHits.isEmpty()) {
+                    // no need to execute sub scorer, context is empty
+                } else {
+                    subScorer.score(new HitCollector() {
+                        public void collect(int doc, float score) {
+                            subHits.set(doc);
+                        }
+                    });
-                // reuse for final hits
-                hits.clear();
-
-                subScorer.score(new HitCollector() {
-                    public void collect(int doc, float score) {
-                        subHits.set(doc);
-                    }
-                });
+                subHitsCalculated = true;

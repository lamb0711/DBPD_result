JCR-2762: Optimize bundle serialization

Introduce bundle serialization version 3 that uses a fixed list of known names and namespaces to more efficiently store commonly used names. See BundleWriter.writeName() for a detailed description of the name serialization format.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1022485 13f79535-47bb-0310-9956-ffa450edef68

-        // primaryType and version
-        Name type = bundle.getNodeTypeName();
-        int index = binding.nsIndex.stringToIndex(type.getNamespaceURI());
-        out.writeByte(index >>> 16);
-        out.writeByte(index >>> 8);
-        out.writeByte(index);
-        out.writeInt(binding.nameIndex.stringToIndex(type.getLocalName()));
+        // primaryType
+        writeName(bundle.getNodeTypeName());
-            writeIndexedQName(name);
+            writeName(name);
-        writeIndexedQName(null);
+        writeName(null);
-                writeIndexedQName(pName);
+                writeName(pName);
-        writeIndexedQName(null);
+        writeName(null);
-            writeQName(entry.getName());   // name
+            writeName(entry.getName());   // name
-                        writeQName(val.getName());
+                        writeName(val.getName());
-     * Serializes a Name
+     * Serializes a name. The name encoding works as follows:
+     * <p>
+     * First; if the name is known by the {@link BundleNames} class (this
+     * includes the <code>null</code> name), then the name is serialized
+     * as a single byte using the following format.
+     * <pre>
+     * +-------------------------------+
+     * | 0 |    common name index      |
+     * +-------------------------------+
+     * </pre>
+     * <p>
+     * Second; if the name is not known, it gets serialized as a
+     * variable-length field whose first byte looks like this:
+     * <pre>
+     * +-------------------------------+
+     * | 1 | ns index  |  name length  |
+     * +-------------------------------+
+     * </pre>
+     * <p>
+     * The three-bit namespace index identifies either a known namespace
+     * in the {@link BundleNames} class (values 0 - 6) or an explicit
+     * namespace URI string that is written using
+     * {@link DataOutputStream#writeUTF(String)} right after this byte
+     * (value 7).
+     * <p>
+     * The four-bit name length field indicates the length (in UTF-8 bytes)
+     * of the local part of the name. Since zero-length local names are not
+     * allowed, the length is first decremented by one before storing in this
+     * field. The UTF-8 byte sequence is written out after this byte and the
+     * possible namespace URI string. If the length of the local name is
+     * larger than 15 (i.e. would be stored as 0x0f or more), then the value
+     * 0x0f is stored as the name length and the name string is written
+     * using {@link DataOutputStream#writeUTF(String)}.
-    private void writeQName(Name name) throws IOException {
-        out.writeInt(binding.nsIndex.stringToIndex(name.getNamespaceURI()));
-        out.writeUTF(name.getLocalName());
-    }
-
-    /**
-     * Serializes a indexed Name
-     *
-     * @param name the name
-     * @throws IOException in an I/O error occurs.
-     */
-    private void writeIndexedQName(Name name) throws IOException {
-        if (name == null) {
-            out.writeInt(-1);
+    private void writeName(Name name) throws IOException {
+        int index = BundleNames.nameToIndex(name);
+        if (index != -1) {
+            assert 0 <= index && index < 0x80;
+            out.writeByte(index);
-            out.writeInt(binding.nsIndex.stringToIndex(name.getNamespaceURI()));
-            out.writeInt(binding.nameIndex.stringToIndex(name.getLocalName()));
+            String uri = name.getNamespaceURI();
+            int ns = BundleNames.namespaceToIndex(uri) & 0x07;
+
+            String local = name.getLocalName();
+            byte[] bytes = local.getBytes("UTF-8");
+            int len = Math.min(bytes.length - 1, 0x0f);
+
+            out.writeByte(0x80 | ns << 4 | len);
+            if (ns == 0x07) {
+                out.writeUTF(uri);
+            }
+            if (len != 0x0f) {
+                out.write(bytes);
+            } else {
+                out.writeUTF(local);
+            }

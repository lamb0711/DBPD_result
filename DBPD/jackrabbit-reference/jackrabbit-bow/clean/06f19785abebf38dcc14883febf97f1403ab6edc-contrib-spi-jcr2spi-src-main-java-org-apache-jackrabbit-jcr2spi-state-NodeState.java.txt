- Create a factory method in ChildNodeReference, which creates a UUIDReference or a PathElementReference based on the availability of a UUID in the child NodeState.
- Introduce a propertiesInAttic in NodeState, which contains properties that are marked removed in the transient space and have been overlayed with a new property with the same name.
- Reviewed NodeState.moveChildNodeEntry()
- Removed unused NodeStateListener.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@432506 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.util.WeakIdentityCollection;
+     * Map of properties which are deleted and have been re-created as transient
+     * property with the same name.
+     */
+    private HashMap propertiesInAttic = new HashMap();
+
+    /**
-     * Listeners (weak references)
-     */
-    private final transient Collection listeners = new WeakIdentityCollection(3);
-
-    /**
-            parent = nodeState.parent; // TODO: parent from wrong ism layer
+            //parent = nodeState.parent; // TODO: parent from wrong ism layer
+            propertiesInAttic.clear();
-        ChildNodeEntry entry = childNodeEntries.add(nodeName, uuid);
-        notifyNodeAdded(entry);
-        return entry;
+        return childNodeEntries.add(nodeName, uuid);
-        ChildNodeEntry cne;
-        if (uuid != null) {
-            cne = new UUIDReference(child, isf);
-        } else {
-            cne = new PathElementReference(child, isf, idFactory);
-        }
+        ChildNodeEntry cne = ChildNodeReference.create(child, isf, idFactory);
+     * Renames this node to <code>newName</code>.
+     *
+     * @param newName the new name for this node state.
+     * @throws IllegalStateException if this is the root node.
+     */
+    private synchronized void rename(QName newName) {
+        if (parent == null) {
+            throw new IllegalStateException("root node cannot be renamed");
+        }
+        name = newName;
+    }
+
+    /**
-                // already removed
+                // remove invalid property state from properties map
+                it.remove();
+        // move all properties from attic back to properties map
+        properties.putAll(propertiesInAttic);
+        propertiesInAttic.clear();
+
-        if (properties.containsKey(propertyName)) {
-            throw new ItemExistsException(propertyName.toString());
+        // check for an existing property
+        PropertyReference ref = (PropertyReference) properties.get(propertyName);
+        if (ref != null) {
+            PropertyState existingState = null;
+            try {
+                existingState = ref.getPropertyState();
+            } catch (ItemStateException e) {
+                // probably does not exist anymore, remove from properties map
+                properties.remove(propertyName);
+            }
+            if (existingState != null) {
+                if (existingState.getStatus() == STATUS_EXISTING_REMOVED) {
+                    // move to attic
+                    propertiesInAttic.put(propertyName, ref);
+                } else {
+                    throw new ItemExistsException(propertyName.toString());
+                }
+            }
+     * Reorders the child node <code>insertNode</code> before the child node
+     * <code>beforeNode</code>.
-     * @param insertNode
-     * @param beforeNode
+     * @param insertNode the child node to reorder.
+     * @param beforeNode the child node where to insert the node before. If
+     *                   <code>null</code> the child node <code>insertNode</code>
+     *                   is moved to the end of the child node entries.
+     * @throws NoSuchItemStateException if <code>insertNode</code> or
+     *                                  <code>beforeNode</code> is not a child
+     *                                  node of this <code>NodeState</code>.
+        // mark this state as modified
+        markModified();
-    // TODO: review. move with SPI Ids
-        // rename only
-            if (newParent == this) {
-                ChildNodeEntry newEntry = childNodeEntries.add(name, childState.getUUID());
-                notifyNodeAdded(newEntry);
-                notifyNodeRemoved(oldEntry);
-            } else {
-                notifyNodeRemoved(oldEntry);
-                // re-parent target node
-                childState.setParent(newParent);
-                // add child node entry to new parent
-                newParent.addChildNodeEntry(newName, childState.getUUID());
-            }
+            childState.rename(newName);
+            // re-parent target node
+            childState.setParent(newParent);
+            // add child node entry to new parent
+            newParent.childNodeEntries.add(childState);
-    //---------------------------------------------------< Listener support >---
-    /**
-     * {@inheritDoc}
-     * <p/>
-     * If the listener passed is at the same time a <code>NodeStateListener</code>
-     * we add it to our list of specialized listeners.
-     */
-    public void addListener(ItemStateListener listener) {
-        if (listener instanceof NodeStateListener) {
-            synchronized (listeners) {
-                if (listeners.contains(listener)) {
-                    log.debug("listener already registered: " + listener);
-                    // no need to add to call ItemState.addListener()
-                    return;
-                } else {
-                    listeners.add(listener);
-                }
-            }
-        }
-        super.addListener(listener);
-    }
-
-    /**
-     * {@inheritDoc}
-     * <p/>
-     * If the listener passed is at the same time a <code>NodeStateListener</code>
-     * we remove it from our list of specialized listeners.
-     */
-    public void removeListener(ItemStateListener listener) {
-        if (listener instanceof NodeStateListener) {
-            synchronized (listeners) {
-                listeners.remove(listener);
-            }
-        }
-        super.removeListener(listener);
-    }
-
-    //----------------------------------------------< Listener notification >---
-    /**
-     * Notify the listeners that a child node entry has been added
-     */
-    private void notifyNodeAdded(ChildNodeEntry added) {
-        synchronized (listeners) {
-            Iterator iter = listeners.iterator();
-            while (iter.hasNext()) {
-                NodeStateListener l = (NodeStateListener) iter.next();
-                if (l != null) {
-                    l.nodeAdded(this, added.getName(), added.getIndex(), added.getId());
-                }
-            }
-        }
-    }
-
-    /**
-     * Notify the listeners that the child node entries have been replaced
-     */
-    private void notifyNodesReplaced() {
-        synchronized (listeners) {
-            Iterator iter = listeners.iterator();
-            while (iter.hasNext()) {
-                NodeStateListener l = (NodeStateListener) iter.next();
-                if (l != null) {
-                    l.nodesReplaced(this);
-                }
-            }
-        }
-    }
-
-    /**
-     * Notify the listeners that a child node entry has been removed
-     */
-    private void notifyNodeRemoved(ChildNodeEntry removed) {
-        synchronized (listeners) {
-            Iterator iter = listeners.iterator();
-            while (iter.hasNext()) {
-                NodeStateListener l = (NodeStateListener) iter.next();
-                if (l != null) {
-                    l.nodeRemoved(this, removed.getName(),
-                            removed.getIndex(), removed.getId());
-                }
-            }
-        }
-    }
-
+         * Adds a <code>childNode</code> to the end of the list.
+         *
+         * @param childNode the <code>NodeState</code> to add.
+         * @return the <code>ChildNodeEntry</code> which was created for
+         *         <code>childNode</code>.
+         */
+        ChildNodeEntry add(NodeState childNode) {
+            ChildNodeEntry cne = ChildNodeReference.create(childNode, isf, idFactory);
+            add(cne);
+            return cne;
+        }
+
+        /**

JCR-2887 : Split PrivilegeRegistry in a per-session manager instance and a repository level registry [work in progress]

- clustering support
- move definition & def-reader/writer to spi-commons

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1095338 13f79535-47bb-0310-9956-ffa450edef68

-package org.apache.jackrabbit.commons.privilege;
+package org.apache.jackrabbit.spi.commons.privilege;
+import org.apache.jackrabbit.spi.Name;
+import org.apache.jackrabbit.spi.NameFactory;
+import org.apache.jackrabbit.spi.commons.name.NameFactoryImpl;
+import org.apache.jackrabbit.util.Text;
+import org.xml.sax.InputSource;
+import javax.xml.transform.Result;
+import java.io.Reader;
+import java.io.Writer;
+import java.util.HashMap;
+import java.util.HashSet;
-
-import com.sun.org.apache.xml.internal.serialize.XMLSerializer;
+import java.util.Set;
+    private static final NameFactory NAME_FACTORY = NameFactoryImpl.getInstance();
+
+        return readDefinitions(new InputSource(in), namespaces);
+
+    }
+
+    /**
+     * @see PrivilegeHandler#readDefinitions(java.io.Reader, java.util.Map)
+     */
+    public PrivilegeDefinition[] readDefinitions(Reader reader, Map<String, String> namespaces) throws ParseException {
+        return readDefinitions(new InputSource(reader), namespaces);
+    }
+
+    private PrivilegeDefinition[] readDefinitions(InputSource input, Map<String, String> namespaces) throws ParseException {
-            Document doc = builder.parse(in);
+            Document doc = builder.parse(input);
-
-     * @see PrivilegeHandler#writeDefinitions(java.io.OutputStream, PrivilegeDefinition[], java.util.Map) 
+     * @see PrivilegeHandler#writeDefinitions(java.io.OutputStream, PrivilegeDefinition[], java.util.Map)
+        writeDefinitions(new StreamResult(out), definitions, namespaces);
+    }
+
+    /**
+     * @see PrivilegeHandler#writeDefinitions(java.io.Writer, PrivilegeDefinition[], java.util.Map)
+     */
+    public void writeDefinitions(Writer writer, PrivilegeDefinition[] definitions, Map<String, String> namespaces) throws IOException {
+        writeDefinitions(new StreamResult(writer), definitions, namespaces);
+    }
+
+    private void writeDefinitions(Result result, PrivilegeDefinition[] definitions, Map<String, String> namespaces) throws IOException {
+            Map<String, String> uriToPrefix = new HashMap<String, String>(namespaces.size());
-                privileges.setAttribute(ATTR_XMLNS + prefix, namespaces.get(prefix));
+                String uri = namespaces.get(prefix);
+                privileges.setAttribute(ATTR_XMLNS + prefix, uri);
+                uriToPrefix.put(uri, prefix);
-                priv.setAttribute(ATTR_NAME, def.getName());
+                priv.setAttribute(ATTR_NAME, getQualifiedName(def.getName(), uriToPrefix));
-                for (String aggrName : def.getDeclaredAggregateNames()) {
+                for (Name aggrName : def.getDeclaredAggregateNames()) {
-                    contains.setAttribute(ATTR_NAME, aggrName);
+                    contains.setAttribute(ATTR_NAME, getQualifiedName(aggrName, uriToPrefix));
-            transformer.transform(new DOMSource(doc), new StreamResult(out));
+            transformer.transform(new DOMSource(doc), result);
-            String name = elem.getAttribute(ATTR_NAME);
+            Name name = getName(elem.getAttribute(ATTR_NAME), namespaces);
-            List<String> aggrNames = new ArrayList<String>();
+            Set<Name> aggrNames = new HashSet<Name>();
-                        aggrNames.add(aggrName);
+                        aggrNames.add(getName(aggrName, namespaces));
-            return new PrivilegeDefinition(name, isAbstract, aggrNames.toArray(new String[aggrNames.size()]));
+            return new PrivilegeDefinition(name, isAbstract, aggrNames);
+
+    private Name getName(String jcrName, Map<String,String> namespaces) {
+       String prefix = Text.getNamespacePrefix(jcrName);
+        String uri = (Name.NS_EMPTY_PREFIX.equals(prefix)) ? Name.NS_DEFAULT_URI : namespaces.get(prefix);
+        return NAME_FACTORY.create(uri, Text.getLocalName(jcrName));
+    }
+
+    private String getQualifiedName(Name name, Map<String,String> uriToPrefix) {
+        String uri = name.getNamespaceURI();
+        String prefix = (Name.NS_DEFAULT_URI.equals(uri)) ? Name.NS_EMPTY_PREFIX : uriToPrefix.get(uri);
+        return prefix + ":" + name.getLocalName();
+    }

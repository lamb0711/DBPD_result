JCR-178: Allow concurrent index updates and queries

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@232801 13f79535-47bb-0310-9956-ffa450edef68

-import EDU.oswego.cs.dl.util.concurrent.FIFOReadWriteLock;
+import org.apache.lucene.index.IndexReader;
+import org.apache.commons.collections.iterators.AbstractIteratorDecorator;
-     * Read-write lock to synchronize access on the index.
-     */
-    private final FIFOReadWriteLock readWriteLock = new FIFOReadWriteLock();
-
-    /**
-                } catch (IOException e) {
+                } catch (Exception e) {
-        Document doc = createDocument(node, getNamespaceMappings());
-        try {
-            readWriteLock.writeLock().acquire();
-        } catch (InterruptedException e) {
-            throw new RepositoryException("Failed to aquire write lock.");
-        }
-
-        try {
-            index.addDocument(doc);
-        } finally {
-            readWriteLock.writeLock().release();
-        }
+        throw new UnsupportedOperationException("addNode");
-        Term idTerm = new Term(FieldNames.UUID, uuid);
-        try {
-            readWriteLock.writeLock().acquire();
-        } catch (InterruptedException e) {
-            throw new IOException("Failed to aquire write lock.");
-        }
+        throw new UnsupportedOperationException("deleteNode");
+    }
-        try {
-            index.removeDocument(idTerm);
-        } finally {
-            readWriteLock.writeLock().release();
-        }
-
+    /**
+     * This implementation forwards the call to
+     * {@link MultiIndex#update(java.util.Iterator, java.util.Iterator)} and
+     * transforms the two iterators to the required types.
+     *
+     * @param remove uuids of nodes to remove.
+     * @param add    NodeStates to add. Calls to <code>next()</code> on this
+     *               iterator may return <code>null</code>, to indicate that a
+     *               node could not be indexed successfully.
+     * @throws RepositoryException if an error occurs while indexing a node.
+     * @throws IOException         if an error occurs while updating the index.
+     */
+    public void updateNodes(Iterator remove, Iterator add)
+            throws RepositoryException, IOException {
+        index.update(new AbstractIteratorDecorator(remove) {
+            public Object next() {
+                String uuid = (String) super.next();
+                return new Term(FieldNames.UUID, uuid);
+            }
+        }, new AbstractIteratorDecorator(add) {
+            public Object next() {
+                NodeState state = (NodeState) super.next();
+                if (state == null) {
+                    return null;
+                }
+                Document doc = null;
+                try {
+                    doc = createDocument(state, getNamespaceMappings());
+                } catch (RepositoryException e) {
+                    log.error("Exception while creating document for node: " +
+                            state.getUUID() + ": " + e.toString());
+                }
+                return doc;
+            }
+        });
-    Hits executeQuery(Query query,
+    QueryHits executeQuery(Query query,
-        try {
-            readWriteLock.readLock().acquire();
-        } catch (InterruptedException e) {
-            throw new IOException("Unable to obtain read lock on search index.");
-        }
-
-        Hits hits = null;
-        try {
-            SortField[] sortFields = new SortField[orderProps.length];
-            for (int i = 0; i < orderProps.length; i++) {
-                String prop = null;
-                if (Constants.JCR_SCORE.equals(orderProps[i])) {
-                    // order on jcr:score does not use the natural order as
-                    // implemented in lucene. score ascending in lucene means that
-                    // higher scores are first. JCR specs that lower score values
-                    // are first.
-                    sortFields[i] = new SortField(null, SortField.SCORE, orderSpecs[i]);
-                } else {
-                    try {
-                        prop = orderProps[i].toJCRName(getNamespaceMappings());
-                    } catch (NoPrefixDeclaredException e) {
-                        // will never happen
-                    }
-                    sortFields[i] = new SortField(prop, SharedFieldSortComparator.PROPERTIES, !orderSpecs[i]);
-                }
-            }
-
-            if (sortFields.length > 0) {
-                hits = new IndexSearcher(index.getIndexReader()).search(query, new Sort(sortFields));
+        SortField[] sortFields = new SortField[orderProps.length];
+        for (int i = 0; i < orderProps.length; i++) {
+            String prop = null;
+            if (Constants.JCR_SCORE.equals(orderProps[i])) {
+                // order on jcr:score does not use the natural order as
+                // implemented in lucene. score ascending in lucene means that
+                // higher scores are first. JCR specs that lower score values
+                // are first.
+                sortFields[i] = new SortField(null, SortField.SCORE, orderSpecs[i]);
-                hits = new IndexSearcher(index.getIndexReader()).search(query);
+                try {
+                    prop = orderProps[i].toJCRName(getNamespaceMappings());
+                } catch (NoPrefixDeclaredException e) {
+                    // will never happen
+                }
+                sortFields[i] = new SortField(prop, SharedFieldSortComparator.PROPERTIES, !orderSpecs[i]);
-        } finally {
-            readWriteLock.readLock().release();
-        return hits;
+        IndexReader reader = index.getIndexReader();
+        IndexSearcher searcher = new IndexSearcher(reader);
+        Hits hits;
+        if (sortFields.length > 0) {
+            hits = searcher.search(query, new Sort(sortFields));
+        } else {
+            hits = searcher.search(query);
+        }
+        return new QueryHits(hits, reader);

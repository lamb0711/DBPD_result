Workspace.clone(...,removeExisting=true) & Workspace.importXML(..., IMPORT_UUID_COLLISION_REMOVE_EXISTING) potentially leaves repository in inconsistent state

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@160781 13f79535-47bb-0310-9956-ffa450edef68

-     * Recursively removes the specified node state including its properties and
-     * child nodes.
+     * Unlinks the specified target node from all its parents and recursively
+     * removes it including its properties and child nodes.
-     * todo duplicate code in WorkspaceImpl; consolidate in WorkspaceOperations class
+     * <b>Precondition:</b> the state manager of this workspace needs to be in
+     * edit mode.
+     * todo duplicate code in WorkspaceImporter; consolidate in WorkspaceOperations class
+     *
+     * @param target
+     * @throws RepositoryException if an error occurs
+     */
+    protected void removeNode(NodeState target)
+            throws RepositoryException {
+
+        // copy list to avoid ConcurrentModificationException
+        ArrayList parentUUIDs = new ArrayList(target.getParentUUIDs());
+        Iterator iter = parentUUIDs.iterator();
+        while (iter.hasNext()) {
+            String parentUUID = (String) iter.next();
+            NodeId parentId = new NodeId(parentUUID);
+
+            // unlink target node from this parent
+            unlinkNodeState(target, parentUUID);
+
+            // remove child node entries
+            NodeState parent;
+            try {
+                parent = (NodeState) stateMgr.getItemState(parentId);
+            } catch (ItemStateException ise) {
+                // should never get here...
+                String msg = "internal error: failed to retrieve parent state";
+                log.error(msg, ise);
+                throw new RepositoryException(msg, ise);
+            }
+            // use temp array to avoid ConcurrentModificationException
+            ArrayList tmp =
+                    new ArrayList(parent.getChildNodeEntries(target.getUUID()));
+            // remove from tail to avoid problems with same-name siblings
+            for (int i = tmp.size() - 1; i >= 0; i--) {
+                NodeState.ChildNodeEntry entry = (NodeState.ChildNodeEntry) tmp.get(i);
+                parent.removeChildNodeEntry(entry.getName(), entry.getIndex());
+            }
+            // store parent
+            stateMgr.store(parent);
+        }
+    }
+
+    /**
+     * Unlinks the given target node from the specified parent i.e. removes
+     * <code>parentUUID</code> from its list of parents. If as a result
+     * the target node would be orphaned it will be recursively removed
+     * including its properties and child nodes.
+     * <p/>
+     * Note that the child node entry refering to <code>target</code> is
+     * <b><i>not</i></b> automatically removed from <code>target</code>'s
+     * parent denoted by <code>parentUUID</code>.
+     * <p/>
+     * <b>Precondition:</b> the state manager of this workspace needs to be in
+     * edit mode.
+     * todo duplicate code in WorkspaceImporter; consolidate in WorkspaceOperations class
-    protected void removeNode(NodeState target, String parentUUID)
+    private void unlinkNodeState(NodeState target, String parentUUID)
+
-                    NodeState node = (NodeState) stateMgr.getItemState(nodeId);
-                    // check if existing can be removed
+                    NodeState nodeState = (NodeState) stateMgr.getItemState(nodeId);
+                    // check if child node can be removed
-                    wsp.checkRemoveNode(node,
+                    wsp.checkRemoveNode(nodeState, (NodeId) target.getId(),
-                    // remove child node (recursive)
-                    removeNode(node, target.getUUID());
+                    // unlink child node (recursive)
+                    unlinkNodeState(nodeState, target.getUUID());
-                    PropertyState prop = (PropertyState) stateMgr.getItemState(propId);
+                    PropertyState propState = (PropertyState) stateMgr.getItemState(propId);
-                    stateMgr.destroy(prop);
+                    stateMgr.destroy(propState);
-                if (p0.equals(p1) || p0.isAncestorOf(p1)) {
+                if (p1.equals(p0) || p1.isAncestorOf(p0)) {
-            removeNode(conflicting, conflicting.getParentUUID());
+            removeNode(conflicting);
+
-            removeNode(conflicting, conflicting.getParentUUID());
+            removeNode(conflicting);

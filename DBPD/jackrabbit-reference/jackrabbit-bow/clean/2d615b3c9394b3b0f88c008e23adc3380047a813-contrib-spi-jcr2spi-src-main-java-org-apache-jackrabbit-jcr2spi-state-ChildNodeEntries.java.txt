work in progress

- NodeInfo does not load information about child-node-entries
  -> add separate SPI call
  -> add initial draft ChildInfo interface
  -> ChildNodeEntries are not built upon creation of the NodeState
  -> ItemStateFactory: add method to retrieve ChildNodeEntries

- respect CacheBehaviour while persisting transient modifications

- LockInfo.getNodeId() -> not used so far -> remove

- SessionItemStateManager: getHierarchyManager() only used by SessionImpl -> moved

- Improve TODO comments
- Javadoc


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@482657 13f79535-47bb-0310-9956-ffa450edef68

-    
+
+    /**
+     * Create <code>ChildNodeEntries</code> for the given node state.
+     *
+     * @param nodeState
+     */
+    ChildNodeEntries(NodeState nodeState, ChildNodeEntries base) {
+        this.nodeState = nodeState;
+        for (Iterator it = base.iterator(); it.hasNext();) {
+            ChildNodeEntry cne = (ChildNodeEntry) it.next();
+            add(cne.getName(), cne.getUUID(), cne.getIndex());
+        }
+    }
+
-        ChildNodeEntry cne = add(nodeName, uuid);
-        // TODO: in case of SNS, move new cne to the right position.
+        ChildNodeEntry cne = ChildNodeReference.create(nodeState, nodeName, uuid, nodeState.isf, nodeState.idFactory);
+        add(cne, index);
-
-    /**
-     * Adds a <code>ChildNodeEntry</code> for a child node with the given
-     * name and an optional <code>uuid</code>.
-     *
-     * @param nodeName The name of the child node.
-     * @param uuid The UUID of the child node if it can be identified with a UUID;
-     * otherwise <code>null</code>.
-     * @return the created ChildNodeEntry.
-     */
-    private ChildNodeEntry add(QName nodeName, String uuid) {
-        ChildNodeEntry cne = ChildNodeReference.create(nodeState, nodeName, uuid, nodeState.isf, nodeState.idFactory);
-        add(cne);
-        return cne;
-    }
+     * Adds a <code>ChildNodeEntry</code>. If an entry with the given index
+     * already exists, the the new sibling is inserted before.
+     *
+     * @param cne the <code>ChildNodeEntry</code> to add.
+     */
+    private void add(ChildNodeEntry cne, int index) {
+        QName nodeName = cne.getName();
+
+        // retrieve ev. sibling node with same index
+        // if index is 'undefined' behave just as '#add(ChildNodeEntry).
+        LinkedEntries.LinkNode existing = (index < Path.INDEX_DEFAULT) ? null : getLinkNode(nodeName, index);
+
+        // add new entry (same as #add(ChildNodeEntry)
+        List siblings = null;
+        Object obj = nameMap.get(nodeName);
+        if (obj != null) {
+            if (obj instanceof List) {
+                // map entry is a list of siblings
+                siblings = (ArrayList) obj;
+            } else {
+                // map entry is a single child node entry,
+                // convert to siblings list
+                siblings = new ArrayList();
+                siblings.add(obj);
+                nameMap.put(nodeName, siblings);
+            }
+        }
+
+        LinkedEntries.LinkNode ln = entries.add(cne);
+        if (siblings != null) {
+            siblings.add(ln);
+        } else {
+            nameMap.put(nodeName, ln);
+        }
+
+        // if new entry must be inserted instead of appended at the end
+        // reorder entries now
+        if (existing != null) {
+            reorder(obj, ln, existing);
+        }
+    }
+
+    /**
-     * Removes all child node entries
-     */
-    void removeAll() {
-        nameMap.clear();
-        entries.clear();
-    }
-
-    /**
+        reorder(insertObj, insertLN, beforeLN);
+    }
+
+    /**
+     *
+     * @param insertObj
+     * @param insertLN
+     * @param beforeLN
+     */
+    private void reorder(Object insertObj, LinkedEntries.LinkNode insertLN, LinkedEntries.LinkNode beforeLN) {
-            if (beforeNode == null) {
+            if (beforeLN == null) {
-
-                QName insertName = insertNode.getQName();
+                QName insertName = insertLN.getChildNodeEntry().getName();
-     * resolution of any ChildNodeEntry that matches by name.
+     * resolution of any <code>ChildNodeEntry</code> that matches by name.
+    /**
+     * Returns the matching <code>LinkNode</code> from a list or a single
+     * <code>LinkNode</code>. This method will return <code>null</code>
+     * if none of the entries matches.
+     *
+     * @param name
+     * @param index
+     * @return the matching <code>LinkNode</code> or <code>null</code>.
+     */
+    private LinkedEntries.LinkNode getLinkNode(QName name, int index) {
+        Object listOrLinkNode = nameMap.get(name);
+        if (listOrLinkNode == null) {
+            // no matching child node entry
+            return null;
+        }
+
+        if (listOrLinkNode instanceof List) {
+            // has same name sibling
+            for (Iterator it = ((List) listOrLinkNode).iterator(); it.hasNext();) {
+                LinkedEntries.LinkNode n = (LinkedEntries.LinkNode) it.next();
+                ChildNodeEntry cne = n.getChildNodeEntry();
+                if (cne.getIndex() == index) {
+                    return n;
+                }
+            }
+        } else {
+            // single child node with this name
+            ChildNodeEntry cne = ((LinkedEntries.LinkNode) listOrLinkNode).getChildNodeEntry();
+            if (cne.getIndex() == index) {
+                return (LinkedEntries.LinkNode) listOrLinkNode;
+            }
+        }
+
+        // no matching entry
+        return null;
+    }

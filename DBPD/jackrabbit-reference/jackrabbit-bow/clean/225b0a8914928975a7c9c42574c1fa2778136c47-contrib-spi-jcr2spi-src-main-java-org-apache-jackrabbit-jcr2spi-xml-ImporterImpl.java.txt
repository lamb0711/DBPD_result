work in progress

- HierarchyManager: changes methods to take ItemState instead of ItemId
- HierarchyManager: remove log-utility methods (saveGetJCRPath)
- HierarchyManager: remove CachingHierachyManager. not used
- ItemManager: changes methods to take ItemState instead of ItemId
- ItemStateValidator: remove utility methods not related to validation
- new class LogUtil that provides static saveGetJCRPath methods previously
  present on HierarchyManager, ItemStateValidator
- NodeState: add method 'getPropertyEntries()'
- create interface ChildPropertyEntry
- let PropertyReference implement ChildPropertyEntry

TODO: query/NodeIteratorImpl needs to be fixed. 


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@429652 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.state.NoSuchItemStateException;
+import org.apache.jackrabbit.jcr2spi.util.LogUtil;
-import org.apache.jackrabbit.spi.ItemId;
-            ItemId id = hierMgr.getItemId(parentPath);
-            if (!id.denotesNode()) {
-                throw new PathNotFoundException(hierMgr.safeGetJCRPath(parentPath));
+            ItemState itemState = hierMgr.getItemState(parentPath);
+            if (!itemState.isNode()) {
+                throw new PathNotFoundException(LogUtil.safeGetJCRPath(parentPath, session.getNamespaceResolver()));
-            importTarget = validator.getNodeState((NodeId) id);
+            importTarget = (NodeState) itemState;
-            throw new PathNotFoundException(hierMgr.safeGetJCRPath(parentPath));
+            throw new PathNotFoundException(LogUtil.safeGetJCRPath(parentPath, session.getNamespaceResolver()));
-                       log.debug("skipping protected node " + hierMgr.safeGetJCRPath(existing.getId()));
+                       log.debug("skipping protected node " + LogUtil.safeGetJCRPath(existing, session.getNamespaceResolver(), hierMgr));
-                       throw new ItemExistsException(hierMgr.safeGetJCRPath(existing.getId()));
+                       throw new ItemExistsException(LogUtil.safeGetJCRPath(existing, session.getNamespaceResolver(), hierMgr));
-                       NodeState conflicting = validator.getNodeState(nodeInfo.getId());
+                       NodeState conflicting = (NodeState) stateMgr.getItemState(nodeInfo.getId());
-                   } catch (ItemNotFoundException infe) {
+                   } catch (NoSuchItemStateException e) {
+                   } catch (ItemStateException e) {
+                       String msg = "Internal error: failed to retrieve state of " + nodeInfo.getId().toString();
+                       log.debug(msg);
+                       throw new RepositoryException(msg, e);
-                Path p0 = hierMgr.getQPath(importTarget.getId());
-                Path p1 = hierMgr.getQPath(conflicting.getId());
+                Path p0 = hierMgr.getQPath(importTarget);
+                Path p1 = hierMgr.getQPath(conflicting);
-                    log.debug("skipping protected property " + hierMgr.safeGetJCRPath(existing.getPropertyId()));
+                    log.debug("skipping protected property " + LogUtil.safeGetJCRPath(existing, session.getNamespaceResolver(), hierMgr));
-                    throw new ItemExistsException(hierMgr.safeGetJCRPath(existing.getPropertyId()));
+                    throw new ItemExistsException(LogUtil.safeGetJCRPath(existing, session.getNamespaceResolver(), hierMgr));

JCR-3000 SQL2 Join with OR clause still has some issues

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1143477 13f79535-47bb-0310-9956-ffa450edef68

-    
+
-    private static final Logger log = LoggerFactory.getLogger(QueryEngine.class);
+    private static final Logger log = LoggerFactory
+            .getLogger(QueryEngine.class);
-        
+
-                throw new RuntimeException(
-                        "Unable to compare rows " + a + " and " + b, e);
+                throw new RuntimeException("Unable to compare rows " + a
+                        + " and " + b, e);
-        if (log.isDebugEnabled()) {
-            time = System.currentTimeMillis() - time;
-            log.debug("SQL2 QUERY execute took " + time + " ms.");
-        }
+        log.debug("SQL2 QUERY execute took {} ms.", System.currentTimeMillis()
+                - time);
-            if (log.isDebugEnabled()) {
-                log.debug(genString(printIndentation)
-                        + "SQL2 RIGHT OUTER JOIN transformed to LEFT OUTER JOIN.");
-            }
+            log.debug(
+                    "{} SQL2 RIGHT OUTER JOIN transformed to LEFT OUTER JOIN.",
+                    genString(printIndentation));
-        long timeJoinLeftSide = System.currentTimeMillis();
+        boolean isOuterJoin = JCR_JOIN_TYPE_LEFT_OUTER.equalsIgnoreCase(join
+                .getJoinType());
+        QueryResult result = execute(merger, csInfo, isOuterJoin,
+                printIndentation);
+
+        long sort = System.currentTimeMillis();
+        QueryResult sortedResult = sort(result, orderings, evaluator, offset,
+                limit);
+        log.debug(" {} SQL2 SORT took {} ms.", genString(printIndentation),
+                System.currentTimeMillis() - sort);
+        return sortedResult;
+    }
+
+    protected QueryResult execute(JoinMerger merger,
+            ConstraintSplitInfo csInfo, boolean isOuterJoin,
+            int printIndentation) throws RepositoryException {
+
+        long timeJoinLeftSide = System.currentTimeMillis();
+
+        if (csInfo.isMultiple()) {
+            log.debug("{} SQL2 JOIN execute: there are multiple inner splits.",
+                    genString(printIndentation));
+
+            // first branch
+            long bTime = System.currentTimeMillis();
+            QueryResult branch1 = execute(merger,
+                    csInfo.getLeftInnerConstraints(), isOuterJoin,
+                    printIndentation + printIndentStep);
+            Set<Row> allRows = new TreeSet<Row>(new RowPathComparator(
+                    Arrays.asList(merger.getSelectorNames())));
+            RowIterator ri1 = branch1.getRows();
+            while (ri1.hasNext()) {
+                Row r = ri1.nextRow();
+                allRows.add(r);
+            }
+            log.debug("{} SQL2 JOIN executed first branch, took {} ms.",
+                    genString(printIndentation), System.currentTimeMillis()
+                            - bTime);
+
+            // second branch
+            bTime = System.currentTimeMillis();
+            QueryResult branch2 = execute(merger,
+                    csInfo.getRightInnerConstraints(), isOuterJoin,
+                    printIndentation + printIndentStep);
+            RowIterator ri2 = branch2.getRows();
+            while (ri2.hasNext()) {
+                Row r = ri2.nextRow();
+                allRows.add(r);
+            }
+            log.debug("{} SQL2 JOIN executed second branch, took {} ms.",
+                    genString(printIndentation), System.currentTimeMillis()
+                            - bTime);
+            return new SimpleQueryResult(merger.getColumnNames(),
+                    merger.getSelectorNames(), new RowIteratorAdapter(allRows));
+        }
+        
-        // So, in the case of an OUTER JOIN we'll run 2 queries, one with 'ON'
+        // So, in the case of an OUTER JOIN we'll run 2 queries, one with
+        // 'ON'
-        // - excludingOuterJoinRowsSet: the 'ON' + 'WHERE' condition dataset, or
+        // - excludingOuterJoinRowsSet: the 'ON' + 'WHERE' condition
+        // dataset, or
-        boolean isOuterJoin = JCR_JOIN_TYPE_LEFT_OUTER.equalsIgnoreCase(join
-                .getJoinType());
-
-        Set<Row> rightRows = buildRightRowsJoin(csInfo, rightConstraints, isOuterJoin,
-                rightCo, printIndentation + printIndentStep);
+        Set<Row> rightRows = buildRightRowsJoin(csInfo, rightConstraints,
+                isOuterJoin, rightCo, printIndentation + printIndentStep);
-
-        long timeMergeAndSort = System.currentTimeMillis();
-
-        QueryResult result = merger.merge(new RowIteratorAdapter(leftRows),
+        return merger.merge(new RowIteratorAdapter(leftRows),
-        QueryResult sortedResult = sort(result, orderings, evaluator, offset,
-                limit);
-        if (log.isDebugEnabled()) {
-            timeMergeAndSort = System.currentTimeMillis() - timeMergeAndSort;
-            log.debug(genString(printIndentation)
-                    + "SQL2 JOIN MERGE and SORT took " + timeMergeAndSort
-                    + " ms.");
-        }
-        return sortedResult;
+
-            if (csi.getLeftInnerConstraints().isHasLeftConstraints()) {
-                leftRows.addAll(buildLeftRowsJoin(
-                        csi.getLeftInnerConstraints(), comparator,
-                        printIndentation + printIndentStep));
-            }
-            if (csi.getRightInnerConstraints().isHasLeftConstraints()) {
-                leftRows.addAll(buildLeftRowsJoin(
-                        csi.getRightInnerConstraints(), comparator,
-                        printIndentation + printIndentStep));
-            }
+            leftRows.addAll(buildLeftRowsJoin(csi.getLeftInnerConstraints(),
+                    comparator, printIndentation + printIndentStep));
+            leftRows.addAll(buildLeftRowsJoin(csi.getRightInnerConstraints(),
+                    comparator, printIndentation + printIndentStep));
-        
+
-                rightRows.addAll(buildRightRowsJoin(
-                        csi.getLeftInnerConstraints(), rightConstraints,
-                        ignoreWhereConstraints, comparator, printIndentation
-                                + printIndentStep));
-                rightRows.addAll(buildRightRowsJoin(
-                        csi.getRightInnerConstraints(), rightConstraints,
-                        ignoreWhereConstraints, comparator, printIndentation
-                                + printIndentStep));
+            rightRows.addAll(buildRightRowsJoin(csi.getLeftInnerConstraints(),
+                    rightConstraints, ignoreWhereConstraints, comparator,
+                    printIndentation + printIndentStep));
+            rightRows.addAll(buildRightRowsJoin(csi.getRightInnerConstraints(),
+                    rightConstraints, ignoreWhereConstraints, comparator,
+                    printIndentation + printIndentStep));
-                        + time + " ms. selector: " + selector
-                        + ", columns: " + Arrays.toString(columnNames)
-                        + ", constraint: " + constraint);
+                        + time + " ms. selector: " + selector + ", columns: "
+                        + Arrays.toString(columnNames) + ", constraint: "
+                        + constraint);
-    private Map<String, PropertyValue> getColumnMap(
-            Column[] columns, Map<String, NodeType> selectors)
-            throws RepositoryException {
-        Map<String, PropertyValue> map =
-            new LinkedHashMap<String, PropertyValue>();
+    private Map<String, PropertyValue> getColumnMap(Column[] columns,
+            Map<String, NodeType> selectors) throws RepositoryException {
+        Map<String, PropertyValue> map = new LinkedHashMap<String, PropertyValue>();
-                    map.put(name, qomFactory.propertyValue(
-                            columns[i].getSelectorName(),
-                            columns[i].getPropertyName()));
+                    map.put(name,
+                            qomFactory.propertyValue(
+                                    columns[i].getSelectorName(),
+                                    columns[i].getPropertyName()));
-                map.putAll(getColumnMap(
-                        selector.getKey(), selector.getValue()));
+                map.putAll(getColumnMap(selector.getKey(), selector.getValue()));
-    private Map<String, PropertyValue> getColumnMap(
-            String selector, NodeType type) throws RepositoryException {
-        Map<String, PropertyValue> map =
-            new LinkedHashMap<String, PropertyValue>();
+    private Map<String, PropertyValue> getColumnMap(String selector,
+            NodeType type) throws RepositoryException {
+        Map<String, PropertyValue> map = new LinkedHashMap<String, PropertyValue>();
-            return Collections.singletonMap(
-                    selector.getSelectorName(), getNodeType(selector));
+            return Collections.singletonMap(selector.getSelectorName(),
+                    getNodeType(selector));
-     * Sorts the given query results according to the given QOM orderings.
-     * If one or more orderings have been specified, this method will iterate
+     * Sorts the given query results according to the given QOM orderings. If
+     * one or more orderings have been specified, this method will iterate
-     *
-     * @param result original query results
-     * @param orderings QOM orderings
-     * @param offset result offset
-     * @param limit result limit
+     * 
+     * @param result
+     *            original query results
+     * @param orderings
+     *            QOM orderings
+     * @param offset
+     *            result offset
+     * @param limit
+     *            result limit
-     * @throws RepositoryException if the results can not be sorted
+     * @throws RepositoryException
+     *             if the results can not be sorted
-        if ((orderings != null && orderings.length > 0)
-                || offset != 0 || limit >= 0) {
+        if ((orderings != null && orderings.length > 0) || offset != 0
+                || limit >= 0) {
-            return new SimpleQueryResult(
-                    result.getColumnNames(), result.getSelectorNames(),
-                    new RowIteratorAdapter(rows));
+            return new SimpleQueryResult(result.getColumnNames(),
+                    result.getSelectorNames(), new RowIteratorAdapter(rows));

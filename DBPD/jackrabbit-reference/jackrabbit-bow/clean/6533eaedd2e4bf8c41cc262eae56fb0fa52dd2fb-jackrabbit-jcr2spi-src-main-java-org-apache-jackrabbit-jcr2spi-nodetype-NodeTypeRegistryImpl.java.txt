JCR-1547: JCR2SPI: remove dependency to state-package within entprovider interface

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@650417 13f79535-47bb-0310-9956-ffa450edef68

+import EDU.oswego.cs.dl.util.concurrent.ConcurrentReaderHashMap;
-import org.apache.jackrabbit.jcr2spi.state.NodeState;
-import org.apache.jackrabbit.jcr2spi.state.Status;
-import org.apache.jackrabbit.jcr2spi.state.PropertyState;
-import org.apache.jackrabbit.jcr2spi.hierarchy.PropertyEntry;
-import org.apache.jackrabbit.spi.QPropertyDefinition;
+import org.apache.jackrabbit.spi.QPropertyDefinition;
+import org.apache.jackrabbit.spi.QItemDefinition;
-import org.apache.jackrabbit.spi.commons.nodetype.NodeTypeConflictException;
-import org.apache.jackrabbit.spi.commons.name.NameConstants;
-import org.slf4j.LoggerFactory;
+import org.slf4j.LoggerFactory;
-
-import EDU.oswego.cs.dl.util.concurrent.ConcurrentReaderHashMap;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.TreeSet;
+import java.util.HashMap;
-        EffectiveNodeTypeImpl ent = validator.validateNodeTypeDef(ntDef, registeredNTDefs);
+        EffectiveNodeType ent = validator.validateNodeTypeDef(ntDef, registeredNTDefs);
-        EffectiveNodeTypeImpl ent = validator.validateNodeTypeDef(ntd, registeredNTDefs);
+        EffectiveNodeType ent = validator.validateNodeTypeDef(ntd, registeredNTDefs);
-            throws NodeTypeConflictException, NoSuchNodeTypeException {
+            throws ConstraintViolationException, NoSuchNodeTypeException {
-        throws NodeTypeConflictException, NoSuchNodeTypeException {
+        throws ConstraintViolationException, NoSuchNodeTypeException {
-     * @see EffectiveNodeTypeProvider#getEffectiveNodeType(NodeState)
-     * @inheritDoc
-     * In case the status of the given node state is not {@link Status#EXISTING}
-     * the transiently added mixin types are taken into account as well.
+     * @see EffectiveNodeTypeProvider#getEffectiveNodeType(QNodeTypeDefinition, Map)
-    public EffectiveNodeType getEffectiveNodeType(NodeState nodeState) throws ConstraintViolationException, NoSuchNodeTypeException {
-        try {
-            Name[] allNtNames;
-            if (nodeState.getStatus() == Status.EXISTING) {
-                allNtNames = nodeState.getNodeTypeNames();
-            } else {
-                // TODO: check if correct (and only used for creating new)
-                Name primaryType = nodeState.getNodeTypeName();
-                allNtNames = new Name[] { primaryType }; // default
-                try {
-                    PropertyEntry pe = nodeState.getNodeEntry().getPropertyEntry(NameConstants.JCR_MIXINTYPES, true);
-                    if (pe != null) {
-                        PropertyState mixins = pe.getPropertyState();
-                        QValue[] values = mixins.getValues();
-                        allNtNames = new Name[values.length + 1];
-                        for (int i = 0; i < values.length; i++) {
-                            allNtNames[i] = values[i].getName();
-                        }
-                        allNtNames[values.length] = primaryType;
-                    } // else: no jcr:mixinTypes property exists -> ignore
-                } catch (RepositoryException e) {
-                    // unexpected error: ignore
-                }
+    public EffectiveNodeType getEffectiveNodeType(QNodeTypeDefinition ntd, Map ntdMap)
+            throws ConstraintViolationException, NoSuchNodeTypeException {
+        TreeSet mergedNodeTypes = new TreeSet();
+        TreeSet inheritedNodeTypes = new TreeSet();
+        TreeSet allNodeTypes = new TreeSet();
+        Map namedItemDefs = new HashMap();
+        List unnamedItemDefs = new ArrayList();
+        Set supportedMixins = null;
+
+        Name ntName = ntd.getName();
+        // prepare new instance
+        mergedNodeTypes.add(ntName);
+        allNodeTypes.add(ntName);
+
+        Name[] smixins = ntd.getSupportedMixinTypes();
+
+        if (smixins != null) {
+            supportedMixins = new HashSet();
+            for (int i = 0; i < smixins.length; i++) {
+                supportedMixins.add(smixins[i]);
-            return getEffectiveNodeType(allNtNames);
-        } catch (NodeTypeConflictException e) {
-            String msg = "Internal error: failed to build effective node type from node types defined with " + nodeState;
-            log.debug(msg);
-            throw new ConstraintViolationException(msg, e);
+
+        // map of all item definitions (maps id to definition)
+        // used to effectively detect ambiguous child definitions where
+        // ambiguity is defined in terms of definition identity
+        Set itemDefIds = new HashSet();
+
+        QNodeDefinition[] cnda = ntd.getChildNodeDefs();
+        for (int i = 0; i < cnda.length; i++) {
+            // check if child node definition would be ambiguous within
+            // this node type definition
+            if (itemDefIds.contains(cnda[i])) {
+                // conflict
+                String msg;
+                if (cnda[i].definesResidual()) {
+                    msg = ntName + " contains ambiguous residual child node definitions";
+                } else {
+                    msg = ntName + " contains ambiguous definitions for child node named "
+                            + cnda[i].getName();
+                }
+                log.debug(msg);
+                throw new ConstraintViolationException(msg);
+            } else {
+                itemDefIds.add(cnda[i]);
+            }
+            if (cnda[i].definesResidual()) {
+                // residual node definition
+                unnamedItemDefs.add(cnda[i]);
+            } else {
+                // named node definition
+                Name name = cnda[i].getName();
+                List defs = (List) namedItemDefs.get(name);
+                if (defs == null) {
+                    defs = new ArrayList();
+                    namedItemDefs.put(name, defs);
+                }
+                if (defs.size() > 0) {
+                    /**
+                     * there already exists at least one definition with that
+                     * name; make sure none of them is auto-create
+                     */
+                    for (int j = 0; j < defs.size(); j++) {
+                        QItemDefinition qDef = (QItemDefinition) defs.get(j);
+                        if (cnda[i].isAutoCreated() || qDef.isAutoCreated()) {
+                            // conflict
+                            String msg = "There are more than one 'auto-create' item definitions for '"
+                                    + name + "' in node type '" + ntName + "'";
+                            log.debug(msg);
+                            throw new ConstraintViolationException(msg);
+                        }
+                    }
+                }
+                defs.add(cnda[i]);
+            }
+        }
+        QPropertyDefinition[] pda = ntd.getPropertyDefs();
+        for (int i = 0; i < pda.length; i++) {
+            // check if property definition would be ambiguous within
+            // this node type definition
+            if (itemDefIds.contains(pda[i])) {
+                // conflict
+                String msg;
+                if (pda[i].definesResidual()) {
+                    msg = ntName + " contains ambiguous residual property definitions";
+                } else {
+                    msg = ntName + " contains ambiguous definitions for property named "
+                            + pda[i].getName();
+                }
+                log.debug(msg);
+                throw new ConstraintViolationException(msg);
+            } else {
+                itemDefIds.add(pda[i]);
+            }
+            if (pda[i].definesResidual()) {
+                // residual property definition
+                unnamedItemDefs.add(pda[i]);
+            } else {
+                // named property definition
+                Name name = pda[i].getName();
+                List defs = (List) namedItemDefs.get(name);
+                if (defs == null) {
+                    defs = new ArrayList();
+                    namedItemDefs.put(name, defs);
+                }
+                if (defs.size() > 0) {
+                    /**
+                     * there already exists at least one definition with that
+                     * name; make sure none of them is auto-create
+                     */
+                    for (int j = 0; j < defs.size(); j++) {
+                        QItemDefinition qDef = (QItemDefinition) defs.get(j);
+                        if (pda[i].isAutoCreated() || qDef.isAutoCreated()) {
+                            // conflict
+                            String msg = "There are more than one 'auto-create' item definitions for '"
+                                    + name + "' in node type '" + ntName + "'";
+                            log.debug(msg);
+                            throw new ConstraintViolationException(msg);
+                        }
+                    }
+                }
+                defs.add(pda[i]);
+            }
+        }
+
+        // create empty effective node type instance
+        EffectiveNodeTypeImpl ent = new EffectiveNodeTypeImpl(mergedNodeTypes,
+                inheritedNodeTypes, allNodeTypes, namedItemDefs,
+                unnamedItemDefs, supportedMixins);
+
+        // resolve supertypes recursively
+        Name[] supertypes = ntd.getSupertypes();
+        if (supertypes.length > 0) {
+            EffectiveNodeTypeImpl effSuperType = (EffectiveNodeTypeImpl) getEffectiveNodeType(supertypes, ntdMap);
+            ent.internalMerge(effSuperType, true);
+        }
+        return ent;
-                ent = EffectiveNodeTypeImpl.create(this, ntd, ntdCache);
+                ent = getEffectiveNodeType(ntd, ntdCache);
-            } catch (NodeTypeConflictException ntce) {
+            } catch (ConstraintViolationException e) {
-                throw new NoSuchNodeTypeException(msg, ntce);
+                throw new NoSuchNodeTypeException(msg, e);
-     * @throws NodeTypeConflictException
+     * @throws ConstraintViolationException
-        throws NodeTypeConflictException, NoSuchNodeTypeException {
+        throws ConstraintViolationException, NoSuchNodeTypeException {
-                        EffectiveNodeTypeImpl ent = EffectiveNodeTypeImpl.create(this, ntd, ntdCache);
+                        EffectiveNodeType ent = getEffectiveNodeType(ntd, ntdCache);
-                            result = ent;
+                            result = (EffectiveNodeTypeImpl) ent;
-                            result = result.merge(ent);
+                            result = result.merge((EffectiveNodeTypeImpl) ent);
-
-
-    private void internalRegister(QNodeTypeDefinition ntd, EffectiveNodeTypeImpl ent) {
+    private void internalRegister(QNodeTypeDefinition ntd, EffectiveNodeType ent) {

work in progress

- reorder: wrong usage of OrderPatch
- reorder: missing check for 'before' being null
- reorder: affected-items in op. not consistent with modified items
- move: session.move must remember srcId 
- spi: add possibility to obtain sessionInfo for another workspace based on an existing sessionInfo.
- uriresolver: defensive check for type of ItemId

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@464431 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.name.MalformedPathException;
-     * A current element Path instance.
-     */
-    public static final Path CURRENT_PATH;
-
-    static {
-        try {
-            Path.PathBuilder builder = new Path.PathBuilder();
-            builder.addFirst(Path.CURRENT_ELEMENT);
-            CURRENT_PATH = builder.getPath();
-        } catch (MalformedPathException e) {
-            // path is always valid
-            throw new InternalError("unable to create path from '.'");
-        }
-    }
-
-    /**
-                if (id.equals(event.getParentId())) {
-                    ItemId evId = event.getItemId();
-                    ItemState newState = null;
-
-                    if (evId.denotesNode()) {
-                        QName name = event.getQPath().getNameElement().getName();
-                        int index = event.getQPath().getNameElement().getNormalizedIndex();
-                        String uuid = (((NodeId)evId).getPath() != null) ? null : ((NodeId)evId).getUUID();
-
-                        // add new childNodeEntry if it has not been added by
-                        // some earlier 'add' event
-                        // TODO: TOBEFIXED for SNSs
-                        ChildNodeEntry cne = getChildNodeEntry(name, index);
-                        if (cne == null || ((uuid == null) ? cne.getUUID() != null : !uuid.equals(cne.getUUID()))) {
-                            cne = childNodeEntries.add(name, uuid);
-                        }
-                        try {
-                            newState = cne.getNodeState();
-                        } catch (ItemStateException e) {
-                            log.error("Internal error", e);
-                        }
-                    } else {
-                        QName pName = ((PropertyId) event.getItemId()).getQName();
-                        // create a new property reference if it has not been
-                        // added by some earlier 'add' event
-                        ChildPropertyEntry re;
-                        if (hasPropertyName(pName)) {
-                            re = (ChildPropertyEntry) properties.get(pName);
-                        } else {
-                            re = PropertyReference.create(this, pName, isf, idFactory);
-                            properties.put(pName, re);
-                        }
-                        try {
-                            newState = re.getPropertyState();
-                        } catch (ItemStateException e) {
-                            log.error("Internal error", e);
-                        }
-                        // make sure this state is up to date (uuid/mixins)
-                        refresh(pName, event.getType());
-                    }
-
-                    // connect the added state from the transient layer to the
-                    // new workspaceState and make sure its data are updated.
-                    if (newState != null && changeLog != null) {
-                        for (Iterator it = changeLog.addedStates(); it.hasNext();) {
-                            ItemState added = (ItemState) it.next();
-                            if (added.hasOverlayedState()) {
-                                // already connected
-                                continue;
-                            }
-                            // TODO: TOBEFIXED. may fail (produce wrong results) for SNSs, since currently events upon 'save' are not garantied to be 'local' changes only
-                            if (added.getId().equals(evId)) {
-                                added.connect(newState);
-                                added.merge();
-                                break;
-                            }
-                        }
-                    }
-                    // and let the transiently modified session state now, that
-                    // its workspace state has been touched.
-                    setStatus(Status.MODIFIED);
-                } else {
-                    // ILLEGAL
-                    throw new IllegalArgumentException("Illegal event type " + event.getType() + " for NodeState.");
+                if (!id.equals(event.getParentId())) {
+                    // TODO: TOBEFIXED. this should never occur and indicates severe consistency issue.
+                    throw new IllegalArgumentException("Event parent (" + event.getParentId() + ") does not match this state with id: " + id);
+                ItemId evId = event.getItemId();
+                ItemState newState = null;
+
+                if (evId.denotesNode()) {
+                    QName name = event.getQPath().getNameElement().getName();
+                    int index = event.getQPath().getNameElement().getNormalizedIndex();
+                    String uuid = (((NodeId)evId).getPath() != null) ? null : ((NodeId)evId).getUUID();
+
+                    // add new childNodeEntry if it has not been added by
+                    // some earlier 'add' event
+                    // TODO: TOBEFIXED for SNSs
+                    ChildNodeEntry cne = getChildNodeEntry(name, index);
+                    if (cne == null || ((uuid == null) ? cne.getUUID() != null : !uuid.equals(cne.getUUID()))) {
+                        cne = childNodeEntries.add(name, uuid);
+                    }
+                    try {
+                        newState = cne.getNodeState();
+                    } catch (ItemStateException e) {
+                        log.error("Internal error", e);
+                    }
+                } else {
+                    QName pName = ((PropertyId) event.getItemId()).getQName();
+                    // create a new property reference if it has not been
+                    // added by some earlier 'add' event
+                    ChildPropertyEntry re;
+                    if (hasPropertyName(pName)) {
+                        re = (ChildPropertyEntry) properties.get(pName);
+                    } else {
+                        re = PropertyReference.create(this, pName, isf, idFactory);
+                        properties.put(pName, re);
+                    }
+                    try {
+                        newState = re.getPropertyState();
+                    } catch (ItemStateException e) {
+                        log.error("Internal error", e);
+                    }
+                    // make sure this state is up to date (uuid/mixins)
+                    refresh(pName, event.getType());
+                }
+
+                // connect the added state from the transient layer to the
+                // new workspaceState and make sure its data are updated.
+                if (newState != null && changeLog != null) {
+                    for (Iterator it = changeLog.addedStates(); it.hasNext();) {
+                        ItemState added = (ItemState) it.next();
+                        if (added.hasOverlayedState()) {
+                            // already connected
+                            continue;
+                        }
+                        // TODO: TOBEFIXED. may fail (produce wrong results) for SNSs, since currently events upon 'save' are not garantied to be 'local' changes only
+                        // TODO: TOBEFIXED. equals to false if added-state is referenceable.
+                        if (added.getId().equals(evId)) {
+                            added.connect(newState);
+                            added.merge();
+                            break;
+                        }
+                    }
+                }
+                // and let the transiently modified session state now, that
+                // its workspace state has been touched.
+                setStatus(Status.MODIFIED);
+                Set toRemove = new HashSet();
-                                childNodeEntries.remove(cne.getName(), cne.getIndex());
+                                toRemove.add(cne);
-                        childNodeEntries.remove(cne.getName(), cne.getIndex());
+                        toRemove.add(cne);
+                for (Iterator it = toRemove.iterator(); it.hasNext();) {
+                    ChildNodeEntry cne = (ChildNodeEntry) it.next();
+                    childNodeEntries.remove(cne.getName(), cne.getIndex());
+                }
-
+        childState.markModified();

JCR-3078 - Add CopyMoveHanlder so that the copy/move behavior can be customized (as this is the case for the IOHandler and PropertyHandler)


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1173533 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.webdav.DavException;
+import org.apache.jackrabbit.webdav.DavServletResponse;
+import org.apache.jackrabbit.webdav.jcr.JcrDavException;
+import javax.jcr.PathNotFoundException;
-public class DefaultHandler implements IOHandler, PropertyHandler {
+public class DefaultHandler implements IOHandler, PropertyHandler, CopyMoveHandler {
-                    || JcrConstants.JCR_MIMETYPE.equals(name)
-                    || JcrConstants.JCR_ENCODING.equals(name)
-                    || JcrConstants.JCR_LASTMODIFIED.equals(name)) {
+                        || JcrConstants.JCR_MIMETYPE.equals(name)
+                        || JcrConstants.JCR_ENCODING.equals(name)
+                        || JcrConstants.JCR_LASTMODIFIED.equals(name)) {
+    //----------------------------------------------------< CopyMoveHandler >---
+    /**
+     * @see CopyMoveHandler#canCopy(CopyMoveContext, org.apache.jackrabbit.webdav.DavResource, org.apache.jackrabbit.webdav.DavResource)
+     */
+    public boolean canCopy(CopyMoveContext context, DavResource source, DavResource destination) {
+        return true;
+    }
+
+    /**
+     * @see CopyMoveHandler#copy(CopyMoveContext, org.apache.jackrabbit.webdav.DavResource, org.apache.jackrabbit.webdav.DavResource)
+     */
+    public boolean copy(CopyMoveContext context, DavResource source, DavResource destination) throws DavException {
+        if (context.isShallowCopy() && source.isCollection()) {
+            // TODO: currently no support for shallow copy; however this is
+            // only relevant if the source resource is a collection, because
+            // otherwise it doesn't make a difference
+            throw new DavException(DavServletResponse.SC_FORBIDDEN, "Unable to perform shallow copy.");
+        }
+        try {
+            context.getSession().getWorkspace().copy(source.getLocator().getRepositoryPath(), destination.getLocator().getRepositoryPath());
+            return true;
+        }  catch (PathNotFoundException e) {
+            // according to rfc 2518: missing parent
+            throw new DavException(DavServletResponse.SC_CONFLICT, e.getMessage());
+        } catch (RepositoryException e) {
+            throw new JcrDavException(e);
+        }
+    }
+
+    /**
+     * @see CopyMoveHandler#canMove(CopyMoveContext, org.apache.jackrabbit.webdav.DavResource, org.apache.jackrabbit.webdav.DavResource)
+     */
+    public boolean canMove(CopyMoveContext context, DavResource source, DavResource destination) {
+        return true;
+    }
+
+    /**
+     * @see CopyMoveHandler#move(CopyMoveContext, org.apache.jackrabbit.webdav.DavResource, org.apache.jackrabbit.webdav.DavResource) 
+     */
+    public boolean move(CopyMoveContext context, DavResource source, DavResource destination) throws DavException {
+        try {
+            context.getWorkspace().move(source.getLocator().getRepositoryPath(), destination.getLocator().getRepositoryPath());
+            return true;
+        } catch (RepositoryException e) {
+            throw new JcrDavException(e);
+        }
+    }
+
-               || ntName.equals(JcrConstants.MIX_REFERENCEABLE)
-               || ntName.equals(JcrConstants.MIX_VERSIONABLE)
-               || ntName.equals(JcrConstants.MIX_LOCKABLE);
+                || ntName.equals(JcrConstants.MIX_REFERENCEABLE)
+                || ntName.equals(JcrConstants.MIX_VERSIONABLE)
+                || ntName.equals(JcrConstants.MIX_LOCKABLE);

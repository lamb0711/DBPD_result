JCR-189: QueryHandler should use lucene Input-/OutputStream implementations

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@233174 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.fs.BasedFileSystem;
-import org.apache.jackrabbit.core.fs.FileSystem;
-import org.apache.jackrabbit.core.fs.FileSystemException;
-import org.apache.jackrabbit.core.fs.FileSystemResource;
+import java.io.File;
-    private final FileSystem fs;
+    private final File indexDir;
-     * @param fs the base file system
+     * @param indexDir the base file system
-     * @throws FileSystemException if an error occurs
-    MultiIndex(FileSystem fs,
+    MultiIndex(File indexDir,
-               String rootUUID) throws FileSystemException, IOException {
+               String rootUUID) throws IOException {
-        this.fs = fs;
+        this.indexDir = indexDir;
-        if (fs.exists(indexNames.getFileName())) {
-            indexNames.read(fs);
+        if (indexNames.exists(indexDir)) {
+            indexNames.read(indexDir);
-        if (fs.exists(deletable.getFileName())) {
-            deletable.read(fs);
+        if (deletable.exists(indexDir)) {
+            deletable.read(indexDir);
-        FileSystemResource mapFile = new FileSystemResource(fs, NS_MAPPING_FILE);
+        File mapFile = new File(indexDir, NS_MAPPING_FILE);
-                FileSystem sub = new BasedFileSystem(fs, indexNames.getName(i));
-                sub.init();
+                File sub = new File(indexDir, indexNames.getName(i));
+                if (!sub.exists() && !sub.mkdir()) {
+                    throw new IOException("Unable to create directory: " + sub.getAbsolutePath());
+                }
-            RedoLog redoLog = new RedoLog(new FileSystemResource(fs, REDO_LOG));
+            RedoLog redoLog = new RedoLog(new File(indexDir, REDO_LOG));
-        } catch (FileSystemException e) {
-            throw new IOException(e.getMessage());
-            // create new index folder
-            String name = indexNames.newName();
-            FileSystem sub = new BasedFileSystem(fs, name);
-            PersistentIndex index;
-            try {
-                sub.init();
-                index = new PersistentIndex(name, sub, true, handler.getAnalyzer());
-                index.setMaxMergeDocs(handler.getMaxMergeDocs());
-                index.setMergeFactor(handler.getMergeFactor());
-                index.setMinMergeDocs(handler.getMinMergeDocs());
-                index.setUseCompoundFile(handler.getUseCompoundFile());
-            } catch (FileSystemException e) {
-                throw new IOException(e.getMessage());
-            }
+
+            File sub = newIndexFolder();
+            String name = sub.getName();
+            PersistentIndex index = new PersistentIndex(name, sub, true, handler.getAnalyzer());
+            index.setMaxMergeDocs(handler.getMaxMergeDocs());
+            index.setMergeFactor(handler.getMergeFactor());
+            index.setMinMergeDocs(handler.getMinMergeDocs());
+            index.setUseCompoundFile(handler.getUseCompoundFile());
-            try {
-                indexes.add(index);
-                indexNames.addName(name);
-                indexNames.write(fs);
-            } catch (FileSystemException e) {
-                throw new IOException(e.getMessage());
-            }
+            indexes.add(index);
+            indexNames.addName(name);
+            indexNames.write(indexDir);
-        try {
-            volatileIndex.getRedoLog().clear();
-        } catch (FileSystemException e) {
-            log.error("Internal error: Unable to clear redo log.", e);
-        }
+        volatileIndex.getRedoLog().clear();
+
-            try {
-                String name = indexNames.newName();
-                FileSystem sub = new BasedFileSystem(fs, name);
-                sub.init();
-                PersistentIndex index = new PersistentIndex(name, sub, true, handler.getAnalyzer());
-                index.setMaxMergeDocs(handler.getMaxMergeDocs());
-                index.setMergeFactor(handler.getMergeFactor());
-                index.setMinMergeDocs(handler.getMinMergeDocs());
-                index.setUseCompoundFile(handler.getUseCompoundFile());
-                indexes.add(index);
-                indexNames.addName(name);
-                indexNames.write(fs);
-            } catch (FileSystemException e) {
-                throw new IOException(e.getMessage());
-            }
+            File sub = newIndexFolder();
+            String name = sub.getName();
+            PersistentIndex index = new PersistentIndex(name, sub, true, handler.getAnalyzer());
+            index.setMaxMergeDocs(handler.getMaxMergeDocs());
+            index.setMergeFactor(handler.getMergeFactor());
+            index.setMinMergeDocs(handler.getMinMergeDocs());
+            index.setUseCompoundFile(handler.getUseCompoundFile());
+            indexes.add(index);
+            indexNames.addName(name);
+            indexNames.write(indexDir);
+                indexNames.write(indexDir);
-                try {
-                    fs.deleteFolder(index.getName());
-                } catch (FileSystemException e) {
+                File dir = new File(indexDir, index.getName());
+                if (!deleteIndex(dir)) {
-                    try {
-                        deletable.write(fs);
-                    } catch (FileSystemException e1) {
-                        throw new IOException(e.getMessage());
-                    }
+                    deletable.write(indexDir);
-        try {
-            indexNames.write(fs);
-        } catch (FileSystemException e) {
-            throw new IOException(e.getMessage());
-        }
-        String name = indexNames.newName();
-        FileSystem sub = new BasedFileSystem(fs, name);
-        PersistentIndex index;
-        try {
-            sub.init();
-            index = new PersistentIndex(name, sub, true, handler.getAnalyzer());
-            index.setMaxMergeDocs(handler.getMaxMergeDocs());
-            index.setMergeFactor(handler.getMergeFactor());
-            index.setMinMergeDocs(handler.getMinMergeDocs());
-            index.setUseCompoundFile(handler.getUseCompoundFile());
-        } catch (FileSystemException e) {
-            throw new IOException(e.getMessage());
-        }
+        File sub = newIndexFolder();
+        String name = sub.getName();
+        PersistentIndex index = new PersistentIndex(name, sub, true, handler.getAnalyzer());
+        index.setMaxMergeDocs(handler.getMaxMergeDocs());
+        index.setMergeFactor(handler.getMergeFactor());
+        index.setMinMergeDocs(handler.getMinMergeDocs());
+        index.setUseCompoundFile(handler.getUseCompoundFile());
+
+
-            try {
-                fs.deleteFolder(pi.getName());
-            } catch (FileSystemException e) {
+            File dir = new File(indexDir, pi.getName());
+            if (!deleteIndex(dir)) {
-                try {
-                    deletable.write(fs);
-                } catch (FileSystemException e1) {
-                    throw new IOException(e.getMessage());
-                }
-        try {
-            indexNames.write(fs);
-        } catch (FileSystemException e) {
-            throw new IOException(e.getMessage());
-        }
+        indexNames.write(indexDir);
+        deletable.write(indexDir);
-            try {
-                fs.deleteFolder(indexName);
+            File dir = new File(indexDir, indexName);
+            if (deleteIndex(dir)) {
-            } catch (FileSystemException e) {
+            } else {
-            deletable.write(fs);
-        } catch (Exception e) {
-            // catches IOException and FileSystemException
+            deletable.write(indexDir);
+        } catch (IOException e) {
+     * Deletes the index <code>directory</code>.
+     *
+     * @param directory the index directory to delete.
+     * @return <code>true</code> if the delete was successful,
+     *         <code>false</code> otherwise.
+     */
+    private boolean deleteIndex(File directory) {
+        // trivial if it does not exist anymore
+        if (!directory.exists()) {
+            return true;
+        }
+        // delete files first
+        File[] files = directory.listFiles();
+        for (int i = 0; i < files.length; i++) {
+            if (!files[i].delete()) {
+                return false;
+            }
+        }
+        // now delete directory itself
+        return directory.delete();
+    }
+
+    /**
+     * Returns an new index folder which is empty.
+     *
+     * @return the new index folder.
+     * @throws IOException if the folder cannot be created.
+     */
+    private File newIndexFolder() throws IOException {
+        // create new index folder. make sure it does not exist
+        File sub;
+        do {
+            sub = new File(indexDir, indexNames.newName());
+        } while (sub.exists());
+
+        if (!sub.mkdir()) {
+            throw new IOException("Unable to create directory: " + sub.getAbsolutePath());
+        }
+        return sub;
+    }
+
+    /**

JCR-3860: Properly expose missing values in TimeSeries implementations
Add encoding for default value so clients get a chance to identify them. Default is 0 for backward compatibility.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1706408 13f79535-47bb-0310-9956-ffa450edef68

+import static java.util.Arrays.fill;
+
-import org.apache.jackrabbit.api.stats.TimeSeries;
+import org.apache.jackrabbit.api.stats.TimeSeries;
-    private final AtomicLong counter = new AtomicLong();
+    private final AtomicLong counter;
+    /** The value used to encode missing values */
+    private final long missingValue;
+
-    private final long[] valuePerSecond = new long[60];
+    private final long[] valuePerSecond;
-    private final long[] valuePerMinute = new long[60];
+    private final long[] valuePerMinute;
-    private final long[] valuePerHour = new long[7 * 24];
+    private final long[] valuePerHour;
-    private final long[] valuePerWeek = new long[3 * 52];
+    private final long[] valuePerWeek;
-    private int seconds = 0;
+    private int seconds;
-    private int minutes = 0;
+    private int minutes;
-    private int hours = 0;
+    private int hours;
-    private int weeks = 0;
+    private int weeks;
+    /**
+     * Same as {@link #TimeSeriesRecorder(boolean, long)} passing long for the 2nd argument
+     * @param resetValueEachSecond    Whether to reset value each second
+     */
+        this(resetValueEachSecond, 0);
+    }
+
+    /**
+     * @param resetValueEachSecond    Whether to reset value each second
+     * @param missingValue            The value used to encode missing values
+     */
+    public TimeSeriesRecorder(boolean resetValueEachSecond, long missingValue) {
+        this.missingValue = missingValue;
+        counter = new AtomicLong(missingValue);
+        valuePerSecond = newArray(60, missingValue);
+        valuePerMinute = newArray(60, missingValue);
+        valuePerHour = newArray(7 * 24, missingValue);
+        valuePerWeek = newArray(3 * 52, missingValue);
+    }
+
+    private static long[] newArray(int size, long value) {
+        long[] array = new long[size];
+        fill(array, value);
+        return array;
-            valuePerSecond[seconds++] = counter.getAndSet(0);
+            valuePerSecond[seconds++] = counter.getAndSet(missingValue);
+
+    @Override
+    public long getMissingValue() {
+        return missingValue;
+    }
+
+    @Override
+    @Override
+    @Override
+    @Override
-        for (int i = 0; i < array.length; i++) {
-
-            sum += array[i];
+        int count = 0;
+        for (long value : array) {
+            if (value != missingValue) {
+                count++;
+                sum += value;
+            }
-        if (resetValueEachSecond) {
+        if (count == 0) {
+            return missingValue;
+        } else if (resetValueEachSecond) {
+        } else {
+            return round((double) sum / count);
-        return round((double) sum / array.length);

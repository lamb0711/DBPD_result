JCR-3773: Lucene ConsistencyCheck reports nodes under jcr:nodeTypes as deleted

ConsistenyCheck now completely ignores successors of jcr:nodeTypes.

M    jackrabbit-core/src/main/java/org/apache/jackrabbit/core/query/lucene/ConsistencyCheck.java


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1590733 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.commons.conversion.MalformedPathException;
+import org.apache.jackrabbit.spi.commons.name.NameConstants;
+import org.apache.jackrabbit.spi.commons.name.PathBuilder;
+     * Paths of nodes that will be excluded from consistency check
+     */
+    private final Set<Path> ignoredPaths = new HashSet<Path>();
+
+    /**
+        //JCR-3773: ignore the tree jcr:nodeTypes
+        PathBuilder pathBuilder = new PathBuilder();
+        pathBuilder.addRoot();
+        pathBuilder.addLast(NameConstants.JCR_NODETYPES);
+        try {
+            Path path = pathBuilder.getPath();
+            log.info("consistency check will skip " + path);
+            ignoredPaths.add(path);
+        } catch (MalformedPathException e) {
+            //will never happen
+            log.error("Malformed path", e);
+        }
+
-                boolean nodeExists = nodeIds.containsKey(id);
-                if (nodeExists) {
-                    Boolean alreadyIndexed = nodeIds.put(id, Boolean.TRUE);
-                    if (alreadyIndexed) {
-                        multipleEntries.add(id);
+                if (!isIgnored(id)) {
+                    boolean nodeExists = nodeIds.containsKey(id);
+                    if (nodeExists) {
+                        Boolean alreadyIndexed = nodeIds.put(id, Boolean.TRUE);
+                        if (alreadyIndexed) {
+                            multipleEntries.add(id);
+                        }
+                    } else {
+                        errors.add(new NodeDeleted(id));
-                } else {
-                    errors.add(new NodeDeleted(id));
-                if (!nodeIds.containsKey(id)) {
-                    continue; // this node was already marked for deletion
+                if (!nodeIds.containsKey(id) || isIgnored(id)) {
+                    // this node is ignored or was already marked for deletion
+                    continue;
-                if (!indexed && !isExcluded(nodeId)) {
+                if (!indexed && !isIgnored(nodeId) && !isExcluded(nodeId)) {
+    private boolean isIgnored(NodeId id) {
+        try {
+            final HierarchyManager hierarchyManager = handler.getContext().getHierarchyManager();
+            final Path path = hierarchyManager.getPath(id);
+            for (Path excludedPath : ignoredPaths) {
+                if (excludedPath.isEquivalentTo(path) || excludedPath.isAncestorOf(path)) {
+                    return true;
+                }
+            }
+        } catch (RepositoryException ignored) {
+        }
+        return false;
+    }
+

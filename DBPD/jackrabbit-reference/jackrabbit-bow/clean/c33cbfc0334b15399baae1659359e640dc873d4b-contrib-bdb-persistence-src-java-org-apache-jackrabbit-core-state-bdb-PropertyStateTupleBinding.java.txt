simplified and adapted bdb-persistence to latest modifications in core (r329224)

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@329242 13f79535-47bb-0310-9956-ffa450edef68

-import java.io.IOException;
-import java.io.InputStream;
-
-import javax.jcr.PropertyType;
-
-import org.apache.jackrabbit.core.PropertyId;
-import org.apache.jackrabbit.core.nodetype.PropDefId;
-import org.apache.jackrabbit.core.state.PropertyState;
-import org.apache.jackrabbit.core.value.BLOBFileValue;
-import org.apache.jackrabbit.core.value.InternalValue;
-
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.jackrabbit.core.PropertyId;
+import org.apache.jackrabbit.core.state.PropertyState;
+import org.apache.jackrabbit.core.state.util.BLOBStore;
+import org.apache.jackrabbit.core.state.util.Serializer;
+    private Log log = LogFactory.getLog(PropertyStateTupleBinding.class);
+
+
+        PropertyState state = new PropertyState(id.getName(), id.getParentUUID(), PropertyState.STATUS_NEW, false);
+
-            PropertyState state = new PropertyState(id.getName(), id.getParentUUID(), PropertyState.STATUS_NEW, false);
-
-            // type
-            int type = in.readInt();
-            state.setType(type);
-            // multiValued
-            boolean multiValued = in.readBoolean();
-            state.setMultiValued(multiValued);
-            // definitionId
-            String s = in.readString();
-            state.setDefinitionId(PropDefId.valueOf(s));
-            // values
-            int count = in.readInt(); // count
-            InternalValue[] values = new InternalValue[count];
-            for (int i = 0; i < count; i++) {
-                InternalValue val;
-                if (type == PropertyType.BINARY) {
-                    s = in.readString(); // value (i.e. blobId)
-                    // special handling required for binary value:
-                    // the value stores the id of the blob resource in the blob store
-                    val = InternalValue.create(blobStore.get(s));
-                } else {
-                    int len = in.readInt(); // lenght of byte[]
-                    byte[] bytes = new byte[len];
-                    in.read(bytes); // byte[]
-                    s = new String(bytes, BerkeleyDBPersistenceManager.ENCODING);
-                    val = InternalValue.valueOf(s, type);
-                }
-                values[i] = val;
-            }
-            state.setValues(values);
-
-            return state;
+            Serializer.deserialize(state, in, blobStore);
-            throw new RuntimeException(e);
+            // since the TupleInput methods do not throw any
+            // exceptions the above call should neither...
+            String msg = "error while deserializing property state";
+            log.debug(msg);
+            throw new RuntimeException(msg, e);
+
+        return state;
-            PropertyState state = (PropertyState) o;
-
-            // type
-            out.writeInt(state.getType());
-            // multiValued
-            out.writeBoolean(state.isMultiValued());
-            // definitionId
-            out.writeString(state.getDefinitionId().toString());
-            // values
-            InternalValue[] values = state.getValues();
-            out.writeInt(values.length); // count
-            for (int i = 0; i < values.length; i++) {
-                InternalValue val = values[i];
-                if (state.getType() == PropertyType.BINARY) {
-                    // special handling required for binary value:
-                    // spool binary value to file in blob store
-                    BLOBFileValue blobVal = (BLOBFileValue) val.internalValue();
-                    InputStream in = blobVal.getStream();
-                    String blobId;
-                    try {
-                        blobId = blobStore.put((PropertyId) state.getId(), i, in, blobVal.getLength());
-                    } finally {
-                        try {
-                            in.close();
-                        } catch (IOException e) {
-                            // ignore
-                        }
-                    }
-                    // store id of blob as property value
-                    out.writeString(blobId); // value
-                    // replace value instance with value
-                    // backed by resource in blob store and delete temp file
-                    values[i] = InternalValue.create(blobStore.get(blobId));
-                    blobVal.discard();
-                    blobVal = null; // gc hint
-                } else {
-                    byte[] bytes = val.toString().getBytes(BerkeleyDBPersistenceManager.ENCODING);
-                    out.writeInt(bytes.length); // lenght of byte[]
-                    out.write(bytes); // byte[]
-                }
-            }
+            Serializer.serialize((PropertyState) o, out, blobStore);
-            throw new RuntimeException(e);
+            // since the TupleOutput methods do not throw any
+            // exceptions the above call should neither...
+            String msg = "error while serializing property state";
+            log.debug(msg);
+            throw new RuntimeException(msg, e);
-

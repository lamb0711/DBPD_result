JCR-3198: Broken handling of outer join results over davex

Return the set of selector names as a part of the response description field along with column names.

For compatibility with earlier clients/servers this new functionality (and extensible) functionality is only enabled when the search request is made with the query language qualified with the JCR WebDAV extension namespace.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1227240 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.spi.Name;
-    private final Map<Name, NodeId> nodeIds = new HashMap<Name, NodeId>();
+    private final Map<String, NodeId> nodeIds = new HashMap<String, NodeId>();
-    private final Map<Name, Double> scores = new HashMap<Name, Double>();
+    private final Map<String, Double> scores = new HashMap<String, Double>();
-    private final Name[] selectorNames;
-
+
-        this.selectorNames = new Name[selList.size()];
-                this.selectorNames[i] = (selectorName == null) ? null : resolver.getQName(selectorName);
-                    scores.put(this.selectorNames[i], score);
+                    scores.put(selectorName, score);
-                    nodeIds.put(this.selectorNames[i], id);
+                    nodeIds.put(selectorName, id);
-    public NodeId getNodeId(Name selectorName) {
+    public NodeId getNodeId(String selectorName) {
+        if (selectorName == null && scores.size() == 1) {
+            return nodeIds.values().iterator().next();
+        }
+
-        if (id == null) {
-            if (nodeIds.size() == 1) {
-                return nodeIds.values().iterator().next();
-            } else {
-                throw new IllegalArgumentException(selectorName + " is not a valid selectorName");
-            }
+        if (id == null && !nodeIds.containsKey(selectorName)) {
+            throw new IllegalArgumentException(selectorName + " is not a valid selectorName");
-    public double getScore(Name selectorName) {
+    public double getScore(String selectorName) {
+        if (selectorName == null && scores.size() == 1) {
+            return scores.values().iterator().next();
+        }
+
-        if (score == null) {
-            if (scores.size() == 1) {
-                return scores.values().iterator().next();
-            } else {
-                throw new IllegalArgumentException(selectorName + " is not a valid selectorName");
-            }
+        if (score == null && !nodeIds.containsKey(selectorName)) {
+            throw new IllegalArgumentException(selectorName + " is not a valid selectorName");
-    Name[] getSelectorNames() {
-        return selectorNames;
-    }

- [JCR-134] extensibility patch for DavResourceImpl
- moving JcrConstants.java to commons
- fixing minor import issues
- readding lost stuff
- adding proper shutdown to RepositoryStartupServlet.java

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@190721 13f79535-47bb-0310-9956-ffa450edef68

- * NOTE: the timeout requested is always replace by a infinite timeout and
- * expiration of locks is not checked.
-    public ActiveLock getLock(Type type, Scope scope, DavResource resource) {
+    public synchronized ActiveLock getLock(Type type, Scope scope, DavResource resource) {
-	String key = resource.getResourcePath();
-	ActiveLock lock = (locks.containsKey(key)) ? (ActiveLock)locks.get(key) : null;
+        return getLock(resource.getResourcePath());
+    }
-	// look for an inherited lock
-	if (lock == null) {
-	    // cut path instead of retrieving the parent resource
-	    String parentPath = Text.getRelativeParent(key, 1);
-	    boolean found = false;
-	    /* stop as soon as parent lock is found:
-	    if the lock is deep or the parent is a collection the lock
-	    applies to the given resource. */
-	    while (!"/".equals(parentPath) && !(found = locks.containsKey(parentPath))) {
-		parentPath = Text.getRelativeParent(parentPath, 1);
-	    }
-	    if (found) {
-		ActiveLock parentLock = (ActiveLock)locks.get(parentPath);
-		if (parentLock.isDeep()) {
-		    lock = parentLock;
-		}
-	    }
-	}
-	// since locks have infinite timeout, check for expired lock is omitted.
-	return lock;
+    /**
+     * Recursivly tries to find the lock
+     *
+     * @param path
+     * @return
+     */
+    private ActiveLock getLock(String path) {
+	ActiveLock lock = (ActiveLock) locks.get(path);
+        if (lock != null) {
+            // check if not expired
+            if (lock.isExpired()) {
+                lock = null;
+            }
+        }
+        if (lock == null) {
+            // check, if child of deep locked parent
+            if (!path.equals("/")) {
+                ActiveLock parentLock = getLock(Text.getRelativeParent(path, 1));
+                if (parentLock != null && parentLock.isDeep()) {
+                    lock = parentLock;
+                }
+            }
+        }
+        return lock;
-    public synchronized ActiveLock createLock(LockInfo lockInfo, DavResource resource)
+    public synchronized ActiveLock createLock(LockInfo lockInfo,
+                                              DavResource resource)
-	if (locks.containsKey(resourcePath)) {
+        ActiveLock lock = (ActiveLock) locks.get(resourcePath);
+        if (lock != null && lock.isExpired()) {
+            locks.remove(resourcePath);
+            lock = null;
+        }
+        if (lock != null) {
-	ActiveLock lock = new DefaultActiveLock(lockInfo);
-	// Lazy: reset the timeout to 'Infinite', in order to omit the tests for
-	// lock expiration.
-	lock.setTimeout(DavConstants.INFINITE_TIMEOUT);
+	lock = new DefaultActiveLock(lockInfo);
-	// timeout is always infinite > no test for expiration or adjusting timeout needed.
+        lock.setTimeout(lockInfo.getTimeout());
-	// since locks have infinite timeout, check for expiration is omitted.
-

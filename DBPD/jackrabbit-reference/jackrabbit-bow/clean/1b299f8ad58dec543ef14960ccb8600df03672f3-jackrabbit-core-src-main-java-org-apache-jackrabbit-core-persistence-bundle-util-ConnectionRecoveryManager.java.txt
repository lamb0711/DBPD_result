JCR-940: make reconnect work, but throw a RepositoryException if the driver could not be loaded

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@578043 13f79535-47bb-0310-9956-ffa450edef68

+import javax.jcr.RepositoryException;
+
+     * @throws RepositoryException if the database driver could not be loaded
-    public ConnectionRecoveryManager(boolean block, String driver, String url, String user, String password) {
+    public ConnectionRecoveryManager(boolean block, String driver, String url, String user, String password) throws RepositoryException {
+     * @throws RepositoryException if the database driver could not be loaded
-    public synchronized Connection getConnection() throws SQLException {
+    public synchronized Connection getConnection() throws SQLException, RepositoryException {
+     * Executes the given SQL query. Retries once or blocks (when the
+     * <code>block</code> parameter has been set to true on construction)
+     * if this fails and autoReconnect is enabled.
+     *
+     * @param sql the SQL query to execute
+     * @return the executed ResultSet
+     * @throws SQLException on error
+     * @throws RepositoryException if the database driver could not be loaded
+     */
+    public synchronized ResultSet executeQuery(String sql) throws SQLException, RepositoryException {
+        int trials = 2;
+        SQLException lastException  = null;
+        do {
+            trials--;
+            try {
+                return executeQueryInternal(sql);
+            } catch (SQLException e) {
+                lastException = e;
+            }
+        } while(autoReconnect && (block || trials > 0));
+        throw lastException;
+    }
+
+    /**
+     * @throws RepositoryException if the database driver could not be loaded
-    public synchronized ResultSet executeQuery(String sql) throws SQLException {
+    private ResultSet executeQueryInternal(String sql) throws SQLException, RepositoryException {
+     * @throws RepositoryException if the database driver could not be loaded
-    public synchronized Statement executeStmt(String sql, Object[] params) throws SQLException {
+    public Statement executeStmt(String sql, Object[] params) throws SQLException, RepositoryException {
+     * @throws RepositoryException if the database driver could not be loaded
-    public synchronized Statement executeStmt(String sql, Object[] params, boolean returnGeneratedKeys, int maxRows) throws SQLException {
+    public synchronized Statement executeStmt(String sql, Object[] params, boolean returnGeneratedKeys, int maxRows) throws SQLException, RepositoryException {
+        int trials = 2;
+        SQLException lastException  = null;
+        do {
+            trials--;
+            try {
+                return executeStmtInternal(sql, params, returnGeneratedKeys, maxRows);
+            } catch (SQLException e) {
+                lastException = e;
+            }
+        } while(autoReconnect && (block || trials > 0));
+        throw lastException;
+    }
+
+    /**
+     * Executes the given SQL statement with the specified parameters.
+     *
+     * @param sql statement to execute
+     * @param params parameters to set
+     * @param returnGeneratedKeys if the statement should return auto generated keys
+     * @param maxRows the maximum number of rows to return (0 for all rows)
+     * @return the <code>Statement</code> object that had been executed
+     * @throws SQLException if an error occurs
+     * @throws RepositoryException if the database driver could not be loaded
+     */
+    private Statement executeStmtInternal(String sql, Object[] params, boolean returnGeneratedKeys, int maxRows) throws SQLException, RepositoryException {
+     * @throws RepositoryException if the database driver could not be loaded
-    private void setupConnection() throws SQLException {
+    private void setupConnection() throws SQLException, RepositoryException {
-            Class.forName(driver).newInstance();
-        } catch (Exception e) {
-            throw new SQLException("could not load driver: " + e.getMessage());
+            Class driverClass = Class.forName(driver);
+            // Workaround for Apache Derby:
+            // The JDBC specification recommends the Class.ForName method without the .newInstance() method call, 
+            // but adding the newInstance() guarantees that Derby will be booted on any Java Virtual Machine.
+            driverClass.newInstance();
+        } catch (Throwable e) {
+            throw new RepositoryException("Could not load or initialize the database driver class " + driver, e);
-        connection = DriverManager.getConnection(url, user, password);
+        try {
+            connection = DriverManager.getConnection(url, user, password);
+        } catch (SQLException e) {
+            log.warn("Could not connect; driver: " + driver + " url: " + url + " user: " + user + " error: " + e.toString(), e);
+            throw e;
+        }
+     * @throws RepositoryException 
-    private void reestablishConnection() throws SQLException {
+    private void reestablishConnection() throws SQLException, RepositoryException {

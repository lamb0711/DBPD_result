JCR-2104: JSR 283 Full Versioning
- checkpoint must be aware of current activity for the checkout part
- minor improvements such as @Override annotations, removal of unused params, methods, use generics whereever possible



git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@918491 13f79535-47bb-0310-9956-ffa450edef68

-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.security.AccessControlException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import javax.jcr.AccessDeniedException;
-import javax.jcr.Credentials;
-import javax.jcr.GuestCredentials;
-import javax.jcr.ImportUUIDBehavior;
-import javax.jcr.InvalidItemStateException;
-import javax.jcr.ItemExistsException;
-import javax.jcr.ItemNotFoundException;
-import javax.jcr.ItemVisitor;
-import javax.jcr.LoginException;
-import javax.jcr.MergeException;
-import javax.jcr.NamespaceException;
-import javax.jcr.NamespaceRegistry;
-import javax.jcr.NoSuchWorkspaceException;
-import javax.jcr.Node;
-import javax.jcr.NodeIterator;
-import javax.jcr.PathNotFoundException;
-import javax.jcr.Property;
-import javax.jcr.PropertyIterator;
-import javax.jcr.ReferentialIntegrityException;
-import javax.jcr.Repository;
-import javax.jcr.RepositoryException;
-import javax.jcr.Session;
-import javax.jcr.UnsupportedRepositoryOperationException;
-import javax.jcr.Value;
-import javax.jcr.ValueFactory;
-import javax.jcr.ValueFormatException;
-import javax.jcr.Workspace;
-import javax.jcr.lock.Lock;
-import javax.jcr.lock.LockException;
-import javax.jcr.nodetype.ConstraintViolationException;
-import javax.jcr.nodetype.InvalidNodeTypeDefinitionException;
-import javax.jcr.nodetype.NoSuchNodeTypeException;
-import javax.jcr.nodetype.NodeType;
-import javax.jcr.nodetype.NodeTypeDefinition;
-import javax.jcr.nodetype.NodeTypeExistsException;
-import javax.jcr.nodetype.NodeTypeIterator;
-import javax.jcr.nodetype.NodeTypeManager;
-import javax.jcr.observation.EventJournal;
-import javax.jcr.observation.EventListener;
-import javax.jcr.observation.ObservationManager;
-import javax.jcr.query.InvalidQueryException;
-import javax.jcr.query.Query;
-import javax.jcr.query.QueryManager;
-import javax.jcr.util.TraversingItemVisitor;
-import javax.jcr.version.Version;
-import javax.jcr.version.VersionException;
-import javax.jcr.version.VersionHistory;
-import javax.jcr.version.VersionManager;
-
-import org.apache.jackrabbit.JcrConstants;
-import org.apache.jackrabbit.spi.Batch;
-import org.apache.jackrabbit.spi.Event;
-import org.apache.jackrabbit.spi.EventBundle;
-import org.apache.jackrabbit.spi.EventFilter;
-import org.apache.jackrabbit.spi.IdFactory;
-import org.apache.jackrabbit.spi.ItemId;
-import org.apache.jackrabbit.spi.LockInfo;
-import org.apache.jackrabbit.spi.Name;
-import org.apache.jackrabbit.spi.NameFactory;
-import org.apache.jackrabbit.spi.NodeId;
-import org.apache.jackrabbit.spi.NodeInfo;
-import org.apache.jackrabbit.spi.Path;
-import org.apache.jackrabbit.spi.PathFactory;
-import org.apache.jackrabbit.spi.PropertyId;
-import org.apache.jackrabbit.spi.PropertyInfo;
-import org.apache.jackrabbit.spi.QNodeDefinition;
-import org.apache.jackrabbit.spi.QNodeTypeDefinition;
-import org.apache.jackrabbit.spi.QPropertyDefinition;
-import org.apache.jackrabbit.spi.QValue;
-import org.apache.jackrabbit.spi.QValueFactory;
-import org.apache.jackrabbit.spi.QueryInfo;
+import org.apache.jackrabbit.spi.IdFactory;
+import org.apache.jackrabbit.spi.QValueFactory;
+import org.apache.jackrabbit.spi.ItemId;
+import org.apache.jackrabbit.spi.NodeId;
+import org.apache.jackrabbit.spi.QNodeDefinition;
+import org.apache.jackrabbit.spi.QPropertyDefinition;
+import org.apache.jackrabbit.spi.PropertyId;
+import org.apache.jackrabbit.spi.NodeInfo;
+import org.apache.jackrabbit.spi.PropertyInfo;
+import org.apache.jackrabbit.spi.Batch;
+import org.apache.jackrabbit.spi.LockInfo;
+import org.apache.jackrabbit.spi.QueryInfo;
+import org.apache.jackrabbit.spi.EventFilter;
+import org.apache.jackrabbit.spi.EventBundle;
+import org.apache.jackrabbit.spi.QValue;
+import org.apache.jackrabbit.spi.NameFactory;
+import org.apache.jackrabbit.spi.PathFactory;
+import org.apache.jackrabbit.spi.Name;
+import org.apache.jackrabbit.spi.Path;
-import org.apache.jackrabbit.spi.commons.EventBundleImpl;
+import org.apache.jackrabbit.spi.QNodeTypeDefinition;
+import org.apache.jackrabbit.spi.Event;
+import org.apache.jackrabbit.spi.ItemInfo;
+import org.apache.jackrabbit.spi.ChildInfo;
+import org.apache.jackrabbit.spi.commons.EventBundleImpl;
+import org.apache.jackrabbit.spi.commons.QPropertyDefinitionImpl;
-import org.apache.jackrabbit.spi.commons.QPropertyDefinitionImpl;
-import org.apache.jackrabbit.spi.commons.conversion.DefaultNamePathResolver;
-import org.apache.jackrabbit.spi.commons.conversion.MalformedPathException;
-import org.apache.jackrabbit.spi.commons.conversion.NameException;
-import org.apache.jackrabbit.spi.commons.conversion.NamePathResolver;
-import org.apache.jackrabbit.spi.commons.name.NameConstants;
-import org.apache.jackrabbit.spi.commons.name.NameFactoryImpl;
-import org.apache.jackrabbit.spi.commons.name.PathBuilder;
-import org.apache.jackrabbit.spi.commons.name.PathFactoryImpl;
+import org.apache.jackrabbit.spi.commons.name.NameFactoryImpl;
+import org.apache.jackrabbit.spi.commons.name.PathFactoryImpl;
+import org.apache.jackrabbit.spi.commons.name.NameConstants;
+import org.apache.jackrabbit.spi.commons.name.PathBuilder;
+import org.apache.jackrabbit.spi.commons.conversion.NameException;
+import org.apache.jackrabbit.spi.commons.conversion.NamePathResolver;
+import org.apache.jackrabbit.spi.commons.conversion.MalformedPathException;
+import org.apache.jackrabbit.spi.commons.conversion.DefaultNamePathResolver;
-import org.apache.jackrabbit.spi.commons.value.ValueFactoryQImpl;
+import org.apache.jackrabbit.spi.commons.value.ValueFactoryQImpl;
+import org.apache.jackrabbit.JcrConstants;
+
+import javax.jcr.RepositoryException;
+import javax.jcr.Credentials;
+import javax.jcr.LoginException;
+import javax.jcr.NoSuchWorkspaceException;
+import javax.jcr.ItemNotFoundException;
+import javax.jcr.PathNotFoundException;
+import javax.jcr.ValueFormatException;
+import javax.jcr.AccessDeniedException;
+import javax.jcr.UnsupportedRepositoryOperationException;
+import javax.jcr.ItemExistsException;
+import javax.jcr.InvalidItemStateException;
+import javax.jcr.ReferentialIntegrityException;
+import javax.jcr.MergeException;
+import javax.jcr.NamespaceException;
+import javax.jcr.Repository;
+import javax.jcr.Session;
+import javax.jcr.Node;
+import javax.jcr.Property;
+import javax.jcr.NodeIterator;
+import javax.jcr.NamespaceRegistry;
+import javax.jcr.Workspace;
+import javax.jcr.ImportUUIDBehavior;
+import javax.jcr.Value;
+import javax.jcr.ItemVisitor;
+import javax.jcr.ValueFactory;
+import javax.jcr.GuestCredentials;
+import javax.jcr.PropertyIterator;
+import javax.jcr.util.TraversingItemVisitor;
+import javax.jcr.observation.ObservationManager;
+import javax.jcr.observation.EventListener;
+import javax.jcr.observation.EventJournal;
+import javax.jcr.query.InvalidQueryException;
+import javax.jcr.query.QueryManager;
+import javax.jcr.query.Query;
+import javax.jcr.lock.LockException;
+import javax.jcr.lock.Lock;
+import javax.jcr.version.VersionException;
+import javax.jcr.version.VersionHistory;
+import javax.jcr.version.Version;
+import javax.jcr.version.VersionManager;
+import javax.jcr.nodetype.NoSuchNodeTypeException;
+import javax.jcr.nodetype.ConstraintViolationException;
+import javax.jcr.nodetype.NodeTypeManager;
+import javax.jcr.nodetype.NodeTypeIterator;
+import javax.jcr.nodetype.NodeType;
+import javax.jcr.nodetype.InvalidNodeTypeDefinitionException;
+import javax.jcr.nodetype.NodeTypeExistsException;
+import javax.jcr.nodetype.NodeTypeDefinition;
+import java.util.Map;
+import java.util.Iterator;
+import java.util.HashMap;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Collection;
+import java.io.InputStream;
+import java.io.IOException;
+import java.io.ByteArrayInputStream;
+import java.security.AccessControlException;
+    /**
+     * {@inheritDoc}
+     */
-        Map<String, QValue[]> descriptors = new HashMap();
+        Map<String, QValue[]> descriptors = new HashMap<String, QValue[]>();
-                        public String getURI(String prefix) throws NamespaceException {
+                        public String getURI(String prefix) {
-                        public String getPrefix(String uri) throws NamespaceException {
+                        public String getPrefix(String uri) {
-        for (Iterator it = sInfo.getSubscriptions().iterator(); it.hasNext(); ) {
-            EventSubscription s = (EventSubscription) it.next();
+        for (EventSubscription s : sInfo.getSubscriptions()) {
-                for (int i = 0; i < actions.length; i++) {
+                for (String action : actions) {
-                    actStr += actions[i];
+                    actStr += action;
-    public Iterator getItemInfos(SessionInfo sessionInfo, NodeId nodeId)
+    public Iterator<? extends ItemInfo> getItemInfos(SessionInfo sessionInfo, NodeId nodeId)
-            final List itemInfos = new ArrayList();
+            final List<ItemInfo> itemInfos = new ArrayList<ItemInfo>();
+                @Override
+                @Override
+                @Override
+                @Override
-    public Iterator getChildInfos(SessionInfo sessionInfo, NodeId parentId)
+    public Iterator<ChildInfo> getChildInfos(SessionInfo sessionInfo, NodeId parentId)
-        List childInfos = new ArrayList();
+        List<ChildInfo> childInfos = new ArrayList<ChildInfo>();
-            return LockInfoImpl.createLockInfo(lock, idFactory, sInfo.getNamePathResolver());
+            return LockInfoImpl.createLockInfo(lock, idFactory);
-                return LockInfoImpl.createLockInfo(lock, idFactory, sInfo.getNamePathResolver());
+                return LockInfoImpl.createLockInfo(lock, idFactory);
-                // TODO: remove check once jsr283 is released
-                if (sInfo.getSession() instanceof javax.jcr.Session) {
-                    javax.jcr.lock.LockManager lMgr = ((sInfo.getSession().getWorkspace()).getLockManager());
-                    lock = lMgr.lock(n.getPath(), deep, sessionScoped, timeoutHint, ownerHint);
-                } else {
-                    lock = n.lock(deep, sessionScoped);
-                }
-                return LockInfoImpl.createLockInfo(lock, idFactory, sInfo.getNamePathResolver());
+                javax.jcr.lock.LockManager lMgr = (sInfo.getSession().getWorkspace()).getLockManager();
+                lock = lMgr.lock(n.getPath(), deep, sessionScoped, timeoutHint, ownerHint);
+                return LockInfoImpl.createLockInfo(lock, idFactory);
-        return idFactory.createNodeId(newVersion, sInfo.getNamePathResolver());
+        return idFactory.createNodeId(newVersion);
-        sInfo.getSession().getWorkspace().getVersionManager().setActivity(activity);
-        executeWithLocalEvents(new Callable() {
-            public Object run() throws RepositoryException {
-                getNode(nodeId, sInfo).checkout();
-                return null;
-            }
-        }, sInfo);
+        VersionManager vMgr = sInfo.getSession().getWorkspace().getVersionManager();
+        vMgr.setActivity(activity);
+        try {
+            executeWithLocalEvents(new Callable() {
+                public Object run() throws RepositoryException {
+                    getNode(nodeId, sInfo).checkout();
+                    return null;
+                }
+            }, sInfo);
+        } finally {
+            vMgr.setActivity(null);
+        }
+    /**
+     * {@inheritDoc}
+     */
-        return idFactory.createNodeId(newVersion, sInfo.getNamePathResolver());
+        return idFactory.createNodeId(newVersion);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public NodeId checkpoint(SessionInfo sessionInfo, final NodeId nodeId, final NodeId activityId) throws UnsupportedRepositoryOperationException, RepositoryException {
+        final SessionInfoImpl sInfo = getSessionInfoImpl(sessionInfo);
+        Node activity = (activityId == null) ? null : getNode(activityId, sInfo);
+        VersionManager vMgr = sInfo.getSession().getWorkspace().getVersionManager();
+        vMgr.setActivity(activity);
+        try {
+            Version newVersion = (Version) executeWithLocalEvents(new Callable() {
+                public Object run() throws RepositoryException {
+                    VersionManager vMgr = sInfo.getSession().getWorkspace().getVersionManager();
+                    return vMgr.checkpoint(getNodePath(nodeId, sInfo));
+                }
+            }, sInfo);
+            return idFactory.createNodeId(newVersion);
+        } finally {
+            vMgr.setActivity(null);
+        }
-    public Iterator merge(final SessionInfo sessionInfo,
+    public Iterator<NodeId> merge(final SessionInfo sessionInfo,
-        return (Iterator) executeWithLocalEvents(new Callable() {
+        return (Iterator<NodeId>) executeWithLocalEvents(new Callable() {
-                List ids = new ArrayList();
+                List<NodeId> ids = new ArrayList<NodeId>();
-                    ids.add(idFactory.createNodeId(it.nextNode(),
-                            sInfo.getNamePathResolver()));
+                    ids.add(idFactory.createNodeId(it.nextNode()
+                    ));
-    public Iterator merge(final SessionInfo sessionInfo,
+    public Iterator<NodeId> merge(final SessionInfo sessionInfo,
-        return (Iterator) executeWithLocalEvents(new Callable() {
+        return (Iterator<NodeId>) executeWithLocalEvents(new Callable() {
-                List ids = new ArrayList();
+                List<NodeId> ids = new ArrayList<NodeId>();
-                    ids.add(idFactory.createNodeId(it.nextNode(),
-                            sInfo.getNamePathResolver()));
+                    ids.add(idFactory.createNodeId(it.nextNode()
+                    ));
-                List l = Arrays.asList(mergeFailedIds);
+                List<NodeId> l = Arrays.asList(mergeFailedIds);
-                Value[] values = mergeFailed.getValues();
-                for (int i = 0; i < values.length; i++) {
-                    String uuid = values[i].getString();
+                for (Value value : mergeFailed.getValues()) {
+                    String uuid = value.getString();
-                        version = (Version) sInfo.getSession().getNodeByUUID(uuid);
+                        version = (Version) sInfo.getSession().getNodeByIdentifier(uuid);
-                l = new ArrayList(predecessorIds.length);
+                l = new ArrayList<NodeId>(predecessorIds.length);
-                values = predecessors.getValues();
-                for (int i = 0; i < values.length; i++) {
-                    NodeId vId = idFactory.createNodeId(values[i].getString());
+                for (Value value : predecessors.getValues()) {
+                    NodeId vId = idFactory.createNodeId(value.getString());
-        return idFactory.createNodeId(activity, sInfo.getNamePathResolver());
+        return idFactory.createNodeId(activity);
-    public Iterator mergeActivity(SessionInfo sessionInfo, final NodeId activityId) throws UnsupportedRepositoryOperationException, RepositoryException {
+    public Iterator<NodeId> mergeActivity(SessionInfo sessionInfo, final NodeId activityId) throws UnsupportedRepositoryOperationException, RepositoryException {
-        return (Iterator) executeWithLocalEvents(new Callable() {
+        return (Iterator<NodeId>) executeWithLocalEvents(new Callable() {
-                List ids = new ArrayList();
+                List<NodeId> ids = new ArrayList<NodeId>();
-                    ids.add(idFactory.createNodeId(it.nextNode(),
-                            sInfo.getNamePathResolver()));
+                    ids.add(idFactory.createNodeId(it.nextNode()
+                    ));
-        return idFactory.createNodeId(configuration, sInfo.getNamePathResolver());
+        return idFactory.createNodeId(configuration);
-                                    Map namespaces)
+                                    Map<String, String> namespaces)
-        Set ntNames = null;
+        Set<Name> ntNames = null;
-            ntNames = new HashSet(Arrays.asList(nodeTypeName));
+            ntNames = new HashSet<Name>(Arrays.asList(nodeTypeName));
-    public Map getRegisteredNamespaces(SessionInfo sessionInfo)
+    public Map<String, String> getRegisteredNamespaces(SessionInfo sessionInfo)
-        Map namespaces = new HashMap();
-        String[] prefixes = nsReg.getPrefixes();
-        for (int i = 0; i < prefixes.length; i++) {
-            namespaces.put(prefixes[i], nsReg.getURI(prefixes[i]));
+        Map<String, String> namespaces = new HashMap<String, String>();
+        for (String prefix : nsReg.getPrefixes()) {
+            namespaces.put(prefix, nsReg.getURI(prefix));
-        private final Set removedNodeIds = new HashSet();
+        private final Set<NodeId> removedNodeIds = new HashSet<NodeId>();
-                removedNodeIds.add(itemId);
+                removedNodeIds.add(nodeId);
-                    Set mixinNames = new HashSet();
-                    for (int i = 0; i < mixinNodeTypeIds.length; i++) {
-                        mixinNames.add(getJcrName(mixinNodeTypeIds[i]));
+                    Set<String> mixinNames = new HashSet<String>();
+                    for (Name mixinNodeTypeId : mixinNodeTypeIds) {
+                        mixinNames.add(getJcrName(mixinNodeTypeId));
-                    NodeType[] nts = n.getMixinNodeTypes();
-                    Set currentMixins = new HashSet();
-                    for (int i = 0; i < nts.length; i++) {
-                        currentMixins.add(nts[i].getName());
+                    Set<String> currentMixins = new HashSet<String>();
+                    for (NodeType nt : n.getMixinNodeTypes()) {
+                        currentMixins.add(nt.getName());
-                    Set remove = new HashSet(currentMixins);
+                    Set<String> remove = new HashSet<String>(currentMixins);
-                    for (Iterator it = remove.iterator(); it.hasNext(); ) {
-                        n.removeMixin((String) it.next());
+                    for (String mixName : remove) {
+                        n.removeMixin(mixName);
-                    for (Iterator it = mixinNames.iterator(); it.hasNext(); ) {
-                        n.addMixin((String) it.next());
+                    for (String mixName : mixinNames) {
+                        n.addMixin(mixName);
-        // TODO: improve. avoid roundtrip over node access.
+        // TODO: improve. avoid round trip over node access.
-                              Map namespaces)
+                              Map<String, String> namespaces)
-        Map previous = setNamespaceMappings(session, namespaces);
+        Map<String, String> previous = setNamespaceMappings(session, namespaces);
-    private Map setNamespaceMappings(Session session, Map namespaces)
+    private Map<String, String> setNamespaceMappings(Session session, Map<String, String> namespaces)
-        Map previous = new HashMap();
+        Map<String, String> previous = new HashMap<String, String>();
-        Iterator iterator = namespaces.entrySet().iterator();
-        while (iterator.hasNext()) {
-            Map.Entry entry = (Map.Entry) iterator.next();
-            String uri = (String) entry.getValue();
-            String prefix = (String) entry.getKey();
+        for (Map.Entry<String, String> entry : namespaces.entrySet()) {
+            String uri = entry.getValue();
+            String prefix = entry.getKey();
-            Collection subscr = sInfo.getSubscriptions();
+            Collection<EventSubscription> subscr = sInfo.getSubscriptions();
-                List listeners = new ArrayList(subscr.size());
+                List<EventListener> listeners = new ArrayList<EventListener>(subscr.size());
-                    for (Iterator it = subscr.iterator(); it.hasNext(); ) {
-                        EventSubscription s = (EventSubscription) it.next();
+                    for (EventSubscription s : subscr) {
-                    for (Iterator it = listeners.iterator(); it.hasNext(); ) {
+                    for (EventListener listener : listeners) {
-                            obsMgr.removeEventListener((EventListener) it.next());
+                            obsMgr.removeEventListener(listener);

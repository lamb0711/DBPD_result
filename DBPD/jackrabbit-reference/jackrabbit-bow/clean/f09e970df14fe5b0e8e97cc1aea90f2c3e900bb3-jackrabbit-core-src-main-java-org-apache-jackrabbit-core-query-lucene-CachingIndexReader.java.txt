JCR-1337: Optimize first execution queries for DescendantSelfAxisWeight/ChildAxisQuery

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@615223 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.uuid.UUID;
+import java.util.Map;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.text.NumberFormat;
+     * @throws IOException if an error occurs while reading from the index.
-    CachingIndexReader(IndexReader delegatee, DocNumberCache cache) {
+    CachingIndexReader(IndexReader delegatee, DocNumberCache cache)
+            throws IOException {
+        initializeParents(delegatee);
+     * Initializes the {@link #parents} <code>DocId</code> array.
+     *
+     * @param reader the underlying index reader.
+     * @throws IOException if an error occurs while reading from the index.
+     */
+    private void initializeParents(IndexReader reader) throws IOException {
+        long time = System.currentTimeMillis();
+        Map docs = new HashMap();
+        for (int i = 0; i < reader.maxDoc(); i++) {
+            if (!reader.isDeleted(i)) {
+                Document doc = reader.document(i, FieldSelectors.UUID_AND_PARENT);
+                UUID uuid = UUID.fromString(doc.get(FieldNames.UUID));
+                UUID parent = null;
+                try {
+                    parent = UUID.fromString(doc.get(FieldNames.PARENT));
+                } catch (IllegalArgumentException e) {
+                    // root node does not have a parent
+                }
+                NodeInfo info = new NodeInfo(i, uuid, parent);
+                docs.put(uuid, info);
+            }
+        }
+        double foreignParents = 0;
+        for (Iterator it = docs.values().iterator(); it.hasNext(); ) {
+            NodeInfo info = (NodeInfo) it.next();
+            NodeInfo parent = (NodeInfo) docs.get(info.parent);
+            if (parent != null) {
+                parents[info.docId] = DocId.create(parent.docId);
+            } else if (info.parent != null) {
+                foreignParents++;
+                parents[info.docId] = DocId.create(info.parent);
+            } else {
+                // no parent -> root node
+                parents[info.docId] = DocId.NULL;
+            }
+        }
+        if (log.isDebugEnabled()) {
+            NumberFormat nf = NumberFormat.getPercentInstance();
+            nf.setMaximumFractionDigits(1);
+            time = System.currentTimeMillis() - time;
+            if (parents.length > 0) {
+                foreignParents /= parents.length;
+            }
+            log.debug("initialized {} DocIds in {} ms, {} foreign parents",
+                    new Object[]{
+                        new Integer(parents.length),
+                        new Long(time),
+                        nf.format(foreignParents)
+                    });
+        }
+    }
+
+    private static class NodeInfo {
+
+        final int docId;
+
+        final UUID uuid;
+
+        final UUID parent;
+
+        public NodeInfo(int docId, UUID uuid, UUID parent) {
+            this.docId = docId;
+            this.uuid = uuid;
+            this.parent = parent;
+        }
+    }
+
+    /**

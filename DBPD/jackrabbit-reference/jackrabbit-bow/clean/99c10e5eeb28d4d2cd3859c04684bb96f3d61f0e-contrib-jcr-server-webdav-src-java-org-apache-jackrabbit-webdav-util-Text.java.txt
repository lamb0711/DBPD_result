- comitting latest changes from angela
- adding configuration for authorization header behaviour

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@159798 13f79535-47bb-0310-9956-ffa450edef68

+import java.security.MessageDigest;
-public final class Text extends org.apache.jackrabbit.core.util.Text {
+public final class Text {
+
+    /**
+     * used for the md5
+     */
+    public final static char[] HEXTABLE = "0123456789abcdef".toCharArray();
-     * <p>
+     * <p/>
-	    synchronized (dateFormatter) {
-		dateFormatter.applyPattern( ... );
-		dateFormatter.setTimezone( ... );
-		String result = dateFormatter.format( ... );
-	    }
-     *	</pre>
-     * <p>
+     * synchronized (dateFormatter) {
+     * dateFormatter.applyPattern( ... );
+     * dateFormatter.setTimezone( ... );
+     * String result = dateFormatter.format( ... );
+     * }
+     * 	</pre>
+     * <p/>
-	    synchronized (dateFormatter) {
-		dateFormatter.applyPattern( ... );
-		dateFormatter.setTimezone( ... );
-	        try {
-		    Date result = dateFormatter.parse(dateString);
-	        } catch (ParseException pe) {
-		    // handle exception
-	        }
-	    }
-     *	</pre>
-     *
+     * synchronized (dateFormatter) {
+     * dateFormatter.applyPattern( ... );
+     * dateFormatter.setTimezone( ... );
+     * try {
+     * Date result = dateFormatter.parse(dateString);
+     * } catch (ParseException pe) {
+     * // handle exception
+     * }
+     * }
+     * 	</pre>
-    /** format for RFC 1123 date string -- "Sun, 06 Nov 1994 08:49:37 GMT" */
+    /**
+     * format for RFC 1123 date string -- "Sun, 06 Nov 1994 08:49:37 GMT"
+     */
-	new SimpleDateFormat("EEE, dd MMM yyyyy HH:mm:ss z", Locale.US);
+            new SimpleDateFormat("EEE, dd MMM yyyyy HH:mm:ss z", Locale.US);
-	rfc1123Format.setTimeZone(TIMEZONE_UTC);
+        rfc1123Format.setTimeZone(TIMEZONE_UTC);
-     * @param ch the character to use a split pattern
+     * @param ch  the character to use a split pattern
-	return explode(str,ch,false);
+        return explode(str, ch, false);
-     * @param str the string to decompose
-     * @param ch the character to use a split pattern
+     *
+     * @param str          the string to decompose
+     * @param ch           the character to use a split pattern
-	if (str == null) {
+        if (str == null) {
-        int pos     = 0;
+        int pos = 0;
-	    if (pos-lastpos>0 || respectEmpty)
+            if (pos - lastpos > 0 || respectEmpty)
-            lastpos = pos+1;
+            lastpos = pos + 1;
-        } else if (respectEmpty && lastpos==str.length()) {
-	    strings.add("");
-	}
+        } else if (respectEmpty && lastpos == str.length()) {
+            strings.add("");
+        }
-	StringBuffer buf = new StringBuffer();
-	for (int i=0; i<arr.length; i++) {
-	    if (i>0) {
-		buf.append(delim);
-	    }
-	    buf.append(arr[i]);
-	}
-	return buf.toString();
+        StringBuffer buf = new StringBuffer();
+        for (int i = 0; i < arr.length; i++) {
+            if (i > 0) {
+                buf.append(delim);
+            }
+            buf.append(arr[i]);
+        }
+        return buf.toString();
-    	char[] ca1=h1.toCharArray(); // this is faster, than a .charAt everytime
-	char[] ca2=h2.toCharArray();
-        int n= ca1.length < ca2.length ? ca1.length : ca2.length;
-        int i=0;
-	while (i<n) {
-    	    if (ca1[i]!=ca2[i]) {
-    		char c1= ca1[i];
-		char c2= ca2[i];
-		// we give the '/' the highest priority
-		if      (c1=='/') c1=1;
-		else if (c2=='/') c2=1;
-		return c1-c2;
-	    }
+        char[] ca1 = h1.toCharArray(); // this is faster, than a .charAt everytime
+        char[] ca2 = h2.toCharArray();
+        int n = ca1.length < ca2.length ? ca1.length : ca2.length;
+        int i = 0;
+        while (i < n) {
+            if (ca1[i] != ca2[i]) {
+                char c1 = ca1[i];
+                char c2 = ca2[i];
+                // we give the '/' the highest priority
+                if (c1 == '/')
+                    c1 = 1;
+                else if (c2 == '/') c2 = 1;
+                return c1 - c2;
+            }
-	}
-	return ca1.length-ca2.length;
+        }
+        return ca1.length - ca2.length;
-     * @param path the path
+     * @param path   the path
-	if (parent==null) parent="";
-	if (path==null) path="";
+        if (parent == null) parent = "";
+        if (path == null) path = "";
-        if (path.equals("") || (path.charAt(0)!='/' && path.indexOf(':')<0)) {
+        if (path.equals("") || (path.charAt(0) != '/' && path.indexOf(':') < 0)) {
-            source = new StringBuffer(path==null?"":path);
+            source = new StringBuffer(path == null ? "" : path);
-	return makeCanonicalPath(source);
+        return makeCanonicalPath(source);
-	if (base==null) base="";
-	if (path==null) path="";
+        if (base == null) base = "";
+        if (path == null) path = "";
-        if (path.equals("") || path.charAt(0)!='/') {
+        if (path.equals("") || path.charAt(0) != '/') {
-            source = new StringBuffer(path==null?"":path);
+            source = new StringBuffer(path == null ? "" : path);
-	return makeCanonicalPath(source);
+        return makeCanonicalPath(source);
+     *
-	return makeCanonicalPath(new StringBuffer(path));
+        return makeCanonicalPath(new StringBuffer(path));
+     *
-        int   dst=0, pos=0, slash=0, dots=0, last=0, len=source.length();
-        int[] slashes=new int[1024];
-        slashes[0]=source.charAt(0)=='/' ? 0 : -1;
-        while (pos<len) {
-            int ch=source.charAt(pos++);
+        int dst = 0, pos = 0, slash = 0, dots = 0, last = 0, len = source.length();
+        int[] slashes = new int[1024];
+        slashes[0] = source.charAt(0) == '/' ? 0 : -1;
+        while (pos < len) {
+            int ch = source.charAt(pos++);
-                    if (last=='/') continue;
+                    if (last == '/') continue;
-                    if (dots==1) {
+                    if (dots == 1) {
-                        dst=slashes[slash];
-                    } else if (dots==2) {
+                        dst = slashes[slash];
+                    } else if (dots == 2) {
-                        if (--slash <0) slash=0;
-                        dst=slashes[slash];
+                        if (--slash < 0) slash = 0;
+                        dst = slashes[slash];
-                        slashes[++slash]=dst;
+                        slashes[++slash] = dst;
-                    dots=0;
+                    dots = 0;
-                    dots=3;
+                    dots = 3;
-	    last=ch;
-            if (dst>=0) source.setCharAt(dst, (char) (last=ch));
-	    dst++;
+            last = ch;
+            if (dst >= 0) source.setCharAt(dst, (char) (last = ch));
+            dst++;
-        if (dst>0) source.setLength(dst);
-	return dst==0 ? "/" : source.toString();
+        if (dst > 0) source.setLength(dst);
+        return dst == 0 ? "/" : source.toString();
+     *
-     public static boolean isSibling(String h1, String h2) {
+    public static boolean isSibling(String h1, String h2) {
-        return (pos1==pos2 && pos1>=0 && h1.regionMatches(0,h2,0,pos1));
-     }
+        return (pos1 == pos2 && pos1 >= 0 && h1.regionMatches(0, h2, 0, pos1));
+    }
-     * @param handle the current handle
+     * @param handle     the current handle
-            descendant.startsWith(handle) &&
-                descendant.charAt(handle.length())=='/';
+                descendant.startsWith(handle) &&
+                descendant.charAt(handle.length()) == '/';
-     * @param path the path to check
+     * @param path       the path to check
-	if (path.equals(descendant)) {
-	    return true;
-	} else {
-	    String pattern = path.endsWith("/") ? path : path + "/";
-	    return descendant.startsWith(pattern);
-	}
+        if (path.equals(descendant)) {
+            return true;
+        } else {
+            String pattern = path.endsWith("/") ? path : path + "/";
+            return descendant.startsWith(pattern);
+        }
+     *
-        int pos=handle.lastIndexOf('/');
-        return pos>=0 ? handle.substring(pos+1) : "";
+        int pos = handle.lastIndexOf('/');
+        return pos >= 0 ? handle.substring(pos + 1) : "";
+     *
-     * @param delim the delimiter
+     * @param delim  the delimiter
-        int pos=handle.lastIndexOf(delim);
-        return pos>=0 ? handle.substring(pos+1) : "";
+        int pos = handle.lastIndexOf(delim);
+        return pos >= 0 ? handle.substring(pos + 1) : "";
-     *        supported by the MessageDigest class.
-     * @param data The plain text String to be digested.
-     *
+     *                  supported by the MessageDigest class.
+     * @param data      The plain text String to be digested.
-     *
-     *         the MessageDigest class.
-     *
-     * @deprecated since echidna, use {@link #digest(String, String, String)}
+     *                                  the MessageDigest class.
+     * Digest the plain string using the given algorithm.
+     *
+     * @param algorithm The alogrithm for the digest. This algorithm must be
+     *                  supported by the MessageDigest class.
+     * @param data      The plain text String to be digested.
+     * @param enc       The character encoding to use
+     * @return The digested plain text String represented as Hex digits.
+     * @throws NoSuchAlgorithmException     if the desired algorithm is not supported by
+     *                                      the MessageDigest class.
+     * @throws UnsupportedEncodingException if the encoding is not supported
+     */
+    public static String digest(String algorithm, String data, String enc)
+            throws NoSuchAlgorithmException, UnsupportedEncodingException {
+
+        return digest(algorithm, data.getBytes(enc));
+    }
+
+    /**
+     * Digest the plain string using the given algorithm.
+     *
+     * @param algorithm The alogrithm for the digest. This algorithm must be
+     *                  supported by the MessageDigest class.
+     * @param data      the data to digest with the given algorithm
+     * @return The digested plain text String represented as Hex digits.
+     * @throws NoSuchAlgorithmException if the desired algorithm is not supported by
+     *                                  the MessageDigest class.
+     */
+    public static String digest(String algorithm, byte[] data)
+            throws NoSuchAlgorithmException {
+
+        MessageDigest md = MessageDigest.getInstance(algorithm);
+        byte[] digest = md.digest(data);
+        StringBuffer res = new StringBuffer(digest.length * 2);
+        for (int i = 0; i < digest.length; i++) {
+            byte b = digest[i];
+            res.append(HEXTABLE[(b >> 4) & 15]);
+            res.append(HEXTABLE[b & 15]);
+        }
+        return res.toString();
+    }
+
+    /**
-     * @param level the level of the parent
+     * @param level  the level of the parent
-	int idx = handle.length();
-	while (level > 0) {
-	    idx = handle.lastIndexOf('/',idx-1);
-	    if (idx < 0) {
-		return "";
-	    }
-	    level--;
-	}
-	return (idx == 0) ? "/" : handle.substring(0,idx);
+        int idx = handle.length();
+        while (level > 0) {
+            idx = handle.lastIndexOf('/', idx - 1);
+            if (idx < 0) {
+                return "";
+            }
+            level--;
+        }
+        return (idx == 0) ? "/" : handle.substring(0, idx);
-     * @param level the level of the parent
+     * @param level  the level of the parent
-	int idx = 0;
+        int idx = 0;
-	while (level >= 0 && idx<len) {
-	    idx = handle.indexOf('/', idx+1);
-	    if (idx < 0) {
-		idx=len;
-	    }
-	    level--;
-	}
-	return level>=0 ? "" : handle.substring(0,idx);
+        while (level >= 0 && idx < len) {
+            idx = handle.indexOf('/', idx + 1);
+            if (idx < 0) {
+                idx = len;
+            }
+            level--;
+        }
+        return level >= 0 ? "" : handle.substring(0, idx);
-     *
+     * <p/>
-	URISave = new BitSet(256);
-	int i;
-	for (i = 'a'; i <= 'z'; i++) {
-	    URISave.set(i);
-	}
-	for (i = 'A'; i <= 'Z'; i++) {
-	    URISave.set(i);
-	}
-	for (i = '0'; i <= '9'; i++) {
-	    URISave.set(i);
-	}
-	URISave.set('-');
-	URISave.set('_');
-	URISave.set('.');
-	URISave.set('!');
-	URISave.set('~');
-	URISave.set('*');
-	URISave.set('\'');
-	URISave.set('(');
-	URISave.set(')');
+        URISave = new BitSet(256);
+        int i;
+        for (i = 'a'; i <= 'z'; i++) {
+            URISave.set(i);
+        }
+        for (i = 'A'; i <= 'Z'; i++) {
+            URISave.set(i);
+        }
+        for (i = '0'; i <= '9'; i++) {
+            URISave.set(i);
+        }
+        URISave.set('-');
+        URISave.set('_');
+        URISave.set('.');
+        URISave.set('!');
+        URISave.set('~');
+        URISave.set('*');
+        URISave.set('\'');
+        URISave.set('(');
+        URISave.set(')');
-     *
-     *
-     *
-	try {
-	    BitSet validChars = isPath ? URISaveEx : URISave;
-	    byte[] bytes = string.getBytes("utf-8");
-	    StringBuffer out = new StringBuffer(bytes.length);
-	    for (int i = 0; i < bytes.length; i++) {
-		int c = bytes[i]&0xff;
-		if (validChars.get(c) && c!=escape) {
-		    out.append((char)c);
-		} else {
-		    out.append(escape);
-		    out.append(hexTable[(c>>4) & 0x0f]);
-		    out.append(hexTable[(c   ) & 0x0f]);
-		}
-	    }
-	    return out.toString();
-	} catch (UnsupportedEncodingException e) {
-	    throw new InternalError(e.toString());
+        try {
+            BitSet validChars = isPath ? URISaveEx : URISave;
+            byte[] bytes = string.getBytes("utf-8");
+            StringBuffer out = new StringBuffer(bytes.length);
+            for (int i = 0; i < bytes.length; i++) {
+                int c = bytes[i] & 0xff;
+                if (validChars.get(c) && c != escape) {
+                    out.append((char) c);
+                } else {
+                    out.append(escape);
+                    out.append(HEXTABLE[(c >> 4) & 0x0f]);
+                    out.append(HEXTABLE[(c) & 0x0f]);
+                }
+            }
+            return out.toString();
+        } catch (UnsupportedEncodingException e) {
+            throw new InternalError(e.toString());
-     *
-	return escape(string, '%');
+        return escape(string, '%');
-     *
-	return escape(path, '%', true);
+        return escape(path, '%', true);
+     *
-     *
-     * @throws NullPointerException if <code>string</code> is <code>null</code>.
+     * @throws NullPointerException           if <code>string</code> is <code>null</code>.
-     *         escape character
-     * @throws IllegalArgumentException if the 2 characters following the escape
-     *         character do not represent a hex-number.
+     *                                        escape character
+     * @throws IllegalArgumentException       if the 2 characters following the escape
+     *                                        character do not represent a hex-number.
-	ByteArrayOutputStream out = new ByteArrayOutputStream(string.length());
-        for (int i=0; i<string.length(); i++) {
+        ByteArrayOutputStream out = new ByteArrayOutputStream(string.length());
+        for (int i = 0; i < string.length(); i++) {
-	    if (c==escape) {
-		try {
-		    out.write(Integer.parseInt(string.substring(i+1,i+3),16));
-		} catch (NumberFormatException e) {
-		    throw new IllegalArgumentException();
-		}
-		i += 2;
-	    } else {
-		out.write(c);
+            if (c == escape) {
+                try {
+                    out.write(Integer.parseInt(string.substring(i + 1, i + 3), 16));
+                } catch (NumberFormatException e) {
+                    throw new IllegalArgumentException();
+                }
+                i += 2;
+            } else {
+                out.write(c);
-	    return new String(out.toByteArray(), "utf-8");
+            return new String(out.toByteArray(), "utf-8");
-	    throw new InternalError(e.toString());
+            throw new InternalError(e.toString());
-     *
-     * @throws NullPointerException if <code>string</code> is <code>null</code>.
+     * @throws NullPointerException           if <code>string</code> is <code>null</code>.
-     *         escape character
-     * @throws IllegalArgumentException if the 2 characters following the escape
-     *         character do not represent a hex-number.
+     *                                        escape character
+     * @throws IllegalArgumentException       if the 2 characters following the escape
+     *                                        character do not represent a hex-number.
-	return unescape(string, '%');
+        return unescape(string, '%');
-     * @param date The date value to be formatted
+     * @param date          The date value to be formatted
-     * 		supports a subset of the pattern characters of the POSIX
-     * 		<code>strftime()</code> function. If this pattern is empty or
-     * 		<code>null</code> the default pattern
-     * 		<code>dd.MM.yyyy HH:mm:ss</code> is used.
-     * @param zone Defines for which time zone the date should be outputted. If
-     *      this parameter is <code>null</code>, then the local time zone is taken.
-     *
+     *                      supports a subset of the pattern characters of the POSIX
+     *                      <code>strftime()</code> function. If this pattern is empty or
+     *                      <code>null</code> the default pattern
+     *                      <code>dd.MM.yyyy HH:mm:ss</code> is used.
+     * @param zone          Defines for which time zone the date should be outputted. If
+     *                      this parameter is <code>null</code>, then the local time zone is taken.
-        synchronized(dateFormatter) {
+        synchronized (dateFormatter) {
-     * @param date The date value to be formatted
+     * @param date          The date value to be formatted
-     * 		supports a subset of the pattern characters of the POSIX
-     * 		<code>strftime()</code> function. If this pattern is empty or
-     * 		<code>null</code> the default pattern
-     * 		<code>dd.MM.yyyy HH:mm:ss</code> is used.
-     * @param   asUTC Defines whether to interpret the date as belong to the UTC
-     * 		time zone or the local time zone.
+     *                      supports a subset of the pattern characters of the POSIX
+     *                      <code>strftime()</code> function. If this pattern is empty or
+     *                      <code>null</code> the default pattern
+     *                      <code>dd.MM.yyyy HH:mm:ss</code> is used.
+     * @param asUTC         Defines whether to interpret the date as belong to the UTC
+     *                      time zone or the local time zone.
-     * @param date The date value to be formatted
+     * @param date  The date value to be formatted
-     * 		time zone or the local time zone.
+     *              time zone or the local time zone.
-	return strftime(date, null, asUTC);
+        return strftime(date, null, asUTC);
-	return strftime(date, null, false);
+        return strftime(date, null, false);
-     * @param dateString The date string to be parsed
+     * @param dateString    The date string to be parsed
-     * 		or empty, the same default pattern is used as with
-     * 		{@link #strftime(Date, String, boolean)}, namely
-     * 		<code>dd.MM.yyyy HH:mm:ss</code>.
-     *
+     *                      or empty, the same default pattern is used as with
+     *                      {@link #strftime(Date, String, boolean)}, namely
+     *                      <code>dd.MM.yyyy HH:mm:ss</code>.
-     * 		to the format pattern.
+     *                        to the format pattern.
-	    throws ParseException {
+            throws ParseException {
-	return parseDate(dateString, formatPattern, false);
+        return parseDate(dateString, formatPattern, false);
-     * @param dateString The date string to be parsed
+     * @param dateString    The date string to be parsed
-     * 		or empty, the same default pattern is used as with
-     * 		{@link #strftime(Date, String, boolean)}, namely
-     * 		<code>dd.MM.yyyy HH:mm:ss</code>.
-     * @param isUTC if <code>true</code> the date string is considered in UTC,
-     *        otherwise the default timezone of the host is used.
-     *
+     *                      or empty, the same default pattern is used as with
+     *                      {@link #strftime(Date, String, boolean)}, namely
+     *                      <code>dd.MM.yyyy HH:mm:ss</code>.
+     * @param isUTC         if <code>true</code> the date string is considered in UTC,
+     *                      otherwise the default timezone of the host is used.
-     * 		to the format pattern.
+     *                        to the format pattern.
-				       boolean isUTC)
-	    throws ParseException {
+                                       boolean isUTC)
+            throws ParseException {
-	synchronized (dateFormatter) {
-	    dateFormatter.applyPattern(formatPattern);
-	    if (isUTC) {
-		dateFormatter.setTimeZone(TIMEZONE_UTC);
-	    } else {
-		dateFormatter.setTimeZone(TimeZone.getDefault());
-	    }
-	    return dateFormatter.parse(dateString);
-	}
+        synchronized (dateFormatter) {
+            dateFormatter.applyPattern(formatPattern);
+            if (isUTC) {
+                dateFormatter.setTimeZone(TIMEZONE_UTC);
+            } else {
+                dateFormatter.setTimeZone(TimeZone.getDefault());
+            }
+            return dateFormatter.parse(dateString);
+        }
-     *
-     * 		to the format pattern.
+     *                        to the format pattern.
-	return parseDate(dateString, DEFAULT_DATE_FORMAT_PATTERN, false);
+        return parseDate(dateString, DEFAULT_DATE_FORMAT_PATTERN, false);
-     * @param isUTC if <code>true</code> the date string is considered in UTC,
-     *        otherwise the default timezone of the host is used.
-     *
-     *
+     * @param isUTC      if <code>true</code> the date string is considered in UTC,
+     *                   otherwise the default timezone of the host is used.
-     * 		to the format pattern.
+     *                        to the format pattern.
-	    throws ParseException {
-	return parseDate(dateString, DEFAULT_DATE_FORMAT_PATTERN, isUTC);
+            throws ParseException {
+        return parseDate(dateString, DEFAULT_DATE_FORMAT_PATTERN, isUTC);
-    /** left justified - '-' flag */
+    /**
+     * left justified - '-' flag
+     */
-    /** always show sign - '+' flag */
+    /**
+     * always show sign - '+' flag
+     */
-    /** space placeholder for omitted plus sign - ' ' flag, ignore if SI */
+    /**
+     * space placeholder for omitted plus sign - ' ' flag, ignore if SI
+     */
-    /** zero padded if right aligned - '0' flag, ignore if LJ */
+    /**
+     * zero padded if right aligned - '0' flag, ignore if LJ
+     */
-     * 	SI  - incr. precision to have zero as first char
-     * 	x   - prefix '0x'
-     * 	X   - prefix '0X'
-     *  eEf - always show decimal point, omit trailing zeroes
-     *  gG  - always show decimal point, show trailing zeroes
+     * SI  - incr. precision to have zero as first char
+     * x   - prefix '0x'
+     * X   - prefix '0X'
+     * eEf - always show decimal point, omit trailing zeroes
+     * gG  - always show decimal point, show trailing zeroes
-    /** interpret ints as short - 'h' size */
+    /**
+     * interpret ints as short - 'h' size
+     */
-    /** interpret ints as long - 'l' size */
+    /**
+     * interpret ints as long - 'l' size
+     */
-    /** waiting for format */
+    /**
+     * waiting for format
+     */
-    /** parsing flags */
+    /**
+     * parsing flags
+     */
-    /** parsing wdth */
+    /**
+     * parsing wdth
+     */
-    /** parsing precision */
+    /**
+     * parsing precision
+     */
-    /** parsing size */
+    /**
+     * parsing size
+     */
-    /** parsing type */
+    /**
+     * parsing type
+     */
-    /** parsing finished */
+    /**
+     * parsing finished
+     */
-    /** incomplete pattern at end of format string, throw error */
+    /**
+     * incomplete pattern at end of format string, throw error
+     */
-    /** end of format string during plain text */
+    /**
+     * end of format string during plain text
+     */
-     * <p>
+     * <p/>
-     * <p>
+     * <p/>
-     * <p>
+     * <p/>
-     * <p>
+     * <p/>
-     *   <code>
-     *     [ <i>flags</i> ] [ <i>width</i> ] [ "." <i>prec</i> ] [ <i>size</i> ]
-     *     <i>type</i>
-     *   </code>
+     * <code>
+     * [ <i>flags</i> ] [ <i>width</i> ] [ "." <i>prec</i> ] [ <i>size</i> ]
+     * <i>type</i>
+     * </code>
-     * <p>
+     * <p/>
-     *
+     * <p/>
-     *
+     * <p/>
-     *   <tr>
-     *     <td><code>-</code></td>
-     *     <td>The result of the conversion is left justified, and the right
-     *         is  padded with blanks. If you do not use this flag, the result
-     *         is right justified,  and  padded  on  the left.</td>
-     *   </tr>
-     *   <tr>
-     *   <td><code>+</code></td>
-     *   <td>The  result of a signed conversion (as determined by <i>type</i>)
-     *       will always begin with a plus or minus sign. (If you do not use
-     *       this flag, positive values do not begin with a plus sign.)</td>
-     *   </tr>
-     *   <tr>
-     *     <td>"<code> </code>" (space)</td>
-     *     <td>If the first character of a  signed conversion  specification is
-     *         not a sign, or if a signed conversion results in no characters,
-     *         the result will begin  with a space. If the space
-     *         (<code> </code>) flag and the plus (<code>+</code>) flag both
-     *         appear, the space flag is ignored.</td>
-     *   </tr>
-     *   <tr>
-     *     <td><code>0</code></td>
-     *     <td>If the <i>type</i> is <code>d</code>, <code>i</code>,
-     *         <code>o</code>, <code>u</code>, <code>x</code>, <code>X</code>,
-     *         <code>e</code>, <code>E</code>, <code>f</code>, <code>g</code>,
-     *         or <code>G</code>:  leading  zeroes,  are  used to pad the field
-     *         width (following any indication of sign or base); no spaces
-     *         are used  for  padding.  If the zero (<code>0</code>) and minus
-     *         (<code>-</code>) flags both appear, the zero (<code>0</code>)
-     *         flag will be ignored. For <code>d</code>, <code>i</code>,
-     *         <code>o</code>, <code>u</code>, <code>x</code>, <code>X</code>
-     *         conversions, if a precision <i>prec</i> is specified, the zero
-     *         (<code>0</code>) flag is ignored.
-     *         <br>
-     *         Note that <i>0</i> is interpreted as a flag, not as the
-     *         beginning of a field width.</td>
-     *   </tr>
-     *   <tr>
-     *     <td><code>#</code></td>
-     *     <td>The result is to be converted to an alternative form, according
-     *         to the <i>type</i> character:
-     *         <dl>
-     *         <dt><code>o</code>
-     *         <dd>Increases precision to force the first digit of the result
-     *             to be a zero.
-     *
-     *         <dt><code>x</code>
-     *         <dl>A non-zero result will have a <code>0x</code> prefix.
-     *
-     *         <dt><code>X</code>
-     *         <dl>A non-zero result will have a <code>0X</code> prefix.
-     *
-     *         <dt><code>e</code>, <code>E</code>, or <code>f</code>
-     *         <dl>The result will always contain a decimal point even if no
-     *             digits follow the point. (Normally, a decimal point appears
-     *             only if a digit follows it.) Trailing zeroes are removed.
-     *
-     *         <dt><code>g</code> or <code>G</code>
-     *         <dl>Same as <code>e</code> or <code>E</code>, but trailing
-     *             zeroes arenot removed.
-     *
-     *         <dt>all others
-     *         <dd>Undefined.
-     *         </dl></td>
-     *   </tr>
+     * <tr>
+     * <td><code>-</code></td>
+     * <td>The result of the conversion is left justified, and the right
+     * is  padded with blanks. If you do not use this flag, the result
+     * is right justified,  and  padded  on  the left.</td>
+     * </tr>
+     * <tr>
+     * <td><code>+</code></td>
+     * <td>The  result of a signed conversion (as determined by <i>type</i>)
+     * will always begin with a plus or minus sign. (If you do not use
+     * this flag, positive values do not begin with a plus sign.)</td>
+     * </tr>
+     * <tr>
+     * <td>"<code> </code>" (space)</td>
+     * <td>If the first character of a  signed conversion  specification is
+     * not a sign, or if a signed conversion results in no characters,
+     * the result will begin  with a space. If the space
+     * (<code> </code>) flag and the plus (<code>+</code>) flag both
+     * appear, the space flag is ignored.</td>
+     * </tr>
+     * <tr>
+     * <td><code>0</code></td>
+     * <td>If the <i>type</i> is <code>d</code>, <code>i</code>,
+     * <code>o</code>, <code>u</code>, <code>x</code>, <code>X</code>,
+     * <code>e</code>, <code>E</code>, <code>f</code>, <code>g</code>,
+     * or <code>G</code>:  leading  zeroes,  are  used to pad the field
+     * width (following any indication of sign or base); no spaces
+     * are used  for  padding.  If the zero (<code>0</code>) and minus
+     * (<code>-</code>) flags both appear, the zero (<code>0</code>)
+     * flag will be ignored. For <code>d</code>, <code>i</code>,
+     * <code>o</code>, <code>u</code>, <code>x</code>, <code>X</code>
+     * conversions, if a precision <i>prec</i> is specified, the zero
+     * (<code>0</code>) flag is ignored.
+     * <br>
+     * Note that <i>0</i> is interpreted as a flag, not as the
+     * beginning of a field width.</td>
+     * </tr>
+     * <tr>
+     * <td><code>#</code></td>
+     * <td>The result is to be converted to an alternative form, according
+     * to the <i>type</i> character:
+     * <dl>
+     * <dt><code>o</code>
+     * <dd>Increases precision to force the first digit of the result
+     * to be a zero.
+     * <p/>
+     * <dt><code>x</code>
+     * <dl>A non-zero result will have a <code>0x</code> prefix.
+     * <p/>
+     * <dt><code>X</code>
+     * <dl>A non-zero result will have a <code>0X</code> prefix.
+     * <p/>
+     * <dt><code>e</code>, <code>E</code>, or <code>f</code>
+     * <dl>The result will always contain a decimal point even if no
+     * digits follow the point. (Normally, a decimal point appears
+     * only if a digit follows it.) Trailing zeroes are removed.
+     * <p/>
+     * <dt><code>g</code> or <code>G</code>
+     * <dl>Same as <code>e</code> or <code>E</code>, but trailing
+     * zeroes arenot removed.
+     * <p/>
+     * <dt>all others
+     * <dd>Undefined.
+     * </dl></td>
+     * </tr>
-     *
+     * <p/>
-     *
+     * <p/>
-     *
+     * <p/>
-     *
+     * <p/>
-     *
-     *   <dl>
-     *   <dt><code>%</code>
-     *   <dd>prints the percent character (<code>%</code>)
-     *
-     *   <dt><code>c</code>
-     *   <dd>prints <i>arg</i> as single character. That is the argument is
-     *       converted to a <code>String</code> of which only the first
-     *       character is printed.
-     *
-     *   <dt><code>s</code>
-     *   <dd>Prints characters until precision is reached or the
-     *       <code>String</code> ends; takes any <code>Object</code> whose
-     *       <code>toString()</code> method is called to get the
-     *       <code>String</code> to print.
-     *
-     *   <dt><code>d</code>
-     *   <dd>prints a signed decimal integer; takes a <code>Number</code> (same
-     *       as <code>i</code>)
-     *
-     *   <dt><code>d</code>
-     *   <dd>prints a signed decimal integer; takes a <code>Number</code> (same
-     *       as <code>d</code>)
-     *
-     *   <dt><code>d</code>
-     *   <dd>prints a signed octal integer; takes a <code>Number</code>
-     *
-     *   <dt><code>u</code>
-     *   <dd>prints a unsigned decimal integer; takes a <code>Number</code>.
-     *       This conversion is not supported correctly by the Java
-     *       implementation and is really the same as <code>i</code>.
-     *
-     *   <dt><code>x</code>
-     *   <dd>prints an unsigned hexadecimal integer (using <i>abcdef</i> as
-     *       digits beyond <i>9</i>; takes a <code>Number</code>
-     *
-     *   <dt><code>X</code>
-     *   <dd>prints an unsigned hexadecimal integer (using <i>ABCDEF</i> as
-     *       digits beyond <i>9</i>; takes a <code>Number</code>
-     *
-     *   <dt><code>f</code>
-     *   <dd>prints a signed value of the form <i>[-]9999.9999</i>; takes a
-     *       <code>Number</code>
-     *
-     *   <dt><code>e</code>
-     *   <dd>prints a signed value of the form <i>[-]9.9999e[+|-]999</i>; takes
-     *       a <code>Number</code>
-     *
-     *   <dt><code>E</code>
-     *   <dd>prints the same way as <code>e</code>, but using <i>E</i> to
-     *       introduce the exponent; takes a <code>Number</code>
-     *
-     *   <dt><code>g</code>
-     *   <dd>prints a signed value in either <code>f</code> or <code>e</code>
-     *       form, based  on given value and precision &emdash; trailing zeros
-     *       and the decimal point are printed only if necessary; takes a
-     *       <code>Number</code>
-     *
-     *   <dt><code>G</code>
-     *   <dd>prints the same way as <code>g</code>, but using <code>E</code>
-     *       for the exponent if an exponent is needed; takes a
-     *       <code>Number</code>
-     *
-     *   <dt><code>n</code>
-     *   <dd>Not supported in the Java implementation, throws an
-     *       <code>IllegalArgumentException</code> if used.
-     *
-     *   <dt><code>p</code>
-     *   <dd>Not supported in the Java implementation, throws an
-     *       <code>IllegalArgumentException</code> if used.
-     *   </dl>
-     *
+     * <p/>
+     * <dl>
+     * <dt><code>%</code>
+     * <dd>prints the percent character (<code>%</code>)
+     * <p/>
+     * <dt><code>c</code>
+     * <dd>prints <i>arg</i> as single character. That is the argument is
+     * converted to a <code>String</code> of which only the first
+     * character is printed.
+     * <p/>
+     * <dt><code>s</code>
+     * <dd>Prints characters until precision is reached or the
+     * <code>String</code> ends; takes any <code>Object</code> whose
+     * <code>toString()</code> method is called to get the
+     * <code>String</code> to print.
+     * <p/>
+     * <dt><code>d</code>
+     * <dd>prints a signed decimal integer; takes a <code>Number</code> (same
+     * as <code>i</code>)
+     * <p/>
+     * <dt><code>d</code>
+     * <dd>prints a signed decimal integer; takes a <code>Number</code> (same
+     * as <code>d</code>)
+     * <p/>
+     * <dt><code>d</code>
+     * <dd>prints a signed octal integer; takes a <code>Number</code>
+     * <p/>
+     * <dt><code>u</code>
+     * <dd>prints a unsigned decimal integer; takes a <code>Number</code>.
+     * This conversion is not supported correctly by the Java
+     * implementation and is really the same as <code>i</code>.
+     * <p/>
+     * <dt><code>x</code>
+     * <dd>prints an unsigned hexadecimal integer (using <i>abcdef</i> as
+     * digits beyond <i>9</i>; takes a <code>Number</code>
+     * <p/>
+     * <dt><code>X</code>
+     * <dd>prints an unsigned hexadecimal integer (using <i>ABCDEF</i> as
+     * digits beyond <i>9</i>; takes a <code>Number</code>
+     * <p/>
+     * <dt><code>f</code>
+     * <dd>prints a signed value of the form <i>[-]9999.9999</i>; takes a
+     * <code>Number</code>
+     * <p/>
+     * <dt><code>e</code>
+     * <dd>prints a signed value of the form <i>[-]9.9999e[+|-]999</i>; takes
+     * a <code>Number</code>
+     * <p/>
+     * <dt><code>E</code>
+     * <dd>prints the same way as <code>e</code>, but using <i>E</i> to
+     * introduce the exponent; takes a <code>Number</code>
+     * <p/>
+     * <dt><code>g</code>
+     * <dd>prints a signed value in either <code>f</code> or <code>e</code>
+     * form, based  on given value and precision &emdash; trailing zeros
+     * and the decimal point are printed only if necessary; takes a
+     * <code>Number</code>
+     * <p/>
+     * <dt><code>G</code>
+     * <dd>prints the same way as <code>g</code>, but using <code>E</code>
+     * for the exponent if an exponent is needed; takes a
+     * <code>Number</code>
+     * <p/>
+     * <dt><code>n</code>
+     * <dd>Not supported in the Java implementation, throws an
+     * <code>IllegalArgumentException</code> if used.
+     * <p/>
+     * <dt><code>p</code>
+     * <dd>Not supported in the Java implementation, throws an
+     * <code>IllegalArgumentException</code> if used.
-     *
-     * <p>
+     * <p/>
+     * </dl>
+     * <p/>
+     * <p/>
-     * <p>
+     * <p/>
-     * <p>
+     * <p/>
-     * 		C function.
-     * @param args The list of arguments to accomodate the format string. This
-     * 		argument list is supposed to contain at least as much entries as
-     * 		there are formatting options in the format string. If for a
-     * 		numeric option, the entry is not a number an
-     * 		<code>IllegalArgumentException</code> is thrown.
-     *
+     *               C function.
+     * @param args   The list of arguments to accomodate the format string. This
+     *               argument list is supposed to contain at least as much entries as
+     *               there are formatting options in the format string. If for a
+     *               numeric option, the entry is not a number an
+     *               <code>IllegalArgumentException</code> is thrown.
-     * 		is only returned if the <code>format</code> <code>String</code>
-     * 		is empty. A <code>null</code> value is never returned.
-     *
-     * @throws NullPointerException if the formatting string or any of the
-     * 		argument values is <code>null</code>.
+     *         is only returned if the <code>format</code> <code>String</code>
+     *         is empty. A <code>null</code> value is never returned.
+     * @throws NullPointerException     if the formatting string or any of the
+     *                                  argument values is <code>null</code>.
-     *         	format tags, if the formatting string has an incomplete
-     * 		formatting pattern at the end of the string, if the argument
-     * 		vector has not enough values to satisfy the formatting string
-     * 		or if an argument's type does not match the requirements of the
-     * 		format string.
-     *
+     *                                  format tags, if the formatting string has an incomplete
+     *                                  formatting pattern at the end of the string, if the argument
+     *                                  vector has not enough values to satisfy the formatting string
+     *                                  or if an argument's type does not match the requirements of the
+     *                                  format string.
-	// Return immediately if we have no arguments ....
-	if (format == null) {
-	    throw new NullPointerException("format");
-	}
+        // Return immediately if we have no arguments ....
+        if (format == null) {
+            throw new NullPointerException("format");
+        }
-	if (format.length() == 0) {
-	    return "";
-	}
+        if (format.length() == 0) {
+            return "";
+        }
-	// Get the format string
-	char[] s = format.toCharArray();
+        // Get the format string
+        char[] s = format.toCharArray();
-	// prepare the result, initial size has no sound basis
-	StringBuffer res = new StringBuffer( s.length * 3 / 2 );
+        // prepare the result, initial size has no sound basis
+        StringBuffer res = new StringBuffer(s.length * 3 / 2);
-	for (int i=0,j=0, length=format.length(); i < length; ) {
+        for (int i = 0, j = 0, length = format.length(); i < length;) {
-	    int parse_state = PARSE_STATE_NONE;
-	    BitSet flags = new BitSet(16);
-	    int width = 0;
-	    int precision = -1;
-	    char fmt = ' ';
+            int parse_state = PARSE_STATE_NONE;
+            BitSet flags = new BitSet(16);
+            int width = 0;
+            int precision = -1;
+            char fmt = ' ';
-	    // find a start of a formatting ...
-	    while (parse_state == PARSE_STATE_NONE) {
-		if (i >= length) parse_state = PARSE_STATE_TERM;
-		else if (s[i] == '%') {
-		    if (i < length - 1) {
-			if (s[i + 1] == '%') {
-			    res.append('%');
-			    i++;
-			} else {
-			    parse_state = PARSE_STATE_FLAGS;
-			}
-		    } else {
-			throw new java.lang.IllegalArgumentException(
-			    "Incomplete format at end of format string");
-		    }
-		} else {
-		    res.append(s[i]);
-		}
-		i++;
-	    }
+            // find a start of a formatting ...
+            while (parse_state == PARSE_STATE_NONE) {
+                if (i >= length)
+                    parse_state = PARSE_STATE_TERM;
+                else if (s[i] == '%') {
+                    if (i < length - 1) {
+                        if (s[i + 1] == '%') {
+                            res.append('%');
+                            i++;
+                        } else {
+                            parse_state = PARSE_STATE_FLAGS;
+                        }
+                    } else {
+                        throw new java.lang.IllegalArgumentException("Incomplete format at end of format string");
+                    }
+                } else {
+                    res.append(s[i]);
+                }
+                i++;
+            }
-	    // Get flags, if any
-	    while (parse_state == PARSE_STATE_FLAGS) {
-		if (i >= length) parse_state = PARSE_STATE_ABORT;
-		else if (s[i] == ' ') flags.set(FLAG_SP);
-		else if (s[i] == '-') flags.set(FLAG_LJ);
-		else if (s[i] == '+') flags.set(FLAG_SI);
-		else if (s[i] == '0') flags.set(FLAG_ZE);
-		else if (s[i] == '#') flags.set(FLAG_AL);
-		else {
-		    parse_state = PARSE_STATE_WIDTH;
-		    i--;
-		}
-		i++;
-	    }
+            // Get flags, if any
+            while (parse_state == PARSE_STATE_FLAGS) {
+                if (i >= length)
+                    parse_state = PARSE_STATE_ABORT;
+                else if (s[i] == ' ')
+                    flags.set(FLAG_SP);
+                else if (s[i] == '-')
+                    flags.set(FLAG_LJ);
+                else if (s[i] == '+')
+                    flags.set(FLAG_SI);
+                else if (s[i] == '0')
+                    flags.set(FLAG_ZE);
+                else if (s[i] == '#')
+                    flags.set(FLAG_AL);
+                else {
+                    parse_state = PARSE_STATE_WIDTH;
+                    i--;
+                }
+                i++;
+            }
-	    // Get width specification
-	    while (parse_state == PARSE_STATE_WIDTH) {
-		if (i >= length) {
+            // Get width specification
+            while (parse_state == PARSE_STATE_WIDTH) {
+                if (i >= length) {
-		    parse_state = PARSE_STATE_ABORT;
+                    parse_state = PARSE_STATE_ABORT;
-		} else if ('0' <= s[i] && s[i] <= '9') {
+                } else if ('0' <= s[i] && s[i] <= '9') {
-		    width = width * 10 + s[i] - '0';
-		    i++;
+                    width = width * 10 + s[i] - '0';
+                    i++;
-		} else {
-		    // finished with digits or none at all
+                } else {
+                    // finished with digits or none at all
-		    // if width is a '*' take width from arg
-		    if (s[i] == '*') {
-			// Check whether we have an argument
-			if (j >= args.length) {
-			    throw new IllegalArgumentException("Missing " +
-				"argument for the width");
-			}
-			try {
-			    width = ((Number)(args[j++])).intValue();
-			} catch (ClassCastException cce) {
-			    // something wrong with the arg
-			    throw new IllegalArgumentException("Width " +
-				"argument is not numeric");
-			}
-			i++;
-		    }
+                    // if width is a '*' take width from arg
+                    if (s[i] == '*') {
+                        // Check whether we have an argument
+                        if (j >= args.length) {
+                            throw new IllegalArgumentException("Missing " +
+                                    "argument for the width");
+                        }
+                        try {
+                            width = ((Number) (args[j++])).intValue();
+                        } catch (ClassCastException cce) {
+                            // something wrong with the arg
+                            throw new IllegalArgumentException("Width " +
+                                    "argument is not numeric");
+                        }
+                        i++;
+                    }
-		    // if next is a dot, then we have a precision, else a size
-		    if (s[i] == '.') {
-			parse_state = PARSE_STATE_PRECISION;
-			precision = 0;
-			i++;
-		    } else {
-			parse_state = PARSE_STATE_SIZE;
-		    }
+                    // if next is a dot, then we have a precision, else a size
+                    if (s[i] == '.') {
+                        parse_state = PARSE_STATE_PRECISION;
+                        precision = 0;
+                        i++;
+                    } else {
+                        parse_state = PARSE_STATE_SIZE;
+                    }
-		}
-	    }
+                }
+            }
-	    // Get precision
-	    while (parse_state == PARSE_STATE_PRECISION) {
+            // Get precision
+            while (parse_state == PARSE_STATE_PRECISION) {
-		if (i >= length) {
+                if (i >= length) {
-		    parse_state = PARSE_STATE_ABORT;
+                    parse_state = PARSE_STATE_ABORT;
-		} else if ('0' <= s[i] && s[i] <= '9') {
+                } else if ('0' <= s[i] && s[i] <= '9') {
-		    precision = precision * 10 + s[i] - '0';
-		    i++;
+                    precision = precision * 10 + s[i] - '0';
+                    i++;
-		} else {
-		    // finished with digits or none at all
+                } else {
+                    // finished with digits or none at all
-		    // if width is a '*' take precision from arg
-		    if (s[i] == '*') {
-			// Check whether we have an argument
-			if (j >= args.length) {
-			    throw new IllegalArgumentException("Missing " +
-				"argument for the precision");
-			}
-			try {
-			    width = ((Number)(args[j++])).intValue();
-			} catch (ClassCastException cce) {
-			    // something wrong with the arg
-			    throw new IllegalArgumentException("Precision " +
-				"argument is not numeric");
-			}
-			i++;
-		    }
+                    // if width is a '*' take precision from arg
+                    if (s[i] == '*') {
+                        // Check whether we have an argument
+                        if (j >= args.length) {
+                            throw new IllegalArgumentException("Missing " +
+                                    "argument for the precision");
+                        }
+                        try {
+                            width = ((Number) (args[j++])).intValue();
+                        } catch (ClassCastException cce) {
+                            // something wrong with the arg
+                            throw new IllegalArgumentException("Precision " +
+                                    "argument is not numeric");
+                        }
+                        i++;
+                    }
-		    parse_state = PARSE_STATE_SIZE;
+                    parse_state = PARSE_STATE_SIZE;
-		}
+                }
-	    }
+            }
-	    // Get size character
-	    if (parse_state == PARSE_STATE_SIZE) {
-		if (i >= length) parse_state = 6;
-		else {
-		    if (s[i] == 'h') {
-			flags.set(FLAG_SHORT);
-			i++;
-		    }  else if (s[i] == 'l' || s[i] == 'L') {
-			flags.set(FLAG_LONG);
-			i++;
-		    }
-		    parse_state = PARSE_STATE_TYPE;
-		}
-	    }
+            // Get size character
+            if (parse_state == PARSE_STATE_SIZE) {
+                if (i >= length)
+                    parse_state = 6;
+                else {
+                    if (s[i] == 'h') {
+                        flags.set(FLAG_SHORT);
+                        i++;
+                    } else if (s[i] == 'l' || s[i] == 'L') {
+                        flags.set(FLAG_LONG);
+                        i++;
+                    }
+                    parse_state = PARSE_STATE_TYPE;
+                }
+            }
-	    // Get format character
-	    if (parse_state == PARSE_STATE_TYPE) {
-		if (i >= length) parse_state = PARSE_STATE_ABORT;
-		else {
-		    fmt = s[i];
-		    i++;
-		    parse_state = PARSE_STATE_END;
-		}
-	    }
+            // Get format character
+            if (parse_state == PARSE_STATE_TYPE) {
+                if (i >= length)
+                    parse_state = PARSE_STATE_ABORT;
+                else {
+                    fmt = s[i];
+                    i++;
+                    parse_state = PARSE_STATE_END;
+                }
+            }
-	    // Now that we have anything, format it ....
-	    if (parse_state == PARSE_STATE_END) {
+            // Now that we have anything, format it ....
+            if (parse_state == PARSE_STATE_END) {
-		// Check whether we have an argument
-		if (j >= args.length) {
-		    throw new IllegalArgumentException("Not enough parameters for the format string");
-		}
+                // Check whether we have an argument
+                if (j >= args.length) {
+                    throw new IllegalArgumentException("Not enough parameters for the format string");
+                }
-		try {
+                try {
-		    // Convert the argument according to the flag
-		    switch (fmt) {
-			case 'd': // decimal - fall through
-			case 'i': // integral - fall through
-			case 'x': // hexadecimal, lower case - fall through
-			case 'X': // hexadecimal, upper case - fall through
-			case 'o': // octal - fall through
-			case 'u': // unsigned (not really supported)
-			    format(res, (Number)args[j], fmt, width, precision,
-				flags);
-			    break;
+                    // Convert the argument according to the flag
+                    switch (fmt) {
+                        case 'd': // decimal - fall through
+                        case 'i': // integral - fall through
+                        case 'x': // hexadecimal, lower case - fall through
+                        case 'X': // hexadecimal, upper case - fall through
+                        case 'o': // octal - fall through
+                        case 'u': // unsigned (not really supported)
+                            format(res, (Number) args[j], fmt, width, precision,
+                                    flags);
+                            break;
-			case 'f': // float - fall through
-			case 'e': // exponential, lower case - fall through
-			case 'E': // exponential, upper case - fall through
-			case 'g': // float or exp., lower case - fall through
-			case 'G': // float or exp., upper case - fall through
-			    format(res, ((Number)args[j]).doubleValue(), fmt,
-				width, precision, flags);
-			    break;
+                        case 'f': // float - fall through
+                        case 'e': // exponential, lower case - fall through
+                        case 'E': // exponential, upper case - fall through
+                        case 'g': // float or exp., lower case - fall through
+                        case 'G': // float or exp., upper case - fall through
+                            format(res, ((Number) args[j]).doubleValue(), fmt,
+                                    width, precision, flags);
+                            break;
-			case 'c': // character
-			    precision = 1;
-			    // fall through
+                        case 'c': // character
+                            precision = 1;
+                            // fall through
-			case 's': // string
+                        case 's': // string
-			    String val = args[j].toString();
-			    if (val.length() > precision && precision > 0) {
-				val = val.substring(0, precision);
-			    }
+                            String val = args[j].toString();
+                            if (val.length() > precision && precision > 0) {
+                                val = val.substring(0, precision);
+                            }
-			    flags.clear(FLAG_ZE);
-			    format(res, val, "", width, flags);
-			    break;
+                            flags.clear(FLAG_ZE);
+                            format(res, val, "", width, flags);
+                            break;
-			default : // unknown format
+                        default : // unknown format
-			    throw new IllegalArgumentException("Unknown " +
-				"conversion type " + fmt);
+                            throw new IllegalArgumentException("Unknown " +
+                                    "conversion type " + fmt);
-		    }
+                    }
-		} catch (ClassCastException cce) {
-		    // something wrong with the arg
-		    throw new IllegalArgumentException("sprintf: Argument #" +
-			j + " of type " + args[j].getClass().getName() +
-			" does not match format " + fmt);
-		}
+                } catch (ClassCastException cce) {
+                    // something wrong with the arg
+                    throw new IllegalArgumentException("sprintf: Argument #" +
+                            j + " of type " + args[j].getClass().getName() +
+                            " does not match format " + fmt);
+                }
-		// goto the next argument
-		j++;
-	    }
+                // goto the next argument
+                j++;
+            }
-	    // if the format string is not complete
-	    if (parse_state == PARSE_STATE_ABORT) {
-		throw new java.lang.IllegalArgumentException(
-		    "Incomplete format at end of format string");
-	    }
+            // if the format string is not complete
+            if (parse_state == PARSE_STATE_ABORT) {
+                throw new java.lang.IllegalArgumentException("Incomplete format at end of format string");
+            }
-	} // while i
+        } // while i
-	return res.toString();
+        return res.toString();
-     * @param a0 The single parameter
-     *
+     * @param a0     The single parameter
-     *
-     * @param a0 The first parameter
-     * @param a1 The second parameter
-     *
+     * @param a0     The first parameter
+     * @param a1     The second parameter
-     *
-     * @param a0 The first parameter
-     * @param a1 The second parameter
-     * @param a2 The thrid parameter
-     *
+     * @param a0     The first parameter
+     * @param a1     The second parameter
+     * @param a2     The thrid parameter
-     *
-        Object a2) {
+                                 Object a2) {
-     * @param a0 The first parameter
-     * @param a1 The second parameter
-     * @param a2 The thrid parameter
-     * @param a3 The fourth parameter
-     *
+     * @param a0     The first parameter
+     * @param a1     The second parameter
+     * @param a2     The thrid parameter
+     * @param a3     The fourth parameter
-     *
-        Object a2, Object a3) {
+                                 Object a2, Object a3) {
-     * @param a0 The first parameter
-     * @param a1 The second parameter
-     * @param a2 The thrid parameter
-     * @param a3 The fourth parameter
-     * @param a4 The fifth parameter
-     *
+     * @param a0     The first parameter
+     * @param a1     The second parameter
+     * @param a2     The thrid parameter
+     * @param a3     The fourth parameter
+     * @param a4     The fifth parameter
-     *
-        Object a2, Object a3, Object a4) {
+                                 Object a2, Object a3, Object a4) {
-     *
+     * <p/>
-     *
+     * <p/>
-     *
-     * todo: Check for the more or less complete support of all pattern tags.
+     *         <p/>
+     *         todo: Check for the more or less complete support of all pattern tags.
-	char[] format = posixFormat.toCharArray();
-	StringBuffer jFormat = new StringBuffer(format.length);
-	boolean inString = false;
+        char[] format = posixFormat.toCharArray();
+        StringBuffer jFormat = new StringBuffer(format.length);
+        boolean inString = false;
-	for (int i=0; i<format.length; i++) {
+        for (int i = 0; i < format.length; i++) {
-	    if (format[i] == '\'') {
+            if (format[i] == '\'') {
-		// insert a second tick
-		jFormat.append('\'');
+                // insert a second tick
+                jFormat.append('\'');
-	    } else if (format[i] == '%') {
+            } else if (format[i] == '%') {
-		if (inString) {
-		    jFormat.append('\'');
-		    inString = false;
-		}
+                if (inString) {
+                    jFormat.append('\'');
+                    inString = false;
+                }
-		switch(format[++i]) {
-		    case '%':
-			// just a single '%'
-			jFormat.append('%');
-			break;
+                switch (format[++i]) {
+                    case '%':
+                        // just a single '%'
+                        jFormat.append('%');
+                        break;
-		    case 'a':
-			// locale's abbreviated weekday name
-			jFormat.append("EEE");
-			break;
+                    case 'a':
+                        // locale's abbreviated weekday name
+                        jFormat.append("EEE");
+                        break;
-		    case 'A':
-			// locale's full weekday name
-			jFormat.append("EEEE");
-			break;
+                    case 'A':
+                        // locale's full weekday name
+                        jFormat.append("EEEE");
+                        break;
-		    case 'b':
-			// locale's abbreviated month name
-			jFormat.append("MMM");
-			break;
+                    case 'b':
+                        // locale's abbreviated month name
+                        jFormat.append("MMM");
+                        break;
-		    case 'B':
-			// locale's full month name
-			jFormat.append("MMMM");
-			break;
+                    case 'B':
+                        // locale's full month name
+                        jFormat.append("MMMM");
+                        break;
-		    case 'c':
-			// locale's appropriate date and time representation
-			break;
+                    case 'c':
+                        // locale's appropriate date and time representation
+                        break;
-		    case 'C':
-			// century number as a decimal number (00-99)
-			// Not supported
-			break;
+                    case 'C':
+                        // century number as a decimal number (00-99)
+                        // Not supported
+                        break;
-		    case 'd':
-			// day of month (01-31)
-			jFormat.append("dd");
-			break;
+                    case 'd':
+                        // day of month (01-31)
+                        jFormat.append("dd");
+                        break;
-		    case 'D':
-			// date as %m/%d/%y
-			jFormat.append("MM/dd/yy");
-			break;
+                    case 'D':
+                        // date as %m/%d/%y
+                        jFormat.append("MM/dd/yy");
+                        break;
-		    case 'e':
-			// day of month ( 1-31)
-			jFormat.append("d");
-			break;
+                    case 'e':
+                        // day of month ( 1-31)
+                        jFormat.append("d");
+                        break;
-		    case 'h':
-			// locale's abbreviated month name
-			jFormat.append("MMM");
-			break;
+                    case 'h':
+                        // locale's abbreviated month name
+                        jFormat.append("MMM");
+                        break;
-		    case 'H':
-			// hour (00-23)
-			jFormat.append("HH");
-			break;
+                    case 'H':
+                        // hour (00-23)
+                        jFormat.append("HH");
+                        break;
-		    case 'I':
-			// hour (01-12)
-			jFormat.append("hh");
-			break;
+                    case 'I':
+                        // hour (01-12)
+                        jFormat.append("hh");
+                        break;
-		    case 'j':
-			// day number of year (001-366)
-			jFormat.append("DDD");
-			break;
+                    case 'j':
+                        // day number of year (001-366)
+                        jFormat.append("DDD");
+                        break;
-		    case 'K':
-			// plus C !!!
-			if (format[++i] == 'C') {
-			    // locale's appropriate date and time representation
-			}
-			break;
+                    case 'K':
+                        // plus C !!!
+                        if (format[++i] == 'C') {
+                            // locale's appropriate date and time representation
+                        }
+                        break;
-		    case 'm':
-			// month number (01-12)
-			jFormat.append("MM");
-			break;
+                    case 'm':
+                        // month number (01-12)
+                        jFormat.append("MM");
+                        break;
-		    case 'M':
-			// minute (00-59)
-			jFormat.append("mm");
-			break;
+                    case 'M':
+                        // minute (00-59)
+                        jFormat.append("mm");
+                        break;
-		    case 'n':
-			// new line
-			jFormat.append( System.getProperty("line.separator", "\n") );
-			break;
+                    case 'n':
+                        // new line
+                        jFormat.append(System.getProperty("line.separator", "\n"));
+                        break;
-		    case 'p':
-			// locale's equivalent of either AM and PM
-			jFormat.append("aa");
-			break;
+                    case 'p':
+                        // locale's equivalent of either AM and PM
+                        jFormat.append("aa");
+                        break;
-		    case 'r':
-			// locale's 12-hour time representation, default %I:%M:%S [AM|PM]
-			jFormat.append("hh:mm:ss aa");
-			break;
+                    case 'r':
+                        // locale's 12-hour time representation, default %I:%M:%S [AM|PM]
+                        jFormat.append("hh:mm:ss aa");
+                        break;
-		    case 'R':
-			// time as %H:%M
-			jFormat.append("hh:mm");
-			break;
+                    case 'R':
+                        // time as %H:%M
+                        jFormat.append("hh:mm");
+                        break;
-		    case 'S':
-			// seconds (00-61) [ leap seconds ;-) ]
-			jFormat.append("ss");
-			break;
+                    case 'S':
+                        // seconds (00-61) [ leap seconds ;-) ]
+                        jFormat.append("ss");
+                        break;
-		    case 't':
-			// tab character
-			jFormat.append( '\t' );
-			break;
+                    case 't':
+                        // tab character
+                        jFormat.append('\t');
+                        break;
-		    case 'T':
-			// time as %H:%M:%S
-			jFormat.append("HH:mm:ss");
-			break;
+                    case 'T':
+                        // time as %H:%M:%S
+                        jFormat.append("HH:mm:ss");
+                        break;
-		    case 'U':
-			// week number of year (00-53), sunday is first day of week
-			jFormat.append("ww");
-			break;
+                    case 'U':
+                        // week number of year (00-53), sunday is first day of week
+                        jFormat.append("ww");
+                        break;
-		    case 'w':
-			// weekday number (0-6, 0=sunday)
-			jFormat.append("E");
-			break;
+                    case 'w':
+                        // weekday number (0-6, 0=sunday)
+                        jFormat.append("E");
+                        break;
-		    case 'W':
-			// week number of year (00-53), monday is first day of week
-			jFormat.append("ww");
-			break;
+                    case 'W':
+                        // week number of year (00-53), monday is first day of week
+                        jFormat.append("ww");
+                        break;
-		    case 'x':
-			// locale's appropriate date representation
-			break;
+                    case 'x':
+                        // locale's appropriate date representation
+                        break;
-		    case 'X':
-			// locale's appropriate time representation
-			break;
+                    case 'X':
+                        // locale's appropriate time representation
+                        break;
-		    case 'y':
-			// year within century (00-99)
-			jFormat.append("yy");
-			break;
+                    case 'y':
+                        // year within century (00-99)
+                        jFormat.append("yy");
+                        break;
-		    case 'Y':
-			// year as %c%y (e.g. 1986)
-			jFormat.append("yyyy");
-			break;
+                    case 'Y':
+                        // year as %c%y (e.g. 1986)
+                        jFormat.append("yyyy");
+                        break;
-		    case 'Z':
-			// time zone name or no characters if no time zone exists
-			jFormat.append("zzz");
-			break;
+                    case 'Z':
+                        // time zone name or no characters if no time zone exists
+                        jFormat.append("zzz");
+                        break;
-		    default:
-			// ignore and ...
-			continue;
-		}
+                    default:
+                        // ignore and ...
+                        continue;
+                }
-	    } else {
+            } else {
-		if (!inString) {
-		    inString = true;
-		    jFormat.append('\'');
-		}
+                if (!inString) {
+                    inString = true;
+                    jFormat.append('\'');
+                }
-		jFormat.append(format[i]);
-	    }
-	}
+                jFormat.append(format[i]);
+            }
+        }
-	return jFormat.toString();
+        return jFormat.toString();
-     * @param buf The formatted number is appended to this string buffer
-     * @param num The number object to format
-     * @param fmt The format character defining the radix of the number
-     * @param width The minimum field width for the number
+     * @param buf       The formatted number is appended to this string buffer
+     * @param num       The number object to format
+     * @param fmt       The format character defining the radix of the number
+     * @param width     The minimum field width for the number
-     * 		this does not include any signs or prefix characters
-     * @param flags The flags governing the formatting. This is a combination
-     * 		of the FLAG_* constants above.
-     *
+     *                  this does not include any signs or prefix characters
+     * @param flags     The flags governing the formatting. This is a combination
+     *                  of the FLAG_* constants above.
-     *
-	char fmt, int width, int precision, BitSet flags) {
+                                       char fmt, int width, int precision, BitSet flags) {
-	String numStr;
-	String prefStr = "";
-	boolean toUpper = (fmt == 'X');
+        String numStr;
+        String prefStr = "";
+        boolean toUpper = (fmt == 'X');
-	// Check precision and make default
-	if (precision >= 0) {
-	    flags.clear(FLAG_ZE);
-	} else {
-	    precision = 1;
-	}
+        // Check precision and make default
+        if (precision >= 0) {
+            flags.clear(FLAG_ZE);
+        } else {
+            precision = 1;
+        }
-	// Get the value and adjust size interpretation
-	long val;
-	long sizeMask;
-	if (flags.get(FLAG_SHORT)) {
-	    val = num.shortValue();
-	    sizeMask = 0xffffL;
-	} else if (flags.get(FLAG_LONG)) {
-	    val = num.longValue();
-	    sizeMask = 0xffffffffffffffffL;
-	} else {
-	    val = num.intValue();
-	    sizeMask = 0xffffffffL;
-	}
+        // Get the value and adjust size interpretation
+        long val;
+        long sizeMask;
+        if (flags.get(FLAG_SHORT)) {
+            val = num.shortValue();
+            sizeMask = 0xffffL;
+        } else if (flags.get(FLAG_LONG)) {
+            val = num.longValue();
+            sizeMask = 0xffffffffffffffffL;
+        } else {
+            val = num.intValue();
+            sizeMask = 0xffffffffL;
+        }
-	// check formatting type
-	if (fmt == 'x' || fmt == 'X') {
+        // check formatting type
+        if (fmt == 'x' || fmt == 'X') {
-	    numStr = Long.toHexString(val & sizeMask);
+            numStr = Long.toHexString(val & sizeMask);
-	    if (toUpper) {
-		numStr = numStr.toUpperCase();
-	    }
+            if (toUpper) {
+                numStr = numStr.toUpperCase();
+            }
-	    if (flags.get(FLAG_AL)) {
-		prefStr = toUpper ? "0X" : "0x";
-	    }
+            if (flags.get(FLAG_AL)) {
+                prefStr = toUpper ? "0X" : "0x";
+            }
-	} else if (fmt == 'o') {
+        } else if (fmt == 'o') {
-	    numStr = Long.toOctalString(val & sizeMask);
+            numStr = Long.toOctalString(val & sizeMask);
-	    if (flags.get(FLAG_AL) && val != 0 && precision <= numStr.length()) {
-		precision = numStr.length() + 1;
-	    }
+            if (flags.get(FLAG_AL) && val != 0 && precision <= numStr.length()) {
+                precision = numStr.length() + 1;
+            }
-	} else {
+        } else {
-	    numStr = Long.toString(val);
+            numStr = Long.toString(val);
-	    // move sign to prefix if negative, or set '+'
-	    if (val < 0) {
-		prefStr = "-";
-		numStr = numStr.substring(1);
-	    } else if (flags.get(FLAG_SI)) {
-		prefStr = "+";
-	    }
+            // move sign to prefix if negative, or set '+'
+            if (val < 0) {
+                prefStr = "-";
+                numStr = numStr.substring(1);
+            } else if (flags.get(FLAG_SI)) {
+                prefStr = "+";
+            }
-	}
+        }
-	// prefix 0 for precision
-	if (precision > numStr.length()) {
-	    StringBuffer tmp = new StringBuffer(precision);
-	    for (precision -= numStr.length(); precision > 0; precision--) {
-		tmp.append('0');
-	    }
-	    numStr = tmp.append(numStr).toString();
-	}
+        // prefix 0 for precision
+        if (precision > numStr.length()) {
+            StringBuffer tmp = new StringBuffer(precision);
+            for (precision -= numStr.length(); precision > 0; precision--) {
+                tmp.append('0');
+            }
+            numStr = tmp.append(numStr).toString();
+        }
-	return format(buf, numStr, prefStr, width, flags);
+        return format(buf, numStr, prefStr, width, flags);
-     * @param buf The formatted number is appended to this string buffer
-     * @param num The numeric value to format
-     * @param fmt The format character defining the floating point format
-     * @param width The minimum field width for the number
+     * @param buf       The formatted number is appended to this string buffer
+     * @param num       The numeric value to format
+     * @param fmt       The format character defining the floating point format
+     * @param width     The minimum field width for the number
-     * 		digits after the decimal point or the number of significant
-     * 		digits.
-     * @param flags The flags governing the formatting. This is a combination
-     * 		of the FLAG_* constants above.
-     *
+     *                  digits after the decimal point or the number of significant
+     *                  digits.
+     * @param flags     The flags governing the formatting. This is a combination
+     *                  of the FLAG_* constants above.
-     *
-	char fmt, int width, int precision, BitSet flags) {
+                                       char fmt, int width, int precision, BitSet flags) {
-	BigDecimal val = new BigDecimal(num).abs();
+        BigDecimal val = new BigDecimal(num).abs();
-	// the exponent character, will be defined if exponent is needed
-	char expChar = 0;
+        // the exponent character, will be defined if exponent is needed
+        char expChar = 0;
-	// the exponent value
-	int exp;
-	if (fmt != 'f') {
-	    exp = val.unscaledValue().toString().length() - val.scale() - 1;
-	} else {
-	    exp = 0;
-	}
+        // the exponent value
+        int exp;
+        if (fmt != 'f') {
+            exp = val.unscaledValue().toString().length() - val.scale() - 1;
+        } else {
+            exp = 0;
+        }
-	// force display of the decimal dot, if otherwise omitted
-	boolean needDot = (precision == 0 && flags.get(FLAG_AL));
+        // force display of the decimal dot, if otherwise omitted
+        boolean needDot = (precision == 0 && flags.get(FLAG_AL));
-	// for fmt==g|G : treat trailing 0 and decimal dot specially
-	boolean checkTrails = false;
+        // for fmt==g|G : treat trailing 0 and decimal dot specially
+        boolean checkTrails = false;
-	// get a sensible precision value
-	if (precision < 0) {
-	    precision = 6;
-	}
+        // get a sensible precision value
+        if (precision < 0) {
+            precision = 6;
+        }
-	switch (fmt) {
-	    case 'G': // fall through
-	    case 'g':
-		// decrement precision, to simulate significance
-		if (precision > 0) {
-		    precision--;
-		}
+        switch (fmt) {
+            case 'G': // fall through
+            case 'g':
+                // decrement precision, to simulate significance
+                if (precision > 0) {
+                    precision--;
+                }
-		// we have to check trailing zeroes later
-		checkTrails = true;
+                // we have to check trailing zeroes later
+                checkTrails = true;
-		// exponent does not stipulate exp notation, break here
-		if (exp <= precision) {
-		    precision -= exp;
-		    break;
-		}
+                // exponent does not stipulate exp notation, break here
+                if (exp <= precision) {
+                    precision -= exp;
+                    break;
+                }
-		// fall through for exponent handling
+                // fall through for exponent handling
-	    case 'E': // fall through
-	    case 'e':
-		// place the dot after the first decimal place
-		val = val.movePointLeft(exp);
+            case 'E': // fall through
+            case 'e':
+                // place the dot after the first decimal place
+                val = val.movePointLeft(exp);
-		// define the exponent character
-		expChar = (fmt == 'e' || fmt == 'g') ? 'e' : 'E';
+                // define the exponent character
+                expChar = (fmt == 'e' || fmt == 'g') ? 'e' : 'E';
-		break;
-	}
+                break;
+        }
-	// only rescale if the precision is positive, may be negative
-	// for g|G
-	if (precision >= 0) {
-	    val = val.setScale(precision, BigDecimal.ROUND_HALF_UP);
-	}
+        // only rescale if the precision is positive, may be negative
+        // for g|G
+        if (precision >= 0) {
+            val = val.setScale(precision, BigDecimal.ROUND_HALF_UP);
+        }
-	// convert the number to a string
-	String numStr = val.toString();
+        // convert the number to a string
+        String numStr = val.toString();
-	// for g|G : check trailing zeroes
-	if (checkTrails) {
+        // for g|G : check trailing zeroes
+        if (checkTrails) {
-	    if (flags.get(FLAG_AL)) {
+            if (flags.get(FLAG_AL)) {
-		// need a dot, if not existing for alternative format
-		needDot |= (numStr.indexOf('.') < 0);
+                // need a dot, if not existing for alternative format
+                needDot |= (numStr.indexOf('.') < 0);
-	    } else {
-		// remove trailing dots and zeros
-		int dot = numStr.indexOf('.');
-		if (dot >= 0) {
-		    int i;
-		    for (i=numStr.length()-1; i>=dot && numStr.charAt(i)=='0';
-			 i--);
-		    // if stopped at dot, remove it
-		    if (i > dot) {
-			i++;
-		    }
-		    numStr = numStr.substring(0, i);
-		}
-	    }
-	}
+            } else {
+                // remove trailing dots and zeros
+                int dot = numStr.indexOf('.');
+                if (dot >= 0) {
+                    int i;
+                    for (i = numStr.length() - 1; i >= dot && numStr.charAt(i) == '0';
+                         i--)
+                        ;
+                    // if stopped at dot, remove it
+                    if (i > dot) {
+                        i++;
+                    }
+                    numStr = numStr.substring(0, i);
+                }
+            }
+        }
-	// Get a buffer with the number up to now
-	StringBuffer numBuf = new StringBuffer(numStr);
+        // Get a buffer with the number up to now
+        StringBuffer numBuf = new StringBuffer(numStr);
-	// if we need a decimal dot, add it
-	if (needDot) {
-	    numBuf.append('.');
-	}
+        // if we need a decimal dot, add it
+        if (needDot) {
+            numBuf.append('.');
+        }
-	// we have an exponent to add
-	if (expChar != 0) {
-	    numBuf.append(expChar);
-	    numBuf.append(exp < 0 ? '-' : '+');
-	    if (exp < 10) {
-		numBuf.append('0');
-	    }
-	    numBuf.append(exp);
-	}
+        // we have an exponent to add
+        if (expChar != 0) {
+            numBuf.append(expChar);
+            numBuf.append(exp < 0 ? '-' : '+');
+            if (exp < 10) {
+                numBuf.append('0');
+            }
+            numBuf.append(exp);
+        }
-	// define the number's sign as the prefix for later formatting
-	String prefStr;
-	if (num < 0) {
-	    prefStr = "-";
-	} else if (flags.get(FLAG_SI)) {
-	    prefStr = "+";
-	} else {
-	    prefStr = "";
-	}
+        // define the number's sign as the prefix for later formatting
+        String prefStr;
+        if (num < 0) {
+            prefStr = "-";
+        } else if (flags.get(FLAG_SI)) {
+            prefStr = "+";
+        } else {
+            prefStr = "";
+        }
-	// now format it and up we go
-	return format(buf, numBuf.toString(), prefStr, width, flags);
+        // now format it and up we go
+        return format(buf, numBuf.toString(), prefStr, width, flags);
-     * <p>
+     * <p/>
-     * @param buf The <code>StringBuffer</code> to append the formatted result
-     * 		to.
-     * @param str The <code>String</code> to be appended with surrounding
-     * 		blanks, zeroes and <code>prefStr</code> depending on the
-     * 		<code>flags</code>. This is usually the real string to print
-     * 		like "ape" or "4.5E99".
+     * @param buf     The <code>StringBuffer</code> to append the formatted result
+     *                to.
+     * @param str     The <code>String</code> to be appended with surrounding
+     *                blanks, zeroes and <code>prefStr</code> depending on the
+     *                <code>flags</code>. This is usually the real string to print
+     *                like "ape" or "4.5E99".
-     * 		in front of the <code>String</code>. This is usually the prefix
-     * 		string for numeric <code>str</code> values, for example
-     * 		"-", "0x", or "+". The reason for this separation is that the
-     * 		{@link #FLAG_ZE} flag will insert zeroes between the prefix and
-     * 		the string itself to fill the field to the width.
-     * @param width The minimal field width. If the field width is larger than
-     * 		the sum of the lengths of <code>str</code> and
-     * 		<code>prefStr</code>, blanks or zeroes will be prepended or
-     * 		appended according to the flags value.
-     * @param flags The flags indicating where blanks or zeroes will be filled.
-     * 		See above for the interpretation of flags.
-     *
+     *                in front of the <code>String</code>. This is usually the prefix
+     *                string for numeric <code>str</code> values, for example
+     *                "-", "0x", or "+". The reason for this separation is that the
+     *                {@link #FLAG_ZE} flag will insert zeroes between the prefix and
+     *                the string itself to fill the field to the width.
+     * @param width   The minimal field width. If the field width is larger than
+     *                the sum of the lengths of <code>str</code> and
+     *                <code>prefStr</code>, blanks or zeroes will be prepended or
+     *                appended according to the flags value.
+     * @param flags   The flags indicating where blanks or zeroes will be filled.
+     *                See above for the interpretation of flags.
-     * 		<code>str</code>, <code>prefStr</code> or <code>flags</code>
-     * 		is <code>null</code>.
+     *                              <code>str</code>, <code>prefStr</code> or <code>flags</code>
+     *                              is <code>null</code>.
-	String prefStr, int width, BitSet flags) {
+                                       String prefStr, int width, BitSet flags) {
-	int numFill = width - prefStr.length() - str.length();
-	int preZero = 0;
-	int preBlank = 0;
-	int postBlank = 0;
+        int numFill = width - prefStr.length() - str.length();
+        int preZero = 0;
+        int preBlank = 0;
+        int postBlank = 0;
-	if (flags.get(FLAG_LJ)) {
-	    postBlank = numFill;
-	} else if (flags.get(FLAG_ZE)) {
-	    preZero = numFill;
-	} else {
-	    preBlank = numFill;
-	}
+        if (flags.get(FLAG_LJ)) {
+            postBlank = numFill;
+        } else if (flags.get(FLAG_ZE)) {
+            preZero = numFill;
+        } else {
+            preBlank = numFill;
+        }
-	for ( ; preBlank > 0; preBlank--) buf.append(' ');
-	buf.append(prefStr);
-	for ( ; preZero > 0; preZero--) buf.append('0');
-	buf.append(str);
-	for ( ; postBlank > 0; postBlank--) buf.append(' ');
+        for (; preBlank > 0; preBlank--) buf.append(' ');
+        buf.append(prefStr);
+        for (; preZero > 0; preZero--) buf.append('0');
+        buf.append(str);
+        for (; postBlank > 0; postBlank--) buf.append(' ');
-	return buf;
+        return buf;

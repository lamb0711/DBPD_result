JCR-2076: JSR 283: Joins
- columns

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@781369 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.commons.query.qom.ColumnImpl;
-import javax.jcr.NamespaceException;
+import java.util.Map;
+import java.util.LinkedHashMap;
-     * The select properties
+     * The columns to select.
-    protected final Name[] selectProps;
+    protected final Map<String, ColumnImpl> columns = new LinkedHashMap<String, ColumnImpl>();
-    private final List resultNodes = new ArrayList();
+    private final List<ScoreNode[]> resultNodes = new ArrayList<ScoreNode[]>();
-     * @param selectProps     the select properties of the query.
+     * @param columns         the select properties of the query.
+     * @throws IllegalArgumentException if any of the columns does not have a
+     *                                  column name.
-                           Name[] selectProps,
+                           ColumnImpl[] columns,
-        this.selectProps = selectProps;
+        for (ColumnImpl column : columns) {
+            String cn = column.getColumnName();
+            if (cn == null) {
+                String msg = column + " does not have a column name";
+                throw new IllegalArgumentException(msg);
+            }
+            this.columns.put(cn, column);
+
+        }
-        try {
-            String[] propNames = new String[selectProps.length];
-            for (int i = 0; i < selectProps.length; i++) {
-                propNames[i] = session.getJCRName(selectProps[i]);
-            }
-            return propNames;
-        } catch (NamespaceException npde) {
-            String msg = "encountered invalid property name";
-            log.debug(msg);
-            throw new RepositoryException(msg, npde);
-        }
+        return columns.keySet().toArray(new String[columns.size()]);
-        return new RowIteratorImpl(getScoreNodes(), selectProps,
+        return new RowIteratorImpl(getScoreNodes(), columns,
-            log.debug("getResults({}) limit={}", new Long(size), new Long(limit));
+            log.debug("getResults({}) limit={}", size, limit);
-                    new Long(System.currentTimeMillis() - time));
+                    System.currentTimeMillis() - time);
-                collectScoreNodes(result, new ArrayList(), offset);
+                collectScoreNodes(result, new ArrayList<ScoreNode[]>(), offset);
-                    new Long(System.currentTimeMillis() - time));
+                    System.currentTimeMillis() - time);
-                                   List collector,
+                                   List<ScoreNode[]> collector,
-        for (int i = 0; i < nodes.length; i++) {
+        for (ScoreNode node : nodes) {
-                if (nodes[i] != null && !accessMgr.isGranted(nodes[i].getNodeId(), AccessManager.READ)) {
+                if (node != null && !accessMgr.isGranted(node.getNodeId(), AccessManager.READ)) {
-                next = (ScoreNode[]) resultNodes.get(nextPos);
+                next = resultNodes.get(nextPos);

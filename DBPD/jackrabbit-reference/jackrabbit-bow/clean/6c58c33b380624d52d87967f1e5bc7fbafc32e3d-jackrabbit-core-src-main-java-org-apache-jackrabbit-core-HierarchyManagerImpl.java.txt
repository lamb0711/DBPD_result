JCR-1104 - JSR 283 support
- shareble nodes (work in progress)
- improve share-cycle detection

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@646336 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Collections;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+     * Return all parents of a node. A shareable node has possibly more than
+     * one parent.
+     *
+     * @param state item state
+     * @return set of parent <code>NodeId</code>s. If state has no parent,
+     *         array has length <code>0</code>.
+     */
+    protected Set getParentIds(ItemState state) {
+        if (state.isNode()) {
+            // if this is a node, quickly check whether it is shareable and
+            // whether it contains more than one parent
+            NodeState ns = (NodeState) state;
+            Set s = ns.getSharedSet();
+            if (s.size() > 1) {
+                return s;
+            }
+        }
+        NodeId parentId = getParentId(state);
+        if (parentId != null) {
+            LinkedHashSet s = new LinkedHashSet();
+            s.add(parentId);
+            return s;
+        }
+        return Collections.EMPTY_SET;
+    }
+
+    /**
-        
+
-    
+
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean isShareAncestor(NodeId ancestor, NodeId descendant)
+            throws ItemNotFoundException, RepositoryException {
+        if (ancestor.equals(descendant)) {
+            // can't be ancestor of self
+            return false;
+        }
+        try {
+            ItemState state = getItemState(descendant);
+            Set parentIds = getParentIds(state);
+            while (parentIds.size() > 0) {
+                if (parentIds.contains(ancestor)) {
+                    return true;
+                }
+                Set grandparentIds = new LinkedHashSet();
+                Iterator iter = parentIds.iterator();
+                while (iter.hasNext()) {
+                    NodeId parentId = (NodeId) iter.next();
+                    grandparentIds.addAll(getParentIds(getItemState(parentId)));
+                }
+                parentIds = grandparentIds;
+            }
+            // not an ancestor
+            return false;
+        } catch (NoSuchItemStateException nsise) {
+            String msg = "failed to determine degree of relationship of "
+                    + ancestor + " and " + descendant;
+            log.debug(msg);
+            throw new ItemNotFoundException(msg, nsise);
+        } catch (ItemStateException ise) {
+            String msg = "failed to determine degree of relationship of "
+                    + ancestor + " and " + descendant;
+            log.debug(msg);
+            throw new RepositoryException(msg, ise);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public int getShareRelativeDepth(NodeId ancestor, ItemId descendant)
+            throws ItemNotFoundException, RepositoryException {
+
+        if (ancestor.equals(descendant)) {
+            return 0;
+        }
+        int depth = 1;
+        try {
+            ItemState state = getItemState(descendant);
+            if (state.hasOverlayedState()) {
+                state = state.getOverlayedState();
+            }
+            Set parentIds = getParentIds(state);
+            while (parentIds.size() > 0) {
+                if (parentIds.contains(ancestor)) {
+                    return depth;
+                }
+                depth++;
+                Set grandparentIds = new LinkedHashSet();
+                Iterator iter = parentIds.iterator();
+                while (iter.hasNext()) {
+                    NodeId parentId = (NodeId) iter.next();
+                    state = getItemState(parentId);
+                    if (state.hasOverlayedState()) {
+                        state = state.getOverlayedState();
+                    }
+                    grandparentIds.addAll(getParentIds(state));
+                }
+                parentIds = grandparentIds;
+            }
+            // not an ancestor
+            return -1;
+        } catch (NoSuchItemStateException nsise) {
+            String msg = "failed to determine degree of relationship of "
+                    + ancestor + " and " + descendant;
+            log.debug(msg);
+            throw new ItemNotFoundException(msg, nsise);
+        } catch (ItemStateException ise) {
+            String msg = "failed to determine degree of relationship of "
+                    + ancestor + " and " + descendant;
+            log.debug(msg);
+            throw new RepositoryException(msg, ise);
+        }
+    }
+

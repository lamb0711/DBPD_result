JCR-1775: Transaction-safe versioning

Modified the NodeTypeRegistry.getEffectiveNodeType method to simplify calling code that always starts with the primary type name and a set of mixin types.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@701127 13f79535-47bb-0310-9956-ffa450edef68

-        return getEffectiveNodeType(data.getNodeState().getMixinTypeNames());
-    }
-
-    /**
-     * Small optimization to void double call for mixin types.
-     *
-     * @param mixins the set of mixins
-     * @return the effective node type
-     * @throws RepositoryException if an error occurs
-     */
-    private EffectiveNodeType getEffectiveNodeType(Set mixins)
-            throws RepositoryException {
-
-        // build effective node type of mixins & primary type
-        NodeTypeRegistry ntReg = session.getNodeTypeManager().getNodeTypeRegistry();
-
-        Name[] types = new Name[mixins.size() + 1];
-        mixins.toArray(types);
-        // primary type
-        types[types.length - 1] = data.getNodeState().getNodeTypeName();
-            return ntReg.getEffectiveNodeType(types);
+            NodeTypeRegistry registry =
+                session.getNodeTypeManager().getNodeTypeRegistry();
+            return registry.getEffectiveNodeType(
+                    data.getNodeState().getNodeTypeName(),
+                    data.getNodeState().getMixinTypeNames());
-            HashSet set = new HashSet(data.getNodeState().getMixinTypeNames());
-            // primary type
-            set.add(primaryTypeName);
+            Set mixins = new HashSet(data.getNodeState().getMixinTypeNames());
+
-            entExisting = ntReg.getEffectiveNodeType((Name[]) set.toArray(new Name[set.size()]));
+            entExisting = ntReg.getEffectiveNodeType(primaryTypeName, mixins);
-            set.add(mixinName);
+            mixins.add(mixinName);
-            ntReg.getEffectiveNodeType((Name[]) set.toArray(new Name[set.size()]));
-        } catch (NodeTypeConflictException ntce) {
-            throw new ConstraintViolationException(ntce.getMessage());
+            ntReg.getEffectiveNodeType(primaryTypeName, mixins);
+        } catch (NodeTypeConflictException e) {
+            throw new ConstraintViolationException(e.getMessage(), e);
-            // remaining mixin's
-            HashSet set = new HashSet(remainingMixins);
-            // primary type
-            set.add(state.getNodeTypeName());
-            entRemaining = ntReg.getEffectiveNodeType((Name[]) set.toArray(new Name[set.size()]));
-        } catch (NodeTypeConflictException ntce) {
-            throw new ConstraintViolationException(ntce.getMessage());
+            entRemaining = ntReg.getEffectiveNodeType(
+                    state.getNodeTypeName(), remainingMixins);
+        } catch (NodeTypeConflictException e) {
+            throw new ConstraintViolationException(e.getMessage(), e);
-        if (ntName.equals(data.getNodeState().getNodeTypeName())) {
+        Name primary = data.getNodeState().getNodeTypeName();
+        if (ntName.equals(primary)) {
-        return getEffectiveNodeType(mixins).includesNodeType(ntName);
+        try {
+            NodeTypeRegistry registry =
+                session.getNodeTypeManager().getNodeTypeRegistry();
+            EffectiveNodeType type =
+                registry.getEffectiveNodeType(primary, mixins);
+            return type.includesNodeType(ntName);
+        } catch (NodeTypeConflictException e) {
+            String msg = "Failed to build effective node type for " + this;
+            log.debug(msg);
+            throw new RepositoryException(msg, e);
+        }
-            HashSet set = new HashSet(data.getNodeState().getMixinTypeNames());
-            // primary type
-            set.add(primaryTypeName);
+            Set mixins = new HashSet(data.getNodeState().getMixinTypeNames());
+
-            entExisting = ntReg.getEffectiveNodeType((Name[]) set.toArray(new Name[set.size()]));
+            entExisting = ntReg.getEffectiveNodeType(primaryTypeName, mixins);
+
-            set.add(ntName);
+            mixins.add(ntName);
-            ntReg.getEffectiveNodeType((Name[]) set.toArray(new Name[set.size()]));
+            ntReg.getEffectiveNodeType(primaryTypeName, mixins);
-            // existing mixin's
-            HashSet set = new HashSet(state.getMixinTypeNames());
-            // new primary type
-            set.add(ntName);
-            ntReg.getEffectiveNodeType((Name[]) set.toArray(new Name[set.size()]));
+            ntReg.getEffectiveNodeType(ntName, state.getMixinTypeNames());

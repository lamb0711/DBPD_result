JCR-3816: [aws-ext]S3DS not able update lastModified of record > 5GB
JCR-3817: [jackrabbit-aws-ext] Performance of operation degrades while running DS GC

Applying patch from Shashank Gupta

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1632482 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.data.AsyncTouchCallback;
+import org.apache.jackrabbit.core.data.AsyncTouchResult;
+import com.amazonaws.services.s3.transfer.Copy;
-            if (propEndPoint != null & !"".equals(propEndPoint)) {
+            if ((propEndPoint != null) & !"".equals(propEndPoint)) {
-                    s3service.copyObject(copReq);
+                    Copy copy = tmx.copy(copReq);
+                    copy.waitForCopyResult();
+    
+    @Override
+    public void touchAsync(final DataIdentifier identifier,
+            final long minModifiedDate, final AsyncTouchCallback callback)
+            throws DataStoreException {
+        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
+        try {
+            if (callback == null) {
+                throw new IllegalArgumentException(
+                    "callback parameter cannot be null in touchAsync");
+            }
+            Thread.currentThread().setContextClassLoader(
+                getClass().getClassLoader());
+
+            asyncWriteExecuter.execute(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        touch(identifier, minModifiedDate);
+                        callback.onSuccess(new AsyncTouchResult(identifier));
+                    } catch (DataStoreException e) {
+                        AsyncTouchResult result = new AsyncTouchResult(
+                            identifier);
+                        result.setException(e);
+                        callback.onFailure(result);
+                    }
+                }
+            });
+        } catch (Exception e) {
+            callback.onAbort(new AsyncTouchResult(identifier));
+            throw new DataStoreException("Cannot touch the record "
+                + identifier.toString(), e);
+        } finally {
+            if (contextClassLoader != null) {
+                Thread.currentThread().setContextClassLoader(contextClassLoader);
+            }
+        }
+
+    }
+
+    @Override
+    public void touch(DataIdentifier identifier, long minModifiedDate)
+            throws DataStoreException {
+        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
+        try {
+            final long start = System.currentTimeMillis();
+            final String key = getKeyName(identifier);
+            if (minModifiedDate > 0
+                && minModifiedDate > getLastModified(identifier)) {
+                CopyObjectRequest copReq = new CopyObjectRequest(bucket, key,
+                    bucket, key);
+                copReq.setNewObjectMetadata(new ObjectMetadata());
+                Copy copy = tmx.copy(copReq);
+                copy.waitForCompletion();
+                LOG.debug("[{}] touched. time taken [{}] ms ", new Object[] {
+                    identifier, (System.currentTimeMillis() - start) });
+            } else {
+                LOG.debug("[{}] touch not required. time taken [{}] ms ",
+                    new Object[] { identifier,
+                        (System.currentTimeMillis() - start) });
+            }
+
+        } catch (Exception e) {
+            throw new DataStoreException("Error occured in touching key ["
+                + identifier.toString() + "]", e);
+        } finally {
+            if (contextClassLoader != null) {
+                Thread.currentThread().setContextClassLoader(contextClassLoader);
+            }
+        }
+    }
-                    if (!store.isInUse(identifier) && lastModified < min) {
-                        LOG.debug("add id [{}] to delete lists",  s3ObjSumm.getKey());
+                    if (lastModified < min
+                        && store.confirmDelete(identifier)
+                         // confirm once more that record's lastModified < min
+                        //  order is important here
+                        && s3service.getObjectMetadata(bucket,
+                            s3ObjSumm.getKey()).getLastModified().getTime() < min) {
+                       
+
+                        LOG.debug("add id [{}] to delete lists",
+                            s3ObjSumm.getKey());
+        asyncWriteExecuter.shutdownNow();
-        asyncWriteExecuter.shutdownNow();
-                s3service.copyObject(copReq);
-                LOG.debug("lastModified of [{}] updated successfully.", identifier);
-                if (callback != null) {
-                    callback.onSuccess(new AsyncUploadResult(identifier, file));
+                Copy copy = tmx.copy(copReq);
+                try {
+                    copy.waitForCopyResult();
+                    LOG.debug("lastModified of [{}] updated successfully.", identifier);
+                    if (callback != null) {
+                        callback.onSuccess(new AsyncUploadResult(identifier, file));
+                    }
+                }catch (Exception e2) {
+                    AsyncUploadResult asyncUpRes= new AsyncUploadResult(identifier, file);
+                    asyncUpRes.setException(e2);
+                    if (callback != null) {
+                        callback.onAbort(asyncUpRes);
+                    }
+                    throw new DataStoreException("Could not upload " + key, e2);
-                } catch (Exception e2) {
-                    if (!asyncUpload) {
-                        callback.onAbort(new AsyncUploadResult(identifier, file));
-                    }
+                } catch (Exception e2 ) {
+                    AsyncUploadResult asyncUpRes= new AsyncUploadResult(identifier, file);
+                    asyncUpRes.setException(e2);
+                    if (callback != null) {
+                        callback.onAbort(asyncUpRes);
+                    } 
+    
-                s3service.copyObject(copReq);
-                LOG.debug("[{}] renamed to [{}] ", oldKey, newS3Key);
+                Copy copy = tmx.copy(copReq);
+                try {
+                    copy.waitForCopyResult();
+                    LOG.debug("[{}] renamed to [{}] ", oldKey, newS3Key);
+                } catch (InterruptedException ie) {
+                    LOG.error(" Exception in renaming [{}] to [{}] ",
+                        new Object[] { ie, oldKey, newS3Key });
+                }
+               
-
+    
+
+    

JCR-2715: Improved join query performance

Add support for offset and limit on join queries.
Better handling of queries with too many or clauses.
Various smaller improvements.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1024211 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Set;
-import javax.jcr.PathNotFoundException;
+import javax.jcr.NodeIterator;
+import org.apache.jackrabbit.commons.iterator.NodeIteratorAdapter;
-    public QueryEngine(Session session) throws RepositoryException {
-        this(session, new HashMap<String, Value>());
-    }
-
-            Column[] columns, Source source,
-            Constraint constraint, Ordering[] orderings)
+            Column[] columns, Source source, Constraint constraint,
+            Ordering[] orderings, long offset, long limit)
-            return execute(columns, selector, constraint, orderings);
+            return execute(
+                    columns, selector, constraint, orderings, offset, limit);
-            return execute(columns, join, constraint, orderings);
+            return execute(
+                    columns, join, constraint, orderings, offset, limit);
-            Column[] columns, Join join,
-            Constraint constraint, Ordering[] orderings)
+            Column[] columns, Join join, Constraint constraint,
+            Ordering[] orderings, long offset, long limit)
-        System.out.println("FROM " + left + " WHERE " + leftConstraint);
-        QueryResult leftResult = execute(null, left, leftConstraint, null);
+        QueryResult leftResult =
+            execute(null, left, leftConstraint, null, 0, -1);
-            System.out.println(row);
+        RowIterator rightRows;
-        Constraint rightConstraint = Constraints.and(
-                qomFactory,
-                merger.getRightJoinConstraint(leftRows),
-                splitter.getRightConstraint());
-        System.out.println("FROM " + right + " WHERE " + rightConstraint);
-        QueryResult rightResult = execute(null, right, rightConstraint, null);
-
-        return merger.merge(
-                new RowIteratorAdapter(leftRows), rightResult.getRows());
-    }
-
-    private Set<String> getPaths(
-            String selectorName, String relativePath, List<Row> rows)
-            throws RepositoryException {
-        Set<String> paths = new HashSet<String>();
-        for (Row row : rows) {
-            try {
-                Node node = row.getNode(selectorName);
-                if (relativePath != null) {
-                    node = node.getNode(relativePath);
+        List<Constraint> rightConstraints =
+            merger.getRightJoinConstraints(leftRows);
+        if (rightConstraints.size() < 500) {
+            Constraint rightConstraint = Constraints.and(
+                    qomFactory,
+                    Constraints.or(qomFactory, rightConstraints),
+                    splitter.getRightConstraint());
+            rightRows =
+                execute(null, right, rightConstraint, null, 0, -1).getRows();
+        } else {
+            List<Row> list = new ArrayList<Row>();
+            for (int i = 0; i < rightConstraints.size(); i += 500) {
+                Constraint rightConstraint = Constraints.and(
+                        qomFactory,
+                        Constraints.or(qomFactory, rightConstraints.subList(
+                                i, Math.min(i + 500, rightConstraints.size()))),
+                        splitter.getRightConstraint());
+                QueryResult rigthResult =
+                    execute(null, right, rightConstraint, null, 0, -1);
+                for (Row row : JcrUtils.getRows(rigthResult)) {
+                    list.add(row);
-                paths.add(node.getPath());
-            } catch (PathNotFoundException e) {
-                // Node at relative path not found, skip
+            rightRows = new RowIteratorAdapter(list);
-        return paths;
+        return merger.merge(
+                new RowIteratorAdapter(leftRows), rightRows, offset, limit);
-            Column[] columns, Selector selector,
-            Constraint constraint, Ordering[] orderings)
+            Column[] columns, Selector selector, Constraint constraint,
+            Ordering[] orderings, long offset, long limit)
-        System.out.println(builder.toString());
+        NodeIterator nodes = query.execute().getNodes();
+        while ((offset-- > 0 || limit == 0) && nodes.hasNext()) {
+            nodes.next();
+        }
+        if (limit > 0) {
+            List<Node> list = new ArrayList<Node>((int) limit);
+            for (int i = 0; i < limit && nodes.hasNext(); i++) {
+                list.add(nodes.nextNode());
+            }
+            nodes = new NodeIteratorAdapter(list);
+        }
+
-        RangeIterator rows = new RangeIteratorAdapter(query.execute().getNodes()) {
+        RangeIterator rows = new RangeIteratorAdapter(nodes) {

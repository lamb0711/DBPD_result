JCR-307: further optimizations which should improve performance significantly when dealing with 'heavy' nodes

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@375921 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.commons.collections.OrderedMapIterator;
-import java.util.Map;
-    /** Serialization UID of this class. */
+    /**
+     * Serialization UID of this class.
+     */
-    /** the uuid of this node */
+    /**
+     * the uuid of this node
+     */
-    /** the name of this node's primary type */
+    /**
+     * the name of this node's primary type
+     */
-    /** the names of this node's mixin types */
+    /**
+     * the names of this node's mixin types
+     */
-    /** id of this node's definition */
+    /**
+     * id of this node's definition
+     */
-    /** insertion-ordered collection of ChildNodeEntry objects */
+    /**
+     * insertion-ordered collection of ChildNodeEntry objects
+     */
-    /** set of property names (QName objects) */
+    /**
+     * set of property names (QName objects)
+     */
-     * @param index 1-based index if there are same-name child node entries
+     * @param index   1-based index if there are same-name child node entries
-        childNodeEntries.removeAll();
-        childNodeEntries.addAll(nodeEntries);
+        if (nodeEntries instanceof ChildNodeEntries) {
+            // optimization
+            ChildNodeEntries entries = (ChildNodeEntries) nodeEntries;
+            childNodeEntries = (ChildNodeEntries) entries.clone();
+        } else {
+            childNodeEntries.removeAll();
+            childNodeEntries.addAll(nodeEntries);
+        }
+        if (propNames instanceof HashSet) {
+            HashSet names = (HashSet) propNames;
+            propNames = (HashSet) names.clone();
+        }
-        List others = new ArrayList();
-        others.addAll(((NodeState) getOverlayedState()).getChildNodeEntries());
+        ChildNodeEntries otherChildNodeEntries =
+                ((NodeState) overlayedState).childNodeEntries;
-        List ours = new ArrayList();
-        ours.addAll(childNodeEntries);
+        if (childNodeEntries.isEmpty()
+                || otherChildNodeEntries.isEmpty()) {
+            return Collections.EMPTY_LIST;
+        }
+
+        // build intersections of both collections,
+        // each preserving their relative order
+        List ours = childNodeEntries.retainAll(otherChildNodeEntries);
+        List others = otherChildNodeEntries.retainAll(childNodeEntries);
-        // remove added nodes from 'our' entries
-        ours.removeAll(getAddedChildNodeEntries());
-        // remove all removed nodes from 'other' entries
-        others.removeAll(getRemovedChildNodeEntries());
-            if (!entry.getUUID().equals(other.getUUID())) {
+            if (entry == other || entry.getUUID().equals(other.getUUID())) {
+                // no reorder, move to next child entry
+                i++;
+            } else {
+                // reordered entry detected
-            } else {
-                // no reorder, move to next child entry
-                i++;
-     *
+     * <p/>
-     *
+     * <p/>
-           }
-           return entry;
+            }
+            return entry;
-         * <code>this</code> but not in <code>other</code>
+         * <code>this</code> but not in <code>other</code>.
+                if (entry == otherEntry) {
+                    continue;
+                }
+        /**
+         * Returns a list of <code>ChildNodeEntry</code>s who do exist in
+         * <code>this</code> <i>and</i> in <code>other</code>.
+         * <p/>
+         * Note that two entries are considered identical in this context if
+         * they have the same name and uuid, i.e. the index is disregarded
+         * whereas <code>ChildNodeEntry.equals(Object)</code> also compares
+         * the index.
+         *
+         * @param other entries to be retained
+         * @return a new list of those entries that do exist in
+         *         <code>this</code> <i>and</i> in <code>other</code>
+         */
+        List retainAll(ChildNodeEntries other) {
+            if (entries.isEmpty()
+                    || other.isEmpty()) {
+                return Collections.EMPTY_LIST;
+            }
+
+            List result = new ArrayList();
+            Iterator iter = iterator();
+            while (iter.hasNext()) {
+                ChildNodeEntry entry = (ChildNodeEntry) iter.next();
+                ChildNodeEntry otherEntry = (ChildNodeEntry) other.get(entry.uuid);
+                if (entry == otherEntry) {
+                    result.add(entry);
+                } else if (otherEntry != null
+                        && entry.getName().equals(otherEntry.getName())) {
+                    result.add(entry);
+                }
+            }
+
+            return result;
+        }
+
-            return new OrderedMapIterator(entries.asList().listIterator(), entries);
+            return new EntriesIterator();
-            return new OrderedMapIterator(entries.asList().listIterator(), entries);
+            return new EntriesIterator();
-            return new OrderedMapIterator(entries.asList().listIterator(index), entries);
+            if (index < 0 || index >= entries.size()) {
+                throw new IndexOutOfBoundsException();
+            }
+            ListIterator iter = new EntriesIterator();
+            while (index-- > 0) {
+                iter.next();
+            }
+            return iter;
+         *
-            for (Iterator it = nameMap.keySet().iterator(); it.hasNext(); ) {
+            for (Iterator it = nameMap.keySet().iterator(); it.hasNext();) {
-        class OrderedMapIterator implements ListIterator {
+        class EntriesIterator implements ListIterator {
-            final ListIterator keyIter;
-            final Map entries;
+            OrderedMapIterator mapIter;
-            OrderedMapIterator(ListIterator keyIter, Map entries) {
-                this.keyIter = keyIter;
-                this.entries = entries;
+            EntriesIterator() {
+                mapIter = entries.orderedMapIterator();
-                return keyIter.hasNext();
+                return mapIter.hasNext();
-                return entries.get(keyIter.next());
+                mapIter.next();
+                return mapIter.getValue();
-                return keyIter.hasPrevious();
+                return mapIter.hasPrevious();
-                return keyIter.nextIndex();
+                return entries.indexOf(mapIter.getKey()) + 1;
-                return entries.get(keyIter.previous());
+                mapIter.previous();
+                return mapIter.getValue();
-                return keyIter.previousIndex();
+                return entries.indexOf(mapIter.getKey()) - 1;

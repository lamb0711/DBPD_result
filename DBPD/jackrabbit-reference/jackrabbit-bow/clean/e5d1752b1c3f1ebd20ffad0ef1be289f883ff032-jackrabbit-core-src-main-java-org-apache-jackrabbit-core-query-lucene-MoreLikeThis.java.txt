JCR-2415: Update Lucene to 3.0
- Merge all from JCR-2415-lucene-3.0 at 1064038 (reintegration)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1064058 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.lucene.util.Version;
-import org.apache.lucene.analysis.Token;
+import org.apache.lucene.analysis.tokenattributes.TermAttribute;
+import java.util.List;
-    public static final Analyzer DEFAULT_ANALYZER = new StandardAnalyzer();
+    public static final Analyzer DEFAULT_ANALYZER = new StandardAnalyzer(Version.LUCENE_24);
-    public static final Set DEFAULT_STOP_WORDS = null;
+    public static final Set<String> DEFAULT_STOP_WORDS = null;
-    private Set stopWords = DEFAULT_STOP_WORDS;
+    private Set<String> stopWords = DEFAULT_STOP_WORDS;
-    public void setStopWords(Set stopWords) {
+    public void setStopWords(Set<String> stopWords) {
-    public Set getStopWords() {
+    public Set<String> getStopWords() {
-            Collection fields = ir.getFieldNames( IndexReader.FieldOption.INDEXED);
-            fieldNames = (String[]) fields.toArray(new String[fields.size()]);
+            @SuppressWarnings("unchecked")
+            Collection<String> fields = ir.getFieldNames(IndexReader.FieldOption.INDEXED);
+            fieldNames = fields.toArray(new String[fields.size()]);
-            Collection fields = ir.getFieldNames( IndexReader.FieldOption.INDEXED);
-            fieldNames = (String[]) fields.toArray(new String[fields.size()]);
+            @SuppressWarnings("unchecked")
+            Collection<String> fields = ir.getFieldNames(IndexReader.FieldOption.INDEXED);
+            fieldNames = fields.toArray(new String[fields.size()]);
-    private PriorityQueue createQueue(Map words) throws IOException {
+    private PriorityQueue createQueue(Map<String, Int> words) throws IOException {
-        Iterator it = words.keySet().iterator();
+        Iterator<String> it = words.keySet().iterator();
-            String word = (String) it.next();
+            String word = it.next();
-            res.insert(new Object[]{word,                   // the word
+            res.insertWithOverflow(new Object[]{word,                   // the word
-        Map termFreqMap = new HashMap();
+        Map<String, Int> termFreqMap = new HashMap<String, Int>();
-    private void addTermFrequencies(Map termFreqMap, TermFreqVector vector) {
+    private void addTermFrequencies(Map<String, Int> termFreqMap, TermFreqVector vector) {
-    private void addTermFrequencies(Reader r, Map termFreqMap, String fieldName)
+    private void addTermFrequencies(Reader r, Map<String, Int> termFreqMap, String fieldName)
-        final Token reusableToken = new Token();
-        for (Token nextToken = ts.next(reusableToken); nextToken != null; nextToken = ts.next(reusableToken)) {
-            String word = nextToken.term();
+        while (ts.incrementToken()) {
+            TermAttribute term = ts.getAttribute(TermAttribute.class);
+            String word =  term.term();
-            Int cnt = (Int) termFreqMap.get(word);
+            Int cnt = termFreqMap.get(word);
+        ts.end();
+        ts.close();
-        Map words = new HashMap();
+        Map<String, Int> words = new HashMap<String, Int>();
-        ArrayList al = new ArrayList(maxQueryTerms);
+        List<String> al = new ArrayList<String>(maxQueryTerms);
-            al.add(ar[0]); // the 1st entry is the interesting word
+            al.add((String) ar[0]); // the 1st entry is the interesting word
-        String[] res = new String[al.size()];
-        return (String[]) al.toArray(res);
+        return al.toArray(new String[al.size()]);
-        ArrayList al = new ArrayList(maxQueryTerms);
+        List<String> al = new ArrayList<String>(maxQueryTerms);
-            al.add(ar[0]); // the 1st entry is the interesting word
+            al.add((String) ar[0]); // the 1st entry is the interesting word
-        String[] res = new String[al.size()];
-        return (String[]) al.toArray(res);
+        return al.toArray(new String[al.size()]);

JCR-2113 : WIP (Contribution by Alfusainey Jallow)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1640892 13f79535-47bb-0310-9956-ffa450edef68

+import javax.jcr.PathNotFoundException;
+import org.apache.jackrabbit.spi.PrivilegeDefinition;
+import org.apache.jackrabbit.spi.commons.privilege.PrivilegeDefinitionImpl;
+import org.apache.jackrabbit.webdav.security.SupportedPrivilege;
+import org.apache.jackrabbit.webdav.security.SupportedPrivilegeSetProperty;
+    @Override
+    public PrivilegeDefinition[] getPrivilegeDefinitions(SessionInfo sessionInfo) throws RepositoryException {
+        return internalGetPrivilegeDefinitions(sessionInfo, uriResolver.getRepositoryUri());
+    }
+
+    @Override
+    public PrivilegeDefinition[] getSupportedPrivileges(SessionInfo sessionInfo, NodeId nodeId) throws RepositoryException {
+        String uri = (nodeId == null) ? uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName()) : getItemUri(nodeId, sessionInfo);
+        return internalGetPrivilegeDefinitions(sessionInfo, uri);
+    }
+
+    private PrivilegeDefinition[] internalGetPrivilegeDefinitions(SessionInfo sessionInfo, String uri) throws RepositoryException {
+        DavPropertyNameSet nameSet = new DavPropertyNameSet();
+        nameSet.add(SecurityConstants.SUPPORTED_PRIVILEGE_SET);
+        DavMethodBase method = null;
+        try {
+            method = new PropFindMethod(uri, nameSet, DEPTH_0);
+            getClient(sessionInfo).executeMethod(method);
+
+            MultiStatusResponse[] responses = method.getResponseBodyAsMultiStatus().getResponses();
+            if (responses.length < 1) {
+                throw new PathNotFoundException("Unable to retrieve privileges definitions.");
+            }
+
+            DavPropertyName displayName = SecurityConstants.SUPPORTED_PRIVILEGE_SET;
+            DavProperty<?> p = responses[0].getProperties(DavServletResponse.SC_OK).get(displayName);
+            if (p == null) {
+                return new PrivilegeDefinition[0];
+            } else {
+                // build PrivilegeDefinition(s) from the supported-privileges dav property
+                NamePathResolver npResolver = getNamePathResolver(sessionInfo);
+                Map<Name, SupportedPrivilege> spMap = new HashMap<Name, SupportedPrivilege>();
+                fillSupportedPrivilegeMap(new SupportedPrivilegeSetProperty(p).getValue(), spMap, npResolver);
+
+                List<PrivilegeDefinition> pDefs = new ArrayList<PrivilegeDefinition>();
+                for (Name privilegeName : spMap.keySet()) {
+                    SupportedPrivilege sp = spMap.get(privilegeName);
+                    Set<Name> aggrnames = null;
+                    SupportedPrivilege[] aggregates = sp.getSupportedPrivileges();
+                    if (aggregates != null && aggregates.length > 0) {
+                        aggrnames = new HashSet<Name>();
+                        for (SupportedPrivilege aggregate : aggregates) {
+                            aggrnames.add(npResolver.getQName(aggregate.getPrivilege().getName()));
+                        }
+                    }
+                    PrivilegeDefinition def = new PrivilegeDefinitionImpl(privilegeName, sp.isAbstract(), aggrnames);
+                    pDefs.add(def);
+                }
+                return pDefs.toArray(new PrivilegeDefinition[pDefs.size()]);
+            }
+        } catch (IOException e) {
+            throw new RepositoryException(e);
+        } catch (DavException e) {
+            throw ExceptionConverter.generate(e);
+        } finally {
+            if (method != null) {
+                method.releaseConnection();
+            }
+        }
+    }
+
+    private static void fillSupportedPrivilegeMap(List<SupportedPrivilege> sps, Map<Name, SupportedPrivilege> spMap, NamePathResolver npResolver) throws NamespaceException, IllegalNameException {
+        for (SupportedPrivilege sp : sps) {
+            spMap.put(npResolver.getQName(sp.getPrivilege().getName()), sp);
+            List<SupportedPrivilege> agg = Arrays.asList(sp.getSupportedPrivileges());
+            if (!agg.isEmpty()) {
+                fillSupportedPrivilegeMap(agg, spMap, npResolver);
+            }
+        }
+    }
+

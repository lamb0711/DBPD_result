JCR-1365: Query path constraints like foo//*/bar do not scale
- more performance improvements

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@629453 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Arrays;
+import java.util.Collections;
-     * Creates query hits that consist of the nodes that are traversed from
-     * a given <code>start</code> node.
+     * Creates query hits that consist of the nodes that are traversed from a
+     * given <code>start</code> node.
-     * @param start the start node of the traversal.
+     * @param start        the start node of the traversal.
-        this.nodes = new TraversingNodeIterator(start);
+        this(start, includeStart, Integer.MAX_VALUE);
+    }
+
+    /**
+     * Creates query hits that consist of the nodes that are traversed from a
+     * given <code>start</code> node.
+     *
+     * @param start        the start node of the traversal.
+     * @param includeStart whether to include the start node in the result.
+     * @param maxDepth     the maximum depth of nodes to traverse.
+     */
+    public NodeTraversingQueryHits(Node start,
+                                   boolean includeStart,
+                                   int maxDepth) {
+        this.nodes = new TraversingNodeIterator(start, maxDepth);
-     * <p/>
-     * Does nothing.
-     */
-    protected void doClose() throws IOException {
-        // nothing to do
-    }
-
-    /**
-     * {@inheritDoc}
-     * <p/>
-     * This implementation always returns <code>-1</code>.
-     */
-    public int getSize() {
-        // don't know
-        return -1;
-    }
-
-    /**
-     * {@inheritDoc}
+         * The maximum depth of the traversal.
+         */
+        private final int maxDepth;
+
+        /**
-        private IteratorChain selfAndChildren;
+        private Iterator selfAndChildren;
-         * @param start the node from where to start the traversal.
+         *
+         * @param start    the node from where to start the traversal.
+         * @param maxDepth the maximum depth of nodes to traverse.
-        TraversingNodeIterator(Node start) {
+        TraversingNodeIterator(Node start, int maxDepth) {
+            if (maxDepth < 0) {
+                throw new IllegalArgumentException("maxDepth must be >= 0");
+            }
+            this.maxDepth = maxDepth;
-                Iterator current = Arrays.asList(new Node[]{currentNode}).iterator();
+                Iterator current = Collections.singletonList(currentNode).iterator();
-
-                // create new TraversingNodeIterator for each child
-                try {
-                    NodeIterator children = currentNode.getNodes();
-                    while (children.hasNext()) {
-                        allIterators.add(new TraversingNodeIterator(children.nextNode()));
+                if (maxDepth == 0) {
+                    // only current node
+                } else if (maxDepth == 1) {
+                    try {
+                        allIterators.add(currentNode.getNodes());
+                    } catch (RepositoryException e) {
+                        // currentNode is probably stale
-                } catch (RepositoryException e) {
-                    // currentNode is probably stale
+                } else {
+                    // create new TraversingNodeIterator for each child
+                    try {
+                        NodeIterator children = currentNode.getNodes();
+                        while (children.hasNext()) {
+                            allIterators.add(new TraversingNodeIterator(children.nextNode(), maxDepth - 1));
+                        }
+                    } catch (RepositoryException e) {
+                        // currentNode is probably stale
+                    }

JCR-3107 Speed up hierarchy cache initialization
 - based on a patch by Martin BÃ¶ttcher

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1182761 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.text.NumberFormat;
+import java.util.Arrays;
+import java.util.BitSet;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+import org.apache.commons.collections.map.LRUMap;
+import org.apache.jackrabbit.core.id.NodeId;
+import org.apache.lucene.index.CorruptIndexException;
-import org.apache.lucene.index.CorruptIndexException;
-import org.apache.jackrabbit.core.id.NodeId;
-import org.apache.commons.collections.map.LRUMap;
+import org.apache.lucene.store.IndexInput;
+import org.apache.lucene.store.IndexOutput;
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.BitSet;
-import java.util.Map;
-import java.util.HashMap;
-import java.util.Collections;
-import java.text.NumberFormat;
-import java.util.concurrent.ConcurrentHashMap;
-
-    private CacheInitializer cacheInitializer;
+    private final CacheInitializer cacheInitializer;
-        this.shareableNodes = new BitSet();
-        TermDocs tDocs = delegatee.termDocs(
-                new Term(FieldNames.SHAREABLE_NODE, ""));
-        try {
-            while (tDocs.next()) {
-                shareableNodes.set(tDocs.doc());
-            }
-        } finally {
-            tDocs.close();
-        }
+        this.shareableNodes = initShareableNodes(delegatee);
+    private BitSet initShareableNodes(IndexReader delegatee) throws IOException {
+        BitSet shareableNodes = new BitSet();
+        TermDocs tDocs = delegatee.termDocs(new Term(FieldNames.SHAREABLE_NODE,
+                ""));
+        try {
+            while (tDocs.next()) {
+                shareableNodes.set(tDocs.doc());
+            }
+        } finally {
+            tDocs.close();
+        }
+        return shareableNodes;
+    }
+
+         * The {@link #inSegmentParents} is persisted using this filename.
+         */
+        private static final String FILE_CACHE_NAME_ARRAY = "cache.inSegmentParents";
+
+        /**
-         *
-         * @param reader an index reader.
+         * @param reader
+         *            an index reader.
-                initializeParents(reader);
+                boolean initCacheFromFile = loadCacheFromFile();
+                if (!initCacheFromFile) {
+                    // file-based cache is not available, load from the
+                    // repository
+                    initializeParents(reader);
+                }
-                    // no more nodes to initialize
+                    // no more nodes to initialize, persist cache to file
+                    saveCacheToFile();
+
+        /**
+         * Persists the cache info {@link #inSegmentParents} to a file:
+         * {@link #FILE_CACHE_NAME_ARRAY}, for faster init times on startup.
+         * 
+         * see https://issues.apache.org/jira/browse/JCR-3107
+         */
+        public void saveCacheToFile() throws IOException {
+            IndexOutput io = null;
+            try {
+                io = reader.directory().createOutput(FILE_CACHE_NAME_ARRAY);
+                for (int parent : inSegmentParents) {
+                    io.writeInt(parent);
+                }
+            } catch (Exception e) {
+                log.error(
+                        "Error saving " + FILE_CACHE_NAME_ARRAY + ": "
+                                + e.getMessage(), e);
+            } finally {
+                io.close();
+            }
+        }
+
+        /**
+         * Loads the cache info {@link #inSegmentParents} from the file
+         * {@link #FILE_CACHE_NAME_ARRAY}.
+         * 
+         * see https://issues.apache.org/jira/browse/JCR-3107
+         * 
+         * @return true if the cache has been initialized of false if the cache
+         *         file does not exist yet, or an error happened
+         */
+        private boolean loadCacheFromFile() throws IOException {
+            IndexInput ii = null;
+            try {
+                ii = reader.directory().openInput(FILE_CACHE_NAME_ARRAY);
+                for (int i = 0; i < inSegmentParents.length; i++) {
+                    inSegmentParents[i] = ii.readInt();
+                }
+                return true;
+            } catch (FileNotFoundException ignore) {
+                // expected in the case where the file-based cache has not been
+                // initialized yet
+            } catch (IOException ignore) {
+                log.warn(
+                        "Saved state of CachingIndexReader is corrupt, will try to remove offending file "
+                                + FILE_CACHE_NAME_ARRAY, ignore);
+                // In the case where is a read error, the cache file is removed
+                // so it can be recreated after
+                // the cache loads the data from the repository directly
+                reader.directory().deleteFile(FILE_CACHE_NAME_ARRAY);
+            } finally {
+                if (ii != null) {
+                    ii.close();
+                }
+            }
+            return false;
+        }

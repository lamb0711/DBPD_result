JCR-1007: Move common implementations of SPI interfaces to spi-commons module

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@553507 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.spi.QPropertyDefinition;
+import org.apache.jackrabbit.name.NameFormat;
+import org.apache.jackrabbit.name.IllegalNameException;
+import org.apache.jackrabbit.name.UnknownPrefixException;
-import java.util.Arrays;
- * TODO: mostly copied from spi2dav, move common parts to spi-commons.
-class QPropertyDefinitionImpl extends QItemDefinitionImpl implements QPropertyDefinition {
-
-    /**
-     * The required type.
-     */
-    private final int requiredType;
-
-    /**
-     * The value constraints.
-     */
-    private final String[] valueConstraints;
-
-    /**
-     * The default values.
-     */
-    private final QValue[] defaultValues;
-
-    /**
-     * The 'multiple' flag
-     */
-    private final boolean multiple;
+class QPropertyDefinitionImpl
+        extends org.apache.jackrabbit.spi.commons.QPropertyDefinitionImpl {
-                            QValueFactory qValueFactory) throws RepositoryException {
-        super(propDef, nsResolver);
-        Value[] defValues = propDef.getDefaultValues();
-        if (defValues != null) {
-            defaultValues = new QValue[defValues.length];
-            for (int i = 0; i < defValues.length; i++) {
-                defaultValues[i] = ValueFormat.getQValue(defValues[i], nsResolver, qValueFactory);
-            }
-        } else {
-            defaultValues = null;
-        }
-        this.multiple = propDef.isMultiple();
-        this.requiredType = propDef.getRequiredType();
-        this.valueConstraints = propDef.getValueConstraints();
-        if (requiredType == PropertyType.REFERENCE
-                || requiredType == PropertyType.NAME
-                || requiredType == PropertyType.PATH) {
-            for (int i = 0; i < valueConstraints.length; i++) {
-                int type = requiredType == PropertyType.REFERENCE ? PropertyType.NAME : requiredType;
-                this.valueConstraints[i] = ValueFormat.getQValue(
-                        valueConstraints[i], type, nsResolver, qValueFactory).getString();
+                            QValueFactory qValueFactory)
+            throws RepositoryException, IllegalNameException, UnknownPrefixException {
+        super(propDef.getName().equals(ANY_NAME.getLocalName()) ? ANY_NAME : NameFormat.parse(propDef.getName(), nsResolver),
+                NameFormat.parse(propDef.getDeclaringNodeType().getName(), nsResolver),
+                propDef.isAutoCreated(), propDef.isMandatory(),
+                propDef.getOnParentVersion(), propDef.isProtected(),
+                convertValues(propDef.getDefaultValues(), nsResolver, qValueFactory),
+                propDef.isMultiple(), propDef.getRequiredType(),
+                convertConstraints(propDef.getValueConstraints(), nsResolver, qValueFactory, propDef.getRequiredType()));
+    }
+
+    /**
+     * Convers JCR {@link Value}s to {@link QValue}s.
+     *
+     * @param values     the JCR values.
+     * @param nsResolver the namespace resolver.
+     * @param factory    the QValue factory.
+     * @return the converted values.
+     * @throws RepositoryException if an error occurs while converting the
+     *                             values.
+     */
+    private static QValue[] convertValues(Value[] values,
+                                          NamespaceResolver nsResolver,
+                                          QValueFactory factory)
+            throws RepositoryException {
+        QValue[] defaultValues = null;
+        if (values != null) {
+            defaultValues = new QValue[values.length];
+            for (int i = 0; i < values.length; i++) {
+                defaultValues[i] = ValueFormat.getQValue(values[i], nsResolver, factory);
-    }
-
-    //------------------------------------------------< QPropertyDefinition >---
-    /**
-     * {@inheritDoc}
-     */
-    public int getRequiredType() {
-        return requiredType;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public String[] getValueConstraints() {
-        return valueConstraints;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public QValue[] getDefaultValues() {
-     * {@inheritDoc}
-     */
-    public boolean isMultiple() {
-        return multiple;
-    }
-
-    /**
-     * {@inheritDoc}
+     * Makes sure name and path constraints are parsed correctly using the
+     * namespace resolver.
-     * @return always <code>false</code>
+     * @param constraints  the constraint strings from the JCR property
+     *                     definition.
+     * @param nsResolver   the namespace resolver.
+     * @param factory      the QValueFactory.
+     * @param requiredType the required type of the property definition.
+     * @return SPI formatted constraint strings.
+     * @throws RepositoryException if an error occurs while converting the
+     *                             constraint strings.
-    public boolean definesNode() {
-        return false;
-    }
-
-    //-------------------------------------------< java.lang.Object overrides >
-    /**
-     * Compares two property definitions for equality. Returns <code>true</code>
-     * if the given object is a property defintion and has the same attributes
-     * as this property definition.
-     *
-     * @param obj the object to compare this property definition with
-     * @return <code>true</code> if the object is equal to this property definition,
-     *         <code>false</code> otherwise
-     * @see Object#equals(Object)
-     */
-    public boolean equals(Object obj) {
-        if (this == obj) {
-            return true;
-        }
-        if (obj instanceof QPropertyDefinition) {
-            QPropertyDefinition other = (QPropertyDefinition) obj;
-            return super.equals(obj)
-                    && requiredType == other.getRequiredType()
-                    && Arrays.equals(valueConstraints, other.getValueConstraints())
-                    && Arrays.equals(defaultValues, other.getDefaultValues())
-                    && multiple == other.isMultiple();
-        }
-        return false;
-    }
-
-    /**
-     * Overwrites {@link QItemDefinitionImpl#hashCode()}.
-     *
-     * @return
-     */
-    public int hashCode() {
-        if (hashCode == 0) {
-            // build hashCode (format: <declaringNodeType>/<name>/<requiredType>/<multiple>)
-            StringBuffer sb = new StringBuffer();
-
-            sb.append(getDeclaringNodeType().toString());
-            sb.append('/');
-            if (definesResidual()) {
-                sb.append('*');
-            } else {
-                sb.append(getQName().toString());
+    private static String[] convertConstraints(String[] constraints,
+                                               NamespaceResolver nsResolver,
+                                               QValueFactory factory, 
+                                               int requiredType)
+            throws RepositoryException {
+        if (requiredType == PropertyType.REFERENCE
+                || requiredType == PropertyType.NAME
+                || requiredType == PropertyType.PATH) {
+            int type = requiredType == PropertyType.REFERENCE ? PropertyType.NAME : requiredType;
+            for (int i = 0; i < constraints.length; i++) {
+                constraints[i] = ValueFormat.getQValue(
+                        constraints[i], type, nsResolver, factory).getString();
-            sb.append('/');
-            sb.append(getRequiredType());
-            sb.append('/');
-            sb.append(isMultiple() ? 1 : 0);
-
-            hashCode = sb.toString().hashCode();
-        return hashCode;
+        return constraints;

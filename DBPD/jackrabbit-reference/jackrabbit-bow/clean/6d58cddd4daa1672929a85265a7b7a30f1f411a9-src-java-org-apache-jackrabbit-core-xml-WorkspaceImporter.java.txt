JCR-61: Docview import fails, if attribute and childelem have same name

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@190588 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.state.ItemState;
-        this.importTarget = itemOps.getNodeState(parentPath);
+        importTarget = itemOps.getNodeState(parentPath);
+                    if (parent.hasPropertyEntry(nodeName)) {
+                        /**
+                         * a property with the same name already exists; if this property
+                         * has been imported as well (e.g. through document view import
+                         * where an element can have the same name as one of the attributes
+                         * of its parent element) we have to rename the onflicting property;
+                         *
+                         * see http://issues.apache.org/jira/browse/JCR-61
+                         */
+                        PropertyId propId = new PropertyId(parent.getUUID(), nodeName);
+                        PropertyState conflicting = itemOps.getPropertyState(propId);
+                        if (conflicting.getStatus() == ItemState.STATUS_NEW) {
+                            // assume this property has been imported as well;
+                            // rename conflicting property
+                            // @todo use better reversible escaping scheme to create unique name
+                            QName newName = new QName(nodeName.getNamespaceURI(), nodeName.getLocalName() + "_");
+                            if (parent.hasPropertyEntry(newName)) {
+                                newName = new QName(newName.getNamespaceURI(), newName.getLocalName() + "_");
+                            }
+                            PropertyState newProp =
+                                    itemOps.createPropertyState(parent, newName,
+                                            conflicting.getType(), conflicting.getValues().length);
+                            newProp.setValues(conflicting.getValues());
+                            parent.removePropertyEntry(nodeName);
+                            itemOps.store(parent);
+                            itemOps.destroy(conflicting);
+                        }
+                    }
+

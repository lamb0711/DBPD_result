- Remove AtticItemStateManager (not needed anymore)
- Remove dispose methods from TransientItemStateManager. TransientItemStateManager is a listener on all modified ItemStates and maintains its ChangeLog according to the callbacks.
- Move method SessionItemStateManager.checkIsSelfContained() to ChangeLog.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@433610 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.commons.collections.iterators.IteratorChain;
+import java.util.HashSet;
+    /**
+     * Make sure that this ChangeLog is totally 'self-contained'
+     * and independant; items within the scope of this update operation
+     * must not have 'external' dependencies;
+     * (e.g. moving a node requires that the target node including both
+     * old and new parents are saved)
+     */
+    public void checkIsSelfContained()
+            throws ItemStateException {
+        Set affectedStates = new HashSet();
+        affectedStates.addAll(modifiedStates);
+        affectedStates.addAll(deletedStates);
+        Iterator it = new IteratorChain(modifiedStates(), deletedStates());
+        while (it.hasNext()) {
+            ItemState transientState = (ItemState) it.next();
+            if (transientState.isNode()) {
+                NodeState nodeState = (NodeState) transientState;
+                Set dependentStates = new HashSet();
+                if (nodeState.hasOverlayedState()) {
+                    // TODO: oldParentState is overlayed state from workspace. do not use!
+                    NodeState oldParentState = nodeState.getOverlayedState().getParent();
+                    NodeState newParentState = nodeState.getParent();
+                    if (oldParentState != null) {
+                        if (newParentState == null) {
+                            // node has been removed, add old parent
+                            // to dependencies
+                            dependentStates.add(oldParentState);
+                        } else {
+                            if (!oldParentState.equals(newParentState)) {
+                                // node has been moved, add old and new parent
+                                // to dependencies
+                                dependentStates.add(oldParentState);
+                                dependentStates.add(newParentState);
+                            }
+                        }
+                    }
+                }
+                // removed child node entries
+                Iterator cneIt = nodeState.getRemovedChildNodeEntries().iterator();
+                while (cneIt.hasNext()) {
+                    ChildNodeEntry cne = (ChildNodeEntry) cneIt.next();
+                    dependentStates.add(cne.getNodeState());
+                }
+                // added child node entries
+                cneIt = nodeState.getAddedChildNodeEntries().iterator();
+                while (cneIt.hasNext()) {
+                    ChildNodeEntry cne = (ChildNodeEntry) cneIt.next();
+                    dependentStates.add(cne.getNodeState());
+                }
+
+                // now walk through dependencies and check whether they
+                // are within the scope of this save operation
+                Iterator depIt = dependentStates.iterator();
+                while (depIt.hasNext()) {
+                    NodeState dependantState = (NodeState) depIt.next();
+                    if (!affectedStates.contains(dependantState)) {
+                        // need to save the parent as well
+                        String msg = dependantState.getNodeId().toString() + " needs to be saved as well.";
+                        throw new ItemStateException(msg);
+                    }
+                }
+            }
+        }
+    }
+

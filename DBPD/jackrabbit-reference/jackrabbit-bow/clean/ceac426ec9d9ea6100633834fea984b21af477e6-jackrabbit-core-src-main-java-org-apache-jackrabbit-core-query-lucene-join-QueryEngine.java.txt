JCR-2715: Improved join query performance

Map single-selector queries to the more efficient SQL1 query engine.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1023748 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Iterator;
+import javax.jcr.PropertyType;
+import javax.jcr.query.Query;
+import javax.jcr.query.QueryManager;
-import org.apache.jackrabbit.commons.flat.TreeTraverser;
+    private String toSqlConstraint(Constraint constraint)
+            throws RepositoryException {
+        if (constraint instanceof And) {
+            And and = (And) constraint;
+            String c1 = toSqlConstraint(and.getConstraint1());
+            String c2 = toSqlConstraint(and.getConstraint2());
+            return "(" + c1 + ") AND (" + c2 + ")";
+        } else if (constraint instanceof Or) {
+            Or or = (Or) constraint;
+            String c1 = toSqlConstraint(or.getConstraint1());
+            String c2 = toSqlConstraint(or.getConstraint2());
+            return "(" + c1 + ") OR (" + c2 + ")";
+        } else if (constraint instanceof Not) {
+            Not or = (Not) constraint;
+            return "NOT (" + toSqlConstraint(or.getConstraint()) + ")";
+        } else if (constraint instanceof Comparison) {
+            Comparison c = (Comparison) constraint;
+            String left = toSqlOperand(c.getOperand1());
+            String right = toSqlOperand(c.getOperand2());
+            if (c.getOperator().equals(JCR_OPERATOR_EQUAL_TO)) {
+                return left + " = " + right;
+            } else {
+                throw new RepositoryException("Unsupported comparison: " + c);
+            }
+        } else if (constraint instanceof ChildNode) {
+            ChildNode cn = (ChildNode) constraint;
+            return "jcr:path LIKE '" + cn.getParentPath() + "/%'";
+        } else  {
+            throw new RepositoryException("Unsupported constraint: " + constraint);
+        }
+    }
+
+    private String toSqlOperand(Operand operand) throws RepositoryException {
+        if (operand instanceof PropertyValue) {
+            PropertyValue pv = (PropertyValue) operand;
+            return pv.getPropertyName();
+        } else if (operand instanceof Literal) {
+            Literal literal = (Literal) operand;
+            Value value = literal.getLiteralValue();
+            int type = value.getType();
+            if (type == PropertyType.LONG || type == PropertyType.DOUBLE) {
+                return value.getString();
+            } else {
+                return "'" + value.getString() + "'";
+            }
+        } else {
+            throw new RepositoryException("Uknown operand type: " + operand);
+        }
+    }
+
+        StringBuilder builder = new StringBuilder();
+        builder.append("SELECT * FROM ");
+        builder.append(selector.getNodeTypeName());
+        if (constraint != null) {
+            builder.append(" WHERE ");
+            builder.append(toSqlConstraint(constraint));
+        }
+        System.out.println(builder.toString());
+
+        QueryManager manager = session.getWorkspace().getQueryManager();
+        Query query = manager.createQuery(builder.toString(), Query.SQL);
+
-        Iterator<Node> nodes =
-            TreeTraverser.nodeIterator(session.getRootNode());
-        RangeIterator rows = new RangeIteratorAdapter(nodes) {
+//        Iterator<Node> nodes =
+//            TreeTraverser.nodeIterator(session.getRootNode());
+        RangeIterator rows = new RangeIteratorAdapter(query.execute().getNodes()) {
-        RangeIterator filtered = new FilteredRangeIterator(
-                rows, getPredicate(selector, constraint));
+//        RangeIterator filtered = new FilteredRangeIterator(
+//                rows, getPredicate(selector, constraint));
-                columnNames, selectorNames, new RowIteratorAdapter(filtered));
+                columnNames, selectorNames, new RowIteratorAdapter(rows));

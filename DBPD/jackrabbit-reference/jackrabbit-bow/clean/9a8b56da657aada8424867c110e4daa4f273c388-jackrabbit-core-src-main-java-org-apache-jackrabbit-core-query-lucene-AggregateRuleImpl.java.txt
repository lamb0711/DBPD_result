JCR-2989 Support for embedded index aggregates

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1182367 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.spi.Path;
-import org.apache.jackrabbit.spi.Name;
-import org.apache.jackrabbit.spi.commons.name.NameConstants;
-import org.apache.jackrabbit.spi.commons.name.PathBuilder;
-import org.apache.jackrabbit.spi.commons.conversion.IllegalNameException;
-import org.apache.jackrabbit.spi.commons.conversion.MalformedPathException;
-import org.apache.jackrabbit.spi.commons.conversion.NameResolver;
-import org.apache.jackrabbit.core.state.NodeState;
-import org.apache.jackrabbit.core.state.ItemStateManager;
-import org.apache.jackrabbit.core.state.ItemStateException;
-import org.apache.jackrabbit.core.state.ChildNodeEntry;
-import org.apache.jackrabbit.core.state.PropertyState;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import javax.jcr.NamespaceException;
+import javax.jcr.RepositoryException;
+
+import org.apache.jackrabbit.core.state.ChildNodeEntry;
+import org.apache.jackrabbit.core.state.ItemStateException;
+import org.apache.jackrabbit.core.state.ItemStateManager;
+import org.apache.jackrabbit.core.state.NodeState;
+import org.apache.jackrabbit.core.state.PropertyState;
+import org.apache.jackrabbit.spi.Name;
+import org.apache.jackrabbit.spi.Path;
+import org.apache.jackrabbit.spi.commons.conversion.IllegalNameException;
+import org.apache.jackrabbit.spi.commons.conversion.MalformedPathException;
+import org.apache.jackrabbit.spi.commons.conversion.NameResolver;
+import org.apache.jackrabbit.spi.commons.name.NameConstants;
+import org.apache.jackrabbit.spi.commons.name.PathBuilder;
+import org.w3c.dom.CharacterData;
-import org.w3c.dom.CharacterData;
-
-import javax.jcr.RepositoryException;
-import javax.jcr.NamespaceException;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Arrays;
+     * recursive aggregation (for same type nodes) default value.
+     */
+    private static final boolean RECURSIVE_AGGREGATION_DEFAULT = false;
+
+    /**
+     * flag to enable recursive aggregation (for same type nodes).
+     */
+    private final boolean recursiveAggregation;
+
+    /**
+     * recursive aggregation (for same type nodes) limit default value.
+     */
+
+    protected static final long RECURSIVE_AGGREGATION_LIMIT_DEFAULT = 100;
+
+    /**
+     * recursive aggregation (for same type nodes) limit. embedded aggregation
+     * of nodes that have the same type can go only this levels up.
+     * 
+     * A value eq to 0 gives unlimited aggregation.
+     */
+    private final long recursiveAggregationLimit;
+
+    /**
+        this.recursiveAggregation = getRecursiveAggregation(config);
+        this.recursiveAggregationLimit = getRecursiveAggregationLimit(config);
-                return aggregateRoot;
+                boolean sameNodeTypeAsRoot = nodeState.getNodeTypeName().equals(aggregateRoot.getNodeTypeName());
+                if(!sameNodeTypeAsRoot || (sameNodeTypeAsRoot && recursiveAggregation)){
+                    return aggregateRoot;
+                }
+        
-                return aggregateRoot;
+                boolean sameNodeTypeAsRoot = nodeState.getNodeTypeName().equals(aggregateRoot.getNodeTypeName());
+                if(!sameNodeTypeAsRoot || (sameNodeTypeAsRoot && recursiveAggregation)){
+                    return aggregateRoot;
+                }
-                nodeStates.addAll(Arrays.asList(nodeInclude.resolve(nodeState)));
+                for (NodeState childNs : nodeInclude.resolve(nodeState)) {
+                    boolean sameNodeTypeAsRoot = nodeState.getNodeTypeName().equals(childNs.getNodeTypeName());
+                    if (!sameNodeTypeAsRoot || (sameNodeTypeAsRoot && recursiveAggregation)) {
+                        nodeStates.add(childNs);
+                    }
+                }
+    /**
+     * {@inheritDoc}
+     */
+    public long getRecursiveAggregationLimit() {
+        return recursiveAggregationLimit;
+    }
+
+    
+    private boolean getRecursiveAggregation(Node config) {
+        Node rAttr = config.getAttributes().getNamedItem("recursive");
+        if (rAttr == null) {
+            return RECURSIVE_AGGREGATION_DEFAULT;
+        }
+        return Boolean.valueOf(rAttr.getNodeValue());
+    }
+    private long getRecursiveAggregationLimit(Node config)
+            throws RepositoryException {
+        Node rAttr = config.getAttributes().getNamedItem("recursiveLimit");
+        if (rAttr == null) {
+            return RECURSIVE_AGGREGATION_LIMIT_DEFAULT;
+        }
+        try {
+            return Long.valueOf(rAttr.getNodeValue());
+        } catch (NumberFormatException e) {
+            throw new RepositoryException(
+                    "Unable to read indexing configuration (recursiveLimit).",
+                    e);
+        }
+    }
+    

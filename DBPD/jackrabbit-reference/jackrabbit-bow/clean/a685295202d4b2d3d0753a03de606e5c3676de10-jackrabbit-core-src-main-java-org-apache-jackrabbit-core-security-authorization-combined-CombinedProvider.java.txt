security: work in progress

- change ACEditor to take jcr path
- extract common, abstract policy entry impl
- add more tests
- add JackrabbitAccessControlManager for policy editing
- various minor changes, fixes, improvements

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@644215 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.security.authorization.GlobPattern;
-import org.apache.jackrabbit.core.security.authorization.acl.ACLEditor;
+import org.apache.jackrabbit.core.security.authorization.Permission;
+import org.apache.jackrabbit.core.security.authorization.PolicyEntry;
+import org.apache.jackrabbit.core.security.authorization.PolicyTemplate;
-import org.apache.commons.collections.map.ListOrderedMap;
+import javax.jcr.Item;
-import javax.jcr.observation.ObservationManager;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Arrays;
-    private SessionImpl session;
-    private ObservationManager obsMgr;
-
-    protected CombinedProvider() {
+    private String policyName;
+
+    public CombinedProvider() {
-        if (initialized) {
-            throw new IllegalStateException("already initialized");
-        }
-        if (!(systemSession instanceof SessionImpl)) {
-            throw new RepositoryException("SessionImpl (system session) expected.");
-        }
-        session = (SessionImpl) systemSession;
-        obsMgr = session.getWorkspace().getObservationManager();
+        super.init(systemSession, options);
-        String rootPath = acRoot.getPath();
-        editor = new CombinedEditor(session, session.getNamePathResolver(),
-                session.getQPath(rootPath));
+        NodeImpl root = (NodeImpl) session.getRootNode();
+        if (root.hasNode(N_ACCESSCONTROL)) {
+            acRoot = root.getNode(N_ACCESSCONTROL);
+            if (!acRoot.isNodeType(NT_REP_ACCESS_CONTROL)) {
+                throw new RepositoryException("Error while initializing Access Control Provider: Found ac-root to be wrong node type " + acRoot.getPrimaryNodeType().getName());
+            }
+        } else {
+            acRoot = root.addNode(N_ACCESSCONTROL, NT_REP_ACCESS_CONTROL, null);
+        }
+
+        policyName = session.getJCRName(AccessControlConstants.N_POLICY);
+
+        editor = new CombinedEditor(session, resolver, resolver.getQPath(acRoot.getPath()));
-            PolicyTemplateImpl pt = editor.editPolicyTemplate(administrators);
-            pt.setEntry(new PolicyEntryImpl(administrators, PrivilegeRegistry.ALL, true, rootPath, glob));
-            editor.setPolicyTemplate(pt.getNodeId(), pt);
+            PolicyTemplate pt = editor.editPolicyTemplate(administrators);
+            pt.setEntry(new PolicyEntryImpl(administrators, PrivilegeRegistry.ALL, true, root.getPath(), glob));
+            editor.setPolicyTemplate(pt.getPath(), pt);
-            // TODO: to be improved. how to define where everyone has read-access
-            pt.setEntry(new PolicyEntryImpl(everyone, PrivilegeRegistry.READ, true, rootPath, glob));
-            editor.setPolicyTemplate(pt.getNodeId(), pt);
+            pt.setEntry(new PolicyEntryImpl(everyone, PrivilegeRegistry.READ, true, root.getPath(), glob));
+            editor.setPolicyTemplate(pt.getPath(), pt);
-
-
-        NodeImpl root = (NodeImpl) session.getRootNode();
-        if (root.hasNode(N_ACCESSCONTROL)) {
-            // TODO: make sure its a node with the correct nodetype
-            acRoot = root.getNode(N_ACCESSCONTROL);
-            if (!acRoot.isNodeType(NT_REP_ACCESS_CONTROL)) {
-                throw new RepositoryException("Error while initializing Access Control Provider: Found ac-root to be wrong node type " + acRoot.getPrimaryNodeType().getName());
-            }
-        } else {
-            acRoot = root.addNode(N_ACCESSCONTROL, NT_REP_ACCESS_CONTROL, null);
-        }
-        initialized = true;
-        log.debug("Unable to createFromNode " + CombinedEditor.class.getName() + ".");
+        log.debug("Unable to build access control editor " + CombinedEditor.class.getName() + ".");
-            // TODO: include the resource-based ACLs!
+            // TODO: TOBEFIXED include the resource-based ACLs!
-    //----------------------------------------< private | package protected >---
-    /**
-     * Test if the given path points to a Node (or an existing or non existing
-     * direct decendant of an existing Node) that stores AC-information
-     *
-     * @param path
-     * @return
-     * @throws RepositoryException
-     */
-    private boolean isAccessControlItem(Path path) throws ItemNotFoundException, RepositoryException {
-        NodeImpl node;
-        String absPath = session.getJCRPath(path);
-        if (session.nodeExists(absPath)) {
-            node = (NodeImpl) session.getNode(absPath);
-        } else {
-            // path points to existing prop or non-existing item (node or prop).
-            String parentPath = Text.getRelativeParent(absPath, 1);
-            if (session.nodeExists(parentPath)) {
-                node = (NodeImpl) session.getNode(parentPath);
-            } else {
-                throw new ItemNotFoundException("No item exists at " + absPath + " nor at its direct ancestor.");
-            }
-        }
-        return node.isNodeType(ACLEditor.NT_REP_ACL) || node.isNodeType(ACLEditor.NT_REP_ACE);
-    }
-
-    /**
-     *
-     * @param principals
-     * @return
-     * @throws RepositoryException
-     */
-    private ACLImpl getACL(Set principals) throws RepositoryException {
-        // acNodes must be ordered in the same order as the principals
-        // in order to obtain proper acl-evalution in case the given
-        // principal-set is ordered.
-        Map princToACEs = new ListOrderedMap();
-        Set acPaths = new HashSet();
-        // build acl-hierarchy assuming that principal-order determines the
-        // acl-inheritance.
-        for (Iterator it = principals.iterator(); it.hasNext();) {
-            Principal princ = (Principal) it.next();
-            PolicyTemplateImpl at = editor.getPolicyTemplate(princ);
-            if (at == null) {
-                log.debug("No matching ACL node found for principal " + princ.getName() + " -> principal ignored.");
-            } else {
-                // retrieve the ACEs from the node
-                PolicyEntryImpl[] aces = (PolicyEntryImpl[]) at.getEntries();
-                princToACEs.put(princ, aces);
-
-                Path p = session.getHierarchyManager().getPath(at.getNodeId());
-                acPaths.add(session.getJCRPath(p));
-            }
-        }
-        return new ACLImpl(princToACEs, acPaths);
-    }
-
-        private ACLImpl acl;
+        private final Set acPaths;
+        private Entries entries;
-            acl = getACL(principals);
+            acPaths = new HashSet(principals.size());
+            entries = reload();
-            // TODO: rather on CombinedProvider? -> but must keep references to the CompiledPermission then....?
-            obsMgr.addEventListener(this, events, acRoot.getPath(), true, null, ntNames, true);
+            observationMgr.addEventListener(this, events, acRoot.getPath(), true, null, ntNames, false);
-        protected Result buildResult(Path absPath) throws RepositoryException {
+        protected synchronized Result buildResult(Path absPath) throws RepositoryException {
-            boolean isAclItem = isAccessControlItem(absPath);
-            
+            boolean isAclItem = false;
+            /* Test if the given path points to a Node (or an existing or non
+             * existing direct decendant of an existing Node) that stores
+             * AC-information
+             */
+            String[] segments = Text.explode(jcrPath, '/', false);
+            if (segments.length > 0) {
+                for (int i = segments.length - 1; i >= 0 && !isAclItem; i--) {
+                    isAclItem = policyName.equals(segments[i]);
+                }
+            }
+
-                permissions = acl.getPermissions(session.getItem(jcrPath), isAclItem);
+                permissions = entries.getPermissions(session.getItem(jcrPath), isAclItem);
-                Node parent = session.getNode(Text.getRelativeParent(jcrPath, 1));
-                String name = session.getJCRName(absPath.getNameElement().getName());
-                permissions = acl.getPermissions(parent, name, isAclItem);
+                Node parent = null;
+                String parentPath = jcrPath;
+                while (parent == null) {
+                    parentPath = Text.getRelativeParent(parentPath, 1);
+                    if (parentPath.length() == 0) {
+                        // root node reached
+                        parent = session.getRootNode();
+                    } else if (session.nodeExists(parentPath)) {
+                        parent = session.getNode(parentPath);
+                    }
+                }
+                String relPath = jcrPath.substring(parent.getPath().length() + 1);
+                permissions = entries.getPermissions(parent, relPath, isAclItem);
-            /* privileges can only be determined for existing nodes.
-               not for properties and neither for non-existing nodes. */
-            int privileges = (session.nodeExists(jcrPath)) ? acl.getPrivileges(jcrPath) : PrivilegeRegistry.NO_PRIVILEGE;
+            /* TODO: privileges can only be determined for nodes. */
+            int privileges = entries.getPrivileges(jcrPath);
-                obsMgr.removeEventListener(this);
+                observationMgr.removeEventListener(this);
-        public void onEvent(EventIterator events) {
-            Set acPaths = acl.getAcPaths();
+        public synchronized void onEvent(EventIterator events) {
-
-
-                    // reload the acl
-                    acl = getACL(principals);
+                    // reload the acl
+                    entries = reload();
+
+        /**
+         *
+         * @return
+         * @throws RepositoryException
+         */
+        private Entries reload() throws RepositoryException {
+            // reload the paths
+            acPaths.clear();
+
+            // acNodes must be ordered in the same order as the principals
+            // in order to obtain proper acl-evalution in case the given
+            // principal-set is ordered.
+            List allACEs = new ArrayList();
+            // build acl-hierarchy assuming that principal-order determines the
+            // acl-inheritance.
+            for (Iterator it = principals.iterator(); it.hasNext();) {
+                Principal princ = (Principal) it.next();
+                PolicyTemplate at = editor.getPolicyTemplate(princ);
+                if (at == null || at.isEmpty()) {
+                    log.debug("No matching ACL node found for principal " + princ.getName() + " -> principal ignored.");
+                } else {
+                    // retrieve the ACEs from the node
+                    PolicyEntry[] aces = (PolicyEntry[]) at.getEntries();
+                    allACEs.addAll(Arrays.asList(aces));
+                    acPaths.add(at.getPath());
+                }
+            }
+            return new Entries(allACEs);
+        }
+    }
+
+    //--------------------------------------------------------------------------
+
+    private static class Entries {
+
+        private final List entries;
+
+        private Entries(List entries) {
+            this.entries = entries;
+        }
+
+        /**
+         * Loop over all entries and evaluate allows/denies for those matching
+         * the given jcrPath.
+         *
+         * @param target Existing target item for which the permissions will be
+         * evaluated.
+         * @param protectsACL
+         * @return
+         * @throws RepositoryException
+         */
+        private int getPermissions(Item target, boolean protectsACL) throws RepositoryException {
+            int allows = 0;
+            int denies = 0;
+            for (Iterator it = entries.iterator(); it.hasNext() && allows != Permission.ALL;) {
+                PolicyEntryImpl entr = (PolicyEntryImpl) it.next();
+                if (entr.matches(target)) {
+                    int privs = entr.getPrivilegeBits();
+                    int permissions = Permission.calculatePermissions(privs, privs, protectsACL);
+                    if (entr.isAllow()) {
+                        allows |= Permission.diff(permissions, denies);
+                    } else {
+                        denies |= Permission.diff(permissions, allows);
+                    }
+                }
+            }
+            return allows;
+        }
+
+        /**
+         * loop over all entries and evaluate allows/denies for those matching
+         * the given jcrPath.
+         *
+         * @param parent Existing parent of the target to be evaluated.
+         * @param relPath relative path to a non-existing child item to calculate the
+         * permissions for.
+         * @param protectsACL
+         * @return
+         * @throws RepositoryException
+         */
+        private int getPermissions(Node parent, String relPath, boolean protectsACL) throws RepositoryException {
+            int allows = 0;
+            int denies = 0;
+            String jcrPath = parent.getPath() + "/" + relPath;
+
+            for (Iterator it = entries.iterator(); it.hasNext() && allows != Permission.ALL;) {
+                PolicyEntryImpl entr = (PolicyEntryImpl) it.next();
+                if (entr.matches(jcrPath)) {
+                    int privs = entr.getPrivilegeBits();
+                    int permissions = Permission.calculatePermissions(privs, privs, protectsACL);
+                    if (entr.isAllow()) {
+                        allows |= Permission.diff(permissions, denies);
+                    } else {
+                        denies |= Permission.diff(permissions, allows);
+                    }
+                }
+            }
+            return allows;
+        }
+
+        private int getPrivileges(String nodePath) throws RepositoryException {
+            // TODO: improve. avoid duplicate evaluation...            
+            int allows = 0;
+            int denies = 0;
+            for (Iterator it = entries.iterator(); it.hasNext() && allows != Permission.ALL;) {
+                PolicyEntryImpl entr = (PolicyEntryImpl) it.next();
+                // loop over all entries and evaluate allows/denies for those
+                // matching the given jcrPath
+                // TODO: check again which ACEs must be respected.
+                // TODO: maybe ancestor-defs only if glob = *?
+                String np = entr.getNodePath();
+                // TODO: TOBEFIXED Text.isDescendant that returns false if np==root-path
+                if (np.equals(nodePath) || "/".equals(np) || Text.isDescendant(np, nodePath)) {
+                    if (entr.isAllow()) {
+                        allows |= PrivilegeRegistry.diff(entr.getPrivilegeBits(), denies);
+                    } else {
+                        denies |= PrivilegeRegistry.diff(entr.getPrivilegeBits(), allows);
+                    }
+                }
+            }
+            return allows;
+        }

work in progress.

- nodestates must always be connected to their cne upon creation
  TODO: add some sort of caching to avoid traffic overhead
- add TODO for refresh, that currently doesn't work properly
- ItemState.refresh only takes changelog and returns the ids of the
  processed states. cleanup of events is left to caller.
- move of NodeStates does not work
- PathResolver: force start to be an NodeState
- all MODIFIED status for SessionStates as well in order to make sure
  that listeners are informed about external changes even if the 
  state is EXISTING.

next TODO: make sure, that public getChildNodeEntry/ies and hasChildNodeEntry check for validity of the connected NodeState. don't return entries, where the nodestate is (transiently) removed or stale.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@472818 13f79535-47bb-0310-9956-ffa450edef68

-     * <code>nodeState</code>.
+     * <code>nodeState</code>. Note, that this method does not check if the
+     * given childNodeEntry (and its attached NodeState) is still valid.
-     * @param nodeState the node state.
+     * @param childState the child node state for which a entry is searched.
-     *         is no <code>ChildNodeEntry</code> for <code>nodeState</code>.
+     * is no <code>ChildNodeEntry</code> for the given <code>NodeState</code>.
-    ChildNodeEntry get(NodeState nodeState) {
-        Object o = nameMap.get(nodeState.getQName());
+    ChildNodeEntry get(NodeState childState) {
+        Object o = nameMap.get(childState.getQName());
-                    if (cne.isAvailable() && cne.getNodeState() == nodeState) {
+                    if (cne.isAvailable() && cne.getNodeState() == childState) {
-                if (cne.isAvailable() && cne.getNodeState() == nodeState) {
+                if (cne.isAvailable() && cne.getNodeState() == childState) {
-                    // before and is assumed valid
+                    // before and is assumed valid // TODO: check if correct.
-        List l = get(nodeName);
-        for (Iterator it = l.iterator(); it.hasNext();) {
-            ChildNodeEntry cne = (ChildNodeEntry) it.next();
+        Iterator cneIter = (nodeName != null) ? get(nodeName).iterator() : iterator();
+        while (cneIter.hasNext()) {
+            ChildNodeEntry cne = (ChildNodeEntry) cneIter.next();
-     * @param nodeName the name of the child node.
-     * @param uuid     the UUID of the child node if it can be identified
-     *                 with a UUID; otherwise <code>null</code>.
+     * @param nodeName The name of the child node.
+     * @param uuid The UUID of the child node if it can be identified with a UUID;
+     * otherwise <code>null</code>.
-    void reorder(NodeState insertNode, NodeState beforeNode)
-        throws NoSuchItemStateException {
+    void reorder(NodeState insertNode, NodeState beforeNode) throws NoSuchItemStateException {
-            log.error("Internal error.", e);
+            // should never occur.
+            log.error("Internal Error: ", e);
-     * <code>LinkNode</code>.
+     * <code>LinkNode</code>. Note, that in contrast to {@link #getLinkNode(ChildNodeEntry)}
+     * this method will throw <code>NoSuchItemStateException</code> if none of the
+     * entries matches either due to missing entry for given state name or due
+     * to missing availability of the <code>ChildNodeEntry</code>.
-     * @param nodeState      the <code>NodeState</code> which is the value
-     *                       of on of the <code>LinkNode</code>s.
+     * @param nodeState the <code>NodeState</code> that is compared to the
+     * resolution of any ChildNodeEntry that matches by name.
-     *                                  matches.
+     * matches.
-        
+
-    //---------------------------------------< unmodifiable Collection view >---
-
+    //--------------------------------------------< unmodifiable Collection >---
+    /**
+     * @see Collection#contains(Object)
+     */
+    /**
+     * @see Collection#containsAll(Collection)
+     */
+    /**
+     * @see Collection#isEmpty()
+     */
+    /**
+     * @see Collection#iterator()
+     */
+    /**
+     * @see Collection#size()
+     */
+    /**
+     * @see Collection#toArray()
+     */
+    /**
+     * @see Collection#toArray(Object[])
+     */
+    /**
+     * Throws <code>UnsupportedOperationException</code>.
+     *
+     * @see Collection#add(Object)
+     */
+    /**
+     * Throws <code>UnsupportedOperationException</code>.
+     *
+     * @see Collection#addAll(Collection)
+     */
+    /**
+     * Throws <code>UnsupportedOperationException</code>.
+     *
+     * @see Collection#clear()
+     */
+    /**
+     * Throws <code>UnsupportedOperationException</code>.
+     *
+     * @see Collection#remove(Object)
+     */
+    /**
+     * Throws <code>UnsupportedOperationException</code>.
+     *
+     * @see Collection#removeAll(Collection)
+     */
+    /**
+     * Throws <code>UnsupportedOperationException</code>.
+     *
+     * @see Collection#retainAll(Collection)
+     */
-
+    //-------------------------------------------------< AbstractLinkedList >---
+         * @see AbstractLinkedList#createNode(Object)
+         * @see AbstractLinkedList#createHeaderNode()
-        //-----------------------------------------------------------------------
+        //----------------------------------------------------------------------

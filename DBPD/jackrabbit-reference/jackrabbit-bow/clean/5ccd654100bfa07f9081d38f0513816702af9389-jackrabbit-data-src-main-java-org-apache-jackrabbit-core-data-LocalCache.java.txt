JCR-3815: Local Cache Purge Cause Performance Issues
Applying patch from Shashank Gupta.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1632481 13f79535-47bb-0310-9956-ffa450edef68

-                LOG.debug("file [{}] added to local cache.", fileName);
+                LOG.debug(
+                    "file [{}] doesn't exists. adding to local cache using inputstream.",
+                    fileName);
+                LOG.debug(
+                    "file [{}] doesn't exists. returning transient file [{}].",
+                    fileName, transFile.getAbsolutePath());
-            // f.exists and not in purge mode
+            LOG.debug(
+                "file [{}]  exists. adding to local cache using inputstream.",
+                fileName);
-        cache.tryPurge();
+        tryPurge();
-    public AsyncUploadCacheResult store(String fileName, File src, boolean tryForAsyncUpload) throws IOException {
+    public AsyncUploadCacheResult store(String fileName, File src,
+            boolean tryForAsyncUpload) throws IOException {
-            || (src.exists() && !dest.exists() && !src.equals(dest) && canAdmitFile(src.length())
+            || (src.exists() && !dest.exists() && !src.equals(dest)
+                && canAdmitFile(src.length())
+            LOG.debug("file [{}]  exists= [{}] and adding to local cache.",
+                fileName, destExists);
-            LOG.debug("file [{}] added to local cache.", fileName);
+        } else {
+            LOG.info("file [{}] exists= [{}] not added to local cache.",
+                fileName, destExists);
-        cache.tryPurge();
+        tryPurge();
-            cache.put(fileName, f.length());
+            cache.get(fileName);
-        for (String n : new ArrayList<String>(toBeDeleted)) {
-            if (tryDelete(n)) {
+        for (String fileName : new ArrayList<String>(toBeDeleted)) {
+            fileName = fileName.replace("\\", "/");
+            if( cache.remove(fileName) != null) {
+    
+    /**
+     * This method tries purging of local cache. It checks if local cache
+     * has exceeded the defined limit then it triggers purge cache job in a
+     * seperate thread.
+     */
+    synchronized void tryPurge() {
+        if (!isInPurgeMode()
+            && cache.currentSizeInBytes > cache.cachePurgeTrigSize) {
+            setPurgeMode(true);
+            LOG.info(
+                "cache.entries = [{}], currentSizeInBytes=[{}]  exceeds cachePurgeTrigSize=[{}]",
+                new Object[] { cache.size(), cache.currentSizeInBytes,
+                    cache.cachePurgeTrigSize });
+            new Thread(new PurgeJob()).start();
+        } else {
+            LOG.debug(
+                "currentSizeInBytes=[{}],cachePurgeTrigSize=[{}], isInPurgeMode =[{}]",
+                new Object[] { cache.currentSizeInBytes,
+                    cache.cachePurgeTrigSize, isInPurgeMode() });
+        }
+    }
+            } else {
+                LOG.info("not able to remove cache entry [{}], size [{}]", key,
+                    super.get(key));
-        public synchronized Long put(final String fileName, final Long value) {
-            Long oldValue = cache.get(fileName);
-            if (oldValue == null) {
-                long flength = value.longValue();
-                currentSizeInBytes += flength;
-                return super.put(fileName.replace("\\", "/"), value);
+        public Long put(final String fileName, final Long value) {
+            if( isInPurgeMode()) {
+                LOG.debug("cache is purge mode: put is no-op");
+                return null;
-           toBeDeleted.remove(fileName);
-           return oldValue;
-        }
-
-        /**
-         * This method tries purging of local cache. It checks if local cache
-         * has exceeded the defined limit then it triggers purge cache job in a
-         * seperate thread.
-         */
-        synchronized void tryPurge() {
-            if (currentSizeInBytes > cachePurgeTrigSize && !isInPurgeMode()) {
-                setPurgeMode(true);
-                LOG.info(
-                    "currentSizeInBytes=[{}]  exceeds cachePurgeTrigSize=[{}]",
-                    cache.currentSizeInBytes, cache.cachePurgeTrigSize);
-                new Thread(new PurgeJob()).start();
-            } else {
-                LOG.debug(
-                    "currentSizeInBytes=[{}],cachePurgeTrigSize=[{}], isInPurgeMode =[{}]",
-                    new Object[] { cache.currentSizeInBytes,
-                        cache.cachePurgeTrigSize, isInPurgeMode() });
+            synchronized (this) {
+                Long oldValue = cache.get(fileName);
+                if (oldValue == null) {
+                    long flength = value.longValue();
+                    currentSizeInBytes += flength;
+                    return super.put(fileName.replace("\\", "/"), value);
+                }
+                toBeDeleted.remove(fileName);
+                return oldValue;
+        
+        @Override
+        public Long get(Object key) {
+            if( isInPurgeMode()) {
+                LOG.debug("cache is purge mode: get is no-op");
+                return null;
+            }
+            synchronized (this) {
+                return super.get(key);
+            }
+        }
+        
-                    LOG.info(" cache purge job started");
+                    LOG.info(" cache purge job started. initial cache entries = [{}]", initialSize);
-
-

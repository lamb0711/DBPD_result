JCR-2699: Improve read/write concurrency

Make BundleCache synchronized and use the LinkedHashMap class instead of the LinkedMap from Commons Collections (LinkedHashMap supports access-ordering, which makes it better for a LRU map)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1002101 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.collections.map.LinkedMap;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
-    private LinkedMap bundles = new LinkedMap();
+    private final LinkedHashMap<NodeId, NodePropBundle> bundles;
+    @SuppressWarnings("serial")
+        this.bundles = new LinkedHashMap<NodeId, NodePropBundle>(
+                (int) maxSize / 1024, 0.75f, true /* access-ordered */) {
+            @Override
+            protected boolean removeEldestEntry(
+                    Map.Entry<NodeId, NodePropBundle> e) {
+                if (curSize > BundleCache.this.maxSize) {
+                    curSize -= e.getValue().getSize();
+                    return true;
+                } else {
+                    return false;
+                }
+            }
+        };
-    public NodePropBundle get(NodeId id) {
-        Entry entry = (Entry) bundles.remove(id);
-        if (entry != null) {
-            // at end
-            bundles.put(id, entry);
+    public synchronized NodePropBundle get(NodeId id) {
+        NodePropBundle bundle = bundles.get(id);
+        if (bundle != null) {
-        return entry == null ? null : entry.bundle;
+        return bundle;
-     * Puts a bunlde to the cache. If the new size of the cache exceeds the
-     * {@link #getMaxSize() max size} of the cache it will remove bundles from
-     * this cache until the limit is satisfied.
+     * Puts a bundle to the cache.
-    public void put(NodePropBundle bundle) {
-        Entry entry = (Entry) bundles.remove(bundle.getId());
-        if (entry == null) {
-            entry = new Entry(bundle, bundle.getSize());
-        } else {
-            curSize -= entry.size;
-            entry.bundle = bundle;
-            entry.size = bundle.getSize();
+    public synchronized void put(NodePropBundle bundle) {
+        NodePropBundle previous = bundles.get(bundle.getId());
+        if (previous != null) {
+            curSize -= previous.getSize();
-        bundles.put(bundle.getId(), entry);
-        curSize += entry.size;
-        // now limit size of cache
-        while (curSize > maxSize) {
-            entry = (Entry) bundles.remove(0);
-            curSize -= entry.size;
-        }
+        bundles.put(bundle.getId(), bundle);
+        curSize += bundle.getSize();
-    public boolean contains(NodeId id) {
+    public synchronized boolean contains(NodeId id) {
-    public NodePropBundle remove(NodeId id) {
-        Entry entry = (Entry) bundles.remove(id);
-        if (entry != null) {
-            curSize -= entry.size;
-            return entry.bundle;
-        } else {
-            return null;
+    public synchronized NodePropBundle remove(NodeId id) {
+        NodePropBundle bundle = bundles.remove(id);
+        if (bundle != null) {
+            curSize -= bundle.getSize();
+        return bundle;
-    public void clear() {
+    public synchronized void clear() {
-    /**
-     * Internal class that holds the bundles.
-     */
-    private static final class Entry {
-
-        /**
-         * the cached bundle
-         */
-        private NodePropBundle bundle;
-
-        /**
-         * the memory usage of the bundle in bytes
-         */
-        private long size;
-
-        /**
-         * Creates a new entry.
-         *
-         * @param bundle the bundle to cache
-         * @param size the size of the bundle
-         */
-        public Entry(NodePropBundle bundle, long size) {
-            this.bundle = bundle;
-            this.size = size;
-        }
-    }
-

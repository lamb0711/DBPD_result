Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.spi.IdFactory;
-import org.apache.jackrabbit.spi.Event;
-import org.apache.jackrabbit.name.Path;
-import org.apache.jackrabbit.name.MalformedPathException;
+import org.apache.jackrabbit.spi.NodeId;
+import org.apache.jackrabbit.spi.PropertyId;
+import org.apache.jackrabbit.name.Path;
+import org.apache.jackrabbit.jcr2spi.hierarchy.HierarchyEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.NodeEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.PropertyEntry;
+import org.apache.jackrabbit.jcr2spi.nodetype.EffectiveNodeType;
+import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeRegistry;
+import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeConflictException;
-import javax.jcr.ItemNotFoundException;
-     * Flag used to distinguish workspace states from session states. The first
-     * accepts call to {@link #refresh(Event)}, while the latter
+     * Flag used to distinguish workspace states from session states. The latter
-     *  IdFactory used to build id of the states
-     */
-    final IdFactory idFactory;
-
-    /**
-    /**
-     * The parent <code>NodeState</code> or <code>null</code> if this
-     * instance represents the root node.
-     */
-    NodeState parent;
+    // TODO: find better solution..... needed to retrieve definition.
+    final NodeTypeRegistry ntReg;
-     * @param parent
-     * @param initialStatus the initial status of the item state object
+     * @param initialStatus
+     * @param isWorkspaceState
-    protected ItemState(NodeState parent, int initialStatus, ItemStateFactory isf,
-                        IdFactory idFactory, boolean isWorkspaceState) {
+    protected ItemState(int initialStatus, boolean isWorkspaceState,
+                        ItemStateFactory isf, NodeTypeRegistry ntReg) {
-        this.parent = parent;
-        this.idFactory = idFactory;
+        this.ntReg = ntReg;
-     * @param overlayedState the backing item state being overlayed
-     * @param initialStatus the initial status of the new <code>ItemState</code> instance
+     * @param overlayedState
+     * @param initialStatus
-    protected ItemState(ItemState overlayedState, NodeState parent,
-                        int initialStatus, ItemStateFactory isf, IdFactory idFactory) {
+    protected ItemState(ItemState overlayedState, int initialStatus, ItemStateFactory isf) {
-        this.parent = parent;
-        this.idFactory = idFactory;
-
+        this.ntReg = overlayedState.ntReg;
+     * The <code>HierarchyEntry</code> corresponding to this <code>ItemState</code>.
+     *
+     * @return The <code>HierarchyEntry</code> corresponding to this <code>ItemState</code>.
+     */
+    public abstract HierarchyEntry getHierarchyEntry();
+
+    /**
+     * Utility method:
-     * Returns the name of this state.
+     * Utility method:
+     * Returns the name of this state. Shortcut for calling 'getQName' on the
+     * {@link ItemState#getHierarchyEntry() hierarchy entry}.
-    public abstract QName getQName();
+    public QName getQName() {
+        return getHierarchyEntry().getQName();
+    }
-     * Returns the identifier of this item state.
+     * Utility method:
+     * Returns the identifier of this item state. Shortcut for calling 'getId'
+     * on the {@link ItemState#getHierarchyEntry() hierarchy entry}.
-     * Returns the qualified path of this item state.
+     * Utility method:
+     * Returns the qualified path of this item state. Shortcut for calling
+     * 'getPath' on the {@link ItemState#getHierarchyEntry() hierarchy entry}.
-     * @return qualified path
-     * @throws ItemNotFoundException
-     * @throws RepositoryException
+     * @return
+     * @throws RepositoryException if an error occurs
-    public Path getQPath() throws ItemNotFoundException, RepositoryException {
-        // shortcut for root state
-        if (parent == null) {
-            return Path.ROOT;
-        }
-
-        // build path otherwise
-        try {
-            Path.PathBuilder builder = new Path.PathBuilder();
-            buildPath(builder, this);
-            return builder.getPath();
-        } catch (MalformedPathException e) {
-            String msg = "Failed to build path of " + this;
-            throw new RepositoryException(msg, e);
-        }
+    public Path getQPath() throws RepositoryException {
+        return getHierarchyEntry().getPath();
-     * Adds the path element of an item id to the path currently being built.
-     * On exit, <code>builder</code> contains the path of <code>state</code>.
+     * Utility method: Shortcut for calling
+     * 'getParent().getNodeState()' on the {@link ItemState#getHierarchyEntry()
+     * hierarchy entry}.
-     * @param builder builder currently being used
-     * @param state   item to find path of
+     * @return
+     * @throws NoSuchItemStateException
+     * @throws ItemStateException
-    private void buildPath(Path.PathBuilder builder, ItemState state)
-        throws ItemNotFoundException {
-        NodeState parentState = state.getParent();
-        // shortcut for root state
-        if (parentState == null) {
-            builder.addRoot();
-            return;
-        }
-
-        // recursively build path of parent
-        buildPath(builder, parentState);
-
-        QName name = state.getQName();
-        if (state.isNode()) {
-            int index = ((NodeState)state).getIndex();
-            // add to path
-            if (index == Path.INDEX_DEFAULT) {
-                builder.addLast(name);
-            } else {
-                builder.addLast(name, index);
-            }
-        } else {
-            // property-state: add to path
-            builder.addLast(name);
-        }
-    }
-
-    /**
-     * Returns the parent <code>NodeState</code> or <code>null</code>
-     * if either this item state represents the root node or this item state is
-     * 'free floating', i.e. not attached to the repository's hierarchy.
-     *
-     * @return the parent <code>NodeState</code>
-     */
-    public NodeState getParent() {
-        return parent;
+    public NodeState getParent() throws NoSuchItemStateException, ItemStateException {
+        return getHierarchyEntry().getParent().getNodeState();
-    void setStatus(int newStatus) {
+    public void setStatus(int newStatus) {
-     * Reloads this item state recursively. If '<code>keepChanges</code>' is
-     * true, states with transient changes are left untouched. Otherwise this
-     * state gets its data reloaded from the persistent state.
-     * todo throw exception in case of error?
-     */
-    public abstract void reload(boolean keepChanges);
-
-    /**
-    abstract boolean merge(ItemState another, boolean keepChanges);
-
-    /**
-     * Invalidates this item state recursively. In contrast to {@link #refresh}
-     * this method only sets the status of this item state to {@link
-     * Status#INVALIDATED} and does not acutally update it with the persistent
-     * state in the repository.
-     */
-    public abstract void invalidate(boolean recursive);
+     public abstract boolean merge(ItemState another, boolean keepChanges);
-     * @param state
+     * @param overlayed
-    public void statusChanged(ItemState state, int previousStatus) {
+    public void statusChanged(ItemState overlayed, int previousStatus) {
-        state.checkIsWorkspaceState();
+        overlayed.checkIsWorkspaceState();
-        if (state == overlayedState) {
-            switch (state.getStatus()) {
+        if (overlayed == overlayedState) {
+            switch (overlayed.getStatus()) {
-                        synchronized (this) {
-                            if (merge(state, false) || status == Status.INVALIDATED) {
-                                // temporarily set the state to MODIFIED in order
-                                // to inform listeners.
-                                setStatus(Status.MODIFIED);
-                            }
-                        }
+                        // temporarily set the state to MODIFIED in order to inform listeners.
+                        setStatus(Status.MODIFIED);
-                    log.error("Workspace state cannot have its state changed to " + state.getStatus());
+                    log.error("Workspace state cannot have its state changed to " + overlayed.getStatus());
-    //--------------------------------------------------< Workspace - State >---
-    /**
-     * Used on 'workspace' states in order to update the state according to
-     * an external modification indicated by the given event.
-     *
-     * @param event
-     * @throws IllegalStateException if this state is a 'session' state.
-     */
-    abstract void refresh(Event event);
-
-    /**
-     * Returns the overlaying item state or <code>null</code> if that state
-     * has not been created yet or has been disconnected.
-     *
-     * @return
-     */
-    ItemState getSessionState() {
-        checkIsWorkspaceState();
-        ItemStateLifeCycleListener[] la;
-        synchronized (listeners) {
-            la = (ItemStateLifeCycleListener[]) listeners.toArray(new ItemStateLifeCycleListener[listeners.size()]);
-        }
-        for (int i = 0; i < la.length; i++) {
-            if (la[i] instanceof ItemState) {
-                return (ItemState) la[i];
-            }
-        }
-        return null;
-    }
-
-    void connect(ItemState overlayedState) {
+    private void connect(ItemState overlayedState) {
-        if (this.overlayedState != null && this.overlayedState != overlayedState) {
+        if (this.overlayedState == null) {
+            setOverLayedState(overlayedState);
+        } else if (this.overlayedState != overlayedState) {
+        } // attempt to connect state to its ol-state again -> nothing to do.
+    }
+
+    /**
+     * Replaces the overlayedState with a new instance retrieved from the
+     * persistent layer thus forcing a reload of this ItemState or in case
+     * of a NEW state, retrieves the overlayed state after the state has been
+     * persisted and connects the NEW state. Note, that in the latter case,
+     * the parent must already be connected to its overlayed state.
+     *
+     * @param keepChanges
+     * @throws NoSuchItemStateException
+     * @throws ItemStateException
+     */
+    public void reconnect(boolean keepChanges) throws NoSuchItemStateException, ItemStateException {
+        checkIsSessionState();
+        // Need to use the workspace-ISF in order not to create yet another
+        // session-state.
+        ItemStateFactory wspIsf;
+        if (overlayedState != null) {
+            wspIsf = overlayedState.isf;
+        } else {
+            wspIsf = getParent().overlayedState.isf;
+        }
+
+        ItemState overlayed;
+        if (isNode()) {
+            overlayed = wspIsf.createNodeState((NodeId) getId(), (NodeEntry) getHierarchyEntry());
+        } else {
+            overlayed = wspIsf.createPropertyState((PropertyId) getId(), (PropertyEntry) getHierarchyEntry());
+        }
+        setOverLayedState(overlayed);
+        boolean modified = merge(overlayed, keepChanges);
+        if (status == Status.NEW || status == Status.INVALIDATED) {
+            setStatus(Status.EXISTING);
+        } else if (modified) {
+            // start notification by marking ol-state modified.
+            overlayed.setStatus(Status.MODIFIED);
+        }
+    }
+
+    /**
+     *
+     * @param overlayedState
+     */
+    private void setOverLayedState(ItemState overlayedState) {
+        if (this.overlayedState != null) {
+           this.overlayedState.removeListener(this);
-     * Removes this item state. This will change the status of this property
-     * state to either {@link Status#EXISTING_REMOVED} or {@link
-     * Status#REMOVED} depending on the current status.
-     *
-     * @throws ItemStateException if an error occurs while removing this item
-     * state. e.g. this item state is not valid anymore.
-     */
-    void remove() throws ItemStateException {
-        checkIsSessionState();
-        if (!isValid()) {
-            throw new ItemStateException("Cannot remove an invalid ItemState");
-        }
-        int oldStatus = getStatus();
-        if (oldStatus == Status.NEW) {
-            setStatus(Status.REMOVED);
-        } else {
-            setStatus(Status.EXISTING_REMOVED);
-        }
-        // now inform parent
-        getParent().childStatusChanged(this, oldStatus);
-    }
-
-    /**
-     * Reverts this item state to its initial status (i.e. removing any transient
-     * modifications.
-     */
-    void revert() throws ItemStateException {
-        checkIsSessionState();
-
-        switch (getStatus()) {
-            case Status.EXISTING_MODIFIED:
-            case Status.STALE_MODIFIED:
-                // revert state from overlayed
-                merge(overlayedState, false);
-                setStatus(Status.EXISTING);
-                break;
-            case Status.EXISTING_REMOVED:
-                // revert state from overlayed
-                merge(overlayedState, false);
-                setStatus(Status.EXISTING);
-                parent.childStatusChanged(this, Status.EXISTING_REMOVED);
-                break;
-            case Status.NEW:
-                remove();
-                break;
-            case Status.STALE_DESTROYED:
-                // overlayed does not exist any more
-                // cannot call 'remove' on invalid state -> manuall remove
-                setStatus(Status.REMOVED);
-                parent.childStatusChanged(this, Status.STALE_DESTROYED);
-                break;
-            default:
-                // Cannot revert EXISTING, REMOVED, INVALIDATED, MODIFIED states.
-                // State was implicitely reverted
-                log.debug("State with status " + getStatus() + " cannot be reverted.");
-        }
-    }
-
-    /**
-     * Checks if this <code>ItemState</code> is transiently modified, new or stale
-     * modified. and adds itself to the <code>ChangeLog</code>.
-     * If this <code>ItemState</code> has children it will call
-     * {@link #collectStates(ChangeLog, boolean)} recursively.
-     *
-     * @param changeLog the <code>ChangeLog</code> collecting the transient
-     * item states present in a given tree.
-     * @param throwOnStale If the given flag is true, this methods throws
-     * StaleItemStateException if this state is stale.
-     * @throws StaleItemStateException if <code>throwOnStale</code> is true and
-     * this state is stale.
-     */
-    void collectStates(ChangeLog changeLog, boolean throwOnStale) throws StaleItemStateException {
-        checkIsSessionState();
-        if (throwOnStale && Status.isStale(getStatus())) {
-            String msg = "Cannot save changes: " + getId() + " has been modified externally.";
-            log.debug(msg);
-            throw new StaleItemStateException(msg);
-        }
-        // only interested in transient modifications or stale-modified states
-        switch (getStatus()) {
-            case Status.NEW:
-                changeLog.added(this);
-                break;
-            case Status.EXISTING_MODIFIED:
-            case Status.STALE_MODIFIED:
-                changeLog.modified(this);
-                break;
-            case Status.EXISTING_REMOVED:
-                changeLog.deleted(this);
-                break;
-            default:
-                log.debug("Collecting states: Ignored ItemState with status " + getStatus());
-        }
-    }
-
-    /**
+
+    EffectiveNodeType getEffectiveNodeType() throws RepositoryException {
+        try {
+            EffectiveNodeType ent = getNodeTypeRegistry().getEffectiveNodeType(getParent().getNodeTypeNames());
+            return ent;
+        } catch (ItemStateException e) {
+            throw new RepositoryException("Error while accessing Definition ", e);
+        } catch (NodeTypeConflictException e) {
+            throw new RepositoryException("Error while accessing Definition ", e);
+        }
+    }
+
+    NodeTypeRegistry getNodeTypeRegistry() {
+        return ntReg;
+    }

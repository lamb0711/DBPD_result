JCR-3185: refactor consistency checks in BundleDBPersistenceManager into a standalone class that could be re-used for other PMs

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1221428 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Random;
-import java.util.Set;
-import org.apache.jackrabbit.core.persistence.check.ConsistencyChecker;
-import org.apache.jackrabbit.core.persistence.check.ConsistencyReport;
-import org.apache.jackrabbit.core.persistence.check.ConsistencyReportImpl;
-import org.apache.jackrabbit.core.persistence.check.ReportItem;
-import org.apache.jackrabbit.core.persistence.check.ReportItemImpl;
-import org.apache.jackrabbit.spi.commons.name.NameFactoryImpl;
-        extends AbstractBundlePersistenceManager implements DatabaseAware, ConsistencyChecker {
+        extends AbstractBundlePersistenceManager implements DatabaseAware {
-    private void addMessage(Set<ReportItem> reports, NodeId id, String message) {
-        if (reports != null) {
-            reports.add(new ReportItemImpl(id.toString(), message));
-        }
-    }
-
-    /**
-     * Checks a single bundle for inconsistencies, ie. inexistent child nodes
-     * and inexistent parents.
-     *
-     * @param id node id for the bundle to check
-     * @param bundle the bundle to check
-     * @param fix if <code>true</code>, repair things that can be repaired
-     * @param modifications if <code>fix == true</code>, collect the repaired
-     * {@linkplain NodePropBundle bundles} here
-     */
-    protected void checkBundleConsistency(NodeId id, NodePropBundle bundle,
-                                          boolean fix, Collection<NodePropBundle> modifications,
-                                          Set<ReportItem> reports) {
-        //log.info(name + ": checking bundle '" + id + "'");
-
-        // skip all system nodes except root node
-        if (id.toString().endsWith("babecafebabe")
-                && !id.toString().equals("cafebabe-cafe-babe-cafe-babecafebabe")) {
-            return;
-        }
-
-        // look at the node's children
-        Collection<NodePropBundle.ChildNodeEntry> missingChildren = new ArrayList<NodePropBundle.ChildNodeEntry>();
-        for (NodePropBundle.ChildNodeEntry entry : bundle.getChildNodeEntries()) {
-
-            // skip check for system nodes (root, system root, version storage, node types)
-            if (entry.getId().toString().endsWith("babecafebabe")) {
-                continue;
-            }
-
-            try {
-                // analyze child node bundles
-                NodePropBundle child = loadBundle(entry.getId());
-                String message = null;
-                if (child == null) {
-                    message = "NodeState '" + id + "' references inexistent child" + " '"
-                            + entry.getName() + "' with id " + "'" + entry.getId() + "'";
-                    log.error(message);
-                    missingChildren.add(entry);
-                } else {
-                    NodeId cp = child.getParentId();
-                    if (cp == null) {
-                        message = "ChildNode has invalid parent id: <null>";
-                        log.error(message);
-                    } else if (!cp.equals(id)) {
-                        message = "ChildNode has invalid parent id: '" + cp + "' (instead of '" + id + "')";
-                        log.error(message);
-                    }
-                }
-                if (message != null) {
-                    addMessage(reports, id, message);
-                }
-            } catch (ItemStateException e) {
-                // problem already logged (loadBundle called with logDetailedErrors=true)
-                addMessage(reports, id, e.getMessage());
-            }
-        }
-        // remove child node entry (if fixing is enabled)
-        if (fix && !missingChildren.isEmpty()) {
-            for (NodePropBundle.ChildNodeEntry entry : missingChildren) {
-                bundle.getChildNodeEntries().remove(entry);
-            }
-            modifications.add(bundle);
-        }
-
-        // check parent reference
-        NodeId parentId = bundle.getParentId();
-        try {
-            // skip root nodes (that point to itself)
-            if (parentId != null && !id.toString().endsWith("babecafebabe")) {
-                NodePropBundle parentBundle = loadBundle(parentId);
-                
-                if (parentBundle == null) {
-                    String message = "NodeState '" + id + "' references inexistent parent id '" + parentId + "'";
-                    log.error(message);
-                    addMessage(reports, id, message);
-                }
-                else {
-                    boolean found = false;
-
-                    for (NodePropBundle.ChildNodeEntry entry : parentBundle.getChildNodeEntries()) {
-                        if (entry.getId().equals(id)){
-                            found = true;
-                            break;
-                        }
-                    }
-
-                    if (!found) {
-                        String message = "NodeState '" + id + "' is not referenced by its parent node '" + parentId + "'";
-                        log.error(message);
-                        addMessage(reports, id, message);
-
-                        int l = (int) System.currentTimeMillis();
-                        int r = new Random().nextInt();
-                        int n = l + r;
-                        String nodeName = Integer.toHexString(n);
-                        parentBundle.addChildNodeEntry(NameFactoryImpl
-                                .getInstance().create("{}" + nodeName), id);
-                        log.info("NodeState '" + id + "' adds itself to its parent node '" + parentId + "' with a new name '" + nodeName + "'");
-                        modifications.add(parentBundle);
-                    }
-                }
-            }
-        } catch (ItemStateException e) {
-            String message = "Error reading node '" + parentId + "' (parent of '" + id + "'): " + e;
-            log.error(message);
-            addMessage(reports, id, message);
-        }
-    }
-
-    public ConsistencyReport check(String[] uuids, boolean recursive,
-            boolean fix) throws RepositoryException {
-
-        Set<ReportItem> reports = new HashSet<ReportItem>();
-
-        long tstart = System.currentTimeMillis();
-        int total = internalCheckConsistency(uuids, recursive, fix, reports);
-        long elapsed = System.currentTimeMillis() - tstart;
-
-        return new ConsistencyReportImpl(total, elapsed, reports);
-    }
-
-    public void checkConsistency(String[] uuids, boolean recursive, boolean fix) {
-        try {
-            internalCheckConsistency(uuids, recursive, fix, null);
-        }
-        catch (RepositoryException ex) {
-            log.error("While running consistency check.", ex);
-        }
-    }
-    
-    private int internalCheckConsistency(String[] uuids, boolean recursive, boolean fix, Set<ReportItem> reports) throws RepositoryException {
-        int count = 0;
-        int total = 0;
-        Collection<NodePropBundle> modifications = new ArrayList<NodePropBundle>();        
-
-        if (uuids == null) {
-            total = getNumberOfNodeIds();
-            
-            try {
-                Iterable<NodeId> allIds = getAllNodeIds(null, 0);
-
-                for (NodeId id : allIds) {
-                    try {
-                        // parse and check bundle
-                        NodePropBundle bundle = loadBundle(id);
-                        if (bundle == null) {
-                            log.error("No bundle found for id '" + id + "'");
-                        } else {
-                            checkBundleConsistency(id, bundle, fix, modifications, reports);
-
-                            count++;
-                            if (count % 1000 == 0) {
-                                log.info(name + ": checked " + count + "/" + total + " bundles...");
-                            }
-                        }
-                    } catch (ItemStateException e) {
-                        // problem already logged (loadBundle called with
-                        // logDetailedErrors=true)
-                    }
-
-                }
-            } catch (ItemStateException ex) {
-                throw new RepositoryException("getting nodeIds", ex);
-            } finally {
-                total = count;
-            }
-        } else {
-            // check only given uuids, handle recursive flag
-
-            // 1) convert uuid array to modifiable list
-            // 2) for each uuid do
-            //     a) load node bundle
-            //     b) check bundle, store any bundle-to-be-modified in collection
-            //     c) if recursive, add child uuids to list of uuids
-
-            List<NodeId> idList = new ArrayList<NodeId>(uuids.length);
-            // convert uuid string array to list of UUID objects
-            for (int i = 0; i < uuids.length; i++) {
-                try {
-                    idList.add(new NodeId(uuids[i]));
-                } catch (IllegalArgumentException e) {
-                    log.error("Invalid id for consistency check, skipping: '" + uuids[i] + "': " + e);
-                }
-            }
-            
-            // iterate over UUIDs (including ones that are newly added inside the loop!)
-            for (int i = 0; i < idList.size(); i++) {
-                NodeId id = idList.get(i);
-                try {
-                    // load the node from the database
-                    NodePropBundle bundle = loadBundle(id);
-
-                    if (bundle == null) {
-                        log.error("No bundle found for id '" + id + "'");
-                    }
-                    else {
-                        checkBundleConsistency(id, bundle, fix, modifications, reports);
-
-                        if (recursive) {
-                            for (NodePropBundle.ChildNodeEntry entry : bundle.getChildNodeEntries()) {
-                                idList.add(entry.getId());
-                            }
-                        }
-
-                        count++;
-                        if (count % 1000 == 0) {
-                            log.info(name + ": checked " + count + "/" + idList.size() + " bundles...");
-                        }
-                    }
-                } catch (ItemStateException e) {
-                    // problem already logged (loadBundle called with logDetailedErrors=true)
-                }
-            }
-
-            total = idList.size();
-        }
-
-        // repair collected broken bundles
-        if (fix && !modifications.isEmpty()) {
-            log.info(name + ": Fixing " + modifications.size() + " inconsistent bundle(s)...");
-            for (NodePropBundle bundle : modifications) {
-                try {
-                    log.info(name + ": Fixing bundle '" + bundle.getId() + "'");
-                    bundle.markOld(); // use UPDATE instead of INSERT
-                    storeBundle(bundle);
-                    evictBundle(bundle.getId());
-                } catch (ItemStateException e) {
-                    log.error(name + ": Error storing fixed bundle: " + e);
-                }
-            }
-        }
-
-        log.info(name + ": checked " + count + "/" + total + " bundles.");
-
-        return total;
-    }
-
-    private synchronized int getNumberOfNodeIds() throws RepositoryException {
-        ResultSet rs = null;
-        try {
-            String sql = "select count(*) from " + schemaObjectPrefix + "BUNDLE";
-            rs = conHelper.exec(sql, new Object[0], false, 0);
-
-            if (!rs.next()) {
-                String message = "Could not retrieve total number of bundles: empty result set.";
-                log.error(message);
-                throw new RepositoryException(message);
-            }
-            return rs.getInt(1);
-        } catch (SQLException ex) {
-            throw new RepositoryException("Could not retrieve total number of bundles", ex);
-        } finally {
-            DbUtility.close(rs);
-        }
-    }
-
-    public synchronized Iterable<NodeId> getAllNodeIds(NodeId bigger, int maxCount)
+    public synchronized List<NodeId> getAllNodeIds(NodeId bigger, int maxCount)

Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.state.entry.ChildNodeEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.NodeEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.PropertyEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.HierarchyEntry;
+       NodeEntry parentEntry = (NodeEntry) parent.getHierarchyEntry();
-       if (parent.hasChildNodeEntry(nodeInfo.getName())) {
+       if (parentEntry.hasNodeEntry(nodeInfo.getName())) {
-           ChildNodeEntry entry = parent.getChildNodeEntry(nodeInfo.getName(), Path.INDEX_DEFAULT);
+           NodeEntry entry = parentEntry.getNodeEntry(nodeInfo.getName(), Path.INDEX_DEFAULT);
-                   NodeState conflicting = (NodeState) stateMgr.getItemState(conflictingId);
-                   nodeState = resolveUUIDConflict(parent, conflicting, nodeInfo);
+                   HierarchyEntry conflicting = session.getHierarchyManager().getHierarchyEntry(conflictingId);
+                   // assert that the entry is available
+                   conflicting.getItemState();
+
+                   nodeState = resolveUUIDConflict(parent, (NodeEntry) conflicting, nodeInfo);
-                   String msg = "Internal error: failed to retrieve state of " + nodeInfo.getUUID().toString();
+                   String msg = "Internal error: failed to retrieve node state";
-    NodeState resolveUUIDConflict(NodeState parent, NodeState conflicting,
-                                  NodeInfo nodeInfo) throws RepositoryException {
+    NodeState resolveUUIDConflict(NodeState parent, NodeEntry conflicting,
+                                  NodeInfo nodeInfo)
+        throws ItemExistsException, RepositoryException, ItemStateException {
-                Path p1 = conflicting.getQPath();
+                Path p1 = conflicting.getPath();
-                Operation op = Remove.create(conflicting);
+                Operation op = Remove.create(conflicting.getNodeState(), parent);
-                // 'replace' current parent with parent of conflicting
-                parent = conflicting.getParent();
-                if (parent == null) {
+                if (conflicting.getNodeState().isRoot()) {
-                
+
+                // 'replace' current parent with parent of conflicting
+                parent = conflicting.getParent().getNodeState();
+
-                op = Remove.create(conflicting);
+                op = Remove.create(conflicting.getNodeState(), parent);
-                    Operation rm = Remove.create(conflicting);
+                    Operation rm = Remove.create(conflicting, parent);
-                List cne = parent.getChildNodeEntries(nodeInfo.getName());
+                List cne = parent.getNodeEntry().getNodeEntries(nodeInfo.getName());
-                    childState = ((ChildNodeEntry)cne.get(cne.size()-1)).getNodeState();
+                    childState = ((NodeEntry)cne.get(cne.size()-1)).getNodeState();
-                    childState = ((ChildNodeEntry)cne.get(0)).getNodeState();
+                    childState = ((NodeEntry)cne.get(0)).getNodeState();
-        if (parentState.hasPropertyName(propName)) {
+        NodeEntry parentEntry = (NodeEntry) parentState.getHierarchyEntry();
+        PropertyEntry pEntry = parentEntry.getPropertyEntry(propName);
+        if (pEntry != null) {
-                PropertyState existing = parentState.getPropertyState(propName);
+                PropertyState existing = pEntry.getPropertyState();
-                propState = parentState.getPropertyState(propName);
+                propState = parentEntry.getPropertyEntry(propName).getPropertyState();
-        if (propState != null && propState.getType() == PropertyType.REFERENCE) {
+        if (propState.getType() == PropertyType.REFERENCE) {
-}
+}

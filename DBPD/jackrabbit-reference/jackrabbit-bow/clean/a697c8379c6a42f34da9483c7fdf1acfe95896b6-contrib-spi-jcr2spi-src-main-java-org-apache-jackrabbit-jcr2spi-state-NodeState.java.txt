work in progress

- version always protected
- versionHistory always protected
- fix Node.getReferences && reference properties
- mixinTypes are 'active' upon save only (and not before). therefore
  cleanup after removeMixin is done only after save.
  adding new states defined by a new mixin are only added after the
  node has been saved.
- nodestates identified by a uuid only were created a second time upon
  ChildNodeEntry.resolve => fix needs to be improved
- Events/ChangeLog are processed by the save-target state
- ChangeLog.persisted not used any more

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@467956 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.commons.collections.iterators.IteratorChain;
-import org.apache.jackrabbit.spi.PropertyId;
-    private QName[] mixinTypeNames = new QName[0];
+    private QName[] mixinTypeNames = QName.EMPTY_ARRAY;
-     * The <code>ItemStateFactory</code> which is used to create new
-     * <code>ItemState</code> instances.
-     */
-    private final ItemStateFactory isf;
-
-    /**
-        super(parent, initialStatus, idFactory, isWorkspaceState);
+        super(parent, initialStatus, isf, idFactory, isWorkspaceState);
-        this.isf = isf;
+        assertAvailability();
-        super(overlayedState, parent, initialStatus, idFactory);
-        this.isf = isf;
-        reset();
+        super(overlayedState, parent, initialStatus, isf, idFactory);
+        if (overlayedState != null) {
+            synchronized (overlayedState) {
+                NodeState wspState = (NodeState) overlayedState;
+                name = wspState.name;
+                uuid = wspState.uuid;
+                nodeTypeName = wspState.nodeTypeName;
+                definition = wspState.definition;
+
+                init(wspState.getMixinTypeNames(), wspState.getChildNodeEntries(), wspState.getPropertyNames(), wspState.getNodeReferences());
+            }
+        }
+        assertAvailability();
+    /**
+     *
+     * @param mixinTypeNames
+     * @param childEntries
+     * @param propertyNames
+     * @param references
+     */
-            properties.put(propName, PropertyReference.create(this, propName, isf, idFactory));
+            addPropertyEntry(PropertyReference.create(this, propName, isf, idFactory));
-            childNodeEntries.add(cne.getName(), cne.getUUID());
+            childNodeEntries.add(cne.getName(), cne.getUUID(), cne.getIndex());
+    private void assertAvailability() {
+        // TODO: improve this.
+        if (uuid != null) {
+            // make sure this state is connected to its childNode-entry
+            ChildNodeEntry cne = parent.childNodeEntries.get(uuid);
+            if (!cne.isAvailable()) {
+                try {
+                    cne.getNodeState();
+                } catch (ItemStateException e) {
+                    // ignore
+                }
+            }
+        }
+    }
+
+        NodeState parent = getParent();
-    public final String getUUID() {
+    public String getUUID() {
+     * Modify the uuid of this state and make sure, that the parent state
+     * contains a proper childNodeEntry for this state. If the given uuid is
+     * not different from the uuid of this state, the method returns silently
+     * without changing neither the parent nor this state.
+     *
+     * @param uuid
+     */
+    private void setUUID(String uuid) {
+        String oldUUID = this.uuid;
+        boolean mod = (oldUUID == null) ? uuid != null : !oldUUID.equals(uuid);
+        if (mod) {
+            this.uuid = uuid;
+            if (getParent() != null) {
+                getParent().childNodeEntries.replaceEntry(this);
+            }
+        }
+    }
+
+    /**
-        if (getStatus() == Status.NEW) {
-            return null;
-        } else {
-            return references;
-        }
+        return references;
+     *
+     * @param propEntry
+     */
+    private void addPropertyEntry(ChildPropertyEntry propEntry) {
+        QName propName = propEntry.getName();
+        properties.put(propName, propEntry);
+        try {
+            if (isWorkspaceState() && isUuidOrMixin(propName)) {
+                if (QName.JCR_UUID.equals(propName) && uuid == null) {
+                    PropertyState ps = propEntry.getPropertyState();
+                    setUUID(ps.getValue().getString());
+                } else if (QName.JCR_MIXINTYPES.equals(propName) && (mixinTypeNames == null || mixinTypeNames.length == 0)) {
+                    PropertyState ps = propEntry.getPropertyState();
+                    mixinTypeNames = getMixinNames(ps);
+                }
+            }
+        } catch (ItemStateException e) {
+            log.error("Internal Error", e);
+        } catch (RepositoryException e) {
+            log.error("Internal Error", e);
+        }
+    }
+
+    /**
+     *
+     * @param propName
+     */
+    private void removePropertyEntry(QName propName) {
+        if (properties.remove(propName) != null) {
+            if (isWorkspaceState()) {
+                if (QName.JCR_UUID.equals(propName)) {
+                    setUUID(null);
+                } else if (QName.JCR_MIXINTYPES.equals(propName)) {
+                    mixinTypeNames = QName.EMPTY_ARRAY;
+                }
+            }
+        }
+    }
+
+    /**
-     * @param changeLog
-     * @see ItemState#refresh(Event, ChangeLog)
+     * @see ItemState#refresh(Event)
-    synchronized void refresh(Event event, ChangeLog changeLog) {
+    synchronized void refresh(Event event) {
+        QName name = event.getQPath().getNameElement().getName();
+                int index = event.getQPath().getNameElement().getNormalizedIndex();
+                NodeId evId = (NodeId) event.getItemId();
+                String uuid = (evId.getPath() != null) ? null : evId.getUUID();
+
+                // add new childNodeEntry if it has not been added by
+                // some earlier 'add' event
+                // TODO: TOBEFIXED for SNSs
+                ChildNodeEntry cne = childNodeEntries.get(name, index);
+                if (cne == null || ((uuid == null) ? cne.getUUID() != null : !uuid.equals(cne.getUUID()))) {
+                    cne = childNodeEntries.add(name, uuid, index);
+                }
+                // and let the transiently modified session state now, that
+                // its workspace state has been touched.
+                setStatus(Status.MODIFIED);
+                break;
+
-                if (!id.equals(event.getParentId())) {
-                    // TODO: TOBEFIXED. this should never occur and indicates severe consistency issue.
-                    throw new IllegalArgumentException("Event parent (" + event.getParentId() + ") does not match this state with id: " + id);
-                }
-                ItemId evId = event.getItemId();
-                ItemState newState = null;
-
-                if (evId.denotesNode()) {
-                    QName name = event.getQPath().getNameElement().getName();
-                    int index = event.getQPath().getNameElement().getNormalizedIndex();
-                    String uuid = (((NodeId)evId).getPath() != null) ? null : ((NodeId)evId).getUUID();
-
-                    // add new childNodeEntry if it has not been added by
-                    // some earlier 'add' event
-                    // TODO: TOBEFIXED for SNSs
-                    ChildNodeEntry cne = getChildNodeEntry(name, index);
-                    if (cne == null || ((uuid == null) ? cne.getUUID() != null : !uuid.equals(cne.getUUID()))) {
-                        cne = childNodeEntries.add(name, uuid);
-                    }
-                    try {
-                        newState = cne.getNodeState();
-                    } catch (ItemStateException e) {
-                        log.error("Internal error", e);
-                    }
-                } else {
-                    QName pName = ((PropertyId) event.getItemId()).getQName();
-                    // create a new property reference if it has not been
-                    // added by some earlier 'add' event
-                    ChildPropertyEntry re;
-                    if (hasPropertyName(pName)) {
-                        re = (ChildPropertyEntry) properties.get(pName);
-                    } else {
-                        re = PropertyReference.create(this, pName, isf, idFactory);
-                        properties.put(pName, re);
-                    }
-                    try {
-                        newState = re.getPropertyState();
-                    } catch (ItemStateException e) {
-                        log.error("Internal error", e);
-                    }
-                    // make sure this state is up to date (uuid/mixins)
-                    refresh(pName, event.getType());
-                }
-
-                // connect the added state from the transient layer to the
-                // new workspaceState and make sure its data are updated.
-                if (newState != null && changeLog != null) {
-                    for (Iterator it = changeLog.addedStates(); it.hasNext();) {
-                        ItemState added = (ItemState) it.next();
-                        if (added.hasOverlayedState()) {
-                            // already connected
-                            continue;
-                        }
-                        // TODO: TOBEFIXED. may fail (produce wrong results) for SNSs, since currently events upon 'save' are not garantied to be 'local' changes only
-                        // TODO: TOBEFIXED. equals to false if added-state is referenceable.
-                        if (added.getId().equals(evId)) {
-                            added.connect(newState);
-                            added.merge();
-                            break;
-                        }
-                    }
+                // create a new property reference if it has not been
+                // added by some earlier 'add' event
+                if (!hasPropertyName(name)) {
+                    ChildPropertyEntry re = PropertyReference.create(this, name, isf, idFactory);
+                    addPropertyEntry(re);
-                    QName qName = event.getQPath().getNameElement().getName();
-                    int index = event.getQPath().getNameElement().getNormalizedIndex();
-                    childNodeEntries.remove(qName, index);
+                    index = event.getQPath().getNameElement().getNormalizedIndex();
+                    childNodeEntries.remove(name, index);
-                if (id.equals(event.getParentId())) {
-                    QName pName = ((PropertyId) event.getItemId()).getQName();
-                    properties.remove(pName);
-                    // make sure this state is up to date (uuid/mixins)
-                    refresh(pName, event.getType());
-                    setStatus(Status.MODIFIED);
-                } else {
-                    // ILLEGAL
-                    throw new IllegalArgumentException("Illegal event type " + event.getType() + " for NodeState.");
-                }
+                removePropertyEntry(name);
+                setStatus(Status.MODIFIED);
-                if (id.equals(event.getParentId())) {
-                    QName pName = ((PropertyId) event.getItemId()).getQName();
-                    if (refresh(pName, event.getType())) {
-                        setStatus(Status.MODIFIED);
+                if (QName.JCR_UUID.equals(name) || QName.JCR_MIXINTYPES.equals(name)) {
+                    try {
+                        PropertyState ps = getPropertyState(name);
+                        adjustNodeState(this, new PropertyState[] {ps});
+                    } catch (ItemStateException e) {
+                        // should never occur.
+                        log.error("Internal error while updating node state.", e);
-                } else {
-                    // ILLEGAL
-                    throw new IllegalArgumentException("Illegal event type " + event.getType() + " for NodeState.");
+    //----------------------------------------------------< Session - State >---
-     * Returns true, if the uuid or the mixin types of this state have been
-     * modified.
-     *
-     * @param propertyName
-     * @param eventType
-     * @return
+     * {@inheritDoc}
+     * @see ItemState#refresh(Collection,ChangeLog)
-    private boolean refresh(QName propertyName, int eventType) {
-        if (QName.JCR_UUID.equals(propertyName)) {
-            // TODO: to be fixed.
-        } else if (QName.JCR_MIXINTYPES.equals(propertyName)) {
-            if (eventType == Event.PROPERTY_REMOVED) {
-                mixinTypeNames = QName.EMPTY_ARRAY;
-            } else { // added or changed
-                try {
-                    PropertyState ps = getPropertyState(propertyName);
-                    QValue[] values = ps.getValues();
-                    QName[] newMixins = new QName[values.length];
-                    for (int i = 0; i < values.length; i++) {
-                        newMixins[i] = QName.valueOf(values[i].getString());
-                    }
-                    mixinTypeNames = newMixins;
-                } catch (ItemStateException e) {
-                    // should never occur.
-                    log.error("Internal error while updating mixin types.", e);
-                } catch (RepositoryException e) {
-                    // should never occur.
-                    log.error("Internal error while updating mixin types.", e);
+    void refresh(Collection events, ChangeLog changeLog) throws IllegalStateException {
+
+        // remember parent states that have need to adjust their uuid/mixintypes
+        // or that got a new child entry added or existing entries removed.
+        HashMap modParents = new HashMap();
+
+        // process deleted states from the changelog
+        for (Iterator it = changeLog.deletedStates(); it.hasNext();) {
+            ItemState state = (ItemState) it.next();
+            state.setStatus(Status.REMOVED);
+            state.overlayedState.setStatus(Status.REMOVED);
+
+            // adjust parent states unless the parent is removed as well
+            NodeState parent = state.getParent();
+            if (!changeLog.deletedStates.contains(parent)) {
+                NodeState overlayedParent = (NodeState) parent.overlayedState;
+                if (state.isNode()) {
+                    overlayedParent.childNodeEntries.remove((NodeState)state.overlayedState);
+                } else {
+                    overlayedParent.removePropertyEntry(state.overlayedState.getQName());
+                modifiedParent(parent, state, modParents);
-            return true;
+            // don't remove processed state from changelog, but from event list
+            // state on changelog is used for check if parent is deleted as well.
+            removeEvent(events, state);
-        return false;
+
+        // process added states from the changelog. since the changlog maintains
+        // LinkedHashSet for its entries, the iterator will not return a added
+        // entry before its NEW parent.
+        for (Iterator it = changeLog.addedStates(); it.hasNext();) {
+            ItemState addedState = (ItemState) it.next();
+            NodeState parent = addedState.getParent();
+            // TODO: only retrieve overlayed state, if necessary
+            try {
+                // adjust parent child-entries
+                NodeState overlayedParent = (NodeState) parent.overlayedState;
+                QName addedName = addedState.getQName();
+                if (addedState.isNode()) {
+                    int index = parent.getChildNodeEntry((NodeState) addedState).getIndex();
+                    ChildNodeEntry cne;
+                    if (overlayedParent.hasChildNodeEntry(addedName, index)) {
+                        cne = overlayedParent.getChildNodeEntry(addedName, index);
+                    } else {
+                        cne = overlayedParent.childNodeEntries.add(addedState.getQName(), null, index);
+                    }
+                    NodeState overlayed = cne.getNodeState();
+                    if (overlayed.getUUID() != null) {
+                        overlayedParent.childNodeEntries.replaceEntry(overlayed);
+                    }
+                    addedState.connect(overlayed);
+                } else {
+                    ChildPropertyEntry pe;
+                    if (overlayedParent.hasPropertyName(addedName)) {
+                        pe = (ChildPropertyEntry) overlayedParent.properties.get(addedName);
+                    } else {
+                        pe = PropertyReference.create(overlayedParent, addedName, overlayedParent.isf,  overlayedParent.idFactory);
+                        overlayedParent.addPropertyEntry(pe);
+                    }
+                    addedState.connect(pe.getPropertyState());
+                }
+
+                // make sure the new state gets updated (e.g. uuid created by server)
+                addedState.reset();
+                // and mark the added-state existing
+                addedState.setStatus(Status.EXISTING);
+                // if parent is modified -> remember for final status reset
+                if (parent.getStatus() == Status.EXISTING_MODIFIED) {
+                    modifiedParent(parent, addedState, modParents);
+                }
+
+                it.remove();
+                removeEvent(events, addedState);
+            } catch (ItemStateException e) {
+                log.error("Internal error.", e);
+            }
+        }
+
+        for (Iterator it = changeLog.modifiedStates(); it.hasNext();) {
+            ItemState modState = (ItemState) it.next();
+            if (modState.isNode()) {
+                continue;
+            }
+            // push changes down to overlayed state
+            int type = ((PropertyState) modState).getType();
+            QValue[] values = ((PropertyState) modState).getValues();
+            ((PropertyState) modState.overlayedState).init(type, values);
+
+            modState.setStatus(Status.EXISTING);
+            // if property state defines a modified jcr:mixinTypes
+            // the parent is listed as modified state and needs to be
+            // processed at the end.
+            if (isUuidOrMixin(modState.getQName())) {
+                modifiedParent(this, modState, modParents);
+            }
+            // remove the processed event from the set
+            it.remove();
+            removeEvent(events, modState);
+        }
+
+        /* process all parent states that need their uuid or mixin-types being
+           adjusted because that property has been added or modified */
+        for (Iterator it = modParents.keySet().iterator(); it.hasNext();) {
+            NodeState parent = (NodeState) it.next();
+            List l = (List) modParents.get(parent);
+            adjustNodeState(parent, (PropertyState[]) l.toArray(new PropertyState[l.size()]));
+        }
+
+        /* finally check if all entries in the changelog have been processed
+           and eventually force a reload in order not to have any states with
+           wrong transient status floating around. */
+        Iterator[] its = new Iterator[] {changeLog.addedStates(), changeLog.deletedStates(), changeLog.modifiedStates()};
+        IteratorChain chain = new IteratorChain(its);
+        while (chain.hasNext()) {
+            ItemState state = (ItemState) chain.next();
+            if (!(state.getStatus() == Status.EXISTING || state.getStatus() == Status.REMOVED)) {
+                // error: state has not been processed
+                // TODO: discard state and force reload of all data
+            }
+        }
-    //----------------------------------------------------< Session - State >---
-                uuid = wspState.uuid;
-                nodeTypeName = wspState.nodeTypeName;
-                definition = wspState.definition;
-
-                init(wspState.getMixinTypeNames(), wspState.getChildNodeEntries(), wspState.getPropertyNames(), wspState.getNodeReferences());
-            }
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     * @see ItemState#merge()
-     */
-    synchronized void merge() {
-        checkIsSessionState();
-
-        if (overlayedState != null) {
-            synchronized (overlayedState) {
-                NodeState wspState = (NodeState) overlayedState;
-                name = wspState.name;
-                uuid = wspState.uuid;
+                setUUID(wspState.uuid);
-                references = wspState.getNodeReferences();
-                // search for removed properties
-                Collection wspProps = wspState.getPropertyNames();
+                // remove all entries in the attic
+                propertiesInAttic.clear();
+
+                // merge prop-names
+                Collection wspPropNames = wspState.getPropertyNames();
+                for (Iterator it = wspPropNames.iterator(); it.hasNext();) {
+                    QName propName = (QName) it.next();
+                    if (!hasPropertyName(propName)) {
+                        addPropertyEntry(PropertyReference.create(this, propName, isf, idFactory));
+                    }
+                }
-                    ChildPropertyEntry pe = (ChildPropertyEntry) properties.get((QName) it.next());
-                    if (pe.isAvailable()) {
-                        try {
-                            PropertyState ps = getPropertyState(pe.getName());
-                            if (ps.getStatus() == Status.REMOVED || ps.getStatus() == Status.STALE_DESTROYED) {
-                                it.remove();
-                            }
-                        } catch (ItemStateException e) {
-                            log.error("Internal error while merging item node states.", e);
-                        }
-                    } else if (!wspProps.contains(pe.getName())) {
-                        // not available and not present in wsp-layer any more.
+                    // remove all prop-entries in the session state that are
+                    // not present in the wsp-state.
+                    if (!wspPropNames.contains(it.next())) {
-                // add missing property entries
-                for (Iterator it = wspProps.iterator(); it.hasNext();) {
-                    QName propName = (QName) it.next();
-                    if (!hasPropertyName(propName)) {
-                        properties.put(propName, PropertyReference.create(this, propName, isf, idFactory));
-                    } // else property is already listed
-                }
-                Collection wspEntries = wspState.getChildNodeEntries();
-                // remove child entries, that are 'REMOVED' in the wsp layer
-                Set toRemove = new HashSet();
+                // merge child node entries
+                for (Iterator it = wspState.getChildNodeEntries().iterator(); it.hasNext();) {
+                    ChildNodeEntry cne = (ChildNodeEntry) it.next();
+                    int index = cne.getIndex();
+                    if (!childNodeEntries.contains(cne.getName(), index, cne.getUUID())) {
+                        childNodeEntries.add(cne.getName(), cne.getUUID(), index);
+                    }
+                }
+                List toRemove = new ArrayList();
-                    if (cne.isAvailable()) {
-                        try {
-                            NodeState ns = cne.getNodeState();
-                            if (ns.getStatus() == Status.REMOVED) {
-                                toRemove.add(cne);
-                            }
-                        } catch (ItemStateException e) {
-                            // should not occur
-                            log.error("Internal error while merging item node states.", e);
-                        }
-                    } else if (wspState.getChildNodeEntries(cne.getName()).isEmpty()) {
+                    if (!wspState.childNodeEntries.contains(cne.getName(), cne.getIndex(), cne.getUUID())) {
-                    } // TODO: clean up same-named siblings
+                    }
-
-                // add missing child entries
-                for (Iterator it = wspEntries.iterator(); it.hasNext();) {
-                    ChildNodeEntry wspEntry = (ChildNodeEntry) it.next();
-                    List namedEntries = getChildNodeEntries(wspEntry.getName());
-                    if (namedEntries.isEmpty()) {
-                        // simple case: no cne with the given name
-                        childNodeEntries.add(wspEntry.getName(), wspEntry.getUUID());
-                    } else {
-                        List wspCnes = wspState.getChildNodeEntries(wspEntry.getName());
-                        // TODO: compare sn-siblings an add missing ones
-                    }
-                }
+                // set the node references
+                references = wspState.references;
-        parent.childNodeStateRemoved(this);
+        getParent().childNodeStateRemoved(this);
-                parent.childNodeStateRemoved(this);
+                getParent().childNodeStateRemoved(this);
-                parent.childNodeStateRemoved(this);
+                getParent().childNodeStateRemoved(this);
-                parent.childNodeStateRemoved(this);
+                getParent().childNodeStateRemoved(this);
-     * @see ItemState#collectTransientStates(Set)
+     * @see ItemState#collectTransientStates(Collection)
-    void collectTransientStates(Set transientStates) {
+    void collectTransientStates(Collection transientStates) {
-     * Sets the names of this node's mixin types.
-     *
-     * @param mixinTypeNames set of names of mixin types
-     */
-    synchronized void setMixinTypeNames(QName[] mixinTypeNames) {
-        checkIsSessionState();
-
-        if (mixinTypeNames != null) {
-            this.mixinTypeNames = mixinTypeNames;
-        } else {
-            this.mixinTypeNames = new QName[0];
-        }
-        markModified();
-    }
-
-    /**
-     * @param uuid  the uuid of the child node state or <code>null</code> if
-     *              <code>child</code> cannot be identified with a uuid.
-    synchronized void addChildNodeState(NodeState child, String uuid) {
+    synchronized void addChildNodeState(NodeState child) {
-
+
-                properties.remove(propertyName);
+                removePropertyEntry(propertyName);
-        properties.put(propertyName, PropertyReference.create(propState, isf, idFactory));
+        addPropertyEntry(PropertyReference.create(propState, isf, idFactory));
-            properties.remove(propState.getQName());
+            removePropertyEntry(propState.getQName());
-
-
-        if (parent == null) {
+        if (getParent() == null) {
+    /**
+     *
+     * @param ps
+     * @return
+     * @throws RepositoryException
+     */
+    private static QName[] getMixinNames(PropertyState ps) throws RepositoryException {
+        assert QName.JCR_MIXINTYPES.equals(ps.getQName());
+
+        QValue[] values = ps.getValues();
+        QName[] newMixins = new QName[values.length];
+        for (int i = 0; i < values.length; i++) {
+            newMixins[i] = QName.valueOf(values[i].getString());
+        }
+        return newMixins;
+    }
+
+    private static boolean isUuidOrMixin(QName propName) {
+        return QName.JCR_UUID.equals(propName) || QName.JCR_MIXINTYPES.equals(propName);
+    }
+
+    private static void modifiedParent(NodeState parent, ItemState child, Map modParents) {
+        List l;
+        if (modParents.containsKey(parent)) {
+            l = (List) modParents.get(parent);
+        } else {
+            l = new ArrayList(2);
+            modParents.put(parent, l);
+        }
+        if (child != null && !child.isNode() && isUuidOrMixin(child.getQName())) {
+            l.add(child);
+        }
+    }
+
+    /**
+     *
+     * @param parent
+     * @param props
+     */
+    private static void adjustNodeState(NodeState parent, PropertyState[] props) {
+        NodeState overlayed = (parent.isWorkspaceState()) ? parent : (NodeState) parent.overlayedState;
+        NodeState sState = (parent.isWorkspaceState()) ? (NodeState) overlayed.getSessionState() : parent;
+
+        if (overlayed != null) {
+            for (int i = 0; i < props.length; i++) {
+                try {
+                    if (QName.JCR_UUID.equals(props[i].getQName())) {
+                        String uuid = (props[i].getStatus() == Status.REMOVED) ? null : props[i].getValue().getString();
+                        sState.setUUID(uuid);
+                        overlayed.setUUID(uuid);
+                    } else if (QName.JCR_MIXINTYPES.equals(props[i].getQName())) {
+                        QName[] mixins = (props[i].getStatus() == Status.REMOVED) ? QName.EMPTY_ARRAY : getMixinNames(props[i]);
+
+                        sState.mixinTypeNames = mixins;
+                        overlayed.mixinTypeNames = mixins;
+                    } // else: ignore.
+                } catch (RepositoryException e) {
+                    // should never occur.
+                    log.error("Internal error while updating node state.", e);
+                }
+            }
+
+            // make sure all other modifications on the overlayed state are
+            // reflected on the session-state.
+            sState.reset();
+            // make sure, the session-state gets its status reset to Existing.
+            if (sState.getStatus() == Status.EXISTING_MODIFIED) {
+                sState.setStatus(Status.EXISTING);
+            }
+        } else {
+            // should never occur.
+            log.warn("Error while adjusting nodestate: Overlayed state is missing.");
+        }
+    }
+         *
+         * @param name
+         * @param index
+         * @param uuid
+         * @return
+         */
+        private boolean contains(QName name, int index, String uuid) {
+            if (!nameMap.containsKey(name)) {
+                // no matching child node entry
+                return false;
+            }
+            Object o = nameMap.get(name);
+            if (o instanceof List) {
+                // SNS
+                for (Iterator it = ((List) o).iterator(); it.hasNext(); ) {
+                    LinkedEntries.LinkNode n = (LinkedEntries.LinkNode) it.next();
+                    ChildNodeEntry cne = n.getChildNodeEntry();
+                    if (uuid == null) {
+                        if (cne.getIndex() == index) {
+                            return true;
+                        }
+                    } else if (uuid.equals(cne.getUUID())) {
+                        return true;
+                    }
+                }
+                // no matching entry found
+                return false;
+            } else {
+                // single child node with this name
+                ChildNodeEntry cne = ((LinkedEntries.LinkNode) o).getChildNodeEntry();
+                if (uuid == null) {
+                    return cne.getUUID() == null;
+                } else {
+                    return uuid.equals(cne.getUUID());
+                }
+            }
+        }
+
+        /**
+         * 
+         * @param uuid
+         * @return
+         */
+        private ChildNodeEntry get(String uuid) {
+            for (Iterator it = entries.iterator(); it.hasNext();) {
+                LinkedEntries.LinkNode ln = (LinkedEntries.LinkNode) it.next();
+                ChildNodeEntry cne = ln.getChildNodeEntry();
+                if (cne.getUUID() == uuid) {
+                    return cne;
+                }
+            }
+            return null;
+        }
+
+        /**
-                        if (cne.isAvailable() && cne.getNodeState() == nodeState) {
+                        if (cne.getNodeState() == nodeState) {
-                    if (cne.isAvailable() && cne.getNodeState() == nodeState) {
+                    if (cne.getNodeState() == nodeState) {
-                return Collections.singletonList(
-                        ((LinkedEntries.LinkNode) obj).getChildNodeEntry());
+                return Collections.singletonList(((LinkedEntries.LinkNode) obj).getChildNodeEntry());
-            List siblings = null;
-            Object obj = nameMap.get(nodeName);
-            if (obj != null) {
-                if (obj instanceof List) {
-                    // map entry is a list of siblings
-                    siblings = (List) obj;
-                } else {
-                    // map entry is a single child node entry,
-                    // convert to siblings list
-                    siblings = new ArrayList();
-                    siblings.add(obj);
-                    nameMap.put(nodeName, siblings);
-                }
-            }
+            ChildNodeEntry cne = ChildNodeReference.create(NodeState.this, nodeName, uuid, isf, idFactory);
+            add(cne);
+            return cne;
+        }
-            ChildNodeEntry entry = ChildNodeReference.create(NodeState.this, nodeName, uuid, isf, idFactory);
-            LinkedEntries.LinkNode ln = entries.add(entry);
+        /**
+         * Insert a new childnode entry at the position indicated by index.
+         * @param nodeName
+         * @param uuid
+         * @param index
+         * @return
+         */
+        ChildNodeEntry add(QName nodeName, String uuid, int index) {
+            ChildNodeEntry cne = add(nodeName, uuid);
+            // TODO: in case of SNS, move new cne to the right position.
+            return cne;
+        }
-            if (siblings != null) {
-                siblings.add(ln);
-            } else {
-                nameMap.put(nodeName, ln);
-            }
-
-            return entry;
+        /**
+         * Adds a <code>childNode</code> to the end of the list.
+         *
+         * @param childState the <code>NodeState</code> to add.
+         * @return the <code>ChildNodeEntry</code> which was created for
+         *         <code>childNode</code>.
+         */
+        ChildNodeEntry add(NodeState childState) {
+            ChildNodeEntry cne = ChildNodeReference.create(childState, isf, idFactory);
+            add(cne);
+            return cne;
-         * Adds a <code>childNode</code> to the end of the list.
-         *
-         * @param childNode the <code>NodeState</code> to add.
-         * @return the <code>ChildNodeEntry</code> which was created for
-         *         <code>childNode</code>.
-         */
-        ChildNodeEntry add(NodeState childNode) {
-            ChildNodeEntry cne = ChildNodeReference.create(childNode, isf, idFactory);
-            add(cne);
-            return cne;
-        }
-
-        /**
-         *                   reordered to.
+         * reordered to.
-         *                                  <code>beforeNode</code> does not
-         *                                  have a <code>ChildNodeEntry</code>
-         *                                  in this <code>ChildNodeEntries</code>.
+         * <code>beforeNode</code> does not have a <code>ChildNodeEntry</code>
+         * in this <code>ChildNodeEntries</code>.
+         * If the given child state got a (new) uuid assigned or its removed,
+         * its childEntry must be adjusted.
+         *
+         * @param childState
+         */
+        private void replaceEntry(NodeState childState) {
+            // NOTE: test if child-state needs to get a new entry not checked here.
+            try {
+                Object replaceObj = nameMap.get(childState.getQName());
+                LinkedEntries.LinkNode ln = getLinkNode(replaceObj, childState);
+                ChildNodeEntry newCne = ChildNodeReference.create(childState, isf, idFactory);
+                entries.replaceNode(ln, newCne);
+            } catch (NoSuchItemStateException e) {
+                log.error("Internal error.", e);
+            }
+        }
+
+        /**
+         * Replace the value of the given LinkNode with a new childNodeEntry
+         * value.
+         *
+         * @param node
+         * @param value
+         */
+        void replaceNode(LinkNode node, ChildNodeEntry value) {
+            updateNode(node, value);
+        }
+
+        /**

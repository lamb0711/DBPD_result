fixed JCR-59: NodeType.canSetProperty() does not allow for type conversion

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@160284 13f79535-47bb-0310-9956-ffa450edef68

-     * Note that the <i>protected</i> flag is not checked.
+     * Note that the <i>protected</i> flag is not checked. Also note that no
+     * type conversions are attempted if the type of the given values does not
+     * match the required type as specified in the given definition.
-            PropertyDefImpl def =
-                    getApplicablePropertyDef(name, value.getType(), false);
+            PropertyDefImpl def;
+            try {
+                // try to get definition that matches the given value type
+                def = getApplicablePropertyDef(name, value.getType(), false);
+            } catch (ConstraintViolationException cve) {
+                // fallback: ignore type
+                def = getApplicablePropertyDef(name, PropertyType.UNDEFINED, false);
+            }
-            InternalValue internalValue = InternalValue.create(value, nsResolver);
+            int targetType;
+            if (def.getRequiredType() != PropertyType.UNDEFINED &&
+                    def.getRequiredType() != value.getType()) {
+                // type conversion required
+                targetType = def.getRequiredType();
+            } else {
+                // no type conversion required
+                targetType = value.getType();
+            }
+            // create InternalValue from Value and perform
+            // type conversion as necessary
+            InternalValue internalValue = InternalValue.create(value, targetType,
+                    nsResolver);
-            int type = (values.length == 0) ? PropertyType.UNDEFINED : values[0].getType();
-            PropertyDefImpl def = getApplicablePropertyDef(name, type, true);
+            // determine type of values
+            int type = PropertyType.UNDEFINED;
+            for (int i = 0; i < values.length; i++) {
+                if (type == PropertyType.UNDEFINED) {
+                    type = values[i].getType();
+                } else if (type != values[i].getType()) {
+                    // inhomogeneous types
+                    return false;
+                }
+            }
+            PropertyDefImpl def;
+            try {
+                // try to get definition that matches the given value type
+                def = getApplicablePropertyDef(name, type, true);
+            } catch (ConstraintViolationException cve) {
+                // fallback: ignore type
+                def = getApplicablePropertyDef(name, PropertyType.UNDEFINED, true);
+            }
+
+            // determine target type
+            int targetType;
+            if (def.getRequiredType() != PropertyType.UNDEFINED &&
+                    def.getRequiredType() != type) {
+                // type conversion required
+                targetType = def.getRequiredType();
+            } else {
+                // no type conversion required
+                targetType = type;
+            }
+
-                    InternalValue internalValue = InternalValue.create(values[i], nsResolver);
+                    // create InternalValue from Value and perform
+                    // type conversion as necessary
+                    InternalValue internalValue =
+                            InternalValue.create(values[i], targetType,
+                                    nsResolver);
-            InternalValue[] internalValues = (InternalValue[]) list.toArray(new InternalValue[list.size()]);
+            InternalValue[] internalValues =
+                    (InternalValue[]) list.toArray(new InternalValue[list.size()]);

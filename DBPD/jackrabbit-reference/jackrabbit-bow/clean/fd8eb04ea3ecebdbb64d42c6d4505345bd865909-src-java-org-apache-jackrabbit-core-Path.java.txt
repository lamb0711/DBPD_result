optimized the following methods:

Node.addNode
Node.getProperty
Node.hasProperty
Node.getNode
Node.hasNode
Node.save

avoid unnecessary throwing & catching of exceptions
avoid unnecessary building & resolving of paths
avoid unnecessary regexp evaluations




git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@125788 13f79535-47bb-0310-9956-ffa450edef68

-    public static final class PathBuilder implements Cloneable {
+    /**
+     * package private inner class used to build a path from path elements;
+     * this class does not validate the format of the path elements!
+     */
+    static final class PathBuilder implements Cloneable {
-        public PathBuilder() {
+        PathBuilder() {
-        public PathBuilder(PathElement[] elements) {
+        PathBuilder(PathElement[] elements) {
-        public void addRoot() {
+        void addRoot() {
-        public void addAll(PathElement[] elements) {
+        void addAll(PathElement[] elements) {
-        public void addFirst(String nameSpaceURI, String localName) {
+        void addFirst(String nameSpaceURI, String localName) {
-        public void addFirst(String nameSpaceURI, String localName, int index) {
+        void addFirst(String nameSpaceURI, String localName, int index) {
-        public void addFirst(QName name) {
+        void addFirst(QName name) {
-        public void addFirst(QName name, int index) {
+        void addFirst(QName name, int index) {
-        public void addLast(String nameSpaceURI, String localName) {
+        void addLast(String nameSpaceURI, String localName) {
-        public void addLast(String nameSpaceURI, String localName, int index) {
+        void addLast(String nameSpaceURI, String localName, int index) {
-        public void addLast(QName name) {
+        void addLast(QName name) {
-        public void addLast(QName name, int index) {
+        void addLast(QName name, int index) {
-        public Path getPath() throws MalformedPathException {
+        Path getPath() throws MalformedPathException {
-                String localName = elements[i].getName().getLocalName();
-                Matcher matcher = PATH_ELEMENT_PATTERN.matcher(localName);
-                if (!matcher.matches()) {
-                    // illegal syntax for path element
-                    throw new MalformedPathException(localName + "' is not a legal path element");
-                }
+        public boolean denotesCurrent() {
+            return false;
+        }
+
+        // PathElement override
+        public boolean denotesParent() {
+            return false;
+        }
+
+        // PathElement override
+        public boolean denotesName() {
+            return false;
+        }
+
+        // PathElement override
+        public boolean denotesRoot() {
+            return false;
+        }
+
+        // PathElement override
+        public boolean denotesCurrent() {
+            return true;
+        }
+
+        // PathElement override
+        public boolean denotesParent() {
+            return false;
+        }
+
+        // PathElement override
+        public boolean denotesName() {
+            return false;
+        }
+
+        // PathElement override
+        public boolean denotesRoot() {
+            return false;
+        }
+
+        // PathElement override
+        public boolean denotesCurrent() {
+            return false;
+        }
+
+        // PathElement override
+        public boolean denotesParent() {
+            return true;
+        }
+
+        // PathElement override
+        public boolean denotesName() {
+            return false;
+        }
+
+        // PathElement override
+        /**
+         * Returns <code>true</code> if this element denotes the <i>root</i> element,
+         * otherwise returns <code>false</code>.
+         *
+         * @return <code>true</code> if this element denotes the <i>root</i>
+         *         element; otherwise <code>false</code>
+         */
-            return false;
+            return equals(ROOT_ELEMENT);
+        }
+
+        /**
+         * Returns <code>true</code> if this element denotes the <i>parent</i>
+         * ('..') element, otherwise returns <code>false</code>.
+         *
+         * @return <code>true</code> if this element denotes the <i>parent</i>
+         *         element; otherwise <code>false</code>
+         */
+        public boolean denotesParent() {
+            return equals(PARENT_ELEMENT);
+        }
+
+        /**
+         * Returns <code>true</code> if this element denotes the <i>current</i>
+         * ('.') element, otherwise returns <code>false</code>.
+         *
+         * @return <code>true</code> if this element denotes the <i>current</i>
+         *         element; otherwise <code>false</code>
+         */
+        public boolean denotesCurrent() {
+            return equals(CURRENT_ELEMENT);
+        }
+
+        /**
+         * Returns <code>true</code> if this element represents a regular name
+         * (i.e. neither root, '.' nor '..'), otherwise returns <code>false</code>.
+         *
+         * @return <code>true</code> if this element represents a regular name;
+         *         otherwise <code>false</code>
+         */
+        public boolean denotesName() {
+            return !denotesRoot() && !denotesParent() && !denotesCurrent();
-    private static PathElement[] parse(String jcrPath, PathElement[] master, NamespaceResolver resolver)
+    private static PathElement[] parse(String jcrPath, PathElement[] master,
+                                       NamespaceResolver resolver)

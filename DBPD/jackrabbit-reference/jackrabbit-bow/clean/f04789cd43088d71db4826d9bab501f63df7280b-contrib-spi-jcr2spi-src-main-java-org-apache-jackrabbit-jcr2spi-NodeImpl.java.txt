work in progress

jcr2spi
- HierarchyManager: fixing methods with ItemId param
- HierarchyManagerImpl(s): removing unused methods
- ItemManagerImpl: replacing NodeId as cacheKey
- ItemImpl: remove ISM field

jcr2spi/xml
- ImporterImpl renamed to SessionImporter (used for s-import only)
- xml import: Use UUID String instead of creating NodeIds
- ReferenceChangeTracker: remove usage of spi NodeId

jcr2spi/state
- SessionItemStateManager: ValueFactory not needed since QPropertyDefinition returns qualified values.

jcr2spi/util
- LogUtil: add 'saveGetJCRName' utility method

jcr2spi/locking
- locking: LockManager to use NodeState instead of NodeId
- locking: removing locktoken from Session checks if Session is lock holder

jcr2spi/query
- NodeIteratorImpl: fix commented code, that allows to retrieve
  search results from IdIterator returned from QueryInfo
- minor reformatting, javadoc

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@430791 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.state.ItemStateManager;
+import org.apache.jackrabbit.jcr2spi.util.LogUtil;
-        // paranoid sanity check
+        // make sure the nodetype name is valid
-            /**
-             * todo need proper way of handling inconsistent/corrupt node type references
-             * e.g. 'flag' nodes that refer to non-registered node types
-             */
-            log.warn("Fallback to nt:unstructured due to unknown node type '" + nodeTypeName + "' of node " + safeGetJCRPath());
-            primaryTypeName = QName.NT_UNSTRUCTURED;
+            // DIFF JR: jr defines nt:unstructured as fallback.
+            // should not occur. Since nodetypes are defined by the 'server'
+            // its not possible to determine a fallback nodetype that is
+            // always available.
+            throw new IllegalArgumentException("Unknown nodetype " + LogUtil.saveGetJCRName(nodeTypeName, session.getNamespaceResolver()));
-        } catch (NoPrefixDeclaredException npde) {
+        } catch (NoPrefixDeclaredException e) {
-            String msg = "internal error: encountered unregistered namespace " + qName.getNamespaceURI();
+            String msg = "Internal error while resolving qualified name " + qName.toString();
-            throw new RepositoryException(msg, npde);
+            throw new RepositoryException(msg, e);
-            String msg = "root node doesn't have a parent";
+            String msg = "Root node doesn't have a parent.";
-                String msg = "Cannot add a node to property " + parentPath;
+                String msg = "Cannot add a node to property " + LogUtil.safeGetJCRPath(parentPath, session.getNamespaceResolver());
+                // should never occur
-            throw new ItemNotFoundException(safeGetJCRPath() + " has no child node with name " + srcChildRelPath);
+            throw new ItemNotFoundException("Node " + safeGetJCRPath() + " has no child node with name " + srcChildRelPath);
-            throw new ItemNotFoundException(safeGetJCRPath() + " has no child node with name " + destChildRelPath);
+            throw new ItemNotFoundException("Node " + safeGetJCRPath() + " has no child node with name " + destChildRelPath);
-        itemStateMgr.execute(op);
+        session.getSessionItemStateManager().execute(op);
-                // TODO: check if is correct to avoid any validation exception that way
+                // TODO: check if is correct to avoid any validation exception
-                // TODO: check if is correct to avoid any validation exception that way
+                // TODO: check if is correct to avoid any validation exception
-        /**
-         * IMPORTANT:
-         * an implementation of Node.getNodes()
-         * must not use a class derived from TraversingElementVisitor
-         * to traverse the hierarchy because this would lead to an infinite
-         * recursion!
-         */
+        // NOTE: Don't use a class derived from TraversingElementVisitor to traverse
+        // the child nodes because this would lead to an infinite recursion.
-            String msg = "failed to list the child nodes of " + safeGetJCRPath();
+            String msg = "Failed to list the child nodes of " + safeGetJCRPath();
-            String msg = "failed to list the child nodes of " + safeGetJCRPath();
+            String msg = "Failed to list the child nodes of " + safeGetJCRPath();
-            throw new ItemNotFoundException("No primary item present on Node " + getPath());
+            throw new ItemNotFoundException("No primary item present on Node " + safeGetJCRPath());
-            throw new ItemNotFoundException("Primary item " + name + " does not exist on Node " + getPath());
+            throw new ItemNotFoundException("Primary item " + name + " does not exist on Node " + safeGetJCRPath());
+        // Node is referenceable -> NodeId must contain a UUID part
+            ItemStateManager itemStateMgr = session.getItemStateManager();
-            String msg = "Unable to retrieve REFERENCE properties that refer to " + getPath();
+            String msg = "Unable to retrieve REFERENCE properties that refer to " + safeGetJCRPath();
-        itemStateMgr.execute(op);
+        session.getSessionItemStateManager().execute(op);
-                throw new ConstraintViolationException(mixinName + " can not be removed: the node is being referenced through at least one property of type REFERENCE");
+                throw new ConstraintViolationException("Mixin type " + mixinName + " can not be removed: the node is being referenced through at least one property of type REFERENCE");
-        itemStateMgr.execute(op);
+        session.getSessionItemStateManager().execute(op);
-            log.debug("Cannot add mixin '" + mixinName + "' for the following reason: " + e.getMessage());
+            log.debug("Cannot add mixin '" + mixinName + "': " + e.getMessage());
-            log.debug("Cannot add mixin '" + mixinName + "' for the following reason: " + e.getMessage());
+            log.debug("Cannot add mixin '" + mixinName + "': " + e.getMessage());
-            session.getVersionManager().checkin(getNodeId());
+            session.getVersionManager().checkin(getNodeState());
-            log.debug("Node " + getPath() + " is already checked in.");
+            // nothing to do
+            log.debug("Node " + safeGetJCRPath() + " is already checked in.");
-            session.getVersionManager().checkout(getNodeId());
+            session.getVersionManager().checkout(getNodeState());
-            log.debug("Node " + getPath() + " is already checked out.");
+            // nothing to do
+            log.debug("Node " + safeGetJCRPath() + " is already checked out.");
-            String msg = "Unable to finish merge. Node is checked-in: " + safeGetJCRPath();
+            String msg = "Unable to resolve merge conflict. Node is checked-in: " + safeGetJCRPath();
-            String msg = "Unable to finish merge. Specified version is not in jcr:mergeFailed property: " + safeGetJCRPath();
+            String msg = "Unable to resolve merge conflict. Specified version is not in jcr:mergeFailed property: " + safeGetJCRPath();
-            throw new RepositoryException("Unexpected error: Failed to retrieve a valid ID for version " + version.getPath());
+            throw new RepositoryException("Incompatible Version object :" + version);
-                        throw new RepositoryException("Unexpected error: NodeState expected.");
+                        // should not occur
+                        throw new RepositoryException("Merge failed with internal error: NodeState expected.");
-                    throw new RepositoryException("Unexpected error", e);
+                    // should not occur
+                    throw new RepositoryException(e);
-        } catch (NameException be) {
+        } catch (NameException e) {
-            String msg = "internal error: failed to determine relative path";
-            log.error(msg, be);
-            throw new RepositoryException(msg, be);
+            String msg = "Internal error: failed to determine relative path";
+            log.error(msg, e);
+            throw new RepositoryException(msg, e);
-        return session.getVersionManager().isCheckedOut(getNodeId());
+        return session.getVersionManager().isCheckedOut(getNodeState());
-            if (session.getItemManager().itemExists(parentPath)) {
+            if (itemMgr.itemExists(parentPath)) {
-                Item parent = session.getItemManager().getItem(parentPath);
+                Item parent = itemMgr.getItem(parentPath);
-        return session.getLockManager().lock(getNodeId(), this, isDeep, isSessionScoped);
+        return session.getLockManager().lock(getNodeState(), isDeep, isSessionScoped);
-        return session.getLockManager().getLock(getNodeId());
+        return session.getLockManager().getLock(getNodeState());
-        session.getLockManager().unlock(getNodeId());
+        session.getLockManager().unlock(getNodeState());
-            return (lMgr.isLocked(getNodeId()) && lMgr.getLock(getNodeId()).getNode().isSame(this));
+            return (lMgr.isLocked(getNodeState()) && lMgr.getLock(getNodeState()).getNode().isSame(this));
-        return session.getLockManager().isLocked(getNodeId());
+        return session.getLockManager().isLocked(getNodeState());
-        return session.getHierarchyManager().getQName(getNodeState());
+        NodeState parentState = getNodeState().getParent();
+        if (parentState == null) {
+            // shortcut. the given state represents the root or an orphaned node
+            return QName.ROOT;
+        }
+
+        NodeId nodeId = getNodeState().getNodeId();
+        ChildNodeEntry entry = parentState.getChildNodeEntry(nodeId);
+        if (entry == null) {
+            String msg = "Failed to retrieve qualified name of Node " + nodeId;
+            log.debug(msg);
+            throw new RepositoryException(msg);
+        }
+        return entry.getName();
-        session.getLockManager().checkLock(getNodeId());
+        session.getLockManager().checkLock(getNodeState());
-        itemStateMgr.execute(an);
+        session.getSessionItemStateManager().execute(an);
-        itemStateMgr.execute(op);
+        session.getSessionItemStateManager().execute(op);
-                log.error(mixinName + ": not a mixin node type");
+                log.error(mixin.getName() + ": not a mixin node type");
-                log.error(mixinName + ": already contained in primary node type");
+                log.error(mixin.getName() + ": already contained in primary node type");
-                log.error(mixinName + ": already contained in mixin types");
+                log.error(mixin.getName() + ": already contained in mixin types");
-        return session.getValidator().getApplicablePropertyDefinition(propertyName, type, multiValued, getNodeState());
+        ItemStateValidator validator = session.getValidator();
+        return validator.getApplicablePropertyDefinition(propertyName, type, multiValued, getNodeState());

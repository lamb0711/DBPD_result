work in progress

- version always protected
- versionHistory always protected
- fix Node.getReferences && reference properties
- mixinTypes are 'active' upon save only (and not before). therefore
  cleanup after removeMixin is done only after save.
  adding new states defined by a new mixin are only added after the
  node has been saved.
- nodestates identified by a uuid only were created a second time upon
  ChildNodeEntry.resolve => fix needs to be improved
- Events/ChangeLog are processed by the save-target state
- ChangeLog.persisted not used any more

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@467956 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Iterator;
+import java.util.Collections;
-     * accepts call to {@link #refresh(Event, ChangeLog)}, while the latter
+     * accepts call to {@link #refresh(Event)}, while the latter
+     * The <code>ItemStateFactory</code> which is used to create new
+     * <code>ItemState</code> instances.
+     */
+    final ItemStateFactory isf;
+
+    /**
-    protected ItemState(NodeState parent, int initialStatus, IdFactory idFactory,
+    protected ItemState(NodeState parent, int initialStatus, ItemStateFactory isf, IdFactory idFactory,
+        this.isf = isf;
-                        int initialStatus, IdFactory idFactory) {
+                        int initialStatus, ItemStateFactory isf, IdFactory idFactory) {
+        this.isf = isf;
-        return status == Status.EXISTING || status == Status.EXISTING_MODIFIED || status == Status.NEW;
+        return Status.isValid(getStatus());
-        if (getParent() == null) {
+        if (parent == null) {
-        } catch (NoSuchItemStateException e) {
-            String msg = "Failed to build path of " + this;
-            log.debug(msg);
-            throw new ItemNotFoundException(msg, e);
-        } catch (ItemStateException e) {
-            String msg = "Failed to build path of " + this;
-            log.debug(msg);
-            throw new RepositoryException(msg, e);
-            throws ItemStateException, RepositoryException {
+        throws ItemNotFoundException {
-        if (Status.isTerminalStatus(oldStatus)) {
+        if (Status.isTerminal(oldStatus)) {
-            if (la[i] instanceof ItemStateLifeCycleListener) {
-                ((ItemStateLifeCycleListener) la[i]).statusChanged(this, oldStatus);
+            if (la[i] != null) {
+                la[i].statusChanged(this, oldStatus);
-            assert (!listeners.contains(listener));
+    /**
+     * Unmodifiable iterator over the listeners present on this item state.
+     * 
+     * @return
+     */
+    public Iterator getListeners() {
+        return Collections.unmodifiableCollection(listeners).iterator();
+    }
+    //-----------------------------------------< ItemStateLifeCycleListener >---
+    /**
+     *
+     * @param state
+     * @param previousStatus
+     */
+    public void statusChanged(ItemState state, int previousStatus) {
+        checkIsSessionState();
+
+        // the given state is the overlayed state this state (session) is listening to.
+        if (state == overlayedState) {
+            switch (state.getStatus()) {
+                case Status.MODIFIED:
+                    // underlying state has been modified by external changes
+                    if (status == Status.EXISTING) {
+                        synchronized (this) {
+                            reset();
+                        }
+                    } else if (status == Status.EXISTING_MODIFIED) {
+                        setStatus(Status.STALE_MODIFIED);
+                    }
+                    // else: this status is EXISTING_REMOVED => ignore.
+                    // no other status is possible.
+                    break;
+                case Status.REMOVED:
+                    if (status == Status.EXISTING_MODIFIED) {
+                        setStatus(Status.STALE_DESTROYED);
+                    } else {
+                        setStatus(Status.REMOVED);
+                    }
+                    break;
+                default:
+                    // Should never occur, since 'setStatus(int)' already validates
+                    log.error("Workspace state cannot have its state changed to " + state.getStatus());
+                    break;
+            }
+        }
+    }
+
+
-     * the given event (and ev. changelog).
+     * an external modification indicated by the given event.
+     * @throws IllegalStateException if this state is a 'session' state.
+     */
+    abstract void refresh(Event event);
+
+    /**
+     * Returns the overlaying item state or <code>null</code> if that state
+     * has not been created yet or has been disconnected.
+     *
+     * @return
+     */
+    ItemState getSessionState() {
+        checkIsWorkspaceState();
+        ItemStateLifeCycleListener[] la;
+        synchronized (listeners) {
+            la = (ItemStateLifeCycleListener[]) listeners.toArray(new ItemStateLifeCycleListener[listeners.size()]);
+        }
+        for (int i = 0; i < la.length; i++) {
+            if (la[i] instanceof ItemState) {
+                return (ItemState) la[i];
+            }
+        }
+        return null;
+    }
+
+    //----------------------------------------------------< Session - State >---
+    /**
+     * Used on the target state of a save call AFTER the changelog has been
+     * successfully submitted to the SPI..
+     *
+     * @param events
-    abstract void refresh(Event event, ChangeLog changeLog);
+    abstract void refresh(Collection events, ChangeLog changeLog) throws IllegalStateException;
-
-    //----------------------------------------------------< Session - State >---
-     * Merge the state information from the overlayed state into this state
-     */
-    abstract void merge();
-
-    /**
-     * Returns <code>true</code> if this item state represents new or modified
-     * state or <code>false</code> if it represents existing, unmodified state.
-     *
-     * @return <code>true</code> if this item state is modified or new,
-     *         otherwise <code>false</code>
-     */
-    private boolean isTransient() {
-        checkIsSessionState();
-        return status == Status.EXISTING_MODIFIED || status == Status.NEW;
-    }
-
-    /**
-     * call the method {@link #collectTransientStates(java.util.Set)} on those
+     * call the method {@link #collectTransientStates(Collection)} on those
-     *                        collected while the <code>ItemState</code>
-     *                        hierarchy is traversed.
-    abstract void collectTransientStates(Set transientStates);
+    abstract void collectTransientStates(Collection transientStates);
-    //-----------------------------------------< ItemStateLifeCycleListener >---
+
+    //--------------------------------------------------------------------------
-     * @param state
-     * @param previousStatus
+     * @param events
+     * @param processedState
-    public void statusChanged(ItemState state, int previousStatus) {
-        // workspace-states never are listening to another state
-        checkIsSessionState();
-        state.checkIsWorkspaceState();
-
-        switch (state.getStatus()) {
-            case Status.EXISTING:
-                // nothing to do
+    static void removeEvent(Collection events, ItemState processedState) {
+        for (Iterator it = events.iterator(); it.hasNext();) {
+            if (((Event)it.next()).getItemId().equals(processedState.getId())) {
+                it.remove();
-            case Status.MODIFIED:
-                if (previousStatus == Status.EXISTING) {
-                    // underlying state has been modified
-                    if (isTransient()) {
-                        setStatus(Status.STALE_MODIFIED);
-                    } else {
-                        synchronized (this) {
-                            // this instance represents existing state, update it
-                            merge();
-                            setStatus(Status.EXISTING);
-                        }
-                    }
-                }
-                break;
-            case Status.REMOVED:
-                if (isTransient()) {
-                    setStatus(Status.STALE_DESTROYED);
-                } else {
-                    setStatus(Status.REMOVED);
-                }
-                break;
-            default:
-                // Should never occur, since 'setStatus(int)' already validates
-                log.error("Workspace state cannot have its state changed to " + state.getStatus());
-                break;
+            }

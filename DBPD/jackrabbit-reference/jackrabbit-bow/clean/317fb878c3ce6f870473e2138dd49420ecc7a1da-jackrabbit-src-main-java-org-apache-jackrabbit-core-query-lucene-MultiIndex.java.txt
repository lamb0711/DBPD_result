JCR-554: Index creates many folders when re-indexing
- delete unused index segments earlier
- use UUID instances instead of String representation of a UUID

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@439019 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.uuid.UUID;
+     * Flag indicating whether re-indexing is running.
+     */
+    private boolean reindexing = false;
+
+    /**
+                reindexing = true;
+                reindexing = false;
-    }
+            }
-     * @param remove Iterator of <code>Term</code>s that identify documents to
+     * @param remove Iterator of <code>UUID</code>s that identify documents to
-                String uuid = ((Term) remove.next()).text();
-                executeAndLog(new DeleteNode(transactionId, uuid));
+                executeAndLog(new DeleteNode(transactionId, (UUID) remove.next()));
-     * Deletes the first document that matches the <code>idTerm</code>.
+     * Deletes the first document that matches the <code>uuid</code>.
-     * @param idTerm document that match this term will be deleted.
+     * @param uuid document that match this <code>uuid</code> will be deleted.
-    void removeDocument(Term idTerm) throws IOException {
-        List remove = Arrays.asList(new Term[]{idTerm});
+    void removeDocument(UUID uuid) throws IOException {
+        List remove = Arrays.asList(new UUID[]{uuid});
-     * Deletes all documents that match the <code>idTerm</code>.
+     * Deletes all documents that match the <code>uuid</code>.
-     * @param idTerm documents that match this term will be deleted.
+     * @param uuid documents that match this <code>uuid</code> will be deleted.
-    synchronized int removeAllDocuments(Term idTerm) throws IOException {
+    synchronized int removeAllDocuments(UUID uuid) throws IOException {
+            Term idTerm = new Term(FieldNames.UUID, uuid.toString());
-                redoLog.append(new DeleteNode(getTransactionId(), idTerm.text()));
+                redoLog.append(new DeleteNode(getTransactionId(), uuid));
-                        redoLog.append(new DeleteNode(getTransactionId(), idTerm.text()));
+                        redoLog.append(new DeleteNode(getTransactionId(), uuid));
+     * Returns <code>true</code> if this multi index has an index segment with
+     * the given name. This method even returns <code>true</code> if an index
+     * segments has not yet been loaded / initialized but exists on disk.
+     *
+     * @param indexName the name of the index segment.
+     * @return <code>true</code> if it exists; otherwise <code>false</code>.
+     */
+    synchronized boolean hasIndex(String indexName) {
+        // check existing
+        for (Iterator it = indexes.iterator(); it.hasNext();) {
+            PersistentIndex idx = (PersistentIndex) it.next();
+            if (idx.getName().equals(indexName)) {
+                return true;
+            }
+        }
+        // check if it exists on disk
+        return new File(indexDir, indexName).exists();
+    }
+
+    /**
-            executeAndLog(new Start(Action.INTERNAL_TRANSACTION));
+            // if we are reindexing there is already an active transaction
+            if (!reindexing) {
+                executeAndLog(new Start(Action.INTERNAL_TRANSACTION));
+            }
+            // Index merger does not log an action when it creates the target
+            // index of the merge. We have to do this here.
+            executeAndLog(new CreateIndex(getTransactionId(), index.getName(), false));
+
-            executeAndLog(new Commit(getTransactionId()));
+            if (reindexing) {
+                // do some cleanup right away when reindexing
+                attemptDelete();
+            } else {
+                // only commit if we are not reindexing
+                // when reindexing the final commit is done at the very end
+                executeAndLog(new Commit(getTransactionId()));
+            }
-        if (a.getType() == Action.TYPE_COMMIT) {
+        // please note that flushing the redo log is only required on
+        // commit, but we also want to keep track of new indexes for sure.
+        // otherwise it might happen that unused index folders are orphaned
+        // after a crash.
+        if (a.getType() == Action.TYPE_COMMIT || a.getType() == Action.TYPE_ADD_INDEX) {
-        executeAndLog(new AddNode(getTransactionId(), id.getUUID().toString()));
+        executeAndLog(new AddNode(getTransactionId(), id.getUUID()));
-        private final String uuid;
+        private final UUID uuid;
-        AddNode(long transactionId, String uuid) {
+        AddNode(long transactionId, UUID uuid) {
-            this(transactionId, doc.get(FieldNames.UUID));
+            this(transactionId, UUID.fromString(doc.get(FieldNames.UUID)));
-            return new AddNode(transactionId, arguments);
+            return new AddNode(transactionId, UUID.fromString(arguments));
-                    doc = index.createDocument(NodeId.valueOf(uuid));
+                    doc = index.createDocument(new NodeId(uuid));
-            PersistentIndex idx = index.getOrCreateIndex(indexName, false);
-            index.deleteIndex(idx);
+            if (index.hasIndex(indexName)) {
+                PersistentIndex idx = index.getOrCreateIndex(indexName, false);
+                index.deleteIndex(idx);
+            }
-        private final String uuid;
+        private final UUID uuid;
-        DeleteNode(long transactionId, String uuid) {
+        DeleteNode(long transactionId, UUID uuid) {
-            return new DeleteNode(transactionId, arguments);
+            return new DeleteNode(transactionId, UUID.fromString(arguments));
-            Term idTerm = new Term(FieldNames.UUID, uuid);
+            Term idTerm = new Term(FieldNames.UUID, uuid.toString());

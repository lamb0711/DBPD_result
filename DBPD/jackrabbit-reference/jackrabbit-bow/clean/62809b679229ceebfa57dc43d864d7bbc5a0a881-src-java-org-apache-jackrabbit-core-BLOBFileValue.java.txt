- improve temp-file handling of small blobs (improves speed especially on windows boxes)

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@160204 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.ByteArrayInputStream;
+    /** the property type */
+    /** the default encoding */
+    /** empty array */
+    private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
+
+    /** max size for keeping tmp data in memory */
+    private static final int MAX_BUFFER_SIZE = 0x10000;
+
+    /** underlaying file */
+    private final File file;
+
+    /** flag indicating if file is a temp file */
-    private final File file;
+    /** buffer for small data */
+    private byte[] buffer = EMPTY_BYTE_ARRAY;
+
+    /** underlaying file system resource */
+    /** converted text */
-     * to a temporary file.
+     * to a temporary file or to a byte buffer, if smaller than
+     * {@link #MAX_BUFFER_SIZE}.
-        // create temp file
-        file = File.createTempFile("bin", null);
-        file.deleteOnExit();
-        // this instance is backed by a 'real' file; set virtual fs resource to null
-        fsResource = null;
-
-        // spool stream to temp file
-        FileOutputStream out = new FileOutputStream(file);
+        byte[] spoolBuffer = new byte[0x2000];
+        int read;
+        int len = 0;
+        OutputStream out = null;
+        File spoolFile = null;
-            byte[] buffer = new byte[8192];
-            int read = 0;
-            while ((read = in.read(buffer)) > 0) {
-                out.write(buffer, 0, read);
+            while ((read = in.read(spoolBuffer)) > 0) {
+                if (out != null) {
+                    out.write(spoolBuffer, 0, read);
+                    len += read;
+                } else if (len + read > MAX_BUFFER_SIZE) {
+                    // create temp file
+                    spoolFile = File.createTempFile("bin", null);
+                    spoolFile.deleteOnExit();
+                    out = new FileOutputStream(spoolFile);
+                    out.write(buffer, 0, len);
+                    out.write(spoolBuffer, 0, read);
+                    buffer = null;
+                    len += read;
+                } else if (len + read > buffer.length) {
+                    byte[] newBuffer = new byte[len+read];
+                    System.arraycopy(buffer, 0, newBuffer, 0, len);
+                    System.arraycopy(spoolBuffer, 0, newBuffer, len, read);
+                    buffer = newBuffer;
+                    len += read;
+                }
-            out.close();
+            if (out != null) {
+                out.close();
+            }
+        // init vars
+        file = spoolFile;
+        fsResource = null;
+    /**
+     * {@inheritDoc}
+     */
-        } else {
+        } else if (fsResource != null) {
+        } else {
+            return buffer.length;
-        } else {
+        } else if (fsResource != null) {
+        } else {
+            buffer = EMPTY_BYTE_ARRAY;
-        } else {
+        } else if (fsResource != null) {
+        } else {
+            in = new ByteArrayInputStream(buffer);
-            int read = 0;
+            int read;
-    //-------------------------------------------< java.lang.Object overrides >
+    //-----------------------------------------< java.lang.Object overrides >---
-        } else {
+        } else if (fsResource != null) {
+        } else {
+            // this instance is backed to a byte buffer
+            return buffer.toString();
-    //----------------------------------------------------------------< Value >
+    //--------------------------------------------------------------< Value >---
-        } else {
+        } else if (fsResource != null) {
+        } else {
+            return new ByteArrayInputStream(buffer);

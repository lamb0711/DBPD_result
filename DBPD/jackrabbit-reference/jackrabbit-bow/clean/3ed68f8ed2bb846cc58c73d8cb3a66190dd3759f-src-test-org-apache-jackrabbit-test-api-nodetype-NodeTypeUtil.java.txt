Additional test cases for various areas, contributed by Vinzenz Wyser.

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@164016 13f79535-47bb-0310-9956-ffa450edef68

-import java.text.ParseException;
-class NodeTypeUtil {
+public class NodeTypeUtil {
-     * @param regardDefaultPrimaryType: if true, the default primary type of the returned
-     *                                  <code>NodeDef</code> is according to param
-     *                                  <code>defaultPrimaryType</code>. If false, the returned
-     *                                  <code>NodeDef</code> might have a default primary type
-     *                                  or not.
-     * @param defaultPrimaryType:       if <code>regardDefaultPrimaryType</code> is true:
-     *                                  if true, the returned <code>NodeDef</code> has a
-     *                                  default primary type, else not
-     * @param residual:                 if true, the returned <code>NodeDef</code> is of
-     *                                  the residual name "*", else not
+     * @param regardDefaultPrimaryType: if true, the default primary type of the
+     *                                  returned <code>NodeDef</code> is
+     *                                  according to param <code>defaultPrimaryType</code>.
+     *                                  If false, the returned <code>NodeDef</code>
+     *                                  might have a default primary type or
+     *                                  not.
+     * @param defaultPrimaryType:       if <code>regardDefaultPrimaryType</code>
+     *                                  is true: if true, the returned
+     *                                  <code>NodeDef</code> has a default
+     *                                  primary type, else not
+     * @param residual:                 if true, the returned <code>NodeDef</code>
+     *                                  is of the residual name "*", else not
-     * @return the first <code>NodeDef</code> found fitting the
-     *         requirements
+     * @return the first <code>NodeDef</code> found fitting the requirements
-                    // check if a value out of constraint is buildable
-                    Value v = getValueOutOfContstraint(propDef);
-                    if (v == null) {
-                        // no value out of the constraint range available
-                        continue;
-                    }
-     * Returns a value out of the value constraints
+     * Returns a value according to the value contraints of a
+     * <code>PropertyDefinition</code>
+     *
+     * @param propDef:  The <code>PropertyDefinition</code> whose constraints
+     *                  will be regarded
+     * @param satisfied If true, the returned <code>Value</code> will satisfying
+     *                  the constraints - If false, the returned
+     *                  <code>Value</code> will not satisfying the constraints.
+     * @return Depending on param <code>satisfied</code> a <code>Value</code>
+     *         satisfying or not satistying the constraints of
+     *         <code>propDef</code> will be returned. Null will be returned if
+     *         no accordant <code>Value</code> could be build.
-    public static Value getValueOutOfContstraint(PropertyDefinition propDef)
+    public static Value getValueAccordingToValueConstraints(PropertyDefinition propDef,
+                                                            boolean satisfied)
+
+                    // indicate if absMin and absMax are already set
+                    boolean absMinSet = false;
+                    boolean absMaxSet = false;
+
-                                if (min < absMin) {
+                                if (!absMinSet) {
+                                    absMin = min;
+                                    absMinSet = true;
+                                } else if (min < absMin) {
-                                if (max > absMax) {
+                                if (!absMaxSet) {
+                                    absMaxSet = true;
+                                } else if (max > absMax) {
+                                    absMin = max;
-                    if (!minBoundless && absMin > 1) {
-                        return new BinaryValue("0");
-                    } else if (!maxBoundless) {
-                        // build a binary value of size > absMax
+                    if (satisfied) {
+                        // build a binary value absMin < size > absMax
-                        for (int i = 0; i <= absMax; i = i + 10) {
-                            content.append("0123456789");
+                        for (int i = 0; i <= absMin + 1; i++) {
+                            content.append("X");
-                        return new BinaryValue(content.toString());
+                        if (!maxBoundless && content.length() >= absMax) {
+                            return null;
+                        } else {
+                            return new BinaryValue(content.toString());
+                        }
-                        return null;
+                        if (!minBoundless && absMin > 1) {
+                            // return a value of size < absMin
+                            return new BinaryValue("0");
+                        } else if (!maxBoundless) {
+                            // build a binary value of size > absMax
+                            StringBuffer content = new StringBuffer();
+                            for (int i = 0; i <= absMax; i = i + 10) {
+                                content.append("0123456789");
+                            }
+                            return new BinaryValue(content.toString());
+                        } else {
+                            return null;
+                        }
-                    boolean value = !Boolean.valueOf(constraints[0]).booleanValue();
-                    return new BooleanValue(value);
+                    boolean value = Boolean.valueOf(constraints[0]).booleanValue();
+                    if (satisfied) {
+                        return new BooleanValue(value);
+                    } else {
+                        return new BooleanValue(!value);
+                    }
-                    if (!minBoundless) {
-                        absMin.setTimeInMillis(absMin.getTimeInMillis() - 1);
-                        return new DateValue(absMin);
-                    } else if (!maxBoundless) {
-                        absMax.setTimeInMillis(absMax.getTimeInMillis() + 1);
-                        return new DateValue(absMax);
+                    if (satisfied) {
+                        if (absMin != null) {
+                            absMin.setTimeInMillis(absMin.getTimeInMillis() + 1);
+                            if (absMin.after(absMax)) {
+                                return null;
+                            }
+                            return new DateValue(absMin);
+                        } else if (absMax != null) {
+                            absMax.setTimeInMillis(absMax.getTimeInMillis() - 1);
+                            if (absMax.before(absMin)) {
+                                return null;
+                            }
+                            return new DateValue(absMax);
+                        } else {
+                            // neither min nor max set: return "now"
+                            return new DateValue(Calendar.getInstance());
+                        }
-                        return null;
+                        if (!minBoundless) {
+                            absMin.setTimeInMillis(absMin.getTimeInMillis() - 1);
+                            return new DateValue(absMin);
+                        } else if (!maxBoundless) {
+                            absMax.setTimeInMillis(absMax.getTimeInMillis() + 1);
+                            return new DateValue(absMax);
+                        } else {
+                            return null;
+                        }
+                    // indicate if absMin and absMax are already set
+                    boolean absMinSet = false;
+                    boolean absMaxSet = false;
+
-                                if (min < absMin) {
+                                if (!absMinSet) {
+                                    absMin = min;
+                                    absMinSet = true;
+                                } else if (min < absMin) {
-                                if (max > absMax) {
+                                if (!absMaxSet) {
+                                    absMax = max;
+                                    absMaxSet = true;
+                                } else if (max > absMax) {
-                    if (!minBoundless) {
-                        return new DoubleValue(absMin - 1);
-                    } else if (!maxBoundless) {
-                        return new DoubleValue(absMax + 1);
+                    if (satisfied) {
+                        if (minBoundless) {
+                            return new DoubleValue(absMax - 1);
+                        } else if (maxBoundless) {
+                            return new DoubleValue(absMin + 1);
+                        } else if (absMin < absMax) {
+                            double d = (absMin + absMax) / 2;
+                            return new DoubleValue(d);
+                        } else {
+                            return null;
+                        }
-                        return null;
+                        if (!minBoundless) {
+                            return new DoubleValue(absMin - 1);
+                        } else if (!maxBoundless) {
+                            return new DoubleValue(absMax + 1);
+                        } else {
+                            return null;
+                        }
+                    // indicate if absMin and absMax are already set
+                    boolean absMinSet = false;
+                    boolean absMaxSet = false;
+
-                                if (min < absMin) {
+                                if (!absMinSet) {
+                                    absMin = min;
+                                    absMinSet = true;
+                                } else if (min < absMin) {
-                                if (max > absMax) {
+                                if (!absMaxSet) {
+                                    absMax = max;
+                                    absMaxSet = true;
+                                } else if (max > absMax) {
-                    if (!minBoundless) {
-                        return new LongValue(absMin - 1);
-                    } else if (!maxBoundless) {
-                        return new LongValue(absMax + 1);
+                    if (satisfied) {
+                        if (minBoundless) {
+                            return new LongValue(absMax - 1);
+                        } else if (maxBoundless) {
+                            return new LongValue(absMin + 1);
+                        } else if (absMin < absMax - 1) {
+                            long x = (absMin + absMax) / 2;
+                            return new LongValue(x);
+                        } else {
+                            return null;
+                        }
-                        return null;
+                        if (!minBoundless) {
+                            return new LongValue(absMin - 1);
+                        } else if (!maxBoundless) {
+                            return new LongValue(absMax + 1);
+                        } else {
+                            return null;
+                        }
-                    // build a name that is for sure not part of the constraints
-                    StringBuffer name = new StringBuffer("X");
-                    for (int i = 0; i < constraints.length; i++) {
-                        name.append(constraints[i].replaceAll(":", ""));
+                    if (satisfied) {
+                        // not in use so far
+                        return null;
+                    } else {
+                        // build a name that is for sure not part of the constraints
+                        StringBuffer name = new StringBuffer("X");
+                        for (int i = 0; i < constraints.length; i++) {
+                            name.append(constraints[i].replaceAll(":", ""));
+                        }
+                        return NameValue.valueOf(name.toString());
-                    return NameValue.valueOf(name.toString());
-                    // build a path that is for sure not part of the constraints
-                    StringBuffer path = new StringBuffer("X");
-                    for (int i = 0; i < constraints.length; i++) {
-                        path.append(constraints[i]);
+                    if (satisfied) {
+                        // not in use so far
+                        return null;
+                    } else {
+                        // build a path that is for sure not part of the constraints
+                        StringBuffer path = new StringBuffer("X");
+                        for (int i = 0; i < constraints.length; i++) {
+                            path.append(constraints[i]);
+                        }
+                        String pathStr = path.toString();
+
+                        // replace colon to avoid /a/x:b + y:c => /a/x:b:y:c
+                        // where x:b:y:c is not a legal path element
+                        pathStr = pathStr.replaceAll(":", "");
+                        pathStr = pathStr.replaceAll("\\*", "");
+                        pathStr = pathStr.replaceAll("//", "/");
+
+                        return PathValue.valueOf(pathStr);
-                    String pathStr = path.toString();
-
-                    // replace colon to avoid /a/x:b + y:c => /a/x:b:y:c
-                    // where x:b:y:c is not a legal path element
-                    pathStr = pathStr.replaceAll(":", "");
-                    pathStr = pathStr.replaceAll("\\*", "");
-                    pathStr = pathStr.replaceAll("//", "/");
-
-                    return PathValue.valueOf(pathStr);
-                    // build a string that will probably not be part of the constraints
-                    StringBuffer value = new StringBuffer("X");
-                    for (int i = 0; i < constraints.length; i++) {
-                        value.append(constraints[i]);
-                    }
-
-                    // test if value does not match any of the constraints
-                    for (int i = 0; i < constraints.length; i++) {
-                        Pattern pattern = Pattern.compile(constraints[i]);
-                        Matcher matcher = pattern.matcher(value);
-                        if (matcher.matches()) {
-                            return null;
+                    if (satisfied) {
+                        // not in use so far
+                        return null;
+                    } else {
+                        // build a string that will probably not satisfy the constraints
+                        StringBuffer value = new StringBuffer("X");
+                        for (int i = 0; i < constraints.length; i++) {
+                            value.append(constraints[i]);
+
+                        // test if value does not match any of the constraints
+                        for (int i = 0; i < constraints.length; i++) {
+                            Pattern pattern = Pattern.compile(constraints[i]);
+                            Matcher matcher = pattern.matcher(value);
+                            if (matcher.matches()) {
+                                return null;
+                            }
+                        }
+                        return new StringValue(value.toString());
-                    return new StringValue(value.toString());

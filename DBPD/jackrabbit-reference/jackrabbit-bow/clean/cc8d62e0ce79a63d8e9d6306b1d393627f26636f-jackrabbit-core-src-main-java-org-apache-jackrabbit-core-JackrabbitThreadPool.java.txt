JCR-3146 Text extraction may congest thread pool in the repository

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1202192 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+     * The logger instance for this class.
+     */
+    private static final Logger log = LoggerFactory
+            .getLogger(JackrabbitThreadPool.class);
+
+    /**
-    private static final RejectedExecutionHandler handler =
-            new ThreadPoolExecutor.CallerRunsPolicy();
+    private static final RejectedExecutionHandler handler = new CallerRunsPolicy();
+
+    /**
+     * Property to control the value at which the thread pool starts to schedule
+     * the {@link LowPriorityTask} tasks for later execution.
+     * 
+     * Set to <code>0</code> to disable the check
+     * 
+     * Default value is 0 (check is disabled).
+     * 
+     */
+    public static final String MAX_LOAD_FOR_LOW_PRIORITY_TASKS_PROPERTY = "org.apache.jackrabbit.core.JackrabbitThreadPool.maxLoadForLowPriorityTasks";
+
+    /**
+     * @see #MAX_LOAD_FOR_LOW_PRIORITY_TASKS_PROPERTY
+     */
+    private final static Integer maxLoadForLowPriorityTasks = getMaxLoadForLowPriorityTasks();
+
+    private static int getMaxLoadForLowPriorityTasks() {
+        final int defaultMaxLoad = 75;
+        int max = Integer.getInteger(MAX_LOAD_FOR_LOW_PRIORITY_TASKS_PROPERTY,
+                defaultMaxLoad);
+        if (max < 0 || max > 100) {
+            return defaultMaxLoad;
+        }
+        return max;
+    }
+
+    /**
+     * Queue where all the {@link LowPriorityTask} tasks go for later execution
+     */
+    private final BlockingQueue<Runnable> lowPriorityTasksQueue = new LinkedBlockingQueue<Runnable>();
+
+    /**
+     * Tasks that handles the scheduling and the execution of
+     * {@link LowPriorityTask} tasks
+     */
+    private final RetryLowPriorityTask retryTask;
+        retryTask = new RetryLowPriorityTask(this, lowPriorityTasksQueue);
+    @Override
+    public void execute(Runnable command) {
+        if (command instanceof LowPriorityTask) {
+            scheduleLowPriority(command);
+            return;
+        }
+        super.execute(command);
+    }
+
+    private void scheduleLowPriority(Runnable command) {
+        if (isOverDefinedMaxLoad()) {
+            lowPriorityTasksQueue.add(command);
+            retryTask.retryLater();
+            return;
+        }
+        super.execute(command);
+    }
+
+    /**
+     * compares the current load of the executor with the defined
+     * <code>{@link #maxLoadForLowPriorityTasks}</code> parameter.
+     * 
+     * Used to determine if the executor can handle additional
+     * {@link LowPriorityTask} tasks.
+     * 
+     * @return true if the load is under the
+     *         <code>{@link #maxLoadForLowPriorityTasks}</code> parameter
+     */
+    private boolean isOverDefinedMaxLoad() {
+        if (maxLoadForLowPriorityTasks == 0) {
+            return false;
+        }
+        double currentLoad = ((double) getActiveCount()) / getPoolSize() * 100;
+        return currentLoad > maxLoadForLowPriorityTasks;
+    }
+
+    /**
+     * TEST ONLY
+     * 
+     * @return the number of low priority tasks that are waiting in the queue
+     */
+    int getPendingLowPriorityTaskCount() {
+        return lowPriorityTasksQueue.size();
+    }
+
+    private static final class RetryLowPriorityTask implements Runnable {
+
+        /**
+         * schedule interval in ms for delayed tasks
+         */
+        private static final int LATER_MS = 50;
+
+        private final JackrabbitThreadPool executor;
+        private final BlockingQueue<Runnable> lowPriorityTasksQueue;
+
+        /**
+         * flag to indicate that another execute has been scheduled or is
+         * currently running.
+         */
+        private final AtomicBoolean retryPending;
+
+        public RetryLowPriorityTask(JackrabbitThreadPool executor,
+                BlockingQueue<Runnable> lowPriorityTasksQueue) {
+            this.executor = executor;
+            this.lowPriorityTasksQueue = lowPriorityTasksQueue;
+            this.retryPending = new AtomicBoolean(false);
+        }
+
+        public void retryLater() {
+            if (!retryPending.getAndSet(true)) {
+                executor.schedule(this, LATER_MS, TimeUnit.MILLISECONDS);
+            }
+        }
+
+        public void run() {
+            int count = 0;
+            while (!executor.isOverDefinedMaxLoad()) {
+                Runnable r = lowPriorityTasksQueue.poll();
+                if (r == null) {
+                    log.debug("Executed {} low priority tasks.", count);
+                    break;
+                }
+                count++;
+                executor.execute(r);
+            }
+            retryPending.set(false);
+            if (!lowPriorityTasksQueue.isEmpty()) {
+                log.debug(
+                        "Executor is under load, will schedule {} remaining tasks for {} ms later",
+                        lowPriorityTasksQueue.size(), LATER_MS);
+                retryLater();
+            }
+        }
+    }

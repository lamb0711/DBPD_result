JCR-160: Query index not in sync with workspace
- A possible commit.lock is now also removed on startup. Previously only a write.lock was removed.
- An integrity check is run if the search index detects a commit or write lock on startup. This check removes nodes from the index that are not available anymore through the ItemStateManager.
- Applying the redo log on startup is now more failsafe.

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@216142 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.state.ItemStateManager;
+import org.apache.jackrabbit.core.NodeId;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.document.Document;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Iterator;
-    private static final String WRITE_LOCK = "write.lock";
+    private static final String WRITE_LOCK = IndexWriter.WRITE_LOCK_NAME;
+
+    /** Name of the commit lock file */
+    private static final String COMMIT_LOCK = IndexWriter.COMMIT_LOCK_NAME;
+    /** Set to <code>true</code> if this index encountered locks on startup */
+    private boolean lockEncountered = false;
+
+            lockEncountered = true;
+        if (fs.exists(COMMIT_LOCK)) {
+            lockEncountered = true;
+            log.warn("Removing commit lock on search index.");
+            try {
+                fs.deleteFile(COMMIT_LOCK);
+            } catch (FileSystemException e) {
+                log.error("Unable to remove write lock on search index.");
+            }
+        }
+    }
+
+    /**
+     * Returns <code>true</code> if this index encountered a lock on the file
+     * system during startup. This indicates a unclean shutdown.
+     *
+     * @return <code>true</code> if this index encountered a lock on startup;
+     *         <code>false</code> otherwise.
+     */
+    boolean getLockEncountered() {
+        return lockEncountered;
-            }
+    }
+     * Checks if the nodes in this index still exist in the ItemStateManager
+     * <code>mgr</code>. Nodes that do not exist in <code>mgr</code> will
+     * be deleted from the index.
+     *
+     * @param mgr the ItemStateManager.
+     */
+    void integrityCheck(ItemStateManager mgr) {
+        // List<Integer> of document numbers to delete
+        List deleted = new ArrayList();
+        IndexReader reader;
+        try {
+            reader = getIndexReader();
+            int maxDoc = reader.maxDoc();
+            for (int i = 0; i < maxDoc; i++) {
+                if (!reader.isDeleted(i)) {
+                    Document d = reader.document(i);
+                    NodeId id = new NodeId(d.get(FieldNames.UUID));
+                    if (!mgr.hasItemState(id)) {
+                        // not known to ItemStateManager
+                        deleted.add(new Integer(i));
+                        log.warn("Node " + id.getUUID() + " does not exist anymore. Will be removed from index.");
+                    }
+                }
+            }
+        } catch (IOException e) {
+            log.error("Unable to read from index: " + e);
+            return;
+        }
+
+        // now delete them
+        for (Iterator it = deleted.iterator(); it.hasNext(); ) {
+            int docNum = ((Integer) it.next()).intValue();
+            try {
+                reader.delete(docNum);
+            } catch (IOException e) {
+                log.error("Unable to delete inexistent node from index: " + e);
+            }
+        }
+
+        // commit changes on reader
+        try {
+            commit();
+        } catch (IOException e) {
+            log.error("Unable to commit index: " + e);
+        }
+    }
+
+    /**

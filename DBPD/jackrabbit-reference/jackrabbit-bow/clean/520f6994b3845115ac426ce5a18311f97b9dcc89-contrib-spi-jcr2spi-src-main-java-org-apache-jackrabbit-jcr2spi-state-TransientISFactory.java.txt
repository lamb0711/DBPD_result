work in progress.

- nodestates must always be connected to their cne upon creation
  TODO: add some sort of caching to avoid traffic overhead
- add TODO for refresh, that currently doesn't work properly
- ItemState.refresh only takes changelog and returns the ids of the
  processed states. cleanup of events is left to caller.
- move of NodeStates does not work
- PathResolver: force start to be an NodeState
- all MODIFIED status for SessionStates as well in order to make sure
  that listeners are informed about external changes even if the 
  state is EXISTING.

next TODO: make sure, that public getChildNodeEntry/ies and hasChildNodeEntry check for validity of the connected NodeState. don't return entries, where the nodestate is (transiently) removed or stale.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@472818 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.state.entry.ChildNodeEntry;
-    private final ItemStateManager parent;
+    private final ItemStateManager workspaceItemStateMgr;
-    TransientISFactory(IdFactory idFactory, ItemStateManager parent) {
+    TransientISFactory(IdFactory idFactory, ItemStateManager workspaceItemStateMgr) {
-        this.parent = parent;
+        this.workspaceItemStateMgr = workspaceItemStateMgr;
-        NodeState overlayedState = (NodeState) parent.getRootState();
+        NodeState overlayedState = (NodeState) workspaceItemStateMgr.getRootState();
-            NodeState overlayedState = (NodeState) parent.getItemState(nodeId);
+            NodeState overlayedState = (NodeState) workspaceItemStateMgr.getItemState(nodeId);
-            NodeState parentState = null;
-            if (overlayedParent != null) {
+            if (overlayedParent == null) {
+                // special case root state
+                return createRootState(ism);
+            }
+            
+            NodeState parentState = (NodeState) overlayedParent.getSessionState();
+            if (parentState == null) {
-            nodeState = new NodeState(overlayedState, parentState, Status.EXISTING, this, idFactory);
-            nodeState.addListener(cache);
-            cache.created(nodeState);
+            ChildNodeEntry cne = parentState.getChildNodeEntry(nodeId);
+            if (cne != null) {
+                nodeState = cne.getNodeState();
+                nodeState.addListener(cache);
+                cache.created(nodeState);
+            } else {
+                throw new NoSuchItemStateException("No such item " + nodeId.toString());
+            }
-            NodeState overlayedState = (NodeState) parent.getItemState(nodeId);
+            NodeState overlayedState = (NodeState) workspaceItemStateMgr.getItemState(nodeId);
-            PropertyState overlayedState = (PropertyState) parent.getItemState(propertyId);
+            PropertyState overlayedState = (PropertyState) workspaceItemStateMgr.getItemState(propertyId);

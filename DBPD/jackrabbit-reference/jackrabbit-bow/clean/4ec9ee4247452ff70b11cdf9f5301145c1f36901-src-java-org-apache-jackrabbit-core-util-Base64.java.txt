- removed @author and @version (i.e. $Revision & $Id) tags
- removed tab characters from java source code

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@47648 13f79535-47bb-0310-9956-ffa450edef68

- *
- * @author Stefan Guggisberg
- * @version $Revision: 1.9 $, $Date: 2004/08/02 16:19:52 $
-	    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".toCharArray();
+            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".toCharArray();
-	// initialize decoding table
-	for (int i = 0; i < DECODETABLE.length; i++) {
-	    DECODETABLE[i] = 0x7f;
-	}
-	// build decoding table
-	for (int i = 0; i < BASE64CHARS.length; i++) {
-	    DECODETABLE[BASE64CHARS[i]] = (byte) i;
-	}
+        // initialize decoding table
+        for (int i = 0; i < DECODETABLE.length; i++) {
+            DECODETABLE[i] = 0x7f;
+        }
+        // build decoding table
+        for (int i = 0; i < BASE64CHARS.length; i++) {
+            DECODETABLE[BASE64CHARS[i]] = (byte) i;
+        }
-	long encLen = dataLength * 4 / 3;
-	encLen += (encLen + 4) % 4;
-	return encLen;
+        long encLen = dataLength * 4 / 3;
+        encLen += (encLen + 4) % 4;
+        return encLen;
-	long decLen = encLength * 3 / 4;
-	return decLen + 3;
+        long decLen = encLength * 3 / 4;
+        return decLen + 3;
-	    throws IOException {
-	// encode stream data in chunks;
-	// chunksize must be a multiple of 3 in order
-	// to avoid padding within output
-	byte[] buffer = new byte[9 * 1024];
-	int read = 0;
-	while ((read = in.read(buffer)) > 0) {
-	    encode(buffer, 0, read, writer);
-	}
+            throws IOException {
+        // encode stream data in chunks;
+        // chunksize must be a multiple of 3 in order
+        // to avoid padding within output
+        byte[] buffer = new byte[9 * 1024];
+        int read = 0;
+        while ((read = in.read(buffer)) > 0) {
+            encode(buffer, 0, read, writer);
+        }
-	    throws IOException {
-	Writer writer = new OutputStreamWriter(out, CHARSET);
-	encode(in, writer);
+            throws IOException {
+        Writer writer = new OutputStreamWriter(out, CHARSET);
+        encode(in, writer);
-	    throws IOException {
-	if (len == 0) {
-	    return;
-	}
-	if (len < 0 || off >= data.length
-		|| len + off > data.length) {
-	    throw new IllegalArgumentException();
-	}
-	char[] enc = new char[4];
-	while (len >= 3) {
-	    int i = ((data[off] & 0xff) << 16)
-		    + ((data[off + 1] & 0xff) << 8)
-		    + (data[off + 2] & 0xff);
-	    enc[0] = BASE64CHARS[i >> 18];
-	    enc[1] = BASE64CHARS[(i >> 12) & 0x3f];
-	    enc[2] = BASE64CHARS[(i >> 6) & 0x3f];
-	    enc[3] = BASE64CHARS[i & 0x3f];
-	    writer.write(enc, 0, 4);
-	    off += 3;
-	    len -= 3;
-	}
-	// add padding if necessary
-	if (len == 1) {
-	    int i = data[off] & 0xff;
-	    enc[0] = BASE64CHARS[i >> 2];
-	    enc[1] = BASE64CHARS[(i << 4) & 0x3f];
-	    enc[2] = BASE64PAD;
-	    enc[3] = BASE64PAD;
-	    writer.write(enc, 0, 4);
-	} else if (len == 2) {
-	    int i = ((data[off] & 0xff) << 8) + (data[off + 1] & 0xff);
-	    enc[0] = BASE64CHARS[i >> 10];
-	    enc[1] = BASE64CHARS[(i >> 4) & 0x3f];
-	    enc[2] = BASE64CHARS[(i << 2) & 0x3f];
-	    enc[3] = BASE64PAD;
-	    writer.write(enc, 0, 4);
-	}
+            throws IOException {
+        if (len == 0) {
+            return;
+        }
+        if (len < 0 || off >= data.length
+                || len + off > data.length) {
+            throw new IllegalArgumentException();
+        }
+        char[] enc = new char[4];
+        while (len >= 3) {
+            int i = ((data[off] & 0xff) << 16)
+                    + ((data[off + 1] & 0xff) << 8)
+                    + (data[off + 2] & 0xff);
+            enc[0] = BASE64CHARS[i >> 18];
+            enc[1] = BASE64CHARS[(i >> 12) & 0x3f];
+            enc[2] = BASE64CHARS[(i >> 6) & 0x3f];
+            enc[3] = BASE64CHARS[i & 0x3f];
+            writer.write(enc, 0, 4);
+            off += 3;
+            len -= 3;
+        }
+        // add padding if necessary
+        if (len == 1) {
+            int i = data[off] & 0xff;
+            enc[0] = BASE64CHARS[i >> 2];
+            enc[1] = BASE64CHARS[(i << 4) & 0x3f];
+            enc[2] = BASE64PAD;
+            enc[3] = BASE64PAD;
+            writer.write(enc, 0, 4);
+        } else if (len == 2) {
+            int i = ((data[off] & 0xff) << 8) + (data[off + 1] & 0xff);
+            enc[0] = BASE64CHARS[i >> 10];
+            enc[1] = BASE64CHARS[(i >> 4) & 0x3f];
+            enc[2] = BASE64CHARS[(i << 2) & 0x3f];
+            enc[3] = BASE64PAD;
+            writer.write(enc, 0, 4);
+        }
-	char[] chunk = new char[8192];
-	int read;
-	while ((read = reader.read(chunk)) > -1) {
-	    decode(chunk, 0, read, out);
-	}
+        char[] chunk = new char[8192];
+        int read;
+        while ((read = reader.read(chunk)) > -1) {
+            decode(chunk, 0, read, out);
+        }
-	decode(new InputStreamReader(in, CHARSET), out);
+        decode(new InputStreamReader(in, CHARSET), out);
-	char[] chars = data.toCharArray();
-	decode(chars, 0, chars.length, out);
+        char[] chars = data.toCharArray();
+        decode(chars, 0, chars.length, out);
-	decode(chars, 0, chars.length, out);
+        decode(chars, 0, chars.length, out);
-	if (len == 0) {
-	    return;
-	}
-	if (len < 0 || off >= chars.length
-		|| len + off > chars.length) {
-	    throw new IllegalArgumentException();
-	}
-	char[] chunk = new char[4];
-	byte[] dec = new byte[3];
-	int posChunk = 0;
-	// decode in chunks of 4 characters
-	for (int i = off; i < (off + len); i++) {
-	    char c = chars[i];
-	    if (c < DECODETABLE.length && DECODETABLE[c] != 0x7f
-		    || c == BASE64PAD) {
-		chunk[posChunk++] = c;
-		if (posChunk == chunk.length) {
-		    int b0 = DECODETABLE[chunk[0]];
-		    int b1 = DECODETABLE[chunk[1]];
-		    int b2 = DECODETABLE[chunk[2]];
-		    int b3 = DECODETABLE[chunk[3]];
-		    if (chunk[3] == BASE64PAD && chunk[2] == BASE64PAD) {
-			dec[0] = (byte) (b0 << 2 & 0xfc | b1 >> 4 & 0x3);
-			out.write(dec, 0, 1);
-		    } else if (chunk[3] == BASE64PAD) {
-			dec[0] = (byte) (b0 << 2 & 0xfc | b1 >> 4 & 0x3);
-			dec[1] = (byte) (b1 << 4 & 0xf0 | b2 >> 2 & 0xf);
-			out.write(dec, 0, 2);
-		    } else {
-			dec[0] = (byte) (b0 << 2 & 0xfc | b1 >> 4 & 0x3);
-			dec[1] = (byte) (b1 << 4 & 0xf0 | b2 >> 2 & 0xf);
-			dec[2] = (byte) (b2 << 6 & 0xc0 | b3 & 0x3f);
-			out.write(dec, 0, 3);
-		    }
-		    posChunk = 0;
-		}
-	    } else {
-		throw new IllegalArgumentException("specified data is not base64 encoded");
-	    }
-	}
+        if (len == 0) {
+            return;
+        }
+        if (len < 0 || off >= chars.length
+                || len + off > chars.length) {
+            throw new IllegalArgumentException();
+        }
+        char[] chunk = new char[4];
+        byte[] dec = new byte[3];
+        int posChunk = 0;
+        // decode in chunks of 4 characters
+        for (int i = off; i < (off + len); i++) {
+            char c = chars[i];
+            if (c < DECODETABLE.length && DECODETABLE[c] != 0x7f
+                    || c == BASE64PAD) {
+                chunk[posChunk++] = c;
+                if (posChunk == chunk.length) {
+                    int b0 = DECODETABLE[chunk[0]];
+                    int b1 = DECODETABLE[chunk[1]];
+                    int b2 = DECODETABLE[chunk[2]];
+                    int b3 = DECODETABLE[chunk[3]];
+                    if (chunk[3] == BASE64PAD && chunk[2] == BASE64PAD) {
+                        dec[0] = (byte) (b0 << 2 & 0xfc | b1 >> 4 & 0x3);
+                        out.write(dec, 0, 1);
+                    } else if (chunk[3] == BASE64PAD) {
+                        dec[0] = (byte) (b0 << 2 & 0xfc | b1 >> 4 & 0x3);
+                        dec[1] = (byte) (b1 << 4 & 0xf0 | b2 >> 2 & 0xf);
+                        out.write(dec, 0, 2);
+                    } else {
+                        dec[0] = (byte) (b0 << 2 & 0xfc | b1 >> 4 & 0x3);
+                        dec[1] = (byte) (b1 << 4 & 0xf0 | b2 >> 2 & 0xf);
+                        dec[2] = (byte) (b2 << 6 & 0xc0 | b3 & 0x3f);
+                        out.write(dec, 0, 3);
+                    }
+                    posChunk = 0;
+                }
+            } else {
+                throw new IllegalArgumentException("specified data is not base64 encoded");
+            }
+        }

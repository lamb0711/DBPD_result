work in progress

- version always protected
- versionHistory always protected
- fix Node.getReferences && reference properties
- mixinTypes are 'active' upon save only (and not before). therefore
  cleanup after removeMixin is done only after save.
  adding new states defined by a new mixin are only added after the
  node has been saved.
- nodestates identified by a uuid only were created a second time upon
  ChildNodeEntry.resolve => fix needs to be improved
- Events/ChangeLog are processed by the save-target state
- ChangeLog.persisted not used any more

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@467956 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Collection;
+import java.util.Iterator;
-    private QName name;
+    private final QName name;
+
+    /**
+     * Property definition
+     */
+    private final QPropertyDefinition def;
-     * Property definition
-     */
-    private QPropertyDefinition def;
-
-    /**
-                            int initialStatus, IdFactory idFactory) {
-        super(overlayedState, parent, initialStatus, idFactory);
+                            int initialStatus, ItemStateFactory isf, IdFactory idFactory) {
+        super(overlayedState, parent, initialStatus, isf, idFactory);
+        this.name = overlayedState.name;
+        this.def = overlayedState.def;
+
-                            int initialStatus, IdFactory idFactory, boolean isWorkspaceState) {
-        super(parent, initialStatus, idFactory, isWorkspaceState);
+                            int initialStatus, ItemStateFactory isf, IdFactory idFactory,
+                            boolean isWorkspaceState) {
+        super(parent, initialStatus, isf, idFactory, isWorkspaceState);
-
-        type = PropertyType.UNDEFINED;
-        values = QValue.EMPTY_ARRAY;
+        init(PropertyType.UNDEFINED, QValue.EMPTY_ARRAY);
+        // free old values as necessary
+        QValue[] oldValues = this.values;
+        if (oldValues != null) {
+            for (int i = 0; i < oldValues.length; i++) {
+                QValue old = oldValues[i];
+                if (old != null) {
+                    // make sure temporarily allocated data is discarded
+                    // before overwriting it (see QValue#discard())
+                    old.discard();
+                }
+            }
+        }
-        return idFactory.createPropertyId(parent.getNodeId(), getQName());
+        return idFactory.createPropertyId(getParent().getNodeId(), getQName());
-     * @see ItemState#refresh(Event, ChangeLog)
+     * @see ItemState#refresh(Event)
-    synchronized void refresh(Event event, ChangeLog changeLog) {
+    synchronized void refresh(Event event) {
-                if (event.getItemId().equals(getId())) {
-                    setStatus(Status.REMOVED);
-                } else {
-                    // ILLEGAL
-                    throw new IllegalArgumentException("EventId " + event.getItemId() + " does not match id of this property state.");
-                }
+                setStatus(Status.REMOVED);
-                if (event.getItemId().equals(getId())) {
+                // TODO: improve.
+                /* retrieve property value and type from server even if
+                   changes were issued from this session (changelog).
+                   this is currently the only way to update the workspace
+                   state, which is not connected to its overlaying session-state.
+                */
+                try {
+                    PropertyState tmp = isf.createPropertyState(getPropertyId(), parent);
+                    init(tmp.getType(), tmp.getValues());
-                } else {
-                    // ILLEGAL
-                    throw new IllegalArgumentException("EventId " + event.getItemId() + " does not match id of this property state.");
+                } catch (ItemStateException e) {
+                    // TODO: rather throw?
+                    log.error("Internal Error", e);
+     * @see ItemState#refresh(Collection,ChangeLog)
+     */
+    void refresh(Collection events, ChangeLog changeLog) throws IllegalStateException {
+        for (Iterator it = changeLog.modifiedStates(); it.hasNext();) {
+            ItemState modState = (ItemState) it.next();
+            if (modState == this) {
+                /*
+                NOTE: overlayedState must be existing, otherwise save was not
+                possible on prop. Similarly a property can only be the changelog
+                target, if it was modified. removal, add must be persisted on parent.
+                */
+                // push changes to overlayed state and reset status
+                ((PropertyState) overlayedState).init(getType(), getValues());
+                setStatus(Status.EXISTING);
+                // parent must not be informed, since all properties that
+                // affect the parent state (uuid, mixins) are protected.
+                removeEvent(events, modState);
+            }
+        }
+    }
+
+    /**
+     * {@inheritDoc}
-                name = wspState.name;
-                type = wspState.type;
-                def = wspState.def;
-                values = wspState.values;
+                init(wspState.type, wspState.values);
-    synchronized void merge() {
-        reset();
-    }
-
-
-        parent.propertyStateRemoved(this);
+        getParent().propertyStateRemoved(this);
-                parent.propertyStateRemoved(this);
+                getParent().propertyStateRemoved(this);
-                parent.propertyStateRemoved(this);
+                getParent().propertyStateRemoved(this);
-                parent.propertyStateRemoved(this);
+                getParent().propertyStateRemoved(this);
-     * @see ItemState#collectTransientStates(Set)
+     * @see ItemState#collectTransientStates(Collection)
-    void collectTransientStates(Set transientStates) {
+    void collectTransientStates(Collection transientStates) {
-
-        this.values = values;
-        this.type = type;
+        init(type, values);
+

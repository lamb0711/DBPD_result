work in progress

JCR2SPI
--------------------------------------------------------------

- reorder ItemState/NodeState/PropertyState in order to group
  methods by state types (overlayed workspace state vs. session/transient states)
- add utility methods that allow to determine and validate the
  type of ItemState.
- move childitementry classes to separate package and force usage
  of interface methods
- add checks for state type to ItemManager implementation
- add checks for state type to LockManager
- fix Node.getMixinTypes()
- rename ItemState.pull to 'reset'. remove todo asking for a careful
  merging of wsp-State and introduce a new method 'merge'.

SPI
--------------------------------------------------------------------

- rename login as suggested by julian
- add method dispose(SessionInfo) 
- rename ItemId.getRelativePath to getPath

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@454423 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.state.entry.ChildNodeEntry;
-    private final Path relPath;
+    private final Path path;
-        this.relPath = relPath;
+        this.path = relPath;
-     * @param relPath the path to resolve.
+     * @param path the path to resolve.
-     * @throws IllegalArgumentException if relPath is absolute or not normalized
+     * @throws IllegalArgumentException if path is absolute or not normalized
-    public static ItemState resolve(ItemState start, Path relPath)
+    public static ItemState resolve(ItemState start, Path path)
-        return new PathResolver(start, relPath).resolve();
+        return new PathResolver(start, path).resolve();
-     * Looks up the <code>ItemState</code> at <code>relPath</code> starting at
+     * Looks up the <code>ItemState</code> at <code>path</code> starting at
-     * @param relPath the path to resolve.
+     * @param path the path to resolve.
-     * @throws IllegalArgumentException if relPath is absolute or not normalized
+     * @throws IllegalArgumentException if path is absolute or not normalized
-    public static ItemState lookup(ItemState start, Path relPath)
+    public static ItemState lookup(ItemState start, Path path)
-        return new PathResolver(start, relPath).lookup();
+        return new PathResolver(start, path).lookup();
-            throw new NoSuchItemStateException(relPath.toString());
+            throw new NoSuchItemStateException(path.toString());
-        for (int i = 0; i < relPath.getLength(); i++) {
-            Path.PathElement elem = relPath.getElement(i);
+        for (int i = 0; i < path.getLength(); i++) {
+            Path.PathElement elem = path.getElement(i);
-                    throw new NoSuchItemStateException(relPath.toString());
+                    throw new NoSuchItemStateException(path.toString());
-                    && i == relPath.getLength() - 1) { // property must be final path element
+                    && i == path.getLength() - 1) { // property must be final path element
-                throw new NoSuchItemStateException(relPath.toString());
+                throw new NoSuchItemStateException(path.toString());
-            throw new NoSuchItemStateException(relPath.toString());
+            throw new NoSuchItemStateException(path.toString());
-        for (int i = 0; i < relPath.getLength(); i++) {
-            Path.PathElement elem = relPath.getElement(i);
+        for (int i = 0; i < path.getLength(); i++) {
+            Path.PathElement elem = path.getElement(i);
-                    && i == relPath.getLength() - 1) { // property must be final path element
+                    && i == path.getLength() - 1) { // property must be final path element
-                throw new NoSuchItemStateException(relPath.toString());
+                throw new NoSuchItemStateException(path.toString());

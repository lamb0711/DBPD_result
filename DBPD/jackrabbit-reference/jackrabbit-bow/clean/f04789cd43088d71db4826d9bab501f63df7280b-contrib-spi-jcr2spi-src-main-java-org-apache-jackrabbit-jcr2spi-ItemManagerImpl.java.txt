work in progress

jcr2spi
- HierarchyManager: fixing methods with ItemId param
- HierarchyManagerImpl(s): removing unused methods
- ItemManagerImpl: replacing NodeId as cacheKey
- ItemImpl: remove ISM field

jcr2spi/xml
- ImporterImpl renamed to SessionImporter (used for s-import only)
- xml import: Use UUID String instead of creating NodeIds
- ReferenceChangeTracker: remove usage of spi NodeId

jcr2spi/state
- SessionItemStateManager: ValueFactory not needed since QPropertyDefinition returns qualified values.

jcr2spi/util
- LogUtil: add 'saveGetJCRName' utility method

jcr2spi/locking
- locking: LockManager to use NodeState instead of NodeId
- locking: removing locktoken from Session checks if Session is lock holder

jcr2spi/query
- NodeIteratorImpl: fix commented code, that allows to retrieve
  search results from IdIterator returned from QueryInfo
- minor reformatting, javadoc

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@430791 13f79535-47bb-0310-9956-ffa450edef68

- * <li>providing access to <code>Item</code> instances by <code>ItemId</code>
+ * <li>providing access to <code>Item</code> instances by <code>ItemState</code>
-    //private final ItemStateManager itemStateMgr;
-    // TODO: TO-BE-FIXED. With SPI_ItemId simple map cannot be used any more
-     * A cache for item instances created by this <code>ItemManagerImpl</code>
+     * A cache for item instances created by this <code>ItemManagerImpl</code>.
+     * // DIFF JR:
+     * The <code>ItemState</code>s act as keys for the map. In contrast to
+     * o.a.j.core the item state are copied to transient space for reading and
+     * will therefor not change upon transient modifications.
-        // setup item cache with weak references to items
-        itemCache = new ReferenceMap(ReferenceMap.HARD, ReferenceMap.WEAK);
+        /* Setup item cache with weak keys (ItemState) and weak values (Item).*/
+        itemCache = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);
-        ItemId id = itemState.getId();
-        ItemImpl item = retrieveItem(id);
+        Item item = retrieveItem(itemState);
-     * @see ItemLifeCycleListener#itemCreated(ItemImpl)
+     * @see ItemLifeCycleListener#itemCreated(Item)
-    public void itemCreated(ItemImpl item) {
+    public void itemCreated(Item item) {
+        if (!(item instanceof ItemImpl)) {
+            String msg = "Incompatible Item object: " + ItemImpl.class.getName() + " expected.";
+            throw new IllegalArgumentException(msg);
+        }
-        cacheItem(item);
+        cacheItem(((ItemImpl)item).getItemState(), item);
-     * @see ItemLifeCycleListener#itemInvalidated(ItemImpl)
+     * @see ItemLifeCycleListener#itemInvalidated(Item)
-    public void itemInvalidated(ItemImpl item) {
+    public void itemInvalidated(Item item) {
+        if (!(item instanceof ItemImpl)) {
+            String msg = "Incompatible Item object: " + ItemImpl.class.getName() + " expected.";
+            throw new IllegalArgumentException(msg);
+        }
-        evictItem(item.getId());
+        evictItem(((ItemImpl)item).getItemState());
-     * @see ItemLifeCycleListener#itemDestroyed(ItemImpl)
+     * @see ItemLifeCycleListener#itemDestroyed(Item)
-    public void itemDestroyed(ItemImpl item) {
+    public void itemDestroyed(Item item) {
+        if (!(item instanceof ItemImpl)) {
+            String msg = "Incompatible Item object: " + ItemImpl.class.getName() + " expected.";
+            throw new IllegalArgumentException(msg);
+        }
-        item.removeLifeCycleListener(this);
+        ((ItemImpl)item).removeLifeCycleListener(this);
-        evictItem(item.getId());
+        evictItem(((ItemImpl)item).getItemState());
-        ps.println("ItemManagerImpl (" + this + ")");
+        ps.println("ItemManager (" + this + ")");
-            ItemId id = (ItemId) iter.next();
-            ItemImpl item = (ItemImpl) itemCache.get(id);
+            ItemState state = (ItemState) iter.next();
+            Item item = (Item) itemCache.get(state);
-            if (item.getItemState().isTransient()) {
-                ps.print("transient ");
+            if (item.isNew()) {
+                ps.print("new ");
+            } else if (item.isModified()) {
+                ps.print("modified ");
-                ps.print("          ");
+                ps.print("- ");
-            ps.println(id + "\t" + LogUtil.safeGetJCRPath(item.getItemState(), session.getNamespaceResolver(), hierMgr) + " (" + item + ")");
+            ps.println(state.getId() + "\t" + LogUtil.safeGetJCRPath(state, session.getNamespaceResolver(), hierMgr) + " (" + item + ")");
-                ItemImpl item = retrieveItem(id);
+                Item item = retrieveItem(state);
-                    evictItem(id);
+                    evictItem(state);
+    /**
+     *
+     * @param state
+     * @return
+     * @throws RepositoryException
+     */
+    /**
+     * 
+     * @param state
+     * @return
+     * @throws RepositoryException
+     */
-
-    /**
-     * Returns an item reference from the cache.
-     *
-     * @param id id of the item that should be retrieved.
-     * @return the item reference stored in the corresponding cache entry
-     *         or <code>null</code> if there's no corresponding cache entry.
-     */
-    private ItemImpl retrieveItem(ItemId id) {
-        return (ItemImpl) itemCache.get(id);
-    }
-
-    private void cacheItem(ItemImpl item) {
-        ItemId id = item.getId();
-        if (itemCache.containsKey(id)) {
-            log.warn("overwriting cached item " + id);
+    private void cacheItem(ItemState state, Item item) {
+        if (itemCache.containsKey(state)) {
+            log.warn("overwriting cached item " + state);
-            log.debug("caching item " + id);
+            log.debug("caching item " + state);
-        itemCache.put(id, item);
+        itemCache.put(state, item);
+    }
+
+    /**
+     * Returns an item reference from the cache.
+     *
+     * @param state State of the item that should be retrieved.
+     * @return the item reference stored in the corresponding cache entry
+     *         or <code>null</code> if there's no corresponding cache entry.
+     */
+    private Item retrieveItem(ItemState state) {
+        return (Item) itemCache.get(state);
-     * @param id id of the item to remove from the cache
+     * @param itemState state of the item to remove from the cache
-    private void evictItem(ItemId id) {
+    private void evictItem(ItemState itemState) {
-            log.debug("removing item " + id + " from cache");
+            log.debug("removing item " + itemState + " from cache");
-        itemCache.remove(id);
+        itemCache.remove(itemState);

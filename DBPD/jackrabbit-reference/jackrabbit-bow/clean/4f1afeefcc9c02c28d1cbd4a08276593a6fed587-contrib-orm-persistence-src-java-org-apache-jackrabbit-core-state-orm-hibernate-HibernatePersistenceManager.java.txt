committing as-is Patch for ORM-Persistence posted by serge

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@160306 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.state.PersistenceManager;
+import org.apache.ojb.broker.PersistenceBroker;
+import org.apache.jackrabbit.core.state.ChangeLog;
+import org.apache.ojb.broker.PersistenceBrokerFactory;
+import org.apache.ojb.broker.PersistenceBrokerException;
-public class HibernatePersistenceManager extends AbstractPersistenceManager {
+public class HibernatePersistenceManager implements PersistenceManager {
-                            BLOBFileValue blobValue = new BLOBFileValue(in);
-                            internalValueList.add(blobValue);
+                            internalValueList.add(InternalValue.create(in));
-    public void store(NodeState state) throws ItemStateException {
+    public void store(NodeState state, Session session) throws ItemStateException, HibernateException {
-        Session session = null;
-        Transaction tx = null;
-        try {
-            session = sessionFactory.openSession();
-            tx = session.beginTransaction();
-            tx.commit();
-        } catch (HibernateException he) {
-            try {
-                if (tx != null)
-                    tx.rollback();
-            } catch (HibernateException he2) {
-                log.error("Error while rolling back transaction", he2);
-            }
-            throw new ItemStateException("Error saving " + state.getId(), he);
-        } finally {
-            if (session != null) {
-                try {
-                    session.close();
-                } catch (HibernateException he) {
-                    throw new ItemStateException(
-                        "Error while closing hibernate session", he);
-                }
-            }
-        }
-    public void store(PropertyState state) throws ItemStateException {
+    public void store(PropertyState state, Session session) throws ItemStateException, HibernateException {
-        Session session = null;
-        Transaction tx = null;
-        try {
-            session = sessionFactory.openSession();
-            tx = session.beginTransaction();
-                                tx.rollback();
-                                session.close();
-            tx.commit();
-        } catch (HibernateException he) {
-            try {
-                if (tx != null)
-                    tx.rollback();
-            } catch (HibernateException he2) {
-                log.error("Error while rolling back transaction", he2);
-            }
-            throw new ItemStateException("Error saving " + state.getId(), he);
-        } finally {
-            if (session != null) {
-                try {
-                    session.close();
-                } catch (HibernateException he) {
-                    throw new ItemStateException(
-                        "Error while closing hibernate session", he);
-                }
-            }
-        }
-    public void store(NodeReferences refs) throws ItemStateException {
+    public void store(NodeReferences refs, Session session) throws ItemStateException, HibernateException {
-        Session session = null;
-        Transaction tx = null;
-        try {
-            session = sessionFactory.openSession();
-            tx = session.beginTransaction();
+        // destroy all the references before saving
+        destroy(refs, session);
+
-            tx.commit();
-        } catch (HibernateException he) {
-            try {
-                if (tx != null)
-                    tx.rollback();
-            } catch (HibernateException he2) {
-                log.error("Error while rolling back transaction", he2);
-            }
-            throw new ItemStateException(
-                "Error storing node references for targetId=" +
-                refs.getTargetId(), he);
-        } finally {
-            if (session != null) {
-                try {
-                    session.close();
-                } catch (HibernateException he) {
-                    throw new ItemStateException(
-                        "Error while closing hibernate session", he);
-                }
-            }
-        }
-    public void destroy(NodeState state) throws ItemStateException {
+    public void destroy(NodeState state, Session session) throws ItemStateException, HibernateException {
-        Session session = null;
-        Transaction tx = null;
-        try {
-            session = sessionFactory.openSession();
-            tx = session.beginTransaction();
-            tx.commit();
-        } catch (HibernateException he) {
-            try {
-                if (tx != null)
-                    tx.rollback();
-            } catch (HibernateException he2) {
-                log.error("Error while rolling back transaction", he2);
-            }
-            throw new ItemStateException("Error deleting " + state.getId(), he);
-        } finally {
-            if (session != null) {
-                try {
-                    session.close();
-                } catch (HibernateException he) {
-                    throw new ItemStateException(
-                        "Error while closing hibernate session", he);
-                }
-            }
-        }
-    public void destroy(PropertyState state) throws ItemStateException {
+    public void destroy(PropertyState state, Session session) throws ItemStateException, HibernateException {
-        Session session = null;
-        Transaction tx = null;
-        try {
-            session = sessionFactory.openSession();
-            tx = session.beginTransaction();
-            tx.commit();
-        } catch (HibernateException he) {
-            try {
-                if (tx != null)
-                    tx.rollback();
-            } catch (HibernateException he2) {
-                log.error("Error while rolling back transaction", he2);
-            }
-            throw new ItemStateException("Error deleting " + state.getId(), he);
-        } finally {
-            if (session != null) {
-                try {
-                    session.close();
-                } catch (HibernateException he) {
-                    throw new ItemStateException(
-                        "Error while closing hibernate session", he);
-                }
-            }
-        }
-    public void destroy(NodeReferences refs) throws ItemStateException {
+    public void destroy(NodeReferences refs, Session session) throws ItemStateException, HibernateException {
-        Session session = null;
-        Transaction tx = null;
-        try {
-            session = sessionFactory.openSession();
-            tx = session.beginTransaction();
-            tx.commit();
-        } catch (HibernateException he) {
-            try {
-                if (tx != null)
-                    tx.rollback();
-            } catch (HibernateException he2) {
-                log.error("Error while rolling back transaction", he2);
+    }
+
+    /**
+     * @see PersistenceManager#createNew
+     */
+    public NodeState createNew(NodeId id)
+    {
+        return new NodeState(id.getUUID(), null, null, NodeState.STATUS_NEW,
+                false);
+    }
+
+    /**
+     * @see PersistenceManager#createNew
+     */
+    public PropertyState createNew(PropertyId id)
+    {
+        return new PropertyState(id.getName(), id.getParentUUID(),
+                PropertyState.STATUS_NEW, false);
+    }
+
+    /**
+     * @see PersistenceManager#store(ChangeLog)
+     *
+     * This method ensures that changes are either written completely to the
+     * underlying persistence layer, or not at all.
+     */
+    public void store(ChangeLog changeLog) throws ItemStateException
+    {
+        Session session = null;
+        Transaction tx = null;
+        try
+        {
+            session = sessionFactory.openSession();
+            tx = session.beginTransaction();
+            Iterator iter = changeLog.deletedStates();
+            while (iter.hasNext())
+            {
+                ItemState state = (ItemState) iter.next();
+                if (state.isNode())
+                {
+                    destroy((NodeState) state, session);
+                } else
+                {
+                    destroy((PropertyState) state, session);
+                }
-            throw new ItemStateException(
-                "Error deleting node references for targetId=" +
-                refs.getTargetId().toString(), he);
-        } finally {
+            iter = changeLog.addedStates();
+            while (iter.hasNext())
+            {
+                ItemState state = (ItemState) iter.next();
+                if (state.isNode())
+                {
+                    store((NodeState) state, session);
+                } else
+                {
+                    store((PropertyState) state, session);
+                }
+            }
+            iter = changeLog.modifiedStates();
+            while (iter.hasNext())
+            {
+                ItemState state = (ItemState) iter.next();
+                if (state.isNode())
+                {
+                    store((NodeState) state, session);
+                } else
+                {
+                    store((PropertyState) state, session);
+                }
+            }
+            iter = changeLog.modifiedRefs();
+            while (iter.hasNext())
+            {
+                NodeReferences refs = (NodeReferences) iter.next();
+                if (refs.hasReferences())
+                {
+                    store(refs, session);
+                } else
+                {
+                    destroy(refs, session);
+                }
+            }
+            tx.commit() ;
+        } catch (ItemStateException e)
+        {
+            if (tx != null) {
+                try {
+                    tx.rollback();
+                } catch (HibernateException ex) {
+                    throw new ItemStateException("Error while rolling back", ex);
+                }
+            }
+            throw e;
+        } catch (HibernateException e)
+        {
+            if (tx != null) {
+                try {
+                    tx.rollback();
+                } catch (HibernateException ex) {
+                    throw new ItemStateException("Error while rolling back", ex);
+                }
+            }
+            throw new ItemStateException("Unable to store", e);
+        } finally
+        {
-                } catch (HibernateException he) {
-                    throw new ItemStateException(
-                        "Error while closing hibernate session", he);
+                } catch (HibernateException ex) {
+                    throw new ItemStateException("Error while closing session", ex);
+

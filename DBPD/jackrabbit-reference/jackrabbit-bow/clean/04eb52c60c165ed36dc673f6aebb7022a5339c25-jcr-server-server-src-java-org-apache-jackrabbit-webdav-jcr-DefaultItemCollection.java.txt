JCR-405: PROPPATCH doesn't respect document order
minor improvements within 'jcr' package:
- reorder nodes
- fixing creation/replacement of multivalued JCR properties
- contentlength for single value JCR properties
- improve spooling of resource content

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@397835 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.server.io.IOUtil;
+import org.apache.jackrabbit.webdav.xml.DomUtil;
+import org.apache.jackrabbit.webdav.io.OutputContext;
+import org.apache.jackrabbit.webdav.jcr.property.ValuesProperty;
-import org.apache.jackrabbit.webdav.property.DavPropertyIterator;
+import org.w3c.dom.Document;
+import org.xml.sax.SAXException;
+import javax.jcr.PathNotFoundException;
+import javax.xml.parsers.ParserConfigurationException;
-import java.io.FileNotFoundException;
+
+import java.io.OutputStream;
+import java.util.List;
-
-    private File content;
+    private static final String TMP_PREFIX = "_tmp_";
-
-     * Returns an {@link java.io.InputStream} to the content of this collection.
+     * If this resource represents an existing <code>Node</code> the system
+     * view is spooled as resource content.
+     *
+     * @param outputContext
+     * @throws IOException
+     * @see Session#exportSystemView(String, OutputStream, boolean, boolean)
-    public InputStream getStream() {
-        if (!initedProps)  {
-            initProperties();
-        }
-        if (content != null) {
-            try {
-                return new FileInputStream(content);
-            } catch (FileNotFoundException e) {
-                // should not occur
-                log.error(e.getMessage());
+    public void spool(OutputContext outputContext) throws IOException {
+        // spool properties
+        super.spool(outputContext);
+        // spool data
+        try {
+            OutputStream out = outputContext.getOutputStream();
+            if (out != null && exists()) {
+                getRepositorySession().exportSystemView(item.getPath(), out, false, true);
+        } catch (PathNotFoundException e) {
+            log.error("Error while spooling resource content: " + e.getMessage());
+        } catch (RepositoryException e) {
+            log.error("Error while spooling resource content: " + e.getMessage());
-        return null;
-     * Loops over the given <code>Set</code>s and alters the properties accordingly.
+     * Loops over the given <code>List</code>s and alters the properties accordingly.
-     * @param setProperties
-     * @param removePropertyNames
+     * @param changeList
-    public MultiStatusResponse alterProperties(DavPropertySet setProperties,
-                                DavPropertyNameSet removePropertyNames)
-        throws DavException {
-        DavPropertyIterator setIter = setProperties.iterator();
-        while (setIter.hasNext()) {
-            DavProperty prop = setIter.nextProperty();
-            // use the internal set method in order to prevent premature 'save'
-            internalSetProperty(prop);
-        }
-        Iterator remNameIter = removePropertyNames.iterator();
-        while (remNameIter.hasNext()) {
-            DavPropertyName propName = (DavPropertyName) remNameIter.next();
-            // use the internal set method in order to prevent premature 'save'
-            internalRemoveProperty(propName);
+    public MultiStatusResponse alterProperties(List changeList) throws DavException {
+        Iterator it = changeList.iterator();
+        while (it.hasNext()) {
+            Object propEntry = it.next();
+            if (propEntry instanceof DavPropertyName) {
+                // use the internal remove method in order to prevent premature 'save'
+                DavPropertyName propName = (DavPropertyName) propEntry;
+                internalRemoveProperty(propName);
+            } else if (propEntry instanceof DavProperty) {
+                // use the internal set method in order to prevent premature 'save'
+                DavProperty prop = (DavProperty) propEntry;
+                internalSetProperty(prop);
+            } else {
+                throw new IllegalArgumentException("unknown object in change list: " + propEntry.getClass().getName());
+            }
+        File tmpFile = null;
-                    // PUT: not possible
+                    // PUT: not possible without request body
-                    // TODO: find a way to create non-binary and multivalue properties
-                    // NOTE: will fail for multivalue properties.
-                    n.setProperty(memberName, in);
+                    tmpFile = File.createTempFile(TMP_PREFIX + memberName, null, null);
+                    FileOutputStream out = new FileOutputStream(tmpFile);
+                    IOUtil.spool(in, out);
+                    out.close();
+                    // try to parse the request body into a 'values' property.
+                    ValuesProperty vp = buildValuesProperty(new FileInputStream(tmpFile));
+                    if (vp != null) {
+                        if (JCR_VALUE.equals(vp.getName())) {
+                            n.setProperty(memberName, vp.getJcrValue());
+                        } else {
+                            n.setProperty(memberName, vp.getJcrValues());
+                        }
+                    } else {
+                        // request body cannot be parsed into a 'values' property.
+                        // fallback: try to import as single value from stream.
+                        n.setProperty(memberName, new FileInputStream(tmpFile));
+                    }
-            complete();
+            if (resource.exists() && resource instanceof AbstractItemResource) {
+                // PUT may modify value of existing jcr property. thus, this
+                // node is not modified by the 'addMember' call.
+                ((AbstractItemResource)resource).complete();
+            } else {
+                complete();
+            }
+        } finally {
+            if (tmpFile != null) {
+                tmpFile.delete();
+            }
-                String srcRelPath = Text.getName(instructions[i].getMemberHandle());
+                String srcRelPath = instructions[i].getMemberHandle();
+            complete();
-        String destPath = null;
+        String destRelPath = null;
-                destPath = firstChild.getPath();
+                // use last segment of node-path instead of name.
+                destRelPath = Text.getName(firstChild.getPath());
-            if (destPath == null) {
+            if (destRelPath == null) {
-            String afterRelPath = Text.getName(position.getSegment());
+            String afterRelPath = position.getSegment();
-            while (childNodes.hasNext() && destPath == null) {
-                String childPath = childNodes.nextNode().getPath();
+            while (childNodes.hasNext() && destRelPath == null) {
+                // compare to last segment of node-path instead of name.
+                String childRelPath = Text.getName(childNodes.nextNode().getPath());
-                    destPath = childPath;
+                    destRelPath = childRelPath;
-                    found = afterRelPath.equals(Text.getName(childPath));
+                    found = afterRelPath.equals(childRelPath);
-            destPath = position.getSegment();
+            // before or last. in the latter case the segmet is 'null'
+            destRelPath = position.getSegment();
-
-        return (destPath != null) ? Text.getName(destPath) : destPath;
+        return destRelPath;
-            try {
-                String prefix = "_tmp_" + item.getName();
-                // create tmpFile in default system-tmp directory
-                content = File.createTempFile(prefix, null, null);
-                content.deleteOnExit();
-                FileOutputStream out = new FileOutputStream(content);
-                getRepositorySession().exportSystemView(item.getPath(), out, false, true);
-                out.close();
-                properties.add(new DefaultDavProperty(DavPropertyName.GETCONTENTLENGTH, new Long(content.length())));
-                properties.add(new DefaultDavProperty(DavPropertyName.GETCONTENTTYPE, "text/xml"));
-
-            } catch (IOException e) {
-                log.error("Error while property initialization: "+e.getMessage());
-            } catch (RepositoryException e) {
-                log.error("Error while property initialization: "+e.getMessage());
-            }
-
+            // resource is serialized as system-view (xml)
+            properties.add(new DefaultDavProperty(DavPropertyName.GETCONTENTTYPE, "text/xml"));
+
+    /**
+     * Tries to parse the given input stream as xml document and build a
+     * {@link ValuesProperty} out of it.
+     *
+     * @param in
+     * @return values property or 'null' if the given stream cannot be parsed
+     * into an XML document or if build the property fails.
+     */
+    private ValuesProperty buildValuesProperty(InputStream in) {
+        String errorMsg = "Cannot parse stream into a 'ValuesProperty'.";
+        try {
+            Document reqBody = DomUtil.BUILDER_FACTORY.newDocumentBuilder().parse(in);
+            DavProperty defaultProp = DefaultDavProperty.createFromXml(reqBody.getDocumentElement());
+            ValuesProperty vp = new ValuesProperty(defaultProp, PropertyType.STRING);
+            return vp;
+        } catch (IOException e) {
+            log.debug(errorMsg, e);
+        } catch (ParserConfigurationException e) {
+            log.debug(errorMsg, e);
+        } catch (SAXException e) {
+            log.debug(errorMsg, e);
+        } catch (DavException e) {
+            log.debug(errorMsg, e);
+        } catch (RepositoryException e) {
+            log.debug(errorMsg, e);
+        }
+        // cannot parse request body into a 'values' property
+        return null;
+    }

JCR-2762: Optimize bundle serialization

Add common names used by the access control features. Reorder names by popularity.

Rename read/writeInt() to read/writeVarInt() as suggested by Thomas. Remove recursion from writeVarInt().

Minor optimizations in read/writeName(), including a fix to the case where the local name is more than 15 characters long.

Extend the use of read/writeVarInt() and read/writeString() to more places in the code.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1022488 13f79535-47bb-0310-9956-ffa450edef68

-        writeInt(bundle.getModCount());
+        writeVarInt(bundle.getModCount());
-     * integer (see {@link #writeInt(int)}) right after this byte.
+     * integer (see {@link #writeVarInt(int)}) right after this byte.
-                writeInt(len - 0x0f);
+                writeVarInt(len - 0x0f);
-        writeInt(state.getModCount());
+        writeVarInt(state.getModCount());
-                                out.writeUTF(val.toString());
+                                writeString(val.toString());
-                            out.writeUTF(blobId);   // value
+                            writeString(blobId);   // value
-                    // because writeUTF(String) has a size limit of 64k,
-                    // we're using write(byte[]) instead
-                    byte[] bytes = val.toString().getBytes("UTF-8");
-                    writeInt(bytes.length); // length of byte[]
-                    out.write(bytes);   // byte[]
+                    writeString(val.toString());
+                    break;
-            out.writeUTF(decimal.toString());
+            writeString(decimal.toString());
-     * {@link DataOutputStream#writeUTF(String)} right after this byte.
+     * {@link #writeString(String)} right after this byte.
-     * 0x0f is stored as the name length and the name string is written
-     * using {@link DataOutputStream#writeUTF(String)}.
+     * 0x0f is stored as the name length and the name string is written as
+     * UTF-8 using {@link #writeBytes(byte[], int)} with a base length of
+     * 0x10 (0x0f + 1).
-                out.writeUTF(uri);
+                writeString(uri);
-                out.writeUTF(local);
+                writeBytes(bytes, 0x0f + 1);
-    private void writeInt(int value) throws IOException {
-        int b = value & 0x7f;
-        if (b == value) {
-            out.writeByte(b);
-        } else {
-            out.writeByte(b | 0x80);
-            writeInt(value >>> 7);
+    private void writeVarInt(int value) throws IOException {
+        while (true) {
+            int b = value & 0x7f;
+            if (b != value) {
+                out.writeByte(b | 0x80);
+                value >>>= 7; // unsigned shift
+            } else {
+                out.writeByte(b);
+                return;
+            }
+    /**
+     * Serializes a string in UTF-8. The length of the UTF-8 byte sequence
+     * is first written as a variable-length string (see
+     * {@link #writeVarInt(int)}), and then the sequence itself is written.
+     *
+     * @param value string value
+     * @throws IOException if an I/O error occurs
+     */
+    private void writeString(String value) throws IOException {
+        writeBytes(value.getBytes("UTF-8"), 0);
+    }
+
+    /**
+     * Serializes the given array of bytes. The length of the byte array is
+     * first written as a {@link #writeVarInt(int) variable length integer},
+     * followed by the given bytes.
+     *
+     * @param bytes the bytes to be serialized
+     * @param base optional base length
+     * @throws IOException if an I/O error occurs
+     */
+    private void writeBytes(byte[] bytes, int base) throws IOException {
+        assert bytes.length >= base;
+        writeVarInt(bytes.length - base);
+        out.write(bytes);
+    }
+

JCR-688: Extracted the generational cache to a separate class

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@494560 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-
- * <p>
- * The cache consists of three parts: a long term cache and two generations
- * of recent cache entries. The two generations are used to collect recent new
- * entries, and those entries that are used within two successive generations
- * get promoted to the long term cache. The entries within the long term cache
- * are discarded only when the size of the cache exceeds the given maximum
- * cache size.
-     * Default maximum cache size.
-     */
-    private static final int DEFAULT_CACHE_SIZE = 1000;
-
-    /**
-     * Divisor used to determine the default generation age from the
-     * maximum cache size.
-     */
-    private static final int DEFAULT_SIZE_AGE_RATIO = 10;
-
-    /**
-     * Maximum size of the name cache.
+     * Generational cache.
-    private final int maxSize;
+    private final GenerationalCache cache;
-     * Maximum age of a cache generation.
-     */
-    private final int maxAge;
-
-    /**
-     * Long term name cache. Read only.
-     */
-    private Map cache = new HashMap();
-
-    /**
-     * Old cache generation. Read only.
-     */
-    private Map old = new HashMap();
-
-    /**
-     * Young cache generation. Write only.
-     */
-    private Map young = new HashMap();
-
-    /**
-     * Age of the young cache generation.
-     */
-    private int age = 0;
-
-    /**
-     * Creates a caching name resolver.
+     * Creates a caching decorator for the given name resolver. The given
+     * generational cache is used for caching.
-     * @param maxSize maximum size of the long term cache
-     * @param maxAge maximum age of a cache generation
+     * @param cache generational cache
-    public CachingNameResolver(NameResolver resolver, int maxSize, int maxAge) {
+    public CachingNameResolver(NameResolver resolver, GenerationalCache cache) {
-        this.maxSize = maxSize;
-        this.maxAge = maxAge;
+        this.cache = cache;
-     * Creates a caching name resolver using the default generation age for
-     * the given cache size.
+     * Creates a caching decorator for the given name resolver.
-     * @param resolver decorated name resolver
-     * @param maxSize maximum size of the long term cache
-     */
-    public CachingNameResolver(NameResolver resolver, int maxSize) {
-        this(resolver, maxSize, maxSize / DEFAULT_SIZE_AGE_RATIO);
-    }
-
-    /**
-     * Creates a caching name resolver using the default size and
-     * generation age.
-     *
-     * @param resolver decorated name resolver
+     * @param resolver name resolver
-        this(resolver, DEFAULT_CACHE_SIZE);
-    }
-
-    /**
-     * Caches the given key-value pair and increases the age of the current
-     * cache generation. When the maximum age of a generation is reached,
-     * the following steps are taken:
-     * <ol>
-     *   <li>The union of the two cache generations is calculated</li>
-     *   <li>The union is added to the long term name cache</li>
-     *   <li>If the cache size exceeds the maximum, only the union is kept</li>
-     *   <li>A new cache generation is started</li>
-     * </ol>
-     *
-     * @param key key of the cache entry
-     * @param value value of the cache entry
-     */
-    private synchronized void cache(Object key, Object value) {
-        young.put(key, value);
-
-        if (++age == maxAge) {
-            Map union = new HashMap();
-            Iterator iterator = old.entrySet().iterator();
-            while (iterator.hasNext()) {
-                Map.Entry entry = (Map.Entry) iterator.next();
-                if (young.containsKey(entry.getKey())) {
-                    union.put(entry.getKey(), entry.getValue());
-                }
-            }
-
-            if (!union.isEmpty()) {
-                if (cache.size() + union.size() <= maxSize) {
-                    union.putAll(cache);
-                }
-                cache = union;
-            }
-
-            old = young;
-            young = new HashMap();
-            age = 0;
-        }
+        this(resolver, new GenerationalCache());
-            qname = (QName) old.get(name);
-            if (qname == null) {
-                qname = resolver.getQName(name);
-            }
-            cache(name, qname);
+            qname = resolver.getQName(name);
+            cache.put(name, qname);
-     * Returns the prefixed JCR name for the given qualified name.
-     * If the name is in the default namespace, then the local name
-     * is returned without a prefix. Otherwise the name is first looked
-     * up form the generational cache and the call gets delegated to the
-     * decorated name resolver only if the cache misses.
+     * Returns the prefixed JCR name for the given qualified name. The name
+     * is first looked up form the generational cache and the call gets
+     * delegated to the decorated name resolver only if the cache misses.
-            name = (String) old.get(qname);
-            if (name == null) {
-                name = resolver.getJCRName(qname);
-            }
-            cache(qname, name);
+            name = resolver.getJCRName(qname);
+            cache.put(qname, name);

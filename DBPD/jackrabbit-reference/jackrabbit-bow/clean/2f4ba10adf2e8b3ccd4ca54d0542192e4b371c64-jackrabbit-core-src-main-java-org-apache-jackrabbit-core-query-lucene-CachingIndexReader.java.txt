JCR-2524: Reduce memory usage of DocIds

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@924677 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Arrays;
+import java.util.concurrent.ConcurrentHashMap;
-     * Cache of nodes parent relation. If an entry in the array is not null,
-     * that means the node with the document number = array-index has the node
-     * with <code>DocId</code> as parent.
+     * Cache of nodes parent relation. If an entry in the array is >= 0,
+     * then that means the node with the document number = array-index has the
+     * node with the value at that position as parent.
-    private final DocId[] parents;
+    private final int[] inSegmentParents;
-     * Initializes the {@link #parents} cache.
+     * Cache of nodes parent relation that point to a foreign index segment.
+     */
+    private final Map<Integer, DocId> foreignParentDocIds = new ConcurrentHashMap<Integer, DocId>();
+
+    /**
+     * Initializes the {@link #inSegmentParents} and {@link #foreignParentDocIds}
+     * caches.
-     * @param initCache if the {@link #parents} cache should be initialized
+     * @param initCache if the parent caches should be initialized
-        this.parents = new DocId[delegatee.maxDoc()];
+        this.inSegmentParents = new int[delegatee.maxDoc()];
+        Arrays.fill(this.inSegmentParents, -1);
-        parent = parents[n];
+        int parentDocNum = inSegmentParents[n];
+        if (parentDocNum != -1) {
+            parent = DocId.create(parentDocNum);
+        } else {
+            parent = foreignParentDocIds.get(n);
+        }
+            int plainDocId = -1;
-                                    parent = DocId.create(docs.doc());
+                                    plainDocId = docs.doc();
+                                    parent = DocId.create(plainDocId);
-            parents[n] = parent;
+            if (plainDocId != -1) {
+                // PlainDocId
+                inSegmentParents[n] = plainDocId;
+            } else {
+                // UUIDDocId
+                foreignParentDocIds.put(n, parent);
+                if (existing) {
+                    // there was an existing parent reference in
+                    // inSegmentParents, which was invalid and is replaced
+                    // with a UUIDDocId (points to a foreign segment).
+                    // mark as unknown
+                    inSegmentParents[n] = -1;
+                }
+            }
-     * Initializes the {@link CachingIndexReader#parents} cache.
+     * Initializes the {@link CachingIndexReader#inSegmentParents} and
+     * {@link CachingIndexReader#foreignParentDocIds} caches.
-         * Initializes the {@link CachingIndexReader#parents} <code>DocId</code>
-         * array.
+         * Initializes the {@link CachingIndexReader#inSegmentParents} and
+         * {@link CachingIndexReader#foreignParentDocIds} caches.
-                    parents[info.docId] = DocId.create(parent.docId);
+                    inSegmentParents[info.docId] = parent.docId;
-                    parents[info.docId] = DocId.create(info.parent);
+                    foreignParentDocIds.put(info.docId, DocId.create(info.parent));
-                    parents[info.docId] = DocId.create(doc.getValues(FieldNames.PARENT));
+                    foreignParentDocIds.put(info.docId, DocId.create(doc.getValues(FieldNames.PARENT)));
-                    parents[info.docId] = DocId.NULL;
+                    foreignParentDocIds.put(info.docId, DocId.NULL);
-                if (parents.length > 0) {
-                    foreignParents /= parents.length;
+                if (inSegmentParents.length > 0) {
+                    foreignParents /= inSegmentParents.length;
-                            parents.length,
+                            inSegmentParents.length,

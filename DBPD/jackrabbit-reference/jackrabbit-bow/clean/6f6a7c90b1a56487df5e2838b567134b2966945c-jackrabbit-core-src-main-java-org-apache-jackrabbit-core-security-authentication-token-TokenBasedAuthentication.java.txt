JCR-3687 : Backport improvements made to token based auth in OAK

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1537027 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.api.security.authentication.token.TokenCredentials;
-import org.apache.jackrabbit.api.security.principal.ItemBasedPrincipal;
-import org.apache.jackrabbit.api.security.user.User;
-import org.apache.jackrabbit.core.NodeImpl;
-import org.apache.jackrabbit.core.SessionImpl;
-import org.apache.jackrabbit.core.id.NodeId;
-import org.apache.jackrabbit.core.id.NodeIdFactory;
-import org.apache.jackrabbit.core.security.SecurityConstants;
-import org.apache.jackrabbit.core.security.authentication.Authentication;
-import org.apache.jackrabbit.spi.Name;
-import org.apache.jackrabbit.util.ISO8601;
-import org.apache.jackrabbit.util.Text;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
+import java.util.Date;
-import javax.jcr.Property;
-import javax.jcr.PropertyIterator;
-import java.io.UnsupportedEncodingException;
-import java.security.NoSuchAlgorithmException;
-import java.security.Principal;
-import java.security.SecureRandom;
-import java.util.Arrays;
-import java.util.Calendar;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Date;
-import java.util.GregorianCalendar;
-import java.util.HashMap;
-import java.util.Map;
+
+import org.apache.jackrabbit.api.JackrabbitSession;
+import org.apache.jackrabbit.api.security.authentication.token.TokenCredentials;
+import org.apache.jackrabbit.api.security.user.User;
+import org.apache.jackrabbit.core.NodeImpl;
+import org.apache.jackrabbit.core.SessionImpl;
+import org.apache.jackrabbit.core.security.authentication.Authentication;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
-    private static final String TOKEN_ATTRIBUTE_EXPIRY = TOKEN_ATTRIBUTE + ".exp";
-    private static final String TOKEN_ATTRIBUTE_KEY = TOKEN_ATTRIBUTE + ".key";
-    private static final String TOKENS_NODE_NAME = ".tokens";
-    private static final String TOKENS_NT_NAME = "nt:unstructured"; // TODO: configurable
+    /**
+     * @deprecated This system parameter allows to enable backwards compatible
+     * behavior of the {@code TokenBasedAuthentication}. Note that as of OAK 1.0
+     * this flag will no be supported.
+     */
+    public static final String PARAM_COMPAT = "TokenCompatMode";
-    private static final char DELIM = '_';
-
-    private final String token;
-    private final long tokenExpiration;
-    private final Session session;
-
-    private final Map<String, String> attributes;
-    private final Map<String, String> info;
-    private final long expiry;
-    private final String key;
+    private final TokenInfo tokenInfo;
-        this.session = session;
-        this.tokenExpiration = tokenExpiration;
-        this.token = token;
-        long expTime = Long.MAX_VALUE;
-        String keyV = null;
-        if (token != null) {
-            attributes = new HashMap<String, String>();
-            info = new HashMap<String, String>();
-
-            Node n = getTokenNode(token, session);
-            PropertyIterator it = n.getProperties();
-            while (it.hasNext()) {
-                Property p = it.nextProperty();
-                String name = p.getName();
-                if (TOKEN_ATTRIBUTE_EXPIRY.equals(name)) {
-                    expTime = p.getLong();
-                } else if (TOKEN_ATTRIBUTE_KEY.equals(name)) {
-                    keyV = p.getString();
-                } else if (isMandatoryAttribute(name)) {
-                    attributes.put(name, p.getString());
-                } else if (isInfoAttribute(name)) {
-                    info.put(name, p.getString());
-                } // else: jcr property -> ignore
-            }
+        if (compatMode()) {
+            this.tokenInfo = new CompatTokenProvider((SessionImpl) session, tokenExpiration).getTokenInfo(token);
-            attributes = Collections.emptyMap();
-            info = Collections.emptyMap();
+            this.tokenInfo = new TokenProvider((SessionImpl) session, tokenExpiration).getTokenInfo(token);
-        expiry = expTime;
-        key = keyV;
+
-        return token != null && isTokenBasedLogin(credentials);
+        return tokenInfo != null && isTokenBasedLogin(credentials);
+        return validateCredentials(tokenCredentials);
+    }
-        // credentials without userID -> check if attributes provide
-        // sufficient information for successful authentication.
-        if (token.equals(tokenCredentials.getToken())) {
-            long loginTime = new Date().getTime();
-            // test if the token has already expired
-            if (expiry < loginTime) {
-                // already expired -> login fails.
-                // ... remove the expired token node before aborting the login
-                removeToken();
-                return false;
-            }
+    private boolean validateCredentials(TokenCredentials tokenCredentials) throws RepositoryException {
+        if (tokenInfo == null) {
+            log.debug("No valid TokenInfo for token.");
+            return false;
+        }
-            // test for matching key
-            if (key != null && !key.equals(getDigestedKey(tokenCredentials))) {
-                return false;
-            }
+        long loginTime = new Date().getTime();
+        if (tokenInfo.isExpired(loginTime)) {
+            // token is expired
+            log.debug("Token is expired");
+            tokenInfo.remove();
+            return false;
+        }
-            // check if all other required attributes match
-            for (String name : attributes.keySet()) {
-                if (!attributes.get(name).equals(tokenCredentials.getAttribute(name))) {
-                    // no match -> login fails.
-                    return false;
-                }
-            }
-
-            // update set of informative attributes on the credentials
-            // based on the properties present on the token node.
-            Collection<String> attrNames = Arrays.asList(tokenCredentials.getAttributeNames());
-            for (String key : info.keySet()) {
-                if (!attrNames.contains(key)) {
-                    tokenCredentials.setAttribute(key, info.get(key));
-                }
-            }
-
-            // update token node if required: optionally resetting the expiration
-            updateTokenNode(expiry, loginTime);
-
+        if (tokenInfo.matches(tokenCredentials)) {
+            tokenInfo.resetExpiration(loginTime);
-        // wrong credentials that cannot be compared by this authentication
-    /**
-     * Performs the following checks/updates:
-     * <ol>
-     * <li>Reset the expiration if half of the expiration has passed in order to
-     * minimize write operations (avoid resetting upon each login).</li>
-     * </ol>
-     *
-     * @param tokenExpiry
-     * @param loginTime
-     */
-    private void updateTokenNode(long tokenExpiry, long loginTime) {
-        Node tokenNode;
-        Session s = null;
-        try {
-            // expiry...
-            if (tokenExpiry - loginTime <= tokenExpiration/2) {
-                long expirationTime = loginTime + tokenExpiration;
-                Calendar cal = GregorianCalendar.getInstance();
-                cal.setTimeInMillis(expirationTime);
-
-                s = ((SessionImpl) session).createSession(session.getWorkspace().getName());
-                tokenNode = getTokenNode(token, s);
-                tokenNode.setProperty(TOKEN_ATTRIBUTE_EXPIRY, s.getValueFactory().createValue(cal));
-                s.save();
-            }
-        } catch (RepositoryException e) {
-            log.warn("Failed to update expiry or informative attributes of token node.", e);
-        } finally {
-            if (s != null) {
-                s.logout();
-            }
-        }
-    }
-
-    /**
-     * Remove the node associated with the expired token defined by this TokenBasedAuthentication.
-     */
-    private void removeToken() {
-        Session s = null;
-        try {
-            s = ((SessionImpl) session).createSession(session.getWorkspace().getName());
-            Node tokenNode = getTokenNode(token, s);
-            
-            tokenNode.remove();
-            s.save();
-        } catch (RepositoryException e) {
-            log.warn("Internal error while removing token node.", e);
-        } finally {
-            if (s != null) {
-                s.logout();
-            }
-        }
-    }
-
-     *  
+     *
-        return attributeName != null && attributeName.startsWith(TOKEN_ATTRIBUTE);
-    }
-
-    /**
-     * Returns <code>false</code> if the specified attribute name doesn't have
-     * a 'jcr' or 'rep' namespace prefix; <code>true</code> otherwise. This is
-     * a lazy evaluation in order to avoid testing the defining node type of
-     * the associated jcr property.
-     *
-     * @param propertyName
-     * @return <code>true</code> if the specified property name doesn't seem
-     * to represent repository internal information.
-     */
-    private static boolean isInfoAttribute(String propertyName) {
-        String prefix = Text.getNamespacePrefix(propertyName);
-        return !Name.NS_JCR_PREFIX.equals(prefix) && !Name.NS_REP_PREFIX.equals(prefix);
+        if (compatMode()) {
+            return CompatTokenProvider.isMandatoryAttribute(attributeName);
+        } else {
+            return TokenProvider.isMandatoryAttribute(attributeName);
+        }
-                                                       long tokenExpiration, Session session) throws RepositoryException {
+                                          long tokenExpiration, Session session) throws RepositoryException {
-        String userPath = null;
-        Principal pr = user.getPrincipal();
-        if (pr instanceof ItemBasedPrincipal) {
-            userPath = ((ItemBasedPrincipal) pr).getPath();
+
+        TokenInfo ti;
+        if (compatMode()) {
+            ti = new CompatTokenProvider((SessionImpl) session, tokenExpiration).createToken(user, credentials);
+        } else {
+            ti = new TokenProvider((SessionImpl) session, tokenExpiration).createToken(user, credentials);
-        TokenCredentials tokenCredentials;
-        if (userPath != null && session.nodeExists(userPath)) {
-            Node userNode = session.getNode(userPath);
-            Node tokenParent;
-            if (!userNode.hasNode(TOKENS_NODE_NAME)) {
-                userNode.addNode(TOKENS_NODE_NAME, TOKENS_NT_NAME);
-                try {
-                    session.save();
-                } catch (RepositoryException e) {
-                    // may happen when .tokens node is created concurrently
-                    session.refresh(false);
-                }
-            }
-            tokenParent = userNode.getNode(TOKENS_NODE_NAME);
-
-            long creationTime = new Date().getTime();
-            long expirationTime = creationTime + tokenExpiration;
-
-            Calendar cal = GregorianCalendar.getInstance();
-            cal.setTimeInMillis(creationTime);
-
-            // generate key part of the login token
-            String key = generateKey(8);
-
-            // create the token node
-            String tokenName = Text.replace(ISO8601.format(cal), ":", ".");
-            Node tokenNode;
-            // avoid usage of sequential nodeIDs
-            if (System.getProperty(NodeIdFactory.SEQUENTIAL_NODE_ID) == null) {
-                tokenNode = tokenParent.addNode(tokenName);
-            } else {
-                tokenNode = ((NodeImpl) tokenParent).addNodeWithUuid(tokenName, NodeId.randomId().toString());
-            }
-
-            StringBuilder sb = new StringBuilder(tokenNode.getIdentifier());
-            sb.append(DELIM).append(key);
-
-            String token = sb.toString();
-            tokenCredentials = new TokenCredentials(token);
-            credentials.setAttribute(TOKEN_ATTRIBUTE, token);
-
-            // add key property
-            tokenNode.setProperty(TOKEN_ATTRIBUTE_KEY, getDigestedKey(key));
-
-            // add expiration time property
-            cal.setTimeInMillis(expirationTime);
-            tokenNode.setProperty(TOKEN_ATTRIBUTE_EXPIRY, session.getValueFactory().createValue(cal));
-
-            // add additional attributes passed in by the credentials.
-            for (String name : credentials.getAttributeNames()) {
-                if (!TOKEN_ATTRIBUTE.equals(name)) {
-                    String value = credentials.getAttribute(name).toString();
-                    tokenNode.setProperty(name, value);
-                    tokenCredentials.setAttribute(name, value);
-                }
-            }
-            session.save();
-            return tokenCredentials;
+        if (ti != null) {
+            return ti.getCredentials();
-            throw new RepositoryException("Cannot create login token: No corresponding node for User " + user.getID() +" in workspace '" + workspaceName + "'.");
+            throw new RepositoryException("Cannot create login token.");
-        return getTokenNode(credentials.getToken(), session);
-    }
-
-    private static Node getTokenNode(String token, Session session) throws RepositoryException {
-        int pos = token.indexOf(DELIM);
-        String id = (pos == -1) ? token : token.substring(0, pos);
-        return session.getNodeByIdentifier(id);
-    }
-
-    private static String generateKey(int size) {
-        SecureRandom random = new SecureRandom();
-        byte key[] = new byte[size];
-        random.nextBytes(key);
-
-        StringBuffer res = new StringBuffer(key.length * 2);
-        for (byte b : key) {
-            res.append(Text.hexTable[(b >> 4) & 15]);
-            res.append(Text.hexTable[b & 15]);
+        if (compatMode()) {
+            return CompatTokenProvider.getTokenNode(credentials.getToken(), session);
+        } else {
+            return TokenProvider.getTokenNode(credentials.getToken(), session);
-        return res.toString();
-    private static String getDigestedKey(TokenCredentials tc) throws RepositoryException {
-        String tk = tc.getToken();
-        int pos = tk.indexOf(DELIM);
-        if (pos > -1) {
-            return getDigestedKey(tk.substring(pos+1));
-        }     
-        return null;
-    }
-    private static String getDigestedKey(String key) throws RepositoryException {
-        try {
-            StringBuilder sb = new StringBuilder();
-            sb.append("{").append(SecurityConstants.DEFAULT_DIGEST).append("}");
-            sb.append(Text.digest(SecurityConstants.DEFAULT_DIGEST, key, "UTF-8"));
-            return sb.toString();
-        } catch (NoSuchAlgorithmException e) {
-            throw new RepositoryException("Failed to generate login token.");
-        } catch (UnsupportedEncodingException e) {
-            throw new RepositoryException("Failed to generate login token.");
+    public static String getUserId(TokenCredentials tokenCredentials, Session session) throws RepositoryException {
+        if (compatMode()) {
+            return CompatTokenProvider.getUserId(tokenCredentials, session);
+        } else {
+            if (!(session instanceof JackrabbitSession)) {
+                throw new RepositoryException("JackrabbitSession expected");
+            }
+            NodeImpl n = (NodeImpl) getTokenNode(tokenCredentials, session);
+            return TokenProvider.getUserId(n, ((JackrabbitSession) session).getUserManager());
+
+    private static boolean compatMode() {
+        return Boolean.parseBoolean(System.getProperty(PARAM_COMPAT));
+    }

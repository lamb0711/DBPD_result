JCR-1276: A Property and a Node Can Have the Same Name

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@605622 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.Name;
+import org.apache.jackrabbit.spi.Path;
-import org.apache.jackrabbit.spi.Path;
-import org.apache.jackrabbit.spi.Name;
-import org.apache.jackrabbit.spi.commons.name.PathMap;
+import org.apache.jackrabbit.spi.commons.name.PathMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Set;
-import java.util.HashMap;
-import java.io.PrintStream;
-
+import java.io.PrintStream;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Set;
-    protected ItemId resolvePath(Path path, ItemState state, int next)
-            throws ItemStateException {
+    protected void beforeResolvePath(Path path, ItemState state, int next) {
-                cache((NodeState) state, parentPath);
+                cache(((NodeState) state).getNodeId(), parentPath);
-        return super.resolvePath(path, state, next);
-                cache((NodeState) state, builder.getPath());
+                cache(((NodeState) state).getNodeId(), builder.getPath());
-
+        ItemId id;
-            return super.resolvePath(path);
+            id = super.resolvePath(path);
+        } else {
+            LRUEntry entry = (LRUEntry) element.get();
+            if (element.hasPath(path)) {
+                entry.touch();
+                return entry.getId();
+            }
+            // first try to resolve node path, then property path
+            id = super.resolvePath(path, entry.getId(), element.getDepth() + 1, true);
+            if (id == null) {
+                id = super.resolvePath(path, entry.getId(), element.getDepth() + 1, false);
+            }
-        LRUEntry entry = (LRUEntry) element.get();
-        if (element.hasPath(path)) {
-            entry.touch();
-            return entry.getId();
+
+        if (id != null && id.denotesNode() && !isCached(id)) {
+            // cache result
+            cache((NodeId) id, path);
-        return super.resolvePath(path, entry.getId(), element.getDepth() + 1);
+
+        return id;
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p/>
+     * Check the path indicated inside our cache first.
+     */
+    public NodeId resolveNodePath(Path path) throws RepositoryException {
+        ItemId id = resolvePath(path);
+        return id != null && id.denotesNode() ? (NodeId) id : null;
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p/>
+     * Check the path indicated inside our cache first.
+     */
+    public PropertyId resolvePropertyPath(Path path) throws RepositoryException {
+        // Run base class shortcut and sanity checks first
+        if (path.denotesRoot()) {
+            return null;
+        } else if (!path.isCanonical()) {
+            String msg = "path is not canonical";
+            log.debug(msg);
+            throw new RepositoryException(msg);
+        }
+
+        // check cache for parent path
+        PathMap.Element element = map(path.getAncestor(1));
+        if (element == null) {
+            return super.resolvePropertyPath(path);
+        } else {
+            LRUEntry entry = (LRUEntry) element.get();
+            return (PropertyId) super.resolvePath(path, entry.getId(), element.getDepth() + 1, false);
+        }
-     * Cache an item in the hierarchy given its id and path. Adds a listener
-     * for this item state to get notified about changes.
+     * Cache an item in the hierarchy given its id and path.
-     * @param state node state
-     * @param path  path to item
+     * @param id   node id
+     * @param path path to item
-    private void cache(NodeState state, Path path) {
-        NodeId id = state.getNodeId();
-
+    private void cache(NodeId id, Path path) {

fixing/changing xml representation of node type definitions

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@47157 13f79535-47bb-0310-9956-ffa450edef68

+import org.jdom.filter.Filter;
+import org.jdom.filter.ContentFilter;
+import org.jdom.output.Format;
-    private static final String ROOT_ELEMENT_NAME = "nodeTypes";
-    private static final String NODETYPE_ELEMENT_NAME = "nodeType";
+    private static final String ROOT_ELEMENT = "nodeTypes";
+    private static final String NODETYPE_ELEMENT = "nodeType";
-    private static final String SUPERTYPES_ATTRIBUTE = "supertypes";
-    private static final String PROPERTYDEF_ELEMENT_NAME = "propertyDef";
+    private static final String SUPERTYPES_ELEMENT = "supertypes";
+    private static final String SUPERTYPE_ELEMENT = "supertype";
+    private static final String PROPERTYDEF_ELEMENT = "propertyDef";
-    private static final String VALUECONSTRAINT_ATTRIBUTE = "valueConstraint";
-    private static final String DEFAULTVALUES_ATTRIBUTE = "defaultValues";
+    private static final String VALUECONSTRAINTS_ELEMENT = "valueConstraints";
+    private static final String VALUECONSTRAINT_ELEMENT = "valueConstraint";
+    private static final String DEFAULTVALUES_ELEMENT = "defaultValues";
+    private static final String DEFAULTVALUE_ELEMENT = "defaultValue";
-    private static final String CHILDNODEDEF_ELEMENT_NAME = "childNodeDef";
-    private static final String REQUIREDPRIMARYTYPES_ATTRIBUTE = "requiredPrimaryTypes";
+    private static final String CHILDNODEDEF_ELEMENT = "childNodeDef";
+    private static final String REQUIREDPRIMARYTYPES_ELEMENT = "requiredPrimaryTypes";
+    private static final String REQUIREDPRIMARYTYPE_ELEMENT = "requiredPrimaryType";
-	    String error = "internal error: failed to parse persistent node type definitions";
-	    log.error(error);
-	    throw new RepositoryException(error);
+	    String msg = "internal error: failed to parse persistent node type definitions";
+	    log.error(msg, jde);
+	    throw new RepositoryException(msg, jde);
-	Iterator iter = root.getChildren(NODETYPE_ELEMENT_NAME).iterator();
+	Iterator iter = root.getChildren(NODETYPE_ELEMENT).iterator();
-	Element root = new Element(ROOT_ELEMENT_NAME);
+	Element root = new Element(ROOT_ELEMENT);
-	    Element ntElem = new Element(NODETYPE_ELEMENT_NAME);
+	    Element ntElem = new Element(NODETYPE_ELEMENT);
-	XMLOutputter serializer = new XMLOutputter("\t", true);
+	XMLOutputter serializer = new XMLOutputter(Format.getPrettyFormat());
+
-	    throw new InvalidNodeTypeDefException("invalid node type name:" + sntName, e);
+	    String msg = "invalid serialized node type definition [" + sntName + "]: invalid node type name: " + sntName;
+	    log.error(msg, e);
+	    throw new InvalidNodeTypeDefException(msg, e);
-	String supertypes = ntElem.getAttributeValue(SUPERTYPES_ATTRIBUTE);
-	if (supertypes != null && supertypes.length() > 0) {
-	    String[] sta = supertypes.split(",\\s*");
-	    QName[] qNames = new QName[sta.length];
-	    for (int i = 0; i < sta.length; i++) {
-		try {
-		    qNames[i] = QName.fromJCRName(sta[i], nsResolver);
-		} catch (BaseException e) {
-		    throw new InvalidNodeTypeDefException("invalid supertype name:" + sta[i], e);
+	ArrayList list = new ArrayList();
+	Element typesElem = ntElem.getChild(SUPERTYPES_ELEMENT);
+	if (typesElem != null) {
+	    Iterator iter = typesElem.getChildren(SUPERTYPE_ELEMENT).iterator();
+	    while (iter.hasNext()) {
+		Element typeElem = (Element) iter.next();
+		Filter filter = new ContentFilter(ContentFilter.TEXT | ContentFilter.CDATA);
+		List content = typeElem.getContent(filter);
+		if (!content.isEmpty()) {
+		    String name = typeElem.getTextTrim();
+		    try {
+			list.add(QName.fromJCRName(name, nsResolver));
+		    } catch (BaseException e) {
+			String msg = "invalid serialized node type definition [" + sntName + "]: invalid supertype: " + name;
+			log.error(msg, e);
+			throw new InvalidNodeTypeDefException(msg, e);
+		    }
-	    if (sta.length > 0) {
-		ntDef.setSupertypes(qNames);
+	    if (!list.isEmpty()) {
+		ntDef.setSupertypes((QName[]) list.toArray(new QName[list.size()]));
+
+
-	ArrayList list = new ArrayList();
-	Iterator iter = ntElem.getChildren(PROPERTYDEF_ELEMENT_NAME).iterator();
+	list.clear();
+	Iterator iter = ntElem.getChildren(PROPERTYDEF_ELEMENT).iterator();
-		    throw new InvalidNodeTypeDefException("invalid property name:" + propName, e);
+		    String msg = "invalid serialized node type definition [" + sntName + "]: invalid property name: " + propName;
+		    log.error(msg, e);
+		    throw new InvalidNodeTypeDefException(msg, e);
-		    String error = "invalid serialized node type definition: invalid type " + typeName;
-		    log.error(error);
-		    throw new InvalidNodeTypeDefException(error);
+		    String msg = "invalid serialized node type definition [" + sntName + "]: invalid type: " + typeName;
+		    log.error(msg, e);
+		    throw new InvalidNodeTypeDefException(msg, e);
-	    // valueConstraint
-	    String valueConstraint = elem.getAttributeValue(VALUECONSTRAINT_ATTRIBUTE);
-	    if (valueConstraint != null && valueConstraint.length() > 0) {
-		try {
-		    pd.setValueConstraint(ValueConstraint.create(type, valueConstraint));
-		} catch (InvalidConstraintException e) {
-		    String error = "invalid serialized node type definition: invalid constraint " + valueConstraint;
-		    log.error(error, e);
-		    throw new InvalidNodeTypeDefException(error, e);
+	    // valueConstraints
+	    Element constraintsElem = elem.getChild(VALUECONSTRAINTS_ELEMENT);
+	    if (constraintsElem != null) {
+		ArrayList list1 = new ArrayList();
+		Iterator iter1 = constraintsElem.getChildren(VALUECONSTRAINT_ELEMENT).iterator();
+		while (iter1.hasNext()) {
+		    Element constraintElem = (Element) iter1.next();
+		    Filter filter = new ContentFilter(ContentFilter.TEXT | ContentFilter.CDATA);
+		    List content = constraintElem.getContent(filter);
+		    if (!content.isEmpty()) {
+			String constraint = constraintElem.getTextTrim();
+			try {
+			    list1.add(ValueConstraint.create(type, constraint));
+			} catch (InvalidConstraintException e) {
+			    String msg = "invalid serialized node type definition [" + sntName + "]: invalid constraint: " + constraint;
+			    log.error(msg, e);
+			    throw new InvalidNodeTypeDefException(msg, e);
+			}
+		    }
+		}
+		if (!list1.isEmpty()) {
+		    pd.setValueConstraints((ValueConstraint[]) list1.toArray(new ValueConstraint[list1.size()]));
-	    // @todo provide escaping for separator character within single value or change xml representation for defaultValues
-	    String defaultValues = elem.getAttributeValue(DEFAULTVALUES_ATTRIBUTE);
-	    if (defaultValues != null && defaultValues.length() > 0) {
+	    Element defValuesElem = elem.getChild(DEFAULTVALUES_ELEMENT);
+	    if (defValuesElem != null) {
-		String[] dva = defaultValues.split(",\\s*");
-		InternalValue[] defVals = new InternalValue[dva.length];
-		for (int i = 0; i < dva.length; i++) {
-		    defVals[i] = InternalValue.valueOf(dva[i], defValType);
+		ArrayList list1 = new ArrayList();
+		Iterator iter1 = defValuesElem.getChildren(DEFAULTVALUE_ELEMENT).iterator();
+		while (iter1.hasNext()) {
+		    Element valueElem = (Element) iter1.next();
+		    Filter filter = new ContentFilter(ContentFilter.TEXT | ContentFilter.CDATA);
+		    List content = valueElem.getContent(filter);
+		    if (!content.isEmpty()) {
+			String defValue = valueElem.getTextTrim();
+			try {
+			    list1.add(InternalValue.valueOf(defValue, defValType));
+			} catch (IllegalArgumentException e) {
+			    String msg = "invalid serialized node type definition [" + sntName + "]: invalid defaultValue: " + defValue;
+			    log.error(msg, e);
+			    throw new InvalidNodeTypeDefException(msg, e);
+			}
+		    }
-		if (defVals.length > 0) {
-		    pd.setDefaultValues(defVals);
+		if (!list1.isEmpty()) {
+		    pd.setDefaultValues((InternalValue[]) list1.toArray(new InternalValue[list1.size()]));
-		    String error = "invalid serialized node type definition: invalid onVersion " + onVersion;
-		    log.error(error);
-		    throw new InvalidNodeTypeDefException(error);
+		    String msg = "invalid serialized node type definition [" + sntName + "]: invalid onVersion: " + onVersion;
+		    log.error(msg, e);
+		    throw new InvalidNodeTypeDefException(msg, e);
-	iter = ntElem.getChildren(CHILDNODEDEF_ELEMENT_NAME).iterator();
+	iter = ntElem.getChildren(CHILDNODEDEF_ELEMENT).iterator();
-		    throw new InvalidNodeTypeDefException("invalid child node name:" + nodeName, e);
+		    String msg = "invalid serialized node type definition [" + sntName + "]: invalid child node name: " + nodeName;
+		    log.error(msg, e);
+		    throw new InvalidNodeTypeDefException(msg, e);
-	    String requiredPrimaryTypes = elem.getAttributeValue(REQUIREDPRIMARYTYPES_ATTRIBUTE);
-	    if (requiredPrimaryTypes != null && requiredPrimaryTypes.length() > 0) {
-		String[] sta = requiredPrimaryTypes.split(",\\s*");
-		QName[] qNames = new QName[sta.length];
-		for (int i = 0; i < sta.length; i++) {
-		    try {
-			qNames[i] = QName.fromJCRName(sta[i], nsResolver);
-		    } catch (BaseException e) {
-			throw new InvalidNodeTypeDefException("invalid requiredPrimaryType:" + sta[i], e);
+	    Element reqTtypesElem = elem.getChild(REQUIREDPRIMARYTYPES_ELEMENT);
+	    if (reqTtypesElem != null) {
+		ArrayList list1 = new ArrayList();
+		Iterator iter1 = reqTtypesElem.getChildren(REQUIREDPRIMARYTYPE_ELEMENT).iterator();
+		while (iter1.hasNext()) {
+		    Element typeElem = (Element) iter1.next();
+		    Filter filter = new ContentFilter(ContentFilter.TEXT | ContentFilter.CDATA);
+		    List content = typeElem.getContent(filter);
+		    if (!content.isEmpty()) {
+			String name = typeElem.getTextTrim();
+			try {
+			    list1.add(QName.fromJCRName(name, nsResolver));
+			} catch (BaseException e) {
+			    String msg = "invalid serialized node type definition [" + sntName + "]: invalid requiredPrimaryType: " + name;
+			    log.error(msg, e);
+			    throw new InvalidNodeTypeDefException(msg, e);
+			}
-		if (sta.length > 0) {
-		    cnd.setRequiredPrimaryTypes(qNames);
+		if (!list1.isEmpty()) {
+		    cnd.setRequiredPrimaryTypes((QName[]) list1.toArray(new QName[list1.size()]));
-		    throw new InvalidNodeTypeDefException("invalid defaultPrimaryType:" + defaultPrimaryType, e);
+		    String msg = "invalid serialized node type definition [" + sntName + "]: invalid defaultPrimaryType: " + defaultPrimaryType;
+		    log.error(msg, e);
+		    throw new InvalidNodeTypeDefException(msg, e);
-		    String error = "invalid serialized node type definition: invalid onVersion " + onVersion;
-		    log.error(error);
-		    throw new InvalidNodeTypeDefException(error);
+		    String msg = "invalid serialized node type definition [" + sntName + "]: invalid onVersion: " + onVersion;
+		    log.error(msg, e);
+		    throw new InvalidNodeTypeDefException(msg, e);
+
-	    StringBuffer supertypes = new StringBuffer();
-	    for (int i = 0; i < qNames.length; i++) {
-		if (supertypes.length() > 0) {
-		    supertypes.append(",");
+	    if (qNames.length != 0) {
+		Element typesElem = new Element(SUPERTYPES_ELEMENT);
+		ntElem.addContent(typesElem);
+		for (int i = 0; i < qNames.length; i++) {
+		    Element typeElem = new Element(SUPERTYPE_ELEMENT);
+		    typesElem.addContent(typeElem);
+		    typeElem.setText(qNames[i].toJCRName(nsResolver));
-		supertypes.append(qNames[i].toJCRName(nsResolver));
-	    ntElem.setAttribute(SUPERTYPES_ATTRIBUTE, supertypes.toString());
+
+
-		Element elem = new Element(PROPERTYDEF_ELEMENT_NAME);
+		Element elem = new Element(PROPERTYDEF_ELEMENT);
-		// valueConstraint
-		String valueConstraint = pd.getValueConstraint() == null ? "" : pd.getValueConstraint().getDefinition();
-		elem.setAttribute(VALUECONSTRAINT_ATTRIBUTE, valueConstraint);
-		// defaultValues
-		// @todo provide escaping for separator character within single value or change xml representation for defaultValues
-		InternalValue[] defVals = pd.getDefaultValues();
-		StringBuffer defaultValues = new StringBuffer();
-		if (defVals != null) {
-		    for (int n = 0; n < defVals.length; n++) {
-			if (defaultValues.length() > 0) {
-			    defaultValues.append(",");
-			}
-			defaultValues.append(defVals[n].toString());
+		// valueConstraints
+		ValueConstraint[] vca = pd.getValueConstraints();
+		if (vca != null && vca.length != 0) {
+		    Element constraintsElem = new Element(VALUECONSTRAINTS_ELEMENT);
+		    elem.addContent(constraintsElem);
+		    for (int j = 0; j < vca.length; j++) {
+			Element constraintElem = new Element(VALUECONSTRAINTS_ELEMENT);
+			constraintsElem.addContent(constraintElem);
+			constraintElem.setText(vca[j].getDefinition());
-
-		elem.setAttribute(DEFAULTVALUES_ATTRIBUTE, defaultValues.toString());
+		// defaultValues
+		InternalValue[] defVals = pd.getDefaultValues();
+		if (defVals != null && defVals.length != 0) {
+		    Element valuesElem = new Element(DEFAULTVALUES_ELEMENT);
+		    elem.addContent(valuesElem);
+		    for (int j = 0; j < defVals.length; j++) {
+			Element valueElem = new Element(DEFAULTVALUE_ELEMENT);
+			valuesElem.addContent(valueElem);
+			valueElem.setText(defVals[j].toString());
+		    }
+		}
-		Element elem = new Element(CHILDNODEDEF_ELEMENT_NAME);
+		Element elem = new Element(CHILDNODEDEF_ELEMENT);
-		StringBuffer requiredPrimaryTypes = new StringBuffer();
-		for (int j = 0; j < qNames.length; j++) {
-		    if (requiredPrimaryTypes.length() > 0) {
-			requiredPrimaryTypes.append(",");
+		if (qNames.length != 0) {
+		    Element typesElem = new Element(REQUIREDPRIMARYTYPES_ELEMENT);
+		    elem.addContent(typesElem);
+		    for (int j = 0; j < qNames.length; j++) {
+			Element typeElem = new Element(REQUIREDPRIMARYTYPE_ELEMENT);
+			typesElem.addContent(typeElem);
+			typeElem.setText(qNames[j].toJCRName(nsResolver));
-		    requiredPrimaryTypes.append(qNames[j].toJCRName(nsResolver));
-		elem.setAttribute(REQUIREDPRIMARYTYPES_ATTRIBUTE, requiredPrimaryTypes.toString());

JCR-3198: Broken handling of outer join results over davex

Return the set of selector names as a part of the response description field along with column names.

For compatibility with earlier clients/servers this new functionality (and extensible) functionality is only enabled when the search request is made with the query language qualified with the JCR WebDAV extension namespace.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1227240 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.webdav.jcr.ItemResourceConstants;
-import javax.jcr.query.qom.Source;
-import javax.jcr.query.qom.Join;
-import javax.jcr.query.qom.Selector;
-import javax.jcr.query.qom.QueryObjectModel;
-import java.util.Iterator;
-import java.util.Arrays;
-                // todo: define proper namespace
+                // Note: Existing clients already assume that the
+                // query languages returned in the DASL header are
+                // not prefixed with any namespace, so we probably
+                // shouldn't use an explicit namespace here.
-            return queryResultToMultiStatus(getQuery(sInfo));
+            QueryResult result = getQuery(sInfo).execute();
+            MultiStatus ms = new MultiStatus();
+
+            if (ItemResourceConstants.NAMESPACE.equals(
+                    sInfo.getLanguageNameSpace())) {
+                ms.setResponseDescription(
+                        "Columns: " + encode(result.getColumnNames())
+                        + "\nSelectors: " + encode(result.getSelectorNames()));
+            } else {
+                ms.setResponseDescription(encode(result.getColumnNames()));
+            }
+
+            queryResultToMultiStatus(result, ms);
+
+            return ms;
-    private MultiStatus queryResultToMultiStatus(Query query)
+    private void queryResultToMultiStatus(QueryResult result, MultiStatus ms)
-        QueryResult qResult = query.execute();
-        MultiStatus ms = new MultiStatus();
-
-        columnNames.addAll(Arrays.asList(qResult.getColumnNames()));
-        StringBuffer responseDescription = new StringBuffer();
-        String delim = "";
-        for (String columnName : columnNames) {
-            responseDescription.append(delim);
-            responseDescription.append(ISO9075.encode(columnName));
-            delim = " ";
-        }
-        ms.setResponseDescription(responseDescription.toString());
-        for (Iterator<String> it = columnNames.iterator(); it.hasNext(); ) {
-            String columnName = it.next();
+        for (String columnName : result.getColumnNames()) {
+                columnNames.add(columnName);
-            } else {
-                it.remove();
+
-        List<String> sn = new ArrayList<String>();
-        collectSelectorNames(query, qResult, sn);
-        for (String selectorName : sn) {
+        String[] sns = result.getSelectorNames();
+        boolean join = sns.length > 1;
+        for (String selectorName : sns) {
+
+        int n = 0;
+        String root = getHref("/");
-        RowIterator rowIter = qResult.getRows();
+        RowIterator rowIter = result.getRows();
-            /*
-             * get the path for the first selector and build a webdav compliant
-             * resource path based on it.
-             * 
-             * Use Row#getPath(String) which works for both simple rows and join
-             * rows (in contrast to Row#getPath()).
-             * 
-             * see also https://issues.apache.org/jira/browse/JCR-3089
-             */
-            final String itemPath = row.getPath(sn.get(0));
-            DavResourceLocator loc = locator.getFactory().createResourceLocator(locator.getPrefix(), locator.getWorkspacePath(), itemPath, false);
-            String href = loc.getHref(true);
+            String href;
+            if (join) {
+                // We need a distinct href for each join result row to
+                // allow the MultiStatus response to keep them separate
+                href = root + "?" + n++;
+            } else {
+                href = getHref(row.getPath());
+            }
+
-        return ms;
+    }
+
+    /**
+     * Returns the resource location of the given query result row.
+     * The result rows of join queries have no meaningful single resource
+     * location, so we'll just default to the root node for all such rows.
+     *
+     * @param row query result row
+     * @param join flag to indicate a join query
+     * @return resource location of the row
+     */
+    private String getHref(String path) throws RepositoryException {
+        DavResourceLocator l = locator.getFactory().createResourceLocator(
+                locator.getPrefix(), locator.getWorkspacePath(), path, false);
+        return l.getHref(true);
+    }
+
+    private String encode(String[] names) {
+        StringBuilder builder = new StringBuilder();
+        String delim = "";
+        for (String name : names) {
+            builder.append(delim);
+            builder.append(ISO9075.encode(name));
+            delim = " ";
+        }
+        return builder.toString();
-    private static void collectSelectorNames(Query query,
-                                             QueryResult result,
-                                             List<String> sn) throws RepositoryException {
-        if (query instanceof QueryObjectModel) {
-            QueryObjectModel qom = (QueryObjectModel) query;
-            collectSelectorNames(qom.getSource(), sn);
-        } else {
-            sn.addAll(Arrays.asList(result.getSelectorNames()));
-        }
-    }
-
-    private static void collectSelectorNames(Source source, List<String> sn) {
-        if (source instanceof Join) {
-            collectSelectorNames((Join) source, sn);
-        } else {
-            collectSelectorNames((Selector) source, sn);
-        }
-    }
-
-    private static void collectSelectorNames(Join join, List<String> sn) {
-        collectSelectorNames(join.getLeft(), sn);
-        collectSelectorNames(join.getRight(), sn);
-    }
-
-    private static void collectSelectorNames(Selector s, List<String> sn) {
-        sn.add(s.getSelectorName());
-    }

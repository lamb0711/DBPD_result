JCR-1799 updating events swallowed (CacheBehavior.OBSERVATION)   	
JCR-1783 incomplete changelog when combining move with removal of new destination parent

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@704361 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.util.LogUtil;
-import org.apache.jackrabbit.spi.Path;
+import org.apache.jackrabbit.jcr2spi.util.LogUtil;
+import org.apache.jackrabbit.spi.Path;
-import org.slf4j.LoggerFactory;
+import org.slf4j.LoggerFactory;
-import javax.jcr.RepositoryException;
-import javax.jcr.UnsupportedRepositoryOperationException;
-import javax.jcr.version.VersionException;
+import javax.jcr.RepositoryException;
+import javax.jcr.UnsupportedRepositoryOperationException;
+import javax.jcr.lock.LockException;
-import javax.jcr.lock.LockException;
+import javax.jcr.version.VersionException;
-    private Move(NodeState srcNodeState, NodeState srcParentState, NodeState destParentState, Name destName, boolean sessionMove) {
+    private Move(NodeState srcNodeState, NodeState srcParentState, NodeState destParentState, Name destName, boolean sessionMove)
+            throws RepositoryException {
+        assert status == STATUS_PENDING;
-    public void persisted() {
+    public void persisted() throws RepositoryException {
+        assert status == STATUS_PENDING;
+        status = STATUS_PERSISTED;
-            throw new UnsupportedOperationException("persisted() not implemented for transient modification.");
-        }
-        // non-recursive invalidation
-        try {
-            srcState.getNodeEntry().move(destName, destParentState.getNodeEntry(), false);
-            // TODO: TOBEFIXED. moved state ev. got a new definition.
-        } catch (RepositoryException e) {
-            // should not occure
-            log.error("Internal error", e);
-            srcParentState.getHierarchyEntry().invalidate(false);
-            destParentState.getHierarchyEntry().invalidate(false);
-            srcState.getHierarchyEntry().invalidate(false);
+            srcState.getNodeEntry().complete(this);
+        } else {
+            // non-recursive invalidation
+            try {
+                srcState.getNodeEntry().move(destName, destParentState.getNodeEntry(), false);
+                // TODO: TOBEFIXED. moved state ev. got a new definition.
+            } catch (RepositoryException e) {
+                // should not occure
+                log.error("Internal error", e);
+                srcParentState.getHierarchyEntry().invalidate(false);
+                destParentState.getHierarchyEntry().invalidate(false);
+                srcState.getHierarchyEntry().invalidate(false);
+            }
+
+    /**
+     * @see Operation#undo()
+     */
+    public void undo() throws RepositoryException {
+        assert status == STATUS_PENDING;
+        if (sessionMove) {
+            status = STATUS_UNDO;
+            srcState.getHierarchyEntry().complete(this);
+        } else {
+            super.undo();
+        }
+    }
+
-        // for session-move perform a lazy check for existing items at destination.
-        // since the hierarchy may not be complete it is possible that an conflict
-        // is only detected upon saving the 'move'.
-        NodeEntry destEntry = (NodeEntry) destParentState.getHierarchyEntry();
-        if (destEntry.hasPropertyEntry(destName) && sessionMove) {
-            throw new ItemExistsException("Move destination already exists (Property).");
-        }
-        // force childnodeentries list to be present before the move is executed
-        // on the hierarchy entry.
-        if (destEntry.hasNodeEntry(destName)) {
-            NodeEntry existing = destEntry.getNodeEntry(destName, Path.INDEX_DEFAULT);
-            if (existing != null && sessionMove) {
-                try {
-                    if (!existing.getNodeState().getDefinition().allowsSameNameSiblings()) {
-                        throw new ItemExistsException("Node existing at move destination does not allow same name siblings.");
+        if (sessionMove) {
+            NodeEntry destEntry = (NodeEntry) destParentState.getHierarchyEntry();
+            if (destEntry.hasPropertyEntry(destName)) {
+                // TODO: remove for 283
+                throw new ItemExistsException("Move destination already exists (Property).");
+            }
+
+            // force childnodeentries list to be present before the move is executed
+            // on the hierarchy entry.
+            assertChildNodeEntries(srcParentState);
+            assertChildNodeEntries(destParentState);
+
+            if (destEntry.hasNodeEntry(destName)) {
+                NodeEntry existing = destEntry.getNodeEntry(destName, Path.INDEX_DEFAULT);
+                if (existing != null && sessionMove) {
+                    try {
+                        if (!existing.getNodeState().getDefinition().allowsSameNameSiblings()) {
+                            throw new ItemExistsException("Node existing at move destination does not allow same name siblings.");
+                        }
+                    } catch (ItemNotFoundException e) {
+                        // existing apparent not valid any more -> probably no conflict
-                } catch (ItemNotFoundException e) {
-                    // existing apparent not valid any more -> probably no conflict

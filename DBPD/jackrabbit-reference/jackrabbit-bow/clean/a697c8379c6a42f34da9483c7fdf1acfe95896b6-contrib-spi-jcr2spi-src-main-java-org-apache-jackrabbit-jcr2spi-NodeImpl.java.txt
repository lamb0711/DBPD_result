work in progress

- version always protected
- versionHistory always protected
- fix Node.getReferences && reference properties
- mixinTypes are 'active' upon save only (and not before). therefore
  cleanup after removeMixin is done only after save.
  adding new states defined by a new mixin are only added after the
  node has been saved.
- nodestates identified by a uuid only were created a second time upon
  ChildNodeEntry.resolve => fix needs to be improved
- Events/ChangeLog are processed by the save-target state
- ChangeLog.persisted not used any more

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@467956 13f79535-47bb-0310-9956-ffa450edef68

-        return setProperty(name, v);
+        return setProperty(name, v, type);
-        return setProperty(name, v);
+        return setProperty(name, v, PropertyType.BINARY);
-        return setProperty(name, session.getValueFactory().createValue(value));
+        return setProperty(name, session.getValueFactory().createValue(value), PropertyType.BOOLEAN);
-        return setProperty(name, session.getValueFactory().createValue(value));
+        return setProperty(name, session.getValueFactory().createValue(value), PropertyType.DOUBLE);
-        return setProperty(name, session.getValueFactory().createValue(value));
+        return setProperty(name, session.getValueFactory().createValue(value), PropertyType.LONG);
-        return setProperty(name, v);
+        return setProperty(name, v, PropertyType.DATE);
-        // validation performed in subsequent method
-        Value v = (value == null ? null : session.getValueFactory().createValue(value));
-        return setProperty(name, v);
+        // duplicate check to make sure, writability is asserted before value
+        // validation below.
+        checkIsWritable();
+        Value v;
+        if (value == null) {
+            v = null;
+        } else {
+            PropertyImpl.checkValidReference(value, PropertyType.REFERENCE, this);
+            v = session.getValueFactory().createValue(value);
+        }
+        return setProperty(name, v, PropertyType.REFERENCE);
-        if (!isNodeType(QName.MIX_REFERENCEABLE)) {
+        String uuid = getNodeState().getUUID();
+        if (!isNodeType(QName.MIX_REFERENCEABLE) && uuid != null) {
-        return getNodeId().getUUID();
+        return uuid;
-            if (itemStateMgr.hasReferingStates(getNodeState())) {
-                Collection refStates = itemStateMgr.getReferingStates(getNodeState());
-                return new LazyItemIterator(itemMgr, refStates);
-            } else {
+            Collection refStates = itemStateMgr.getReferingStates(getNodeState());
+            if (refStates.isEmpty()) {
+            } else {
+                return new LazyItemIterator(itemMgr, refStates);
+        } catch (ConstraintViolationException e) {
+            log.debug("Cannot add mixin '" + mixinName + "': " + e.getMessage());
+            return false;
-        restore(v, removeExisting);
+        restore(this, null, v, removeExisting);
-        targetNode.checkIsWritable();
-        targetNode.checkIsLocked();
-
-
+            targetNode.checkIsWritable();
+            targetNode.checkIsLocked();
+            targetNode.checkIsLocked();
-            throw new UnsupportedRepositoryOperationException(msg);
+            throw new LockException(msg);

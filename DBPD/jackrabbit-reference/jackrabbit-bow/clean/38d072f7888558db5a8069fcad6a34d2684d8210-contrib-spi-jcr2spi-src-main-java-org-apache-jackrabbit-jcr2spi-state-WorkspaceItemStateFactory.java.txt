work in progress

- Restore: pass NodeState(s) and Path instead of NodeId(s)
- LockManager: make sure lockmanager only remembers workspace states
- LockManager: make sure operations are executed using workspace states
- LockManager: improve isLocked/getLock/checkIsLocked and respect locks that
have been accessed before.
- VersionManager: make sure operations are executed using workspace states
- VersionManager: add checkIsCheckedOut
- VersionManager: force manager to have a WorkspaceManager
- NodeReferences:
  > make interface package protected
  > clarify method naming
  > add implementation to WorkspaceItemStateFactory
  > add NodeReferences field to NodeState
  > TO_IMPROVE: references are currently always retrieve from the SPI.
- ItemStateManager + NodeReferences
  > rename interfaces methods
  > change method signature to take NodeState instead of NodeId
  > 'getReferences' returns the property states directly

- remove some JR DIFFs. 

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@432234 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.HashSet;
+import java.util.Set;
+import java.util.Collections;
+import java.util.Arrays;
+import java.util.Iterator;
+            // If the uuid is not null, the state could include mix:referenceable.
+            // Therefore build a NodeReference instance and add it to the state.
+            if (uuid != null) {
+                PropertyId[] references = info.getReferences();
+                state.addNodeReferences(new NodeReferencesImpl(info.getId(), references));
+            }
+
+
+    /**
+     * <code>NodeReferences</code> represents the references (i.e. properties of
+     * type <code>REFERENCE</code>) to a particular node (denoted by its uuid).
+     */
+    private class NodeReferencesImpl implements NodeReferences {
+
+        /**
+         * Identifier of this <code>NodeReferences</code> instance. Since the
+         * id of target state consists of a UUID and contains not relative
+         * path, the id will be stable and can be stored.
+         */
+        private NodeId nodeId;
+
+        /**
+         * Private constructor
+         *
+         * @param nodeId
+         * @param referenceIds
+         */
+        private NodeReferencesImpl(NodeId nodeId, PropertyId[] referenceIds) {
+            this.nodeId = nodeId;
+
+            // TODO: modify in order to make usage of the references returned
+            // with NodeInfo that was just retrieved and implement a notification
+            // mechanism that updates this NodeReference object if references
+            // are modified.
+        }
+
+        //-------------------------------------------------< NodeReferences >---
+        /**
+         * @see NodeReferences#isEmpty()
+         */
+        public boolean isEmpty() {
+            try {
+                NodeInfo info = service.getNodeInfo(sessionInfo, nodeId);
+                return info.getReferences().length > 0;
+            } catch (RepositoryException e) {
+                log.error("Internal error.",e);
+                return false;
+            }
+        }
+
+        /**
+         * @see NodeReferences#iterator()
+         */
+        public Iterator iterator() {
+            try {
+                NodeInfo info = service.getNodeInfo(sessionInfo, nodeId);
+                if (info.getReferences().length > 0) {
+                    Set referenceIds = new HashSet();
+                    referenceIds.addAll(Arrays.asList(info.getReferences()));
+                    return Collections.unmodifiableSet(referenceIds).iterator();
+                } else {
+                    return Collections.EMPTY_SET.iterator();
+                }
+            } catch (RepositoryException e) {
+                log.error("Internal error.",e);
+                return Collections.EMPTY_SET.iterator();
+            }
+        }
+    }

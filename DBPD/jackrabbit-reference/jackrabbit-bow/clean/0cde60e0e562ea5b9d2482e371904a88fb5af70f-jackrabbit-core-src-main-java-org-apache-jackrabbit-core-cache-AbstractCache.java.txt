JCR-3013: ArrayIndexOutOfBoundsException: ConcurrentCache

The previous fix had a potential concurrency issue where another thread could still access an overflown access count through getAccessCount() right before the accessCount.set(0) call was made.

I prevented that problem by switching to a long counter which should make overflows highly unlikely (you'd need to have multiple processors just repeatedly accessing the cache for at least decades to get an overflow), and by using Math.abs() in the ConcurrentCache.shrinkIfNeeded() where the actual problem would then occur.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1155431 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.concurrent.atomic.AtomicInteger;
+     * <p>
+     * A long counter is used to prevent integer overflow. Even if the cache
+     * was accessed once every nanosecond, an overflow would only occur in
+     * about 300 years. See
+     * <a href="https://issues.apache.org/jira/browse/JCR-3013">JCR-3013</a>.
-    private final AtomicInteger accessCount = new AtomicInteger();
+    private final AtomicLong accessCount = new AtomicLong();
-        int count = accessCount.incrementAndGet();
-        // guard against integer overflow
-        if (count < 0) {
-            accessCount.set(0);
-            count = accessCount.incrementAndGet();
-        }
+        long count = accessCount.incrementAndGet();

minor cleanup, javadoc and improved class structuring

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@641301 13f79535-47bb-0310-9956-ffa450edef68

+    //---------------------------------------------< EffectiveNodeTypeCache >---
-     * {@inheritDoc}
+     * @see EffectiveNodeTypeCache#getKey(Name[])
-     * {@inheritDoc}
+     * @see EffectiveNodeTypeCache#put(EffectiveNodeType)
-     * {@inheritDoc}
+     * @see EffectiveNodeTypeCache#put(Key, EffectiveNodeType)
-     * {@inheritDoc}
+     * @see EffectiveNodeTypeCache#findBest(Key)
-     * {@inheritDoc}
+     * @see EffectiveNodeTypeCache#invalidate(Name)
-     * {@inheritDoc}
+     * @see EffectiveNodeTypeCache#contains(Key)
-     * {@inheritDoc}
+     * @see EffectiveNodeTypeCache#get(Key)
-     * {@inheritDoc}
+     * @see EffectiveNodeTypeCache#clear()
+    //------------------------------------------------------------< private >---
+    //----------------------------------------------------------< Cloneable >---
-     * {@inheritDoc}
+     * @see Cloneable#clone()
+    //-----------------------------------------------------------< Dumpable >---
-     * {@inheritDoc}
+     * @see org.apache.jackrabbit.jcr2spi.util.Dumpable#dump(PrintStream)
+    //----------------------------------------------------------------< Key >---
-         * {@inheritDoc}
-         */
-        public Name[] getNames() {
-            return names;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public boolean contains(Key otherKey) {
-            /*
-             * 0 - 0 => 0
-             * 0 - 1 => 1
-             * 1 - 0 => 0
-             * 1 - 1 => 0
-             * !a and b
-             */
-            BitsetKey other = (BitsetKey) otherKey;
-            int len = Math.max(bits.length, other.bits.length);
-            for (int i=0; i<len; i++) {
-                long w1 = i < bits.length ? bits[i] : 0;
-                long w2 = i < other.bits.length ? other.bits[i] : 0;
-                long r = ~w1 & w2;
-                if (r != 0) {
-                    return false;
-                }
-            }
-            return true;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public Key subtract(Key otherKey) {
-            /*
-             * 0 - 0 => 0
-             * 0 - 1 => 0
-             * 1 - 0 => 1
-             * 1 - 1 => 0
-             * a and !b
-             */
-            BitsetKey other = (BitsetKey) otherKey;
-            int len = Math.max(bits.length, other.bits.length);
-            long[] newBits = new long[len];
-            int numBits = 0;
-            for (int i=0; i<len; i++) {
-                long w1 = i < bits.length ? bits[i] : 0;
-                long w2 = i < other.bits.length ? other.bits[i] : 0;
-                newBits[i] = w1 & ~w2;
-                numBits += bitCount(newBits[i]);
-            }
-            return new BitsetKey(newBits, numBits);
-        }
-
-        /**
+        /**
+         * Calculates the hashcode.
+         * @return the calculated hashcode
+         */
+        private int calcHashCode() {
+            long h = 1234;
+            int addr = bits.length -1;
+            while (addr >=0 && bits[addr] == 0) {
+                addr--;
+            }
+            while (addr >=0) {
+                h ^= bits[addr] * (addr + 1);
+                addr--;
+            }
+            return (int)((h >> 32) ^ h);
+        }
+        //------------------------------------------------------------< Key >---
+        /**
+         * @see Key#getNames()
+         */
+        public Name[] getNames() {
+            return names;
+        }
+
+        /**
+         * @see Key#contains(Key)
+         */
+        public boolean contains(Key otherKey) {
+            /*
+             * 0 - 0 => 0
+             * 0 - 1 => 1
+             * 1 - 0 => 0
+             * 1 - 1 => 0
+             * !a and b
+             */
+            BitsetKey other = (BitsetKey) otherKey;
+            int len = Math.max(bits.length, other.bits.length);
+            for (int i=0; i<len; i++) {
+                long w1 = i < bits.length ? bits[i] : 0;
+                long w2 = i < other.bits.length ? other.bits[i] : 0;
+                long r = ~w1 & w2;
+                if (r != 0) {
+                    return false;
+                }
+            }
+            return true;
+        }
+
+        /**
+         * @see Key#subtract(Key)
+         */
+        public Key subtract(Key otherKey) {
+            /*
+             * 0 - 0 => 0
+             * 0 - 1 => 0
+             * 1 - 0 => 1
+             * 1 - 1 => 0
+             * a and !b
+             */
+            BitsetKey other = (BitsetKey) otherKey;
+            int len = Math.max(bits.length, other.bits.length);
+            long[] newBits = new long[len];
+            int numBits = 0;
+            for (int i=0; i<len; i++) {
+                long w1 = i < bits.length ? bits[i] : 0;
+                long w2 = i < other.bits.length ? other.bits[i] : 0;
+                newBits[i] = w1 & ~w2;
+                numBits += bitCount(newBits[i]);
+            }
+            return new BitsetKey(newBits, numBits);
+        }
+
+        //-----------------------------------------------------< Comparable >---
+         *
+         * @see Comparable#compareTo(Object)
+        //---------------------------------------------------------< Object >---
-         * {@inheritDoc}
+         * @see Object#equals(Object)
-         * {@inheritDoc}
+         * @see Object#hashCode()
-         * Calculates the hashcode.
-         * @return the calculated hashcode
-         */
-        private int calcHashCode() {
-            long h = 1234;
-            int addr = bits.length -1;
-            while (addr >=0 && bits[addr] == 0) {
-                addr--;
-            }
-            while (addr >=0) {
-                h ^= bits[addr] * (addr + 1);
-                addr--;
-            }
-            return (int)((h >> 32) ^ h);
-        }
-
-        /**
-         * {@inheritDoc}
+         * @see Object#toString()
-

JCR-2836: Unclosed threads in Jackrabbit

Automatically close the DynamicPooledExecutor threads when no longer used.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1055068 13f79535-47bb-0310-9956-ffa450edef68

+     * Number of instances that access the underlying executor.
+     * Used to automatically shutdown the thread pool when unused.
+     */
+    private static int instances = 0;
+
+    /**
-    private final ThreadPoolExecutor executor;
+    private static ThreadPoolExecutor executor = null;
-    private long lastCheck;
+    private static long lastCheck;
-        ThreadFactory f = new ThreadFactory() {
-            public Thread newThread(Runnable r) {
-                Thread t = new Thread(r, "DynamicPooledExecutor");
-                t.setDaemon(true);
-                return t;
-            }
-        };
-        this.executor = new ThreadPoolExecutor(
-                1, Runtime.getRuntime().availableProcessors(),
-                500, TimeUnit.MILLISECONDS,
-                new LinkedBlockingQueue<Runnable>(), f);
-        this.lastCheck = System.currentTimeMillis();
+        startInstance();
-    private synchronized void adjustPoolSize() {
+    private static synchronized ThreadPoolExecutor adjustPoolSize() {
+        return executor;
-        adjustPoolSize();
+        ThreadPoolExecutor executor = adjustPoolSize();
+    public void close() {
+        stopInstance();
+    }
+
+    private static synchronized void startInstance() {
+        instances++;
+        if (executor == null) {
+            ThreadFactory f = new ThreadFactory() {
+                public Thread newThread(Runnable r) {
+                    Thread t = new Thread(r, "DynamicPooledExecutor");
+                    t.setDaemon(true);
+                    return t;
+                }
+            };
+            executor = new ThreadPoolExecutor(
+                    1, Runtime.getRuntime().availableProcessors(),
+                    500, TimeUnit.MILLISECONDS,
+                    new LinkedBlockingQueue<Runnable>(), f);
+            lastCheck = System.currentTimeMillis();
+        }
+    }
+
+    private static synchronized void stopInstance() {
+        instances--;
+        if (instances == 0) {
+            executor.shutdown();
+            try {
+                executor.awaitTermination(10, TimeUnit.SECONDS);
+            } catch (InterruptedException e) {
+                // ignore and continue
+            }
+            executor = null;
+        }
+    }
+

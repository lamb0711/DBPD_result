JCR-1990: Optimize queries with relative path in order by clause

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@746946 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.state.PropertyState;
+import org.apache.jackrabbit.core.PropertyId;
+import javax.jcr.PathNotFoundException;
+
-     * The rules that define this indexing aggregate.
+     * The node includes of this indexing aggregate.
-    private final Rule[] rules;
+    private final NodeInclude[] nodeIncludes;
+
+    /**
+     * The property includes of this indexing aggregate.
+     */
+    private final PropertyInclude[] propertyIncludes;
-                      HierarchyManager hmgr)
-            throws MalformedPathException, IllegalNameException, NamespaceException {
+                      HierarchyManager hmgr) throws MalformedPathException,
+            IllegalNameException, NamespaceException, PathNotFoundException {
-        this.rules = getRules(config);
+        this.nodeIncludes = getNodeIncludes(config);
+        this.propertyIncludes = getPropertyIncludes(config);
-     * @param nodeState
+     * @param nodeState the node state.
-        for (int i = 0; i < rules.length; i++) {
-            NodeState aggregateRoot = rules[i].matches(nodeState);
+        for (int i = 0; i < nodeIncludes.length; i++) {
+            NodeState aggregateRoot = nodeIncludes[i].matches(nodeState);
+            if (aggregateRoot != null
+                    && aggregateRoot.getNodeTypeName().equals(nodeTypeName)) {
+                return aggregateRoot;
+            }
+        }
+        // check property includes
+        for (int i = 0; i < propertyIncludes.length; i++) {
+            NodeState aggregateRoot = propertyIncludes[i].matches(nodeState);
-            for (int i = 0; i < rules.length; i++) {
-                nodeStates.addAll(Arrays.asList(rules[i].resolve(nodeState)));
+            for (int i = 0; i < nodeIncludes.length; i++) {
+                nodeStates.addAll(Arrays.asList(nodeIncludes[i].resolve(nodeState)));
+    /**
+     * {@inheritDoc}
+     */
+    public PropertyState[] getAggregatedPropertyStates(NodeState nodeState)
+            throws ItemStateException {
+        if (nodeState.getNodeTypeName().equals(nodeTypeName)) {
+            List propStates = new ArrayList();
+            for (int i = 0; i < propertyIncludes.length; i++) {
+                propStates.addAll(Arrays.asList(
+                        propertyIncludes[i].resolvePropertyStates(nodeState)));
+            }
+            if (propStates.size() > 0) {
+                return (PropertyState[]) propStates.toArray(
+                        new PropertyState[propStates.size()]);
+            }
+        }
+        return null;
+    }
+
-     * Creates rules defined in the <code>config</code>.
+     * Creates node includes defined in the <code>config</code>.
-     * @return the rules defined in the <code>config</code>.
+     * @return the node includes defined in the <code>config</code>.
-    private Rule[] getRules(Node config)
+    private NodeInclude[] getNodeIncludes(Node config)
-        List rules = new ArrayList();
+        List includes = new ArrayList();
-                rules.add(new Rule(builder.getPath(), ntName));
+                includes.add(new NodeInclude(builder.getPath(), ntName));
-        return (Rule[]) rules.toArray(new Rule[rules.size()]);
+        return (NodeInclude[]) includes.toArray(new NodeInclude[includes.size()]);
+    }
+
+    /**
+     * Creates property includes defined in the <code>config</code>.
+     *
+     * @param config the indexing aggregate configuration.
+     * @return the property includes defined in the <code>config</code>.
+     * @throws MalformedPathException if a path in the configuration is
+     *                                malformed.
+     * @throws IllegalNameException   if the node type name contains illegal
+     *                                characters.
+     * @throws NamespaceException if the node type contains an unknown
+     *                                prefix.
+     */
+    private PropertyInclude[] getPropertyIncludes(Node config) throws
+            MalformedPathException, IllegalNameException, NamespaceException,
+            PathNotFoundException {
+        List includes = new ArrayList();
+        NodeList childNodes = config.getChildNodes();
+        for (int i = 0; i < childNodes.getLength(); i++) {
+            Node n = childNodes.item(i);
+            if (n.getNodeName().equals("include-property")) {
+                String[] elements = Text.explode(getTextContent(n), '/');
+                PathBuilder builder = new PathBuilder();
+                for (int j = 0; j < elements.length; j++) {
+                    if (elements[j].equals("*")) {
+                        throw new IllegalNameException("* not supported in include-property");
+                    }
+                    builder.addLast(resolver.getQName(elements[j]));
+                }
+                includes.add(new PropertyInclude(builder.getPath()));
+            }
+        }
+        return (PropertyInclude[]) includes.toArray(new PropertyInclude[includes.size()]);
-    private final class Rule {
+    private abstract class AbstractInclude {
-        private final Name nodeTypeName;
+        protected final Name nodeTypeName;
-        private final Path pattern;
+        protected final Path pattern;
-        private Rule(Path pattern, Name nodeTypeName) {
+        AbstractInclude(Path pattern, Name nodeTypeName) {
+         * @throws ItemStateException if an error occurs while accessing node
+         *                            states.
+         * @throws RepositoryException if another error occurs.
-        /**
-         * Resolves the <code>nodeState</code> using this rule.
-         *
-         * @param nodeState the root node of the enclosing indexing aggregate.
-         * @return the descendant node states as defined by this rule.
-         * @throws ItemStateException if an error occurs while resolving the
-         *                            node states.
-         */
-        NodeState[] resolve(NodeState nodeState) throws ItemStateException {
-            List nodeStates = new ArrayList();
-            resolve(nodeState, nodeStates, 0);
-            return (NodeState[]) nodeStates.toArray(new NodeState[nodeStates.size()]);
-        }
-
-        private void resolve(NodeState nodeState, List collector, int offset)
+        protected void resolve(NodeState nodeState, List collector, int offset)
+
+    private final class NodeInclude extends AbstractInclude {
+
+        /**
+         * Creates a new node include with a relative path pattern and an
+         * optional node type name.
+         *
+         * @param nodeTypeName node type name or <code>null</code> if all node
+         *                     types are allowed.
+         * @param pattern      a relative path pattern.
+         */
+        NodeInclude(Path pattern, Name nodeTypeName) {
+            super(pattern, nodeTypeName);
+        }
+
+        /**
+         * Resolves the <code>nodeState</code> using this rule.
+         *
+         * @param nodeState the root node of the enclosing indexing aggregate.
+         * @return the descendant node states as defined by this rule.
+         * @throws ItemStateException if an error occurs while resolving the
+         *                            node states.
+         */
+        NodeState[] resolve(NodeState nodeState) throws ItemStateException {
+            List nodeStates = new ArrayList();
+            resolve(nodeState, nodeStates, 0);
+            return (NodeState[]) nodeStates.toArray(new NodeState[nodeStates.size()]);
+        }
+    }
+
+    private final class PropertyInclude extends AbstractInclude {
+
+        private final Name propertyName;
+
+        PropertyInclude(Path pattern)
+                throws PathNotFoundException {
+            super(pattern.getAncestor(1), null);
+            this.propertyName = pattern.getNameElement().getName();
+        }
+
+        /**
+         * Resolves the <code>nodeState</code> using this rule.
+         *
+         * @param nodeState the root node of the enclosing indexing aggregate.
+         * @return the descendant property states as defined by this rule.
+         * @throws ItemStateException if an error occurs while resolving the
+         *                            property states.
+         */
+        PropertyState[] resolvePropertyStates(NodeState nodeState)
+                throws ItemStateException {
+            List nodeStates = new ArrayList();
+            resolve(nodeState, nodeStates, 0);
+            List propStates = new ArrayList();
+            for (Iterator it = nodeStates.iterator(); it.hasNext(); ) {
+                NodeState state = (NodeState) it.next();
+                if (state.hasPropertyName(propertyName)) {
+                    PropertyId propId = new PropertyId(state.getNodeId(), propertyName);
+                    propStates.add(ism.getItemState(propId));
+                }
+            }
+            return (PropertyState[]) propStates.toArray(
+                    new PropertyState[propStates.size()]);
+        }
+    }

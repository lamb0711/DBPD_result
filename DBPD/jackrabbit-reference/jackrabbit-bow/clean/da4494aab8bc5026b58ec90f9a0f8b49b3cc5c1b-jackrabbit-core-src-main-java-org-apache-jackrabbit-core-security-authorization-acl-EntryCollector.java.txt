JCR-3095 : Move operation may turn AC caches stale

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1179536 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.observation.SynchronousEventListener;
+import javax.jcr.observation.EventListener;
+    private final EventListener moveListener;
+
-        observationMgr.addEventListener(this, events, systemSession.getRootNode().getPath(), true, null, ntNames, true);        
+        String rootPath = systemSession.getRootNode().getPath();
+        observationMgr.addEventListener(this, events, rootPath, true, null, ntNames, true);
+        /*
+         In addition both the collector and all subscribed listeners should be
+         informed about any kind of move events.
+         */
+        moveListener = new MoveListener();
+        observationMgr.addEventListener(moveListener, Event.NODE_MOVED, rootPath, true, null, null, true);
-            systemSession.getWorkspace().getObservationManager().removeEventListener(this);
+            ObservationManager observationMgr = systemSession.getWorkspace().getObservationManager();
+            observationMgr.removeEventListener(this);
+            observationMgr.removeEventListener(moveListener);
+
+    /**
+     * Listening to any kind of move events in the hierarchy. Since ac content
+     * is associated with individual nodes the caches need to be informed about
+     * any kind of move as well even if the target node is not access control
+     * content s.str.
+     */
+    private class MoveListener implements SynchronousEventListener {
+
+        public void onEvent(EventIterator events) {
+            // NOTE: simplified event handling as all listeners just clear
+            // the cache in case of any move event. therefore there is currently
+            // no need to process all events and using the rootID as marker.
+            while (events.hasNext()) {
+                Event event = events.nextEvent();
+                if (event.getType() == Event.NODE_MOVED) {
+                    Map<NodeId, Integer> m = Collections.singletonMap(rootID, AccessControlObserver.MOVE);
+                    AccessControlModifications<NodeId> mods = new AccessControlModifications<NodeId>(m);
+                    notifyListeners(mods);
+                    break;
+                } //else: illegal event-type: should never occur. ignore
+            }
+        }
+    }

fixing potential security hole & minor optimization

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@209277 13f79535-47bb-0310-9956-ffa450edef68

-     * <b>Important:</b> This method is public in order to make it accessible
-     * from internal code located in subpackages, i.e. it should never be called
-     * from an application directly.
+     * <strong>Important:</strong> This method is public in order to make it
+     * accessible from internal code located in subpackages, i.e. it should
+     * never be called from an application directly!!!
+        /**
+         * todo FIXME internalSetProperty being public is a potential security risk
+         * the following code snippet is a workaround that verifies that the
+         * caller is located in the same package (i.e. 'core') or a subpackage
+         * thereof; it is tested with jackrabbit being run standalone; however
+         * i commented it out as i am not sure whether there are potential
+         * problems/side effects with other setups/environments.
+         */
+/*
+        CallContext ctx = new CallContext();
+        String calledFromPackage = ctx.getCaller().getPackage().getName();
+        String thisPackage = NodeImpl.class.getPackage().getName();
+        // check if we're called from current package (i.e. 'core')
+        // or a subpackage thereof
+        if (!calledFromPackage.startsWith(thisPackage)) {
+            throw new SecurityException("illegal method invokation");
+        }
+*/
-     * <p/>
-     * <b>Important:</b> This method is for internal use only and should never
-     * be called from an application directly.
-    public Property internalSetProperty(QName name, InternalValue[] values)
+    protected Property internalSetProperty(QName name, InternalValue[] values)
-    public Property internalSetProperty(QName name, InternalValue[] values,
+    protected Property internalSetProperty(QName name, InternalValue[] values,
-        // @todo optimize, no need to build entire path just to find this node's index
-        int index = getPrimaryPath().getNameElement().getIndex();
-        if (index == 0) {
+        String parentUUID = state.getParentUUID();
+        if (parentUUID == null) {
+            // the root node cannot have same-name siblings; always return 1
-        } else {
-            return index;
+        }
+
+        try {
+            NodeState parent =
+                    (NodeState) stateMgr.getItemState(new NodeId(parentUUID));
+            NodeState.ChildNodeEntry parentEntry =
+                    parent.getChildNodeEntry(((NodeState) state).getUUID());
+            return parentEntry.getIndex();
+        } catch (ItemStateException ise) {
+            // should never get here...
+            String msg = "internal error: failed to determine index";
+            log.error(msg, ise);
+            throw new RepositoryException(msg, ise);
+
+    //--------------------------------------------------------< inner classes >
+    private static class CallContext extends SecurityManager {
+        Class getCaller() {
+            // getClassContext()[0] is 'this' class
+            // getClassContext()[1] is the class that called getCaller() (i.e. 'this' method)
+            // getClassContext()[2] is the one we're looking for
+            return super.getClassContext()[2];
+        }
+
+        Class[] getCallerStack() {
+            return super.getClassContext();
+        }
+    }

work in progress

- SPI: replace String/Stream for values by QValue interface
- SPI: add factory for QValue
  > adjust commons and add implementation
  > adjust usages of former QValue object with jcr2spi, spi2dav
- RepositoryService.getChildInfos returns Iterator instead of Collection
- spi2dav: add implementation for new query interfaces

- TODO: 
  improve conversion of jcr-value to q-value and vice-versa




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@497885 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.QValue;
+import org.apache.jackrabbit.spi.QValueFactory;
-import java.io.InputStream;
-import java.io.ByteArrayInputStream;
-import java.io.UnsupportedEncodingException;
+import java.io.IOException;
-    private Object[] values;
+    private QValue[] values;
-                            NamespaceResolver nsResolver, ValueFactory valueFactory)
-        throws RepositoryException, DavException {
+                            NamespaceResolver nsResolver, ValueFactory valueFactory,
+                            QValueFactory qValueFactory)
+        throws RepositoryException, DavException, IOException {
+        // values from jcr-server must be converted to qualified values.
-            // TODO: jcr-server sends jcr values not qualified
-            if (type == PropertyType.BINARY) {
-                values = (jcrValue == null) ?  new InputStream[0] : new InputStream[] {jcrValue.getStream()};
+            if (jcrValue == null) {
+                // TODO: should never occur. since 'null' single values are not allowed. rather throw?
+                values = QValue.EMPTY_ARRAY;
-                String vStr = (jcrValue == null) ? "" : ValueFormat.getQValue(jcrValue, nsResolver).getString();
-                values = new String[] {vStr};
+                QValue qv;
+                if (type == PropertyType.BINARY) {
+                    qv = qValueFactory.create(jcrValue.getStream());
+                } else {
+                    qv = ValueFormat.getQValue(jcrValue, nsResolver, qValueFactory);
+                }
+                values = new QValue[] {qv};
-            if (type == PropertyType.BINARY) {
-                values = new InputStream[jcrValues.length];
-                for (int i = 0; i < jcrValues.length; i++) {
-                    values[i] = jcrValues[i].getStream();
-                }
-            } else {
-                values = new String[jcrValues.length];
-                for (int i = 0; i < jcrValues.length; i++) {
-                    values[i] = ValueFormat.getQValue(jcrValues[i], nsResolver).getString();
+            values = new QValue[jcrValues.length];
+            for (int i = 0; i < jcrValues.length; i++) {
+                if (type == PropertyType.BINARY) {
+                    values[i] = qValueFactory.create(jcrValues[i].getStream());
+                } else {
+                    values[i] = ValueFormat.getQValue(jcrValues[i], nsResolver, qValueFactory);
-    public String[] getValues() {
-        if (values instanceof InputStream[]) {
-            // TODO
-            throw new UnsupportedOperationException("use getValueAsStream");
-        } else {
-            return (String[])values;
-        }
+    public QValue[] getValues() {
+        return values;
-
-    public InputStream[] getValuesAsStream() {
-        if (values instanceof InputStream[]) {
-            return (InputStream[]) values;
-        } else {
-            InputStream[] ins = new InputStream[values.length];
-            for (int i = 0; i < values.length; i++) {
-                String v = (String)values[i];
-                try {
-                    ins[i] = (v != null) ? new ByteArrayInputStream(v.getBytes("UTF-8")) : null;
-                } catch (UnsupportedEncodingException e) {
-                    log.error("Error while converting values", e);
-                }
-            }
-            return ins;
-        }
-    }
-}
+}

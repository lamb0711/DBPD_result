work in progress

- version always protected
- versionHistory always protected
- fix Node.getReferences && reference properties
- mixinTypes are 'active' upon save only (and not before). therefore
  cleanup after removeMixin is done only after save.
  adding new states defined by a new mixin are only added after the
  node has been saved.
- nodestates identified by a uuid only were created a second time upon
  ChildNodeEntry.resolve => fix needs to be improved
- Events/ChangeLog are processed by the save-target state
- ChangeLog.persisted not used any more

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@467956 13f79535-47bb-0310-9956-ffa450edef68

+    private ItemStateCache cache;
+
-            return createNodeState(info, parent);
+            if (parent != null) {
+                return parent.getChildNodeEntry(info.getQName(), info.getIndex()).getNodeState();
+            } else {
+                return createNodeState(info, parent);
+            }
-                childNodeEntries.add(new CNE(childInfo.getQName(), childUUID));
+                childNodeEntries.add(new CNE(childInfo.getQName(), childInfo.getIndex(), childUUID));
-            // If the uuid is not null, the state could include mix:referenceable.
-            // Therefore build a NodeReference instance and add it to the state.
-            NodeReferences nodeRefs = null;
-            if (uuid != null) {
-                PropertyId[] references = info.getReferences();
-                nodeRefs = new NodeReferencesImpl(info.getId(), references);
-            }
+            // Build node-references object even if the state is not refereceable yet.
+            PropertyId[] references = info.getReferences();
+            NodeReferences nodeRefs = new NodeReferencesImpl(state, references);
-            // copied from local-state-mgr TODO... check
-            // register as listener
-            // TODO check if needed
-            //state.addListener(this);
+            state.addListener(cache);
+            cache.created(state);
+
-            String msg = "internal error: failed to retrieve node definition.";
+            String msg = "Internal error: failed to retrieve node definition.";
-            String msg = "internal error: failed to retrieve node definition.";
+            String msg = "Internal error: failed to retrieve node definition.";
-    private PropertyState createPropertyState(PropertyInfo info,
-                                              NodeState parent)
-            throws ItemStateException {
+    private PropertyState createPropertyState(PropertyInfo info, NodeState parent)
+        throws ItemStateException {
-                def, Status.EXISTING, service.getIdFactory(), true);
+                def, Status.EXISTING, this, service.getIdFactory(), true);
+            state.addListener(cache);
+            cache.created(state);
-            // register as listener
-            // TODO check if needed
-            // state.addListener(this);
-            String msg = "internal error: failed to retrieve property definition.";
+            String msg = "internal error: failed to build property state.";
-        } catch (ConstraintViolationException e) {
-            String msg = "internal error: failed to retrieve property definition.";
-            log.debug(msg);
-            throw new ItemStateException(msg, e);
-        } catch (NoSuchNodeTypeException e) {
-            String msg = "internal error: failed to retrieve property definition.";
+        } catch (RepositoryException e) {
+            String msg = "internal error: failed to build property state.";
+    /**
+     *
+     * @param cache
+     * @see ItemStateFactory#setCache(ItemStateCache)
+     */
+    public void setCache(ItemStateCache cache) {
+        this.cache = cache;
+    }
+        private final int index;
-        private CNE(QName name, String uuid) {
+        private CNE(QName name, int index, String uuid) {
+            this.index = index;
-            throw new UnsupportedOperationException();
+            return index;
-        /**
-         * Identifier of this <code>NodeReferences</code> instance. Since the
-         * id of target state consists of a UUID and contains not relative
-         * path, the id will be stable and can be stored.
-         */
-        private NodeId nodeId;
+        private NodeState nodeState;
-         * @param nodeId
+         * @param nodeState
-        private NodeReferencesImpl(NodeId nodeId, PropertyId[] referenceIds) {
-            this.nodeId = nodeId;
+        private NodeReferencesImpl(NodeState nodeState, PropertyId[] referenceIds) {
+            this.nodeState = nodeState;
+            // shortcut
+            if (nodeState.getUUID() == null) {
+                return true;
+            }
+            // nodestate has a uuid and is potentially mix:referenceable
+            // => try to retrieve references
-                NodeInfo info = service.getNodeInfo(sessionInfo, nodeId);
+                NodeInfo info = service.getNodeInfo(sessionInfo, nodeState.getNodeId());
+            // shortcut
+            if (nodeState.getUUID() == null) {
+                return Collections.EMPTY_SET.iterator();
+            }
+            // nodestate has a uuid and is potentially mix:referenceable
+            // => try to retrieve references
-                NodeInfo info = service.getNodeInfo(sessionInfo, nodeId);
+                NodeInfo info = service.getNodeInfo(sessionInfo, nodeState.getNodeId());
-                log.error("Internal error.",e);
+                log.error("Internal error.", e);

work in progress

- version always protected
- versionHistory always protected
- fix Node.getReferences && reference properties
- mixinTypes are 'active' upon save only (and not before). therefore
  cleanup after removeMixin is done only after save.
  adding new states defined by a new mixin are only added after the
  node has been saved.
- nodestates identified by a uuid only were created a second time upon
  ChildNodeEntry.resolve => fix needs to be improved
- Events/ChangeLog are processed by the save-target state
- ChangeLog.persisted not used any more

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@467956 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.collections.map.ReferenceMap;
-import org.apache.commons.collections.map.LRUMap;
-import java.util.Map;
-     * Maps a String uuid to a {@link NodeState}.
+     * Cache
-    private final Map uuid2NodeState;
-
-    /**
-     * Map of recently used <code>ItemState</code>.
-     */
-    private final Map recentlyUsed;
+    private final ItemStateCache cache;
-     * An {@link ItemStateLifeCycleListener} to maintain the LRU and UUID
-     * reference cache.
-     */
-    private final ItemStateLifeCycleListener lifeCycleListener;
-
-    /**
-        this.uuid2NodeState = new ReferenceMap(ReferenceMap.HARD, ReferenceMap.WEAK);
-        this.recentlyUsed = new LRUMap(1000); // TODO: make configurable
-        this.lifeCycleListener = new ISLifeCycleListener();
+        this.cache = new ItemStateCache();
+
+        isf.setCache(cache);
-            if (root.getUUID() != null) {
-                uuid2NodeState.put(root.getUUID(), root);
-            }
-            root.addListener(lifeCycleListener);
-        if (hasReferingStates(nodeState)) {
-            Set refStates = new HashSet();
-            Iterator it =  nodeState.getNodeReferences().iterator();
-            while (it.hasNext()) {
-                PropertyId pId = (PropertyId) it.next();
-                refStates.add(getItemState(pId));
-            }
-            return Collections.unmodifiableCollection(refStates);
-        } else {
+        Set refStates = new HashSet();
+        Iterator it =  nodeState.getNodeReferences().iterator();
+        while (it.hasNext()) {
+            PropertyId pId = (PropertyId) it.next();
+            refStates.add(getItemState(pId));
+        }
+        if (refStates.isEmpty()) {
+        } else {
+            return Collections.unmodifiableCollection(refStates);
-        return nr != null && !nr.isEmpty();
+        return !nr.isEmpty();
-     * Called whenever an item state is accessed. Calling this method will update
-     * the LRU map which keeps track of most recently used item states.
-     *
-     * @param state the touched state.
-     */
-    protected void touch(ItemState state) {
-        recentlyUsed.put(state, state);
-    }
-
-    /**
-            nodeState = (NodeState) uuid2NodeState.get(uuid);
+            nodeState = cache.getNodeState(uuid);
-                // state identified by the uuid is not yet cached -> get from ISM
+                // state identified by the uuid is not yet cached -> get from ISF
-                nodeState.addListener(lifeCycleListener);
-                uuid2NodeState.put(uuid, nodeState);
-        touch(s);
-            state = (ItemState) uuid2NodeState.get(id.getUUID());
+            state = cache.getNodeState(id.getUUID());
-
-    //-----------------------------------------< ItemStateLifeCycleListener >---
-
-    private class ISLifeCycleListener implements ItemStateLifeCycleListener {
-
-        public void statusChanged(ItemState state, int previousStatus) {
-            if (state.getStatus() == Status.REMOVED ||
-                state.getStatus() == Status.STALE_DESTROYED) {
-                recentlyUsed.remove(state);
-                if (state.isNode()) {
-                    NodeState nodeState = (NodeState) state;
-                    if (nodeState.getUUID() != null) {
-                        uuid2NodeState.remove(nodeState.getUUID());
-                    }
-                }
-            }
-        }
-    }

work in progress

- HierarchyManager: changes methods to take ItemState instead of ItemId
- HierarchyManager: remove log-utility methods (saveGetJCRPath)
- HierarchyManager: remove CachingHierachyManager. not used
- ItemManager: changes methods to take ItemState instead of ItemId
- ItemStateValidator: remove utility methods not related to validation
- new class LogUtil that provides static saveGetJCRPath methods previously
  present on HierarchyManager, ItemStateValidator
- NodeState: add method 'getPropertyEntries()'
- create interface ChildPropertyEntry
- let PropertyReference implement ChildPropertyEntry

TODO: query/NodeIteratorImpl needs to be fixed. 


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@429652 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.CachingHierarchyManager;
+import org.apache.jackrabbit.jcr2spi.HierarchyManagerImpl;
+import org.apache.jackrabbit.jcr2spi.util.LogUtil;
-     * Id of the root node.
-     */
-    // TODO: TO-BE-FIXED. With SPI_ItemId rootId must not be stored separately
-    private final NodeId rootId;
-
-    /**
-    // DIFF JACKRABBIT: private CachingHierarchyManager hierMgr;
-    private final CachingHierarchyManager hierMgr;
+    private final HierarchyManager hierMgr;
+    // DIFF JR: store root id. since 'CachingItemStateManager' not used any more
+    // TODO: TO-BE-FIXED. With SPI_ItemId rootId must not be stored separately
+    private NodeId rootId;
+
-        // DIFF JACKRABBIT: added rootId
-        this.rootId = rootId;
-        // create hierarchy manager that uses both transient and persistent state
-        hierMgr = new CachingHierarchyManager(rootId, this, nsResolver);
+        this.rootId = rootId;
+
+        // create hierarchy manager
+        hierMgr = new HierarchyManagerImpl(rootId, this, nsResolver);
+
-     * 
+     *
-                    depth = hierMgr.getRelativeDepth(parentId, state.getId());
+                    depth = getHierarchyManager().getRelativeDepth(parentId, state.getId());
-                new ZombieHierarchyManager(hierMgr.getRootNodeId(),
+                new ZombieHierarchyManager(rootId,
-                        hierMgr.getNamespaceResolver());
+                        nsResolver);
-            // get all item states
+            // root state -> get all item states
-                        String msg = hierMgr.safeGetJCRPath(state.getId()) + ": cannot save a new item.";
+                        String msg = LogUtil.safeGetJCRPath(state, nsResolver, getHierarchyManager()) + ": cannot save a new item.";
-                        String msg = hierMgr.safeGetJCRPath(state.getId()) + ": the item cannot be saved because it has been modified externally.";
+                        String msg = LogUtil.safeGetJCRPath(state, nsResolver, getHierarchyManager()) + ": the item cannot be saved because it has been modified externally.";
-                        String msg = hierMgr.safeGetJCRPath(state.getId()) + ": the item cannot be saved because it has been deleted externally.";
+                        String msg = LogUtil.safeGetJCRPath(state, nsResolver, getHierarchyManager()) + ": the item cannot be saved because it has been deleted externally.";
-                        String msg = hierMgr.safeGetJCRPath(state.getId()) + ": the item cannot be saved; it seems to have been removed externally.";
+                        String msg = LogUtil.safeGetJCRPath(state, nsResolver, getHierarchyManager()) + ": the item cannot be saved; it seems to have been removed externally.";
-                        String msg = hierMgr.safeGetJCRPath(id)
-                            + " needs to be saved as well.";
+                        // TODO convert id to human-readable id
+                        String msg = id.toString() + " needs to be saved as well.";
-        NodeState parent = validator.getNodeState(operation.getParentId());
+        NodeState parent = getNodeState(operation.getParentId());
-        NodeState parent = validator.getNodeState(operation.getParentId());
+        NodeState parent = getNodeState(operation.getParentId());
-        NodeState srcState = create(validator.getNodeState(operation.getNodeId()));
-        NodeState srcParent = create(validator.getNodeState(operation.getSourceParentId()));
+        NodeState srcState = create(getNodeState(operation.getNodeId()));
+        NodeState srcParent = create(getNodeState(operation.getSourceParentId()));
-        NodeState destParent = create(validator.getNodeState(operation.getDestinationParentId()));
+        NodeState destParent = create(getNodeState(operation.getDestinationParentId()));
-        NodeState nState = create(validator.getNodeState(operation.getNodeId()));
+        NodeState nState = create(getNodeState(operation.getNodeId()));
-            Iterator childProps = new HashSet(nState.getPropertyNames()).iterator();
+            Iterator childProps = new HashSet(nState.getPropertyEntries()).iterator();
-                    PropertyState childState = nState.getPropertyState((QName) childProps.next());
+                    ChildPropertyEntry entry = (ChildPropertyEntry) childProps.next();
+                    PropertyState childState = entry.getPropertyState();
-            throw new ItemNotFoundException(getHierarchyManager().safeGetJCRPath(operation.getPropertyId()));
+            // TODO convert id to human-readable id
+            throw new ItemNotFoundException(operation.getPropertyId().toString());
-            String msg = "internal error: failed to retrieve state of " + getHierarchyManager().safeGetJCRPath(operation.getPropertyId());
+            // TODO convert id to human-readable id
+            String msg = "internal error: failed to retrieve state of " + operation.getPropertyId().toString();
-        NodeState parent = create(validator.getNodeState(operation.getParentId()));
+        NodeState parent = create(getNodeState(operation.getParentId()));
-        Iterator tmpIter = new HashSet(targetState.getPropertyNames()).iterator();
+        Iterator tmpIter = new HashSet(targetState.getPropertyEntries()).iterator();
-            QName propName = (QName) tmpIter.next();
+            ChildPropertyEntry entry = (PropertyReference) tmpIter.next();
-                PropertyState child = targetState.getPropertyState(propName);
+                PropertyState child = entry.getPropertyState();
-                                                                 QPropertyDefinition def)
+                                                          QPropertyDefinition def)
+
+
+    /**
+     * Retrieves the state of the item with the specified id using the given
+     * item state manager.
+     * <p/>
+     * Note that access rights are <b><i>not</i></b> enforced!
+     *
+     * @param id
+     * @return
+     * @throws ItemNotFoundException
+     * @throws RepositoryException
+     */
+    private NodeState getNodeState(NodeId id) throws ItemNotFoundException, RepositoryException {
+        try {
+            return (NodeState) getItemState(id);
+        } catch (NoSuchItemStateException e) {
+            throw new ItemNotFoundException(id.toString());
+        } catch (ItemStateException e) {
+            String msg = "internal error: failed to retrieve state of " + id.toString();
+            log.debug(msg);
+            throw new RepositoryException(msg, e);
+        }
+    }

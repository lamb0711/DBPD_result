JCR-1104 - JSR 283 support
- shareble nodes (work in progress)


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@638398 13f79535-47bb-0310-9956-ffa450edef68

-
+    
+    /**
+     * Shareable node cache.
+     */
+    private final ShareableNodesCache shareableNodesCache;
+    
+        
+        // setup shareable nodes cache
+        shareableNodesCache = new ShareableNodesCache();
+        shareableNodesCache.clear();
+     * Returns a shareble node with a given id and parent id.
+     * @param id
+     * @return
+     * @throws RepositoryException
+     */
+    public synchronized NodeImpl getNode(NodeId id, NodeId parentId)
+            throws ItemNotFoundException, AccessDeniedException, RepositoryException {
+        // check sanity of session
+        session.sanityCheck();
+        
+        // check shareable nodes
+        NodeImpl node = shareableNodesCache.retrieve(id, parentId);
+        if (node != null) {
+            return node;
+        }
+        
+        node = (NodeImpl) getItem(id);
+        if (!node.getParentId().equals(parentId)) {
+            node = new NodeImpl(node, parentId);
+            shareableNodesCache.cache(node);
+        }
+        return node;
+    }
+
+    /**
-            return (ItemImpl) itemCache.get(id);
+            ItemImpl item = (ItemImpl) itemCache.get(id);
+            if (item == null && id.denotesNode()) {
+                item = shareableNodesCache.retrieve((NodeId) id);
+            }
+            return item;
+        if (item.isNode()) {
+            NodeImpl node = (NodeImpl) item;
+            if (node.isShareable()) {
+                shareableNodesCache.cache(node);
+                return;
+            }
+        }
+        if (item.isNode()) {
+            shareableNodesCache.evict((NodeImpl) item);
+        }
+        if (item.isNode()) {
+            shareableNodesCache.evict((NodeImpl) item);
+        }
+    
+    /**
+     * Invoked by a <code>NodeImpl</code> when it is has become transient
+     * and has therefore replaced its state. Will inform all other nodes
+     * in the shareable set about this change.
+     */
+    public void becameTransient(NodeImpl node) {
+        NodeState state = (NodeState) node.getItemState();
+        
+        NodeImpl n = (NodeImpl) retrieveItem(node.getId());
+        if (n != null && n != node) {
+            n.stateReplaced(state);
+        }
+        shareableNodesCache.stateReplaced(node);
+    }
+
+    /**
+     * Invoked by a <code>NodeImpl</code> when it is has become transient
+     * and has therefore replaced its state. Will inform all other nodes
+     * in the shareable set about this change.
+     */
+    public void persisted(NodeImpl node) {
+        NodeState state = (NodeState) node.getItemState();
+        
+        NodeImpl n = (NodeImpl) retrieveItem(node.getId());
+        if (n != null && n != node) {
+            n.stateReplaced(state);
+        }
+        shareableNodesCache.stateReplaced(node);
+    }
+    
+    /**
+     * Cache of shareable nodes.
+     */
+    class ShareableNodesCache {
+        
+        /**
+         * This cache is based on a reference map, that maps an item id to a map,
+         * which again maps a (hard-ref) parent id to a (weak-ref) shareable node.
+         */
+        private final ReferenceMap cache;
+        
+        /**
+         * Create a new instance of this class.
+         */
+        public ShareableNodesCache() {
+            cache = new ReferenceMap(ReferenceMap.HARD, ReferenceMap.HARD);
+        }
+        
+        /**
+         * Clear cache.
+         * 
+         * @see ReferenceMap#clear()
+         */
+        public void clear() {
+            cache.clear();
+        }
+
+        /**
+         * Return the first available node that maps to the given id.
+         * 
+         * @param id node id
+         * @return node or <code>null</code>
+         */
+        public synchronized NodeImpl retrieve(NodeId id) {
+            ReferenceMap map = (ReferenceMap) cache.get(id);
+            if (map != null) {
+                Iterator iter = map.values().iterator();
+                while (iter.hasNext()) {
+                    NodeImpl node = (NodeImpl) iter.next();
+                    if (node != null) {
+                        return node;
+                    }
+                }
+            }
+            return null;
+        }
+
+        /**
+         * Return the node with the given id and parent id.
+         * 
+         * @param id node id
+         * @param parentId parent id
+         * @return node or <code>null</code>
+         */
+        public synchronized NodeImpl retrieve(NodeId id, NodeId parentId) {
+            ReferenceMap map = (ReferenceMap) cache.get(id);
+            if (map != null) {
+                return (NodeImpl) map.get(parentId);
+            }
+            return null;
+        }
+        
+        /**
+         * Cache some node.
+         * 
+         * @param node node to cache
+         */
+        public synchronized void cache(NodeImpl node) {
+            ReferenceMap map = (ReferenceMap) cache.get(node.getId());
+            if (map == null) {
+                map = new ReferenceMap(ReferenceMap.HARD, ReferenceMap.WEAK);
+                cache.put(node.getId(), map);
+            }
+            Object old = map.put(node.getParentId(), node);
+            if (old != null) {
+                log.warn("overwriting cached item: " + old);
+            }
+        }
+        
+        /**
+         * Evict some node from the cache.
+         * 
+         * @param node node to evict
+         */
+        public synchronized void evict(NodeImpl node) {
+            ReferenceMap map = (ReferenceMap) cache.get(node.getId());
+            if (map != null) {
+                map.remove(node.getParentId());
+            }
+        }
+        
+        /**
+         * Evict all nodes with a given node id from the cache.
+         * 
+         * @param id node id to evict
+         */
+        public synchronized void evictAll(NodeId id) {
+            cache.remove(id);
+        }
+
+        /**
+         * TODO SN: document
+         */
+        public synchronized void stateReplaced(NodeImpl node) {
+            NodeState state = (NodeState) node.getItemState();
+
+            ReferenceMap map = (ReferenceMap) cache.get(node.getId());
+            if (map != null) {
+                Iterator iter = map.values().iterator();
+                while (iter.hasNext()) {
+                    NodeImpl n = (NodeImpl) iter.next();
+                    if (n != null && n != node) {
+                        n.stateReplaced(state);
+                    }
+                }
+            }
+        }
+    }

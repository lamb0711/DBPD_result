JCR-2104: JSR 283 Versioning
   - VersionHistory.getAllFrozenNodes()  (move iteratoradaptor from core to jcr-commons), VersionHistory.getVersionableIdentifier()
   - Version.getFrozenNode, Version.getLinearPredecessor()
   - VersionManager (work in progress): 170-methods, shallow merge, checkpoint
      -> extend SPI interfaces accordingly

JCR-2003: JCR2SPI / SPI: Add support for JCR 2.0
   - Session.hasPermission()
   - Node.getProperties/getNodes with glob
   - Node.getIdentifier()

JCR-2004: Update SPI locking to match JCR 2.0
   - separate JCR LockManager from the internal lock manager

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@773828 13f79535-47bb-0310-9956-ffa450edef68

-        checkIsAlive();
-        // build the array of actions to be checked
-        String[] actionsArr = actions.split(",");
-
-        Path targetPath = getQPath(absPath);
-
-        boolean isGranted;
-        // The given abs-path may point to a non-existing item
-        if (itemManager.nodeExists(targetPath)) {
-            NodeState nState = getHierarchyManager().getNodeState(targetPath);
-            isGranted = getAccessManager().isGranted(nState, actionsArr);
-        } else if (itemManager.propertyExists(targetPath)) {
-            PropertyState pState = getHierarchyManager().getPropertyState(targetPath);
-            isGranted = getAccessManager().isGranted(pState, actionsArr);
-        } else {
-            NodeState parentState = null;
-            Path parentPath = targetPath;
-            while (parentState == null) {
-                parentPath = parentPath.getAncestor(1);
-                if (itemManager.nodeExists(parentPath)) {
-                    parentState = getHierarchyManager().getNodeState(parentPath);
-                }
-            }
-            // parentState is the nearest existing nodeState or the root state.
-            Path relPath = parentPath.computeRelativePath(targetPath);
-            isGranted = getAccessManager().isGranted(parentState, relPath, actionsArr);
-        }
-
-        if (!isGranted) {
+        if (!hasPermission(absPath, actions)) {
-    public boolean hasPermission(String absPath, String actions)
-            throws RepositoryException {
-        // TODO: implementation missing
-        throw new UnsupportedRepositoryOperationException("JCR-1104");
+    public boolean hasPermission(String absPath, String actions) throws RepositoryException {
+        checkIsAlive();
+        // build the array of actions to be checked
+        String[] actionsArr = actions.split(",");
+
+        Path targetPath = getQPath(absPath);
+
+        boolean isGranted;
+        // The given abs-path may point to a non-existing item
+        if (itemManager.nodeExists(targetPath)) {
+            NodeState nState = getHierarchyManager().getNodeState(targetPath);
+            isGranted = getAccessManager().isGranted(nState, actionsArr);
+        } else if (itemManager.propertyExists(targetPath)) {
+            PropertyState pState = getHierarchyManager().getPropertyState(targetPath);
+            isGranted = getAccessManager().isGranted(pState, actionsArr);
+        } else {
+            NodeState parentState = null;
+            Path parentPath = targetPath;
+            while (parentState == null) {
+                parentPath = parentPath.getAncestor(1);
+                if (itemManager.nodeExists(parentPath)) {
+                    parentState = getHierarchyManager().getNodeState(parentPath);
+                }
+            }
+            // parentState is the nearest existing nodeState or the root state.
+            Path relPath = parentPath.computeRelativePath(targetPath);
+            isGranted = getAccessManager().isGranted(parentState, relPath, actionsArr);
+        }
+        return isGranted;

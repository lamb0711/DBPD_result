JCR-1589: JSR 283 Retention & Hold Management (work in progress)
JCR-1957: Move common validation checks to a single place

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@738422 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.security.AccessManager;
-        // make sure that parent node is checked-out
-        if (!parentNode.internalIsCheckedOut()) {
-            String msg = this + ": cannot add a child to a checked-in node";
-            log.debug(msg);
-            throw new VersionException(msg);
-        }
-
-        // check lock status
-        parentNode.checkLock();
+        // make sure that parent node is checked-out and not locked
+        int options = ItemValidator.CHECK_LOCK | ItemValidator.CHECK_VERSIONING;
+        session.getValidator().checkModify(parentNode, options, Permission.NONE);
-        // check protected flag of parent (i.e. this) node
-        final NodeDefinition definition = data.getNodeDefinition();
-        if (definition.isProtected()) {
-            String msg = this + ": cannot add a child to a protected node";
-            log.debug(msg);
-            throw new ConstraintViolationException(msg);
-        }
+        // check protected flag of parent (i.e. this) node and retention/hold
+        int options = ItemValidator.CHECK_CONSTRAINTS | ItemValidator.CHECK_HOLD |
+                ItemValidator.CHECK_RETENTION;
+        session.getValidator().checkModify(this, options, Permission.NONE);
-        // make sure this node is checked-out
-        if (!internalIsCheckedOut()) {
-            String msg = this + ": cannot add a mixin node type to a checked-in node";
-            log.debug(msg);
-            throw new VersionException(msg);
-        }
-
-        // check protected flag
-        final NodeDefinition definition = data.getNodeDefinition();
-        if (definition.isProtected()) {
-            String msg = this + ": cannot add a mixin node type to a protected node";
-            log.debug(msg);
-            throw new ConstraintViolationException(msg);
-        }
-
-        // check lock status
-        checkLock();
-        // check permissions
-        Path p = getPrimaryPath();
-        AccessManager acMgr = session.getAccessManager();
-        acMgr.checkPermission(p, Permission.NODE_TYPE_MNGMT);
+        int options = ItemValidator.CHECK_LOCK | ItemValidator.CHECK_VERSIONING |
+                ItemValidator.CHECK_CONSTRAINTS | ItemValidator.CHECK_HOLD;
+        int permissions = Permission.NODE_TYPE_MNGMT;
-            acMgr.checkPermission(p, Permission.VERSION_MNGMT);
+            permissions |= Permission.VERSION_MNGMT;
+        session.getValidator().checkModify(this, options, permissions);
-        // make sure this node is checked-out
-        if (!internalIsCheckedOut()) {
-            String msg =
-                this + ": cannot remove a mixin node type from a checked-in node";
-            log.debug(msg);
-            throw new VersionException(msg);
-        }
-
-        // check protected flag
-        NodeDefinition definition = data.getNodeDefinition();
-        if (definition.isProtected()) {
-            String msg =
-                this + ": cannot remove a mixin node type from a protected node";
-            log.debug(msg);
-            throw new ConstraintViolationException(msg);
-        }
-
-        // check lock status
-        checkLock();
-        // check permission
-        session.getAccessManager().checkPermission(getPrimaryPath(), Permission.NODE_TYPE_MNGMT);
+        int options = ItemValidator.CHECK_LOCK | ItemValidator.CHECK_VERSIONING |
+                ItemValidator.CHECK_CONSTRAINTS | ItemValidator.CHECK_HOLD;
+        int permissions = Permission.NODE_TYPE_MNGMT;
+        session.getValidator().checkModify(this, options, permissions);
-        // make sure this node is checked-out
-        if (!internalIsCheckedOut()) {
-            String msg = this + ": cannot set property of a checked-in node";
-            log.debug(msg);
-            throw new VersionException(msg);
-        }
-
-        // check lock status
-        checkLock();
+        // make sure this node is checked-out and is not locked
+        int options = ItemValidator.CHECK_LOCK | ItemValidator.CHECK_VERSIONING;
+        session.getValidator().checkModify(this, options, Permission.NONE);
-        // make sure this node is checked-out
-        if (!internalIsCheckedOut()) {
-            String msg = this + ": cannot add node to a checked-in node";
-            log.debug(msg);
-            throw new VersionException(msg);
-        }
-
-        // check lock status
-        checkLock();
+        // make sure this node is checked-out and not locked by another session.
+        int options = ItemValidator.CHECK_LOCK | ItemValidator.CHECK_VERSIONING;
+        session.getValidator().checkModify(this, options, Permission.NONE);
-        // make sure this node is checked-out
-        if (!internalIsCheckedOut()) {
-            String msg =
-                this + ": cannot change child node ordering of a checked-in node";
-            log.debug(msg);
-            throw new VersionException(msg);
-        }
-
-        // check protected flag
-        final NodeDefinition definition = data.getNodeDefinition();
-        if (definition.isProtected()) {
-            String msg =
-                this + ": cannot change child node ordering of a protected node";
-            log.debug(msg);
-            throw new ConstraintViolationException(msg);
-        }
-
-        // check lock status
-        checkLock();
+        // make sure this node is checked-out and neither protected nor locked
+        int options = ItemValidator.CHECK_LOCK | ItemValidator.CHECK_VERSIONING |
+                ItemValidator.CHECK_CONSTRAINTS;
+        session.getValidator().checkModify(this, options, Permission.NONE);
-        if (!internalIsCheckedOut()) {
-            String msg = this + ": cannot add a child to a checked-in node";
-            log.debug(msg);
-            throw new VersionException(msg);
-        }
-
-        checkLock();
+        // (3) check protected flag of parent (i.e. this) node
+        int options = ItemValidator.CHECK_LOCK | ItemValidator.CHECK_VERSIONING | ItemValidator.CHECK_CONSTRAINTS;
+        session.getValidator().checkModify(this, options, Permission.NONE);
-        // (3) check for name collisions
+        // (4) check for name collisions
-        // (4) check protected flag of parent (i.e. this) node
-        final NodeDefinition definition = data.getNodeDefinition();
-        if (definition.isProtected()) {
-            String msg = this + ": cannot add a child to a protected node";
-            log.debug(msg);
-            throw new ConstraintViolationException(msg);
-        }
-
-        // check checked-out status
-        if (!internalIsCheckedOut()) {
+        Name ntName = session.getQName(mixinName);
+        NodeTypeManagerImpl ntMgr = session.getNodeTypeManager();
+        NodeTypeImpl mixin = ntMgr.getNodeType(ntName);
+        if (!mixin.isMixin()) {
-
-        // check protected flag
-        if (data.getNodeDefinition().isProtected()) {
-            return false;
-        }
-
-        // check lock status
-        try {
-            checkLock();
-        } catch (LockException le) {
-            return false;
-        }
-
-        Name ntName;
-        try {
-            ntName = session.getQName(mixinName);
-        } catch (NameException e) {
-            throw new RepositoryException(
-                    "invalid mixin type name: " + mixinName, e);
-        }
-
-        // check permissions
-        Path p = getPrimaryPath();
-        AccessManager acMgr = session.getAccessManager();
-        if (!acMgr.isGranted(p, Permission.NODE_TYPE_MNGMT)) {
-            return false;
-        }
+        
+        int options = ItemValidator.CHECK_LOCK | ItemValidator.CHECK_VERSIONING |
+                ItemValidator.CHECK_CONSTRAINTS | ItemValidator.CHECK_HOLD;
+        int permissions = Permission.NODE_TYPE_MNGMT;
-            if (!acMgr.isGranted(p, Permission.VERSION_MNGMT)) {
-                return false;
-            }
+            permissions |= Permission.VERSION_MNGMT;
-
-        NodeTypeManagerImpl ntMgr = session.getNodeTypeManager();
-        NodeTypeImpl mixin = ntMgr.getNodeType(ntName);
-        if (!mixin.isMixin()) {
+        if (!session.getValidator().canModify(this, options, permissions)) {
-        // check for pending changes
-        if (hasPendingChanges()) {
-            String msg = "Unable to checkin node. Node has pending changes: " + this;
-            log.debug(msg);
-            throw new InvalidItemStateException(msg);
-        }
-
-        // check lock status
-        checkLock();
-        // check permission
-        session.getAccessManager().checkPermission(getPrimaryPath(), Permission.VERSION_MNGMT);
+        // check lock status, holds and permissions
+        int options = ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD | ItemValidator.CHECK_PENDING_CHANGES_ON_NODE;
+        session.getValidator().checkModify(this, options, Permission.VERSION_MNGMT);
-        // check lock status
-        checkLock();
-        // check permission
-        session.getAccessManager().checkPermission(getPrimaryPath(), Permission.VERSION_MNGMT);
+        int options = ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD;
+        session.getValidator().checkModify(this, options, Permission.VERSION_MNGMT);
-        checkSessionHasPending();
-        checkLock();
+        int options = ItemValidator.CHECK_PENDING_CHANGES | ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD;
+        session.getValidator().checkModify(this, options, Permission.NONE);
-        checkSessionHasPending();
-        checkLock();
+        int options = ItemValidator.CHECK_PENDING_CHANGES | ItemValidator.CHECK_LOCK| ItemValidator.CHECK_HOLD;
+        session.getValidator().checkModify(this, options, Permission.NONE);
-        checkSessionHasPending();
-        checkLock();
+        int options = ItemValidator.CHECK_PENDING_CHANGES | ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD;
+        session.getValidator().checkModify(this, options, Permission.NONE);
-        checkSessionHasPending();
-        checkLock();
+        int options = ItemValidator.CHECK_PENDING_CHANGES | ItemValidator.CHECK_LOCK| ItemValidator.CHECK_HOLD;
+        session.getValidator().checkModify(this, options, Permission.NONE);
-     * Checks if this nodes session has pending changes.
-     *
-     * @throws InvalidItemStateException if this nodes session has pending changes
-     * @throws RepositoryException
-     */
-    private void checkSessionHasPending()
-            throws InvalidItemStateException, RepositoryException {
-        // check for pending changes
-        if (session.hasPendingChanges()) {
-            String msg = "Unable to perform operation. Session has pending changes.";
-            log.debug(msg);
-            throw new InvalidItemStateException(msg);
-        }
-
-
-    }
-
-    /**
-        // check for pending changes
-        if (hasPendingChanges()) {
-            String msg =
-                "Unable to finish merge. Node has pending changes: " + this;
-            log.debug(msg);
-            throw new InvalidItemStateException(msg);
-        }
-
-        // check lock
-        checkLock();
-        // check permission
-        session.getAccessManager().checkPermission(getPrimaryPath(), Permission.VERSION_MNGMT);
-
-        // check if checked out
-        if (!internalIsCheckedOut()) {
-            String msg = "Unable to finish merge. Node is checked-in: " + this;
-            log.error(msg);
-            throw new VersionException(msg);
-        }
+        // check lock, permissions and checkout-status
+        int options = ItemValidator.CHECK_LOCK | ItemValidator.CHECK_VERSIONING | ItemValidator.CHECK_PENDING_CHANGES_ON_NODE | ItemValidator.CHECK_HOLD;
+        session.getValidator().checkModify(this, options, Permission.VERSION_MNGMT);
-        checkSessionHasPending();
-        // check permission
-        session.getAccessManager().checkPermission(getPrimaryPath(), Permission.VERSION_MNGMT);
+        session.getValidator().checkModify(this, ItemValidator.CHECK_PENDING_CHANGES, Permission.VERSION_MNGMT);
-        // check lock status
-        checkLock();
+        // check lock and hold status
+        int options = ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD;
+        session.getValidator().checkModify(this, options, Permission.NONE);
+     * @deprecated
-        // make sure this node is checked-out
-        if (!internalIsCheckedOut()) {
-            String msg = this + ": cannot set primary type of a checked-in node";
-            log.debug(msg);
-            throw new VersionException(msg);
-        }
-
-        // check protected flag
-        if (data.getDefinition().isProtected()) {
-            String msg = this + ": cannot set primary type of a protected node";
-            log.debug(msg);
-            throw new ConstraintViolationException(msg);
-        }
+        // make sure this node is checked-out, neither protected nor locked and
+        // the editing session has sufficient permission to change the primary type.
+        int options = ItemValidator.CHECK_VERSIONING | ItemValidator.CHECK_LOCK |
+                ItemValidator.CHECK_CONSTRAINTS | ItemValidator.CHECK_HOLD;
+        session.getValidator().checkModify(this, options, Permission.NODE_TYPE_MNGMT);
-        // check lock status
-        checkLock();
-        // check permission
-        session.getAccessManager().checkPermission(getPrimaryPath(), Permission.NODE_TYPE_MNGMT);
-
-        Name ntName;
-        try {
-            ntName = session.getQName(nodeTypeName);
-        } catch (NameException e) {
-            throw new RepositoryException(
-                    "invalid node type name: " + nodeTypeName, e);
-        }
-
+        Name ntName = session.getQName(nodeTypeName);
+            log.debug("Node already has " + nodeTypeName + " as primary node type.");

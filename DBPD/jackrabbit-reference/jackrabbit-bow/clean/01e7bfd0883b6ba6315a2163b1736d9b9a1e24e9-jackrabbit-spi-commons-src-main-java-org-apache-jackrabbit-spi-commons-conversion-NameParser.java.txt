JCR-2288: o.a.jackrabbit.spi.commons.conversion.NameParser should not assume that namespace URI's are registered

Accept {} and {x:y} as valid namespace URI formats in expanded names. No further namespace validity tests are needed.

As a special backwards compatibility feature, {internal} is also accepted as a valid URI prefix.

Adjusted a few corner case tests that are affected by this change.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@815745 13f79535-47bb-0310-9956-ffa450edef68

-                    try {
-                        // make sure the uri is a known namespace uri
-                        // TODO: since namespace registration does not validate
-                        //       the URI format validation is omitted here
-                        if (!checkFormat) {
-                            resolver.getPrefix(tmp);
-                        }
+                    if (tmp.length() == 0 || tmp.indexOf(':') != -1) {
+                        // The leading "{...}" part is empty or contains
+                        // a colon, so we treat it as a valid namespace URI.
+                        // More detailed validity checks (is it well formed,
+                        // registered, etc.) are not needed here.
-                    } catch (NamespaceException e) {
-                        // unknown uri -> apparently a localname starting with {
-                        // -> make sure there are no invalid characters
-                        if (tmp.indexOf(':') == -1 && tmp.indexOf('/') == -1) {
-                            state = STATE_NAME;
-                            nameStart = 0;
-                        } else {
-                            throw new IllegalNameException("Unknown uri " + tmp + ". But ':' and '/' are not allowed in a local name.");
-                        }
+                    } else if (tmp.equals("internal")) {
+                        // As a special Jackrabbit backwards compatibility
+                        // feature, support {internal} as a valid URI prefix
+                        uri = tmp;
+                        state = STATE_NAME_START;
+                    } else if (tmp.indexOf('/') == -1) {
+                        // The leading "{...}" contains neither a colon nor
+                        // a slash, so we can interpret it as a a part of a
+                        // normal local name.
+                        state = STATE_NAME;
+                        nameStart = 0;
+                    } else {
+                        throw new IllegalNameException(
+                                "The URI prefix of the name " + jcrName
+                                + " is neither a valid URI nor a valid part"
+                                + " of a local name.");

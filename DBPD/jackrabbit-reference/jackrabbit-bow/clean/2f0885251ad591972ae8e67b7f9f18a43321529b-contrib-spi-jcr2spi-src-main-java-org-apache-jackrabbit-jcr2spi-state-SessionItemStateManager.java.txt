Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.hierarchy.NodeEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.PropertyEntry;
-import org.apache.jackrabbit.spi.ItemId;
-import org.apache.jackrabbit.spi.IdFactory;
-import java.util.Set;
-import java.util.HashSet;
-import java.util.Collection;
-import java.util.Collections;
-                                   IdFactory idFactory,
-                                   QValueFactory qValueFactory) {
+                                   QValueFactory qValueFactory,
+                                   ItemStateFactory isf) {
+        
-        this.transientStateMgr = new TransientItemStateManager(idFactory, workspaceItemStateMgr);
+        this.transientStateMgr = new TransientItemStateManager();
+        isf.addCreationListener(transientStateMgr);
+
-    //---------------------------------------------------< ItemStateManager >---
-    /**
-     * {@inheritDoc}
-     * @see ItemStateManager#getRootState()
-     */
-    public NodeState getRootState() throws ItemStateException {
-        // always retrieve from transientStateMgr
-        return transientStateMgr.getRootState();
-    }
-
-    /**
-     * {@inheritDoc}
-     * @see ItemStateManager#getItemState(ItemId)
-     */
-    public ItemState getItemState(ItemId id)
-            throws NoSuchItemStateException, ItemStateException {
-
-        ItemState itemState = transientStateMgr.getItemState(id);
-        // check status of ItemState. Transient ISM also returns removed ItemStates
-        if (itemState.isValid()) {
-            return itemState;
-        } else {
-            throw new NoSuchItemStateException(id.toString());
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     * @see ItemStateManager#hasItemState(ItemId)
-     */
-    public boolean hasItemState(ItemId id) {
-        // first check if the specified item exists at all in the transient ISM
-        if (transientStateMgr.hasItemState(id)) {
-            // retrieve item and check state
-            try {
-                ItemState itemState = transientStateMgr.getItemState(id);
-                if (itemState.isValid()) {
-                    return true;
-                }
-            } catch (ItemStateException e) {
-                // has been removed in the meantime
-            }
-        }
-        return false;
-    }
-
-    /**
-     * {@inheritDoc}
-     * Since node references cannot be managed within the transient space,
-     * this call is delegated to the workspace itemstate manager.
-     *
-     * @see ItemStateManager#getReferingStates(NodeState)
-     * @param nodeState
-     */
-    public Collection getReferingStates(NodeState nodeState) throws ItemStateException {
-        NodeState wspState = (NodeState) nodeState.getWorkspaceState();
-        if (wspState == null) {
-            // new state => unable to determine references
-            return Collections.EMPTY_SET;
-        }
-
-        Collection rs = workspaceItemStateMgr.getReferingStates(wspState);
-        if (rs.isEmpty()) {
-            return rs;
-        } else {
-            // retrieve session-propertystates
-            Set refStates = new HashSet();
-            for (Iterator it =  rs.iterator(); it.hasNext();) {
-                PropertyState wState = (PropertyState) it.next();
-                ItemState sState = wState.getSessionState();
-                if (sState == null) {
-                    // overlaying state has not been build up to now
-                   sState = getItemState(wState.getPropertyId());
-                }
-                // add property state to list of refering states unless it has
-                // be removed in the transient layer.
-                if (sState.isValid()) {
-                   refStates.add(sState);
-                }
-            }
-            return Collections.unmodifiableCollection(refStates);
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     * Since node references cannot be managed within the transient space,
-     * this call is delegated to the workspace itemstate manager.
-     *
-     * @see ItemStateManager#hasReferingStates(NodeState)
-     * @param nodeState
-     */
-    public boolean hasReferingStates(NodeState nodeState) {
-        try {
-            return !getReferingStates(nodeState).isEmpty();
-        } catch (ItemStateException e) {
-            log.warn("Internal error", e);
-            return false;
-        }
-    }
-
-    //------------------------------------------< UpdatableItemStateManager >---
-    /**
-     * {@inheritDoc}
-     */
-    public void execute(Operation operation) throws RepositoryException {
-        operation.accept(this);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void execute(ChangeLog changes) throws RepositoryException {
-        throw new UnsupportedOperationException("Not implemented for SessionItemStateManager");
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void dispose() {
-        // discard all transient changes
-        transientStateMgr.dispose();
-        // dispose our (i.e. 'local') state manager
-        workspaceItemStateMgr.dispose();
-    }
-
-    //--------------------------------------------------------------------------
-     *         <code>false</code> otherwise.
+     * <code>false</code> otherwise.
-     *                            and descendant items is not a closed set of
-     *                            changes. That is, at least another item needs
-     *                            to be canceled as well in another sub-tree.
+     * and descendant items is not a closed set of changes. That is, at least
+     * another item needs to be canceled as well in another sub-tree.
-                state.revert();
+                state.getHierarchyEntry().revert();
-     * Adjust references at the end of a successful {@link Session#importXML(String, InputStream, int) XML import}.
+     * Adjust references at the end of a successful
+     * {@link Session#importXML(String, InputStream, int) XML import}.
-    //-------------------------------------------< Transient state handling >---
-
+    //------------------------------------------< UpdatableItemStateManager >---
-     *
-     * @param itemState
-     * @param throwOnStale Throws StaleItemStateException if either the given
-     * <code>ItemState</code> or any of its decendants is stale and the flag is true.
-     * @return
-     * @throws StaleItemStateException if a stale <code>ItemState</code> is
-     * encountered while traversing the state hierarchy. The <code>changeLog</code>
-     * might have been populated with some transient item states. A client should
-     * therefore not reuse the <code>changeLog</code> if such an exception is thrown.
-     * @throws ItemStateException if <code>state</code> is a new item state.
+     * {@inheritDoc}
+     * @see UpdatableItemStateManager#execute(Operation)
-    private ChangeLog getChangeLog(ItemState itemState, boolean throwOnStale) throws StaleItemStateException, ItemStateException, ConstraintViolationException {
-        // build changelog for affected and decendant states only
-        ChangeLog changeLog = new ChangeLog(itemState);
-        // fail-fast test: check status of this item's state
-        if (itemState.getStatus() == Status.NEW) {
-            String msg = "Cannot save an item with status NEW (" +itemState+ ").";
-            log.debug(msg);
-            throw new ItemStateException(msg);
-        }
-        if (throwOnStale && Status.isStale(itemState.getStatus())) {
-            String msg =  "Attempt to save an item, that has been externally modified (" +itemState+ ").";
-            log.debug(msg);
-            throw new StaleItemStateException(msg);
-        }
-        // collect transient/stale states that should be persisted or reverted
-        itemState.collectStates(changeLog, throwOnStale);
-
-        changeLog.collectOperations(transientStateMgr.getOperations());
-        changeLog.checkIsSelfContained();
-        return changeLog;
+    public void execute(Operation operation) throws RepositoryException {
+        operation.accept(this);
-    //--------------------------------------------------------------------------
+    /**
+     * {@inheritDoc}
+     * @see UpdatableItemStateManager#execute(ChangeLog)
+     */
+    public void execute(ChangeLog changes) throws RepositoryException {
+        throw new UnsupportedOperationException("Not implemented for SessionItemStateManager");
+    }
+     * {@inheritDoc}
+     * @see UpdatableItemStateManager#dispose()
+     */
+    public void dispose() {
+        // discard all transient changes
+        transientStateMgr.dispose();
+        // dispose our (i.e. 'local') state manager
+        workspaceItemStateMgr.dispose();
+    }
+
+    //---------------------------------------------------< OperationVisitor >---
+    /**
+     * @see OperationVisitor#visit(AddNode)
+     * @see OperationVisitor#visit(AddProperty)
-        QPropertyDefinition pDef = validator.getApplicablePropertyDefinition(propertyName, operation.getPropertyType(), operation.isMultiValued(), parent);
+        QPropertyDefinition pDef = operation.getDefinition();
+     * @see OperationVisitor#visit(Move)
+     * @see OperationVisitor#visit(Remove)
-        // remember operation unless new state got removed
+        // unless new state got removed remember operation and mark parent modified.
+            operation.getParentState().markModified();
+     * @see OperationVisitor#visit(SetMixin)
+        NodeEntry nEntry = (NodeEntry) nState.getHierarchyEntry();
-        // new array of mixinNames to be set on the nodestate (and corresponding property state)
-        if (mixinNames != null && mixinNames.length > 0) {
-            // update/create corresponding property state
-            if (nState.hasPropertyName(QName.JCR_MIXINTYPES)) {
-                // execute value of existing property
-                try {
-                    PropertyState pState = nState.getPropertyState(QName.JCR_MIXINTYPES);
+        try {
+            // new array of mixinNames to be set on the nodestate (and corresponding property state)
+            PropertyEntry mixinEntry = nEntry.getPropertyEntry(QName.JCR_MIXINTYPES);
+            if (mixinNames != null && mixinNames.length > 0) {
+                // update/create corresponding property state
+                if (mixinEntry != null) {
+                    // execute value of existing property
+                    PropertyState pState = mixinEntry.getPropertyState();
-                } catch (ItemStateException e) {
-                    // should not occur, since existance has been asserted before
-                    throw new RepositoryException(e);
+                } else {
+                    // create new jcr:mixinTypes property
+                    EffectiveNodeType ent = validator.getEffectiveNodeType(nState);
+                    QPropertyDefinition pd = ent.getApplicablePropertyDefinition(QName.JCR_MIXINTYPES, PropertyType.NAME, true);
+                    QValue[] mixinValue = getQValues(mixinNames, qValueFactory);
+                    int options = ItemStateValidator.CHECK_LOCK | ItemStateValidator.CHECK_VERSIONING;
+                    addPropertyState(nState, pd.getQName(), pd.getRequiredType(), mixinValue, pd, options);
+                nState.markModified();
+                transientStateMgr.addOperation(operation);
-                // create new jcr:mixinTypes property
-                EffectiveNodeType ent = validator.getEffectiveNodeType(nState);
-                QPropertyDefinition pd = ent.getApplicablePropertyDefinition(QName.JCR_MIXINTYPES, PropertyType.NAME, true);
-                QValue[] mixinValue = getQValues(mixinNames, qValueFactory);
-                int options = ItemStateValidator.CHECK_LOCK | ItemStateValidator.CHECK_VERSIONING;
-                addPropertyState(nState, pd.getQName(), pd.getRequiredType(), mixinValue, pd, options);
-            }
-        } else {
-            // remove the jcr:mixinTypes property state if already present
-            if (nState.hasPropertyName(QName.JCR_MIXINTYPES)) {
-                try {
-                    PropertyState pState = nState.getPropertyState(QName.JCR_MIXINTYPES);
+                // remove the jcr:mixinTypes property state if already present
+                if (mixinEntry != null) {
+                    PropertyState pState = mixinEntry.getPropertyState();
+                    boolean newMixinState = pState.getStatus() == Status.NEW;
-                } catch (ItemStateException e) {
-                    // should not occur, since existance has been asserted before
-                    throw new RepositoryException(e);
+                    // only added the remove-mixin operation if it doesn't revert
+                    // a previous 'add-mixin' (which has been removed automatically
+                    // upon notification of removing the prop-state).
+                    if (!newMixinState) {
+                        nState.markModified();
+                        transientStateMgr.addOperation(operation);
+                    }
+        } catch (ItemStateException e) {
+            // should not occur, since existance has been asserted before
+            throw new RepositoryException(e);
-
-        nState.markModified();
-        transientStateMgr.addOperation(operation);
+     * @see OperationVisitor#visit(SetPropertyValue)
+     * @see OperationVisitor#visit(ReorderNodes)
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(Clone)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(Clone)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(Clone)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(Clone)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(Update)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(Restore)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(Merge)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(ResolveMergeConflict)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(LockOperation)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(LockRefresh)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(LockRelease)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(AddLabel)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(RemoveLabel)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(RemoveVersion)
+     */
+     * @param itemState
+     * @param throwOnStale Throws StaleItemStateException if either the given
+     * <code>ItemState</code> or any of its decendants is stale and the flag is true.
+     * @return
+     * @throws StaleItemStateException if a stale <code>ItemState</code> is
+     * encountered while traversing the state hierarchy. The <code>changeLog</code>
+     * might have been populated with some transient item states. A client should
+     * therefore not reuse the <code>changeLog</code> if such an exception is thrown.
+     * @throws ItemStateException if <code>state</code> is a new item state.
+     */
+    private ChangeLog getChangeLog(ItemState itemState, boolean throwOnStale) throws StaleItemStateException, ItemStateException, ConstraintViolationException {
+        // build changelog for affected and decendant states only
+        ChangeLog changeLog = new ChangeLog(itemState);
+        // fail-fast test: check status of this item's state
+        if (itemState.getStatus() == Status.NEW) {
+            String msg = "Cannot save an item with status NEW (" +itemState+ ").";
+            log.debug(msg);
+            throw new ItemStateException(msg);
+        }
+        if (throwOnStale && Status.isStale(itemState.getStatus())) {
+            String msg =  "Attempt to save an item, that has been externally modified (" +itemState+ ").";
+            log.debug(msg);
+            throw new StaleItemStateException(msg);
+        }
+        // collect transient/stale states that should be persisted or reverted
+        itemState.getHierarchyEntry().collectStates(changeLog, throwOnStale);
+
+        changeLog.collectOperations(transientStateMgr.getOperations());
+        changeLog.checkIsSelfContained();
+        return changeLog;
+    }
+
+    /**
+     *
-            itemState.remove();
+            itemState.getHierarchyEntry().transientRemove();

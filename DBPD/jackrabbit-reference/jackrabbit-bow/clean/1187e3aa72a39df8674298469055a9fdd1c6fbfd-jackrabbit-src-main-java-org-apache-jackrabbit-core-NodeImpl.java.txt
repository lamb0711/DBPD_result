JCR-605: Error when registering node types on virgin repository
- centralized workspace initialization code in SharedItemStateManager. The jcr:system node is now created within the same method as the root node of the workspace: SharedItemStateManager.createRootNodeState()

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@469480 13f79535-47bb-0310-9956-ffa450edef68

-    /**
-     * Adds a child node entry for a virtual node state to this node. E.g. the
-     * node <code>/jcr:system/jcr:versionStorage</code>.
-     *
-     * @param nodeName the name of the virtual child node.
-     * @param nodeType the node type of the virtual child node.
-     * @param id       the id of the virtual node state.
-     * @return the <code>NodeImpl</code> for the virtual node state with
-     *         <code>id</code>.
-     * @throws ItemExistsException          if there already exists a child node
-     *                                      entry with the given <code>nodeName</code>.
-     * @throws ConstraintViolationException if this node does not allow a child
-     *                                      node with the specified <code>nodeType</code>
-     *                                      and <code>nodeName</code>.
-     * @throws RepositoryException          if there is no virtual node state
-     *                                      with <code>id</code>.
-     */
-    protected NodeImpl internalAddVirtualChildNode(QName nodeName,
-                                                   NodeTypeImpl nodeType,
-                                                   NodeId id)
-            throws ItemExistsException, ConstraintViolationException, RepositoryException {
-        Path nodePath;
-        try {
-            nodePath = Path.create(getPrimaryPath(), nodeName, true);
-        } catch (MalformedPathException e) {
-            // should never happen
-            String msg = "internal error: invalid path " + safeGetJCRPath();
-            log.debug(msg);
-            throw new RepositoryException(msg, e);
-        }
-
-        NodeDefinitionImpl def;
-        try {
-            QName nodeTypeName = null;
-            if (nodeType != null) {
-                nodeTypeName = nodeType.getQName();
-            }
-            def = getApplicableChildNodeDefinition(nodeName, nodeTypeName);
-        } catch (RepositoryException re) {
-            String msg = "no definition found in parent node's node type for new node";
-            log.debug(msg);
-            throw new ConstraintViolationException(msg, re);
-        }
-
-        // check for name collisions
-        NodeState thisState = (NodeState) state;
-        if (thisState.hasPropertyName(nodeName)) {
-            // there's already a property with that name
-            throw new ItemExistsException(itemMgr.safeGetJCRPath(nodePath));
-        }
-        NodeState.ChildNodeEntry cne = thisState.getChildNodeEntry(nodeName, 1);
-        if (cne != null) {
-            // there's already a child node entry with that name;
-            // check same-name sibling setting of new node
-            if (!def.allowsSameNameSiblings()) {
-                throw new ItemExistsException(itemMgr.safeGetJCRPath(nodePath));
-            }
-            // check same-name sibling setting of existing node
-            NodeId newId = cne.getId();
-            if (!((NodeImpl) itemMgr.getItem(newId)).getDefinition().allowsSameNameSiblings()) {
-                throw new ItemExistsException(itemMgr.safeGetJCRPath(nodePath));
-            }
-        }
-
-        // get virtual node state
-        NodeState nodeState;
-        try {
-            nodeState = (NodeState) stateMgr.getItemState(id);
-        } catch (ItemStateException e) {
-            String msg = "failed to get virtual child node " + nodeName + " of "
-                    + safeGetJCRPath();
-            log.debug(msg);
-            throw new RepositoryException(msg, e);
-        }
-
-        // create Node instance wrapping virtual state
-        NodeImpl node = itemMgr.createNodeInstance(nodeState, def);
-
-        // touch the virtual node, otherwise save will complain that the
-        // virtual node needs to be saved as well.
-        node.getOrCreateTransientItemState();
-
-        // add new child node entry
-        thisState.addChildNodeEntry(nodeName, id);
-
-        return node;
-    }
-

JCR-1590 JSR 283: Locking

- getSecondsRemaining is negative if lock is expired or released
- getLockToken always returns null if lock is sessionscoped

JCR-2004 Update SPI locking to match JCR 2.0

- extend spi/LockInfo.java
- add JCR 2.0 variant of RepositoryService#lock that takes timeoutHint and ownerHint
- adjust jcr2spi
- adjust spi implementation(s)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@753244 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.JcrConstants;
-import javax.jcr.Node;
-    private final boolean sessionScoped;
-        this (lock, lock.isSessionScoped());
-    }
-
-    /**
-     * Create a new <code>ActiveLock</code> object with type '{@link Type#WRITE write}'
-     * and scope '{@link Scope#EXCLUSIVE exclusive}'.
-     *
-     * @param lock
-     */
-    public JcrActiveLock(Lock lock, boolean sessionScoped) {
-        this.sessionScoped = sessionScoped;
+     * <p/>
+     * In case of session-scoped JCR 2.0 locks, the token is never exposed even
+     * if the current session is lock holder. In order to cope with DAV specific
+     * requirements and the fulfill the requirement stated above, the node's
+     * identifier is subsequently exposed as DAV-token.
-        return lock.getLockToken();
+        String token = lock.getLockToken();
+        if (token == null && lock.isSessionScoped()
+                && lock instanceof org.apache.jackrabbit.api.jsr283.lock.Lock
+                && ((org.apache.jackrabbit.api.jsr283.lock.Lock)lock).isLockOwningSession()) {
+            // special handling for session scoped locks that are owned by the
+            // current session but never expose their token with jsr 283.
+            try {
+                token = ((org.apache.jackrabbit.api.jsr283.Node)lock.getNode()).getIdentifier();
+            } catch (RepositoryException e) {
+                // should never get here
+                log.warn("Unexpected error while retrieving node identifier for building a DAV specific lock token.",e.getMessage());
+            }
+        }
+        // default behaviour: just return the token exposed by the lock.
+        return token;
-        boolean isDeep = true;
-        Node n = lock.getNode();
-        try {
-            // find out about deepness. if node does not hold the lock its deep anyway
-            if (n.holdsLock() && n.hasProperty(JcrConstants.JCR_LOCKISDEEP)) {
-                isDeep = n.getProperty(JcrConstants.JCR_LOCKISDEEP).getBoolean();
-            }
-        } catch (RepositoryException e) {
-            // ignore and keep default depth settings
-        }
-        return isDeep;
+        return lock.isDeep();
-        return (sessionScoped) ? ItemResourceConstants.EXCLUSIVE_SESSION : Scope.EXCLUSIVE;
+        return (lock.isSessionScoped()) ? ItemResourceConstants.EXCLUSIVE_SESSION : Scope.EXCLUSIVE;

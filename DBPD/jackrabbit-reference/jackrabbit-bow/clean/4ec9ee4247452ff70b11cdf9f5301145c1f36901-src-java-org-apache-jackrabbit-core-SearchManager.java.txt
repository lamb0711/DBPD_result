- removed @author and @version (i.e. $Revision & $Id) tags
- removed tab characters from java source code

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@47648 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.search.NamespaceMappings;
-import org.apache.jackrabbit.core.search.QueryRootNode;
-import org.apache.jackrabbit.core.search.OrderQueryNode;
-import org.apache.jackrabbit.core.search.lucene.SearchIndex;
-import org.apache.jackrabbit.core.search.lucene.NodeIndexer;
-import org.apache.jackrabbit.core.search.lucene.FieldNames;
-import org.apache.jackrabbit.core.search.lucene.QueryResultImpl;
-import org.apache.jackrabbit.core.search.lucene.LuceneQueryBuilder;
-import org.apache.jackrabbit.core.observation.SynchronousEventListener;
+import org.apache.jackrabbit.core.observation.SynchronousEventListener;
+import org.apache.jackrabbit.core.search.NamespaceMappings;
+import org.apache.jackrabbit.core.search.OrderQueryNode;
+import org.apache.jackrabbit.core.search.QueryRootNode;
+import org.apache.jackrabbit.core.search.lucene.*;
+import org.apache.jackrabbit.core.state.ItemStateException;
-import org.apache.jackrabbit.core.state.ItemStateException;
-import org.apache.lucene.search.Query;
+import org.apache.lucene.search.Query;
-import javax.jcr.observation.EventIterator;
-import javax.jcr.observation.EventType;
-import java.io.IOException;
+import javax.jcr.observation.EventIterator;
+import javax.jcr.observation.EventType;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Collections;
-import java.util.Set;
-import java.util.HashSet;
-import java.util.Iterator;
+import java.io.IOException;
+import java.util.*;
- *
- * @author Marcel Reutegger
- * @version $Revision:  $, $Date:  $
-			 HierarchyManager hmgr,
-			 SessionImpl session,
-			 String indexPath) throws IOException {
-	this.stateProvider = stateProvider;
-	this.hmgr = hmgr;
-	this.session = session;
-	index = new SearchIndex(indexPath, new StandardAnalyzer());
-	nsMappings = new NamespaceMappings(new File(indexPath, "ns_mappings.properties"));
+                         HierarchyManager hmgr,
+                         SessionImpl session,
+                         String indexPath) throws IOException {
+        this.stateProvider = stateProvider;
+        this.hmgr = hmgr;
+        this.session = session;
+        index = new SearchIndex(indexPath, new StandardAnalyzer());
+        nsMappings = new NamespaceMappings(new File(indexPath, "ns_mappings.properties"));
-	// FIXME rather throw RepositoryException?
-	log.debug("add node to index: " + path);
-	Document doc = NodeIndexer.createDocument(node, stateProvider, path, nsMappings);
-	index.addDocument(doc);
+        // FIXME rather throw RepositoryException?
+        log.debug("add node to index: " + path);
+        Document doc = NodeIndexer.createDocument(node, stateProvider, path, nsMappings);
+        index.addDocument(doc);
-	log.debug("update index for node: " + path);
-	deleteNode(path, node.getUUID());
-	addNode(node, path);
+        log.debug("update index for node: " + path);
+        deleteNode(path, node.getUUID());
+        addNode(node, path);
-	log.debug("remove node from index: " + path);
-	index.removeDocument(new Term(FieldNames.UUID, uuid));
+        log.debug("remove node from index: " + path);
+        index.removeDocument(new Term(FieldNames.UUID, uuid));
-	index.close();
+        index.close();
-				   QueryRootNode root,
-				   SessionImpl session)
-	    throws RepositoryException {
+                                   QueryRootNode root,
+                                   SessionImpl session)
+            throws RepositoryException {
-	// build lucene query
-	Query query = LuceneQueryBuilder.createQuery(root,
-		session, nsMappings, index.getAnalyzer());
+        // build lucene query
+        Query query = LuceneQueryBuilder.createQuery(root,
+                session, nsMappings, index.getAnalyzer());
-	OrderQueryNode orderNode = root.getOrderNode();
-	// FIXME according to spec this should be descending
-	// by default. this contrasts to standard sql semantics
-	// where default is ascending.
-	boolean ascending = true;
-	String[] orderProperties = null;
-	if (orderNode != null) {
-	    ascending = orderNode.isAscending();
-	    orderProperties = orderNode.getOrderByProperties();
-	} else {
-	    orderProperties = new String[0];
-	}
+        OrderQueryNode orderNode = root.getOrderNode();
+        // FIXME according to spec this should be descending
+        // by default. this contrasts to standard sql semantics
+        // where default is ascending.
+        boolean ascending = true;
+        String[] orderProperties = null;
+        if (orderNode != null) {
+            ascending = orderNode.isAscending();
+            orderProperties = orderNode.getOrderByProperties();
+        } else {
+            orderProperties = new String[0];
+        }
-	List uuids;
+        List uuids;
-	// execute it
-	try {
-	    Hits result = index.executeQuery(query, orderProperties, ascending);
-	    uuids = new ArrayList(result.length());
-	    for (int i = 0; i < result.length(); i++) {
-		String uuid = result.doc(i).get(FieldNames.UUID);
-		// check access
-		if (accessMgr.isGranted(new NodeId(uuid), Permission.READ_ITEM)) {
-		    uuids.add(uuid);
-		}
-	    }
-	} catch (IOException e) {
-	    uuids = Collections.EMPTY_LIST;
-	}
+        // execute it
+        try {
+            Hits result = index.executeQuery(query, orderProperties, ascending);
+            uuids = new ArrayList(result.length());
+            for (int i = 0; i < result.length(); i++) {
+                String uuid = result.doc(i).get(FieldNames.UUID);
+                // check access
+                if (accessMgr.isGranted(new NodeId(uuid), Permission.READ_ITEM)) {
+                    uuids.add(uuid);
+                }
+            }
+        } catch (IOException e) {
+            uuids = Collections.EMPTY_LIST;
+        }
-	// return QueryResult
-	return new QueryResultImpl(itemMgr,
-		(String[]) uuids.toArray(new String[uuids.size()]),
-		root.getSelectProperties());
+        // return QueryResult
+        return new QueryResultImpl(itemMgr,
+                (String[]) uuids.toArray(new String[uuids.size()]),
+                root.getSelectProperties());
-	Set modified = new HashSet();
+        Set modified = new HashSet();
-	// FIXME optimize operations on index.
-	// only one cycle of document removes and document adds
+        // FIXME optimize operations on index.
+        // only one cycle of document removes and document adds
-	while (events.hasNext()) {
-	    try {
-		EventImpl e = (EventImpl) events.nextEvent();
-		long type = e.getType();
-		if (type == EventType.CHILD_NODE_ADDED) {
+        while (events.hasNext()) {
+            try {
+                EventImpl e = (EventImpl) events.nextEvent();
+                long type = e.getType();
+                if (type == EventType.CHILD_NODE_ADDED) {
-		    Path path = Path.create(
-			    e.getNodePath() + ((e.getNodePath().length() > 1) ? "/" : "") + e.getChildName(),
-			    session.getNamespaceResolver(),
-			    true);
+                    Path path = Path.create(e.getNodePath() + ((e.getNodePath().length() > 1) ? "/" : "") + e.getChildName(),
+                            session.getNamespaceResolver(),
+                            true);
-		    path = getIndexlessPath(path);
+                    path = getIndexlessPath(path);
-		    ItemId id = new NodeId(e.getChildUUID());
-		    addNode((NodeState) stateProvider.getItemState(id),
-			    path.toJCRPath(nsMappings));
+                    ItemId id = new NodeId(e.getChildUUID());
+                    addNode((NodeState) stateProvider.getItemState(id),
+                            path.toJCRPath(nsMappings));
-		} else if (type == EventType.CHILD_NODE_REMOVED) {
+                } else if (type == EventType.CHILD_NODE_REMOVED) {
-		    Path path = Path.create(e.getNodePath() + ((e.getNodePath().length() > 1) ? "/" : "") + e.getChildName(),
-			    session.getNamespaceResolver(),
-			    true);
-		    deleteNode(path.toJCRPath(nsMappings), e.getChildUUID());
+                    Path path = Path.create(e.getNodePath() + ((e.getNodePath().length() > 1) ? "/" : "") + e.getChildName(),
+                            session.getNamespaceResolver(),
+                            true);
+                    deleteNode(path.toJCRPath(nsMappings), e.getChildUUID());
-		} else if (type == EventType.PROPERTY_ADDED
-			|| type == EventType.PROPERTY_CHANGED
-			|| type == EventType.PROPERTY_REMOVED) {
+                } else if (type == EventType.PROPERTY_ADDED
+                        || type == EventType.PROPERTY_CHANGED
+                        || type == EventType.PROPERTY_REMOVED) {
-		    Path path = Path.create(
-			    e.getNodePath(),
-			    session.getNamespaceResolver(),
-			    true);
-		    modified.add(path);
-		}
-	    } catch (MalformedPathException e) {
-		log.error("error indexing node.", e);
-	    } catch (NoPrefixDeclaredException e) {
-		log.error("error indexing node.", e);
-	    } catch (ItemStateException e) {
-		log.error("error indexing node.", e);
-	    } catch (RepositoryException e) {
-		log.error("error indexing node.", e);
-	    } catch (IOException e) {
-		log.error("error indexing node.", e);
-	    }
-	}
+                    Path path = Path.create(e.getNodePath(),
+                            session.getNamespaceResolver(),
+                            true);
+                    modified.add(path);
+                }
+            } catch (MalformedPathException e) {
+                log.error("error indexing node.", e);
+            } catch (NoPrefixDeclaredException e) {
+                log.error("error indexing node.", e);
+            } catch (ItemStateException e) {
+                log.error("error indexing node.", e);
+            } catch (RepositoryException e) {
+                log.error("error indexing node.", e);
+            } catch (IOException e) {
+                log.error("error indexing node.", e);
+            }
+        }
-	for (Iterator it = modified.iterator(); it.hasNext();) {
-	    try {
-		Path path = (Path) it.next();
-		ItemId id = hmgr.resolvePath(path);
-		path = getIndexlessPath(path);
-		updateNode((NodeState) stateProvider.getItemState(id),
-			path.toJCRPath(nsMappings));
-	    } catch (NoPrefixDeclaredException e) {
-		log.error("error indexing node.", e);
-	    } catch (ItemStateException e) {
-		log.error("error indexing node.", e);
-	    } catch (RepositoryException e) {
-		log.error("error indexing node.", e);
-	    } catch (IOException e) {
-		log.error("error indexing node.", e);
-	    }
-	}
+        for (Iterator it = modified.iterator(); it.hasNext();) {
+            try {
+                Path path = (Path) it.next();
+                ItemId id = hmgr.resolvePath(path);
+                path = getIndexlessPath(path);
+                updateNode((NodeState) stateProvider.getItemState(id),
+                        path.toJCRPath(nsMappings));
+            } catch (NoPrefixDeclaredException e) {
+                log.error("error indexing node.", e);
+            } catch (ItemStateException e) {
+                log.error("error indexing node.", e);
+            } catch (RepositoryException e) {
+                log.error("error indexing node.", e);
+            } catch (IOException e) {
+                log.error("error indexing node.", e);
+            }
+        }
+     *
-	boolean hasIndexes = false;
-	Path.PathElement[] elements = p.getElements();
-	for (int i = 0; i < elements.length && !hasIndexes; i++) {
-	    hasIndexes = (elements[i].getIndex() > 0);
-	}
+        boolean hasIndexes = false;
+        Path.PathElement[] elements = p.getElements();
+        for (int i = 0; i < elements.length && !hasIndexes; i++) {
+            hasIndexes = (elements[i].getIndex() > 0);
+        }
-	if (hasIndexes) {
-	    // create Path without indexes
-	    Path.PathBuilder builder = new Path.PathBuilder();
-	    builder.addRoot();
-	    for (int i = 1; i < elements.length; i++) {
-		builder.addLast(elements[i].getName());
-	    }
-	    try {
-		return builder.getPath();
-	    } catch (MalformedPathException e) {
-		// will never happen, because Path p is always valid
-		log.error("internal error: malformed path.", e);
-	    }
-	}
-	// return original path if it does not contain indexed path elements
-	return p;
+        if (hasIndexes) {
+            // create Path without indexes
+            Path.PathBuilder builder = new Path.PathBuilder();
+            builder.addRoot();
+            for (int i = 1; i < elements.length; i++) {
+                builder.addLast(elements[i].getName());
+            }
+            try {
+                return builder.getPath();
+            } catch (MalformedPathException e) {
+                // will never happen, because Path p is always valid
+                log.error("internal error: malformed path.", e);
+            }
+        }
+        // return original path if it does not contain indexed path elements
+        return p;

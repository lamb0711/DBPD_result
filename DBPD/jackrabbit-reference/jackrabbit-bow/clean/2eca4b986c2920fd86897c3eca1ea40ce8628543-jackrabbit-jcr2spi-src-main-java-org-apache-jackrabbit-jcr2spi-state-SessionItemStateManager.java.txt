JCR-1799 updating events swallowed (CacheBehavior.OBSERVATION)   	
JCR-1783 incomplete changelog when combining move with removal of new destination parent

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@704361 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.List;
+import java.util.ArrayList;
-        if (!hasPendingChanges()) {
+        if (!transientStateMgr.hasPendingChanges()) {
-
-        ChangeLog changeLog = getChangeLog(state, true);
+        ChangeLog changeLog = transientStateMgr.getChangeLog(state, true);
-
-        try {
-            ChangeLog changeLog = getChangeLog(itemState, false);
-            if (!changeLog.isEmpty()) {
-                // let changelog revert all changes
-                changeLog.undo();
-                // remove transient states and related operations from the t-statemanager
-                transientStateMgr.dispose(changeLog);
-                changeLog.reset();
-            }
-        } catch (InvalidItemStateException e) {
-            // should never get here
-            String msg = "Unable to undo item.";
-            log.debug(msg);
-            throw new RepositoryException(e);
+        // short cut
+        if (!transientStateMgr.hasPendingChanges()) {
+            return;
+        }
+        ChangeLog changeLog = transientStateMgr.getChangeLog(itemState, false);
+        if (!changeLog.isEmpty()) {
+            // let changelog revert all changes
+            changeLog.undo();
+            // remove transient states and related operations from the t-statemanager
+            transientStateMgr.dispose(changeLog);
+            changeLog.reset();
-        addNodeState(parent, operation.getNodeName(), operation.getNodeTypeName(), operation.getUuid(), def, options);
+        List newStates = addNodeState(parent, operation.getNodeName(), operation.getNodeTypeName(), operation.getUuid(), def, options);
+        operation.addedState(newStates);
-        // unless new state got removed remember operation and mark parent modified.
-        if (!Status.isTerminal(state.getStatus())) {
-            transientStateMgr.addOperation(operation);
-            operation.getParentState().markModified();
-        }
+        
+        transientStateMgr.addOperation(operation);
+        operation.getParentState().markModified();
-        NodeEntry nEntry = (NodeEntry) nState.getHierarchyEntry();
+        NodeEntry nEntry = nState.getNodeEntry();
-        // new array of mixinNames to be set on the nodestate (and corresponding property state)
+        // assert the existence of the property entry and set the array of
+        // mixinNames to be set on the corresponding property state
-        if (mixinNames != null && mixinNames.length > 0) {
+        if (mixinNames.length > 0) {
-        } else {
+        } else if (mixinEntry != null) {
-            if (mixinEntry != null) {
-                PropertyState pState = mixinEntry.getPropertyState();
-                boolean newMixinState = pState.getStatus() == Status.NEW;
-                int options = ItemStateValidator.CHECK_LOCK | ItemStateValidator.CHECK_VERSIONING;
-                removeItemState(pState, options);
-                // only added the remove-mixin operation if it doesn't revert
-                // a previous 'add-mixin' (which has been removed automatically
-                // upon notification of removing the prop-state).
-                if (!newMixinState) {
-                    nState.markModified();
-                    transientStateMgr.addOperation(operation);
-                }
-            }
-        }
+            PropertyState pState = mixinEntry.getPropertyState();
+            boolean newMixinState = pState.getStatus() == Status.NEW;
+            int options = ItemStateValidator.CHECK_LOCK | ItemStateValidator.CHECK_VERSIONING;
+            removeItemState(pState, options);
+
+            nState.markModified();
+            transientStateMgr.addOperation(operation);
+        } // else: empty Name array and no mixin-prop-entry (should not occur)
-     * @param itemState
-     * @param throwOnStale Throws InvalidItemStateException if either the given
-     * <code>ItemState</code> or any of its decendants is stale and the flag is true.
-     * @return
-     * @throws InvalidItemStateException if a stale <code>ItemState</code> is
-     * encountered while traversing the state hierarchy. The <code>changeLog</code>
-     * might have been populated with some transient item states. A client should
-     * therefore not reuse the <code>changeLog</code> if such an exception is thrown.
-     * @throws RepositoryException if <code>state</code> is a new item state.
-     */
-    private ChangeLog getChangeLog(ItemState itemState, boolean throwOnStale) throws InvalidItemStateException, ConstraintViolationException, RepositoryException {
-        // build changelog for affected and decendant states only
-        ChangeLog changeLog = new ChangeLog(itemState);
-        // fail-fast test: check status of this item's state
-        if (itemState.getStatus() == Status.NEW) {
-            String msg = "Cannot save/revert an item with status NEW (" +itemState+ ").";
-            log.debug(msg);
-            throw new RepositoryException(msg);
-        }
-        if (throwOnStale && Status.isStale(itemState.getStatus())) {
-            String msg =  "Attempt to save/revert an item, that has been externally modified (" +itemState+ ").";
-            log.debug(msg);
-            throw new InvalidItemStateException(msg);
-        }
-        // collect transient/stale states that should be persisted or reverted
-        itemState.getHierarchyEntry().collectStates(changeLog, throwOnStale);
-
-        changeLog.collectOperations(transientStateMgr.getOperations());
-        changeLog.checkIsSelfContained();
-        return changeLog;
-    }
-
-    /**
-     *
-    private void addPropertyState(NodeState parent, Name propertyName,
+    private PropertyState addPropertyState(NodeState parent, Name propertyName,
-        transientStateMgr.createNewPropertyState(propertyName, parent, pDef, values, propertyType);
+        return transientStateMgr.createNewPropertyState(propertyName, parent, pDef, values, propertyType);
-    private void addNodeState(NodeState parent, Name nodeName, Name nodeTypeName,
+    private List addNodeState(NodeState parent, Name nodeName, Name nodeTypeName,
+        List addedStates = new ArrayList();
+
-        // state for consistency between 'addNode' and importXML // TODO review
+        // state for consistency between 'addNode' and importXML
+        addedStates.add(nodeState);
-            addPropertyState(nodeState, NameConstants.JCR_UUID, PropertyType.STRING, value, pDef, 0);
+            addedStates.add(addPropertyState(nodeState, NameConstants.JCR_UUID, PropertyType.STRING, value, pDef, 0));
-                    addPropertyState(nodeState, pd.getName(), pd.getRequiredType(), autoValue, pd, propOptions);
+                    addedStates.add(addPropertyState(nodeState, pd.getName(), pd.getRequiredType(), autoValue, pd, propOptions));
-            addNodeState(nodeState, nd.getName(), nd.getDefaultPrimaryType(), null, nd, opt);
+            addedStates.addAll(addNodeState(nodeState, nd.getName(), nd.getDefaultPrimaryType(), null, nd, opt));
+        return addedStates;

JCR-1547: JCR2SPI: remove dependency to state-package within entprovider interface

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@650417 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.spi.QNodeTypeDefinition;
-import org.apache.jackrabbit.spi.commons.nodetype.NodeTypeConflictException;
-import java.util.HashMap;
+import java.util.HashMap;
-    private final TreeSet mergedNodeTypes;
+    private final TreeSet mergedNodeTypes = new TreeSet();
-    private final TreeSet inheritedNodeTypes;
+    private final TreeSet inheritedNodeTypes = new TreeSet();
-    private final TreeSet allNodeTypes;
+    private final TreeSet allNodeTypes = new TreeSet();
-    private final HashMap namedItemDefs;
+    private final Map namedItemDefs = new HashMap();
-    private final ArrayList unnamedItemDefs;
+    private final List unnamedItemDefs = new ArrayList();
-     * private constructor.
+     * constructor.
-    private EffectiveNodeTypeImpl() {
-        mergedNodeTypes = new TreeSet();
-        inheritedNodeTypes = new TreeSet();
-        allNodeTypes = new TreeSet();
-        namedItemDefs = new HashMap();
-        unnamedItemDefs = new ArrayList();
-        supportedMixins = null;
-    }
-
-    /**
-     * Factory method: creates an effective node type
-     * representation of a node type definition. Whereas all referenced
-     * node types must exist (i.e. must be registered), the definition itself
-     * is not required to be registered.
-     *
-     * @param entProvider
-     * @param ntd
-     * @param ntdMap
-     * @return
-     * @throws NodeTypeConflictException
-     * @throws NoSuchNodeTypeException
-     */
-    static EffectiveNodeTypeImpl create(EffectiveNodeTypeProvider entProvider, QNodeTypeDefinition ntd, Map ntdMap)
-            throws NodeTypeConflictException, NoSuchNodeTypeException {
-        // create empty effective node type instance
-        EffectiveNodeTypeImpl ent = new EffectiveNodeTypeImpl();
-        Name ntName = ntd.getName();
-
-        // prepare new instance
-        ent.mergedNodeTypes.add(ntName);
-        ent.allNodeTypes.add(ntName);
-
-        Name[] smixins = ntd.getSupportedMixinTypes();
-    
-        if (smixins != null) {
-            ent.supportedMixins = new HashSet();
-            for (int i = 0; i < smixins.length; i++) {
-                ent.supportedMixins.add(smixins[i]);
-            }
+    EffectiveNodeTypeImpl(TreeSet mergedNodeTypes, TreeSet inheritedNodeTypes,
+                          TreeSet allNodeTypes, Map namedItemDefs,
+                          List unnamedItemDefs, Set supportedMixins) {
+        this.mergedNodeTypes.addAll(mergedNodeTypes);
+        this.inheritedNodeTypes.addAll(inheritedNodeTypes);
+        this.allNodeTypes.addAll(allNodeTypes);
+        Iterator iter = namedItemDefs.keySet().iterator();
+        while (iter.hasNext()) {
+            Object key = iter.next();
+            List list = (List) namedItemDefs.get(key);
+            this.namedItemDefs.put(key, new ArrayList(list));
-        
-        // map of all item definitions (maps id to definition)
-        // used to effectively detect ambiguous child definitions where
-        // ambiguity is defined in terms of definition identity
-        Set itemDefIds = new HashSet();
+        this.unnamedItemDefs.addAll(unnamedItemDefs);
-        QNodeDefinition[] cnda = ntd.getChildNodeDefs();
-        for (int i = 0; i < cnda.length; i++) {
-            // check if child node definition would be ambiguous within
-            // this node type definition
-            if (itemDefIds.contains(cnda[i])) {
-                // conflict
-                String msg;
-                if (cnda[i].definesResidual()) {
-                    msg = ntName + " contains ambiguous residual child node definitions";
-                } else {
-                    msg = ntName + " contains ambiguous definitions for child node named "
-                            + cnda[i].getName();
-                }
-                log.debug(msg);
-                throw new NodeTypeConflictException(msg);
-            } else {
-                itemDefIds.add(cnda[i]);
-            }
-            if (cnda[i].definesResidual()) {
-                // residual node definition
-                ent.unnamedItemDefs.add(cnda[i]);
-            } else {
-                // named node definition
-                Name name = cnda[i].getName();
-                List defs = (List) ent.namedItemDefs.get(name);
-                if (defs == null) {
-                    defs = new ArrayList();
-                    ent.namedItemDefs.put(name, defs);
-                }
-                if (defs.size() > 0) {
-                    /**
-                     * there already exists at least one definition with that
-                     * name; make sure none of them is auto-create
-                     */
-                    for (int j = 0; j < defs.size(); j++) {
-                        QItemDefinition qDef = (QItemDefinition) defs.get(j);
-                        if (cnda[i].isAutoCreated() || qDef.isAutoCreated()) {
-                            // conflict
-                            String msg = "There are more than one 'auto-create' item definitions for '"
-                                    + name + "' in node type '" + ntName + "'";
-                            log.debug(msg);
-                            throw new NodeTypeConflictException(msg);
-                        }
-                    }
-                }
-                defs.add(cnda[i]);
-            }
+        if (supportedMixins != null) {
+            this.supportedMixins = new HashSet();
+            this.supportedMixins.addAll(supportedMixins);
-        QPropertyDefinition[] pda = ntd.getPropertyDefs();
-        for (int i = 0; i < pda.length; i++) {
-            // check if property definition would be ambiguous within
-            // this node type definition
-            if (itemDefIds.contains(pda[i])) {
-                // conflict
-                String msg;
-                if (pda[i].definesResidual()) {
-                    msg = ntName + " contains ambiguous residual property definitions";
-                } else {
-                    msg = ntName + " contains ambiguous definitions for property named "
-                            + pda[i].getName();
-                }
-                log.debug(msg);
-                throw new NodeTypeConflictException(msg);
-            } else {
-                itemDefIds.add(pda[i]);
-            }
-            if (pda[i].definesResidual()) {
-                // residual property definition
-                ent.unnamedItemDefs.add(pda[i]);
-            } else {
-                // named property definition
-                Name name = pda[i].getName();
-                List defs = (List) ent.namedItemDefs.get(name);
-                if (defs == null) {
-                    defs = new ArrayList();
-                    ent.namedItemDefs.put(name, defs);
-                }
-                if (defs.size() > 0) {
-                    /**
-                     * there already exists at least one definition with that
-                     * name; make sure none of them is auto-create
-                     */
-                    for (int j = 0; j < defs.size(); j++) {
-                        QItemDefinition qDef = (QItemDefinition) defs.get(j);
-                        if (pda[i].isAutoCreated() || qDef.isAutoCreated()) {
-                            // conflict
-                            String msg = "There are more than one 'auto-create' item definitions for '"
-                                    + name + "' in node type '" + ntName + "'";
-                            log.debug(msg);
-                            throw new NodeTypeConflictException(msg);
-                        }
-                    }
-                }
-                defs.add(pda[i]);
-            }
-        }
-
-        // resolve supertypes recursively
-        Name[] supertypes = ntd.getSupertypes();
-        if (supertypes.length > 0) {
-            EffectiveNodeTypeImpl effSuperType = (EffectiveNodeTypeImpl)entProvider.getEffectiveNodeType(supertypes, ntdMap);
-            ent.internalMerge(effSuperType, true);
-        }
-
-        // we're done
-        return ent;
-     * @throws NodeTypeConflictException
+     * @throws ConstraintViolationException
-            throws NodeTypeConflictException {
+            throws ConstraintViolationException {
-     * @throws NodeTypeConflictException
+     * @throws ConstraintViolationException
-    private synchronized void internalMerge(EffectiveNodeTypeImpl other, boolean supertype)
-            throws NodeTypeConflictException {
+    synchronized void internalMerge(EffectiveNodeTypeImpl other, boolean supertype)
+            throws ConstraintViolationException {
-                            throw new NodeTypeConflictException(msg);
+                            throw new ConstraintViolationException(msg);
-                                    throw new NodeTypeConflictException(msg);
+                                    throw new ConstraintViolationException(msg);
-                                throw new NodeTypeConflictException(msg);
+                                throw new ConstraintViolationException(msg);
-                            throw new NodeTypeConflictException(msg);
+                            throw new ConstraintViolationException(msg);
-                            throw new NodeTypeConflictException(msg);
+                            throw new ConstraintViolationException(msg);
-        EffectiveNodeTypeImpl clone = new EffectiveNodeTypeImpl();
-
-        clone.mergedNodeTypes.addAll(mergedNodeTypes);
-        clone.inheritedNodeTypes.addAll(inheritedNodeTypes);
-        clone.allNodeTypes.addAll(allNodeTypes);
-        Iterator iter = namedItemDefs.keySet().iterator();
-        while (iter.hasNext()) {
-            Object key = iter.next();
-            List list = (List) namedItemDefs.get(key);
-            clone.namedItemDefs.put(key, new ArrayList(list));
-        }
-        clone.unnamedItemDefs.addAll(unnamedItemDefs);
-        
-        if (supportedMixins != null) {
-            clone.supportedMixins = new HashSet();
-            clone.supportedMixins.addAll(supportedMixins);
-        }
-
+        EffectiveNodeTypeImpl clone = new EffectiveNodeTypeImpl(mergedNodeTypes,
+                inheritedNodeTypes, allNodeTypes, namedItemDefs, unnamedItemDefs,
+                supportedMixins);

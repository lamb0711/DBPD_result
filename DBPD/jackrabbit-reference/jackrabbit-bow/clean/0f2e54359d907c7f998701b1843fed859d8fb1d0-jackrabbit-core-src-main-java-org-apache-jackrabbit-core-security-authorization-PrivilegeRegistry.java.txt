JCR-1588 - JSR 283: Access Control (work in progress)
JCR-1590 - JSR 283: Locking
JCR-1915 - Node.setPrimaryNodeType should only redefine child-definitions that are not covered by the new effective nt
JCR-1875 - Failing Node.unlock() might leave inconsistent transient state
JCR-538 - Failing Node.checkin() or Node.checkout() might leave inconsistent transient state

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@732693 13f79535-47bb-0310-9956-ffa450edef68

-    private static final Set REGISTERED_PRIVILEGES = new HashSet(10);
+    /**
+     * Jackrabbit specific write privilege that combines {@link Privilege#JCR_WRITE}
+     * and {@link Privilege#NODE_TYPE_MNGMT}.
+     */
+    public static final String REP_WRITE = "{" + Name.NS_REP_URI + "}write";
+
+    private static final Set REGISTERED_PRIVILEGES = new HashSet(20);
-    public static final int READ = 1;
-    public static final int MODIFY_PROPERTIES = 2;
-    public static final int ADD_CHILD_NODES = 4;
-    public static final int REMOVE_CHILD_NODES = 8;
-    public static final int REMOVE_NODE = 16;
-    public static final int READ_AC = 32;
-    public static final int MODIFY_AC = 64;
-    public static final int WRITE = 14;
-    public static final int ALL = 127;
+
+    private static final int READ = 1;
+    private static final int MODIFY_PROPERTIES = 2;
+    private static final int ADD_CHILD_NODES = 4;
+    private static final int REMOVE_CHILD_NODES = 8;
+    private static final int REMOVE_NODE = 16;
+    
+    private static final int READ_AC = 32;
+    private static final int MODIFY_AC = 64;
+
+    private static final int NODE_TYPE_MNGMT = 128;
+    private static final int VERSION_MNGMT = 256;
+    private static final int LOCK_MNGMT = 512;
+    private static final int LIFECYCLE_MNGMT = 1024;
+    private static final int RETENTION_MNGMT = 2048;
+
+    private static final int WRITE = 30;
+    private static final int JACKRABBIT_WRITE = 158;
+    private static final int ALL = 4095;
+
+
+    private static final InternalPrivilege NODE_TYPE_MANAGEMENT_PRIVILEGE = registerPrivilege(new InternalPrivilege(Privilege.JCR_NODE_TYPE_MANAGEMENT, NODE_TYPE_MNGMT));
+    private static final InternalPrivilege VERSION_MANAGEMENT_PRIVILEGE = registerPrivilege(new InternalPrivilege(Privilege.JCR_VERSION_MANAGEMENT, VERSION_MNGMT));
+    private static final InternalPrivilege LOCK_MANAGEMENT_PRIVILEGE = registerPrivilege(new InternalPrivilege(Privilege.JCR_LOCK_MANAGEMENT, LOCK_MNGMT));
+    private static final InternalPrivilege LIFECYCLE_MANAGEMENT_PRIVILEGE = registerPrivilege(new InternalPrivilege(Privilege.JCR_LIFECYCLE_MANAGEMENT, LIFECYCLE_MNGMT));
+    private static final InternalPrivilege RETENTION_MANAGEMENT_PRIVILEGE = registerPrivilege(new InternalPrivilege(Privilege.JCR_RETENTION_MANAGEMENT, RETENTION_MNGMT));
+
-            REMOVE_CHILD_NODES_PRIVILEGE }));
+            REMOVE_CHILD_NODES_PRIVILEGE,
+            REMOVE_NODE_PRIVILEGE,
+    }));
+
+    private static final InternalPrivilege JACKRABBIT_WRITE_PRIVILEGE = registerPrivilege(new InternalPrivilege(REP_WRITE, new InternalPrivilege[] {
+            WRITE_PRIVILEGE,
+            NODE_TYPE_MANAGEMENT_PRIVILEGE
+    }));
+
-            REMOVE_NODE_PRIVILEGE,
+            JACKRABBIT_WRITE_PRIVILEGE,
-            MODIFY_AC_PRIVILEGE}));
+            MODIFY_AC_PRIVILEGE,
+            VERSION_MANAGEMENT_PRIVILEGE,
+            LOCK_MANAGEMENT_PRIVILEGE,
+            LIFECYCLE_MANAGEMENT_PRIVILEGE,
+            RETENTION_MANAGEMENT_PRIVILEGE
+    }));
+     * Build the permissions granted by evaluating the given privileges.
+     *
+     * @param privs The privileges granted on the Node itself (for properties
+     * the ACL of the direct ancestor).
+     * @param parentPrivs The privileges granted on the parent of the Node. Not
+     * relevant for properties since it only is used to determine permissions
+     * on a Node (add_child_nodes, remove_child_nodes).
+     * @param isAllow
+     * @param protectsPolicy
+     * @return the permissions granted evaluating the given privileges.
+     */
+    public static int calculatePermissions(int privs, int parentPrivs, boolean isAllow, boolean protectsPolicy) {
+        int perm = Permission.NONE;
+        if (protectsPolicy) {
+            if ((parentPrivs & PrivilegeRegistry.READ_AC) == PrivilegeRegistry.READ_AC) {
+                perm |= Permission.READ;
+            }
+            if ((parentPrivs & PrivilegeRegistry.MODIFY_AC) == PrivilegeRegistry.MODIFY_AC) {
+                perm |= Permission.ADD_NODE;
+                perm |= Permission.SET_PROPERTY;
+                perm |= Permission.REMOVE_NODE;
+                perm |= Permission.REMOVE_PROPERTY;
+                perm |= Permission.NODE_TYPE_MNGMT;
+            }
+        } else {
+            if ((privs & READ) == READ) {
+                perm |= Permission.READ;
+            }
+            if ((privs & MODIFY_PROPERTIES) == MODIFY_PROPERTIES) {
+                perm |= Permission.SET_PROPERTY;
+                perm |= Permission.REMOVE_PROPERTY;
+            }
+            // add_node permission is granted through privilege on the parent.
+            if ((parentPrivs & ADD_CHILD_NODES) == ADD_CHILD_NODES) {
+                perm |= Permission.ADD_NODE;
+            }
+            /*
+             remove_node is
+             allowed: only if remove_child_nodes privilege is present on
+                      the parent AND remove_node is present on the node itself
+             denied : if either remove_child_nodes is denied on the parent
+                      OR remove_node is denied on the node itself.
+            */
+            if (isAllow) {
+                if ((parentPrivs & REMOVE_CHILD_NODES) == REMOVE_CHILD_NODES &&
+                        (privs & REMOVE_NODE) == REMOVE_NODE) {
+                    perm |= Permission.REMOVE_NODE;
+                }
+            } else {
+                if ((parentPrivs & REMOVE_CHILD_NODES) == REMOVE_CHILD_NODES ||
+                        (privs & REMOVE_NODE) == REMOVE_NODE) {
+                    perm |= Permission.REMOVE_NODE;
+                }
+            }
+        }
+
+        // the remaining (special) permissions are simply defined on the node
+        if ((privs & READ_AC) == READ_AC) {
+            perm |= Permission.READ_AC;
+        }
+        if ((privs & MODIFY_AC) == MODIFY_AC) {
+            perm |= Permission.MODIFY_AC;
+        }
+        if ((privs & LIFECYCLE_MNGMT) == LIFECYCLE_MNGMT) {
+            perm |= Permission.LIFECYCLE_MNGMT;
+        }
+        if ((privs & LOCK_MNGMT) == LOCK_MNGMT) {
+            perm |= Permission.LOCK_MNGMT;
+        }
+        if ((privs & NODE_TYPE_MNGMT) == NODE_TYPE_MNGMT) {
+            perm |= Permission.NODE_TYPE_MNGMT;
+        }
+        if ((privs & RETENTION_MNGMT) == RETENTION_MNGMT) {
+            perm |= Permission.RETENTION_MNGMT;
+        }
+        if ((privs & VERSION_MNGMT) == VERSION_MNGMT) {
+            perm |= Permission.VERSION_MNGMT;
+        }
+        return perm;
+    }
+    
+    /**
-            if ((bits & WRITE) == WRITE) {
+            if ((bits & JACKRABBIT_WRITE) == JACKRABBIT_WRITE) {
+                privileges.add(JACKRABBIT_WRITE_PRIVILEGE);
+            } else if ((bits & WRITE) == WRITE) {
-            }
-            if ((bits & REMOVE_NODE) == REMOVE_NODE) {
-                privileges.add(REMOVE_NODE_PRIVILEGE);
+                if ((bits & REMOVE_NODE) == REMOVE_NODE) {
+                    privileges.add(REMOVE_NODE_PRIVILEGE);
+                }
+                if ((bits & NODE_TYPE_MNGMT) == NODE_TYPE_MNGMT) {
+                    privileges.add(NODE_TYPE_MANAGEMENT_PRIVILEGE);
+                }
+            if ((bits & VERSION_MNGMT) == VERSION_MNGMT) {
+                privileges.add(VERSION_MANAGEMENT_PRIVILEGE);
+            }
+            if ((bits & LOCK_MNGMT) == LOCK_MNGMT) {
+                privileges.add(LOCK_MANAGEMENT_PRIVILEGE);
+            }
+            if ((bits & LIFECYCLE_MNGMT) == LIFECYCLE_MNGMT) {
+                privileges.add(LIFECYCLE_MANAGEMENT_PRIVILEGE);
+            }
+            if ((bits & RETENTION_MNGMT) == RETENTION_MNGMT) {
+                privileges.add(RETENTION_MANAGEMENT_PRIVILEGE);
+            }
-        private final boolean isAbstract = false;
+        private final boolean isAbstract;
+            isAbstract = false;
+            this.isAbstract = false;
-

re-implemented handling of values on import to allow import of large binary properties 

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@160072 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.util.Base64;
-import org.apache.jackrabbit.core.util.ValueHelper;
-import javax.jcr.Value;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
-                throw new ConstraintViolationException (msg);
+                throw new ConstraintViolationException(msg);
-                InternalValue[] vals = pi.getValues();
+                TextValue[] tva = pi.getValues();
-                    if (vals.length == 1) {
+                    if (tva.length == 1) {
-                if ((vals.length == 0 || vals.length > 1) && !def.isMultiple()) {
+                if ((tva.length == 0 || tva.length > 1) && !def.isMultiple()) {
-                // check whether type conversion is required
-                if (def.getRequiredType() != PropertyType.UNDEFINED
-                        && def.getRequiredType() != type) {
-                    // type doesn't match required type,
-                    // type conversion required
-                    for (int i = 0; i < vals.length; i++) {
-                        // convert InternalValue to Value of required type
-                        Value v =
-                                ValueHelper.convert(vals[i].toJCRValue(nsContext),
-                                        def.getRequiredType());
-                        // convert Value to InternalValue using
-                        // current namespace context of xml document
-                        vals[i] = InternalValue.create(v, nsContext);
+                // convert serialized values to InternalValue objects
+                InternalValue[] iva = new InternalValue[tva.length];
+                int targetType = def.getRequiredType();
+                if (targetType == PropertyType.UNDEFINED) {
+                    if (type == PropertyType.UNDEFINED) {
+                        targetType = PropertyType.STRING;
+                    } else {
+                        targetType = type;
+                for (int i = 0; i < tva.length; i++) {
+                    TextValue tv = tva[i];
+                    if (targetType == PropertyType.BINARY) {
+                        // base64 encoded BINARY type;
+                        // decode using Reader
+/*
+                        // @todo decode to temp file and pass FileInputStream to InternalValue factory method
+                        File tmpFile = null;
+                        try {
+                            tmpFile = File.createTempFile("bin", null);
+                            FileOutputStream out = new FileOutputStream(tmpFile);
+                            Base64.decode(tv.reader(), out);
+                            out.close();
+                            iva[i] = InternalValue.create(new FileInputStream(tmpFile));
+                        } catch (IOException ioe) {
+                            String msg = "failed to decode binary value";
+                            log.debug(msg, ioe);
+                            throw new RepositoryException(msg, ioe);
+                        } finally {
+                            // the temp file can be deleted because
+                            // the InternalValue instance has spooled
+                            // its contents
+                            if (tmpFile != null) {
+                                tmpFile.delete();
+                            }
+                        }
+*/
+                        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+                        try {
+                            Base64.decode(tv.reader(), baos);
+                            // no need to close ByteArrayOutputStream
+                            //baos.close();
+                            iva[i] = InternalValue.create(new ByteArrayInputStream(baos.toByteArray()));
+                        } catch (IOException ioe) {
+                            String msg = "failed to decode binary value";
+                            log.debug(msg, ioe);
+                            throw new RepositoryException(msg, ioe);
+                        }
+                    } else {
+                        // retrieve serialized value
+                        String serValue;
+                        try {
+                            serValue = tv.retrieve();
+                        } catch (IOException ioe) {
+                            String msg = "failed to retrieve serialized value";
+                            log.debug(msg, ioe);
+                            throw new RepositoryException(msg, ioe);
+                        }
+
+                        // convert serialized value to InternalValue using
+                        // current namespace context of xml document
+                        iva[i] = InternalValue.create(serValue, targetType,
+                                nsContext);
+                    }
+
+                }
-                prop.setValues(vals);
+                prop.setValues(iva);

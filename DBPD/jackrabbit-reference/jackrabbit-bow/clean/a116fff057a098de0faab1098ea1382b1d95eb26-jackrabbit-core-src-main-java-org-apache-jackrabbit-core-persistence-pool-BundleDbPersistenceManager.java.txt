JCR-3069: add new ConsistencyChecker interface, implement it in BundleDbPersistenceManager, use it in ConcurrentImportTest, extend AutoFixCorruptNode to check it (work-in-progress)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1181777 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.HashSet;
+import java.util.Set;
+import org.apache.jackrabbit.core.persistence.check.ConsistencyChecker;
+import org.apache.jackrabbit.core.persistence.check.ConsistencyReport;
+import org.apache.jackrabbit.core.persistence.check.ConsistencyReportImpl;
+import org.apache.jackrabbit.core.persistence.check.ReportItem;
+import org.apache.jackrabbit.core.persistence.check.ReportItemImpl;
-        extends AbstractBundlePersistenceManager implements DatabaseAware {
+        extends AbstractBundlePersistenceManager implements DatabaseAware, ConsistencyChecker {
+    private void addMessage(Set<ReportItem> reports, NodeId id, String message) {
+        if (reports != null) {
+            reports.add(new ReportItemImpl(id.toString(), message));
+        }
+    }
+
-                                          boolean fix, Collection<NodePropBundle> modifications) {
+                                          boolean fix, Collection<NodePropBundle> modifications,
+                                          Set<ReportItem> reports) {
+                String message = null;
-                    log.error(
-                            "NodeState '" + id + "' references inexistent child"
-                            + " '" + entry.getName() + "' with id "
-                            + "'" + entry.getId() + "'");
+                    message = "NodeState '" + id + "' references inexistent child" + " '"
+                            + entry.getName() + "' with id " + "'" + entry.getId() + "'";
+                    log.error(message);
-                        log.error("ChildNode has invalid parent uuid: <null>");
+                        message = "ChildNode has invalid parent uuid: <null>";
+                        log.error(message);
-                        log.error("ChildNode has invalid parent uuid: '" + cp + "' (instead of '" + id + "')");
+                        message = "ChildNode has invalid parent uuid: '" + cp + "' (instead of '" + id + "')";
+                        log.error(message);
+                if (message != null) {
+                    addMessage(reports, id, message);
+                }
-                    log.error("NodeState '" + id + "' references inexistent parent uuid '" + parentId + "'");
+                    String message = "NodeState '" + id + "' references inexistent parent uuid '" + parentId + "'";
+                    log.error(message);
+                    addMessage(reports, id, message);
-            	if (!found) {
-            		log.error("NodeState '" + id + "' is not referenced by its parent node '" + parentId + "'");
-            		int l = (int) System.currentTimeMillis();
-            		int r = new Random().nextInt();
-            		int n = l + r; 
-            		String nodeName = Integer.toHexString(n);
-            		parentBundle.addChildNodeEntry(NameFactoryImpl.getInstance().create("{}" + nodeName), id);
-            		log.info("NodeState '" + id + "' adds itself to its parent node '" + parentId + "' with a new name '" + nodeName+ "'");
-            		modifications.add(parentBundle);
-            	}
+                if (!found) {
+                    String message = "NodeState '" + id + "' is not referenced by its parent node '" + parentId + "'";
+                    log.error(message);
+                    addMessage(reports, id, message);
+
+                    int l = (int) System.currentTimeMillis();
+                    int r = new Random().nextInt();
+                    int n = l + r;
+                    String nodeName = Integer.toHexString(n);
+                    parentBundle.addChildNodeEntry(NameFactoryImpl
+                            .getInstance().create("{}" + nodeName), id);
+                    log.info("NodeState '" + id + "' adds itself to its parent node '" + parentId + "' with a new name '" + nodeName + "'");
+                    modifications.add(parentBundle);
+                }
+    public ConsistencyReport check(String[] uuids, boolean recursive,
+            boolean fix) throws RepositoryException {
+
+        Set<ReportItem> reports = new HashSet<ReportItem>();
+
+        long tstart = System.currentTimeMillis();
+        int total = internalCheckConsistency(uuids, recursive, fix, reports);
+        long elapsed = System.currentTimeMillis() - tstart;
+
+        return new ConsistencyReportImpl(total, elapsed, reports);
+    }
+
+        try {
+            internalCheckConsistency(uuids, recursive, fix, null);
+        }
+        catch (RepositoryException ex) {
+            log.error("While running consistency check.", ex);
+        }
+    }
+    
+    private int internalCheckConsistency(String[] uuids, boolean recursive, boolean fix, Set<ReportItem> reports) throws RepositoryException {
-            // get all node bundles in the database with a single sql statement,
+            // get all node bundles in the database with a single SQL statement,
-                        log.error("Could not retrieve total number of bundles. empty result set.");
-                        return;
+                        String message = "Could not retrieve total number of bundles. empty result set.";
+                        log.error(message);
+                        throw new RepositoryException(message);
-                        checkBundleConsistency(id, bundle, fix, modifications);
+                        checkBundleConsistency(id, bundle, fix, modifications, reports);
-                    checkBundleConsistency(id, bundle, fix, modifications);
+                    checkBundleConsistency(id, bundle, fix, modifications, reports);
+
+        return total;

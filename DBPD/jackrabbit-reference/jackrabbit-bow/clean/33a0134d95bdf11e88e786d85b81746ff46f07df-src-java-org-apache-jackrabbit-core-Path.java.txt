- added Path.computeRelativePath method
- removed NodeImpl.isRepositoryRoot and replaced calls with with n.getDepth()==0

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@156060 13f79535-47bb-0310-9956-ffa450edef68

-     * @return a normailzed path representation of this path
+     * @return a normalized path representation of this path
+     * Computes the relative path from <code>this</code> absolute path to
+     * <code>other</code>.
+     *
+     * @param other an absolute path
+     * @return the relative path from <code>this</code> path to
+     *         <code>other</code> path
+     * @throws MalformedPathException if either <code>this</code> or
+     *                                <code>other</code> path is not absolute
+     */
+    public Path computeRelativePath(Path other) throws MalformedPathException {
+        if (other == null) {
+            throw new IllegalArgumentException("null argument");
+        }
+
+        // make sure both paths are absolute
+        if (!isAbsolute() || !other.isAbsolute()) {
+            throw new MalformedPathException("not an absolute path");
+        }
+
+        // make sure we're comparing canonical paths
+        Path p0 = getCanonicalPath();
+        Path p1 = other.getCanonicalPath();
+
+        if (p0.equals(p1)) {
+            // both paths are equal, the relative path is therefore '.'
+            PathBuilder pb = new PathBuilder();
+            pb.addLast(CURRENT_ELEMENT);
+            return pb.getPath();
+        }
+
+        // determine length of common path fragment
+        int lengthCommon = 0;
+        for (int i = 0; i < p0.elements.length && i < p1.elements.length; i++) {
+            if (!p0.elements[i].equals(p1.elements[i])) {
+                break;
+            }
+            lengthCommon++;
+        }
+
+        PathBuilder pb = new PathBuilder();
+        if (lengthCommon < p0.elements.length) {
+            /**
+             * the common path fragment is an ancestor of this path;
+             * this has to be accounted for by prepending '..' elements
+             * to the relative path
+             */
+            int tmp = p0.elements.length - lengthCommon;
+            while (tmp-- > 0) {
+                pb.addFirst(PARENT_ELEMENT);
+            }
+        }
+        // add remainder of other path
+        for (int i = lengthCommon; i < p1.elements.length; i++) {
+            pb.addLast(p1.elements[i]);
+        }
+        // we're done
+        return pb.getPath();
+    }
+
+    /**

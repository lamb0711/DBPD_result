JCR-2140: Baselines & Configurations


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@797094 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Set;
+import java.util.HashSet;
+
+import org.slf4j.LoggerFactory;
+import org.slf4j.Logger;
+     * default logger
+     */
+    private static final Logger log = LoggerFactory.getLogger(VersionManagerImplConfig.class);
+
+    /**
-        NodeStateEx config = parent.getNode(baseline.getVersionHistory().getVersionableId());
-        NodeId rootId = config.getPropertyValue(NameConstants.JCR_ROOT).getNodeId();
+        // check if nt:configuration exists
+        NodeId configId = baseline.getConfigurationId();
+        NodeId rootId = baseline.getConfigurationRootId();
-            throw new UnsupportedRepositoryOperationException(
-                    "Configuration for the given baseline already exists at: " + safeGetJCRPath(existing));
+            String msg = "Configuration for the given baseline already exists at: " + safeGetJCRPath(existing);
+            log.error(msg);
+            throw new UnsupportedRepositoryOperationException(msg);
-            throw new RepositoryException("Internal error: supplied baseline has no version for its configuration root.");
+            String msg = "Internal error: supplied baseline has no version for its configuration root.";
+            log.error(msg);
+            throw new RepositoryException(msg);
+            // check if nt:configuration node exists
+            NodeStateEx config = null;
+            if (stateMgr.hasItemState(configId)) {
+                config = parent.getNode(configId);
+            } else {
+                internalCreateConfiguration(rootId, configId, baseline.getId());
+            }
+            // create the root node so that the restore works
-            // now just restore all versions
-            internalRestore(versions, true);
+
+            // and finally restore the config and root
+            internalRestore(config, baseline, null, false);
+
-            return config.getNodeId();
+            return configId;
-     * Performs a configuration restore
-     * @param config config to restore
-     * @param name name of the baseline version
-     * @param removeExisting remove existing flag
-     * @throws RepositoryException if an error occurs
-     */
-//    protected void restore(InternalConfiguration config, Name name, boolean removeExisting)
-//            throws RepositoryException {
-//        throw new UnsupportedRepositoryOperationException("not implemented, yet");
-//    }
-
-    /**
-     * Performs a configuration restore
-     * @param config config to restore
-     * @param name label of the baseline version
-     * @param removeExisting remove existing flag
-     * @throws RepositoryException if an error occurs
-     */
-//    protected void restoreByLabel(InternalConfiguration config, Name name, boolean removeExisting)
-//            throws RepositoryException {
-//        throw new UnsupportedRepositoryOperationException("not implemented, yet");
-//    }
-
-    /**
-     * Performs a configuration restore
-     * @param config config to restore
-     * @param version baseline version to restore
-     * @param removeExisting remove existing flag
-     * @throws RepositoryException if an error occurs
-     */
-//    protected void restore(InternalConfiguration config, Version version, boolean removeExisting)
-//            throws RepositoryException {
-//        throw new UnsupportedRepositoryOperationException("not implemented, yet");
-//    }
-
-    /**
-            NodeId rootId = state.getNodeId();
-            NodeStateEx configRoot = internalGetConfigRoot();
-            NodeStateEx configParent = InternalVersionManagerBase.getParentNode(
-                    configRoot,
-                    rootId.toString(),
-                    NameConstants.REP_CONFIGURATIONS);
-            Name name = InternalVersionManagerBase.getName(rootId.toString());
-
-            NodeId configId = new NodeId();
-            NodeStateEx config = configParent.addNode(name, NameConstants.NT_CONFIGURATION, configId, true);
-            config.setPropertyValue(NameConstants.JCR_ROOT, InternalValue.create(rootId));
-
-            // init mix:versionable flags
-            VersionHistoryInfo vh = vMgr.getVersionHistory(session, config.getState(), null);
-
-            // and set the base version and history to the config
-            InternalValue historyId = InternalValue.create(vh.getVersionHistoryId());
-            InternalValue versionId = InternalValue.create(vh.getRootVersionId());
-
-            config.setPropertyValue(NameConstants.JCR_BASEVERSION, versionId);
-            config.setPropertyValue(NameConstants.JCR_VERSIONHISTORY, historyId);
-            config.setPropertyValue(NameConstants.JCR_ISCHECKEDOUT, InternalValue.create(true));
-            config.setPropertyValues(NameConstants.JCR_PREDECESSORS, PropertyType.REFERENCE, new InternalValue[]{versionId});
-            configParent.store();
+            NodeId configId = internalCreateConfiguration(state.getNodeId(), null, null);
-
-
+     * Creates a new configuration node.
+     * <p/>
+     * The nt:confguration is stored within the nt:configurations storage using
+     * the nodeid of the configuration root (rootId) as path.
+     *
+     * @param rootId the id of the configuration root node
+     * @param configId the id of the configuration node
+     * @param baseLine id of the baseline version or <code>null</code>
+     * @return the node id of the created configuration
+     * @throws RepositoryException if an error occurs
+     */
+    private NodeId internalCreateConfiguration(NodeId rootId,
+                                              NodeId configId, NodeId baseLine)
+            throws RepositoryException {
+
+        NodeStateEx configRoot = internalGetConfigRoot();
+        NodeStateEx configParent = InternalVersionManagerBase.getParentNode(
+                configRoot,
+                rootId.toString(),
+                NameConstants.REP_CONFIGURATIONS);
+        Name name = InternalVersionManagerBase.getName(rootId.toString());
+
+        if (configId == null) {
+            configId = new NodeId();
+        }
+        NodeStateEx config = configParent.addNode(name, NameConstants.NT_CONFIGURATION, configId, true);
+        Set<Name> mix = new HashSet<Name>();
+        mix.add(NameConstants.REP_VERSION_REFERENCE);
+        config.setMixins(mix);
+        config.setPropertyValue(NameConstants.JCR_ROOT, InternalValue.create(rootId));
+
+        // init mix:versionable flags
+        VersionHistoryInfo vh = vMgr.getVersionHistory(session, config.getState(), null);
+
+        // and set the base version and history to the config
+        InternalValue historyId = InternalValue.create(vh.getVersionHistoryId());
+        InternalValue versionId = InternalValue.create(
+                baseLine == null ? vh.getRootVersionId() : baseLine);
+
+        config.setPropertyValue(NameConstants.JCR_BASEVERSION, versionId);
+        config.setPropertyValue(NameConstants.JCR_VERSIONHISTORY, historyId);
+        config.setPropertyValue(NameConstants.JCR_ISCHECKEDOUT, InternalValue.create(true));
+        config.setPropertyValues(NameConstants.JCR_PREDECESSORS, PropertyType.REFERENCE, new InternalValue[]{versionId});
+        configParent.store();
+
+        return configId;
+    }
+
+    /**

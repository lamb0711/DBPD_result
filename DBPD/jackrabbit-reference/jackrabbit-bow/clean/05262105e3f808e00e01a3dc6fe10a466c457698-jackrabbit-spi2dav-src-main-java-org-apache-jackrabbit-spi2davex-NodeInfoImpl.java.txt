JCR-2625: spi2davex: reduce memory footprint of Node/PropertyInfoImpl

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@945164 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.LinkedHashSet;
-import java.util.Set;
-import org.apache.jackrabbit.spi.PropertyInfo;
+    // data deduced from property values
-    private String uniqueID;
-    private final Set<PropertyInfo> propertyInfos = new LinkedHashSet<PropertyInfo>();
-    private Set<ChildInfo> childInfos = null;
+    private final List<PropertyId> propertyIds = new ArrayList<PropertyId>(8);
+    private List<ChildInfo> childInfos = null;
-        List<PropertyId> l = new ArrayList<PropertyId>();
-        for (PropertyInfo propertyInfo : propertyInfos) {
-            l.add(propertyInfo.getId());
-        }
-        return l.iterator();
+        return propertyIds.iterator();
-    void addPropertyInfo(PropertyInfoImpl propInfo, IdFactory idFactory) throws RepositoryException {
-        propertyInfos.add(propInfo);
-
-        Name pn = propInfo.getId().getName();
-        if (NameConstants.JCR_UUID.equals(pn)) {
-            uniqueID = propInfo.getValues()[0].getString();
-            id = idFactory.createNodeId(uniqueID);
-        } else if (NameConstants.JCR_PRIMARYTYPE.equals(pn)) {
-            primaryNodeTypeName = propInfo.getValues()[0].getName();
-        } else if (NameConstants.JCR_MIXINTYPES.equals(pn)) {
-            QValue[] vs = propInfo.getValues();
-            Name[] mixins = new Name[vs.length];
-            for (int i = 0; i < vs.length; i++) {
-                mixins[i] = vs[i].getName();
+    void setPropertyInfos(PropertyInfoImpl[] propInfos, IdFactory idFactory) throws RepositoryException {
+        boolean resolveUUID = false;
+        for (PropertyInfoImpl propInfo : propInfos) {
+            Name pn = propInfo.getId().getName();
+            if (NameConstants.JCR_UUID.equals(pn)) {
+                id = idFactory.createNodeId(propInfo.getValues()[0].getString());
+                resolveUUID = true;
+            } else if (NameConstants.JCR_PRIMARYTYPE.equals(pn)) {
+                primaryNodeTypeName = propInfo.getValues()[0].getName();
+            } else if (NameConstants.JCR_MIXINTYPES.equals(pn)) {
+                QValue[] vs = propInfo.getValues();
+                Name[] mixins = new Name[vs.length];
+                for (int i = 0; i < vs.length; i++) {
+                    mixins[i] = vs[i].getName();
+                }
+                mixinNodeTypeNames = mixins;
-            mixinNodeTypeNames = mixins;
-    }
-    void resolveUUID(IdFactory idFactory) {
-        if (uniqueID != null) {
-            for (Object o : propertyInfos) {
-                PropertyInfoImpl propInfo = (PropertyInfoImpl) o;
+        propertyIds.clear();
+        for (PropertyInfoImpl propInfo : propInfos) {
+            if (resolveUUID) {
+            propertyIds.add(propInfo.getId());
+
-            childInfos = new LinkedHashSet<ChildInfo>();
+            childInfos = new ArrayList<ChildInfo>();
-    void setNumberOfChildNodes(long numberOfChildNodes) {
-        if (numberOfChildNodes == 0) {
-            childInfos = Collections.<ChildInfo>emptySet();
-        } // else: wait for calls to #addChildInfo
+    void markAsLeafNode() {
+        childInfos = Collections.emptyList();
-        return !(id == null || primaryNodeTypeName == null || propertyInfos.isEmpty());
-    }
-
-    void checkCompleted() throws RepositoryException {
-        if (!isCompleted()) {
-            throw new RepositoryException("Incomplete NodeInfo");
-        }
+        return (id != null && primaryNodeTypeName != null && !propertyIds.isEmpty());
-        return uniqueID;
+        if (id.getUniqueID() != null && id.getPath() == null) {
+            return id.getUniqueID();
+        } else {
+            return null;
+        }

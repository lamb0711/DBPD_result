Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.webdav.lock.ActiveLock;
+import org.apache.jackrabbit.name.MalformedPathException;
-    private static boolean isLockMethod(DavMethod method) {
+    private static boolean isUnLockMethod(DavMethod method) {
-        return DavMethods.DAV_LOCK == code || DavMethods.DAV_UNLOCK == code;
+        return DavMethods.DAV_UNLOCK == code;
-            initMethod(method, sessionInfo, !isLockMethod(method));
+            initMethod(method, sessionInfo, !isUnLockMethod(method));
+        nameSet.add(ItemResourceConstants.JCR_PATH);
+            Object type = propSet.get(DavPropertyName.RESOURCETYPE).getValue();
+            if (type == null) {
+                // the given id points to a Property instead of a Node
+                throw new ItemNotFoundException("No node for id " + nodeId);
+            }
+
+        } catch (MalformedPathException e) {
+            throw new RepositoryException(e);
+        nameSet.add(ItemResourceConstants.JCR_PATH);
+        nameSet.add(ItemResourceConstants.JCR_PATH);
-
+        } catch (MalformedPathException e) {
+            throw new RepositoryException(e);
+        nameSet.add(ItemResourceConstants.JCR_PARENT);
-                return new LockInfoImpl(LockDiscovery.createFromXml(p.toXml(domFactory)), nodeId);
-            } else {
+                LockDiscovery ld = LockDiscovery.createFromXml(p.toXml(domFactory));
+                NodeId parentId = getParentId(ps, sessionInfo);
+                return retrieveLockInfo(ld, sessionInfo, nodeId, parentId);
+            }  else {
-
-            return new LockInfoImpl(disc, nodeId);
+            return retrieveLockInfo(disc, sessionInfo, nodeId, null);
+    private LockInfo retrieveLockInfo(LockDiscovery lockDiscovery, SessionInfo sessionInfo,
+                                      NodeId nodeId, NodeId parentId)
+        throws LockException, RepositoryException {
+        List activeLocks = (List) lockDiscovery.getValue();
+        Iterator it = activeLocks.iterator();
+        ActiveLock activeLock = null;
+        while (it.hasNext()) {
+            ActiveLock l = (ActiveLock) it.next();
+            Scope sc = l.getScope();
+            if (l.getType() == Type.WRITE && (sc == Scope.EXCLUSIVE || sc == ItemResourceConstants.EXCLUSIVE_SESSION)) {
+                if (activeLock != null) {
+                    throw new RepositoryException("Node " + nodeId + " contains multiple exclusive write locks.");
+                } else {
+                    activeLock = l;
+                }
+            }
+        }
+        if (activeLock == null) {
+            throw new LockException("No lock present on node " + nodeId);
+        }
+        if (activeLock.isDeep() && parentId != null) {
+            // try if lock is inherited
+            try {
+                return getLockInfo(sessionInfo, parentId);
+            } catch (LockException e) {
+                // no lock on parent
+                return new LockInfoImpl(activeLock, nodeId);
+            }
+        }
+        // no deep lock or parentID == null or lock is not present on parent
+        // -> nodeID is lockHolding Id.
+        return new LockInfoImpl(activeLock, nodeId);
+    }
+

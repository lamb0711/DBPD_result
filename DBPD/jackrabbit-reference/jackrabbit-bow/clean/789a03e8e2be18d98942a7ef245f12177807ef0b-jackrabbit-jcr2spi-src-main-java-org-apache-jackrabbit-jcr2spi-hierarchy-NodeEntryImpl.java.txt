JCR-2050: Optimize refresh operations

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@771280 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.jcr.InvalidItemStateException;
+import javax.jcr.ItemExistsException;
+import javax.jcr.ItemNotFoundException;
+import javax.jcr.PathNotFoundException;
+import javax.jcr.RepositoryException;
+
-import javax.jcr.InvalidItemStateException;
-import javax.jcr.ItemExistsException;
-import javax.jcr.ItemNotFoundException;
-import javax.jcr.PathNotFoundException;
-import javax.jcr.RepositoryException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
+     * Information regarding the invalidation status of the underyling {@link ItemState}
+     * of this entry. The semantics depend on the {@link EntryFactory.InvalidationStrategy}.
+     */
+    private long invalidationStatus;
+
+    /**
-    /**
-     * @inheritDoc
-     * @see HierarchyEntry#invalidate(boolean)
-     */
-        if (recursive) {
-            // invalidate all child entries including properties present in the
-            // attic (removed props shadowed by a new property with the same name).
-            for (Iterator it = getAllChildEntries(true); it.hasNext();) {
-                HierarchyEntry ce = (HierarchyEntry) it.next();
-                ce.invalidate(recursive);
-            }
-        }
-        // invalidate 'childNodeEntries'
-        if (getStatus() != Status.NEW) {
-            childNodeEntries.invalidate();
-        }
-        // ... and invalidate the resolved state (if available)
-        super.invalidate(recursive);
+        getInvalidationStrategy().invalidate(this, recursive);
+    }
+
+    public void calculateStatus() {
+        getInvalidationStrategy().applyPending(this);
-     * decendants are reloaded.
+     * descendants are reloaded.
-            // recursivly reload all entries including props that are in the attic.
+            // recursively reload all entries including props that are in the attic.
-        IdFactory idFactory = factory.getIdFactory();
+        IdFactory idFactory = getIdFactory();
-            PathFactory pf = factory.getPathFactory();
+            PathFactory pf = getPathFactory();
-        IdFactory idFactory = factory.getIdFactory();
-            PathFactory pf = factory.getPathFactory();
-            NodeId parentId = (revertInfo != null) ? revertInfo.oldParent.getWorkspaceId() : parent.getWorkspaceId();
-            return idFactory.createNodeId(parentId, pf.create(getName(true), getIndex(true)));
+            NodeId parentId = (revertInfo != null)
+                ? revertInfo.oldParent.getWorkspaceId()
+                : parent.getWorkspaceId();
+            return getIdFactory().createNodeId(parentId,
+                    getPathFactory().create(getName(true), getIndex(true)));
-            Path.Element elem = (Path.Element) elems[i];
+            Path.Element elem = elems[i];
-                PathBuilder pb = new PathBuilder(factory.getPathFactory());
+                PathBuilder pb = new PathBuilder(getPathFactory());
-            Path.Element elem = (Path.Element) elems[i];
+            Path.Element elem = elems[i];
-            PathBuilder pb = new PathBuilder(factory.getPathFactory());
+            PathBuilder pb = new PathBuilder(getPathFactory());
-            IdFactory idFactory = factory.getIdFactory();
+            IdFactory idFactory = getIdFactory();
-            PathFactory pf = factory.getPathFactory();
-            NodeId cId = factory.getIdFactory().createNodeId(getWorkspaceId(), pf.create(nodeName, index));
+
+            NodeId cId = getIdFactory().createNodeId(getWorkspaceId(),
+                    getPathFactory().create(nodeName, index));
-        NodeState state = factory.getItemStateFactory().createNewNodeState(entry, primaryNodeType, definition);
+        NodeState state = getItemStateFactory().createNewNodeState(entry, primaryNodeType, definition);
-        // add the property entry
-        PropertyState state = factory.getItemStateFactory().createNewPropertyState(entry, definition, values, propertyType);
+        PropertyState state = getItemStateFactory().createNewPropertyState(entry, definition, values, propertyType);
-        return factory.getItemStateFactory().createNodeState(getWorkspaceId(), this);
+        return getItemStateFactory().createNodeState(getWorkspaceId(), this);
-        PathFactory pf = factory.getPathFactory();
+        PathFactory pf = getPathFactory();
+    private EntryFactory.InvalidationStrategy getInvalidationStrategy() {
+        return factory.getInvalidationStrategy();
+    }
+
+    /**
+     * Invalidates the underlying {@link ItemState}. If <code>recursive</code> is
+     * true also invalidates the underlying item states of all child entries.
+     * @param recursive
+     */
+    private void invalidateInternal(boolean recursive) {
+        if (recursive) {
+            // invalidate all child entries including properties present in the
+            // attic (removed props shadowed by a new property with the same name).
+            for (Iterator it = getAllChildEntries(true); it.hasNext();) {
+                HierarchyEntry ce = (HierarchyEntry) it.next();
+                ce.invalidate(true);
+            }
+        }
+        super.invalidate(true);
+    }
+
-            NodeState state = factory.getItemStateFactory().createDeepNodeState(childId, this);
+            NodeState state = getItemStateFactory().createDeepNodeState(childId, this);
-            PropertyState state = factory.getItemStateFactory().createDeepPropertyState(childId, this);
+            PropertyState state = getItemStateFactory().createDeepPropertyState(childId, this);
+                break;
+
+    // ----------------------------------------------< InvalidationStrategy >---
+    /**
+     * An implementation of <code>InvalidationStrategy</code> which lazily invalidates
+     * the underlying {@link ItemState}s.
+     */
+    static class LazyInvalidation implements EntryFactory.InvalidationStrategy {
+
+        /**
+         * Marker for entries with a pending recursive invalidation.
+         */
+        private static long INVALIDATION_PENDING = -1;
+
+        /**
+         * Time stamp of the last time a recursive invalidation occurred.
+         */
+        private long lastInvalidation;
+
+        /**
+         * A recursive invalidation is being processed if <code>true</code>.
+         * This flag is for preventing re-entrance.
+         */
+        private boolean invalidating;
+
+        /**
+         * Actual time stamp
+         */
+        private long timeStamp;
+
+        /**
+         * @return  time stamp used to mark entries
+         */
+        private long getTimeStamp() {
+            return timeStamp++;
+        }
+
+        /**
+         * Records a pending recursive {@link ItemState#invalidate() invalidation} for
+         * <code>entry</code> if <code>recursive</code> is <code>true</code>. Otherwise
+         * invalidates the entry right away.
+         * {@inheritDoc}
+         */
+        public void invalidate(NodeEntry entry, boolean recursive) {
+            if (recursive) {
+                ((NodeEntryImpl)entry).invalidationStatus = INVALIDATION_PENDING;
+                if (!invalidating) {
+                    lastInvalidation = getTimeStamp();
+                }
+            } else {
+                ((NodeEntryImpl)entry).invalidateInternal(false);
+            }
+        }
+
+        /**
+         * Checks whether <code>entry</code> itself has a invalidation pending.
+         * If so, the <code>entry</code> is invalidated. Otherwise check
+         * whether an invalidation occurred after the entry has last been
+         * invalidated. If so, search the path to the root for an originator of
+         * the pending invalidation.
+         * If such an originator is found, invalidate each entry on the path.
+         * Otherwise this method does nothing.
+         * {@inheritDoc}
+         */
+        public void applyPending(NodeEntry entry) {
+            if (!invalidating) {
+                invalidating = true;
+                try {
+                    NodeEntryImpl ne = (NodeEntryImpl) entry;
+                    if (ne.invalidationStatus == INVALIDATION_PENDING) {
+                        ne.invalidateInternal(true);
+                        ne.invalidationStatus = getTimeStamp();
+                    } else if (ne.invalidationStatus <= lastInvalidation) {
+                        resolvePendingInvalidation(ne);
+                    }
+                } finally {
+                    invalidating = false;
+                }
+            }
+        }
+
+        /**
+         * Search the path to the root for an originator of a pending invalidation of
+         * this <code>entry</code>. If such an originator is found, invalidate each
+         * entry on the path. Otherwise do nothing.
+         *
+         * @param entry
+         */
+        private void resolvePendingInvalidation(NodeEntryImpl entry) {
+            if (entry != null) {
+
+                // First recursively travel up to the first parent node
+                // which has invalidation pending or to the root node if
+                // no such node exists.
+                if (entry.invalidationStatus != INVALIDATION_PENDING) {
+                    resolvePendingInvalidation(entry.parent);
+                }
+
+                // Then travel the path backwards invalidating as required
+                if (entry.invalidationStatus == INVALIDATION_PENDING) {
+                    entry.invalidateInternal(true);
+                }
+                entry.invalidationStatus = getTimeStamp();
+            }
+        }
+    }
+
+    /**
+     * An implementation of <code>InvalidationStrategy</code> which eagerly invalidates
+     * the underlying {@link ItemState}s.
+     */
+    static class EagerInvalidation implements EntryFactory.InvalidationStrategy {
+
+        /**
+         * Calls {@link ItemState#invalidate()} for the underlying item state of this
+         * <code>entry</code> and - if <code>recursive</code> is <code>true</code> -
+         * recursively for all item states of all child entries
+         * {@inheritDoc}
+         */
+        public void invalidate(NodeEntry entry, boolean recursive) {
+            ((NodeEntryImpl) entry).invalidateInternal(recursive);
+        }
+
+        /**
+         * Does nothing since invalidation has occurred already.
+         * {@inheritDoc}
+         */
+        public void applyPending(NodeEntry entry) {
+            // Empty
+        }
+    }

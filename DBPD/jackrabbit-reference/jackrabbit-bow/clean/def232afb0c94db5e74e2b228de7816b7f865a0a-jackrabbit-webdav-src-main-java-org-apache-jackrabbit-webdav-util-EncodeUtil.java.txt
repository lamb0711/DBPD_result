JCR-4238: use StandardCharsets to avoid having to handle UnsupportedEncodingException

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1819271 13f79535-47bb-0310-9956-ffa450edef68

+import java.nio.charset.StandardCharsets;
-        try {
-            BitSet validChars = isPath ? URISaveEx : URISave;
-            byte[] bytes = string.getBytes("utf-8");
-            StringBuffer out = new StringBuffer(bytes.length);
-            for (byte aByte : bytes) {
-                int c = aByte & 0xff;
-                if (validChars.get(c) && c != escape) {
-                    out.append((char) c);
-                } else {
-                    out.append(escape);
-                    out.append(hexTable[(c >> 4) & 0x0f]);
-                    out.append(hexTable[(c) & 0x0f]);
-                }
+        BitSet validChars = isPath ? URISaveEx : URISave;
+        byte[] bytes = string.getBytes(StandardCharsets.UTF_8);
+        StringBuffer out = new StringBuffer(bytes.length);
+        for (byte aByte : bytes) {
+            int c = aByte & 0xff;
+            if (validChars.get(c) && c != escape) {
+                out.append((char) c);
+            } else {
+                out.append(escape);
+                out.append(hexTable[(c >> 4) & 0x0f]);
+                out.append(hexTable[(c) & 0x0f]);
-            return out.toString();
-        } catch (UnsupportedEncodingException e) {
-            throw new InternalError(e.toString());
+        return out.toString();
-        try {
-            byte[] utf8 = string.getBytes("utf-8");
+        byte[] utf8 = string.getBytes(StandardCharsets.UTF_8);
-            // Check whether escape occurs at invalid position
-            if ((utf8.length >= 1 && utf8[utf8.length - 1] == escape) ||
-                (utf8.length >= 2 && utf8[utf8.length - 2] == escape)) {
-                throw new IllegalArgumentException("Premature end of escape sequence at end of input");
-            }
-
-            ByteArrayOutputStream out = new ByteArrayOutputStream(utf8.length);
-            for (int k = 0; k < utf8.length; k++) {
-                byte b = utf8[k];
-                if (b == escape) {
-                    out.write((decodeDigit(utf8[++k]) << 4) + decodeDigit(utf8[++k]));
-                }
-                else {
-                    out.write(b);
-                }
-            }
-
-            return new String(out.toByteArray(), "utf-8");
+        // Check whether escape occurs at invalid position
+        if ((utf8.length >= 1 && utf8[utf8.length - 1] == escape) ||
+            (utf8.length >= 2 && utf8[utf8.length - 2] == escape)) {
+            throw new IllegalArgumentException("Premature end of escape sequence at end of input");
-        catch (UnsupportedEncodingException e) {
-            throw new InternalError(e.toString());
+
+        ByteArrayOutputStream out = new ByteArrayOutputStream(utf8.length);
+        for (int k = 0; k < utf8.length; k++) {
+            byte b = utf8[k];
+            if (b == escape) {
+                out.write((decodeDigit(utf8[++k]) << 4) + decodeDigit(utf8[++k]));
+            }
+            else {
+                out.write(b);
+            }
+
+        return new String(out.toByteArray(), StandardCharsets.UTF_8);

OAK-77 : Consolidate Utilities (WIP)

- move ItemNameMatcher to jackrabbit-jcr-commons

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1333420 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.commons.ItemNameMatcher;
-import java.util.StringTokenizer;
+    @Override
+    @Override
-     * Matches the name pattern against the specified name.
-     * <p/>
-     * The pattern may be a full name or a partial name with one or more
-     * wildcard characters ("*"), or a disjunction (using the "|" character
-     * to represent logical <i>OR</i>) of these. For example,
-     * <p/>
-     * <code>"jcr:*|foo:bar"</code>
-     * <p/>
-     * would match
-     * <p/>
-     * <code>"foo:bar"</code>, but also <code>"jcr:whatever"</code>.
-     * <p/>
-     * <pre>
-     * The EBNF for pattern is:
+     * Same as {@link ItemNameMatcher#matches(String, String)}.
-     * namePattern ::= disjunct {'|' disjunct}
-     * disjunct ::= name [':' name]
-     * name ::= '*' |
-     *          ['*'] fragment {'*' fragment}['*']
-     * fragment ::= char {char}
-     * char ::= nonspace | ' '
-     * nonspace ::= (* Any Unicode character except:
-     *               '/', ':', '[', ']', '*',
-     *               ''', '"', '|' or any whitespace
-     *               character *)
-     * </pre>
-     * Note that leading and trailing whitespace around a pattern <i>is</i> ignored.
-     *
-     * @param name the name to test the pattern with
-     * @param pattern the pattern to be matched against the name
-     * @return true if the specified name matches the pattern
-        // split pattern
-        StringTokenizer st = new StringTokenizer(pattern, OR, false);
-        while (st.hasMoreTokens()) {
-            // remove leading & trailing whitespace from token
-            String token = st.nextToken().trim();
-            if (internalMatches(name, token, 0, 0)) {
-                return true;
-            }
-        }
-        return false;
+        return ItemNameMatcher.matches(name, pattern);
-     * Matches the <code>nameGlob</code> strings in the passed array against
-     * the specified name.
-     * <p>
-     * A glob may be a full name or a partial name with one or more
-     * wildcard characters ("<code>*</code>").
-     * <p>
-     * Note that unlike in the case of the {@link #matches(String, String)}
-     * leading and trailing whitespace around a glob is <i>not</i> ignored.
+     * Same as {@link ItemNameMatcher#matches(String, String)}.
-     * @param name the name to test the pattern with
-     * @param nameGlobs an array of globbing strings
-     * @return true if the specified name matches any of the globs
-     * @see javax.jcr.Node#getNodes(String[])
+     * @see javax.jcr.Node#getNodes(String)
-        for (int i = 0; i < nameGlobs.length; i++) {
-            // use globbing string as-is, i.e. don't trim any leading/trailing
-            // whitespace
-            if (internalMatches(name, nameGlobs[i], 0, 0)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Internal helper used to recursively match the pattern
-     *
-     * @param s       The string to be tested
-     * @param pattern The pattern
-     * @param sOff    offset within <code>s</code>
-     * @param pOff    offset within <code>pattern</code>.
-     * @return true if <code>s</code> matched pattern, else false.
-     */
-    private static boolean internalMatches(String s, String pattern,
-                                           int sOff, int pOff) {
-        int pLen = pattern.length();
-        int sLen = s.length();
-
-        while (true) {
-            if (pOff >= pLen) {
-                if (sOff >= sLen) {
-                    return true;
-                } else if (s.charAt(sOff) == '[') {
-                    // check for subscript notation (e.g. "whatever[1]")
-
-                    // the entire pattern matched up to the subscript:
-                    // -> ignore the subscript
-                    return true;
-                } else {
-                    return false;
-                }
-            }
-            if (sOff >= sLen && pattern.charAt(pOff) != WILDCARD_CHAR) {
-                return false;
-            }
-
-            // check for a '*' as the next pattern char;
-            // this is handled by a recursive call for
-            // each postfix of the name.
-            if (pattern.charAt(pOff) == WILDCARD_CHAR) {
-                if (++pOff >= pLen) {
-                    return true;
-                }
-
-                while (true) {
-                    if (internalMatches(s, pattern, sOff, pOff)) {
-                        return true;
-                    }
-                    if (sOff >= sLen) {
-                        return false;
-                    }
-                    sOff++;
-                }
-            }
-
-            if (pOff < pLen && sOff < sLen) {
-                if (pattern.charAt(pOff) != s.charAt(sOff)) {
-                    return false;
-                }
-            }
-            pOff++;
-            sOff++;
-        }
+        return ItemNameMatcher.matches(name, nameGlobs);

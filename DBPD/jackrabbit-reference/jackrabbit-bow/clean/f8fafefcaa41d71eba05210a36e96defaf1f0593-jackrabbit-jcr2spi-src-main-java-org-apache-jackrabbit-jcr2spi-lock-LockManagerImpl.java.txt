JCR-2104: JSR 283 Versioning
   - VersionHistory.getAllFrozenNodes()  (move iteratoradaptor from core to jcr-commons), VersionHistory.getVersionableIdentifier()
   - Version.getFrozenNode, Version.getLinearPredecessor()
   - VersionManager (work in progress): 170-methods, shallow merge, checkpoint
      -> extend SPI interfaces accordingly

JCR-2003: JCR2SPI / SPI: Add support for JCR 2.0
   - Session.hasPermission()
   - Node.getProperties/getNodes with glob
   - Node.getIdentifier()

JCR-2004: Update SPI locking to match JCR 2.0
   - separate JCR LockManager from the internal lock manager

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@773828 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.NodeImpl;
-    private final PathResolver resolver;
-                           CacheBehaviour cacheBehaviour, PathResolver pathResolver) {
+                           CacheBehaviour cacheBehaviour) {
-        this.resolver = pathResolver;
-    //--------------------------------------------------------< LockManager >---
-    /**
-     * @see javax.jcr.lock.LockManager#getLock(String)
-     */
-    public javax.jcr.lock.Lock getLock(String absPath) throws LockException, RepositoryException {
-        Node n = itemManager.getNode(resolver.getQPath(absPath));
-        return (javax.jcr.lock.Lock) n.getLock();
-    }
-
-    /**
-     * @see javax.jcr.lock.LockManager#isLocked(String)
-     */
-    public boolean isLocked(String absPath) throws RepositoryException {
-        Node n = itemManager.getNode(resolver.getQPath(absPath));
-        return n.isLocked();
-    }
-
-    /**
-     * @see javax.jcr.lock.LockManager#holdsLock(String)
-     */
-    public boolean holdsLock(String absPath) throws RepositoryException {
-        Node n = itemManager.getNode(resolver.getQPath(absPath));
-        return n.holdsLock();
-    }
-
-    /**
-     * @see javax.jcr.lock.LockManager#lock(String, boolean, boolean, long, String)
-     */
-    public javax.jcr.lock.Lock lock(String absPath, boolean isDeep, boolean isSessionScoped, long timeoutHint, String ownerInfo) throws RepositoryException {
-        Node n = itemManager.getNode(resolver.getQPath(absPath));
-        return (javax.jcr.lock.Lock) ((NodeImpl) n).lock(isDeep, isSessionScoped, timeoutHint, ownerInfo);
-    }
-
-    /**
-     * @see javax.jcr.lock.LockManager#unlock(String) 
-     */
-    public void unlock(String absPath) throws LockException, RepositoryException {
-        Node n = itemManager.getNode(resolver.getQPath(absPath));
-        n.unlock();
-    }
-
-    /**
-     * Returns the lock tokens present on the <code>SessionInfo</code> this
-     * manager has been created with.
-     *
-     * @see javax.jcr.lock.LockManager#getLockTokens()
-     */
-    public String[] getLockTokens() {
-        return wspManager.getLockTokens();
-    }
-
-    /**
-     * Delegates this call to {@link WorkspaceManager#addLockToken(String)}.
-     * If this succeeds this method will inform all locks stored in the local
-     * map in order to give them the chance to update their lock information.
-     *
-     * @see javax.jcr.lock.LockManager#addLockToken(String)
-     */
-    public void addLockToken(String lt) throws LockException, RepositoryException {
-        wspManager.addLockToken(lt);
-        notifyTokenAdded(lt);
-    }
-
-    /**
-     * If the lock addressed by the token is session-scoped, this method will
-     * throw a LockException, such as defined by JSR170 v.1.0.1 for
-     * {@link Session#removeLockToken(String)}.<br>Otherwise the call is
-     * delegated to {@link WorkspaceManager#removeLockToken(String)}.
-     * All locks stored in the local lock map are notified by the removed
-     * token in order have them updated their lock information.
-     *
-     * @see javax.jcr.lock.LockManager#removeLockToken(String)
-     */
-    public void removeLockToken(String lt) throws LockException, RepositoryException {
-        // JSR170 v. 1.0.1 defines that the token of a session-scoped lock may
-        // not be moved over to another session. thus removal ist not possible
-        // and the lock is always present in the lock map.
-        Iterator it = lockMap.values().iterator();
-        boolean found = false;
-        // loop over cached locks to determine if the token belongs to a session
-        // scoped lock, in which case the removal must fail immediately.
-        while (it.hasNext() && !found) {
-            LockImpl l = (LockImpl) it.next();
-            if (lt.equals(l.getLockToken())) {
-                // break as soon as the lock associated with the given token was found.
-                found = true;
-                if (l.isSessionScoped()) {
-                    throw new LockException("Cannot remove lock token associated with a session scoped lock.");
-                }
-            }
-        }
-
-        // remove lock token from sessionInfo. call will fail, if the session
-        // is not lock holder.
-        wspManager.removeLockToken(lt);
-        // inform about this lt being removed from this session
-        notifyTokenRemoved(lt);
-    }
-
+
+    /**
+     * Returns the lock tokens present on the <code>SessionInfo</code> this
+     * manager has been created with.
+     *
+     * @see LockStateManager#getLockTokens()
+     */
+    public String[] getLockTokens() {
+        return wspManager.getLockTokens();
+    }
+
+    /**
+     * Delegates this call to {@link WorkspaceManager#addLockToken(String)}.
+     * If this succeeds this method will inform all locks stored in the local
+     * map in order to give them the chance to update their lock information.
+     *
+     * @see LockStateManager#addLockToken(String)
+     */
+    public void addLockToken(String lt) throws LockException, RepositoryException {
+        wspManager.addLockToken(lt);
+        notifyTokenAdded(lt);
+    }
+
+    /**
+     * If the lock addressed by the token is session-scoped, this method will
+     * throw a LockException, such as defined by JSR170 v.1.0.1 for
+     * {@link Session#removeLockToken(String)}.<br>Otherwise the call is
+     * delegated to {@link WorkspaceManager#removeLockToken(String)}.
+     * All locks stored in the local lock map are notified by the removed
+     * token in order have them updated their lock information.
+     *
+     * @see LockStateManager#removeLockToken(String)
+     */
+    public void removeLockToken(String lt) throws LockException, RepositoryException {
+        // JSR170 v. 1.0.1 defines that the token of a session-scoped lock may
+        // not be moved over to another session. thus removal ist not possible
+        // and the lock is always present in the lock map.
+        Iterator it = lockMap.values().iterator();
+        boolean found = false;
+        // loop over cached locks to determine if the token belongs to a session
+        // scoped lock, in which case the removal must fail immediately.
+        while (it.hasNext() && !found) {
+            LockImpl l = (LockImpl) it.next();
+            if (lt.equals(l.getLockToken())) {
+                // break as soon as the lock associated with the given token was found.
+                found = true;
+                if (l.isSessionScoped()) {
+                    throw new LockException("Cannot remove lock token associated with a session scoped lock.");
+                }
+            }
+        }
+
+        // remove lock token from sessionInfo. call will fail, if the session
+        // is not lock holder.
+        wspManager.removeLockToken(lt);
+        // inform about this lt being removed from this session
+        notifyTokenRemoved(lt);
+    }
+

JCR-2579: InvalidItemStateException when attempting concurrent, non conflicting writes

The problem was caused by NodeState returning the underlying ChildNodeEntries as an unsynchronized List<> instance. I've refactored the code so that whenever a list of ChildNodeEntries is returned from NodeState, that list is independent of the internal mutable state of the NodeState instance.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@955307 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Iterator;
-        return childNodeEntries;
+        return childNodeEntries.list();
-            return childNodeEntries;
+            return childNodeEntries.list();
-            return Collections.emptyList();
-        }
-
-        ChildNodeEntries otherChildNodeEntries =
-                ((NodeState) overlayedState).childNodeEntries;
-
-        // do a lazy init
-        List<ChildNodeEntry> renamed = null;
-
-        for (Iterator<ChildNodeEntry> iter = childNodeEntries.iterator(); iter.hasNext();) {
-            ChildNodeEntry cne = iter.next();
-            ChildNodeEntry cneOther = otherChildNodeEntries.get(cne.getId());
-            if (cneOther != null && !cne.getName().equals(cneOther.getName())) {
-                // child node entry with same id but different name exists in
-                // overlayed and this state => renamed entry detected
-                if (renamed == null) {
-                    renamed = new ArrayList<ChildNodeEntry>();
-                }
-                renamed.add(cne);
-            }
-        }
-
-        if (renamed == null) {
-            return Collections.emptyList();
+            return childNodeEntries.getRenamedEntries(
+                    ((NodeState) overlayedState).childNodeEntries);
-            return renamed;
+            return Collections.emptyList();
-            ChildNodeEntry entry = (ChildNodeEntry) ours.get(i);
-            ChildNodeEntry other = (ChildNodeEntry) others.get(i);
+            ChildNodeEntry entry = ours.get(i);
+            ChildNodeEntry other = others.get(i);
-                    if (entry.getId().equals(((ChildNodeEntry) others.get(i + 1)).getId())) {
+                    if (entry.getId().equals(others.get(i + 1).getId())) {
-                            if (((ChildNodeEntry) ours.get(j)).getId().equals(other.getId())) {
+                            if (ours.get(j).getId().equals(other.getId())) {
-                    if (((ChildNodeEntry) ours.get(j)).getId().equals(entry.getId())) {
+                    if (ours.get(j).getId().equals(entry.getId())) {
-                    if (((ChildNodeEntry) others.get(j)).getId().equals(entry.getId())) {
+                    if (others.get(j).getId().equals(entry.getId())) {

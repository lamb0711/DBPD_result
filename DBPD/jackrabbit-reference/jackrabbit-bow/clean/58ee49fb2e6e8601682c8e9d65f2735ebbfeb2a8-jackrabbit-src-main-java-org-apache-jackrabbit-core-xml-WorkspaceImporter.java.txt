JCR-569: Added a few new methods in WorkspaceImporter to reduce duplication and to simplify too large/deep methods.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@477142 13f79535-47bb-0310-9956-ffa450edef68

+import javax.jcr.version.Version;
+    private final SessionImpl session;
+    private final VersionManager versionManager;
+        this.wsp = wsp;
+        this.session = (SessionImpl) wsp.getSession();
+        this.versionManager = session.getVersionManager();
+        this.ntReg = ntReg;
+        this.uuidBehavior = uuidBehavior;
-        SessionImpl ses = (SessionImpl) wsp.getSession();
-        itemOps = new BatchedItemOperations(wsp.getItemStateManager(),
-                ntReg, ses.getLockManager(), ses, wsp.getHierarchyManager(),
-                ses.getNamespaceResolver());
+        itemOps = new BatchedItemOperations(
+                wsp.getItemStateManager(), ntReg, session.getLockManager(),
+                session, wsp.getHierarchyManager(), session.getNamespaceResolver());
-        this.wsp = wsp;
-        this.ntReg = ntReg;
-        this.uuidBehavior = uuidBehavior;
-
-            PropDef def;
-            PropertyState prop;
-            SessionImpl session = (SessionImpl) wsp.getSession();
-            VersionManager vMgr = session.getVersionManager();
-            VersionHistory vh = vMgr.getVersionHistory(session, node);
-            if (vh == null) {
-                vh = vMgr.createVersionHistory(session, node);
+            VersionHistory history = versionManager.getVersionHistory(session, node);
+            if (history == null) {
+                history = versionManager.createVersionHistory(session, node);
+            Version rootVersion = history.getRootVersion();
-            if (!node.hasPropertyName(QName.JCR_VERSIONHISTORY)) {
-                def = itemOps.findApplicablePropertyDefinition(QName.JCR_VERSIONHISTORY,
-                        PropertyType.REFERENCE, false, node);
-                prop = itemOps.createPropertyState(node, QName.JCR_VERSIONHISTORY,
-                        PropertyType.REFERENCE, def);
-                prop.setValues(new InternalValue[]{InternalValue.create(new UUID(vh.getUUID()))});
-            }
+            conditionalAddProperty(
+                    node, QName.JCR_VERSIONHISTORY, PropertyType.REFERENCE, false,
+                    InternalValue.create(new UUID(history.getUUID())));
-            if (!node.hasPropertyName(QName.JCR_BASEVERSION)) {
-                def = itemOps.findApplicablePropertyDefinition(QName.JCR_BASEVERSION,
-                        PropertyType.REFERENCE, false, node);
-                prop = itemOps.createPropertyState(node, QName.JCR_BASEVERSION,
-                        PropertyType.REFERENCE, def);
-                prop.setValues(new InternalValue[]{InternalValue.create(new UUID(vh.getRootVersion().getUUID()))});
-            }
+            conditionalAddProperty(
+                    node, QName.JCR_BASEVERSION, PropertyType.REFERENCE, false,
+                    InternalValue.create(new UUID(rootVersion.getUUID())));
-            if (!node.hasPropertyName(QName.JCR_PREDECESSORS)) {
-                def = itemOps.findApplicablePropertyDefinition(QName.JCR_PREDECESSORS,
-                        PropertyType.REFERENCE, true, node);
-                prop = itemOps.createPropertyState(node, QName.JCR_PREDECESSORS,
-                        PropertyType.REFERENCE, def);
-                prop.setValues(new InternalValue[]{InternalValue.create(new UUID(vh.getRootVersion().getUUID()))});
-            }
+            conditionalAddProperty(
+                    node, QName.JCR_PREDECESSORS, PropertyType.REFERENCE, true,
+                    InternalValue.create(new UUID(rootVersion.getUUID())));
-            if (!node.hasPropertyName(QName.JCR_ISCHECKEDOUT)) {
-                def = itemOps.findApplicablePropertyDefinition(QName.JCR_ISCHECKEDOUT,
-                        PropertyType.BOOLEAN, false, node);
-                prop = itemOps.createPropertyState(node, QName.JCR_ISCHECKEDOUT,
-                        PropertyType.BOOLEAN, def);
-                prop.setValues(new InternalValue[]{InternalValue.create(true)});
-            }
+            conditionalAddProperty(
+                    node, QName.JCR_ISCHECKEDOUT, PropertyType.BOOLEAN, false,
+                    InternalValue.create(true));
+        }
+    }
+
+    /**
+     * Adds the the given property to a node unless the property already
+     * exists.
+     *
+     * @param node the node to which the property is added
+     * @param name name of the property
+     * @param type property type (see {@link PropertyType})
+     * @param multiple whether the property is multivalued
+     * @param value initial value of the property, if it needs to be added
+     * @throws RepositoryException if the property could not be added
+     */
+    private void conditionalAddProperty(
+            NodeState node, QName name, int type, boolean multiple,
+            InternalValue value)
+            throws RepositoryException {
+        if (!node.hasPropertyName(name)) {
+            PropDef def = itemOps.findApplicablePropertyDefinition(
+                    name, type, multiple, node);
+            PropertyState prop = itemOps.createPropertyState(
+                    node, name, type, def);
+            prop.setValues(new InternalValue[] { value });
-
-                    NodeDef def =
-                            itemOps.findApplicableNodeDefinition(nodeName, ntName, parent);
+                    NodeDef def = itemOps.findApplicableNodeDefinition(
+                            nodeName, ntName, parent);
-                        /**
-                         * a property with the same name already exists; if this property
-                         * has been imported as well (e.g. through document view import
-                         * where an element can have the same name as one of the attributes
-                         * of its parent element) we have to rename the onflicting property;
-                         *
-                         * see http://issues.apache.org/jira/browse/JCR-61
-                         */
-                        PropertyId propId = new PropertyId(parent.getNodeId(), nodeName);
-                        PropertyState conflicting = itemOps.getPropertyState(propId);
-                        if (conflicting.getStatus() == ItemState.STATUS_NEW) {
-                            // assume this property has been imported as well;
-                            // rename conflicting property
-                            // @todo use better reversible escaping scheme to create unique name
-                            QName newName = new QName(nodeName.getNamespaceURI(), nodeName.getLocalName() + "_");
-                            if (parent.hasPropertyName(newName)) {
-                                newName = new QName(newName.getNamespaceURI(), newName.getLocalName() + "_");
-                            }
-                            PropertyState newProp =
-                                    itemOps.createPropertyState(parent, newName,
-                                            conflicting.getType(), conflicting.getValues().length);
-                            newProp.setValues(conflicting.getValues());
-                            parent.removePropertyName(nodeName);
-                            itemOps.store(parent);
-                            itemOps.destroy(conflicting);
-                        }
+                        resolvePropertyNameConflict(parent, nodeName);
-                    NodeState conflicting;
-
-                        conflicting = itemOps.getNodeState(id);
-                    } catch (ItemNotFoundException infe) {
-                        conflicting = null;
-                    }
-                    if (conflicting != null) {
+                        NodeState conflicting = itemOps.getNodeState(id);
-                    } else {
+                    } catch (ItemNotFoundException e) {
-
-                        NodeDef def =
-                                itemOps.findApplicableNodeDefinition(nodeName, ntName, parent);
+                        NodeDef def = itemOps.findApplicableNodeDefinition(
+                                nodeName, ntName, parent);
+     * Resolves a conflict where a property with the same name as a node
+     * being imported already exists; if this property has been imported
+     * as well (e.g. through document view import where an element can have
+     * the same name as one of the attributes of its parent element) we have
+     * to rename the onflicting property.
+     *
+     * @see http://issues.apache.org/jira/browse/JCR-61
+     * @param parent parent node
+     * @param name name of the node being imported
+     * @throws RepositoryException
+     */
+    private void resolvePropertyNameConflict(NodeState parent, QName name)
+            throws RepositoryException {
+        PropertyId propId = new PropertyId(parent.getNodeId(), name);
+        PropertyState conflicting = itemOps.getPropertyState(propId);
+        if (conflicting.getStatus() == ItemState.STATUS_NEW) {
+            // assume this property has been imported as well;
+            // rename conflicting property
+            // @todo use better reversible escaping scheme to create unique name
+            QName newName = new QName(name.getNamespaceURI(), name.getLocalName() + "_");
+            while (parent.hasPropertyName(newName)) {
+                newName = new QName(newName.getNamespaceURI(), newName.getLocalName() + "_");
+            }
+            InternalValue[] values = conflicting.getValues();
+            PropertyState newProp = itemOps.createPropertyState(
+                    parent, newName, conflicting.getType(), values.length);
+            newProp.setValues(values);
+            parent.removePropertyName(name);
+            itemOps.store(parent);
+            itemOps.destroy(conflicting);
+        }
+    }
+
+    /**
+

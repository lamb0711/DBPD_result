redesigned transaction support & PersistenceManager

orginal code contributed by dominique pfister, required a lot of tweaking to make it run & work; not thoroughly tested

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@126221 13f79535-47bb-0310-9956-ffa450edef68

-public class SessionItemStateManager implements ItemStateProvider {
+public class SessionItemStateManager implements ItemStateManager {
-    private final PersistentItemStateProvider persistentStateMgr;
+    private final ItemStateManager persistentStateMgr;
-    public SessionItemStateManager(String rootNodeUUID, PersistentItemStateProvider persistentStateMgr, NamespaceResolver nsResolver) {
+    public SessionItemStateManager(String rootNodeUUID,
+                                   ItemStateManager persistentStateMgr,
+                                   NamespaceResolver nsResolver) {
+
-        hierMgr = new HierarchyManagerImpl(rootNodeUUID, this, nsResolver);
+        hierMgr = new HierarchyManagerImpl(rootNodeUUID, this, nsResolver,
+                transientStateMgr.getAttic());
-    private synchronized void collectDescendantItemStates(ItemId id, List descendents) {
-        // XXX very inefficient implementation, especially if # of transient states
-        // is relatively small compared to the total # of persistent states
-        if (descendents.size() == transientStateMgr.getEntriesCount()) {
-            return;
-        }
-        try {
-            if (id.denotesNode()) {
-                NodeId parentId = (NodeId) id;
-                ItemId[] childIds = hierMgr.listChildren(parentId);
-                for (int i = 0; i < childIds.length; i++) {
-                    ItemId childId = childIds[i];
-                    if (transientStateMgr.hasItemState(childId)) {
-                        ItemState state = transientStateMgr.getItemState(childId);
-                        if (!descendents.contains(state)) {
-                            descendents.add(state);
-                        }
-                    }
-                    if (childId.denotesNode()) {
-                        // recurse
-                        collectDescendantItemStates(childId, descendents);
-                    }
-                }
-                // also add transient child nodes that have been unlinked from
-                // the specified parent node but are not orphaned yet (i.e.
-                // they are still linked to at least one other parent node)
-                if (transientStateMgr.hasItemState(parentId)) {
-                    NodeState parentState = (NodeState) transientStateMgr.getItemState(parentId);
-                    Iterator iter = parentState.getRemovedChildNodeEntries().iterator();
-                    while (iter.hasNext()) {
-                        // removed child nodes
-                        NodeState.ChildNodeEntry cne = (NodeState.ChildNodeEntry) iter.next();
-                        NodeId removedChildId = new NodeId(cne.getUUID());
-                        if (transientStateMgr.hasItemState(removedChildId)) {
-                            ItemState state = transientStateMgr.getItemState(removedChildId);
-                            if (!descendents.contains(state)) {
-                                descendents.add(state);
-                            }
-                        }
-                    }
-                }
-            }
-        } catch (ItemStateException ise) {
-            log.warn("inconsistent hierarchy state", ise);
-        } catch (RepositoryException re) {
-            log.warn("inconsistent hierarchy state", re);
-        }
-    }
-
-    private synchronized void collectDescendantItemStatesInAttic(ItemId id, List descendents) {
-        // XXX very inefficient implementation, especially if # of transient states
-        // is relatively small compared to the total # of persistent states
-        if (descendents.size() == transientStateMgr.getEntriesInAtticCount()) {
-            return;
-        }
-        try {
-            if (id.denotesNode()) {
-                NodeId parentId = (NodeId) id;
-
-                // traverse zombie children (i.e. children marked as removed)
-                ItemId[] childIds = hierMgr.listZombieChildren(parentId);
-                for (int i = 0; i < childIds.length; i++) {
-                    ItemId childId = childIds[i];
-                    // check attic
-                    if (transientStateMgr.hasItemStateInAttic(childId)) {
-                        // found on attic, add to descendents list
-                        ItemState state = transientStateMgr.getItemStateInAttic(childId);
-                        if (!descendents.contains(state)) {
-                            descendents.add(state);
-                        }
-                    }
-                    if (childId.denotesNode()) {
-                        // recurse
-                        collectDescendantItemStatesInAttic(childId, descendents);
-                    }
-                }
-
-                // traverse existing children (because they might have zombie children)
-                childIds = hierMgr.listChildren(parentId);
-                for (int i = 0; i < childIds.length; i++) {
-                    ItemId childId = childIds[i];
-                    if (childId.denotesNode()) {
-                        // recurse
-                        collectDescendantItemStatesInAttic(childId, descendents);
-                    }
-                }
-            }
-        } catch (ItemStateException ise) {
-            log.warn("inconsistent hierarchy state", ise);
-        } catch (RepositoryException re) {
-            log.warn("inconsistent hierarchy state", re);
-        }
-    }
-
-     * Dumps the state of this <code>TransientItemStateManager</code> instance
+     * Dumps the state of this <code>SessionItemStateManager</code> instance
-        //persistentStateMgr.dump(ps);
-        ps.println();
+        // FIXME hack!
+        if (persistentStateMgr instanceof ItemStateCache) {
+            ((ItemStateCache) persistentStateMgr).dump(ps);
+            ps.println();
+        }
-    //----------------------------------------------------< ItemStateProvider >
+    //-----------------------------------------------------< ItemStateManager >
-     * @see ItemStateProvider#getItemState(ItemId)
+     * @see ItemStateManager#getItemState(ItemId)
-        if (transientStateMgr.hasItemStateInAttic(id)) {
+        if (transientStateMgr.getAttic().hasItemState(id)) {
-     * @see ItemStateProvider#hasItemState(ItemId)
+     * @see ItemStateManager#hasItemState(ItemId)
-        if (transientStateMgr.hasItemStateInAttic(id)) {
+        if (transientStateMgr.getAttic().hasItemState(id)) {
+
-     * @see ItemStateProvider#getItemStateInAttic(ItemId)
+     * @see ItemStateManager#getNodeReferences
-    public ItemState getItemStateInAttic(ItemId id)
+    public NodeReferences getNodeReferences(NodeId targetId)
-        return transientStateMgr.getItemStateInAttic(id);
+
+        return persistentStateMgr.getNodeReferences(targetId);
-     * @see ItemStateProvider#hasItemStateInAttic(ItemId)
+     * @see ItemStateManager#beginUpdate
-    public boolean hasItemStateInAttic(ItemId id) {
-        return transientStateMgr.hasItemStateInAttic(id);
+    public UpdateOperation beginUpdate() throws ItemStateException {
+        return persistentStateMgr.beginUpdate();
+
-    //------------------< methods for creating persistent ItemState instances >
-    /**
-     * Creates a <code>PersistentNodeState</code> instance representing new,
-     * i.e. not yet existing state. Call <code>{@link PersistentNodeState#store()}</code>
-     * on the returned object to make it persistent.
-     *
-     * @param uuid
-     * @param nodeTypeName
-     * @param parentUUID
-     * @return
-     * @throws ItemStateException
-     */
-    public PersistentNodeState createPersistentNodeState(String uuid, QName nodeTypeName, String parentUUID)
-            throws ItemStateException {
-        return persistentStateMgr.createNodeState(uuid, nodeTypeName, parentUUID);
-    }
-
-    /**
-     * Creates a <code>PersistentPropertyState</code> instance representing new,
-     * i.e. not yet existing state. Call <code>{@link PersistentPropertyState#store()}</code>
-     * on the returned object to make it persistent.
-     *
-     * @param parentUUID
-     * @param propName
-     * @return
-     * @throws ItemStateException
-     */
-    public PersistentPropertyState createPersistentPropertyState(String parentUUID, QName propName)
-            throws ItemStateException {
-        return persistentStateMgr.createPropertyState(parentUUID, propName);
-    }
-

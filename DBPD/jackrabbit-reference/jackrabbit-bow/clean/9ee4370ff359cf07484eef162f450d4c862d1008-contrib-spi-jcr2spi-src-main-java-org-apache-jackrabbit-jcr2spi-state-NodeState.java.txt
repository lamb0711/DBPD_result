SPI
- replace ChildNodeEntryImpl with new implementations
- CachingItemStateManager now uses ItemStateFactory
- WorkspaceManager implements ItemStateFactory
- Retrieving an ItemState now forces loading all ancestors by design
- NodeState does not maintain indexes of child node entries anymore. They are calculated on demand.
- ItemStateFactory methods do not require parent NodeState anymore. The parent NodeState is retrieved using an ItemStateManager. Which in turn may lead to recursive retrieval of ancestors if necessary.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@426536 13f79535-47bb-0310-9956-ffa450edef68

-    private static class ChildNodeEntries implements List, Cloneable {
+    private class ChildNodeEntries implements List, Cloneable {
-            int index = Path.INDEX_UNDEFINED;
-                index = siblings.size();
-            index++;
-            ChildNodeEntry entry = new ChildNodeEntryImpl(nodeName, id, index);
+            ChildNodeEntry entry = createChildNodeEntry(nodeName, id);
-            // update indices of subsequent same-name siblings
-            for (int i = index - 1; i < siblings.size(); i++) {
-                ChildNodeEntry oldEntry = (ChildNodeEntry) siblings.get(i);
-                ChildNodeEntry newEntry = new ChildNodeEntryImpl(nodeName, oldEntry.getId(), oldEntry.getIndex() - 1);
-                // overwrite old entry with updated entry in siblings list
-                siblings.set(i, newEntry);
-                // overwrite old entry with updated entry in ordered entries map
-                entries.put(newEntry.getId(), newEntry);
-            }
-
+        /**
+         * Creates a <code>ChildNodeEntry</code> instance based on
+         * <code>nodeName</code>, <code>id</code> and <code>index</code>.
+         *
+         * @param nodeName the name of the child node.
+         * @param id the id of the child node.
+         * @return
+         */
+        private ChildNodeEntry createChildNodeEntry(QName nodeName, NodeId id) {
+            if (id.getRelativePath() != null) {
+                return new PathElementReference(NodeState.this, nodeName, NodeState.this.idFactory);
+            } else {
+                return new UUIDReference(NodeState.this, id, nodeName);
+            }
+        }
+

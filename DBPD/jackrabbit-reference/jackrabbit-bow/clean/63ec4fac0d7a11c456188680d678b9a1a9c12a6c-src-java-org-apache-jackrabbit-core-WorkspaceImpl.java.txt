redesigned transaction support & PersistenceManager

orginal code contributed by dominique pfister, required a lot of tweaking to make it run & work; not thoroughly tested

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@126221 13f79535-47bb-0310-9956-ffa450edef68

-    protected final PersistentItemStateProvider persistentStateMgr;
-
-    /**
-     * The reference mgr associated with the workspace represented by <i>this</i>
-     * <code>Workspace</code> instance.
-     */
-    protected final ReferenceManager refMgr;
+    protected final LocalItemStateManager stateMgr;
-     * @param persistentStateMgr
+     * @param stateMgr
-    WorkspaceImpl(WorkspaceConfig wspConfig, PersistentItemStateProvider persistentStateMgr,
-                  ReferenceManager refMgr, RepositoryImpl rep, SessionImpl session) {
+    WorkspaceImpl(WorkspaceConfig wspConfig, SharedItemStateManager stateMgr,
+                  RepositoryImpl rep, SessionImpl session) {
-        this.persistentStateMgr = persistentStateMgr;
-        this.refMgr = refMgr;
-        hierMgr = new HierarchyManagerImpl(rep.getRootNodeUUID(), persistentStateMgr, session.getNamespaceResolver());
+        this.stateMgr = new LocalItemStateManager(stateMgr);
+        this.hierMgr = new HierarchyManagerImpl(rep.getRootNodeUUID(),
+                this.stateMgr, session.getNamespaceResolver());
-    public PersistentItemStateProvider getPersistentStateManager() {
-        return persistentStateMgr;
-    }
-
-    ReferenceManager getReferenceManager() {
-        return refMgr;
+    public LocalItemStateManager getItemStateManager() {
+        return stateMgr;
-    protected static PersistentNodeState getNodeState(String nodePath,
-                                                      NamespaceResolver nsResolver,
-                                                      HierarchyManagerImpl hierMgr,
-                                                      PersistentItemStateProvider stateMgr)
+    protected static NodeState getNodeState(String nodePath,
+                                            NamespaceResolver nsResolver,
+                                            HierarchyManagerImpl hierMgr,
+                                            ItemStateManager stateMgr)
-    protected static PersistentNodeState getParentNodeState(String path,
-                                                            NamespaceResolver nsResolver,
-                                                            HierarchyManagerImpl hierMgr,
-                                                            PersistentItemStateProvider stateMgr)
+    protected static NodeState getParentNodeState(String path,
+                                                  NamespaceResolver nsResolver,
+                                                  HierarchyManagerImpl hierMgr,
+                                                  ItemStateManager stateMgr)
-    protected static PersistentNodeState getNodeState(Path nodePath,
-                                                      HierarchyManagerImpl hierMgr,
-                                                      PersistentItemStateProvider stateMgr)
+    protected static NodeState getNodeState(Path nodePath,
+                                            HierarchyManagerImpl hierMgr,
+                                            ItemStateManager stateMgr)
-    protected static PersistentNodeState getNodeState(NodeId id,
-                                                      PersistentItemStateProvider stateMgr)
+    protected static NodeState getNodeState(NodeId id,
+                                            ItemStateManager stateMgr)
-        return (PersistentNodeState) stateMgr.getItemState(id);
+        return (NodeState) stateMgr.getItemState(id);
-                                       PersistentItemStateProvider stateMgr)
+                                       ItemStateManager stateMgr)
-        PersistentNodeState parentState = getNodeState(parentPath, hierMgr, stateMgr);
+        NodeState parentState = getNodeState(parentPath, hierMgr, stateMgr);
-                                          PersistentItemStateProvider stateMgr)
+                                          ItemStateManager stateMgr)
-        PersistentNodeState targetState = getNodeState(nodePath, hierMgr, stateMgr);
+        NodeState targetState = getNodeState(nodePath, hierMgr, stateMgr);
-        PersistentNodeState parentState = getNodeState(parentPath, hierMgr, stateMgr);
+        NodeState parentState = getNodeState(parentPath, hierMgr, stateMgr);
-        HashSet set = new HashSet(((NodeState) state).getMixinTypeNames());
+        HashSet set = new HashSet((state).getMixinTypeNames());
-    private static PersistentNodeState copyNodeState(NodeState srcState,
-                                                     String parentUUID,
-                                                     NodeTypeRegistry ntReg,
-                                                     HierarchyManagerImpl srcHierMgr,
-                                                     PersistentItemStateProvider srcStateMgr,
-                                                     PersistentItemStateProvider destStateMgr,
-                                                     boolean clone)
+    private static NodeState copyNodeState(NodeState srcState,
+                                           String parentUUID,
+                                           NodeTypeRegistry ntReg,
+                                           HierarchyManagerImpl srcHierMgr,
+                                           ItemStateManager srcStateMgr,
+                                           ItemStateManager destStateMgr,
+                                           boolean clone,
+                                           UpdateOperation update)
-        PersistentNodeState newState;
+
+        NodeState newState;
-            newState = destStateMgr.createNodeState(uuid, srcState.getNodeTypeName(), parentUUID);
+            newState = update.createNew(uuid, srcState.getNodeTypeName(), parentUUID);
-                PersistentNodeState newChildState = copyNodeState(srcChildState, uuid,
-                        ntReg, srcHierMgr, srcStateMgr, destStateMgr, clone);
+                NodeState newChildState = copyNodeState(srcChildState, uuid,
+                        ntReg, srcHierMgr, srcStateMgr, destStateMgr, clone, update);
-                newChildState.store();
+                update.store(newChildState);
-                PersistentPropertyState newChildState = copyPropertyState(srcChildState, uuid, entry.getName(),
-                        ntReg, srcHierMgr, srcStateMgr, destStateMgr);
+                PropertyState newChildState = copyPropertyState(srcChildState, uuid, entry.getName(),
+                        ntReg, srcHierMgr, srcStateMgr, destStateMgr, update);
-                newChildState.store();
+                update.store(newChildState);
-    private static PersistentPropertyState copyPropertyState(PropertyState srcState,
-                                                             String parentUUID,
-                                                             QName propName,
-                                                             NodeTypeRegistry ntReg,
-                                                             HierarchyManagerImpl srcHierMgr,
-                                                             PersistentItemStateProvider srcStateMgr,
-                                                             PersistentItemStateProvider destStateMgr)
+    private static PropertyState copyPropertyState(PropertyState srcState,
+                                                   String parentUUID,
+                                                   QName propName,
+                                                   NodeTypeRegistry ntReg,
+                                                   HierarchyManagerImpl srcHierMgr,
+                                                   ItemStateManager srcStateMgr,
+                                                   ItemStateManager destStateMgr,
+                                                   UpdateOperation update)
+
-        PersistentPropertyState newState;
-        try {
-            newState = destStateMgr.createPropertyState(parentUUID, propName);
-            PropDefId defId = srcState.getDefinitionId();
-            newState.setDefinitionId(defId);
-            newState.setType(srcState.getType());
-            newState.setMultiValued(srcState.isMultiValued());
-            InternalValue[] values = srcState.getValues();
-            if (values != null) {
-                InternalValue[] newValues = new InternalValue[values.length];
-                for (int i = 0; i < values.length; i++) {
-                    newValues[i] = values[i] != null ? values[i].createCopy() : null;
-                }
-                newState.setValues(values);
-                // FIXME delegate to 'node type instance handler'
-                if (defId != null) {
-                    PropDef def = ntReg.getPropDef(defId);
-                    if (def.getDeclaringNodeType().equals(NodeTypeRegistry.MIX_REFERENCEABLE)) {
-                        if (propName.equals(ItemImpl.PROPNAME_UUID)) {
-                            // set correct value of jcr:uuid property
-                            newState.setValues(new InternalValue[]{InternalValue.create(parentUUID)});
-                        }
+        PropertyState newState = update.createNew(propName, parentUUID);
+        PropDefId defId = srcState.getDefinitionId();
+        newState.setDefinitionId(defId);
+        newState.setType(srcState.getType());
+        newState.setMultiValued(srcState.isMultiValued());
+        InternalValue[] values = srcState.getValues();
+        if (values != null) {
+            InternalValue[] newValues = new InternalValue[values.length];
+            for (int i = 0; i < values.length; i++) {
+                newValues[i] = values[i] != null ? values[i].createCopy() : null;
+            }
+            newState.setValues(values);
+            // FIXME delegate to 'node type instance handler'
+            if (defId != null) {
+                PropDef def = ntReg.getPropDef(defId);
+                if (def.getDeclaringNodeType().equals(NodeTypeRegistry.MIX_REFERENCEABLE)) {
+                    if (propName.equals(ItemImpl.PROPNAME_UUID)) {
+                        // set correct value of jcr:uuid property
+                        newState.setValues(new InternalValue[]{InternalValue.create(parentUUID)});
-            return newState;
-        } catch (ItemStateException ise) {
-            String msg = "internal error: failed to copy state of " + srcHierMgr.safeGetJCRPath(srcState.getId());
-            log.error(msg, ise);
-            throw new RepositoryException(msg, ise);
+        return newState;
-                                     PersistentItemStateProvider srcStateMgr,
+                                     ItemStateManager srcStateMgr,
-                                     PersistentItemStateProvider destStateMgr,
+                                     ItemStateManager destStateMgr,
-        PersistentNodeState srcState;
+        NodeState srcState;
-        PersistentNodeState destParentState;
+        NodeState destParentState;
-/*
-	// check if target node needs to be inserted at specific location in child node entries list
-	boolean insertTargetEntry = false;
-	int ind = destName.getIndex();
-	if (ind > 0) {
-	    // target name contains subscript:
-	    // validate subscript
-	    List sameNameSibs = destParentState.getChildNodeEntries(destName.getName());
-	    if (ind > sameNameSibs.size() + 1) {
-		String msg = "invalid subscript in name: " + destAbsPath;
-		log.error(msg);
-		throw new RepositoryException(msg);
-	    }
-	    insertTargetEntry = (ind < sameNameSibs.size() + 1) ? true : false;
-	}
-	if (insertTargetEntry) {
-	    // check hasOrderableChildNodes flag
-	    if (!ntReg.getNodeTypeDef(destParentState.getNodeTypeName()).hasOrderableChildNodes()) {
-		throw new ConstraintViolationException(destAbsPath + ": parent node's node type does not allow explicit ordering of child nodes");
-	    }
-	}
-*/
+
-
-        // create deep copy of source node state
-        PersistentNodeState newState = copyNodeState(srcState, destParentState.getUUID(),
-                ntReg, srcHierMgr, srcStateMgr, destStateMgr, clone);
-
-        // add to new parent
-        destParentState.addChildNodeEntry(destName.getName(), newState.getUUID());
-/*
-	if (!insertTargetEntry) {
-	    // append target entry
-	    destParentState.addChildNodeEntry(destName.getName(), newState.getUUID());
-	} else {
-	    // insert target entry at specified position
-	    Iterator iter = new ArrayList(destParentState.getChildNodeEntries()).iterator();
-	    destParentState.removeAllChildNodeEntries();
-	    while (iter.hasNext()) {
-		NodeState.ChildNodeEntry entry = (NodeState.ChildNodeEntry) iter.next();
-		if (entry.getName().equals(destName.getName()) &&
-			entry.getIndex() == destName.getIndex()) {
-		    destParentState.addChildNodeEntry(destName.getName(), newState.getUUID());
-		}
-		destParentState.addChildNodeEntry(entry.getName(), entry.getUUID());
-	    }
-	}
-*/
-        // change definition (id) of new node
-        ChildNodeDef newNodeDef = findApplicableDefinition(destName.getName(), srcState.getNodeTypeName(), destParentState, ntReg);
-        newState.setDefinitionId(new NodeDefId(newNodeDef));
-
-        // persist states
-            newState.store();
-            destParentState.store();
+            UpdateOperation update = destStateMgr.beginUpdate();
+
+            // create deep copy of source node state
+            NodeState newState = copyNodeState(srcState, destParentState.getUUID(),
+                    ntReg, srcHierMgr, srcStateMgr, destStateMgr, clone, update);
+
+            // add to new parent
+            destParentState.addChildNodeEntry(destName.getName(), newState.getUUID());
+
+            // change definition (id) of new node
+            ChildNodeDef newNodeDef = findApplicableDefinition(destName.getName(), srcState.getNodeTypeName(), destParentState, ntReg);
+            newState.setDefinitionId(new NodeDefId(newNodeDef));
+
+            // persist states
+            update.store(newState);
+            update.store(destParentState);
+
+            // finish update operations
+            update.end();
-        PersistentItemStateProvider srcStateMgr = rep.getWorkspaceStateManager(srcWorkspace);
+        ItemStateManager srcStateMgr = rep.getWorkspaceStateManager(srcWorkspace);
-                destAbsPath, persistentStateMgr, hierMgr,
+                destAbsPath, stateMgr, hierMgr,
-        internalCopy(srcAbsPath, persistentStateMgr, hierMgr,
-                destAbsPath, persistentStateMgr, hierMgr,
+        internalCopy(srcAbsPath, stateMgr, hierMgr,
+                destAbsPath, stateMgr, hierMgr,
-        PersistentItemStateProvider srcStateMgr = rep.getWorkspaceStateManager(srcWorkspace);
+        ItemStateManager srcStateMgr = rep.getWorkspaceStateManager(srcWorkspace);
-                destAbsPath, persistentStateMgr, hierMgr,
+                destAbsPath, stateMgr, hierMgr,
-
-        PersistentNodeState targetState;
-        PersistentNodeState srcParentState;
+        NodeState targetState;
+        NodeState srcParentState;
+
-            targetState = getNodeState(srcPath, hierMgr, persistentStateMgr);
-            srcParentState = getNodeState(srcParentPath, hierMgr, persistentStateMgr);
+            targetState = getNodeState(srcPath, hierMgr, stateMgr);
+            srcParentState = getNodeState(srcParentPath, hierMgr, stateMgr);
-        PersistentNodeState destParentState;
+        NodeState destParentState;
+
-            destParentState = getNodeState(destParentPath, hierMgr, persistentStateMgr);
+            destParentState = getNodeState(destParentPath, hierMgr, stateMgr);
+
-        checkRemoveNode(srcPath, rep.getNodeTypeRegistry(), session.getAccessManager(), hierMgr, persistentStateMgr);
+        checkRemoveNode(srcPath, rep.getNodeTypeRegistry(),
+                session.getAccessManager(), hierMgr, stateMgr);
-                hierMgr, persistentStateMgr);
-/*
-	// check if target node needs to be inserted at specific location in child node entries list
-	boolean insertTargetEntry = false;
-	int ind = destName.getIndex();
-	if (ind > 0) {
-	    // target name contains subscript:
-	    // validate subscript
-	    List sameNameSibs = destParentState.getChildNodeEntries(destName.getName());
-	    if (ind > sameNameSibs.size() + 1) {
-		String msg = "invalid subscript in name: " + destAbsPath;
-		log.error(msg);
-		throw new RepositoryException(msg);
-	    }
-	    insertTargetEntry = (ind < sameNameSibs.size() + 1) ? true : false;
-	}
-	if (insertTargetEntry) {
-	    // check hasOrderableChildNodes flag
-	    if (!rep.getNodeTypeRegistry().getNodeTypeDef(destParentState.getNodeTypeName()).hasOrderableChildNodes()) {
-		throw new ConstraintViolationException(destAbsPath + ": parent node's node type does not allow explicit ordering of child nodes");
-	    }
-	}
-*/
+                hierMgr, stateMgr);
+
-
-        boolean renameOnly = srcParentState.getUUID().equals(destParentState.getUUID());
-
-        // add to new parent
-        if (!renameOnly) {
-            targetState.addParentUUID(destParentState.getUUID());
-        }
-        destParentState.addChildNodeEntry(destName.getName(), targetState.getUUID());
-/*
-	if (!insertTargetEntry) {
-	    // append target entry
-	    destParentState.addChildNodeEntry(destName.getName(), targetState.getUUID());
-	} else {
-	    // insert target entry at specified position
-	    Iterator iter = new ArrayList(destParentState.getChildNodeEntries()).iterator();
-	    destParentState.removeAllChildNodeEntries();
-	    while (iter.hasNext()) {
-		NodeState.ChildNodeEntry entry = (NodeState.ChildNodeEntry) iter.next();
-		if (entry.getName().equals(destName.getName()) &&
-			entry.getIndex() == destName.getIndex()) {
-		    destParentState.addChildNodeEntry(destName.getName(), targetState.getUUID());
-		}
-		destParentState.addChildNodeEntry(entry.getName(), entry.getUUID());
-	    }
-	}
-*/
-        // change definition (id) of target node
-        ChildNodeDef newTargetDef = findApplicableDefinition(destName.getName(), targetState.getNodeTypeName(), destParentState, rep.getNodeTypeRegistry());
-        targetState.setDefinitionId(new NodeDefId(newTargetDef));
-
-        // remove from old parent
-        if (!renameOnly) {
-            targetState.removeParentUUID(srcParentState.getUUID());
-        }
-        int srcNameIndex = srcName.getIndex() == 0 ? 1 : srcName.getIndex();
-/*
-	// if the net result of the move is changing the position of a child node
-	// among its same-same siblings, the subscript of the child node entry
-	// to be removed might need adjustment
-	if (renameOnly && srcName.getName().equals(destName.getName()) &&
-		insertTargetEntry && destName.getIndex() <= srcNameIndex) {
-	    srcNameIndex++;
-	}
-*/
-        srcParentState.removeChildNodeEntry(srcName.getName(), srcNameIndex);
-
-        // persist states
-            targetState.store();
-            if (renameOnly) {
-                srcParentState.store();
-            } else {
-                destParentState.store();
-                srcParentState.store();
+            UpdateOperation update = stateMgr.beginUpdate();
+            boolean renameOnly = srcParentState.getUUID().equals(destParentState.getUUID());
+
+            // add to new parent
+            if (!renameOnly) {
+                targetState.addParentUUID(destParentState.getUUID());
+            destParentState.addChildNodeEntry(destName.getName(), targetState.getUUID());
+
+            // change definition (id) of target node
+            ChildNodeDef newTargetDef = findApplicableDefinition(destName.getName(), targetState.getNodeTypeName(), destParentState, rep.getNodeTypeRegistry());
+            targetState.setDefinitionId(new NodeDefId(newTargetDef));
+
+            // remove from old parent
+            if (!renameOnly) {
+                targetState.removeParentUUID(srcParentState.getUUID());
+            }
+
+            int srcNameIndex = srcName.getIndex() == 0 ? 1 : srcName.getIndex();
+            srcParentState.removeChildNodeEntry(srcName.getName(), srcNameIndex);
+
+            // persist states
+            update.store(targetState);
+            if (renameOnly) {
+                update.store(srcParentState);
+            } else {
+                update.store(destParentState);
+                update.store(srcParentState);
+            }
+
+            // finish update
+            update.end();
-        PersistentNodeState state;
+        NodeState state;
-            state = getNodeState(path, hierMgr, persistentStateMgr);
+            state = getNodeState(path, hierMgr, stateMgr);
-                persistentStateMgr, (NamespaceRegistryImpl) rep.getNamespaceRegistry(),
+                stateMgr, rep.getNamespaceRegistry(),
-        PersistentNodeState state;
+        NodeState state;
-            state = getNodeState(path, hierMgr, persistentStateMgr);
+            state = getNodeState(path, hierMgr, stateMgr);
-                persistentStateMgr, (NamespaceRegistryImpl) rep.getNamespaceRegistry(),
+                stateMgr, rep.getNamespaceRegistry(),

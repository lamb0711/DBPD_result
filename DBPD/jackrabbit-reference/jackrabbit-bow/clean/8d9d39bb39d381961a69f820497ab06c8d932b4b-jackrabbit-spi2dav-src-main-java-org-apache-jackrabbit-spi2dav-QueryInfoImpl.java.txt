JCR-3198: Broken handling of outer join results over davex

Return the set of selector names as a part of the response description field along with column names.

For compatibility with earlier clients/servers this new functionality (and extensible) functionality is only enabled when the search request is made with the query language qualified with the JCR WebDAV extension namespace.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1227240 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Set;
-import java.util.HashSet;
-import org.apache.jackrabbit.spi.Name;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-    /**
-     * Logger instance for this class.
-     */
-    private static final Logger log = LoggerFactory.getLogger(QueryInfoImpl.class);
+    private static final String COLUMNS = "Columns: ";
-    private final String[] columnNames;
+    private static final String SELECTORS = "Selectors: ";
+
+    private final List<String> columnNames = new ArrayList<String>();
+
+    private final List<String> selectorNames = new ArrayList<String>();
-        if (responseDescription != null) {
-            String[] cn = responseDescription.split(" ");
-            this.columnNames = new String[cn.length];
-            for (int i = 0; i < cn.length; i++) {
-                columnNames[i] = ISO9075.decode(cn[i]);
+        if (responseDescription == null) {
+            throw new RepositoryException(
+                    "Missing column infos: Unable to build QueryInfo object.");
+        }
+        if (responseDescription.startsWith(COLUMNS)) {
+            for (String line : responseDescription.split("\n")) {
+                if (line.startsWith(COLUMNS)) {
+                    decode(line.substring(COLUMNS.length()), columnNames);
+                } else if (line.startsWith(SELECTORS)) {
+                    decode(line.substring(SELECTORS.length()), selectorNames);
+                }
-            throw new RepositoryException("Missing column infos: Unable to build QueryInfo object.");
+            // Backwards compatibility with old servers that only provide
+            // the list of columns as the response description
+            decode(responseDescription, columnNames);
-            results.add(new QueryResultRowImpl(response, columnNames, resolver,
+            results.add(new QueryResultRowImpl(
+                    response, getColumnNames(), resolver,
+     * Splits the given string at spaces and ISO9075-decodes the parts.
+     *
+     * @param string source string
+     * @param list where the decoded parts get added
+     */
+    private void decode(String string, List<String> list) {
+        String[] parts = string.split(" ");
+        for (int i = 0; i < parts.length; i++) {
+            list.add(ISO9075.decode(parts[i]));
+        }
+    }
+
+    /**
-        String[] names = new String[columnNames.length];
-        System.arraycopy(columnNames, 0, names, 0, columnNames.length);
-        return names;
+        return columnNames.toArray(new String[columnNames.size()]);
-    public Name[] getSelectorNames() {
-        if (results.isEmpty()) {
-            // TODO: this is not correct
-            return Name.EMPTY_ARRAY;
-        } else {
-            Set<Name> uniqueNames = new HashSet<Name>();
-            QueryResultRowImpl row = (QueryResultRowImpl) results.get(0);
-            for (Name n : row.getSelectorNames()) {
-                if (n != null) {
-                    uniqueNames.add(n);
-                }
-            }
-            return uniqueNames.toArray(new Name[uniqueNames.size()]);
-        }
+    public String[] getSelectorNames() {
+        return selectorNames.toArray(new String[selectorNames.size()]);

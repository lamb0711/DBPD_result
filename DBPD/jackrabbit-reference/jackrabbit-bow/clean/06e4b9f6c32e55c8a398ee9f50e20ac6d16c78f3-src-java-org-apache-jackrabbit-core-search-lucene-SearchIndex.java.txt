more eol-style fixes


git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@47405 13f79535-47bb-0310-9956-ffa450edef68

-/*
- * Copyright 2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.jackrabbit.core.search.lucene;
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.Hits;
-import org.apache.log4j.Logger;
-//import org.apache.lucene.search.Sort;
-//import org.apache.lucene.search.SortField;
-
-import java.io.IOException;
-
-import EDU.oswego.cs.dl.util.concurrent.FIFOReadWriteLock;
-
-/**
- * @author Marcel Reutegger
- * @version $Revision:  $, $Date:  $
- */
-public class SearchIndex {
-
-    private static final Logger log = Logger.getLogger(SearchIndex.class);
-
-    /** 512k default size */
-    //private static final long DEFAULT_MERGE_SIZE = 512 * 1024 * 1024;
-
-    //private long mergeSize = DEFAULT_MERGE_SIZE;
-
-    private PersistentIndex persistentIndex;
-
-    //private VolatileIndex volatileIndex;
-
-    private final Analyzer analyzer;
-
-    private final String location;
-
-    private final FIFOReadWriteLock readWriteLock = new FIFOReadWriteLock();
-
-    public SearchIndex(String location, Analyzer analyzer) throws IOException {
-	//volatileIndex = new VolatileIndex(analyzer);
-	persistentIndex = new PersistentIndex(location, analyzer);
-	persistentIndex.setUseCompoundFile(true);
-	this.location = location;
-	this.analyzer = analyzer;
-    }
-
-    public void addDocument(Document doc) throws IOException {
-	try {
-	    readWriteLock.writeLock().acquire();
-	} catch (InterruptedException e) {
-	    // FIXME: ??? do logging, simply return?
-	    return;
-	}
-
-	try {
-	    persistentIndex.addDocument(doc);
-	} finally {
-	    readWriteLock.writeLock().release();
-	}
-
-	/*
-	volatileIndex.addDocument(doc);
-	if (volatileIndex.size() > mergeSize) {
-	    persistentIndex.mergeIndex(volatileIndex);
-	    // create new volatile index
-	    volatileIndex = new VolatileIndex(analyzer);
-	}
-	*/
-    }
-
-    public void removeDocument(Term idTerm) throws IOException {
-	try {
-	    readWriteLock.writeLock().acquire();
-	} catch (InterruptedException e) {
-	    // FIXME: ??? do logging, simply return?
-	    return;
-	}
-
-	try {
-	    persistentIndex.removeDocument(idTerm);
-	} finally {
-	    readWriteLock.writeLock().release();
-	}
-
-	//volatileIndex.removeDocument(idTerm);
-    }
-
-    public void close() {
-	/*
-	try {
-	    persistentIndex.mergeIndex(volatileIndex);
-	} catch (IOException e) {
-	    // FIXME do logging
-	}
-	volatileIndex.close();
-	*/
-	log.info("Closing index: " + location);
-    	persistentIndex.close();
-    }
-
-    public Hits executeQuery(Query query,
-			     String[] orderProps,
-			     boolean ascending) throws IOException {
-        try {
-	    readWriteLock.readLock().acquire();
-	} catch (InterruptedException e) {
-	    // FIXME: ??? do logging, simply return?
-	    return null;
-	}
-
-	/*
-	SortField[] sortFields = new SortField[orderProps.length];
-	for (int i = 0; i < orderProps.length; i++) {
-	    sortFields[i] = new SortField(orderProps[i], SortField.STRING, !ascending);
-	}
-        */
-	Hits hits = null;
-	try {
-	    hits = persistentIndex.getIndexSearcher().search(query
-		    /*, new Sort(sortFields) */);
-	} finally {
-	    readWriteLock.readLock().release();
-	}
-
-	return hits;
-    }
-
-    public Analyzer getAnalyzer() {
-	return analyzer;
-    }
-}
+/*
+ * Copyright 2004 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.core.search.lucene;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.Hits;
+import org.apache.log4j.Logger;
+//import org.apache.lucene.search.Sort;
+//import org.apache.lucene.search.SortField;
+
+import java.io.IOException;
+
+import EDU.oswego.cs.dl.util.concurrent.FIFOReadWriteLock;
+
+/**
+ * @author Marcel Reutegger
+ * @version $Revision:  $, $Date:  $
+ */
+public class SearchIndex {
+
+    private static final Logger log = Logger.getLogger(SearchIndex.class);
+
+    /** 512k default size */
+    //private static final long DEFAULT_MERGE_SIZE = 512 * 1024 * 1024;
+
+    //private long mergeSize = DEFAULT_MERGE_SIZE;
+
+    private PersistentIndex persistentIndex;
+
+    //private VolatileIndex volatileIndex;
+
+    private final Analyzer analyzer;
+
+    private final String location;
+
+    private final FIFOReadWriteLock readWriteLock = new FIFOReadWriteLock();
+
+    public SearchIndex(String location, Analyzer analyzer) throws IOException {
+	//volatileIndex = new VolatileIndex(analyzer);
+	persistentIndex = new PersistentIndex(location, analyzer);
+	persistentIndex.setUseCompoundFile(true);
+	this.location = location;
+	this.analyzer = analyzer;
+    }
+
+    public void addDocument(Document doc) throws IOException {
+	try {
+	    readWriteLock.writeLock().acquire();
+	} catch (InterruptedException e) {
+	    // FIXME: ??? do logging, simply return?
+	    return;
+	}
+
+	try {
+	    persistentIndex.addDocument(doc);
+	} finally {
+	    readWriteLock.writeLock().release();
+	}
+
+	/*
+	volatileIndex.addDocument(doc);
+	if (volatileIndex.size() > mergeSize) {
+	    persistentIndex.mergeIndex(volatileIndex);
+	    // create new volatile index
+	    volatileIndex = new VolatileIndex(analyzer);
+	}
+	*/
+    }
+
+    public void removeDocument(Term idTerm) throws IOException {
+	try {
+	    readWriteLock.writeLock().acquire();
+	} catch (InterruptedException e) {
+	    // FIXME: ??? do logging, simply return?
+	    return;
+	}
+
+	try {
+	    persistentIndex.removeDocument(idTerm);
+	} finally {
+	    readWriteLock.writeLock().release();
+	}
+
+	//volatileIndex.removeDocument(idTerm);
+    }
+
+    public void close() {
+	/*
+	try {
+	    persistentIndex.mergeIndex(volatileIndex);
+	} catch (IOException e) {
+	    // FIXME do logging
+	}
+	volatileIndex.close();
+	*/
+	log.info("Closing index: " + location);
+    	persistentIndex.close();
+    }
+
+    public Hits executeQuery(Query query,
+			     String[] orderProps,
+			     boolean ascending) throws IOException {
+        try {
+	    readWriteLock.readLock().acquire();
+	} catch (InterruptedException e) {
+	    // FIXME: ??? do logging, simply return?
+	    return null;
+	}
+
+	/*
+	SortField[] sortFields = new SortField[orderProps.length];
+	for (int i = 0; i < orderProps.length; i++) {
+	    sortFields[i] = new SortField(orderProps[i], SortField.STRING, !ascending);
+	}
+        */
+	Hits hits = null;
+	try {
+	    hits = persistentIndex.getIndexSearcher().search(query
+		    /*, new Sort(sortFields) */);
+	} finally {
+	    readWriteLock.readLock().release();
+	}
+
+	return hits;
+    }
+
+    public Analyzer getAnalyzer() {
+	return analyzer;
+    }
+}

JCR-1590 JSR 283: Locking

- getSecondsRemaining is negative if lock is expired or released
- getLockToken always returns null if lock is sessionscoped

JCR-2004 Update SPI locking to match JCR 2.0

- extend spi/LockInfo.java
- add JCR 2.0 variant of RepositoryService#lock that takes timeoutHint and ownerHint
- adjust jcr2spi
- adjust spi implementation(s)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@753244 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.NodeImpl;
+import org.apache.jackrabbit.spi.commons.conversion.PathResolver;
+import java.util.Date;
-public class LockManagerImpl implements LockManager, SessionListener {
+public class LockManagerImpl implements LockManager, org.apache.jackrabbit.api.jsr283.lock.LockManager, SessionListener {
+    private static final long TIMEOUT_EXPIRED = -1;
+    private static final long TIMEOUT_INFINITE = Long.MAX_VALUE;
+
+    private final PathResolver resolver;
-                           CacheBehaviour cacheBehaviour) {
+                           CacheBehaviour cacheBehaviour, PathResolver pathResolver) {
+        this.resolver = pathResolver;
+    //--------------------------------------------------------< LockManager >---
+    /**
+     * @see org.apache.jackrabbit.api.jsr283.lock.LockManager#getLock(String)
+     */
+    public org.apache.jackrabbit.api.jsr283.lock.Lock getLock(String absPath) throws LockException, RepositoryException {
+        Node n = itemManager.getNode(resolver.getQPath(absPath));
+        return (org.apache.jackrabbit.api.jsr283.lock.Lock) n.getLock();
+    }
+
+    /**
+     * @see org.apache.jackrabbit.api.jsr283.lock.LockManager#isLocked(String)
+     */
+    public boolean isLocked(String absPath) throws RepositoryException {
+        Node n = itemManager.getNode(resolver.getQPath(absPath));
+        return n.isLocked();
+    }
+
+    /**
+     * @see org.apache.jackrabbit.api.jsr283.lock.LockManager#holdsLock(String)
+     */
+    public boolean holdsLock(String absPath) throws RepositoryException {
+        Node n = itemManager.getNode(resolver.getQPath(absPath));
+        return n.holdsLock();
+    }
+
+    /**
+     * @see org.apache.jackrabbit.api.jsr283.lock.LockManager#lock(String, boolean, boolean, long, String)
+     */
+    public org.apache.jackrabbit.api.jsr283.lock.Lock lock(String absPath, boolean isDeep, boolean isSessionScoped, long timeoutHint, String ownerInfo) throws RepositoryException {
+        Node n = itemManager.getNode(resolver.getQPath(absPath));
+        return (org.apache.jackrabbit.api.jsr283.lock.Lock) ((NodeImpl) n).lock(isDeep, isSessionScoped, timeoutHint, ownerInfo);
+    }
+
+    /**
+     * @see org.apache.jackrabbit.api.jsr283.lock.LockManager#unlock(String) 
+     */
+    public void unlock(String absPath) throws LockException, RepositoryException {
+        Node n = itemManager.getNode(resolver.getQPath(absPath));
+        n.unlock();
+    }
+
+    //---------------------< org.apache.jackrabbit.jcr2spi.lock.LockManager >---
+        return lock(nodeState, isDeep, isSessionScoped, Long.MAX_VALUE, null);
+    }
+
+    /**
+     * @see LockManager#lock(NodeState,boolean,boolean,long,String)
+     */
+    public Lock lock(NodeState nodeState, boolean isDeep, boolean isSessionScoped, long timeoutHint, String ownerHint) throws RepositoryException {
-        LockOperation op = LockOperation.create(nodeState, isDeep, isSessionScoped);
+        LockOperation op = LockOperation.create(nodeState, isDeep, isSessionScoped, timeoutHint, ownerHint);
-        if (l != null && l.getLockToken() == null) {
+        if (l != null && !l.isLockOwningSession()) {
+    //--------< LockManager, org.apache.jackrabbit.jcr2spi.lock.LockManager >---
-            if (l.isSessionScoped() && l.getLockToken() != null) {
+            if (l.isSessionScoped() && l.isLockOwningSession()) {
-                lockHoldingState = ((NodeEntry) lockedEntry).getNodeState();
+                lockHoldingState = lockedEntry.getNodeState();
-            // need correct information about lock status -> retrieve lockInfo
+            // need precise information about lock status -> retrieve lockInfo
-                lock.lockState.lockInfo = lState.lockInfo;
+                lock.lockState.setLockInfo(lState.lockInfo);
+        private long expiration = TIMEOUT_INFINITE;
-            this.lockInfo = lockInfo;
+            setLockInfo(lockInfo);
+        private void setLockInfo(LockInfo lockInfo) {
+            this.lockInfo = lockInfo;
+            long seconds = lockInfo.getSecondsRemaining();
+            if (seconds <= TIMEOUT_EXPIRED) {
+                expiration = TIMEOUT_EXPIRED;
+                isLive = false;
+            } else if (seconds < TIMEOUT_INFINITE) {
+                // calculate timeout
+                expiration = new Date().getTime()/1000 + lockInfo.getSecondsRemaining();
+            } else {
+                expiration = TIMEOUT_INFINITE;
+            }
+        }
+
+        /**
+         * @return <code>true</code> if the lock is still alive.
+         */
+        private boolean isLive() {
+            if (isLive) {
+                isLive = getSecondsRemaining() > 0;
+            }
+            return isLive;
+        }
+
+        /**
+         * @return the number of seconds until the lock's timeout is reached,
+         * {@link Long#MAX_VALUE} if timeout is infinite or undefined and
+         * a negative value if timeout has already been reached or the lock
+         * has been otherwise released.
+         */
+        private long getSecondsRemaining() {
+            if (!isLive) {
+                return TIMEOUT_EXPIRED;
+            } else if (expiration == TIMEOUT_INFINITE) {
+                return expiration;
+            } else {
+                long seconds = expiration - new Date().getTime()/1000;
+                if (seconds <= 0) {
+                    isLive = false;
+                    return TIMEOUT_EXPIRED;
+                } else {
+                    return seconds;
+                }
+            }
+        }
+
-            if (isLive) {
-                isLive = false;
+            if (isLive()) {
+                isLive = false;
-            if (!isLive) {
+            if (!isLive()) {
-    private class LockImpl implements Lock, LockTokenListener {
+    private class LockImpl implements org.apache.jackrabbit.api.jsr283.lock.Lock, LockTokenListener {
-            } else if (isHoldBySession()) {
+            } else if (lockState.lockInfo.isLockOwner()) {
+            // shortcut for jsr 283 session scoped locks: they never expose
+            // the lock token to the API users.
+            if (isSessionScoped()) {
+                return null;
+            }
+
-            return lockState.isLive;
+            return lockState.isLive();
-            if (getLockToken() == null) {
+            if (!isLockOwningSession()) {
+        /**
+         * @see org.apache.jackrabbit.api.jsr283.lock.Lock#getSecondsRemaining()
+         */
+        public long getSecondsRemaining() throws RepositoryException {
+            updateLockInfo();
+            return lockState.getSecondsRemaining();
+        }
+
+        /**
+         * @see org.apache.jackrabbit.api.jsr283.lock.Lock#isLockOwningSession()
+         */
+        public boolean isLockOwningSession(){
+            return lockState.lockInfo.isLockOwner();
+        }
+
-            if (getLockToken() == null) {
-                // could be that this affects this lock and session became
+            if (!isSessionScoped() && !isLockOwningSession()) {
+                // unless this lock is session-scoped (token is never transfered)
+                // and the session isn't the owner yet (token already present),
+                // it could be that this affects this lock and session became
-            // for this lock.
+            // for this lock. this will never be true for session-scoped locks
+            // that are not exposed (thus cannot be removed).
-        /**
-         * @return true if this lock is hold by this session. false otherwise.
-         */
-        private boolean isHoldBySession() {
-            return lockState.lockInfo.getLockToken() != null;
-        }

JCR-2620 -  Authorizable#getProperty and #setProperty should deal with relativePath

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@987435 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.api.security.user.UserManager;
+import org.apache.jackrabbit.commons.predicate.Predicate;
+import org.apache.jackrabbit.core.SessionImpl;
+import org.apache.jackrabbit.spi.Path;
+import java.util.HashMap;
+import java.util.Map;
-                NodeIterator nodes = collectNodes(value,
-                        Collections.singleton(propertyName), ntName,
-                        root.getNodes(), true, 1);
-                if (nodes.hasNext()) {
-                    return nodes.nextNode();
+                Set<Node> matchSet = new HashSet<Node>();
+                collectNodes(value, Collections.singleton(propertyName), ntName, root.getNodes(), matchSet, true, 1);
+
+                NodeIterator it = new NodeIteratorAdapter(matchSet);
+                if (it.hasNext()) {
+                    return it.nextNode();
-                return collectNodes(value, propertyNames, ntName, root.getNodes(), exact, maxSize);
+                Set<Node> matchSet = new HashSet<Node>();
+                collectNodes(value, propertyNames, ntName, root.getNodes(), matchSet, exact, maxSize);
+                return new NodeIteratorAdapter(matchSet);
+            } catch (PathNotFoundException e) {
+                // should not get here
+                log.warn("Error while retrieving node " + sr);
+            }
+        } // else: searchRoot does not exist yet -> omit the search
+        return NodeIteratorAdapter.EMPTY;
+    }
+
+    /**
+     * @inheritDoc
+     */
+    @Override
+    public NodeIterator findNodes(Path relPath, String value, int authorizableType, boolean exact, long maxSize) throws RepositoryException {
+        String sr = getSearchRoot(authorizableType);
+        if (getSession().nodeExists(sr)) {
+            try {
+                String path = getNamePathResolver().getJCRPath(relPath);
+                AuthorizableTypePredicate pred = getAuthorizableTypePredicate(authorizableType, relPath.getLength() > 1);
+
+                Node root = getSession().getNode(sr);
+                Map<String, Node> matchingNodes = new HashMap<String, Node>();
+                collectNodes(value, path, pred, root.getNodes(), matchingNodes, exact, maxSize);
+
+                return new NodeIteratorAdapter(matchingNodes.values());
-     * searches the given value in the range of the given NodeIterator.
-     * recurses unitll all matching values in all configured props are found.
-     *
-     * @param value   the value to be found in the nodes
-     * @param props   property to be searched, or null if {@link javax.jcr.Item#getName()}
-     * @param ntName  to filter search
-     * @param nodes   range of nodes and descendants to be searched
-     * @param exact   if set to true the value has to match exactly else a
-     * substring is searched
-     * @param maxSize
-     * @return
-     */
-    private NodeIterator collectNodes(String value, Set<Name> props, Name ntName,
-                                      NodeIterator nodes, boolean exact,
-                                      long maxSize) {
-        Set<Node> matchSet = new HashSet<Node>();
-        collectNodes(value, props, ntName, nodes, matchSet, exact, maxSize);
-        return new NodeIteratorAdapter(matchSet);
-    }
-
-    /**
-     * searches the given value in the range of the given NodeIterator.
-     * recurses unitll all matching values in all configured properties are found.
+     * Searches the given value in the range of the given NodeIterator.
+     * This method is called recursively to look within the complete tree
+     * of authorizable nodes.
-     * @param nodeTypeName  name of nodetypes to search
+     * @param nodeTypeName  name of node types to search
+    private void collectNodes(String value, String relPath,
+                              AuthorizableTypePredicate predicate, NodeIterator itr,
+                              Map<String, Node> matchingNodes, boolean exact, long maxSize) {
+        while (itr.hasNext()) {
+            NodeImpl node = (NodeImpl) itr.nextNode();
+            try {
+                Node authNode = getMatchingNode(node, predicate, relPath, value, exact);
+                if (authNode != null) {
+                    matchingNodes.put(authNode.getIdentifier(), authNode);
+                    maxSize--;
+                } else if (node.hasNodes() && maxSize > 0) {
+                    collectNodes(value, relPath, predicate, node.getNodes(), matchingNodes, exact, maxSize);
+                }
+            } catch (RepositoryException e) {
+                log.warn("Internal error while accessing node", e);
+            }
+        }
+    }
+
+    /**
+     *
+     * @param node
+     * @param predicate
+     * @param relPath
+     * @param value
+     * @param exact
+     * @return
+     * @throws RepositoryException
+     */
+    private static Node getMatchingNode(NodeImpl node, AuthorizableTypePredicate predicate,
+                                        String relPath, String value,
+                                        boolean exact) throws RepositoryException {
+        boolean match = false;
+        Node authNode = predicate.getAuthorizableNode(node);
+        if (authNode != null && node.hasProperty(relPath)) {
+            try {
+                Property prop = node.getProperty(relPath);
+                if (prop.isMultiple()) {
+                    Value[] values = prop.getValues();
+                    for (int i = 0; i < values.length && !match; i++) {
+                        match = matches(value, values[i].getString(), exact);
+                    }
+                } else {
+                    match = matches(value, prop.getString(), exact);
+                }
+            } catch (PatternSyntaxException pe) {
+                log.debug("couldn't search for {}, pattern invalid: {}", value, pe.getMessage());
+            }
+        }
+        return (match) ? authNode : null;
+    }
+

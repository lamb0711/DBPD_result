Added SQL and XPath query implementation. The implementation is not complete yet. Only basic operations are supported.
Also added postGoals to the maven.xml to generate the parser classes for SQL XPath.

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@123135 13f79535-47bb-0310-9956-ffa450edef68

-public class PathQueryNode extends QueryNode {
+public class PathQueryNode extends NAryQueryNode {
-     * Match path exact
+     * Empty step node array.
-    public static final int TYPE_EXACT = 1;
+    private static final LocationStepQueryNode[] EMPTY = new LocationStepQueryNode[0];
-    /**
-     * Match child nodes of path
-     */
-    public static final int TYPE_CHILDREN = 2;
-
-    /**
-     * Match descendant nodes or self of path
-     */
-    public static final int TYPE_DESCENDANT_SELF = 3;
-
-    /**
-     * The base path
-     */
-    private final String path;
-
-    /**
-     * Converted path without indexes. /bla[2] -> /bla
-     */
-    private final String indexlessPath;
-
-    /**
-     * The match type for this query node
-     */
-    private final int type;
-
-    /**
-     * Flag indicating if this path query contains indexed location steps
-     */
-    private final boolean indexedName;
-
-    /**
-     * Creates a new <code>PathQueryNode</code> instance.
-     *
-     * @param parent this parent node of this query node.
-     * @param path   the base path.
-     * @param type   one of {@link #TYPE_CHILDREN}, {@link #TYPE_DESCENDANT_SELF},
-     *               {@link #TYPE_EXACT}
-     */
-    public PathQueryNode(QueryNode parent, String path, int type) {
+    public PathQueryNode(QueryNode parent) {
-        if (type < TYPE_EXACT || type > TYPE_DESCENDANT_SELF) {
-            throw new IllegalArgumentException(String.valueOf(type));
-        }
-        this.path = path;
-        this.type = type;
-        this.indexedName = (path.indexOf('[') > -1);
-        if (indexedName) {
-            // also create an indexless path
-            StringBuffer tmp = new StringBuffer(path);
-            int idx;
-            while ((idx = tmp.indexOf("[")) > -1) {
-                int end = tmp.indexOf("]", idx);
-                if (end > -1) {
-                    tmp.replace(idx, end, "");
-                } else {
-                    // should never happen
-                    // FIXME do some error logging?
-                    break;
-                }
-            }
-            this.indexlessPath = tmp.toString();
-        } else {
-            this.indexlessPath = path;
-        }
-
-     * Returns the unmodified path for this query node, as passed to the
-     * constructor.
-     *
-     * @return the unmodified path for this query node.
+     * Adds a path step to this <code>PathQueryNode</code>.
+     * @param step the step to add.
-    public String getPath() {
-        return path;
+    public void addPathStep(LocationStepQueryNode step) {
+        addOperand(step);
-     * Returns a normalized path without indexes.
-     *
-     * @return a normalized path without indexes.
+     * Returns an array of all currently set location step nodes.
+     * @return an array of all currently set location step nodes.
-    public String getIndexlessPath() {
-        return indexlessPath;
+    public LocationStepQueryNode[] getPathSteps() {
+        if (operands == null) {
+            return EMPTY;
+        } else {
+            return (LocationStepQueryNode[]) operands.toArray(new LocationStepQueryNode[operands.size()]);
+        }
-     * Returns the type of this <code>PathQueryNode</code>.
-     *
-     * @return one of {@link #TYPE_CHILDREN}, {@link #TYPE_DESCENDANT_SELF},
-     *         {@link #TYPE_EXACT}
-     */
-    public int getType() {
-        return type;
-    }
-
-    /**
-     * Returns <code>true</code> if the path contains an index. E.g. a location
-     * step in XPath has a position predicate. If the path does not contain any
-     * indexes <code>false</code> is returned.
-     *
-     * @return <code>true</code> if the path contains an indexed location step.
-     */
-    public boolean hasIndexedName() {
-        return indexedName;
-    }
-
-
-    /**
-        StringBuffer jcrql = new StringBuffer("LOCATION ");
-        jcrql.append(path);
-        if (type == TYPE_CHILDREN) {
-            jcrql.append("/*");
-        } else if (type == TYPE_DESCENDANT_SELF) {
-            jcrql.append("//");
+        StringBuffer sb = new StringBuffer("LOCATION \"");
+        LocationStepQueryNode[] steps = getPathSteps();
+        for (int i = 0; i < steps.length; i++) {
+            if (steps[i].getNameTest() == null
+                    || steps[i].getNameTest().length() > 0) {
+                sb.append('/');
+            }
+            sb.append(steps[i].toJCRQLString());
-        return jcrql.toString();
+        sb.append('"');
+        return sb.toString();
+    }
+
+
+    /**
+     * Returns a JCR SQL representation for this query node.
+     *
+     * @return a JCR SQL representation for this query node.
+     */
+    public String toJCRSQLString() {
+        // FIXME implement namespace awareness
+        StringBuffer sb = new StringBuffer("\"jcr:path\"='");
+        LocationStepQueryNode[] steps = getPathSteps();
+        for (int i = 0; i < steps.length; i++) {
+            if (steps[i].getNameTest() == null
+                    || steps[i].getNameTest().length() > 0) {
+                sb.append('/');
+            }
+            sb.append(steps[i].toJCRSQLString());
+        }
+        sb.append('\'');
+        return sb.toString();
-        // todo implement correctly.
-        return "";
+        StringBuffer sb = new StringBuffer();
+        LocationStepQueryNode[] steps = getPathSteps();
+        for (int i = 0; i < steps.length; i++) {
+            if (steps[i].getNameTest() == null
+                    || steps[i].getNameTest().length() > 0) {
+                sb.append('/');
+            }
+            sb.append(steps[i].toXPathString());
+        }
+        return sb.toString();

JCR-1154: Throw DataStoreException instead of IOException

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@591286 13f79535-47bb-0310-9956-ffa450edef68

+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+    
+    /** Logger instance */
+    private static Logger log = LoggerFactory.getLogger(PropertyState.class);
-                    values[i] = InternalValue.create(new InputStream() {
-
-                        private long consumed = 0;
-
-                        public int read() throws IOException {
-                            if (consumed >= length) {
-                                return -1;  // eof
-                            }
-                            int b = stream.read();
-                            consumed++;
-                            return b;
-                        }
-
-                        public int read(byte[] b, int off, int len) throws IOException {
-                            if (consumed >= length) {
-                                return -1;  // eof
-                            }
-                            if ((consumed + len) > length) {
-                                len = (int) (length - consumed);
-                            }
-                            int read = stream.read(b, off, len);
-                            consumed += read;
-                            return read;
-                        }
-
-                        public long skip(long n) throws IOException {
-                            if (consumed >= length && n > 0) {
-                                return -1;  // eof
-                            }
-                            if ((consumed + n) > length) {
-                                n = length - consumed;
-                            }
-                            long skipped = stream.skip(n);
-                            consumed += skipped;
-                            return skipped;
-                        }
-
-                        public void close() {
-                            // nop
-                        }
-                    });
+                    try {
+                        values[i] = createInternalValueFromInputStream(stream, length);
+                    } catch (RepositoryException e) {
+                        String msg = "Failed to create internal value: " + e.getMessage();
+                        log.error(msg, e);
+                        throw new IOException(msg);
+                    }
+                    
+    
+    private InternalValue createInternalValueFromInputStream(final InputStream stream, final long length) throws RepositoryException {
+        return InternalValue.create(new InputStream() {
+            
+            private long consumed = 0;
+
+            public int read() throws IOException {
+                if (consumed >= length) {
+                    return -1;  // eof
+                }
+                int b = stream.read();
+                consumed++;
+                return b;
+            }
+
+            public int read(byte[] b, int off, int len) throws IOException {
+                if (consumed >= length) {
+                    return -1;  // eof
+                }
+                if ((consumed + len) > length) {
+                    len = (int) (length - consumed);
+                }
+                int read = stream.read(b, off, len);
+                consumed += read;
+                return read;
+            }
+
+            public long skip(long n) throws IOException {
+                if (consumed >= length && n > 0) {
+                    return -1;  // eof
+                }
+                if ((consumed + n) > length) {
+                    n = length - consumed;
+                }
+                long skipped = stream.skip(n);
+                consumed += skipped;
+                return skipped;
+            }
+
+            public void close() {
+                // nop
+            }
+        });
+    }

JCR-2272: Errors during concurrent session import of nodes with same UUIDs

Merge changes back to trunk.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1176546 13f79535-47bb-0310-9956-ffa450edef68

+import javax.jcr.InvalidItemStateException;
+import javax.jcr.RepositoryException;
-    public NodeState createNew(NodeId id, Name nodeTypeName,
-                               NodeId parentId)
-            throws IllegalStateException {
+    public NodeState createNew(
+            NodeId id, Name nodeTypeName, NodeId parentId)
+            throws RepositoryException {
-            throw new IllegalStateException("Not in edit mode");
+            throw new RepositoryException("Not in edit mode");
-        NodeState state = new NodeState(id, nodeTypeName, parentId,
-                ItemState.STATUS_NEW, false);
+        boolean nonRandomId = true;
+        if (id == null) {
+            id = getNodeIdFactory().newNodeId();
+            nonRandomId = false;
+        }
+
+        NodeState state = new NodeState(
+                id, nodeTypeName, parentId, ItemState.STATUS_NEW, false);
+
+        if (nonRandomId && !changeLog.deleted(id)
+                && sharedStateMgr.hasItemState(id)) {
+            throw new InvalidItemStateException(
+                    "Node " + id + " already exists");
+        }
+
+     * Returns the local node state below the given transient one. If given
+     * a fresh new node state, then a new local state is created and added
+     * to the change log.
+     *
+     * @param transientState transient state
+     * @return local node state
+     * @throws RepositoryException if the local state could not be created
+     */
+    public NodeState getOrCreateLocalState(NodeState transientState)
+            throws RepositoryException {
+        NodeState localState = (NodeState) transientState.getOverlayedState();
+        if (localState == null) {
+            // The transient node state is new, create a new local state
+            localState = new NodeState(
+                    transientState.getNodeId(),
+                    transientState.getNodeTypeName(),
+                    transientState.getParentId(),
+                    ItemState.STATUS_NEW,
+                    false);
+            changeLog.added(localState);
+            localState.setContainer(this);
+            try {
+                transientState.connect(localState);
+            } catch (ItemStateException e) {
+                // should never happen
+                throw new RepositoryException(e);
+            }
+        }
+        return localState;
+    }
+
+    /**
-                    // underlying state has been permanently created
-                    local.pull();
-                    local.setStatus(ItemState.STATUS_EXISTING);
-                    cache.cache(local);
+                    if (local.isNode() && local.getOverlayedState() != created) {
+                        // mid-air collision of concurrent node state creation
+                        // with same id (JCR-2272)
+                        if (local.getStatus() == ItemState.STATUS_NEW) {
+                            local.setStatus(ItemState.STATUS_UNDEFINED); // we need a state that is != NEW
+                        }
+                    } else {
+                        if (local.getOverlayedState() == created) {
+                            // underlying state has been permanently created
+                            local.pull();
+                            local.setStatus(ItemState.STATUS_EXISTING);
+                            cache.cache(local);
+                        }
+                    }

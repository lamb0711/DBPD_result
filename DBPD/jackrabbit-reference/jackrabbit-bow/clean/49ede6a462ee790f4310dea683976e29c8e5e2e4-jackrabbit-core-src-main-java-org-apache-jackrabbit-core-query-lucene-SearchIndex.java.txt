JCR-1820: Ensure queries are not blocked during large updates

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@706649 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.collections.iterators.AbstractIteratorDecorator;
+import org.apache.commons.collections.iterators.TransformIterator;
+import org.apache.commons.collections.collection.TransformedCollection;
+import org.apache.commons.collections.IteratorUtils;
+import org.apache.commons.collections.Transformer;
+import java.util.Collection;
-     * {@link MultiIndex#update(java.util.Iterator, java.util.Iterator)} and
+     * {@link MultiIndex#update(Collection, Collection)} and
-        final Set removedNodeIds = new HashSet();
-        final Set addedNodeIds = new HashSet();
-        index.update(new AbstractIteratorDecorator(remove) {
-            public Object next() {
-                NodeId nodeId = (NodeId) super.next();
-                removedNodeIds.add(nodeId);
-                return nodeId.getUUID();
-            }
-        }, new AbstractIteratorDecorator(add) {
-            public Object next() {
-                NodeState state = (NodeState) super.next();
-                if (state == null) {
-                    return null;
-                }
-                addedNodeIds.add(state.getNodeId());
-                removedNodeIds.remove(state.getNodeId());
-                Document doc = null;
-                try {
-                    doc = createDocument(state, getNamespaceMappings(),
-                            index.getIndexFormatVersion());
-                    retrieveAggregateRoot(state, aggregateRoots);
-                } catch (RepositoryException e) {
-                    log.warn("Exception while creating document for node: "
-                            + state.getNodeId() + ": " + e.toString());
-                }
-                return doc;
-            }
-        });
+        final HashSet removedUUIDs = new HashSet();
+        final Set addedUUIDs = new HashSet();
+
+        index.update(IteratorUtils.toList(new TransformIterator(remove,
+                new Transformer() {
+                    public Object transform(Object input) {
+                        UUID uuid = ((NodeId) input).getUUID();
+                        removedUUIDs.add(uuid);
+                        return uuid;
+                    }
+                })), IteratorUtils.toList(new TransformIterator(add,
+                new Transformer() {
+                    public Object transform(Object input) {
+                        NodeState state = (NodeState) input;
+                        if (state == null) {
+                            return null;
+                        }
+                        UUID uuid = state.getNodeId().getUUID();
+                        addedUUIDs.add(uuid);
+                        removedUUIDs.remove(uuid);
+                        Document doc = null;
+                        try {
+                            doc = createDocument(state, getNamespaceMappings(),
+                                    index.getIndexFormatVersion());
+                            retrieveAggregateRoot(state, aggregateRoots);
+                        } catch (RepositoryException e) {
+                            log.warn("Exception while creating document for node: "
+                                    + state.getNodeId() + ": " + e.toString());
+                        }
+                        return doc;
+                    }
+                })));
-        aggregateRoots.keySet().removeAll(addedNodeIds);
+        aggregateRoots.keySet().removeAll(addedUUIDs);
-        // based on removed NodeIds get affected aggregate root nodes
-        retrieveAggregateRoot(removedNodeIds, aggregateRoots);
+        // based on removed UUIDs get affected aggregate root nodes
+        retrieveAggregateRoot(removedUUIDs, aggregateRoots);
-            index.update(new AbstractIteratorDecorator(
-                    aggregateRoots.keySet().iterator()) {
-                public Object next() {
-                    return ((NodeId) super.next()).getUUID();
-                }
-            }, new AbstractIteratorDecorator(aggregateRoots.values().iterator()) {
-                public Object next() {
-                    NodeState state = (NodeState) super.next();
-                    try {
-                        return createDocument(state, getNamespaceMappings(),
-                                index.getIndexFormatVersion());
-                    } catch (RepositoryException e) {
-                        log.warn("Exception while creating document for node: "
-                                + state.getNodeId() + ": " + e.toString());
-                    }
-                    return null;
-                }
-            });
+            Collection modified = TransformedCollection.decorate(
+                    new ArrayList(),
+                    new Transformer() {
+                        public Object transform(Object input) {
+                            NodeState state = (NodeState) input;
+                            try {
+                                return createDocument(state,
+                                        getNamespaceMappings(),
+                                        index.getIndexFormatVersion());
+                            } catch (RepositoryException e) {
+                                log.warn("Exception while creating document for node: "
+                                        + state.getNodeId() + ": " + e.toString());
+                            }
+                            return null;
+                        }
+                    });
+            modified.addAll(aggregateRoots.values());
+            index.update(aggregateRoots.keySet(), modified);
-     * @param map   aggregate roots are collected in this map. Key=NodeId,
+     * @param map   aggregate roots are collected in this map. Key=UUID,
-                        map.put(root.getNodeId(), root);
+                        map.put(root.getNodeId().getUUID(), root);
-     * Retrieves the root of the indexing aggregate for <code>removedNodeIds</code>
+     * Retrieves the root of the indexing aggregate for <code>removedUUIDs</code>
-     * @param removedNodeIds the ids of removed nodes.
+     * @param removedUUIDs   the UUIDs of removed nodes.
-     *                       Key=NodeId, value=NodeState.
+     *                       Key=UUID, value=NodeState.
-    protected void retrieveAggregateRoot(Set removedNodeIds, Map map) {
+    protected void retrieveAggregateRoot(Set removedUUIDs, Map map) {
-                        Iterator it = removedNodeIds.iterator();
+                        Iterator it = removedUUIDs.iterator();
-                            NodeId id = (NodeId) it.next();
+                            UUID uuid = (UUID) it.next();
-                                    id.getUUID().toString());
+                                    uuid.toString());
-                                String uuid = doc.get(FieldNames.UUID);
-                                NodeId nId = new NodeId(UUID.fromString(uuid));
-                                map.put(nId, ism.getItemState(nId));
+                                NodeId nId = new NodeId(UUID.fromString(
+                                        doc.get(FieldNames.UUID)));
+                                map.put(nId.getUUID(), ism.getItemState(nId));

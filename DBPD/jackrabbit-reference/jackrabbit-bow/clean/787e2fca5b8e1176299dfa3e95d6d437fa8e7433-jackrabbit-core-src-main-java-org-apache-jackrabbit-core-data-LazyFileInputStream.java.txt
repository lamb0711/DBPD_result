JCR-2067 FileDataStore: only open a stream when really necessary - close() can throw a NullPointerException

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@779081 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.FileDescriptor;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-    private static Logger log = LoggerFactory.getLogger(LazyFileInputStream.class);
+    /**
+     * The file descriptor to use.
+     */
+    protected final FileDescriptor fd;
-     * Create a lazy input stream for the given file.
+     * Creates a new <code>LazyFileInputStream</code> for the given file. If the
+     * file is unreadable, a FileNotFoundException is thrown.
-     * 
+     *
+     * @throws java.io.FileNotFoundException
-    public LazyFileInputStream(File file) throws FileNotFoundException {
+    public LazyFileInputStream(File file)
+            throws FileNotFoundException {
-        }        
+        }
+        this.fd = null;
+    }
+
+    /**
+     * Creates a new <code>LazyFileInputStream</code> for the given file
+     * descriptor.
+     * The file is not opened until the first byte is read from the stream.
+     *
+     * @param fdObj
+     */
+    public LazyFileInputStream(FileDescriptor fd) {
+        super(null);
+        this.file = null;
+        this.fd = fd;
+    }
+
+    /**
+     * Creates a new <code>LazyFileInputStream</code> for the given file. If the
+     * file is unreadable, a FileNotFoundException is thrown.
+     *
+     * @param name
+     * @throws java.io.FileNotFoundException
+     */
+    public LazyFileInputStream(String name) throws FileNotFoundException {
+        this(new File(name));
-     * 
-     * @throws IOException
+     *
+     * @throws java.io.IOException
-    protected void openStream() throws IOException {
+    protected void open() throws IOException {
-            in = new FileInputStream(file);
+            if (fd != null) {
+                in = new FileInputStream(fd);
+            } else {
+                in = new FileInputStream(file);
+            }
-    
+
-        openStream();
+        open();
-    public int read(byte[] b) throws IOException {
-        return read(b, 0, b.length);
-    }
-
-    public int read(byte[] b, int off, int len) throws IOException {
-        openStream();
-        return super.read(b, off, len);
+    public int available() throws IOException {
+        open();
+        return super.available();
-        super.close();
-    }
-
-    public long skip(long n) throws IOException {
-        openStream();
-        return super.skip(n);
-    }
-
-    public int available() throws IOException {
-        openStream();
-        return super.available();
-    }
-
-    public void mark(int readlimit) {
-        try {
-            openStream();
-        } catch (IOException e) {
-            log.info("Error getting underlying stream: ", e);
+        
+        // only close the file if it was in fact opened
+        if (in != null) {
+            super.close();
-        super.mark(readlimit);
-    public void reset() throws IOException {
-        openStream();
+    public synchronized void reset() throws IOException {
+        open();
-            openStream();
+            open();
-            log.info("Error getting underlying stream: ", e);
-            return false;
+            throw new IllegalStateException(e.toString());
+    public synchronized void mark(int readlimit) {
+        try {
+            open();
+        } catch (IOException e) {
+            throw new IllegalStateException(e.toString());
+        }
+        super.mark(readlimit);
+    }
+
+    public long skip(long n) throws IOException {
+        open();
+        return super.skip(n);
+    }
+
+    public int read(byte[] b) throws IOException {
+        open();
+        return super.read(b, 0, b.length);
+    }
+
+    public int read(byte[] b, int off, int len) throws IOException {
+        open();
+        return super.read(b, off, len);
+    }
+

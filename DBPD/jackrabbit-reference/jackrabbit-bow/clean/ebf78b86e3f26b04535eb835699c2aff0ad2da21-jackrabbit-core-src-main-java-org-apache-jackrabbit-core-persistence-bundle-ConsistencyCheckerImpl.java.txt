JCR-3525 code cleanup and java doc comments; remove the option of checking in batches instead of all at once: this broke during a previous refactoring and is not a user friendly option since it is very slow

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1448555 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.Name;
-    /** the default logger */
-     * Whether to load all node infos before checking or to check nodes as they are loaded.
-     * The former is magnitudes faster but requires more memory.
-     */
-    private static final boolean CHECKAFTERLOADING = Boolean.getBoolean("org.apache.jackrabbit.checker.checkafterloading");
-
-    /**
-    private static final NameFactory NF = NameFactoryImpl.getInstance();
-
-    private final List<ConsistencyCheckerError> errors = new ArrayList<ConsistencyCheckerError>();
+    private List<ConsistencyCheckerError> errors;
+        errors = new ArrayList<ConsistencyCheckerError>();
-        if (!errors.isEmpty()) {
+        if (hasErrors()) {
-        for (ConsistencyCheckerError error : errors) {
-            reportItems.add(error.getReportItem());
+        if (hasErrors()) {
+            for (ConsistencyCheckerError error : errors) {
+                reportItems.add(error.getReportItem());
+            }
-                        bundle.setModCount((short) (bundle.getModCount()+1));
+    private boolean hasErrors() {
+        return errors != null && !errors.isEmpty();
+    }
+
-        for (ConsistencyCheckerError error : errors) {
-            if (error.isRepairable()) {
-                return true;
+        if (hasErrors()) {
+            for (ConsistencyCheckerError error : errors) {
+                if (error.isRepairable()) {
+                    return true;
+                }
+            // check all nodes
-                        NodeId id = entry.getKey();
-                        lastId = id;
+                        lastId = entry.getKey();
-                        if (!CHECKAFTERLOADING) {
-                            // check immediately
-                            NodeInfo nodeInfo = entry.getValue();
-                            checkBundleConsistency(id, nodeInfo, batch);
-                        }
-                    if (CHECKAFTERLOADING) {
-                        allInfos.putAll(batch);
-                    }
+                    allInfos.putAll(batch);
-                if (CHECKAFTERLOADING) {
-                    // check info
-                    for (Map.Entry<NodeId, NodeInfo> entry : allInfos.entrySet()) {
-                        checkBundleConsistency(entry.getKey(), entry.getValue(), allInfos);
-                    }
+                for (Map.Entry<NodeId, NodeInfo> entry : allInfos.entrySet()) {
+                    checkBundleConsistency(entry.getKey(), entry.getValue(), allInfos);
-            } catch (ItemStateException ex) {
-                throw new RepositoryException("getting nodeIds", ex);
+
+            } catch (ItemStateException e) {
+                throw new RepositoryException("Error loading nodes", e);
+            } finally {
+                NodeInfo.clearPool();
-            // 1) convert uuid array to modifiable list
-            // 2) for each uuid do
-            // a) load node bundle
-            // b) check bundle, store any bundle-to-be-modified in collection
-            // c) if recursive, add child uuids to list of uuids
-
-            // convert uuid string array to list of UUID objects
-            // iterate over UUIDs (including ones that are newly added inside
-            // the loop!)
-                    // load the node from the database
-                    NodePropBundle bundle = pm.loadBundle(id);
-
+                    final NodePropBundle bundle = pm.loadBundle(id);
-                            log.info(pm + ": checked " + count + "/"
-                                    + idList.size() + " bundles...");
+                            log.info(pm + ": checked " + count + "/" + idList.size() + " bundles...");
-                } catch (ItemStateException e) {
-                    // problem already logged (loadBundle called with
-                    // logDetailedErrors=true)
+                } catch (ItemStateException ignored) {
+                    // problem already logged
-        // clear the NodeId pool
-        NodeInfo.clearPool();
-
-     * @param id node id for the bundle to check
+     * @param nodeId node id for the bundle to check
-    private void checkBundleConsistency(NodeId id, NodeInfo nodeInfo, Map<NodeId, NodeInfo> infos) {
+    private void checkBundleConsistency(NodeId nodeId, NodeInfo nodeInfo, Map<NodeId, NodeInfo> infos) {
-        if (isVirtualNode(id)) {
+        if (!isRoot(nodeId) && isVirtualNode(nodeId)) {
-            listener.startCheck(id.toString());
+            listener.startCheck(nodeId.toString());
-            // skip check for system nodes (root, system root, version storage, node types)
-            if (childNodeId.toString().endsWith("babecafebabe")) {
+            if (isVirtualNode(childNodeId)) {
-                addError(new MissingChild(id, childNodeId));
+                addError(new MissingChild(nodeId, childNodeId));
-                if (!id.equals(childNodeInfo.getParentId())) {
-                    addError(new DisconnectedChild(id, childNodeId, childNodeInfo.getParentId()));
+                if (!nodeId.equals(childNodeInfo.getParentId())) {
+                    addError(new DisconnectedChild(nodeId, childNodeId, childNodeInfo.getParentId()));
-        // skip root nodes (that point to itself)
-        if (parentId != null && !id.toString().endsWith("babecafebabe")) {
+        // skip root nodes
+        if (parentId != null && !isRoot(nodeId)) {
-                addError(new OrphanedNode(id, parentId));
+                addError(new OrphanedNode(nodeId, parentId));
-                    if (childNodeId.equals(id)){
+                    if (childNodeId.equals(nodeId)){
-                    addError(new AbandonedNode(id, parentId));
+                    addError(new AbandonedNode(nodeId, parentId));
-    /**
-     * @return whether the id is for a virtual node (not needing checking)
-     */
-    protected boolean isVirtualNode(NodeId id) {
-        String s = id.toString();
-        return !isRoot(s) && s.endsWith("babecafebabe");
+    protected boolean isVirtualNode(NodeId nodeId) {
+        return nodeId.toString().endsWith("babecafebabe");
-    private boolean isRoot(String id) {
-        return "cafebabe-cafe-babe-cafe-babecafebabe".equals(id);
+    private boolean isRoot(NodeId nodeId) {
+        return "cafebabe-cafe-babe-cafe-babecafebabe".equals(nodeId.toString());
-            bundle.markOld(); // use UPDATE instead of INSERT
+            bundle.markOld();
+            bundle.setModCount((short) (bundle.getModCount()+1));
+    /**
+     * A missing child is when the node referred to by a child node entry
+     * does not exist.
+     *
+     * This type of error is repaired by removing the corrupted child node entry.
+     */
+    /**
+     * A disconnected child is when a child node entry refers to a node
+     * that exists, but that node actually has a different parent.
+     *
+     * This type of error is repaired by removing the corrupted child node entry.
+     */
+    /**
+     * An orphaned node is a node whose parent does not exist.
+     *
+     * This type of error is repaired by reattaching the orphan to
+     * a special purpose 'lost and found' node.
+     */
-                lfBundle.addChildNodeEntry(NF.create("", nodeName), nodeId);
+                final NameFactory nameFactory = NameFactoryImpl.getInstance();
+                lfBundle.addChildNodeEntry(nameFactory.create("", nodeName), nodeId);
+    /**
+     * An abandoned node is a node that points to an existing node
+     * as its parent, but that parent node does not have a corresponding
+     * child node entry for the child.
+     *
+     * This type of error is repaired by adding the missing child node entry
+     * to the parent.
+     */
-            final String nodeName = createNodeName();
-            parentBundle.addChildNodeEntry(NF.create("{}" + nodeName), nodeId);
+            parentBundle.addChildNodeEntry(createNodeName(), nodeId);
-        private String createNodeName() {
-            int l = (int) System.currentTimeMillis();
-            int r = new Random().nextInt();
-            int n = l + r;
-            return Integer.toHexString(n);
+        private Name createNodeName() {
+            int n = (int) System.currentTimeMillis() + new Random().nextInt();
+            final String localName = Integer.toHexString(n);
+            final NameFactory nameFactory = NameFactoryImpl.getInstance();
+            return nameFactory.create("{}" + localName);

JCR-3151 SharedFieldCache can cause a memory leak

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1205361 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.WeakHashMap;
+
+import javax.jcr.PropertyType;
+
-import org.apache.lucene.search.FieldComparator;
-
-import javax.jcr.PropertyType;
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.WeakHashMap;
-        private final Comparable[] values;
+        private final Comparable<?>[] values;
-        public final Map<Integer, Comparable> valuesMap;
+        public final Map<Integer, Comparable<?>> valuesMap;
-        public ValueIndex(Comparable[] values, int setValues) {
+        public ValueIndex(Comparable<?>[] values, int setValues) {
-        public Comparable getValue(int i) {
+        public Comparable<?> getValue(int i) {
-        private Map<Integer, Comparable> getValuesMap(Comparable[] values, int setValues) {
-            Map<Integer, Comparable> map = new HashMap<Integer, Comparable>(setValues);
+        private static Map<Integer, Comparable<?>> getValuesMap(Comparable<?>[] values, int setValues) {
+            Map<Integer, Comparable<?>> map = new HashMap<Integer, Comparable<?>>(setValues);
-        private boolean isSparse(Comparable[] values, int setValues) {
+        private static boolean isSparse(Comparable<?>[] values, int setValues) {
-     * @param comparator the field comparator instance.
-    public ValueIndex getValueIndex(IndexReader reader,
-                                    String field,
-                                    String prefix,
-                                    FieldComparator comparator)
-            throws IOException {
+    public ValueIndex getValueIndex(IndexReader reader, String field,
+            String prefix) throws IOException {
-        ValueIndex ret = lookup(reader, field, prefix, comparator);
+        ValueIndex ret = lookup(reader, field, prefix);
-            Comparable[] retArray = new Comparable[reader.maxDoc()];
+            Comparable<?>[] retArray = new Comparable[reader.maxDoc()];
-            store(reader, field, prefix, comparator, value);
+            store(reader, field, prefix, value);
-    ValueIndex lookup(IndexReader reader, String field,
-                      String prefix, FieldComparator comparer) {
-        Key key = new Key(field, prefix, comparer);
-        synchronized (this) {
+    ValueIndex lookup(IndexReader reader, String field, String prefix) {
+        synchronized (cache) {
-            return readerCache.get(key);
+            return readerCache.get(new Key(field, prefix));
-    ValueIndex store(IndexReader reader, String field, String prefix,
-                 FieldComparator comparer, ValueIndex value) {
-        Key key = new Key(field, prefix, comparer);
-        synchronized (this) {
+    void store(IndexReader reader, String field, String prefix, ValueIndex value) {
+        synchronized (cache) {
-            return readerCache.put(key, value);
+            readerCache.put(new Key(field, prefix), value);
-    private Comparable getValue(String value, int type) {
+    private Comparable<?> getValue(String value, int type) {
-     * <code>prefix</code> and <code>comparator</code>.
+     * and <code>prefix</code>.
-        private final Object comparator;
-        Key(String field, String prefix, FieldComparator comparator) { 
+        Key(String field, String prefix) { 
-            this.comparator = comparator;
-         * instance and refers to the same field, prefix and comparator object.
+         * instance and refers to the same field and prefix.
-                        && other.prefix == prefix
-                        && other.comparator.equals(comparator);
+                        && other.prefix == prefix;
-         * Composes a hashcode based on the field, prefix and comparator.
+         * Composes a hashcode based on the field and prefix.
-            return field.hashCode() ^ prefix.hashCode() ^ comparator.hashCode();
+            return field.hashCode() ^ prefix.hashCode();

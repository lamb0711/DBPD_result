JCR-2715: Improved join query performance

Extend LuceneQueryFactory to handle more QOM constraints.
Simplify handling of bind variables.
Improve OperandEvaluator, including its javadocs.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1026361 13f79535-47bb-0310-9956-ffa450edef68

+import javax.jcr.query.qom.StaticOperand;
-class OperandEvaluator {
+/**
+ * Evaluator of QOM {@link Operand operands}. This class evaluates operands
+ * in the context of a {@link ValueFactory value factory}, a set of bind
+ * variables and possibly a query result row.
+ */
+public class OperandEvaluator {
+    /** Value factory */
+    /** Bind variables */
+    /**
+     * Creates an operand evaluator for the given value factory and set of
+     * bind variables.
+     *
+     * @param factory value factory
+     * @param variables bind variables
+     */
+    /**
+     * Returns the value of the given static operand
+     * ({@link Literal literal} or {@link BindVariableValue bind variable}).
+     *
+     * @param operand static operand to be evaluated
+     * @return evaluated value
+     * @throws RepositoryException if a named bind variable is not found,
+     *                             or if the operand type is unknown
+     */
+    public Value getValue(StaticOperand operand) throws RepositoryException {
+        if (operand instanceof Literal) {
+            Literal literal = (Literal) operand;
+            return literal.getLiteralValue();
+        } else if (operand instanceof BindVariableValue) {
+            BindVariableValue bvv = (BindVariableValue) operand;
+            Value value = variables.get(bvv.getBindVariableName());
+            if (value != null) {
+                return value;
+            } else {
+                throw new RepositoryException(
+                        "Unknown bind variable: " + bvv.getBindVariableName());
+            }
+        } else {
+            throw new UnsupportedRepositoryOperationException(
+                    "Unknown static operand type: " + operand);
+        }
+    }
+
+    /**
+     * Returns the value of the given operand in the context of the given row.
+     * This is a convenience method that uses a somewhat lossy best-effort
+     * mapping to evaluate multi-valued operands to a single value. Use the
+     * {@link #getValues(Operand, Row)} method for more accurate results.
+     *
+     * @param operand operand to be evaluated
+     * @param row query result row
+     * @return evaluated value
+     * @throws RepositoryException
+     */
-        switch (values.length) {
-        case 0:
-            return factory.createValue("");
-        case 1:
+        if (values.length == 1) {
-        default:
+        } else {
-     * Evaluates the given operand against the given row.
+     * Evaluates the given operand in the context of the given row.
-     * @param operand operand
-     * @param row row
+     * @param operand operand to be evaluated
+     * @param row query result row
-        if (operand instanceof BindVariableValue) {
-            return getBindVariableValues((BindVariableValue) operand);
+        if (operand instanceof StaticOperand) {
+            StaticOperand so = (StaticOperand) operand;
+            return new Value[] { getValue(so) };
-            return getFullTextSearchScoreValues(
-                    (FullTextSearchScore) operand, row);
+            FullTextSearchScore ftss = (FullTextSearchScore) operand;
+            double score = row.getScore(ftss.getSelectorName());
+            return new Value[] { factory.createValue(score) };
+        } else if (operand instanceof NodeName) {
+            NodeName nn = (NodeName) operand;
+            Node node = row.getNode(nn.getSelectorName());
+            return new Value[] { factory.createValue(node.getName(), NAME) };
-        } else if (operand instanceof Literal) {
-            return getLiteralValues((Literal) operand);
-        } else if (operand instanceof NodeLocalName) {
-            return getNodeLocalNameValues((NodeLocalName) operand, row);
-        } else if (operand instanceof NodeName) {
-            return getNodeNameValues((NodeName) operand, row);
-        } else if (operand instanceof PropertyValue) {
-            return getPropertyValues((PropertyValue) operand, row);
+        } else if (operand instanceof NodeLocalName) {
+            return getNodeLocalNameValues((NodeLocalName) operand, row);
+        } else if (operand instanceof PropertyValue) {
+            return getPropertyValues((PropertyValue) operand, row);
-     * Returns the value of the given variable value operand at the given row.
-     *
-     * @param operand variable value operand
-     * @return value of the operand at the given row
-     */
-    private Value[] getBindVariableValues(BindVariableValue operand) {
-        Value value = variables.get(operand.getBindVariableName());
-        if (value != null) {
-            return new Value[] { value };
-        } else {
-            return new Value[0];
-        }
-    }
-
-    /**
-     * Returns the value of the given search score operand at the given row.
-     *
-     * @param operand search score operand
-     * @param row row
-     * @return value of the operand at the given row
-     * @throws RepositoryException if the operand can't be evaluated
-     */
-    private Value[] getFullTextSearchScoreValues(
-            FullTextSearchScore operand, Row row) throws RepositoryException {
-        double score = row.getScore(operand.getSelectorName());
-        return new Value[] { factory.createValue(score) };
-    }
-
-    /**
-     * Returns the value of the given literal value operand.
-     *
-     * @param operand literal value operand
-     * @return value of the operand
-     */
-    private Value[] getLiteralValues(Literal operand) {
-        return new Value[] { operand.getLiteralValue() };
-    }
-
-    /**
+     * Returns the values of the given upper case operand at the given row.
+     *
+     * @param operand upper case operand
+     * @param row row
+     * @return values of the operand at the given row
+     * @throws RepositoryException if the operand can't be evaluated
+     */
+    private Value[] getUpperCaseValues(UpperCase operand, Row row)
+            throws RepositoryException {
+        Value[] values = getValues(operand.getOperand(), row);
+        for (int i = 0; i < values.length; i++) {
+            String value = values[i].getString();
+            String upper = value.toUpperCase(ENGLISH);
+            if (!value.equals(upper)) {
+                values[i] = factory.createValue(upper);
+            }
+        }
+        return values;
+    }
+
+    /**
-     * Returns the value of the given node name operand at the given row.
-     *
-     * @param operand node name operand
-     * @param row row
-     * @return value of the operand at the given row
-     * @throws RepositoryException if the operand can't be evaluated
-     */
-    private Value[] getNodeNameValues(NodeName operand, Row row)
-            throws RepositoryException {
-        Node node = row.getNode(operand.getSelectorName());
-        return new Value[] { factory.createValue(node.getName(), NAME) };
-    }
-
-    /**
-     * Returns the values of the given upper case operand at the given row.
-     *
-     * @param operand upper case operand
-     * @param row row
-     * @return values of the operand at the given row
-     * @throws RepositoryException if the operand can't be evaluated
-     */
-    private Value[] getUpperCaseValues(UpperCase operand, Row row)
-            throws RepositoryException {
-        Value[] values = getValues(operand.getOperand(), row);
-        for (int i = 0; i < values.length; i++) {
-            String value = values[i].getString();
-            String upper = value.toLowerCase(ENGLISH);
-            if (!value.equals(upper)) {
-                values[i] = factory.createValue(upper);
-            }
-        }
-        return values;
-    }
-
-    /**

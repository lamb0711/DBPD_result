JCR-446: Use a read-write lock to prevent logins during shutdown (and vice versa)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@447148 13f79535-47bb-0310-9956-ffa450edef68

+import EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock;
+
+     * Shutdown lock for guaranteeing that no new sessions are started during
+     * repository shutdown and that a repository shutdown is not initiated
+     * during a login. Each session login acquires a read lock while the
+     * repository shutdown requires a write lock. This guarantees that there
+     * can be multiple concurrent logins when the repository is not shutting
+     * down, but that only a single shutdown and no concurrent logins can
+     * happen simultaneously.
+     */
+    private final ReadWriteLock shutdownLock = new WriterPreferenceReadWriteLock();
+
+    /**
+
-     * Shuts down this repository.
+     * Shuts down this repository. The shutdown is guarded by a shutdown lock
+     * that prevents any new sessions from being started simultaneously.
-    public synchronized void shutdown() {
-        // check status of this instance
-        if (disposed) {
-            // there's nothing to do here because the repository has already been shut down
-            return;
+    public void shutdown() {
+        try {
+            shutdownLock.writeLock().acquire();
+        } catch (InterruptedException e) {
+            // TODO: Should this be a checked exception?
+            throw new RuntimeException("Shutdown lock could not be acquired", e);
+        try {
+            // check status of this instance
+            if (!disposed) {
+                doShutdown();
+            }
+        } finally {
+            shutdownLock.writeLock().release();
+        }
+    }
+
+    /**
+     * Private method that performs the actual shutdown after the shutdown
+     * lock has been acquired by the {@link #shutdown()} method.
+     */
+    private synchronized void doShutdown() {
-        // check sanity of this instance
-        sanityCheck();
-
-        if (workspaceName == null) {
-            workspaceName = repConfig.getDefaultWorkspaceName();
+        try {
+            shutdownLock.readLock().acquire();
+        } catch (InterruptedException e) {
+            throw new RepositoryException("Login lock could not be acquired", e);
-        // check if workspace exists (will throw NoSuchWorkspaceException if not)
-        getWorkspaceInfo(workspaceName);
+        try {
+            // check sanity of this instance
+            sanityCheck();
-        if (credentials == null) {
-            try {
+            if (workspaceName == null) {
+                workspaceName = repConfig.getDefaultWorkspaceName();
+            }
+
+            // check if workspace exists (will throw NoSuchWorkspaceException if not)
+            getWorkspaceInfo(workspaceName);
+
+            if (credentials == null) {
-            } catch (SecurityException se) {
-                throw new LoginException(
-                        "Unable to access authentication information", se);
-            } catch (AccessDeniedException ade) {
-                // authenticated subject is not authorized for the specified workspace
-                throw new LoginException("Workspace access denied", ade);
-        }
-
-        // login either using JAAS or our own LoginModule
-        AuthContext authCtx;
-        try {
+            // login either using JAAS or our own LoginModule
+            AuthContext authCtx;
+
+            // create session
+            return createSession(authCtx, workspaceName);
+        } catch (SecurityException se) {
+            throw new LoginException(
+                    "Unable to access authentication information", se);
-        }
-
-        // create session
-        try {
-            return createSession(authCtx, workspaceName);
-            throw new LoginException(ade.getMessage());
+            throw new LoginException("Workspace access denied", ade);
+        } finally {
+            shutdownLock.readLock().release();

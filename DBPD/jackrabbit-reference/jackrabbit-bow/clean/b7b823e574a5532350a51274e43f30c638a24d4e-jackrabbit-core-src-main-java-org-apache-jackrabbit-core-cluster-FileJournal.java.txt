JCR-702: Allow database as backend for clustering
JCR-703: Add signature and major/minor version to the journal files used for clustering 


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@495239 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.NodeId;
-import org.apache.jackrabbit.core.nodetype.NodeTypeDef;
-import org.apache.jackrabbit.core.nodetype.compact.ParseException;
-import org.apache.jackrabbit.core.state.ChangeLog;
-import org.apache.jackrabbit.core.state.ItemState;
-import org.apache.jackrabbit.core.state.NodeState;
-import org.apache.jackrabbit.core.state.PropertyState;
-import org.apache.jackrabbit.core.observation.EventState;
-import org.apache.jackrabbit.core.observation.EventStateCollection;
-import org.apache.jackrabbit.name.Path;
-import org.apache.jackrabbit.name.QName;
-import org.apache.jackrabbit.name.NoPrefixDeclaredException;
-import org.apache.jackrabbit.name.NameException;
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
-import java.util.Iterator;
-import java.util.Set;
-import java.util.HashSet;
-import java.util.Collection;
-
-import EDU.oswego.cs.dl.util.concurrent.Mutex;
-
-import javax.jcr.observation.Event;
-import javax.jcr.Session;
- * latest revision file. When the current log file's size exceeds <code>maxSize</code>
+ * next available revision. When the current log file's size exceeds <code>maxSize</code>
- * <li><code>directory</code>: the shared directory where journal logs and read from
- * and written to; this is a required property with no default value</li>
+ * <li><code>directory</code>: the shared directory where journal logs and read from
+ * and written to; this is a required property with no default value</li>
+ * <p/>
+ * Technically, the global revision file contains the cumulated file position, i.e. if
+ * there are <code>N</code> journal files, with file lengths <code>L[1]</code>...
+ * <code>L[N]</code> (excluding the size of the file headers), then the global revision
+ * will be L[1]+...+L[N].
-public class FileJournal implements Journal {
+public class FileJournal extends AbstractJournal {
-     * Journal id.
-     */
-    private String id;
-
-    /**
-     * Namespace resolver used to map prefixes to URIs and vice-versa.
-     */
-    private NamespaceResolver resolver;
-
-    /**
-     * Record processor.
-     */
-    private RecordProcessor processor;
-
-    /**
-     * Revision file name, bean property.
-     */
-    private String revision;
-
-    /**
-     * Instance counter.
-     */
-    private FileRevision instanceRevision;
-
-    /**
-     * Global journal counter.
+     * Global revision counter.
-     * Mutex used when writing journal.
+     * Id as byte array.
-    private final Mutex writeMutex = new Mutex();
-
-    /**
-     * Current temporary journal log.
-     */
-    private File tempLog;
-
-    /**
-     * Current file record output.
-     */
-    private FileRecordOutput out;
-
-    /**
-     * Current file record.
-     */
-    private FileRecord record;
-
-    /**
-     * Last used session for event sources.
-     */
-    private Session lastSession;
+    private byte[] rawId;
-     * Bean getter for revision file.
-     * @return revision file
-     */
-    public String getRevision() {
-        return revision;
-    }
-
-    /**
-     * Bean setter for journal directory.
-     * @param revision directory used for journaling
-     */
-    public void setRevision(String revision) {
-        this.revision = revision;
-    }
-
-    /**
-    public void init(String id, RecordProcessor processor, NamespaceResolver resolver) throws JournalException {
-        this.id = id;
-        this.resolver = resolver;
-        this.processor = processor;
+    public void init(String id, RecordProcessor processor, NamespaceResolver resolver)
+            throws JournalException {
+        
+        super.init(id, processor, resolver);
-        if (revision == null) {
-            String msg = "Revision not specified.";
-            throw new JournalException(msg);
-        }
-        journal = new File(root, basename + "." + LOG_EXTENSION);
+        try {
+            rawId = toRawId(id);
+        } catch (IOException e) {
+            String msg = "Unable to convert '" + id + "' to its binary representation.";
+            throw new JournalException(msg, e);
+        }
-        instanceRevision = new FileRevision(new File(revision));
+        journal = new File(root, basename + "." + LOG_EXTENSION);
-        long instanceValue = instanceRevision.get();
+        long instanceValue = getLocalRevision();
-            FileRecordCursor cursor = new FileRecordCursor(logFiles,
-                    instanceValue, globalValue);
+            FileRecordCursor cursor = new FileRecordCursor(logFiles, instanceValue, globalValue);
-                    if (!record.getCreator().equals(id)) {
+                    if (!Arrays.equals(rawId, record.getCreator())) {
-                    instanceRevision.set(record.getNextRevision());
+                    setLocalRevision(record.getNextRevision());
-                String msg = "Unable to iterate over modified records: " + e.getMessage();
+                String msg = "Unable to iterate over modified records.";
-
-                try {
-                    cursor.close();
-                } catch (IOException e) {
-                    String msg = "I/O error while closing record cursor: " + e.getMessage();
-                    log.warn(msg);
-                }
+                cursor.close();
-            log.info("Sync finished, instance revision is: " + instanceRevision.get());
+            log.info("Sync finished, instance revision is: " + getLocalRevision());
-    void process(FileRecord record) throws JournalException {
-        log.info("Processing revision: " + record.getRevision());
-
-        FileRecordInput in = record.getInput(resolver);
-        String workspace = null;
+    private void process(FileRecord record) throws JournalException {
+        RecordInput in = record.getInput(resolver);
-            workspace = in.readString();
-            processor.start(workspace);
-
-            for (;;) {
-                char c = in.readChar();
-                if (c == '\0') {
-                    break;
-                }
-                if (c == 'N') {
-                    NodeOperation operation = NodeOperation.create(in.readByte());
-                    operation.setId(in.readNodeId());
-                    processor.process(operation);
-                } else if (c == 'P') {
-                    PropertyOperation operation = PropertyOperation.create(in.readByte());
-                    operation.setId(in.readPropertyId());
-                    processor.process(operation);
-                } else if (c == 'E') {
-                    int type = in.readByte();
-                    NodeId parentId = in.readNodeId();
-                    Path parentPath = in.readPath();
-                    NodeId childId = in.readNodeId();
-                    Path.PathElement childRelPath = in.readPathElement();
-                    QName ntName = in.readQName();
-
-                    Set mixins = new HashSet();
-                    int mixinCount = in.readInt();
-                    for (int i = 0; i < mixinCount; i++) {
-                        mixins.add(in.readQName());
-                    }
-                    String userId = in.readString();
-                    processor.process(createEventState(type, parentId, parentPath, childId,
-                            childRelPath, ntName, mixins, userId));
-                } else if (c == 'L') {
-                    NodeId nodeId = in.readNodeId();
-                    boolean isLock = in.readBoolean();
-                    if (isLock) {
-                        boolean isDeep = in.readBoolean();
-                        String owner = in.readString();
-                        processor.process(nodeId, isDeep, owner);
-                    } else {
-                        processor.process(nodeId);
-                    }
-                } else if (c == 'S') {
-                    String oldPrefix = in.readString();
-                    String newPrefix = in.readString();
-                    String uri = in.readString();
-                    processor.process(oldPrefix, newPrefix, uri);
-                } else if (c == 'T') {
-                    int size = in.readInt();
-                    HashSet ntDefs = new HashSet();
-                    for (int i = 0; i < size; i++) {
-                        ntDefs.add(in.readNodeTypeDef());
-                    }
-                    processor.process(ntDefs);
-                } else {
-                    throw new IllegalArgumentException("Unknown entry type: " + c);
-                }
-            }
-            processor.end();
-
-        } catch (NameException e) {
-            String msg = "Unable to read revision " + record.getRevision() +
-                    ": " + e.getMessage();
-            throw new JournalException(msg);
-        } catch (ParseException e) {
-            String msg = "Unable to read revision " + record.getRevision() +
-                    ": " + e.getMessage();
-            throw new JournalException(msg);
-        } catch (IOException e) {
-            String msg = "Unable to read revision " + record.getRevision() +
-                    ": " + e.getMessage();
-            throw new JournalException(msg);
-        } catch (IllegalArgumentException e) {
-            String msg = "Error while processing revision " +
-                    record.getRevision() + ": " + e.getMessage();
-            throw new JournalException(msg);
+            process(record.getRevision(), in);
-    public void begin(String workspace) throws JournalException {
-        try {
-            writeMutex.acquire();
-        } catch (InterruptedException e) {
-            String msg = "Interrupted while waiting for write lock.";
-            throw new JournalException(msg);
-        }
-
-        boolean succeeded = false;
-
-        try {
-            sync();
-
-            tempLog = File.createTempFile("journal", ".tmp", root);
-
-            record = new FileRecord(id, tempLog);
-            out = record.getOutput(resolver);
-            out.writeString(workspace);
-
-            succeeded = true;
-        } catch (IOException e) {
-            String msg = "Unable to create journal log " + tempLog + ": " + e.getMessage();
-            throw new JournalException(msg);
-        } finally {
-            if (!succeeded) {
-                writeMutex.release();
-            }
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void log(ChangeLog changeLog, EventStateCollection esc) throws JournalException {
-        Iterator addedStates = changeLog.addedStates();
-        while (addedStates.hasNext()) {
-            ItemState state = (ItemState) addedStates.next();
-            if (state.isNode()) {
-                log(NodeAddedOperation.create((NodeState) state));
-            } else {
-                log(PropertyAddedOperation.create((PropertyState) state));
-            }
-        }
-        Iterator modifiedStates = changeLog.modifiedStates();
-        while (modifiedStates.hasNext()) {
-            ItemState state = (ItemState) modifiedStates.next();
-            if (state.isNode()) {
-                log(NodeModifiedOperation.create((NodeState) state));
-            } else {
-                log(PropertyModifiedOperation.create((PropertyState) state));
-            }
-        }
-        Iterator deletedStates = changeLog.deletedStates();
-        while (deletedStates.hasNext()) {
-            ItemState state = (ItemState) deletedStates.next();
-            if (state.isNode()) {
-                log(NodeDeletedOperation.create((NodeState) state));
-            } else {
-                log(PropertyDeletedOperation.create((PropertyState) state));
-            }
-        }
-
-        Iterator events = esc.getEvents().iterator();
-        while (events.hasNext()) {
-            EventState event = (EventState) events.next();
-            log(event);
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void log(String oldPrefix, String newPrefix, String uri) throws JournalException {
-        try {
-            out.writeChar('S');
-            out.writeString(oldPrefix);
-            out.writeString(newPrefix);
-            out.writeString(uri);
-        } catch (IOException e) {
-            String msg = "Unable to write to journal log " + tempLog + ": " + e.getMessage();
-            throw new JournalException(msg);
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void log(NodeId nodeId, boolean isDeep, String owner) throws JournalException {
-        log(nodeId, true, isDeep, owner);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void log(NodeId nodeId) throws JournalException {
-        log(nodeId, false, false, null);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void log(Collection ntDefs) throws JournalException {
-        try {
-            out.writeChar('T');
-            out.writeInt(ntDefs.size());
-
-            Iterator iter = ntDefs.iterator();
-            while (iter.hasNext()) {
-                out.writeNodeTypeDef((NodeTypeDef) iter.next());
-            }
-        } catch (IOException e) {
-            String msg = "Unable to write to journal log " + tempLog + ": " + e.getMessage();
-            throw new JournalException(msg);
-        }
-
-    }
-
-    /**
-     * Log a property operation.
-     *
-     * @param operation property operation
-     */
-    protected void log(PropertyOperation operation) throws JournalException {
-        try {
-            out.writeChar('P');
-            out.writeByte(operation.getOperationType());
-            out.writePropertyId(operation.getId());
-        } catch (NoPrefixDeclaredException e) {
-            String msg = "Unable to write to journal log " + tempLog + ": " + e.getMessage();
-            throw new JournalException(msg);
-        } catch (IOException e) {
-            String msg = "Unable to write to journal log " + tempLog + ": " + e.getMessage();
-            throw new JournalException(msg);
-        }
-    }
-
-    /**
-     * Log a node operation.
-     *
-     * @param operation node operation
-     */
-    protected void log(NodeOperation operation) throws JournalException {
-        try {
-            out.writeChar('N');
-            out.writeByte(operation.getOperationType());
-            out.writeNodeId(operation.getId());
-        } catch (IOException e) {
-            String msg = "Unable to write to journal log " + tempLog + ": " + e.getMessage();
-            throw new JournalException(msg);
-        }
-    }
-
-    /**
-     * Log an event. Subclass responsibility.
-     *
-     * @param event event to log
-     */
-    protected void log(EventState event) throws JournalException {
-        try {
-            out.writeChar('E');
-            out.writeByte(event.getType());
-            out.writeNodeId(event.getParentId());
-            out.writePath(event.getParentPath());
-            out.writeNodeId(event.getChildId());
-            out.writePathElement(event.getChildRelPath());
-            out.writeQName(event.getNodeType());
-
-            Set mixins = event.getMixinNames();
-            out.writeInt(mixins.size());
-            Iterator iter = mixins.iterator();
-            while (iter.hasNext()) {
-                out.writeQName((QName) iter.next());
-            }
-            out.writeString(event.getUserId());
-        } catch (NoPrefixDeclaredException e) {
-            String msg = "Unable to write to journal log " + tempLog + ": " + e.getMessage();
-            throw new JournalException(msg);
-        } catch (IOException e) {
-            String msg = "Unable to write to journal log " + tempLog + ": " + e.getMessage();
-            throw new JournalException(msg);
-        }
-    }
-
-    /**
-     * Log either a lock or an unlock operation.
-     *
-     * @param nodeId node id
-     * @param isLock <code>true</code> if this is a lock;
-     *               <code>false</code> if this is an unlock
-     * @param isDeep flag indicating whether lock is deep
-     * @param owner lock owner
-     */
-    protected void log(NodeId nodeId, boolean isLock, boolean isDeep, String owner)
-            throws JournalException {
-
-        try {
-            out.writeChar('L');
-            out.writeNodeId(nodeId);
-            out.writeBoolean(isLock);
-            if (isLock) {
-                out.writeBoolean(isDeep);
-                out.writeString(owner);
-            }
-        } catch (IOException e) {
-            String msg = "Unable to write to journal log " + tempLog + ": " + e.getMessage();
-            throw new JournalException(msg);
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void prepare() throws JournalException {
+    protected long lockRevision() throws JournalException {
-
-        boolean prepared = false;
-
-        try {
-            sync();
-
-            record.setRevision(globalRevision.get());
-
-            prepared = true;
-        } finally {
-            if (!prepared) {
-                globalRevision.unlock();
-                writeMutex.release();
-            }
-        }
+        return globalRevision.get();
-    public void commit() throws JournalException {
+    protected void unlockRevision(boolean successful) {
+        globalRevision.unlock();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    protected void append(long revision, File record) throws JournalException {
-            out.writeChar('\0');
-            out.close();
-
-            long nextRevision = record.getNextRevision();
-
-                if (nextRevision - recordLog.getFirstRevision() > maximumSize) {
+                if (revision - recordLog.getFirstRevision() > maximumSize) {
-            recordLog.append(record);
-
-            tempLog.delete();
+            long nextRevision = recordLog.append(revision, rawId, record);
-            instanceRevision.set(nextRevision);
+            setLocalRevision(nextRevision);
-            String msg = "Unable to close journal log " + tempLog + ": " + e.getMessage();
+            String msg = "Unable to append new record to journal " + journal + ": " + e.getMessage();
-        } finally {
-            out = null;
-            globalRevision.unlock();
-            writeMutex.release();
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void cancel() {
-        if (out != null) {
-            try {
-                out.close();
-                tempLog.delete();
-            } catch (IOException e) {
-                String msg = "Unable to close journal log " + tempLog + ": " + e.getMessage();
-                log.warn(msg);
-            } finally {
-                out = null;
-                globalRevision.unlock();
-                writeMutex.release();
-            }
-     * Create an event state.
-     *
-     * @param type event type
-     * @param parentId parent id
-     * @param parentPath parent path
-     * @param childId child id
-     * @param childRelPath child relative path
-     * @param ntName ndoe type name
-     * @param userId user id
-     * @return event
-     */
-    protected EventState createEventState(int type, NodeId parentId, Path parentPath,
-                                          NodeId childId, Path.PathElement childRelPath,
-                                          QName ntName, Set mixins, String userId) {
-        switch (type) {
-            case Event.NODE_ADDED:
-                return EventState.childNodeAdded(parentId, parentPath, childId, childRelPath,
-                        ntName, mixins, getOrCreateSession(userId));
-            case Event.NODE_REMOVED:
-                return EventState.childNodeRemoved(parentId, parentPath, childId, childRelPath,
-                        ntName, mixins, getOrCreateSession(userId));
-            case Event.PROPERTY_ADDED:
-                return EventState.propertyAdded(parentId, parentPath, childRelPath,
-                        ntName, mixins, getOrCreateSession(userId));
-            case Event.PROPERTY_CHANGED:
-                return EventState.propertyChanged(parentId, parentPath, childRelPath,
-                        ntName, mixins, getOrCreateSession(userId));
-            case Event.PROPERTY_REMOVED:
-                return EventState.propertyRemoved(parentId, parentPath, childRelPath,
-                        ntName, mixins, getOrCreateSession(userId));
-            default:
-                String msg = "Unexpected event type: " + type;
-                throw new IllegalArgumentException(msg);
-        }
-    }
-
-
-    /**
-     * Return a session matching a certain user id.
-     *
-     * @param userId user id
-     * @return session
-     */
-    protected Session getOrCreateSession(String userId) {
-        if (lastSession == null || !lastSession.getUserID().equals(userId)) {
-            lastSession = new ClusterSession(userId);
-        }
-        return lastSession;
-    }
-
-    /**
+
+    /**
+     * Convert an id given as string, to its raw form, i.e. to its binary
+     * representation, encoded as UTF-8.
+     *
+     * @throws IOException if an I/O error occurs, which is very unlikely.
+     */
+    private static byte[] toRawId(String id) throws IOException {
+        ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        DataOutputStream dos = new DataOutputStream(bos);
+        dos.writeUTF(id);
+        dos.close();
+
+        byte[] b = bos.toByteArray();
+        byte[] rawId = new byte[b.length - 2];
+        System.arraycopy(b, 2, rawId, 0, rawId.length);
+        return rawId;
+    }

JCR-333 NodeTypeDef depends on supertype ordering

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@384271 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Iterator;
-    private QName[] supertypes;
+    private HashSet supertypes;
-    private PropDef[] propDefs;
-    private NodeDef[] nodeDefs;
+    private HashSet propDefs;
+    private HashSet nodeDefs;
-        nodeDefs = NodeDef.EMPTY_ARRAY;
-        propDefs = PropDef.EMPTY_ARRAY;
-        supertypes = QName.EMPTY_ARRAY;
+        nodeDefs = new HashSet();
+        propDefs = new HashSet();
+        supertypes = new HashSet();
-            for (int i = 0; i < supertypes.length; i++) {
-                dependencies.add(supertypes[i]);
-            }
+            dependencies.addAll(supertypes);
-            for (int i = 0; i < nodeDefs.length; i++) {
+            for (Iterator iter = nodeDefs.iterator(); iter.hasNext();) {
+                NodeDef nd = (NodeDef) iter.next();
-                QName ntName = nodeDefs[i].getDefaultPrimaryType();
+                QName ntName = nd.getDefaultPrimaryType();
-                QName[] ntNames = nodeDefs[i].getRequiredPrimaryTypes();
+                QName[] ntNames = nd.getRequiredPrimaryTypes();
-            for (int i = 0; i < propDefs.length; i++) {
+            for (Iterator iter = propDefs.iterator(); iter.hasNext();) {
+                PropDef pd = (PropDef) iter.next();
-                if (propDefs[i].getRequiredType() == PropertyType.REFERENCE) {
-                    ValueConstraint[] ca = propDefs[i].getValueConstraints();
+                if (pd.getRequiredType() == PropertyType.REFERENCE) {
+                    ValueConstraint[] ca = pd.getValueConstraints();
-        supertypes = names;
+        supertypes.clear();
+        supertypes.addAll(Arrays.asList(names));
-        propDefs = defs;
+        propDefs.clear();
+        propDefs.addAll(Arrays.asList(defs));
-        nodeDefs = defs;
+        nodeDefs.clear();
+        nodeDefs.addAll(Arrays.asList(defs));
-        return supertypes;
+        if (supertypes.isEmpty()) {
+            return QName.EMPTY_ARRAY;
+        }
+        return (QName[]) supertypes.toArray(new QName[supertypes.size()]);
-        return propDefs;
+        if (propDefs.isEmpty()) {
+            return PropDef.EMPTY_ARRAY;
+        }
+        return (PropDef[]) propDefs.toArray(new PropDef[propDefs.size()]);
-        return nodeDefs;
+        if (nodeDefs.isEmpty()) {
+            return NodeDef.EMPTY_ARRAY;
+        }
+        return (NodeDef[]) nodeDefs.toArray(new NodeDef[nodeDefs.size()]);
-        clone.supertypes = (QName[]) supertypes.clone();
+        clone.supertypes = (HashSet) supertypes.clone();
-        clone.nodeDefs = (NodeDef[]) nodeDefs.clone();
-        clone.propDefs = (PropDef[]) propDefs.clone();
+        clone.nodeDefs = (HashSet) nodeDefs.clone();
+        clone.propDefs = (HashSet) propDefs.clone();
-                    && Arrays.equals(supertypes, other.supertypes)
+                    && supertypes.equals(other.supertypes)
-                    && Arrays.equals(propDefs, other.propDefs)
-                    && Arrays.equals(nodeDefs, other.nodeDefs);
+                    && propDefs.equals(other.propDefs)
+                    && nodeDefs.equals(other.nodeDefs);

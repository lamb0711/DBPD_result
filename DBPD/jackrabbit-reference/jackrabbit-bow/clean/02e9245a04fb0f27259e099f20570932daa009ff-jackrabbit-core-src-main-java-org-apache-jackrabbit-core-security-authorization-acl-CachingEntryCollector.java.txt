JCR-2950: avoid parallel updates for the same node id (note this patch implements three different strategies for testing purposes)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1353495 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+import javax.jcr.RepositoryException;
+
-import javax.jcr.RepositoryException;
-import java.util.Map;
-
+    private ConcurrentMap<NodeId, FutureEntries> futures = new ConcurrentHashMap<NodeId, FutureEntries>();
+    private final String strategy;
+
-     * 
+     *
+
+        // for testing purposes, see JCR-2950
+        String propname = "org.apache.jackrabbit.core.security.authorization.acl.CachingEntryCollector.strategy";
+        strategy = System.getProperty(propname, "T");
+        if (!("S".equals(strategy) || "T".equals(strategy) || "P".equals(strategy))) {
+            throw new RepositoryException("Invalid value " + strategy + " specified for system property " + propname);
+        }
-     * 
+     *
-    private Entries updateCache(NodeImpl node) throws RepositoryException {
+    private Entries internalUpdateCache(NodeImpl node) throws RepositoryException {
+     * Update cache for the given node id
+     * @param node The target node
+     * @return The list of entries present on the specified node or an empty list.
+     * @throws RepositoryException
+     */
+    private Entries updateCache(NodeImpl node) throws RepositoryException {
+        if ("T".equals(strategy)) {
+            return throttledUpdateCache(node);
+        } else if ("S".equals(strategy)) {
+            return synchronizedUpdateCache(node);
+        } else if ("P".equals(strategy)) {
+            return parallelUpdateCache(node);
+        } else {
+            // panic
+            throw new RuntimeException("invalid value for updateCacheStrategy: " + strategy);
+        }
+    }
+
+    /**
+     * See {@link CachingEntryCollector#updateCache(NodeImpl)} ; this variant runs fully synchronized
+     */
+    synchronized private Entries synchronizedUpdateCache(NodeImpl node) throws RepositoryException {
+        return internalUpdateCache(node);
+    }
+
+    /**
+     * See {@link CachingEntryCollector#updateCache(NodeImpl)} ; this variant runs fully parallel
+     */
+    private Entries parallelUpdateCache(NodeImpl node) throws RepositoryException {
+        return internalUpdateCache(node);
+    }
+
+    /**
+     * See {@link CachingEntryCollector#updateCache(NodeImpl)} ; this variant blocks the current
+     * thread if a concurrent update for the same node id takes place
+     */
+    private Entries throttledUpdateCache(NodeImpl node) throws RepositoryException {
+        NodeId id = node.getNodeId();
+        FutureEntries fe = null;
+        FutureEntries nfe = new FutureEntries();
+        boolean found = true;
+
+        fe = futures.putIfAbsent(id, nfe);
+        if (fe == null) {
+            found = false;
+            fe = nfe;
+        }
+
+        if (found) {
+            // we have found a previous FutureEntries object, so use it
+            return fe.get();
+        } else {
+            // otherwise obtain result and when done notify waiting FutureEntries
+            try {
+                Entries e = internalUpdateCache(node);
+                futures.remove(id);
+                fe.setResult(e);
+                return e;
+            } catch (Throwable problem) {
+                futures.remove(id);
+                fe.setProblem(problem);
+                if (problem instanceof RepositoryException) {
+                    throw (RepositoryException)problem;
+                } else {
+                    throw new RuntimeException(problem);
+                }
+            }
+        }
+    }
+
+    /**
-     * 
+     *
-    //--------------------------------------------------------------------------
+    /**
+     * A place holder for a yet to be computed {@link Entries} result 
+     */
+    private class FutureEntries {
+
+        private boolean ready = false;
+        private Entries result = null;
+        private Throwable problem = null;
+
+        synchronized public Entries get() throws RepositoryException {
+            while (!ready) {
+                try {
+                    wait();
+                } catch (InterruptedException e) {
+                }
+            }
+            if (problem != null) {
+                if (problem instanceof RepositoryException) {
+                    throw new RepositoryException(problem);
+                }
+                else {
+                    throw new RuntimeException(problem);
+                }
+            }
+            return result;
+        }
+
+        synchronized public void setResult(Entries e) {
+            result = e;
+            ready = true;
+            notifyAll();
+        }
+
+        synchronized public void setProblem(Throwable t) {
+            problem = t;
+            ready = true;
+            notifyAll();
+        }
+    }
+

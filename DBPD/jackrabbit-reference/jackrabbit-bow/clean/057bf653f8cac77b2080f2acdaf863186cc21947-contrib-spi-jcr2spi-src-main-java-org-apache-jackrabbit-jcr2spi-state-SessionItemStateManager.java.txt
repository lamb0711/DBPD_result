work in progress

- remove NodeState.getPropertyId and replace by getPropertyState
- use ChildNodeEntry.getNodeState
- consequently remove utility methods getNodeState, getPropertyState on
  ItemStateValidator, that converted ItemStateExceptions to RepositoryExc.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@429269 13f79535-47bb-0310-9956-ffa450edef68

-                PropertyState pState = validator.getPropertyState(nState.getNodeId(), QName.JCR_MIXINTYPES);
-                setPropertyStateValue(pState, QValue.create(mixinNames), PropertyType.NAME);
+                try {
+                    PropertyState pState = nState.getPropertyState(QName.JCR_MIXINTYPES);
+                    setPropertyStateValue(pState, QValue.create(mixinNames), PropertyType.NAME);
+                } catch (ItemStateException e) {
+                    // should not occur, since existance has been asserted before
+                    throw new RepositoryException(e);
+                }
-                PropertyState pState = validator.getPropertyState(nState.getNodeId(), QName.JCR_MIXINTYPES);
-                int options = 0; // no checks required
-                removeItemState(pState, options);
+                try {
+                    PropertyState pState = nState.getPropertyState(QName.JCR_MIXINTYPES);
+                    int options = 0; // no checks required
+                    removeItemState(pState, options);
+                } catch (ItemStateException e) {
+                    // should not occur, since existance has been asserted before
+                    throw new RepositoryException(e);
+                }
-                PropertyState childState = validator.getPropertyState(nState.getNodeId(), (QName) childProps.next());
-                QName declNtName = childState.getDefinition().getDeclaringNodeType();
-                // check if property has been defined by mixin type (or one of its supertypes)
-                if (!ent.includesNodeType(declNtName)) {
-                    // the remaining effective node type doesn't include the
-                    // node type that declared this property, it is thus safe
-                    // to remove it
-                    int options = 0; // no checks required
-                    removeItemState(childState, options);
+                try {
+                    PropertyState childState = nState.getPropertyState((QName) childProps.next());
+                    QName declNtName = childState.getDefinition().getDeclaringNodeType();
+                    // check if property has been defined by mixin type (or one of its supertypes)
+                    if (!ent.includesNodeType(declNtName)) {
+                        // the remaining effective node type doesn't include the
+                        // node type that declared this property, it is thus safe
+                        // to remove it
+                        int options = 0; // no checks required
+                        removeItemState(childState, options);
+                    }
+                } catch (ItemStateException e) {
+                    // ignore. cleanup will occure upon save anyway
+                    log.error("Error while removing child node defined by removed mixin: {0}", e.getMessage());
-                ChildNodeEntry entry = (ChildNodeEntry) childNodes.next();
-                NodeState childState = validator.getNodeState(entry.getId());
-                // check if node has been defined by mixin type (or one of its supertypes)
-                QName declNtName = childState.getDefinition().getDeclaringNodeType();
-                if (!ent.includesNodeType(declNtName)) {
-                    // the remaining effective node type doesn't include the
-                    // node type that declared this child node, it is thus safe
-                    // to remove it.
-                    int options = 0; // NOTE: referencial intergrity checked upon save.
-                    removeItemState(childState, options);
+                try {
+                    ChildNodeEntry entry = (ChildNodeEntry) childNodes.next();
+                    NodeState childState = entry.getNodeState();
+                    // check if node has been defined by mixin type (or one of its supertypes)
+                    QName declNtName = childState.getDefinition().getDeclaringNodeType();
+                    if (!ent.includesNodeType(declNtName)) {
+                        // the remaining effective node type doesn't include the
+                        // node type that declared this child node, it is thus safe
+                        // to remove it.
+                        int options = 0; // NOTE: referencial intergrity checked upon save.
+                        removeItemState(childState, options);
+                    }
+                } catch (ItemStateException e) {
+                    // ignore. cleanup will occure upon save anyway
+                    log.error("Error while removing child property defined by removed mixin: {0}", e.getMessage());
-        PropertyState pState = validator.getPropertyState(operation.getPropertyId());
-        setPropertyStateValue(pState, operation.getValues(), operation.getPropertyType());
-        transientStateMgr.addOperation(operation);
+        try {
+            PropertyState pState = (PropertyState) getItemState(operation.getPropertyId());
+            setPropertyStateValue(pState, operation.getValues(), operation.getPropertyType());
+            transientStateMgr.addOperation(operation);
+        } catch (NoSuchItemStateException nsise) {
+            throw new ItemNotFoundException(getHierarchyManager().safeGetJCRPath(operation.getPropertyId()));
+        } catch (ItemStateException ise) {
+            String msg = "internal error: failed to retrieve state of " + getHierarchyManager().safeGetJCRPath(operation.getPropertyId());
+            log.debug(msg);
+            throw new RepositoryException(msg, ise);
+        }
-                    NodeState child = validator.getNodeState(entry.getId());
+                    NodeState child = entry.getNodeState();
-                } catch (ItemNotFoundException e) {
+                } catch (ItemStateException e) {
-                PropertyState child = validator.getPropertyState(targetState.getNodeId(), propName);
+                PropertyState child = targetState.getPropertyState(propName);
-            } catch (ItemNotFoundException e) {
+            } catch (ItemStateException e) {

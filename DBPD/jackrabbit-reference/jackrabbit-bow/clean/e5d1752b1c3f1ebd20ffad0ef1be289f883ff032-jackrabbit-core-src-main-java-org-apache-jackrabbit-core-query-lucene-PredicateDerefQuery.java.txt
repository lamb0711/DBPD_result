JCR-2415: Update Lucene to 3.0
- Merge all from JCR-2415-lucene-3.0 at 1064038 (reintegration)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1064058 13f79535-47bb-0310-9956-ffa450edef68

-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.BitSet;
-import java.util.List;
-import java.util.Set;
-
+import org.apache.jackrabbit.core.query.lucene.hits.AbstractHitCollector;
-import org.apache.lucene.search.HitCollector;
+import java.io.IOException;
+import java.util.BitSet;
+import java.util.Set;
+
+@SuppressWarnings("serial")
-    protected Weight createWeight(Searcher searcher) {
+    public Weight createWeight(Searcher searcher) {
-    private class DerefWeight implements Weight {
+    private class DerefWeight extends Weight {
-        public Scorer scorer(IndexReader reader) throws IOException {
-            subQueryScorer = subQuery.weight(searcher).scorer(reader);
+        public Scorer scorer(IndexReader reader, boolean scoreDocsInOrder,
+                boolean topScorer) throws IOException {
+            subQueryScorer = subQuery.weight(searcher).scorer(reader, scoreDocsInOrder, topScorer);
-                nameTestScorer = new NameQuery(nameTest, version, nsMappings).weight(searcher).scorer(reader);
+                nameTestScorer = new NameQuery(nameTest, version, nsMappings).weight(searcher).scorer(reader, scoreDocsInOrder, topScorer);
-        
+
-        /**
-         * List of UUIDs of selected nodes
-         */
-        private List uuids = null;
-        
-        /**
-         * {@inheritDoc}
-         */
-        public boolean next() throws IOException {
+        @Override
+        public int nextDoc() throws IOException {
+            if (nextDoc == NO_MORE_DOCS) {
+                return nextDoc;
+            }
+
-            return nextDoc > -1;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public int doc() {
+            if (nextDoc < 0) {
+                nextDoc = NO_MORE_DOCS;
+            }
-        /**
-         * {@inheritDoc}
-         */
+        @Override
+        public int docID() {
+            return nextDoc;
+        }
+
+        @Override
-        /**
-         * {@inheritDoc}
-         */
-        public boolean skipTo(int target) throws IOException {
+        @Override
+        public int advance(int target) throws IOException {
+            if (nextDoc == NO_MORE_DOCS) {
+                return nextDoc;
+            }
+
-            return nextDoc > -1;
+            if (nextDoc < 0) {
+                nextDoc = NO_MORE_DOCS;
+            }
+            return nextDoc;
-         * {@inheritDoc}
-         *
-         * @throws UnsupportedOperationException this implementation always
-         *                                       throws an <code>UnsupportedOperationException</code>.
-         */
-        public Explanation explain(int doc) throws IOException {
-            throw new UnsupportedOperationException();
-        }
-
-
-        /**
-            if (uuids == null) {
-                uuids = new ArrayList();
-                subQueryScorer.score(new HitCollector() {
-                    public void collect(int doc, float score) {
-                        subQueryHits.set(doc);
+            subQueryScorer.score(new AbstractHitCollector() {
+                @Override
+                protected void collect(int doc, float score) {
+                    subQueryHits.set(doc);
+                }
+            });
+
+            TermDocs termDocs = reader.termDocs(new Term(FieldNames.PROPERTIES_SET, refProperty));
+            String prefix = FieldNames.createNamedValue(refProperty, "");
+            while (termDocs.next()) {
+                int doc = termDocs.doc();
+
+                String[] values = reader.document(doc).getValues(FieldNames.PROPERTIES);
+                if (values == null) {
+                    // no reference properties at all on this node
+                    continue;
+                }
+                for (int v = 0; v < values.length; v++) {
+                    if (values[v].startsWith(prefix)) {
+                        String uuid = values[v].substring(prefix.length());
+
+                        TermDocs node = reader.termDocs(TermFactory.createUUIDTerm(uuid));
+                        try {
+                            while (node.next()) {
+                                if (subQueryHits.get(node.doc())) {
+                                    hits.set(doc);
+                                }
+                            }
+                        } finally {
+                            node.close();
+                        }
+                    }
+                }
+            }
+
+            // collect nameTest hits
+            final BitSet nameTestHits = new BitSet();
+            if (nameTestScorer != null) {
+                nameTestScorer.score(new AbstractHitCollector() {
+                    @Override
+                    protected void collect(int doc, float score) {
+                        nameTestHits.set(doc);
+            }
-                TermDocs termDocs = reader.termDocs(new Term(FieldNames.PROPERTIES_SET, refProperty));
-                String prefix = FieldNames.createNamedValue(refProperty, "");
-                while (termDocs.next()) {
-                    int doc = termDocs.doc();
-                     
-                    String[] values = reader.document(doc).getValues(FieldNames.PROPERTIES);
-                    if (values == null) {
-                        // no reference properties at all on this node
-                        continue;
-                    }
-                    for (int v = 0; v < values.length; v++) {
-                        if (values[v].startsWith(prefix)) {
-                            String uuid = values[v].substring(prefix.length());
-                            
-                            TermDocs node = reader.termDocs(TermFactory.createUUIDTerm(uuid));
-                            try {
-                                while (node.next()) {
-                                    if (subQueryHits.get(node.doc())) {
-                                        hits.set(doc);
-                                    }
-                                }
-                            } finally {
-                                node.close();
-                            }
-                        }
-                    }
-                }
-                
-                // collect nameTest hits
-                final BitSet nameTestHits = new BitSet();
-                if (nameTestScorer != null) {
-                    nameTestScorer.score(new HitCollector() {
-                        public void collect(int doc, float score) {
-                            nameTestHits.set(doc);
-                        }
-                    });
-                }
-
-                // filter out the target nodes that do not match the name test
-                // if there is any name test at all.
-                if (nameTestScorer != null) {
-                    hits.and(nameTestHits);
-                }
+            // filter out the target nodes that do not match the name test
+            // if there is any name test at all.
+            if (nameTestScorer != null) {
+                hits.and(nameTestHits);

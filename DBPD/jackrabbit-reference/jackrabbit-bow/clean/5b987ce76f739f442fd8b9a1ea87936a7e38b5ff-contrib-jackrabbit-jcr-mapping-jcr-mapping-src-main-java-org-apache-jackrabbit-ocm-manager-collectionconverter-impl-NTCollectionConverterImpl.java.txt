Apply and modify patch for JCR-1053. Thanks to AndrÃ© Bierwolf.
I added more unit tests on collection & proxy. 

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@566872 13f79535-47bb-0310-9956-ffa450edef68

+import javax.jcr.query.InvalidQueryException;
+import javax.jcr.query.Query;
+import javax.jcr.query.QueryResult;
+import org.apache.jackrabbit.util.ISO9075;
- * This collection mapping strategy maps a collection into several nodes based on specific node type.
+ * This collection mapping strategy maps the collection elements into subnodes based on the same node types.
+ * 
+ * There are 2 constraints in this collection converter : 
+ * 1/ this is not possible to have 2 different collections in the main object which are used the same jcr node type for their elements. 
+ * 2/ this is not possible to make a distinction between an empty collection and an null collection. 
- * If the collection element class contains an id (see the FieldDescriptor definition), this id value is used to build the collection element node.
+ * If the collection element class contains an id (see the FieldDescriptor definition), this id value is used to build the collection element node name.
+ *          
+ *          Each "collection-element" nodes have the same jcr node type
+ *          
+ *          Each collection element nodes have the same jcr node type
-         Collection collectionNodes = this.getCollectionNodes(session, parentNode, 
+         NodeIterator nodes = this.getCollectionNodes(session, parentNode, 
-         if (collectionNodes != null && elementClassDescriptor.hasIdField()) {
-            Iterator nodeIterator = collectionNodes.iterator();
+         if (nodes != null && elementClassDescriptor.hasIdField()) {
+            
-            while (nodeIterator.hasNext()) {
-                Node child = (Node) nodeIterator.next();
+            while (nodes.hasNext()) {
+                Node child = (Node) nodes.next();
-        //Class elementClass = ReflectionUtils.forName(collectionDescriptor.getElementClassName());
-        Collection nodes = this.getCollectionNodes(session, parentNode, elementClassDescriptor.getJcrType());
+
+        NodeIterator nodes = this.getCollectionNodes(session, parentNode, elementClassDescriptor.getJcrType());
-        if (nodes == null)
+        if (nodes == null || nodes.getSize() == 0)
-        
-        Iterator children = nodes.iterator();
-        while (children.hasNext()) {
-            Node itemNode = (Node) children.next();
+                
+        while (nodes.hasNext()) {
+            Node itemNode = (Node) nodes.next();
+     * 
+     * return true If the parent node doesn't contains node based on the node type associated to the collection elements
+     *  
-    	    // This collection converter returns at least a empty collection (see in doGetCollection) 
-        return false;
-    }         
-
-    private Collection getCollectionNodes(Session session, Node parentNode, String itemNodeType)
+        String elementClassName = collectionDescriptor.getElementClassName();
+        ClassDescriptor elementClassDescriptor = mapper.getClassDescriptorByClass(ReflectionUtils.forName(elementClassName));
+		QueryResult queryResult = getQuery(session, parentNode, elementClassDescriptor.getJcrType());    	
+    	return queryResult.getNodes().getSize() == 0;
+    }
+        
+    private NodeIterator getCollectionNodes(Session session, Node parentNode, String itemNodeType)
-        List collectionNodes = new ArrayList();
-
-        // TODO : review this workaround used to support version nodes
-        // Searching on the version storage has some bugs => loop on all child noded and check the property jcr:frozenPrimaryType
-        // I have to investigate in more detail what's happen exactly
-        if (!parentNode.getPath().startsWith("/jcr:system/jcr:versionStorage")) {
-            NodeIterator nodeIterator = parentNode.getNodes();
-            while (nodeIterator.hasNext()) {
-                Node child = nodeIterator.nextNode();
-
-                if (child.isNodeType(itemNodeType)) {
-                    collectionNodes.add(child);
-                }
-            }
-        }
-        else {
-            NodeIterator nodeIterator = parentNode.getNodes();
-            while (nodeIterator.hasNext()) {
-                Node child = nodeIterator.nextNode();
-
-                if (child.getProperty("jcr:frozenPrimaryType").getString().equals(itemNodeType)) {
-                    collectionNodes.add(child);
-                }
-            }
-
-        }
-
-        if (collectionNodes.size() == 0)
-        {
-        	return null; 
-        }
-        else
-        {
-            return collectionNodes;
-        }
+        List collectionNodes = null;
+        
+        QueryResult queryResult = getQuery(session, parentNode, itemNodeType);
+        return  queryResult.getNodes();
+        
-        Collection nodes = this.getCollectionNodes(session, parentNode, itemNodeType);
-        if (nodes == null) return;
-        	
-        Iterator nodeIterator = nodes.iterator();
-        while (nodeIterator.hasNext()) {
-            Node node = (Node) nodeIterator.next();
+        NodeIterator nodes = this.getCollectionNodes(session, parentNode, itemNodeType);
+        if (nodes == null || nodes.getSize()==0) return;
+        
+        while (nodes.hasNext()) {
+            Node node = (Node) nodes.next();
+    
+   
+	
+	private QueryResult getQuery(Session session, Node parentNode, String jcrNodeType) throws RepositoryException, InvalidQueryException {
+    	String jcrExpression= "";    	
+    	if (!parentNode.getPath().startsWith("/jcr:system/jcr:versionStorage")) 
+    	{
+            jcrExpression = "SELECT * FROM " + jcrNodeType + " WHERE jcr:path LIKE '" + parentNode.getPath() 
+                                       + "/%' AND NOT jcr:path LIKE '" + parentNode.getPath() + "/%/%'";
+    	}
+    	else
+    	{
+    	
+    		jcrExpression = "SELECT * FROM nt:frozenNode" + " WHERE jcr:path LIKE '" + parentNode.getPath() + "/%'" 
+    		                 + " AND NOT jcr:path LIKE '" + parentNode.getPath() + "/%/%'"
+    		                 + " AND jcr:frozenPrimaryType = '" + jcrNodeType + "'";
+
+    		                
+    	}
+        Query jcrQuery = session.getWorkspace().getQueryManager().createQuery(jcrExpression, javax.jcr.query.Query.SQL);
+        QueryResult queryResult = jcrQuery.execute();
+		return queryResult;
+	}

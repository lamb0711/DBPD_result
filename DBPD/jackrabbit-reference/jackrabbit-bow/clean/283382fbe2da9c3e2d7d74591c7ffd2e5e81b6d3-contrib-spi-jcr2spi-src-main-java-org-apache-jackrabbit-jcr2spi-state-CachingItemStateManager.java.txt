- Rename TransientChangeLog to TransientItemStateManager.
- ChangeLog does not disconnect ItemStates anymore
- Added WorkspaceItemStateManager which extends CachingItemStateManager. CachingItemStateManager is now more generic.
- TransientItemStateManager implements TransientItemStateFactory

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@431572 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.spi.EventIterator;
-import org.apache.jackrabbit.spi.Event;
-import org.apache.jackrabbit.jcr2spi.observation.InternalEventListener;
-import java.util.List;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.Set;
-import java.util.Iterator;
-public class CachingItemStateManager implements ItemStateManager, InternalEventListener {
+public class CachingItemStateManager implements ItemStateManager, ItemStateLifeCycleListener {
+        root.addListener(this);
-    //-------------------------------< InternalEventListener >------------------
+    //------------------------< ItemStateListener >-----------------------------
-    /**
-     * Processes <code>events</code> and invalidates cached <code>ItemState</code>s
-     * accordingly.
-     * @param events 
-     * @param isLocal
-     */
-    public void onEvent(EventIterator events, boolean isLocal) {
-        // if events origin from local changes then
-        // cache does not need invalidation
-        if (isLocal) {
-            return;
-        }
-
-        // collect set of removed node ids
-        Set removedNodeIds = new HashSet();
-        List eventList = new ArrayList();
-        while (events.hasNext()) {
-            Event e = events.nextEvent();
-            eventList.add(e);
-        }
-
-        for (Iterator it = eventList.iterator(); it.hasNext(); ) {
-            Event e = (Event) it.next();
-            ItemId itemId = e.getItemId();
-            NodeId parentId = e.getParentId();
-            ItemState state;
-            NodeState parent;
-            switch (e.getType()) {
-                case Event.NODE_ADDED:
-                case Event.PROPERTY_ADDED:
-                    state = lookup(itemId);
-                    if (state != null) {
-                        // TODO: item already exists ???
-                        // remove from cache and invalidate
-                        recentlyUsed.remove(state);
-                        state.discard();
-                    }
-                    parent = (NodeState) lookup(parentId);
-                    if (parent != null) {
-                        // discard and let wsp manager reload state when accessed next time
-                        recentlyUsed.remove(parent);
-                        parent.discard();
-                    }
-                    break;
-                case Event.NODE_REMOVED:
-                case Event.PROPERTY_REMOVED:
-                    state = lookup(itemId);
-                    if (state != null) {
-                        if (itemId.denotesNode()) {
-                            if (itemId.getRelativePath() == null) {
-                                // also remove mapping from uuid
-                                uuid2NodeState.remove(itemId.getUUID());
-                            }
-                        }
-                        recentlyUsed.remove(state);
-                        state.notifyStateDestroyed();
-                    }
-                    state = lookup(parentId);
-                    if (state != null) {
-                        parent = (NodeState) state;
-                        // check if removed as well
-                        if (removedNodeIds.contains(parent.getId())) {
-                            // do not invalidate here
-                        } else {
-                            // discard and let wsp manager reload state when accessed next time
-                            recentlyUsed.remove(parent);
-                            parent.discard();
-                        }
-                    }
-                    break;
-                case Event.PROPERTY_CHANGED:
-                    state = lookup(itemId);
-                    // discard and let wsp manager reload state when accessed next time
-                    if (state != null) {
-                        recentlyUsed.remove(state);
-                        state.discard();
-                    }
+    public void statusChanged(ItemState state, int previousStatus) {
+        if (state.getStatus() == ItemState.STATUS_REMOVED ||
+                state.getStatus() == ItemState.STATUS_STALE_DESTROYED) {
+            recentlyUsed.remove(state);
+            if (state.isNode()) {
+                NodeState nodeState = (NodeState) state;
+                if (nodeState.getUUID() != null) {
+                    uuid2NodeState.remove(nodeState.getUUID());
+                }
+    public void stateCreated(ItemState created) {
+    }
+
+    public void stateModified(ItemState modified) {
+    }
+
+    public void stateDestroyed(ItemState destroyed) {
+    }
+
+    public void stateDiscarded(ItemState discarded) {
+    }
+
-    private void touch(ItemState state) {
+    protected void touch(ItemState state) {
-        NodeState nodeState = null;
+        // start with root node if no uuid part in id
+        NodeState nodeState = root;
+                nodeState.addListener(this);
-    private ItemState lookup(ItemId id) {
+    protected ItemState lookup(ItemId id) {

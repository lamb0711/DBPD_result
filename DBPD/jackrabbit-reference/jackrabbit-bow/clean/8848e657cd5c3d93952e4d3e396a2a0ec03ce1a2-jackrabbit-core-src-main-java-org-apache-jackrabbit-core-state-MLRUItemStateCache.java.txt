JCR-2699: Improve read/write concurrency

Use a LinkedHashMap instead of LinkedMap from Commons Collections to optimize the LRU data structure.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1002066 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Iterator;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
-    private long totalMem;
+    private volatile long totalMem;
-    private long maxMem;
+    private volatile long maxMem;
-    private long numWrites;
+    private volatile long numWrites;
-    private long accessCount;
+    private volatile long accessCount;
-    private final LinkedMap cache = new LinkedMap();
+    private final Map<ItemId, Entry> cache;
+    @SuppressWarnings("serial")
+        this.cache = new LinkedHashMap<ItemId, MLRUItemStateCache.Entry>(
+                maxMem / 1024, 0.75f, true /* access-ordered */) {
+            @Override
+            protected boolean removeEldestEntry(Map.Entry<ItemId, Entry> e) {
+                if (totalMem > MLRUItemStateCache.this.maxMem) {
+                    totalMem -= e.getValue().size;
+                    return true;
+                } else {
+                    return false;
+                }
+            }
+        };
-            Entry entry = (Entry) cache.remove(id);
+            Entry entry = cache.get(id);
-                // 'touch' item, by adding at end of list
-                cache.put(id, entry);
-            return (ItemState[]) cache.values().toArray(new ItemState[cache.size()]);
+            ItemState[] states = new ItemState[cache.size()];
+            int i = 0;
+            for (Entry entry : cache.values()) {
+                states[i++] = entry.state;
+            }
+            return states;
-            Entry entry = (Entry) cache.get(id);
+            Entry entry = cache.get(id);
-            cache.put(id, entry);
-            shrinkIfRequired();
+            cache.put(id, entry);
-    private void shrinkIfRequired() {
-        // remove items, if too many
-        synchronized (cache) {
-            while (totalMem > maxMem) {
-                ItemId id = (ItemId) cache.firstKey();
-                Entry entry = (Entry) cache.remove(id);
-                totalMem -= entry.size;
-            }
-        }
-    }
-
-            Entry entry = (Entry) cache.remove(id);
+            Entry entry = cache.remove(id);
-        synchronized (cache) {
-            totalMem = 0;
-            Iterator iter = cache.values().iterator();
-            while (iter.hasNext()) {
-                Entry entry = (Entry) iter.next();
-                entry.recalc();
-                totalMem += entry.size;
-            }
-        }
-            shrinkIfRequired();
+
+            // remove items, if too many
+            if (totalMem > maxMem) {
+                totalMem = 0;
+                List<Map.Entry<ItemId, Entry>> entries =
+                    new ArrayList<Map.Entry<ItemId, Entry>>(cache.entrySet());
+                for (Map.Entry<ItemId, Entry> entry : entries) {
+                    long entrySize = entry.getValue().size;
+                    if (totalMem + entrySize > maxMem) {
+                        cache.remove(entry.getKey());
+                    } else {
+                        totalMem += entrySize;
+                    }
+                }
+            }

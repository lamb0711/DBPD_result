- added 'multiValued' flag to ProperyState
- misc. minor fixes and java doc corrections

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@106895 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.OutputStream;
-            ValueConstraint[] constraints = pd.getValueConstraints();
+            /**
+             * check default values:
+             * make sure type of value is consistent with required property type
+             */
+            if (defVals != null && defVals.length != 0) {
+                int reqType = pd.getRequiredType();
+                for (int j = 0; j < defVals.length; j++) {
+                    if (reqType == PropertyType.UNDEFINED) {
+                        reqType = defVals[j].getType();
+                    } else {
+                        if (defVals[j].getType() != reqType) {
+                            String reason = "type of default value(s) is not consistent with required property type";
+                            log.error(reason);
+                            throw new InvalidNodeTypeDefException(reason);
+                        }
+                    }
+                }
+            }
+            /**
+             * todo check that auto-created properties have have at least either default values or system generated values
+             */
+            // check that default values satisfy value constraints
+            ValueConstraint[] constraints = pd.getValueConstraints();
-                // check that default values satisfy value constraints
-     * <li>Default values in property definitions must satisfy value constrains
-     * in the same property child-node definition</li>
+     * <li>Default values in property definitions must satisfy value constraints
+     * specified in the same property definition</li>
-     * <li>Nodetypes specified as constraints in child-node definitions
+     * <li>Node types specified as constraints in child-node definitions
-     * node type constraints in the same child-node definition</li>
+     * node type constraints specified in the same child-node definition</li>
+        OutputStream out = null;
-            customNTDefs.store(customNodeTypesResource.getOutputStream(), nsReg);
+            out = customNodeTypesResource.getOutputStream();
+            customNTDefs.store(out, nsReg);
+        } finally {
+            if (out != null) {
+                try {
+                    out.close();
+                } catch (IOException ioe) {
+                    // ignore
+                }
+            }
+     * Same as <code>{@link #registerNodeType(NodeTypeDef)}</code> except
+     * that a collection of <code>NodeTypeDef</code>s is registered instead of
+     * just one.
+     * <p/>
+     * This method can be used to register a set of node types that have
+     * dependencies on each other.
+     * <p/>
+     * Note that in the case an exception is thrown, some node types might have
+     * been nevertheless successfully registered.
+     *
+     * @param ntDefs a collection of <code>NodeTypeDef<code>s
+     * @throws InvalidNodeTypeDefException
+     * @throws RepositoryException
+     */
+    public synchronized void registerNodeTypes(Collection ntDefs)
+            throws InvalidNodeTypeDefException, RepositoryException {
+        // exceptions that might be thrown by internalRegister(Collection)
+        RepositoryException re = null;
+        InvalidNodeTypeDefException intde = null;
+
+        // store names of currently registered node types before proceeding
+        HashSet oldNTNames = new HashSet(registeredNTDefs.keySet());
+
+        try {
+            // validate and register new node type definitions
+            internalRegister(ntDefs);
+        } catch (RepositoryException e) {
+            // store exception so it can be re-thrown later on
+            re = e;
+        } catch (InvalidNodeTypeDefException e) {
+            // store exception so it can be re-thrown later on
+            intde = e;
+        }
+
+        /**
+         * build set of names of actually registered new node types
+         * (potentially a subset of those specified in ntDefs if an exception
+         * had been thrown)
+         */
+        HashSet newNTNames = new HashSet(registeredNTDefs.keySet());
+        newNTNames.removeAll(oldNTNames);
+
+        if (newNTNames.size() > 0) {
+            // persist new node type definitions
+            for (Iterator iter = newNTNames.iterator(); iter.hasNext(); ) {
+                QName ntName = (QName) iter.next();
+                customNTDefs.add((NodeTypeDef) registeredNTDefs.get(ntName));
+            }
+            OutputStream out = null;
+            try {
+                out = customNodeTypesResource.getOutputStream();
+                customNTDefs.store(out, nsReg);
+            } catch (IOException ioe) {
+                String error = "internal error: failed to write custom node type definition to " + customNodeTypesResource.getPath();
+                log.error(error, ioe);
+                throw new RepositoryException(error, ioe);
+            } catch (FileSystemException fse) {
+                String error = "internal error: failed to write custom node type definition to " + customNodeTypesResource.getPath();
+                log.error(error, fse);
+                throw new RepositoryException(error, fse);
+            } finally {
+                if (out != null) {
+                    try {
+                        out.close();
+                    } catch (IOException ioe) {
+                        // ignore
+                    }
+                }
+            }
+
+            // notify listeners
+            for (Iterator iter = newNTNames.iterator(); iter.hasNext(); ) {
+                QName ntName = (QName) iter.next();
+                notifyRegistered(ntName);
+            }
+        }
+
+        // re-throw exception as necessary
+        if (re != null) {
+            throw re;
+        } else if (intde != null) {
+            throw intde;
+        }
+    }
+
+    /**
+        OutputStream out = null;
-            customNTDefs.store(customNodeTypesResource.getOutputStream(), nsReg);
+            out = customNodeTypesResource.getOutputStream();
+            customNTDefs.store(out, nsReg);
+        } finally {
+            if (out != null) {
+                try {
+                    out.close();
+                } catch (IOException ioe) {
+                    // ignore
+                }
+            }

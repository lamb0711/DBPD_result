JCR-3517 double check capability for eliminating false positives due to concurrent updates

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1444515 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.cluster.ClusterException;
+import org.apache.jackrabbit.core.cluster.ClusterNode;
-
+    public void doubleCheckErrors() {
+        if (!errors.isEmpty()) {
+            log.info("Double checking errors");
+            final ClusterNode clusterNode = handler.getContext().getClusterNode();
+            if (clusterNode != null) {
+                try {
+                    clusterNode.sync();
+                } catch (ClusterException e) {
+                    log.error("Could not sync cluster node for double checking errors");
+                }
+            }
+            final Iterator<ConsistencyCheckError> iterator = errors.iterator();
+            while (iterator.hasNext()) {
+                try {
+                    final ConsistencyCheckError error = iterator.next();
+                    if (!error.doubleCheck(handler, stateMgr)) {
+                        log.info("False positive: " + error.toString());
+                        iterator.remove();
+                    }
+                } catch (RepositoryException e) {
+                    log.error("Failed to double check consistency error", e);
+                } catch (IOException e) {
+                    log.error("Failed to double check consistency error", e);
+                }
+            }
+        }
+    }
+
-                NodeId parentId;
-                if (parent != null && !parent.isEmpty()) {
-                    parentId = new NodeId(parent);
-                } else {
+                if (parent == null || parent.isEmpty()) {
+                final NodeId parentId = new NodeId(parent);
+
+        @Override
+        boolean doubleCheck(SearchIndex handler, ItemStateManager stateManager)
+                throws RepositoryException, IOException {
+            final List<Document> documents = handler.getNodeDocuments(id);
+            for (Document document : documents) {
+                final String parent = document.get(FieldNames.PARENT);
+                if (parent != null && !parent.isEmpty()) {
+                    final NodeId parentId = new NodeId(parent);
+                    if (handler.getNodeDocuments(parentId).isEmpty()) {
+                        return true;
+                    }
+                }
+            }
+            return false;
+
+        }
+        private NodeId parentId;
+
+            this.parentId = parentId;
+
+        @Override
+        boolean doubleCheck(SearchIndex handler, ItemStateManager stateManager)
+                throws IOException, RepositoryException {
+            final List<Document> documents = handler.getNodeDocuments(id);
+            for (Document document : documents) {
+                final String parent = document.get(FieldNames.PARENT);
+                if (parent != null && !parent.isEmpty()) {
+                    final NodeId parentId = new NodeId(parent);
+                    if (parentId.equals(this.parentId) && !stateManager.hasItemState(parentId)) {
+                        return true;
+                    }
+                }
+            }
+            return false;
+        }
+        private NodeId indexedParentId;
+
+            this.indexedParentId = indexedParentId;
+        @Override
+        boolean doubleCheck(final SearchIndex handler, final ItemStateManager stateManager)
+                throws RepositoryException, IOException {
+            final List<Document> documents = handler.getNodeDocuments(id);
+            for (Document document : documents) {
+                final String parent = document.get(FieldNames.PARENT);
+                if (parent != null && !parent.isEmpty()) {
+                    final NodeId parentId = new NodeId(parent);
+                    if (parentId.equals(indexedParentId) && !stateManager.hasItemState(parentId)) {
+                        return true;
+                    }
+                }
+            }
+            return false;
+        }
+
+
+        @Override
+        boolean doubleCheck(SearchIndex handler, ItemStateManager stateManager)
+                throws RepositoryException, IOException {
+            return handler.getNodeDocuments(id).size() > 1;
+        }
+
+        @Override
+        boolean doubleCheck(SearchIndex handler, ItemStateManager stateManager)
+                throws RepositoryException, IOException {
+            final List<Document> documents = handler.getNodeDocuments(id);
+            if (!documents.isEmpty()) {
+                if (!stateManager.hasItemState(id)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+        @Override
+        boolean doubleCheck(SearchIndex handler, ItemStateManager stateManager)
+                throws RepositoryException, IOException {
+            final List<Document> documents = handler.getNodeDocuments(id);
+            if (documents.isEmpty()) {
+                if (stateManager.hasItemState(id)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+

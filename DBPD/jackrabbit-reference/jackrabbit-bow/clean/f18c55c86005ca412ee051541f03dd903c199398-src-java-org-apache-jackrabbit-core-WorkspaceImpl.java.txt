fixed JCR-42: Workspace.move() and Session.move() allow moves to an invalid path
minor other changes

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@153279 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.version.VersionManager;
+     * Verifies that the node at <code>nodePath</code> is checked-out; throws a
+     * <code>VersionException</code> if that's not the case.
+     * <p/>
+     * A node is considered <i>checked-out</i> if it is versionable and
+     * checked-out, or is non-versionable but its nearest versionable ancestor
+     * is checked-out, or is non-versionable and there are no versionable
+     * ancestors.
+     *
+     * @param nodePath
+     * @param hierMgr
+     * @param stateMgr
+     * @throws VersionException
+     * @throws RepositoryException
+     */
+    protected static void verifyCheckedOut(Path nodePath,
+                                           HierarchyManagerImpl hierMgr,
+                                           ItemStateManager stateMgr)
+            throws VersionException, RepositoryException {
+        // search nearest ancestor that is versionable, start with node at nodePath
+        /**
+         * FIXME should not only rely on existence of jcr:isCheckedOut property
+         * but also verify that node.isNodeType("mix:versionable")==true;
+         * this would have a negative impact on performance though...
+         */
+        NodeState nodeState = getNodeState(nodePath, hierMgr, stateMgr);
+        while (!nodeState.hasPropertyEntry(VersionManager.PROPNAME_IS_CHECKED_OUT)) {
+            if (nodePath.denotesRoot()) {
+                return;
+            }
+            nodePath = nodePath.getAncestor(1);
+            nodeState = getNodeState(nodePath, hierMgr, stateMgr);
+        }
+        PropertyId propId =
+                new PropertyId(nodeState.getUUID(), VersionManager.PROPNAME_IS_CHECKED_OUT);
+        PropertyState propState;
+        try {
+            propState = (PropertyState) stateMgr.getItemState(propId);
+        } catch (ItemStateException ise) {
+            String msg = "internal error: failed to retrieve state of "
+                    + hierMgr.safeGetJCRPath(propId);
+            log.debug(msg);
+            throw new RepositoryException(msg, ise);
+        }
+        boolean checkedOut = ((Boolean) propState.getValues()[0].internalValue()).booleanValue();
+        if (!checkedOut) {
+            throw new VersionException(hierMgr.safeGetJCRPath(nodePath) + " is checked-in");
+        }
+    }
+
+    /**
-            PathNotFoundException, ItemExistsException, RepositoryException {
+            VersionException, PathNotFoundException, ItemExistsException,
+            LockException, RepositoryException {
+        // make sure destination parent node is checked-out
+        verifyCheckedOut(destParentPath, destHierMgr, destStateMgr);
+
+        // @todo check locked-status
+
-        // @todo check ckecked-out status
-        // @todo check locked-status status
-        // @todo reimplement Workspace#copy according to new spec
-        // @todo check ckecked-out status
-        // @todo check locked-status status
-
-        // @todo reimplement Workspace#copy according to new spec
-        // @todo check ckecked-out status
-        // @todo check locked-status status
-
-        // @todo reimplement Workspace#move according to new spec
-        // @todo check ckecked-out status
-        // @todo check locked-status status
-
+            if (srcPath.isAncestorOf(destPath)) {
+                String msg = destAbsPath + ": invalid destination path (cannot be descendant of source path)";
+                log.debug(msg);
+                throw new RepositoryException(msg);
+            }
+        // make sure both source & destination parent nodes are checked-out
+        verifyCheckedOut(srcParentPath, hierMgr, stateMgr);
+        verifyCheckedOut(destParentPath, hierMgr, stateMgr);
+
+        // @todo check locked-status
+

JCR-3222: Allow servlet filters to specify custom session providers

Add support for custom session providers as OSGi services

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1236821 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.Set;
+import javax.jcr.LoginException;
+import javax.jcr.RepositoryException;
+import javax.jcr.Session;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import org.apache.felix.scr.annotations.ReferenceCardinality;
+import org.apache.felix.scr.annotations.ReferencePolicy;
+import org.apache.jackrabbit.server.SessionProvider;
-    @Property(name = JcrRemotingServlet.INIT_PARAM_MISSING_AUTH_MAPPING, value = "") })
-public class DavexServletService extends JcrRemotingServlet {
+    @Property(name = JcrRemotingServlet.INIT_PARAM_MISSING_AUTH_MAPPING, value = ""),
+    @Property(name = "contextId", value = "") })
+@Reference(
+        name = "providers", referenceInterface = SessionProvider.class,
+        policy = ReferencePolicy.DYNAMIC,
+        cardinality = ReferenceCardinality.OPTIONAL_MULTIPLE,
+        bind = "addSessionProvider", unbind = "removeSessionProvider")
+public class DavexServletService extends JcrRemotingServlet
+        implements SessionProvider {
+    /**
+     * Currently available custom session providers. They're used
+     * first before the default provider gets consulted. The associated
+     * set of sessions is used to forcibly release all sessions acquired
+     * from a provider when that provider is being removed.
+     */
+    private final Map<SessionProvider, Set<Session>> providers =
+            new LinkedHashMap<SessionProvider, Set<Session>>();
+
+    /**
+     * Currently active sessions. Used to link a session to the correct
+     * provider in the {@link #releaseSession(Session)} method.
+     */
+    private final Map<Session, SessionProvider> sessions =
+            new HashMap<Session, SessionProvider>();
+
+    @Override
+    protected SessionProvider getSessionProvider() {
+        return this;
+    }
+
+    /**
+     * Adds a custom session provider service.
+     *
+     * @param provider session provider
+     */
+    public synchronized void addSessionProvider(SessionProvider provider) {
+        providers.put(provider, new HashSet<Session>());
+    }
+
+    /**
+     * Removes a custom session provider service. All active sessions
+     * acquired from that provider are forcibly released.
+     *
+     * @param provider session provider
+     */
+    public synchronized void removeSessionProvider(SessionProvider provider) {
+        Set<Session> sessions = providers.remove(provider);
+        if (sessions != null) {
+            for (Session session : sessions) {
+                releaseSession(session);
+            }
+        }
+    }
+
+    //-----------------------------------------------------< SessionProvider >
+
+    /**
+     * Asks each available session provider in order for a session and
+     * returns the first session given. The default provider is used
+     * if no custom provider service is available or can provide a requested
+     * session.
+     */
+    public synchronized Session getSession(
+            HttpServletRequest request, Repository repository, String workspace)
+            throws LoginException, ServletException, RepositoryException {
+        SessionProvider provider = null;
+        Session session = null;
+
+        for (Map.Entry<SessionProvider, Set<Session>> entry : providers.entrySet()) {
+            provider = entry.getKey();
+            session = provider.getSession(request, repository, workspace);
+            if (session != null) {
+                entry.getValue().add(session);
+                break;
+            }
+        }
+
+        if (session == null) {
+            provider = super.getSessionProvider();
+            session = provider.getSession(request, repository, workspace);
+        }
+
+        if (session != null) {
+            sessions.put(session, provider);
+        }
+
+        return session;
+    }
+
+    /**
+     * Releases the given session using the provider from which it was acquired.
+     */
+    public synchronized void releaseSession(Session session) {
+        SessionProvider provider = sessions.remove(session);
+        if (provider != null) {
+            provider.releaseSession(session);
+        }
+    }
+

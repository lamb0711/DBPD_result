JCR-1588: 283 Access Control

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@689499 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.api.jsr283.security.AccessControlEntry;
-import org.apache.jackrabbit.api.jsr283.security.AccessControlPolicy;
-import javax.jcr.ItemNotFoundException;
-public abstract class AbstractAccessControlProvider implements AccessControlProvider {
+public abstract class AbstractAccessControlProvider implements AccessControlProvider, AccessControlUtils {
-    private final String policyName;
-    private final String policyDesc;
+    public static final String PARAM_OMIT_DEFAULT_PERMISSIONS = "omit-default-permission";
-     * Returns the system session this provider has been created for.
+     * the system session this provider has been created for.
-    private Principal everyone;
-        this(AbstractAccessControlProvider.class.getName() + ": default Policy", null);
-    }
-
-    protected AbstractAccessControlProvider(String defaultPolicyName, String defaultPolicyDesc) {
-        policyName = defaultPolicyName;
-        policyDesc = defaultPolicyDesc;
-     *
+     * Throws <code>IllegalStateException</code> if the provider has not
+     * been initialized or has been closed.
-     * Simple test if the specified path points to an item that defines AC
-     * information.
-     * 
-     * @param absPath
-     * @return
-     */
-    protected abstract boolean isAcItem(Path absPath) throws RepositoryException;
-
-    /**
+     * Returns compiled permissions for the administrator i.e. permissions
+     * that grants everything and returns {@link PrivilegeRegistry#ALL}
+     * upon {@link CompiledPermissions#getPrivileges(Path)} for all
+     * paths.
-     * @param principals
-     * @return
-     */
-    protected static boolean isAdminOrSystem(Set principals) {
-        for (Iterator it = principals.iterator(); it.hasNext();) {
-            Principal p = (Principal) it.next();
-            if (p instanceof AdminPrincipal || p instanceof SystemPrincipal) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     *
-     * @return
+     * @return an implementation of <code>CompiledPermissions</code> that
+     * grants everything and always returns {@link PrivilegeRegistry#ALL}
+     * upon {@link CompiledPermissions#getPrivileges(Path)}.
-            public boolean grants(Path absPath, int permissions) throws RepositoryException {
+            public boolean grants(Path absPath, int permissions) {
-            public int getPrivileges(Path absPath) throws RepositoryException {
+            public int getPrivileges(Path absPath) {
-            public boolean canReadAll() throws RepositoryException {
+            public boolean canReadAll() {
-     * Simple implementation to determine if the given set of principals
-     * only will result in read-only access.
+     * Returns compiled permissions for a read-only user i.e. permissions
+     * that grants READ permission for all non-AC items.
-     * @param principals
-     * @return true if the given set only contains the everyone group.
-     */
-    protected boolean isReadOnly(Set principals) {
-        // TODO: improve. need to detect if 'anonymous' is included.
-        return principals.size() == 1 && principals.contains(everyone);
-    }
-
-    /**
-     *
-     * @return
+     * @return an implementation of <code>CompiledPermissions</code> that
+     * grants READ permission for all non-AC items.
-            public boolean canReadAll() throws RepositoryException {
+            public boolean canReadAll() {
+    //-------------------------------------------------< AccessControlUtils >---
+    /**
+     * @see AccessControlUtils#isAdminOrSystem(Set)
+     */
+    public boolean isAdminOrSystem(Set principals) {
+        for (Iterator it = principals.iterator(); it.hasNext();) {
+            Principal p = (Principal) it.next();
+            if (p instanceof AdminPrincipal || p instanceof SystemPrincipal) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * @see AccessControlUtils#isReadOnly(Set)
+     */
+    public boolean isReadOnly(Set principals) {
+        // TODO: find ways to determine read-only status
+        return false;
+    }
+
-    public void init(Session systemSession, Map options) throws RepositoryException {
+    public void init(Session systemSession, Map configuration) throws RepositoryException {
-
-        everyone = session.getPrincipalManager().getEveryone();
-
-
-    /**
-     * @see AccessControlProvider#getPolicy(Path)
-     * @param absPath
-     */
-    public AccessControlPolicy getPolicy(Path absPath) throws ItemNotFoundException, RepositoryException {
-        checkInitialized();
-        return new AccessControlPolicy() {
-            public String getName() throws RepositoryException {
-                return policyName;
-            }
-            public String getDescription() throws RepositoryException {
-                return policyDesc;
-            }
-        };
-    }
-
-    /**
-     * @see AccessControlProvider#getAccessControlEntries(Path)
-     * @param absPath
-     */
-    public AccessControlEntry[] getAccessControlEntries(Path absPath) throws RepositoryException {
-        checkInitialized();
-        // always empty array, since aces will never be changed using the api.
-        return new AccessControlEntry[0];
-    }
-
-    /**
-     * @see AccessControlProvider#getEditor(Session)
-     */
-    public AccessControlEditor getEditor(Session session) {
-        checkInitialized();
-        // not editable at all: policy is always the default and cannot be
-        // changed using the JCR API.
-        return null;
-    }

JCR-482: Applied Julian Reschke's patch to avoid problems with concurrent namespace registrations.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@439854 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.HashMap;
+
+    
+    /**
+     * the set of namespace declarations that have already been serialized
+     */
+    protected NamespaceStack namespaces;
+        // start with an empty set of known prefixes
+        this.namespaces = new NamespaceStack(null);
-     * XML top-level element. The effect is the same as setting the
+     * XML element as required (e.g., normally just on the root
+     * element). The effect is the same as setting the
-        if (level == 0) {
-            String[] prefixes = session.getNamespacePrefixes();
-            for (int i = 0; i < prefixes.length; i++) {
-                if (prefixes[i].length() > 0
-                        && !QName.NS_XML_PREFIX.equals(prefixes[i])) {
+        String[] prefixes = session.getNamespacePrefixes();
+        NamespaceStack newNamespaces = null;
+        
+        for (int i = 0; i < prefixes.length; i++) {
+            String prefix = prefixes[i];
+            
+            if (prefix.length() > 0
+                    && !QName.NS_XML_PREFIX.equals(prefix)) {
+                String uri = session.getNamespaceURI(prefix);
+                
+                // get the matching namespace from previous declarations
+                String mappedToNs = this.namespaces.getNamespaceURI(prefix);
+            
+                if (! uri.equals(mappedToNs)) {
+                    // when not the same, add a declaration
-                            QName.NS_XMLNS_URI,
-                            prefixes[i],
-                            QName.NS_XMLNS_PREFIX + ":" + prefixes[i],
-                            "CDATA",
-                            session.getNamespaceURI(prefixes[i]));
+                        QName.NS_XMLNS_URI,
+                        prefix,
+                        QName.NS_XMLNS_PREFIX + ":" + prefix,
+                        "CDATA",
+                        uri);
+                    
+                    if (newNamespaces == null) {
+                        // replace current namespace stack when needed
+                        newNamespaces = new NamespaceStack(this.namespaces);
+                        this.namespaces = newNamespaces;
+                    }
+                    
+                    // remember the new declaration
+                    newNamespaces.setNamespacePrefix(prefix, uri);
+                
-                Node childNode = nodeIter.nextNode();
+                Node childNode = nodeIter.nextNode();
+                
+                // remember the current namespace declarations
+                NamespaceStack previousNamespaces = this.namespaces;
+                
+                
+                // restore the effective namespace declarations 
+                // (from before visiting the child node)
+                this.namespaces = previousNamespaces;
+            
+
+    
+    /**
+     * Implements a simple stack of namespace
+     * declarations.
+     */
+    
+    private static class NamespaceStack extends HashMap {
+      
+        /**
+         * Parent stack (may be <code>null</code>)
+         */
+        private final NamespaceStack parent;
+              
+        /**
+         * Instantiate a new stack
+         * @param parent parent stack (may be <code>null</code> for the initial stack)
+         */
+        public NamespaceStack(NamespaceStack parent) {
+            this.parent = parent;
+        }
+      
+        /**
+         * Obtain namespace URI for a prefix
+         * @param prefix prefix
+         * @return namespace URI (or <code>null</code> when unknown)
+         */
+        public String getNamespaceURI(String prefix) {
+          
+            String namespace = (String)super.get(prefix);
+    
+            if (namespace != null) {
+                // found in this element, return right away
+                return namespace;
+            }
+            else {
+                // ask parent, when present
+                if (this.parent == null) {
+                    return null;
+                }
+                else {
+                    return this.parent.getNamespaceURI(prefix);
+                }
+              }
+        }
+      
+        /**
+         * Add a new prefix mapping
+         * @param prefix namespace prefix
+         * @param uri namespace URI
+         */
+        public void setNamespacePrefix(String prefix, String uri) {
+            super.put(prefix, uri);
+        }
+    }

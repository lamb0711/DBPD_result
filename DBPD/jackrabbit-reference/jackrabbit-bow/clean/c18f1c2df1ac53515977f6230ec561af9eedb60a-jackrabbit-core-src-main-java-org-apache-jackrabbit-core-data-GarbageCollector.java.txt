JCR-3490 instead of individually loading every node in the repository load batches of node infos at once. node states are now only loaded when the node in question indeed has a blob property in the data store

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1427374 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.persistence.util.NodeInfo;
+import java.util.Map;
+    /**
+     * The number of nodes to fetch at once from the persistence manager. Defaults to 8kb
+     */
+    private static final int NODESATONCE = Integer.getInteger("org.apache.jackrabbit.garbagecollector.nodesatonce", 1024 * 8);
+
-    /**
-     * @deprecated use setMarkEventListener().
-     */
-    public void setScanEventListener(ScanEventListener callback) {
-        setMarkEventListener(callback);
-    }
-
-    /**
-     * @deprecated use mark().
-     */
-    public void scan() throws RepositoryException {
-        mark();
-    }
-
-    /**
-     * @deprecated use isPersistenceManagerScan().
-     */
-    public boolean getPersistenceManagerScan() {
-        return isPersistenceManagerScan();
-    }
-
-            for (NodeId id : pm.getAllNodeIds(null, 0)) {
-                if (callback != null) {
-                    callback.beforeScanning(null);
-                }
-                try {
-                    NodeState state = pm.load(id);
-                    Set<Name> propertyNames = state.getPropertyNames();
-                    for (Name name : propertyNames) {
-                        PropertyId pid = new PropertyId(id, name);
-                        PropertyState ps = pm.load(pid);
-                        if (ps.getType() == PropertyType.BINARY) {
-                            for (InternalValue v : ps.getValues()) {
-                                // getLength will update the last modified date
-                                // if the persistence manager scan is running
-                                v.getLength();
+            Map<NodeId,NodeInfo> batch = pm.getAllNodeInfos(null, NODESATONCE);
+            while (!batch.isEmpty()) {
+                NodeId lastId = null;
+                for (NodeInfo info : batch.values()) {
+                    lastId = info.getId();
+                    if (callback != null) {
+                        callback.beforeScanning(null);
+                    }
+                    if (info.hasBlobsInDataStore()) {
+                        try {
+                            NodeState state = pm.load(info.getId());
+                            Set<Name> propertyNames = state.getPropertyNames();
+                            for (Name name : propertyNames) {
+                                PropertyId pid = new PropertyId(info.getId(), name);
+                                PropertyState ps = pm.load(pid);
+                                if (ps.getType() == PropertyType.BINARY) {
+                                    for (InternalValue v : ps.getValues()) {
+                                        // getLength will update the last modified date
+                                        // if the persistence manager scan is running
+                                        v.getLength();
+                                    }
+                                }
+                        } catch (NoSuchItemStateException ignored) {
+                            // the node may have been deleted in the meantime
-                } catch (NoSuchItemStateException e) {
-                    // the node may have been deleted or moved in the meantime
-                    // ignore it
+                batch = pm.getAllNodeInfos(lastId, NODESATONCE);
+        NodeInfo.clearPool();
-    /**
-     * @deprecated use sweep().
-     */
-    public int deleteUnused() throws RepositoryException {
-        return sweep();
-    }
-

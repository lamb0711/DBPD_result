JCR-EXT: Cleanups and improvements for the simple node type state implementation.

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@328809 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.HashSet;
-import java.util.Set;
-
-    private QName name;
+    private QName name = null;
-    private boolean mixin;
+    private boolean mixin = false;
-    private boolean hasOrderableChildNodes;
+    private boolean hasOrderableChildNodes = false;
-    private QName primaryItemName;
+    private QName primaryItemName = null;
-    private Set supertypeNames;
+    private QName[] supertypeNames = new QName[0];
-    private Set childNodeDefinitionStates;
+    private NodeDefinitionState[] childNodeDefinitionStates =
+        new NodeDefinitionState[0];
-    private Set propertyDefinitionStates;
-
-    /** Creates an empty node type state instance. */
-    public NodeTypeState() {
-        name = null;
-        mixin = false;
-        hasOrderableChildNodes = false;
-        primaryItemName = null;
-        supertypeNames = new HashSet();
-        childNodeDefinitionStates = new HashSet();
-        propertyDefinitionStates = new HashSet();
-    }
+    private PropertyDefinitionState[] propertyDefinitionStates =
+        new PropertyDefinitionState[0];
-    public boolean isHasOrderableChildNodes() {
+    public boolean hasOrderableChildNodes() {
-        return (QName[])
-            supertypeNames.toArray(new QName[supertypeNames.size()]);
+        return supertypeNames;
-     * Adds a supertype name to the list of declared supertypes.
+     * Sets the list of declared supertypes.
-     * @param name supertype name
+     * @param supertypeNames supertype names
-    public void addSupertypeName(QName name) {
-        supertypeNames.add(name);
+    public void setSupertypeNames(QName[] supertypeNames) {
+        this.supertypeNames = supertypeNames;
-        return (NodeDefinitionState[]) childNodeDefinitionStates.toArray(
-                new NodeDefinitionState[childNodeDefinitionStates.size()]);
+        return childNodeDefinitionStates;
-     * Adds a node definition state to the list of child node definition
-     * states of the node type.
+     * Sets the list of child node definition states of the node type.
-     * @param state child node definition state
+     * @param childNodeDefinitionStates child node definition states
-    public void addChildNodeDefinition(NodeDefinitionState state) {
-        childNodeDefinitionStates.add(state);
+    public void setChildNodeDefinitionStates(
+            NodeDefinitionState[] childNodeDefinitionStates) {
+        this.childNodeDefinitionStates = childNodeDefinitionStates;
-        return (PropertyDefinitionState[]) propertyDefinitionStates.toArray(
-                new PropertyDefinitionState[propertyDefinitionStates.size()]);
+        return propertyDefinitionStates;
-     * Adds a property definition state to the list of property definition
-     * states of the node type.
+     * Sets the list of property definition states of the node type.
-     * @param state property definition state
+     * @param propertyDefinitionStates property definition states
-    public void addPropertyDefinitionState(PropertyDefinitionState state) {
-        propertyDefinitionStates.add(state);
+    public void setPropertyDefinitionStates(
+            PropertyDefinitionState[] propertyDefinitionStates) {
+        this.propertyDefinitionStates = propertyDefinitionStates;
+    }
+
+    public boolean equals(Object object) {
+        return (this == object)
+            || (object != null && new StateComparator().compare(this, object) == 0);
+    }
+
+    public int hashCode() {
+        int code = 37;
+        code = code * 17 + ((name != null) ? name.hashCode() : 0);
+        code = code * 17 + (mixin ? 1 : 0);
+        code = code * 17 + (hasOrderableChildNodes ? 1 : 0);
+        return code;

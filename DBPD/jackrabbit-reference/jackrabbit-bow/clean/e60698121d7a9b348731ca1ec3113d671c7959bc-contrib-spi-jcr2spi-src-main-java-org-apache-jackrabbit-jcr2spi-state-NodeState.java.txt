Redesign implementation of ChildNodeEntries:
- replace LinkedMap with linked list

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@432233 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.collections.map.LinkedMap;
+import org.apache.commons.collections.list.AbstractLinkedList;
+import org.apache.commons.collections.iterators.UnmodifiableIterator;
+import java.util.AbstractList;
-     * <code>List</code> view.
+     * <code>Collection</code> view.
-        // TODO: turn this into a linked set. NodeId cannot be use as key!
-        // insertion-ordered map of entries (key=NodeId, value=entry)
-        private final Map entries = new LinkedMap();
-        // map used for lookup by name
-        // (key=name, value=either a single entry or a list of sns entries)
+        /**
+         * Linked list of {@link ChildNodeEntry} instances.
+         */
+        private final LinkedEntries entries = new LinkedEntries();
+
+        /**
+         * map used for lookup by name
+         * (key=name, value=either a single {@link AbstractLinkedList.Node} or a
+         * list of {@link AbstractLinkedList.Node}s which are sns entries)
+         */
+        /**
+         * Returns the <code>ChildNodeEntry</code> for the given
+         * <code>nodeState</code>.
+         *
+         * @param nodeState the node state.
+         * @return the <code>ChildNodeEntry</code> or <code>null</code> if there
+         *         is no <code>ChildNodeEntry</code> for <code>nodeState</code>.
+         */
-            return (ChildNodeEntry) entries.get(nodeState.getId());
+            Object o = nameMap.get(nodeState.getName());
+            if (o == null) {
+                // no matching child node entry
+                return null;
+            }
+            if (o instanceof List) {
+                // has same name sibling
+                for (Iterator it = ((List) o).iterator(); it.hasNext(); ) {
+                    LinkedEntries.LinkNode n = (LinkedEntries.LinkNode) it.next();
+                    ChildNodeEntry cne = n.getChildNodeEntry();
+                    // only check available child node entries
+                    try {
+                        if (cne.isAvailable() && cne.getNodeState() == nodeState) {
+                            return cne;
+                        }
+                    } catch (ItemStateException e) {
+                        log.warn("error retrieving a child node state", e);
+                    }
+                }
+            } else {
+                // single child node with this name
+                ChildNodeEntry cne = ((LinkedEntries.LinkNode) o).getChildNodeEntry();
+                try {
+                    if (cne.isAvailable() && cne.getNodeState() == nodeState) {
+                        return cne;
+                    }
+                } catch (ItemStateException e) {
+                    log.warn("error retrieving a child node state", e);
+                }
+            }
+            // not found
+            return null;
+        /**
+         * Returns a <code>List</code> of <code>ChildNodeEntry</code>s for the
+         * given <code>nodeName</code>.
+         *
+         * @param nodeName the child node name.
+         * @return same name sibling nodes with the given <code>nodeName</code>.
+         */
-            if (obj instanceof ArrayList) {
+            if (obj instanceof List) {
+                final List sns = (List) obj;
-                return Collections.unmodifiableList((ArrayList) obj);
+                return Collections.unmodifiableList(new AbstractList() {
+
+                    public Object get(int index) {
+                        return ((LinkedEntries.LinkNode) sns.get(index)).getChildNodeEntry();
+                    }
+
+                    public int size() {
+                        return sns.size();
+                    }
+
+                    public Iterator iterator() {
+                        return new Iterator() {
+
+                            private Iterator iter = sns.iterator();
+
+                            public void remove() {
+                                throw new UnsupportedOperationException("remove");
+                            }
+
+                            public boolean hasNext() {
+                                return iter.hasNext();
+                            }
+
+                            public Object next() {
+                                return ((LinkedEntries.LinkNode) iter.next()).getChildNodeEntry();
+                            }
+                        };
+                    }
+                });
-                return Collections.singletonList(obj);
+                return Collections.singletonList(
+                        ((LinkedEntries.LinkNode) obj).getChildNodeEntry());
+        /**
+         * Returns the <code>ChildNodeEntry</code> with the given
+         * <code>nodeName</code> and <code>index</code>.
+         *
+         * @param nodeName name of the child node entry.
+         * @param index    the index of the child node entry.
+         * @return the <code>ChildNodeEntry</code> or <code>null</code> if there
+         *         is no such <code>ChildNodeEntry</code>.
+         */
-            if (obj instanceof ArrayList) {
+            if (obj instanceof List) {
-                ArrayList siblings = (ArrayList) obj;
+                List siblings = (List) obj;
-                    return (ChildNodeEntry) siblings.get(index - 1);
+                    return ((LinkedEntries.LinkNode) siblings.get(index - 1)).getChildNodeEntry();
-                    return (ChildNodeEntry) obj;
+                    return ((LinkedEntries.LinkNode) obj).getChildNodeEntry();
+        /**
+         * Adds a <code>ChildNodeEntry</code> for a child node with the given
+         * name and an optional <code>uuid</code>.
+         *
+         * @param nodeName the name of the child node.
+         * @param uuid     the UUID of the child node if it can be identified
+         *                 with a UUID; otherwise <code>null</code>.
+         * @return the created ChildNodeEntry.
+         */
-                if (obj instanceof ArrayList) {
+                if (obj instanceof List) {
-                    siblings = (ArrayList) obj;
+                    siblings = (List) obj;
+            LinkedEntries.LinkNode ln = entries.add(entry);
+
-                siblings.add(entry);
+                siblings.add(ln);
-                nameMap.put(nodeName, entry);
+                nameMap.put(nodeName, ln);
-            entries.put(idFactory.createNodeId(uuid), entry);
+        /**
+         * Adds a <code>ChildNodeEntry</code> to the end of the list.
+         *
+         * @param cne the <code>ChildNodeEntry</code> to add.
+         */
-                if (obj instanceof ArrayList) {
+                if (obj instanceof List) {
+            LinkedEntries.LinkNode ln = entries.add(cne);
+
-                siblings.add(cne);
+                siblings.add(ln);
-                nameMap.put(nodeName, cne);
+                nameMap.put(nodeName, ln);
-            entries.put(cne.getId(), cne);
+        /**
+         * Appends a list of <code>ChildNodeEntry</code>s to this list.
+         *
+         * @param entriesList the list of <code>ChildNodeEntry</code>s to add.
+         */
+        /**
+         * Removes the child node entry with the given <code>nodeName</code> and
+         * <code>index</code>.
+         *
+         * @param nodeName the name of the child node entry to remove.
+         * @param index    the index of the child node entry to remove.
+         * @return the removed <code>ChildNodeEntry</code> or <code>null</code>
+         *         if there is no matching <code>ChildNodeEntry</code>.
+         */
-            if (obj instanceof ChildNodeEntry) {
+            if (obj instanceof LinkedEntries.LinkNode) {
-                ChildNodeEntry removedEntry = (ChildNodeEntry) obj;
+                LinkedEntries.LinkNode ln = (LinkedEntries.LinkNode) obj;
-                entries.remove(removedEntry.getId());
-                return removedEntry;
+                // remove LinkNode from entries
+                ln.remove();
+                return ln.getChildNodeEntry();
-            List siblings = (ArrayList) obj;
+            List siblings = (List) obj;
-            ChildNodeEntry removedEntry = (ChildNodeEntry) siblings.remove(index - 1);
-            // remove from ordered entries map
-            entries.remove(removedEntry.getId());
+            LinkedEntries.LinkNode ln = (LinkedEntries.LinkNode) siblings.remove(index - 1);
+            ChildNodeEntry removedEntry = ln.getChildNodeEntry();
+            // remove from ordered entries
+            ln.remove();
-                    if (tmp.getNodeState() == nodeState) {
+                    if (tmp.isAvailable() && tmp.getNodeState() == nodeState) {
-        //-------------------------------------------< unmodifiable List view >
+        //--------------------------------------< unmodifiable Collection view >
+
-                return entries.containsKey(((ChildNodeEntry) o).getId());
+                // narrow down to same name sibling nodes and check list
+                return get(((ChildNodeEntry) o).getName()).contains(o);
-            return new EntriesIterator();
+            return UnmodifiableIterator.decorate(entries.iterator());
-            Iterator iter = entries.values().iterator();
+            Iterator iter = entries.iterator();
-        //----------------------------------------------------< inner classes >
+    }
-        class EntriesIterator implements Iterator {
+    /**
+     * An implementation of a linked list which provides access to the internal
+     * LinkNode which links the entries of the list.
+     */
+    private static class LinkedEntries extends AbstractLinkedList {
-            private final Iterator mapIter;
+        /**
+         * Adds a child node entry to this list.
+         *
+         * @param cne the child node entry to add.
+         * @return the LinkNode which refers to the added <code>ChildNodeEntry</code>.
+         */
+        LinkNode add(ChildNodeEntry cne) {
+            LinkNode ln = (LinkNode) createNode(cne);
+            addNode(ln, header);
+            return ln;
+        }
-            EntriesIterator() {
-                mapIter = entries.values().iterator();
+        /**
+         * Reorders an existing <code>LinkNode</code> before another existing
+         * <code>LinkNode</code>. If <code>before</code> is <code>null</code>
+         * the <code>insert</code> node is moved to the end of the list.
+         *
+         * @param insert the node to reorder.
+         * @param before the node where to reorder node <code>insert</code>.
+         */
+        void reorderNode(LinkNode insert, LinkNode before) {
+            removeNode(insert);
+            if (before == null) {
+                addNode(insert, header);
+            } else {
+                addNode(insert, before);
+            }
+        }
+
+        /**
+         * Create a new <code>LinkNode</code> for a given {@link ChildNodeEntry}
+         * <code>value</code>.
+         *
+         * @param value a child node entry.
+         * @return a wrapping {@link LinkedEntries.LinkNode}.
+         */
+        protected Node createNode(Object value) {
+            return new LinkNode(value);
+        }
+
+        /**
+         * @return a new <code>LinkNode</code>.
+         */
+        protected Node createHeaderNode() {
+            return new LinkNode();
+        }
+
+        /**
+         * Extends the <code>AbstractLinkedList.Node</code>.
+         */
+        private class LinkNode extends AbstractLinkedList.Node {
+
+            protected LinkNode() {
+                super();
-            public boolean hasNext() {
-                return mapIter.hasNext();
+            protected LinkNode(Object value) {
+                super(value);
-            public Object next() {
-                return mapIter.next();
+            /**
+             * @return the wrapped <code>ChildNodeEntry</code>.
+             */
+            public ChildNodeEntry getChildNodeEntry() {
+                return (ChildNodeEntry) super.getValue();
+            /**
+             * Removes this <code>LinkNode</code> from the linked list.
+             */
-                throw new UnsupportedOperationException();
+                removeNode(this);
+

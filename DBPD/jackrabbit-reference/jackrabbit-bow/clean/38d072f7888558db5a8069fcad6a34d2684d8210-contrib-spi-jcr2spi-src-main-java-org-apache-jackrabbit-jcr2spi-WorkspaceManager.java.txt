work in progress

- Restore: pass NodeState(s) and Path instead of NodeId(s)
- LockManager: make sure lockmanager only remembers workspace states
- LockManager: make sure operations are executed using workspace states
- LockManager: improve isLocked/getLock/checkIsLocked and respect locks that
have been accessed before.
- VersionManager: make sure operations are executed using workspace states
- VersionManager: add checkIsCheckedOut
- VersionManager: force manager to have a WorkspaceManager
- NodeReferences:
  > make interface package protected
  > clarify method naming
  > add implementation to WorkspaceItemStateFactory
  > add NodeReferences field to NodeState
  > TO_IMPROVE: references are currently always retrieve from the SPI.
- ItemStateManager + NodeReferences
  > rename interfaces methods
  > change method signature to take NodeState instead of NodeId
  > 'getReferences' returns the property states directly

- remove some JR DIFFs. 

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@432234 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.state.NodeReferences;
-    // TODO: TO-BE-FIXED. Major refactoring of caching mechanism with change to SPI ids
-        try {
-            this.service = service;
-            this.sessionInfo = sessionInfo;
+        this.service = service;
+        this.sessionInfo = sessionInfo;
-            ItemStateFactory isf = createItemStateFactory();
-            cache = new WorkspaceItemStateManager(isf, service.getIdFactory());
-            addEventListener(cache);
+        ItemStateFactory isf = createItemStateFactory();
+        cache = new WorkspaceItemStateManager(isf, service.getIdFactory());
+        addEventListener(cache);
-            nsRegistry = createNamespaceRegistry();
-            ntRegistry = createNodeTypeRegistry(nsRegistry);
-            externalChangeListener = createChangeListener();
-        } catch (ItemStateException e) {
-            throw new RepositoryException(e);
-        }
+        nsRegistry = createNamespaceRegistry();
+        ntRegistry = createNodeTypeRegistry(nsRegistry);
+        externalChangeListener = createChangeListener();
-     * @see ItemStateManager#getNodeReferences(NodeId)
+     * @see ItemStateManager#getReferingStates(NodeState)
+     * @param nodeState
-    public NodeReferences getNodeReferences(NodeId id) throws NoSuchItemStateException, ItemStateException {
+    public Collection getReferingStates(NodeState nodeState) throws ItemStateException {
-            return cache.getNodeReferences(id);
+            return cache.getReferingStates(nodeState);
-     * @see ItemStateManager#hasNodeReferences(NodeId)
+     * @see ItemStateManager#hasReferingStates(NodeState)
+     * @param nodeState
-    public boolean hasNodeReferences(NodeId id) {
+    public boolean hasReferingStates(NodeState nodeState) {
-            return cache.hasNodeReferences(id);
+            return cache.hasReferingStates(nodeState);
-    public void importXml(NodeId parentId, InputStream xmlStream, int uuidBehaviour) throws RepositoryException, LockException, ConstraintViolationException, AccessDeniedException, UnsupportedRepositoryOperationException, ItemExistsException, VersionException {
+    public void importXml(NodeState parentState, InputStream xmlStream, int uuidBehaviour) throws RepositoryException, LockException, ConstraintViolationException, AccessDeniedException, UnsupportedRepositoryOperationException, ItemExistsException, VersionException {
+        // TODO check retrieval of nodeId
+        NodeId parentId = parentState.getNodeId();
-            NodeId nId = operation.getNodeId();
-            NodeId[] versionIds = operation.getVersionIds();
-            NodeId[] vIds = new NodeId[versionIds.length];
-            for (int i = 0; i < vIds.length; i++) {
-                vIds[i] = versionIds[i];
+            NodeState nState = operation.getNodeState();
+            NodeState[] versionStates = operation.getVersionStates();
+            if (versionStates == null || versionStates.length == 0) {
+                throw new IllegalArgumentException("Restore must specify at least a singe version.");
-            if (nId == null) {
+            NodeId[] vIds = new NodeId[versionStates.length];
+            for (int i = 0; i < vIds.length; i++) {
+                vIds[i] = versionStates[i].getNodeId();
+            }
+
+            if (nState == null) {
-                events = service.restore(sessionInfo, nId, vIds[0], operation.removeExisting());
+
+                NodeId targetId;
+                Path relPath = operation.getRelativePath();
+                if (relPath != null) {
+                    targetId = getIdFactory().createNodeId(nState.getNodeId(), relPath);
+                } else {
+                    targetId = nState.getNodeId();
+                }
+                events = service.restore(sessionInfo, targetId, vIds[0], operation.removeExisting());

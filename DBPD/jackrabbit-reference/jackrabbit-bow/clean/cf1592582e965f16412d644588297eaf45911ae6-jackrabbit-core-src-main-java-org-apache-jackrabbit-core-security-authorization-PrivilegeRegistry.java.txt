JCR-2887 : Split PrivilegeRegistry in a per-session manager instance and a repository level registry [work in progress]

- clustering support
- move definition & def-reader/writer to spi-commons

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1095338 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.commons.privilege.ParseException;
-import org.apache.jackrabbit.commons.privilege.PrivilegeDefinition;
-import org.apache.jackrabbit.commons.privilege.PrivilegeDefinitionReader;
-import org.apache.jackrabbit.commons.privilege.PrivilegeDefinitionWriter;
+import org.apache.jackrabbit.core.cluster.PrivilegeEventChannel;
+import org.apache.jackrabbit.core.cluster.PrivilegeEventListener;
+import org.apache.jackrabbit.spi.commons.privilege.ParseException;
+import org.apache.jackrabbit.spi.commons.privilege.PrivilegeDefinition;
+import org.apache.jackrabbit.spi.commons.privilege.PrivilegeDefinitionReader;
+import org.apache.jackrabbit.spi.commons.privilege.PrivilegeDefinitionWriter;
+import java.util.Collection;
-public final class PrivilegeRegistry {
+public final class PrivilegeRegistry implements PrivilegeEventListener {
+    /**
+     * Privilege event channel for clustering support.
+     */
+    private PrivilegeEventChannel eventChannel;
+
+    /**
+     * Create a new <code>PrivilegeRegistry</code> instance.
+     *
+     * @param namespaceRegistry
+     * @param fs
+     * @throws RepositoryException
+     */
-        registerDefinitions(createBuiltInPrivilegeDefinitions());
+        cacheDefinitions(createBuiltInPrivilegeDefinitions());
-            Map<Name, DefinitionStub> customDefs = customPrivilegesStore.load();
+            Map<Name, PrivilegeDefinition> customDefs = customPrivilegesStore.load();
-            registerDefinitions(definitions);
+            cacheDefinitions(definitions);
-        registerDefinitions(createBuiltInPrivilegeDefinitions());
+        cacheDefinitions(createBuiltInPrivilegeDefinitions());
+
+    //---------------------------------------------< PrivilegeEventListener >---
+    /**
+     * @inheritDoc
+     * @see PrivilegeEventListener#externalRegisteredPrivileges(java.util.Collection)
+     */
+    public void externalRegisteredPrivileges(Collection<PrivilegeDefinition> definitions) throws RepositoryException {
+        Map<Name, PrivilegeDefinition> defs = new HashMap<Name, PrivilegeDefinition>(definitions.size());
+        for (PrivilegeDefinition d : definitions) {
+            defs.put(d.getName(), d);
+        }
+        registerCustomDefinitions(defs);
+    }
+
+    //----------------------------------------< public methods : clustering >---
+
+    /**
+     * Set a clustering event channel to inform about changes.
+     *
+     * @param eventChannel event channel
+     */
+    public void setEventChannel(PrivilegeEventChannel eventChannel) {
+        this.eventChannel = eventChannel;
+        eventChannel.setListener(this);
+    }
+
+    //--------------------------------< public methods : privilege registry >---
-        if (customPrivilegesStore == null) {
-            throw new UnsupportedOperationException("No privilege store defined.");
-        }
-        synchronized (registeredPrivileges) {
-            Map<Name, DefinitionStub> stubs = Collections.singletonMap(privilegeName, new DefinitionStub(privilegeName, isAbstract, declaredAggregateNames));
-            Map<Name, Definition> definitions = createCustomDefinitions(stubs);
-            try {
-                // write the new custom privilege to the store and upon successful
-                // update of the file system resource add finally it to the map of
-                // registered privileges.
-                customPrivilegesStore.append(definitions);
-                registerDefinitions(definitions);
+        Map<Name, PrivilegeDefinition> stubs = Collections.singletonMap(privilegeName, new PrivilegeDefinition(privilegeName, isAbstract, declaredAggregateNames));
+        registerCustomDefinitions(stubs);
-            } catch (IOException e) {
-                throw new RepositoryException("Failed to register custom privilege " + privilegeName.toString(), e);
-            } catch (FileSystemException e) {
-                throw new RepositoryException("Failed to register custom privilege " + privilegeName.toString(), e);
-            } catch (ParseException e) {
-                throw new RepositoryException("Failed to register custom privilege " + privilegeName.toString(), e);
-            }
-        }
-
-        for (Listener l : listeners.keySet()) {
-            l.privilegeRegistered(privilegeName);
+        // inform clustering about the new privilege.
+        if (eventChannel != null) {
+            eventChannel.registeredPrivileges(stubs.values());
-    Definition[] getAll() {
+    PrivilegeDefinition[] getAll() {
-    Definition get(Name name) {
+    PrivilegeDefinition get(Name name) {
-                    customNames.add(def.name);
-                    if (!def.declaredAggregateNames.isEmpty()) {
+                    customNames.add(def.getName());
+                    if (!def.getDeclaredAggregateNames().isEmpty()) {
-                customNames.removeAll(aggregate.declaredAggregateNames);
+                customNames.removeAll(aggregate.getDeclaredAggregateNames());
+    /**
+     * Return the privilege bits for the specified privilege definitions.
+     *
+     * @param definitions
+     * @return privilege bits.
+     */
+    PrivilegeBits getBits(PrivilegeDefinition... definitions) {
+        PrivilegeBits bts = PrivilegeBits.getInstance();
+        for (PrivilegeDefinition d : definitions) {
+            if (d instanceof Definition) {
+                bts.add(((Definition) d).bits);
+            }
+        }
+        return bts;
+    }
+
+    /**
+     * Add a privilege registration listener.
+     * 
+     * @param listener
+     */
+     * Register the specified custom privilege definitions.
+     * 
+     * @param stubs
+     * @throws RepositoryException If an error occurs.
+     */
+    private void registerCustomDefinitions(Map<Name, PrivilegeDefinition> stubs) throws RepositoryException {
+        if (customPrivilegesStore == null) {
+            throw new UnsupportedOperationException("No privilege store defined.");
+        }
+        synchronized (registeredPrivileges) {
+            Map<Name, Definition> definitions = createCustomDefinitions(stubs);
+            try {
+                // write the new custom privilege to the store and upon successful
+                // update of the file system resource add finally it to the map of
+                // registered privileges.
+                customPrivilegesStore.append(definitions);
+                cacheDefinitions(definitions);
+
+            } catch (IOException e) {
+                throw new RepositoryException("Failed to register custom privilegess.", e);
+            } catch (FileSystemException e) {
+                throw new RepositoryException("Failed to register custom privileges.", e);
+            } catch (ParseException e) {
+                throw new RepositoryException("Failed to register custom privileges.", e);
+            }
+        }
+
+        for (Listener l : listeners.keySet()) {
+            l.privilegesRegistered(stubs.keySet());
+        }
+    }
+
+    /**
-    private void registerDefinitions(Map<Name, Definition> definitions) {
+    private void cacheDefinitions(Map<Name, Definition> definitions) {
-            bitsToNames.put(def.bits, Collections.singleton(def.name));
+            bitsToNames.put(def.bits, Collections.singleton(def.getName()));
-            Set<Name> allAggrNames = all.declaredAggregateNames;
+            Set<Name> allAggrNames = new HashSet<Name>(all.getDeclaredAggregateNames());
-        defs.put(jcrWrite.name, jcrWrite);
+        defs.put(jcrWrite.getName(), jcrWrite);
-        defs.put(repWrite.name, repWrite);
+        defs.put(repWrite.getName(), repWrite);
-        defs.put(jcrAll.name, jcrAll);
+        defs.put(jcrAll.getName(), jcrAll);
-    private Map<Name, Definition> createCustomDefinitions(Map<Name, DefinitionStub> toRegister) throws RepositoryException {
+    private Map<Name, Definition> createCustomDefinitions(Map<Name, PrivilegeDefinition> toRegister) throws RepositoryException {
-        Set<DefinitionStub> aggregates = new HashSet<DefinitionStub>();
+        Set<PrivilegeDefinition> aggregates = new HashSet<PrivilegeDefinition>();
-        for (DefinitionStub stub : toRegister.values()) {
-            Name name = stub.name;
+        for (PrivilegeDefinition stub : toRegister.values()) {
+            Name name = stub.getName();
-            namespaceRegistry.getPrefix(stub.name.getNamespaceURI());
+            namespaceRegistry.getPrefix(name.getNamespaceURI());
-            if (stub.declaredAggregateNames.isEmpty()) {
+            Set<Name> dagn = stub.getDeclaredAggregateNames();
+            if (dagn.isEmpty()) {
-                for (Name declaredAggregateName : stub.declaredAggregateNames) {
+                for (Name declaredAggregateName : dagn) {
-            for (Iterator<DefinitionStub> itr = aggregates.iterator(); itr.hasNext();) {
-                DefinitionStub stub = itr.next();
-                PrivilegeBits bts = getAggregateBits(stub.declaredAggregateNames, definitions);
+            for (Iterator<PrivilegeDefinition> itr = aggregates.iterator(); itr.hasNext();) {
+                PrivilegeDefinition stub = itr.next();
+                PrivilegeBits bts = getAggregateBits(stub.getDeclaredAggregateNames(), definitions);
-                        throw new RepositoryException("Custom aggregate privilege '" + stub.name + "' is already covered by '" + existingName.toString() + "'");
+                        throw new RepositoryException("Custom aggregate privilege '" + stub.getName() + "' is already covered by '" + existingName.toString() + "'");
-                            throw new RepositoryException("Custom aggregate privilege '" + stub.name + "' is already defined by '"+ d.name+"'");
+                            throw new RepositoryException("Custom aggregate privilege '" + stub.getName() + "' is already defined by '"+ d.getName()+"'");
-                    definitions.put(def.name, def);
+                    definitions.put(def.getName(), def);
-    private boolean isCircularAggregation(DefinitionStub def, Name declaredAggregateName, Map<Name, DefinitionStub> toRegister) {
-        DefinitionStub d = toRegister.get(declaredAggregateName);
-        if (d.declaredAggregateNames.isEmpty()) {
+    private boolean isCircularAggregation(PrivilegeDefinition def, Name declaredAggregateName, Map<Name, PrivilegeDefinition> toRegister) {
+        PrivilegeDefinition d = toRegister.get(declaredAggregateName);
+        if (d.getDeclaredAggregateNames().isEmpty()) {
-            for (Name n : d.declaredAggregateNames) {
-                if (def.name.equals(n)) {
+            for (Name n : d.getDeclaredAggregateNames()) {
+                if (def.getName().equals(n)) {
-         * @param privilegeName The name of the new privilege
+         * @param privilegeNames
-        void privilegeRegistered(Name privilegeName);
-    }
-
-
-    /**
-     * Raw, non-validated stub of a PrivilegeDefinition
-     */
-    private static class DefinitionStub {
-        
-        protected final Name name;
-        protected final boolean isAbstract;
-        protected final Set<Name> declaredAggregateNames;
-
-        private int hashCode;
-
-        private DefinitionStub(Name name, boolean isAbstract, Set<Name> declaredAggregateNames) {
-            this.name = name;
-            this.isAbstract = isAbstract;
-            this.declaredAggregateNames = (declaredAggregateNames == null) ? Collections.<Name>emptySet() : declaredAggregateNames;
-        }
-
-        //---------------------------------------------------------< Object >---
-        @Override
-        public String toString() {
-            return name.toString();
-        }
-
-        @Override
-        public int hashCode() {
-            if (hashCode == 0) {
-                int h = 17;
-                h = 37 * h + name.hashCode();
-                h = 37 * h + Boolean.valueOf(isAbstract).hashCode();
-                /* NOTE: evaluation of decl-aggr-names is sufficient as
-                   uniqueness is asserted upon registration */
-                h = 37 * h + declaredAggregateNames.hashCode();
-                hashCode = h;
-            }
-            return hashCode;
-        }
-
-        @Override
-        public boolean equals(Object obj) {
-            if (obj == this) {
-                return true;
-            }
-            if (obj instanceof DefinitionStub) {
-                DefinitionStub other = (DefinitionStub) obj;
-                return name.equals(other.name)
-                        && isAbstract==other.isAbstract
-                        /* NOTE: comparison of decl-aggr-names is sufficient as
-                           uniqueness is asserted upon registration */
-                        && declaredAggregateNames.equals(other.declaredAggregateNames);
-            }
-            return false;
-        }
+        void privilegesRegistered(Set<Name> privilegeNames);
-     * Internal definition of a jcr level privilege.
+     * Internal definition of a JCR privilege extending from the general
+     * privilege definition. It defines addition information that ease
+     * the evaluation of privileges.
-    static class Definition extends DefinitionStub {
+    private static class Definition extends PrivilegeDefinition {
-        private Definition(DefinitionStub stub, PrivilegeBits bits) {
-            this(stub.name, stub.isAbstract, stub.declaredAggregateNames, bits, true);
+        private Definition(PrivilegeDefinition stub, PrivilegeBits bits) {
+            this(stub.getName(), stub.isAbstract(), stub.getDeclaredAggregateNames(), bits, true);
-        Name getName() {
-            return name;
-        }
-
-        PrivilegeBits getBits() {
-            return bits;
-        }
-
-        boolean isAbstract() {
-            return isAbstract;
-        }
-
-        Name[] getDeclaredAggregateNames() {
-            if (declaredAggregateNames.isEmpty()) {
-                return Name.EMPTY_ARRAY;
-            } else {
-                return declaredAggregateNames.toArray(new Name[declaredAggregateNames.size()]);
-            }
-        }
-
-                int h = 17;
-                h = 37 * h + name.hashCode();
-                h = 37 * h + Boolean.valueOf(isAbstract).hashCode();
+                int h = super.hashCode();
-                return name.equals(other.name)
-                        && isAbstract==other.isAbstract
-                        && bits.equals(other.bits);
+                return bits.equals(other.bits) && super.equals(other);
-        private Map<Name, DefinitionStub> load() throws FileSystemException, RepositoryException, ParseException, IOException {
-            Map<Name, DefinitionStub> stubs = new LinkedHashMap<Name, DefinitionStub>();
+        private Map<Name, PrivilegeDefinition> load() throws FileSystemException, RepositoryException, ParseException, IOException {
+            Map<Name, PrivilegeDefinition> stubs = new LinkedHashMap<Name, PrivilegeDefinition>();
-
-                        Name privName = getName(def.getName());
-                        boolean isAbstract = def.isAbstract();
-                        Set<Name> declaredAggrNames = new HashSet<Name>();
-                        for (String dan : def.getDeclaredAggregateNames()) {
-                            declaredAggrNames.add(getName(dan));
-                        }
-
+                        Name privName = def.getName();
-                        stubs.put(privName, new DefinitionStub(privName, isAbstract, declaredAggrNames));
+                        stubs.put(privName, def);
-        private Name getName(String jcrName) throws RepositoryException {
-            String uri = namespaceRegistry.getURI(Text.getNamespacePrefix(jcrName));
-            return NAME_FACTORY.create(uri, Text.getLocalName(jcrName));
-        }
-
-                String name = resolver.getJCRName(d.name);
-                String uri = d.name.getNamespaceURI();
+                String uri = d.getName().getNamespaceURI();
-                String[] aggrNames = new String[d.declaredAggregateNames.size()];
-                int i = 0;
-                for (Name dan : d.declaredAggregateNames) {
-                    aggrNames[i++] = resolver.getJCRName(dan);
-                    uri = d.name.getNamespaceURI();
+                for (Name dan : d.getDeclaredAggregateNames()) {
+                    uri = dan.getNamespaceURI();
-                PrivilegeDefinition pd = new PrivilegeDefinition(name, d.isAbstract, aggrNames);
-                jcrDefs.add(pd);
+                jcrDefs.add(d);

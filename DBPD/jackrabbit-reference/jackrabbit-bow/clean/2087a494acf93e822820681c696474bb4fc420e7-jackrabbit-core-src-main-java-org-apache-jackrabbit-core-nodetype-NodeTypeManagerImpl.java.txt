JCR-2064 Add new JSR283 features to CND reader/writer
JCR-2153 Introduce QValueConstraint and change return type of QPropertyDefinition.getValueConstraints()
JCR-2158 Consolidate CND related classes from SPI and Core


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@785777 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.collections.map.ReferenceMap;
-import org.apache.jackrabbit.api.JackrabbitNodeTypeManager;
-import javax.jcr.nodetype.InvalidNodeTypeDefinitionException;
-import org.apache.jackrabbit.commons.NamespaceHelper;
-import org.apache.jackrabbit.commons.iterator.NodeTypeIteratorAdapter;
-import org.apache.jackrabbit.spi.commons.conversion.NameException;
-import org.apache.jackrabbit.spi.commons.nodetype.compact.ParseException;
-import org.apache.jackrabbit.core.SessionImpl;
-import org.apache.jackrabbit.core.data.DataStore;
-import org.apache.jackrabbit.core.nodetype.compact.CompactNodeTypeDefReader;
-
-import javax.jcr.nodetype.NodeTypeDefinition;
-import javax.jcr.nodetype.NodeTypeExistsException;
-
-import org.apache.jackrabbit.core.nodetype.xml.NodeTypeReader;
-import org.apache.jackrabbit.core.util.Dumpable;
-import org.apache.jackrabbit.core.value.InternalValue;
-import org.apache.jackrabbit.spi.commons.namespace.NamespaceMapping;
-import org.apache.jackrabbit.spi.commons.nodetype.AbstractNodeTypeManager;
-import org.apache.jackrabbit.spi.Name;
-import org.xml.sax.InputSource;
-import org.xml.sax.SAXException;
-
-import javax.jcr.NamespaceException;
-import javax.jcr.RepositoryException;
-import javax.jcr.UnsupportedRepositoryOperationException;
-import javax.jcr.Value;
-import javax.jcr.ValueFormatException;
-import javax.jcr.ValueFactory;
-import javax.jcr.nodetype.NoSuchNodeTypeException;
-import javax.jcr.nodetype.NodeDefinition;
-import javax.jcr.nodetype.NodeType;
-import javax.jcr.nodetype.NodeTypeIterator;
-import javax.jcr.nodetype.PropertyDefinition;
+import javax.jcr.NamespaceException;
+import javax.jcr.RepositoryException;
+import javax.jcr.UnsupportedRepositoryOperationException;
+import javax.jcr.Value;
+import javax.jcr.ValueFactory;
+import javax.jcr.ValueFormatException;
+import javax.jcr.nodetype.InvalidNodeTypeDefinitionException;
+import javax.jcr.nodetype.NoSuchNodeTypeException;
+import javax.jcr.nodetype.NodeDefinition;
+import javax.jcr.nodetype.NodeType;
+import javax.jcr.nodetype.NodeTypeDefinition;
+import javax.jcr.nodetype.NodeTypeExistsException;
+import javax.jcr.nodetype.NodeTypeIterator;
+import javax.jcr.nodetype.PropertyDefinition;
+
+import org.apache.commons.collections.map.ReferenceMap;
+import org.apache.jackrabbit.api.JackrabbitNodeTypeManager;
+import org.apache.jackrabbit.commons.NamespaceHelper;
+import org.apache.jackrabbit.commons.iterator.NodeTypeIteratorAdapter;
+import org.apache.jackrabbit.core.SessionImpl;
+import org.apache.jackrabbit.core.data.DataStore;
+import org.apache.jackrabbit.core.nodetype.xml.NodeTypeReader;
+import org.apache.jackrabbit.core.util.Dumpable;
+import org.apache.jackrabbit.core.value.InternalValue;
+import org.apache.jackrabbit.spi.Name;
+import org.apache.jackrabbit.spi.QNodeTypeDefinition;
+import org.apache.jackrabbit.spi.QValueConstraint;
+import org.apache.jackrabbit.spi.commons.conversion.NameException;
+import org.apache.jackrabbit.spi.commons.namespace.NamespaceMapping;
+import org.apache.jackrabbit.spi.commons.nodetype.AbstractNodeTypeManager;
+import org.apache.jackrabbit.spi.commons.nodetype.InvalidConstraintException;
+import org.apache.jackrabbit.spi.commons.nodetype.compact.CompactNodeTypeDefReader;
+import org.apache.jackrabbit.spi.commons.nodetype.compact.ParseException;
+import org.apache.jackrabbit.spi.commons.nodetype.constraint.ValueConstraint;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+
-    private final Map ntCache;
+    private final Map<Name, NodeTypeImpl> ntCache;
-    private final Map pdCache;
+    private final Map<PropDefId, PropertyDefinitionImpl> pdCache;
-    private final Map ndCache;
+    private final Map<NodeDefId, NodeDefinitionImpl> ndCache;
+     * @param store      the data store
+    @SuppressWarnings("unchecked")
-     * @param id
+     * @param id node def id
-            NodeDefinitionImpl ndi = (NodeDefinitionImpl) ndCache.get(id);
+            NodeDefinitionImpl ndi = ndCache.get(id);
-     * @param id
+     * @param id prop def id
-            PropertyDefinitionImpl pdi = (PropertyDefinitionImpl) pdCache.get(id);
+            PropertyDefinitionImpl pdi = pdCache.get(id);
-     * @param name
-     * @return
-     * @throws NoSuchNodeTypeException
+     * @param name node type name
+     * @return node type
+     * @throws NoSuchNodeTypeException if the nodetype does not exit
-            NodeTypeImpl nt = (NodeTypeImpl) ntCache.get(name);
+            NodeTypeImpl nt = ntCache.get(name);
-            Map namespaceMap = new HashMap();
-            List nodeTypeDefs = new ArrayList();
+            Map<String, String> namespaceMap = new HashMap<String, String>();
+            List<NodeTypeDef> nodeTypeDefs = new ArrayList<NodeTypeDef>();
-
-                    nodeTypeDefs.addAll(reader.getNodeTypeDefs());
+                    for (QNodeTypeDefinition ntDef: reader.getNodeTypeDefinitions()) {
+                        nodeTypeDefs.add(new NodeTypeDef(ntDef));
+                    }
-                List newNodeTypeDefs = new ArrayList();
-                List registeredNodeTypeDefs = new ArrayList();
-                for (Iterator iter = nodeTypeDefs.iterator(); iter.hasNext();) {
-                    NodeTypeDef nodeTypeDef = (NodeTypeDef) iter.next();
+                List<NodeTypeDef> newNodeTypeDefs = new ArrayList<NodeTypeDef>();
+                List<NodeTypeDef> registeredNodeTypeDefs = new ArrayList<NodeTypeDef>();
+                for (NodeTypeDef nodeTypeDef: nodeTypeDefs) {
-                ArrayList nodeTypes = new ArrayList();
+                ArrayList<NodeType> nodeTypes = new ArrayList<NodeType>();
-                // reregister already existing node types
-                for (Iterator iter = registeredNodeTypeDefs.iterator(); iter.hasNext();) {
-                    NodeTypeDef nodeTypeDef = (NodeTypeDef) iter.next();
+                // re-register already existing node types
+                for (NodeTypeDef nodeTypeDef: registeredNodeTypeDefs) {
-                return (NodeType[]) nodeTypes.toArray(new NodeType[nodeTypes.size()]);
+                return nodeTypes.toArray(new NodeType[nodeTypes.size()]);
-                Collection types = registerNodeTypes(nodeTypeDefs);
-                return (NodeType[]) types.toArray(new NodeType[types.size()]);
+                Collection<NodeType> types = registerNodeTypes(nodeTypeDefs);
+                return types.toArray(new NodeType[types.size()]);
-        ArrayList list = new ArrayList(ntNames.length);
-        for (int i = 0; i < ntNames.length; i++) {
-            list.add(getNodeType(ntNames[i]));
+        ArrayList<NodeType> list = new ArrayList<NodeType>(ntNames.length);
+        for (Name ntName : ntNames) {
+            list.add(getNodeType(ntName));
-        ArrayList list = new ArrayList(ntNames.length);
-        for (int i = 0; i < ntNames.length; i++) {
-            NodeType nt = getNodeType(ntNames[i]);
+        ArrayList<NodeType> list = new ArrayList<NodeType>(ntNames.length);
+        for (Name ntName : ntNames) {
+            NodeType nt = getNodeType(ntName);
-        ArrayList list = new ArrayList(ntNames.length);
-        for (int i = 0; i < ntNames.length; i++) {
-            NodeType nt = getNodeType(ntNames[i]);
+        ArrayList<NodeType> list = new ArrayList<NodeType>(ntNames.length);
+        for (Name ntName : ntNames) {
+            NodeType nt = getNodeType(ntName);
-     * @returns registered node types
-     * @throws InvalidNodeTypeDefException
-     * @throws RepositoryException
+     * @return registered node types
+     * @throws InvalidNodeTypeDefException if a nodetype is invalid
+     * @throws RepositoryException if an error occurs
-    private Collection registerNodeTypes(List defs)
+    private Collection<NodeType> registerNodeTypes(List<NodeTypeDef> defs)
-        Set types = new HashSet();
-        Iterator iterator = defs.iterator();
-        while (iterator.hasNext()) {
+        Set<NodeType> types = new HashSet<NodeType>();
+        for (NodeTypeDef def : defs) {
-                NodeTypeDef def = (NodeTypeDef) iterator.next();
-        List addedDefs = new ArrayList();
-        List modifiedDefs = new ArrayList();
+        List<NodeTypeDef> addedDefs = new ArrayList<NodeTypeDef>();
+        List<NodeTypeDef> modifiedDefs = new ArrayList<NodeTypeDef>();
-            ArrayList result = new ArrayList();
+            ArrayList<NodeType> result = new ArrayList<NodeType>();
-            // reregister already existing node types
-            for (Iterator iter = modifiedDefs.iterator(); iter.hasNext();) {
-                NodeTypeDef nodeTypeDef = (NodeTypeDef) iter.next();
+            // re-register already existing node types
+            for (NodeTypeDef nodeTypeDef: modifiedDefs) {
-        HashSet ntNames = new HashSet();
-        for (int i = 0; i < names.length; i++) {
+        Set<Name> ntNames = new HashSet<Name>();
+        for (String name : names) {
-                ntNames.add(session.getQName(names[i]));
+                ntNames.add(session.getQName(name));
-                throw new RepositoryException("Invalid name: " + names[i], e);
+                throw new RepositoryException("Invalid name: " + name, e);
-                throw new RepositoryException("Invalid name: " + names[i], e);
+                throw new RepositoryException("Invalid name: " + name, e);
-     * @param definition
+     * @param definition the definition
-     * @throws InvalidNodeTypeDefinitionException
-     * @throws RepositoryException
+     * @throws InvalidNodeTypeDefinitionException if the definiton is invalid
+     * @throws RepositoryException if a repository error occurs
-                    ValueConstraint[] qconstraints = new ValueConstraint[constraints.length];
+                    QValueConstraint[] qconstraints = new QValueConstraint[constraints.length];

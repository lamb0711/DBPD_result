JCR-2762: Optimize bundle serialization

Use a bit field to optimize for common mixin type, property, child node, and shared set counts.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1022942 13f79535-47bb-0310-9956-ffa450edef68

-import static org.apache.jackrabbit.core.persistence.util.BundleBinding.NULL_NODE_ID;
-
-
-        // read primary type...special handling
-        Name nodeTypeName;
-            nodeTypeName = readName();
+            readBundleNew(bundle);
-            int a = in.readUnsignedByte();
-            int b = in.readUnsignedByte();
-            int c = in.readUnsignedByte();
-            String uri = binding.nsIndex.indexToString(a << 16 | b << 8 | c);
-            String local = binding.nameIndex.indexToString(in.readInt());
-            nodeTypeName = NameFactoryImpl.getInstance().create(uri, local);
+            readBundleOld(bundle);
-        bundle.setNodeTypeName(nodeTypeName);
+        return bundle;
+    }
+
+    private void readBundleNew(NodePropBundle bundle) throws IOException {
+        // node type
+        bundle.setNodeTypeName(readName());
+
+        // parentUUID
+        NodeId parentId = readNodeId();
+        if (BundleBinding.NULL_PARENT_ID.equals(parentId)) {
+            parentId = null;
+        }
+        bundle.setParentId(parentId);
+
+        // read modcount
+        bundle.setModCount((short) readVarInt());
+
+        int b = in.readUnsignedByte();
+        bundle.setReferenceable((b & 1) != 0);
+
+        // mixin types
+        int mn = readVarInt((b >> 7) & 1, 1);
+        if (mn == 0) {
+            bundle.setMixinTypeNames(Collections.<Name>emptySet());
+        } else if (mn == 1) {
+            bundle.setMixinTypeNames(Collections.singleton(readName()));
+        } else {
+            Set<Name> mixins = new HashSet<Name>(mn * 2);
+            for (int i = 0; i < mn; i++) {
+                mixins.add(readName());
+            }
+            bundle.setMixinTypeNames(mixins);
+        }
+
+        // properties
+        int pn = readVarInt((b >> 4) & 7, 7);
+        for (int i = 0; i < pn; i++) {
+            PropertyId id = new PropertyId(bundle.getId(), readName());
+            bundle.addProperty(readPropertyEntry(id));
+        }
+
+        // child nodes (list of name/uuid pairs)
+        int nn = readVarInt((b >> 2) & 3, 3);
+        for (int i = 0; i < nn; i++) {
+            Name name = readQName();
+            NodeId id = readNodeId();
+            bundle.addChildNodeEntry(name, id);
+        }
+
+        // read shared set
+        int sn = readVarInt((b >> 1) & 1, 1);
+        if (sn == 0) {
+            bundle.setSharedSet(Collections.<NodeId>emptySet());
+        } else if (sn == 1) {
+            bundle.setSharedSet(Collections.singleton(readNodeId()));
+        } else {
+            Set<NodeId> shared = new HashSet<NodeId>();
+            for (int i = 0; i < sn; i++) {
+                shared.add(readNodeId());
+            }
+            bundle.setSharedSet(shared);
+        }
+    }
+
+    private void readBundleOld(NodePropBundle bundle) throws IOException {
+        // read primary type...special handling
+        int a = in.readUnsignedByte();
+        int b = in.readUnsignedByte();
+        int c = in.readUnsignedByte();
+        String uri = binding.nsIndex.indexToString(a << 16 | b << 8 | c);
+        String local = binding.nameIndex.indexToString(in.readInt());
+        bundle.setNodeTypeName(
+                NameFactoryImpl.getInstance().create(uri, local));
-        if (version < BundleBinding.VERSION_3) {
-            // definitionId
-            in.readUTF();
-        }
+        // definitionId
+        in.readUTF();
-        readMixinTypes(bundle);
+        Name name = readIndexedQName();
+        if (name != null) {
+            Set<Name> mixinTypeNames = new HashSet<Name>();
+            do {
+                mixinTypeNames.add(name);
+                name = readIndexedQName();
+            } while (name != null);
+            bundle.setMixinTypeNames(mixinTypeNames);
+        } else {
+            bundle.setMixinTypeNames(Collections.<Name>emptySet());
+        }
-        readProperties(bundle);
+        name = readIndexedQName();
+        while (name != null) {
+            PropertyId pId = new PropertyId(bundle.getId(), name);
+            NodePropBundle.PropertyEntry pState = readPropertyEntry(pId);
+            // skip redundant primaryType, mixinTypes and uuid properties
+            if (!name.equals(NameConstants.JCR_PRIMARYTYPE)
+                    && !name.equals(NameConstants.JCR_MIXINTYPES)
+                    && !name.equals(NameConstants.JCR_UUID)) {
+                bundle.addProperty(pState);
+            }
+            name = readIndexedQName();
+        }
-        readChildNodeEntries(bundle);
+        NodeId childId = readNodeId();
+        while (childId != null) {
+            bundle.addChildNodeEntry(readQName(), childId);
+            childId = readNodeId();
+        }
-        if (version >= BundleBinding.VERSION_3) {
-            bundle.setModCount((short) readVarInt());
-        } else if (version >= BundleBinding.VERSION_1) {
+        if (version >= BundleBinding.VERSION_1) {
-        readSharedSet(bundle);
-
-        return bundle;
-    }
-
-    private void readMixinTypes(NodePropBundle bundle) throws IOException {
-        if (version >= BundleBinding.VERSION_3) {
-            int n = readVarInt();
-            if (n == 0) {
-                bundle.setMixinTypeNames(Collections.<Name>emptySet());
-            } else if (n == 1) {
-                bundle.setMixinTypeNames(Collections.singleton(readName()));
-            } else {
-                Set<Name> mixins = new HashSet<Name>(n * 2);
-                for (int i = 0; i < n; i++) {
-                    mixins.add(readName());
-                }
-                bundle.setMixinTypeNames(mixins);
-            }
-        } else {
-            Name name = readIndexedQName();
-            if (name == null) {
-                bundle.setMixinTypeNames(Collections.<Name>emptySet());
-            } else {
-                Set<Name> mixinTypeNames = new HashSet<Name>();
-                do {
-                    mixinTypeNames.add(name);
-                    name = readIndexedQName();
-                } while (name != null);
-                bundle.setMixinTypeNames(mixinTypeNames);
-            }
-        }
-    }
-
-    private void readProperties(NodePropBundle bundle) throws IOException {
-        if (version >= BundleBinding.VERSION_3) {
-            int n = readVarInt();
-            for (int i = 0; i < n; i++) {
-                PropertyId id = new PropertyId(bundle.getId(), readName());
-                bundle.addProperty(readPropertyEntry(id));
-            }
-        } else {
-            Name name = readIndexedQName();
-            while (name != null) {
-                PropertyId pId = new PropertyId(bundle.getId(), name);
-                NodePropBundle.PropertyEntry pState = readPropertyEntry(pId);
-                // skip redundant primaryType, mixinTypes and uuid properties
-                if (!name.equals(NameConstants.JCR_PRIMARYTYPE)
-                        && !name.equals(NameConstants.JCR_MIXINTYPES)
-                        && !name.equals(NameConstants.JCR_UUID)) {
-                    bundle.addProperty(pState);
-                }
-                name = readIndexedQName();
-            }
-        }
-    }
-
-    private void readSharedSet(NodePropBundle bundle) throws IOException {
-        Set<NodeId> sharedSet;
-        if (version >= BundleBinding.VERSION_3) {
-            int n = readVarInt();
-            if (n == 0) {
-                sharedSet = Collections.emptySet();
-            } else if (n == 1) {
-                sharedSet = Collections.singleton(readNodeId());
-            } else {
-                sharedSet = new HashSet<NodeId>();
-                for (int i = 0; i < n; i++) {
-                    sharedSet.add(readNodeId());
-                }
-            }
-        } else if (version == BundleBinding.VERSION_2) {
+        if (version >= BundleBinding.VERSION_2) {
-                sharedSet = new HashSet<NodeId>();
+                Set<NodeId> shared = new HashSet<NodeId>();
-                    sharedSet.add(parentId);
+                    shared.add(parentId);
+                bundle.setSharedSet(shared);
-                sharedSet = Collections.emptySet();
+                bundle.setSharedSet(Collections.<NodeId>emptySet());
-            sharedSet = Collections.emptySet();
-        }
-        bundle.setSharedSet(sharedSet);
-    }
-
-    private void readChildNodeEntries(NodePropBundle bundle) throws IOException {
-        if (version >= BundleBinding.VERSION_3) {
-            int n = readVarInt();
-            for (int i = 0; i < n; i++) {
-                NodeId id = readNodeId();
-                Name name = readQName();
-                bundle.addChildNodeEntry(name, id);
-            }
-        } else {
-            NodeId childId = readNodeId();
-            while (childId != null) {
-                bundle.addChildNodeEntry(readQName(), childId);
-                childId = readNodeId();
-            }
+            bundle.setSharedSet(Collections.<NodeId>emptySet());
-            if (msb != NULL_NODE_ID.getMostSignificantBits()
-                    || lsb != NULL_NODE_ID.getLeastSignificantBits()) {
-                return new NodeId(msb, lsb);
-            } else {
-                return null;
-            }
+            return new NodeId(msb, lsb);
+    private int readVarInt(int value, int base) throws IOException {
+        if (value < base) {
+            return value;
+        } else {
+            return readVarInt() + base;
+        }
+    }
+
-        if (len == base) {
-            len += readVarInt();
-        }
-        byte[] bytes = new byte[len];
+        byte[] bytes = new byte[readVarInt(len, base)];

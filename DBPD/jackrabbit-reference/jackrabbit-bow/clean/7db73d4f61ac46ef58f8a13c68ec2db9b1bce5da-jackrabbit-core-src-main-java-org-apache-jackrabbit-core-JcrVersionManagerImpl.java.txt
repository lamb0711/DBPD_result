JCR-2140 Configurations and Baselines


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@796586 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.value.InternalValue;
+import org.apache.jackrabbit.core.version.InternalBaseline;
+import org.apache.jackrabbit.core.version.InternalConfiguration;
-import org.apache.jackrabbit.core.version.JcrVersionManagerImplMerge;
+import org.apache.jackrabbit.core.version.JcrVersionManagerImplConfig;
+import org.apache.jackrabbit.core.version.VersionSet;
-public class JcrVersionManagerImpl extends JcrVersionManagerImplMerge
+public class JcrVersionManagerImpl extends JcrVersionManagerImplConfig
-        // check lock status, holds and permissions
-        int options = ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD |
-                ItemValidator.CHECK_PENDING_CHANGES_ON_NODE;
-        NodeStateEx state = getNodeState(absPath, options, Permission.VERSION_MNGMT);
-        NodeId baseId = checkoutCheckin(state, true, false);
+        NodeStateEx state = getNodeState(absPath,
+                ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD | ItemValidator.CHECK_PENDING_CHANGES_ON_NODE,
+                Permission.VERSION_MNGMT);
+        NodeId baseId;
+        if (isConfiguration(state)) {
+            InternalConfiguration config = vMgr.getConfiguration(state.getNodeId());
+            baseId = checkin(config);
+        } else {
+            baseId = checkoutCheckin(state, true, false);
+        }
-        // check lock status, holds and permissions
-        int options = ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD;
-        NodeStateEx state = getNodeState(absPath, options, Permission.VERSION_MNGMT);
-        checkoutCheckin(state, false, true);
+        NodeStateEx state = getNodeState(absPath,
+                ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD,
+                Permission.VERSION_MNGMT);
+        if (isConfiguration(state)) {
+            // currently has no effect
+        } else {
+            checkoutCheckin(state, false, true);
+        }
-        int options = ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD |
-                ItemValidator.CHECK_PENDING_CHANGES_ON_NODE;
-        NodeStateEx state = getNodeState(absPath, options, Permission.VERSION_MNGMT);
-        NodeId baseId = checkoutCheckin(state, true, true);
+        NodeStateEx state = getNodeState(absPath,
+                ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD | ItemValidator.CHECK_PENDING_CHANGES_ON_NODE,
+                Permission.VERSION_MNGMT);
+        NodeId baseId;
+        if (isConfiguration(state)) {
+            InternalConfiguration config = vMgr.getConfiguration(state.getNodeId());
+            baseId = checkin(config);
+        } else {
+            baseId = checkoutCheckin(state, true, true);
+        }
-        final Map<NodeId, InternalVersion> toRestore = new HashMap<NodeId, InternalVersion>();
+        Map<NodeId, InternalVersion> toRestore = new HashMap<NodeId, InternalVersion>();
-            NodeId historyId = v.getVersionHistory().getId();
-            // check for collision
-            if (toRestore.containsKey(historyId)) {
-                throw new VersionException("Unable to restore. Two or more versions have same version history.");
+            if (v instanceof InternalBaseline) {
+                // do simple explode, ignore restoring of nt:configuration node for now.
+                for (InternalVersion bv: ((InternalBaseline) v).getBaseVersions().versions().values()) {
+                    // check for collision
+                    NodeId historyId = bv.getVersionHistory().getId();
+                    if (toRestore.containsKey(historyId)) {
+                        throw new VersionException("Unable to restore. Two or more versions have same version history.");
+                    }
+                    toRestore.put(historyId, bv);
+                }
+            } else {
+                // check for collision
+                NodeId historyId = v.getVersionHistory().getId();
+                if (toRestore.containsKey(historyId)) {
+                    throw new VersionException("Unable to restore. Two or more versions have same version history.");
+                }
+                toRestore.put(historyId, v);
-            toRestore.put(historyId, v);
-        restore(toRestore, removeExisting);
+        WriteOperation ops = startWriteOperation();
+        try {
+            internalRestore(new VersionSet(toRestore, true), removeExisting);
+            ops.save();
+        } catch (ItemStateException e) {
+            throw new RepositoryException(e);
+        } finally {
+            ops.close();
+        }
-    public void restore(String absPath, String versionName,
-                        boolean removeExisting)
+    public void restore(String absPath, String versionName, boolean removeExisting)
-        int options = ItemValidator.CHECK_PENDING_CHANGES | ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD;
-        NodeStateEx state = getNodeState(absPath, options, Permission.NONE);
-        restore(state, session.getQName(versionName), removeExisting);
+        NodeStateEx state = getNodeState(absPath,
+                ItemValidator.CHECK_PENDING_CHANGES | ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD,
+                Permission.NONE);
+        if (isConfiguration(state)) {
+            InternalConfiguration config = vMgr.getConfiguration(state.getNodeId());
+            restore(config, session.getQName(versionName), removeExisting);
+        } else {
+            restore(state, session.getQName(versionName), removeExisting);
+        }
-
-
-            int options = ItemValidator.CHECK_PENDING_CHANGES | ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD;
-            NodeStateEx state = getNodeState(absPath, options, Permission.NONE);
-            restore(state, version, removeExisting);
+            NodeStateEx state = getNodeState(absPath,
+                    ItemValidator.CHECK_PENDING_CHANGES | ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD,
+                    Permission.NONE);
+            if (isConfiguration(state)) {
+                InternalConfiguration config = vMgr.getConfiguration(state.getNodeId());
+                restore(config, version, removeExisting);
+            } else {
+                restore(state, version, removeExisting);
+            }
-            int options = ItemValidator.CHECK_PENDING_CHANGES | ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD;
-            NodeStateEx state = getNodeState(parent, options, Permission.NONE);
+            NodeStateEx state = getNodeState(parent,
+                    ItemValidator.CHECK_PENDING_CHANGES | ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD,
+                    Permission.NONE);
-    public void restoreByLabel(String absPath, String versionLabel,
-                               boolean removeExisting)
+    public void restoreByLabel(String absPath, String versionLabel, boolean removeExisting)
-        int options = ItemValidator.CHECK_PENDING_CHANGES | ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD;
-        NodeStateEx state = getNodeState(absPath, options, Permission.NONE);
-        restoreByLabel(state, session.getQName(versionLabel), removeExisting);
+        NodeStateEx state = getNodeState(absPath,
+                ItemValidator.CHECK_PENDING_CHANGES | ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD,
+                Permission.NONE);
+        if (isConfiguration(state)) {
+            InternalConfiguration config = vMgr.getConfiguration(state.getNodeId());
+            restoreByLabel(config, session.getQName(versionLabel), removeExisting);
+        } else {
+            restoreByLabel(state, session.getQName(versionLabel), removeExisting);
+        }
-        NodeStateEx state = getNodeState(node, ItemValidator.CHECK_PENDING_CHANGES, Permission.VERSION_MNGMT);
+        NodeStateEx state = getNodeState(node,
+                ItemValidator.CHECK_PENDING_CHANGES,
+                Permission.VERSION_MNGMT);
-        NodeStateEx state = getNodeState(absPath, ItemValidator.CHECK_PENDING_CHANGES, Permission.VERSION_MNGMT);
+        NodeStateEx state = getNodeState(absPath,
+                ItemValidator.CHECK_PENDING_CHANGES,
+                Permission.VERSION_MNGMT);
-        int options = ItemValidator.CHECK_LOCK | ItemValidator.CHECK_VERSIONING | ItemValidator.CHECK_PENDING_CHANGES_ON_NODE | ItemValidator.CHECK_HOLD;
-        NodeStateEx state = getNodeState(absPath, options, Permission.VERSION_MNGMT);
+        NodeStateEx state = getNodeState(absPath,
+                ItemValidator.CHECK_LOCK | ItemValidator.CHECK_PENDING_CHANGES_ON_NODE | ItemValidator.CHECK_HOLD,
+                Permission.VERSION_MNGMT);
-        int options = ItemValidator.CHECK_LOCK | ItemValidator.CHECK_VERSIONING | ItemValidator.CHECK_PENDING_CHANGES_ON_NODE | ItemValidator.CHECK_HOLD;
-        NodeStateEx state = getNodeState(absPath, options, Permission.VERSION_MNGMT);
+        NodeStateEx state = getNodeState(absPath,
+                ItemValidator.CHECK_LOCK | ItemValidator.CHECK_PENDING_CHANGES_ON_NODE | ItemValidator.CHECK_HOLD,
+                Permission.VERSION_MNGMT);
-        throw new UnsupportedRepositoryOperationException("comming soon...");
+        if (session.nodeExists(absPath)) {
+            // refuse to create a configuration if a baseline is specified.
+            if (baseline != null) {
+                throw new UnsupportedRepositoryOperationException(
+                        "Create configuration to existing nodes only allowed without specifying a basline: " + absPath);
+            }
+
+            NodeStateEx state = getNodeState(absPath,
+                    ItemValidator.CHECK_LOCK | ItemValidator.CHECK_PENDING_CHANGES_ON_NODE | ItemValidator.CHECK_HOLD,
+                    Permission.VERSION_MNGMT);
+            // check versionable
+            if (!checkVersionable(state)) {
+                throw new UnsupportedRepositoryOperationException("Node not full versionable: " + absPath);
+            }
+            if (state.getPropertyValue(NameConstants.JCR_CONFIGURATION) != null) {
+                throw new UnsupportedRepositoryOperationException("Node is already a configuration root: " + absPath);
+            }
+
+            WriteOperation ops = startWriteOperation();
+            try {
+                NodeId configId = vMgr.createConfiguration(session, state.getNodeId());
+                state.setPropertyValue(NameConstants.JCR_CONFIGURATION, InternalValue.create(configId));
+                state.store();
+                ops.save();
+                return session.getNodeById(configId);
+            } catch (ItemStateException e) {
+                throw new RepositoryException(e);
+            } finally {
+                ops.close();
+            }
+        } else {
+            // check if supplied baseline is valid
+            if (baseline == null) {
+                throw new UnsupportedRepositoryOperationException(
+                        "CreateConfiguration on non-existing path must supply a baseline: " + absPath);
+            }
+            VersionImpl v = (VersionImpl) baseline;
+            InternalBaseline bl = vMgr.getBaseline(v.getNodeId());
+            if (bl == null) {
+                throw new UnsupportedRepositoryOperationException(
+                        "Supplied version is not a baseline: " + v.safeGetJCRPath());
+            }
+
+            // parent has to exist
+            Path path = session.getQPath(absPath);
+            Path parentPath = path.getAncestor(1);
+            Name name = path.getNameElement().getName();
+            NodeImpl parent = session.getItemManager().getNode(parentPath);
+
+            NodeStateEx state = getNodeState(parent,
+                    ItemValidator.CHECK_PENDING_CHANGES | ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD,
+                    Permission.NONE);
+            InternalConfiguration config = restore(state, name, bl);
+            return session.getNodeById(config.getId());
+        }
+
+    /**
+     * Checks if the given node state is a nt:configuration. Note that this check
+     * is currently used to either avoid versioning operations on nt:configuration
+     * nodes or to use a differnt strategy for such nodes.
+     *
+     * @param state the state to check
+     * @return <code>true</code> if it is a configuration
+     * @throws RepositoryException if an error occurs
+     */
+    private boolean isConfiguration(NodeStateEx state) throws RepositoryException {
+        return state.getEffectiveNodeType().includesNodeType(NameConstants.NT_CONFIGURATION);
+    }
+
+

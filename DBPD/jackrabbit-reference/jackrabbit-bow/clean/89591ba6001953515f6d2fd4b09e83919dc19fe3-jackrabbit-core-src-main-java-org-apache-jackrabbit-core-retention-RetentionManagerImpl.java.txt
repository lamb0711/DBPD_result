JCR-1589: JSR 283 Retention & Hold Management (work in progress)
JCR-1957: Move common validation checks to a single place

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@738422 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.api.jsr283.retention.Hold;
+import org.apache.jackrabbit.api.jsr283.retention.RetentionManager;
+import org.apache.jackrabbit.api.jsr283.retention.RetentionPolicy;
+import org.apache.jackrabbit.core.NodeImpl;
+import org.apache.jackrabbit.core.SessionImpl;
+import org.apache.jackrabbit.core.ProtectedItemModifier;
+import org.apache.jackrabbit.core.PropertyImpl;
+import org.apache.jackrabbit.core.security.authorization.Permission;
+import org.apache.jackrabbit.spi.Name;
+import org.apache.jackrabbit.spi.NameFactory;
+import org.apache.jackrabbit.spi.commons.name.NameFactoryImpl;
-import org.apache.jackrabbit.api.jsr283.retention.RetentionManager;
-import org.apache.jackrabbit.api.jsr283.retention.Hold;
-import org.apache.jackrabbit.api.jsr283.retention.RetentionPolicy;
-import javax.jcr.PathNotFoundException;
+import javax.jcr.PathNotFoundException;
-import javax.jcr.Session;
-import javax.jcr.version.VersionException;
+import javax.jcr.Value;
+import javax.jcr.PropertyType;
+import javax.jcr.version.VersionException;
+import java.util.ArrayList;
+import java.util.List;
-public class RetentionManagerImpl implements RetentionManager {
+public class RetentionManagerImpl extends ProtectedItemModifier implements RetentionManager {
-    private final Session session;
-    
-    public RetentionManagerImpl(Session session) {
+    private static final NameFactory NAME_FACTORY = NameFactoryImpl.getInstance();
+
+    static final Name REP_RETENTION_MANAGEABLE = NAME_FACTORY.create(Name.NS_REP_URI, "RetentionManageable");
+    static final Name REP_HOLD = NAME_FACTORY.create(Name.NS_REP_URI, "hold");
+    static final Name REP_RETENTION_POLICY = NAME_FACTORY.create(Name.NS_REP_URI, "retentionPolicy");
+
+    private final SessionImpl session;
+
+    /**
+     *
+     * @param session The editing session.
+     */
+    public RetentionManagerImpl(SessionImpl session) {
+        super(Permission.RETENTION_MNGMT);
-
+    
+    //---------------------------------------------------< RetentionManager >---
+    /**
+     * @see RetentionManager#getHolds(String)
+     */
-        //TODO
-        return new Hold[0];
+
+        NodeImpl n = (NodeImpl) session.getNode(absPath);
+        session.getAccessManager().checkPermission(session.getQPath(absPath), Permission.RETENTION_MNGMT);        
+
+        Hold[] holds;
+        if (n.isNodeType(REP_RETENTION_MANAGEABLE) && n.hasProperty(REP_HOLD)) {
+            holds = HoldImpl.createFromProperty(n.getProperty(REP_HOLD), n.getNodeId());
+        } else {
+            holds = new Hold[0];
+        }
+        return holds;
+    /**
+     * @see RetentionManager#addHold(String, String, boolean) 
+     */
-        //TODO
-        throw new UnsupportedOperationException("Not yet implemented");
+
+        NodeImpl n = (NodeImpl) session.getNode(absPath);
+        if (!n.isNodeType(REP_RETENTION_MANAGEABLE)) {
+            n.addMixin(REP_RETENTION_MANAGEABLE);
+        }
+
+        HoldImpl hold = new HoldImpl(session.getQName(name), isDeep, n.getNodeId(), session);
+        Value[] vls;
+        if (n.hasProperty(REP_HOLD)) {
+            Value[] vs = n.getProperty(REP_HOLD).getValues();
+            // check if the same hold already exists
+            for (int i = 0; i < vs.length; i++) {
+                if (hold.equals(HoldImpl.createFromValue(vs[i], n.getNodeId(), session))) {
+                    throw new RepositoryException("Hold already exists.");
+                }
+            }
+            vls = new Value[vs.length + 1];
+            System.arraycopy(vs, 0, vls, 0, vs.length);
+        } else {
+            vls = new Value[1];
+        }
+
+        // add the value of the new hold
+        vls[vls.length - 1] = hold.toValue(session.getValueFactory());
+        setProperty(n, REP_HOLD, vls);
+        return hold;
+    /**
+     * @see RetentionManager#removeHold(String, Hold) 
+     */
-        //TODO
-        throw new UnsupportedOperationException("Not yet implemented");
+
+        NodeImpl n = (NodeImpl) session.getNode(absPath);
+        if (hold instanceof HoldImpl
+                && n.getNodeId().equals(((HoldImpl) hold).getNodeId())
+                && n.isNodeType(REP_RETENTION_MANAGEABLE)
+                && n.hasProperty(REP_HOLD)) {
+
+            PropertyImpl p = n.getProperty(REP_HOLD);
+            Value[] vls = p.getValues();
+
+            List newValues = new ArrayList(vls.length - 1);
+            for (int i = 0; i < vls.length; i++) {
+                if (!hold.equals(HoldImpl.createFromValue(vls[i], n.getNodeId(), session))) {
+                    newValues.add(vls[i]);
+                }
+            }
+            if (newValues.size() < vls.length) {
+                if (newValues.size() == 0) {
+                    removeItem(p);
+                } else {
+                    setProperty(n, REP_HOLD, (Value[]) newValues.toArray(new Value[newValues.size()]));
+                }
+            } else {
+                // no matching hold.
+                throw new RepositoryException("Cannot remove '" + hold.getName() + "' at " + absPath + ".");
+            }
+        } else {
+            // invalid hold or no hold at absPath
+            throw new RepositoryException("Cannot remove '" + hold.getName() + "' at " + absPath + ".");
+        }
+    /**
+     * @see RetentionManager#getRetentionPolicy(String) 
+     */
-        // TODO
-        return null;
+
+        NodeImpl n = (NodeImpl) session.getNode(absPath);
+        session.getAccessManager().checkPermission(session.getQPath(absPath), Permission.RETENTION_MNGMT);
+
+        RetentionPolicy rPolicy = null;
+        if (n.isNodeType(REP_RETENTION_MANAGEABLE) && n.hasProperty(REP_RETENTION_POLICY)) {
+            String jcrName = n.getProperty(REP_RETENTION_POLICY).getString();
+            rPolicy = new RetentionPolicyImpl(jcrName, n.getNodeId(), session);
+        }
+        
+        return rPolicy;
+    /**
+     * @see RetentionManager#setRetentionPolicy(String, RetentionPolicy)
+     */
-        //TODO
-        throw new UnsupportedOperationException("Not yet implemented");
+
+        NodeImpl n = (NodeImpl) session.getNode(absPath);
+        if (!(retentionPolicy instanceof RetentionPolicyImpl)) {
+            throw new RepositoryException("Invalid retention policy.");
+        }
+        Value retentionReference = session.getValueFactory().createValue(retentionPolicy.getName(), PropertyType.NAME);
+        if (!n.isNodeType(REP_RETENTION_MANAGEABLE)) {
+            n.addMixin(REP_RETENTION_MANAGEABLE);
+        }
+        setProperty(n, REP_RETENTION_POLICY, retentionReference);
+    /**
+     * @see RetentionManager#removeRetentionPolicy(String) 
+     */
-        //TODO
-        throw new UnsupportedOperationException("Not yet implemented");
+
+        NodeImpl n = (NodeImpl) session.getNode(absPath);
+        if (n.isNodeType(REP_RETENTION_MANAGEABLE) && n.hasProperty(REP_RETENTION_POLICY)) {
+            removeItem(n.getProperty(REP_RETENTION_POLICY));
+        } else {
+            throw new RepositoryException("Cannot remove retention policy at absPath.");
+        }

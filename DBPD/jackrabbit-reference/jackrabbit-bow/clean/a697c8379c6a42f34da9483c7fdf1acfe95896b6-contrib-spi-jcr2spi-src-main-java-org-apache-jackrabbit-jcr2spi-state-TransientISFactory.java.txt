work in progress

- version always protected
- versionHistory always protected
- fix Node.getReferences && reference properties
- mixinTypes are 'active' upon save only (and not before). therefore
  cleanup after removeMixin is done only after save.
  adding new states defined by a new mixin are only added after the
  node has been saved.
- nodestates identified by a uuid only were created a second time upon
  ChildNodeEntry.resolve => fix needs to be improved
- Events/ChangeLog are processed by the save-target state
- ChangeLog.persisted not used any more

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@467956 13f79535-47bb-0310-9956-ffa450edef68

-    private ItemStateLifeCycleListener listener;
+    private ItemStateCache cache;
+    private ItemStateCreationListener listener;
-    void setListener(ItemStateLifeCycleListener listener) {
-        this.listener = listener;
-    }
-        // get a notification when this item state is saved or invalidated
+
+        // notify listeners when this item state is saved or invalidated
+        nodeState.addListener(cache);
-        // notify listener that a node state has been created
-        listener.statusChanged(nodeState, Status.NEW);
+
+        // notify listeners that a node state has been created
+        cache.created(nodeState);
+        listener.created(nodeState);
+
-            definition, Status.NEW, idFactory, false);
+            definition, Status.NEW, this, idFactory, false);
+
+        propState.addListener(cache);
-        // notify listener that a property state has been created
-        listener.statusChanged(propState, Status.NEW);
+
+        // notify listeners that a property state has been created
+        cache.created(propState);
+        listener.created(propState);
+
+    /**
+     * @inheritDoc
+     * @see TransientItemStateFactory#setListener(ItemStateCreationListener)
+     */
+    public void setListener(ItemStateCreationListener listener) {
+        this.listener = listener;
+    }
+
-        NodeState nodeState = new NodeState(overlayedState, null,
-            Status.EXISTING, this, idFactory);
-        nodeState.addListener(listener);
+        NodeState nodeState = new NodeState(overlayedState, null, Status.EXISTING, this, idFactory);
+
+        nodeState.addListener(cache);
+        cache.created(nodeState);
-        // retrieve state to overlay
-        NodeState overlayedState = (NodeState) parent.getItemState(nodeId);
-        NodeState overlayedParent = overlayedState.getParent();
-        NodeState parentState = null;
-        if (overlayedParent != null) {
-            parentState = (NodeState) ism.getItemState(overlayedParent.getId());
+
+        NodeState nodeState = cache.getNodeState(nodeId);
+        if (nodeState == null) {
+            // retrieve state to overlay
+            NodeState overlayedState = (NodeState) parent.getItemState(nodeId);
+            NodeState overlayedParent = overlayedState.getParent();
+
+            NodeState parentState = null;
+            if (overlayedParent != null) {
+                parentState = (NodeState) ism.getItemState(overlayedParent.getId());
+            }
+
+            nodeState = new NodeState(overlayedState, parentState, Status.EXISTING, this, idFactory);
+            nodeState.addListener(cache);
+            cache.created(nodeState);
-        NodeState nodeState = new NodeState(overlayedState, parentState,
-            Status.EXISTING, this, idFactory);
-        nodeState.addListener(listener);
-        // retrieve state to overlay
-        NodeState overlayedState = (NodeState) parent.getItemState(nodeId);
-        NodeState nodeState = new NodeState(overlayedState, parentState,
-            Status.EXISTING, this, idFactory);
-        nodeState.addListener(listener);
+
+        NodeState nodeState = cache.getNodeState(nodeId);
+        if (nodeState == null) {
+            // retrieve state to overlay
+            NodeState overlayedState = (NodeState) parent.getItemState(nodeId);
+            nodeState = new NodeState(overlayedState, parentState, Status.EXISTING, this, idFactory);
+
+            nodeState.addListener(cache);
+            cache.created(nodeState);
+        }
-        // retrieve state to overlay
-        PropertyState overlayedState = (PropertyState) parent.getItemState(propertyId);
-        PropertyState propState = new PropertyState(overlayedState, parentState,
-            Status.EXISTING, idFactory);
-        propState.addListener(listener);
+
+        PropertyState propState = cache.getPropertyState(propertyId);
+        if (propState == null) {
+            // retrieve state to overlay
+            PropertyState overlayedState = (PropertyState) parent.getItemState(propertyId);
+            propState = new PropertyState(overlayedState, parentState, Status.EXISTING, this, idFactory);
+
+            propState.addListener(cache);
+            cache.created(propState);
+        }
+
+    /**
+     * @inheritDoc
+     * @see ItemStateFactory#setCache(ItemStateCache)
+     */
+    public void setCache(ItemStateCache cache) {
+        this.cache = cache;
+    }

JCR-1747: org.apache.jackrabbit.core.query.lucene.SearchIndex with in-memory lucene index

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@718218 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.fs.FileSystemException;
-import org.apache.jackrabbit.core.fs.local.LocalFileSystem;
+import org.apache.jackrabbit.core.query.lucene.directory.DirectoryManager;
+import org.apache.lucene.store.Directory;
-import java.io.File;
-import java.io.FileFilter;
-     * Default name of the redo log file
-     */
-    private static final String REDO_LOG = "redo.log";
-
-    /**
-     * Name of the file that contains the indexing queue log.
-     */
-    private static final String INDEXING_QUEUE_FILE = "indexing_queue.log";
-
-    /**
-     * The base filesystem to store the index.
+     * The directory manager.
-    private final File indexDir;
+    private final DirectoryManager directoryManager;
+
+    /**
+     * The base directory to store the index.
+     */
+    private final Directory indexDir;
-     * @param indexDir the base file system
-     * @param mapping the namespace mapping to use
-    MultiIndex(File indexDir,
-               SearchIndex handler,
-               Set excludedIDs,
-               NamespaceMappings mapping) throws IOException {
-
-        this.indexDir = indexDir;
+    MultiIndex(SearchIndex handler,
+               Set excludedIDs) throws IOException {
+        this.directoryManager = handler.getDirectoryManager();
+        this.indexDir = directoryManager.getDirectory(".");
-        this.redoLog = new RedoLog(new File(indexDir, REDO_LOG));
+        this.redoLog = new RedoLog(indexDir);
-        this.nsMappings = mapping;
+        this.nsMappings = handler.getNamespaceMappings();
-        IndexingQueueStore store;
-        try {
-            LocalFileSystem fs = new LocalFileSystem();
-            fs.setRoot(indexDir);
-            fs.init();
-            store = new IndexingQueueStore(fs, INDEXING_QUEUE_FILE);
-        } catch (FileSystemException e) {
-            throw Util.createIOException(e);
-        }
+        IndexingQueueStore store = new IndexingQueueStore(indexDir);
-            File sub = new File(indexDir, indexNames.getName(i));
+            String name = indexNames.getName(i);
-            if (!sub.exists()) {
-                log.debug("index does not exist anymore: " + sub.getAbsolutePath());
+            if (!directoryManager.hasDirectory(name)) {
+                log.debug("index does not exist anymore: " + name);
-            PersistentIndex index = new PersistentIndex(indexNames.getName(i),
-                    sub, handler.getTextAnalyzer(), handler.getSimilarity(),
-                    cache, indexingQueue);
+            PersistentIndex index = new PersistentIndex(name,
+                    handler.getTextAnalyzer(), handler.getSimilarity(),
+                    cache, indexingQueue, directoryManager);
-        File sub;
-            sub = newIndexFolder();
-            indexName = sub.getName();
-        } else {
-            sub = new File(indexDir, indexName);
+            do {
+                indexName = indexNames.newName();
+            } while (directoryManager.hasDirectory(indexName));
-        PersistentIndex index = new PersistentIndex(indexName, sub,
+        PersistentIndex index = new PersistentIndex(indexName,
-                cache, indexingQueue);
+                cache, indexingQueue, directoryManager);
+     * @throws IOException if an error occurs while checking existence of
+     *          directory.
-    synchronized boolean hasIndex(String indexName) {
+    synchronized boolean hasIndex(String indexName) throws IOException {
-        return new File(indexDir, indexName).exists();
+        return directoryManager.hasDirectory(indexName);
+     *
+     * @throws IOException if an error occurs while reading directories.
-    private void enqueueUnusedSegments() {
+    private void enqueueUnusedSegments() throws IOException {
-        File[] segmentDirs = indexDir.listFiles(new FileFilter() {
-            public boolean accept(File pathname) {
-                return pathname.isDirectory() && pathname.getName().startsWith("_");
-            }
-        });
-        for (int i = 0; i < segmentDirs.length; i++) {
-            String name = segmentDirs[i].getName();
-            if (!indexNames.contains(name)) {
-                deletable.add(name);
+        String[] dirNames = directoryManager.getDirectoryNames();
+        for (int i = 0; i < dirNames.length; i++) {
+            if (dirNames[i].startsWith("_") && !indexNames.contains(dirNames[i])) {
+                deletable.add(dirNames[i]);
-                File dir = new File(indexDir, indexName);
-                if (deleteIndex(dir)) {
+                if (directoryManager.delete(indexName)) {
-        File deletable = new File(indexDir, "deletable");
-        if (deletable.exists()) {
-            deletable.delete();
-        }
-    }
-
-    /**
-     * Deletes the index <code>directory</code>.
-     *
-     * @param directory the index directory to delete.
-     * @return <code>true</code> if the delete was successful,
-     *         <code>false</code> otherwise.
-     */
-    private boolean deleteIndex(File directory) {
-        // trivial if it does not exist anymore
-        if (!directory.exists()) {
-            return true;
-        }
-        // delete files first
-        File[] files = directory.listFiles();
-        for (int i = 0; i < files.length; i++) {
-            if (!files[i].delete()) {
-                return false;
+        String fileName = "deletable";
+        try {
+            if (indexDir.fileExists(fileName)) {
+                indexDir.deleteFile(fileName);
+        } catch (IOException e) {
+            log.warn("Unable to remove file 'deletable'.", e);
-        // now delete directory itself
-        return directory.delete();
-    }
-
-    /**
-     * Returns an new index folder which is empty.
-     *
-     * @return the new index folder.
-     * @throws IOException if the folder cannot be created.
-     */
-    private File newIndexFolder() throws IOException {
-        // create new index folder. make sure it does not exist
-        File sub;
-        do {
-            sub = new File(indexDir, indexNames.newName());
-        } while (sub.exists());
-
-        if (!sub.mkdir()) {
-            throw new IOException("Unable to create directory: " + sub.getAbsolutePath());
-        }
-        return sub;

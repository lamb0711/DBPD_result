[JCR-181] jcr-server should honor a webdav request's Content-Type and Content-Language headers
[JCR-200] move log4j initialization out of RepositoryStartupServlet

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@240176 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.HashSet;
+import java.util.Set;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.jdom.Namespace;
+import org.apache.jackrabbit.webdav.version.DeltaVConstants;
- * type property. Valid resource types are '{@link #COLLECTION collection}',
- * {@link #DEFAULT_RESOURCE}.
+ * type property. The property may contain multiple resource type
+ * values. Predefined resource types are those defined by RFC2518 and RFC3253:
+ * <ul>
+ * <li>{@link #DEFAULT_RESOURCE the empty default resource type},</li>
+ * <li>'{@link #COLLECTION DAV:collection}',</li>
+ * <li>'{@link #VERSION_HISTORY DAV:version-history}',</li>
+ * <li>'{@link #ACTIVITY DAV:activity}',</li>
+ * <li>'{@link #BASELINE DAV:baseline}',</li>
+ * </ul>
-    private int resourceType = DEFAULT_RESOURCE;
+    /**
+     * The version-history resource type
+     */
+    public static final int VERSION_HISTORY = COLLECTION + 1;
-     * Create a resource type property
+     * The activity resource type
+     */
+    public static final int ACTIVITY = VERSION_HISTORY + 1;
+
+    /**
+     * The baseline resource type
+     */
+    public static final int BASELINE = ACTIVITY + 1;
+
+    /**
+     * Array containing all possible resourcetype elements
+     */
+    private static final List NAMES = new ArrayList();
+    static {
+        NAMES.add(null);
+        NAMES.add(new TypeName(XML_COLLECTION, NAMESPACE));
+        NAMES.add(new TypeName(DeltaVConstants.XML_VERSION_HISTORY, DeltaVConstants.NAMESPACE));
+        NAMES.add(new TypeName(DeltaVConstants.XML_ACTIVITY, DeltaVConstants.NAMESPACE));
+        NAMES.add(new TypeName(DeltaVConstants.XML_BASELINE, DeltaVConstants.NAMESPACE));
+    };
+
+    private final int[] resourceTypes;
+
+    /**
+     * Create a single-valued resource type property
-        super(DavPropertyName.RESOURCETYPE, false);
-	if (!isValidResourceType(resourceType)) {
-           throw new IllegalArgumentException("Invalid resource type '"+ resourceType +"'.");
-        }
-	this.resourceType = resourceType;
+        this(new int[] { resourceType });
-     * Return the JDOM element representation of this resource type
+     * Create a multi-valued resource type property
+     */
+    public ResourceType(int[] resourceTypes) {
+        super(DavPropertyName.RESOURCETYPE, false);
+        for (int i=0; i<resourceTypes.length; i++) {
+            if (!isValidResourceType(resourceTypes[i])) {
+                throw new IllegalArgumentException("Invalid resource type '"+ resourceTypes[i] +"'.");
+            }
+        }
+	this.resourceTypes = resourceTypes;
+    }
+
+    /**
+     * Return the JDOM element representation of this property
-        if (getValue() != null) {
-            elem.addContent((Element)getValue());
-        }
+        elem.addContent((Set)getValue());
-     * Returns the Xml representation of this resource type.
+     * Returns the Xml representation of this property as a
+     * <code>Set</code> of <code>Element</code>s.
-     * @return Xml representation of this resource type.
+     * @return a <code>Set</code> of <code>Element</code>s
+     * representing this property.
-        return (resourceType == COLLECTION) ? new Element(XML_COLLECTION, NAMESPACE) : null;
+        Set elements = new HashSet();
+        for (int i=0; i<resourceTypes.length; i++) {
+            Element elem = resourceTypeToXml(resourceTypes[i]);
+            if (elem != null) {
+                elements.add(elem);
+            }
+        }
+        return elements;
-     * Returns the resource type specified with the constructor.
+     * Returns the resource types specified with the constructor.
-     * @return resourceType
+     * @return resourceTypes
-    public int getResourceType() {
-        return resourceType;
+    public int[] getResourceTypes() {
+        return resourceTypes;
-     * Validates the specified resourceType.
+     * Returns the Xml representation of an individual resource type,
+     * or <code>null</code> if the resource type has no Xml
+     * representation (e.g. {@link #DEFAULT_RESOURCE}).<p/>{@link #getValue()} uses
+     * this method to build the full set of Xml elements for the property's resource
+     * types. Subclasses should override this method to add support for resource
+     * types they define.
-     * @param resourceType
-     * @return true if the specified resourceType is valid.
+     * @return Xml element representing the internal type or <code>null</code>
+     * if the resource has no element name assigned (default resource type).
-    public boolean isValidResourceType(int resourceType) {
-        if (resourceType < DEFAULT_RESOURCE || resourceType > COLLECTION) {
-	    return false;
-	}
+    private static Element resourceTypeToXml(int resourceType) {
+        TypeName name = (TypeName) NAMES.get(resourceType);
+        return (name != null) ? new Element(name.localName, name.namespace) : null;
+    }
+
+    /**
+     * Returns true if the given integer defines a valid resource type.
+     *
+     * @param resourceType to be validated.
+     * @return true if this is one of the predefined resource types
+     */
+    private static boolean isValidResourceType(int resourceType) {
+        if (resourceType < DEFAULT_RESOURCE || resourceType > NAMES.size()-1) {
+            return false;
+        }
+
+    /**
+     * Register an additional resource type
+     *
+     * @param name
+     * @param namespace
+     * @return int to be used for creation of a new <code>ResourceType</code> property
+     * that contains this type.
+     * @throws IllegalArgumentException if the given element is <code>null</code> or
+     * if the registration fails for another reason.
+     */
+    public static int registerResourceType(String name, Namespace namespace) {
+        if (name == null || namespace == null) {
+            throw new IllegalArgumentException("Cannot register a <null> resourcetype");
+        }
+        TypeName tn = new TypeName(name, namespace);
+        // avoid duplicate registrations
+        if (NAMES.contains(tn)) {
+            return NAMES.indexOf(tn);
+        }
+        // register new type
+        if (NAMES.add(tn)) {
+            return NAMES.size() - 1;
+        } else {
+            throw new IllegalArgumentException("Could not register resourcetype " +  namespace.getPrefix() + name);
+        }
+    }
+
+    //--------------------------------------------------------< inner class >---
+    /**
+     * Private inner class used to register predefined and user defined resource
+     * types.
+     */
+    private static class TypeName {
+
+        private final String localName;
+        private final Namespace namespace;
+        private final int hashCode;
+
+        private TypeName(String localName, Namespace namespace) {
+            this.localName = localName;
+            this.namespace = namespace;
+            hashCode = ("{" + namespace.getURI() + "}" + localName).hashCode();
+        }
+
+        public int hashCode() {
+            return hashCode;
+        }
+
+        public boolean equals(Object o) {
+            if (o instanceof TypeName) {
+                return hashCode == ((TypeName)o).hashCode;
+            }
+            return false;
+        }
+    }

JCR-160: Query index not in sync with workspace
- Improve error handling for uuids that have no node representation anymore, because they have been deleted in the meantime.

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@209739 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.List;
+import java.util.ArrayList;
-class DocOrderNodeIteratorImpl extends NodeIteratorImpl {
+class DocOrderNodeIteratorImpl implements ScoreNodeIterator {
+    /** The UUIDs of the nodes in the result set */
+    protected String[] uuids;
+
+    /** The score values for the nodes in the result set */
+    protected Float[] scores;
+
+    /** ItemManager to turn UUIDs into Node instances */
+    protected final ItemManager itemMgr;
+
-        super(itemMgr, uuids, scores);
+        this.itemMgr = itemMgr;
+        this.uuids = uuids;
+        this.scores = scores;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public Object next() {
+        return nextNodeImpl();
+        return nextNodeImpl();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public NodeImpl nextNodeImpl() {
-        return orderedNodes.nextNode();
+        return orderedNodes.nextNodeImpl();
+    }
+
+    /**
+     * @throws UnsupportedOperationException always.
+     */
+    public void remove() {
+        throw new UnsupportedOperationException("remove");
-     * {@inheritDoc}
+     * Returns the number of nodes in this iterator.
+     * </p>
+     * Note: The number returned by this method may differ from the number
+     * of nodes actually returned by calls to hasNext() / getNextNode()! This
+     * is because this iterator works on a lazy instantiation basis and while
+     * iterating over the nodes some of them might have been deleted in the
+     * meantime. Those will not be returned by getNextNode().
+     *
+     * @return the number of node in this iterator.
-     * @throws UnsupportedOperationException always.
-     */
-    public void remove() {
-        throw new UnsupportedOperationException("remove");
-    }
-
-    /**
-    public Object next() {
-        initOrderedIterator();
-        return orderedNodes.next();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    float getScore() {
+    public float getScore() {
-    /**
-     * {@inheritDoc}
-     */
-    NodeImpl nextNodeImpl() {
-        initOrderedIterator();
-        return orderedNodes.nextNodeImpl();
-    }
-
-     * Initializes the NodeIterator in document order, if needed.
+     * Initializes the NodeIterator in document order
-        if (orderedNodes == null) {
-            long time = System.currentTimeMillis();
-            ScoreNode[] nodes = new ScoreNode[uuids.length];
-            for (int i = 0; i < uuids.length; i++) {
-                nodes[i] = new ScoreNode(uuids[i], scores[i]);
-            }
+        if (orderedNodes != null) {
+            return;
+        }
+        long time = System.currentTimeMillis();
+        ScoreNode[] nodes = new ScoreNode[uuids.length];
+        for (int i = 0; i < uuids.length; i++) {
+            nodes[i] = new ScoreNode(uuids[i], scores[i]);
+        }
-            Arrays.sort(nodes, new Comparator() {
-                public int compare(Object o1, Object o2) {
-                    ScoreNode n1 = (ScoreNode) o1;
-                    ScoreNode n2 = (ScoreNode) o2;
-                    try {
-                        NodeImpl node1 = (NodeImpl) itemMgr.getItem(new NodeId(n1.uuid));
-                        NodeImpl node2 = (NodeImpl) itemMgr.getItem(new NodeId(n2.uuid));
-                        Path.PathElement[] path1 = node1.getPrimaryPath().getElements();
-                        Path.PathElement[] path2 = node2.getPrimaryPath().getElements();
+        final List invalidUUIDs = new ArrayList(2);
-                        // find nearest common ancestor
-                        int commonDepth = 0; // root
-                        while (path1.length > commonDepth && path2.length > commonDepth) {
-                            if (path1[commonDepth].equals(path2[commonDepth])) {
-                                commonDepth++;
-                            } else {
-                                break;
-                            }
-                        }
-                        // path elements at last depth were equal
-                        commonDepth--;
-
-                        // check if either path is an ancestor of the other
-                        if (path1.length - 1 == commonDepth) {
-                            // path1 itself is ancestor of path2
-                            return -1;
-                        }
-                        if (path2.length - 1 == commonDepth) {
-                            // path2 itself is ancestor of path1
-                            return 1;
-                        }
-                        // get common ancestor node
-                        NodeImpl commonNode = (NodeImpl) node1.getAncestor(commonDepth);
-                        // move node1/node2 to the commonDepth + 1
-                        // node1 and node2 then will be child nodes of commonNode
-                        node1 = (NodeImpl) node1.getAncestor(commonDepth + 1);
-                        node2 = (NodeImpl) node2.getAncestor(commonDepth + 1);
-                        for (NodeIterator it = commonNode.getNodes(); it.hasNext();) {
-                            Node child = it.nextNode();
-                            if (child.isSame(node1)) {
-                                return -1;
-                            } else if (child.isSame(node2)) {
-                                return 1;
-                            }
-                        }
-                        log.error("Internal error: unable to determine document order of nodes:");
-                        log.error("\tNode1: " + node1.getPath());
-                        log.error("\tNode2: " + node2.getPath());
-                        return 0;
-                    } catch (RepositoryException e) {
-                        log.error("Exception while sorting nodes in document order: " + e.toString(), e);
-                        // todo ???
-                        return 0;
+        do {
+            if (invalidUUIDs.size() > 0) {
+                // previous sort run was not successful -> remove failed uuids
+                ScoreNode[] tmp = new ScoreNode[nodes.length - invalidUUIDs.size()];
+                int newIdx = 0;
+                for (int i = 0; i < nodes.length; i++) {
+                    if (!invalidUUIDs.contains(nodes[i].uuid)) {
+                        tmp[newIdx++] = nodes[i];
-            });
+                nodes = tmp;
+                invalidUUIDs.clear();
+            }
-            for (int i = 0; i < nodes.length; i++) {
-                uuids[i] = nodes[i].uuid;
-                scores[i] = nodes[i].score;
+            try {
+                // sort the uuids
+                Arrays.sort(nodes, new Comparator() {
+                    public int compare(Object o1, Object o2) {
+                        ScoreNode n1 = (ScoreNode) o1;
+                        ScoreNode n2 = (ScoreNode) o2;
+                        try {
+                            NodeImpl node1 = null;
+                            try {
+                                node1 = (NodeImpl) itemMgr.getItem(new NodeId(n1.uuid));
+                            } catch (RepositoryException e) {
+                                log.warn("Node " + n1.uuid + " does not exist anymore: " + e);
+                                // node does not exist anymore
+                                invalidUUIDs.add(n1.uuid);
+                                throw new SortFailedException();
+                            }
+                            NodeImpl node2 = null;
+                            try {
+                                node2 = (NodeImpl) itemMgr.getItem(new NodeId(n2.uuid));
+                            } catch (RepositoryException e) {
+                                log.warn("Node " + n2.uuid + " does not exist anymore: " + e);
+                                // node does not exist anymore
+                                invalidUUIDs.add(n2.uuid);
+                                throw new SortFailedException();
+                            }
+                            Path.PathElement[] path1 = node1.getPrimaryPath().getElements();
+                            Path.PathElement[] path2 = node2.getPrimaryPath().getElements();
+
+                            // find nearest common ancestor
+                            int commonDepth = 0; // root
+                            while (path1.length > commonDepth && path2.length > commonDepth) {
+                                if (path1[commonDepth].equals(path2[commonDepth])) {
+                                    commonDepth++;
+                                } else {
+                                    break;
+                                }
+                            }
+                            // path elements at last depth were equal
+                            commonDepth--;
+
+                            // check if either path is an ancestor of the other
+                            if (path1.length - 1 == commonDepth) {
+                                // path1 itself is ancestor of path2
+                                return -1;
+                            }
+                            if (path2.length - 1 == commonDepth) {
+                                // path2 itself is ancestor of path1
+                                return 1;
+                            }
+                            // get common ancestor node
+                            NodeImpl commonNode = (NodeImpl) node1.getAncestor(commonDepth);
+                            // move node1/node2 to the commonDepth + 1
+                            // node1 and node2 then will be child nodes of commonNode
+                            node1 = (NodeImpl) node1.getAncestor(commonDepth + 1);
+                            node2 = (NodeImpl) node2.getAncestor(commonDepth + 1);
+                            for (NodeIterator it = commonNode.getNodes(); it.hasNext();) {
+                                Node child = it.nextNode();
+                                if (child.isSame(node1)) {
+                                    return -1;
+                                } else if (child.isSame(node2)) {
+                                    return 1;
+                                }
+                            }
+                            log.error("Internal error: unable to determine document order of nodes:");
+                            log.error("\tNode1: " + node1.getPath());
+                            log.error("\tNode2: " + node2.getPath());
+                        } catch (RepositoryException e) {
+                            log.error("Exception while sorting nodes in document order: " + e.toString(), e);
+                        }
+                        // if we get here something went wrong
+                        // remove both uuids from array
+                        invalidUUIDs.add(n1.uuid);
+                        invalidUUIDs.add(n2.uuid);
+                        // terminate sorting
+                        throw new SortFailedException();
+                    }
+                });
+            } catch (SortFailedException e) {
+                // retry
-            if (log.isDebugEnabled()) {
-                log.debug("" + uuids.length + " node(s) ordered in " + (System.currentTimeMillis() - time) + " ms");
-            }
-            orderedNodes = new NodeIteratorImpl(itemMgr, uuids, scores);
+
+        } while (invalidUUIDs.size() > 0);
+
+        // resize uuids and scores array if we had to remove some uuids
+        if (uuids.length != nodes.length) {
+            uuids = new String[nodes.length];
+            scores = new Float[nodes.length];
+
+        for (int i = 0; i < nodes.length; i++) {
+            uuids[i] = nodes[i].uuid;
+            scores[i] = nodes[i].score;
+        }
+        if (log.isDebugEnabled()) {
+            log.debug("" + uuids.length + " node(s) ordered in " + (System.currentTimeMillis() - time) + " ms");
+        }
+        orderedNodes = new NodeIteratorImpl(itemMgr, uuids, scores);
+    /**
+     * Simple helper class that associates a score with each node uuid.
+     */
+
+    /**
+     * Indicates that sorting failed.
+     */
+    private static final class SortFailedException extends RuntimeException {
+    }

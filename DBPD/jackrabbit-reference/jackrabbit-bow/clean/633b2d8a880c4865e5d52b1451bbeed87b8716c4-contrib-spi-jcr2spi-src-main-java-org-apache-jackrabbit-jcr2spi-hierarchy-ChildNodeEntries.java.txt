fixed: move, reorder (work in progress)
fixed: locktoken transfer
fixed: recursive transient removal of invalidated tree fails (restoreTests)
improve: simplify usage of workspace operations
fixed: store original itemId with transient operations in order to properly reflect the changelog upon batch creation
fixed: workspace import doesn't invalidate
fixed: session import uuid handling




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@513279 13f79535-47bb-0310-9956-ffa450edef68

-    
+
+            // shortcut if index can never match
+            if (index > siblings.size()) {
+                return null;
+            }
-     * Adds a <code>NodeEntry</code> to the end of the list.
+     * Adds a <code>NodeEntry</code> to the end of the list. Same as
+     * {@link #add(NodeEntry, int)}, where the index is {@link Path#INDEX_UNDEFINED}.
-        QName nodeName = cne.getQName();
-        List siblings = null;
-        Object obj = nameMap.get(nodeName);
-        if (obj != null) {
-            if (obj instanceof List) {
-                // map entry is a list of siblings
-                siblings = (ArrayList) obj;
-            } else {
-                // map entry is a single child node entry,
-                // convert to siblings list
-                siblings = new ArrayList();
-                siblings.add(obj);
-                nameMap.put(nodeName, siblings);
-            }
-        }
-
-        LinkedEntries.LinkNode ln = entries.add(cne);
-
-        if (siblings != null) {
-            siblings.add(ln);
-        } else {
-            nameMap.put(nodeName, ln);
-        }
+        add(cne, Path.INDEX_UNDEFINED);
-     * Adds a <code>NodeEntry</code>. If an entry with the given index
-     * already exists, the the new sibling is inserted before.
+     * Adds a <code>NodeEntry</code>.<br>
+     * Note the following special cases:
+     * <ol>
+     * <li>If an entry with the given index already exists, the the new sibling
+     * is inserted before.</li>
+     * <li>If the given index is bigger that the last entry in the siblings list,
+     * intermediate entries will be created.</li>
+     * </ol>
-        // retrieve ev. sibling node with same index
-        // if index is 'undefined' behave just as '#add(NodeEntry).
+        // retrieve ev. sibling node with same index if index is 'undefined'
+        // the existing entry is always null and no reordering occur.
+        // in case index greater than default -> make sure all intermediate
+        // entries exist.
+        if (index > Path.INDEX_DEFAULT) {
+            int previousIndex = index - 1;
+            LinkedEntries.LinkNode previous = getLinkNode(nodeName, previousIndex);
+            if (previous == null) {
+                // add missing entry (or entries)
+                parent.addNodeEntry(nodeName, null, previousIndex);
+
+            } // else: all intermediate entries exist
+        } // else: undefined or default index are not affected
+
-        // if new entry must be inserted instead of appended at the end
-        // reorder entries now
+        // reorder the child entries if, the new entry must be inserted rather
+        // than appended at the end of the list.
+     * @return the NodeEntry that followed the 'insertNode' before the reordering.
-    boolean reorder(NodeEntry insertNode, NodeEntry beforeNode) {
+    NodeEntry reorder(NodeEntry insertNode, NodeEntry beforeNode) {
-            return false;
+            throw new NoSuchElementException();
-            return false;
+            throw new NoSuchElementException();
+        NodeEntry previousBefore = insertLN.getNextLinkNode().getNodeEntry();
-        return true;
+        return previousBefore;
-        } else {
-            // no same name siblings -> nothing to do.
-        }
+        } // else: no same name siblings -> no special handling required

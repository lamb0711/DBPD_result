work in progress

- Restore: pass NodeState(s) and Path instead of NodeId(s)
- LockManager: make sure lockmanager only remembers workspace states
- LockManager: make sure operations are executed using workspace states
- LockManager: improve isLocked/getLock/checkIsLocked and respect locks that
have been accessed before.
- VersionManager: make sure operations are executed using workspace states
- VersionManager: add checkIsCheckedOut
- VersionManager: force manager to have a WorkspaceManager
- NodeReferences:
  > make interface package protected
  > clarify method naming
  > add implementation to WorkspaceItemStateFactory
  > add NodeReferences field to NodeState
  > TO_IMPROVE: references are currently always retrieve from the SPI.
- ItemStateManager + NodeReferences
  > rename interfaces methods
  > change method signature to take NodeState instead of NodeId
  > 'getReferences' returns the property states directly

- remove some JR DIFFs. 

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@432234 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.state.UpdatableItemStateManager;
+import org.apache.jackrabbit.jcr2spi.state.ItemState;
+import org.apache.jackrabbit.jcr2spi.WorkspaceManager;
+import javax.jcr.version.VersionException;
+
+import org.apache.jackrabbit.name.Path;
-import org.apache.jackrabbit.spi.NodeId;
-    private final UpdatableItemStateManager stateManager;
+    private final WorkspaceManager workspaceManager;
-    public VersionManagerImpl(UpdatableItemStateManager stateManager) {
-        this.stateManager = stateManager;
+    public VersionManagerImpl(WorkspaceManager workspaceManager) {
+        this.workspaceManager = workspaceManager;
-        Operation ci = Checkin.create(nodeState);
-        stateManager.execute(ci);
+        NodeState wspState = getWorkspaceState(nodeState);
+        Operation ci = Checkin.create(wspState);
+        workspaceManager.execute(ci);
-        Operation co = Checkout.create(nodeState);
-        stateManager.execute(co);
+        NodeState wspState = getWorkspaceState(nodeState);
+        Operation co = Checkout.create(wspState);
+        workspaceManager.execute(co);
+        // shortcut: if state is new, its ancestor must be checkout
+        if (nodeState.getStatus() == ItemState.STATUS_NEW) {
+            return true;
+        }
+
+        NodeState wspState = getWorkspaceState(nodeState);
-            while (!nodeState.hasPropertyName(QName.JCR_ISCHECKEDOUT)) {
-                NodeState parentState = nodeState.getParent();
+            while (!wspState.hasPropertyName(QName.JCR_ISCHECKEDOUT)) {
+                NodeState parentState = wspState.getParent();
-                nodeState = parentState;
+                wspState = parentState;
-            PropertyState propState = nodeState.getPropertyState(QName.JCR_ISCHECKEDOUT);
+            PropertyState propState = wspState.getPropertyState(QName.JCR_ISCHECKEDOUT);
+    public void checkIsCheckedOut(NodeState nodeState) throws VersionException, RepositoryException {
+        if (!isCheckedOut(nodeState)) {
+            throw new VersionException(nodeState + " is checked-in");
+        }
+    }
+
-        Operation op = Remove.create(versionState);
-        stateManager.execute(op);
+        NodeState wspVersionState = getWorkspaceState(versionState);
+        Operation op = Remove.create(wspVersionState);
+        workspaceManager.execute(op);
-        Operation op = AddLabel.create(versionHistoryState, versionState, qLabel, moveLabel);
-        stateManager.execute(op);
+        NodeState wspVHState = getWorkspaceState(versionHistoryState);
+        NodeState wspVState = getWorkspaceState(versionState);
+        Operation op = AddLabel.create(wspVHState, wspVState, qLabel, moveLabel);
+        workspaceManager.execute(op);
-        Operation op = RemoveLabel.create(versionHistoryState, versionState, qLabel);
-        stateManager.execute(op);
+        NodeState wspVHState = getWorkspaceState(versionHistoryState);
+        NodeState wspVState = getWorkspaceState(versionState);
+        Operation op = RemoveLabel.create(wspVHState, wspVState, qLabel);
+        workspaceManager.execute(op);
-    public void restore(NodeId nodeId, NodeId versionId, boolean removeExisting) throws RepositoryException {
-        Operation op = Restore.create(nodeId, versionId, removeExisting);
-        stateManager.execute(op);
+    public void restore(NodeState nodeState, Path relativePath, NodeState versionState, boolean removeExisting) throws RepositoryException {
+        NodeState wspState = getWorkspaceState(nodeState);
+        NodeState wspVState = getWorkspaceState(versionState);
+        Operation op = Restore.create(wspState, relativePath, wspVState, removeExisting);
+        workspaceManager.execute(op);
-    public void restore(NodeId[] versionIds, boolean removeExisting) throws RepositoryException {
-        Operation op = Restore.create(versionIds, removeExisting);
-        stateManager.execute(op);
+    public void restore(NodeState[] versionStates, boolean removeExisting) throws RepositoryException {
+        NodeState[] wspStates = new NodeState[versionStates.length];
+        for (int i = 0; i < versionStates.length; i++) {
+            wspStates[i] = getWorkspaceState(versionStates[i]);
+        }
+
+        Operation op = Restore.create(wspStates, removeExisting);
+        workspaceManager.execute(op);
+        NodeState wspState = getWorkspaceState(nodeState);
-        Operation op = Merge.create(nodeState, workspaceName, bestEffort, mergeFailedCollector);
-        stateManager.execute(op);
+        Operation op = Merge.create(wspState, workspaceName, bestEffort, mergeFailedCollector);
+        workspaceManager.execute(op);
-        Operation op = ResolveMergeConflict.create(nodeState, versionState, done);
-        stateManager.execute(op);
+        NodeState wspState = getWorkspaceState(nodeState);
+        NodeState wspVState = getWorkspaceState(versionState);
+        Operation op = ResolveMergeConflict.create(wspState, wspVState, done);
+        workspaceManager.execute(op);
+    }
+
+    //------------------------------------------------------------< private >---
+    /**
+     * If the given <code>NodeState</code> has an overlayed state, the overlayed
+     * (workspace) state will be returned. Otherwise the given state is returned.
+     *
+     * @param nodeState
+     * @return The overlayed state or the given state, if this one does not have
+     * an overlayed state.
+     */
+    private NodeState getWorkspaceState(NodeState nodeState) {
+        if (nodeState.hasOverlayedState()) {
+            // nodestate has been obtained from  Session-ISM
+            return (NodeState) nodeState.getOverlayedState();
+        } else {
+            // nodestate has been obtained from Workspace-ISM already
+            return nodeState;
+        }

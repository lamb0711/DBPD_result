JCR-337 - Remove jcr dependency from dav-library
JCR-343 - Report#init limits the Report interface to DeltaV compliant resources
JCR-340 - ValuesProperty missing property type information
JCR-342 - DavResource#getDavSession() missing
JCR-344 - DeltaVResource lists MKWORKSPACE in the method constant.
JCR-345 - DavException does not allow to specify an exception cause

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@385540 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.webdav.version.DeltaVResource;
-import org.apache.jackrabbit.webdav.DavSession;
+import org.apache.jackrabbit.webdav.DavResource;
- *
- * @todo currently the nodetype report is not consistent with the general way of representing nodetype names (with NodetypeElement) in order to be compatible with the jackrabbit nodetype registry...
- * @todo for the same reason, not the complete nodetype-definition, but only the nodetype def as stored is represented.
- * @todo no namespace definition with response (> jackrabbit)... and nodetype element has same name as the one used with dav-properties
-public class NodeTypesReport implements Report, NodeTypeConstants {
+//todo: currently the nodetype report is not consistent with the general way of representing nodetype names (with NodetypeElement) in order to be compatible with the jackrabbit nodetype registry...
+//todo: for the same reason, not the complete nodetype-definition, but only the nodetype def as stored is represented.
+//todo: no namespace definition with response (> jackrabbit)... and nodetype element has same name as the one used with dav-properties
+public class NodeTypesReport extends AbstractJcrReport implements NodeTypeConstants {
-    private Session session;
-     * @see Report#init(org.apache.jackrabbit.webdav.version.DeltaVResource, org.apache.jackrabbit.webdav.version.report.ReportInfo)
+     * @see Report#init(DavResource, ReportInfo)
-    public void init(DeltaVResource resource, ReportInfo info) throws DavException {
-        if (resource == null) {
-            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "Resource must not be null.");
-        }
-        if (!getType().isRequestedReportType(info)) {
-            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "dcr:nodetypes element expected.");
-        }
-        DavSession davSession = resource.getSession();
-        if (davSession == null || davSession.getRepositorySession() == null) {
-            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "The resource must provide a non-null session object in order to create the nodetypes report.");
-    }
-        session = davSession.getRepositorySession();
+    public void init(DavResource resource, ReportInfo info) throws DavException {
+        // delegate basic validation to super class
+        super.init(resource, info);
+        // report specific validation and preparation for xml serialization
-            ntIter = getNodeTypes(session, info);
+            ntIter = getNodeTypes(getRepositorySession(), info);
-        if (session == null || ntIter == null) {
+        if (ntIter == null) {
-            while (ntIter.hasNext()) {
-                NodeType nt = ntIter.nextNodeType();
+        while (ntIter.hasNext()) {
+            NodeType nt = ntIter.nextNodeType();
-                ntDef.setAttribute(NAME_ATTRIBUTE, nt.getName());
-                ntDef.setAttribute(ISMIXIN_ATTRIBUTE, Boolean.toString(nt.isMixin()));
-                ntDef.setAttribute(HASORDERABLECHILDNODES_ATTRIBUTE, Boolean.toString(nt.hasOrderableChildNodes()));
+            ntDef.setAttribute(NAME_ATTRIBUTE, nt.getName());
+            ntDef.setAttribute(ISMIXIN_ATTRIBUTE, Boolean.toString(nt.isMixin()));
+            ntDef.setAttribute(HASORDERABLECHILDNODES_ATTRIBUTE, Boolean.toString(nt.hasOrderableChildNodes()));
-		// declared supertypes
-		NodeType[] snts = nt.getDeclaredSupertypes();
+            // declared supertypes
+            NodeType[] snts = nt.getDeclaredSupertypes();
-		for (int i = 0; i < snts.length; i++) {
+            for (int i = 0; i < snts.length; i++) {
-		}
+            }
-		// declared childnode defs
-		NodeDefinition[] cnd = nt.getChildNodeDefinitions();
-		for (int i = 0; i < cnd.length; i++) {
-		    if (cnd[i].getDeclaringNodeType().getName().equals(nt.getName())) {
+            // declared childnode defs
+            NodeDefinition[] cnd = nt.getChildNodeDefinitions();
+            for (int i = 0; i < cnd.length; i++) {
+                if (cnd[i].getDeclaringNodeType().getName().equals(nt.getName())) {
-		    }
-		}
-
-		// declared propertyDefs
-		PropertyDefinition[] pd = nt.getPropertyDefinitions();
-		for (int i = 0; i < pd.length; i++) {
-		    if (pd[i].getDeclaringNodeType().getName().equals(nt.getName())) {
-                    ntDef.appendChild(PropertyDefinitionImpl.create(pd[i]).toXml(document));
-		    }
-		}
-
-                String primaryItemName = nt.getPrimaryItemName();
-                if (primaryItemName != null) {
-                    ntDef.setAttribute(PRIMARYITEMNAME_ATTRIBUTE, primaryItemName);
+            }
+
+            // declared propertyDefs
+            PropertyDefinition[] pd = nt.getPropertyDefinitions();
+            for (int i = 0; i < pd.length; i++) {
+                if (pd[i].getDeclaringNodeType().getName().equals(nt.getName())) {
+                    ntDef.appendChild(PropertyDefinitionImpl.create(pd[i]).toXml(document));
+                }
+            }
+
+            String primaryItemName = nt.getPrimaryItemName();
+            if (primaryItemName != null) {
+                ntDef.setAttribute(PRIMARYITEMNAME_ATTRIBUTE, primaryItemName);
+            }
-                    ntIter = ntMgr.getAllNodeTypes();
+            ntIter = ntMgr.getAllNodeTypes();
-                    ntIter = ntMgr.getMixinNodeTypes();
+            ntIter = ntMgr.getMixinNodeTypes();
-                    ntIter = ntMgr.getPrimaryNodeTypes();
-                }
+            ntIter = ntMgr.getPrimaryNodeTypes();
+        }

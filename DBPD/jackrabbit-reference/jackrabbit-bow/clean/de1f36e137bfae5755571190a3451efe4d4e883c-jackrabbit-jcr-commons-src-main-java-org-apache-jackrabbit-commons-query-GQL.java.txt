JCR-3812 Improvements to the GQL tools

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1627529 13f79535-47bb-0310-9956-ffa450edef68

+    
+    /**
+     * A pseudo-property for native xpath conditions.
+     */
+    private static final String NATIVE_XPATH = "jcr:nativeXPath";
+    
+    /**
+     * Executes the GQL query and returns the result as a row iterator.
+     *
+     * @param jcrQuery the native JCR query.
+     * @param jcrQueryLanguage the JCR query language
+     * @param session the session that will execute the query.
+     * @param commonPathPrefix a common path prefix for the GQL query.
+     * @param filter an optional filter that may include/exclude result rows.
+     * @return the result.
+     */
+    public static RowIterator executeXPath(String jcrQuery,
+                                      String jcrQueryLanguage,
+                                      Session session,
+                                      String commonPathPrefix,
+                                      Filter filter) {
+        GQL query = new GQL("", session, commonPathPrefix, filter);
+        return query.executeJcrQuery(jcrQuery, jcrQueryLanguage);
+    }
+    
+    /**
+     * Translate the GQL query to XPath.
+     *
+     * @param statement the GQL query.
+     * @param session the session that will execute the query.
+     * @param commonPathPrefix a common path prefix for the GQL query.
+     * @return the xpath statement.
+     */
+    public static String translateToXPath(String statement,
+            Session session,
+            String commonPathPrefix) throws RepositoryException {
+        GQL query = new GQL(statement, session, commonPathPrefix, null);
+        return query.translateStatement();
+    }
+        String xpath;
-            String stmt = translateStatement();
+            xpath = translateStatement();
+        } catch (RepositoryException e) {
+            // in case of error return empty result
+            return RowIteratorAdapter.EMPTY;
+        }
+        return executeJcrQuery(xpath, Query.XPATH);
+    }
+    
+    private RowIterator executeJcrQuery(String jcrQuery, String jcrQueryLanguage) {
+        try {
-            RowIterator nodes = qm.createQuery(stmt, Query.XPATH).execute().getRows();
+            RowIterator nodes = qm.createQuery(jcrQuery, jcrQueryLanguage).execute().getRows();
-        }
+        }        
-            NodeTypeManager ntMgr = session.getWorkspace().getNodeTypeManager();
-            NodeTypeIterator it = ntMgr.getAllNodeTypes();
-            while (it.hasNext()) {
-                NodeType nt = it.nextNodeType();
-                PropertyDefinition[] defs = nt.getDeclaredPropertyDefinitions();
-                for (PropertyDefinition def : defs) {
-                    String pn = def.getName();
-                    if (!pn.equals("*")) {
-                        String localName = pn;
-                        int idx = pn.indexOf(':');
-                        if (idx != -1) {
-                            localName = pn.substring(idx + 1);
+            if (session != null) {
+                NodeTypeManager ntMgr = session.getWorkspace().getNodeTypeManager();
+                NodeTypeIterator it = ntMgr.getAllNodeTypes();
+                while (it.hasNext()) {
+                    NodeType nt = it.nextNodeType();
+                    PropertyDefinition[] defs = nt.getDeclaredPropertyDefinitions();
+                    for (PropertyDefinition def : defs) {
+                        String pn = def.getName();
+                        if (!pn.equals("*")) {
+                            String localName = pn;
+                            int idx = pn.indexOf(':');
+                            if (idx != -1) {
+                                localName = pn.substring(idx + 1);
+                            }
+                            propertyNames.put(localName, pn);
-                        propertyNames.put(localName, pn);
+            if (property.equals(NATIVE_XPATH)) {
+                buffer.append(value);
+                return;
+            }        
+            int start = buffer.length();
+                if (name.equals("-")) {
+                    // no order by at all
+                    buffer.delete(start, buffer.length());
+                    return;
+                }

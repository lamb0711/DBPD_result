JCR-2140 Configurations and Baselines


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@796586 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Set;
+
-import javax.jcr.Value;
-import javax.jcr.UnsupportedRepositoryOperationException;
+import javax.jcr.PropertyType;
-import org.apache.jackrabbit.core.NodeImpl;
-import org.apache.jackrabbit.core.value.InternalValue;
-import org.apache.jackrabbit.core.value.InternalValue;
+import org.apache.jackrabbit.core.value.InternalValue;
+    public InternalBaseline getBaseline(NodeId id) throws RepositoryException {
+        // lock handling via getItem()
+        InternalBaseline v = (InternalBaseline) getItem(id);
+        if (v == null) {
+            log.warn("Versioning item not found: " + id);
+        }
+        return v;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
-     * Creates aew configuration node
+     * Creates a new configuration node.
+     * <p/>
+     * The nt:confguration is stored within the nt:configurations storage using
+     * the nodeid of the configuration root (rootId) as path.
+     *
-     * @param baseline the optional baseline
-    NodeStateEx internalCreateConfiguration(NodeId rootId, InternalBaseline baseline)
+    NodeStateEx internalCreateConfiguration(NodeId rootId)
-        if (baseline != null) {
-            // the exact behavior is not clarified yet.
-            // see http://jsr-283.dev.java.net/issues/show_bug.cgi?id=795
-            throw new UnsupportedRepositoryOperationException(
-                    "creating configurations based on a baseline not supported, yet");
-        }
-
-            NodeId configId = new NodeId();
-                    configId.toString(), NameConstants.REP_CONFIGURATIONS);
-            Name name = getName(configId.toString());
+                    rootId.toString(), NameConstants.REP_CONFIGURATIONS);
+            Name name = getName(rootId.toString());
+
+            NodeId configId = new NodeId();
-            String uuid = new NodeId().toString();
-            NodeStateEx histParent = getParentNode(historyRoot, uuid, NameConstants.REP_VERSIONSTORAGE);
-            Name histName = getName(uuid);
+            NodeStateEx histParent = getParentNode(historyRoot, configId.toString(), NameConstants.REP_VERSIONSTORAGE);
+            Name histName = getName(configId.toString());
+            config.setPropertyValue(NameConstants.JCR_ISCHECKEDOUT, InternalValue.create(true));
+            InternalValue[] preds = new InternalValue[]{InternalValue.create(blId)};
+            config.setPropertyValues(NameConstants.JCR_PREDECESSORS, PropertyType.REFERENCE, preds, true);
+     * {@inheritDoc}
+     */
+    public InternalConfiguration getConfigurationForNode(NodeId rootId) throws RepositoryException {
+        ReadLock lock = acquireReadLock();
+        try {
+            String uuid = rootId.toString();
+            Name name = getName(uuid);
+
+            NodeStateEx parent = getParentNode(configurationsRoot, uuid, null);
+            if (parent != null && parent.hasNode(name)) {
+                NodeStateEx config = parent.getNode(name, 1);
+                return new InternalConfigurationImpl(this, config);
+            } else {
+                return null;
+            }
+        } finally {
+            lock.release();
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public InternalConfiguration getConfiguration(NodeId nodeId)
+            throws RepositoryException {
+        // lock handling via getItem()
+        InternalConfiguration config = (InternalConfiguration) getItem(nodeId);
+        if (config == null) {
+            throw new ItemNotFoundException(nodeId.toString());
+        }
+        return config;
+    }
+
+    /**
-            InternalVersionImpl v = history.checkin(NameFactoryImpl.getInstance().create("", versionName), node);
+            InternalVersionImpl v = history.checkin(
+                    NameFactoryImpl.getInstance().create("", versionName), node, null);
+     * internally checks in a configuration
+     * @param config the config
+     * @param baseVersions the base versions to record
+     * @return the new baseline
+     * @throws RepositoryException if an error occurs
+     */
+    protected InternalBaseline internalCheckin(InternalConfigurationImpl config,
+                                               Set<NodeId> baseVersions)
+            throws RepositoryException {
+        InternalVersionHistoryImpl vh = (InternalVersionHistoryImpl) getVersionHistoryOfNode(config.getId());
+        WriteOperation operation = startWriteOperation();
+        try {
+            NodeStateEx node = config.node;
+            String versionName = calculateCheckinVersionName(vh, node, false);
+            InternalBaseline v = (InternalBaseline) vh.checkin(
+                    NameFactoryImpl.getInstance().create("", versionName),
+                    node, baseVersions);
+            // update properties on 'node' to point to the new base version
+            // but leave it checked out
+            node.setPropertyValue(
+                    NameConstants.JCR_BASEVERSION,
+                    InternalValue.create(v.getId()));
+            node.setPropertyValues(
+                    NameConstants.JCR_PREDECESSORS,
+                    PropertyType.REFERENCE,
+                    new InternalValue[]{InternalValue.create(v.getId())}
+            );
+            node.store();
+            operation.save();
+            return v;
+        } catch (ItemStateException e) {
+            throw new RepositoryException(e);
+        } finally {
+            operation.close();
+        }
+    }
+
+    /**
+                } else if (ntName.equals(NameConstants.NT_CONFIGURATION)) {
+                    return new InternalConfigurationImpl(this, pNode);

- removed @author and @version (i.e. $Revision & $Id) tags
- removed tab characters from java source code

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@47648 13f79535-47bb-0310-9956-ffa450edef68

- *
- * @author Stefan Guggisberg
- * @version $Revision: 1.49 $, $Date: 2004/09/09 15:23:43 $
-	    new QName(NamespaceRegistryImpl.NS_NT_URI, "unstructured");
+            new QName(NamespaceRegistryImpl.NS_NT_URI, "unstructured");
-	    new QName(NamespaceRegistryImpl.NS_NT_URI, "base");
+            new QName(NamespaceRegistryImpl.NS_NT_URI, "base");
-	    new QName(NamespaceRegistryImpl.NS_NT_URI, "hierarchyNode");
+            new QName(NamespaceRegistryImpl.NS_NT_URI, "hierarchyNode");
-	    new QName(NamespaceRegistryImpl.NS_NT_URI, "mimeResource");
+            new QName(NamespaceRegistryImpl.NS_NT_URI, "mimeResource");
-	    new QName(NamespaceRegistryImpl.NS_NT_URI, "query");
+            new QName(NamespaceRegistryImpl.NS_NT_URI, "query");
-	    new QName(NamespaceRegistryImpl.NS_MIX_URI, "referenceable");
+            new QName(NamespaceRegistryImpl.NS_MIX_URI, "referenceable");
-	    new QName(NamespaceRegistryImpl.NS_MIX_URI, "lockable");
+            new QName(NamespaceRegistryImpl.NS_MIX_URI, "lockable");
-	    new QName(NamespaceRegistryImpl.NS_MIX_URI, "versionable");
+            new QName(NamespaceRegistryImpl.NS_MIX_URI, "versionable");
-	    new QName(NamespaceRegistryImpl.NS_NT_URI, "versionHistory");
+            new QName(NamespaceRegistryImpl.NS_NT_URI, "versionHistory");
-	    new QName(NamespaceRegistryImpl.NS_NT_URI, "version");
+            new QName(NamespaceRegistryImpl.NS_NT_URI, "version");
-	    new QName(NamespaceRegistryImpl.NS_NT_URI, "frozen");
+            new QName(NamespaceRegistryImpl.NS_NT_URI, "frozen");
-	    new QName(NamespaceRegistryImpl.NS_NT_URI, "frozenVersionableChild");
+            new QName(NamespaceRegistryImpl.NS_NT_URI, "frozenVersionableChild");
-	    new QName(NamespaceRegistryImpl.NS_JCR_URI, "primaryType");
+            new QName(NamespaceRegistryImpl.NS_JCR_URI, "primaryType");
-	    "org/apache/jackrabbit/core/nodetype/builtin_nodetypes.xml";
+            "org/apache/jackrabbit/core/nodetype/builtin_nodetypes.xml";
-	    throws RepositoryException {
-	NodeTypeRegistry ntMgr = new NodeTypeRegistry(nsReg, ntStore);
-	return ntMgr;
+            throws RepositoryException {
+        NodeTypeRegistry ntMgr = new NodeTypeRegistry(nsReg, ntStore);
+        return ntMgr;
-	    throws RepositoryException {
-	this.nsReg = nsReg;
-	this.ntStore = ntStore;
-	customNodeTypesResource = new FileSystemResource(this.ntStore, CUSTOM_NODETYPES_RESOURCE_NAME);
-	try {
-	    // make sure path to resource exists
-	    if (!customNodeTypesResource.exists()) {
-		customNodeTypesResource.makeParentDirs();
-	    }
-	} catch (FileSystemException fse) {
-	    String error = "internal error: invalid resource: " + customNodeTypesResource.getPath();
-	    log.error(error, fse);
-	    throw new RepositoryException(error, fse);
-	}
+            throws RepositoryException {
+        this.nsReg = nsReg;
+        this.ntStore = ntStore;
+        customNodeTypesResource = new FileSystemResource(this.ntStore, CUSTOM_NODETYPES_RESOURCE_NAME);
+        try {
+            // make sure path to resource exists
+            if (!customNodeTypesResource.exists()) {
+                customNodeTypesResource.makeParentDirs();
+            }
+        } catch (FileSystemException fse) {
+            String error = "internal error: invalid resource: " + customNodeTypesResource.getPath();
+            log.error(error, fse);
+            throw new RepositoryException(error, fse);
+        }
-	entCache = new EffectiveNodeTypeCache();
-	registeredNTDefs = new HashMap();
-	propDefs = new HashMap();
-	nodeDefs = new HashMap();
+        entCache = new EffectiveNodeTypeCache();
+        registeredNTDefs = new HashMap();
+        propDefs = new HashMap();
+        nodeDefs = new HashMap();
-	// setup definition of root node
-	rootNodeDef = createRootNodeDef();
-	nodeDefs.put(new NodeDefId(rootNodeDef), rootNodeDef);
+        // setup definition of root node
+        rootNodeDef = createRootNodeDef();
+        nodeDefs.put(new NodeDefId(rootNodeDef), rootNodeDef);
-	// load and register pre-defined (i.e. built-in) node types
-	builtInNTDefs = new NodeTypeDefStore();
-	InputStream in = null;
-	try {
-	    in = getClass().getClassLoader().getResourceAsStream(BUILTIN_NODETYPES_RESOURCE_PATH);
-	    builtInNTDefs.load(in);
-	    internalRegister(builtInNTDefs.all());
-	} catch (IOException ioe) {
-	    String error = "internal error: failed to read built-in node type definitions stored in " + BUILTIN_NODETYPES_RESOURCE_PATH;
-	    log.error(error, ioe);
-	    throw new RepositoryException(error, ioe);
-	} catch (InvalidNodeTypeDefException intde) {
-	    String error = "internal error: invalid built-in node type definition stored in " + BUILTIN_NODETYPES_RESOURCE_PATH;
-	    log.error(error, intde);
-	    throw new RepositoryException(error, intde);
-	} finally {
-	    if (in != null) {
-		try {
-		    in.close();
-		} catch (IOException ioe) {
-		    // ignore
-		}
-	    }
-	}
+        // load and register pre-defined (i.e. built-in) node types
+        builtInNTDefs = new NodeTypeDefStore();
+        InputStream in = null;
+        try {
+            in = getClass().getClassLoader().getResourceAsStream(BUILTIN_NODETYPES_RESOURCE_PATH);
+            builtInNTDefs.load(in);
+            internalRegister(builtInNTDefs.all());
+        } catch (IOException ioe) {
+            String error = "internal error: failed to read built-in node type definitions stored in " + BUILTIN_NODETYPES_RESOURCE_PATH;
+            log.error(error, ioe);
+            throw new RepositoryException(error, ioe);
+        } catch (InvalidNodeTypeDefException intde) {
+            String error = "internal error: invalid built-in node type definition stored in " + BUILTIN_NODETYPES_RESOURCE_PATH;
+            log.error(error, intde);
+            throw new RepositoryException(error, intde);
+        } finally {
+            if (in != null) {
+                try {
+                    in.close();
+                } catch (IOException ioe) {
+                    // ignore
+                }
+            }
+        }
-	// load and register custom node types
-	customNTDefs = new NodeTypeDefStore();
-	in = null;
-	try {
-	    if (customNodeTypesResource.exists()) {
-		in = customNodeTypesResource.getInputStream();
-	    }
-	} catch (FileSystemException fse) {
-	    String error = "internal error: failed to access custom node type definitions stored in " + customNodeTypesResource.getPath();
-	    log.error(error, fse);
-	    throw new RepositoryException(error, fse);
-	}
-	if (in == null) {
-	    log.info("no custom node type definitions found");
-	} else {
-	    try {
-		customNTDefs.load(in);
-		internalRegister(customNTDefs.all());
-	    } catch (IOException ioe) {
-		String error = "internal error: failed to read custom node type definitions stored in " + customNodeTypesResource.getPath();
-		log.error(error, ioe);
-		throw new RepositoryException(error, ioe);
-	    } catch (InvalidNodeTypeDefException intde) {
-		String error = "internal error: invalid custom node type definition stored in " + customNodeTypesResource.getPath();
-		log.error(error, intde);
-		throw new RepositoryException(error, intde);
-	    } finally {
-		try {
-		    in.close();
-		} catch (IOException ioe) {
-		    // ignore
-		}
-	    }
-	}
+        // load and register custom node types
+        customNTDefs = new NodeTypeDefStore();
+        in = null;
+        try {
+            if (customNodeTypesResource.exists()) {
+                in = customNodeTypesResource.getInputStream();
+            }
+        } catch (FileSystemException fse) {
+            String error = "internal error: failed to access custom node type definitions stored in " + customNodeTypesResource.getPath();
+            log.error(error, fse);
+            throw new RepositoryException(error, fse);
+        }
+        if (in == null) {
+            log.info("no custom node type definitions found");
+        } else {
+            try {
+                customNTDefs.load(in);
+                internalRegister(customNTDefs.all());
+            } catch (IOException ioe) {
+                String error = "internal error: failed to read custom node type definitions stored in " + customNodeTypesResource.getPath();
+                log.error(error, ioe);
+                throw new RepositoryException(error, ioe);
+            } catch (InvalidNodeTypeDefException intde) {
+                String error = "internal error: invalid custom node type definition stored in " + customNodeTypesResource.getPath();
+                log.error(error, intde);
+                throw new RepositoryException(error, intde);
+            } finally {
+                try {
+                    in.close();
+                } catch (IOException ioe) {
+                    // ignore
+                }
+            }
+        }
-	ChildNodeDef def = new ChildNodeDef();
+        ChildNodeDef def = new ChildNodeDef();
-	// FIXME need a fake declaring node type
-	def.setDeclaringNodeType(new QName(NamespaceRegistryImpl.NS_DEFAULT_URI, ""));
-	def.setRequiredPrimaryTypes(new QName[]{NT_BASE});
-	def.setDefaultPrimaryType(NT_UNSTRUCTURED);
-	def.setMandatory(true);
-	def.setProtected(false);
-	def.setOnParentVersion(OnParentVersionAction.VERSION);
-	def.setPrimaryItem(false);
-	def.setAllowSameNameSibs(false);
-	def.setAutoCreate(true);
-	return def;
+        // FIXME need a fake declaring node type
+        def.setDeclaringNodeType(new QName(NamespaceRegistryImpl.NS_DEFAULT_URI, ""));
+        def.setRequiredPrimaryTypes(new QName[]{NT_BASE});
+        def.setDefaultPrimaryType(NT_UNSTRUCTURED);
+        def.setMandatory(true);
+        def.setProtected(false);
+        def.setOnParentVersion(OnParentVersionAction.VERSION);
+        def.setPrimaryItem(false);
+        def.setAllowSameNameSibs(false);
+        def.setAutoCreate(true);
+        return def;
-	    throws InvalidNodeTypeDefException, RepositoryException {
-	ArrayList list = new ArrayList(ntDefs);
+            throws InvalidNodeTypeDefException, RepositoryException {
+        ArrayList list = new ArrayList(ntDefs);
-	// iterate over definitions until there are no more definitions with
-	// unresolved (i.e. unregistered) dependencies or an error occurs;
+        // iterate over definitions until there are no more definitions with
+        // unresolved (i.e. unregistered) dependencies or an error occurs;
-	int count = -1;  // number of registered nt's per iteration
-	while (list.size() > 0 && count != 0) {
-	    count = 0;
-	    Iterator iterator = list.iterator();
-	    while (iterator.hasNext()) {
-		NodeTypeDef ntd = (NodeTypeDef) iterator.next();
-		// check if definition has unresolved dependencies
-		if (registeredNTDefs.keySet().containsAll(ntd.getDependencies())) {
-		    // try to register it
-		    internalRegister(ntd);
-		    // remove it from list
-		    iterator.remove();
-		    // increase count
-		    count++;
-		}
-	    }
-	}
-	if (list.size() > 0) {
-	    StringBuffer msg = new StringBuffer();
-	    msg.append("the following node types could not be registered because of unresolvable dependencies: ");
-	    Iterator iterator = list.iterator();
-	    while (iterator.hasNext()) {
-		msg.append(((NodeTypeDef) iterator.next()).getName());
-		msg.append(" ");
-	    }
-	    log.error(msg.toString());
-	    throw new InvalidNodeTypeDefException(msg.toString());
-	}
+        int count = -1;  // number of registered nt's per iteration
+        while (list.size() > 0 && count != 0) {
+            count = 0;
+            Iterator iterator = list.iterator();
+            while (iterator.hasNext()) {
+                NodeTypeDef ntd = (NodeTypeDef) iterator.next();
+                // check if definition has unresolved dependencies
+                if (registeredNTDefs.keySet().containsAll(ntd.getDependencies())) {
+                    // try to register it
+                    internalRegister(ntd);
+                    // remove it from list
+                    iterator.remove();
+                    // increase count
+                    count++;
+                }
+            }
+        }
+        if (list.size() > 0) {
+            StringBuffer msg = new StringBuffer();
+            msg.append("the following node types could not be registered because of unresolvable dependencies: ");
+            Iterator iterator = list.iterator();
+            while (iterator.hasNext()) {
+                msg.append(((NodeTypeDef) iterator.next()).getName());
+                msg.append(" ");
+            }
+            log.error(msg.toString());
+            throw new InvalidNodeTypeDefException(msg.toString());
+        }
-	    throws InvalidNodeTypeDefException, RepositoryException {
-	QName name = ntd.getName();
-	if (name != null && registeredNTDefs.containsKey(name)) {
-	    String reason = name + " already exists";
-	    log.error(reason);
-	    throw new InvalidNodeTypeDefException(reason);
-	}
+            throws InvalidNodeTypeDefException, RepositoryException {
+        QName name = ntd.getName();
+        if (name != null && registeredNTDefs.containsKey(name)) {
+            String reason = name + " already exists";
+            log.error(reason);
+            throw new InvalidNodeTypeDefException(reason);
+        }
-	EffectiveNodeType ent = validateNodeTypeDef(ntd);
+        EffectiveNodeType ent = validateNodeTypeDef(ntd);
-	// store new effective node type instance
-	entCache.put(ent);
+        // store new effective node type instance
+        entCache.put(ent);
-	// register clone of node type definition
-	try {
-	    ntd = (NodeTypeDef) ntd.clone();
-	} catch (CloneNotSupportedException e) {
-	    // should never get here
-	    log.fatal("internal error", e);
-	    throw new InternalError(e.getMessage());
-	}
-	registeredNTDefs.put(name, ntd);
+        // register clone of node type definition
+        try {
+            ntd = (NodeTypeDef) ntd.clone();
+        } catch (CloneNotSupportedException e) {
+            // should never get here
+            log.fatal("internal error", e);
+            throw new InternalError(e.getMessage());
+        }
+        registeredNTDefs.put(name, ntd);
-	// store poperty & child node definitions of new node type by id
-	PropDef[] pda = ntd.getPropertyDefs();
-	for (int i = 0; i < pda.length; i++) {
-	    PropDef def = pda[i];
-	    PropDefId id = new PropDefId(def);
-	    propDefs.put(id, def);
-	}
-	ChildNodeDef[] nda = ntd.getChildNodeDefs();
-	for (int i = 0; i < nda.length; i++) {
-	    ChildNodeDef def = nda[i];
-	    NodeDefId id = new NodeDefId(def);
-	    nodeDefs.put(id, def);
-	}
+        // store poperty & child node definitions of new node type by id
+        PropDef[] pda = ntd.getPropertyDefs();
+        for (int i = 0; i < pda.length; i++) {
+            PropDef def = pda[i];
+            PropDefId id = new PropDefId(def);
+            propDefs.put(id, def);
+        }
+        ChildNodeDef[] nda = ntd.getChildNodeDefs();
+        for (int i = 0; i < nda.length; i++) {
+            ChildNodeDef def = nda[i];
+            NodeDefId id = new NodeDefId(def);
+            nodeDefs.put(id, def);
+        }
-	return ent;
+        return ent;
-	if (!listeners.containsKey(listener)) {
-	    listeners.put(listener, listener);
-	}
+        if (!listeners.containsKey(listener)) {
+            listeners.put(listener, listener);
+        }
-	listeners.remove(listener);
+        listeners.remove(listener);
-	// copy listeners to array to avoid ConcurrentModificationException
-	NodeTypeRegistryListener[] la = new NodeTypeRegistryListener[listeners.size()];
-	Iterator iter = listeners.values().iterator();
-	int cnt = 0;
-	while (iter.hasNext()) {
-	    la[cnt++] = (NodeTypeRegistryListener) iter.next();
-	}
-	for (int i = 0; i < la.length; i++) {
-	    if (la[i] != null) {
-		la[i].nodeTypeRegistered(ntName);
-	    }
-	}
+        // copy listeners to array to avoid ConcurrentModificationException
+        NodeTypeRegistryListener[] la = new NodeTypeRegistryListener[listeners.size()];
+        Iterator iter = listeners.values().iterator();
+        int cnt = 0;
+        while (iter.hasNext()) {
+            la[cnt++] = (NodeTypeRegistryListener) iter.next();
+        }
+        for (int i = 0; i < la.length; i++) {
+            if (la[i] != null) {
+                la[i].nodeTypeRegistered(ntName);
+            }
+        }
-	// copy listeners to array to avoid ConcurrentModificationException
-	NodeTypeRegistryListener[] la = new NodeTypeRegistryListener[listeners.size()];
-	Iterator iter = listeners.values().iterator();
-	int cnt = 0;
-	while (iter.hasNext()) {
-	    la[cnt++] = (NodeTypeRegistryListener) iter.next();
-	}
-	for (int i = 0; i < la.length; i++) {
-	    if (la[i] != null) {
-		la[i].nodeTypeUnregistered(ntName);
-	    }
-	}
+        // copy listeners to array to avoid ConcurrentModificationException
+        NodeTypeRegistryListener[] la = new NodeTypeRegistryListener[listeners.size()];
+        Iterator iter = listeners.values().iterator();
+        int cnt = 0;
+        while (iter.hasNext()) {
+            la[cnt++] = (NodeTypeRegistryListener) iter.next();
+        }
+        for (int i = 0; i < la.length; i++) {
+            if (la[i] != null) {
+                la[i].nodeTypeUnregistered(ntName);
+            }
+        }
-	    throws InvalidNodeTypeDefException, RepositoryException {
+            throws InvalidNodeTypeDefException, RepositoryException {
-	// the effective (i.e. merged and resolved) node type resulting from
-	// the specified node type definition;
-	// the effective node type will finally be created after the definition
-	// has been verified and checked for conflicts etc.; in some cases it
-	// will be created already at an earlier stage during the validation
-	// of child node definitions
-	EffectiveNodeType ent = null;
+        // the effective (i.e. merged and resolved) node type resulting from
+        // the specified node type definition;
+        // the effective node type will finally be created after the definition
+        // has been verified and checked for conflicts etc.; in some cases it
+        // will be created already at an earlier stage during the validation
+        // of child node definitions
+        EffectiveNodeType ent = null;
-	QName name = ntd.getName();
-	if (name == null) {
-	    String reason = "no name specified";
-	    log.error(reason);
-	    throw new InvalidNodeTypeDefException(reason);
-	}
+        QName name = ntd.getName();
+        if (name == null) {
+            String reason = "no name specified";
+            log.error(reason);
+            throw new InvalidNodeTypeDefException(reason);
+        }
-	if (registeredNTDefs.containsKey(name)) {
-	    String reason = name + " already exists";
-	    log.error(reason);
-	    throw new InvalidNodeTypeDefException(reason);
-	}
+        if (registeredNTDefs.containsKey(name)) {
+            String reason = name + " already exists";
+            log.error(reason);
+            throw new InvalidNodeTypeDefException(reason);
+        }
-	// validate supertypes
-	QName[] supertypes = ntd.getSupertypes();
-	for (int i = 0; i < supertypes.length; i++) {
-	    // simple check for infinite recursion
-	    // (won't trap recursion on a deeper inheritance level)
-	    if (name.equals(supertypes[i])) {
-		String reason = "invalid supertype: " + supertypes[i] + " (infinite recursion))";
-		log.error(reason);
-		throw new InvalidNodeTypeDefException(reason);
-	    }
-	    if (!registeredNTDefs.containsKey(supertypes[i])) {
-		String reason = "invalid supertype: " + supertypes[i];
-		log.error(reason);
-		throw new InvalidNodeTypeDefException(reason);
-	    }
-	}
+        // validate supertypes
+        QName[] supertypes = ntd.getSupertypes();
+        for (int i = 0; i < supertypes.length; i++) {
+            // simple check for infinite recursion
+            // (won't trap recursion on a deeper inheritance level)
+            if (name.equals(supertypes[i])) {
+                String reason = "invalid supertype: " + supertypes[i] + " (infinite recursion))";
+                log.error(reason);
+                throw new InvalidNodeTypeDefException(reason);
+            }
+            if (!registeredNTDefs.containsKey(supertypes[i])) {
+                String reason = "invalid supertype: " + supertypes[i];
+                log.error(reason);
+                throw new InvalidNodeTypeDefException(reason);
+            }
+        }
-	// check for circularity in inheritance chain ('a' extends 'b' extends 'a'):
-	Stack inheritanceChain = new Stack();
-	inheritanceChain.push(name);
-	checkForCircularInheritance(supertypes, inheritanceChain);
+        // check for circularity in inheritance chain ('a' extends 'b' extends 'a'):
+        Stack inheritanceChain = new Stack();
+        inheritanceChain.push(name);
+        checkForCircularInheritance(supertypes, inheritanceChain);
-	// note that infinite recursion through inheritance is automatically being checked
-	// by the following call to getEffectiveNodeType
-	// as it's impossible to register an node type definition which references a
-	// supertype that isn't registered yet...
+        // note that infinite recursion through inheritance is automatically being checked
+        // by the following call to getEffectiveNodeType
+        // as it's impossible to register an node type definition which references a
+        // supertype that isn't registered yet...
-	// build effective (i.e. merged and resolved) node type from supertypes
-	// and check for conflicts
-	if (supertypes.length > 0) {
-	    try {
-		buildEffectiveNodeType(supertypes);
-	    } catch (NodeTypeConflictException ntce) {
-		String reason = "failed to validate supertypes";
-		log.error(reason, ntce);
-		throw new InvalidNodeTypeDefException(reason, ntce);
-	    } catch (NoSuchNodeTypeException nsnte) {
-		String reason = "failed to validate supertypes";
-		log.error(reason, nsnte);
-		throw new InvalidNodeTypeDefException(reason, nsnte);
-	    }
-	}
+        // build effective (i.e. merged and resolved) node type from supertypes
+        // and check for conflicts
+        if (supertypes.length > 0) {
+            try {
+                buildEffectiveNodeType(supertypes);
+            } catch (NodeTypeConflictException ntce) {
+                String reason = "failed to validate supertypes";
+                log.error(reason, ntce);
+                throw new InvalidNodeTypeDefException(reason, ntce);
+            } catch (NoSuchNodeTypeException nsnte) {
+                String reason = "failed to validate supertypes";
+                log.error(reason, nsnte);
+                throw new InvalidNodeTypeDefException(reason, nsnte);
+            }
+        }
-	ChildItemDef primaryItem = null;
+        ChildItemDef primaryItem = null;
-	// validate property definitions
-	PropDef[] pda = ntd.getPropertyDefs();
-	for (int i = 0; i < pda.length; i++) {
-	    PropDef pd = pda[i];
-	    // check primary item flag
-	    if (pd.isPrimaryItem()) {
-		if (pd.definesResidual()) {
-		    String reason = "primary item must specify a name";
-		    log.error(reason);
-		    throw new InvalidNodeTypeDefException(reason);
-		}
-		if (primaryItem != null) {
-		    String reason = "more than one primary item specified";
-		    log.error(reason);
-		    throw new InvalidNodeTypeDefException(reason);
-		} else {
-		    primaryItem = pd;
-		}
-	    }
-	    // check that auto-created properties specify a name
-	    if (pd.definesResidual() && pd.isAutoCreate()) {
-		String reason = "auto-created properties must specify a name";
-		log.error(reason);
-		throw new InvalidNodeTypeDefException(reason);
-	    }
-	    ValueConstraint[] constraints = pd.getValueConstraints();
-	    InternalValue[] defVals = pd.getDefaultValues();
-	    if (constraints != null && constraints.length != 0
-		    && defVals != null && defVals.length != 0) {
-		// check that default values satisfy value constraints
-		for (int j = 0; j < constraints.length; j++) {
-		    for (int k = 0; k < defVals.length; k++) {
-			try {
-			    constraints[j].check(defVals[k]);
-			} catch (ConstraintViolationException cve) {
-			    String msg = "default value of property "
-				    + (pd.definesResidual() ? "*" : pd.getName().toString())
-				    + " does not satisfy value constraint "
-				    + constraints[j].getDefinition();
-			    log.error(msg, cve);
-			    throw new InvalidNodeTypeDefException(msg, cve);
-			}
-		    }
-		}
-	    }
-	}
+        // validate property definitions
+        PropDef[] pda = ntd.getPropertyDefs();
+        for (int i = 0; i < pda.length; i++) {
+            PropDef pd = pda[i];
+            // check primary item flag
+            if (pd.isPrimaryItem()) {
+                if (pd.definesResidual()) {
+                    String reason = "primary item must specify a name";
+                    log.error(reason);
+                    throw new InvalidNodeTypeDefException(reason);
+                }
+                if (primaryItem != null) {
+                    String reason = "more than one primary item specified";
+                    log.error(reason);
+                    throw new InvalidNodeTypeDefException(reason);
+                } else {
+                    primaryItem = pd;
+                }
+            }
+            // check that auto-created properties specify a name
+            if (pd.definesResidual() && pd.isAutoCreate()) {
+                String reason = "auto-created properties must specify a name";
+                log.error(reason);
+                throw new InvalidNodeTypeDefException(reason);
+            }
+            ValueConstraint[] constraints = pd.getValueConstraints();
+            InternalValue[] defVals = pd.getDefaultValues();
+            if (constraints != null && constraints.length != 0
+                    && defVals != null && defVals.length != 0) {
+                // check that default values satisfy value constraints
+                for (int j = 0; j < constraints.length; j++) {
+                    for (int k = 0; k < defVals.length; k++) {
+                        try {
+                            constraints[j].check(defVals[k]);
+                        } catch (ConstraintViolationException cve) {
+                            String msg = "default value of property "
+                                    + (pd.definesResidual() ? "*" : pd.getName().toString())
+                                    + " does not satisfy value constraint "
+                                    + constraints[j].getDefinition();
+                            log.error(msg, cve);
+                            throw new InvalidNodeTypeDefException(msg, cve);
+                        }
+                    }
+                }
+            }
+        }
-	// validate child-node definitions
-	ChildNodeDef[] cnda = ntd.getChildNodeDefs();
-	for (int i = 0; i < cnda.length; i++) {
-	    ChildNodeDef cnd = cnda[i];
-	    // check primary item flag
-	    if (cnd.isPrimaryItem()) {
-		if (cnd.definesResidual()) {
-		    String msg = "primary item must specify a name";
-		    log.error(msg);
-		    throw new InvalidNodeTypeDefException(msg);
-		}
-		if (primaryItem != null) {
-		    String msg = "more than one primary item specified";
-		    log.error(msg);
-		    throw new InvalidNodeTypeDefException(msg);
-		} else {
-		    primaryItem = cnd;
-		}
-	    }
-	    // check that auto-created child-nodes specify a name
-	    if (cnd.definesResidual() && cnd.isAutoCreate()) {
-		String msg = "auto-created child-nodes must specify a name";
-		log.error(msg);
-		throw new InvalidNodeTypeDefException(msg);
-	    }
-	    // check default primary type
-	    QName dpt = cnd.getDefaultPrimaryType();
-	    boolean referenceToSelf = false;
-	    EffectiveNodeType defaultENT = null;
-	    if (dpt != null) {
-		// check if this node type specifies itself as default primary type
-		if (name.equals(dpt)) {
-		    referenceToSelf = true;
-		}
-		// the default primary type must be registered with one notable
-		// exception: the node type just being registered
-		if (!name.equals(dpt) && !registeredNTDefs.containsKey(dpt)) {
-		    String msg = "Invalid default primary type: " + dpt + " in childnode definition " + cnd.getName();
-		    log.error(msg);
-		    throw new InvalidNodeTypeDefException(msg);
-		}
-		// build effective (i.e. merged and resolved) node type from
-		// default primary type and check for conflicts
-		try {
-		    if (!referenceToSelf) {
-			defaultENT = getEffectiveNodeType(dpt);
-		    } else {
-			// the default primary type is identical with the node type
-			// just being registered; we have to instantiate it
-			// 'manually'
-			ent = EffectiveNodeType.create(this, ntd);
-			defaultENT = ent;
-		    }
-		    if (cnd.isAutoCreate()) {
-			// check for circularity through default primary types of
-			// auto-created child nodes (node type 'a' defines
-			// auto-created child node with default primary type 'a')
-			Stack definingNTs = new Stack();
-			definingNTs.push(name);
-			checkForCircularNodeAutoCreation(defaultENT, definingNTs);
-		    }
-		} catch (NodeTypeConflictException ntce) {
-		    String msg = "failed to validate default primary type";
-		    log.error(msg, ntce);
-		    throw new InvalidNodeTypeDefException(msg, ntce);
-		} catch (NoSuchNodeTypeException nsnte) {
-		    String msg = "failed to validate default primary type";
-		    log.error(msg, nsnte);
-		    throw new InvalidNodeTypeDefException(msg, nsnte);
-		}
-	    }
+        // validate child-node definitions
+        ChildNodeDef[] cnda = ntd.getChildNodeDefs();
+        for (int i = 0; i < cnda.length; i++) {
+            ChildNodeDef cnd = cnda[i];
+            // check primary item flag
+            if (cnd.isPrimaryItem()) {
+                if (cnd.definesResidual()) {
+                    String msg = "primary item must specify a name";
+                    log.error(msg);
+                    throw new InvalidNodeTypeDefException(msg);
+                }
+                if (primaryItem != null) {
+                    String msg = "more than one primary item specified";
+                    log.error(msg);
+                    throw new InvalidNodeTypeDefException(msg);
+                } else {
+                    primaryItem = cnd;
+                }
+            }
+            // check that auto-created child-nodes specify a name
+            if (cnd.definesResidual() && cnd.isAutoCreate()) {
+                String msg = "auto-created child-nodes must specify a name";
+                log.error(msg);
+                throw new InvalidNodeTypeDefException(msg);
+            }
+            // check default primary type
+            QName dpt = cnd.getDefaultPrimaryType();
+            boolean referenceToSelf = false;
+            EffectiveNodeType defaultENT = null;
+            if (dpt != null) {
+                // check if this node type specifies itself as default primary type
+                if (name.equals(dpt)) {
+                    referenceToSelf = true;
+                }
+                // the default primary type must be registered with one notable
+                // exception: the node type just being registered
+                if (!name.equals(dpt) && !registeredNTDefs.containsKey(dpt)) {
+                    String msg = "Invalid default primary type: " + dpt + " in childnode definition " + cnd.getName();
+                    log.error(msg);
+                    throw new InvalidNodeTypeDefException(msg);
+                }
+                // build effective (i.e. merged and resolved) node type from
+                // default primary type and check for conflicts
+                try {
+                    if (!referenceToSelf) {
+                        defaultENT = getEffectiveNodeType(dpt);
+                    } else {
+                        // the default primary type is identical with the node type
+                        // just being registered; we have to instantiate it
+                        // 'manually'
+                        ent = EffectiveNodeType.create(this, ntd);
+                        defaultENT = ent;
+                    }
+                    if (cnd.isAutoCreate()) {
+                        // check for circularity through default primary types of
+                        // auto-created child nodes (node type 'a' defines
+                        // auto-created child node with default primary type 'a')
+                        Stack definingNTs = new Stack();
+                        definingNTs.push(name);
+                        checkForCircularNodeAutoCreation(defaultENT, definingNTs);
+                    }
+                } catch (NodeTypeConflictException ntce) {
+                    String msg = "failed to validate default primary type";
+                    log.error(msg, ntce);
+                    throw new InvalidNodeTypeDefException(msg, ntce);
+                } catch (NoSuchNodeTypeException nsnte) {
+                    String msg = "failed to validate default primary type";
+                    log.error(msg, nsnte);
+                    throw new InvalidNodeTypeDefException(msg, nsnte);
+                }
+            }
-	    // check required primary types
-	    QName[] reqTypes = cnd.getRequiredPrimaryTypes();
-	    if (reqTypes != null && reqTypes.length > 0) {
-		for (int n = 0; n < reqTypes.length; n++) {
-		    QName rpt = reqTypes[n];
-		    referenceToSelf = false;
-		    // check if this node type specifies itself as required primary type
-		    if (name.equals(rpt)) {
-			referenceToSelf = true;
-		    }
-		    // the required primary type must be registered with one notable
-		    // exception: the node type just being registered
-		    if (!name.equals(rpt) && !registeredNTDefs.containsKey(rpt)) {
-			String msg = "invalid required primary type: " + rpt;
-			log.error(msg);
-			throw new InvalidNodeTypeDefException(msg);
-		    }
-		    // check if default primary type satisfies the required primary type constraint
-		    if (defaultENT != null && !defaultENT.includesNodeType(rpt)) {
-			String msg = "default primary type does not satisfy required primary type constraint " + rpt;
-			log.error(msg);
-			throw new InvalidNodeTypeDefException(msg);
-		    }
-		    // build effective (i.e. merged and resolved) node type from
-		    // required primary type constraint and check for conflicts
-		    try {
-			if (!referenceToSelf) {
-			    getEffectiveNodeType(rpt);
-			} else {
-			    // the required primary type is identical with the node type
-			    // just being registered; we have to instantiate it
-			    // 'manually'
-			    if (ent == null) {
-				ent = EffectiveNodeType.create(this, ntd);
-			    }
-			}
-		    } catch (NodeTypeConflictException ntce) {
-			String msg = "failed to validate required primary type constraint";
-			log.error(msg, ntce);
-			throw new InvalidNodeTypeDefException(msg, ntce);
-		    } catch (NoSuchNodeTypeException nsnte) {
-			String msg = "failed to validate required primary type constraint";
-			log.error(msg, nsnte);
-			throw new InvalidNodeTypeDefException(msg, nsnte);
-		    }
-		}
-	    }
-	}
+            // check required primary types
+            QName[] reqTypes = cnd.getRequiredPrimaryTypes();
+            if (reqTypes != null && reqTypes.length > 0) {
+                for (int n = 0; n < reqTypes.length; n++) {
+                    QName rpt = reqTypes[n];
+                    referenceToSelf = false;
+                    // check if this node type specifies itself as required primary type
+                    if (name.equals(rpt)) {
+                        referenceToSelf = true;
+                    }
+                    // the required primary type must be registered with one notable
+                    // exception: the node type just being registered
+                    if (!name.equals(rpt) && !registeredNTDefs.containsKey(rpt)) {
+                        String msg = "invalid required primary type: " + rpt;
+                        log.error(msg);
+                        throw new InvalidNodeTypeDefException(msg);
+                    }
+                    // check if default primary type satisfies the required primary type constraint
+                    if (defaultENT != null && !defaultENT.includesNodeType(rpt)) {
+                        String msg = "default primary type does not satisfy required primary type constraint " + rpt;
+                        log.error(msg);
+                        throw new InvalidNodeTypeDefException(msg);
+                    }
+                    // build effective (i.e. merged and resolved) node type from
+                    // required primary type constraint and check for conflicts
+                    try {
+                        if (!referenceToSelf) {
+                            getEffectiveNodeType(rpt);
+                        } else {
+                            // the required primary type is identical with the node type
+                            // just being registered; we have to instantiate it
+                            // 'manually'
+                            if (ent == null) {
+                                ent = EffectiveNodeType.create(this, ntd);
+                            }
+                        }
+                    } catch (NodeTypeConflictException ntce) {
+                        String msg = "failed to validate required primary type constraint";
+                        log.error(msg, ntce);
+                        throw new InvalidNodeTypeDefException(msg, ntce);
+                    } catch (NoSuchNodeTypeException nsnte) {
+                        String msg = "failed to validate required primary type constraint";
+                        log.error(msg, nsnte);
+                        throw new InvalidNodeTypeDefException(msg, nsnte);
+                    }
+                }
+            }
+        }
-	// now build effective (i.e. merged and resolved) node type from
-	// this node type definition; this will potentially detect more
-	// conflicts or problems
-	if (ent == null) {
-	    try {
-		ent = EffectiveNodeType.create(this, ntd);
-	    } catch (NodeTypeConflictException ntce) {
-		String msg = "failed to resolve node type definition";
-		log.error(msg, ntce);
-		throw new InvalidNodeTypeDefException(msg, ntce);
-	    } catch (NoSuchNodeTypeException nsnte) {
-		String msg = "failed to resolve node type definition";
-		log.error(msg, nsnte);
-		throw new InvalidNodeTypeDefException(msg, nsnte);
-	    }
-	}
-	return ent;
+        // now build effective (i.e. merged and resolved) node type from
+        // this node type definition; this will potentially detect more
+        // conflicts or problems
+        if (ent == null) {
+            try {
+                ent = EffectiveNodeType.create(this, ntd);
+            } catch (NodeTypeConflictException ntce) {
+                String msg = "failed to resolve node type definition";
+                log.error(msg, ntce);
+                throw new InvalidNodeTypeDefException(msg, ntce);
+            } catch (NoSuchNodeTypeException nsnte) {
+                String msg = "failed to resolve node type definition";
+                log.error(msg, nsnte);
+                throw new InvalidNodeTypeDefException(msg, nsnte);
+            }
+        }
+        return ent;
-	return (QName[]) registeredNTDefs.keySet().toArray(new QName[registeredNTDefs.size()]);
+        return (QName[]) registeredNTDefs.keySet().toArray(new QName[registeredNTDefs.size()]);
-	return rootNodeDef;
+        return rootNodeDef;
-	    throws NoSuchNodeTypeException {
-	WeightedKey key = new WeightedKey(new QName[]{ntName});
-	if (entCache.contains(key)) {
-	    return entCache.get(key);
-	} else {
-	    throw new NoSuchNodeTypeException(ntName.toString());
-	}
+            throws NoSuchNodeTypeException {
+        WeightedKey key = new WeightedKey(new QName[]{ntName});
+        if (entCache.contains(key)) {
+            return entCache.get(key);
+        } else {
+            throw new NoSuchNodeTypeException(ntName.toString());
+        }
-	    throws NodeTypeConflictException, NoSuchNodeTypeException {
-	// 1. make sure every single node type is registered
-	for (int i = 0; i < ntNames.length; i++) {
-	    if (!registeredNTDefs.containsKey(ntNames[i])) {
-		throw new NoSuchNodeTypeException(ntNames[i].toString());
-	    }
-	}
+            throws NodeTypeConflictException, NoSuchNodeTypeException {
+        // 1. make sure every single node type is registered
+        for (int i = 0; i < ntNames.length; i++) {
+            if (!registeredNTDefs.containsKey(ntNames[i])) {
+                throw new NoSuchNodeTypeException(ntNames[i].toString());
+            }
+        }
-	WeightedKey key = new WeightedKey(ntNames);
+        WeightedKey key = new WeightedKey(ntNames);
-	// 2. check if aggregate has already been build
-	if (entCache.contains(key)) {
-	    return entCache.get(key);
-	}
+        // 2. check if aggregate has already been build
+        if (entCache.contains(key)) {
+            return entCache.get(key);
+        }
-	// 3. build aggregate
-	EffectiveNodeType result = null;
+        // 3. build aggregate
+        EffectiveNodeType result = null;
-	// build list of 'best' existing sub-aggregates
-	ArrayList tmpResults = new ArrayList();
-	while (key.size() > 0) {
-	    // check if we've already built this aggregate
-	    if (entCache.contains(key)) {
-		tmpResults.add(entCache.get(key));
-		// subtract the result from the temporary key
-		// (which is 'empty' now)
-		key = key.subtract(key);
-		break;
-	    }
-	    // walk list of existing aggregates sorted by 'weight' of
-	    // aggregate (i.e. the cost of building it)
-	    boolean foundSubResult = false;
-	    Iterator iter = entCache.keys();
-	    while (iter.hasNext()) {
-		WeightedKey k = (WeightedKey) iter.next();
-		// check if the existing aggregate is a 'subset' of the one
-		// we're looking for
-		if (key.contains(k)) {
-		    tmpResults.add(entCache.get(k));
-		    // subtract the result from the temporary key
-		    key = key.subtract(k);
-		    foundSubResult = true;
-		    break;
-		}
-	    }
-	    if (!foundSubResult) {
-		// no matching sub-aggregates found:
-		// build aggregate of remaining node types through iteration
-		QName[] remainder = key.toArray();
-		for (int i = 0; i < remainder.length; i++) {
-		    EffectiveNodeType ent = null;
-		    ent = EffectiveNodeType.create(this, remainder[i]);
-		    // store new effective node type
-		    entCache.put(ent);
-		    if (result == null) {
-			result = ent;
-		    } else {
-			result = result.merge(ent);
-			// store intermediate result (sub-aggregate)
-			entCache.put(result);
-		    }
-		}
-		// add aggregate of remaining node types to result list
-		tmpResults.add(result);
-		break;
-	    }
-	}
-	// merge the sub-aggregates into new effective node type
-	for (int i = 0; i < tmpResults.size(); i++) {
-	    if (result == null) {
-		result = (EffectiveNodeType) tmpResults.get(i);
-	    } else {
-		result = result.merge((EffectiveNodeType) tmpResults.get(i));
-		// store intermediate result
-		entCache.put(result);
-	    }
-	}
-	// we're done
-	return result;
+        // build list of 'best' existing sub-aggregates
+        ArrayList tmpResults = new ArrayList();
+        while (key.size() > 0) {
+            // check if we've already built this aggregate
+            if (entCache.contains(key)) {
+                tmpResults.add(entCache.get(key));
+                // subtract the result from the temporary key
+                // (which is 'empty' now)
+                key = key.subtract(key);
+                break;
+            }
+            // walk list of existing aggregates sorted by 'weight' of
+            // aggregate (i.e. the cost of building it)
+            boolean foundSubResult = false;
+            Iterator iter = entCache.keys();
+            while (iter.hasNext()) {
+                WeightedKey k = (WeightedKey) iter.next();
+                // check if the existing aggregate is a 'subset' of the one
+                // we're looking for
+                if (key.contains(k)) {
+                    tmpResults.add(entCache.get(k));
+                    // subtract the result from the temporary key
+                    key = key.subtract(k);
+                    foundSubResult = true;
+                    break;
+                }
+            }
+            if (!foundSubResult) {
+                // no matching sub-aggregates found:
+                // build aggregate of remaining node types through iteration
+                QName[] remainder = key.toArray();
+                for (int i = 0; i < remainder.length; i++) {
+                    EffectiveNodeType ent = null;
+                    ent = EffectiveNodeType.create(this, remainder[i]);
+                    // store new effective node type
+                    entCache.put(ent);
+                    if (result == null) {
+                        result = ent;
+                    } else {
+                        result = result.merge(ent);
+                        // store intermediate result (sub-aggregate)
+                        entCache.put(result);
+                    }
+                }
+                // add aggregate of remaining node types to result list
+                tmpResults.add(result);
+                break;
+            }
+        }
+        // merge the sub-aggregates into new effective node type
+        for (int i = 0; i < tmpResults.size(); i++) {
+            if (result == null) {
+                result = (EffectiveNodeType) tmpResults.get(i);
+            } else {
+                result = result.merge((EffectiveNodeType) tmpResults.get(i));
+                // store intermediate result
+                entCache.put(result);
+            }
+        }
+        // we're done
+        return result;
-	    throws InvalidNodeTypeDefException, RepositoryException {
-	for (int i = 0; i < supertypes.length; i++) {
-	    QName nt = supertypes[i];
-	    int pos = inheritanceChain.lastIndexOf(nt);
-	    if (pos >= 0) {
-		StringBuffer buf = new StringBuffer();
-		for (int j = 0; j < inheritanceChain.size(); j++) {
-		    if (j == pos) {
-			buf.append("--> ");
-		    }
-		    buf.append(inheritanceChain.get(j));
-		    buf.append(" extends ");
-		}
-		buf.append("--> ");
-		buf.append(nt);
-		throw new InvalidNodeTypeDefException("circular inheritance detected: " + buf.toString());
-	    }
+            throws InvalidNodeTypeDefException, RepositoryException {
+        for (int i = 0; i < supertypes.length; i++) {
+            QName nt = supertypes[i];
+            int pos = inheritanceChain.lastIndexOf(nt);
+            if (pos >= 0) {
+                StringBuffer buf = new StringBuffer();
+                for (int j = 0; j < inheritanceChain.size(); j++) {
+                    if (j == pos) {
+                        buf.append("--> ");
+                    }
+                    buf.append(inheritanceChain.get(j));
+                    buf.append(" extends ");
+                }
+                buf.append("--> ");
+                buf.append(nt);
+                throw new InvalidNodeTypeDefException("circular inheritance detected: " + buf.toString());
+            }
-	    try {
-		QName[] sta = getNodeTypeDef(nt).getSupertypes();
-		if (sta != null && sta.length > 0) {
-		    // check recursively
-		    inheritanceChain.push(nt);
-		    checkForCircularInheritance(sta, inheritanceChain);
-		    inheritanceChain.pop();
-		}
-	    } catch (NoSuchNodeTypeException nsnte) {
-		String reason = "unknown supertype: " + nt;
-		log.error(reason, nsnte);
-		throw new InvalidNodeTypeDefException(reason, nsnte);
-	    }
-	}
+            try {
+                QName[] sta = getNodeTypeDef(nt).getSupertypes();
+                if (sta != null && sta.length > 0) {
+                    // check recursively
+                    inheritanceChain.push(nt);
+                    checkForCircularInheritance(sta, inheritanceChain);
+                    inheritanceChain.pop();
+                }
+            } catch (NoSuchNodeTypeException nsnte) {
+                String reason = "unknown supertype: " + nt;
+                log.error(reason, nsnte);
+                throw new InvalidNodeTypeDefException(reason, nsnte);
+            }
+        }
-	    throws InvalidNodeTypeDefException {
-	// check for circularity through default node types of auto-created child nodes
-	// (node type 'a' defines auto-created child node with default node type 'a')
-	QName[] childNodeNTs = childNodeENT.getAllNodeTypes();
-	for (int i = 0; i < childNodeNTs.length; i++) {
-	    QName nt = childNodeNTs[i];
-	    int pos = definingParentNTs.lastIndexOf(nt);
-	    if (pos >= 0) {
-		StringBuffer buf = new StringBuffer();
-		for (int j = 0; j < definingParentNTs.size(); j++) {
-		    if (j == pos) {
-			buf.append("--> ");
-		    }
-		    buf.append("node type ");
-		    buf.append(definingParentNTs.get(j));
-		    buf.append(" defines auto-created child node with default ");
-		}
-		buf.append("--> ");
-		buf.append("node type ");
-		buf.append(nt);
-		throw new InvalidNodeTypeDefException("circular node auto-creation detected: " + buf.toString());
-	    }
-	}
+            throws InvalidNodeTypeDefException {
+        // check for circularity through default node types of auto-created child nodes
+        // (node type 'a' defines auto-created child node with default node type 'a')
+        QName[] childNodeNTs = childNodeENT.getAllNodeTypes();
+        for (int i = 0; i < childNodeNTs.length; i++) {
+            QName nt = childNodeNTs[i];
+            int pos = definingParentNTs.lastIndexOf(nt);
+            if (pos >= 0) {
+                StringBuffer buf = new StringBuffer();
+                for (int j = 0; j < definingParentNTs.size(); j++) {
+                    if (j == pos) {
+                        buf.append("--> ");
+                    }
+                    buf.append("node type ");
+                    buf.append(definingParentNTs.get(j));
+                    buf.append(" defines auto-created child node with default ");
+                }
+                buf.append("--> ");
+                buf.append("node type ");
+                buf.append(nt);
+                throw new InvalidNodeTypeDefException("circular node auto-creation detected: " + buf.toString());
+            }
+        }
-	ChildNodeDef[] nodeDefs = childNodeENT.getAutoCreateNodeDefs();
-	for (int i = 0; i < nodeDefs.length; i++) {
-	    QName dnt = nodeDefs[i].getDefaultPrimaryType();
-	    QName definingNT = nodeDefs[i].getDeclaringNodeType();
-	    try {
-		if (dnt != null) {
-		    // check recursively
-		    definingParentNTs.push(definingNT);
-		    checkForCircularNodeAutoCreation(getEffectiveNodeType(dnt), definingParentNTs);
-		    definingParentNTs.pop();
-		}
-	    } catch (NoSuchNodeTypeException nsnte) {
-		String reason = definingNT + " defines invalid default node type for child node " + nodeDefs[i].getName();
-		log.error(reason, nsnte);
-		throw new InvalidNodeTypeDefException(reason, nsnte);
-	    }
-	}
+        ChildNodeDef[] nodeDefs = childNodeENT.getAutoCreateNodeDefs();
+        for (int i = 0; i < nodeDefs.length; i++) {
+            QName dnt = nodeDefs[i].getDefaultPrimaryType();
+            QName definingNT = nodeDefs[i].getDeclaringNodeType();
+            try {
+                if (dnt != null) {
+                    // check recursively
+                    definingParentNTs.push(definingNT);
+                    checkForCircularNodeAutoCreation(getEffectiveNodeType(dnt), definingParentNTs);
+                    definingParentNTs.pop();
+                }
+            } catch (NoSuchNodeTypeException nsnte) {
+                String reason = definingNT + " defines invalid default node type for child node " + nodeDefs[i].getName();
+                log.error(reason, nsnte);
+                throw new InvalidNodeTypeDefException(reason, nsnte);
+            }
+        }
-	    throws InvalidNodeTypeDefException, RepositoryException {
-	// validate and register new node type definition
-	EffectiveNodeType ent = internalRegister(ntd);
-	// persist new node type definition
-	customNTDefs.add(ntd);
-	try {
-	    customNTDefs.store(customNodeTypesResource.getOutputStream(), nsReg);
-	} catch (IOException ioe) {
-	    String error = "internal error: failed to write custom node type definition to " + customNodeTypesResource.getPath();
-	    log.error(error, ioe);
-	    throw new RepositoryException(error, ioe);
-	} catch (FileSystemException fse) {
-	    String error = "internal error: failed to write custom node type definition to " + customNodeTypesResource.getPath();
-	    log.error(error, fse);
-	    throw new RepositoryException(error, fse);
-	}
+            throws InvalidNodeTypeDefException, RepositoryException {
+        // validate and register new node type definition
+        EffectiveNodeType ent = internalRegister(ntd);
+        // persist new node type definition
+        customNTDefs.add(ntd);
+        try {
+            customNTDefs.store(customNodeTypesResource.getOutputStream(), nsReg);
+        } catch (IOException ioe) {
+            String error = "internal error: failed to write custom node type definition to " + customNodeTypesResource.getPath();
+            log.error(error, ioe);
+            throw new RepositoryException(error, ioe);
+        } catch (FileSystemException fse) {
+            String error = "internal error: failed to write custom node type definition to " + customNodeTypesResource.getPath();
+            log.error(error, fse);
+            throw new RepositoryException(error, fse);
+        }
-	// notify listeners
-	notifyRegistered(ntd.getName());
+        // notify listeners
+        notifyRegistered(ntd.getName());
-	return ent;
+        return ent;
-	    throws NoSuchNodeTypeException, RepositoryException {
-	if (!registeredNTDefs.containsKey(name)) {
-	    throw new NoSuchNodeTypeException(name.toString());
-	}
-	if (builtInNTDefs.contains(name)) {
-	    throw new RepositoryException(name.toString() + ": can't unregister built-in node type.");
-	}
+            throws NoSuchNodeTypeException, RepositoryException {
+        if (!registeredNTDefs.containsKey(name)) {
+            throw new NoSuchNodeTypeException(name.toString());
+        }
+        if (builtInNTDefs.contains(name)) {
+            throw new RepositoryException(name.toString() + ": can't unregister built-in node type.");
+        }
-	/**
-	 * todo check if this node type (or any node type that has dependencies
-	 * on this node type) is currently referenced by nodes in the repository.
-	 *
-	 * this is absolutely necessary in order to guarantee integrity of
-	 * repository content.
-	 *
-	 * throw exception until this is can be done (using search)
-	 */
-	boolean isReferenced = true;
-	if (isReferenced) {
-	    throw new RepositoryException("not yet implemented");
-	}
+        /**
+         * todo check if this node type (or any node type that has dependencies
+         * on this node type) is currently referenced by nodes in the repository.
+         *
+         * this is absolutely necessary in order to guarantee integrity of
+         * repository content.
+         *
+         * throw exception until this is can be done (using search)
+         */
+        boolean isReferenced = true;
+        if (isReferenced) {
+            throw new RepositoryException("not yet implemented");
+        }
-	NodeTypeDef ntd = (NodeTypeDef) registeredNTDefs.get(name);
-	registeredNTDefs.remove(name);
-	// remove effective node type from aggregates cache
-	entCache.remove(new QName[]{name});
+        NodeTypeDef ntd = (NodeTypeDef) registeredNTDefs.get(name);
+        registeredNTDefs.remove(name);
+        // remove effective node type from aggregates cache
+        entCache.remove(new QName[]{name});
-	// remove poperty & child node definitions
-	PropDef[] pda = ntd.getPropertyDefs();
-	for (int i = 0; i < pda.length; i++) {
-	    PropDefId id = new PropDefId(pda[i]);
-	    propDefs.remove(id);
-	}
-	ChildNodeDef[] nda = ntd.getChildNodeDefs();
-	for (int i = 0; i < nda.length; i++) {
-	    NodeDefId id = new NodeDefId(nda[i]);
-	    nodeDefs.remove(id);
-	}
+        // remove poperty & child node definitions
+        PropDef[] pda = ntd.getPropertyDefs();
+        for (int i = 0; i < pda.length; i++) {
+            PropDefId id = new PropDefId(pda[i]);
+            propDefs.remove(id);
+        }
+        ChildNodeDef[] nda = ntd.getChildNodeDefs();
+        for (int i = 0; i < nda.length; i++) {
+            NodeDefId id = new NodeDefId(nda[i]);
+            nodeDefs.remove(id);
+        }
-	// persist removal of node type definition
-	customNTDefs.remove(name);
-	try {
-	    customNTDefs.store(customNodeTypesResource.getOutputStream(), nsReg);
-	} catch (IOException ioe) {
-	    String error = "internal error: failed to write custom node type definition to " + customNodeTypesResource.getPath();
-	    log.error(error, ioe);
-	    throw new RepositoryException(error, ioe);
-	} catch (FileSystemException fse) {
-	    String error = "internal error: failed to write custom node type definition to " + customNodeTypesResource.getPath();
-	    log.error(error, fse);
-	    throw new RepositoryException(error, fse);
-	}
+        // persist removal of node type definition
+        customNTDefs.remove(name);
+        try {
+            customNTDefs.store(customNodeTypesResource.getOutputStream(), nsReg);
+        } catch (IOException ioe) {
+            String error = "internal error: failed to write custom node type definition to " + customNodeTypesResource.getPath();
+            log.error(error, ioe);
+            throw new RepositoryException(error, ioe);
+        } catch (FileSystemException fse) {
+            String error = "internal error: failed to write custom node type definition to " + customNodeTypesResource.getPath();
+            log.error(error, fse);
+            throw new RepositoryException(error, fse);
+        }
-	// @todo remove also any node types & aggregates which have dependencies on this node type
+        // @todo remove also any node types & aggregates which have dependencies on this node type
-	// notify listeners
-	notifyUnregistered(name);
+        // notify listeners
+        notifyUnregistered(name);
-	    throws NoSuchNodeTypeException, InvalidNodeTypeDefException,
-	    RepositoryException {
-	QName name = ntd.getName();
-	if (!registeredNTDefs.containsKey(name)) {
-	    throw new NoSuchNodeTypeException(name.toString());
-	}
-	if (builtInNTDefs.contains(name)) {
-	    throw new RepositoryException(name.toString() + ": can't reregister built-in node type.");
-	}
+            throws NoSuchNodeTypeException, InvalidNodeTypeDefException,
+            RepositoryException {
+        QName name = ntd.getName();
+        if (!registeredNTDefs.containsKey(name)) {
+            throw new NoSuchNodeTypeException(name.toString());
+        }
+        if (builtInNTDefs.contains(name)) {
+            throw new RepositoryException(name.toString() + ": can't reregister built-in node type.");
+        }
-	/**
-	 * todo
-	 * - check if this node type (or any node type that has dependencies
-	 *   on this node type) is currently referenced by any nodes;
-	 *   this is absolutely necessary in order to guarantee integrity of
-	 *   repository content
-	 * - validate new node type definition
-	 * - build diff of old & new node type definition
-	 * - check if applying changes to affected nodes would violate existing node type constraints
-	 * - re-register node type definition and update caches
-	 * - notify listeners on re-registration
-	 * - apply and persist changes to affected nodes
-	 * - what else?
-	 */
-	/*unregisterNodeType(name);
-	return registerNodeType(ntd);*/
-	throw new RepositoryException("not yet implemented");
+        /**
+         * todo
+         * - check if this node type (or any node type that has dependencies
+         *   on this node type) is currently referenced by any nodes;
+         *   this is absolutely necessary in order to guarantee integrity of
+         *   repository content
+         * - validate new node type definition
+         * - build diff of old & new node type definition
+         * - check if applying changes to affected nodes would violate existing node type constraints
+         * - re-register node type definition and update caches
+         * - notify listeners on re-registration
+         * - apply and persist changes to affected nodes
+         * - what else?
+         */
+        /*unregisterNodeType(name);
+        return registerNodeType(ntd);*/
+        throw new RepositoryException("not yet implemented");
-	if (!registeredNTDefs.containsKey(nodeTypeName)) {
-	    throw new NoSuchNodeTypeException(nodeTypeName.toString());
-	}
-	NodeTypeDef def = (NodeTypeDef) registeredNTDefs.get(nodeTypeName);
-	// return clone to make sure nobody messes around with the 'real' definition
-	try {
-	    return (NodeTypeDef) def.clone();
-	} catch (CloneNotSupportedException e) {
-	    // should never get here
-	    log.fatal("internal error", e);
-	    throw new InternalError(e.getMessage());
-	}
+        if (!registeredNTDefs.containsKey(nodeTypeName)) {
+            throw new NoSuchNodeTypeException(nodeTypeName.toString());
+        }
+        NodeTypeDef def = (NodeTypeDef) registeredNTDefs.get(nodeTypeName);
+        // return clone to make sure nobody messes around with the 'real' definition
+        try {
+            return (NodeTypeDef) def.clone();
+        } catch (CloneNotSupportedException e) {
+            // should never get here
+            log.fatal("internal error", e);
+            throw new InternalError(e.getMessage());
+        }
-	return registeredNTDefs.containsKey(nodeTypeName);
+        return registeredNTDefs.containsKey(nodeTypeName);
-	ChildNodeDef def = (ChildNodeDef) nodeDefs.get(id);
-	if (def == null) {
-	    return null;
-	}
-	// return clone to make sure nobody messes around with the 'real' definition
-	try {
-	    return (ChildNodeDef) def.clone();
-	} catch (CloneNotSupportedException e) {
-	    // should never get here
-	    log.fatal("internal error", e);
-	    throw new InternalError(e.getMessage());
-	}
+        ChildNodeDef def = (ChildNodeDef) nodeDefs.get(id);
+        if (def == null) {
+            return null;
+        }
+        // return clone to make sure nobody messes around with the 'real' definition
+        try {
+            return (ChildNodeDef) def.clone();
+        } catch (CloneNotSupportedException e) {
+            // should never get here
+            log.fatal("internal error", e);
+            throw new InternalError(e.getMessage());
+        }
-	PropDef def = (PropDef) propDefs.get(id);
-	if (def == null) {
-	    return null;
-	}
-	// return clone to make sure nobody messes around with the 'real' definition
-	try {
-	    return (PropDef) def.clone();
-	} catch (CloneNotSupportedException e) {
-	    // should never get here
-	    log.fatal("internal error", e);
-	    throw new InternalError(e.getMessage());
-	}
+        PropDef def = (PropDef) propDefs.get(id);
+        if (def == null) {
+            return null;
+        }
+        // return clone to make sure nobody messes around with the 'real' definition
+        try {
+            return (PropDef) def.clone();
+        } catch (CloneNotSupportedException e) {
+            // should never get here
+            log.fatal("internal error", e);
+            throw new InternalError(e.getMessage());
+        }
-	ps.println("NodeTypeManager (" + this + ")");
-	ps.println();
-	ps.println("Registered NodeTypes:");
-	ps.println();
-	Iterator iter = registeredNTDefs.values().iterator();
-	while (iter.hasNext()) {
-	    NodeTypeDef ntd = (NodeTypeDef) iter.next();
-	    ps.println(ntd.getName());
-	    QName[] supertypes = ntd.getSupertypes();
-	    ps.println("\tSupertypes");
-	    for (int i = 0; i < supertypes.length; i++) {
-		ps.println("\t\t" + supertypes[i]);
-	    }
-	    ps.println("\tMixin\t" + ntd.isMixin());
-	    ps.println("\tOrderableChildNodes\t" + ntd.hasOrderableChildNodes());
-	    PropDef[] pd = ntd.getPropertyDefs();
-	    for (int i = 0; i < pd.length; i++) {
-		ps.print("\tPropertyDef");
-		ps.println(" (declared in " + pd[i].getDeclaringNodeType() + ") id=" + new PropDefId(pd[i]));
-		ps.println("\t\tName\t\t" + (pd[i].definesResidual() ? "*" : pd[i].getName().toString()));
-		String type = pd[i].getRequiredType() == 0 ? "null" : PropertyType.nameFromValue(pd[i].getRequiredType());
-		ps.println("\t\tRequiredType\t" + type);
-		ValueConstraint[] vca = pd[i].getValueConstraints();
-		StringBuffer constraints = new StringBuffer();
-		if (vca == null) {
-		    constraints.append("<null>");
-		} else {
-		    for (int n = 0; n < vca.length; n++) {
-			if (constraints.length() > 0) {
-			    constraints.append(", ");
-			}
-			constraints.append(vca[n].getDefinition());
-		    }
-		}
-		ps.println("\t\tValueConstraints\t" + constraints.toString());
-		InternalValue[] defVals = pd[i].getDefaultValues();
-		StringBuffer defaultValues = new StringBuffer();
-		if (defVals == null) {
-		    defaultValues.append("<null>");
-		} else {
-		    for (int n = 0; n < defVals.length; n++) {
-			if (defaultValues.length() > 0) {
-			    defaultValues.append(", ");
-			}
-			defaultValues.append(defVals[n].toString());
-		    }
-		}
-		ps.println("\t\tDefaultValue\t" + defaultValues.toString());
-		ps.println("\t\tAutoCreate\t" + pd[i].isAutoCreate());
-		ps.println("\t\tMandatory\t" + pd[i].isMandatory());
-		ps.println("\t\tOnVersion\t" + OnParentVersionAction.nameFromValue(pd[i].getOnParentVersion()));
-		ps.println("\t\tProtected\t" + pd[i].isProtected());
-		ps.println("\t\tPrimaryItem\t" + pd[i].isPrimaryItem());
-		ps.println("\t\tMultiple\t" + pd[i].isMultiple());
-	    }
-	    ChildNodeDef[] nd = ntd.getChildNodeDefs();
-	    for (int i = 0; i < nd.length; i++) {
-		ps.print("\tNodeDef");
-		ps.println(" (declared in " + nd[i].getDeclaringNodeType() + ") id=" + new NodeDefId(nd[i]));
-		ps.println("\t\tName\t\t" + (nd[i].definesResidual() ? "*" : nd[i].getName().toString()));
-		QName[] reqPrimaryTypes = nd[i].getRequiredPrimaryTypes();
-		if (reqPrimaryTypes != null && reqPrimaryTypes.length > 0) {
-		    for (int n = 0; n < reqPrimaryTypes.length; n++) {
-			ps.print("\t\tRequiredPrimaryType\t" + reqPrimaryTypes[n]);
-		    }
-		}
-		QName defPrimaryType = nd[i].getDefaultPrimaryType();
-		if (defPrimaryType != null) {
-		    ps.print("\n\t\tDefaultPrimaryType\t" + defPrimaryType);
-		}
-		ps.println("\n\t\tAutoCreate\t" + nd[i].isAutoCreate());
-		ps.println("\t\tMandatory\t" + nd[i].isMandatory());
-		ps.println("\t\tOnVersion\t" + OnParentVersionAction.nameFromValue(nd[i].getOnParentVersion()));
-		ps.println("\t\tProtected\t" + nd[i].isProtected());
-		ps.println("\t\tPrimaryItem\t" + nd[i].isPrimaryItem());
-		ps.println("\t\tAllowSameNameSibs\t" + nd[i].allowSameNameSibs());
-	    }
-	}
-	ps.println();
+        ps.println("NodeTypeManager (" + this + ")");
+        ps.println();
+        ps.println("Registered NodeTypes:");
+        ps.println();
+        Iterator iter = registeredNTDefs.values().iterator();
+        while (iter.hasNext()) {
+            NodeTypeDef ntd = (NodeTypeDef) iter.next();
+            ps.println(ntd.getName());
+            QName[] supertypes = ntd.getSupertypes();
+            ps.println("\tSupertypes");
+            for (int i = 0; i < supertypes.length; i++) {
+                ps.println("\t\t" + supertypes[i]);
+            }
+            ps.println("\tMixin\t" + ntd.isMixin());
+            ps.println("\tOrderableChildNodes\t" + ntd.hasOrderableChildNodes());
+            PropDef[] pd = ntd.getPropertyDefs();
+            for (int i = 0; i < pd.length; i++) {
+                ps.print("\tPropertyDef");
+                ps.println(" (declared in " + pd[i].getDeclaringNodeType() + ") id=" + new PropDefId(pd[i]));
+                ps.println("\t\tName\t\t" + (pd[i].definesResidual() ? "*" : pd[i].getName().toString()));
+                String type = pd[i].getRequiredType() == 0 ? "null" : PropertyType.nameFromValue(pd[i].getRequiredType());
+                ps.println("\t\tRequiredType\t" + type);
+                ValueConstraint[] vca = pd[i].getValueConstraints();
+                StringBuffer constraints = new StringBuffer();
+                if (vca == null) {
+                    constraints.append("<null>");
+                } else {
+                    for (int n = 0; n < vca.length; n++) {
+                        if (constraints.length() > 0) {
+                            constraints.append(", ");
+                        }
+                        constraints.append(vca[n].getDefinition());
+                    }
+                }
+                ps.println("\t\tValueConstraints\t" + constraints.toString());
+                InternalValue[] defVals = pd[i].getDefaultValues();
+                StringBuffer defaultValues = new StringBuffer();
+                if (defVals == null) {
+                    defaultValues.append("<null>");
+                } else {
+                    for (int n = 0; n < defVals.length; n++) {
+                        if (defaultValues.length() > 0) {
+                            defaultValues.append(", ");
+                        }
+                        defaultValues.append(defVals[n].toString());
+                    }
+                }
+                ps.println("\t\tDefaultValue\t" + defaultValues.toString());
+                ps.println("\t\tAutoCreate\t" + pd[i].isAutoCreate());
+                ps.println("\t\tMandatory\t" + pd[i].isMandatory());
+                ps.println("\t\tOnVersion\t" + OnParentVersionAction.nameFromValue(pd[i].getOnParentVersion()));
+                ps.println("\t\tProtected\t" + pd[i].isProtected());
+                ps.println("\t\tPrimaryItem\t" + pd[i].isPrimaryItem());
+                ps.println("\t\tMultiple\t" + pd[i].isMultiple());
+            }
+            ChildNodeDef[] nd = ntd.getChildNodeDefs();
+            for (int i = 0; i < nd.length; i++) {
+                ps.print("\tNodeDef");
+                ps.println(" (declared in " + nd[i].getDeclaringNodeType() + ") id=" + new NodeDefId(nd[i]));
+                ps.println("\t\tName\t\t" + (nd[i].definesResidual() ? "*" : nd[i].getName().toString()));
+                QName[] reqPrimaryTypes = nd[i].getRequiredPrimaryTypes();
+                if (reqPrimaryTypes != null && reqPrimaryTypes.length > 0) {
+                    for (int n = 0; n < reqPrimaryTypes.length; n++) {
+                        ps.print("\t\tRequiredPrimaryType\t" + reqPrimaryTypes[n]);
+                    }
+                }
+                QName defPrimaryType = nd[i].getDefaultPrimaryType();
+                if (defPrimaryType != null) {
+                    ps.print("\n\t\tDefaultPrimaryType\t" + defPrimaryType);
+                }
+                ps.println("\n\t\tAutoCreate\t" + nd[i].isAutoCreate());
+                ps.println("\t\tMandatory\t" + nd[i].isMandatory());
+                ps.println("\t\tOnVersion\t" + OnParentVersionAction.nameFromValue(nd[i].getOnParentVersion()));
+                ps.println("\t\tProtected\t" + nd[i].isProtected());
+                ps.println("\t\tPrimaryItem\t" + nd[i].isPrimaryItem());
+                ps.println("\t\tAllowSameNameSibs\t" + nd[i].allowSameNameSibs());
+            }
+        }
+        ps.println();
-	entCache.dump(ps);
+        entCache.dump(ps);
-     *
-     * @author Stefan Guggisberg
-	/**
-	 * set of node type names, sorted in ascending order
-	 */
-	private final TreeSet set;
-	private final int weight;
+        /**
+         * set of node type names, sorted in ascending order
+         */
+        private final TreeSet set;
+        private final int weight;
-	/**
-	 * @param ntNames
-	 */
-	WeightedKey(QName[] ntNames) {
-	    this(ntNames, ntNames.length);
-	}
+        /**
+         * @param ntNames
+         */
+        WeightedKey(QName[] ntNames) {
+            this(ntNames, ntNames.length);
+        }
-	/**
-	 * @param ntNames
-	 * @param weight
-	 */
-	WeightedKey(QName[] ntNames, int weight) {
-	    this.weight = weight;
+        /**
+         * @param ntNames
+         * @param weight
+         */
+        WeightedKey(QName[] ntNames, int weight) {
+            this.weight = weight;
-	    set = new TreeSet();
-	    for (int i = 0; i < ntNames.length; i++) {
-		// add name to this sorted set
-		set.add(ntNames[i]);
-	    }
-	}
+            set = new TreeSet();
+            for (int i = 0; i < ntNames.length; i++) {
+                // add name to this sorted set
+                set.add(ntNames[i]);
+            }
+        }
-	/**
-	 * @param ntNames
-	 */
-	WeightedKey(Collection ntNames) {
-	    this(ntNames, ntNames.size());
-	}
+        /**
+         * @param ntNames
+         */
+        WeightedKey(Collection ntNames) {
+            this(ntNames, ntNames.size());
+        }
-	/**
-	 * @param ntNames
-	 * @param weight
-	 */
-	WeightedKey(Collection ntNames, int weight) {
-	    this.weight = weight;
-	    set = new TreeSet(ntNames);
-	}
+        /**
+         * @param ntNames
+         * @param weight
+         */
+        WeightedKey(Collection ntNames, int weight) {
+            this.weight = weight;
+            set = new TreeSet(ntNames);
+        }
-	/**
-	 * The key is the string representation of this sorted set
-	 * (e.g. the key for a set containing entries "c", "b" and "a" would
-	 * be "[a, b, c]").
-	 *
-	 * @return string representation of this sorted set
-	 * @see AbstractCollection#toString
-	 */
-	String getKey() {
-	    return set.toString();
-	}
+        /**
+         * The key is the string representation of this sorted set
+         * (e.g. the key for a set containing entries "c", "b" and "a" would
+         * be "[a, b, c]").
+         *
+         * @return string representation of this sorted set
+         * @see AbstractCollection#toString
+         */
+        String getKey() {
+            return set.toString();
+        }
-	/**
-	 * @return
-	 */
-	int getWeight() {
-	    return weight;
-	}
+        /**
+         * @return
+         */
+        int getWeight() {
+            return weight;
+        }
-	int size() {
-	    return set.size();
-	}
+        int size() {
+            return set.size();
+        }
-	Iterator iterator() {
-	    return Collections.unmodifiableSortedSet(set).iterator();
-	}
+        Iterator iterator() {
+            return Collections.unmodifiableSortedSet(set).iterator();
+        }
-	Set getSet() {
-	    return Collections.unmodifiableSortedSet(set);
-	}
+        Set getSet() {
+            return Collections.unmodifiableSortedSet(set);
+        }
-	QName[] toArray() {
-	    return (QName[]) set.toArray(new QName[set.size()]);
-	}
+        QName[] toArray() {
+            return (QName[]) set.toArray(new QName[set.size()]);
+        }
-	boolean contains(WeightedKey otherKey) {
-	    return set.containsAll(otherKey.getSet());
-	}
+        boolean contains(WeightedKey otherKey) {
+            return set.containsAll(otherKey.getSet());
+        }
-	WeightedKey subtract(WeightedKey otherKey) {
-	    Set tmp = (Set) set.clone();
-	    tmp.removeAll(otherKey.getSet());
-	    return new WeightedKey(tmp);
+        WeightedKey subtract(WeightedKey otherKey) {
+            Set tmp = (Set) set.clone();
+            tmp.removeAll(otherKey.getSet());
+            return new WeightedKey(tmp);
-	}
+        }
-	/**
-	 * The resulting sort-order is: 1. descending weight, 2. ascending key
-	 * (i.e. string representation of this sorted set).
-	 *
-	 * @param o
-	 * @return
-	 */
-	public int compareTo(Object o) {
-	    WeightedKey other = (WeightedKey) o;
-	    if (getWeight() > other.getWeight()) {
-		return -1;
-	    } else if (getWeight() < other.getWeight()) {
-		return 1;
-	    }
-	    return getKey().compareTo(other.getKey());
-	}
+        /**
+         * The resulting sort-order is: 1. descending weight, 2. ascending key
+         * (i.e. string representation of this sorted set).
+         *
+         * @param o
+         * @return
+         */
+        public int compareTo(Object o) {
+            WeightedKey other = (WeightedKey) o;
+            if (getWeight() > other.getWeight()) {
+                return -1;
+            } else if (getWeight() < other.getWeight()) {
+                return 1;
+            }
+            return getKey().compareTo(other.getKey());
+        }
-	public int hashCode() {
-	    // ignore weight
-	    return set.hashCode();
-	}
+        public int hashCode() {
+            // ignore weight
+            return set.hashCode();
+        }
-	public boolean equals(Object obj) {
-	    if (this == obj) {
-		return true;
-	    }
-	    if (obj instanceof WeightedKey) {
-		WeightedKey other = (WeightedKey) obj;
-		// ignore weight
-		return set.equals(other.set);
-	    }
-	    return false;
-	}
+        public boolean equals(Object obj) {
+            if (this == obj) {
+                return true;
+            }
+            if (obj instanceof WeightedKey) {
+                WeightedKey other = (WeightedKey) obj;
+                // ignore weight
+                return set.equals(other.set);
+            }
+            return false;
+        }
-	public String toString() {
-	    return set.toString() + " (" + weight + ")";
-	}
+        public String toString() {
+            return set.toString() + " (" + weight + ")";
+        }
-	// ordered set of keys
-	final TreeSet sortedKeys;
-	// cache of pre-build aggregations of node types
-	final HashMap aggregates;
+        // ordered set of keys
+        final TreeSet sortedKeys;
+        // cache of pre-build aggregations of node types
+        final HashMap aggregates;
-	EffectiveNodeTypeCache() {
-	    sortedKeys = new TreeSet();
-	    aggregates = new HashMap();
-	}
+        EffectiveNodeTypeCache() {
+            sortedKeys = new TreeSet();
+            aggregates = new HashMap();
+        }
-	void put(EffectiveNodeType ent) {
-	    // we define the weight as the total number of included node types
-	    // (through aggregation and inheritance)
-	    int weight = ent.getAllNodeTypes().length;
-	    // the effective node type is identified by the list of merged
-	    // (i.e. aggregated) node types
-	    WeightedKey k = new WeightedKey(ent.getMergedNodeTypes(), weight);
-	    aggregates.put(k, ent);
-	    sortedKeys.add(k);
-	}
+        void put(EffectiveNodeType ent) {
+            // we define the weight as the total number of included node types
+            // (through aggregation and inheritance)
+            int weight = ent.getAllNodeTypes().length;
+            // the effective node type is identified by the list of merged
+            // (i.e. aggregated) node types
+            WeightedKey k = new WeightedKey(ent.getMergedNodeTypes(), weight);
+            aggregates.put(k, ent);
+            sortedKeys.add(k);
+        }
-	boolean contains(QName[] ntNames) {
-	    return aggregates.containsKey(new WeightedKey(ntNames));
-	}
+        boolean contains(QName[] ntNames) {
+            return aggregates.containsKey(new WeightedKey(ntNames));
+        }
-	boolean contains(WeightedKey key) {
-	    return aggregates.containsKey(key);
-	}
+        boolean contains(WeightedKey key) {
+            return aggregates.containsKey(key);
+        }
-	EffectiveNodeType get(QName[] ntNames) {
-	    return (EffectiveNodeType) aggregates.get(new WeightedKey(ntNames));
-	}
+        EffectiveNodeType get(QName[] ntNames) {
+            return (EffectiveNodeType) aggregates.get(new WeightedKey(ntNames));
+        }
-	EffectiveNodeType get(WeightedKey key) {
-	    return (EffectiveNodeType) aggregates.get(key);
-	}
+        EffectiveNodeType get(WeightedKey key) {
+            return (EffectiveNodeType) aggregates.get(key);
+        }
-	EffectiveNodeType remove(QName[] ntNames) {
-	    return remove(new WeightedKey(ntNames));
-	}
+        EffectiveNodeType remove(QName[] ntNames) {
+            return remove(new WeightedKey(ntNames));
+        }
-	EffectiveNodeType remove(WeightedKey key) {
-	    EffectiveNodeType removed = (EffectiveNodeType) aggregates.remove(key);
-	    if (removed != null) {
-		// remove index entry
+        EffectiveNodeType remove(WeightedKey key) {
+            EffectiveNodeType removed = (EffectiveNodeType) aggregates.remove(key);
+            if (removed != null) {
+                // remove index entry
-		// FIXME: can't simply call TreeSet.remove(key) because the entry
-		// in sortedKeys might have a different weight and would thus
-		// not be found
-		Iterator iter = sortedKeys.iterator();
-		while (iter.hasNext()) {
-		    WeightedKey k = (WeightedKey) iter.next();
-		    // WeightedKey.equals(Object) ignores the weight
-		    if (key.equals(k)) {
-			sortedKeys.remove(k);
-			break;
-		    }
-		}
-	    }
-	    return removed;
-	}
+                // FIXME: can't simply call TreeSet.remove(key) because the entry
+                // in sortedKeys might have a different weight and would thus
+                // not be found
+                Iterator iter = sortedKeys.iterator();
+                while (iter.hasNext()) {
+                    WeightedKey k = (WeightedKey) iter.next();
+                    // WeightedKey.equals(Object) ignores the weight
+                    if (key.equals(k)) {
+                        sortedKeys.remove(k);
+                        break;
+                    }
+                }
+            }
+            return removed;
+        }
-	/**
-	 * Returns an iterator over the keys. The order of the returned keys is:
-	 * <ul>
-	 * <li>1. descending weight</li>
-	 * <li>2. ascending key (i.e. unique identifier of aggregate)</li>
-	 * </ul>
-	 *
-	 * @see NodeTypeRegistry.WeightedKey#compareTo
-	 */
-	Iterator keys() {
-	    return sortedKeys.iterator();
-	}
+        /**
+         * Returns an iterator over the keys. The order of the returned keys is:
+         * <ul>
+         * <li>1. descending weight</li>
+         * <li>2. ascending key (i.e. unique identifier of aggregate)</li>
+         * </ul>
+         *
+         * @see NodeTypeRegistry.WeightedKey#compareTo
+         */
+        Iterator keys() {
+            return sortedKeys.iterator();
+        }
-	//------------------------------------------------------< diagnostics >
-	/**
-	 * Dumps the state of this <code>EffectiveNodeTypeCache</code> instance.
-	 *
-	 * @param ps
-	 * @throws RepositoryException
-	 */
-	void dump(PrintStream ps) throws RepositoryException {
-	    ps.println("EffectiveNodeTypeCache (" + this + ")");
-	    ps.println();
-	    ps.println("EffectiveNodeTypes in cache:");
-	    ps.println();
-	    Iterator iter = sortedKeys.iterator();
-	    while (iter.hasNext()) {
-		WeightedKey k = (WeightedKey) iter.next();
-		//EffectiveNodeType ent = (EffectiveNodeType) aggregates.get(k);
-		ps.println(k);
-	    }
-	}
+        //------------------------------------------------------< diagnostics >
+        /**
+         * Dumps the state of this <code>EffectiveNodeTypeCache</code> instance.
+         *
+         * @param ps
+         * @throws RepositoryException
+         */
+        void dump(PrintStream ps) throws RepositoryException {
+            ps.println("EffectiveNodeTypeCache (" + this + ")");
+            ps.println();
+            ps.println("EffectiveNodeTypes in cache:");
+            ps.println();
+            Iterator iter = sortedKeys.iterator();
+            while (iter.hasNext()) {
+                WeightedKey k = (WeightedKey) iter.next();
+                //EffectiveNodeType ent = (EffectiveNodeType) aggregates.get(k);
+                ps.println(k);
+            }
+        }

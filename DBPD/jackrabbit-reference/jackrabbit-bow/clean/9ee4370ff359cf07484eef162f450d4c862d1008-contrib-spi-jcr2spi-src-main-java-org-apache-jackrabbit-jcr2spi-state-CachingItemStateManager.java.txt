SPI
- replace ChildNodeEntryImpl with new implementations
- CachingItemStateManager now uses ItemStateFactory
- WorkspaceManager implements ItemStateFactory
- Retrieving an ItemState now forces loading all ancestors by design
- NodeState does not maintain indexes of child node entries anymore. They are calculated on demand.
- ItemStateFactory methods do not require parent NodeState anymore. The parent NodeState is retrieved using an ItemStateManager. Which in turn may lead to recursive retrieval of ancestors if necessary.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@426536 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.IdFactory;
+import org.apache.jackrabbit.spi.PropertyId;
-     * The underlying item state manager.
+     * The item state factory to create <code>ItemState</code>s that are not
+     * present in the cache.
-    private final ItemStateManager ism;
+    private final ItemStateFactory isf;
-    public CachingItemStateManager(ItemStateManager ism) {
-        this.ism = ism;
+    /**
+     * The Id factory.
+     */
+    private final IdFactory idFactory;
+
+    public CachingItemStateManager(ItemStateFactory isf, IdFactory idFactory) {
+        this.isf = isf;
+        this.idFactory = idFactory;
-        // TODO: caching missing
-        return ism.getNodeReferences(id);
+        // TODO: implement
+        return null;
-        // TODO: caching missing
-        return ism.hasNodeReferences(id);
+        // TODO: caching implement
+        return false;
-                ItemId refId = (relPath == null) ? id : new NodeIdImpl(uuid);
-                ItemState state = ism.getItemState(refId);
+                NodeId refId = (relPath == null) ? (NodeId) id : idFactory.createNodeId(uuid);
+                NodeState state = isf.createNodeState(refId, this);
-                // not yet cached, load from ism
-                ItemState state = ism.getItemState(id);
+                // not yet cached, load from isf
+                ItemState state;
+                if (id.denotesNode()) {
+                    state = isf.createNodeState((NodeId) id, this);
+                } else {
+                    state = isf.createPropertyState((PropertyId) id, this);
+                }
-
-    //--------------------------------------------------------< Inner class >---
-    /**
-     * Simple implementation of the NodeId interface that always wraps around a
-     * UUID String only and never takes a relative path.
-     * Since the uuid is retrieved from an existing <code>ItemId</code> there is
-     * no need to pass the IdFactory and using this simple implementation instead.
-     */
-    private static final class NodeIdImpl implements NodeId {
-
-        private final String uuid;
-
-        public NodeIdImpl(String uuid) {
-            if (uuid == null) {
-                throw new IllegalArgumentException("Expected non-null uuid.");
-            }
-            this.uuid = uuid;
-        }
-
-        /**
-         * Always return <code>true</code>.
-         *
-         * @return true
-         */
-        public boolean denotesNode() {
-            return true;
-        }
-
-        /**
-         * Always returns a non-null string.
-         *
-         * @return uuid passed to the constructor, which is never <code>null</code>.
-         */
-        public String getUUID() {
-            return uuid;
-        }
-
-        /**
-         * Always return <code>null</code>.
-         *
-         * @return <code>null</code>
-         */
-        public Path getRelativePath() {
-            return null;
-        }
-    }

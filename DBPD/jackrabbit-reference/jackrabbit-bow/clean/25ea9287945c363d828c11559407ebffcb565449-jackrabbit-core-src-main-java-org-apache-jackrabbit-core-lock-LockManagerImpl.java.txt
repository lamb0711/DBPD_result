JCR-2183 - Provide overridables for lock checking
- Add public LockInfo class
- Make AbstractLockInfo package private
- Rename internal LockInfo classes to avoid confusion
- Add overridable in LockManagerImpl with default implementation

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@790892 13f79535-47bb-0310-9956-ffa450edef68

-            LockInfo info = new LockInfo(lockToken, false,
+            InternalLockInfo info = new InternalLockInfo(lockToken, false,
-        final ArrayList<LockInfo> list = new ArrayList<LockInfo>();
+        final ArrayList<AbstractLockInfo> list = new ArrayList<AbstractLockInfo>();
-                LockInfo info = (LockInfo) element.get();
-                if (!info.sessionScoped) {
+            	AbstractLockInfo info = (AbstractLockInfo) element.get();
+                if (!info.isSessionScoped()) {
-                AbstractLockInfo info = list.get(i);
-                writer.write(info.lockToken.toString());
+            	AbstractLockInfo info = list.get(i);
+                writer.write(info.getLockToken());
-        LockInfo info = new LockInfo(new LockToken(node.getNodeId()),
+        InternalLockInfo info = new InternalLockInfo(new LockToken(node.getNodeId()),
-                } else if (other.deep) {
+                } else if (other.isDeep()) {
-                getSessionLockManager(session).lockTokenAdded(info.lockToken.toString());
+                getSessionLockManager(session).lockTokenAdded(info.getLockToken());
-            if (!info.sessionScoped) {
+            if (!info.isSessionScoped()) {
-            if (session != info.getLockHolder()) {
-                throw new LockException("Node not locked by session: " + node);
-            }
+            checkUnlock(info, session);
-            if (!info.sessionScoped) {
+            if (!info.isSessionScoped()) {
-                if (info.isLive() && info.getLockHolder().equals(session)) {
+                if (info.isLive() && info.isLockHolder(session)) {
-                if (element.hasPath(path) || info.deep) {
+                if (element.hasPath(path) || info.isDeep()) {
-    public boolean isLockHolder(Session session, NodeImpl node)
-            throws RepositoryException {
-        acquire();
-
-        try {
-            SessionImpl nodeSession = (SessionImpl) node.getSession();
-            PathMap.Element element = lockMap.map(getPath(nodeSession, node.getId()), true);
-            if (element == null) {
-                return false;
-            }
-            AbstractLockInfo info = (AbstractLockInfo) element.get();
-            return info != null && info.getLockHolder() == session;
-        } catch (ItemNotFoundException e) {
-            return false;
-        } finally {
-            release();
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-        AbstractLockInfo info = (AbstractLockInfo) element.get();
+        LockInfo info = (LockInfo) element.get();
-            if (element.hasPath(path) || info.deep) {
-                if (session != info.getLockHolder()) {
-                    throw new LockException("Node locked.");
-                }
+            if (element.hasPath(path) || info.isDeep()) {
+            	checkLock(info, session);
+     * Check whether a lock info allows access to a session. May be overridden
+     * by subclasses to allow access to nodes for sessions other than the
+     * lock holder itself.
+     * <p/>
+     * Default implementation allows access to the lock holder only.
+     * 
+     * @param info info to check
+     * @param session session
+     * @throws LockException if write access to the specified path is not allowed
+     * @throws RepositoryException if some other error occurs
+     */
+    protected void checkLock(LockInfo info, Session session) 
+    		throws LockException, RepositoryException {
+    	
+    	if (!info.isLockHolder(session)) {
+            throw new LockException("Node locked.");
+        }
+    }
+
+    /**
-    public void lockTokenAdded(SessionImpl session, String lt) throws LockException, RepositoryException {
+    public void checkUnlock(Session session, NodeImpl node)
+    		throws LockException, RepositoryException {
+
+	    // check whether node is locked by this session
+	    PathMap.Element element = lockMap.map(
+	    		getPath((SessionImpl) session, node.getId()), true);
+	    if (element == null) {
+	        throw new LockException("Node not locked: " + node);
+	    }
+	    AbstractLockInfo info = (AbstractLockInfo) element.get();
+	    if (info == null) {
+	        throw new LockException("Node not locked: " + node);
+	    }
+	    checkUnlock(info, session);
+    }
+
+    /**
+     * Check whether a session is allowed to unlock a node. May be overridden
+     * by subclasses to allow this to sessions other than the lock holder
+     * itself.
+     * <p/>
+     * Default implementation allows unlocking to the lock holder only.
+     * 
+     * @param info info to check
+     * @param session session
+     * @throws LockException if unlocking is denied
+     * @throws RepositoryException if some other error occurs
+     */
+    protected void checkUnlock(LockInfo info, Session session)
+    		throws LockException, RepositoryException {
+    	
+	    if (!info.isLockHolder(session)) {
+	        throw new LockException("Node not locked by session: " + info.getId());
+	    }
+    }
+    
+    /**
+     * {@inheritDoc}
+     */
+    public void addLockToken(SessionImpl session, String lt) throws LockException, RepositoryException {
-                    if (info.getLockHolder() == null) {
+                	if (info.isLockHolder(session)) {
+                		// nothing to do
+                	} else if (info.getLockHolder() == null) {
-                        if (info instanceof LockInfo) {
-                            session.addListener((LockInfo) info);
+                        if (info instanceof InternalLockInfo) {
+                            session.addListener((InternalLockInfo) info);
-    public void lockTokenRemoved(SessionImpl session, String lt) throws LockException, RepositoryException {
+    public void removeLockToken(SessionImpl session, String lt) 
+    		throws LockException, RepositoryException {
+    	
-                    if (session == info.getLockHolder()) {
+                	if (info.isLockHolder(session)) {
+                	} else if (info.getLockHolder() == null) {
+                		// nothing to do
-        final ArrayList<LockInfo> infos = new ArrayList<LockInfo>();
+        final ArrayList<AbstractLockInfo> infos = new ArrayList<AbstractLockInfo>();
-                LockInfo info = (LockInfo) element.get();
+            	AbstractLockInfo info = (AbstractLockInfo) element.get();
-            LockInfo info = infos.get(i);
+        	AbstractLockInfo info = infos.get(i);
-                if (!info.sessionScoped) {
+                if (!info.isSessionScoped()) {
-    class LockInfo extends AbstractLockInfo implements SessionListener {
+    class InternalLockInfo extends AbstractLockInfo implements SessionListener {
-        public LockInfo(LockToken lockToken, boolean sessionScoped,
-                        boolean deep, String lockOwner) {
+        public InternalLockInfo(LockToken lockToken, boolean sessionScoped,
+                                boolean deep, String lockOwner) {
-        public LockInfo(LockToken lockToken, boolean sessionScoped,
-                        boolean deep, String lockOwner, long timeoutHint) {
+        public InternalLockInfo(LockToken lockToken, boolean sessionScoped,
+                                boolean deep, String lockOwner, long timeoutHint) {
-
+        
-            if (live) {
-                if (sessionScoped) {
+            if (isLive()) {
+                if (isSessionScoped()) {
-                            log.warn("Unable to remove session-scoped lock on node '" + lockToken + "': " + e.getMessage());
+                            log.warn("Unable to remove session-scoped lock on node '" + getLockToken() + "': " + e.getMessage());
-                } else {
-                    if (session == lockHolder) {
-                        session.removeLockToken(lockToken.toString());
-                        lockHolder = null;
-                    }
+                } else if (isLockHolder(session)) {
+                    session.removeLockToken(getLockToken());
+                    setLockHolder(null);
-            LockInfo info = new LockInfo(new LockToken(nodeId), false, isDeep, lockOwner);
+            InternalLockInfo info = new InternalLockInfo(new LockToken(nodeId), false, isDeep, lockOwner);

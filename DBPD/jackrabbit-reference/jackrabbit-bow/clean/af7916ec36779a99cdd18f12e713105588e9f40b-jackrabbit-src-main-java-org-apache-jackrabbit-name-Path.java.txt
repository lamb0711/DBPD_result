reverting some too enthusiastic changes :-)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@424290 13f79535-47bb-0310-9956-ffa450edef68

-
-    /**
-     * Creates a new <code>Path</code> from the given path elements.
-     *
-     * @param elements the path elements that will form the path
-     * @return a new <code>Path</code>
-     */
-    public static Path create(PathElement[] elements) {
-        PathElement[] tmp = new PathElement[elements.length];
-        boolean isNormalized = true;
-        boolean leadingParent = true;
-        for (int i = 0; i < elements.length; i++) {
-            PathElement elem = tmp[i] = elements[i];
-            if (elem.denotesCurrent() || elem.denotesParent()) {
-                leadingParent &= elem.denotesParent();
-                isNormalized &= !elem.denotesCurrent() && (leadingParent || !elem.denotesParent());
-            }
-        }
-        return new Path(tmp, isNormalized);
-    }
-
-    /**
-     * Creates a new <code>Path</code> from the given path elements but does
-     * not check if the path is normalized or not.
-     * <p/>
-     * Please note that this method should only be called, if the normalized
-     * state is known. Further is the element array not duplicated. Basically
-     * this method should only be called from {@link PathFormat}.
-     *
-     * @param elements     the path elements that will form the path
-     * @param isNormalized flag
-     * @return a new <code>Path</code>
-     */
-    protected static Path create(PathElement[] elements, boolean isNormalized) {
-        return new Path(elements, isNormalized);
-    }
-
-        return normalize
-                ? PathFormat.parse(null, jcrPath, resolver).getNormalizedPath()
-                : PathFormat.parse(null, jcrPath, resolver);
+        Path path = PathFormat.parse(jcrPath, resolver);
+        if (normalize) {
+            return path.getNormalizedPath();
+        } else {
+            return path;
+        }
-        return canonicalize
-                ? PathFormat.parse(parent, relJCRPath, resolver).getCanonicalPath()
-                : PathFormat.parse(parent, relJCRPath, resolver);
+        Path path = PathFormat.parse(parent, relJCRPath, resolver);
+        if (canonicalize) {
+            return path.getCanonicalPath();
+        } else {
+            return path;
+        }
+
-        return normalize
-                ? pb.getPath().getNormalizedPath()
-                : pb.getPath();
+
+        Path path = pb.getPath();
+        if (normalize) {
+            return path.getNormalizedPath();
+        } else {
+            return path;
+        }
-     * @param parent    the parent path
-     * @param name      the name of the new path element.
+     * @param parent the parent path
+     * @param name the name of the new path element.
-        return normalize
-                ? pb.getPath().getNormalizedPath()
-                : pb.getPath();
+
+        Path path = pb.getPath();
+        if (normalize) {
+            return path.getNormalizedPath();
+        } else {
+            return path;
+        }
-        return normalize
-                ? pb.getPath().getNormalizedPath()
-                : pb.getPath();
+
+        Path path = pb.getPath();
+        if (normalize) {
+            return path.getNormalizedPath();
+        } else {
+            return path;
+        }
-        PathElement elem = createPathElement(name, index);
-        return new Path(new PathElement[]{elem}, !elem.denotesCurrent());
-    }
-
-    /**
-     * Create a PathElement from the given QName and index.
-     *
-     * @param qName
-     * @param index
-     * @return new path element
-     * @throws IllegalArgumentException if the index is less than {@link Path#INDEX_UNDEFINED}.
-     */
-    public static PathElement createPathElement(QName qName, int index) {
+        PathElement elem;
-            return PathElement.create(qName);
+            elem = PathElement.create(name);
-            return PathElement.create(qName, index);
+            elem = PathElement.create(name, index);
+        return new Path(new PathElement[]{elem}, !elem.denotesCurrent());
-
-
-        for (int i = 0; i < p0.getElements().length && i < p1.getElements().length; i++)
-        {
+        for (int i = 0; i < p0.getElements().length && i < p1.getElements().length; i++) {
-     * @throws PathNotFoundException
-     *                                  if there is no ancestor of the specified
-     *                                  degree
+     * @throws PathNotFoundException if there is no ancestor of the specified degree
-
-

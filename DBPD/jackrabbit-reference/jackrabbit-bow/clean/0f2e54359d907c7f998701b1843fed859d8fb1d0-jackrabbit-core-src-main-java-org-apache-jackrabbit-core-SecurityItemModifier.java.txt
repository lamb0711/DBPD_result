JCR-1588 - JSR 283: Access Control (work in progress)
JCR-1590 - JSR 283: Locking
JCR-1915 - Node.setPrimaryNodeType should only redefine child-definitions that are not covered by the new effective nt
JCR-1875 - Failing Node.unlock() might leave inconsistent transient state
JCR-538 - Failing Node.checkin() or Node.checkout() might leave inconsistent transient state

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@732693 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.security.AccessManager;
+import org.apache.jackrabbit.core.security.authorization.Permission;
+import org.apache.jackrabbit.spi.Path;
-import javax.jcr.AccessDeniedException;
-import javax.jcr.ItemExistsException;
-import javax.jcr.ItemNotFoundException;
-import javax.jcr.PathNotFoundException;
-import javax.jcr.lock.LockException;
-import javax.jcr.nodetype.ConstraintViolationException;
-import javax.jcr.version.VersionException;
+import javax.jcr.ItemExistsException;
+import javax.jcr.AccessDeniedException;
-    protected SecurityItemModifier() {
+    private final boolean checkAcPermission;
+
+    protected SecurityItemModifier(boolean checkAcPermission) {
+        this.checkAcPermission = checkAcPermission;
-    protected NodeImpl addSecurityNode(NodeImpl parentImpl, Name name, Name ntName) throws RepositoryException, PathNotFoundException, LockException, ConstraintViolationException, ItemExistsException, VersionException {
-        synchronized (parentImpl) {
-            // validation: make sure Node is not locked or checked-in.
-            parentImpl.checkSetProperty();
+    protected NodeImpl addSecurityNode(NodeImpl parentImpl, Name name, Name ntName) throws RepositoryException {
+        checkPermission(parentImpl, name, getPermission(true, false));
+        // validation: make sure Node is not locked or checked-in.
+        parentImpl.checkSetProperty();
-            NodeTypeImpl nodeType = parentImpl.session.getNodeTypeManager().getNodeType(ntName);
-            NodeDefinitionImpl def = parentImpl.getApplicableChildNodeDefinition(name, ntName);
+        NodeTypeImpl nodeType = parentImpl.session.getNodeTypeManager().getNodeType(ntName);
+        NodeDefinitionImpl def = parentImpl.getApplicableChildNodeDefinition(name, ntName);
-            // check for name collisions
-            // TODO: improve. copied from NodeImpl
-            NodeState thisState = (NodeState) parentImpl.getItemState();
-            ChildNodeEntry cne = thisState.getChildNodeEntry(name, 1);
-            if (cne != null) {
-                // there's already a child node entry with that name;
-                // check same-name sibling setting of new node
-                if (!def.allowsSameNameSiblings()) {
-                    throw new ItemExistsException();
-                }
-                // check same-name sibling setting of existing node
-                NodeId newId = cne.getId();
-                NodeImpl n = (NodeImpl) parentImpl.session.getItemManager().getItem(newId);
-                if (!n.getDefinition().allowsSameNameSiblings()) {
-                    throw new ItemExistsException();
-                }
+        // check for name collisions
+        // TODO: improve. copied from NodeImpl
+        NodeState thisState = (NodeState) parentImpl.getItemState();
+        ChildNodeEntry cne = thisState.getChildNodeEntry(name, 1);
+        if (cne != null) {
+            // there's already a child node entry with that name;
+            // check same-name sibling setting of new node
+            if (!def.allowsSameNameSiblings()) {
+                throw new ItemExistsException();
-
-            return parentImpl.createChildNode(name, def, nodeType, null);
-        }
-    }
-
-    protected Property setSecurityProperty(NodeImpl parentImpl, Name name, Value value) throws RepositoryException, PathNotFoundException, LockException, ConstraintViolationException, ItemExistsException, VersionException {
-        synchronized (parentImpl) {
-            // validation: make sure Node is not locked or checked-in.
-            parentImpl.checkSetProperty();
-            InternalValue intVs = InternalValue.create(value, parentImpl.session);
-            return parentImpl.internalSetProperty(name, intVs);
-        }
-    }
-
-    protected Property setSecurityProperty(NodeImpl parentImpl, Name name, Value[] values) throws RepositoryException, PathNotFoundException, LockException, ConstraintViolationException, ItemExistsException, VersionException {
-        synchronized (parentImpl) {
-            // validation: make sure Node is not locked or checked-in.
-            parentImpl.checkSetProperty();
-            InternalValue[] intVs = new InternalValue[values.length];
-            for (int i = 0; i < values.length; i++) {
-                intVs[i] = InternalValue.create(values[i], parentImpl.session);
+            // check same-name sibling setting of existing node
+            NodeId newId = cne.getId();
+            NodeImpl n = (NodeImpl) parentImpl.session.getItemManager().getItem(newId);
+            if (!n.getDefinition().allowsSameNameSiblings()) {
+                throw new ItemExistsException();
-            return parentImpl.internalSetProperty(name, intVs);
+        }
+
+        return parentImpl.createChildNode(name, def, nodeType, null);
+    }
+
+    protected Property setSecurityProperty(NodeImpl parentImpl, Name name, Value value) throws RepositoryException {
+        if (!parentImpl.isNew()) {
+            checkPermission(parentImpl, name, getPermission(false, false));
+        }
+        // validation: make sure Node is not locked or checked-in.
+        parentImpl.checkSetProperty();
+        InternalValue intVs = InternalValue.create(value, parentImpl.session);
+        return parentImpl.internalSetProperty(name, intVs);
+    }
+
+    protected Property setSecurityProperty(NodeImpl parentImpl, Name name, Value[] values) throws RepositoryException {
+        checkPermission(parentImpl, name, getPermission(false, false));
+        // validation: make sure Node is not locked or checked-in.
+        parentImpl.checkSetProperty();
+        InternalValue[] intVs = new InternalValue[values.length];
+        for (int i = 0; i < values.length; i++) {
+            intVs[i] = InternalValue.create(values[i], parentImpl.session);
+        }
+        return parentImpl.internalSetProperty(name, intVs);
+    }
+
+    protected void removeSecurityItem(ItemImpl itemImpl) throws RepositoryException {
+        NodeImpl n;
+        if (itemImpl.isNode()) {
+            n = (NodeImpl) itemImpl;
+        } else {
+            n = (NodeImpl) itemImpl.getParent();
+        }
+        checkPermission(itemImpl, getPermission(itemImpl.isNode(), true));
+        // validation: make sure Node is not locked or checked-in.
+        n.checkSetProperty();
+        itemImpl.internalRemove(true);
+    }
+
+    private void checkPermission(ItemImpl item, int perm) throws RepositoryException {
+        SessionImpl sImpl = (SessionImpl) item.getSession();
+        AccessManager acMgr = sImpl.getAccessManager();
+
+        Path path = sImpl.getHierarchyManager().getPath(item.getId());
+        acMgr.checkPermission(path, perm);
+    }
+
+    private void checkPermission(NodeImpl node, Name childName, int perm) throws RepositoryException {
+        SessionImpl sImpl = (SessionImpl) node.getSession();
+        AccessManager acMgr = sImpl.getAccessManager();
+
+        boolean isGranted = acMgr.isGranted(node.getPrimaryPath(), childName, perm);
+        if (!isGranted) {
+            throw new AccessDeniedException("Permission denied.");
-    protected void removeSecurityItem(ItemImpl itemImpl) throws LockException, VersionException, AccessDeniedException, ItemNotFoundException, RepositoryException {
-        NodeImpl n = (itemImpl.isNode()) ? (NodeImpl) itemImpl : (NodeImpl) itemImpl.getParent();
-        synchronized (n) {
-            // validation: make sure Node is not locked or checked-in.
-            n.checkSetProperty();
-            itemImpl.internalRemove(true);
+    private int getPermission(boolean isNode, boolean isRemove) {
+        if (checkAcPermission) {
+            return Permission.MODIFY_AC;
+        } else if (isNode) {
+            return (isRemove) ? Permission.REMOVE_NODE : Permission.ADD_NODE;
+        } else {
+            return (isRemove) ? Permission.REMOVE_PROPERTY : Permission.SET_PROPERTY;

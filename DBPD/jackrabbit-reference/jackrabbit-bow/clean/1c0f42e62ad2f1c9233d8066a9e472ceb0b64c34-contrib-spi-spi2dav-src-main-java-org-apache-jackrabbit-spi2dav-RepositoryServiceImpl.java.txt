- replace all EventIterator return values in RepositoryService with EventBundle[]
- remove RepositoryService.addEventListener()/removeEventListener() and introduce getEvents() instead
- added quick description of new design: see org/apache/jackrabbit/spi/package.html
- update spi/project.properties with correct links to external javadoc
- fix package in spi/project.xml


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@468388 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.webdav.observation.Filter;
-import org.apache.jackrabbit.webdav.observation.ObservationConstants;
+import org.apache.jackrabbit.webdav.observation.ObservationConstants;
-import org.apache.jackrabbit.spi.EventListener;
-import org.apache.jackrabbit.spi.EventIterator;
-import org.apache.jackrabbit.spi.Event;
+import org.apache.jackrabbit.spi.EventBundle;
-import java.util.Map;
-import java.util.Collections;
-    private static long POLL_INTERVAL = 300000000;  // TODO: make configurable
-
-    private EventIterator execute(DavMethod method, SessionInfo sessionInfo) throws RepositoryException {
+    private EventBundle[] execute(DavMethod method, SessionInfo sessionInfo) throws RepositoryException {
-            EventIterator events = poll(subscrUri, subscrId, sessionInfo);
+            // TODO: poll until we see our change
+            EventBundle[] events = null;
+            int retries = 10;
+            while ((events == null || events.length == 0) && retries-- > 0) {
+                events = poll(subscrUri, subscrId, sessionInfo);
+            }
-                return new SessionInfoImpl(credentials, workspaceName, new SubscriptionMgrImpl());
+                return new SessionInfoImpl(credentials, workspaceName);
-        SubscriptionManager sMgr = ((SessionInfoImpl)sessionInfo).getSubscriptionManager();
-        sMgr.dispose();
+        String subscriptionId = ((SessionInfoImpl)sessionInfo).getSubscriptionId();
+        if (subscriptionId != null) {
+            String rootUri = uriResolver.getRootItemUri(sessionInfo.getWorkspaceName());
+            unsubscribe(rootUri, subscriptionId, sessionInfo);
+        }
-    public EventIterator submit(Batch batch) throws RepositoryException {
+    public EventBundle[] submit(Batch batch) throws RepositoryException {
-            return IteratorHelper.EMPTY;
+            return new EventBundle[]{EventBundleImpl.EMPTY};
-            EventIterator events;
+            EventBundle[] events;
-    public EventIterator importXml(SessionInfo sessionInfo, NodeId parentId, InputStream xmlStream, int uuidBehaviour) throws ItemExistsException, PathNotFoundException, VersionException, ConstraintViolationException, LockException, AccessDeniedException, UnsupportedRepositoryOperationException, RepositoryException {
+    public EventBundle[] importXml(SessionInfo sessionInfo, NodeId parentId, InputStream xmlStream, int uuidBehaviour) throws ItemExistsException, PathNotFoundException, VersionException, ConstraintViolationException, LockException, AccessDeniedException, UnsupportedRepositoryOperationException, RepositoryException {
-    public EventIterator move(SessionInfo sessionInfo, NodeId srcNodeId, NodeId destParentNodeId, QName destName) throws ItemExistsException, PathNotFoundException, VersionException, ConstraintViolationException, LockException, AccessDeniedException, UnsupportedRepositoryOperationException, RepositoryException {
+    public EventBundle[] move(SessionInfo sessionInfo, NodeId srcNodeId, NodeId destParentNodeId, QName destName) throws ItemExistsException, PathNotFoundException, VersionException, ConstraintViolationException, LockException, AccessDeniedException, UnsupportedRepositoryOperationException, RepositoryException {
-    public EventIterator copy(SessionInfo sessionInfo, String srcWorkspaceName, NodeId srcNodeId, NodeId destParentNodeId, QName destName) throws NoSuchWorkspaceException, ConstraintViolationException, VersionException, AccessDeniedException, PathNotFoundException, ItemExistsException, LockException, UnsupportedRepositoryOperationException, RepositoryException {
+    public EventBundle[] copy(SessionInfo sessionInfo, String srcWorkspaceName, NodeId srcNodeId, NodeId destParentNodeId, QName destName) throws NoSuchWorkspaceException, ConstraintViolationException, VersionException, AccessDeniedException, PathNotFoundException, ItemExistsException, LockException, UnsupportedRepositoryOperationException, RepositoryException {
-    public EventIterator update(SessionInfo sessionInfo, NodeId nodeId, String srcWorkspaceName) throws NoSuchWorkspaceException, AccessDeniedException, LockException, InvalidItemStateException, RepositoryException {
+    public EventBundle[] update(SessionInfo sessionInfo, NodeId nodeId, String srcWorkspaceName) throws NoSuchWorkspaceException, AccessDeniedException, LockException, InvalidItemStateException, RepositoryException {
-    public EventIterator clone(SessionInfo sessionInfo, String srcWorkspaceName, NodeId srcNodeId, NodeId destParentNodeId, QName destName, boolean removeExisting) throws NoSuchWorkspaceException, ConstraintViolationException, VersionException, AccessDeniedException, PathNotFoundException, ItemExistsException, LockException, UnsupportedRepositoryOperationException, RepositoryException {
+    public EventBundle[] clone(SessionInfo sessionInfo, String srcWorkspaceName, NodeId srcNodeId, NodeId destParentNodeId, QName destName, boolean removeExisting) throws NoSuchWorkspaceException, ConstraintViolationException, VersionException, AccessDeniedException, PathNotFoundException, ItemExistsException, LockException, UnsupportedRepositoryOperationException, RepositoryException {
-    public EventIterator lock(SessionInfo sessionInfo, NodeId nodeId, boolean deep, boolean sessionScoped) throws UnsupportedRepositoryOperationException, LockException, AccessDeniedException, InvalidItemStateException, RepositoryException {
+    public EventBundle[] lock(SessionInfo sessionInfo, NodeId nodeId, boolean deep, boolean sessionScoped) throws UnsupportedRepositoryOperationException, LockException, AccessDeniedException, InvalidItemStateException, RepositoryException {
-            EventIterator events = execute(method, sessionInfo);
+            EventBundle[] events = execute(method, sessionInfo);
-    public EventIterator refreshLock(SessionInfo sessionInfo, NodeId nodeId) throws LockException, RepositoryException {
+    public EventBundle[] refreshLock(SessionInfo sessionInfo, NodeId nodeId) throws LockException, RepositoryException {
-    public EventIterator unlock(SessionInfo sessionInfo, NodeId nodeId) throws UnsupportedRepositoryOperationException, LockException, AccessDeniedException, InvalidItemStateException, RepositoryException {
+    public EventBundle[] unlock(SessionInfo sessionInfo, NodeId nodeId) throws UnsupportedRepositoryOperationException, LockException, AccessDeniedException, InvalidItemStateException, RepositoryException {
-        EventIterator events = execute(method, sessionInfo);
+        EventBundle[] events = execute(method, sessionInfo);
-    public EventIterator checkin(SessionInfo sessionInfo, NodeId nodeId) throws VersionException, UnsupportedRepositoryOperationException, InvalidItemStateException, LockException, RepositoryException {
+    public EventBundle[] checkin(SessionInfo sessionInfo, NodeId nodeId) throws VersionException, UnsupportedRepositoryOperationException, InvalidItemStateException, LockException, RepositoryException {
-    public EventIterator checkout(SessionInfo sessionInfo, NodeId nodeId) throws UnsupportedRepositoryOperationException, LockException, RepositoryException {
+    public EventBundle[] checkout(SessionInfo sessionInfo, NodeId nodeId) throws UnsupportedRepositoryOperationException, LockException, RepositoryException {
-    public EventIterator restore(SessionInfo sessionInfo, NodeId nodeId, NodeId versionId, boolean removeExisting) throws VersionException, PathNotFoundException, ItemExistsException, UnsupportedRepositoryOperationException, LockException, InvalidItemStateException, RepositoryException {
+    public EventBundle[] restore(SessionInfo sessionInfo, NodeId nodeId, NodeId versionId, boolean removeExisting) throws VersionException, PathNotFoundException, ItemExistsException, UnsupportedRepositoryOperationException, LockException, InvalidItemStateException, RepositoryException {
-    public EventIterator restore(SessionInfo sessionInfo, NodeId[] versionIds, boolean removeExisting) throws ItemExistsException, UnsupportedRepositoryOperationException, VersionException, LockException, InvalidItemStateException, RepositoryException {
+    public EventBundle[] restore(SessionInfo sessionInfo, NodeId[] versionIds, boolean removeExisting) throws ItemExistsException, UnsupportedRepositoryOperationException, VersionException, LockException, InvalidItemStateException, RepositoryException {
-    private EventIterator update(String uri, String[] updateSource, int updateType, boolean removeExisting, SessionInfo sessionInfo) throws RepositoryException {
+    private EventBundle[] update(String uri, String[] updateSource, int updateType, boolean removeExisting, SessionInfo sessionInfo) throws RepositoryException {
-    public EventIterator merge(SessionInfo sessionInfo, NodeId nodeId, String srcWorkspaceName, boolean bestEffort) throws NoSuchWorkspaceException, AccessDeniedException, MergeException, LockException, InvalidItemStateException, RepositoryException {
+    public EventBundle[] merge(SessionInfo sessionInfo, NodeId nodeId, String srcWorkspaceName, boolean bestEffort) throws NoSuchWorkspaceException, AccessDeniedException, MergeException, LockException, InvalidItemStateException, RepositoryException {
-    public EventIterator resolveMergeConflict(SessionInfo sessionInfo, NodeId nodeId, NodeId[] mergeFailedIds, NodeId[] predecessorIds) throws VersionException, InvalidItemStateException, UnsupportedRepositoryOperationException, RepositoryException {
+    public EventBundle[] resolveMergeConflict(SessionInfo sessionInfo, NodeId nodeId, NodeId[] mergeFailedIds, NodeId[] predecessorIds) throws VersionException, InvalidItemStateException, UnsupportedRepositoryOperationException, RepositoryException {
-    public EventIterator addVersionLabel(SessionInfo sessionInfo, NodeId versionHistoryId, NodeId versionId, QName label, boolean moveLabel) throws VersionException, RepositoryException {
+    public EventBundle[] addVersionLabel(SessionInfo sessionInfo, NodeId versionHistoryId, NodeId versionId, QName label, boolean moveLabel) throws VersionException, RepositoryException {
-    public EventIterator removeVersionLabel(SessionInfo sessionInfo, NodeId versionHistoryId, NodeId versionId, QName label) throws VersionException, RepositoryException {
+    public EventBundle[] removeVersionLabel(SessionInfo sessionInfo, NodeId versionHistoryId, NodeId versionId, QName label) throws VersionException, RepositoryException {
-            if (method != null) {
-                method.releaseConnection();
-            }
+            method.releaseConnection();
-     * @see RepositoryService#addEventListener(SessionInfo,NodeId,EventListener,int,boolean,String[],QName[])
+     * @see RepositoryService#getEvents(SessionInfo, long)
-    public void addEventListener(SessionInfo sessionInfo, NodeId nodeId, EventListener listener, int eventTypes, boolean isDeep, String[] uuids, QName[] nodeTypeIds) throws RepositoryException {
-        // build event types
-        List eTypes = new ArrayList();
-        if ((eventTypes & Event.NODE_ADDED) == Event.NODE_ADDED) {
-            eTypes.add(SubscriptionImpl.getEventType(javax.jcr.observation.Event.NODE_ADDED));
-        }
-        if ((eventTypes & Event.NODE_REMOVED) == Event.NODE_REMOVED) {
-            eTypes.add(SubscriptionImpl.getEventType(javax.jcr.observation.Event.NODE_REMOVED));
-        }
-        if ((eventTypes & Event.PROPERTY_ADDED) == Event.PROPERTY_ADDED) {
-            eTypes.add(SubscriptionImpl.getEventType(javax.jcr.observation.Event.PROPERTY_ADDED));
-        }
-        if ((eventTypes & Event.PROPERTY_REMOVED) == Event.PROPERTY_REMOVED) {
-            eTypes.add(SubscriptionImpl.getEventType(javax.jcr.observation.Event.PROPERTY_REMOVED));
-        }
-        if ((eventTypes & Event.PROPERTY_CHANGED) == Event.PROPERTY_CHANGED) {
-            eTypes.add(SubscriptionImpl.getEventType(javax.jcr.observation.Event.PROPERTY_CHANGED));
-        }
-        EventType[] etArr = (EventType[]) eTypes.toArray(new EventType[eTypes.size()]);
-
-        // build filters from params
-        List filters = new ArrayList();
-        for (int i = 0; uuids != null && i < uuids.length; i++) {
-            filters.add(new Filter(ObservationConstants.XML_UUID, ObservationConstants.NAMESPACE, uuids[i]));
-        }
-        for (int i = 0; nodeTypeIds != null && i < nodeTypeIds.length; i++) {
-            try {
-                String ntName = NameFormat.format(nodeTypeIds[i], nsResolver);
-                filters.add(new Filter(ObservationConstants.XML_NODETYPE_NAME, ObservationConstants.NAMESPACE, ntName));
-            } catch (NoPrefixDeclaredException e) {
-                throw new RepositoryException(e);
-            }
-        }
-        Filter[] ftArr = (Filter[]) filters.toArray(new Filter[filters.size()]);
-
-        boolean noLocal = true;
-        SubscriptionInfo subscriptionInfo = new SubscriptionInfo(etArr, ftArr, noLocal, isDeep, DavConstants.UNDEFINED_TIMEOUT);
-        String uri = getItemUri(nodeId, sessionInfo);
-
+    public EventBundle[] getEvents(SessionInfo sessionInfo, long timeout)
+            throws RepositoryException, UnsupportedRepositoryOperationException {
-        SubscriptionManager sMgr = ((SessionInfoImpl)sessionInfo).getSubscriptionManager();
-        if (sMgr.subscriptionExists(listener)) {
-            String subscriptionId = sMgr.getSubscriptionId(listener);
-            subscribe(uri, subscriptionInfo, subscriptionId, sessionInfo);
-            log.debug("Subscribed on server for listener " + listener);
-        } else {
-            String subscriptionId = subscribe(uri, subscriptionInfo, null, sessionInfo);
-            log.debug("Subscribed on server for listener " + listener);
-            sMgr.addSubscription(uri, subscriptionId, listener);
-            log.debug("Added subscription for listener " + listener);
+        SessionInfoImpl sessionInfoImpl = (SessionInfoImpl)sessionInfo;
+        String rootUri = uriResolver.getRootItemUri(sessionInfo.getWorkspaceName());
+        String subscriptionId = sessionInfoImpl.getSubscriptionId();
+        if (subscriptionId == null) {
+            SubscriptionInfo subscriptionInfo = new SubscriptionInfo(ALL_EVENTS, true, DavConstants.UNDEFINED_TIMEOUT);
+            subscriptionId = subscribe(rootUri, subscriptionInfo, null, sessionInfo);
+            log.debug("Subscribed on server for session info " + sessionInfo);
+            sessionInfoImpl.setSubscriptionId(subscriptionId);
+
+        return poll(rootUri, subscriptionId, sessionInfo);
-    /**
-     * @see RepositoryService#removeEventListener(SessionInfo, NodeId, EventListener)
-     */
-    public void removeEventListener(SessionInfo sessionInfo, NodeId nodeId, EventListener listener) throws RepositoryException {
-        checkSessionInfo(sessionInfo);
-        SubscriptionManager sMgr = ((SessionInfoImpl)sessionInfo).getSubscriptionManager();
-        String subscriptionId = sMgr.getSubscriptionId(listener);
-
-        String uri = getItemUri(nodeId, sessionInfo);
-        sMgr.removeSubscription(listener);
-        log.debug("Removed subscription for listener " + listener);
-        unsubscribe(uri, subscriptionId, sessionInfo);
-        log.debug("Unsubscribed on server for listener " + listener);
-    }
-
-
-    private EventIterator poll(String uri, String subscriptionId,  SessionInfo sessionInfo) throws RepositoryException {
+    private EventBundle[] poll(String uri, String subscriptionId,  SessionInfo sessionInfo) throws RepositoryException {
+            EventBundle[] events;
-                return IteratorHelper.EMPTY;
+                events = new EventBundle[]{EventBundleImpl.EMPTY};
-                return new EventIteratorImpl(discEl, uriResolver, sessionInfo);
+                ElementIterator it = DomUtil.getChildren(discEl,
+                        ObservationConstants.XML_EVENTBUNDLE,
+                        ObservationConstants.NAMESPACE);
+                List bundles = new ArrayList();
+                while (it.hasNext()) {
+                    bundles.add(new EventBundleImpl(it.nextElement(), uriResolver, sessionInfo));
+                }
+                events = (EventBundle[]) bundles.toArray(new EventBundle[bundles.size()]);
+            return events;
-        private EventIterator end(HttpClient client, boolean commit) throws RepositoryException {
+        private EventBundle[] end(HttpClient client, boolean commit) throws RepositoryException {
-                EventIterator events = poll(subscrUri, subscriptionId, sessionInfo);
+                // TODO: until we see our change!
+                EventBundle[] events = null;
+                int retries = 10;
+                while ((events == null || events.length == 0) && retries-- > 0) {
+                    events = poll(subscrUri, subscriptionId, sessionInfo);
+                }
-            QValue qV = null;
-                qV = QValue.create(value, propertyType);
+                QValue qV = QValue.create(value, propertyType);
-
-    /**
-     * <code>SubscriptionManager</code>...
-     */
-    private class SubscriptionMgrImpl implements SubscriptionManager {
-
-        private SessionInfo sessionInfo;
-
-        private final Map subscriptions = new HashMap();
-        private final Object subscriptionsLock = new Object();
-        private Map currentSubscriptions;
-
-        private Thread t;
-
-        public void setSessionInfo(SessionInfo sessionInfo) {
-            this.sessionInfo = sessionInfo;
-        }
-
-        public boolean subscriptionExists(EventListener listener) {
-            return getSubscriptions().containsKey(listener);
-        }
-
-        public String getSubscriptionId(EventListener listener) {
-            if (getSubscriptions().containsKey(listener)) {
-                return ((String[]) getSubscriptions().get(listener))[1];
-            } else {
-                return null;
-            }
-        }
-
-        public void addSubscription(String uri, String subscriptionId, EventListener listener) {
-            synchronized (subscriptionsLock) {
-                boolean doStart = subscriptions.isEmpty();
-                subscriptions.put(listener, new String[] {uri,subscriptionId});
-                currentSubscriptions = null;
-                if (doStart) {
-                    startPolling();
-                }
-            }
-        }
-
-        public synchronized void removeSubscription(EventListener listener) {
-            synchronized (subscriptionsLock) {
-                subscriptions.remove(listener);
-                currentSubscriptions = null;
-                if (subscriptions.isEmpty()) {
-                    stopPolling();
-                }
-            }
-        }
-
-        public void dispose() {
-            synchronized (subscriptionsLock) {
-                if (!subscriptions.isEmpty()) {
-                    subscriptions.clear();
-                    currentSubscriptions = null;
-                    stopPolling();
-                }
-            }
-        }
-
-        private Map getSubscriptions() {
-            synchronized (subscriptionsLock) {
-                if (currentSubscriptions == null) {
-                    currentSubscriptions = Collections.unmodifiableMap(new HashMap(subscriptions));
-                }
-                return currentSubscriptions;
-            }
-        }
-
-        private void startPolling() {
-            Runnable r = new Runnable() {
-                public void run() {
-                    while (t == Thread.currentThread()) {
-                        try {
-                            // sleep
-                            Thread.sleep(POLL_INTERVAL);
-                            // poll
-                            Iterator lstnIterator = getSubscriptions().keySet().iterator();
-                            while (lstnIterator.hasNext()) {
-                                EventListener listener = (EventListener) lstnIterator.next();
-                                String[] value = (String[]) getSubscriptions().get(listener);
-                                String uri = value[0];
-                                String subscriptionId = value[1];
-                                EventIterator eventIterator = poll(uri, subscriptionId, sessionInfo);
-                                listener.onEvent(eventIterator);
-                            }
-                        } catch (InterruptedException e) {
-                            log.debug("Polling thread interrupted: " + e.getMessage());
-                            return;
-                        } catch (RepositoryException e) {
-                            log.warn("Polling failed: ", e.getMessage());
-                        }
-                    }
-                }
-            };
-            t = new Thread(r);
-            t.start();
-        }
-
-        private void stopPolling() {
-            t.interrupt();
-        }
-    }

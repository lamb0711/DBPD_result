JCR-2887 : Split PrivilegeRegistry in a per-session manager instance and a repository level registry [work in progress]

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1082239 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.commons.iterator.Iterators;
+     * A custom privilege for which bits were not calculated
+     */
+    private static final int UNDEFINED = -1;
+
+    /**
-    private int nextBits = RETENTION_MNGMT << 1;
-
-            Map<Name, Definition> definitions = createPrivilegeDefinitions(customDefs);
+            Map<Name, Definition> definitions = createCustomDefinitions(customDefs);
-        return new PrivilegeManagerImpl(this, resolver).getPrivileges(bits);
+        Set<Privilege> prvs = new PrivilegeManagerImpl(this, resolver).getPrivileges(bits);
+        return prvs.toArray(new Privilege[prvs.size()]);
-     * Note, that the bits calculated for jcr:all does not include any
-     * registered custom privileges.
-     *
+     * 
-        int bits = PrivilegeRegistry.NO_PRIVILEGE;
+        int bits = NO_PRIVILEGE;
-            Map<Name, DefinitionStub> stubs = Collections.singletonMap(privilegeName, new DefinitionStub(privilegeName, isAbstract, declaredAggregateNames, true));
-            Map<Name, Definition> definitions = createPrivilegeDefinitions(stubs);
+            Map<Name, DefinitionStub> stubs = Collections.singletonMap(privilegeName, new DefinitionStub(privilegeName, isAbstract, declaredAggregateNames));
+            Map<Name, Definition> definitions = createCustomDefinitions(stubs);
+     * Calculates the bits of the specified definitions. Note, that custom
+     * privileges don't have a integer representation as they are not used
+     * for permission calculation.
+     *
+     * @param defs
+     * @return
+     */
+    int getBits(Definition[] defs) {
+        int bits = NO_PRIVILEGE;
+        for (Definition def : defs) {
+            bits |= def.bits;
+        }
+        return bits;
+    }
+
+    /**
+     * Returns the names of the privileges identified by the specified bits.
+     * Note, that custom privileges don't have a integer representation as they
+     * are not used for permission calculation.
+     * 
-        if (bitsToNames.containsKey(bits)) {
+        if (bits <= NO_PRIVILEGE) {
+            return Name.EMPTY_ARRAY;
+        } else if (bitsToNames.containsKey(bits)) {
+            // matches all built-in aggregates and single built-in privileges
+            // bits are a combination of built-in privileges.
-            // include matching custom privilege names 
-            for (Definition def : registeredPrivileges.values()) {
-                if (def.isCustom && ((bits & def.bits) == def.bits)) {
-                    names.add(def.name);
-                }
-            }
-
-            bitsToNames.put(def.bits, Collections.singleton(def.name));
+            if (def.bits > NO_PRIVILEGE) {
+                bitsToNames.put(def.bits, Collections.singleton(def.name));
+            }
-            int allBits = all.bits;
-            for (Definition def : definitions.values()) {
-                allBits |= def.bits;
-            }
-
-            all = new Definition(NameConstants.JCR_ALL, false, allAggrNames, allBits);
+            all = new Definition(NameConstants.JCR_ALL, false, allAggrNames, all.bits);
-     * new <code>PrivilegeDefinition</code>s. The validation includes name
+     * new custom <code>PrivilegeDefinition</code>s. The validation includes name
-    private Map<Name, Definition> createPrivilegeDefinitions(Map<Name, DefinitionStub> toRegister) throws RepositoryException {
+    private Map<Name, Definition> createCustomDefinitions(Map<Name, DefinitionStub> toRegister) throws RepositoryException {
-                definitions.put(name, new Definition(stub, nextBits()));
+                definitions.put(name, new Definition(stub, NO_PRIVILEGE));
-                int bts = getAggregateBits(stub.declaredAggregateNames, definitions);
-                if (bitsToNames.containsKey(bts) && bitsToNames.get(bts).size() == 1) {
-                    Name existingName = bitsToNames.get(bts).iterator().next();
-                    throw new RepositoryException("Custom aggregate privilege '" + stub.name + "' is already covered by '" + existingName.toString() + "'");
+
+                int bts = NO_PRIVILEGE;
+                for (Name n : stub.declaredAggregateNames) {
+                    Definition aggr = null;
+                    if (registeredPrivileges.containsKey(n)) {
+                        aggr = registeredPrivileges.get(n);
+                    } else if (definitions.containsKey(n)) {
+                        aggr = definitions.get(n);
+                    }
+
+                    if (aggr == null) {
+                        // unknown dependency
+                        bts = UNDEFINED;
+                        break;
+                    } else if (!aggr.isCustom()) {
+                        throw new RepositoryException("Custom privileges may only aggregate custom privileges.");
+                    } // else: a known custom privilege -> try next.
-                if (bts != NO_PRIVILEGE) {
+
+                if (bts == NO_PRIVILEGE) {
+
+                    // final validation if a custom aggregated has not yet been defined.
+                    Iterator<Definition> it = Iterators.iteratorChain(registeredPrivileges.values().iterator(), definitions.values().iterator());
+                    while (it.hasNext()) {
+                        Definition d = it.next();
+                        if (isEquivalentAggregate(d, def, definitions)) {
+                            throw new RepositoryException("Custom aggregate privilege '" + def.name + "' is already defined by '"+ d.name+"'");
+                        }
+                    }
+
-                }
+                } // unresolvable bts -> postpone to next iterator.
-    /**
-     *
-     * @return
-     */
-    private int nextBits() {
-        int b = nextBits;
-        nextBits = nextBits << 1;
-        return b;
+    private boolean isEquivalentAggregate(Definition d, Definition otherDef,
+                                          Map<Name, Definition> unregistered) {
+        // either of the definitions isn't an aggregate.
+        if (d.declaredAggregateNames.isEmpty() || otherDef.declaredAggregateNames.isEmpty()) {
+            return false;
+        }
+        // two aggregates that defined the same declared aggregate names
+        if (d.declaredAggregateNames.equals(otherDef.declaredAggregateNames)) {
+            return true;
+        }
+        // two aggregates that defined the same aggregation of simple definitions.
+        Set<Name> aggrNames = getAggrNames(d, unregistered);
+        Set<Name> otherAggrNames = getAggrNames(otherDef, unregistered);
+        return aggrNames.size() == otherAggrNames.size() && aggrNames.containsAll(otherAggrNames);
-    /**
-     *
-     * @param declaredAggregateNames
-     * @param toRegister
-     * @return
-     */
-    private int getAggregateBits(Set<Name> declaredAggregateNames, Map<Name, Definition> toRegister) {
-        int bts = NO_PRIVILEGE;
-        for (Name n : declaredAggregateNames) {
-            if (registeredPrivileges.containsKey(n)) {
-                bts |= registeredPrivileges.get(n).bits;
-            } else if (toRegister.containsKey(n)) {
-                Definition def = toRegister.get(n);
-                if (def.bits == NO_PRIVILEGE) {
-                    // not yet processed dependency -> wait for next iteration.
-                    return NO_PRIVILEGE;
-                } else {
-                    bts |= def.bits;
-                }
+    private Set<Name> getAggrNames(Definition def, Map<Name, Definition> unregistered) {
+        Set<Name> names = new HashSet<Name>();
+        for (Name n : def.declaredAggregateNames) {
+            Definition a = (unregistered.containsKey(n)) ? unregistered.get(n) : registeredPrivileges.get(n);
+            if (a.declaredAggregateNames.isEmpty()) {
+                names.add(a.name);
-                // unknown dependency (should not get here)
-                return NO_PRIVILEGE;
+                names.addAll(getAggrNames(a, unregistered));
-        return bts;
+        return names;
-        protected final boolean isCustom;
-        
+
-        private DefinitionStub(Name name, boolean isAbstract, Set<Name> declaredAggregateNames, boolean isCustom) {
+        private DefinitionStub(Name name, boolean isAbstract, Set<Name> declaredAggregateNames) {
-            this.isCustom = isCustom;
+                /* NOTE: evaluation of decl-aggr-names is sufficient as
+                   uniqueness is asserted upon registration */
+                        /* NOTE: comparison of decl-aggr-names is sufficient as
+                           uniqueness is asserted upon registration */
-            this(stub.name, stub.isAbstract, stub.declaredAggregateNames, bits, stub.isCustom);
+            this(stub.name, stub.isAbstract, stub.declaredAggregateNames, bits);
-            this(name, isAbstract, Collections.<Name>emptySet(), bits, false);
+            this(name, isAbstract, Collections.<Name>emptySet(), bits);
-            this(name, isAbstract, declaredAggregateNames, bits, false);
-        }
-
-        private Definition(Name name, boolean isAbstract, Set<Name> declaredAggregateNames, int bits, boolean isCustom) {
-            super(name, isAbstract, declaredAggregateNames, isCustom);
-            if (bits == NO_PRIVILEGE) {
+            super(name, isAbstract, declaredAggregateNames);
+            if (bits < NO_PRIVILEGE) {
-        int getBits() {
-            return bits;
-        }
-
+
+        boolean isCustom() {
+            return bits == NO_PRIVILEGE;
+        }
-                        stubs.put(privName, new DefinitionStub(privName, isAbstract, declaredAggrNames, true));
+                        stubs.put(privName, new DefinitionStub(privName, isAbstract, declaredAggrNames));

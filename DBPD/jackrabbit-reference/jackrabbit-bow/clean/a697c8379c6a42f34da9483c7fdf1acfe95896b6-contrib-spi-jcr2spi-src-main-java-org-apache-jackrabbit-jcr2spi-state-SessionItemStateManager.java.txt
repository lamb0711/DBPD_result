work in progress

- version always protected
- versionHistory always protected
- fix Node.getReferences && reference properties
- mixinTypes are 'active' upon save only (and not before). therefore
  cleanup after removeMixin is done only after save.
  adding new states defined by a new mixin are only added after the
  node has been saved.
- nodestates identified by a uuid only were created a second time upon
  ChildNodeEntry.resolve => fix needs to be improved
- Events/ChangeLog are processed by the save-target state
- ChangeLog.persisted not used any more

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@467956 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.state.entry.ChildPropertyEntry;
-import org.apache.jackrabbit.jcr2spi.state.entry.ChildNodeEntry;
+import org.apache.jackrabbit.uuid.UUID;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashSet;
-
-        // TODO: not correct. ItemManager later on expectes overlaying state
-        return workspaceItemStateMgr.getReferingStates(nodeState);
+        NodeState wspState = (NodeState) nodeState.getWorkspaceState();
+        if (wspState == null) {
+            // new state => unable to determine references
+            return Collections.EMPTY_SET;
+        }
+
+        Collection rs = workspaceItemStateMgr.getReferingStates(wspState);
+        if (rs.isEmpty()) {
+            return rs;
+        } else {
+            // retrieve session-propertystates
+            Set refStates = new HashSet();
+            for (Iterator it =  rs.iterator(); it.hasNext();) {
+                PropertyState wState = (PropertyState) it.next();
+                ItemState sState = wState.getSessionState();
+                if (sState == null) {
+                    // overlaying state has not been build up to now
+                   sState = getItemState(wState.getPropertyId());
+                }
+                // add property state to list of refering states unless it has
+                // be removed in the transient layer.
+                if (sState.isValid()) {
+                   refStates.add(sState);
+                }
+            }
+            return Collections.unmodifiableCollection(refStates);
+        }
-        return workspaceItemStateMgr.hasReferingStates(nodeState);
+        try {
+            return !getReferingStates(nodeState).isEmpty();
+        } catch (ItemStateException e) {
+            log.warn("Internal error", e);
+            return false;
+        }
-        switch (state.getStatus()) {
-            case Status.NEW:
-                {
-                    String msg = LogUtil.safeGetJCRPath(state, nsResolver) + ": cannot save a new item.";
-                    log.debug(msg);
-                    throw new ItemStateException(msg);
-                }
+        if (state.getStatus() == Status.NEW) {
+            String msg = LogUtil.safeGetJCRPath(state, nsResolver) + ": cannot save a new item.";
+            log.debug(msg);
+            throw new ItemStateException(msg);
-        if (throwOnStale) {
-            switch (state.getStatus()) {
-                case Status.STALE_MODIFIED:
-                    {
-                        String msg = LogUtil.safeGetJCRPath(state, nsResolver) + ": the item cannot be saved because it has been modified externally.";
-                        log.debug(msg);
-                        throw new StaleItemStateException(msg);
-                    }
-                case Status.STALE_DESTROYED:
-                    {
-                        String msg = LogUtil.safeGetJCRPath(state, nsResolver) + ": the item cannot be saved because it has been deleted externally.";
-                        log.debug(msg);
-                        throw new StaleItemStateException(msg);
-                    }
-            }
+
+        if (throwOnStale && Status.isStale(state.getStatus())) {
+            String msg = LogUtil.safeGetJCRPath(state, nsResolver) + ": the item cannot be saved because it has been modified/removed externally.";
+            log.debug(msg);
+            throw new StaleItemStateException(msg);
-        Set transientStates = new HashSet();
+        Set transientStates = new LinkedHashSet();
-        // remember if an existing mixin is being removed.
-        boolean anyRemoved;
-
+        // NOTE: nodestate is only modified upon save of the changes!
-        // mixin-names to be execute on the nodestate (and corresponding property state)
+        // new array of mixinNames to be set on the nodestate (and corresponding property state)
-            // find out if any of the existing mixins is removed
-            List originalMixins = new ArrayList();
-            originalMixins.addAll(Arrays.asList(nState.getMixinTypeNames()));
-            originalMixins.removeAll(Arrays.asList(mixinNames));
-            anyRemoved = originalMixins.size() > 0;
-
-            // update nodestate
-            nState.setMixinTypeNames(mixinNames);
-
-            anyRemoved = nState.getMixinTypeNames().length > 0;
-            // remove all mixins
-            nState.setMixinTypeNames(null);
-
-        // make sure, the modification of the mixin set did not left child-item
-        // states defined by the removed mixin type(s)
-        // TODO: the following block should be delegated to 'server' - side.
-        if (anyRemoved) {
-            EffectiveNodeType ent = validator.getEffectiveNodeType(nState);
-            // use temp set to avoid ConcurrentModificationException
-            Iterator childProps = new HashSet(nState.getPropertyEntries()).iterator();
-            while (childProps.hasNext()) {
-                try {
-                    ChildPropertyEntry entry = (ChildPropertyEntry) childProps.next();
-                    PropertyState childState = entry.getPropertyState();
-                    QName declNtName = childState.getDefinition().getDeclaringNodeType();
-                    // check if property has been defined by mixin type (or one of its supertypes)
-                    if (!ent.includesNodeType(declNtName)) {
-                        // the remaining effective node type doesn't include the
-                        // node type that declared this property, it is thus safe
-                        // to remove it
-                        int options = 0; // no checks required
-                        removeItemState(childState, options);
-                    }
-                } catch (ItemStateException e) {
-                    // ignore. cleanup will occure upon save anyway
-                    log.error("Error while removing child node defined by removed mixin: {0}", e.getMessage());
-                }
-            }
-            // use temp array to avoid ConcurrentModificationException
-            Iterator childNodes = new ArrayList(nState.getChildNodeEntries()).iterator();
-            while (childNodes.hasNext()) {
-                try {
-                    ChildNodeEntry entry = (ChildNodeEntry) childNodes.next();
-                    NodeState childState = entry.getNodeState();
-                    // check if node has been defined by mixin type (or one of its supertypes)
-                    QName declNtName = childState.getDefinition().getDeclaringNodeType();
-                    if (!ent.includesNodeType(declNtName)) {
-                        // the remaining effective node type doesn't include the
-                        // node type that declared this child node, it is thus safe
-                        // to remove it.
-                        int options = 0; // NOTE: referencial intergrity checked upon save.
-                        removeItemState(childState, options);
-                    }
-                } catch (ItemStateException e) {
-                    // ignore. cleanup will occure upon save anyway
-                    log.error("Error while removing child property defined by removed mixin: {0}", e.getMessage());
-                }
-            }
-        }
-
+        nState.markModified();
-        PropertyState propState = transientStateMgr.createNewPropertyState(propertyName, parent, pDef);
-
-        // NOTE: callers must make sure, the property type is not 'undefined'
-        propState.setValues(values, propertyType);
+        PropertyState propState = transientStateMgr.createNewPropertyState(propertyName, parent, pDef, values, propertyType);
-    private void addNodeState(NodeState parent, QName nodeName, QName nodeTypeName, String uuid, QNodeDefinition definition, int options) throws RepositoryException, ConstraintViolationException, AccessDeniedException, UnsupportedRepositoryOperationException, NoSuchNodeTypeException, ItemExistsException, VersionException {
+    private void addNodeState(NodeState parent, QName nodeName, QName nodeTypeName,
+                              String uuid, QNodeDefinition definition, int options)
+        throws RepositoryException, ConstraintViolationException, AccessDeniedException,
+        UnsupportedRepositoryOperationException, NoSuchNodeTypeException,
+        ItemExistsException, VersionException {
-                int propOptions = 0; // nothing to check
+                int propOptions = ItemStateValidator.CHECK_NONE;
-
-        // free old values as necessary
-        QValue[] oldValues = propState.getValues();
-        if (oldValues != null) {
-            for (int i = 0; i < oldValues.length; i++) {
-                QValue old = oldValues[i];
-                if (old != null) {
-                    // make sure temporarily allocated data is discarded
-                    // before overwriting it (see QValue#discard())
-                    old.discard();
-                }
-            }
-        }
-                genValues = new QValue[]{QValue.create(parent.getNodeId().getUUID().toString())};
+                String uuid = parent.getUUID();
+                if (uuid == null) {
+                    uuid = UUID.randomUUID().toString();
+                }
+                genValues = new QValue[]{QValue.create(uuid)};

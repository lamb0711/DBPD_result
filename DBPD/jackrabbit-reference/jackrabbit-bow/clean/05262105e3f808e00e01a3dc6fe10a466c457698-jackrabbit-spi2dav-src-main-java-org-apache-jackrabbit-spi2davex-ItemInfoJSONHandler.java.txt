JCR-2625: spi2davex: reduce memory footprint of Node/PropertyInfoImpl

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@945164 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.commons.name.NameConstants;
+import org.apache.jackrabbit.spi.commons.util.StringCache;
-    private static final int SPECIAL_JSON_PAIR = Integer.MAX_VALUE;
+    private static final String LEAF_NODE_HINT = "::NodeIteratorSize";
+    private boolean expectingHintValue = false;
+
-    private int propertyType;
+    // temp. property state
+    private int propertyType;
+    private boolean multiValuedProperty = false;
+    private List<QValue> propValues = new ArrayList<QValue>();
+
-    private PropertyInfoImpl mvPropInfo;
+
+    private Stack<List<PropertyInfoImpl>> propInfoLists = new Stack<List<PropertyInfoImpl>>();
+        propInfoLists.push(new ArrayList<PropertyInfoImpl>(8));
-                itemInfos.add(nInfo);
+                propInfoLists.push(new ArrayList<PropertyInfoImpl>(8));
-            nInfo.resolveUUID(idFactory);
+            List<PropertyInfoImpl> props = propInfoLists.pop();
+            // all required information to create a node info should now be gathered
+            nInfo.setPropertyInfos(props.toArray(new PropertyInfoImpl[props.size()]), idFactory);
-            if (!nInfo.isCompleted()) {
+            if (nInfo.isCompleted()) {
+                itemInfos.addAll(props);
+                itemInfos.add(nInfo);
+            } else {
-                itemInfos.remove(nInfo);
+        } finally {
+            // reset all node-related handler state
+            name = null;
+            index = Path.INDEX_DEFAULT;
-        try {
-            mvPropInfo = createPropertyInfo(null, true);
-        } catch (RepositoryException e) {
-            throw new IOException(e.getMessage());
-        }
+        multiValuedProperty = true;
+        propValues.clear();
-            // make sure that type is set for mv-properties with empty value array.
-            if (propertyType == PropertyType.UNDEFINED &&
-                    mvPropInfo.numberOfValues() == 0) {
-                int type = vFactory.retrieveType(getValueURI());
-                mvPropInfo.setType(type);
+            if (propertyType == PropertyType.UNDEFINED) {
+                if (propValues.isEmpty()) {
+                    // make sure that type is set for mv-properties with empty value array.
+                    propertyType = vFactory.retrieveType(getValueURI());
+                } else {
+                    propertyType = propValues.get(0).getType();
+                }
-            mvPropInfo.checkCompleted();
-            getCurrentNodeInfo().addPropertyInfo(mvPropInfo, idFactory);
-            mvPropInfo = null;
+            // create multi-valued property info
+            NodeInfoImpl parent = getCurrentNodeInfo();
+            Path p = pFactory.create(parent.getPath(), name, true);
+            PropertyId id = idFactory.createPropertyId(parent.getId(), name);
+            PropertyInfoImpl propInfo = new PropertyInfoImpl(id, p, propertyType, propValues.toArray(new QValue[propValues.size()]));
+            propInfo.checkCompleted();
+            getCurrentPropInfos().add(propInfo);
+        } finally {
+            // reset property-related handler state
+            propertyType = PropertyType.UNDEFINED;
+            multiValuedProperty = false;
+            propValues.clear();
+            name = null;
+        expectingHintValue = false;
-            if (key.equals("::NodeIteratorSize")) {
-                propertyType = SPECIAL_JSON_PAIR;
-                // TODO: if additional JSON pairs are created -> set name
+            if (key.equals(LEAF_NODE_HINT)) {
+                expectingHintValue = true;
+                // TODO: remember name of hint if there will be additional types of hints
+                name = null;
-                // binary property
-                name = resolver.getQName(key.substring(1));
-                propertyType = PropertyType.BINARY;
+                expectingHintValue = true;
+                // either
+                //   :<nameOfProperty> : "PropertyTypeName"
+                // or
+                //   :<nameOfBinaryProperty> : <lengthOfBinaryProperty>
+                //name = resolver.getQName(key.substring(1));
+                name = resolver.getQName(StringCache.fromCacheOrNew(key.substring(1)));
-                name = resolver.getQName(key.substring(0, pos));
+                //name = resolver.getQName(key.substring(0, pos));
+                name = resolver.getQName(StringCache.fromCacheOrNew(key.substring(0, pos)));
-                Name previousName = name;
-                name = resolver.getQName(key);
-                propertyType = guessPropertyType(name, previousName);
-                // property type is defined through json value OR special property
-                // :propertyName = type.
+                name = resolver.getQName(StringCache.cache(key));
+    /**
+     * there is currently one special string-value hint:
+     *
+     *   :<nameOfProperty> : "PropertyTypeName"
+     *
+     * @param value The value.
+     * @throws IOException
+     */
+        if (expectingHintValue) {
+            // :<nameOfProperty> : "PropertyTypeName"
+            propertyType = PropertyType.valueFromName(value);
+            return;
+        }
-                case SPECIAL_JSON_PAIR:
-                    // currently no special boolean value pair -> ignore
-                    return;
-                case PropertyType.BINARY:
-                    // key started with ':' but value is String instead of
-                    // long. value therefore reflects the property type.
-                    // -> reset the property type.
-                    // -> omit creation of value AND call to value(QValue)
-                    propertyType = PropertyType.valueFromName(value);
-                    return;
+                    if (!NameConstants.JCR_UUID.equals(name)) {
+                        value = StringCache.cache(value);
+                    }
-        if (propertyType == SPECIAL_JSON_PAIR) {
-            // currently no special boolean value pair -> ignore
+        if (expectingHintValue) {
+            // there are currently no special boolean value hints:
+    /**
+     * there are currently 2 types of special long value hints:
+     *
+     * a) ::NodeIteratorSize : 0
+     *    ==> denotes the current node as leaf node
+     *
+     * b) :<nameOfBinaryProperty> : <lengthOfBinaryProperty>
+     *
+     * @param value The value.
+     * @throws IOException
+     */
-        if (propertyType == SPECIAL_JSON_PAIR) {
-            NodeInfoImpl parent = getCurrentNodeInfo();
-            if (parent != null) {
-                parent.setNumberOfChildNodes(value);
+        if (expectingHintValue) {
+            if (name == null) {
+                // ::NodeIteratorSize : 0
+                NodeInfoImpl parent = getCurrentNodeInfo();
+                if (parent != null) {
+                    parent.markAsLeafNode();
+                }
+            } else {
+                // :<nameOfBinaryProperty> : <lengthOfBinaryProperty>
+                propertyType = PropertyType.BINARY;
+                try {
+                    int indx = (!multiValuedProperty) ? -1 : propValues.size();
+                    value(vFactory.create(value, getValueURI(), indx));
+                } catch (RepositoryException e) {
+                    throw new IOException(e.getMessage());
+                }
-            QValue v;
-            if (propertyType == PropertyType.BINARY) {
-                int indx = (mvPropInfo == null) ? -1 : mvPropInfo.numberOfValues();
-                v = vFactory.create(value, getValueURI(), indx);
-            } else {
-                v = vFactory.create(value);
-            }
-            value(v);
+            value(vFactory.create(value));
-        if (propertyType == SPECIAL_JSON_PAIR) {
+        if (expectingHintValue) {
-        if (mvPropInfo == null) {
-            createPropertyInfo(value, false);
+        if (!multiValuedProperty) {
+            try {
+                if (propertyType == PropertyType.UNDEFINED) {
+                    propertyType = value.getType();
+                }
+                // create single-valued property info
+                NodeInfoImpl parent = getCurrentNodeInfo();
+                Path p = pFactory.create(parent.getPath(), name, true);
+                PropertyId id = idFactory.createPropertyId(parent.getId(), name);
+                PropertyInfoImpl propInfo = new PropertyInfoImpl(id, p, propertyType, value);
+                propInfo.checkCompleted();
+                // add property info to current list, will be processed on endObject() event
+                getCurrentPropInfos().add(propInfo);
+            } finally {
+                // reset property-related handler state
+                propertyType = PropertyType.UNDEFINED;
+                multiValuedProperty = false;
+                propValues.clear();
+                name = null;
+                expectingHintValue = false;
+            }
-            mvPropInfo.addValue(value);
+            // multi-valued property
+            // add value to current list, will be processed on endArray() event
+            propValues.add(value);
-        return  (nodeInfos.isEmpty()) ? null : (NodeInfoImpl) nodeInfos.peek();
+        return (nodeInfos.isEmpty()) ? null : (NodeInfoImpl) nodeInfos.peek();
-    private PropertyInfoImpl createPropertyInfo(QValue value, boolean isMultiValued) throws RepositoryException {
-        NodeInfoImpl parent = getCurrentNodeInfo();
-        Path p = pFactory.create(parent.getPath(), name, true);
-        PropertyId id = idFactory.createPropertyId(parent.getId(), name);
-
-        PropertyInfoImpl pInfo;
-        if (isMultiValued) {
-            pInfo = new PropertyInfoImpl(id, p, propertyType);
-            // not added to parent but upon having read all values.
-        } else {
-            pInfo = new PropertyInfoImpl(id, p, propertyType, value);
-            parent.addPropertyInfo(pInfo, idFactory);
-        }
-        itemInfos.add(pInfo);
-        return pInfo;
+    private List<PropertyInfoImpl> getCurrentPropInfos() {
+        return (propInfoLists.isEmpty()) ? null : propInfoLists.peek();
-        Path propertyPath;
-        if (mvPropInfo == null) {
-            propertyPath = pFactory.create(getCurrentNodeInfo().getPath(), name, true);
-        } else {
-            propertyPath = mvPropInfo.getPath();
-        }
+        Path propertyPath = pFactory.create(getCurrentNodeInfo().getPath(), name, true);
-
-    private int guessPropertyType(Name name, Name previousName) {
-        if (name.equals(previousName)) {
-            // property has been previously retrieved from :name : "typeName"
-            // entry in the JSON string. if by coincidence the previous key
-            // is equal but belongs to an JSON object (-> node) the prop type
-            // has been reset to UNDEFINED anyway.
-            return propertyType;
-        } else {
-            // default: determine type upon Property.getType() only.
-            return PropertyType.UNDEFINED;
-        }
-    }

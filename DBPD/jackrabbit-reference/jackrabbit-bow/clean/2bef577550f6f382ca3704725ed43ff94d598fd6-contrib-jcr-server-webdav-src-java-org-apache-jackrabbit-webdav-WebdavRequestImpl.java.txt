JCR-258 - remove JDOM dependency from jcr-server contribution
JCR-295 - usage of Cache-Control header 
JCR-297 - log output while parsing xml
minor consistency issues and improvements

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@368683 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.webdav.header.LabelHeader;
+import org.apache.jackrabbit.webdav.header.OverwriteHeader;
+import org.apache.jackrabbit.webdav.header.TimeoutHeader;
+import org.apache.jackrabbit.webdav.property.DavProperty;
-import org.apache.jackrabbit.webdav.property.DavProperty;
-import org.apache.jackrabbit.webdav.version.DeltaVConstants;
-import org.apache.jackrabbit.util.Text;
+import org.apache.jackrabbit.webdav.xml.DomUtil;
+import org.apache.jackrabbit.webdav.xml.ElementIterator;
-import org.jdom.Document;
-import org.jdom.Element;
-import org.jdom.JDOMException;
-import org.jdom.input.SAXBuilder;
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.xml.sax.SAXException;
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
-import java.util.List;
+    private static final DocumentBuilderFactory BUILDER_FACTORY = DocumentBuilderFactory.newInstance();
-        boolean doOverwrite = true;
-        String overwriteHeader = httpRequest.getHeader(HEADER_OVERWRITE);
-        if (overwriteHeader != null && !overwriteHeader.equalsIgnoreCase(NO_OVERWRITE)) {
-            doOverwrite = false;
-        }
-        return doOverwrite;
+        return new OverwriteHeader(httpRequest).isOverwrite();
-     * Parse the request timeout header and convert the timeout value
-     * into a long indicating the number of milliseconds until expiration time
-     * is reached.<br>
-     * NOTE: If the requested timeout is 'infinite' {@link Long.MAX_VALUE}
-     * is returned.
+     * Parse the Timeout header and return a long representing the value.
+     * {@link #UNDEFINED_TIMEOUT} is used as default value if no header
+     * is available or if the parsing fails.
-     * @return milliseconds the lock is requested to live.
+     * @return milliseconds indicating length of the timeout.
+     * @see TimeoutHeader#parse(javax.servlet.http.HttpServletRequest, long)
-        String timeoutStr = httpRequest.getHeader(HEADER_TIMEOUT);
-        long timeout = UNDEFINED_TIMEOUT;
-        if (timeoutStr != null && timeoutStr.length() > 0) {
-            int secondsInd = timeoutStr.indexOf("Second-");
-            if (secondsInd >= 0) {
-                secondsInd += 7; // read over "Second-"
-                int i = secondsInd;
-                while (i < timeoutStr.length() && Character.isDigit(timeoutStr.charAt(i))) {
-                    i++;
-                }
-                try {
-                    timeout = 1000L * Long.parseLong(timeoutStr.substring(secondsInd, i));
-                } catch (NumberFormatException ignore) {
-                    // ignore an let the lock define the default timeout
-                    log.error("Invalid timeout format: " + timeoutStr);
-                }
-            } else if (timeoutStr.equalsIgnoreCase(TIMEOUT_INFINITE)) {
-                timeout = INFINITE_TIMEOUT;
-            }
-        }
-        return timeout;
+        return TimeoutHeader.parse(httpRequest, UNDEFINED_TIMEOUT).getTimeout();
+        /*
+        Don't attempt to parse the body if the contentlength header is 0
+        NOTE: a value of -1 indicates that the length is unknown, thus we have to parse the body.
+        NOTE that http1.1 request using chunked transfer coding will therefore not be detected here
+        */
+        if (httpRequest.getContentLength() == 0) {
+            return requestDocument;
+        }
-                    SAXBuilder builder = new SAXBuilder(false);
-                    requestDocument = builder.build(in);
+                BUILDER_FACTORY.setNamespaceAware(true);
+                DocumentBuilder docBuilder = BUILDER_FACTORY.newDocumentBuilder();
+                requestDocument = docBuilder.parse(in);
-            } catch (JDOMException e) {
+        } catch (ParserConfigurationException e) {
+        } catch (SAXException e) {
+            log.debug("Unable to build an XML Document from the request body: " + e.getMessage());
-    public int getPropFindType() {
+    public int getPropFindType() throws DavException {
-    public DavPropertyNameSet getPropFindProperties() {
+    public DavPropertyNameSet getPropFindProperties() throws DavException {
-    private void parsePropFindRequest() {
-
+    private void parsePropFindRequest() throws DavException {
-
-        // TODO: spec requires a 'BAD REQUEST' error code
+        // TODO: invalid XML -> spec requires a 'BAD REQUEST' error code
-        // propfind httpRequest with invalid body >> treat as if empty body
-        Element root = requestDocument.getRootElement();
-        if (!root.getName().equals(XML_PROPFIND)) {
+        // propfind httpRequest with invalid body
+        Element root = requestDocument.getDocumentElement();
+        if (!XML_PROPFIND.equals(root.getLocalName())) {
-            return;
+            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "PropFind-Request has no <profind> tag.");
-        List childList = root.getChildren();
-        for (int i = 0; i < childList.size(); i++) {
-            Element child = (Element) childList.get(i);
-            String nodeName = child.getName();
+        ElementIterator it = DomUtil.getChildren(root);
+        while (it.hasNext()) {
+            Element child = it.nextElement();
+            String nodeName = child.getLocalName();
-    public DavPropertySet getPropPatchSetProperties() {
+    public DavPropertySet getPropPatchSetProperties() throws DavException {
-    public DavPropertyNameSet getPropPatchRemoveProperties() {
+    public DavPropertyNameSet getPropPatchRemoveProperties() throws DavException {
-    private void parsePropPatchRequest() {
+    private void parsePropPatchRequest() throws DavException {
-            return;
+            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "Invalid request body.");
-        Element root = requestDocument.getRootElement();
-        if (!root.getName().equals(XML_PROPERTYUPDATE)) {
+        Element root = requestDocument.getDocumentElement();
+        if (!DomUtil.matches(root, XML_PROPERTYUPDATE, NAMESPACE)) {
-            return;
+            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "PropPatch-Request has no <propertyupdate> tag.");
-        List setList = root.getChildren(XML_SET, NAMESPACE);
-        if (!setList.isEmpty()) {
-            Iterator setIter = setList.iterator();
-            while (setIter.hasNext()) {
-                Element propElem = ((Element) setIter.next()).getChild(XML_PROP, NAMESPACE);
-                Iterator it = propElem.getChildren().iterator();
+        ElementIterator it = DomUtil.getChildren(root, XML_SET, NAMESPACE);
-                    Element propertyElem = (Element) it.next();
-                    proppatchSet.add(DefaultDavProperty.createFromXml(propertyElem));
+            Element propEl = DomUtil.getChildElement(it.nextElement(), XML_PROP, NAMESPACE);
+            if (propEl != null) {
+                ElementIterator properties = DomUtil.getChildren(propEl);
+                while (properties.hasNext()) {
+                   proppatchSet.add(DefaultDavProperty.createFromXml(properties.nextElement()));
-        List removeList = root.getChildren(XML_REMOVE, NAMESPACE);
-        if (!removeList.isEmpty()) {
-            Iterator removeIter = removeList.iterator();
-            while (removeIter.hasNext()) {
-                Element propElem = ((Element) removeIter.next()).getChild(XML_PROP, NAMESPACE);
-                Iterator it = propElem.getChildren().iterator();
+        it = DomUtil.getChildren(root, XML_REMOVE, NAMESPACE);
-                    Element propertyElem = (Element) it.next();
-                    proppatchRemove.add(DavPropertyName.createFromXml(propertyElem));
+            Element propEl = DomUtil.getChildElement(it.nextElement(), XML_PROP, NAMESPACE);
+            if (propEl != null) {
+                ElementIterator names = DomUtil.getChildren(propEl);
+                while (names.hasNext()) {
+                    proppatchRemove.add(DavPropertyName.createFromXml(names.nextElement()));
-            Element root = requestDocument.getRootElement();
-            if (root.getName().equals(XML_LOCKINFO)) {
+            Element root = requestDocument.getDocumentElement();
+            if (root.getLocalName().equals(XML_LOCKINFO)) {
-                return new TransactionInfo(requestDocument.getRootElement());
+                return new TransactionInfo(requestDocument.getDocumentElement());
-            Element root = requestDocument.getRootElement();
-            if (ObservationConstants.XML_SUBSCRIPTIONINFO.equals(root.getName())) {
+            Element root = requestDocument.getDocumentElement();
+            if (ObservationConstants.XML_SUBSCRIPTIONINFO.equals(root.getLocalName())) {
-    public OrderPatch getOrderPatch() {
+    public OrderPatch getOrderPatch() throws DavException {
-            Element root = requestDocument.getRootElement();
-            if (!OrderingConstants.XML_ORDERPATCH.equals(root.getName()) ||
-                    root.getChild(OrderingConstants.XML_ORDERING_TYPE) == null) {
-                log.error("ORDERPATH request body must start with an 'orderpatch' element, which must contain an 'ordering-type' child element.");
-                return op;
-            }
-
+            Element root = requestDocument.getDocumentElement();
-                op = new OrderPatch(root);
+                op = OrderPatch.createFromXml(root);
+                throw new DavException(DavServletResponse.SC_BAD_REQUEST);
-        String label = getHeader(DeltaVConstants.HEADER_LABEL);
+        LabelHeader label = LabelHeader.parse(this);
-            label = Text.unescape(label);
+            return label.getLabel();
-        return label;
+        return null;
-            Element root = requestDocument.getRootElement();
+            Element root = requestDocument.getDocumentElement();
-                mInfo = new MergeInfo(requestDocument.getRootElement());
+                mInfo = new MergeInfo(requestDocument.getDocumentElement());
-                uInfo = new UpdateInfo(requestDocument.getRootElement());
+                uInfo = new UpdateInfo(requestDocument.getDocumentElement());
-            rInfo = new ReportInfo(requestDocument.getRootElement(), getDepth(DEPTH_0));
+            rInfo = new ReportInfo(requestDocument.getDocumentElement(), getDepth(DEPTH_0));
-            info = new OptionsInfo(requestDocument.getRootElement());
+            info = OptionsInfo.createFromXml(requestDocument.getDocumentElement());

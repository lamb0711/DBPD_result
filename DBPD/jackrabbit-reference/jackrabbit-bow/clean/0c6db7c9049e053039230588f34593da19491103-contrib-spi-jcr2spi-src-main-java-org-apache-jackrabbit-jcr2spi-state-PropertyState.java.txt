work in progress

- remove 'add' and 'set' methods on NodeState/PropertyState, that were
  used for initialization and did not mark the state modified. this
  was confusing, since similar methods called 'markmodified'.
  replaced by an 'init' method.
- SessionISM: fix options for addMixin (should not check for protected)
- move validation of PropertyState from ItemStateValidator to state.
- add TODO: TransientISM must clean up operations upon status changes.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@453120 13f79535-47bb-0310-9956-ffa450edef68

+import javax.jcr.RepositoryException;
+import javax.jcr.nodetype.ConstraintViolationException;
+import org.apache.jackrabbit.jcr2spi.nodetype.ValueConstraint;
+     *
+     * @param type
+     * @param values
+     */
+    void init(int type, QValue[] values) {
+        this.type = type;
+        this.values = (values == null) ? QValue.EMPTY_ARRAY : values;
+    }
+
+    /**
-     * Sets the type of the property value(s)
-     *
-     * @param type the type to be set
-     * @see PropertyType
-     */
-    void setType(int type) {
-        this.type = type;
-    }
-
-
-    /**
-    void setValues(QValue[] values) {
-        internalSetValues(values);
-        markModified();
-    }
-
-    /**
-     * TODO: rather separate PropertyState into interface and implementation
-     * TODO: and move internalSetValues to implementation only.
-     * Sets the value(s) of this property without marking this property state
-     * as modified.
-     *
-     * @param values the new values
-     */
-    void internalSetValues(QValue[] values) {
+    void setValues(QValue[] values, int type) throws RepositoryException {
+        // make sure the arguements are consistent and do not violate the
+        // given property definition.
+        validate(values, type, this.def);
+        this.type = type;
+        markModified();
+
+    /**
+     * Checks whether the given property parameters are consistent and satisfy
+     * the constraints specified by the given definition. The following
+     * validations/checks are performed:
+     * <ul>
+     * <li>make sure the type is not undefined and matches the type of all
+     * values given</li>
+     * <li>make sure all values have the same type.</li>
+     * <li>check if the type of the property values does comply with the
+     * requiredType specified in the property's definition</li>
+     * <li>check if the property values satisfy the value constraints
+     * specified in the property's definition</li>
+     * </ul>
+     *
+     * @param values
+     * @param propertyType
+     * @param definition
+     * @throws ConstraintViolationException If any of the validations fails.
+     * @throws RepositoryException If another error occurs.
+     */
+    private static void validate(QValue[] values, int propertyType, QPropertyDefinition definition)
+        throws ConstraintViolationException, RepositoryException {
+        if (propertyType == PropertyType.UNDEFINED) {
+            throw new RepositoryException("'Undefined' is not a valid property type for existing values.");
+        }
+        if (definition.getRequiredType() != PropertyType.UNDEFINED && definition.getRequiredType() != propertyType) {
+            throw new ConstraintViolationException("RequiredType constraint is not satisfied");
+        }
+        for (int i = 0; i < values.length; i++) {
+            if (propertyType != values[i].getType()) {
+                throw new ConstraintViolationException("Inconsistent value types: Required type = " + PropertyType.nameFromValue(propertyType) + "; Found value with type = " + PropertyType.nameFromValue(values[i].getType()));
+            }
+        }
+        ValueConstraint.checkValueConstraints(definition, values);
+    }

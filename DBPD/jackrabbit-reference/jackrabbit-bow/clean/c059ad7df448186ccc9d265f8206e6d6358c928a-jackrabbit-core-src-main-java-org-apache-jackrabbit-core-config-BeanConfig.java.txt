JCR-1438: Replace Config classes with factories

Use generics in BeanConfig.newInstance() to avoid the need of class casts.

Use the standard java.beans classes instead of BeanMap for the configured bean properties. This allows better control over value types.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@826653 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.collections.BeanMap;
+import java.beans.BeanInfo;
+import java.beans.IntrospectionException;
+import java.beans.Introspector;
+import java.beans.PropertyDescriptor;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+
-import java.util.Properties;
-import java.util.Map;
-import java.util.HashMap;
-import java.util.Collections;
-import java.io.InputStream;
-import java.io.IOException;
-
-public class BeanConfig<T> {
+public class BeanConfig {
-    public Object newInstance() throws ConfigurationException {
+    @SuppressWarnings("unchecked")
+    public <T> T newInstance(Class<T> klass) throws ConfigurationException {
-            // Instantiate the object using the default constructor
-            Object object = objectClass.newInstance();
+            if (!klass.isAssignableFrom(objectClass)) {
+                throw new ConfigurationException(
+                        "Configured class "+getClassName()
+                        + " does not implement " + klass.getName()
+                        + ". Please fix the repository configuration.");
+            }
+
+            // Instantiate the object using the default constructor
+            Object instance = objectClass.newInstance();
-            BeanMap map = new BeanMap(object);
-            for (Object key : map.keySet()) {
-                String value = properties.getProperty(key.toString());
+            List<?> names = Collections.list(properties.propertyNames());
+            BeanInfo info = Introspector.getBeanInfo(objectClass, Object.class);
+            for (PropertyDescriptor property : info.getPropertyDescriptors()) {
+                String value = properties.getProperty(property.getName());
-                    map.put(key, value);
+                    setProperty(instance, property, value);
+                    names.remove(property.getName());
-            if (validate) {
-                // Check that no invalid property names were configured
-                for (Object key : properties.keySet()) {
-                    if (!map.containsKey(key)
-                            && properties.getProperty(key.toString()) != null) {
-                        String msg =
-                            "Configured class " + object.getClass().getName()
-                            + " does not contain the property " + key
-                            + ". Please fix the repository configuration.";
-                        log.error(msg);
-                        throw new ConfigurationException(msg);
-                    }
-                }
+            // Check that no invalid property names were configured
+            if (validate && !names.isEmpty()) {
+                throw new ConfigurationException(
+                        "Configured class " + getClassName()
+                        + " does not contain the properties " + names);
-            return (T) object;
+            return (T) instance;
+        } catch (IntrospectionException e) {
+            throw new ConfigurationException(
+                    "Configured bean implementation class " + getClassName()
+                    + " can not be introspected", e);
+        }
+    }
+
+    private void setProperty(
+            Object instance, PropertyDescriptor property, String value)
+            throws ConfigurationException {
+        Method method = property.getWriteMethod();
+        if (method == null) {
+            throw new ConfigurationException(
+                    "Property " + property.getName() + " of class "
+                    + getClassName() + " can not be written"); 
+        }
+
+        Class<?>[] types = method.getParameterTypes();
+        if (types.length != 1) {
+            throw new ConfigurationException(
+                    "Property " + property.getName() + " of class "
+                    + getClassName() + " has an invalid setter");
+        }
+
+        Class<?> type = types[0];
+        try {
+            if (types[0].isAssignableFrom(String.class)
+                || types[0].isAssignableFrom(Object.class)) {
+                method.invoke(instance, value);
+            } else if (types[0].isAssignableFrom(Boolean.TYPE)
+                    || types[0].isAssignableFrom(Boolean.class)) {
+                method.invoke(instance, Boolean.valueOf(value));
+            } else if (types[0].isAssignableFrom(Integer.TYPE)
+                    || types[0].isAssignableFrom(Integer.class)) {
+                method.invoke(instance, Integer.valueOf(value));
+            } else if (types[0].isAssignableFrom(Long.TYPE)
+                    || types[0].isAssignableFrom(Long.class)) {
+                method.invoke(instance, Long.valueOf(value));
+            } else if (types[0].isAssignableFrom(Double.TYPE)
+                    || types[0].isAssignableFrom(Double.class)) {
+                method.invoke(instance, Double.valueOf(value));
+            } else {
+                throw new ConfigurationException(
+                        "The type (" + type.getName()
+                        + ") of property " + property.getName() + " of class "
+                        + getClassName() + " is not supported");
+            }
+        } catch (NumberFormatException e) {
+            throw new ConfigurationException(
+                    "Invalid number format (" + value + ") for property "
+                    + property.getName() + " of class " + getClassName(), e);
+        } catch (InvocationTargetException e) {
+            throw new ConfigurationException(
+                    "Property " + property.getName() + " of class "
+                    + getClassName() + " can not be set to \"" + value + "\"",
+                    e);
+        } catch (IllegalAccessException e) {
+            throw new ConfigurationException(
+                    "The setter of property " + property.getName()
+                    + " of class " + getClassName() + " can not be accessed",
+                    e);
+        } catch (IllegalArgumentException e) {
+            throw new ConfigurationException(
+                    "Unable to call the setter of property "
+                    + property.getName() + " of class " + getClassName(), e);

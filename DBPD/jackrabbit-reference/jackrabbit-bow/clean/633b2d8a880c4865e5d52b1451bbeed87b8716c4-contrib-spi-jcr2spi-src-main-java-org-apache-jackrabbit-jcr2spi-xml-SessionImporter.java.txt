fixed: move, reorder (work in progress)
fixed: locktoken transfer
fixed: recursive transient removal of invalidated tree fails (restoreTests)
improve: simplify usage of workspace operations
fixed: store original itemId with transient operations in order to properly reflect the changelog upon batch creation
fixed: workspace import doesn't invalidate
fixed: session import uuid handling




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@513279 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeConflictException;
+import org.apache.jackrabbit.uuid.UUID;
+import java.util.Arrays;
+import java.util.ArrayList;
+
-           // a valid child node with that name already exists...
-           NodeEntry entry = parentEntry.getNodeEntry(nodeInfo.getName(), Path.INDEX_DEFAULT);
-           NodeState existing = null;
-               existing = entry.getNodeState();
+               // a valid child node with that name already exists
+               NodeEntry entry = parentEntry.getNodeEntry(nodeInfo.getName(), Path.INDEX_DEFAULT);
+               NodeState existing = entry.getNodeState();
+
+               QNodeDefinition def = existing.getDefinition();
+               if (!def.allowsSameNameSiblings()) {
+                   // existing doesn't allow same-name siblings, check for conflicts
+                   EffectiveNodeType entExisting = session.getValidator().getEffectiveNodeType(existing);
+                   if (def.isProtected() && entExisting.includesNodeType(nodeInfo.getNodeTypeName()))
+                   {
+                       // skip protected node
+                       parents.push(null); // push null onto stack for skipped node
+                       log.debug("skipping protected node " + LogUtil.safeGetJCRPath(existing, session.getNamespaceResolver()));
+                       return;
+                   }
+                   if (def.isAutoCreated() && entExisting.includesNodeType(nodeInfo.getNodeTypeName()))
+                   {
+                       // this node has already been auto-created, no need to create it
+                       nodeState = existing;
+                   } else {
+                       throw new ItemExistsException(LogUtil.safeGetJCRPath(existing, session.getNamespaceResolver()));
+                   }
+               }
+           } catch (NoSuchItemStateException e) {
+               // 'existing' doesn't exist any more -> ignore
-               // should not occur. existance has been checked before
-               throw new RepositoryException(e);
-           }
-           QNodeDefinition def = existing.getDefinition();
-           if (!def.allowsSameNameSiblings()) {
-               // existing doesn't allow same-name siblings, check for conflicts
-               EffectiveNodeType entExisting = session.getValidator().getEffectiveNodeType(existing);
-               if (def.isProtected() && entExisting.includesNodeType(nodeInfo.getNodeTypeName())) {
-                   // skip protected node
-                   parents.push(null); // push null onto stack for skipped node
-                   log.debug("skipping protected node " + LogUtil.safeGetJCRPath(existing, session.getNamespaceResolver()));
-                   return;
-               }
-               if (def.isAutoCreated() && entExisting.includesNodeType(nodeInfo.getNodeTypeName())) {
-                   // this node has already been auto-created, no need to create it
-                   nodeState = existing;
-               } else {
-                   throw new ItemExistsException(LogUtil.safeGetJCRPath(existing, session.getNamespaceResolver()));
-               }
+               // undefined internal error
+               String msg = "Internal error. Failed to retrieve existing nodeState.";
+               log.debug(msg);
+               throw new RepositoryException(msg, e);
+               // make sure the import does not define a uuid without having
+               // a primaryType or mixin that makes the new node referenceable
+               checkIncludesMixReferenceable(nodeInfo);
+
-                   String msg = "Internal error: failed to retrieve node state";
+                   String msg = "Internal error: failed to retrieve conflicting node state";
+                String newUUID = UUID.randomUUID().toString();
-                nodeInfo.setUUID(null);
+                nodeInfo.setUUID(newUUID);
-                    EffectiveNodeType ent = session.getValidator().getEffectiveNodeType(nodeState);
-                    if (ent.includesNodeType(QName.MIX_REFERENCEABLE)) {
-                        refTracker.mappedUUIDs(originalUUID, nodeState.getUniqueID());
-                    }
+                    refTracker.mappedUUIDs(originalUUID, newUUID);
-                Operation op = Remove.create(conflicting.getNodeState(), parent);
+                Operation op = Remove.create(conflicting.getNodeState());
-                op = Remove.create(conflicting.getNodeState(), parent);
+                op = Remove.create(conflicting.getNodeState());
-                    Operation rm = Remove.create(conflicting, parent);
+                    Operation rm = Remove.create(conflicting);
+
+    /**
+     * Validate the given <code>NodeInfo</code>: make sure, that if a uuid is
+     * defined, the primary or the mixin types include mix:referenceable.
+     *
+     * @param nodeInfo
+     * @throws RepositoryException
+     */
+    private void checkIncludesMixReferenceable(Importer.NodeInfo nodeInfo) throws RepositoryException {
+        List l = new ArrayList();
+        l.add(nodeInfo.getNodeTypeName());
+        l.addAll(Arrays.asList(nodeInfo.getMixinNames()));
+        if (l.contains(QName.MIX_REFERENCEABLE)) {
+            // shortcut
+            return;
+        }
+        QName[] ntNames = (QName[]) l.toArray(new QName[l.size()]);
+        try {
+            EffectiveNodeType ent = session.getValidator().getEffectiveNodeType(ntNames);
+            if (!ent.includesNodeType(QName.MIX_REFERENCEABLE)) {
+                throw new ConstraintViolationException("XML defines jcr:uuid without defining import node to be referenceable.");
+            }
+        } catch (NodeTypeConflictException e) {
+            throw new RepositoryException("Internal error", e);
+        }
+    }

Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.state.entry.ChildNodeEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.NodeEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.PropertyEntry;
-    public static final int CHECK_REFERENCES = 16;
-
-    /**
-     * option for <code>{@link #checkRemoveItem}</code> method:<p/>
-     * check that target node is not being referenced
-     */
-    public static final int CHECK_ALL = CHECK_ACCESS | CHECK_LOCK | CHECK_VERSIONING | CHECK_CONSTRAINTS | CHECK_COLLISION | CHECK_REFERENCES;
+    public static final int CHECK_ALL = CHECK_ACCESS | CHECK_LOCK | CHECK_VERSIONING | CHECK_CONSTRAINTS | CHECK_COLLISION;
-    public void validate(NodeState nodeState)
-            throws ConstraintViolationException, RepositoryException {
+    public void validate(NodeState nodeState) throws ConstraintViolationException,
+        RepositoryException {
-            if (!nodeState.hasChildNodeEntry(cnd.getQName())) {
+            if (!nodeState.getNodeEntry().hasNodeEntry(cnd.getQName())) {
-        QPropertyDefinition def = propState.getDefinition();
-        checkWriteProperty(propState.getParent(), propState.getQName(), def, options);
+        try {
+            NodeState parent = propState.getParent();
+            QPropertyDefinition def = propState.getDefinition();
+            checkWriteProperty(parent, propState.getQName(), def, options);
+        } catch (NoSuchItemStateException e) {
+            throw new ItemNotFoundException(e);
+        } catch (ItemStateException e) {
+            throw new RepositoryException(e);
+        }
-    public void checkWriteProperty(NodeState parentState, QName propertyName, QPropertyDefinition definition, int options)
+    private void checkWriteProperty(NodeState parentState, QName propertyName, QPropertyDefinition definition, int options)
-     *                    <li><code>{@link #CHECK_REFERENCES}</code>:
-     *                    make sure no references exist on target node</li>
-        // NOTE: referencial integrity should be asserted for all child-nodes.
-        NodeState parentState = targetState.getParent();
-        if (parentState == null) {
+        if (targetState.isNode() && ((NodeState)targetState).isRoot()) {
-        checkIsWritable(parentState, options);
+        try {
+            checkIsWritable(targetState.getParent(), options);
+        } catch (NoSuchItemStateException e) {
+            throw new ItemNotFoundException(e);
+        } catch (ItemStateException e) {
+            throw new RepositoryException(e);
+        }
-                    throw new AccessDeniedException(safeGetJCRPath(targetState)
-                            + ": not allowed to remove node");
+                    throw new AccessDeniedException(safeGetJCRPath(targetState) + ": not allowed to remove node");
-                String msg = "internal error: failed to check access rights for "
-                        + safeGetJCRPath(targetState);
+                String msg = "internal error: failed to check access rights for " + safeGetJCRPath(targetState);
-        // check referential integrity of state to be deleted
-        if ((options & CHECK_REFERENCES) == CHECK_REFERENCES) {
-            checkReferences(targetState);
-        }
-        NodeState nodeState = (itemState.isNode()) ? (NodeState)itemState : itemState.getParent();
-        mgrProvider.getVersionManager().checkIsCheckedOut(nodeState);
+        try {
+            NodeState nodeState = (itemState.isNode()) ? (NodeState)itemState : itemState.getParent();
+            mgrProvider.getVersionManager().checkIsCheckedOut(nodeState);
+        } catch (NoSuchItemStateException e) {
+            throw new ItemNotFoundException(e);
+        } catch (ItemStateException e) {
+            throw new RepositoryException(e);
+        }
-    private void checkLock(ItemState itemState)
-            throws LockException, RepositoryException {
-        // make sure there's no foreign lock present the node (or the parent node
-        // in case the state represents a PropertyState).
-        NodeState nodeState = (itemState.isNode()) ? ((NodeState)itemState) : itemState.getParent();
-        mgrProvider.getLockManager().checkLock(nodeState);
+    private void checkLock(ItemState itemState) throws LockException, RepositoryException {
+        try {
+            // make sure there's no foreign lock present the node (or the parent node
+            // in case the state represents a PropertyState).
+            NodeState nodeState = (itemState.isNode()) ? ((NodeState)itemState) : itemState.getParent();
+            mgrProvider.getLockManager().checkLock(nodeState);
+        } catch (NoSuchItemStateException e) {
+            throw new ItemNotFoundException(e);
+        } catch (ItemStateException e) {
+            throw new RepositoryException(e);
+        }
+        NodeEntry parentEntry = (NodeEntry) parentState.getHierarchyEntry();
-        if (parentState.hasChildNodeEntry(propertyName)) {
-            String msg = "there's already a child node with name " + propertyName;
+        if (parentEntry.hasNodeEntry(propertyName)) {
+            String msg = "Child node with name '" + propertyName + "' already exists.";
-        if (parentState.hasPropertyName(propertyName)) {
-            PropertyState errorState = null;
+        PropertyEntry pe = parentEntry.getPropertyEntry(propertyName);
+        if (pe != null) {
-                errorState = parentState.getPropertyState(propertyName);
+                pe.getPropertyState();
-            throw new ItemExistsException(safeGetJCRPath(errorState));
+            throw new ItemExistsException("Property '" + pe.getQName() + "' already exists.");
-        } else if (parentState.hasChildNodeEntry(nodeName)) {
+        } else if (parentState.hasChildNodeEntry(nodeName, Path.INDEX_DEFAULT)) {
-                ChildNodeEntry cne = parentState.getChildNodeEntry(nodeName, Path.INDEX_DEFAULT);
-                // cne must not be null, since existence has been checked before
-                NodeState conflictingState = cne.getNodeState();
+                NodeState conflictingState = parentState.getChildNodeState(nodeName, Path.INDEX_DEFAULT);
-
-    /**
-     *
-     * @param toDelete
-     * @throws ReferentialIntegrityException
-     * @throws RepositoryException
-     */
-    private void checkReferences(ItemState toDelete) throws ReferentialIntegrityException, RepositoryException {
-        if (!toDelete.isNode()) {
-            // PropertyState: nothing to do.
-            return;
-        }
-
-        NodeState targetState = (NodeState)toDelete;
-        EffectiveNodeType ent = getEffectiveNodeType(targetState);
-        if (ent.includesNodeType(QName.MIX_REFERENCEABLE)) {
-            ItemStateManager stateMgr = mgrProvider.getItemStateManager();
-            if (stateMgr.hasReferingStates(targetState)) {
-                throw new ReferentialIntegrityException(safeGetJCRPath(targetState) + ": cannot remove node with references");
-            }
-        }
-    }

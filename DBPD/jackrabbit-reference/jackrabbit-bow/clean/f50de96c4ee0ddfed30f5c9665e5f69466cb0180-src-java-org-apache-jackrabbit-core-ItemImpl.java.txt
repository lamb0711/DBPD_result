bug fix: mixin types were not taken into account on checking mandatory child items

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@155794 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.nodetype.NodeDefImpl;
-import org.apache.jackrabbit.core.nodetype.NodeTypeImpl;
-import org.apache.jackrabbit.core.nodetype.PropertyDefImpl;
+import org.apache.jackrabbit.core.nodetype.*;
-import org.apache.jackrabbit.core.state.ItemState;
-import org.apache.jackrabbit.core.state.ItemStateException;
-import org.apache.jackrabbit.core.state.ItemStateListener;
-import org.apache.jackrabbit.core.state.NodeReferences;
-import org.apache.jackrabbit.core.state.NodeReferencesId;
-import org.apache.jackrabbit.core.state.NodeState;
-import org.apache.jackrabbit.core.state.PropertyState;
-import org.apache.jackrabbit.core.state.SessionItemStateManager;
+import org.apache.jackrabbit.core.state.*;
-import javax.jcr.AccessDeniedException;
-import javax.jcr.InvalidItemStateException;
-import javax.jcr.Item;
-import javax.jcr.ItemNotFoundException;
-import javax.jcr.ItemVisitor;
-import javax.jcr.Node;
-import javax.jcr.PathNotFoundException;
-import javax.jcr.PropertyType;
-import javax.jcr.ReferentialIntegrityException;
-import javax.jcr.RepositoryException;
-import javax.jcr.Session;
+import javax.jcr.*;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
+import java.util.*;
-                NodeTypeImpl nt = (NodeTypeImpl) node.getPrimaryNodeType();
+                // primary type
+                NodeTypeImpl pnt = (NodeTypeImpl) node.getPrimaryNodeType();
+                // effective node type (primary type incl. mixins)
+                EffectiveNodeType ent = node.getEffectiveNodeType();
-                NodeType[] nta = def.getRequiredPrimaryTypes();
-                for (int i = 0; i < nta.length; i++) {
-                    NodeTypeImpl ntReq = (NodeTypeImpl) nta[i];
-                    if (nodeState.getStatus() == ItemState.STATUS_NEW
-                            && !(nt.getQName().equals(ntReq.getQName())
-                            || nt.isDerivedFrom(ntReq.getQName()))) {
-                        /**
-                         * the transient node's node type does not satisfy the
-                         * 'required primary types' constraint
-                         */
-                        String msg = node.safeGetJCRPath() + " must be of node type " + ntReq.getName();
-                        log.warn(msg);
-                        throw new ConstraintViolationException(msg);
+                if (nodeState.getStatus() == ItemState.STATUS_NEW) {
+                    NodeType[] nta = def.getRequiredPrimaryTypes();
+                    for (int i = 0; i < nta.length; i++) {
+                        NodeTypeImpl ntReq = (NodeTypeImpl) nta[i];
+                        if (!(pnt.getQName().equals(ntReq.getQName())
+                                || pnt.isDerivedFrom(ntReq.getQName()))) {
+                            /**
+                             * the transient node's primary node type does not
+                             * satisfy the 'required primary types' constraint
+                             */
+                            String msg = node.safeGetJCRPath() + " must be of node type " + ntReq.getName();
+                            log.warn(msg);
+                            throw new ConstraintViolationException(msg);
+                        }
-                PropertyDef[] propDefs = nt.getMandatoryPropertyDefs();
-                for (int i = 0; i < propDefs.length; i++) {
-                    PropertyDefImpl pd = (PropertyDefImpl) propDefs[i];
-                    if (!nodeState.hasPropertyEntry(pd.getQName())) {
+                PropDef[] pda = ent.getMandatoryPropDefs();
+                for (int i = 0; i < pda.length; i++) {
+                    PropDef pd = pda[i];
+                    if (!nodeState.hasPropertyEntry(pd.getName())) {
-                NodeDef[] nodeDefs = nt.getMandatoryNodeDefs();
-                for (int i = 0; i < nodeDefs.length; i++) {
-                    NodeDefImpl nd = (NodeDefImpl) nodeDefs[i];
-                    if (!nodeState.hasChildNodeEntry(nd.getQName())) {
-                        String msg = node.safeGetJCRPath() + ": mandatory child node " + nd.getName() + " does not exist";
+                ChildNodeDef[] cnda = ent.getMandatoryNodeDefs();
+                for (int i = 0; i < cnda.length; i++) {
+                    ChildNodeDef cnd = cnda[i];
+                    if (!nodeState.hasChildNodeEntry(cnd.getName())) {
+                        String msg = node.safeGetJCRPath() + ": mandatory child node " + cnd.getName() + " does not exist";

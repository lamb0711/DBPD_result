- Implement ItemState.revert() and use in SessionItemStateManager.undo()
- Removed some JR diffs

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@432582 13f79535-47bb-0310-9956-ffa450edef68

-    // DIFF JACKRABBIT: private final TransientItemStateManager transientStateMgr;
-        // DIFF JACKRABBIT: this.transientStateMgr = new TransientItemStateManager();
-        if (itemState.getParent() == null) {
-            // optimization for root
-            transientStateMgr.disposeAllItemStates();
-            return;
-        }
+        // TODO: check if self contained
-        // list of transient items that should be discarded
+        Set affectedItemStates = new HashSet();
+        itemState.revert(affectedItemStates);
+
-
-        // check status of current item's state
-        if (itemState.isTransient()) {
-            switch (itemState.getStatus()) {
-                // safety... should have been checked befoe
-                case ItemState.STATUS_NEW:
-                    throw new ItemStateException("Unexpected state: cannot start undo from a new item state.");
-
-                case ItemState.STATUS_STALE_MODIFIED:
-                case ItemState.STATUS_STALE_DESTROYED:
-                case ItemState.STATUS_EXISTING_MODIFIED:
-                    // add this item's state to the list
-                    changeLog.modified(itemState);
-                    break;
-                default:
-                    log.debug("unexpected state status (" + itemState.getStatus() + ")");
-                    // ignore
-                    break;
-            }
-        }
-
-        if (itemState.isNode()) {
-            NodeState nodeState = (NodeState)itemState;
-            // build list of 'new', 'modified' or 'stale' descendants
-            Iterator iter = getDescendantTransientItemStates(nodeState);
-            while (iter.hasNext()) {
-                ItemState childState = (ItemState) iter.next();
-                switch (childState.getStatus()) {
-                    case ItemState.STATUS_STALE_MODIFIED:
-                    case ItemState.STATUS_STALE_DESTROYED:
-                    case ItemState.STATUS_NEW:
-                    case ItemState.STATUS_EXISTING_MODIFIED:
-                        // add new or modified state to the list
-                        changeLog.modified(childState);
-                        break;
-
-                    default:
-                        log.debug("unexpected state status (" + childState.getStatus() + ")");
-                        // ignore
-                        break;
-                }
-            }
-
-            // build list of deleted states
-            Iterator atticIter = getDescendantTransientItemStatesInAttic(nodeState);
-            while (atticIter.hasNext()) {
-                ItemState transientState = (ItemState) atticIter.next();
-                changeLog.deleted(transientState);
-            }
-        }
-
-        /**
-         * build set of item id's which are within the scope of
-         * (i.e. affected by) this cancel operation
-         */
-        Set affectedStates = new HashSet();
-        Iterator it = new IteratorChain(changeLog.modifiedStates(), changeLog.deletedStates());
-        while (it.hasNext()) {
-            affectedStates.add(it.next());
-        }
-        collectOperations(affectedStates, changeLog);
-
-        // process list of 'new', 'modified' or 'stale' transient states
-        Iterator transIter = changeLog.modifiedStates();
-        while (transIter.hasNext()) {
-            // dispose the transient state, it is no longer used;
-            // this will indirectly (through stateDiscarded listener method)
-            // either restore or permanently invalidate the wrapping Item instances
-            ItemState transientState = (ItemState) transIter.next();
-            transientStateMgr.disposeItemState(transientState);
-        }
-        // process list of deleted states
-        Iterator remIter = changeLog.deletedStates();
-        while (remIter.hasNext()) {
-            ItemState rmState = (ItemState) remIter.next();
-            // dispose the transient state; this will indirectly (through
-            // stateDiscarded listener method) resurrect the wrapping Item instances
-            transientStateMgr.disposeItemStateInAttic(rmState);
-        }
+        collectOperations(affectedItemStates, changeLog);
-        Iterator opIter = changeLog.getOperations();
-        while (opIter.hasNext()) {
-            transientStateMgr.removeOperation((Operation) opIter.next());
-        }
+        transientStateMgr.disposeOperations(changeLog.getOperations());
-        // DIFF JACKRABBIT: if (!transientStateMgr.hasAnyItemStatesInAttic()) {

work in progress

- minor improvement and some sync



git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@497068 13f79535-47bb-0310-9956-ffa450edef68

+import EDU.oswego.cs.dl.util.concurrent.ConcurrentReaderHashMap;
+
-    private final HashMap registeredNTDefs;
+    private final ConcurrentReaderHashMap registeredNTDefs;
-    // map of id's and property definitions
+    // set of property definitions
-    // map of id's and node definitions
+    // set of node definitions
-        registeredNTDefs = new HashMap();
+        registeredNTDefs = new ConcurrentReaderHashMap();
-        nodeDefs.add(rootNodeDef);
+        synchronized (nodeDefs) {
+            nodeDefs.add(rootNodeDef);
+        }
-    public synchronized QName[] getRegisteredNodeTypes() {
+    public QName[] getRegisteredNodeTypes() {
-    public synchronized boolean isRegistered(QName nodeTypeName) {
+    public boolean isRegistered(QName nodeTypeName) {
-    public synchronized EffectiveNodeType getEffectiveNodeType(QName[] ntNames,
-                                                               Map ntdMap)
+    public EffectiveNodeType getEffectiveNodeType(QName[] ntNames, Map ntdMap)
-     * @param anEntCache
-     * @param aRegisteredNTDefCache
+     * @param entCache
+     * @param ntdCache
-    private synchronized EffectiveNodeType getEffectiveNodeType(QName ntName,
-                                                               EffectiveNodeTypeCache anEntCache,
-                                                               Map aRegisteredNTDefCache)
-            throws NoSuchNodeTypeException {
+    private EffectiveNodeType getEffectiveNodeType(QName ntName,
+                                                   EffectiveNodeTypeCache entCache,
+                                                   Map ntdCache)
+        throws NoSuchNodeTypeException {
-        EffectiveNodeType ent = anEntCache.get(new QName[]{ntName});
+        EffectiveNodeType ent = entCache.get(new QName[]{ntName});
-        // 2. make sure that the specified node type exists
-        if (!aRegisteredNTDefCache.containsKey(ntName)) {
+        // 2. make sure we've got the definition of the specified node type
+        QNodeTypeDefinition ntd = (QNodeTypeDefinition) ntdCache.get(ntName);
+        if (ntd == null) {
-        try {
-            QNodeTypeDefinition ntd = (QNodeTypeDefinition) aRegisteredNTDefCache.get(ntName);
-            ent = EffectiveNodeTypeImpl.create(this, ntd, aRegisteredNTDefCache);
-            // store new effective node type
-            anEntCache.put(ent);
-            return ent;
-        } catch (NodeTypeConflictException ntce) {
-            // should never get here as all registered node types have to be valid!
-            String msg = "internal error: encountered invalid registered node type " + ntName;
-            log.debug(msg);
-            throw new NoSuchNodeTypeException(msg, ntce);
+        synchronized (entCache) {
+            try {
+                ent = EffectiveNodeTypeImpl.create(this, ntd, ntdCache);
+                // store new effective node type
+                entCache.put(ent);
+                return ent;
+            } catch (NodeTypeConflictException ntce) {
+                // should never get here as all known node types should be valid!
+                String msg = "internal error: encountered invalid registered node type " + ntName;
+                log.debug(msg);
+                throw new NoSuchNodeTypeException(msg, ntce);
+            }
-     * @param anEntCache
-     * @param aRegisteredNTDefCache
+     * @param entCache
+     * @param ntdCache
-    private synchronized EffectiveNodeType getEffectiveNodeType(QName[] ntNames,
-                                                               EffectiveNodeTypeCache anEntCache,
-                                                               Map aRegisteredNTDefCache)
-            throws NodeTypeConflictException, NoSuchNodeTypeException {
+    private EffectiveNodeType getEffectiveNodeType(QName[] ntNames,
+                                                   EffectiveNodeTypeCache entCache,
+                                                   Map ntdCache)
+        throws NodeTypeConflictException, NoSuchNodeTypeException {
-        EffectiveNodeTypeCache.WeightedKey key =
-                new EffectiveNodeTypeCache.WeightedKey(ntNames);
+        EffectiveNodeTypeCache.WeightedKey key = new EffectiveNodeTypeCache.WeightedKey(ntNames);
-        if (anEntCache.contains(key)) {
-            return anEntCache.get(key);
+        if (entCache.contains(key)) {
+            return entCache.get(key);
-        // 2. make sure every single node type exists
+        // 2. make sure we've got the definitions of the specified node types
-            if (!aRegisteredNTDefCache.containsKey(ntNames[i])) {
+            if (!ntdCache.containsKey(ntNames[i])) {
+
-
-        // build list of 'best' existing sub-aggregates
-        ArrayList tmpResults = new ArrayList();
-        while (key.getNames().length > 0) {
-            // check if we've already built this aggregate
-            if (anEntCache.contains(key)) {
-                tmpResults.add(anEntCache.get(key));
-                // subtract the result from the temporary key
-                // (which is 'empty' now)
-                key = key.subtract(key);
-                break;
-            }
-            /**
-             * walk list of existing aggregates sorted by 'weight' of
-             * aggregate (i.e. the cost of building it)
-             */
-            boolean foundSubResult = false;
-            Iterator iter = anEntCache.keyIterator();
-            while (iter.hasNext()) {
-                EffectiveNodeTypeCache.WeightedKey k =
-                        (EffectiveNodeTypeCache.WeightedKey) iter.next();
-                /**
-                 * check if the existing aggregate is a 'subset' of the one
-                 * we're looking for
-                 */
-                if (key.contains(k)) {
-                    tmpResults.add(anEntCache.get(k));
+        synchronized (entCache) {
+            // build list of 'best' existing sub-aggregates
+            ArrayList tmpResults = new ArrayList();
+            while (key.getNames().length > 0) {
+                // check if we've already built this aggregate
+                if (entCache.contains(key)) {
+                    tmpResults.add(entCache.get(key));
-                    key = key.subtract(k);
-                    foundSubResult = true;
+                    // (which is 'empty' now)
+                    key = key.subtract(key);
+                    break;
+                }
+                /**
+                 * walk list of existing aggregates sorted by 'weight' of
+                 * aggregate (i.e. the cost of building it)
+                 */
+                boolean foundSubResult = false;
+                Iterator iter = entCache.keyIterator();
+                while (iter.hasNext()) {
+                    EffectiveNodeTypeCache.WeightedKey k =
+                            (EffectiveNodeTypeCache.WeightedKey) iter.next();
+                    /**
+                     * check if the existing aggregate is a 'subset' of the one
+                     * we're looking for
+                     */
+                    if (key.contains(k)) {
+                        tmpResults.add(entCache.get(k));
+                        // subtract the result from the temporary key
+                        key = key.subtract(k);
+                        foundSubResult = true;
+                        break;
+                    }
+                }
+                if (!foundSubResult) {
+                    /**
+                     * no matching sub-aggregates found:
+                     * build aggregate of remaining node types through iteration
+                     */
+                    QName[] remainder = key.getNames();
+                    for (int i = 0; i < remainder.length; i++) {
+                        QNodeTypeDefinition ntd = (QNodeTypeDefinition) ntdCache.get(remainder[i]);
+                        EffectiveNodeTypeImpl ent = EffectiveNodeTypeImpl.create(this, ntd, ntdCache);
+                        // store new effective node type
+                        entCache.put(ent);
+                        if (result == null) {
+                            result = ent;
+                        } else {
+                            result = result.merge(ent);
+                            // store intermediate result (sub-aggregate)
+                            entCache.put(result);
+                        }
+                    }
+                    // add aggregate of remaining node types to result list
+                    tmpResults.add(result);
-            if (!foundSubResult) {
-                /**
-                 * no matching sub-aggregates found:
-                 * build aggregate of remaining node types through iteration
-                 */
-                QName[] remainder = key.getNames();
-                for (int i = 0; i < remainder.length; i++) {
-                    QNodeTypeDefinition ntd = (QNodeTypeDefinition) aRegisteredNTDefCache.get(remainder[i]);
-                    EffectiveNodeTypeImpl ent =
-                            EffectiveNodeTypeImpl.create(this, ntd, aRegisteredNTDefCache);
-                    // store new effective node type
-                    anEntCache.put(ent);
-                    if (result == null) {
-                        result = ent;
-                    } else {
-                        result = result.merge(ent);
-                        // store intermediate result (sub-aggregate)
-                        anEntCache.put(result);
-                    }
+            // merge the sub-aggregates into new effective node type
+            for (int i = 0; i < tmpResults.size(); i++) {
+                if (result == null) {
+                    result = (EffectiveNodeTypeImpl) tmpResults.get(i);
+                } else {
+                    result = result.merge((EffectiveNodeTypeImpl) tmpResults.get(i));
+                    // store intermediate result
+                    entCache.put(result);
-                // add aggregate of remaining node types to result list
-                tmpResults.add(result);
-                break;
-            }
-        }
-        // merge the sub-aggregates into new effective node type
-        for (int i = 0; i < tmpResults.size(); i++) {
-            if (result == null) {
-                result = (EffectiveNodeTypeImpl) tmpResults.get(i);
-            } else {
-                result = result.merge((EffectiveNodeTypeImpl) tmpResults.get(i));
-                // store intermediate result
-                anEntCache.put(result);
-    public synchronized void unregisterNodeType(QName nodeTypeName)
-            throws NoSuchNodeTypeException, RepositoryException {
-
-        // perform basic validation
-        if (!registeredNTDefs.containsKey(nodeTypeName)) {
-            throw new NoSuchNodeTypeException(nodeTypeName.toString());
-        }
-
-        /**
-         * check if there are node types that have dependencies on the given
-         * node type
-         */
-        if (hasDependentNodeTypes(nodeTypeName)) {
-            StringBuffer msg = new StringBuffer();
-            msg.append(nodeTypeName + " could not be removed because registered node types are still referencing it.");
-            throw new RepositoryException(msg.toString());
-        }
-
-        // persist removal of node type definition
-        // NOTE: conflict with existing content not asserted on client
-        storage.unregisterNodeTypes(new QName[] {nodeTypeName});
-
-        // update internal cache
-        internalUnregister(nodeTypeName);
-
-        // notify listeners
-        notifyUnregistered(nodeTypeName);
+    public void unregisterNodeType(QName nodeTypeName) throws NoSuchNodeTypeException, RepositoryException {
+        HashSet ntNames = new HashSet();
+        ntNames.add(nodeTypeName);
+        unregisterNodeTypes(ntNames);
-    public synchronized QNodeTypeDefinition getNodeTypeDefinition(QName nodeTypeName)
-            throws NoSuchNodeTypeException {
-        if (!registeredNTDefs.containsKey(nodeTypeName)) {
+    public QNodeTypeDefinition getNodeTypeDefinition(QName nodeTypeName)
+        throws NoSuchNodeTypeException {
+        QNodeTypeDefinition def = (QNodeTypeDefinition) registeredNTDefs.get(nodeTypeName);
+        if (def == null) {
-        QNodeTypeDefinition def = (QNodeTypeDefinition) registeredNTDefs.get(nodeTypeName);
-        for (int i = 0; i < pda.length; i++) {
-            propDefs.add(pda[i]);
+        synchronized (propDefs) {
+            for (int i = 0; i < pda.length; i++) {
+                propDefs.add(pda[i]);
+            }
-        for (int i = 0; i < nda.length; i++) {
-            nodeDefs.add(nda[i]);
+        synchronized (nodeDefs) {
+            for (int i = 0; i < nda.length; i++) {
+                nodeDefs.add(nda[i]);
+            }
-        for (int i = 0; i < pda.length; i++) {
-            propDefs.remove(pda[i]);
+        synchronized (propDefs) {
+            for (int i = 0; i < pda.length; i++) {
+                propDefs.remove(pda[i]);
+            }
-        QNodeDefinition[] nda = ntd.getChildNodeDefs();
-        for (int i = 0; i < nda.length; i++) {
-            nodeDefs.remove(nda[i]);
+        synchronized (nodeDefs) {
+            QNodeDefinition[] nda = ntd.getChildNodeDefs();
+            for (int i = 0; i < nda.length; i++) {
+                nodeDefs.remove(nda[i]);
+            }
-    /**
-     * Returns the names of those registered node types that have
-     * dependencies on the given node type.
-     *
-     * @param nodeTypeName
-     * @return a set of node type <code>QName</code>s
-     * @throws NoSuchNodeTypeException
-     */
-    private synchronized boolean hasDependentNodeTypes(QName nodeTypeName)
-            throws NoSuchNodeTypeException {
-        if (!registeredNTDefs.containsKey(nodeTypeName)) {
-            throw new NoSuchNodeTypeException(nodeTypeName.toString());
-        }
-        Iterator iter = registeredNTDefs.values().iterator();
-        while (iter.hasNext()) {
-            QNodeTypeDefinition ntd = (QNodeTypeDefinition) iter.next();
-            if (ntd.getDependencies().contains(nodeTypeName)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private synchronized Set getDependentNodeTypes(QName nodeTypeName)
+    private Set getDependentNodeTypes(QName nodeTypeName)
-        /*
-         * collect names of those node types that have dependencies on the given
-         * node type
-         */
+        // get names of those node types that have dependencies on the given nt

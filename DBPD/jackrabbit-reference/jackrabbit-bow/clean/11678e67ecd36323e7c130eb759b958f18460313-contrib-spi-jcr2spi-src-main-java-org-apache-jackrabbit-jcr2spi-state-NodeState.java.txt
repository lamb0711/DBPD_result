- remove cachebehaviour flag from ChangeLog.persisted
- minor improvement

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@521356 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.config.CacheBehaviour;
+import org.apache.jackrabbit.name.Path;
-    
+
-        PropertyEntry child = getNodeEntry().getPropertyEntry(propertyName);
-        if (child != null) {
-            return child.getPropertyState();
+        HierarchyEntry child = getNodeEntry().getDeepEntry(Path.create(propertyName, Path.INDEX_UNDEFINED));
+        if (child != null && !child.denotesNode()) {
+            return ((PropertyEntry) child).getPropertyState();
-            // TODO; correct?
-     * @see ItemState#persisted(ChangeLog, CacheBehaviour)
+     * @see ItemState#persisted(ChangeLog)
-    void persisted(ChangeLog changeLog, CacheBehaviour cacheBehaviour) throws IllegalStateException {
+    void persisted(ChangeLog changeLog) throws IllegalStateException {
-
-            // delState.overlayedState.getHierarchyEntry().remove();
+            if (Status.isTerminal(delState.getStatus())) {
+                log.debug("Removal of State " + delState + " has already been completed.");
+                continue;
+            }
-                // connect the new state to its overlayed state (including update
-                // via merging in order to be aware of autocreated values,
-                // changed definition etc.
-                addedState.reconnect(false);
-
-                it.remove();
+                if (addedState.getStatus() == Status.EXISTING) {
+                    log.debug("Adding new state " + addedState + " has already been completed.");
+                } else {
+                    // connect the new state to its overlayed state (including update
+                    // via merging in order to be aware of autocreated values,
+                    // changed definition etc.
+                    addedState.reconnect(false);
+                }
+            if (modState.getStatus() == Status.EXISTING) {
+                log.debug("Modified state has already been processed");
+                continue;
+            }
-                    it.remove();
-                it.remove();
-            adjustNodeState(parent, (PropertyState[]) l.toArray(new PropertyState[l.size()]), cacheBehaviour);
+            adjustNodeState(parent, (PropertyState[]) l.toArray(new PropertyState[l.size()]));
-        
+
-    private static void adjustNodeState(NodeState parent, PropertyState[] props,
-                                        CacheBehaviour cacheBehaviour) {
+    private static void adjustNodeState(NodeState parent, PropertyState[] props) {
-            if (cacheBehaviour != CacheBehaviour.OBSERVATION) {
-                // TODO: really necessary???
-                try {
-                    parent.reconnect(false);
-                } catch (RepositoryException e) {
-                    // TODO: handle properly
-                    log.error("Internal error", e);
-                }
+            try {
+                parent.reconnect(false);
+            } catch (RepositoryException e) {
+                // TODO: handle properly
+                log.error("Internal error", e);

JCR-2140 Configurations and Baselines


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@796586 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Map;
- * </p>
+ * <p/>
+ * <p/>
+ * Implementation note: methods starting with "internal" are considered to be
+ * executed within a "write operations" block.
-        /**
+    /**
+     * @throws ItemStateException if an error occurs
-    protected void restore(final Map<NodeId, InternalVersion> versions,
-                           boolean removeExisting)
-            throws RepositoryException {
-
-        // create a version selector to the set of versions
-        VersionSelector vsel = new VersionSelector() {
-            public InternalVersion select(InternalVersionHistory versionHistory) throws RepositoryException {
-                // try to select version as specified
-                InternalVersion v = versions.get(versionHistory.getId());
-                if (v == null) {
-                    // select latest one
-                    v = DateVersionSelector.selectByDate(versionHistory, null);
-                }
-                return v;
-            }
-        };
-
-        WriteOperation ops = startWriteOperation();
-        try {
-            // now restore all versions that have a node in the workspace
-            int numRestored = 0;
-            while (versions.size() > 0) {
-                Set<InternalVersion> restored = null;
-                for (InternalVersion v : versions.values()) {
-                    NodeStateEx state = getNodeStateEx(v.getFrozenNode().getFrozenId());
-                    if (state != null) {
-                        // todo: check should operate on workspace states, too
-                        int options = ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD;
-                        checkModify(state, options, Permission.NONE);
-                        restored = internalRestore(state, v, vsel, removeExisting);
-                        // remove restored versions from set
-                        for (InternalVersion r : restored) {
-                            versions.remove(r.getVersionHistory().getId());
-                        }
-                        numRestored += restored.size();
-                        break;
+    protected void internalRestore(VersionSet versions, boolean removeExisting)
+            throws RepositoryException, ItemStateException {
+        // now restore all versions that have a node in the workspace
+        int numRestored = 0;
+        while (versions.versions().size() > 0) {
+            Set<InternalVersion> restored = null;
+            for (InternalVersion v : versions.versions().values()) {
+                NodeStateEx state = getNodeStateEx(v.getFrozenNode().getFrozenId());
+                if (state != null) {
+                    // todo: check should operate on workspace states, too
+                    int options = ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD;
+                    checkModify(state, options, Permission.NONE);
+                    restored = internalRestore(state, v, versions, removeExisting);
+                    // remove restored versions from set
+                    for (InternalVersion r : restored) {
+                        versions.versions().remove(r.getVersionHistory().getId());
-                }
-                if (restored == null) {
-                    if (numRestored == 0) {
-                        throw new VersionException("Unable to restore. At least one version needs"
-                                + " existing versionable node in workspace.");
-                    } else {
-                        throw new VersionException("Unable to restore. All versions with non"
-                                + " existing versionable nodes need parent.");
-                    }
+                    numRestored += restored.size();
+                    break;
-            ops.save();
-        } catch (ItemStateException e) {
-            log.error("Error while reverting changes applied during restore.", e);
-            throw new RepositoryException(e);
-        } finally {
-            ops.close();
+            if (restored == null) {
+                if (numRestored == 0) {
+                    throw new VersionException("Unable to restore. At least one version needs"
+                            + " existing versionable node in workspace.");
+                } else {
+                    throw new VersionException("Unable to restore. All versions with non"
+                            + " existing versionable nodes need parent.");
+                }
+            }
-        restoreFrozenState(state, version.getFrozenNode(), vsel, restored, removeExisting);
+        internalRestoreFrozen(state, version.getFrozenNode(), vsel, restored, removeExisting);
-    protected void restoreFrozenState(NodeStateEx state, InternalFrozenNode freeze, VersionSelector vsel,
+    protected void internalRestoreFrozen(NodeStateEx state, InternalFrozenNode freeze, VersionSelector vsel,
-                    restoreFrozenState(restoredChild, f, vsel, restored, removeExisting);
+                    internalRestoreFrozen(restoredChild, f, vsel, restored, removeExisting);
-

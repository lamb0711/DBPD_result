JCR-1799 updating events swallowed (CacheBehavior.OBSERVATION)   	
JCR-1783 incomplete changelog when combining move with removal of new destination parent

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@704361 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Iterator;
-     *
+     * Value(s) and type of an existing property that has been transiently
+     * modified.
-    private TransientData transientData;
+    private PropertyData transientData;
-     *
+     * Original value(s) and type of an existing or a new property.
-    private PropertyInfo pInfo;
+    private PropertyData data;
-                            ItemDefinitionProvider definitionProvider) {
+                            ItemDefinitionProvider definitionProvider,
+                            QValue[] values, int propertyType)
+            throws ConstraintViolationException, RepositoryException {
-        this.transientData = null; // TODO: maybe type/values should be passed to constructor
-        this.pInfo = null;
+        setValues(values, propertyType);
+        this.data = new PropertyData(pInfo);
-        this.pInfo = pInfo;
-    public ItemId getId() {
+    public ItemId getId() throws RepositoryException {
-    public ItemId getWorkspaceId() {
+    public ItemId getWorkspaceId() throws RepositoryException {
-     * If <code>keepChanges</code> is true, this method does nothing and returns
-     * false. Otherwise type and values of the other property state are compared
-     * to this state. If they differ, they will be copied to this state and
-     * this method returns true.
+     * If <code>keepChanges</code> is true, this method only compares the existing
+     * values with the values from 'another' and returns true, if the underlying
+     * persistent state is different to the stored persistent values. Otherwise
+     * the transient changes will be discarded.
-        boolean modified = diff(this, (PropertyState) another);
-        this.pInfo = ((PropertyState) another).pInfo;
-        if (!keepChanges && transientData != null) {
-            modified = true;
+        // calculate if the persistent values of this state differ from the
+        // other state.
+        boolean diff = diff(data, ((PropertyState) another).data);
+        // reset the pInfo to point to the pInfo of another state.
+        this.data = ((PropertyState) another).data;
+        // if transient changes should be preserved OR if there are not
+        // transient changes, simply return diff to indicate if this state
+        // was internally changed.
+        if (keepChanges || transientData == null) {
+            return diff;
+        } else {
+            return true;
-        return modified;
-
-    /**
-     * {@inheritDoc}
-     * @see ItemState#persisted(ChangeLog)
-     */
-    void persisted(ChangeLog changeLog)
-        throws IllegalStateException {
-        for (Iterator it = changeLog.modifiedStates(); it.hasNext();) {
-            ItemState modState = (ItemState) it.next();
-            if (modState == this) {
-                /*
-                NOTE: Property can only be the changelog target, if it was
-                existing and has been modified. removal, add and implicit modification
-                of protected properties must be persisted by save on parent.
-                */
-                setStatus(Status.EXISTING);
-            }
-        }
-    }
-
-        return (transientData == null) ? pInfo.getType() : transientData.type;
+        return (transientData == null) ? data.type : transientData.type;
-        // if transientData are null the pInfo MUST be present (ev. add check)
-        return (transientData == null) ? pInfo.getValues() : transientData.values;
+        // if transientData are null the data MUST be present (ev. add check)
+        return (transientData == null) ? data.values : transientData.values;
-        if (transientData == null) {
-            transientData = new TransientData(type, values);
+        if (getStatus() == Status.NEW) {
+            if (data == null) {
+                data = new PropertyData(type, values);
+            } else {
+                data.setValues(type, values);
+            }
-            transientData.setValues(type, values);
+            if (transientData == null) {
+                transientData = new PropertyData(type, values);
+            } else {
+                transientData.setValues(type, values);
+            }
+            markModified();
-        markModified();
-    private static boolean diff(PropertyState p1, PropertyState p2) {
+    private static boolean diff(PropertyData p1, PropertyData p2) {
-        if (p1.getType() != p2.getType()) {
+        if (p1.type != p2.type) {
-        QValue[] vs1 = p1.getValues();
-        QValue[] vs2 = p2.getValues();
+        QValue[] vs1 = p1.values;
+        QValue[] vs2 = p2.values;
-     * Inner class storing transient property values an their type.
+     * Inner class storing property values an their type.
-    private class TransientData {
+    private class PropertyData {
-        private TransientData(int type, QValue[] values) throws RepositoryException {
+        private PropertyData(PropertyInfo pInfo) {
+            this.type = pInfo.getType();
+            this.values = pInfo.getValues();
+        }
+
+        private PropertyData(int type, QValue[] values) throws ConstraintViolationException, RepositoryException {
-        private void setValues(int type, QValue[] values) throws RepositoryException {
+        private void setValues(int type, QValue[] values) throws ConstraintViolationException, RepositoryException {

JCR-999  SPI: provide batch read functionality
JCR-1000 JCR2SPI: remove duplicate item states

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@552873 13f79535-47bb-0310-9956-ffa450edef68

-                target = new WeakReference(state);
+                // only set 'target' if not already by upon resolution
+                if (!isAvailable()) {
+                    setItemState(state);
+                }
+        ItemState state = null;
-            ItemState state = (ItemState) target.get();
-            if (state != null) {
-                return state;
-            }
+            state = (ItemState) target.get();
-        return null;
+        return state;
-     * Set the target of this HierarchyEntry to the given new ItemState.
-     * @throws IllegalStateException if this entry has already been resolved.
-     * @throws IllegalArgumentException if the given state is <code>null</code>
-     * or has another Status than {@link Status#NEW} or in case of class mismatch.
+     * @param entry
-    void internalSetItemState(ItemState newItemState) {
-        if (target != null || newItemState == null) {
-            throw new IllegalStateException();
-        }
-
-        if ((denotesNode() && newItemState.isNode()) || (!denotesNode() && !newItemState.isNode())) {
-            target = new WeakReference(newItemState);
-        } else {
-            throw new IllegalArgumentException();
-        }
-    }
-
-            if (state.getStatus() == Status.NEW) {
-                state.setStatus(Status.REMOVED);
-            } else {
-                state.getWorkspaceState().setStatus(Status.REMOVED);
-            }
+            state.setStatus(Status.REMOVED);
-        ItemState state = null;
-        if (target != null) {
-            state = (ItemState) target.get();
-        }
-        return state != null;
+        return internalGetItemState() != null;
+     * @see HierarchyEntry#setItemState(ItemState)
+     */
+    public synchronized void setItemState(ItemState state) {
+        if (state == null || (denotesNode() && !state.isNode()) || (!denotesNode() && state.isNode())) {
+            throw new IllegalArgumentException();
+        }
+        if (isAvailable()) {
+            throw new IllegalStateException("HierarchyEntry has already been resolved.");
+        }
+        target = new WeakReference(state);
+    }
+
+    /**
+     * {@inheritDoc}<br>
-                state.merge(state.getWorkspaceState(), false);
+                state.revert();
-                state.merge(state.getWorkspaceState(), false);
+                state.revert();
-        // TODO: check again if 'reconnect' is not possible for transiently-modified state
+        // TODO: check again if 'reload' is not possible for transiently-modified state
-            try {
-                state.reconnect(keepChanges);
-            } catch (ItemNotFoundException e) {
-                // remove hierarchyEntry (including all children and set
-                // state-status to REMOVED (or STALE_DESTROYED)
-                remove();
-            } catch (RepositoryException e) {
-                // TODO: rather throw? remove from parent?
-                log.warn("Exception while reloading item state: " + e);
-                log.debug("Stacktrace: ", e);
-            }
+            state.reload(keepChanges);
-
-        state.checkIsSessionState();

JCR-1276: A Property and a Node Can Have the Same Name

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@605622 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.Name;
+import org.apache.jackrabbit.spi.Path;
-import org.apache.jackrabbit.spi.Path;
-import org.apache.jackrabbit.spi.Name;
+    //-------------------------------------------------------< implementation >
+    /**
+     * Recursively invoked method that resolves a path into an item id.
+     *
+     * @param path  full path of item to resolve
+     * @param state intermediate state
+     * @param next  next path element index to resolve
+     * @param denotesNode flag indicating whether <code>path</code> refers to a
+     *                    node (<code>true</code>) or a property (<code>false</code>)
+     * @return the id of the item denoted by <code>path</code> or
+     *         <code>null</code> if no item exists at <code>path</code>.
+     * @throws ItemStateException if an error occured
+     */
+    private ItemId resolvePath(Path path, ItemState state, int next,
+                                 boolean denotesNode)
+            throws ItemStateException {
+
+        // allow subclasses to process intermediate state
+        beforeResolvePath(path, state, next);
+
+        Path.Element[] elements = path.getElements();
+        if (elements.length == next) {
+            return state.getId();
+        }
+        Path.Element elem = elements[next];
+
+        Name name = elem.getName();
+        int index = elem.getIndex();
+        if (index == 0) {
+            index = 1;
+        }
+
+        NodeState parentState = (NodeState) state;
+        if (next == elements.length - 1) {
+            // last path element
+            if (denotesNode) {
+                if (parentState.hasChildNodeEntry(name, index)) {
+                    // child node
+                    NodeState.ChildNodeEntry nodeEntry =
+                            getChildNodeEntry(parentState, name, index);
+                    return nodeEntry.getId();
+                }
+            } else {
+                if (parentState.hasPropertyName(name) && (index <= 1)) {
+                    // property
+                    return new PropertyId(parentState.getNodeId(), name);
+                }
+            }
+            // no such itemn
+            return null;
+        }
+
+        // intermediate path element
+        ItemId childId;
+        if (parentState.hasChildNodeEntry(name, index)) {
+            // child node
+            NodeState.ChildNodeEntry nodeEntry =
+                    getChildNodeEntry(parentState, name, index);
+            childId = nodeEntry.getId();
+            // recurse
+            return resolvePath(path, getItemState(childId), next + 1, denotesNode);
+        }
+        // no such item
+        return null;
+    }
+
+     * @param denotesNode flag indicating whether <code>path</code> refers to a
+     *                    node (<code>true</code>) or a property (<code>false</code>)
+     * @throws RepositoryException if an error occured
-    protected ItemId resolvePath(Path path, ItemId id, int next)
+    protected ItemId resolvePath(Path path, ItemId id, int next,
+                                 boolean denotesNode)
-            return resolvePath(path, getItemState(id), next);
+            return resolvePath(path, getItemState(id), next, denotesNode);
-     * Resolve a path into an item id. Recursively invoked method that may be
-     * overridden by some subclass to either return cached responses or add
-     * response to cache.
+     * Called by recursively invoked method {@link #resolvePath(Path, ItemState, int, boolean)};
+     * May be overridden by some subclass to process/cache intermediate state.
-     * @return the id of the item denoted by <code>path</code> or
-     *         <code>null</code> if no item exists at <code>path</code>.
-    protected ItemId resolvePath(Path path, ItemState state, int next)
-            throws ItemStateException {
-
-        Path.Element[] elements = path.getElements();
-        if (elements.length == next) {
-            return state.getId();
-        }
-        Path.Element elem = elements[next];
-
-        Name name = elem.getName();
-        int index = elem.getIndex();
-        if (index == 0) {
-            index = 1;
-        }
-
-        NodeState parentState = (NodeState) state;
-        ItemId childId;
-
-        if (parentState.hasChildNodeEntry(name, index)) {
-            // child node
-            NodeState.ChildNodeEntry nodeEntry =
-                    getChildNodeEntry(parentState, name, index);
-            childId = nodeEntry.getId();
-
-        } else if (parentState.hasPropertyName(name)) {
-            // property
-            if (index > 1) {
-                // properties can't have same name siblings
-                return null;
-
-            } else if (next < elements.length - 1) {
-                // property is not the last element in the path
-                return null;
-            }
-
-            childId = new PropertyId(parentState.getNodeId(), name);
-
-        } else {
-            // no such item
-            return null;
-        }
-        return resolvePath(path, getItemState(childId), next + 1);
+    protected void beforeResolvePath(Path path, ItemState state, int next) {
+        // do nothing
-        return resolvePath(path, rootNodeId, 1);
+        // first try to resolve node path, then property path
+        ItemId id = resolvePath(path, rootNodeId, 1, true);
+        return (id != null) ? id : resolvePath(path, rootNodeId, 1, false);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public NodeId resolveNodePath(Path path) throws RepositoryException {
+        return (NodeId) resolvePath(path, rootNodeId, 1, true);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public PropertyId resolvePropertyPath(Path path) throws RepositoryException {
+        return (PropertyId) resolvePath(path, rootNodeId, 1, false);

MOV26 MOV26 MOV31 INS31 INS31 INS31 UPD83 INS44 INS44 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS29 INS83 INS43 INS42 INS44 INS43 INS8 INS29 INS83 INS43 INS42 INS44 INS43 INS8 INS65 INS65 INS65 INS39 INS42 INS21 INS25 MOV41 INS65 INS65 INS39 INS42 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS39 INS42 INS60 INS65 INS42 INS43 INS42 INS42 INS41 INS65 INS42 INS43 INS42 INS42 INS41 UPD66 MOV66 INS42 UPD66 MOV66 UPD66 MOV66 INS42 INS66 INS32 UPD27 MOV27 INS8 INS42 INS66 INS66 INS42 INS66 INS66 INS65 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS43 INS59 INS16 INS65 INS42 INS11 INS65 INS42 INS11 UPD42 MOV42 MOV42 INS42 INS42 INS25 MOV41 INS41 INS68 INS42 INS42 INS32 INS36 INS42 INS32 INS43 INS32 INS43 INS32 INS42 INS8 INS8 INS32 INS42 INS69 INS69 INS69 INS69 INS42 INS42 INS42 INS34 INS9 INS27 MOV42 MOV42 MOV42 MOV34 INS9 INS42 INS42 INS42 INS42 INS34 INS9 INS42 INS42 INS42 INS42 INS34 INS9 INS25 INS25 INS42 INS42 MOV32 MOV27 INS42 INS42 INS43 INS43 INS39 INS39 INS42 INS33 INS32 INS8 INS27 INS8 INS42 INS42 INS42 INS34 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS60 INS41 MOV32 INS36 INS41 INS43 INS59 INS32 INS27 MOV14 INS40 INS42 INS32 INS42 INS42 UPD42 MOV42 MOV34 INS42 INS42 INS42 INS42 DEL65 DEL42 DEL34 DEL27 DEL8 DEL8 DEL25 DEL25 DEL42 DEL7 DEL21 DEL8 DEL33 DEL41 DEL8 DEL25 DEL32 DEL41 DEL32
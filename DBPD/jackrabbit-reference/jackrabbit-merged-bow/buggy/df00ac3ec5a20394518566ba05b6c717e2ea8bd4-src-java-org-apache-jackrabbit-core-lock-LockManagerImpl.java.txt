- fixing latest locking issues
- fixing version items refresh

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@157083 13f79535-47bb-0310-9956-ffa450edef68

-            LockInfo info = new LockInfo(lockToken, false,
+            LockInfo info = new LockInfo(this, lockToken, false,
+            info.setLive(true);
+    /**
+     * Internal <code>lock</code> implementation that takes as parameter
+     * a lock info that will be used inside the path map.
+     * @param node node to lock
+     * @param info lock info
+     * @throws LockException if the node is already locked
+     * @throws RepositoryException if another error occurs
+     * @return lock
+     */
+    Lock lock(NodeImpl node, LockInfo info)
+            throws LockException,  RepositoryException {
+
+        // check whether node is already locked
+        Path path = node.getPrimaryPath();
+        PathMap.Child child = lockMap.map(path, false);
+
+        LockInfo other = (LockInfo) child.get();
+        if (other != null) {
+            if (child.hasPath(path)) {
+                throw new LockException("Node already locked: " + node.safeGetJCRPath());
+            } else if (other.deep) {
+                throw new LockException("Parent node has deep lock.");
+            }
+        }
+        if (info.deep && child.hasPath(path)) {
+            throw new LockException("Some child node is locked.");
+        }
+
+        // add properties to content
+        node.internalSetProperty(Constants.JCR_LOCKOWNER,
+                InternalValue.create(node.getSession().getUserId()));
+        node.internalSetProperty(Constants.JCR_LOCKISDEEP,
+                InternalValue.create(info.deep));
+        node.save();
+
+        // create lock token
+        SessionImpl session = (SessionImpl) node.getSession();
+        info.setLockHolder(session);
+        info.setLive(true);
+        if (info.sessionScoped) {
+            session.addListener(info);
+        }
+        session.addLockToken(info.lockToken.toString(), false);
+        lockMap.put(path, info);
+        return new LockImpl(info, node);
+    }
+
+    /**
+     * Unlock a node given by its info. Invoked when a session logs out and
+     * all session scoped locks of that session must be unlocked.
+     * @param info lock info
+     */
+    void unlock(LockInfo info) {
+        // if no session currently holds lock, take system session
+        SessionImpl session = info.getLockHolder();
+        if (session == null) {
+            session = this.session;
+        }
+
+        try {
+            // get node's path and remove child in path map
+            NodeImpl node = (NodeImpl) session.getItemManager().getItem(
+                    new NodeId(info.getUUID()));
+            Path path = node.getPrimaryPath();
+
+            PathMap.Child child = lockMap.map(path, true);
+            if (child != null) {
+                child.set(null);
+            }
+
+            // set live flag to false
+            info.setLive(false);
+
+            // remove properties in content
+            node.removeChildProperty(Constants.JCR_LOCKOWNER);
+            node.removeChildProperty(Constants.JCR_LOCKISDEEP);
+            node.save();
+            
+        } catch (RepositoryException e) {
+            log.warn("Unable to unlock session-scoped lock on node '" +
+                    info.lockToken + "': " + e.getMessage());
+            log.debug("Root cause: ", e);
+        }
+
+    }
+
-        Path path = node.getPrimaryPath();
-        PathMap.Child child = lockMap.map(path, false);
-
-        LockInfo info = (LockInfo) child.get();
-        if (info != null) {
-            if (child.hasPath(path)) {
-                throw new LockException("Node already locked: " + node.safeGetJCRPath());
-            } else if (info.deep) {
-                throw new LockException("Parent node has deep lock.");
-            }
-        }
-        if (isDeep && child.hasPath(path)) {
-            throw new LockException("Some child node is locked.");
-        }
-
-        SessionImpl session = (SessionImpl) node.getSession();
-        info = new LockInfo(new LockToken(node.internalGetUUID()),
-                isSessionScoped, isDeep, session.getUserId());
-        info.setLockHolder(session);
-        if (isSessionScoped) {
-            session.addListener(info);
-        }
-        session.addLockToken(info.lockToken.toString(), false);
-        lockMap.put(path, info);
-        return new LockImpl(info, node);
+        // create lock info to use and pass to internal implementation
+        LockInfo info = new LockInfo(this, new LockToken(node.internalGetUUID()),
+                isSessionScoped, isDeep, node.getSession().getUserId());
+        return lock(node, info);
+        // check whether node is locked by this session
-        child.set(null);
+        // remove lock in path map
+        child.set(null);
-        info.setLockHolder(null);
-        session.removeLockToken(info.lockToken.toString(), false);
+
+        // remove properties in content
+        node.removeChildProperty(Constants.JCR_LOCKOWNER);
+        node.removeChildProperty(Constants.JCR_LOCKISDEEP);
+        node.save();
-                        childAdded(event.getChildUUID(),
+                        nodeAdded(event.getChildUUID(),
-                        childRemoved(event.getChildUUID(),
+                        nodeRemoved(event.getChildUUID(),
-     * Invoked when some child has been added.
+     * Invoked when some node has been added. Relink the child inside our
+     * zombie map to the new parent. Revitalize all locks inside the
+     * zombie child hierarchy.
-    private synchronized void childAdded(String uuid, Path path) {
+    private synchronized void nodeAdded(String uuid, Path path) {
+                zombie.traverse(new PathMap.ChildVisitor() {
+                    public void childVisited(PathMap.Child child) {
+                        LockInfo info = (LockInfo) child.get();
+                        info.setLive(true);
+                    }
+                }, false);
-            log.warn("Added child does not have parent, ignoring event.");
+            log.warn("Added node does not have parent, ignoring event.");
-     * Invoked when some child has been removed.
+     * Invoked when some node has been removed. Unlink the child inside
+     * our path map corresponding to that node. Disable all locks contained
+     * in that subtree.
-    private synchronized void childRemoved(String uuid, Path path) {
+    private synchronized void nodeRemoved(String uuid, Path path) {
+                    child.traverse(new PathMap.ChildVisitor() {
+                        public void childVisited(PathMap.Child child) {
+                            LockInfo info = (LockInfo) child.get();
+                            info.setLive(false);
+                        }
+                    }, false);
-            log.warn("Added child does not have parent, ignoring event.");
+            log.warn("Removed node does not have parent, ignoring event.");

INS31 INS31 INS29 INS44 MOV21 INS29 INS39 INS42 INS44 INS8 MOV29 INS83 INS83 INS43 INS42 INS44 MOV44 MOV44 INS43 INS43 INS8 UPD42 UPD42 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS60 INS21 INS21 INS21 INS65 INS65 INS43 INS42 INS60 INS25 INS54 INS42 INS43 INS42 INS42 INS42 INS60 INS41 INS21 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS43 INS59 INS32 INS32 INS32 INS32 INS40 INS66 INS66 INS42 INS66 INS42 INS43 INS59 INS27 INS8 INS8 INS12 INS42 INS43 INS59 INS32 INS32 UPD66 INS66 INS66 UPD66 INS66 INS66 INS21 INS42 INS42 INS11 UPD42 INS40 INS42 INS42 INS40 INS32 INS42 INS42 INS40 INS32 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS32 INS42 INS33 INS21 INS60 INS60 INS60 INS25 INS21 INS21 INS21 INS21 INS44 INS8 INS42 INS42 MOV14 INS42 INS42 INS42 UPD42 UPD42 INS40 UPD42 UPD42 UPD40 MOV40 INS42 INS42 MOV54 MOV54 MOV44 MOV44 INS32 INS43 INS32 INS42 INS42 INS32 INS42 INS42 INS40 INS42 INS42 INS7 INS43 INS59 INS43 INS59 INS43 INS59 INS27 INS8 INS32 INS32 INS32 INS32 INS43 INS42 INS21 INS21 INS52 INS8 INS42 INS42 INS9 INS42 INS42 INS42 UPD40 INS32 INS42 INS42 INS22 INS42 INS42 INS11 INS42 INS42 INS32 INS40 INS42 INS32 INS42 INS33 INS21 INS42 INS42 INS9 INS42 INS42 INS40 INS42 INS42 INS40 INS42 INS42 INS42 INS32 INS32 INS32 INS21 MOV21 INS52 INS42 INS42 INS52 INS42 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS9 INS32 INS42 INS42 INS27 INS42 INS42 INS45 INS42 INS42 UPD42 MOV42 INS32 UPD45 INS8 UPD45 INS42 INS32 INS42 INS14 INS42 INS42 INS33 INS45 INS40 INS45 INS32 INS42 INS42 INS14 INS9 INS21 MOV21 INS42 INS42 INS43 INS32 INS42 INS42 UPD42 UPD42 INS43 INS1 INS32 INS42 INS42 INS42 INS40 INS31 INS42 INS42 INS14 INS9 INS83 INS39 INS42 INS44 INS8 INS43 INS1 INS43 INS42 MOV60 INS21 INS40 INS31 INS40 INS32 INS83 INS39 INS42 INS44 INS8 INS42 INS42 INS9 INS43 INS42 INS60 INS21 INS40 INS43 INS59 INS32 INS42 INS42 INS11 INS42 INS42 INS9 INS43 INS32 INS42 INS42 INS42 DEL83 DEL83 DEL42 DEL42 DEL7 DEL42 DEL33 DEL42 DEL32 DEL9 DEL8 DEL8
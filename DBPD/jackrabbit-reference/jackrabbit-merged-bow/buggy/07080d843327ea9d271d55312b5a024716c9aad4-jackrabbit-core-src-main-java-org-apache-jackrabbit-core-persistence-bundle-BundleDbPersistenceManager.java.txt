JCR-1428: Add API for selective bundle consistency check (Jackrabbit-specific)
    - Patch by Alexander Klimetschek

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@632993 13f79535-47bb-0310-9956-ffa450edef68

-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.apache.commons.io.IOUtils;
-import org.apache.jackrabbit.util.Text;
-import org.apache.jackrabbit.core.state.ChangeLog;
-import org.apache.jackrabbit.core.state.ItemStateException;
-import org.apache.jackrabbit.core.state.NoSuchItemStateException;
-import org.apache.jackrabbit.core.state.NodeReferencesId;
-import org.apache.jackrabbit.core.state.NodeReferences;
-import org.apache.jackrabbit.core.persistence.PMContext;
-import org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager;
-import org.apache.jackrabbit.core.persistence.bundle.util.DbNameIndex;
-import org.apache.jackrabbit.core.persistence.bundle.util.NodePropBundle;
-import org.apache.jackrabbit.core.persistence.bundle.util.BundleBinding;
-import org.apache.jackrabbit.core.persistence.bundle.util.ErrorHandling;
-import org.apache.jackrabbit.core.persistence.bundle.util.StringIndex;
-import org.apache.jackrabbit.core.persistence.util.Serializer;
-import org.apache.jackrabbit.core.persistence.util.BLOBStore;
-import org.apache.jackrabbit.core.persistence.util.FileSystemBLOBStore;
-import org.apache.jackrabbit.core.fs.FileSystemResource;
-import org.apache.jackrabbit.core.fs.FileSystem;
-import org.apache.jackrabbit.core.fs.local.LocalFileSystem;
-import org.apache.jackrabbit.core.NodeId;
-import org.apache.jackrabbit.core.NodeIdIterator;
-import org.apache.jackrabbit.core.PropertyId;
-import org.apache.jackrabbit.uuid.UUID;
-
+import org.apache.commons.io.IOUtils;
+import org.apache.jackrabbit.core.NodeId;
+import org.apache.jackrabbit.core.NodeIdIterator;
+import org.apache.jackrabbit.core.PropertyId;
+import org.apache.jackrabbit.core.fs.FileSystem;
+import org.apache.jackrabbit.core.fs.FileSystemResource;
+import org.apache.jackrabbit.core.fs.local.LocalFileSystem;
+import org.apache.jackrabbit.core.persistence.PMContext;
+import org.apache.jackrabbit.core.persistence.bundle.util.BundleBinding;
+import org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager;
+import org.apache.jackrabbit.core.persistence.bundle.util.DbNameIndex;
+import org.apache.jackrabbit.core.persistence.bundle.util.ErrorHandling;
+import org.apache.jackrabbit.core.persistence.bundle.util.NodePropBundle;
+import org.apache.jackrabbit.core.persistence.bundle.util.StringIndex;
+import org.apache.jackrabbit.core.persistence.util.BLOBStore;
+import org.apache.jackrabbit.core.persistence.util.FileSystemBLOBStore;
+import org.apache.jackrabbit.core.persistence.util.Serializer;
+import org.apache.jackrabbit.core.state.ChangeLog;
+import org.apache.jackrabbit.core.state.ItemStateException;
+import org.apache.jackrabbit.core.state.NoSuchItemStateException;
+import org.apache.jackrabbit.core.state.NodeReferences;
+import org.apache.jackrabbit.core.state.NodeReferencesId;
+import org.apache.jackrabbit.util.Text;
+import org.apache.jackrabbit.uuid.UUID;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
-            checkConsistency();
+            // check all bundles
+            checkConsistency(null, true, consistencyFix);
-     * Performs a consistency check.
+     * Checks a single bundle for inconsistencies, ie. inexistent child nodes
+     * and inexistent parents.
+     *
+     * @param id
+     *            node id for the bundle to check
+     * @param bundle
+     *            the bundle to check
+     * @param fix
+     *            if true, repair things that can be repaired
+     * @param modifications
+     *            if <code>fix == true</code>, collect the repaired
+     *            {@linkplain NodePropBundle bundles} here
-    private void checkConsistency() {
-        int count = 0;
-        int total = 0;
-        log.info("{}: checking workspace consistency...", name);
+    protected void checkBundleConsistency(NodeId id, NodePropBundle bundle, boolean fix, Collection modifications) {
+        //log.info(name + ": checking bundle '" + id + "'");
-        Collection modifications = new ArrayList();
-        ResultSet rs = null;
-        DataInputStream din = null;
-        try {
-            String sql;
-            if (getStorageModel() == SM_BINARY_KEYS) {
-                sql = "select NODE_ID, BUNDLE_DATA from " + schemaObjectPrefix + "BUNDLE";
-            } else {
-                sql = "select NODE_ID_HI, NODE_ID_LO, BUNDLE_DATA from " + schemaObjectPrefix + "BUNDLE";
+        // look at the node's children
+        Collection missingChildren = new ArrayList();
+        Iterator iter = bundle.getChildNodeEntries().iterator();
+        while (iter.hasNext()) {
+            NodePropBundle.ChildNodeEntry entry = (NodePropBundle.ChildNodeEntry) iter.next();
+
+            // skip check for system nodes (root, system root, version storage, nodetypes)
+            if (entry.getId().toString().endsWith("babecafebabe")) {
+                continue;
-            Statement stmt = connectionManager.executeStmt(sql, new Object[0]);
-            rs = stmt.getResultSet();
-            while (rs.next()) {
-                NodeId id;
-                Blob blob;
-                if (getStorageModel() == SM_BINARY_KEYS) {
-                    id = new NodeId(new UUID(rs.getBytes(1)));
-                    blob = rs.getBlob(2);
+            if (id.toString().endsWith("babecafebabe")) {
+                continue;
+            }
+
+            try {
+                // analyze child node bundles
+                NodePropBundle child = loadBundle(entry.getId(), true);
+                if (child == null) {
+                    log.error(
+                            "NodeState '" + id + "' references inexistent child"
+                            + " '" + entry.getName() + "' with id "
+                            + "'" + entry.getId() + "'");
+                    missingChildren.add(entry);
-                    id = new NodeId(new UUID(rs.getLong(1), rs.getLong(2)));
-                    blob = rs.getBlob(3);
-                }
-                din = new DataInputStream(blob.getBinaryStream());
-                try {
-                    NodePropBundle bundle = binding.readBundle(din, id);
-                    Collection missingChildren = new ArrayList();
-                    Iterator iter = bundle.getChildNodeEntries().iterator();
-                    while (iter.hasNext()) {
-                        NodePropBundle.ChildNodeEntry entry = (NodePropBundle.ChildNodeEntry) iter.next();
-                        if (entry.getId().toString().endsWith("babecafebabe")) {
-                            continue;
-                        }
-                        if (id.toString().endsWith("babecafebabe")) {
-                            continue;
-                        }
-                        try {
-                            NodePropBundle child = loadBundle(entry.getId());
-                            if (child == null) {
-                                log.error("NodeState " + id.getUUID()
-                                        + " references inexistent child " + entry.getName()
-                                        + " with id " + entry.getId().getUUID());
-                                missingChildren.add(entry);
-                            } else {
-                                NodeId cp = child.getParentId();
-                                if (cp == null) {
-                                    log.error("ChildNode has invalid parent uuid: null");
-                                } else if (!cp.equals(id)) {
-                                    log.error("ChildNode has invalid parent uuid: " + cp + " (instead of " + id.getUUID() + ")");
-                                }
-                            }
-                        } catch (ItemStateException e) {
-                            log.error("Error while loading child node: " + e);
-                        }
+                    NodeId cp = child.getParentId();
+                    if (cp == null) {
+                        log.error("ChildNode has invalid parent uuid: <null>");
+                    } else if (!cp.equals(id)) {
+                        log.error("ChildNode has invalid parent uuid: '" + cp + "' (instead of '" + id + "')");
-                    if (consistencyFix && !missingChildren.isEmpty()) {
-                        Iterator iterator = missingChildren.iterator();
-                        while (iterator.hasNext()) {
-                            bundle.getChildNodeEntries().remove(iterator.next());
-                        }
-                        modifications.add(bundle);
-                    }
-
-                    NodeId parentId = bundle.getParentId();
-                    if (parentId != null) {
-                        if (!exists(parentId)) {
-                            log.error("NodeState " + id + " references inexistent parent id " + parentId);
-                        }
-                    }
-                } catch (IOException e) {
-                    log.error("Error in bundle " + id + ": " + e);
-                    din = new DataInputStream(blob.getBinaryStream());
-                    binding.checkBundle(din);
-                count++;
-                if (count % 1000 == 0) {
-                    log.info(name + ": checked " + count + "/" + total + " bundles...");
-                }
+            } catch (ItemStateException e) {
+                // problem already logged (loadBundle called with logDetailedErrors=true)
-        } catch (Exception e) {
-            log.error("Error in bundle", e);
-        } finally {
-            IOUtils.closeQuietly(din);
-            closeResultSet(rs);
+        }
+        // remove child node entry (if fixing is enabled)
+        if (fix && !missingChildren.isEmpty()) {
+            Iterator iterator = missingChildren.iterator();
+            while (iterator.hasNext()) {
+                bundle.getChildNodeEntries().remove(iterator.next());
+            }
+            modifications.add(bundle);
+        // check parent reference
+        NodeId parentId = bundle.getParentId();
+        try {
+            // skip root nodes (that point to itself)
+            if (parentId != null && !id.toString().endsWith("babecafebabe")) {
+                if (!existsBundle(parentId)) {
+                    log.error("NodeState '" + id + "' references inexistent parent uuid '" + parentId + "'");
+                }
+            }
+        } catch (ItemStateException e) {
+            log.error("Error reading node '" + parentId + "' (parent of '" + id + "'): " + e);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void checkConsistency(String[] uuids, boolean recursive, boolean fix) {
+        log.info("{}: checking workspace consistency...", name);
+
+        int count = 0;
+        int total = 0;
+        Collection modifications = new ArrayList();
+
+        if (uuids == null) {
+            // get all node bundles in the database with a single sql statement,
+            // which is (probably) faster than loading each bundle and traversing the tree
+            ResultSet rs = null;
+            DataInputStream din = null;
+            try {
+                String sql;
+                if (getStorageModel() == SM_BINARY_KEYS) {
+                    sql = "select NODE_ID, BUNDLE_DATA from " + schemaObjectPrefix + "BUNDLE";
+                } else {
+                    sql = "select NODE_ID_HI, NODE_ID_LO, BUNDLE_DATA from " + schemaObjectPrefix + "BUNDLE";
+                }
+                Statement stmt = connectionManager.executeStmt(sql, new Object[0]);
+                rs = stmt.getResultSet();
+
+                // iterate over all nodebundles in the db
+                while (rs.next()) {
+                    NodeId id;
+                    Blob blob;
+                    if (getStorageModel() == SM_BINARY_KEYS) {
+                        id = new NodeId(new UUID(rs.getBytes(1)));
+                        blob = rs.getBlob(2);
+                    } else {
+                        id = new NodeId(new UUID(rs.getLong(1), rs.getLong(2)));
+                        blob = rs.getBlob(3);
+                    }
+                    din = new DataInputStream(blob.getBinaryStream());
+                    try {
+                        // parse and check bundle
+                        // check bundle will log any problems itself
+                        if (binding.checkBundle(din)) {
+                            // reset stream for readBundle()
+                            din = new DataInputStream(blob.getBinaryStream());
+                            NodePropBundle bundle = binding.readBundle(din, id);
+                            checkBundleConsistency(id, bundle, fix, modifications);
+                        } else {
+                            log.error("invalid bundle '" + id + "', see previous BundleBinding error log entry");
+                        }
+                    } catch (Exception e) {
+                        log.error("Error in bundle " + id + ": " + e);
+                    }
+                    count++;
+                    if (count % 1000 == 0) {
+                        log.info(name + ": checked " + count + " bundles...");
+                    }
+                }
+            } catch (Exception e) {
+                log.error("Error loading bundle", e);
+            } finally {
+                IOUtils.closeQuietly(din);
+                closeResultSet(rs);
+                total = count;
+            }
+        } else {
+            // check only given uuids, handle recursive flag
+
+            // 1) convert uuid array to modifiable list
+            // 2) for each uuid do
+            //     a) load node bundle
+            //     b) check bundle, store any bundle-to-be-modified in collection
+            //     c) if recursive, add child uuids to list of uuids
+
+            List uuidList = new ArrayList(uuids.length);
+            // convert uuid string array to list of UUID objects
+            for (int i = 0; i < uuids.length; i++) {
+                try {
+                    uuidList.add(new UUID(uuids[i]));
+                } catch (IllegalArgumentException e) {
+                    log.error("Invalid uuid for consistency check, skipping: '" + uuids[i] + "': " + e);
+                }
+            }
+
+            // iterate over UUIDs (including ones that are newly added inside the loop!)
+            for (int i = 0; i < uuidList.size(); i++) {
+                final UUID uuid = (UUID) uuidList.get(i);
+                try {
+                    // load the node from the database
+                    NodeId id = new NodeId(uuid);
+                    NodePropBundle bundle = loadBundle(id, true);
+
+                    if (bundle == null) {
+                        log.error("No bundle found for uuid '" + uuid + "'");
+                        continue;
+                    }
+
+                    checkBundleConsistency(id, bundle, fix, modifications);
+
+                    if (recursive) {
+                        Iterator iter = bundle.getChildNodeEntries().iterator();
+                        while (iter.hasNext()) {
+                            NodePropBundle.ChildNodeEntry entry = (NodePropBundle.ChildNodeEntry) iter.next();
+                            uuidList.add(entry.getId().getUUID());
+                        }
+                    }
+
+                    count++;
+                    if (count % 1000 == 0) {
+                        log.info(name + ": checked " + count + "/" + uuidList.size() + " bundles...");
+                    }
+                } catch (ItemStateException e) {
+                    // problem already logged (loadBundle called with logDetailedErrors=true)
+                }
+            }
+
+            total = uuidList.size();
+        }
+
+        // repair collected broken bundles
-                    log.info(name + ": Fixing bundle " + bundle.getId());
+                    log.info(name + ": Fixing bundle '" + bundle.getId() + "'");
-
+        return loadBundle(id, false);
+    }
+    
+    /**
+     * Loads a bundle from the underlying system and optionally performs
+     * a check on the bundle first.
+     *
+     * @param id the node id of the bundle
+     * @param checkBeforeLoading check the bundle before loading it and log
+     *                           detailed informations about it (slower)
+     * @return the loaded bundle or <code>null</code> if the bundle does not
+     *         exist.
+     * @throws ItemStateException if an error while loading occurs.
+     */
+    protected synchronized NodePropBundle loadBundle(NodeId id, boolean checkBeforeLoading)
+            throws ItemStateException {
+        byte[] bytes = null;
-            byte[] bytes = new byte[(int) length];
+            bytes = new byte[(int) length];
+            
+            if (checkBeforeLoading) {
+                if (binding.checkBundle(din)) {
+                    // reset stream for readBundle()
+                    din = new DataInputStream(new ByteArrayInputStream(bytes));
+                } else {
+                    // gets wrapped as proper ItemStateException below
+                    throw new Exception("invalid bundle, see previous BundleBinding error log entry");
+                }
+            }
+            

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS31 INS31 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS44 MOV8 UPD83 INS44 INS44 INS44 MOV21 MOV29 INS83 INS83 INS43 INS42 INS44 INS43 INS8 INS29 INS44 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS39 INS42 INS43 INS42 INS54 INS65 INS5 INS42 INS39 INS42 INS39 INS42 INS25 INS42 INS43 INS42 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS39 INS42 INS60 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS65 INS66 INS42 INS42 INS42 INS8 INS12 INS65 INS43 INS85 INS27 INS8 INS8 INS42 INS32 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS66 INS42 INS66 MOV5 INS59 INS42 INS66 UPD42 MOV25 MOV44 INS8 INS42 INS42 INS33 MOV60 MOV60 MOV54 INS60 INS24 INS24 INS21 INS42 INS42 INS9 INS42 INS33 INS21 INS25 INS27 INS21 INS43 INS59 INS58 INS27 INS37 INS8 INS58 INS27 INS37 INS8 INS7 INS7 INS42 INS8 INS33 INS9 INS42 INS44 INS8 MOV27 INS38 INS32 INS21 INS42 INS42 INS14 INS39 INS59 INS42 INS40 INS42 INS54 INS39 INS59 INS42 INS32 INS42 INS60 INS54 INS42 INS32 INS42 MOV3 INS25 INS43 INS42 INS32 INS42 INS42 INS27 INS7 INS43 INS40 INS42 INS34 INS8 INS12 INS42 INS34 INS42 INS42 INS83 INS43 INS59 INS8 INS12 INS42 INS42 INS32 INS8 INS8 INS42 INS32 INS42 INS45 INS45 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS21 INS44 INS8 INS42 INS42 INS11 INS60 INS60 INS25 INS21 INS25 INS21 INS25 INS44 INS8 INS42 INS42 INS42 INS21 INS53 INS9 INS42 INS42 UPD42 INS8 UPD45 INS32 INS43 INS42 INS21 INS43 INS32 INS43 INS59 INS43 INS59 INS27 INS8 INS32 INS42 INS8 INS37 INS27 INS8 INS43 INS42 INS7 INS14 INS25 INS42 INS42 INS14 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS33 INS21 INS18 INS42 INS42 INS42 INS42 INS42 INS60 INS61 INS42 INS27 INS34 INS21 INS42 INS42 INS14 INS43 INS45 UPD45 INS42 UPD45 INS45 UPD45 INS45 INS32 INS45 UPD45 UPD45 INS45 MOV32 INS8 INS8 UPD43 INS43 INS2 INS42 INS42 INS27 INS43 INS42 INS42 INS42 INS9 INS32 INS43 INS59 INS32 INS8 INS42 INS34 INS32 UPD45 INS45 INS43 INS14 INS42 INS42 INS42 UPD45 MOV21 MOV60 INS21 INS21 UPD42 INS42 INS42 INS42 INS45 INS2 INS45 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS32 INS42 INS42 INS60 INS21 INS42 INS42 INS27 INS42 INS43 INS42 INS32 INS32 INS42 INS42 INS45 INS42 INS45 INS32 INS42 INS43 INS59 INS32 INS42 INS45 INS42 INS45 INS32 INS45 INS42 UPD45 UPD45 INS42 UPD45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS40 INS42 INS11 INS42 INS42 MOV32 INS42 INS42 INS45 INS42 INS45 INS43 INS32 INS40 INS42 INS42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL66 DEL65 DEL21 DEL45 DEL42 DEL42 DEL59 DEL60
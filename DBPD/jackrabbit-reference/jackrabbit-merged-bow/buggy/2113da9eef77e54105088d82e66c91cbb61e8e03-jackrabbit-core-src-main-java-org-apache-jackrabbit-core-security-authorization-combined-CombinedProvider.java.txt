JCR-1104 : JSR 283 support (security work in progress)

> introduce AccessManager.canRead(Path)
> retrieve Policy/ACE from ACProvider by Path rather than by ID
> add CompiledPermission.canReadAll for optimization
> fix ACLTemplate (various bugs) and add additional tests
> get rid of deprecated AccessManager.isGranted(ItemId, int) wherever possible
  and mark/simplify other usages
  - ItemManager
  - BatchedItemOperations
  - add TODO with QueryResultImpl that still uses the isGranted method.
  - EventConsumer: still uses isGranted. but various calls were replaced by private
    canRead -> simplify later optimization.
> remove unused ACLCache.java
> ItemManager:
  - make getItem consistent with itemExists (check perm even if obtained from cache)
  - replace getItemState by getItemData
  - get rid of duplicate code
  - add canRead(ItemData, Path) which is used (almost) everywhere and avoid permission
    check for NEW,non-protected items
  - consequently getItem(ItemId, boolean) is not required any more.
  - upon building LazyItemIterator for children: omit the duplicate permission
    check while building the set of childIds.
    the perm-check is executed upon the subsequent ItemManager.getItem call anyway 
> NodeImpl: createChildNode called ItemManager.getItem for an new item that has
  not yet been added as CNE to its parent -> replace by ItemManager.createItemInstance
  which omits the permission check.
> ItemImpl: 
  - fix javadoc
  - replace removed method ItemMgr.getItem(ItemId, boolean) by getItem(ItemId)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@649172 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.NodeId;
+import org.apache.jackrabbit.spi.commons.name.PathFactoryImpl;
-import javax.jcr.ItemNotFoundException;
-    // TODO: TOBEFIXED add means to create user-based ACLs (currently editor is not exposed in the API)
-    private String policyName;
-
+
+    //--------------------------------------< AbstractAccessControlProvider >---
+    /**
+     * @see AbstractAccessControlProvider#isAcItem(Path)
+     */
+    protected boolean isAcItem(Path absPath) throws RepositoryException {
+        Path.Element[] elems = absPath.getElements();
+        for (int i = 0; i < elems.length; i++) {
+            if (N_POLICY.equals(elems[i].getName())) {
+                return true;
+            }
+        }
+        return false;
+    }
+
-        policyName = session.getJCRName(AccessControlConstants.N_POLICY);
-
-     * @see AccessControlProvider#getAccessControlEntries(org.apache.jackrabbit.core.NodeId)
+     * @see AccessControlProvider#getAccessControlEntries(Path)
+     * @param absPath
-    public AccessControlEntry[] getAccessControlEntries(NodeId nodeId) throws RepositoryException {
+    public AccessControlEntry[] getAccessControlEntries(Path absPath) throws RepositoryException {
-    public CompiledPermissions compilePermissions(Set principals) throws ItemNotFoundException, RepositoryException {
+    public CompiledPermissions compilePermissions(Set principals) throws RepositoryException {
+        } else if (isReadOnly(principals)) {
+            return getReadOnlyPermissions();
-            // TODO: TOBEFIXED include the resource-based ACLs!
+    /**
+     * @see AccessControlProvider#canAccessRoot(Set)
+     */
+    public boolean canAccessRoot(Set principals) throws RepositoryException {
+        checkInitialized();
+        if (isAdminOrSystem(principals)) {
+            return true;
+        } else {
+            return new CompiledPermissionImpl(principals, false).grants(PathFactoryImpl.getInstance().getRootPath(), Permission.READ);
+        }
+    }
+
+            this(principals, true);
+        }
+
+        /**
+         * @param principals
+         * @throws RepositoryException
+         */
+        private CompiledPermissionImpl(Set principals, boolean listenToEvents) throws RepositoryException {
-            int events = Event.PROPERTY_CHANGED | Event.PROPERTY_ADDED |
-                    Event.PROPERTY_REMOVED | Event.NODE_ADDED | Event.NODE_REMOVED;
-            String[] ntNames = new String[] {
-                    session.getJCRName(NT_REP_ACE)
-            };
-            observationMgr.addEventListener(this, events, acRoot.getPath(), true, null, ntNames, false);
+            if (listenToEvents) {
+                int events = Event.PROPERTY_CHANGED | Event.PROPERTY_ADDED |
+                        Event.PROPERTY_REMOVED | Event.NODE_ADDED | Event.NODE_REMOVED;
+                String[] ntNames = new String[] {
+                        session.getJCRName(NT_REP_ACE)
+                };
+                observationMgr.addEventListener(this, events, acRoot.getPath(), true, null, ntNames, false);
+            }
-            String jcrPath = session.getJCRPath(absPath);
-            boolean isAclItem = false;
-            String[] segments = Text.explode(jcrPath, '/', false);
-            if (segments.length > 0) {
-                for (int i = segments.length - 1; i >= 0 && !isAclItem; i--) {
-                    isAclItem = policyName.equals(segments[i]);
-                }
-            }
-
+            boolean isAclItem = isAcItem(absPath);
+            String jcrPath = session.getJCRPath(absPath);            
-                log.error("Internal error: ", e.getMessage());
+                log.debug("Unable to unregister listener: ", e.getMessage());

MOV26 UPD40 INS31 INS31 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS31 INS65 INS43 INS42 INS42 INS60 INS24 INS41 INS65 UPD43 UPD42 INS65 INS43 INS42 INS42 INS21 INS25 INS29 INS83 INS42 INS44 INS43 INS8 INS44 INS68 UPD42 MOV42 INS5 INS59 INS58 INS27 INS37 INS8 INS9 INS42 UPD42 INS25 INS68 INS42 INS32 INS32 INS8 INS8 INS65 INS65 INS43 INS42 INS42 INS17 INS39 INS42 INS25 INS60 INS42 INS42 INS69 INS43 INS85 UPD42 MOV42 INS32 INS39 INS59 INS42 INS40 INS42 INS25 INS32 INS8 MOV8 INS42 INS42 INS69 INS42 INS42 INS42 INS41 INS41 INS42 INS42 INS42 INS42 INS9 INS42 INS8 MOV39 INS59 INS43 INS40 INS42 INS42 INS42 INS34 INS32 INS8 UPD43 INS42 INS42 INS41 INS43 INS9 INS32 MOV60 MOV60 MOV21 MOV42 MOV32 INS42 INS42 INS42 INS32 INS41 INS42 INS32 INS42 INS14 INS42 INS32 INS40 UPD42 UPD42 INS2 INS42 INS9 INS42 INS43 INS42 INS9 INS32 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD45 DEL40 DEL26 DEL83 DEL43 DEL59 DEL23 DEL42 DEL42 DEL42 DEL40 DEL32 DEL7 DEL21 DEL40 DEL42 DEL43 DEL42 DEL13 DEL9 DEL9 DEL59 DEL60 DEL42 DEL43 DEL85 DEL5 DEL42 DEL59 DEL60 DEL40 DEL34 DEL27 DEL39 DEL42 DEL40 DEL34 DEL27 DEL59 DEL58 DEL42 DEL34 DEL27 DEL42 DEL38 DEL27 DEL42 DEL37 DEL42 DEL42 DEL42 DEL42 DEL42 DEL2 DEL32 DEL7 DEL21 DEL8 DEL24 DEL8 DEL25
JCR-999  SPI: provide batch read functionality
JCR-1000 JCR2SPI: remove duplicate item states

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@552873 13f79535-47bb-0310-9956-ffa450edef68

-import javax.jcr.PropertyType;
-import javax.jcr.ValueFormatException;
-import javax.jcr.RepositoryException;
-import javax.jcr.nodetype.ConstraintViolationException;
-
-import org.apache.jackrabbit.spi.QPropertyDefinition;
-import org.apache.jackrabbit.spi.PropertyId;
-import org.apache.jackrabbit.spi.ItemId;
-import org.apache.jackrabbit.spi.QValue;
-import org.apache.jackrabbit.jcr2spi.nodetype.ValueConstraint;
-import org.apache.jackrabbit.jcr2spi.nodetype.ItemDefinitionProvider;
+import org.apache.jackrabbit.jcr2spi.nodetype.ItemDefinitionProvider;
+import org.apache.jackrabbit.jcr2spi.nodetype.ValueConstraint;
+import org.apache.jackrabbit.spi.ItemId;
+import org.apache.jackrabbit.spi.PropertyInfo;
+import org.apache.jackrabbit.spi.QPropertyDefinition;
+import org.apache.jackrabbit.spi.QValue;
+import javax.jcr.PropertyType;
+import javax.jcr.RepositoryException;
+import javax.jcr.ValueFormatException;
+import javax.jcr.nodetype.ConstraintViolationException;
-     * The internal value(s)
-     */
-    private QValue[] values;
-
-    /**
-     * The type of this property state
-     */
-    private int type;
-
-    /**
-     * Constructs a new property state that is initially connected to an
-     * overlayed state.
-     * @param overlayedState
-     * @param initialStatus
-    protected PropertyState(PropertyState overlayedState, int initialStatus,
-                            ItemStateFactory isf) {
-        super(overlayedState, initialStatus, isf);
-
-        this.definition = overlayedState.definition;
-        this.multiValued = overlayedState.multiValued;
-
-        init(overlayedState.getType(), overlayedState.getValues());
-    }
+    private TransientData transientData;
-     * Create a new <code>PropertyState</code>
+     *
+     */
+    private PropertyInfo pInfo;
+
+    /**
+     * Create a NEW PropertyState
-     * @param initialStatus
-     * @param isWorkspaceState
+     * @param isf
+     * @param definition
+     * @param definitionProvider
-    protected PropertyState(PropertyEntry entry, boolean multiValued, QPropertyDefinition definition,
-                            int initialStatus, boolean isWorkspaceState,
-                            ItemStateFactory isf, ItemDefinitionProvider definitionProvider) {
-        super(initialStatus, isWorkspaceState, entry, isf, definitionProvider);
-
+    protected PropertyState(PropertyEntry entry, ItemStateFactory isf,
+                            QPropertyDefinition definition,
+                            ItemDefinitionProvider definitionProvider) {
+        super(Status.NEW, entry, isf, definitionProvider);
+        this.multiValued = definition.isMultiple();
-        this.multiValued = multiValued;
-        init(PropertyType.UNDEFINED, QValue.EMPTY_ARRAY);
+        this.transientData = null; // TODO: maybe type/values should be passed to constructor
+        this.pInfo = null;
+     * Create an EXISTING PropertyState
-     * @param type
-     * @param values
+     * @param entry
+     * @param pInfo
+     * @param isf
+     * @param definition
+     * @param definitionProvider
-    void init(int type, QValue[] values) {
-        // free old values as necessary
-        QValue[] oldValues = this.values;
-        if (oldValues != null) {
-            for (int i = 0; i < oldValues.length; i++) {
-                QValue old = oldValues[i];
-                if (old != null) {
-                    // make sure temporarily allocated data is discarded
-                    // before overwriting it (see QValue#discard())
-                    old.discard();
-                }
-            }
-        }
-        this.type = type;
-        this.values = (values == null) ? QValue.EMPTY_ARRAY : values;
+    protected PropertyState(PropertyEntry entry, PropertyInfo pInfo,
+                            ItemStateFactory isf,
+                            QPropertyDefinition definition,
+                            ItemDefinitionProvider definitionProvider) {
+        super(entry, isf, definitionProvider);
+        this.multiValued = pInfo.isMultiValued();
+        this.definition = definition;
+        this.transientData = null;
+        this.pInfo = pInfo;
-
-        return getPropertyId();
+        return ((PropertyEntry) getHierarchyEntry()).getId();
+    }
+
+    /**
+     * {@inheritDoc}
+     * @see ItemState#getWorkspaceId()
+     */
+    public ItemId getWorkspaceId() {
+        return ((PropertyEntry) getHierarchyEntry()).getWorkspaceId();
-        if (keepChanges || !diff(this, (PropertyState) another)) {
-            // nothing to do.
-            return false;
+        boolean modified = diff(this, (PropertyState) another);
+        this.pInfo = ((PropertyState) another).pInfo;
+        if (!keepChanges && transientData != null) {
+            modified = true;
+            transientData.discardValues();
+            transientData = null;
+        return modified;
+    }
-        synchronized (another) {
-            PropertyState pState = (PropertyState) another;
-            init(pState.type, pState.values);
+    /**
+     * @see ItemState#revert()
+     * @return true if
+     */
+    public boolean revert() {
+        if (getStatus() == Status.NEW) {
+            throw new IllegalStateException("Cannot call revert on a NEW property state.");
-        return true;
+        if (transientData == null) {
+            return false;
+        } else {
+            transientData.discardValues();
+            transientData = null;
+            return true;
+        }
+    }
+
+
+    /**
+     * {@inheritDoc}
+     * @see ItemState#persisted(ChangeLog)
+     */
+    void persisted(ChangeLog changeLog)
+        throws IllegalStateException {
+        for (Iterator it = changeLog.modifiedStates(); it.hasNext();) {
+            ItemState modState = (ItemState) it.next();
+            if (modState == this) {
+                /*
+                NOTE: Property can only be the changelog target, if it was
+                existing and has been modified. removal, add and implicit modification
+                of protected properties must be persisted by save on parent.
+                */
+                setStatus(Status.EXISTING);
+            }
+        }
-     * Returns the identifier of this property.
-     *
-     * @return the id of this property.
-     */
-    public PropertyId getPropertyId() {
-        if (isWorkspaceState()) {
-            return getPropertyEntry().getWorkspaceId();
-        } else {
-            return getPropertyEntry().getId();
-        }
-    }
-
-    /**
-        return type;
+        return (transientData == null) ? pInfo.getType() : transientData.type;
-        return values;
+        // if transientData are null the pInfo MUST be present (ev. add check)
+        return (transientData == null) ? pInfo.getValues() : transientData.values;
+        QValue[] values = getValues();
-
-    /**
-     * {@inheritDoc}
-     * @see ItemState#persisted(ChangeLog)
-     */
-    void persisted(ChangeLog changeLog)
-        throws IllegalStateException {
-        checkIsSessionState();
-        for (Iterator it = changeLog.modifiedStates(); it.hasNext();) {
-            ItemState modState = (ItemState) it.next();
-            if (modState == this) {
-                /*
-                NOTE: overlayedState must be existing, otherwise save was not
-                possible on prop. Similarly a property can only be the changelog
-                target, if it was modified. removal, add and implicit modification
-                of protected properties must be persisted by save on parent.
-                */
-                // push changes to overlayed state and reset status
-                ((PropertyState) overlayedState).init(getType(), getValues());
-                setStatus(Status.EXISTING);
-            }
-        }
-    }
-        checkIsSessionState();
-        // make sure the arguements are consistent and do not violate the
-        // given property definition.
-        validate(values, type, getDefinition());
-        init(type, values);
-
+        if (transientData == null) {
+            transientData = new TransientData(type, values);
+        } else {
+            transientData.setValues(type, values);
+        }
-     *
-     * @return
-     */
-    private PropertyEntry getPropertyEntry() {
-        return (PropertyEntry) getHierarchyEntry();
-    }
-
-    /**
+
+    //--------------------------------------------------------< inner class >---
+    /**
+     * Inner class storing transient property values an their type.
+     */
+    private class TransientData {
+
+        private int type;
+        private QValue[] values;
+
+        private TransientData(int type, QValue[] values) throws RepositoryException {
+            setValues(type, values);
+        }
+
+        private void setValues(int type, QValue[] values) throws RepositoryException {
+            // make sure the arguements are consistent and do not violate the
+            // given property definition.
+            validate(values, type, getDefinition());
+            // free old values if existing
+            discardValues();
+
+            this.type = type;
+            this.values = (values == null) ? QValue.EMPTY_ARRAY : values;
+        }
+
+        private void discardValues() {
+            if (values != null) {
+                for (int i = 0; i < values.length; i++) {
+                    if (values[i] != null) {
+                        // make sure temporarily allocated data is discarded
+                        // before overwriting it (see QValue#discard())
+                        values[i].discard();
+                    }
+                }
+            }
+        }
+    }

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV23 MOV31 MOV31 UPD40 INS23 INS31 INS55 INS43 INS59 INS29 INS83 INS43 INS59 MOV44 MOV44 MOV21 MOV44 MOV21 INS29 INS83 INS43 INS42 MOV8 INS83 UPD39 UPD42 INS8 INS29 INS83 INS42 INS23 MOV23 INS31 INS31 MOV31 INS42 INS42 INS42 INS42 INS65 INS65 UPD43 UPD42 INS43 UPD42 INS21 INS21 INS65 INS65 INS43 INS42 INS43 UPD42 INS21 INS65 INS65 INS42 INS60 INS21 INS25 INS41 UPD65 UPD65 INS25 MOV25 MOV60 INS25 MOV65 INS83 INS39 MOV59 INS83 INS42 INS44 INS44 INS43 INS8 INS83 INS39 INS42 MOV44 MOV44 INS43 INS8 INS39 INS42 INS8 UPD66 UPD42 INS42 UPD42 INS42 UPD42 INS42 INS40 UPD42 UPD42 UPD42 INS7 INS7 UPD66 INS42 INS42 UPD42 UPD42 INS42 INS42 INS7 INS7 INS65 INS68 INS32 INS39 INS59 INS7 INS27 INS8 INS42 INS68 INS66 INS27 INS8 UPD27 MOV8 INS16 INS16 INS27 INS8 INS8 UPD66 INS39 INS42 INS5 INS42 INS42 INS21 INS42 MOV21 INS21 MOV21 MOV21 INS25 INS32 INS42 INS22 INS33 INS22 INS33 INS32 INS22 INS33 INS22 INS42 INS36 UPD42 INS42 INS42 INS36 INS42 INS42 MOV32 INS22 INS22 MOV38 INS27 INS21 MOV21 INS21 INS42 INS42 INS32 UPD40 MOV40 INS53 UPD42 INS21 MOV41 INS36 INS32 INS40 INS36 INS32 INS40 UPD42 MOV32 INS42 INS33 MOV21 MOV21 INS43 INS85 INS32 INS32 INS27 INS8 INS42 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS11 MOV11 INS52 INS42 INS36 INS42 INS42 INS42 INS33 INS7 INS7 INS42 INS14 INS7 INS27 INS42 INS42 INS27 INS42 INS42 INS7 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS33 INS24 INS43 INS32 MOV11 INS42 INS9 UPD42 INS42 INS42 INS33 INS43 INS45 UPD42 UPD42 INS42 INS33 INS42 INS33 INS42 INS33 INS42 INS14 UPD42 INS42 MOV58 INS27 MOV37 INS8 INS42 INS42 UPD42 MOV42 INS43 INS42 INS42 INS42 INS40 INS25 INS42 INS27 INS8 INS2 INS33 INS21 INS42 INS42 INS32 INS2 INS42 INS42 INS42 DEL66 DEL65 DEL39 DEL66 DEL39 DEL40 DEL40 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL21 DEL39 DEL42 DEL39 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL40 DEL40 DEL32 DEL40 DEL40 DEL42 DEL27 DEL25 DEL42 DEL42 DEL43 DEL42 DEL59 DEL60 DEL8 DEL51 DEL42 DEL42 DEL42 DEL33 DEL27 DEL42 DEL27 DEL43 DEL42 DEL42 DEL42 DEL2 DEL59 DEL60 DEL8 DEL24 DEL8 DEL25 DEL8 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL42 DEL32 DEL32 DEL21 DEL66 DEL65 DEL29 DEL83 DEL43 DEL42 DEL42 DEL32 DEL32 DEL32 DEL41 DEL8 DEL32 DEL42 DEL32 DEL41 DEL8 DEL25 DEL8 DEL31 DEL42 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL66 DEL65 DEL29 DEL65 DEL29 DEL42 DEL43 DEL42
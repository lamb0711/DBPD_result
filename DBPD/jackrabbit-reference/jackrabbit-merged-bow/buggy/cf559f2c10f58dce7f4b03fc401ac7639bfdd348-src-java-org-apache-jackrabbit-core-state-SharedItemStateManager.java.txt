Fixed deadlock issue.
- introduced separate monitor for item state cache operations
- removed synchronized() where not needed and added comment


git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@159676 13f79535-47bb-0310-9956-ffa450edef68

-     * Adds a new virtual item state provider
-     *
+     * Adds a new virtual item state provider.<p/>
+     * NOTE: This method is not synchronized, because it is called right after
+     * creation only by the same thread and therefore concurrency issues
+     * do not occur. Should this ever change, the synchronization status
+     * has to be re-examined.
-    public synchronized void addVirtualItemStateProvider(VirtualItemStateProvider prov) {
+    public void addVirtualItemStateProvider(VirtualItemStateProvider prov) {
+    /**
+     * Create root node state
+     * @param rootNodeUUID root node UUID
+     * @param ntReg node type registry
+     * @return root node state
+     * @throws ItemStateException if an error occurs
+     */
-        // check cache
-        if (isCached(id)) {
-            return (NodeState) retrieve(id);
-        }
-
-        // check cache
-        if (isCached(id)) {
-            return (PropertyState) retrieve(id);
-        }
-
-    public synchronized ItemState getItemState(ItemId id)
+    public ItemState getItemState(ItemId id)
-        if (id.denotesNode()) {
-            return getNodeState((NodeId) id);
-        } else {
-            return getPropertyState((PropertyId) id);
+
+        // check cache. synchronized to ensure an entry is not created twice.
+        synchronized (cacheMonitor) {
+            if (isCached(id)) {
+                return retrieve(id);
+            }
+            if (id.denotesNode()) {
+                return getNodeState((NodeId) id);
+            } else {
+                return getPropertyState((PropertyId) id);
+            }
-    public synchronized boolean hasItemState(ItemId id) {
+    public boolean hasItemState(ItemId id) {
-    public synchronized NodeReferences getNodeReferences(NodeReferencesId id)
+    public NodeReferences getNodeReferences(NodeReferencesId id)
-        // todo: add caching
-
-     * about the changes, if an observation manager is passed to this method.
+     * about the changes, if an observation manager is passed to this method.<p/>
+     * NOTE: This method is not synchronized, because all methods it invokes
+     * on instance members (such as {@link PersistenceManager#store} are
+     * considered to be thread-safe. Should this ever change, the
+     * synchronization status has to be re-examined.
-    public synchronized void store(ChangeLog local, ObservationManagerImpl obsMgr) throws ItemStateException {
+    public void store(ChangeLog local, ObservationManagerImpl obsMgr)
+            throws ItemStateException {
+
-                        String msg = "Target node " + id + " of REFERENCE property does not exist";
+                        String msg = "Target node " + id +
+                                " of REFERENCE property does not exist";

INS29 INS8 INS65 INS65 INS65 INS65 INS65 INS51 UPD66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 MOV8 UPD66 INS66 INS66 INS65 INS66 INS66 INS66 MOV25 INS67 INS42 INS42 MOV32 DEL83 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL41 DEL8 DEL25 DEL83 DEL42 DEL43 DEL11 DEL83 DEL83 DEL83
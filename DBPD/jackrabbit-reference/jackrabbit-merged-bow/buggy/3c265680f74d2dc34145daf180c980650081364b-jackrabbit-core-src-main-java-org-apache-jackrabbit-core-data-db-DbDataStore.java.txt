JCR-2026 DbDataStore: garbage collection deadlock (fix and test case)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1102270 13f79535-47bb-0310-9956-ffa450edef68

+import java.sql.SQLException;
-        "UPDATE ${tablePrefix}${table} SET ID=?, LENGTH=?, LAST_MODIFIED=?"
-        + " WHERE ID=? AND NOT EXISTS(SELECT ID FROM ${tablePrefix}${table} WHERE ID=?)";
+        "UPDATE ${tablePrefix}${table} SET ID=?, LENGTH=?, LAST_MODIFIED=? " +
+        "WHERE ID=? AND LAST_MODIFIED=?";
-    /**
-     * {@inheritDoc}
-     */
-    /**
-     * {@inheritDoc}
-     */
-        ResultSet rs = null;
-        String id = null, tempId = null;
+        String tempId = null;
+        ResultSet rs = null;
-            long now;
+            long tempModified;
-                    now = System.currentTimeMillis();
-                    id = UUID.randomUUID().toString();
+                    tempModified = System.currentTimeMillis();
+                    String id = UUID.randomUUID().toString();
+                    temporaryInUse.add(tempId);
-                    rs = conHelper.exec(selectMetaSQL, new Object[]{tempId}, false, 0);
-                    if (rs.next()) {
+                    rs = conHelper.query(selectMetaSQL, tempId);
+                    boolean hasNext = rs.next();
+                    rs.close();
+                    rs = null;
+                    if (hasNext) {
-                    conHelper.exec(insertTempSQL, new Object[]{tempId, new Long(now)});
+                    conHelper.exec(insertTempSQL, tempId, tempModified);
+                    // prevent that rs.close() is called again
+                    rs = null;
-            if (id == null) {
-                String msg = "Can not create new record";
-                log.error(msg);
-                throw new DataStoreException(msg);
-            }
-            temporaryInUse.add(tempId);
-            conHelper.exec(updateDataSQL, new Object[]{wrapper, tempId});
-            now = System.currentTimeMillis();
+            conHelper.exec(updateDataSQL, wrapper, tempId);
-            id = identifier.toString();
-            // UPDATE DATASTORE SET ID=?, LENGTH=?, LAST_MODIFIED=?
-            // WHERE ID=?
-            // AND NOT EXISTS(SELECT ID FROM DATASTORE WHERE ID=?)
-            int count = conHelper.update(updateSQL, new Object[]{
-                    id, new Long(length), new Long(now),
-                    tempId, id});
-            rs = null; // prevent that rs.close() is called in finally block if count != 0 (rs is closed above)
-            if (count == 0) {
-                // update count is 0, meaning such a row already exists
-                // DELETE FROM DATASTORE WHERE ID=?
-                conHelper.exec(deleteSQL, new Object[]{tempId});
-                // SELECT LENGTH, LAST_MODIFIED FROM DATASTORE WHERE ID=?
-                rs = conHelper.exec(selectMetaSQL, new Object[]{id}, false, 0);
-                if (rs.next()) {
-                    long oldLength = rs.getLong(1);
-                    long lastModified = rs.getLong(2);
-                    if (oldLength != length) {
-                        String msg =
-                            DIGEST + " collision: temp=" + tempId
-                            + " id=" + id + " length=" + length
-                            + " oldLength=" + oldLength;
-                        log.error(msg);
-                        throw new DataStoreException(msg);
-                    }
-                    touch(identifier, lastModified);
+            String id = identifier.toString();
+            long newModified;
+            while (true) {
+                newModified = System.currentTimeMillis();
+                if (checkExisting(tempId, length, identifier)) {
+                    touch(identifier, newModified);
+                    conHelper.exec(deleteSQL, tempId);
+                    break;
+                try {
+                    // UPDATE DATASTORE SET ID=?, LENGTH=?, LAST_MODIFIED=?
+                    // WHERE ID=? AND LAST_MODIFIED=?
+                    int count = conHelper.update(updateSQL,
+                            id, length, newModified, tempId, tempModified);
+                    if (count == 0) {
+                        // update count is 0, meaning the last modified time of the
+                        // temporary row was changed - which means we need to
+                        // re-try using a new last modified date (a later one)
+                        // because we need to ensure the new last modified date
+                        // is _newer_ than the old (otherwise the garbage collection
+                        // could delete rows)
+                    } else {
+                        // update was successful
+                        break;
+                    }
+                } catch (SQLException e) {
+                    // duplicate key (the row already exists) - repeat
+                    // we use exception handling for flow control here, which is bad,
+                    // but the alternative is to use UPDATE ... WHERE ... (SELECT ...)
+                    // which could cause a deadlock in some databases - also,
+                    // duplicate key will only occur if somebody else concurrently
+                    // added the same record (which is very unlikely)
+                }
+                // SELECT LENGTH, LAST_MODIFIED FROM DATASTORE WHERE ID=?
+                rs = conHelper.query(selectMetaSQL, tempId);
+                if (!rs.next()) {
+                    // the row was deleted, which is unexpected / not allowed
+                    String msg =
+                        DIGEST + " temporary entry deleted: " +
+                            " id=" + tempId + " length=" + length;
+                    log.error(msg);
+                    throw new DataStoreException(msg);
+                }
+                tempModified = rs.getLong(2);
+                DbUtility.close(rs);
+                rs = null;
-            DbDataRecord record = new DbDataRecord(this, identifier, length, now);
+            DbDataRecord record = new DbDataRecord(this, identifier, length, newModified);
+     * Check if a row with this ID already exists.
+     *
+     * @return true if the row exists and the length matches
+     * @throw DataStoreException if a row exists, but the length is different
+     */
+    private boolean checkExisting(String tempId, long length, DataIdentifier identifier) throws DataStoreException, SQLException {
+        String id = identifier.toString();
+        // SELECT LENGTH, LAST_MODIFIED FROM DATASTORE WHERE ID=?
+        ResultSet rs = null;
+        try {
+            rs = conHelper.query(selectMetaSQL, id);
+            if (rs.next()) {
+                long oldLength = rs.getLong(1);
+                long lastModified = rs.getLong(2);
+                if (oldLength != length) {
+                    String msg =
+                        DIGEST + " collision: temp=" + tempId
+                        + " id=" + id + " length=" + length
+                        + " oldLength=" + oldLength;
+                    log.error(msg);
+                    throw new DataStoreException(msg);
+                }
+                touch(identifier, lastModified);
+                // row already exists
+                conHelper.exec(deleteSQL, tempId);
+                return true;
+            }
+        } finally {
+            DbUtility.close(rs);
+        }
+        return false;
+    }
+
+    /**
-    /**
-     * {@inheritDoc}
-     */
-            return conHelper.update(deleteOlderSQL, new Long[]{new Long(min)});
+            return conHelper.update(deleteOlderSQL, min);
-    /**
-     * {@inheritDoc}
-     */
-            rs = conHelper.exec(selectAllSQL, new Object[0], false, 0);
+            rs = conHelper.query(selectAllSQL);
-    /**
-     * {@inheritDoc}
-     */
-    /**
-     * {@inheritDoc}
-     */
-            rs = conHelper.exec(selectMetaSQL, new Object[]{id}, false, 0);
+            rs = conHelper.query(selectMetaSQL, id);
-    /**
-     * {@inheritDoc}
-     */
-            rs = conHelper.exec(selectDataSQL, new Object[]{identifier.toString()}, false, 0);
+            rs = conHelper.query(selectDataSQL, identifier.toString());
-    /**
-     * {@inheritDoc}
-     */
+            // ok
+            // ok
+            // ok
-    /**
-     * {@inheritDoc}
-     */
-            Long n = new Long(now);
-                conHelper.exec(updateLastModifiedSQL, new Object[]{
-                        n, key, n
-                });
+                conHelper.update(updateLastModifiedSQL, now, key, now);
-    /**
-     * {@inheritDoc}
-     */
+        // nothing to do
-    /**
-     * {@inheritDoc}
-     */
+        // no effect

INS26 INS40 INS31 INS31 MOV60 MOV29 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS43 INS8 MOV83 MOV39 MOV42 MOV8 INS65 INS65 INS65 INS43 INS42 INS39 INS42 INS43 INS42 INS42 INS42 INS60 INS60 INS54 INS41 UPD45 UPD45 MOV21 INS66 INS66 INS66 INS42 INS42 INS43 INS59 INS43 INS59 MOV8 MOV8 INS9 INS60 INS60 INS61 INS42 INS42 INS32 INS42 INS42 INS33 MOV21 INS43 INS59 INS39 INS59 INS9 INS8 MOV43 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS32 INS42 MOV21 INS25 INS54 INS21 MOV25 INS21 INS21 INS21 INS21 INS41 INS42 UPD42 INS32 INS8 INS42 INS42 INS32 INS8 INS8 INS12 INS7 INS38 INS7 INS32 INS7 MOV43 UPD42 UPD42 INS42 INS32 INS9 UPD42 UPD42 INS42 INS42 INS42 INS42 MOV32 INS60 MOV21 INS60 INS21 MOV21 INS21 INS21 UPD42 INS42 INS42 INS42 INS42 INS21 INS21 INS10 MOV60 MOV25 INS44 INS8 INS42 INS32 MOV32 INS42 INS32 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 MOV43 INS59 INS39 INS59 INS32 INS42 INS32 INS7 INS32 INS32 INS8 INS8 INS43 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS34 UPD42 INS42 MOV32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS10 INS42 INS42 INS27 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS45 INS42 INS45 INS42 DEL65 DEL65 DEL29 DEL65 DEL65 DEL29 DEL42 DEL33 DEL59 DEL42 DEL7 DEL21 DEL42 DEL43 DEL85 DEL5 DEL42 DEL4 DEL3 DEL9 DEL34 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL42 DEL14 DEL4 DEL3 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL4 DEL3 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL42 DEL14 DEL42 DEL43 DEL42 DEL14 DEL42 DEL42 DEL4 DEL3 DEL42 DEL33 DEL27 DEL45 DEL65 DEL65 DEL42 DEL42 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL4 DEL3 DEL32 DEL21 DEL42 DEL43 DEL85 DEL5 DEL42 DEL4 DEL3 DEL9 DEL34 DEL65 DEL65 DEL29 DEL42 DEL43 DEL85 DEL5 DEL42 DEL43 DEL42 DEL14 DEL4 DEL3 DEL65 DEL65 DEL29 DEL42 DEL43 DEL85 DEL5 DEL34 DEL3 DEL9 DEL34 DEL31 DEL65 DEL65 DEL29 DEL42 DEL43 DEL85 DEL5 DEL42 DEL4 DEL3 DEL9 DEL34 DEL65 DEL65 DEL29 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL32 DEL4 DEL3 DEL9 DEL34 DEL32 DEL7 DEL21 DEL65 DEL65 DEL29 DEL65 DEL65 DEL29 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL4 DEL3 DEL65 DEL65 DEL29 DEL65 DEL65 DEL29
core.state: 
replaced abstract ItemStateCache with interface of same name and added ItemStateMap, ItemStateReferenceMap, ItemStateReferenceCache & LRUItemStateCache which provide cleaner semantics and improved memory usage behaviour

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@227042 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.collections.map.ReferenceMap;
+import java.util.ArrayList;
+import java.util.Collection;
-class TransientItemStateManager extends ItemStateCache implements ItemStateManager {
+class TransientItemStateManager implements ItemStateManager {
-    private final Attic attic;
+    /**
+     * map of those states that have been removed transiently
+     */
+    private final ItemStateMap atticMap;
+
+    /**
+     * map of new or modified transient states
+     */
+    private final ItemStateMap transientMap;
+
+    /**
+     * ItemStateManager view of the states in the attic; lazily instantiated
+     * in {@link #getAttic()}
+     */
+    private AtticItemStateManager attic;
-        // we're keeping hard references in the cache
-        super(ReferenceMap.HARD, ReferenceMap.HARD);
-        attic = new Attic();
+        transientMap = new ItemStateMap();
+        atticMap = new ItemStateMap();
-        super.dump(ps);
+        transientMap.dump(ps);
-        attic.dump(ps);
+        atticMap.dump(ps);
-        ItemState state = retrieve(id);
+        ItemState state = transientMap.get(id);
-        return isCached(id);
+        return transientMap.contains(id);
-        return !isEmpty();
+        return !transientMap.isEmpty();
-        return !attic.isEmpty();
+        return !atticMap.isEmpty();
-        return size();
+        return transientMap.size();
-        return attic.size();
+        return atticMap.size();
-        return entries();
+        return transientMap.values().iterator();
-        return attic.entries();
+        return atticMap.values().iterator();
-        // check cache. synchronized to ensure an entry is not created twice.
-        synchronized (cacheMonitor) {
-            if (isCached(id)) {
+        // check map; synchronized to ensure an entry is not created twice.
+        synchronized (transientMap) {
+            if (transientMap.contains(id)) {
-            // put it in cache
-            cache(state);
+            // put transient state in the map
+            transientMap.put(state);
-        // check cache. synchronized to ensure an entry is not created twice.
-        synchronized (cacheMonitor) {
-            if (isCached(id)) {
+        // check map; synchronized to ensure an entry is not created twice.
+        synchronized (transientMap) {
+            if (transientMap.contains(id)) {
-            // put it in cache
-            cache(state);
+            // put transient state in the map
+            transientMap.put(state);
-        // check cache. synchronized to ensure an entry is not created twice.
-        synchronized (cacheMonitor) {
-            if (isCached(id)) {
+        // check map; synchronized to ensure an entry is not created twice.
+        synchronized (transientMap) {
+            if (transientMap.contains(id)) {
-            // put it in cache
-            cache(state);
+            // put transient state in the map
+            transientMap.put(state);
-        // check cache. synchronized to ensure an entry is not created twice.
-        synchronized (cacheMonitor) {
-            if (isCached(id)) {
+        // check map; synchronized to ensure an entry is not created twice.
+        synchronized (transientMap) {
+            if (transientMap.contains(id)) {
-            // put it in cache
-            cache(state);
+            // put transient state in the map
+            transientMap.put(state);
-     * Disposes the specified instance, i.e. discards it and clears it from cache.
+     * Disposes the specified instance, i.e. discards it and removes it from
+     * the map.
-        // remove from cache
-        evict(state.getId());
+        // remove from map
+        transientMap.remove(state.getId());
-     * Transfers the specified instance from the 'active' cache to the attic.
+     * Transfers the specified instance from the 'active' map to the attic.
-        // remove from cache
-        evict(state.getId());
+        // remove from map
+        transientMap.remove(state.getId());
-        attic.cache(state);
+        atticMap.put(state);
-        attic.evict(state.getId());
+        atticMap.remove(state.getId());
-        // dispose item states in cache
-        Iterator iter = entries();
+        // dispose item states in transient map & attic
+        // (use temp collection to avoid ConcurrentModificationException)
+        Collection tmp = new ArrayList(transientMap.values());
+        Iterator iter = tmp.iterator();
-        // dispose item states in attic
-        iter = attic.entries();
+        tmp = new ArrayList(atticMap.values());
+        iter = tmp.iterator();
+        if (attic == null) {
+            attic = new AtticItemStateManager();
+        }
-    class Attic extends ItemStateCache implements ItemStateManager {
+    /**
+     * ItemStateManager view of the states in the attic
+     *
+     * @see TransientItemStateManager#getAttic
+     */
+    private class AtticItemStateManager implements ItemStateManager {
-        Attic() {
-            super(ReferenceMap.HARD, ReferenceMap.HARD);
+        AtticItemStateManager() {
-            ItemState state = retrieve(id);
+            ItemState state = atticMap.get(id);
-            return isCached(id);
+            return atticMap.contains(id);
-
+            // n/a
+            // n/a

MOV26 INS26 MOV31 MOV31 INS40 UPD40 INS23 INS23 INS29 INS83 INS83 INS43 INS59 INS29 UPD43 INS59 INS29 INS83 INS43 MOV59 MOV29 MOV44 MOV29 MOV44 MOV29 MOV29 MOV29 MOV29 MOV29 MOV43 MOV29 MOV43 INS8 MOV8 INS8 MOV8 MOV29 UPD42 MOV44 MOV29 UPD42 MOV44 INS8 INS29 INS83 INS42 INS65 UPD42 MOV42 INS42 INS65 UPD42 INS42 INS65 INS42 INS21 MOV60 INS51 MOV60 MOV60 INS51 MOV60 INS60 INS21 INS25 MOV41 INS65 INS65 UPD42 MOV29 MOV44 MOV29 MOV44 INS66 INS66 INS66 INS66 INS65 INS7 INS32 INS32 INS32 INS42 INS8 UPD42 INS42 INS8 UPD42 UPD66 INS66 UPD66 INS43 INS59 INS7 INS27 INS8 INS66 INS67 INS68 INS42 INS14 UPD42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS42 UPD42 INS32 INS42 INS32 INS42 INS25 MOV60 INS21 MOV41 MOV60 MOV41 INS25 MOV60 INS21 MOV41 MOV60 MOV41 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS14 INS42 INS14 INS42 INS33 INS21 INS42 INS42 INS42 INS43 UPD43 UPD42 INS42 INS42 UPD42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS32 MOV8 INS32 INS32 MOV8 INS32 INS43 INS32 UPD42 INS42 INS43 INS32 UPD42 UPD42 INS7 UPD42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 UPD42 INS42 INS43 INS42 DEL43 DEL40 DEL40 DEL46 DEL42 DEL42 DEL48 DEL32 DEL32 DEL42 DEL42 DEL42 DEL32 DEL25 DEL42 DEL42 DEL32 DEL21 DEL8 DEL51 DEL8 DEL42 DEL42 DEL42 DEL32 DEL25 DEL42 DEL42 DEL32 DEL21 DEL8 DEL51 DEL8 DEL8 DEL42 DEL42 DEL43 DEL40 DEL40 DEL46
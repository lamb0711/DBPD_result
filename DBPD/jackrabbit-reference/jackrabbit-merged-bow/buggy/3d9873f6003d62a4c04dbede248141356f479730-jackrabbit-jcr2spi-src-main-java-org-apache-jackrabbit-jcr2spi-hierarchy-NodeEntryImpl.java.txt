JCR-2498: Implement caching mechanism for ItemInfo batches

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@915810 13f79535-47bb-0310-9956-ffa450edef68

-     * Information regarding the invalidation status of the underlying {@link ItemState}
-     * of this entry. The semantics depend on the {@link EntryFactory.InvalidationStrategy}.
-     */
-    private long invalidationStatus;
-
-    /**
-    @Override
-    public void invalidate(boolean recursive) {
-        getInvalidationStrategy().invalidate(this, recursive);
-    }
-
-    public void calculateStatus() {
-        getInvalidationStrategy().applyPending(this);
-    }
-
-     * attic back into th properties map. If this HierarchyEntry has been
+     * attic back into the properties map. If this HierarchyEntry has been
-       NodeEntryImpl entry = (NodeEntryImpl) parent.childNodeEntries.remove(this);
+       NodeEntry entry = parent.childNodeEntries.remove(this);
-                childNodeAttic.remove((NodeEntryImpl) childEntry);
+                childNodeAttic.remove((NodeEntry) childEntry);
-    private EntryFactory.InvalidationStrategy getInvalidationStrategy() {
-        return factory.getInvalidationStrategy();
-    }
-
-    /**
-     * Invalidates the underlying {@link ItemState}. If <code>recursive</code> is
-     * true also invalidates the underlying item states of all child entries.
-     * @param recursive
-     */
-    private void invalidateInternal(boolean recursive) {
+    @Override
+    protected void invalidateInternal(boolean recursive) {
-        super.invalidate(true);
+        super.invalidateInternal(true);
-        private final NodeEntryImpl oldSuccessor;
-        private final NodeEntryImpl oldPredecessor;
+        private final NodeEntry oldSuccessor;
+        private final NodeEntry oldPredecessor;
-            this.oldSuccessor = (NodeEntryImpl) ((ChildNodeEntriesImpl) parent.childNodeEntries).getNext(NodeEntryImpl.this);
-            this.oldPredecessor = (NodeEntryImpl) ((ChildNodeEntriesImpl) parent.childNodeEntries).getPrevious(NodeEntryImpl.this);
+            this.oldSuccessor = ((ChildNodeEntriesImpl) parent.childNodeEntries).getNext(NodeEntryImpl.this);
+            this.oldPredecessor = ((ChildNodeEntriesImpl) parent.childNodeEntries).getPrevious(NodeEntryImpl.this);
-                NodeEntryImpl ne = NodeEntryImpl.this;
+                NodeEntry ne = NodeEntryImpl.this;
-    // ----------------------------------------------< InvalidationStrategy >---
-    /**
-     * An implementation of <code>InvalidationStrategy</code> which lazily invalidates
-     * the underlying {@link ItemState}s.
-     */
-    static class LazyInvalidation implements EntryFactory.InvalidationStrategy {
-
-        /**
-         * Marker for entries with a pending recursive invalidation.
-         */
-        private static long INVALIDATION_PENDING = -1;
-
-        /**
-         * Time stamp of the last time a recursive invalidation occurred.
-         */
-        private long lastInvalidation;
-
-        /**
-         * A recursive invalidation is being processed if <code>true</code>.
-         * This flag is for preventing re-entrance.
-         */
-        private boolean invalidating;
-
-        /**
-         * Actual time stamp
-         */
-        private long timeStamp;
-
-        /**
-         * @return  time stamp used to mark entries
-         */
-        private long getTimeStamp() {
-            return timeStamp++;
-        }
-
-        /**
-         * Records a pending recursive {@link ItemState#invalidate() invalidation} for
-         * <code>entry</code> if <code>recursive</code> is <code>true</code>. Otherwise
-         * invalidates the entry right away.
-         * {@inheritDoc}
-         */
-        public void invalidate(NodeEntry entry, boolean recursive) {
-            if (recursive) {
-                ((NodeEntryImpl)entry).invalidationStatus = INVALIDATION_PENDING;
-                if (!invalidating) {
-                    lastInvalidation = getTimeStamp();
-                }
-            } else {
-                ((NodeEntryImpl)entry).invalidateInternal(false);
-            }
-        }
-
-        /**
-         * Checks whether <code>entry</code> itself has a invalidation pending.
-         * If so, the <code>entry</code> is invalidated. Otherwise check
-         * whether an invalidation occurred after the entry has last been
-         * invalidated. If so, search the path to the root for an originator of
-         * the pending invalidation.
-         * If such an originator is found, invalidate each entry on the path.
-         * Otherwise this method does nothing.
-         * {@inheritDoc}
-         */
-        public void applyPending(NodeEntry entry) {
-            if (!invalidating) {
-                invalidating = true;
-                try {
-                    NodeEntryImpl ne = (NodeEntryImpl) entry;
-                    if (ne.invalidationStatus == INVALIDATION_PENDING) {
-                        ne.invalidateInternal(true);
-                        ne.invalidationStatus = getTimeStamp();
-                    } else if (ne.invalidationStatus <= lastInvalidation) {
-                        resolvePendingInvalidation(ne);
-                    }
-                } finally {
-                    invalidating = false;
-                }
-            }
-        }
-
-        /**
-         * Search the path to the root for an originator of a pending invalidation of
-         * this <code>entry</code>. If such an originator is found, invalidate each
-         * entry on the path. Otherwise do nothing.
-         *
-         * @param entry
-         */
-        private void resolvePendingInvalidation(NodeEntryImpl entry) {
-            if (entry != null) {
-
-                // First recursively travel up to the first parent node
-                // which has invalidation pending or to the root node if
-                // no such node exists.
-                if (entry.invalidationStatus != INVALIDATION_PENDING) {
-                    resolvePendingInvalidation(entry.parent);
-                }
-
-                // Then travel the path backwards invalidating as required
-                if (entry.invalidationStatus == INVALIDATION_PENDING) {
-                    entry.invalidateInternal(true);
-                }
-                entry.invalidationStatus = getTimeStamp();
-            }
-        }
-    }
-
-    /**
-     * An implementation of <code>InvalidationStrategy</code> which eagerly invalidates
-     * the underlying {@link ItemState}s.
-     */
-    static class EagerInvalidation implements EntryFactory.InvalidationStrategy {
-
-        /**
-         * Calls {@link ItemState#invalidate()} for the underlying item state of this
-         * <code>entry</code> and - if <code>recursive</code> is <code>true</code> -
-         * recursively for all item states of all child entries
-         * {@inheritDoc}
-         */
-        public void invalidate(NodeEntry entry, boolean recursive) {
-            ((NodeEntryImpl) entry).invalidateInternal(recursive);
-        }
-
-        /**
-         * Does nothing since invalidation has occurred already.
-         * {@inheritDoc}
-         */
-        public void applyPending(NodeEntry entry) {
-            // Empty
-        }
-    }

INS83 INS42 MOV78 UPD83 UPD43 UPD43 UPD66 MOV43 UPD42 UPD42 MOV32 UPD42 MOV32 MOV32 MOV43 MOV43 UPD42 MOV42 DEL83 DEL42 DEL66 DEL42 DEL65 DEL66 DEL40 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL32 DEL42 DEL52 DEL42 DEL32 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL32 DEL42 DEL52 DEL32 DEL21 DEL8 DEL31 DEL42 DEL43 DEL11 DEL83 DEL40 DEL43 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL66 DEL42 DEL65 DEL66 DEL66 DEL65 DEL42 DEL65 DEL29 DEL42 DEL43 DEL11 DEL42 DEL43 DEL11 DEL66 DEL66 DEL42 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL40 DEL43 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL34 DEL38 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL59 DEL23 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL37 DEL41 DEL8 DEL31 DEL66 DEL42 DEL42 DEL68 DEL66 DEL65 DEL66 DEL66 DEL66 DEL65 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL38 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL9 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL44 DEL42 DEL38 DEL42 DEL9 DEL7 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL40 DEL42 DEL27 DEL42 DEL42 DEL9 DEL32 DEL21 DEL40 DEL42 DEL32 DEL7 DEL21 DEL8 DEL40 DEL42 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL25 DEL8 DEL42 DEL9 DEL7 DEL21 DEL8 DEL54 DEL8 DEL25 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL42 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL33 DEL27 DEL40 DEL42 DEL27 DEL42 DEL40 DEL32 DEL21 DEL8 DEL25 DEL40 DEL42 DEL27 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL25 DEL40 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL31 DEL55 DEL66 DEL66 DEL42 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL40 DEL43 DEL66 DEL42 DEL42 DEL68 DEL65 DEL66 DEL66 DEL66 DEL65 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL66 DEL65 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL44 DEL8 DEL31 DEL55
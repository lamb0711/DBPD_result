JCR-4339 Indexing configuration condition property seems to be broken

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1836620 13f79535-47bb-0310-9956-ffa450edef68

-import javax.jcr.nodetype.NoSuchNodeTypeException;
+import org.apache.jackrabbit.core.nodetype.EffectiveNodeType;
-        IndexingRule rule = getApplicableIndexingRule(state, propertyName);
+        IndexingRule rule = getApplicableIndexingRule(state);
-            return rule.isIndexed(propertyName);
+            return rule.isIndexed(state, propertyName);
-        IndexingRule rule = getApplicableIndexingRule(state, propertyName);
+        IndexingRule rule = getApplicableIndexingRule(state);
-        IndexingRule rule = getApplicableIndexingRule(state, null);
+        IndexingRule rule = getApplicableIndexingRule(state);
-        IndexingRule rule = getApplicableIndexingRule(state, propertyName);
+        IndexingRule rule = getApplicableIndexingRule(state);
-        IndexingRule rule = getApplicableIndexingRule(state, propertyName);
+        IndexingRule rule = getApplicableIndexingRule(state);
-                        perNtConfig.add(new IndexingRule(element, ntReg.getNodeTypeDef(ntName)));
+                        perNtConfig.add(new IndexingRule(element, ntReg.getNodeTypeDef(ntName), ntReg.getEffectiveNodeType(ntName)));
-     * @param propertyName the property name to check.
-    private IndexingRule getApplicableIndexingRule(NodeState state, Name propertyName) {
+    private IndexingRule getApplicableIndexingRule(NodeState state) {
-                if (rule.appliesTo(state, propertyName)) {
+                if (rule.appliesTo(state)) {
-         * The NodeTypeDefinition of this fulltext indexing rule.
+         * The node type of this fulltext indexing rule.
-        private final QNodeTypeDefinition nodeTypeDefinition;
+        private final Name nodeTypeName;
+
+        /**
+         * Indicates if nodetype is a mixin
+         */
+        private boolean mixinNodeType = false;
+
+        /**
+         * The effective node type of this fulltext indexing rule.
+         */
+        private EffectiveNodeType effectiveNodeType;
-         * @param qNodeTypeDefinition the node type for the rule.
+         * @param nodeTypeDef the node type definition for the rule.
+         * @param effectiveNodeType the EffectiveNodeType of the rule
-        IndexingRule(IndexingRule original, QNodeTypeDefinition qNodeTypeDefinition) {
-            this.nodeTypeDefinition = qNodeTypeDefinition;
+        IndexingRule(IndexingRule original, QNodeTypeDefinition nodeTypeDef, EffectiveNodeType effectiveNodeType) {
+            this.nodeTypeName = nodeTypeDef.getName();
+            this.mixinNodeType = nodeTypeDef.isMixin();
+            this.effectiveNodeType = effectiveNodeType;
-         * @throws NoSuchNodeTypeException if the nodeType could not be evaluated
-                throws MalformedPathException, IllegalNameException, NamespaceException, NoSuchNodeTypeException {
-            this.nodeTypeDefinition = getNodeTypeDefinition(config);
+                throws MalformedPathException, IllegalNameException, NamespaceException {
+            this.nodeTypeName = getNodeTypeName(config);
-            return nodeTypeDefinition.getName();
+            return nodeTypeName;
+         * @param state        the node state.
-        public boolean isIndexed(Name propertyName) {
-            return getConfig(propertyName) != null;
+        public boolean isIndexed(NodeState state, Name propertyName) {
+            if (mixinNodeType && effectiveNodeType != null) {
+                QPropertyDefinition[] allPropDefs = effectiveNodeType.getAllPropDefs();
+                for (QPropertyDefinition propertyDefinition : allPropDefs) {
+                    if (propertyDefinition.getName().equals(propertyName)) {
+                        return getConfig(propertyName) != null;
+                    }
+                }
+                return true;
+            } else {
+                return getConfig(propertyName) != null;
+            }
-         * @param propertyName the property name to check.
-        public boolean appliesTo(NodeState state, Name propertyName) {
-        	Name nodeTypeName = getNodeTypeName();
-        	if (propertyName != null) {
-	        	for (QPropertyDefinition propertyDefinition : nodeTypeDefinition.getPropertyDefs()) {
-	        		if (propertyDefinition.getName().equals(propertyName)) {
-	        			return true;
-	        		}
-	        	}
-        	}
+        public boolean appliesTo(NodeState state) {
+            if (state.getMixinTypeNames().contains(nodeTypeName)) {
+                return true;
+            }
-         * @throws NoSuchNodeTypeException if the node type could not be evaluated
-        private QNodeTypeDefinition getNodeTypeDefinition(Node config)
-                throws IllegalNameException, NamespaceException, NoSuchNodeTypeException {
+        private Name getNodeTypeName(Node config)
+                throws IllegalNameException, NamespaceException {
-            return ntReg.getNodeTypeDef(resolver.getQName(ntString));
+            return resolver.getQName(ntString);

MOV26 UPD40 INS23 INS23 UPD43 INS29 INS83 INS39 INS59 INS29 INS83 INS43 INS59 INS44 INS44 INS8 MOV43 UPD42 UPD42 UPD42 INS65 INS42 INS9 INS65 INS42 INS42 INS65 UPD42 INS43 INS42 INS21 INS21 INS65 INS43 INS42 INS25 INS25 UPD66 INS66 INS66 UPD42 UPD66 INS42 INS66 INS42 INS7 INS7 INS42 INS42 INS66 INS42 INS27 MOV8 MOV8 INS32 MOV8 MOV32 INS32 INS22 INS32 INS22 INS42 INS42 INS27 INS60 INS41 INS32 INS42 INS42 INS42 UPD42 INS42 INS42 INS52 INS42 INS42 INS42 INS52 INS42 UPD42 UPD42 INS42 INS33 INS5 INS59 INS42 INS9 INS42 UPD42 MOV42 INS43 INS85 INS42 INS32 INS42 INS42 INS42 INS8 INS41 INS27 INS32 INS33 INS42 INS42 INS32 INS42 INS42 INS42 DEL42 DEL42 DEL33 DEL42 DEL42 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL44 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL25 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL32
JCR-1588 - JSR 283: Access Control (work in progress)
JCR-1590 - JSR 283: Locking
JCR-1915 - Node.setPrimaryNodeType should only redefine child-definitions that are not covered by the new effective nt
JCR-1875 - Failing Node.unlock() might leave inconsistent transient state
JCR-538 - Failing Node.checkin() or Node.checkout() might leave inconsistent transient state

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@732693 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.spi.commons.conversion.MalformedPathException;
+import org.apache.jackrabbit.core.ItemValidator;
+import org.apache.jackrabbit.core.PropertyId;
+import org.apache.jackrabbit.core.WorkspaceImpl;
+import org.apache.jackrabbit.core.nodetype.PropDef;
+import org.apache.jackrabbit.core.state.ItemStateException;
+import org.apache.jackrabbit.core.state.NodeState;
+import org.apache.jackrabbit.core.state.PropertyState;
+import org.apache.jackrabbit.core.state.UpdatableItemStateManager;
+import org.apache.jackrabbit.core.value.InternalValue;
+import org.apache.jackrabbit.spi.Path;
+import org.apache.jackrabbit.spi.commons.conversion.MalformedPathException;
-import org.apache.jackrabbit.spi.Path;
+import javax.jcr.PropertyType;
-     * as the public method but will not modify content.
+     * as the public method.
+     *
+     * @param timeoutHint
+     * @param ownerInfo
-    AbstractLockInfo internalLock(NodeImpl node, boolean isDeep, boolean isSessionScoped)
+    AbstractLockInfo internalLock(NodeImpl node, boolean isDeep,
+                                  boolean isSessionScoped, long timeoutHint,
+                                  String ownerInfo)
+        String lockOwner = (ownerInfo != null) ? ownerInfo : session.getUserID();
-                isSessionScoped, isDeep, session.getUserID());
+                isSessionScoped, isDeep, lockOwner, timeoutHint);
-            operation = eventChannel.create(node.getNodeId(), isDeep, session.getUserID());
+            operation = eventChannel.create(node.getNodeId(), isDeep, lockOwner);
-            session.addLockToken(info.lockToken.toString(), false);
+            // TODO: TOBEFIXED for 2.0
+            // TODO  only tokens of open-scoped locks must be added to the session.
+            // if (!info.isSessionScoped()) {
+                session.addLockToken(info.lockToken.toString(), false);
+            //}
-
+
+        return lock(node, isDeep, isSessionScoped, Long.MAX_VALUE, null);
+    }
-        AbstractLockInfo info = internalLock(node, isDeep, isSessionScoped);
+    public Lock lock(NodeImpl node, boolean isDeep, boolean isSessionScoped, long timoutHint, String ownerInfo)
+            throws LockException, RepositoryException {
+        AbstractLockInfo info = internalLock(node, isDeep, isSessionScoped, timoutHint, ownerInfo);
+        writeLockProperties(node, info.lockOwner, info.deep);
+
+        removeLockProperties(node);
+    /**
+     * Add the lock related properties to the target node.
+     *
+     * @param node
+     * @param lockOwner
+     * @param isDeep
+     */
+    protected void writeLockProperties(NodeImpl node, String lockOwner, boolean isDeep) throws RepositoryException {
+        boolean success = false;
+
+        SessionImpl editingSession = (SessionImpl) node.getSession();
+        WorkspaceImpl wsp = (WorkspaceImpl) editingSession.getWorkspace();
+        UpdatableItemStateManager stateMgr = wsp.getItemStateManager();
+        ItemValidator helper = new ItemValidator(editingSession.getNodeTypeManager().getNodeTypeRegistry(), wsp.getHierarchyManager(), editingSession);
+
+        synchronized (stateMgr) {
+            if (stateMgr.inEditMode()) {
+                throw new RepositoryException("Unable to write lock properties.");
+            }
+            stateMgr.edit();
+            try {
+                // add properties to content
+                NodeId nodeId = node.getNodeId();
+                NodeState nodeState = (NodeState) stateMgr.getItemState(nodeId);
+
+                PropertyState propState;
+                if (!nodeState.hasPropertyName(NameConstants.JCR_LOCKOWNER)) {
+                    PropDef def = helper.findApplicablePropertyDefinition(NameConstants.JCR_LOCKOWNER, PropertyType.STRING, false, nodeState);
+                    propState = stateMgr.createNew(NameConstants.JCR_LOCKOWNER, nodeId);
+                    propState.setDefinitionId(def.getId());
+                    propState.setType(PropertyType.STRING);
+                    propState.setMultiValued(false);
+                } else {
+                    propState = (PropertyState) stateMgr.getItemState(new PropertyId(nodeId, NameConstants.JCR_LOCKOWNER));
+                }
+                propState.setValues(new InternalValue[] { InternalValue.create(lockOwner) });
+                nodeState.addPropertyName(NameConstants.JCR_LOCKOWNER);
+                stateMgr.store(nodeState);
+
+                if (!nodeState.hasPropertyName(NameConstants.JCR_LOCKISDEEP)) {
+                    PropDef def = helper.findApplicablePropertyDefinition(NameConstants.JCR_LOCKISDEEP, PropertyType.BOOLEAN, false, nodeState);
+                    propState = stateMgr.createNew(NameConstants.JCR_LOCKISDEEP, nodeId);
+                    propState.setDefinitionId(def.getId());
+                    propState.setType(PropertyType.BOOLEAN);
+                    propState.setMultiValued(false);
+                } else {
+                    propState = (PropertyState) stateMgr.getItemState(new PropertyId(nodeId, NameConstants.JCR_LOCKISDEEP));
+                }
+                propState.setValues(new InternalValue[] { InternalValue.create(isDeep) });
+                nodeState.addPropertyName(NameConstants.JCR_LOCKISDEEP);
+                stateMgr.store(nodeState);
+
+                stateMgr.update();
+                success = true;
+            } catch (ItemStateException e) {
+                throw new RepositoryException("Error while creating lock.", e);
+            } finally {
+                if (!success) {
+                    // failed to set lock meta-data content, cleanup
+                    stateMgr.cancel();
+                    try {
+                        unlock(node);
+                    } catch (RepositoryException e) {
+                        // cleanup failed
+                        log.error("error while cleaning up after failed lock attempt", e);
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     *
+     * @param node
+     * @throws RepositoryException
+     */
+    protected void removeLockProperties(NodeImpl node) throws RepositoryException {
+        boolean success = false;
+
+        SessionImpl editingSession = (SessionImpl) node.getSession();
+        WorkspaceImpl wsp = (WorkspaceImpl) editingSession.getWorkspace();
+        UpdatableItemStateManager stateMgr = wsp.getItemStateManager();
+
+        synchronized (stateMgr) {
+            try {
+                // add properties to content
+                NodeId nodeId = node.getNodeId();
+                NodeState nodeState = (NodeState) stateMgr.getItemState(nodeId);
+
+                if (stateMgr.inEditMode()) {
+                    throw new RepositoryException("Unable to remove lock properties.");
+                }
+                stateMgr.edit();
+                if (nodeState.hasPropertyName(NameConstants.JCR_LOCKOWNER)) {
+                    PropertyState propState = (PropertyState) stateMgr.getItemState(new PropertyId(nodeId, NameConstants.JCR_LOCKOWNER));
+                    nodeState.removePropertyName(NameConstants.JCR_LOCKOWNER);
+                    stateMgr.destroy(propState);
+                    stateMgr.store(nodeState);
+                }
+
+                if (nodeState.hasPropertyName(NameConstants.JCR_LOCKISDEEP)) {
+                    PropertyState propState = (PropertyState) stateMgr.getItemState(new PropertyId(nodeId, NameConstants.JCR_LOCKISDEEP));
+                    nodeState.removePropertyName(NameConstants.JCR_LOCKISDEEP);
+                    stateMgr.destroy(propState);
+                    stateMgr.store(nodeState);
+                }
+
+                stateMgr.update();
+                success = true;
+            } catch (ItemStateException e) {
+                throw new RepositoryException("Error while removing lock.", e);
+            } finally {
+                if (!success) {
+                    // failed to set lock meta-data content, cleanup
+                    stateMgr.cancel();
+                }
+            }
+        }
+    }
-            super(lockToken, sessionScoped, deep, lockOwner);
+            this(lockToken, sessionScoped, deep, lockOwner, Long.MAX_VALUE);
+        }
+
+        /**
+         * Create a new instance of this class.
+         *
+         * @param lockToken     lock token
+         * @param sessionScoped whether lock token is session scoped
+         * @param deep          whether lock is deep
+         * @param lockOwner     owner of lock
+         * @param timeoutHint
+         */
+        public LockInfo(LockToken lockToken, boolean sessionScoped,
+                        boolean deep, String lockOwner, long timeoutHint) {
+            super(lockToken, sessionScoped, deep, lockOwner, timeoutHint);
-                        log.warn("Unable to remove session-scoped lock on node '"
-                                + lockToken + "': " + e.getMessage());
-                        log.debug("Root cause: ", e);
+                        // Session is not allowed/able to unlock.
+                        // Use system session present with lock-mgr as fallback
+                        // in order to make sure, that session-scoped locks are
+                        // properly cleaned.
+                        SessionImpl systemSession = LockManagerImpl.this.session;
+                        setLockHolder(systemSession);
+                        try {
+                            NodeImpl node = (NodeImpl) systemSession.getItemManager().getItem(getId());
+                            node.unlock();
+                        } catch (RepositoryException re) {
+                            log.warn("Unable to remove session-scoped lock on node '" + lockToken + "': " + e.getMessage());
+                            log.debug("Root cause: ", e);
+                        }
-    public void externalLock(NodeId nodeId, boolean isDeep, String userId) throws RepositoryException {
+    public void externalLock(NodeId nodeId, boolean isDeep, String lockOwner) throws RepositoryException {
-            LockInfo info = new LockInfo(new LockToken(nodeId), false, isDeep, userId);
+            LockInfo info = new LockInfo(new LockToken(nodeId), false, isDeep, lockOwner);

MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS31 INS31 INS31 INS44 INS44 MOV29 INS83 INS43 INS42 INS44 INS44 INS44 INS43 INS43 INS8 INS44 INS44 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS31 INS65 INS65 INS39 INS42 INS43 INS42 INS60 INS42 INS43 INS42 INS39 INS42 INS39 INS42 INS42 INS42 INS41 INS39 INS42 INS43 INS42 INS21 INS21 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS39 INS42 INS42 INS60 INS60 INS60 INS60 INS60 INS51 INS65 INS65 INS43 INS42 INS42 INS60 INS60 INS60 INS60 INS51 INS29 INS83 INS42 INS44 INS44 INS44 INS44 INS44 INS8 UPD42 UPD66 INS42 INS42 INS42 INS43 INS59 INS42 INS32 INS42 INS32 INS32 INS66 INS42 INS42 INS42 INS42 INS42 INS39 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS42 INS8 INS42 INS42 INS42 INS39 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS42 INS8 INS17 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS39 INS42 INS39 INS42 INS43 INS42 INS39 INS42 INS46 INS42 INS42 INS16 INS42 INS42 INS42 INS42 INS40 INS33 INS42 INS42 INS40 INS40 INS42 INS42 INS42 INS9 INS42 INS42 INS11 INS42 INS42 INS11 INS42 INS42 INS32 INS42 INS42 INS14 INS25 INS21 INS54 INS42 INS9 INS42 INS42 INS11 INS42 INS42 INS11 INS42 INS42 INS32 INS54 INS42 INS42 INS42 INS42 INS40 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS36 INS42 MOV32 INS42 INS42 INS42 INS42 INS43 INS32 INS43 INS32 INS42 INS42 INS43 INS32 INS32 INS42 INS32 INS8 INS32 INS8 INS12 INS8 INS43 INS32 INS43 INS32 INS42 INS42 INS8 INS12 INS8 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS53 INS42 INS42 INS60 INS60 INS60 INS25 INS21 INS21 INS21 INS25 INS21 INS21 INS21 INS21 INS21 INS44 INS8 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS60 INS60 INS25 INS21 INS25 INS25 INS21 INS21 INS44 INS8 INS25 INS42 INS33 INS42 INS42 INS42 INS14 INS43 INS59 INS43 INS59 INS43 INS59 INS38 INS8 INS8 INS32 INS32 INS32 INS38 INS8 INS8 INS32 INS32 INS32 INS32 INS7 INS43 INS42 INS53 INS38 INS8 INS43 INS59 INS43 INS59 INS32 INS8 INS32 INS32 INS8 INS32 INS8 INS32 INS7 INS43 INS42 INS53 INS38 INS8 UPD42 INS43 INS45 INS42 INS42 INS32 INS42 INS42 INS11 INS42 INS42 INS32 INS60 INS21 INS21 INS21 INS21 INS21 INS42 INS42 INS3 INS42 INS42 INS40 INS42 INS42 INS42 INS32 INS60 INS21 INS21 INS21 INS21 INS21 INS42 INS42 INS3 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS14 INS42 INS21 INS54 INS42 INS42 INS32 INS42 INS42 INS11 INS42 INS42 INS53 INS42 INS42 INS42 INS42 INS40 INS60 INS21 INS21 INS21 INS42 INS42 INS40 INS60 INS21 INS21 INS21 INS42 INS42 INS42 INS9 INS42 INS14 INS42 INS21 INS12 INS42 INS42 INS42 INS43 INS32 INS42 INS42 INS40 INS43 INS59 INS7 INS32 INS32 INS32 INS7 INS5 INS4 INS42 INS42 INS40 INS43 INS59 INS7 INS32 INS32 INS32 INS7 INS5 INS4 INS43 INS45 INS42 INS32 INS8 INS12 INS42 INS42 INS43 INS32 INS14 INS43 INS59 INS32 INS32 INS32 INS43 INS59 INS32 INS32 INS32 INS43 INS45 INS42 INS32 MOV44 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS40 INS42 INS42 INS9 INS42 INS11 INS43 INS85 INS32 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS40 INS42 INS42 INS9 INS42 INS11 INS43 INS85 INS32 INS42 INS42 INS42 INS21 INS44 INS8 INS42 INS42 INS42 INS42 INS43 INS45 INS42 INS42 INS11 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS60 INS21 INS54 INS42 INS42 INS40 INS40 INS9 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS40 INS9 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS42 INS32 INS43 INS42 INS21 INS42 INS43 INS32 INS43 INS32 INS43 INS59 INS32 INS8 MOV12 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS14 INS42 INS42 INS22 INS42 INS42 INS60 INS21 INS44 INS43 INS42 INS40 INS43 INS42 INS40 INS42 INS42 INS45 INS42 INS43 INS42 INS40 INS43 INS42 INS40 INS52 INS42 INS43 INS59 INS32 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS42 INS43 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL46
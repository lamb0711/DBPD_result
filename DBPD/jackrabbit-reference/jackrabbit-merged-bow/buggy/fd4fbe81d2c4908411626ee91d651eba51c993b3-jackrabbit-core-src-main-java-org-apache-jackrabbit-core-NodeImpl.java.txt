JCR-1773 - shareable nodes: wrong path returned, causes remove() to delete wrong node


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@790127 13f79535-47bb-0310-9956-ffa450edef68

+
+        Path p = resolveRelativePath(relPath);
+        return getNodeId(p);
+    }
+
+    /**
+     * Resolve a relative path given as string into a <code>Path</code>. If
+     * a <code>NameException</code> occurs, it will be rethrown embedded
+     * into a <code>RepositoryException</code>
+     *
+     * @param relPath relative path
+     * @return <code>Path</code> object
+     * @throws RepositoryException if an error occurs
+     */
+    private Path resolveRelativePath(String relPath) throws RepositoryException {
-            /**
-             * first check if relPath is just a name (in which case we don't
-             * have to build & resolve absolute path)
-             */
-            Path p = session.getQPath(relPath);
-            if (p.getLength() == 1) {
-                Path.Element pe = p.getNameElement();
-                if (pe.denotesName()) {
-                    // check if node entry exists
-                    NodeState thisState = data.getNodeState();
-                    int index = pe.getIndex();
-                    if (index == 0) {
-                        index = 1;
-                    }
-                    ChildNodeEntry cne =
-                            thisState.getChildNodeEntry(pe.getName(), index);
-                    if (cne != null) {
-                        return cne.getId();
-                    } else {
-                        // there's no child node with that name
-                        return null;
-                    }
-                }
-            }
-            /**
-             * build and resolve absolute path
-             */
-            p = PathFactoryImpl.getInstance().create(getPrimaryPath(), p, true);
-            return session.getHierarchyManager().resolveNodePath(p);
+            return session.getQPath(relPath);
+     * Returns the id of the node at <code>p</code> or <code>null</code>
+     * if no node exists at <code>p</code>.
+     * <p/>
+     * Note that access rights are not checked.
+     *
+     * @param p relative path of a (possible) node
+     * @return the id of the node at <code>p</code> or
+     *         <code>null</code> if no node exists at <code>p</code>
+     * @throws RepositoryException if <code>relPath</code> is not a valid
+     *                             relative path
+     */
+    private NodeId getNodeId(Path p) throws RepositoryException {
+        if (p.getLength() == 1) {
+            Path.Element pe = p.getNameElement();
+            if (pe.denotesName()) {
+                // check if node entry exists
+                NodeState thisState = data.getNodeState();
+                int index = pe.getIndex();
+                if (index == 0) {
+                    index = 1;
+                }
+                ChildNodeEntry cne =
+                        thisState.getChildNodeEntry(pe.getName(), index);
+                if (cne != null) {
+                    return cne.getId();
+                } else {
+                    // there's no child node with that name
+                    return null;
+                }
+            }
+        }
+        /**
+         * build and resolve absolute path
+         */
+        p = PathFactoryImpl.getInstance().create(getPrimaryPath(), p, true);
+        return session.getHierarchyManager().resolveNodePath(p);
+    }
+
+    /**
+
-        NodeId id = resolveRelativeNodePath(relPath);
+
+        Path p = resolveRelativePath(relPath);
+        NodeId id = getNodeId(p);
+
+        // determine parent as mandated by path
+        NodeId parentId = null;
+        if (!p.denotesRoot()) {
+            parentId = getNodeId(p.getAncestor(1));
+        }
-            if (data.getNodeState().hasChildNodeEntry(id)) {
-                return itemMgr.getNode(id, getNodeId());
+            if (parentId == null) {
+                return (NodeImpl) itemMgr.getItem(id);
-            return (NodeImpl) itemMgr.getItem(id);
+            // if the node is shareable, it now returns the node with the right
+            // parent
+            return itemMgr.getNode(id, parentId);

INS31 INS31 MOV29 INS83 INS43 INS42 INS44 INS43 INS8 INS29 INS83 MOV43 INS42 MOV44 INS43 INS8 INS29 UPD83 INS42 INS44 MOV8 INS42 INS43 INS42 INS42 INS60 INS41 INS65 INS65 INS65 INS65 INS42 INS54 INS65 INS65 INS65 INS65 INS43 INS42 INS60 INS60 INS25 INS42 INS43 INS59 INS32 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS8 MOV12 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS43 MOV43 INS59 INS43 INS59 INS38 INS8 INS8 INS42 INS42 INS32 INS42 INS42 INS41 INS42 UPD42 INS42 INS32 INS42 INS42 INS33 INS32 INS21 INS25 INS41 INS42 INS42 MOV32 UPD42 INS42 INS42 INS42 INS42 INS7 INS27 MOV8 INS32 INS42 INS32 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS34 DEL42 DEL42 DEL59 DEL60 DEL54 DEL8 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL41 DEL8 DEL25
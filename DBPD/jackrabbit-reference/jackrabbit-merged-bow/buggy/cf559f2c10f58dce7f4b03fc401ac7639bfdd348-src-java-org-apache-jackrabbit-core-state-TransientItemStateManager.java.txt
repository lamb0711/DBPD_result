Fixed deadlock issue.
- introduced separate monitor for item state cache operations
- removed synchronized() where not needed and added comment


git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@159676 13f79535-47bb-0310-9956-ffa450edef68

+
-    NodeState createNodeState(String uuid, QName nodeTypeName, String parentUUID, int initialStatus)
+    NodeState createNodeState(String uuid, QName nodeTypeName,
+                              String parentUUID, int initialStatus)
-        NodeId id = new NodeId(uuid);
-        // check cache
-        if (isCached(id)) {
-            String msg = "there's already a node state instance with id " + id;
-            log.debug(msg);
-            throw new ItemStateException(msg);
-        }
-        NodeState state = new NodeState(uuid, nodeTypeName, parentUUID, initialStatus, true);
-        // put it in cache
-        cache(state);
-        return state;
+        NodeId id = new NodeId(uuid);
+
+        // check cache. synchronized to ensure an entry is not created twice.
+        synchronized (cacheMonitor) {
+            if (isCached(id)) {
+                String msg = "there's already a node state instance with id " + id;
+                log.debug(msg);
+                throw new ItemStateException(msg);
+            }
+
+            NodeState state = new NodeState(uuid, nodeTypeName, parentUUID,
+                    initialStatus, true);
+            // put it in cache
+            cache(state);
+            return state;
+        }
-        ItemId id = overlayedState.getId();
-        // check cache
-        if (isCached(id)) {
-            String msg = "there's already a node state instance with id " + id;
-            log.debug(msg);
-            throw new ItemStateException(msg);
-        }
-        NodeState state = new NodeState(overlayedState, initialStatus, true);
-        // put it in cache
-        cache(state);
-        return state;
+        ItemId id = overlayedState.getId();
+
+        // check cache. synchronized to ensure an entry is not created twice.
+        synchronized (cacheMonitor) {
+            if (isCached(id)) {
+                String msg = "there's already a node state instance with id " + id;
+                log.debug(msg);
+                throw new ItemStateException(msg);
+            }
+
+            NodeState state = new NodeState(overlayedState, initialStatus, true);
+            // put it in cache
+            cache(state);
+            return state;
+        }
-        PropertyId id = new PropertyId(parentUUID, propName);
-        // check cache
-        if (isCached(id)) {
-            String msg = "there's already a property state instance with id " + id;
-            log.debug(msg);
-            throw new ItemStateException(msg);
-        }
-        PropertyState state = new PropertyState(propName, parentUUID, initialStatus, true);
-        // put it in cache
-        cache(state);
-        return state;
+        PropertyId id = new PropertyId(parentUUID, propName);
+
+        // check cache. synchronized to ensure an entry is not created twice.
+        synchronized (cacheMonitor) {
+            if (isCached(id)) {
+                String msg = "there's already a property state instance with id " + id;
+                log.debug(msg);
+                throw new ItemStateException(msg);
+            }
+
+            PropertyState state = new PropertyState(propName, parentUUID, initialStatus, true);
+            // put it in cache
+            cache(state);
+            return state;
+        }
-        PropertyId id = new PropertyId(overlayedState.getParentUUID(), overlayedState.getName());
-        // check cache
-        if (isCached(id)) {
-            String msg = "there's already a property state instance with id " + id;
-            log.debug(msg);
-            throw new ItemStateException(msg);
-        }
-        PropertyState state = new PropertyState(overlayedState, initialStatus, true);
-        // put it in cache
-        cache(state);
-        return state;
+        PropertyId id = new PropertyId(overlayedState.getParentUUID(),
+                overlayedState.getName());
+
+        // check cache. synchronized to ensure an entry is not created twice.
+        synchronized (cacheMonitor) {
+            if (isCached(id)) {
+                String msg = "there's already a property state instance with id " + id;
+                log.debug(msg);
+                throw new ItemStateException(msg);
+            }
+
+            PropertyState state = new PropertyState(overlayedState, initialStatus, true);
+            // put it in cache
+            cache(state);
+            return state;
+        }

INS51 INS51 INS51 INS51 INS42 INS8 INS42 INS8 INS42 INS8 INS42 INS8 MOV25 MOV60 MOV21 MOV41 MOV25 MOV60 MOV21 MOV41 MOV25 MOV60 MOV21 MOV41 MOV25 MOV60 MOV21 MOV41
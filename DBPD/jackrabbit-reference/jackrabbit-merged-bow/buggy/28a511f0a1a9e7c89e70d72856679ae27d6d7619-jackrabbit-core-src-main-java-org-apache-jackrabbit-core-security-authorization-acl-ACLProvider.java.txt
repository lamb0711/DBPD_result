JCR-2573 - Performance of AC Evaluation [work in progress]

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@950440 13f79535-47bb-0310-9956-ffa450edef68

-import java.security.Principal;
-import java.security.acl.Group;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.Iterator;
+import org.apache.commons.collections.map.LRUMap;
+import org.apache.jackrabbit.api.security.principal.PrincipalManager;
+import org.apache.jackrabbit.core.ItemImpl;
+import org.apache.jackrabbit.core.ItemManager;
+import org.apache.jackrabbit.core.NodeImpl;
+import org.apache.jackrabbit.core.SessionImpl;
+import org.apache.jackrabbit.core.id.ItemId;
+import org.apache.jackrabbit.core.id.NodeId;
+import org.apache.jackrabbit.core.id.PropertyId;
+import org.apache.jackrabbit.core.nodetype.NodeTypeImpl;
+import org.apache.jackrabbit.core.security.SecurityConstants;
+import org.apache.jackrabbit.core.security.authorization.AccessControlListener;
+import org.apache.jackrabbit.core.security.authorization.AbstractAccessControlProvider;
+import org.apache.jackrabbit.core.security.authorization.AbstractCompiledPermissions;
+import org.apache.jackrabbit.core.security.authorization.AccessControlConstants;
+import org.apache.jackrabbit.core.security.authorization.AccessControlEditor;
+import org.apache.jackrabbit.core.security.authorization.AccessControlModifications;
+import org.apache.jackrabbit.core.security.authorization.CompiledPermissions;
+import org.apache.jackrabbit.core.security.authorization.Permission;
+import org.apache.jackrabbit.core.security.authorization.PrivilegeRegistry;
+import org.apache.jackrabbit.core.security.authorization.UnmodifiableAccessControlList;
+import org.apache.jackrabbit.spi.Name;
+import org.apache.jackrabbit.spi.Path;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
-import javax.jcr.observation.Event;
-import javax.jcr.observation.EventIterator;
-
-import org.apache.jackrabbit.api.security.principal.PrincipalManager;
-import org.apache.jackrabbit.core.ItemImpl;
-import org.apache.jackrabbit.core.NodeImpl;
-import org.apache.jackrabbit.core.PropertyImpl;
-import org.apache.jackrabbit.core.SessionImpl;
-import org.apache.jackrabbit.core.id.NodeId;
-import org.apache.jackrabbit.core.observation.SynchronousEventListener;
-import org.apache.jackrabbit.core.security.SecurityConstants;
-import org.apache.jackrabbit.core.security.authorization.AbstractAccessControlProvider;
-import org.apache.jackrabbit.core.security.authorization.AbstractCompiledPermissions;
-import org.apache.jackrabbit.core.security.authorization.AccessControlConstants;
-import org.apache.jackrabbit.core.security.authorization.AccessControlEditor;
-import org.apache.jackrabbit.core.security.authorization.CompiledPermissions;
-import org.apache.jackrabbit.core.security.authorization.Permission;
-import org.apache.jackrabbit.core.security.authorization.PrivilegeRegistry;
-import org.apache.jackrabbit.core.security.authorization.UnmodifiableAccessControlList;
-import org.apache.jackrabbit.spi.Path;
-import org.apache.jackrabbit.spi.commons.name.PathFactoryImpl;
-import org.apache.jackrabbit.util.Text;
-import org.apache.commons.collections.iterators.IteratorChain;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import java.security.Principal;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
-    //-------------------------------------------------< AccessControlUtils >---
-     * @see org.apache.jackrabbit.core.security.authorization.AccessControlUtils#isAcItem(Path)
+     * Cache to ease the retrieval of ACEs defined for a given node. This cache
+     * is used by the ACLPermissions created individually for each Session
+     * instance.
-    public boolean isAcItem(Path absPath) throws RepositoryException {
-        Path.Element[] elems = absPath.getElements();
-        for (Path.Element elem : elems) {
-            if (N_POLICY.equals(elem.getName())) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Test if the given node is itself a rep:ACL or a rep:ACE node.
-     * @see org.apache.jackrabbit.core.security.authorization.AccessControlUtils#isAcItem(ItemImpl)
-     */
-    public boolean isAcItem(ItemImpl item) throws RepositoryException {
-        NodeImpl n = ((item.isNode()) ? (NodeImpl) item : (NodeImpl) item.getParent());
-        return n.isNodeType(NT_REP_ACL) || n.isNodeType(NT_REP_ACE);
-    }
+    private EntryCollector entryCollector;
+
+
+        entryCollector = createEntryCollector((SessionImpl) systemSession);
+    }
+
+    @Override
+    public void close() {
+        super.close();        
+        entryCollector.close();
-        NodeImpl node = getNode(targetNode);
+        NodeImpl node = getNode(targetNode, isAcItem(targetNode));
-            return cp.grants(PathFactoryImpl.getInstance().getRootPath(), Permission.READ);
+            return cp.canRead(null, rootNodeId);
+     * Create the <code>EntryCollector</code> instance that is used by this
+     * provider to gather the effective ACEs for a given list of principals at a
+     * given node during AC evaluation.
+     *
+     * @param systemSession The system session to create the entry collector for.
+     * @return A new instance of <code>CachingEntryCollector</code>.
+     * @throws RepositoryException If an error occurs.
+     * @see #retrieveResultEntries(NodeImpl, EntryFilter)
+     */
+    protected EntryCollector createEntryCollector(SessionImpl systemSession) throws RepositoryException {
+        return new CachingEntryCollector(systemSession, systemEditor, rootNodeId);
+    }
+
+    /**
-     * @param principalNames List of principal names.
+     * @param filter The entry filter used to collect the access control entries.
-    protected Iterator<AccessControlEntry> retrieveResultEntries(NodeImpl node, List<String> principalNames) throws RepositoryException {
-        return new Entries(node, principalNames).iterator();
+    protected Iterator<AccessControlEntry> retrieveResultEntries(NodeImpl node, EntryFilter filter) throws RepositoryException {
+        Iterator<AccessControlEntry> itr = entryCollector.collectEntries(node, filter).iterator();
+        return itr;
-     * @return the node
+     * @param isAcItem true if the specified target node defines access control
+     * content; false otherwise.
+     * @return the given <code>targetNode</code> or the nearest non-ac-parent
+     * in case the <code>targetNode</code> itself defines access control content.
-    private NodeImpl getNode(NodeImpl targetNode) throws RepositoryException {
+    private NodeImpl getNode(NodeImpl targetNode, boolean isAcItem) throws RepositoryException {
-        if (isAcItem(targetNode)) {
-            if (targetNode.isNodeType(NT_REP_ACL)) {
+        if (isAcItem) {
+            Name ntName = ((NodeTypeImpl) targetNode.getPrimaryNodeType()).getQName();
+            if (ntName.equals(NT_REP_ACL)) {
-            // build acl for the access controlled node
-            NodeImpl aclNode = node.getNode(N_POLICY);
-            AccessControlList acl = systemEditor.getACL(aclNode);
-            acls.add(new UnmodifiableAccessControlList(acl));
+            // retrieve the entries for the access controlled node
+            acls.add(new UnmodifiableAccessControlList(entryCollector.getEntries(node), node.getPath(), Collections.<String, Integer>emptyMap()));
-     * @param node hte node
-     * @return <code>true</code> if the node is access controlled;
-     *         <code>false</code> otherwise.
+     * @param node the node to be tested
+     * @return <code>true</code> if the node is access controlled and has a
+     * rep:policy child; <code>false</code> otherwise.
-        return node.isNodeType(NT_REP_ACCESS_CONTROLLABLE) && node.hasNode(N_POLICY);
+        return node.hasNode(N_POLICY) && node.isNodeType(NT_REP_ACCESS_CONTROLLABLE);
-    private class AclPermissions extends AbstractCompiledPermissions implements SynchronousEventListener {
+    private class AclPermissions extends AbstractCompiledPermissions implements AccessControlListener {
+        private final Map<NodeId, Boolean> readCache = new LRUMap(1000);
+        private final Object monitor = new Object();
-                 any ACL concerning it is modified. interesting events are:
-                 - new ACE-entry for any of the principals (NODE_ADDED)
-                 - changing ACE-entry for any of the principals (PROPERTY_CHANGED)
-                   > new permissions granted/denied
-                   >
-                 - removed ACE-entry for any of the principals (NODE_REMOVED)
-                */
-                int events = Event.PROPERTY_CHANGED | Event.NODE_ADDED | Event.NODE_REMOVED;
-                String[] ntNames = new String[] {
-                        resolver.getJCRName(NT_REP_ACE),
-                        resolver.getJCRName(NT_REP_ACL)
-                };
-                observationMgr.addEventListener(this, events, session.getRootNode().getPath(), true, null, ntNames, true);
+                 any ACL concerning it is modified.
+                 */
+                 entryCollector.addListener(this);
-        //------------------------------------< AbstractCompiledPermissions >---
-        /**
-         * @see AbstractCompiledPermissions#buildResult(Path)
-         */
-        @Override
-        protected Result buildResult(Path absPath) throws RepositoryException {
-            boolean existingNode = false;
-            NodeImpl node = null;
-            String jcrPath = resolver.getJCRPath(absPath);
-
-            if (session.nodeExists(jcrPath)) {
-                node = (NodeImpl) session.getNode(jcrPath);
-                existingNode = true;
-            } else {
-                // path points to existing prop or non-existing item (node or prop).
-                // -> find the nearest persisted node
-                String parentPath = Text.getRelativeParent(jcrPath, 1);
-                while (parentPath.length() > 0) {
-                    if (session.nodeExists(parentPath)) {
-                        node = (NodeImpl) session.getNode(parentPath);
-                        break;
-                    }
-                    parentPath = Text.getRelativeParent(parentPath, 1);
-                }
-            }
-
-            if (node == null) {
-                // should never get here
-                throw new ItemNotFoundException("Item out of hierarchy.");
-            }
-
-            boolean isAcItem = isAcItem(absPath);
-
+        private Result buildResult(NodeImpl node, boolean existingNode, boolean isAcItem, EntryFilter filter) throws RepositoryException {
-            Iterator<AccessControlEntry> entries = retrieveResultEntries(getNode(node), principalNames);
+            Iterator<AccessControlEntry> entries = retrieveResultEntries(getNode(node, isAcItem), filter);
+
-                boolean isLocal = existingNode && ace.isLocal(jcrPath);
+                boolean isLocal = existingNode && ace.isLocal(node.getNodeId());
+        //------------------------------------< AbstractCompiledPermissions >---
+        /**
+         * @see AbstractCompiledPermissions#buildResult(Path)
+         */
+        @Override
+        protected Result buildResult(Path absPath) throws RepositoryException {
+            boolean existingNode = false;
+            NodeImpl node;
+
+            ItemManager itemMgr = session.getItemManager();
+            try {
+                ItemImpl item = itemMgr.getItem(absPath);
+                if (item.isNode()) {
+                    node = (NodeImpl) item;
+                    existingNode = true;
+                } else {
+                    node = (NodeImpl) item.getParent();
+                }
+            } catch (RepositoryException e) {
+                // path points to a non-persisted item.
+                // -> find the nearest persisted node starting from the root.
+                Path.Element[] elems = absPath.getElements();
+                NodeImpl parent = (NodeImpl) session.getRootNode();
+                for (int i = 1; i < elems.length - 1; i++) {
+                    Name name = elems[i].getName();
+                    int index = elems[i].getIndex();
+                    if (!parent.hasNode(name, index)) {
+                        // last persisted node reached
+                        break;
+                    }
+                    parent = parent.getNode(name, index);
+
+                }
+                node = parent;
+            }
+
+            if (node == null) {
+                // should never get here
+                throw new ItemNotFoundException("Item out of hierarchy.");
+            }
+
+            boolean isAcItem = isAcItem(absPath);
+            return buildResult(node, existingNode, isAcItem, new EntryFilterImpl(principalNames));
+        }
+
+        /**
+         * @see AbstractCompiledPermissions#clearCache()
+         */
+        @Override
+        protected void clearCache() {
+            synchronized (monitor) {
+                readCache.clear();
+            }
+            super.clearCache();
+        }
+
-            try {
-                observationMgr.removeEventListener(this);
-            } catch (RepositoryException e) {
-                log.debug("Unable to unregister listener: ", e.getMessage());
-            }
+            entryCollector.removeListener(this);
-        //--------------------------------------------------< EventListener >---
-         * @see javax.jcr.observation.EventListener#onEvent(EventIterator)
+         * @see CompiledPermissions#canRead(Path, ItemId)
-        public synchronized void onEvent(EventIterator events) {
-            // only invalidate cache if any of the events affects the
-            // nodes defining permissions for principals compiled here.
-            boolean clearCache = false;
-            while (events.hasNext() && !clearCache) {
-                try {
-                    Event ev = events.nextEvent();
-                    String path = ev.getPath();
-                    switch (ev.getType()) {
-                        case Event.NODE_ADDED:
-                            // test if the new node is an ACE node that affects
-                            // the permission of any of the principals listed in
-                            // principalNames.
-                            NodeImpl n = (NodeImpl) session.getNode(path);
-                            if (n.isNodeType(NT_REP_ACE) &&
-                                    principalNames.contains(n.getProperty(P_PRINCIPAL_NAME).getString())) {
-                                clearCache = true;
-                            }
-                            break;
-                        case Event.PROPERTY_REMOVED:
-                        case Event.NODE_REMOVED:
-                            // can't find out if the removed ACL/ACE node was
-                            // relevant for the principals
-                            clearCache = true;
-                            break;
-                        case Event.PROPERTY_ADDED:
-                        case Event.PROPERTY_CHANGED:
-                            // test if the added/changed prop belongs to an ACe
-                            // node and affects the permission of any of the
-                            // principals listed in principalNames.
-                            PropertyImpl p = (PropertyImpl) session.getProperty(path);
-                            NodeImpl parent = (NodeImpl) p.getParent();
-                            if (parent.isNodeType(NT_REP_ACE)) {
-                                String principalName = null;
-                                if (P_PRIVILEGES.equals(p.getQName())) {
-                                    // test if principal-name sibling-prop matches
-                                    principalName = parent.getProperty(P_PRINCIPAL_NAME).getString();
-                                } else if (P_PRINCIPAL_NAME.equals(p.getQName())) {
-                                    // a new ace or an ace change its principal-name.
-                                    principalName = p.getString();
-                                }
-                                if (principalName != null &&
-                                        principalNames.contains(principalName)) {
-                                    clearCache = true;
-                                }
-                            }
-                            break;
-                        case Event.NODE_MOVED:
-                            // protected ac nodes cannot be moved around
-                            // -> nothing to do TODO check again
-                            break;
-                        default:
-                            // illegal event-type: should never occur. ignore
-                    }
-                } catch (RepositoryException e) {
-                    // should not get here
-                    log.warn("Internal error: ", e.getMessage());
+        public boolean canRead(Path path, ItemId itemId) throws RepositoryException {
+            ItemId id = (itemId == null) ? session.getHierarchyManager().resolvePath(path) : itemId;
+            /* currently READ access cannot be denied to individual properties.
+               if the parent node is readable the properties are as well.
+               this simplifies the canRead test as well as the caching.
+             */
+            boolean existingNode = false;
+            NodeId nodeId;
+            if (id.denotesNode()) {
+                nodeId = (NodeId) id;
+                // since method may only be called for existing nodes the
+                // flag be set to true if the id identifies a node.
+                existingNode = true;
+            } else {
+                nodeId = ((PropertyId) id).getParentId();
+            }
+
+            boolean canRead;
+            synchronized (monitor) {
+                if (readCache.containsKey(nodeId)) {
+                    canRead = readCache.get(nodeId);
+                } else {
+                    ItemManager itemMgr = session.getItemManager();
+                    NodeImpl node = (NodeImpl) itemMgr.getItem(nodeId);
+                    Result result = buildResult(node, existingNode, isAcItem(node), new EntryFilterImpl(principalNames));
+
+                    canRead = result.grants(Permission.READ);
+                    readCache.put(nodeId, canRead);
-            if (clearCache) {
-                clearCache();
-            }
-        }
-    }
-
-    //--------------------------------------------------------------------------
-    /**
-     * Inner class used to collect ACEs for a given set of principals throughout
-     * the node hierarchy.
-     */
-    private class Entries {
-
-        private final Collection<String> principalNames;
-        private final List<AccessControlEntry> userAces = new ArrayList();
-        private final List<AccessControlEntry> groupAces = new ArrayList();
-
-        private Entries(NodeImpl node, Collection<String> principalNames) throws RepositoryException {
-            this.principalNames = principalNames;
-            collectEntries(node);
+            return canRead;
-        private void collectEntries(NodeImpl node) throws RepositoryException {
-            // if the given node is access-controlled, construct a new ACL and add
-            // it to the list
-            if (isAccessControlled(node)) {
-                // build acl for the access controlled node
-                NodeImpl aclNode = node.getNode(N_POLICY);
-                //collectEntries(aclNode, principalNamesToEntries);
-                collectEntriesFromAcl(aclNode);
-            }
-            // recursively look for access controlled parents up the hierarchy.
-            if (!rootNodeId.equals(node.getId())) {
-                NodeImpl parentNode = (NodeImpl) node.getParent();
-                collectEntries(parentNode);
-            }
-        }
-
+        //----------------------------------------< ACLModificationListener >---
-         * Separately collect the entries defined for the user and group
-         * principals.
-         *
-         * @param aclNode acl node
-         * @throws RepositoryException if an error occurs
+         * @see org.apache.jackrabbit.core.security.authorization.AccessControlListener#acModified(AccessControlModifications)
-        private void collectEntriesFromAcl(NodeImpl aclNode) throws RepositoryException {
-            // first collect aces present on the given aclNode.
-            List<AccessControlEntry> gaces = new ArrayList<AccessControlEntry>();
-            List<AccessControlEntry> uaces = new ArrayList<AccessControlEntry>();
-
-            ACLTemplate tmpl = (ACLTemplate) systemEditor.getACL(aclNode);
-            for (AccessControlEntry ace : tmpl.getAccessControlEntries()) {
-                Principal principal = ace.getPrincipal();
-                // only process aceNode if 'principalName' is contained in the given set
-                if (principalNames.contains(principal.getName())) {
-                    // add it to the proper list (e.g. separated by principals)
-                    /**
-                     * NOTE: access control entries must be collected in reverse
-                     * order in order to assert proper evaluation.
-                     */
-                    if (principal instanceof Group) {
-                        gaces.add(0, ace);
-                    } else {
-                        uaces.add(0, ace);
-                    }
-                }
-            }
-
-            // add the lists of aces to the overall lists that contain the entries
-            // throughout the hierarchy.
-            if (!gaces.isEmpty()) {
-                groupAces.addAll(gaces);
-            }
-            if (!uaces.isEmpty()) {
-                userAces.addAll(uaces);
-            }
-        }
-
-        private Iterator<AccessControlEntry> iterator() {
-            return new IteratorChain(userAces.iterator(), groupAces.iterator());
+        public void acModified(AccessControlModifications modifications) {
+            // ignore the details of the modifications and clear all caches.
+            clearCache();

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 INS23 INS31 INS31 INS29 INS83 INS43 MOV59 INS78 UPD83 MOV83 MOV39 INS42 MOV8 INS29 INS83 INS43 INS42 INS44 MOV43 MOV8 INS44 UPD43 INS23 INS23 INS31 INS31 INS31 INS31 INS31 MOV65 UPD42 MOV42 UPD42 INS21 INS42 MOV21 MOV21 MOV65 MOV65 INS65 MOV65 INS65 UPD42 MOV42 UPD43 MOV43 UPD42 MOV42 INS43 UPD42 INS60 INS41 INS65 INS39 INS42 UPD42 INS83 INS83 INS74 INS59 INS83 INS83 INS43 INS59 UPD83 MOV44 INS44 INS44 INS44 MOV29 MOV78 UPD83 MOV83 INS43 INS42 MOV44 MOV43 INS8 INS29 INS78 INS83 INS39 INS42 INS8 MOV29 MOV78 INS83 INS39 INS42 INS8 MOV29 INS83 INS39 INS42 INS44 INS44 MOV43 INS8 INS29 INS83 INS39 INS42 INS44 MOV8 UPD66 INS66 UPD66 INS7 INS48 UPD66 UPD66 INS66 UPD42 UPD66 INS66 UPD66 INS68 UPD42 UPD42 UPD66 UPD42 MOV42 MOV74 INS59 INS42 INS42 INS66 INS66 UPD66 INS66 INS42 UPD66 UPD66 UPD66 MOV32 INS43 INS43 INS43 INS42 INS14 INS42 INS42 INS14 INS39 INS42 INS39 INS42 INS43 INS42 INS42 MOV60 INS60 MOV60 INS54 MOV25 MOV60 INS41 INS65 INS42 INS51 INS21 INS21 MOV21 INS43 INS42 INS43 INS42 INS60 INS60 MOV60 INS25 INS60 INS51 INS41 INS65 INS43 INS42 INS42 INS32 INS42 UPD42 UPD42 INS42 INS69 INS69 UPD43 INS42 INS42 INS42 INS42 INS32 INS60 INS21 INS42 INS42 INS42 INS43 INS34 INS43 INS42 INS43 INS59 INS43 INS8 INS12 INS32 INS68 INS42 INS8 INS48 INS32 UPD42 MOV42 UPD42 MOV42 INS43 INS59 INS39 INS59 UPD43 INS32 INS8 MOV8 INS39 INS59 INS42 INS8 INS42 INS68 INS42 INS42 INS11 MOV32 MOV43 INS43 UPD42 INS32 MOV42 INS43 INS59 INS32 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 INS32 INS60 INS25 MOV44 INS8 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS14 INS42 INS42 MOV21 INS42 INS42 INS42 INS52 INS42 INS42 INS69 INS42 INS42 INS16 INS42 INS9 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 INS21 INS21 INS42 INS25 INS40 INS42 INS69 INS43 INS42 UPD42 INS33 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 UPD42 UPD42 INS42 INS42 INS14 UPD42 INS42 INS42 MOV43 INS59 MOV32 INS8 INS8 MOV60 INS60 INS24 INS21 INS43 INS42 INS32 INS43 INS36 INS32 INS42 INS7 INS7 INS32 MOV8 INS8 INS43 INS42 INS36 INS42 MOV43 INS32 INS32 INS32 UPD42 UPD42 INS42 INS42 INS32 INS21 MOV21 INS21 MOV43 INS59 INS58 INS27 INS37 INS8 INS7 INS42 INS42 INS42 INS42 INS27 INS32 INS42 UPD42 MOV42 INS42 INS11 INS42 INS9 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 INS60 INS60 INS60 MOV21 MOV21 INS42 INS11 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV43 INS43 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS7 INS7 INS42 INS11 INS39 INS59 INS42 INS27 INS42 MOV60 MOV60 INS25 INS21 INS42 INS42 INS42 INS33 UPD42 MOV42 UPD42 MOV42 INS43 INS42 INS36 UPD42 INS43 INS59 MOV43 INS59 INS43 INS59 INS43 INS32 INS42 INS32 INS42 MOV11 INS42 MOV11 MOV43 MOV32 INS42 INS34 INS40 INS34 UPD43 INS39 INS38 INS8 INS7 INS42 INS11 UPD42 INS42 INS42 INS32 INS42 INS11 INS42 INS42 INS32 UPD42 INS32 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 UPD42 MOV42 INS42 UPD42 UPD42 UPD42 INS32 INS10 INS42 INS32 INS43 INS42 UPD42 UPD42 INS42 INS42 INS42 MOV43 INS32 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS14 INS42 INS42 INS40 INS2 INS42 INS2 UPD42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL40 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL9 DEL41 DEL8 DEL25 DEL8 DEL70 DEL9 DEL41 DEL8 DEL31 DEL66 DEL65 DEL40 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL44 DEL42 DEL43 DEL42 DEL36 DEL16 DEL36 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL27 DEL41 DEL8 DEL31 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL38 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL8 DEL25 DEL42 DEL42 DEL32 DEL32 DEL40 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL43 DEL74 DEL42 DEL43 DEL42 DEL42 DEL14 DEL32 DEL41 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL14 DEL32 DEL21 DEL39 DEL42 DEL40 DEL40 DEL40 DEL27 DEL59 DEL60 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL4 DEL3 DEL59 DEL60 DEL42 DEL42 DEL32 DEL9 DEL33 DEL42 DEL9 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL10 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL34 DEL32 DEL7 DEL21 DEL8 DEL61 DEL8 DEL25 DEL39 DEL9 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL9 DEL7 DEL40 DEL42 DEL33 DEL42 DEL42 DEL42 DEL32 DEL9 DEL45 DEL32 DEL83 DEL39 DEL42 DEL42 DEL42 DEL52 DEL32 DEL21 DEL8 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL31 DEL40 DEL42 DEL43 DEL69 DEL68 DEL65 DEL29 DEL83 DEL39 DEL42 DEL43 DEL42 DEL44 DEL32 DEL42 DEL38 DEL27 DEL32 DEL40 DEL49 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL27 DEL8 DEL25 DEL10 DEL40 DEL49 DEL40 DEL49 DEL42 DEL9 DEL7 DEL21 DEL10 DEL40 DEL49 DEL40 DEL49 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL32 DEL25 DEL25 DEL42 DEL33 DEL27 DEL42 DEL32 DEL27 DEL8 DEL25 DEL8 DEL25 DEL10 DEL40 DEL49 DEL10 DEL49 DEL50 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL8 DEL61 DEL42 DEL25 DEL8 DEL31 DEL29 DEL83 DEL42 DEL83 DEL83 DEL43 DEL42 DEL43 DEL74 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL14 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL14 DEL59 DEL23 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL42 DEL42 DEL43 DEL31 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL43 DEL74 DEL42 DEL42 DEL43 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL44 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL34 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL34 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL70 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL83 DEL42 DEL31 DEL55
JCR-1104: JSR 283 support

work in (slow) progress...

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@597142 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.data.DataStore;
-import org.apache.jackrabbit.core.value.InternalValue;
+import org.apache.jackrabbit.core.data.DataStore;
+import org.apache.jackrabbit.core.nodetype.jsr283.NodeTypeDefinition;
+import org.apache.jackrabbit.core.value.InternalValue;
-import org.apache.jackrabbit.value.ValueHelper;
+import org.apache.jackrabbit.value.ValueHelper;
+import javax.jcr.NamespaceException;
-import javax.jcr.NamespaceException;
-public class NodeTypeImpl implements NodeType {
+public class NodeTypeImpl implements NodeType, NodeTypeDefinition {
-    //-------------------------------------------------------------< NodeType >
+    //---------------------------------------------------< NodeTypeDefinition >
+     * Returns the names of the supertypes actually declared in this node type.
+     * <p/>
+     * In implementations that support node type registration, if this
+     * <code>NodeTypeDefinition</code> object is actually a newly-created empty
+     * <code>NodeTypeTemplate</code>, then this method will return an array
+     * containing a single string indicating the node type
+     * <code>nt:base</code>.
+     *
+     * @return an array of <code>String</code>s
+     * @since JCR 2.0
+     */
+    public String[] getDeclaredSupertypeNames() {
+        Name[] ntNames = ntd.getSupertypes();
+        String[] supertypes = new String[ntNames.length];
+        for (int i = 0; i < ntNames.length; i++) {
+            try {
+                supertypes[i] = resolver.getJCRName(ntd.getName());
+            } catch (NamespaceException e) {
+                // should never get here
+                log.error("encountered unregistered namespace in node type name", e);
+                supertypes[i] = ntd.getName().toString();
+            }
+        }
+        return supertypes;
+    }
+
+    /**
+     * Returns <code>true</code> if this is an abstract node type; returns
+     * <code>false</code> otherwise.
+     * <p/>
+     * An abstract node type is one that cannot be assigned as the primary or
+     * mixin type of a node but can be used in the definitions of other node
+     * types as a superclass.
+     * <p/>
+     * In implementations that support node type registration, if this
+     * <code>NodeTypeDefinition</code> object is actually a newly-created empty
+     * <code>NodeTypeTemplate</code>, then this method will return
+     * <code>false</code>.
+     *
+     * @return a <code>boolean</code>
+     * @since JCR 2.0
+     */
+    public boolean isAbstract() {
+        return ntd.isAbstract();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean isMixin() {
+        return ntd.isMixin();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean hasOrderableChildNodes() {
+        return ntd.hasOrderableChildNodes();
+    }
+
+    /**
-    public boolean isMixin() {
-        return ntd.isMixin();
+    public NodeType[] getDeclaredSupertypes() {
+        Name[] ntNames = ntd.getSupertypes();
+        NodeType[] supertypes = new NodeType[ntNames.length];
+        for (int i = 0; i < ntNames.length; i++) {
+            try {
+                supertypes[i] = ntMgr.getNodeType(ntNames[i]);
+            } catch (NoSuchNodeTypeException e) {
+                // should never get here
+                log.error("undefined supertype", e);
+                return new NodeType[0];
+            }
+        }
+        return supertypes;
+    public NodeDefinition[] getDeclaredChildNodeDefinitions() {
+        NodeDef[] cnda = ntd.getChildNodeDefs();
+        NodeDefinition[] nodeDefs = new NodeDefinition[cnda.length];
+        for (int i = 0; i < cnda.length; i++) {
+            nodeDefs[i] = ntMgr.getNodeDefinition(cnda[i].getId());
+        }
+        return nodeDefs;
+    }
+
+    //-------------------------------------------------------------< NodeType >
+    /**
+     * {@inheritDoc}
+     */
-    public boolean hasOrderableChildNodes() {
-        return ntd.hasOrderableChildNodes();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public NodeType[] getDeclaredSupertypes() {
-        Name[] ntNames = ntd.getSupertypes();
-        NodeType[] supertypes = new NodeType[ntNames.length];
-        for (int i = 0; i < ntNames.length; i++) {
-            try {
-                supertypes[i] = ntMgr.getNodeType(ntNames[i]);
-            } catch (NoSuchNodeTypeException e) {
-                // should never get here
-                log.error("undefined supertype", e);
-                return new NodeType[0];
-            }
-        }
-        return supertypes;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public NodeDefinition[] getDeclaredChildNodeDefinitions() {
-        NodeDef[] cnda = ntd.getChildNodeDefs();
-        NodeDefinition[] nodeDefs = new NodeDefinition[cnda.length];
-        for (int i = 0; i < cnda.length; i++) {
-            nodeDefs[i] = ntMgr.getNodeDefinition(cnda[i].getId());
-        }
-        return nodeDefs;
-    }
-
-    /**
-     * {@inheritDoc}
-     */

MOV26 MOV26 MOV26 MOV26 INS26 MOV31 MOV31 MOV31 MOV31 INS40 INS43 INS31 INS31 INS42 INS29 INS83 INS5 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS65 INS65 INS65 INS43 INS85 INS60 INS60 INS24 INS41 INS65 INS65 INS65 INS41 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS5 INS59 INS5 INS59 INS58 INS27 INS37 INS8 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS32 INS43 INS85 INS42 INS32 INS43 INS85 INS42 INS3 INS39 INS59 INS42 INS40 INS42 INS54 INS42 INS42 INS42 INS42 INS42 INS42 INS5 INS40 INS42 INS34 INS8 INS12 INS43 INS85 INS21 INS44 INS8 INS42 INS7 INS43 INS42 INS21 INS21 INS2 INS32 INS42 INS32 INS7 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS2 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42
True caching in CachingHierarchyManager

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@190372 13f79535-47bb-0310-9956-ffa450edef68

-    private final Child root = new Child(Path.ROOT.getNameElement());
+    private final Element root = new Element(Path.ROOT.getNameElement());
-    public Child map(Path path, boolean exact) {
+    public Element map(Path path, boolean exact) {
-        Child current = root;
+        Element current = root;
-            Child next = current.getChild(elements[i], false);
+            Element next = current.getChild(elements[i]);
-     * Create a child given by its path. The path map will create any necessary
-     * intermediate children.
+     * Create an element given by its path. The path map will create any necessary
+     * intermediate elements.
-    public Child put(Path path, Object obj) {
-        Child child = put(path);
-        child.obj = obj;
-        return child;
+    public Element put(Path path, Object obj) {
+        Element element = put(path);
+        element.obj = obj;
+        return element;
+    }
+
+    /**
+     * Put an element given by its path. The path map will create any necessary
+     * intermediate elements.
+     * @param path path to child
+     * @param element element to store at destination
+     */
+    public void put(Path path, Element element) {
+        Path.PathElement[] elements = path.getElements();
+        Element current = root;
+
+        for (int i = 1; i < elements.length - 1; i++) {
+            Element next = current.getChild(elements[i]);
+            if (next == null) {
+                next = current.createChild(elements[i]);
+            }
+            current = next;
+        }
+        current.put(path.getNameElement(), element);
-    public Child put(Path path) {
+    public Element put(Path path) {
-        Child current = root;
+        Element current = root;
-            current = current.getChild(elements[i], true);
+            Element next = current.getChild(elements[i]);
+            if (next == null) {
+                next = current.createChild(elements[i]);
+            }
+            current = next;
-     * Ressurrect a child previously removed, given by its path and the
-     * child structure. If an item at path already exists, nothing happens.
-     * @param path new path to child
-     * @param zombie previously removed child object to store at destination
-     */
-    public void resurrect(Path path, Child zombie) {
-        Path.PathElement[] elements = path.getElements();
-        Path.PathElement name = path.getNameElement();
-        Child parent = root;
-
-        if (map(path, true) == null) {
-            for (int i = 1; i < elements.length - 1; i++) {
-                parent = parent.getChild(elements[i], true);
-            }
-            parent.setChild(name, zombie);
-        }
-    }
-
-    /**
-    public void traverse(ChildVisitor visitor, boolean includeEmpty) {
+    public void traverse(ElementVisitor visitor, boolean includeEmpty) {
-    public static class Child {
+    public static class Element {
-         * Parent child
+         * Parent element
-        private Child parent;
+        private Element parent;
-         * Map of immediate children of this child.
+         * Map of immediate children
-         * Number of non-null children
+         * Number of non-empty children
-         * Object associated with this child
+         * Object associated with this element
-         * QName associated with this child
+         * QName associated with this element
-         * index associated with this child
+         * index associated with this element
-         * @param element path element of this child
+         * @param nameIndex path element of this child
-        Child(Path.PathElement element) {
-            this.name = element.getName();
-            this.index = element.getIndex();
+        private Element(Path.PathElement nameIndex) {
+            this.name = nameIndex.getName();
+            this.index = nameIndex.getIndex();
-         * Create a new instance of this class.
+         * Create a child of this node inside the path map.
+         * @param nameIndex position where child is created
+         * @return child
-        Child() {
+        private Element createChild(Path.PathElement nameIndex) {
+            Element element = new Element(nameIndex);
+            put(nameIndex, element);
+            return element;
-         * @param element child's path element
+         * @param nameIndex position where child is inserted
-        public void insertChild(Path.PathElement element) {
-            int index = getOneBasedIndex(element) - 1;
+        public void insert(Path.PathElement nameIndex) {
+            int index = getOneBasedIndex(nameIndex) - 1;
-                ArrayList list = (ArrayList) children.get(element.getName());
+                ArrayList list = (ArrayList) children.get(nameIndex.getName());
-                        Child child = (Child) list.get(i);
-                        if (child != null) {
-                            child.index++;
+                        Element element = (Element) list.get(i);
+                        if (element != null) {
+                            element.index++;
+         * Return an element matching a name and index.
+         * @param nameIndex position where child is located
+         * @return element matching <code>nameIndex</code> or <code>null</code> if
+         *         none exists.
+         */
+        private Element getChild(Path.PathElement nameIndex) {
+            int index = getOneBasedIndex(nameIndex) - 1;
+            Element element = null;
+
+            if (children != null) {
+                ArrayList list = (ArrayList) children.get(nameIndex.getName());
+                if (list != null && list.size() > index) {
+                    element = (Element) list.get(index);
+                }
+            }
+            return element;
+        }
+
+        /**
+         * Link a child of this node. Position is given by <code>nameIndex</code>.
+         * @param nameIndex position where child should be located
+         * @param element element to add
+         */
+        public void put(Path.PathElement nameIndex, Element element) {
+            int index = getOneBasedIndex(nameIndex) - 1;
+            if (children == null) {
+                children = new HashMap();
+            }
+            ArrayList list = (ArrayList) children.get(nameIndex.getName());
+            if (list == null) {
+                list = new ArrayList();
+                children.put(nameIndex.getName(), list);
+            }
+            while (list.size() < index) {
+                list.add(null);
+            }
+            if (list.size() == index) {
+                list.add(element);
+            } else {
+                list.set(index, element);
+            }
+
+            element.parent = this;
+            element.name = nameIndex.getName();
+            element.index = nameIndex.getIndex();
+
+            childrenCount++;
+        }
+
+        /**
-         * the child removed to the left.
-         * @param element child's path element
+         * the child removed to the left. If there are no more children left in
+         * this child and no object is associated with this child, the child
+         * itself gets removed.
+         *
+         * @param nameIndex child's path element
-        public Child removeChild(Path.PathElement element) {
-            int index = getOneBasedIndex(element) - 1;
+        public Element remove(Path.PathElement nameIndex) {
+            int index = getOneBasedIndex(nameIndex) - 1;
-                ArrayList list = (ArrayList) children.get(element.getName());
+                ArrayList list = (ArrayList) children.get(nameIndex.getName());
-                        Child child = (Child) list.get(i);
-                        if (child != null) {
-                            child.index--;
+                        Element element = (Element) list.get(i);
+                        if (element != null) {
+                            element.index--;
-                    Child child = (Child) list.remove(index);
-                    if (child != null) {
-                        child.parent = null;
+                    Element element = (Element) list.remove(index);
+                    if (element != null) {
+                        element.parent = null;
-                    if (obj == null && childrenCount == 0) {
+                    if (childrenCount == 0 && obj == null) {
-                    return child;
+                    return element;
-         * Return a child matching a path element. If a child does not exist
-         * at that position and <code>create</code> is <code>true</code> a
-         * new child will be created.
-         * @param element child's path element
-         * @param create flag indicating whether this child should be
-         *        created if not available
-         */
-        private Child getChild(Path.PathElement element, boolean create) {
-            int index = getOneBasedIndex(element) - 1;
-            Child child = null;
-
-            if (children != null) {
-                ArrayList list = (ArrayList) children.get(element.getName());
-                if (list != null && list.size() > index) {
-                    child = (Child) list.get(index);
-                }
-            }
-            if (child == null && create) {
-                child = new Child();
-                setChild(element, child);
-            }
-            return child;
-        }
-
-        /**
-         * Add a child.
-         * @param element child's path element
-         * @param child child to add
-         */
-        private void setChild(Path.PathElement element, Child child) {
-            int index = getOneBasedIndex(element) - 1;
-            if (children == null) {
-                children = new HashMap();
-            }
-            ArrayList list = (ArrayList) children.get(element.getName());
-            if (list == null) {
-                list = new ArrayList();
-                children.put(element.getName(), list);
-            }
-            while (list.size() < index) {
-                list.add(null);
-            }
-            if (list.size() == index) {
-                list.add(child);
-            } else {
-                list.set(index, child);
-            }
-
-            child.parent = this;
-            child.name = element.getName();
-            child.index = element.getIndex();
-
-            childrenCount++;
-        }
-
-        /**
-         * Remove this child. Delegates the call to the parent item.
+         * Remove this element. Delegates the call to the parent item.
-                parent.removeChild(getPathElement());
+                parent.remove(getPathElement());
-         * Return the object associated with this child
-         * @return object associated with this child
+         * Return the object associated with this element
+         * @return object associated with this element
-         * Set the object associated with this child
-         * @param obj object associated with this child
+         * Set the object associated with this element
+         * @param obj object associated with this element
-         * Return the name of this child
+         * Return the name of this element
-         * Return the index of this child
+         * Return the index of this element
-         * Return a path element pointing to this child
+         * Return a path element pointing to this element
-         * Checks whether this child has the specified path. Introduced to
+         * Checks whether this element has the specified path. Introduced to
-         * Checks whether this child has the specified path, given by
+         * Checks whether this element has the specified path, given by
-         * @return <code>true</code> if this child has the path given;
+         * @return <code>true</code> if this element has the path given;
-        private static int getOneBasedIndex(Path.PathElement element) {
-            int index = element.getIndex();
+        private static int getOneBasedIndex(Path.PathElement nameIndex) {
+            int index = nameIndex.getIndex();
-         *        child regardless, whether the associated object is empty
+         *        element regardless, whether the associated object is empty
-        public void traverse(ChildVisitor visitor, boolean includeEmpty) {
+        public void traverse(ElementVisitor visitor, boolean includeEmpty) {
-                        Child child = (Child) list.get(i);
-                        if (child != null) {
-                            child.traverse(visitor, includeEmpty);
+                        Element element = (Element) list.get(i);
+                        if (element != null) {
+                            element.traverse(visitor, includeEmpty);
-                visitor.childVisited(this);
+                visitor.elementVisited(this);
-         * Return the depth of this child. Defined to be <code>0</code> for the
-         * root node and <code>n + 1</code> for some child if the depth of its
-         * parent is <code>n</code>.
+         * Return the depth of this element. Defined to be <code>0</code> for the
+         * root element and <code>n + 1</code> for some element if the depth of
+         * its parent is <code>n</code>.
-        public boolean isAncestorOf(Child other) {
-            Child parent = other.parent;
+        public boolean isAncestorOf(Element other) {
+            Element parent = other.parent;
-         * Return the parent of this child
-         * @return parent or <code>null</code> if this is the root node
+         * Return the parent of this element
+         * @return parent or <code>null</code> if this is the root element
-        public Child getParent() {
+        public Element getParent() {
+
+        /**
+         * Return the children count of this element
+         * @return children count
+         */
+        public int getChildrenCount() {
+            return childrenCount;
+        }
-     * Child visitor used in {@link PathMap#traverse}
+     * Element visitor used in {@link PathMap#traverse}
-    public interface ChildVisitor {
+    public interface ElementVisitor {
-         * Invoked for every child visited on a tree traversal
-         * @param child child visited
+         * Invoked for every element visited on a tree traversal
+         * @param element element visited
-        void childVisited(Child child);
+        void elementVisited(Element element);

MOV31 MOV31 UPD43 UPD43 UPD43 UPD42 UPD43 UPD42 INS31 UPD42 UPD42 UPD42 UPD42 UPD43 UPD42 MOV60 INS24 MOV21 UPD42 INS60 UPD43 UPD43 INS83 UPD42 INS44 INS83 INS43 UPD42 MOV44 UPD42 UPD43 UPD83 UPD42 MOV44 UPD43 UPD42 UPD43 INS29 INS83 INS39 INS42 INS8 UPD42 UPD43 UPD43 UPD66 UPD66 UPD43 UPD42 UPD66 UPD66 UPD66 UPD42 UPD66 UPD42 UPD43 MOV58 MOV27 MOV37 INS8 INS43 INS59 INS8 UPD42 UPD42 INS43 INS42 INS65 INS65 INS42 UPD42 INS60 INS21 INS41 UPD42 UPD65 UPD42 MOV43 UPD42 INS41 UPD42 UPD43 UPD42 UPD42 UPD42 UPD43 UPD43 UPD42 INS65 INS65 INS41 UPD66 UPD43 UPD42 UPD42 UPD42 UPD42 UPD42 UPD40 UPD42 MOV60 INS25 INS21 UPD42 UPD42 MOV32 UPD42 INS42 INS42 INS42 INS60 INS25 INS21 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD42 INS40 UPD66 INS42 INS66 INS66 INS43 INS59 INS32 INS42 UPD42 UPD66 UPD66 UPD42 UPD66 UPD66 UPD66 UPD43 INS42 UPD66 UPD42 UPD66 UPD42 UPD66 INS42 MOV43 UPD66 INS66 INS66 UPD42 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD42 UPD66 UPD66 UPD66 UPD42 UPD43 UPD66 UPD66 INS66 INS66 INS42 UPD66 UPD42 UPD66 UPD42 UPD43 UPD43 MOV27 INS8 INS7 INS43 INS59 INS27 INS8 INS7 INS42 INS42 INS14 INS42 INS42 INS42 UPD42 UPD42 UPD40 UPD40 UPD40 UPD42 UPD42 UPD42 UPD42 MOV32 INS42 MOV21 INS42 INS42 INS42 INS42 INS32 INS42 INS33 MOV21 INS42 INS42 UPD42 UPD42 INS43 INS42 MOV43 INS8 MOV43 MOV43 UPD42 UPD42 MOV43 UPD42 INS42 INS42 INS2 INS42 UPD42 INS24 MOV21 UPD42 UPD42 UPD42 UPD42 UPD42 MOV24 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS32 INS43 MOV58 MOV27 MOV37 INS8 MOV43 UPD42 UPD42 MOV43 MOV58 MOV27 MOV37 UPD43 MOV27 UPD42 UPD42 UPD42 INS42 INS42 INS2 INS42 INS60 INS25 UPD42 UPD42 UPD42 UPD42 INS42 INS42 UPD42 INS43 INS59 INS27 MOV8 UPD42 UPD43 UPD42 UPD43 UPD43 UPD43 INS42 INS42 INS11 INS42 INS33 INS21 UPD42 UPD42 UPD42 UPD42 UPD42 UPD40 UPD42 UPD42 UPD42 INS43 MOV32 INS37 UPD43 UPD37 UPD43 INS42 INS40 UPD42 UPD40 UPD42 UPD42 DEL9 DEL42 DEL9 DEL42 DEL42 DEL9 DEL32 DEL9 DEL42 DEL42 DEL59 DEL60 DEL8 DEL24 DEL8 DEL25 DEL42 DEL8 DEL66 DEL66 DEL42 DEL39 DEL42 DEL33 DEL27 DEL42 DEL27 DEL42 DEL42 DEL43 DEL14 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL41 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL43 DEL11 DEL59 DEL60 DEL42 DEL33 DEL27 DEL40 DEL37 DEL21 DEL8 DEL25 DEL8 DEL24
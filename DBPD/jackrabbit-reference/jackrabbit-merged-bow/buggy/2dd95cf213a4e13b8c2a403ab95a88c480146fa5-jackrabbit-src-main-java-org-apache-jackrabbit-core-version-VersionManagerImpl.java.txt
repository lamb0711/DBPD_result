[JCR-335] Deadlock caused by versioning operations within transaction

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@393004 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.collections.map.ReferenceMap;
-import org.apache.jackrabbit.core.NodeId;
-import org.apache.jackrabbit.core.NodeImpl;
-import org.apache.jackrabbit.core.PropertyId;
-import org.apache.jackrabbit.core.SessionImpl;
-import org.apache.jackrabbit.core.fs.FileSystem;
-import org.apache.jackrabbit.core.nodetype.NodeTypeRegistry;
-import org.apache.jackrabbit.core.observation.DelegatingObservationDispatcher;
-import org.apache.jackrabbit.core.observation.EventStateCollection;
-import org.apache.jackrabbit.core.observation.EventStateCollectionFactory;
-import org.apache.jackrabbit.core.state.ChangeLog;
-import org.apache.jackrabbit.core.state.ItemStateException;
-import org.apache.jackrabbit.core.state.LocalItemStateManager;
-import org.apache.jackrabbit.core.state.NodeReferences;
-import org.apache.jackrabbit.core.state.NodeReferencesId;
-import org.apache.jackrabbit.core.state.NodeState;
-import org.apache.jackrabbit.core.state.PersistenceManager;
-import org.apache.jackrabbit.core.state.PropertyState;
-import org.apache.jackrabbit.core.state.SharedItemStateManager;
-import org.apache.jackrabbit.core.value.InternalValue;
-import org.apache.jackrabbit.core.virtual.VirtualItemStateProvider;
-import org.apache.jackrabbit.name.QName;
-import org.apache.jackrabbit.name.Path;
-import org.apache.jackrabbit.name.MalformedPathException;
+import org.apache.commons.collections.map.ReferenceMap;
+import org.apache.jackrabbit.core.observation.EventStateCollection;
+import org.apache.jackrabbit.core.observation.DelegatingObservationDispatcher;
+import org.apache.jackrabbit.core.observation.EventStateCollectionFactory;
+import org.apache.jackrabbit.core.SessionImpl;
+import org.apache.jackrabbit.core.NodeId;
+import org.apache.jackrabbit.core.PropertyId;
+import org.apache.jackrabbit.core.NodeImpl;
+import org.apache.jackrabbit.core.virtual.VirtualItemStateProvider;
+import org.apache.jackrabbit.core.value.InternalValue;
+import org.apache.jackrabbit.core.nodetype.NodeTypeRegistry;
+import org.apache.jackrabbit.core.fs.FileSystem;
+import org.apache.jackrabbit.core.state.PersistenceManager;
+import org.apache.jackrabbit.core.state.SharedItemStateManager;
+import org.apache.jackrabbit.core.state.LocalItemStateManager;
+import org.apache.jackrabbit.core.state.PropertyState;
+import org.apache.jackrabbit.core.state.NodeState;
+import org.apache.jackrabbit.core.state.ChangeLog;
+import org.apache.jackrabbit.core.state.ItemStateException;
+import org.apache.jackrabbit.core.state.NodeReferences;
+import org.apache.jackrabbit.core.state.NodeReferencesId;
+import org.apache.jackrabbit.name.Path;
+import org.apache.jackrabbit.name.QName;
+import org.apache.jackrabbit.name.MalformedPathException;
-import javax.jcr.PropertyType;
-import javax.jcr.ReferentialIntegrityException;
+import javax.jcr.PropertyType;
-import javax.jcr.version.Version;
-import javax.jcr.version.VersionException;
+import javax.jcr.ReferentialIntegrityException;
-import java.util.ArrayList;
+import javax.jcr.version.VersionException;
+import javax.jcr.version.Version;
-import java.util.Collections;
+import java.util.ArrayList;
+import java.util.Collections;
-        implements EventStateCollectionFactory {
+        /*implements EventStateCollectionFactory*/ {
-     * the observation manager
+     * the dynamic event state collection factory
-    private DelegatingObservationDispatcher obsMgr;
+    private final DynamicESCFactory escFactory;
-     * Session to be used when creating observation events.
-     */
-    private transient SessionImpl eventSource;
-
-    /**
-     * workaround for potential deadlock
-     */
-    private final Object eventSourceLock = new Object();
-
-    /**
-            this.obsMgr = obsMgr;
+            this.escFactory = new DynamicESCFactory(obsMgr);
-            stateMgr = new LocalItemStateManager(sharedStateMgr, this);
+            stateMgr = new LocalItemStateManager(sharedStateMgr, escFactory);
+     * Returns the event state collection factory.
+     * @return the event state collection factory.
+     */
+    public DynamicESCFactory getEscFactory() {
+        return escFactory;
+    }
+
+    /**
-    public VersionHistory createVersionHistory(Session session, NodeState node)
+    public VersionHistory createVersionHistory(Session session, final NodeState node)
-        InternalVersionHistory history;
-        synchronized (eventSourceLock) {
-            // This needs to be synchronized since it sets the event source
-            // to be used when creating the events to be dispatched later on.
-            eventSource = (SessionImpl) session;
-
-            history = createVersionHistory(node);
-        }
+        InternalVersionHistory history = (InternalVersionHistory)
+                escFactory.doSourced((SessionImpl) session, new SourcedTarget(){
+            public Object run() throws RepositoryException {
+                return createVersionHistory(node);
+            }
+        });
-    public Version checkin(NodeImpl node) throws RepositoryException {
-        InternalVersion version;
+    public Version checkin(final NodeImpl node) throws RepositoryException {
+        InternalVersion version = (InternalVersion)
+                escFactory.doSourced((SessionImpl) node.getSession(), new SourcedTarget(){
+            public Object run() throws RepositoryException {
+                String histUUID = node.getProperty(QName.JCR_VERSIONHISTORY).getString();
+                InternalVersion version = checkin((InternalVersionHistoryImpl)
+                        getVersionHistory(NodeId.valueOf(histUUID)), node);
-        synchronized (eventSourceLock) {
-            // This  needs to be synchronized since it sets the event source
-            // to be used when creating the events to be dispatched later on.
-            eventSource = (SessionImpl) node.getSession();
-
-            String histUUID = node.getProperty(QName.JCR_VERSIONHISTORY).getString();
-            version = checkin((InternalVersionHistoryImpl)
-                    getVersionHistory(NodeId.valueOf(histUUID)), node);
-
-            // invalidate predecessors successor properties
-            InternalVersion[] preds = version.getPredecessors();
-            for (int i = 0; i < preds.length; i++) {
-                PropertyId propId = new PropertyId(preds[i].getId(), QName.JCR_SUCCESSORS);
-                versProvider.onPropertyChanged(propId);
+                // invalidate predecessors successor properties
+                InternalVersion[] preds = version.getPredecessors();
+                for (int i = 0; i < preds.length; i++) {
+                    PropertyId propId = new PropertyId(preds[i].getId(), QName.JCR_SUCCESSORS);
+                    versProvider.onPropertyChanged(propId);
+                }
+                return version;
-        }
-        return (AbstractVersion) eventSource.getNodeById(version.getId());
+        });
+
+        return (AbstractVersion)
+                ((SessionImpl) node.getSession()).getNodeById(version.getId());
-    public void removeVersion(VersionHistory history, QName name)
+    public void removeVersion(VersionHistory history, final QName name)
-        AbstractVersionHistory historyImpl = (AbstractVersionHistory) history;
+        final AbstractVersionHistory historyImpl = (AbstractVersionHistory) history;
-        synchronized (eventSourceLock) {
-            // This needs to be synchronized since it sets the event source
-            // to be used when creating the events to be dispatched later on.
-            eventSource = (SessionImpl) history.getSession();
+        escFactory.doSourced((SessionImpl) history.getSession(), new SourcedTarget(){
+            public Object run() throws RepositoryException {
+                AbstractVersion version = (AbstractVersion) historyImpl.getNode(name);
+                InternalVersion[] preds = version.getInternalVersion().getPredecessors();
-            // save away predecessors before removing version
-            AbstractVersion version = (AbstractVersion) historyImpl.getNode(name);
-            InternalVersion[] preds = version.getInternalVersion().getPredecessors();
+                InternalVersionHistoryImpl vh = (InternalVersionHistoryImpl)
+                        historyImpl.getInternalVersionHistory();
+                removeVersion(vh, name);
-            InternalVersionHistoryImpl vh = (InternalVersionHistoryImpl)
-                    historyImpl.getInternalVersionHistory();
-            removeVersion(vh, name);
-
-            // invalidate predecessors successor properties
-            for (int i = 0; i < preds.length; i++) {
-                PropertyId propId = new PropertyId(preds[i].getId(), QName.JCR_SUCCESSORS);
-                versProvider.onPropertyChanged(propId);
+                // invalidate predecessors successor properties
+                for (int i = 0; i < preds.length; i++) {
+                    PropertyId propId = new PropertyId(preds[i].getId(), QName.JCR_SUCCESSORS);
+                    versProvider.onPropertyChanged(propId);
+                }
+                return null;
-        }
+        });
-    public Version setVersionLabel(VersionHistory history,
-                                                QName version, QName label,
-                                                boolean move)
+    public Version setVersionLabel(final VersionHistory history,
+                                   final QName version, final QName label,
+                                   final boolean move)
-        AbstractVersionHistory historyImpl = (AbstractVersionHistory) history;
-        InternalVersion v;
-        synchronized (eventSourceLock) {
-            // This  needs to be synchronized since it sets the event source
-            // to be used when creating the events to be dispatched later on.
-            eventSource = (SessionImpl) history.getSession();
+        InternalVersion v = (InternalVersion)
+                escFactory.doSourced((SessionImpl) history.getSession(), new SourcedTarget(){
+            public Object run() throws RepositoryException {
+                InternalVersionHistoryImpl vh = (InternalVersionHistoryImpl)
+                        ((AbstractVersionHistory) history).getInternalVersionHistory();
+                return setVersionLabel(vh, version, label, move);
+            }
+        });
-            InternalVersionHistoryImpl vh = (InternalVersionHistoryImpl)
-                    historyImpl.getInternalVersionHistory();
-            v = setVersionLabel(vh, version, label, move);
-        }
-            return (Version) eventSource.getNodeByUUID(v.getId().getUUID());
+            return (Version)
+                    ((SessionImpl) history.getSession()).getNodeByUUID(v.getId().getUUID());
-    //------------------------------------------< EventStateCollectionFactory >
-
-    /**
-     * {@inheritDoc}
-     * <p/>
-     * This object uses one instance of a <code>LocalItemStateManager</code>
-     * to update data on behalf of many sessions. In order to maintain the
-     * association between update operation and session who actually invoked
-     * the update, an internal event source is used.
-     */
-    public synchronized EventStateCollection createEventStateCollection()
-            throws RepositoryException {
-
-        if (eventSource == null) {
-            throw new RepositoryException("Unknown event source.");
-        }
-        return createEventStateCollection(eventSource);
-    }
-
-    /**
-     * Creates an {@link EventStateCollection} using the given <code>source</code>.
-     * @param source the Session that did the changes.
-     * @return <code>EventStateCollection</code>.
-     */
-    EventStateCollection createEventStateCollection(SessionImpl source) {
-        return obsMgr.createEventStateCollection(source, VERSION_STORAGE_PATH);
-    }
-
+
+    public static final class DynamicESCFactory implements EventStateCollectionFactory {
+
+        /**
+         * the observation manager
+         */
+        private DelegatingObservationDispatcher obsMgr;
+
+        /**
+         * the current event source
+         */
+        private SessionImpl source;
+
+
+        /**
+         * Creates a new event state collection factory
+         * @param obsMgr
+         */
+        public DynamicESCFactory(DelegatingObservationDispatcher obsMgr) {
+            this.obsMgr = obsMgr;
+        }
+
+        /**
+         * {@inheritDoc}
+         * <p/>
+         * This object uses one instance of a <code>LocalItemStateManager</code>
+         * to update data on behalf of many sessions. In order to maintain the
+         * association between update operation and session who actually invoked
+         * the update, an internal event source is used.
+         */
+        public synchronized EventStateCollection createEventStateCollection()
+                throws RepositoryException {
+            if (source == null) {
+                throw new RepositoryException("Unknown event source.");
+            }
+            return createEventStateCollection(source);
+        }
+
+        /**
+         * {@inheritDoc}
+         * <p/>
+         * This object uses one instance of a <code>LocalItemStateManager</code>
+         * to update data on behalf of many sessions. In order to maintain the
+         * association between update operation and session who actually invoked
+         * the update, an internal event source is used.
+         */
+        public EventStateCollection createEventStateCollection(SessionImpl source) {
+            return obsMgr.createEventStateCollection(source, VERSION_STORAGE_PATH);
+        }
+
+        /**
+         * Executes the given runnable using the given event source.
+         *
+         * @param eventSource
+         * @param runnable
+         * @throws RepositoryException
+         */
+        public synchronized Object doSourced(SessionImpl eventSource, SourcedTarget runnable)
+                throws RepositoryException {
+            this.source = eventSource;
+            try {
+                return runnable.run();
+            } finally {
+                this.source = null;
+            }
+        }
+    }
+
+    private abstract class SourcedTarget {
+        public abstract Object run() throws RepositoryException;
+    }

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV23 INS31 MOV44 INS55 INS55 UPD83 INS43 INS29 INS83 INS43 INS42 INS8 INS83 INS83 INS83 INS42 MOV43 MOV23 INS23 INS31 MOV31 MOV31 INS31 INS83 INS83 INS42 INS31 INS42 UPD42 INS65 UPD65 MOV65 INS42 INS41 INS83 INS60 INS83 INS83 INS21 INS83 INS83 UPD42 INS83 UPD42 INS83 INS60 INS29 INS83 MOV43 MOV59 INS29 INS83 INS42 INS44 INS8 INS83 INS29 INS83 INS83 MOV43 INS42 INS44 INS44 INS43 INS8 INS83 INS83 INS43 INS42 INS43 UPD66 INS66 UPD66 INS42 INS43 INS59 INS83 INS32 MOV43 INS59 INS65 UPD42 INS65 INS65 INS43 INS42 MOV21 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS42 INS21 INS54 INS42 INS42 INS21 INS42 MOV42 INS11 INS11 INS42 INS42 MOV11 INS14 UPD42 MOV42 INS11 INS66 INS66 INS42 INS42 UPD65 MOV65 INS66 UPD66 MOV66 UPD66 MOV66 INS66 UPD66 MOV66 INS66 INS42 INS42 INS42 INS42 INS42 INS7 INS8 INS8 INS7 MOV43 INS32 INS43 INS32 INS36 INS43 INS1 UPD43 MOV43 INS32 UPD42 UPD42 INS22 INS42 INS41 INS21 INS22 INS14 INS42 INS42 MOV11 INS14 INS42 INS42 INS42 MOV11 INS14 INS11 INS42 INS31 UPD42 INS42 INS42 MOV11 INS14 INS52 INS42 INS32 INS7 INS52 INS42 INS43 INS42 INS42 INS43 INS1 INS43 INS1 INS43 INS32 INS83 INS43 INS42 INS43 MOV8 INS43 INS1 INS36 INS42 INS42 INS22 INS33 INS42 INS42 INS31 INS42 INS31 INS42 UPD42 MOV42 INS42 INS42 INS42 INS41 INS42 INS31 INS11 INS52 INS42 INS83 MOV43 INS42 INS43 INS8 INS83 INS43 INS42 INS43 MOV8 INS33 INS83 INS43 INS42 INS43 INS8 INS43 INS32 INS42 INS41 INS42 INS42 INS60 INS41 INS42 INS42 MOV60 INS41 INS42 INS42 INS42 MOV32 INS43 INS59 INS42 MOV32 INS42 INS42 MOV32 INS36 INS11 MOV43 INS42 DEL29 DEL83 DEL83 DEL23 DEL52 DEL59 DEL60 DEL42 DEL42 DEL7 DEL21 DEL42 DEL7 DEL21 DEL8 DEL51 DEL42 DEL7 DEL21 DEL42 DEL7 DEL21 DEL42 DEL51 DEL42 DEL7 DEL21 DEL42 DEL51 DEL42 DEL42 DEL11 DEL59 DEL60 DEL42 DEL59 DEL60 DEL42 DEL42 DEL7 DEL21 DEL42 DEL7 DEL21 DEL8 DEL51 DEL42 DEL14 DEL42 DEL66 DEL65 DEL42 DEL65 DEL65
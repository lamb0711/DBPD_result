fixed: move, reorder (work in progress)
fixed: locktoken transfer
fixed: recursive transient removal of invalidated tree fails (restoreTests)
improve: simplify usage of workspace operations
fixed: store original itemId with transient operations in order to properly reflect the changelog upon batch creation
fixed: workspace import doesn't invalidate
fixed: session import uuid handling




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@513279 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeConflictException;
+import org.apache.jackrabbit.jcr2spi.operation.WorkspaceImport;
-import org.apache.commons.collections.iterators.IteratorChain;
-            // now do it for real
-            // TODO: check if states are reverted in correct order
-            Iterator[] its = new Iterator[] {changeLog.addedStates(), changeLog.deletedStates(), changeLog.modifiedStates()};
-            IteratorChain chain = new IteratorChain(its);
-            while (chain.hasNext()) {
-                ItemState state = (ItemState) chain.next();
-                state.getHierarchyEntry().revert();
-            }
-
+            // let changelog revert all changes
+            changeLog.undo();
-        setPropertyStateValue(pState, operation.getValues(), operation.getPropertyType(), options);
+        setPropertyStateValue(pState, operation.getValues(), operation.getValueType(), options);
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(WorkspaceImport)
+     */
+    public void visit(WorkspaceImport operation) throws RepositoryException {
+        throw new UnsupportedOperationException("Internal error: WorkspaceImport cannot be handled by session ItemStateManager.");
+    }
+
-        // autocreated child nodes that my are 'protected' by their def.
+        // autocreated child nodes that may be 'protected'.
+        // a new NodeState doesn't have mixins defined yet -> ent is ent of primarytype
+        EffectiveNodeType ent = validator.getEffectiveNodeType(nodeTypeName);
-        try {
-            validator.getEffectiveNodeType(new QName[]{nodeTypeName});
-        } catch (NodeTypeConflictException e) {
-            throw new RepositoryException("node type conflict: " + e.getMessage());
-        }
-        NodeState nodeState = transientStateMgr.createNewNodeState(nodeName, uuid, nodeTypeName, definition, parent);
+        // create new nodeState. NOTE, that the uniqueID is not added to the
+        // state for consistency between 'addNode' and importXML // TODO review
+        NodeState nodeState = transientStateMgr.createNewNodeState(nodeName, null, nodeTypeName, definition, parent);
+        if (uuid != null) {
+            QValue[] value = getQValues(uuid, qValueFactory);
+            EffectiveNodeType effnt = validator.getEffectiveNodeType(QName.MIX_REFERENCEABLE);
+            QPropertyDefinition pDef = effnt.getApplicablePropertyDefinition(QName.JCR_UUID, PropertyType.STRING, false);
+            addPropertyState(nodeState, QName.JCR_UUID, PropertyType.STRING, value, pDef, 0);
+        }
-        EffectiveNodeType ent = validator.getEffectiveNodeType(nodeState);
-            QValue[] autoValue = computeSystemGeneratedPropertyValues(nodeState, pd);
-            if (autoValue != null) {
-                int propOptions = ItemStateValidator.CHECK_NONE;
-                // execute 'addProperty' without adding operation.
-                addPropertyState(nodeState, pd.getQName(), pd.getRequiredType(), autoValue, pd, propOptions);
+            if (!nodeState.hasPropertyName(pd.getQName())) {
+                QValue[] autoValue = computeSystemGeneratedPropertyValues(nodeState, pd);
+                if (autoValue != null) {
+                    int propOptions = ItemStateValidator.CHECK_NONE;
+                    // execute 'addProperty' without adding operation.
+                    addPropertyState(nodeState, pd.getQName(), pd.getRequiredType(), autoValue, pd, propOptions);
+                }
-                String uniqueID = parent.getUniqueID();
-                if (uniqueID == null) {
-                    uniqueID = UUID.randomUUID().toString();
-                }
-                genValues = new QValue[]{qValueFactory.create(uniqueID, PropertyType.REFERENCE)};
+                genValues = getQValues(parent.getUniqueID(), qValueFactory);
+
+    private static QValue[] getQValues(String uniqueID, QValueFactory factory) {
+        if (uniqueID == null) {
+            uniqueID = UUID.randomUUID().toString();
+        }
+        return new QValue[] {factory.create(uniqueID, PropertyType.STRING)};
+    }

MOV26 UPD40 INS31 INS31 INS29 INS83 INS39 INS42 INS44 MOV43 INS8 INS83 INS83 INS5 INS42 INS44 INS44 MOV8 INS65 INS65 INS43 INS42 INS53 INS60 INS25 INS43 INS85 MOV43 INS42 INS43 INS42 INS41 INS8 INS42 INS68 INS42 INS14 INS43 INS59 INS27 INS8 INS42 INS42 INS3 MOV21 MOV21 MOV21 INS42 INS42 INS69 INS43 INS45 UPD42 MOV42 INS42 INS32 INS42 INS33 INS60 MOV60 INS60 INS21 INS25 MOV5 MOV4 INS32 UPD42 INS43 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS33 INS5 INS59 INS43 INS59 INS32 INS38 INS8 UPD42 MOV42 UPD42 MOV42 INS42 INS43 INS85 INS42 INS32 UPD42 INS42 INS42 INS32 INS42 INS42 INS40 INS40 INS42 INS42 INS34 INS32 MOV60 MOV25 INS8 UPD42 UPD40 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS40 INS40 INS9 INS42 INS42 INS32 INS21 INS42 INS42 INS7 INS42 INS32 INS42 MOV32 INS42 DEL40 DEL26 DEL32 DEL42 DEL32 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL4 DEL3 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL8 DEL61 DEL8 DEL42 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL4 DEL3 DEL32 DEL21 DEL8 DEL43 DEL42 DEL44 DEL45 DEL32 DEL27 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL42 DEL42 DEL59 DEL60 DEL42 DEL3 DEL7 DEL21
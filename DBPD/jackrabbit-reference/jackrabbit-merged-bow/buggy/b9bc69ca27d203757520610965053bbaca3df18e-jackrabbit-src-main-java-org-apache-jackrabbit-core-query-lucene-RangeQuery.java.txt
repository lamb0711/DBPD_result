JCR-638: Support lower-/upper-case functions

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@475677 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.List;
+import java.util.ArrayList;
+import java.util.Iterator;
-public class RangeQuery extends Query {
+public class RangeQuery extends Query implements TransformConstants {
+     * How the term enum is transformed before it is compared to lower and upper
+     * term.
+     */
+    private final int transform;
+
+    /**
+     * @param transform how term enums are transformed when read from the index.
-    public RangeQuery(Term lowerTerm, Term upperTerm, boolean inclusive) {
+    public RangeQuery(Term lowerTerm, Term upperTerm, boolean inclusive, int transform) {
+        this.transform = transform;
-        Query stdRangeQueryImpl
-                = new org.apache.lucene.search.RangeQuery(lowerTerm, upperTerm, inclusive);
-        try {
-            return stdRangeQueryImpl.rewrite(reader);
-        } catch (BooleanQuery.TooManyClauses e) {
-            log.debug("Too many terms to enumerate, using custom RangeQuery");
-            // failed, use own implementation
+        if (transform == TRANSFORM_NONE) {
+            Query stdRangeQueryImpl
+                    = new org.apache.lucene.search.RangeQuery(lowerTerm, upperTerm, inclusive);
+            try {
+                return stdRangeQueryImpl.rewrite(reader);
+            } catch (BooleanQuery.TooManyClauses e) {
+                log.debug("Too many terms to enumerate, using custom RangeQuery");
+                // failed, use own implementation
+                return this;
+            }
+        } else {
+            // always use our implementation when we need to transform the
+            // term enum
+            key.append('\uFFFF');
+            key.append(transform);
-            TermEnum enumerator = reader.terms(lowerTerm);
+            String testField = getField();
-            try {
-                boolean checkLower = false;
-                if (!inclusive) {
-                    // make adjustments to set to exclusive
-                    checkLower = true;
-                }
+            boolean checkLower = false;
+            if (!inclusive || transform != TRANSFORM_NONE) {
+                // make adjustments to set to exclusive
+                checkLower = true;
+            }
-                String testField = getField();
+            int propNameLength = FieldNames.getNameLength(lowerTerm.text());
+            String namePrefix = "";
+            if (propNameLength > 0) {
+                namePrefix = lowerTerm.text().substring(0, propNameLength);
+            }
+            List startTerms = new ArrayList(2);
-                TermDocs docs = reader.termDocs();
+            if (transform == TRANSFORM_NONE || lowerTerm.text().length() <= propNameLength) {
+                // use lowerTerm as is
+                startTerms.add(lowerTerm);
+            } else {
+                // first enumerate terms using lower case start character
+                StringBuffer termText = new StringBuffer(propNameLength + 1);
+                termText.append(lowerTerm.text().subSequence(0, propNameLength));
+                char startCharacter = lowerTerm.text().charAt(propNameLength);
+                termText.append(Character.toLowerCase(startCharacter));
+                startTerms.add(new Term(lowerTerm.field(), termText.toString()));
+                // second enumerate terms using upper case start character
+                termText.setCharAt(termText.length() - 1, Character.toUpperCase(startCharacter));
+                startTerms.add(new Term(lowerTerm.field(), termText.toString()));
+            }
+
+            for (Iterator it = startTerms.iterator(); it.hasNext(); ) {
+                Term startTerm = (Term) it.next();
+
+                TermEnum terms = reader.terms(startTerm);
-                    do {
-                        Term term = enumerator.term();
-                        if (term != null && term.field() == testField) {
-                            if (!checkLower || term.text().compareTo(lowerTerm.text()) > 0) {
-                                checkLower = false;
+                    TermDocs docs = reader.termDocs();
+                    try {
+                        do {
+                            Term term = terms.term();
+                            if (term != null && term.field() == testField) {
+                                if (checkLower) {
+                                    int compare = termCompare(term.text(), lowerTerm.text(), propNameLength);
+                                    if (compare > 0 || compare == 0 && inclusive) {
+                                        // do not check lower term anymore if no
+                                        // transformation is done on the term enum
+                                        checkLower = transform == TRANSFORM_NONE ? false : true;
+                                    } else {
+                                        // continue with next term
+                                        continue;
+                                    }
+                                }
-                                    int compare = upperTerm.text().compareTo(term.text());
+                                    int compare = termCompare(term.text(), upperTerm.text(), propNameLength);
-                                    // this is equal to the upper term, break out
-                                    if ((compare < 0) || (!inclusive && compare == 0)) {
-                                        break;
+                                    // this is equal to the upper term
+                                    if ((compare > 0) || (!inclusive && compare == 0)) {
+                                        // only break out if no transformation
+                                        // was done on the term from the enum
+                                        if (transform == TRANSFORM_NONE) {
+                                            break;
+                                        } else {
+                                            // because of the transformation
+                                            // it is possible that the next
+                                            // term will be included again if
+                                            // we still enumerate on the same
+                                            // property name
+                                            if (term.text().startsWith(namePrefix)) {
+                                                continue;
+                                            } else {
+                                                break;
+                                            }
+                                        }
-                                docs.seek(enumerator);
+                                docs.seek(terms);
+                            } else {
+                                break;
-                        } else {
-                            break;
-                        }
-                    } while (enumerator.next());
+                        } while(terms.next());
+                    } finally {
+                        docs.close();
+                    }
-                    docs.close();
+                    terms.close();
-            } finally {
-                enumerator.close();
+
+
+        /**
+         * Compares the <code>text</code> with the <code>other</code> String. This
+         * implementation behaves like {@link String#compareTo(Object)} but also
+         * respects the {@link RangeQuery#transform} property.
+         *
+         * @param text   the text to compare to <code>other</code>. The
+         *               transformation function is applied to this parameter before
+         *               it is compared to <code>other</code>.
+         * @param other  the other String.
+         * @param offset start comparing the two strings at <code>offset</code>.
+         * @return see {@link String#compareTo(Object)}. But also respects {@link
+         *         #transform}.
+         */
+        private int termCompare(String text, String other, int offset) {
+            OffsetCharSequence seq1 = new OffsetCharSequence(offset, text, transform);
+            OffsetCharSequence seq2 = new OffsetCharSequence(offset, other);
+            return seq1.compareTo(seq2);
+        }

INS26 INS26 INS26 INS40 INS40 INS40 INS43 INS23 INS42 INS29 INS83 INS83 INS39 INS59 INS44 INS8 INS31 INS65 INS42 INS65 INS39 INS42 INS21 INS25 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS66 INS66 INS42 INS66 INS7 INS27 MOV8 INS8 INS21 INS21 MOV60 MOV60 MOV25 INS60 INS60 INS25 INS60 INS25 INS24 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS39 INS42 INS60 INS60 INS41 INS22 INS42 INS42 INS42 INS41 INS32 INS32 INS27 INS39 INS59 INS43 INS59 INS27 INS8 INS43 INS59 INS27 INS8 INS8 INS58 INS32 MOV8 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS65 INS66 INS65 INS66 INS42 INS42 INS43 INS59 INS43 INS59 INS32 INS52 INS42 INS52 INS42 INS42 INS13 INS42 INS42 INS42 MOV38 INS27 INS42 INS32 INS42 INS42 INS45 INS42 INS34 INS21 INS42 INS42 INS14 INS27 INS27 INS21 INS60 INS21 MOV60 MOV21 INS21 INS21 INS21 INS43 INS59 INS42 INS42 INS60 INS60 INS68 INS67 INS68 INS67 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS7 INS43 INS34 INS42 INS42 INS32 INS42 INS32 INS43 INS59 INS32 INS39 INS32 INS32 INS32 INS32 INS42 INS42 INS32 INS43 INS59 MOV43 INS59 INS42 INS42 INS69 INS42 INS42 INS42 INS42 INS69 INS42 INS43 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS32 UPD42 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS27 INS32 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS11 INS42 INS32 MOV60 INS54 INS43 INS43 INS42 INS42 INS32 INS42 INS34 INS42 INS42 INS42 INS43 INS27 INS32 INS42 INS34 INS42 INS32 UPD42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 MOV43 INS32 INS32 INS32 INS34 INS42 INS42 INS42 INS43 INS32 INS32 INS43 INS32 INS42 INS42 INS42 MOV8 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS19 INS21 UPD42 MOV8 INS32 INS32 INS60 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS43 INS59 MOV27 MOV8 INS42 INS42 INS32 INS25 INS42 INS42 INS42 INS8 INS60 INS25 UPD42 INS39 INS59 INS27 INS8 INS8 INS8 INS42 INS32 INS27 INS27 MOV21 INS18 MOV32 INS25 INS42 INS32 INS32 INS42 INS42 INS34 INS27 INS42 UPD42 INS42 UPD27 INS27 MOV8 INS8 INS42 INS42 INS42 INS42 INS42 INS34 INS16 INS42 INS42 INS25 INS27 INS9 INS9 MOV32 INS8 INS8 INS42 INS42 UPD42 INS42 INS18 INS10 DEL32 DEL42 DEL38 DEL34 DEL27 DEL27 DEL9 DEL42 DEL32 DEL59 DEL60 DEL25 DEL32 DEL19 DEL8 DEL54
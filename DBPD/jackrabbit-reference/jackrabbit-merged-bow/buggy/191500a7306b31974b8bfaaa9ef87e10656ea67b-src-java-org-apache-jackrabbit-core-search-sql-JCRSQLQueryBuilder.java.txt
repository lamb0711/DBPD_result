Implement 'child axis' and 'descendant-or-self axis' for SQL queries.

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@154682 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.List;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+import java.util.Arrays;
+    /** List of PathQueryNode constraints that need to be merged */
+    private final List pathConstraints = new ArrayList();
+
-        if (pathNode.getPathSteps().length == 0) {
-            pathNode.setAbsolute(true);
+        pathNode.setAbsolute(true);
+        if (pathConstraints.size() == 0) {
+        } else {
+            try {
+                while (pathConstraints.size() > 1) {
+                    // merge path nodes
+                    MergingPathQueryNode path = null;
+                    for (Iterator it = pathConstraints.iterator(); it.hasNext();) {
+                        path = (MergingPathQueryNode) it.next();
+                        if (path.needsMerge()) {
+                            break;
+                        } else {
+                            path = null;
+                        }
+                    }
+                    if (path == null) {
+                        throw new IllegalArgumentException("Invalid combination of jcr:path clauses");
+                    } else {
+                        pathConstraints.remove(path);
+                        MergingPathQueryNode[] paths = (MergingPathQueryNode[]) pathConstraints.toArray(new MergingPathQueryNode[pathConstraints.size()]);
+                        paths = path.doMerge(paths);
+                        pathConstraints.clear();
+                        pathConstraints.addAll(Arrays.asList(paths));
+                    }
+                }
+            } catch (NoSuchElementException e) {
+                throw new IllegalArgumentException("Invalid combination of jcr:path clauses");
+            }
+            MergingPathQueryNode path = (MergingPathQueryNode) pathConstraints.get(0);
+            LocationStepQueryNode[] steps = path.getPathSteps();
+            for (int i = 0; i < steps.length; i++) {
+                LocationStepQueryNode step = new LocationStepQueryNode(pathNode, steps[i].getNameTest(), steps[i].getIncludeDescendants());
+                step.setIndex(steps[i].getIndex());
+                pathNode.addPathStep(step);
+            }
-        // attach constraint to last path step
-        LocationStepQueryNode[] steps = pathNode.getPathSteps();
-        steps[steps.length - 1].addPredicate(constraintNode);
+        if (constraintNode.getNumOperands() > 0) {
+            // attach constraint to last path step
+            LocationStepQueryNode[] steps = pathNode.getPathSteps();
+            steps[steps.length - 1].addPredicate(constraintNode);
+        }
-                    createPathQuery(((ASTLiteral) node.children[1]).getValue());
+                    createPathQuery(((ASTLiteral) node.children[1]).getValue(), parent.getType());
-        parent.addOperand(orQuery);
+        if (orQuery.getNumOperands() > 0) {
+            parent.addOperand(orQuery);
+        }
+     * @param path the path pattern
+     * @param operation the type of the parent node
-    private void createPathQuery(String path) {
-        PathQueryNode pathNode = root.getLocationNode();
+    private void createPathQuery(String path, int operation) {
+        MergingPathQueryNode pathNode = new MergingPathQueryNode(operation);
-                    // descendant '//'
-                    // FIXME this is not possible
+                    // descendant '//' -> invalid path
+                    // todo throw or ignore?
+                    // we currently do not throw and add location step for an
+                    // empty name (which is basically the root node)
+                    pathNode.addPathStep(new LocationStepQueryNode(pathNode, new QName("", ""), false));
-                // @todo how to specify descendant-or-self?
+        pathConstraints.add(pathNode);
+    /**
+     * Extends the <code>PathQueryNode</code> with merging capability. A
+     * <code>PathQueryNode</code> <code>n1</code> can be merged with another
+     * node <code>n2</code> in the following case:
+     * <p/>
+     * <code>n1</code> contains a location step at position <code>X</code> with
+     * a name test that matches any node and has the descending flag set. Where
+     * <code>X</code> &lt; number of location steps.
+     * <code>n2</code> contains no location step to match any node name and
+     * the sequence of name tests is the same as the sequence of name tests
+     * of <code>n1</code>.
+     * The merged node then contains a location step at position <code>X</code>
+     * with the name test of the location step at position <code>X+1</code> and
+     * the descending flag set.
+     * <p/>
+     * The following path patterns:<br/>
+     * <code>/foo/%/bar</code> OR <code>/foo/bar</code><br/>
+     * are merged into:<br/>
+     * <code>/foo//bar</code>.
+     * <p/>
+     * The path patterns:<br/>
+     * <code>/foo/%</code> AND NOT <code>/foo/%/%</code><br/>
+     * are merged into:<br/>
+     * <code>/foo/*</code>
+     */
+    private static class MergingPathQueryNode extends PathQueryNode {
+
+        /** The operation type of the parent node */
+        private int operation;
+
+        /**
+         * Creates a new <code>MergingPathQueryNode</code> with the operation
+         * tpye of a parent node. <code>operation</code> must be one of:
+         * {@link org.apache.jackrabbit.core.search.QueryNode#TYPE_OR},
+         * {@link org.apache.jackrabbit.core.search.QueryNode#TYPE_AND} or
+         * {@link org.apache.jackrabbit.core.search.QueryNode#TYPE_NOT}.
+         * @param operation the operation type of the parent node.
+         */
+        MergingPathQueryNode(int operation) {
+            super(null);
+            if (operation != QueryNode.TYPE_OR && operation != QueryNode.TYPE_AND && operation != QueryNode.TYPE_NOT) {
+                throw new IllegalArgumentException("operation");
+            }
+            this.operation = operation;
+        }
+
+        /**
+         * Merges this node with a node from <code>nodes</code>. If a merge
+         * is not possible an NoSuchElementException is thrown.
+         * @param nodes the nodes to try to merge with.
+         * @return the merged array containing a merged version of this node.
+         */
+        MergingPathQueryNode[] doMerge(MergingPathQueryNode[] nodes) {
+            if (operation == QueryNode.TYPE_OR) {
+                return doOrMerge(nodes);
+            } else {
+                return doAndMerge(nodes);
+            }
+        }
+
+        /**
+         * Merges two nodes into a node which selects any child nodes of a
+         * given node.
+         * <p/>
+         * Example:<br/>
+         * The path patterns:<br/>
+         * <code>/foo/%</code> AND NOT <code>/foo/%/%</code><br/>
+         * are merged into:<br/>
+         * <code>/foo/*</code>
+         *
+         * @param nodes the nodes to merge with.
+         * @return the merged nodes.
+         */
+        private MergingPathQueryNode[] doAndMerge(MergingPathQueryNode[] nodes) {
+            if (operation == QueryNode.TYPE_AND) {
+                // check if there is an node with operation OP_AND_NOT
+                MergingPathQueryNode n = null;
+                for (int i = 0; i < nodes.length; i++) {
+                    if (nodes[i].operation == QueryNode.TYPE_NOT) {
+                        n = nodes[i];
+                        nodes[i] = this;
+                    }
+                }
+                if (n == null) {
+                    throw new NoSuchElementException("Merging not possible with any node");
+                } else {
+                    return n.doAndMerge(nodes);
+                }
+            }
+            // check if this node is valid as an operand
+            if (operands.size() < 3) {
+                throw new NoSuchElementException("Merging not possible");
+            }
+            int size = operands.size();
+            LocationStepQueryNode n1 = (LocationStepQueryNode) operands.get(size - 1);
+            LocationStepQueryNode n2 = (LocationStepQueryNode) operands.get(size - 2);
+            if (n1.getNameTest() != null || n2.getNameTest() != null
+                    || !n1.getIncludeDescendants() || !n2.getIncludeDescendants()) {
+                throw new NoSuchElementException("Merging not possible");
+            }
+            // find a node to merge with
+            MergingPathQueryNode matchedNode = null;
+            for (int i = 0; i < nodes.length; i++) {
+                if (nodes[i].operands.size() == operands.size() - 1) {
+                    boolean match = true;
+                    for (int j = 0; j < operands.size() - 1 && match; j++) {
+                        LocationStepQueryNode step = (LocationStepQueryNode) operands.get(j);
+                        LocationStepQueryNode other = (LocationStepQueryNode) nodes[i].operands.get(j);
+                        match &= (step.getNameTest() == null) ? other.getNameTest() == null : step.getNameTest().equals(other.getNameTest());
+                    }
+                    if (match) {
+                        matchedNode = nodes[i];
+                        break;
+                    }
+                }
+            }
+            if (matchedNode == null) {
+                throw new NoSuchElementException("Merging not possible with any node");
+            }
+            // change descendants flag to only match child nodes
+            // that's the result of the merge.
+            ((LocationStepQueryNode) matchedNode.operands.get(matchedNode.operands.size() - 1)).setIncludeDescendants(false);
+            return nodes;
+        }
+
+        /**
+         * Merges two nodes into one node selecting a node on the
+         * descendant-or-self axis.
+         * <p/>
+         * Example:<br/>
+         * The following path patterns:<br/>
+         * <code>/foo/%/bar</code> OR <code>/foo/bar</code><br/>
+         * are merged into:<br/>
+         * <code>/foo//bar</code>.
+         *
+         * @param nodes the node to merge.
+         * @return the merged nodes.
+         */
+        private MergingPathQueryNode[] doOrMerge(MergingPathQueryNode[] nodes) {
+            // compact this
+            MergingPathQueryNode compacted = new MergingPathQueryNode(QueryNode.TYPE_OR);
+            for (Iterator it = operands.iterator(); it.hasNext();) {
+                LocationStepQueryNode step = (LocationStepQueryNode) it.next();
+                if (step.getIncludeDescendants() && step.getNameTest() == null) {
+                    // check if has next
+                    if (it.hasNext()) {
+                        LocationStepQueryNode next = (LocationStepQueryNode) it.next();
+                        next.setIncludeDescendants(true);
+                        compacted.addPathStep(next);
+                    } else {
+                        compacted.addPathStep(step);
+                    }
+                } else {
+                    compacted.addPathStep(step);
+                }
+            }
+
+            MergingPathQueryNode matchedNode = null;
+            for (int i = 0; i < nodes.length; i++) {
+                // loop over the steps and compare the names
+                if (nodes[i].operands.size() == compacted.operands.size()) {
+                    boolean match = true;
+                    Iterator compactedSteps = compacted.operands.iterator();
+                    Iterator otherSteps = nodes[i].operands.iterator();
+                    while (match && compactedSteps.hasNext()) {
+                        LocationStepQueryNode n1 = (LocationStepQueryNode) compactedSteps.next();
+                        LocationStepQueryNode n2 = (LocationStepQueryNode) otherSteps.next();
+                        match &= (n1.getNameTest() == null) ? n2.getNameTest() == null : n1.getNameTest().equals(n2.getNameTest());
+                    }
+                    if (match) {
+                        matchedNode = nodes[i];
+                        break;
+                    }
+                }
+            }
+            if (matchedNode == null) {
+                throw new NoSuchElementException("Merging not possible with any node.");
+            }
+            // construct new list
+            List mergedList = new ArrayList(Arrays.asList(nodes));
+            mergedList.remove(matchedNode);
+            mergedList.add(compacted);
+            return (MergingPathQueryNode[]) mergedList.toArray(new MergingPathQueryNode[mergedList.size()]);
+        }
+
+        /**
+         * Returns <code>true</code> if this node needs merging; <code>false</code>
+         * otherwise.
+         * @return <code>true</code> if this node needs merging; <code>false</code>
+         * otherwise.
+         */
+        boolean needsMerge() {
+            for (Iterator it = operands.iterator(); it.hasNext();) {
+                LocationStepQueryNode step = (LocationStepQueryNode) it.next();
+                if (step.getIncludeDescendants() && step.getNameTest() == null) {
+                    return true;
+                }
+            }
+            return false;
+        }
+    }

INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS23 INS55 INS29 INS83 INS83 INS43 INS59 INS44 INS29 INS83 INS83 INS42 INS43 INS23 INS31 INS31 INS31 INS31 INS31 INS65 INS42 INS42 INS14 MOV21 INS25 INS25 INS65 INS65 INS39 INS42 INS21 INS65 INS42 INS29 INS83 INS39 INS59 INS29 INS42 INS44 INS8 INS29 INS5 INS42 INS44 INS8 INS29 INS83 INS5 INS42 INS44 INS8 INS29 INS83 INS5 INS42 INS44 INS8 INS29 INS39 INS42 INS8 INS66 INS43 INS27 INS8 INS27 INS8 INS27 INS8 INS42 INS66 INS42 INS66 UPD43 INS32 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS42 INS65 INS65 INS39 INS42 INS46 INS25 INS21 INS65 INS65 INS65 INS43 INS85 INS5 INS42 INS25 INS65 INS65 INS65 INS43 INS85 INS5 INS42 INS25 INS25 INS60 INS60 INS60 INS25 INS60 INS24 INS25 INS21 INS41 INS65 INS65 INS65 INS43 INS85 INS5 INS42 INS60 INS24 INS60 INS24 INS25 INS60 INS21 INS21 INS41 INS65 INS65 INS24 INS41 INS42 INS32 INS34 INS54 INS60 INS60 INS24 INS32 INS34 MOV60 MOV21 INS32 INS34 MOV21 UPD42 INS14 INS42 INS42 INS42 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS42 INS66 INS33 INS27 INS8 INS7 INS66 INS66 INS42 INS66 INS66 INS42 INS43 INS85 INS27 INS8 INS8 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS43 INS85 INS27 INS8 INS27 INS8 INS39 INS59 INS43 INS59 INS43 INS59 INS27 INS8 INS43 INS59 INS58 INS27 INS37 INS8 INS27 INS8 INS32 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS43 INS85 INS43 INS59 INS58 INS32 INS8 INS43 INS59 INS58 INS27 INS37 INS8 INS27 INS8 INS43 INS59 INS32 INS32 INS11 INS66 INS66 INS66 INS66 INS58 INS32 INS8 INS9 INS42 INS42 INS8 INS12 INS43 INS59 INS5 INS59 INS58 INS27 INS37 INS8 INS42 INS42 INS42 INS42 INS43 INS42 INS67 INS67 INS67 INS27 INS27 INS53 INS22 INS42 INS42 INS42 INS40 INS41 INS41 INS42 INS42 INS40 INS60 INS24 INS25 INS32 INS34 INS53 INS42 INS32 INS42 INS42 INS11 INS42 INS42 INS11 INS27 INS38 INS53 INS42 INS42 INS33 INS39 INS59 INS42 INS40 INS42 INS25 INS42 INS33 INS53 INS36 INS42 INS9 INS42 INS42 INS42 INS14 INS43 INS59 INS42 INS42 INS60 INS25 INS42 INS42 INS33 INS39 INS59 INS42 INS40 INS42 INS25 INS42 INS33 INS53 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS5 INS32 INS43 INS59 INS42 INS42 INS60 INS25 INS61 INS44 INS8 INS42 INS42 INS11 INS43 INS85 INS42 INS32 INS39 INS59 INS42 INS40 INS42 INS60 INS21 INS21 INS42 INS40 INS42 INS40 INS42 INS40 INS42 INS27 INS27 INS42 INS40 INS14 INS52 INS42 INS32 INS32 INS43 INS59 INS58 INS27 INS37 INS8 INS27 INS8 INS8 INS42 INS42 INS14 INS42 INS42 INS43 INS32 INS43 INS32 INS27 INS38 INS32 INS14 INS42 INS34 INS27 INS8 INS14 INS11 INS43 INS40 INS42 INS42 INS32 INS43 INS59 INS27 INS8 INS8 INS42 INS34 INS27 INS8 INS14 INS43 INS32 INS43 INS85 INS42 INS42 INS3 INS42 INS42 INS32 INS43 INS59 INS27 INS8 INS27 INS8 INS43 INS42 INS53 INS43 INS32 INS42 UPD42 MOV42 MOV42 INS42 INS34 INS43 INS59 INS32 INS32 INS42 INS40 INS42 INS40 INS43 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS39 INS59 INS42 INS40 INS42 INS25 INS42 INS33 INS53 INS41 INS43 INS45 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS27 INS27 INS27 INS32 INS42 INS42 INS43 INS45 INS32 INS27 INS60 INS24 INS25 INS43 INS45 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS11 INS32 INS27 INS25 INS21 INS32 INS32 INS60 INS60 INS60 INS61 INS25 INS43 INS45 INS42 INS42 INS42 INS42 INS42 INS5 INS32 INS42 INS42 INS42 INS42 INS11 INS32 INS27 INS41 INS32 INS34 INS60 INS24 INS25 INS42 INS14 INS42 INS42 INS42 INS34 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS42 INS21 INS42 INS42 INS34 INS27 INS8 INS14 INS32 INS42 INS42 INS34 INS42 INS34 INS32 INS33 INS32 INS33 INS42 INS42 INS42 INS22 INS42 INS32 INS34 INS39 INS59 INS58 INS27 INS37 INS8 INS42 INS8 INS42 INS42 INS40 INS42 INS27 INS43 INS32 INS42 INS42 INS32 INS33 INS32 INS8 INS8 INS32 INS22 INS42 INS40 INS42 INS39 INS59 INS43 INS59 INS43 INS59 INS27 INS8 INS42 INS8 INS42 INS43 INS85 INS42 INS42 INS43 INS32 INS42 INS42 INS32 INS33 INS9 INS42 INS42 INS43 INS59 INS58 INS32 INS8 INS27 INS8 INS8 INS43 INS45 INS43 INS42 INS32 INS32 INS2 INS42 INS32 INS22 INS40 INS21 INS21 INS43 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS2 INS42 INS42 INS42 INS42 INS9 INS39 INS59 INS27 INS42 INS42 INS60 INS60 INS21 INS21 INS10 INS32 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS60 INS21 INS21 INS21 INS42 INS42 INS42 INS2 INS42 INS42 INS9 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS60 INS60 INS21 INS21 INS10 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS43 INS59 INS42 INS42 INS21 INS25 INS42 INS33 INS53 INS21 INS60 INS21 INS21 INS21 INS42 INS42 INS2 INS42 INS2 INS42 INS42 INS42 INS32 INS42 INS42 INS14 INS2 INS42 INS7 INS7 INS42 INS42 INS42 INS42 INS34 INS42 INS27 INS43 INS59 INS43 INS59 INS7 INS7 INS40 INS42 INS43 INS59 INS32 INS32 INS32 INS42 INS42 INS40 INS42 INS22 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS7 INS7 INS42 INS42 INS32 INS7 INS32 INS8 INS8 INS14 INS32 INS5 INS59 INS7 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS14 INS9 INS42 INS42 INS42 INS2 INS2 INS52 INS32 INS34 INS42 INS42 INS11 INS42 INS42 INS11 INS42 INS16 INS42 INS2 INS42 INS42 INS11 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS2 INS42 INS42 INS42 INS11 INS42 INS42 INS11 INS42 INS16 INS42 INS2 INS42 INS42 INS42 INS11 INS42 INS42 INS10 INS21 INS43 INS45 INS42 INS42 INS42 INS43 INS85 INS42 INS11 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS43 INS45 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS32 INS43 INS32 INS36 INS27 INS32 INS42 INS42 INS43 INS32 INS42 INS42 INS43 INS32 INS43 INS32 INS36 INS27 INS32 INS42 INS42 INS43 INS32 INS7 INS42 INS42 INS5 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS22 INS42 INS42 INS27 INS32 INS33 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS32 INS33 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS33 INS43 INS85 INS42 INS42 INS3 INS2 INS42 INS32 INS33 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS33 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS5 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS85 INS42 INS42 INS42 DEL32 DEL42 DEL22 DEL34 DEL27 DEL42 DEL42 DEL32
- implemented observation events for Node.orderBefore()
- added test cases for Node.orderBefore()

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@158604 13f79535-47bb-0310-9956-ffa450edef68

+    /**
+     * Returns a list of child node entries, that exist both in <i>this</i> node
+     * state and in the overlayed node state, but have been reordered.
+     * <p/>
+     * The list may include only the minimal set of nodes that have been
+     * reordered. That is, even though a certain number of nodes have changed
+     * their context position, the list may include less that this number of
+     * nodes.
+     * <p/>
+     * Example:<br/>
+     * Initial state:
+     * <pre>
+     *  + node1
+     *  + node2
+     *  + node3
+     * </pre>
+     * After reorder:
+     * <pre>
+     *  + node2
+     *  + node3
+     *  + node1
+     * </pre>
+     * All nodes have changed their context position. The returned list however
+     * may only return that <code>node1</code> has been reordered (from the
+     * first position to the end).
+     *
+     * @return list of reordered child node enties.
+     */
+    public synchronized List getReorderedChildNodeEntries() {
+        if (!hasOverlayedState()) {
+            return Collections.EMPTY_LIST;
+        }
+
+        List others = new ArrayList();
+        others.addAll(((NodeState) getOverlayedState()).childNodeEntries.entries);
+
+        List ours = new ArrayList();
+        ours.addAll(childNodeEntries.entries);
+
+        // do a lazy init
+        List reordered = null;
+        // remove added nodes from ours entries
+        ours.removeAll(getAddedChildNodeEntries());
+        // remove all removed nodes from others entries
+        others.removeAll(getRemovedChildNodeEntries());
+        // both entry list now contain the set of nodes that have not
+        // been removed or added. but they may have changed their position
+        for (int i = 0; i < ours.size();) {
+            ChildNodeEntry entry = (ChildNodeEntry) ours.get(i);
+            ChildNodeEntry other = (ChildNodeEntry) others.get(i);
+            if (!entry.getUUID().equals(other.getUUID())) {
+                if (reordered == null) {
+                    reordered = new ArrayList();
+                }
+                // Note, that this check will not necessarily find the
+                // minimal reorder operations required to convert the overlayed
+                // child node entries into the current.
+
+                // is there a next entry
+                if (i + 1 < ours.size()) {
+                    // if entry is the next in the other list, then probably
+                    // the other entry at position <code>i</code> was reordered
+                    if (entry.getUUID().equals(((ChildNodeEntry) others.get(i + 1)).getUUID())) {
+                        // scan for the uuid of the other entry in our list
+                        for (int j = i; j < ours.size(); j++) {
+                            if (((ChildNodeEntry) ours.get(j)).getUUID().equals(other.uuid)) {
+                                // found it
+                                entry = (ChildNodeEntry) ours.get(j);
+                                break;
+                            }
+                        }
+                    }
+                }
+
+                reordered.add(entry);
+                // remove the entry from both lists
+                // entries > i are already cleaned
+                for (int j = i; j < ours.size(); j++) {
+                    if (((ChildNodeEntry) ours.get(j)).getUUID().equals(entry.getUUID())) {
+                        ours.remove(j);
+                    }
+                }
+                for (int j = i; j < ours.size(); j++) {
+                    if (((ChildNodeEntry) others.get(j)).getUUID().equals(entry.getUUID())) {
+                        others.remove(j);
+                    }
+                }
+                // if a reorder has been detected index <code>i</code> is not
+                // incremented, because entries will be shifted when the
+                // reordered entry is removed.
+            } else {
+                // no reorder, move to next child entry
+                i++;
+            }
+        }
+        if (reordered == null) {
+            return Collections.EMPTY_LIST;
+        } else {
+            return reordered;
+        }
+    }
+

INS31 INS29 INS83 INS83 INS43 INS42 INS8 INS65 INS65 INS42 INS25 INS60 INS21 INS60 INS21 INS60 INS21 INS21 INS24 INS25 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS38 INS8 INS43 INS59 INS32 INS43 INS59 INS32 INS43 INS59 INS32 INS32 INS58 INS27 INS8 INS27 INS8 INS8 INS32 INS41 INS42 INS42 INS14 INS42 INS42 INS22 INS42 INS42 INS14 INS42 INS42 INS40 INS42 INS42 INS33 INS42 INS42 INS32 INS42 INS42 INS32 INS39 INS59 INS42 INS32 INS60 INS60 INS25 INS42 INS33 INS41 INS41 INS42 INS40 INS43 INS22 INS42 INS43 INS42 INS42 INS42 INS34 INS42 INS42 INS43 INS59 INS43 INS59 INS38 INS8 INS8 INS40 INS42 INS42 INS36 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS11 INS32 INS25 INS25 INS21 INS24 INS24 INS21 INS11 INS43 INS32 INS43 INS32 INS32 INS42 INS32 INS27 INS8 INS27 INS8 INS32 INS58 INS27 INS37 INS8 INS58 INS27 INS37 INS8 INS37 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS21 INS27 INS32 INS25 INS42 INS42 INS42 INS39 INS59 INS42 INS32 INS42 INS25 INS39 INS59 INS42 INS32 INS42 INS25 INS42 INS42 INS42 INS7 INS42 INS34 INS42 INS42 INS32 INS8 INS42 INS42 INS42 INS42 INS32 INS8 INS42 INS42 INS42 INS42 INS32 INS8 INS42 INS14 INS32 INS42 INS32 INS24 INS32 INS42 INS32 INS21 INS32 INS42 INS32 INS21 INS43 INS42 INS42 INS36 INS42 INS58 INS27 INS37 INS8 INS36 INS42 INS42 INS42 INS32 INS36 INS42 INS42 INS42 INS32 INS42 INS11 INS39 INS59 INS42 INS32 INS42 INS25 INS11 INS42 INS42 INS42 INS11 INS42 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS42 INS32 INS8 INS43 INS32 INS43 INS32 INS42 INS42 INS42 INS27 INS32 INS42 INS40 INS21 INS10 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS36 INS42 INS7 INS11 INS42 INS11 INS43 INS32 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42
Make versioning transactional
- Added specialized XAVersion and XAVersionHistory objects that refresh their internal state when needed
- Defined new observation interface in order to have VersionManagerImpl use standard event dispatching
  instead of writing its own
- Added test cases verifying isolation of versioning operations in transactions


git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@368026 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.PropertyImpl;
-import org.apache.jackrabbit.core.nodetype.NodeTypeImpl;
-import org.apache.jackrabbit.core.observation.EventState;
+import org.apache.jackrabbit.core.observation.EventStateCollectionFactory;
+import org.apache.jackrabbit.core.observation.EventStateCollection;
-import org.apache.jackrabbit.name.Path;
-import org.apache.jackrabbit.uuid.UUID;
-import javax.jcr.NodeIterator;
-import javax.jcr.PropertyIterator;
-import javax.jcr.Value;
-import java.util.LinkedList;
+import java.util.Collection;
-public class VersionManagerImpl implements VersionManager {
+public class VersionManagerImpl extends AbstractVersionManager
+        implements EventStateCollectionFactory {
-     * the state manager for the version storage
+     * the shared state manager for the version storage
-    private LocalItemStateManager stateMgr;
+    private SharedItemStateManager sharedStateMgr;
-     * the persistent root node of the version histories
-     */
-    private final NodeStateEx historyRoot;
-
-    /**
-    //private ReferenceMap items = new ReferenceMap(ReferenceMap.HARD, ReferenceMap.WEAK);
+    private ReferenceMap versionItems = new ReferenceMap(ReferenceMap.HARD, ReferenceMap.WEAK);
-     * Map of returned items. this is kept for invalidating
+     * Session to be used when creating observation events.
-    private ReferenceMap versionItems = new ReferenceMap(ReferenceMap.HARD, ReferenceMap.WEAK);
+    private transient SessionImpl eventSource;
-            SharedItemStateManager sharedStateMgr =
+            sharedStateMgr =
-            stateMgr = new LocalItemStateManager(sharedStateMgr, null);
+            stateMgr = new LocalItemStateManager(sharedStateMgr, this);
-     * Close this version manager. After having closed a persistence
-     * manager, further operations on this object are treated as illegal
-     * and throw
-     *
-     * @throws Exception if an error occurs
+     * {@inheritDoc}
-     * Creates a new version history. This action is needed either when creating
-     * a new 'mix:versionable' node or when adding the 'mix:versionalbe' mixin
-     * to a node.
-     *
-     * @param node
-     * @return
-     * @throws javax.jcr.RepositoryException
+     * {@inheritDoc}
+     * <p/>
+     * This method needs to be synchronized since it sets the event source
+     * to be used when creating the events to be dispatched later on.
-    public VersionHistory createVersionHistory(Session session, NodeState node)
+    public synchronized VersionHistory createVersionHistory(Session session,
+                                                            NodeState node)
-        List created = new LinkedList();
-        InternalVersionHistory history = createVersionHistory(created, node);
+        eventSource = (SessionImpl) session;
+
+        InternalVersionHistory history = createVersionHistory(node);
-        VersionHistoryImpl vh = (VersionHistoryImpl) session.getNodeByUUID(history.getId());
-
-        // generate observation events
-        List events = new ArrayList();
-        Iterator iter = created.iterator();
-        while (iter.hasNext()) {
-            String uuid = (String) iter.next();
-            NodeImpl child = (NodeImpl) ((SessionImpl) session).getItemManager().getItem(new NodeId(uuid));
-            generateAddedEvents(events, (NodeImpl) child.getParent(), child, false);
-        }
-        obsMgr.dispatch(events, (SessionImpl) session);
-        return vh;
+        return (VersionHistory) session.getNodeByUUID(history.getId());
-    public VersionHistory getVersionHistory(Session session, NodeState node)
-            throws RepositoryException {
-
-        String vhId = getVersionHistoryId(node);
-        if (vhId == null) {
-            return null;
-        }
-        return (VersionHistoryImpl) session.getNodeByUUID(vhId);
-    }
-
-    /**
-     * Creates a new Version History.
-     *
-     * @param created a list for adding the uuids of the newly created nodes
-     * @param node the node for which the version history is to be initialized
-     * @return the newly created version history.
-     * @throws RepositoryException
-     */
-    private InternalVersionHistory createVersionHistory(List created, NodeState node)
-            throws RepositoryException {
-
-        try {
-            stateMgr.edit();
-        } catch (IllegalStateException e) {
-            throw new RepositoryException("Unable to start edit operation", e);
-        }
-
-        boolean succeeded = false;
-
-        try {
-            // create deep path
-            String uuid = node.getUUID();
-            NodeStateEx root = historyRoot;
-            for (int i = 0; i < 3; i++) {
-                QName name = new QName(QName.NS_DEFAULT_URI, uuid.substring(i * 2, i * 2 + 2));
-                if (!root.hasNode(name)) {
-                    NodeStateEx n = root.addNode(name, QName.REP_VERSIONSTORAGE, null, false);
-                    created.add(n.getUUID());
-                    root.store();
-                }
-                root = root.getNode(name, 1);
-            }
-            QName historyNodeName = new QName(QName.NS_DEFAULT_URI, uuid);
-            if (root.hasNode(historyNodeName)) {
-                // already exists
-                return null;
-            }
-
-            // create new history node in the persistent state
-            InternalVersionHistoryImpl hist = InternalVersionHistoryImpl.create(this, root, UUID.randomUUID().toString(), historyNodeName, node, created);
-
-            // end update
-            stateMgr.update();
-            succeeded = true;
-
-            log.info("Created new version history " + hist.getId() + " for " + node + ".");
-            return hist;
-
-        } catch (ItemStateException e) {
-            throw new RepositoryException(e);
-        } finally {
-            if (!succeeded) {
-                // update operation failed, cancel all modifications
-                stateMgr.cancel();
-            }
-        }
-    }
-
-    /**
-     * Returns the id of the version history associated with the given node
-     * or <code>null</code> if that node doesn't have a version history.
-     *
-     * @param node the node whose version history's id is to be returned.
-     * @return the the id of the version history associated with the given node
-     *         or <code>null</code> if that node doesn't have a version history.
-     * @throws RepositoryException if an error occurs
-     */
-    private String getVersionHistoryId(NodeState node)
-            throws RepositoryException {
-
-        // build and traverse path
-        String uuid = node.getUUID();
-        NodeStateEx n = historyRoot;
-        for (int i = 0; i < 3; i++) {
-            QName name = new QName(QName.NS_DEFAULT_URI, uuid.substring(i * 2, i * 2 + 2));
-            if (!n.hasNode(name)) {
-                return null;
-            }
-            n = n.getNode(name, 1);
-        }
-        QName historyNodeName = new QName(QName.NS_DEFAULT_URI, uuid);
-        if (!n.hasNode(historyNodeName)) {
-            return null;
-        }
-        return n.getNode(historyNodeName, 1).getUUID();
-    }
-
-    /**
-     * Checks if the version history with the given id exists
-     *
-     * @param id
-     * @return
-     */
-    public boolean hasVersionHistory(String id) {
-        // todo: probably need to check if this item is really a history
-        return hasItem(id);
-    }
-
-    /**
-     * Returns the version history with the given id
-     *
-     * @param id
-     * @return
-     * @throws RepositoryException
-     */
-    public InternalVersionHistory getVersionHistory(String id) throws RepositoryException {
-        return (InternalVersionHistory) getItem(id);
-    }
-
-    /**
-     * Checks if the version with the given id exists
-     *
-     * @param id
-     * @return
-     */
-    public boolean hasVersion(String id) {
-        // todo: probably need to check if this item is really a version
-        return hasItem(id);
-    }
-
-    /**
-     * Returns the version with the given id
-     *
-     * @param id
-     * @return
-     * @throws RepositoryException
-     */
-    public InternalVersion getVersion(String id) throws RepositoryException {
-        return (InternalVersion) getItem(id);
-    }
-
-    /**
-     * checks, if the node with the given id exists
-     *
-     * @param id
-     * @return
-     */
-     * Returns the item with the given persistent id
-     *
-     * @param uuid
-     * @return
-     * @throws RepositoryException
+     * {@inheritDoc}
-    synchronized InternalVersionItem getItem(String uuid) throws RepositoryException {
+    protected synchronized InternalVersionItem getItem(String uuid)
+            throws RepositoryException {
+
-            InternalVersionItem item = (InternalVersionItem) versionItems.get(id);
+            InternalVersionItem item = (InternalVersionItem) versionItems.get(uuid);
-                    versionItems.put(id, item);
+                    versionItems.put(uuid, item);
-     * invokes the checkin() on the persistent version manager and remaps the
-     * newly created version objects.
-     *
-     * @param node
-     * @return
-     * @throws RepositoryException
+     * {@inheritDoc}
+     * <p/>
+     * This method needs to be synchronized since it sets the event source
+     * to be used when creating the events to be dispatched later on.
-    public Version checkin(NodeImpl node) throws RepositoryException {
-        SessionImpl session = (SessionImpl) node.getSession();
-        InternalVersion version = internalCheckin(node);
+    public synchronized Version checkin(NodeImpl node) throws RepositoryException {
+        eventSource = (SessionImpl) node.getSession();
-        VersionImpl v = (VersionImpl) session.getNodeByUUID(version.getId());
+        String histUUID = node.getProperty(QName.JCR_VERSIONHISTORY).getString();
+        InternalVersion version = checkin(
+                (InternalVersionHistoryImpl) getVersionHistory(histUUID), node);
-        // generate observation events
-        List events = new ArrayList();
+        AbstractVersion v = (AbstractVersion) eventSource.getNodeByUUID(version.getId());
-        generateAddedEvents(events, (NodeImpl) v.getParent(), v, true);
-
-        // invalidate predecessors successor property
+        // invalidate predecessors successor properties
-        for (int i=0; i<preds.length; i++) {
+        for (int i = 0; i < preds.length; i++) {
-        obsMgr.dispatch(events, session);
-
-     * Checks in a node
-     *
-     * @param node
-     * @return
-     * @throws RepositoryException
-     * @see javax.jcr.Node#checkin()
+     * {@inheritDoc}
+     * <p/>
+     * This method needs to be synchronized since it sets the event source
+     * to be used when creating the events to be dispatched later on.
-    private synchronized InternalVersion internalCheckin(NodeImpl node) throws RepositoryException {
-        // assuming node is versionable and checkout (check in nodeimpl)
-        // To create a new version of a versionable node N, the client calls N.checkin.
-        // This causes the following series of events:
-        String histUUID = node.getProperty(QName.JCR_VERSIONHISTORY).getString();
-        InternalVersionHistoryImpl history = (InternalVersionHistoryImpl) getVersionHistory(histUUID);
-
-        // 0. resolve the predecessors
-        Value[] values = node.getProperty(QName.JCR_PREDECESSORS).getValues();
-        InternalVersion[] preds = new InternalVersion[values.length];
-        for (int i = 0; i < values.length; i++) {
-            preds[i] = history.getVersion(values[i].getString());
-        }
-
-        // 0.1 search a predecessor, suitable for generating the new name
-        String versionName = null;
-        int maxDots = Integer.MAX_VALUE;
-        for (int i = 0; i < preds.length; i++) {
-            // take the first pred. without a successor
-            if (preds[i].getSuccessors().length == 0) {
-                versionName = preds[i].getName().getLocalName(); //assuming no namespaces in version names
-                // need to count the dots
-                int pos = -1;
-                int numDots = 0;
-                while (versionName.indexOf('.', pos + 1) >= 0) {
-                    pos = versionName.indexOf('.', pos + 1);
-                    numDots++;
-                }
-                if (numDots < maxDots) {
-                    maxDots = numDots;
-                    if (pos < 0) {
-                        versionName = "1.0";
-                    } else {
-                        versionName = versionName.substring(0, pos + 1)
-                                + (Integer.parseInt(versionName.substring(pos + 1)) + 1);
-                    }
-                }
-                break;
-            }
-        }
-        // if no empty found, generate new name
-        if (versionName == null) {
-            versionName = preds[0].getName().getLocalName();
-            do {
-                versionName += ".1";
-            } while (history.hasVersion(new QName("", versionName)));
-        }
-
-        try {
-            stateMgr.edit();
-        } catch (IllegalStateException e) {
-            throw new RepositoryException("Unable to start edit operation.");
-        }
-
-        boolean succeeded = false;
-
-        try {
-            InternalVersionImpl v = history.checkin(new QName("", versionName), node);
-            stateMgr.update();
-            succeeded = true;
-
-            return v;
-        } catch (ItemStateException e) {
-            throw new RepositoryException(e);
-        } finally {
-            if (!succeeded) {
-                // update operation failed, cancel all modifications
-                stateMgr.cancel();
-            }
-        }
-    }
-
-
-    /**
-     * Removes the specified version from the history
-     *
-     * @param history the version history from where to remove the version.
-     * @param name the name of the version to remove.
-     * @throws VersionException if the version <code>history</code> does
-     *  not have a version with <code>name</code>.
-     * @throws RepositoryException if any other error occurs.
-     */
-    public void removeVersion(VersionHistory history, QName name)
+    public synchronized void removeVersion(VersionHistory history, QName name)
-        if (!((VersionHistoryImpl) history).hasNode(name)) {
+
+        AbstractVersionHistory historyImpl = (AbstractVersionHistory) history;
+        if (!historyImpl.hasNode(name)) {
-        // generate observation events
-        SessionImpl session = (SessionImpl) history.getSession();
-        VersionImpl version = (VersionImpl) ((VersionHistoryImpl) history).getNode(name);
-        List events = new ArrayList();
-        generateRemovedEvents(events, (NodeImpl) history, version, true);
+        eventSource = (SessionImpl) history.getSession();
+
+        // save away predecessors before removing version
+        AbstractVersion version = (AbstractVersion) historyImpl.getNode(name);
+        InternalVersion preds[] = version.getInternalVersion().getPredecessors();
-                ((VersionHistoryImpl) history).getInternalVersionHistory();
-
-        try {
-            stateMgr.edit();
-        } catch (IllegalStateException e) {
-            throw new VersionException("Unable to start edit operation", e);
-        }
-        boolean succeeded = false;
-        try {
-            vh.removeVersion(name);
-            stateMgr.update();
-            succeeded = true;
-        } catch (ItemStateException e) {
-            log.error("Error while storing: " + e.toString());
-        } finally {
-            if (!succeeded) {
-                // update operation failed, cancel all modifications
-                stateMgr.cancel();
-            }
-        }
+                historyImpl.getInternalVersionHistory();
+        removeVersion(vh, name);
-        InternalVersion preds[] = version.getInternalVersion().getPredecessors();
-        for (int i=0; i<preds.length; i++) {
+        for (int i = 0; i < preds.length; i++) {
-        obsMgr.dispatch(events, session);
+     * <p/>
+     * This method needs to be synchronized since it sets the event source
+     * to be used when creating the events to be dispatched later on.
-    public Version setVersionLabel(VersionHistory history, QName version,
-                                   QName label, boolean move)
+    public synchronized Version setVersionLabel(VersionHistory history,
+                                                QName version, QName label,
+                                                boolean move)
-        SessionImpl session = (SessionImpl) history.getSession();
+
+        AbstractVersionHistory historyImpl = (AbstractVersionHistory) history;
+        eventSource = (SessionImpl) history.getSession();
-                ((VersionHistoryImpl) history).getInternalVersionHistory();
-        NodeImpl labelNode = ((VersionHistoryImpl) history).getNode(QName.JCR_VERSIONLABELS);
-
-        try {
-            stateMgr.edit();
-        } catch (IllegalStateException e) {
-            throw new VersionException("Unable to start edit operation", e);
-        }
-        InternalVersion v = null;
-        boolean success = false;
-        try {
-            v = vh.setVersionLabel(version, label, move);
-            stateMgr.update();
-            success = true;
-        } catch(ItemStateException e) {
-            log.error("Error while storing: " + e.toString());
-        } finally {
-            if (!success) {
-                // update operation failed, cancel all modifications
-                stateMgr.cancel();
-            }
-        }
-
-        // collect observation events
-        List events = new ArrayList();
-        if (version == null && v != null) {
-            // label removed
-            events.add(EventState.propertyRemoved(
-                    labelNode.internalGetUUID(),
-                    labelNode.getPrimaryPath(),
-                    Path.PathElement.fromString(label.toString()),
-                    (NodeTypeImpl) labelNode.getPrimaryNodeType(),
-                    labelNode.getMixinTypeNames(),
-                    labelNode.getSession()
-            ));
-        } else if (v == null) {
-            // label added
-            events.add(EventState.propertyAdded(
-                    labelNode.internalGetUUID(),
-                    labelNode.getPrimaryPath(),
-                    Path.PathElement.fromString(label.toString()),
-                    (NodeTypeImpl) labelNode.getPrimaryNodeType(),
-                    labelNode.getMixinTypeNames(),
-                    labelNode.getSession()
-            ));
-        } else {
-            // label modified
-            events.add(EventState.propertyChanged(
-                    labelNode.internalGetUUID(),
-                    labelNode.getPrimaryPath(),
-                    Path.PathElement.fromString(label.toString()),
-                    (NodeTypeImpl) labelNode.getPrimaryNodeType(),
-                    labelNode.getMixinTypeNames(),
-                    labelNode.getSession()
-            ));
-        }
-        obsMgr.dispatch(events, session);
+                historyImpl.getInternalVersionHistory();
+        InternalVersion v = setVersionLabel(vh, version, label, move);
-            return (VersionImpl) session.getNodeByUUID(v.getId());
+            return (Version) eventSource.getNodeByUUID(v.getId());
-     * Adds a subtree of itemstates as 'added' to a list of events
-     *
-     * @param events
-     * @param parent
-     * @param node
-     * @throws RepositoryException
+     * Invoked by some external source to indicate that some items in the
+     * versions tree were updated. Version manager should flush its own
+     * caches.
+     * @param items items updated
-    private void generateAddedEvents(List events, NodeImpl parent, NodeImpl node,
-                                     boolean recursive)
-            throws RepositoryException {
-
-        events.add(EventState.childNodeAdded(
-                parent.internalGetUUID(),
-                parent.getPrimaryPath(),
-                node.internalGetUUID(),
-                node.getPrimaryPath().getNameElement(),
-                (NodeTypeImpl) parent.getPrimaryNodeType(),
-                parent.getMixinTypeNames(),
-                node.getSession()
-        ));
-
-        PropertyIterator iter = node.getProperties();
+    public void itemsUpdated(Collection items) {
+        Iterator iter = items.iterator();
-            PropertyImpl prop = (PropertyImpl) iter.nextProperty();
-            events.add(EventState.propertyAdded(
-                    node.internalGetUUID(),
-                    node.getPrimaryPath(),
-                    prop.getPrimaryPath().getNameElement(),
-                    (NodeTypeImpl) node.getPrimaryNodeType(),
-                    node.getMixinTypeNames(),
-                    node.getSession()
-            ));
-        }
-        if (recursive) {
-            NodeIterator niter = node.getNodes();
-            while (niter.hasNext()) {
-                NodeImpl n = (NodeImpl) niter.nextNode();
-                generateAddedEvents(events, node, n, true);
-            }
+            itemUpdated((InternalVersionItem) iter.next());
-     * Adds a subtree of itemstates as 'removed' to a list of events
-     *
-     * @param events
-     * @param parent
-     * @param node
-     * @throws RepositoryException
+     * Update internal version item. Version histories are reloaded if possible.
+     * Matching items are removed from the cache.
+     * @param item item updated
-    private void generateRemovedEvents(List events, NodeImpl parent,
-                                       NodeImpl node, boolean recursive)
-            throws RepositoryException {
-
-        events.add(EventState.childNodeRemoved(
-                parent.internalGetUUID(),
-                parent.getPrimaryPath(),
-                node.internalGetUUID(),
-                node.getPrimaryPath().getNameElement(),
-                (NodeTypeImpl) parent.getPrimaryNodeType(),
-                parent.getMixinTypeNames(),
-                node.getSession()
-        ));
-        if (recursive) {
-            NodeIterator niter = node.getNodes();
-            while (niter.hasNext()) {
-                NodeImpl n = (NodeImpl) niter.nextNode();
-                generateRemovedEvents(events, node, n, true);
+    private void itemUpdated(InternalVersionItem item) {
+        InternalVersionItem cached = (InternalVersionItem) versionItems.remove(item.getId());
+        if (cached != null) {
+            if (cached instanceof InternalVersionHistoryImpl) {
+                InternalVersionHistoryImpl vh = (InternalVersionHistoryImpl) cached;
+                try {
+                    vh.reload();
+                    versionItems.put(vh.getId(), vh);
+                } catch (RepositoryException e) {
+                    log.warn("Unable to update version history: " + e.toString());
+                }
-    public List getItemReferences(InternalVersionItem item) {
+    protected List getItemReferences(InternalVersionItem item) {
+    /**
+     * Return the shared item state manager.
+     */
+    SharedItemStateManager getSharedStateMgr() {
+        return sharedStateMgr;
+    }
+
+    //------------------------------------------< EventStateCollectionFactory >
+
+    /**
+     * {@inheritDoc}
+     * <p/>
+     * This object uses one instance of a <code>LocalItemStateManager</code>
+     * to update data on behalf of many sessions. In order to maintain the
+     * association between update operation and session who actually invoked
+     * the update, an internal event source is used.
+     */
+    public synchronized EventStateCollection createEventStateCollection()
+            throws RepositoryException {
+
+        if (eventSource == null) {
+            throw new RepositoryException("Unknown event source.");
+        }
+        return obsMgr.createEventStateCollection(eventSource);
+    }
+
-            super(persistMgr, rootNodeUUID, ntReg);
+            super(persistMgr, rootNodeUUID, ntReg, false);

MOV26 MOV23 MOV31 MOV31 MOV31 MOV31 UPD40 UPD40 UPD40 UPD43 INS43 INS31 INS31 UPD42 INS42 UPD43 UPD83 MOV43 INS83 MOV29 MOV29 INS83 INS83 UPD83 INS83 INS39 INS42 MOV44 MOV44 MOV43 MOV43 INS8 UPD83 INS83 MOV43 UPD42 MOV44 MOV44 MOV44 MOV44 MOV43 INS29 MOV83 UPD39 MOV39 INS42 MOV44 MOV8 MOV29 UPD83 MOV83 MOV39 UPD42 MOV42 INS44 INS8 UPD83 MOV43 INS42 INS8 UPD83 INS83 UPD43 INS42 MOV43 INS8 UPD42 UPD42 UPD42 INS65 INS21 INS21 INS60 INS65 MOV60 MOV25 MOV21 INS60 MOV60 MOV60 MOV21 MOV24 INS65 MOV60 MOV21 INS60 MOV25 INS65 MOV65 UPD43 UPD42 MOV61 INS65 INS43 INS42 MOV60 INS25 INS41 UPD42 INS25 INS41 UPD66 UPD66 INS65 INS65 UPD66 UPD66 UPD66 INS7 MOV11 INS65 INS66 UPD66 UPD66 INS7 MOV43 MOV59 MOV43 INS59 UPD43 INS65 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 UPD43 UPD43 MOV43 INS59 INS65 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 UPD43 MOV43 MOV43 INS59 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 UPD42 INS66 UPD42 MOV43 MOV32 UPD66 MOV66 UPD66 MOV66 UPD42 UPD66 UPD42 MOV42 MOV43 INS27 INS8 UPD66 INS42 INS65 INS66 UPD66 INS66 INS66 INS66 INS27 MOV8 INS32 INS21 INS42 MOV11 MOV43 INS42 MOV11 UPD42 MOV42 INS42 INS32 UPD42 UPD42 UPD42 INS11 INS42 MOV11 UPD42 UPD42 MOV42 INS11 UPD42 INS11 UPD42 UPD42 INS42 UPD42 UPD42 INS11 INS42 MOV11 UPD42 INS11 INS42 INS32 INS42 INS32 UPD42 INS42 INS33 INS25 INS42 INS33 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS9 INS7 UPD42 MOV42 INS43 UPD42 MOV42 MOV11 UPD42 MOV42 UPD43 INS43 INS42 INS42 INS43 INS32 MOV43 INS32 INS43 INS42 MOV43 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS32 MOV43 INS62 INS8 INS42 MOV14 INS42 UPD43 MOV43 MOV32 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD43 UPD42 MOV42 MOV11 INS42 INS42 INS32 INS42 INS43 MOV60 INS54 UPD45 INS52 INS43 MOV42 UPD42 UPD42 UPD42 UPD42 UPD43 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV43 INS8 MOV12 INS42 UPD42 UPD42 INS11 MOV21 MOV21 MOV43 INS42 INS32 MOV43 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 MOV42 MOV32 UPD42 MOV42 UPD42 UPD42 UPD42 UPD45 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL42 DEL43 DEL42 DEL59 DEL60 DEL33 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL65 DEL40 DEL65 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL36 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL14 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL42 DEL9 DEL32 DEL21 DEL8 DEL61 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL32 DEL21 DEL42 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL33 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL41 DEL8 DEL31 DEL65 DEL42 DEL65 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL65 DEL42 DEL65 DEL65 DEL42 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL41 DEL8 DEL31 DEL65 DEL65 DEL29 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL66 DEL65 DEL42 DEL65 DEL65 DEL42 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL41 DEL8 DEL31 DEL66 DEL65 DEL42 DEL65 DEL65 DEL66 DEL65 DEL42 DEL65 DEL65 DEL42 DEL65 DEL29 DEL42 DEL65 DEL65 DEL42 DEL65 DEL42 DEL59 DEL60 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL9 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL66 DEL65 DEL42 DEL65 DEL42 DEL65 DEL65 DEL42 DEL65 DEL43 DEL40 DEL42 DEL42 DEL42 DEL34 DEL27 DEL42 DEL34 DEL27 DEL34 DEL27 DEL32 DEL14 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL42 DEL42 DEL42 DEL34 DEL32 DEL42 DEL52 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL45 DEL42 DEL42 DEL32 DEL45 DEL42 DEL45 DEL27 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL45 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL34 DEL27 DEL42 DEL37 DEL42 DEL42 DEL42 DEL32 DEL38 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL40 DEL33 DEL9 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL24 DEL43 DEL40 DEL42 DEL14 DEL59 DEL60 DEL32 DEL33 DEL41 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL42 DEL41 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL38 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL66 DEL66 DEL65 DEL42 DEL65 DEL65 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL43 DEL40 DEL42 DEL42 DEL42 DEL34 DEL27 DEL42 DEL34 DEL27 DEL34 DEL27 DEL32 DEL14 DEL42 DEL42 DEL42 DEL42 DEL34 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL34 DEL27 DEL42 DEL37 DEL42 DEL42 DEL42 DEL32 DEL38 DEL33 DEL41 DEL8 DEL25 DEL8 DEL24 DEL42 DEL43 DEL42 DEL43 DEL40 DEL42 DEL14 DEL42 DEL32 DEL38 DEL33 DEL41 DEL8 DEL25 DEL34 DEL32 DEL42 DEL32 DEL41 DEL42 DEL42 DEL42 DEL13 DEL42 DEL34 DEL27 DEL32 DEL34 DEL27 DEL42 DEL42 DEL13 DEL42 DEL34 DEL27 DEL32 DEL7 DEL42 DEL37 DEL21 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL40 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL40 DEL3 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL42 DEL42 DEL42 DEL42 DEL2 DEL42 DEL32 DEL32 DEL7 DEL21 DEL8 DEL24 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL39 DEL42 DEL40 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL42 DEL32 DEL42 DEL22 DEL34 DEL27 DEL42 DEL42 DEL42 DEL2 DEL42 DEL32 DEL42 DEL32 DEL7 DEL21 DEL39 DEL42 DEL34 DEL38 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL42 DEL27 DEL42 DEL42 DEL7 DEL21 DEL42 DEL34 DEL27 DEL42 DEL45 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL34 DEL42 DEL34 DEL27 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL34 DEL27 DEL32 DEL32 DEL34 DEL27 DEL36 DEL27 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL10 DEL8 DEL25 DEL8 DEL24 DEL42 DEL33 DEL27 DEL42 DEL42 DEL34 DEL2 DEL42 DEL32 DEL42 DEL32 DEL7 DEL21 DEL42 DEL45 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL43 DEL45 DEL42 DEL14 DEL32 DEL19 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL12 DEL54 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL43 DEL45 DEL42 DEL14 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL42 DEL41 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL38 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL65 DEL42 DEL65 DEL42 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL11 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL42 DEL42 DEL42 DEL42 DEL32 DEL40 DEL42 DEL42 DEL32 DEL32 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL42 DEL43 DEL66 DEL65 DEL42 DEL65 DEL65 DEL42 DEL65 DEL40 DEL42 DEL68 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL31 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL42 DEL9 DEL32 DEL21 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL45 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL8 DEL42 DEL38 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL83 DEL42 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL40 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL45 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL8 DEL12 DEL42 DEL38 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL33 DEL27 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL40 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL32 DEL21 DEL8 DEL42 DEL33 DEL27 DEL8 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL40 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL32 DEL21 DEL8 DEL25 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL32 DEL21 DEL8 DEL61 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL61 DEL8 DEL25 DEL8 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL32 DEL21 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL9 DEL32 DEL21 DEL8 DEL61 DEL8 DEL25 DEL8
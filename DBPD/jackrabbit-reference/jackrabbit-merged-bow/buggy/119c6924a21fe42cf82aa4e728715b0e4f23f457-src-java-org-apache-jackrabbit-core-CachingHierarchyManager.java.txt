JCR-131: simplifying internal data model (NodeState) by limiting a node to *one* parent



git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@191499 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.commons.collections.map.ReferenceMap;
-import org.apache.commons.collections.map.ReferenceMap;
-import java.util.List;
-import java.util.Iterator;
+import java.util.Iterator;
+import java.util.List;
-    private final ReferenceMap idCache = new ReferenceMap(
-            ReferenceMap.HARD, ReferenceMap.HARD);
+    private final ReferenceMap idCache = new ReferenceMap(ReferenceMap.HARD, ReferenceMap.HARD);
-     * Create a new instance of this class. This hierarchy manager will not
-     * check for item states that have been moved into attic space
+     * Create a new instance of this class.
+     *
-     * @param provider item state manager
-     * @param nsResolver namespace resolver
+     * @param provider     item state manager
+     * @param nsResolver   namespace resolver
-        this(rootNodeUUID, provider, nsResolver, null);
+        super(rootNodeUUID, provider, nsResolver);
+        upperLimit = DEFAULT_UPPER_LIMIT;
-    /**
-     * Create a new instance of this class.
-     * @param rootNodeUUID root node UUID
-     * @param provider item state manager
-     * @param nsResolver namespace resolver
-     * @param attic item state manager for states in the attic space
-     */
-    public CachingHierarchyManager(String rootNodeUUID,
-                                   ItemStateManager provider,
-                                   NamespaceResolver nsResolver,
-                                   ItemStateManager attic) {
-
-        super(rootNodeUUID, provider, nsResolver, attic);
-
-        this.upperLimit = DEFAULT_UPPER_LIMIT;
-    }
-
-    //-----------------------------------------------------< HierarchyManager >
-
+    //-------------------------------------------------< base class overrides >
-     *
-     * Check the item indicated inside our path cache first.
-     */
-    public NodeId[] listParents(ItemId id)
-            throws ItemNotFoundException, RepositoryException {
-
-        if (id.denotesNode()) {
-            PathMap.Element element = get(id);
-            if (element != null) {
-                PathMap.Element parent = element.getParent();
-                if (parent != null) {
-                    LRUEntry entry = (LRUEntry) element.get();
-                    if (entry != null) {
-                        return new NodeId[] { (NodeId) entry.getId() };
-                    }
-                }
-            }
-        }
-        return super.listParents(id);
-    }
-
-    /**
-     * {@inheritDoc}
-     *
-     * Check the path indicated inside our cache first.
-     */
-    public ItemId resolvePath(Path path)
-            throws PathNotFoundException, RepositoryException {
-
-        PathMap.Element element = map(path);
-        if (element == null) {
-            return super.resolvePath(path);
-        }
-        LRUEntry entry = (LRUEntry) element.get();
-        if (element.hasPath(path)) {
-            entry.touch();
-            return entry.getId();
-        }
-        return super.resolvePath(path, entry.getId(), element.getDepth() + 1);
-    }
-
-    /**
-     * {@inheritDoc}
-     *
+     * <p/>
-     *
-     * Overridden method simply checks whether we have an item matching the id
-     * and returns its path, otherwise calls base implementation.
-     */
-    public synchronized Path getPath(ItemId id)
-            throws ItemNotFoundException, RepositoryException {
-
-        if (id.denotesNode()) {
-            PathMap.Element element = get(id);
-            if (element != null) {
-                try {
-                    return element.getPath();
-                } catch (MalformedPathException mpe) {
-                    String msg = "Failed to build path of " + id;
-                    log.debug(msg);
-                    throw new RepositoryException(msg, mpe);
-                }
-            }
-        }
-        return super.getPath(id);
-    }
-
-    /**
-     * {@inheritDoc}
-     *
+     * <p/>
-    protected void getPath(Path.PathBuilder builder, ItemState state)
+    protected void buildPath(Path.PathBuilder builder, ItemState state)
-        super.getPath(builder, state);
+        super.buildPath(builder, state);
+    //-----------------------------------------------------< HierarchyManager >
+    /**
+     * {@inheritDoc}
+     * <p/>
+     * Check the path indicated inside our cache first.
+     */
+    public ItemId resolvePath(Path path)
+            throws PathNotFoundException, RepositoryException {
+
+        PathMap.Element element = map(path);
+        if (element == null) {
+            return super.resolvePath(path);
+        }
+        LRUEntry entry = (LRUEntry) element.get();
+        if (element.hasPath(path)) {
+            entry.touch();
+            return entry.getId();
+        }
+        return super.resolvePath(path, entry.getId(), element.getDepth() + 1);
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p/>
+     * Overridden method simply checks whether we have an item matching the id
+     * and returns its path, otherwise calls base implementation.
+     */
+    public synchronized Path getPath(ItemId id)
+            throws ItemNotFoundException, RepositoryException {
+
+        if (id.denotesNode()) {
+            PathMap.Element element = get(id);
+            if (element != null) {
+                try {
+                    return element.getPath();
+                } catch (MalformedPathException mpe) {
+                    String msg = "Failed to build path of " + id;
+                    log.debug(msg);
+                    throw new RepositoryException(msg, mpe);
+                }
+            }
+        }
+        return super.getPath(id);
+    }
+
-    /**
-     * {@inheritDoc}
-     */
-    public Path[] getAllPaths(ItemId id, boolean includeZombies)
-            throws ItemNotFoundException, RepositoryException {
-
-        if (!includeZombies) {
-            return new Path[] { getPath(id) };
-        }
-        return super.getAllPaths(id, includeZombies);
-    }
-
-     *        item state. To get the overlaid state, invoke
-     *        {@link ItemState#getOverlayedState()}
+     *                  item state. To get the overlaid state, invoke
+     *                  {@link ItemState#getOverlayedState()}
-        } catch(ItemNotFoundException e) {
+        } catch (ItemNotFoundException e) {
-        } catch(RepositoryException e) {
+        } catch (RepositoryException e) {
-     *
+     * <p/>
-            NodeState.ChildNodeEntry old = null;
+            NodeState.ChildNodeEntry old =
+                    ((NodeState) state.getOverlayedState()).getChildNodeEntry(now.getUUID());;
-            List list = ((NodeState) state.getOverlayedState()).
-                    getChildNodeEntries(now.getUUID());
-            if (list.size() > 0) {
-                old = (NodeState.ChildNodeEntry) list.get(0);
-            }
-        } catch(ItemNotFoundException e) {
+        } catch (ItemNotFoundException e) {
-        } catch(RepositoryException e) {
+        } catch (RepositoryException e) {
-    //-------------------------------------------------------< private methods >
+    //------------------------------------------------------< private methods >
+     *
+     *
+     *
-     * @param path path to item
+     * @param path  path to item
+     *
+     *
-     * @param entry LRU entry
+     *
+     * @param entry               LRU entry
+     *
+     *
-     * @param id node id
+     * @param id   node id
+     *
-     * @param id node id
+     * @param id   node id
+         *
+         *
+         *
+         *
+         *

MOV26 MOV26 MOV26 MOV31 MOV31 UPD42 UPD66 UPD66 INS66 INS66 INS66 INS66 INS66 UPD66 UPD66 UPD66 UPD66 INS42 UPD42 INS20 MOV43 UPD42 UPD42 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL33 DEL17 DEL8 DEL31 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL44 DEL42 DEL52 DEL42 DEL22 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL32 DEL40 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL40 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL43 DEL85 DEL5 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL4 DEL3 DEL41 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL48 DEL41 DEL8 DEL31 DEL65 DEL65 DEL29 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL38 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL32 DEL4 DEL3 DEL41 DEL8 DEL25 DEL42 DEL42 DEL42 DEL48 DEL41 DEL8 DEL31 DEL42 DEL33 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL40 DEL43 DEL42 DEL42 DEL34 DEL32 DEL11 DEL7 DEL21 DEL8 DEL25
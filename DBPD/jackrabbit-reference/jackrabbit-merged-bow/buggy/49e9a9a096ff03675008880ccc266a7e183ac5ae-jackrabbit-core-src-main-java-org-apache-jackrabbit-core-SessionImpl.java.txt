JCR-890: concurrent read-only access to a session

Turn Session.move() into a SessionOperation

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@957589 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.nodetype.NodeTypeImpl;
-import org.apache.jackrabbit.core.state.NodeState;
-import javax.jcr.ItemExistsException;
-     * Internal helper class for common validation checks (lock status, checkout
-     * status, protection etc. etc.)
-     */
-    private ItemValidator validator;
-
-    /**
+        context.setItemValidator(new ItemValidator(context));
-     * @throws RepositoryException If an error occurs.
-    public synchronized ItemValidator getValidator() throws RepositoryException {
-        if (validator == null) {
-            validator = new ItemValidator(context);
-        }
-        return validator;
+    public ItemValidator getValidator() {
+        return context.getItemValidator();
-            throws ItemExistsException, PathNotFoundException,
-            VersionException, ConstraintViolationException, LockException,
-            RepositoryException {
-        // check sanity of this session
-        sanityCheck();
-
-        // check paths & get node instances
-
-        Path srcPath;
-        Path.Element srcName;
-        Path srcParentPath;
-        NodeImpl targetNode;
-        NodeImpl srcParentNode;
-        try {
-            srcPath = getQPath(srcAbsPath).getNormalizedPath();
-            if (!srcPath.isAbsolute()) {
-                throw new RepositoryException("not an absolute path: " + srcAbsPath);
-            }
-            srcName = srcPath.getNameElement();
-            srcParentPath = srcPath.getAncestor(1);
-            targetNode = getItemManager().getNode(srcPath);
-            srcParentNode = getItemManager().getNode(srcParentPath);
-        } catch (AccessDeniedException ade) {
-            throw new PathNotFoundException(srcAbsPath);
-        } catch (NameException e) {
-            String msg = srcAbsPath + ": invalid path";
-            log.debug(msg);
-            throw new RepositoryException(msg, e);
-        }
-
-        Path destPath;
-        Path.Element destName;
-        Path destParentPath;
-        NodeImpl destParentNode;
-        try {
-            destPath = getQPath(destAbsPath).getNormalizedPath();
-            if (!destPath.isAbsolute()) {
-                throw new RepositoryException("not an absolute path: " + destAbsPath);
-            }
-            if (srcPath.isAncestorOf(destPath)) {
-                String msg = destAbsPath + ": invalid destination path (cannot be descendant of source path)";
-                log.debug(msg);
-                throw new RepositoryException(msg);
-            }
-            destName = destPath.getNameElement();
-            destParentPath = destPath.getAncestor(1);
-            destParentNode = getItemManager().getNode(destParentPath);
-        } catch (AccessDeniedException ade) {
-            throw new PathNotFoundException(destAbsPath);
-        } catch (NameException e) {
-            String msg = destAbsPath + ": invalid path";
-            log.debug(msg);
-            throw new RepositoryException(msg, e);
-        }
-
-        if (context.getHierarchyManager().isShareAncestor(targetNode.getNodeId(), destParentNode.getNodeId())) {
-            String msg = destAbsPath + ": invalid destination path (share cycle detected)";
-            log.debug(msg);
-            throw new RepositoryException(msg);
-        }
-
-        int ind = destName.getIndex();
-        if (ind > 0) {
-            // subscript in name element
-            String msg = destAbsPath + ": invalid destination path (subscript in name element is not allowed)";
-            log.debug(msg);
-            throw new RepositoryException(msg);
-        }
-
-        // check for name collisions
-        NodeImpl existing = null;
-        try {
-            existing = getItemManager().getNode(destPath);
-            // there's already a node with that name:
-            // check same-name sibling setting of existing node
-            if (!existing.getDefinition().allowsSameNameSiblings()) {
-                throw new ItemExistsException(
-                        "Same name siblings are not allowed: " + existing);
-            }
-        } catch (AccessDeniedException ade) {
-            // FIXME by throwing ItemExistsException we're disclosing too much information
-            throw new ItemExistsException(destAbsPath);
-        } catch (PathNotFoundException pnfe) {
-            // no name collision, fall through
-        }
-
-        // verify for both source and destination parent nodes that
-        // - they are checked-out
-        // - are not protected neither by node type constraints nor by retention/hold
-        int options = ItemValidator.CHECK_CHECKED_OUT | ItemValidator.CHECK_LOCK |
-                ItemValidator.CHECK_CONSTRAINTS | ItemValidator.CHECK_HOLD | ItemValidator.CHECK_RETENTION;
-        getValidator().checkRemove(srcParentNode, options, Permission.NONE);
-        getValidator().checkModify(destParentNode, options, Permission.NONE);
-
-        // check constraints
-        // get applicable definition of target node at new location
-        NodeTypeImpl nt = (NodeTypeImpl) targetNode.getPrimaryNodeType();
-        org.apache.jackrabbit.spi.commons.nodetype.NodeDefinitionImpl newTargetDef;
-        try {
-            newTargetDef = destParentNode.getApplicableChildNodeDefinition(destName.getName(), nt.getQName());
-        } catch (RepositoryException re) {
-            String msg = destAbsPath + ": no definition found in parent node's node type for new node";
-            log.debug(msg);
-            throw new ConstraintViolationException(msg, re);
-        }
-        // if there's already a node with that name also check same-name sibling
-        // setting of new node; just checking same-name sibling setting on
-        // existing node is not sufficient since same-name sibling nodes don't
-        // necessarily have identical definitions
-        if (existing != null && !newTargetDef.allowsSameNameSiblings()) {
-            throw new ItemExistsException(
-                    "Same name siblings not allowed: " + existing);
-        }
-
-        NodeId targetId = targetNode.getNodeId();
-        int index = srcName.getIndex();
-        if (index == 0) {
-            index = 1;
-        }
-
-        // check permissions
-        AccessManager acMgr = context.getAccessManager();
-        if (!(acMgr.isGranted(srcPath, Permission.REMOVE_NODE) &&
-                acMgr.isGranted(destPath, Permission.ADD_NODE | Permission.NODE_TYPE_MNGMT))) {
-            String msg = "Not allowed to move node " + srcAbsPath + " to " + destAbsPath;
-            log.debug(msg);
-            throw new AccessDeniedException(msg);
-        }
-
-        if (srcParentNode.isSame(destParentNode)) {
-            // change definition of target
-            targetNode.onRedefine(newTargetDef.unwrap());
-            // do rename
-            destParentNode.renameChildNode(srcName.getName(), index, targetId, destName.getName());
-        } else {
-            // check shareable case
-            if (targetNode.getNodeState().isShareable()) {
-                String msg = "Moving a shareable node is not supported.";
-                log.debug(msg);
-                throw new UnsupportedRepositoryOperationException(msg);
-            }
-            // change definition of target
-            targetNode.onRedefine(newTargetDef.unwrap());
-
-            // Get the transient states
-            NodeState srcParentState =
-                    (NodeState) srcParentNode.getOrCreateTransientItemState();
-            NodeState targetState =
-                    (NodeState) targetNode.getOrCreateTransientItemState();
-            NodeState destParentState =
-                    (NodeState) destParentNode.getOrCreateTransientItemState();
-
-            // do move:
-            // 1. remove child node entry from old parent
-            if (srcParentState.removeChildNodeEntry(targetId)) {
-                // 2. re-parent target node
-                targetState.setParentId(destParentNode.getNodeId());
-                // 3. add child node entry to new parent
-                destParentState.addChildNodeEntry(destName.getName(), targetId);
-            }
-        }
+            throws RepositoryException {
+        perform(new SessionMoveOperation(this, srcAbsPath, destAbsPath));

MOV43 INS21 INS41 INS21 INS32 INS32 INS32 INS42 INS42 MOV14 INS42 INS42 INS42 INS14 UPD43 MOV43 INS52 INS42 INS42 UPD42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL42 DEL66 DEL65 DEL83 DEL42 DEL33 DEL27 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL41 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL59 DEL60 DEL40 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL38 DEL42 DEL43 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL34 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL43 DEL42 DEL59 DEL60 DEL40 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL38 DEL42 DEL43 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL34 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL42 DEL43 DEL42 DEL42 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL34 DEL27 DEL42 DEL43 DEL42 DEL42 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL42 DEL32 DEL38 DEL42 DEL43 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL39 DEL42 DEL40 DEL40 DEL40 DEL40 DEL40 DEL27 DEL59 DEL60 DEL42 DEL32 DEL42 DEL42 DEL42 DEL40 DEL32 DEL21 DEL42 DEL32 DEL42 DEL42 DEL42 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL40 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL38 DEL27 DEL42 DEL43 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL34 DEL27 DEL42 DEL34 DEL7 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL42 DEL40 DEL40 DEL27 DEL32 DEL27 DEL36 DEL38 DEL42 DEL43 DEL42 DEL45 DEL42 DEL45 DEL42 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25
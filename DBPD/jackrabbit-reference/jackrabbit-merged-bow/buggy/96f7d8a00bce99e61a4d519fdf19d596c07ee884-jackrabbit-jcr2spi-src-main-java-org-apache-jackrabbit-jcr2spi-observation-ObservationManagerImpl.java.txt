JCR-2108: JSR 283 Observation

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@790826 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Iterator;
-import javax.jcr.UnsupportedRepositoryOperationException;
+import org.apache.jackrabbit.spi.Event;
-    private final Map subscriptions = new HashMap();
+    private final Map<EventListener, EventFilter> subscriptions = new HashMap<EventListener, EventFilter>();
-    private Map readOnlySubscriptions;
+    private Map<EventListener, EventFilter> readOnlySubscriptions;
+     *
-     * @param resolver
+     * @param resolver   the name path resolver for this session.
-     * @param valueFactory
-    public ObservationManagerImpl(WorkspaceManager wspManager, NamePathResolver resolver,
+    public ObservationManagerImpl(WorkspaceManager wspManager,
+                                  NamePathResolver resolver,
-        Path path;
-        try {
-            path = resolver.getQPath(absPath).getCanonicalPath();
-        } catch (NameException e) {
-            throw new RepositoryException("Malformed path: " + absPath);
-        }
-
-        // create NodeType instances from names
-        Name[] qNodeTypeNames;
-        if (nodeTypeNames == null) {
-            qNodeTypeNames = null;
-        } else {
-            try {
-                qNodeTypeNames = new Name[nodeTypeNames.length];
-                for (int i = 0; i < nodeTypeNames.length; i++) {
-                    Name ntName = resolver.getQName(nodeTypeNames[i]);
-                    if (!ntRegistry.isRegistered(ntName)) {
-                        throw new RepositoryException("unknown node type: " + nodeTypeNames[i]);
-                    }
-                    qNodeTypeNames[i] = ntName;
-                }
-            } catch (NameException e) {
-                throw new RepositoryException(e.getMessage());
-            }
-        }
-
-        EventFilter filter = wspManager.createEventFilter(eventTypes, path, isDeep, uuids, qNodeTypeNames, noLocal);
+        EventFilter filter = createEventFilter(eventTypes, absPath,
+                isDeep, uuids, nodeTypeNames, noLocal);
-        // TODO
-        throw new UnsupportedRepositoryOperationException("JCR-2108");
+        return getEventJournal(Event.ALL_TYPES, "/", true, null, null);
+    /**
+     * @see javax.jcr.observation.ObservationManager#getEventJournal(int, String, boolean, String[], String[])
+     */
-        throw new UnsupportedRepositoryOperationException("JCR-2108");
+        EventFilter filter = createEventFilter(eventTypes, absPath, isDeep, uuid, nodeTypeName, false);
+        return new EventJournalImpl(wspManager, filter, resolver);
-    public Collection getEventFilters() {
-        List filters = new ArrayList();
+    public Collection<EventFilter> getEventFilters() {
+        List<EventFilter> filters = new ArrayList<EventFilter>();
-        Map activeListeners;
+        Map<EventListener, EventFilter> activeListeners;
-        for (Iterator it = activeListeners.entrySet().iterator(); it.hasNext(); ) {
-            Map.Entry entry = (Map.Entry) it.next();
-            EventListener listener = (EventListener) entry.getKey();
-            EventFilter filter = (EventFilter) entry.getValue();
-            FilteredEventIterator eventIter = new FilteredEventIterator(eventBundle, filter, resolver, wspManager.getIdFactory());
+        for (Map.Entry<EventListener, EventFilter> entry : activeListeners.entrySet()) {
+            EventListener listener = entry.getKey();
+            EventFilter filter = entry.getValue();
+            FilteredEventIterator eventIter = new FilteredEventIterator(
+                    eventBundle.getEvents(), eventBundle.isLocal(), filter,
+                    resolver, wspManager.getIdFactory());
-            readOnlySubscriptions = new HashMap(subscriptions);
+            readOnlySubscriptions = new HashMap<EventListener, EventFilter>(subscriptions);
+    /**
+     * Creates an SPI event filter from the given list of constraints.
+     *
+     * @param eventTypes    the event types.
+     * @param absPath       an absolute path.
+     * @param isDeep        whether to include events for descendant items of
+     *                      the node at absPath.
+     * @param uuids         uuid filters.
+     * @param nodeTypeNames node type filters.
+     * @param noLocal       whether to exclude changes from the local session.
+     * @return the SPI event filter instance.
+     * @throws RepositoryException if an error occurs while creating the event
+     *                             filter.
+     */
+    private EventFilter createEventFilter(int eventTypes,
+                                          String absPath,
+                                          boolean isDeep,
+                                          String[] uuids,
+                                          String[] nodeTypeNames,
+                                          boolean noLocal)
+            throws RepositoryException {
+        Path path;
+        try {
+            path = resolver.getQPath(absPath).getCanonicalPath();
+        } catch (NameException e) {
+            throw new RepositoryException("Malformed path: " + absPath);
+        }
+
+        // create NodeType instances from names
+        Name[] qNodeTypeNames;
+        if (nodeTypeNames == null) {
+            qNodeTypeNames = null;
+        } else {
+            try {
+                qNodeTypeNames = new Name[nodeTypeNames.length];
+                for (int i = 0; i < nodeTypeNames.length; i++) {
+                    Name ntName = resolver.getQName(nodeTypeNames[i]);
+                    if (!ntRegistry.isRegistered(ntName)) {
+                        throw new RepositoryException("unknown node type: " + nodeTypeNames[i]);
+                    }
+                    qNodeTypeNames[i] = ntName;
+                }
+            } catch (NameException e) {
+                throw new RepositoryException(e.getMessage());
+            }
+        }
+
+        return wspManager.createEventFilter(eventTypes, path, isDeep,
+                uuids, qNodeTypeNames, noLocal);
+    }

MOV26 MOV31 UPD40 INS31 INS74 INS74 MOV29 INS83 INS39 INS42 MOV44 INS44 INS44 INS44 INS44 INS44 INS44 INS43 INS8 INS29 INS74 INS29 UPD83 MOV43 UPD42 MOV43 INS43 INS43 MOV43 INS43 INS43 INS39 INS42 INS43 INS42 INS39 INS42 INS5 INS42 INS5 INS42 INS39 INS42 INS42 INS60 MOV51 MOV25 INS41 INS65 INS60 INS41 MOV43 INS43 INS70 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS41 INS42 INS42 INS74 INS42 INS42 INS66 INS42 INS43 INS85 INS43 INS85 INS43 INS59 INS32 INS68 MOV43 INS59 INS14 INS42 INS74 INS74 INS44 MOV32 MOV8 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 MOV32 MOV43 INS43 INS43 INS42 INS42 INS42 INS42 INS32 INS42 INS40 INS45 INS9 INS33 INS33 INS40 INS42 INS69 INS69 INS69 INS69 INS69 INS42 INS32 UPD43 MOV43 INS42 INS42 INS42 MOV43 INS43 MOV43 INS43 INS43 INS74 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS39 INS43 INS39 INS5 INS5 INS42 INS42 INS42 INS42 INS42 INS42 INS9 UPD42 INS42 INS74 INS42 INS42 MOV43 INS43 INS43 MOV43 MOV43 INS42 INS43 INS85 INS43 INS85 MOV43 INS43 UPD42 MOV42 INS42 MOV32 MOV32 INS42 INS42 INS42 INS32 INS32 INS74 INS42 INS42 INS42 INS42 MOV43 MOV43 INS43 INS42 DEL40 DEL26 DEL42 DEL65 DEL42 DEL43 DEL45 DEL14 DEL53 DEL45 DEL14 DEL53 DEL42 DEL40 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL11 DEL11 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL39 DEL42 DEL59 DEL60
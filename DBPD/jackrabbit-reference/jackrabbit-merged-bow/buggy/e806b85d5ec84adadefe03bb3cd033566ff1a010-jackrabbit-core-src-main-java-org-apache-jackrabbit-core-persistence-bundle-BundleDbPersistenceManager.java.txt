JCR-940: BundleDbPersistenceManager auto re-connect

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@575734 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager;
-import java.sql.DriverManager;
-import java.sql.Driver;
-import java.util.Iterator;
-import java.util.Collection;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+ * <li>&lt;param name="{@link #setBlockOnConnectionLoss(String) blockOnConnectionLoss}" value="false"/>
+    /** indicates whether to block if the database connection is lost */
+    protected boolean blockOnConnectionLoss = false;
-    /** jdbc conection */
-    protected Connection con;
+    /**
+     * The class that manages statement execution and recovery from connection loss.
+     */
+    protected ConnectionRecoveryManager connectionManager;
-    // shared prepared statements for bundle management
-    protected PreparedStatement bundleInsert;
-    protected PreparedStatement bundleUpdate;
-    protected PreparedStatement bundleSelect;
-    protected PreparedStatement bundleDelete;
+    // SQL statements for bundle management
+    protected String bundleInsertSQL;
+    protected String bundleUpdateSQL;
+    protected String bundleSelectSQL;
+    protected String bundleDeleteSQL;
-    // shared prepared statements for NodeReference management
-    protected PreparedStatement nodeReferenceInsert;
-    protected PreparedStatement nodeReferenceUpdate;
-    protected PreparedStatement nodeReferenceSelect;
-    protected PreparedStatement nodeReferenceDelete;
+    // SQL statements for NodeReference management
+    protected String nodeReferenceInsertSQL;
+    protected String nodeReferenceUpdateSQL;
+    protected String nodeReferenceSelectSQL;
+    protected String nodeReferenceDeleteSQL;
+    public void setBlockOnConnectionLoss(String block) {
+        this.blockOnConnectionLoss = Boolean.valueOf(block).booleanValue();
+    }
+
+    public String getBlockOnConnectionLoss() {
+        return Boolean.toString(blockOnConnectionLoss);
+    }
+
-            Statement stmt = con.createStatement();
+            Statement stmt = connectionManager.getConnection().createStatement();
-        DatabaseMetaData metaData = con.getMetaData();
+        DatabaseMetaData metaData = connectionManager.getConnection().getMetaData();
-    public synchronized void store(ChangeLog changeLog)
-            throws ItemStateException {
-
+    public synchronized void store(ChangeLog changeLog) throws ItemStateException {
+        Connection con = null;
-            con.setAutoCommit(false);
-            super.store(changeLog);
-        } catch (SQLException e) {
-            String msg = "setting autocommit failed.";
-            log.error(msg, e);
-            throw new ItemStateException(msg, e);
-        } catch (ItemStateException e) {
-            // storing the changes failed, rollback changes
+            boolean tryAgain = true;
+            do {
+                try {
+                    con = connectionManager.getConnection();
+                    connectionManager.setAutoReconnect(false);
+                    con.setAutoCommit(false);
+                    super.store(changeLog);
+                    con.commit();
+                    con.setAutoCommit(true);
+                } catch (SQLException e) {
+                    if (tryAgain) {
+                        tryAgain = false;
+                        continue;
+                    }
+                    throw e;
+                }
+            } while(false);
+        } catch (Throwable th) {
-                con.rollback();
-            } catch (SQLException e1) {
-                String msg = "rollback of change log failed";
-                log.error(msg, e1);
+                if (con != null) {
+                    con.rollback();
+                }
+            } catch (SQLException e) {
+                logException("rollback failed", e);
-            // re-throw original exception
-            throw e;
-        }
-
-        // storing the changes succeeded, now commit the changes
-        try {
-            con.commit();
-            con.setAutoCommit(true);
-        } catch (SQLException e) {
-            String msg = "committing change log failed";
-            log.error(msg, e);
-            throw new ItemStateException(msg, e);
+            if (th instanceof SQLException || th.getCause() instanceof SQLException) {
+                connectionManager.close();
+            }
+            throw new ItemStateException(th.getMessage());
+        } finally {
+            connectionManager.setAutoReconnect(true);
-        // setup jdbc connection
-        // Note: Explicit creation of new instance of the driver is required
-        // in order to re-register the driver in the DriverManager after a
-        // repository shutdown.
-        Driver drv = (Driver) Class.forName(driver).newInstance();
-        log.info("JDBC driver created: {}", drv);
-        con = DriverManager.getConnection(url, user, password);
-        
-        DatabaseMetaData meta = con.getMetaData();
-        try {
-            log.info("Database: " + meta.getDatabaseProductName() + " / " + meta.getDatabaseProductVersion());
-            log.info("Driver: " + meta.getDriverName() + " / " + meta.getDriverVersion());
-        } catch (SQLException e) {
-            log.warn("Can not retrieve database and driver name / version", e);
-        }
-        
-        con.setAutoCommit(true);
+        connectionManager = new ConnectionRecoveryManager(blockOnConnectionLoss,
+                getDriver(), getUrl(), getUser(), getPassword());
-        // prepare statements
-        if (getStorageModel() == SM_BINARY_KEYS) {
-            bundleInsert = con.prepareStatement("insert into " + schemaObjectPrefix + "BUNDLE (BUNDLE_DATA, NODE_ID) values (?, ?)");
-            bundleUpdate = con.prepareStatement("update " + schemaObjectPrefix + "BUNDLE set BUNDLE_DATA = ? where NODE_ID = ?");
-            bundleSelect = con.prepareStatement("select BUNDLE_DATA from " + schemaObjectPrefix + "BUNDLE where NODE_ID = ?");
-            bundleDelete = con.prepareStatement("delete from " + schemaObjectPrefix + "BUNDLE where NODE_ID = ?");
+        buildSQLStatements();
-            nodeReferenceInsert = con.prepareStatement("insert into " + schemaObjectPrefix + "REFS (REFS_DATA, NODE_ID) values (?, ?)");
-            nodeReferenceUpdate = con.prepareStatement("update " + schemaObjectPrefix + "REFS set REFS_DATA = ? where NODE_ID = ?");
-            nodeReferenceSelect = con.prepareStatement("select REFS_DATA from " + schemaObjectPrefix + "REFS where NODE_ID = ?");
-            nodeReferenceDelete = con.prepareStatement("delete from " + schemaObjectPrefix + "REFS where NODE_ID = ?");
-        } else {
-            bundleInsert = con.prepareStatement("insert into " + schemaObjectPrefix + "BUNDLE (BUNDLE_DATA, NODE_ID_HI, NODE_ID_LO) values (?, ?, ?)");
-            bundleUpdate = con.prepareStatement("update " + schemaObjectPrefix + "BUNDLE set BUNDLE_DATA = ? where NODE_ID_HI = ? and NODE_ID_LO = ?");
-            bundleSelect = con.prepareStatement("select BUNDLE_DATA from " + schemaObjectPrefix + "BUNDLE where NODE_ID_HI = ? and NODE_ID_LO = ?");
-            bundleDelete = con.prepareStatement("delete from " + schemaObjectPrefix + "BUNDLE where NODE_ID_HI = ? and NODE_ID_LO = ?");
-
-            nodeReferenceInsert = con.prepareStatement("insert into " + schemaObjectPrefix + "REFS (REFS_DATA, NODE_ID_HI, NODE_ID_LO) values (?, ?, ?)");
-            nodeReferenceUpdate = con.prepareStatement("update " + schemaObjectPrefix + "REFS set REFS_DATA = ? where NODE_ID_HI = ? and NODE_ID_LO = ?");
-            nodeReferenceSelect = con.prepareStatement("select REFS_DATA from " + schemaObjectPrefix + "REFS where NODE_ID_HI = ? and NODE_ID_LO = ?");
-            nodeReferenceDelete = con.prepareStatement("delete from " + schemaObjectPrefix + "REFS where NODE_ID_HI = ? and NODE_ID_LO = ?");
-        }
-        return new DbNameIndex(con, schemaObjectPrefix);
+        return new DbNameIndex(connectionManager, schemaObjectPrefix);
-        PreparedStatement stmt = null;
+            String sql;
-                stmt = con.prepareStatement(
-                        "select NODE_ID, BUNDLE_DATA from "
-                        + schemaObjectPrefix + "BUNDLE");
+                sql = "select NODE_ID, BUNDLE_DATA from " + schemaObjectPrefix + "BUNDLE";
-                stmt = con.prepareStatement(
-                        "select NODE_ID_HI, NODE_ID_LO, BUNDLE_DATA from "
-                        + schemaObjectPrefix + "BUNDLE");
+                sql = "select NODE_ID_HI, NODE_ID_LO, BUNDLE_DATA from " + schemaObjectPrefix + "BUNDLE";
-            stmt.execute();
+            Statement stmt = connectionManager.executeStmt(sql, new Object[0]);
-            closeStatement(stmt);
-        DatabaseMetaData metaData = con.getMetaData();
+        DatabaseMetaData metaData = connectionManager.getConnection().getMetaData();
-            // close shared prepared statements
-            closeStatement(bundleInsert);
-            closeStatement(bundleUpdate);
-            closeStatement(bundleSelect);
-            closeStatement(bundleDelete);
-
-            closeStatement(nodeReferenceInsert);
-            closeStatement(nodeReferenceUpdate);
-            closeStatement(nodeReferenceSelect);
-            closeStatement(nodeReferenceDelete);
-
-
-            // close jdbc connection
-            con.close();
-
+            connectionManager.close();
+     * Constructs a parameter list for a PreparedStatement
+     * for the given UUID.
+     *
+     * @param uuid the uuid
+     * @return a list of Objects
+     */
+    protected Object[] getKey(UUID uuid) {
+        if (getStorageModel() == SM_BINARY_KEYS) {
+            return new Object[]{uuid.getRawBytes()};
+        } else {
+            return new Object[]{new Long(uuid.getMostSignificantBits()),
+                    new Long(uuid.getLeastSignificantBits())};
+        }
+    }
+
+    /**
+     * Creates a parameter array for an SQL statement that needs
+     * (i) a UUID, and (2) another parameter.
+     *
+     * @param uuid the UUID
+     * @param p the other parameter
+     * @param before whether the other parameter should be before the uuid parameter
+     * @return an Object array that represents the parameters
+     */
+    protected Object[] createParams(UUID uuid, Object p, boolean before) {
+
+        // Create the key
+        List key = new ArrayList();
+        if (getStorageModel() == SM_BINARY_KEYS) {
+            key.add(uuid.getRawBytes());
+        } else {
+            key.add(new Long(uuid.getMostSignificantBits()));
+            key.add(new Long(uuid.getLeastSignificantBits()));
+        }
+
+        // Create the parameters
+        List params = new ArrayList();
+        if (before) {
+            params.add(p);
+            params.addAll(key);
+        } else {
+            params.addAll(key);
+            params.add(p);
+        }
+
+        return params.toArray();
+    }
+
+    /**
-        PreparedStatement stmt = bundleSelect;
-            setKey(stmt, id.getUUID(), 1);
-            stmt.execute();
+            Statement stmt = connectionManager.executeStmt(bundleSelectSQL, getKey(id.getUUID()));
-            resetStatement(stmt);
-        PreparedStatement stmt = bundleSelect;
-            setKey(stmt, id.getUUID(), 1);
-            stmt.execute();
+            Statement stmt = connectionManager.executeStmt(bundleSelectSQL, getKey(id.getUUID()));
-
-            resetStatement(stmt);
-        PreparedStatement stmt = null;
-            if (bundle.isNew()) {
-                stmt = bundleInsert;
-            } else {
-                stmt = bundleUpdate;
-            }
-            stmt.setBytes(1, out.toByteArray());
-            setKey(stmt, bundle.getId().getUUID(), 2);
-            stmt.execute();
+            String sql = bundle.isNew() ? bundleInsertSQL : bundleUpdateSQL;
+            Object[] params = createParams(bundle.getId().getUUID(), out.toByteArray(), true);
+            connectionManager.executeStmt(sql, params);
-        } finally {
-            resetStatement(stmt);
-        PreparedStatement stmt = bundleDelete;
-            setKey(stmt, bundle.getId().getUUID(), 1);
-            stmt.execute();
+            connectionManager.executeStmt(bundleDeleteSQL, getKey(bundle.getId().getUUID()));
-        } finally {
-            resetStatement(stmt);
-        PreparedStatement stmt = nodeReferenceSelect;
-            setKey(stmt, targetId.getTargetId().getUUID(), 1);
-            stmt.execute();
+            Statement stmt = connectionManager.executeStmt(
+                    nodeReferenceSelectSQL, getKey(targetId.getTargetId().getUUID()));
-            resetStatement(stmt);
-        PreparedStatement stmt = null;
-        try {
-            // check if insert or update
-            if (exists(refs.getId())) {
-                stmt = nodeReferenceUpdate;
-            } else {
-                stmt = nodeReferenceInsert;
-            }
+        // check if insert or update
+        boolean update = exists(refs.getId());
+        String sql = (update) ? nodeReferenceUpdateSQL : nodeReferenceInsertSQL;
-            ByteArrayOutputStream out = new ByteArrayOutputStream(INITIAL_BUFFER_SIZE);
+        try {
+            ByteArrayOutputStream out =
+                    new ByteArrayOutputStream(INITIAL_BUFFER_SIZE);
-            // we are synchronized on this instance, therefore we do not
-            // not have to additionally synchronize on the preparedStatement
-
-            stmt.setBytes(1, out.toByteArray());
-            setKey(stmt, refs.getTargetId().getUUID(), 2);
-            stmt.execute();
+            Object[] params = createParams(refs.getTargetId().getUUID(), out.toByteArray(), true);
+            connectionManager.executeStmt(sql, params);
-            String msg = "failed to write property state: " + refs.getTargetId();
+            String msg = "failed to write node references: " + refs.getId();
-        } finally {
-            resetStatement(stmt);
-        PreparedStatement stmt = nodeReferenceDelete;
-            setKey(stmt, refs.getTargetId().getUUID(), 1);
-            stmt.execute();
+            connectionManager.executeStmt(nodeReferenceDeleteSQL,
+                    getKey(refs.getTargetId().getUUID()));
-        } finally {
-            resetStatement(stmt);
-        PreparedStatement stmt = nodeReferenceSelect;
-            setKey(stmt, targetId.getTargetId().getUUID(), 1);
-            stmt.execute();
+            Statement stmt = connectionManager.executeStmt(nodeReferenceSelectSQL,
+                    getKey(targetId.getTargetId().getUUID()));
-            // a reference exists, if the result has at least one entry
+            // a reference exists if the result has at least one entry
-            String msg = "failed to check existence of node references: " + targetId;
+            String msg = "failed to check existence of node references: "
+                + targetId;
-            resetStatement(stmt);
+     * Initializes the SQL strings.
+     */
+    protected void buildSQLStatements() {
+        // prepare statements
+        if (getStorageModel() == SM_BINARY_KEYS) {
+            bundleInsertSQL = "insert into " + schemaObjectPrefix + "BUNDLE (BUNDLE_DATA, NODE_ID) values (?, ?)";
+            bundleUpdateSQL = "update " + schemaObjectPrefix + "BUNDLE set BUNDLE_DATA = ? where NODE_ID = ?";
+            bundleSelectSQL = "select BUNDLE_DATA from " + schemaObjectPrefix + "BUNDLE where NODE_ID = ?";
+            bundleDeleteSQL = "delete from " + schemaObjectPrefix + "BUNDLE where NODE_ID = ?";
+
+            nodeReferenceInsertSQL = "insert into " + schemaObjectPrefix + "REFS (REFS_DATA, NODE_ID) values (?, ?)";
+            nodeReferenceUpdateSQL = "update " + schemaObjectPrefix + "REFS set REFS_DATA = ? where NODE_ID = ?";
+            nodeReferenceSelectSQL = "select REFS_DATA from " + schemaObjectPrefix + "REFS where NODE_ID = ?";
+            nodeReferenceDeleteSQL = "delete from " + schemaObjectPrefix + "REFS where NODE_ID = ?";
+        } else {
+            bundleInsertSQL = "insert into " + schemaObjectPrefix + "BUNDLE (BUNDLE_DATA, NODE_ID_HI, NODE_ID_LO) values (?, ?, ?)";
+            bundleUpdateSQL = "update " + schemaObjectPrefix + "BUNDLE set BUNDLE_DATA = ? where NODE_ID_HI = ? and NODE_ID_LO = ?";
+            bundleSelectSQL = "select BUNDLE_DATA from " + schemaObjectPrefix + "BUNDLE where NODE_ID_HI = ? and NODE_ID_LO = ?";
+            bundleDeleteSQL = "delete from " + schemaObjectPrefix + "BUNDLE where NODE_ID_HI = ? and NODE_ID_LO = ?";
+
+            nodeReferenceInsertSQL = "insert into " + schemaObjectPrefix + "REFS (REFS_DATA, NODE_ID_HI, NODE_ID_LO) values (?, ?, ?)";
+            nodeReferenceUpdateSQL = "update " + schemaObjectPrefix + "REFS set REFS_DATA = ? where NODE_ID_HI = ? and NODE_ID_LO = ?";
+            nodeReferenceSelectSQL = "select REFS_DATA from " + schemaObjectPrefix + "REFS where NODE_ID_HI = ? and NODE_ID_LO = ?";
+            nodeReferenceDeleteSQL = "delete from " + schemaObjectPrefix + "REFS where NODE_ID_HI = ? and NODE_ID_LO = ?";
+        }
+    }
+
+    /**
-        protected PreparedStatement blobInsert;
-        protected PreparedStatement blobUpdate;
-        protected PreparedStatement blobSelect;
-        protected PreparedStatement blobSelectExist;
-        protected PreparedStatement blobDelete;
+        protected String blobInsertSQL;
+        protected String blobUpdateSQL;
+        protected String blobSelectSQL;
+        protected String blobSelectExistSQL;
+        protected String blobDeleteSQL;
-            blobInsert =
-                    con.prepareStatement("insert into "
-                    + schemaObjectPrefix + "BINVAL (BINVAL_DATA, BINVAL_ID) values (?, ?)");
-            blobUpdate =
-                    con.prepareStatement("update "
-                    + schemaObjectPrefix + "BINVAL set BINVAL_DATA = ? where BINVAL_ID = ?");
-            blobSelect =
-                    con.prepareStatement("select BINVAL_DATA from "
-                    + schemaObjectPrefix + "BINVAL where BINVAL_ID = ?");
-            blobSelectExist =
-                    con.prepareStatement("select 1 from "
-                    + schemaObjectPrefix + "BINVAL where BINVAL_ID = ?");
-            blobDelete =
-                    con.prepareStatement("delete from "
-                    + schemaObjectPrefix + "BINVAL where BINVAL_ID = ?");
+            blobInsertSQL = "insert into " + schemaObjectPrefix + "BINVAL (BINVAL_DATA, BINVAL_ID) values (?, ?)";
+            blobUpdateSQL = "update " + schemaObjectPrefix + "BINVAL set BINVAL_DATA = ? where BINVAL_ID = ?";
+            blobSelectSQL = "select BINVAL_DATA from " + schemaObjectPrefix + "BINVAL where BINVAL_ID = ?";
+            blobSelectExistSQL = "select 1 from " + schemaObjectPrefix + "BINVAL where BINVAL_ID = ?";
+            blobDeleteSQL = "delete from " + schemaObjectPrefix + "BINVAL where BINVAL_ID = ?";
-            PreparedStatement stmt = blobSelect;
-            synchronized (stmt) {
-                try {
-                    stmt.setString(1, blobId);
-                    stmt.execute();
-                    final ResultSet rs = stmt.getResultSet();
-                    if (!rs.next()) {
-                        closeResultSet(rs);
-                        throw new Exception("no such BLOB: " + blobId);
-                    }
-                    InputStream in = rs.getBinaryStream(1);
-                    if (in == null) {
-                        // some databases treat zero-length values as NULL;
-                        // return empty InputStream in such a case
-                        closeResultSet(rs);
-                        return new ByteArrayInputStream(new byte[0]);
-                    }
-
-                    /**
-                     * return an InputStream wrapper in order to
-                     * close the ResultSet when the stream is closed
-                     */
-                    return new FilterInputStream(in) {
-                        public void close() throws IOException {
-                            in.close();
-                            // now it's safe to close ResultSet
-                            closeResultSet(rs);
-                        }
-                    };
-                } finally {
-                    resetStatement(stmt);
-                }
+            Statement stmt = connectionManager.executeStmt(blobSelectSQL, new Object[]{blobId});
+            final ResultSet rs = stmt.getResultSet();
+            if (!rs.next()) {
+                closeResultSet(rs);
+                throw new Exception("no such BLOB: " + blobId);
+            InputStream in = rs.getBinaryStream(1);
+            if (in == null) {
+                // some databases treat zero-length values as NULL;
+                // return empty InputStream in such a case
+                closeResultSet(rs);
+                return new ByteArrayInputStream(new byte[0]);
+            }
+
+            /**
+             * return an InputStream wrapper in order to
+             * close the ResultSet when the stream is closed
+             */
+            return new FilterInputStream(in) {
+                public void close() throws IOException {
+                    in.close();
+                    // now it's safe to close ResultSet
+                    closeResultSet(rs);
+                }
+            };
-            PreparedStatement stmt = blobSelectExist;
-            try {
-                stmt.setString(1, blobId);
-                stmt.execute();
-                ResultSet rs = stmt.getResultSet();
-                // a BLOB exists if the result has at least one entry
-                boolean exists = rs.next();
-                resetStatement(stmt);
-                closeResultSet(rs);
+            Statement stmt = connectionManager.executeStmt(blobSelectExistSQL, new Object[]{blobId});
+            ResultSet rs = stmt.getResultSet();
+            // a BLOB exists if the result has at least one entry
+            boolean exists = rs.next();
+            closeResultSet(rs);
-                stmt = (exists) ? blobUpdate : blobInsert;
-                stmt.setBinaryStream(1, in, (int) size);
-                stmt.setString(2, blobId);
-                stmt.executeUpdate();
-            } finally {
-                resetStatement(stmt);
-            }
+            String sql = (exists) ? blobUpdateSQL : blobInsertSQL;
+            Object[] params = new Object[]{new ConnectionRecoveryManager.StreamWrapper(in, size), blobId};
+            connectionManager.executeStmt(sql, params);
-            PreparedStatement stmt = blobDelete;
-            try {
-                stmt.setString(1, blobId);
-                return stmt.executeUpdate() == 1;
-            } finally {
-                resetStatement(stmt);
-            }
+            Statement stmt = connectionManager.executeStmt(blobDeleteSQL, new Object[]{blobId});
+            return stmt.getUpdateCount() == 1;
-            closeStatement(blobInsert);
-            closeStatement(blobUpdate);
-            closeStatement(blobSelect);
-            closeStatement(blobSelectExist);
-            closeStatement(blobDelete);
+            // closing the database resources of this blobstore is left to the
+            // owning BundleDbPersistenceManager
-

MOV26 MOV26 MOV26 MOV26 MOV31 UPD40 UPD40 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS29 INS83 INS39 INS59 INS43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 MOV83 INS39 INS42 INS44 INS8 INS83 INS43 INS42 INS8 MOV29 INS83 MOV83 MOV39 MOV42 MOV44 MOV43 INS8 MOV29 INS83 INS39 INS42 MOV44 MOV43 INS8 INS29 INS83 INS5 INS42 INS44 INS8 INS29 INS83 INS5 INS42 INS44 INS44 INS44 INS8 INS29 UPD83 UPD42 INS66 INS65 INS66 INS65 INS42 INS9 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV43 INS42 INS21 INS42 INS41 INS60 INS54 MOV25 MOV21 MOV21 INS21 MOV21 MOV21 MOV21 INS21 MOV21 MOV21 MOV21 MOV25 INS65 INS65 INS65 INS43 INS85 INS43 INS42 INS25 INS65 INS65 INS65 INS65 INS65 INS43 INS85 INS43 INS42 INS43 INS42 INS39 INS42 MOV60 INS25 MOV60 INS25 INS41 INS60 INS65 UPD43 UPD43 UPD43 UPD43 UPD43 MOV8 INS68 INS66 INS66 UPD66 INS7 INS32 MOV43 INS59 INS8 MOV12 INS8 INS7 INS32 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS27 INS8 INS8 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS42 UPD43 INS27 INS8 INS8 INS43 INS42 INS8 INS8 INS32 INS39 INS59 UPD43 INS66 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS60 INS60 MOV60 MOV60 MOV21 INS60 INS60 MOV21 INS60 MOV41 INS42 INS69 INS22 INS32 INS42 INS42 INS42 INS42 INS33 INS60 INS19 INS21 INS42 INS14 INS42 UPD42 INS60 INS60 INS32 INS42 INS41 INS41 UPD42 UPD42 INS14 INS32 INS42 MOV21 MOV21 MOV21 INS42 UPD42 INS14 MOV21 INS21 INS21 INS21 INS42 INS42 INS60 INS60 INS60 INS60 MOV21 INS60 INS42 MOV32 UPD42 UPD42 INS16 INS60 MOV21 INS60 INS43 INS59 UPD43 MOV43 INS59 INS43 INS59 INS5 INS59 UPD43 MOV43 INS59 INS43 INS52 INS42 INS32 INS42 INS32 INS39 INS59 INS8 INS9 UPD43 UPD42 INS54 INS25 INS53 INS32 INS43 INS42 INS32 INS32 INS32 INS32 MOV43 INS59 INS43 INS59 INS32 INS42 INS3 INS3 INS43 INS42 INS32 INS32 INS43 INS32 INS32 INS32 INS43 INS59 INS43 INS59 INS43 INS59 INS5 INS59 INS32 INS43 INS59 INS36 INS42 INS42 INS5 INS59 INS32 INS43 INS59 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 INS42 INS42 INS32 UPD42 MOV42 INS32 INS42 INS42 MOV16 INS43 INS85 INS42 INS3 UPD42 UPD42 INS42 INS42 UPD42 MOV42 INS32 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS9 INS54 UPD42 INS8 INS12 INS27 INS8 INS14 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 UPD42 MOV42 INS42 UPD42 INS5 INS4 INS5 INS4 INS42 UPD42 UPD42 INS32 INS42 INS42 INS14 INS42 INS42 INS14 INS42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS16 INS43 INS85 INS42 INS32 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS32 INS42 INS43 INS85 INS42 INS32 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS32 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV42 INS42 UPD42 MOV42 INS3 INS42 UPD42 MOV42 UPD42 MOV42 INS3 UPD42 UPD42 INS42 INS5 INS4 INS42 UPD42 MOV42 UPD42 MOV42 INS3 UPD42 INS32 MOV8 INS12 INS25 MOV44 INS8 INS62 INS62 INS21 MOV43 INS32 INS42 UPD42 MOV42 INS42 INS3 INS43 INS85 INS32 INS43 INS85 INS14 INS14 UPD42 MOV42 UPD42 MOV42 INS43 INS32 INS43 INS32 INS42 UPD42 MOV42 INS42 MOV32 INS42 UPD42 MOV42 INS42 MOV32 MOV32 INS42 INS42 INS42 INS42 MOV32 MOV32 INS9 UPD42 INS42 UPD42 MOV42 INS42 MOV32 INS42 INS42 MOV32 MOV32 INS9 UPD42 INS42 UPD42 MOV42 INS42 MOV32 INS5 INS4 INS5 INS4 INS43 INS85 INS14 INS42 INS5 INS4 UPD42 MOV42 INS42 INS21 INS21 INS21 INS21 MOV44 INS8 INS27 MOV8 INS21 INS42 MOV43 INS32 INS43 INS32 INS42 INS42 UPD42 MOV27 UPD42 MOV27 INS5 INS34 INS42 INS42 INS42 INS42 INS43 INS32 INS43 INS32 INS42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 MOV42 UPD45 UPD42 INS43 INS85 INS42 INS43 INS85 INS42 INS42 INS43 INS42 INS42 INS43 INS85 INS42 INS7 INS32 MOV32 MOV32 INS25 MOV53 INS42 INS33 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS43 INS85 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 INS42 INS42 INS40 INS42 INS42 INS32 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS8 INS42 INS45 UPD42 MOV42 INS42 INS42 INS42 INS21 INS18 INS7 INS42 INS9 DEL42 DEL45 DEL59 DEL60 DEL42 DEL32 DEL21 DEL43 DEL42 DEL42 DEL14 DEL53 DEL42 DEL44 DEL42 DEL44 DEL8 DEL12 DEL54 DEL8 DEL12 DEL54 DEL8 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL31 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL45 DEL45 DEL42 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL34 DEL21 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL34 DEL21 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL7 DEL21 DEL8 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL34 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL34 DEL42 DEL42 DEL34 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL34 DEL21 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL33 DEL42 DEL42 DEL7 DEL21 DEL8 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL34 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL34 DEL42 DEL42 DEL34 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL34 DEL21 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL8 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL34 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL51 DEL8 DEL42 DEL59 DEL60 DEL42 DEL34 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL7 DEL21 DEL42 DEL42 DEL34 DEL42 DEL39 DEL42 DEL11 DEL32 DEL21 DEL42 DEL42 DEL34 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL42 DEL59 DEL60 DEL34 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21
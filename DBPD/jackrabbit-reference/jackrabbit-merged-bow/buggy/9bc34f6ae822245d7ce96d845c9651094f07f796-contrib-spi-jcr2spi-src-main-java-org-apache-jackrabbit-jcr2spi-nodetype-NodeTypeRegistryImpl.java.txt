- new interface EffectiveNodeTypeProvider
- new interface ItemDefinitionProvider
- limit access to NodeTypeRegistry and simplify the NodeTypeRegistry
  interface.
- avoid duplicate code dealing with logic of EffectiveNodeType
  and retrieval of QItemDefinitions.


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@520408 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.state.NodeState;
+import org.apache.jackrabbit.jcr2spi.state.Status;
+import org.apache.jackrabbit.jcr2spi.hierarchy.PropertyEntry;
+import javax.jcr.nodetype.ConstraintViolationException;
-public class NodeTypeRegistryImpl implements Dumpable, NodeTypeRegistry {
+public class NodeTypeRegistryImpl implements Dumpable, NodeTypeRegistry, EffectiveNodeTypeProvider {
-
-
+    //---------------------------------------------------< NodeTypeRegistry >---
-     * @inheritDoc
+     * @see NodeTypeRegistry#addListener(NodeTypeRegistryListener)
-     * @inheritDoc
+     * @see NodeTypeRegistry#removeListener(NodeTypeRegistryListener)
-     * @inheritDoc
+     * @see NodeTypeRegistry#getRegisteredNodeTypes()
-     * @inheritDoc
+     * @see NodeTypeRegistry#isRegistered(QName)
-    /**
-     * @inheritDoc
+   /**
+     * @see NodeTypeRegistry#registerNodeType(QNodeTypeDefinition)
-    public QNodeDefinition getRootNodeDef() {
-        return rootNodeDef;
+    public synchronized EffectiveNodeType registerNodeType(QNodeTypeDefinition ntDef)
+            throws InvalidNodeTypeDefException, RepositoryException {
+        // validate the new nodetype definition
+        EffectiveNodeTypeImpl ent = validator.validateNodeTypeDef(ntDef, registeredNTDefs);
+
+        // persist new node type definition
+        storage.registerNodeTypes(new QNodeTypeDefinition[] {ntDef});
+
+        // update internal caches
+        internalRegister(ntDef, ent);
+
+        // notify listeners
+        notifyRegistered(ntDef.getQName());
+        return ent;
-     * @inheritDoc
+     * @see NodeTypeRegistry#registerNodeTypes(Collection)
+     */
+    public synchronized void registerNodeTypes(Collection ntDefs)
+            throws InvalidNodeTypeDefException, RepositoryException {
+
+        // validate new nodetype definitions
+        Map defMap = validator.validateNodeTypeDefs(ntDefs, registeredNTDefs);
+        storage.registerNodeTypes((QNodeTypeDefinition[])ntDefs.toArray(new QNodeTypeDefinition[ntDefs.size()]));
+
+        // update internal cache
+        internalRegister(defMap);
+
+        // notify listeners
+        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
+            QName ntName = ((QNodeTypeDefinition)iter.next()).getQName();
+            notifyRegistered(ntName);
+        }
+    }
+
+    /**
+     * @see NodeTypeRegistry#unregisterNodeType(QName)
+     */
+    public void unregisterNodeType(QName nodeTypeName) throws NoSuchNodeTypeException, RepositoryException {
+        HashSet ntNames = new HashSet();
+        ntNames.add(nodeTypeName);
+        unregisterNodeTypes(ntNames);
+    }
+
+    /**
+     * @see NodeTypeRegistry#unregisterNodeTypes(Collection)
+     */
+    public synchronized void unregisterNodeTypes(Collection nodeTypeNames)
+            throws NoSuchNodeTypeException, RepositoryException {
+        // do some preliminary checks
+        for (Iterator iter = nodeTypeNames.iterator(); iter.hasNext();) {
+            QName ntName = (QName) iter.next();
+            if (!registeredNTDefs.containsKey(ntName)) {
+                throw new NoSuchNodeTypeException(ntName.toString());
+            }
+
+            // check for node types other than those to be unregistered
+            // that depend on the given node types
+            Set dependents = getDependentNodeTypes(ntName);
+            dependents.removeAll(nodeTypeNames);
+            if (dependents.size() > 0) {
+                StringBuffer msg = new StringBuffer();
+                msg.append(ntName
+                        + " can not be removed because the following node types depend on it: ");
+                for (Iterator depIter = dependents.iterator(); depIter.hasNext();) {
+                    msg.append(depIter.next());
+                    msg.append(" ");
+                }
+                throw new RepositoryException(msg.toString());
+            }
+        }
+
+        // persist removal of node type definitions
+        // NOTE: conflict with existing content not asserted on client
+        storage.unregisterNodeTypes((QName[]) nodeTypeNames.toArray(new QName[nodeTypeNames.size()]));
+
+
+        // all preconditions are met, node types can now safely be unregistered
+        internalUnregister(nodeTypeNames);
+
+        // notify listeners
+        for (Iterator iter = nodeTypeNames.iterator(); iter.hasNext();) {
+            QName ntName = (QName) iter.next();
+            notifyUnregistered(ntName);
+        }
+    }
+
+    /**
+     * @see NodeTypeRegistry#reregisterNodeType(QNodeTypeDefinition)
+     */
+    public synchronized EffectiveNodeType reregisterNodeType(QNodeTypeDefinition ntd)
+            throws NoSuchNodeTypeException, InvalidNodeTypeDefException,
+            RepositoryException {
+        QName name = ntd.getQName();
+        if (!registeredNTDefs.containsKey(name)) {
+            throw new NoSuchNodeTypeException(name.toString());
+        }
+        /* validate new node type definition */
+        EffectiveNodeTypeImpl ent = validator.validateNodeTypeDef(ntd, registeredNTDefs);
+
+        // first call reregistering on storage
+        storage.reregisterNodeTypes(new QNodeTypeDefinition[]{ntd});
+
+        // unregister old node type definition
+        internalUnregister(name);
+        // register new definition
+        internalRegister(ntd, ent);
+
+        // notify listeners
+        notifyReRegistered(name);
+        return ent;
+    }
+
+    /**
+     * @see NodeTypeRegistry#getNodeTypeDefinition(QName)
+     */
+    public QNodeTypeDefinition getNodeTypeDefinition(QName nodeTypeName)
+        throws NoSuchNodeTypeException {
+        QNodeTypeDefinition def = (QNodeTypeDefinition) registeredNTDefs.get(nodeTypeName);
+        if (def == null) {
+            throw new NoSuchNodeTypeException(nodeTypeName.toString());
+        }
+        return def;
+    }
+    //------------------------------------------< EffectiveNodeTypeProvider >---
+    /**
+     * @see EffectiveNodeTypeProvider#getEffectiveNodeType(QName)
-     * @inheritDoc
+     * @see EffectiveNodeTypeProvider#getEffectiveNodeType(QName[])
-     * @inheritDoc
+     * @see EffectiveNodeTypeProvider#getEffectiveNodeType(QName[], Map)
+     * @see EffectiveNodeTypeProvider#getEffectiveNodeType(NodeState)
+     * @inheritDoc
+     * In case the status of the given node state is not {@link Status#EXISTING}
+     * the transiently added mixin types are taken into account as well.
+     */
+    public EffectiveNodeType getEffectiveNodeType(NodeState nodeState) throws ConstraintViolationException, NoSuchNodeTypeException {
+        try {
+            QName[] allNtNames;
+            if (nodeState.getStatus() == Status.EXISTING) {
+                allNtNames = nodeState.getNodeTypeNames();
+            } else {
+                // TODO: check if correct (and only used for creating new)
+                QName primaryType = nodeState.getNodeTypeName();
+                allNtNames = new QName[] { primaryType }; // default
+                PropertyEntry mixins = nodeState.getNodeEntry().getPropertyEntry(QName.JCR_MIXINTYPES);
+                if (mixins != null) {
+                    try {
+                        QValue[] values = mixins.getPropertyState().getValues();
+                        allNtNames = new QName[values.length + 1];
+                        for (int i = 0; i < values.length; i++) {
+                            allNtNames[i] = values[i].getQName();
+                        }
+                        allNtNames[values.length] = primaryType;
+                    } catch (RepositoryException e) {
+                        // ignore
+                    }
+                }
+            }
+            return getEffectiveNodeType(allNtNames);
+        } catch (NodeTypeConflictException e) {
+            String msg = "Internal error: failed to build effective node type from node types defined with " + nodeState;
+            log.debug(msg);
+            throw new ConstraintViolationException(msg, e);
+        }
+    }
+
+    /**
-    /**
-     * @inheritDoc
-     */
-    public synchronized EffectiveNodeType registerNodeType(QNodeTypeDefinition ntDef)
-            throws InvalidNodeTypeDefException, RepositoryException {
-        // validate the new nodetype definition
-        EffectiveNodeTypeImpl ent = validator.validateNodeTypeDef(ntDef, registeredNTDefs);
-        // persist new node type definition
-        storage.registerNodeTypes(new QNodeTypeDefinition[] {ntDef});
-
-        // update internal caches
-        internalRegister(ntDef, ent);
-
-        // notify listeners
-        notifyRegistered(ntDef.getQName());
-        return ent;
-    }
-
-    /**
-     * @inheritDoc
-     */
-    public synchronized void registerNodeTypes(Collection ntDefs)
-            throws InvalidNodeTypeDefException, RepositoryException {
-
-        // validate new nodetype definitions
-        Map defMap = validator.validateNodeTypeDefs(ntDefs, registeredNTDefs);
-        storage.registerNodeTypes((QNodeTypeDefinition[])ntDefs.toArray(new QNodeTypeDefinition[ntDefs.size()]));
-
-        // update internal cache
-        internalRegister(defMap);
-
-        // notify listeners
-        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
-            QName ntName = ((QNodeTypeDefinition)iter.next()).getQName();
-            notifyRegistered(ntName);
-        }
-    }
-
-    /**
-     * @inheritDoc
-     */
-    public void unregisterNodeType(QName nodeTypeName) throws NoSuchNodeTypeException, RepositoryException {
-        HashSet ntNames = new HashSet();
-        ntNames.add(nodeTypeName);
-        unregisterNodeTypes(ntNames);
-    }
-
-    /**
-     * @inheritDoc
-     */
-    public synchronized void unregisterNodeTypes(Collection nodeTypeNames)
-            throws NoSuchNodeTypeException, RepositoryException {
-        // do some preliminary checks
-        for (Iterator iter = nodeTypeNames.iterator(); iter.hasNext();) {
-            QName ntName = (QName) iter.next();
-            if (!registeredNTDefs.containsKey(ntName)) {
-                throw new NoSuchNodeTypeException(ntName.toString());
-            }
-
-            // check for node types other than those to be unregistered
-            // that depend on the given node types
-            Set dependents = getDependentNodeTypes(ntName);
-            dependents.removeAll(nodeTypeNames);
-            if (dependents.size() > 0) {
-                StringBuffer msg = new StringBuffer();
-                msg.append(ntName
-                        + " can not be removed because the following node types depend on it: ");
-                for (Iterator depIter = dependents.iterator(); depIter.hasNext();) {
-                    msg.append(depIter.next());
-                    msg.append(" ");
-                }
-                throw new RepositoryException(msg.toString());
-            }
-        }
-
-        // persist removal of node type definitions
-        // NOTE: conflict with existing content not asserted on client
-        storage.unregisterNodeTypes((QName[]) nodeTypeNames.toArray(new QName[nodeTypeNames.size()]));
-
-
-        // all preconditions are met, node types can now safely be unregistered
-        internalUnregister(nodeTypeNames);
-
-        // notify listeners
-        for (Iterator iter = nodeTypeNames.iterator(); iter.hasNext();) {
-            QName ntName = (QName) iter.next();
-            notifyUnregistered(ntName);
-        }
-    }
-
-    /**
-     * @inheritDoc
-     */
-    public synchronized EffectiveNodeType reregisterNodeType(QNodeTypeDefinition ntd)
-            throws NoSuchNodeTypeException, InvalidNodeTypeDefException,
-            RepositoryException {
-        QName name = ntd.getQName();
-        if (!registeredNTDefs.containsKey(name)) {
-            throw new NoSuchNodeTypeException(name.toString());
-        }
-        /* validate new node type definition */
-        EffectiveNodeTypeImpl ent = validator.validateNodeTypeDef(ntd, registeredNTDefs);
-
-        // first call reregistering on storage
-        storage.reregisterNodeTypes(new QNodeTypeDefinition[]{ntd});
-
-        // unregister old node type definition
-        internalUnregister(name);
-        // register new definition
-        internalRegister(ntd, ent);
-
-        // notify listeners
-        notifyReRegistered(name);
-        return ent;
-    }
-
-    /**
-     * @inheritDoc
-     */
-    public QNodeTypeDefinition getNodeTypeDefinition(QName nodeTypeName)
-        throws NoSuchNodeTypeException {
-        QNodeTypeDefinition def = (QNodeTypeDefinition) registeredNTDefs.get(nodeTypeName);
-        if (def == null) {
-            throw new NoSuchNodeTypeException(nodeTypeName.toString());
-        }
-        return def;
-    }

INS26 INS26 INS26 INS26 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 INS40 INS40 INS40 INS40 INS43 INS42 UPD43 UPD42 INS44 INS43 INS43 INS8 UPD65 UPD65 UPD65 UPD65 UPD65 UPD65 UPD65 UPD65 UPD65 UPD65 UPD65 UPD65 UPD65 INS65 UPD42 INS43 INS42 INS42 INS42 INS54 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS66 INS65 INS66 INS42 INS8 INS12 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS69 INS42 INS42 INS69 INS67 INS60 INS25 MOV41 INS44 INS8 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS5 INS5 INS43 INS43 INS42 INS42 INS5 INS59 INS27 INS8 INS8 INS32 INS43 INS42 INS60 INS21 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS85 INS43 INS85 INS42 INS42 INS43 INS85 INS42 INS32 INS40 INS21 INS60 INS21 INS60 INS25 INS42 INS42 INS42 INS43 INS59 INS32 INS14 INS42 INS42 INS42 INS42 INS42 INS7 INS43 INS59 INS7 INS43 INS59 INS27 INS8 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS3 INS42 INS42 INS32 INS42 INS33 INS54 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS5 INS4 INS32 INS42 INS40 INS8 INS12 INS43 INS85 INS42 INS42 INS42 INS60 INS21 INS24 INS21 INS44 INS8 INS42 INS5 INS59 INS7 INS58 INS27 INS37 INS8 INS7 INS43 INS42 INS43 INS85 INS42 INS32 INS42 INS3 INS39 INS59 INS42 INS40 INS42 INS21 INS2 INS42 INS42 INS42 INS32 INS42 INS5 INS27 INS42 INS34 INS7 INS42 INS40 INS42 INS42 INS43 INS85 INS40 INS34 INS2 INS32 INS42 INS42 INS42 INS2 INS42 INS42 INS42 DEL42 DEL8
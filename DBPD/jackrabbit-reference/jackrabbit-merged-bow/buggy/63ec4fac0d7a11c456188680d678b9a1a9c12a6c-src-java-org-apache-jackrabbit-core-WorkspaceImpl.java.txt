redesigned transaction support & PersistenceManager

orginal code contributed by dominique pfister, required a lot of tweaking to make it run & work; not thoroughly tested

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@126221 13f79535-47bb-0310-9956-ffa450edef68

-    protected final PersistentItemStateProvider persistentStateMgr;
-
-    /**
-     * The reference mgr associated with the workspace represented by <i>this</i>
-     * <code>Workspace</code> instance.
-     */
-    protected final ReferenceManager refMgr;
+    protected final LocalItemStateManager stateMgr;
-     * @param persistentStateMgr
+     * @param stateMgr
-    WorkspaceImpl(WorkspaceConfig wspConfig, PersistentItemStateProvider persistentStateMgr,
-                  ReferenceManager refMgr, RepositoryImpl rep, SessionImpl session) {
+    WorkspaceImpl(WorkspaceConfig wspConfig, SharedItemStateManager stateMgr,
+                  RepositoryImpl rep, SessionImpl session) {
-        this.persistentStateMgr = persistentStateMgr;
-        this.refMgr = refMgr;
-        hierMgr = new HierarchyManagerImpl(rep.getRootNodeUUID(), persistentStateMgr, session.getNamespaceResolver());
+        this.stateMgr = new LocalItemStateManager(stateMgr);
+        this.hierMgr = new HierarchyManagerImpl(rep.getRootNodeUUID(),
+                this.stateMgr, session.getNamespaceResolver());
-    public PersistentItemStateProvider getPersistentStateManager() {
-        return persistentStateMgr;
-    }
-
-    ReferenceManager getReferenceManager() {
-        return refMgr;
+    public LocalItemStateManager getItemStateManager() {
+        return stateMgr;
-    protected static PersistentNodeState getNodeState(String nodePath,
-                                                      NamespaceResolver nsResolver,
-                                                      HierarchyManagerImpl hierMgr,
-                                                      PersistentItemStateProvider stateMgr)
+    protected static NodeState getNodeState(String nodePath,
+                                            NamespaceResolver nsResolver,
+                                            HierarchyManagerImpl hierMgr,
+                                            ItemStateManager stateMgr)
-    protected static PersistentNodeState getParentNodeState(String path,
-                                                            NamespaceResolver nsResolver,
-                                                            HierarchyManagerImpl hierMgr,
-                                                            PersistentItemStateProvider stateMgr)
+    protected static NodeState getParentNodeState(String path,
+                                                  NamespaceResolver nsResolver,
+                                                  HierarchyManagerImpl hierMgr,
+                                                  ItemStateManager stateMgr)
-    protected static PersistentNodeState getNodeState(Path nodePath,
-                                                      HierarchyManagerImpl hierMgr,
-                                                      PersistentItemStateProvider stateMgr)
+    protected static NodeState getNodeState(Path nodePath,
+                                            HierarchyManagerImpl hierMgr,
+                                            ItemStateManager stateMgr)
-    protected static PersistentNodeState getNodeState(NodeId id,
-                                                      PersistentItemStateProvider stateMgr)
+    protected static NodeState getNodeState(NodeId id,
+                                            ItemStateManager stateMgr)
-        return (PersistentNodeState) stateMgr.getItemState(id);
+        return (NodeState) stateMgr.getItemState(id);
-                                       PersistentItemStateProvider stateMgr)
+                                       ItemStateManager stateMgr)
-        PersistentNodeState parentState = getNodeState(parentPath, hierMgr, stateMgr);
+        NodeState parentState = getNodeState(parentPath, hierMgr, stateMgr);
-                                          PersistentItemStateProvider stateMgr)
+                                          ItemStateManager stateMgr)
-        PersistentNodeState targetState = getNodeState(nodePath, hierMgr, stateMgr);
+        NodeState targetState = getNodeState(nodePath, hierMgr, stateMgr);
-        PersistentNodeState parentState = getNodeState(parentPath, hierMgr, stateMgr);
+        NodeState parentState = getNodeState(parentPath, hierMgr, stateMgr);
-        HashSet set = new HashSet(((NodeState) state).getMixinTypeNames());
+        HashSet set = new HashSet((state).getMixinTypeNames());
-    private static PersistentNodeState copyNodeState(NodeState srcState,
-                                                     String parentUUID,
-                                                     NodeTypeRegistry ntReg,
-                                                     HierarchyManagerImpl srcHierMgr,
-                                                     PersistentItemStateProvider srcStateMgr,
-                                                     PersistentItemStateProvider destStateMgr,
-                                                     boolean clone)
+    private static NodeState copyNodeState(NodeState srcState,
+                                           String parentUUID,
+                                           NodeTypeRegistry ntReg,
+                                           HierarchyManagerImpl srcHierMgr,
+                                           ItemStateManager srcStateMgr,
+                                           ItemStateManager destStateMgr,
+                                           boolean clone,
+                                           UpdateOperation update)
-        PersistentNodeState newState;
+
+        NodeState newState;
-            newState = destStateMgr.createNodeState(uuid, srcState.getNodeTypeName(), parentUUID);
+            newState = update.createNew(uuid, srcState.getNodeTypeName(), parentUUID);
-                PersistentNodeState newChildState = copyNodeState(srcChildState, uuid,
-                        ntReg, srcHierMgr, srcStateMgr, destStateMgr, clone);
+                NodeState newChildState = copyNodeState(srcChildState, uuid,
+                        ntReg, srcHierMgr, srcStateMgr, destStateMgr, clone, update);
-                newChildState.store();
+                update.store(newChildState);
-                PersistentPropertyState newChildState = copyPropertyState(srcChildState, uuid, entry.getName(),
-                        ntReg, srcHierMgr, srcStateMgr, destStateMgr);
+                PropertyState newChildState = copyPropertyState(srcChildState, uuid, entry.getName(),
+                        ntReg, srcHierMgr, srcStateMgr, destStateMgr, update);
-                newChildState.store();
+                update.store(newChildState);
-    private static PersistentPropertyState copyPropertyState(PropertyState srcState,
-                                                             String parentUUID,
-                                                             QName propName,
-                                                             NodeTypeRegistry ntReg,
-                                                             HierarchyManagerImpl srcHierMgr,
-                                                             PersistentItemStateProvider srcStateMgr,
-                                                             PersistentItemStateProvider destStateMgr)
+    private static PropertyState copyPropertyState(PropertyState srcState,
+                                                   String parentUUID,
+                                                   QName propName,
+                                                   NodeTypeRegistry ntReg,
+                                                   HierarchyManagerImpl srcHierMgr,
+                                                   ItemStateManager srcStateMgr,
+                                                   ItemStateManager destStateMgr,
+                                                   UpdateOperation update)
+
-        PersistentPropertyState newState;
-        try {
-            newState = destStateMgr.createPropertyState(parentUUID, propName);
-            PropDefId defId = srcState.getDefinitionId();
-            newState.setDefinitionId(defId);
-            newState.setType(srcState.getType());
-            newState.setMultiValued(srcState.isMultiValued());
-            InternalValue[] values = srcState.getValues();
-            if (values != null) {
-                InternalValue[] newValues = new InternalValue[values.length];
-                for (int i = 0; i < values.length; i++) {
-                    newValues[i] = values[i] != null ? values[i].createCopy() : null;
-                }
-                newState.setValues(values);
-                // FIXME delegate to 'node type instance handler'
-                if (defId != null) {
-                    PropDef def = ntReg.getPropDef(defId);
-                    if (def.getDeclaringNodeType().equals(NodeTypeRegistry.MIX_REFERENCEABLE)) {
-                        if (propName.equals(ItemImpl.PROPNAME_UUID)) {
-                            // set correct value of jcr:uuid property
-                            newState.setValues(new InternalValue[]{InternalValue.create(parentUUID)});
-                        }
+        PropertyState newState = update.createNew(propName, parentUUID);
+        PropDefId defId = srcState.getDefinitionId();
+        newState.setDefinitionId(defId);
+        newState.setType(srcState.getType());
+        newState.setMultiValued(srcState.isMultiValued());
+        InternalValue[] values = srcState.getValues();
+        if (values != null) {
+            InternalValue[] newValues = new InternalValue[values.length];
+            for (int i = 0; i < values.length; i++) {
+                newValues[i] = values[i] != null ? values[i].createCopy() : null;
+            }
+            newState.setValues(values);
+            // FIXME delegate to 'node type instance handler'
+            if (defId != null) {
+                PropDef def = ntReg.getPropDef(defId);
+                if (def.getDeclaringNodeType().equals(NodeTypeRegistry.MIX_REFERENCEABLE)) {
+                    if (propName.equals(ItemImpl.PROPNAME_UUID)) {
+                        // set correct value of jcr:uuid property
+                        newState.setValues(new InternalValue[]{InternalValue.create(parentUUID)});
-            return newState;
-        } catch (ItemStateException ise) {
-            String msg = "internal error: failed to copy state of " + srcHierMgr.safeGetJCRPath(srcState.getId());
-            log.error(msg, ise);
-            throw new RepositoryException(msg, ise);
+        return newState;
-                                     PersistentItemStateProvider srcStateMgr,
+                                     ItemStateManager srcStateMgr,
-                                     PersistentItemStateProvider destStateMgr,
+                                     ItemStateManager destStateMgr,
-        PersistentNodeState srcState;
+        NodeState srcState;
-        PersistentNodeState destParentState;
+        NodeState destParentState;
-/*
-	// check if target node needs to be inserted at specific location in child node entries list
-	boolean insertTargetEntry = false;
-	int ind = destName.getIndex();
-	if (ind > 0) {
-	    // target name contains subscript:
-	    // validate subscript
-	    List sameNameSibs = destParentState.getChildNodeEntries(destName.getName());
-	    if (ind > sameNameSibs.size() + 1) {
-		String msg = "invalid subscript in name: " + destAbsPath;
-		log.error(msg);
-		throw new RepositoryException(msg);
-	    }
-	    insertTargetEntry = (ind < sameNameSibs.size() + 1) ? true : false;
-	}
-	if (insertTargetEntry) {
-	    // check hasOrderableChildNodes flag
-	    if (!ntReg.getNodeTypeDef(destParentState.getNodeTypeName()).hasOrderableChildNodes()) {
-		throw new ConstraintViolationException(destAbsPath + ": parent node's node type does not allow explicit ordering of child nodes");
-	    }
-	}
-*/
+
-
-        // create deep copy of source node state
-        PersistentNodeState newState = copyNodeState(srcState, destParentState.getUUID(),
-                ntReg, srcHierMgr, srcStateMgr, destStateMgr, clone);
-
-        // add to new parent
-        destParentState.addChildNodeEntry(destName.getName(), newState.getUUID());
-/*
-	if (!insertTargetEntry) {
-	    // append target entry
-	    destParentState.addChildNodeEntry(destName.getName(), newState.getUUID());
-	} else {
-	    // insert target entry at specified position
-	    Iterator iter = new ArrayList(destParentState.getChildNodeEntries()).iterator();
-	    destParentState.removeAllChildNodeEntries();
-	    while (iter.hasNext()) {
-		NodeState.ChildNodeEntry entry = (NodeState.ChildNodeEntry) iter.next();
-		if (entry.getName().equals(destName.getName()) &&
-			entry.getIndex() == destName.getIndex()) {
-		    destParentState.addChildNodeEntry(destName.getName(), newState.getUUID());
-		}
-		destParentState.addChildNodeEntry(entry.getName(), entry.getUUID());
-	    }
-	}
-*/
-        // change definition (id) of new node
-        ChildNodeDef newNodeDef = findApplicableDefinition(destName.getName(), srcState.getNodeTypeName(), destParentState, ntReg);
-        newState.setDefinitionId(new NodeDefId(newNodeDef));
-
-        // persist states
-            newState.store();
-            destParentState.store();
+            UpdateOperation update = destStateMgr.beginUpdate();
+
+            // create deep copy of source node state
+            NodeState newState = copyNodeState(srcState, destParentState.getUUID(),
+                    ntReg, srcHierMgr, srcStateMgr, destStateMgr, clone, update);
+
+            // add to new parent
+            destParentState.addChildNodeEntry(destName.getName(), newState.getUUID());
+
+            // change definition (id) of new node
+            ChildNodeDef newNodeDef = findApplicableDefinition(destName.getName(), srcState.getNodeTypeName(), destParentState, ntReg);
+            newState.setDefinitionId(new NodeDefId(newNodeDef));
+
+            // persist states
+            update.store(newState);
+            update.store(destParentState);
+
+            // finish update operations
+            update.end();
-        PersistentItemStateProvider srcStateMgr = rep.getWorkspaceStateManager(srcWorkspace);
+        ItemStateManager srcStateMgr = rep.getWorkspaceStateManager(srcWorkspace);
-                destAbsPath, persistentStateMgr, hierMgr,
+                destAbsPath, stateMgr, hierMgr,
-        internalCopy(srcAbsPath, persistentStateMgr, hierMgr,
-                destAbsPath, persistentStateMgr, hierMgr,
+        internalCopy(srcAbsPath, stateMgr, hierMgr,
+                destAbsPath, stateMgr, hierMgr,
-        PersistentItemStateProvider srcStateMgr = rep.getWorkspaceStateManager(srcWorkspace);
+        ItemStateManager srcStateMgr = rep.getWorkspaceStateManager(srcWorkspace);
-                destAbsPath, persistentStateMgr, hierMgr,
+                destAbsPath, stateMgr, hierMgr,
-
-        PersistentNodeState targetState;
-        PersistentNodeState srcParentState;
+        NodeState targetState;
+        NodeState srcParentState;
+
-            targetState = getNodeState(srcPath, hierMgr, persistentStateMgr);
-            srcParentState = getNodeState(srcParentPath, hierMgr, persistentStateMgr);
+            targetState = getNodeState(srcPath, hierMgr, stateMgr);
+            srcParentState = getNodeState(srcParentPath, hierMgr, stateMgr);
-        PersistentNodeState destParentState;
+        NodeState destParentState;
+
-            destParentState = getNodeState(destParentPath, hierMgr, persistentStateMgr);
+            destParentState = getNodeState(destParentPath, hierMgr, stateMgr);
+
-        checkRemoveNode(srcPath, rep.getNodeTypeRegistry(), session.getAccessManager(), hierMgr, persistentStateMgr);
+        checkRemoveNode(srcPath, rep.getNodeTypeRegistry(),
+                session.getAccessManager(), hierMgr, stateMgr);
-                hierMgr, persistentStateMgr);
-/*
-	// check if target node needs to be inserted at specific location in child node entries list
-	boolean insertTargetEntry = false;
-	int ind = destName.getIndex();
-	if (ind > 0) {
-	    // target name contains subscript:
-	    // validate subscript
-	    List sameNameSibs = destParentState.getChildNodeEntries(destName.getName());
-	    if (ind > sameNameSibs.size() + 1) {
-		String msg = "invalid subscript in name: " + destAbsPath;
-		log.error(msg);
-		throw new RepositoryException(msg);
-	    }
-	    insertTargetEntry = (ind < sameNameSibs.size() + 1) ? true : false;
-	}
-	if (insertTargetEntry) {
-	    // check hasOrderableChildNodes flag
-	    if (!rep.getNodeTypeRegistry().getNodeTypeDef(destParentState.getNodeTypeName()).hasOrderableChildNodes()) {
-		throw new ConstraintViolationException(destAbsPath + ": parent node's node type does not allow explicit ordering of child nodes");
-	    }
-	}
-*/
+                hierMgr, stateMgr);
+
-
-        boolean renameOnly = srcParentState.getUUID().equals(destParentState.getUUID());
-
-        // add to new parent
-        if (!renameOnly) {
-            targetState.addParentUUID(destParentState.getUUID());
-        }
-        destParentState.addChildNodeEntry(destName.getName(), targetState.getUUID());
-/*
-	if (!insertTargetEntry) {
-	    // append target entry
-	    destParentState.addChildNodeEntry(destName.getName(), targetState.getUUID());
-	} else {
-	    // insert target entry at specified position
-	    Iterator iter = new ArrayList(destParentState.getChildNodeEntries()).iterator();
-	    destParentState.removeAllChildNodeEntries();
-	    while (iter.hasNext()) {
-		NodeState.ChildNodeEntry entry = (NodeState.ChildNodeEntry) iter.next();
-		if (entry.getName().equals(destName.getName()) &&
-			entry.getIndex() == destName.getIndex()) {
-		    destParentState.addChildNodeEntry(destName.getName(), targetState.getUUID());
-		}
-		destParentState.addChildNodeEntry(entry.getName(), entry.getUUID());
-	    }
-	}
-*/
-        // change definition (id) of target node
-        ChildNodeDef newTargetDef = findApplicableDefinition(destName.getName(), targetState.getNodeTypeName(), destParentState, rep.getNodeTypeRegistry());
-        targetState.setDefinitionId(new NodeDefId(newTargetDef));
-
-        // remove from old parent
-        if (!renameOnly) {
-            targetState.removeParentUUID(srcParentState.getUUID());
-        }
-        int srcNameIndex = srcName.getIndex() == 0 ? 1 : srcName.getIndex();
-/*
-	// if the net result of the move is changing the position of a child node
-	// among its same-same siblings, the subscript of the child node entry
-	// to be removed might need adjustment
-	if (renameOnly && srcName.getName().equals(destName.getName()) &&
-		insertTargetEntry && destName.getIndex() <= srcNameIndex) {
-	    srcNameIndex++;
-	}
-*/
-        srcParentState.removeChildNodeEntry(srcName.getName(), srcNameIndex);
-
-        // persist states
-            targetState.store();
-            if (renameOnly) {
-                srcParentState.store();
-            } else {
-                destParentState.store();
-                srcParentState.store();
+            UpdateOperation update = stateMgr.beginUpdate();
+            boolean renameOnly = srcParentState.getUUID().equals(destParentState.getUUID());
+
+            // add to new parent
+            if (!renameOnly) {
+                targetState.addParentUUID(destParentState.getUUID());
+            destParentState.addChildNodeEntry(destName.getName(), targetState.getUUID());
+
+            // change definition (id) of target node
+            ChildNodeDef newTargetDef = findApplicableDefinition(destName.getName(), targetState.getNodeTypeName(), destParentState, rep.getNodeTypeRegistry());
+            targetState.setDefinitionId(new NodeDefId(newTargetDef));
+
+            // remove from old parent
+            if (!renameOnly) {
+                targetState.removeParentUUID(srcParentState.getUUID());
+            }
+
+            int srcNameIndex = srcName.getIndex() == 0 ? 1 : srcName.getIndex();
+            srcParentState.removeChildNodeEntry(srcName.getName(), srcNameIndex);
+
+            // persist states
+            update.store(targetState);
+            if (renameOnly) {
+                update.store(srcParentState);
+            } else {
+                update.store(destParentState);
+                update.store(srcParentState);
+            }
+
+            // finish update
+            update.end();
-        PersistentNodeState state;
+        NodeState state;
-            state = getNodeState(path, hierMgr, persistentStateMgr);
+            state = getNodeState(path, hierMgr, stateMgr);
-                persistentStateMgr, (NamespaceRegistryImpl) rep.getNamespaceRegistry(),
+                stateMgr, rep.getNamespaceRegistry(),
-        PersistentNodeState state;
+        NodeState state;
-            state = getNodeState(path, hierMgr, persistentStateMgr);
+            state = getNodeState(path, hierMgr, stateMgr);
-                persistentStateMgr, (NamespaceRegistryImpl) rep.getNamespaceRegistry(),
+                stateMgr, rep.getNamespaceRegistry(),

UPD43 UPD43 UPD42 UPD43 UPD43 UPD43 UPD43 UPD43 INS44 UPD43 INS44 MOV8 INS8 MOV8 UPD42 UPD42 UPD43 UPD42 UPD42 UPD42 UPD43 UPD42 UPD43 UPD42 UPD43 UPD42 UPD43 UPD43 UPD43 UPD42 UPD43 UPD43 INS43 INS42 UPD42 UPD43 UPD43 UPD43 MOV43 UPD42 MOV42 INS60 UPD43 UPD43 INS54 MOV60 MOV60 INS21 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD43 UPD42 UPD43 UPD43 MOV43 UPD42 UPD42 INS42 MOV43 UPD42 UPD42 UPD42 INS43 INS59 UPD42 UPD42 UPD43 UPD43 INS8 MOV12 UPD43 INS32 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 INS14 INS22 UPD43 UPD42 UPD42 UPD42 INS42 INS42 INS32 UPD42 UPD42 INS60 MOV60 MOV21 MOV60 MOV21 MOV21 MOV21 INS21 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 MOV32 MOV32 INS9 UPD42 UPD42 UPD42 UPD9 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS60 MOV60 MOV25 MOV21 MOV60 MOV21 MOV25 MOV60 MOV21 INS21 UPD42 UPD42 UPD42 INS43 INS42 INS52 INS42 INS22 UPD42 MOV43 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS43 INS59 UPD43 INS32 INS43 INS59 INS32 UPD42 MOV32 UPD42 MOV32 INS42 INS52 INS42 INS42 INS42 INS32 UPD42 UPD42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS32 UPD42 INS42 INS42 INS42 INS42 UPD42 UPD42 UPD43 UPD43 INS42 INS42 INS42 UPD42 UPD42 UPD42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 INS42 UPD42 INS42 UPD42 INS42 UPD42 INS42 INS42 INS42 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL42 DEL43 DEL42 DEL44 DEL42 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL41 DEL8 DEL31 DEL42 DEL11 DEL42 DEL43 DEL42 DEL32 DEL7 DEL21 DEL42 DEL43 DEL42 DEL59 DEL60 DEL44 DEL42 DEL43 DEL42 DEL45 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL8 DEL54 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL42 DEL43 DEL11 DEL42 DEL43 DEL11
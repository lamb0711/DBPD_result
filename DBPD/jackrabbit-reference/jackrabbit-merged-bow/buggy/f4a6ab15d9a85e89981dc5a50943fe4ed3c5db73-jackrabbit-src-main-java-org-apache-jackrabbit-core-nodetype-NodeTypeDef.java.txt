JCR-275: added NodeTypeRegistry.unregisterNodeTypes(Collection)
- some additional cleaning up of implementation

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@376692 13f79535-47bb-0310-9956-ffa450edef68

+        primaryItemName = null;
-    public Object clone() throws CloneNotSupportedException {
-        // create a shallow copy
-        NodeTypeDef clone = (NodeTypeDef) super.clone();
-        // clear dependencies (will be lazily built)
-        clone.resetDependencies();
-        return clone;
-    }
-
-    public boolean equals(Object obj) {
-        if (this == obj) {
-            return true;
-        }
-        if (obj instanceof NodeTypeDef) {
-            NodeTypeDef other = (NodeTypeDef) obj;
-            return (name == null ? other.name == null : name.equals(other.name))
-                    && (primaryItemName == null ? other.primaryItemName == null : primaryItemName.equals(other.primaryItemName))
-                    && Arrays.equals(supertypes, other.supertypes)
-                    && mixin == other.mixin
-                    && orderableChildNodes == other.orderableChildNodes
-                    && Arrays.equals(propDefs, other.propDefs)
-                    && Arrays.equals(nodeDefs, other.nodeDefs);
-        }
-        return false;
-    }
-
-    /**
-     * Returns zero to satisfy the Object equals/hashCode contract.
-     * This class is mutable and not meant to be used as a hash key.
-     *
-     * @return always zero
-     * @see Object#hashCode()
-     */
-    public int hashCode() {
-        return 0;
-    }
-
+    //----------------------------------------------------< setters & getters >
+        resetDependencies();
+
+    //-------------------------------------------< java.lang.Object overrides >
+    public Object clone() {
+        NodeTypeDef clone = new NodeTypeDef();
+        clone.name = name;
+        clone.primaryItemName = primaryItemName;
+        clone.supertypes = (QName[]) supertypes.clone();
+        clone.mixin = mixin;
+        clone.orderableChildNodes = orderableChildNodes;
+        clone.nodeDefs = (NodeDef[]) nodeDefs.clone();
+        clone.propDefs = (PropDef[]) propDefs.clone();
+        return clone;
+    }
+
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj instanceof NodeTypeDef) {
+            NodeTypeDef other = (NodeTypeDef) obj;
+            return (name == null ? other.name == null : name.equals(other.name))
+                    && (primaryItemName == null ? other.primaryItemName == null : primaryItemName.equals(other.primaryItemName))
+                    && Arrays.equals(supertypes, other.supertypes)
+                    && mixin == other.mixin
+                    && orderableChildNodes == other.orderableChildNodes
+                    && Arrays.equals(propDefs, other.propDefs)
+                    && Arrays.equals(nodeDefs, other.nodeDefs);
+        }
+        return false;
+    }
+
+    /**
+     * Returns zero to satisfy the Object equals/hashCode contract.
+     * This class is mutable and not meant to be used as a hash key.
+     *
+     * @return always zero
+     * @see Object#hashCode()
+     */
+    public int hashCode() {
+        return 0;
+    }

MOV31 MOV31 MOV31 INS8 INS21 INS21 MOV60 INS21 INS21 INS21 INS21 INS21 MOV21 INS21 MOV41 INS7 INS32 MOV43 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS42 INS33 INS42 INS14 INS40 INS42 INS40 INS42 INS40 INS11 INS40 INS42 INS40 INS42 INS40 INS11 INS40 INS11 MOV43 INS5 INS32 INS5 INS32 INS5 INS32 INS43 INS85 INS42 INS42 INS43 INS85 INS42 MOV42 INS43 INS85 INS42 INS42 UPD42 MOV42 INS42 INS42 DEL42 DEL48 DEL11 DEL42 DEL32 DEL43 DEL8
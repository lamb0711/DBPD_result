JCR-2087: Upgrade to Java 5 as the base platform

Some more Java 5 cleanups.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@795046 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.HashMap;
+import java.util.Map;
-import org.apache.commons.collections.iterators.IteratorChain;
-    private void validateTransientItems(Iterator<ItemState> dirtyIter, Iterator<ItemState> removedIter)
+    /**
+     * the following validations/checks are performed on transient items:
+     *
+     * for every transient item:
+     * - if it is 'modified' or 'new' check the corresponding write permission.
+     * - if it is 'removed' check the REMOVE permission
+     *
+     * for every transient node:
+     * - if it is 'new' check that its node type satisfies the
+     *   'required node type' constraint specified in its definition
+     * - check if 'mandatory' child items exist
+     *
+     * for every transient property:
+     * - check if the property value satisfies the value constraints
+     *   specified in the property's definition
+     *
+     * note that the protected flag is checked in Node.addNode/Node.remove
+     * (for adding/removing child entries of a node), in
+     * Node.addMixin/removeMixin/setPrimaryType (for type changes on nodes)
+     * and in Property.setValue (for properties to be modified).
+     */
+    private void validateTransientItems(Iterable<ItemState> dirty, Iterable<ItemState> removed)
-        /**
-         * the following validations/checks are performed on transient items:
-         *
-         * for every transient item:
-         * - if it is 'modified' or 'new' check the corresponding write permission.
-         * - if it is 'removed' check the REMOVE permission
-         *
-         * for every transient node:
-         * - if it is 'new' check that its node type satisfies the
-         *   'required node type' constraint specified in its definition
-         * - check if 'mandatory' child items exist
-         *
-         * for every transient property:
-         * - check if the property value satisfies the value constraints
-         *   specified in the property's definition
-         *
-         * note that the protected flag is checked in Node.addNode/Node.remove
-         * (for adding/removing child entries of a node), in
-         * Node.addMixin/removeMixin/setPrimaryType (for type changes on nodes)
-         * and in Property.setValue (for properties to be modified).
-         */
-        while (dirtyIter.hasNext()) {
-            ItemState itemState = dirtyIter.next();
+        for (ItemState itemState : dirty) {
-        while (removedIter.hasNext()) {
-            ItemState itemState = removedIter.next();
+        for (ItemState itemState : removed) {
-    private void removeTransientItems(Iterator<ItemState> iter) {
-
-        /**
-         * walk through list of transient items marked 'removed' and
-         * definitively remove each one
-         */
-        while (iter.hasNext()) {
-            ItemState transientState = iter.next();
+    /**
+     * walk through list of transient items marked 'removed' and
+     * definitively remove each one
+     */
+    private void removeTransientItems(Iterable<ItemState> states) {
+        for (ItemState transientState : states) {
-    private void persistTransientItems(Iterator<ItemState> iter)
+    /**
+     * walk through list of transient items and persist each one
+     */
+    private void persistTransientItems(Iterable<ItemState> states)
-
-        // walk through list of transient items and persist each one
-        while (iter.hasNext()) {
-            ItemState state = iter.next();
-            ItemImpl item = itemMgr.getItem(state.getId());
+        for (ItemState state : states) {
-            item.makePersistent();
+            itemMgr.getItem(state.getId()).makePersistent();
-    private void restoreTransientItems(Iterator<ItemState> iter) {
-        // walk through list of transient states and re-apply transient changes
-        while (iter.hasNext()) {
-            ItemState itemState = iter.next();
+    /**
+     * walk through list of transient states and re-apply transient changes
+     */
+    private void restoreTransientItems(Iterable<ItemState> items) {
+        for (ItemState itemState : items) {
-    private void processShareableNodes(Iterator<ItemState> iter) throws RepositoryException {
-        while (iter.hasNext()) {
-            ItemState is = iter.next();
+    private void processShareableNodes(Iterable<ItemState> states) throws RepositoryException {
+        for (ItemState is : states) {
-     * @param iter
+     * @param states
-    private boolean initVersionHistories(Iterator<ItemState> iter) throws RepositoryException {
+    private boolean initVersionHistories(Iterable<ItemState> states) throws RepositoryException {
-        while (iter.hasNext()) {
-            ItemState itemState = iter.next();
+        for (ItemState itemState : states) {
-            /**
-             * build set of item id's which are within the scope of
-             * (i.e. affected by) this save operation
-             */
-            Set<ItemId> affectedIds = new HashSet<ItemId>(dirty.size() + removed.size());
-            for (Iterator<ItemState> it =
-                    new IteratorChain(dirty.iterator(), removed.iterator());
-                 it.hasNext();) {
-                affectedIds.add(it.next().getId());
+            // All affected item states. They keys are used to look up whether
+            // an item is affected, and the values are iterated through below
+            Map<ItemId, ItemState> affected =
+                new HashMap<ItemId, ItemState>(dirty.size() + removed.size());
+            for (ItemState state : dirty) {
+                affected.put(state.getId(), state);
+            }
+            for (ItemState state : removed) {
+                affected.put(state.getId(), state);
-            for (Iterator<ItemState> it =
-                    new IteratorChain(dirty.iterator(), removed.iterator());
-                 it.hasNext();) {
-                ItemState transientState = it.next();
+            for (ItemState transientState : affected.values()) {
-                                    if (!affectedIds.contains(newParentId)
+                                    if (!affected.containsKey(newParentId)
-                                            for (Iterator<ChildNodeEntry> cneIt =
-                                                    parent.getRenamedChildNodeEntries().iterator();
-                                                 cneIt.hasNext();) {
-                                                ChildNodeEntry cne =
-                                                        cneIt.next();
+                                            for (ChildNodeEntry cne : parent.getRenamedChildNodeEntries()) {
-                    for (Iterator<ChildNodeEntry> cneIt =
-                            nodeState.getRemovedChildNodeEntries().iterator();
-                         cneIt.hasNext();) {
-                        ChildNodeEntry cne = cneIt.next();
+                    for (ChildNodeEntry cne : nodeState.getRemovedChildNodeEntries()) {
-                    for (Iterator<ChildNodeEntry> cneIt =
-                            nodeState.getAddedChildNodeEntries().iterator();
-                         cneIt.hasNext();) {
-                        ChildNodeEntry cne = cneIt.next();
+                    for (ChildNodeEntry cne : nodeState.getAddedChildNodeEntries()) {
-                    Iterator<NodeId> depIt = dependentIDs.iterator();
-                    while (depIt.hasNext()) {
-                        NodeId id = depIt.next();
-                        if (!affectedIds.contains(id)) {
+                    for (NodeId id : dependentIDs) {
+                        if (!affected.containsKey(id)) {
-            /**
-             * validate access and node type constraints
-             * (this will also validate child removals)
-             */
-            validateTransientItems(dirty.iterator(), removed.iterator());
+            // validate access and node type constraints
+            // (this will also validate child removals)
+            validateTransientItems(dirty, removed);
-                removeTransientItems(removed.iterator());
+                removeTransientItems(removed);
-                processShareableNodes(dirty.iterator());
+                processShareableNodes(dirty);
-                if (initVersionHistories(dirty.iterator())) {
+                if (initVersionHistories(dirty)) {
-                persistTransientItems(dirty.iterator());
+                persistTransientItems(dirty);
-                for (Iterator<ItemState> it = dirty.iterator(); it.hasNext();) {
-                    ItemState transientState = it.next();
+                for (ItemState transientState : dirty) {
-                    restoreTransientItems(dirty.iterator());
+                    restoreTransientItems(dirty);
-            for (Iterator<ItemState> it = removed.iterator(); it.hasNext();) {
-                ItemState transientState = it.next();
+            for (ItemState transientState : removed) {
-        Iterator<ItemState> iter = list.iterator();
-        while (iter.hasNext()) {
-            transientState = iter.next();
+        for (ItemState state : list) {
-            stateMgr.disposeTransientItemState(transientState);
+            stateMgr.disposeTransientItemState(state);
-            iter = stateMgr.getDescendantTransientItemStatesInAttic((NodeId) id);
+            Iterator<ItemState> iter = stateMgr.getDescendantTransientItemStatesInAttic((NodeId) id);

MOV26 INS26 UPD40 INS40 INS29 INS29 INS29 INS8 INS29 INS65 UPD74 UPD42 UPD74 UPD42 INS70 INS70 INS65 UPD74 UPD42 INS70 INS65 UPD74 UPD42 INS70 INS65 UPD74 UPD42 INS70 UPD74 UPD42 INS70 UPD74 UPD42 INS70 INS70 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 UPD43 UPD43 INS44 INS42 MOV8 INS44 INS42 MOV8 INS66 INS66 UPD43 INS44 INS42 MOV8 INS66 UPD43 INS44 INS42 INS8 INS66 UPD43 INS44 INS42 MOV8 UPD43 INS44 INS42 MOV8 UPD42 UPD43 INS44 INS42 MOV8 INS44 INS42 INS8 UPD42 UPD42 MOV43 INS42 MOV43 INS42 UPD42 MOV43 INS42 UPD42 MOV43 INS42 MOV21 UPD42 MOV43 INS42 UPD42 MOV43 INS42 UPD42 MOV43 INS42 INS70 INS70 INS70 INS70 MOV43 INS42 MOV21 INS60 UPD74 INS44 INS42 INS8 INS44 INS42 INS8 INS44 INS32 MOV8 INS44 INS42 MOV8 MOV74 INS59 MOV32 UPD43 MOV43 INS43 UPD42 INS43 INS42 MOV21 INS43 INS42 INS21 MOV43 INS42 UPD42 MOV42 UPD42 MOV42 MOV42 MOV42 INS70 MOV43 INS42 UPD42 INS42 MOV32 UPD42 INS42 UPD74 MOV42 UPD42 MOV42 INS32 INS44 INS42 MOV8 UPD43 MOV43 INS43 UPD42 UPD42 MOV32 UPD42 MOV42 INS42 INS42 INS32 UPD42 MOV42 INS70 INS70 INS70 MOV42 MOV42 MOV42 MOV42 INS43 INS42 UPD42 INS42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 INS44 MOV32 MOV8 INS44 MOV32 MOV8 INS44 INS42 MOV8 MOV42 MOV43 INS42 MOV43 INS42 MOV43 INS42 MOV42 UPD42 UPD42 UPD42 UPD42 INS70 INS44 MOV32 MOV8 MOV43 INS42 MOV42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL42 DEL42 DEL32 DEL61 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL8 DEL61 DEL8 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL32 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL43 DEL74 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL42 DEL43 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL14 DEL59 DEL58 DEL42 DEL42 DEL32 DEL8 DEL24 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL32 DEL42 DEL32 DEL14 DEL59 DEL58 DEL32 DEL24 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL61 DEL42 DEL7 DEL21
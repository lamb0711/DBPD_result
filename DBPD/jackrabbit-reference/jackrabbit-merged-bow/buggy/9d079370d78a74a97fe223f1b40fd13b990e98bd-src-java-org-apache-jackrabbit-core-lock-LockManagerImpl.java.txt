True caching in CachingHierarchyManager

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@190372 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.commons.collections.SequencedHashMap;
-import java.util.Map;
-import java.util.HashMap;
+import java.util.Iterator;
-    /**`
-     * Map of nodes that been removed and may be re-added as result
-     * of a move operation
-     */
-    private final Map zombieNodes = new HashMap();
-
-        lockMap.traverse(new PathMap.ChildVisitor() {
-            public void childVisited(PathMap.Child child) {
-                LockInfo info = (LockInfo) child.get();
+        lockMap.traverse(new PathMap.ElementVisitor() {
+            public void elementVisited(PathMap.Element element) {
+                LockInfo info = (LockInfo) element.get();
-        PathMap.Child child = lockMap.map(path, false);
+        PathMap.Element element = lockMap.map(path, false);
-        LockInfo other = (LockInfo) child.get();
+        LockInfo other = (LockInfo) element.get();
-            if (child.hasPath(path)) {
+            if (element.hasPath(path)) {
-        if (info.deep && child.hasPath(path)) {
+        if (info.deep && element.hasPath(path)) {
-            PathMap.Child child = lockMap.map(path, true);
-            if (child != null) {
-                child.set(null);
+            PathMap.Element element = lockMap.map(path, true);
+            if (element != null) {
+                element.set(null);
-        PathMap.Child child = lockMap.map(path, false);
-        LockInfo info = (LockInfo) child.get();
+        PathMap.Element element = lockMap.map(path, false);
+        LockInfo info = (LockInfo) element.get();
-        if (child.hasPath(path) || info.deep) {
+        if (element.hasPath(path) || info.deep) {
-        PathMap.Child child = lockMap.map(path, true);
-        if (child == null) {
+        PathMap.Element element = lockMap.map(path, true);
+        if (element == null) {
-        LockInfo info = (LockInfo) child.get();
+        LockInfo info = (LockInfo) element.get();
-        child.set(null);
+        element.set(null);
-        PathMap.Child child = lockMap.map(node.getPrimaryPath(), true);
-        if (child == null) {
+        PathMap.Element element = lockMap.map(node.getPrimaryPath(), true);
+        if (element == null) {
-        return child.get() != null;
+        return element.get() != null;
-        PathMap.Child child = lockMap.map(path, false);
-        LockInfo info = (LockInfo) child.get();
+        PathMap.Element element = lockMap.map(path, false);
+        LockInfo info = (LockInfo) element.get();
-        if (child.hasPath(path)) {
+        if (element.hasPath(path)) {
-        PathMap.Child child = lockMap.map(path, false);
-        LockInfo info = (LockInfo) child.get();
+        PathMap.Element element = lockMap.map(path, false);
+        LockInfo info = (LockInfo) element.get();
-            if (child.hasPath(path) || info.deep) {
+            if (element.hasPath(path) || info.deep) {
-            PathMap.Child child = lockMap.map(node.getPrimaryPath(), true);
-            if (child != null) {
-                LockInfo info = (LockInfo) child.get();
+            PathMap.Element element = lockMap.map(node.getPrimaryPath(), true);
+            if (element != null) {
+                LockInfo info = (LockInfo) element.get();
-            PathMap.Child child = lockMap.map(node.getPrimaryPath(), true);
-            if (child != null) {
-                LockInfo info = (LockInfo) child.get();
+            PathMap.Element element = lockMap.map(node.getPrimaryPath(), true);
+            if (element != null) {
+                LockInfo info = (LockInfo) element.get();
+     * Internal event class that holds old and new paths for moved nodes
+     */
+    private class HierarchyEvent {
+
+        /**
+         * UUID recorded in event
+         */
+        public final String uuid;
+
+        /**
+         * Path recorded in event
+         */
+        public final Path path;
+
+        /**
+         * Old path in move operation
+         */
+        private Path oldPath;
+
+        /**
+         * New path in move operation
+         */
+        private Path newPath;
+
+        /**
+         * Event type, may be {@link Event#NODE_ADDED},
+         * {@link Event#NODE_REMOVED} or a combination of both
+         */
+        private int type;
+
+        /**
+         * Create a new instance of this class.
+         * @param uuid uuid
+         * @param path path
+         * @param type event type
+         */
+        public HierarchyEvent(String uuid, Path path, int type) {
+            this.uuid = uuid;
+            this.path = path;
+            this.type = type;
+        }
+
+        /**
+         * Merge this event with another event. The result will be stored in
+         * this event
+         * @param event other event to merge with
+         */
+        public void merge(HierarchyEvent event) {
+            type |= event.type;
+            if (event.type == Event.NODE_ADDED) {
+                newPath = event.path;
+                oldPath = path;
+            } else {
+                oldPath = event.path;
+                newPath = path;
+            }
+        }
+
+        /**
+         * Return the event type. May be {@link Event#NODE_ADDED},
+         * {@link Event#NODE_REMOVED} or a combination of both.\
+         * @return event type
+         */
+        public int getType() {
+            return type;
+        }
+
+        /**
+         * Return the old path if this is a move operation
+         * @return old path
+         */
+        public Path getOldPath() {
+            return oldPath;
+        }
+
+        /**
+         * Return the new path if this is a move operation
+         * @return new path
+         */
+        public Path getNewPath() {
+            return newPath;
+        }
+    }
+
+    /**
-        while (events.hasNext()) {
-            EventImpl event = (EventImpl) events.nextEvent();
-            switch (event.getType()) {
+        Iterator iter = consolidateEvents(events);
+        while (iter.hasNext()) {
+            HierarchyEvent event = (HierarchyEvent) iter.next();
+            switch (event.type) {
-                    try {
-                        nodeAdded(event.getChildUUID(),
-                                Path.create(event.getPath(), nsResolver, true));
-                    } catch (MalformedPathException e) {
-                        log.info("Unable to get event's path: " + e.getMessage());
-                    } catch (RepositoryException e) {
-                        log.info("Unable to get event's path: " + e.getMessage());
-                    }
+                    nodeAdded(event.path);
-                    try {
-                        nodeRemoved(event.getChildUUID(),
-                                Path.create(event.getPath(), nsResolver, true));
-                    } catch (MalformedPathException e) {
-                        log.info("Unable to get event's path: " + e.getMessage());
-                    } catch (RepositoryException e) {
-                        log.info("Unable to get event's path: " + e.getMessage());
-                    }
+                    nodeRemoved(event.path);
+                    break;
+                case Event.NODE_ADDED | Event.NODE_REMOVED:
+                    nodeMoved(event.getOldPath(), event.getNewPath());
-     * Invoked when some node has been added. Relink the child inside our
-     * zombie map to the new parent. Revitalize all locks inside the
-     * zombie child hierarchy.
+     * Consolidate an event iterator obtained from observation, merging
+     * add and remove operations on nodes with the same UUID into a move
+     * operation.
-    private synchronized void nodeAdded(String uuid, Path path) {
-        try {
-            PathMap.Child parent = lockMap.map(path.getAncestor(1), true);
-            if (parent != null) {
-                parent.insertChild(path.getNameElement());
+    private Iterator consolidateEvents(EventIterator events) {
+        SequencedHashMap eventMap = new SequencedHashMap();
+
+        while (events.hasNext()) {
+            EventImpl event = (EventImpl) events.nextEvent();
+            HierarchyEvent he;
+
+            try {
+                he = new HierarchyEvent(event.getChildUUID(),
+                        Path.create(event.getPath(), nsResolver, true),
+                        event.getType());
+            } catch (MalformedPathException e) {
+                log.info("Unable to get event's path: " + e.getMessage());
+                continue;
+            } catch (RepositoryException e) {
+                log.info("Unable to get event's path: " + e.getMessage());
+                continue;
-            PathMap.Child zombie = (PathMap.Child) zombieNodes.remove(uuid);
-            if (zombie != null) {
-                zombie.traverse(new PathMap.ChildVisitor() {
-                    public void childVisited(PathMap.Child child) {
-                        LockInfo info = (LockInfo) child.get();
-                        info.setLive(true);
-                    }
-                }, false);
-                lockMap.resurrect(path, zombie);
+
+            HierarchyEvent heExisting = (HierarchyEvent) eventMap.get(he.uuid);
+            if (heExisting != null) {
+                heExisting.merge(he);
+            } else {
+                eventMap.put(he.uuid, he);
+            }
+        }
+        return eventMap.values().iterator();
+    }
+
+    /**
+     * Invoked when some node has been added. If the parent of that node
+     * exists, shift all name siblings of the new node having an index greater
+     * or equal.
+     * @param path path of added node
+     */
+    private synchronized void nodeAdded(Path path) {
+        try {
+            PathMap.Element parent = lockMap.map(path.getAncestor(1), true);
+            if (parent != null) {
+                parent.insert(path.getNameElement());
-            log.warn("Added node does not have parent, ignoring event.");
+            log.warn("Unable to determine path of added node's parent.", e);
+            return;
-     * Invoked when some node has been removed. Unlink the child inside
-     * our path map corresponding to that node. Disable all locks contained
-     * in that subtree.
+     * Invoked when some node has been moved. Relink the child inside our
+     * map to the new parent.
+     * @param oldPath old path
-    private synchronized void nodeRemoved(String uuid, Path path) {
+    private synchronized void nodeMoved(Path oldPath, Path newPath) {
+        PathMap.Element element = lockMap.map(oldPath, true);
+        if (element != null) {
+            element.remove();
+        }
+
-            PathMap.Child parent = lockMap.map(path.getAncestor(1), true);
+            PathMap.Element parent = lockMap.map(newPath.getAncestor(1), true);
-                PathMap.Child child = parent.removeChild(path.getNameElement());
-                if (child != null) {
-                    child.traverse(new PathMap.ChildVisitor() {
-                        public void childVisited(PathMap.Child child) {
-                            LockInfo info = (LockInfo) child.get();
+                parent.insert(newPath.getNameElement());
+            }
+            if (element != null) {
+                lockMap.put(newPath, element);
+            }
+        } catch (PathNotFoundException e) {
+            log.warn("Unable to determine path of moved node's parent.", e);
+            return;
+        }
+    }
+
+    /**
+     * Invoked when some node has been removed. Remove the child from our
+     * path map. Disable all locks contained in that subtree.
+     * @param path path of removed node
+     */
+    private synchronized void nodeRemoved(Path path) {
+        try {
+            PathMap.Element parent = lockMap.map(path.getAncestor(1), true);
+            if (parent != null) {
+                PathMap.Element element = parent.remove(path.getNameElement());
+                if (element != null) {
+                    element.traverse(new PathMap.ElementVisitor() {
+                        public void elementVisited(PathMap.Element element) {
+                            LockInfo info = (LockInfo) element.get();
-                    zombieNodes.put(uuid, child);
-            log.warn("Removed node does not have parent, ignoring event.");
+            log.warn("Unable to determine path of moved node's parent.", e);
+            return;

MOV26 MOV26 UPD40 UPD40 INS55 INS31 INS31 INS31 INS29 INS83 INS42 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 MOV29 MOV83 MOV39 UPD42 MOV42 MOV44 INS8 INS29 UPD83 INS43 UPD42 INS29 INS83 INS83 INS39 INS42 MOV44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS8 MOV44 MOV65 INS29 INS83 MOV83 UPD43 MOV43 INS59 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS43 INS59 INS29 INS83 INS43 INS59 INS29 INS83 INS39 INS59 INS29 UPD83 MOV83 INS42 MOV44 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS43 INS42 INS8 INS29 INS83 INS43 INS42 INS8 UPD43 UPD42 INS60 INS61 INS65 INS42 INS60 INS41 INS65 INS65 INS54 INS65 INS65 INS43 INS42 INS43 INS42 INS60 INS25 INS54 INS65 INS65 UPD43 MOV43 UPD43 MOV43 UPD43 MOV43 UPD43 UPD43 MOV43 UPD43 MOV43 UPD66 INS65 UPD42 UPD42 MOV42 INS65 UPD42 MOV42 INS42 INS65 INS42 INS42 INS65 INS42 INS42 MOV65 INS42 INS65 INS65 INS65 INS65 INS43 INS42 INS39 INS42 MOV21 INS21 INS21 INS65 INS65 INS43 INS42 INS21 INS25 INS65 INS65 INS41 INS65 INS65 INS42 INS41 INS65 INS65 INS42 INS41 INS42 INS43 INS59 INS32 INS8 INS66 INS66 INS66 INS43 INS59 INS32 INS66 INS66 INS66 INS42 INS66 INS8 INS12 INS66 INS66 INS42 INS66 INS42 INS42 INS43 INS59 INS27 INS8 INS8 MOV12 UPD66 MOV66 UPD66 MOV66 INS42 UPD66 MOV66 UPD40 UPD42 UPD40 UPD42 UPD40 UPD42 UPD42 UPD42 UPD40 UPD42 UPD42 UPD40 UPD42 UPD42 UPD40 UPD42 INS66 INS66 INS66 INS66 UPD66 INS65 UPD66 INS65 UPD66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS7 INS7 INS7 INS66 INS66 INS42 INS66 INS42 INS7 INS27 INS8 INS8 INS66 INS65 INS66 INS65 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS32 INS42 INS42 MOV60 INS50 INS42 INS42 INS14 INS60 MOV54 MOV12 INS60 INS25 INS32 INS42 MOV60 INS25 MOV44 INS8 INS40 INS42 INS32 INS42 INS33 INS21 INS60 INS25 INS25 MOV60 INS44 UPD43 MOV43 UPD42 UPD43 MOV43 UPD42 MOV43 UPD42 MOV43 MOV43 UPD43 UPD43 INS67 INS67 INS22 INS42 INS22 INS42 INS22 INS42 INS42 INS40 INS40 INS40 INS21 INS21 INS21 INS21 INS67 INS67 INS42 INS42 UPD43 INS40 MOV49 INS21 INS10 MOV49 INS21 INS10 INS49 INS21 INS10 INS43 INS43 INS59 INS43 INS59 INS27 INS8 INS8 INS42 INS42 UPD43 MOV27 INS8 INS21 INS41 INS42 INS42 INS42 UPD9 MOV9 INS32 INS43 INS59 MOV27 INS8 INS27 INS8 INS41 UPD43 INS27 INS43 INS42 INS41 UPD40 UPD42 UPD42 UPD40 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD40 UPD42 UPD42 UPD40 UPD42 UPD42 INS42 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS7 INS7 INS7 INS7 INS42 INS42 INS42 INS42 UPD42 UPD42 INS32 INS32 INS27 INS32 INS42 INS42 INS42 MOV44 MOV44 INS42 INS42 INS11 INS42 INS33 MOV21 MOV21 UPD40 INS21 INS32 INS42 INS42 INS40 INS42 INS32 INS21 INS42 INS33 MOV21 UPD40 INS42 INS33 INS42 UPD42 UPD42 MOV43 MOV43 INS42 INS40 INS42 INS42 INS42 INS40 INS42 INS42 UPD43 INS42 INS40 INS42 INS40 INS40 INS40 INS42 INS32 INS32 INS7 INS18 INS18 INS43 INS32 MOV32 INS42 INS42 INS45 INS42 INS42 INS42 INS32 INS9 INS32 UPD45 INS42 UPD43 UPD45 INS42 UPD43 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS14 INS42 UPD42 MOV42 UPD42 MOV42 INS40 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS40 UPD42 MOV42 UPD42 INS42 INS42 INS34 INS42 INS42 INS32 UPD42 UPD42 UPD42 UPD40 UPD42 MOV32 UPD42 UPD40 MOV43 MOV43 MOV43 INS43 MOV32 MOV32 MOV32 INS42 INS42 UPD42 UPD42 UPD42 INS42 UPD42 MOV43 UPD43 UPD42 UPD40 UPD42 UPD43 UPD42 UPD40 MOV43 MOV43 UPD42 DEL29 DEL83 DEL43 DEL14 DEL59 DEL23 DEL66 DEL66 DEL40 DEL39 DEL42 DEL32 DEL42 DEL45 DEL32 DEL27 DEL45 DEL42 DEL32 DEL27 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL9 DEL32 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL10 DEL10 DEL50 DEL29 DEL83 DEL39 DEL42 DEL8 DEL25 DEL40 DEL43 DEL42 DEL40 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL40 DEL43 DEL9 DEL32 DEL21 DEL8 DEL31 DEL1 DEL14 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL31 DEL65 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21
- Redesigned observation to also include workspace modifications
- Extended observation tests and moved them into the api.observation package

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@155583 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.observation.EventStateCollection;
-import org.apache.jackrabbit.core.observation.ObservationManagerFactory;
-                WorkspaceImpl wsp = (WorkspaceImpl) session.getWorkspace();
-
-                // list of events that are generated by saved changes
-                ObservationManagerFactory obsFactory = rep.getObservationManagerFactory(wsp.getName());
-                EventStateCollection events = obsFactory.createEventStateCollection(session,
-                        session.getItemStateManager(), session.getHierarchyManager());
-
-                /**
-                 * create event states for the affected item states and
-                 * prepare them for event dispatch (this step is necessary in order
-                 * to check access rights on items that will be removed)
-                 *
-                 * todo consolidate event generating and dispatching code (ideally one method call after save has succeeded)
-                 */
-                events.createEventStates(removed);
-                events.createEventStates(dirty);
-                events.prepare();
-
+                    // dispose the transient states marked 'new' or 'modified'
+                    // at this point item state data is pushed down one level,
+                    // node instances are disconnected from the transient
+                    // item state and connected to the 'overlayed' item state.
+                    // transient item states must be removed now. otherwise
+                    // the session item state provider will return an orphaned
+                    // item state which is not referenced by any node instance.
+                    iter = dirty.iterator();
+                    while (iter.hasNext()) {
+                        transientState = (ItemState) iter.next();
+                        // dispose the transient state, it is no longer used
+                        stateMgr.disposeTransientItemState(transientState);
+                    }
+
-                // dispose the transient states marked 'removed'
+                // dispose the transient states marked 'removed'.
+                // item states in attic are removed after store, because
+                // the observation mechanism needs to build paths of removed
+                // items in store().
-                // dispose the transient states marked 'new' or 'modified'
-                iter = dirty.iterator();
-                while (iter.hasNext()) {
-                    transientState = (ItemState) iter.next();
-                    // dispose the transient state, it is no longer used
-                    stateMgr.disposeTransientItemState(transientState);
-                }
-
-                /**
-                 * all changes are persisted, now dispatch events;
-                 * forward this to the session to let it decide on the right
-                 * time for those events to be dispatched in case of
-                 * transactional support
-                 */
-                session.dispatch(events);

MOV21 MOV61 DEL40 DEL26 DEL40 DEL26 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21
- fixing some update/merge issues (JCR-40)
- adding doneMerge, cancelMerge

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@157808 13f79535-47bb-0310-9956-ffa450edef68

-import javax.jcr.ReferenceValue;
-        // check if not merge failed
-        if (hasProperty(JCR_MERGEFAILED) && getProperty(JCR_MERGEFAILED).getValues().length > 0) {
-            String msg = "Unable to checkin node. Node has unresolved merge operation. " + safeGetJCRPath();
-            log.debug(msg);
-            throw new VersionException(msg);
-        }
-
-        // check state of this instance
-        sanityCheck();
-
-        // check for pending changes
-        if (session.hasPendingChanges()) {
-            String msg = "Unable to checkin node. Session has pending changes.";
-            log.debug(msg);
-            throw new InvalidItemStateException(msg);
-        }
-
-        // check lock status
-        checkLock();
-
-        SessionImpl srcSession = null;
-        try {
-            // create session on other workspace for current subject
-            // (may throw NoSuchWorkspaceException and AccessDeniedException)
-            srcSession = rep.createSession(session.getSubject(), srcWorkspaceName);
-
-            NodeImpl srcNode = getCorrespondingNode(srcSession);
-            if (srcNode == null) {
-                /*
-                 * If this node does not have a corresponding node in the workspace
-                 * <code>srcWorkspaceName</code>, then the <code>update</code> method
-                 * has no effect (it does not traverse down the subtree).
-                */
-                return;
-            }
-
-            /*
-             * If this node does have a corresponding node in the workspace <code>srcWorkspaceName</code>,
-             * then this method traverses down the subtree rooted at this node and
-             * replaces the state of each node in the subtree rooted at this node with that
-             * of its corresponding node in the specified source workspace.
-             */
-            boolean removeExisting = false;
-            boolean replaceExisting = true;
-            try {
-                internalUpdate(srcNode, removeExisting, replaceExisting);
-            } catch (RepositoryException e) {
-                session.refresh(false);
-                throw e;
-            }
-            session.save();
-        } finally {
-            if (srcSession != null) {
-                // we don't need the other session anymore, logout
-                srcSession.logout();
-            }
-        }
+        internalMerge(srcWorkspaceName, true, false);
-        // check state of this instance
-        sanityCheck();
-
-        // check for pending changes
-        if (session.hasPendingChanges()) {
-            String msg = "Unable to merge. Session has pending changes.";
-            log.debug(msg);
-            throw new InvalidItemStateException(msg);
-        }
-
-        // if same workspace, ignore
-        if (srcWorkspace.equals(session.getWorkspace().getName())) {
-            return;
-        }
-
-        // check lock status
-        checkLock();
-
-        SessionImpl srcSession = null;
-        try {
-            // create session on other workspace for current subject
-            // (may throw NoSuchWorkspaceException and AccessDeniedException)
-            srcSession = rep.createSession(session.getSubject(), srcWorkspace);
-
-            NodeImpl srcNode = doMergeTest(srcSession, bestEffort);
-            if (srcNode != null) {
-                // remove properties
-                PropertyIterator pi = getProperties();
-                while (pi.hasNext()) {
-                    Property p = pi.nextProperty();
-                    if (!srcNode.hasProperty(p.getName())) {
-                        p.setValue((Value) null);
-                    }
-                }
-                // copy properties
-                pi = srcNode.getProperties();
-                while (pi.hasNext()) {
-                    PropertyImpl p = (PropertyImpl) pi.nextProperty();
-                    internalCopyPropertyFrom(p);
-                }
-
-                // remove subnodes
-                NodeIterator ni = getNodes();
-                while (ni.hasNext()) {
-                    // if the subnode does not exist in the src, and this is update,
-                    // so delete here as well?
-                    Node n = ni.nextNode();
-                    if (!srcNode.hasNode(n.getName())) {
-                        // todo: how does this work for same name siblings?
-                        n.remove();
-                    }
-                }
-                // 'clone' nodes that do not exist
-                ni = srcNode.getNodes();
-                while (ni.hasNext()) {
-                    Node n = ni.nextNode();
-                    if (!hasNode(n.getName())) {
-                        // todo: probably need some internal stuff
-                        // todo: how does this work for same name siblings?
-                        // todo: since clone is a ws operation, 'save' does not work later
-                        session.getWorkspace().clone(srcWorkspace, n.getPath(), getPath() + "/" + n.getName(), true);
-                    } else {
-                        // do recursive merge
-                        n.merge(srcWorkspace, bestEffort);
-                    }
-                }
-            } else {
-                // do not change this node, but recuse merge
-                NodeIterator ni = srcNode.getNodes();
-                while (ni.hasNext()) {
-                    ni.nextNode().merge(srcWorkspace, bestEffort);
-                }
-            }
-
-            save();
-        } finally {
-            if (srcSession != null) {
-                // we don't need the other session anymore, logout
-                srcSession.logout();
-            }
-        }
+        internalMerge(srcWorkspace, false, bestEffort);
-    /**
-     * {@inheritDoc}
-     */
-        // check state of this instance
-        sanityCheck();
-
-        // check for pending changes
-        if (hasPendingChanges()) {
-            String msg = "Unable to checkin node. Node has pending changes: " + safeGetJCRPath();
-            log.debug(msg);
-            throw new InvalidItemStateException(msg);
-        }
-
-        // @todo implement Node#cancelMerge(Version)
-        throw new UnsupportedRepositoryOperationException("not yet implemented");
+        internalFinishMerge(version, true);
-        // check state of this instance
-        sanityCheck();
-
-        // check for pending changes
-        if (hasPendingChanges()) {
-            String msg = "Unable to checkin node. Node has pending changes: " + safeGetJCRPath();
-            log.debug(msg);
-            throw new InvalidItemStateException(msg);
-        }
-
-        // @todo implement Node#doneMerge(Version)
-        throw new UnsupportedRepositoryOperationException("not yet implemented");
+        internalFinishMerge(version, false);
-    private NodeImpl doMergeTest(SessionImpl srcSession, boolean bestEffort)
+    private NodeImpl doMergeTest(SessionImpl srcSession, boolean update, boolean bestEffort)
-        if (!isNodeType(MIX_VERSIONABLE)) {
+        if (!isNodeType(MIX_VERSIONABLE) || update) {
-                List values = hasProperty(JCR_MERGEFAILED)
-                        ? Arrays.asList(getProperty(JCR_MERGEFAILED).getValues())
-                        : new ArrayList();
-                values.add(new ReferenceValue(srcNode.getBaseVersion()));
-                setProperty(JCR_MERGEFAILED, (Value[]) values.toArray(new Value[values.size()]));
+                Set set = internalGetMergeFailed();
+                set.add(srcNode.getBaseVersion().getUUID());
+                internalSetMergeFailed(set);
+     * {@inheritDoc}
+     */
+    private void internalFinishMerge(Version version, boolean cancel)
+            throws VersionException, InvalidItemStateException,
+            UnsupportedRepositoryOperationException, RepositoryException {
+        // check state of this instance
+        sanityCheck();
+
+        // check for pending changes
+        if (hasPendingChanges()) {
+            String msg = "Unable to finish merge. Node has pending changes: " + safeGetJCRPath();
+            log.debug(msg);
+            throw new InvalidItemStateException(msg);
+        }
+
+        // check versionable
+        checkVersionable();
+
+        // check lock
+        checkLock();
+
+        // check if checked out
+        if (!internalIsCheckedOut()) {
+            String msg = "Unable to finish merge. Node is checked-in: " + safeGetJCRPath();
+            log.error(msg);
+            throw new VersionException(msg);
+        }
+
+        // check if version is in mergeFailed list
+        Set failed = internalGetMergeFailed();
+        if (!failed.remove(version.getUUID())) {
+            String msg = "Unable to finish merge. Specified version is not in jcr:mergeFailed property: " + safeGetJCRPath();
+            log.error(msg);
+            throw new VersionException(msg);
+        }
+
+        // remove version from mergeFailed list
+        internalSetMergeFailed(failed);
+
+        if (!cancel) {
+            // add version to jcr:predecessors list
+            Value[] vals = getProperty(JCR_PREDECESSORS).getValues();
+            InternalValue[] v = new InternalValue[vals.length + 1];
+            for (int i=0; i<vals.length; i++) {
+                v[i] = InternalValue.create(UUID.fromString(vals[i].getString()));
+            }
+            v[vals.length] = InternalValue.create(UUID.fromString(version.getUUID()));
+            internalSetProperty(JCR_PREDECESSORS, v);
+        }
+
+        // save
+        save();
+    }
+
+    /**
+     *
+     * @return
+     * @throws RepositoryException
+     */
+    private Set internalGetMergeFailed() throws RepositoryException {
+        HashSet set = new HashSet();
+        if (hasProperty(JCR_MERGEFAILED)) {
+            Value[] vals = getProperty(JCR_MERGEFAILED).getValues();
+            for (int i=0; i<vals.length; i++) {
+                set.add(vals[i].getString());
+            }
+        }
+        return set;
+    }
+
+    /**
+     *
+     * @param set
+     * @throws RepositoryException
+     */
+    private void internalSetMergeFailed(Set set) throws RepositoryException {
+        if (set.isEmpty()) {
+            internalSetProperty(JCR_MERGEFAILED, (InternalValue[]) null);
+        } else {
+            InternalValue[] vals = new InternalValue[set.size()];
+            Iterator iter = set.iterator();
+            int i=0;
+            while (iter.hasNext()) {
+                String uuid = (String) iter.next();
+                vals[i++] = InternalValue.create(UUID.fromString(uuid));
+            }
+            internalSetProperty(JCR_MERGEFAILED, vals);
+        }
+    }
+
+    /**
-     * updates this node with the state given by <code>srcNode</code>
-     *
-     * @param srcNode
+     * {@inheritDoc}
+     */
+    private void internalMerge(String srcWorkspaceName,
+                                boolean update, boolean bestEffort)
+            throws NoSuchWorkspaceException, AccessDeniedException,
+            LockException, InvalidItemStateException, RepositoryException {
+
+        // might be added in future releases
+        boolean removeExisting = true;
+        boolean replaceExisting = false;
+
+        // check state of this instance
+        sanityCheck();
+
+        // check for pending changes
+        if (session.hasPendingChanges()) {
+            String msg = "Unable to " + (update ? "update" : "merge") + " node. Session has pending changes.";
+            log.debug(msg);
+            throw new InvalidItemStateException(msg);
+        }
+
+        // if same workspace, ignore
+        if (srcWorkspaceName.equals(session.getWorkspace().getName())) {
+            return;
+        }
+
+        SessionImpl srcSession = null;
+        try {
+            // create session on other workspace for current subject
+            // (may throw NoSuchWorkspaceException and AccessDeniedException)
+            srcSession = rep.createSession(session.getSubject(), srcWorkspaceName);
+
+            try {
+                internalMerge(srcSession, update, bestEffort, removeExisting, replaceExisting);
+            } catch (RepositoryException e) {
+                try {
+                    session.refresh(false);
+                } catch (RepositoryException e1) {
+                    // ignore
+                }
+                throw e;
+            }
+            session.save();
+        } finally {
+            if (srcSession != null) {
+                // we don't need the other session anymore, logout
+                srcSession.logout();
+            }
+        }
+    }
+
+    /**
+     * Merges/Updates this node with its corresponding ones
+     * @param srcSession
+     * @param update
+     * @param bestEffort
+     * @throws LockException
-    private void internalUpdate(NodeImpl srcNode, boolean removeExisting, boolean replaceExisting)
+    private void internalMerge(SessionImpl srcSession, boolean update, boolean bestEffort, boolean removeExisting, boolean replaceExisting)
+        NodeImpl srcNode = doMergeTest(srcSession, update, bestEffort);
+        if (srcNode == null) {
+            // leave, iterate over children
+            NodeIterator iter = getNodes();
+            while (iter.hasNext()) {
+                NodeImpl n = (NodeImpl) iter.nextNode();
+                n.internalMerge(srcSession, update,  bestEffort, removeExisting, replaceExisting);
+            }
+            return;
+        }
+
-        /*
-         * The "state" of the node in this context means the set of properties and
-         * child nodes it has. In other words, when a node is updated, its set of
-         * properties and child nodes is replaced by that of its corresponding node in the
-         * source workspace. One repercussion of this is that if a node further down the
-         * subtree does not have a corresponding node, then that node is removed (thus
-         * aligning the state of its parent with <i>its</i> correspondee in the other
-         * workspace).
-         */
-
+        // todo: add/remove mixins ?
-        // update the nodes. remove all dst nodes first
+        // update the nodes. remove non existing ones
-            ((NodeImpl) niter.nextNode()).internalRemove(true);
+            NodeImpl n = (NodeImpl) niter.nextNode();
+            // todo: does not work properly for samename siblings
+            if (!srcNode.hasNode(n.getQName())) {
+                n.internalRemove(true);
+            }
-        // add src ones
+
+        // add source ones
-            if (child.isNodeType(MIX_REFERENCEABLE)) {
+            if (hasNode(child.getQName())) {
+                // todo: does not work properly for samename siblings
+                dstNode = getNode(child.getQName());
+            } else if (child.isNodeType(MIX_REFERENCEABLE)) {
-                        // get applicable definition of target node at new location
-                        NodeTypeImpl nt = (NodeTypeImpl) dstNode.getPrimaryNodeType();
-                        NodeDefImpl newTargetDef;
-                        try {
-                            newTargetDef = ((NodeImpl) getParent()).getApplicableChildNodeDef(child.getQName(), nt.getQName());
-                        } catch (RepositoryException re) {
-                            String msg = dstNode.safeGetJCRPath() + ": no definition found in parent node's node type for new node";
-                            log.debug(msg);
-                            throw new ConstraintViolationException(msg, re);
-                        }
-
-                        // check lock status of current parent
-                        ((NodeImpl) dstNode.getParent()).checkLock();
-
-                        // add target to new parent and remove from old one
-                        createChildNodeLink(child.getQName(), uuid);
-                        ((NodeImpl) dstNode.getParent()).removeChildNode(child.getQName(), child.getIndex() == 0 ? 1 : child.getIndex());
-                        // change definition of target if necessary
-                        NodeDefImpl oldTargetDef = (NodeDefImpl) dstNode.getDefinition();
-                        NodeDefId oldTargetDefId = new NodeDefId(oldTargetDef.unwrap());
-                        NodeDefId newTargetDefId = new NodeDefId(newTargetDef.unwrap());
-                        if (!oldTargetDefId.equals(newTargetDefId)) {
-                            dstNode.onRedefine(newTargetDefId);
-                        }
+                        dstNode.internalRemove(false);
+                        dstNode = null;
-                // if child is not referenceable, adjust state
+                // if child is not referenceable, clear uuid
+                dstNode.internalMerge(srcSession, true, bestEffort, removeExisting, replaceExisting);
+            } else {
+                dstNode.internalMerge(srcSession, update, bestEffort, removeExisting, replaceExisting);
-            dstNode.internalUpdate(child, removeExisting, replaceExisting);
+        // also clear mergeFailed
+        internalSetProperty(JCR_MERGEFAILED, (InternalValue[]) null);
+

MOV31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 MOV21 MOV21 MOV21 MOV29 MOV83 MOV39 UPD42 MOV42 INS44 INS43 INS43 INS43 INS43 MOV43 INS8 MOV29 INS83 INS39 INS42 MOV44 MOV44 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 INS8 INS83 INS39 INS42 INS44 INS43 INS43 MOV43 INS43 INS8 MOV29 INS83 INS39 INS42 MOV44 MOV43 MOV43 MOV43 MOV43 INS8 INS44 INS29 INS83 INS39 INS42 MOV44 INS44 MOV43 MOV43 MOV43 INS43 INS8 INS29 INS83 INS43 INS42 INS43 INS8 INS29 UPD83 MOV83 MOV39 UPD42 MOV42 INS44 INS43 INS8 UPD83 INS42 INS44 INS44 UPD42 INS44 INS44 INS43 INS42 INS42 INS42 UPD42 MOV42 INS42 MOV21 INS21 INS43 INS42 INS42 INS42 UPD42 MOV42 INS21 INS21 INS39 INS42 INS65 INS39 INS42 UPD42 MOV42 MOV21 MOV25 MOV21 MOV21 INS25 MOV60 MOV25 MOV21 INS25 MOV21 INS65 INS65 INS42 INS42 MOV60 INS25 INS41 INS65 INS65 INS43 INS42 UPD42 MOV42 INS25 INS39 INS42 INS39 INS42 INS60 INS60 INS25 INS65 INS65 INS65 INS43 UPD42 INS39 INS42 INS39 INS42 INS60 INS25 INS21 INS42 INS32 INS32 UPD42 MOV42 INS32 INS32 INS27 INS65 INS32 INS38 INS8 UPD43 INS32 INS38 INS8 INS42 UPD43 MOV32 INS8 INS42 INS42 INS42 INS42 INS32 INS8 INS8 INS39 INS59 INS39 INS59 INS32 MOV8 UPD66 UPD42 INS42 INS42 INS42 INS42 MOV43 INS59 MOV27 INS8 INS8 INS32 UPD42 MOV42 UPD42 MOV42 INS9 INS9 UPD42 MOV42 UPD42 MOV42 INS9 MOV42 UPD42 MOV42 UPD42 MOV42 INS9 UPD42 MOV42 UPD42 MOV42 INS9 MOV38 INS42 MOV60 UPD42 MOV42 INS32 MOV60 MOV21 MOV53 UPD42 UPD42 INS60 INS53 UPD42 MOV42 UPD42 MOV42 INS42 INS60 MOV60 INS24 MOV21 INS21 UPD42 INS42 INS14 INS60 INS24 UPD42 MOV42 INS42 MOV21 INS60 INS60 INS60 INS61 INS21 INS42 INS9 INS42 INS9 INS42 INS42 MOV32 INS42 INS32 MOV60 INS61 INS41 INS60 INS25 MOV25 INS42 INS42 INS11 MOV43 UPD42 MOV42 MOV43 UPD42 UPD42 UPD42 MOV43 INS59 INS14 MOV5 INS59 INS5 INS58 INS27 INS37 INS8 INS7 INS32 INS43 MOV5 INS59 INS58 INS27 INS37 INS8 INS5 INS59 INS43 INS59 INS39 INS59 INS32 INS8 INS32 MOV43 MOV32 INS42 INS42 INS42 INS42 INS32 INS8 MOV43 INS59 INS38 INS8 MOV32 INS8 INS25 INS8 INS5 INS33 UPD42 INS27 UPD42 UPD42 INS42 UPD42 UPD42 INS42 INS27 UPD42 UPD42 INS42 INS43 INS42 INS42 INS32 INS43 INS85 UPD42 INS3 INS39 INS59 INS42 INS40 INS42 MOV21 INS2 INS32 INS42 INS42 INS42 INS42 INS42 MOV32 INS39 INS59 INS42 INS40 INS42 MOV21 UPD42 UPD42 INS11 INS43 INS85 INS42 INS3 INS42 INS42 INS32 INS42 INS34 INS42 UPD42 MOV42 MOV60 MOV21 INS42 INS42 INS42 INS27 MOV42 MOV42 INS8 UPD42 INS42 INS42 INS60 INS21 INS42 MOV11 INS32 MOV21 UPD42 MOV21 MOV32 INS8 MOV8 INS21 INS21 INS43 INS85 UPD45 INS45 INS32 INS45 INS32 INS42 INS32 INS42 UPD42 MOV42 INS5 INS27 INS42 INS34 INS7 INS42 INS40 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS34 INS5 INS33 UPD42 MOV42 INS5 INS32 UPD42 MOV42 INS42 INS7 INS45 INS36 INS45 INS54 MOV53 MOV43 INS59 INS32 INS42 INS42 INS32 INS54 INS32 INS32 INS42 UPD43 INS32 INS32 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 INS43 INS85 INS40 INS34 INS2 INS32 UPD42 MOV42 UPD42 MOV42 INS32 UPD42 MOV42 UPD42 MOV42 INS32 INS43 INS85 INS43 INS85 INS42 INS42 INS42 INS11 INS2 INS32 INS16 UPD42 UPD42 INS42 INS42 MOV8 INS12 INS42 INS11 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS8 MOV12 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS32 INS42 INS42 MOV32 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS42 INS2 UPD42 MOV42 INS42 INS42 INS43 INS32 INS42 INS37 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS45 INS45 INS44 INS8 MOV43 INS32 UPD42 MOV42 MOV32 MOV21 INS25 UPD42 MOV42 MOV32 UPD42 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 UPD42 MOV42 INS42 MOV43 INS42 INS42 INS42 INS42 INS8 MOV25 INS2 UPD42 MOV42 MOV21 MOV21 INS42 INS42 INS7 MOV42 UPD42 INS9 INS42 INS33 DEL40 DEL26 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL22 DEL34 DEL27 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL7 DEL42 DEL42 DEL32 DEL25 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL32 DEL38 DEL42 DEL42 DEL43 DEL33 DEL11 DEL32 DEL21 DEL8 DEL25 DEL8 DEL61 DEL42 DEL32 DEL8 DEL61 DEL42 DEL42 DEL32 DEL8 DEL61 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL38 DEL8 DEL8 DEL25 DEL8 DEL61 DEL8 DEL42 DEL42 DEL32 DEL8 DEL61 DEL8 DEL25 DEL8 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL31 DEL42 DEL32 DEL21 DEL42 DEL32 DEL43 DEL42 DEL45 DEL32 DEL27 DEL59 DEL60 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL45 DEL14 DEL53 DEL8 DEL31 DEL83 DEL39 DEL42 DEL32 DEL21 DEL32 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL31 DEL42 DEL32 DEL42 DEL43 DEL14 DEL16 DEL42 DEL42 DEL43 DEL14 DEL42 DEL42 DEL42 DEL42 DEL32 DEL3 DEL32 DEL11 DEL32 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL32 DEL7 DEL42 DEL43 DEL42 DEL43 DEL42 DEL32 DEL11 DEL42 DEL42 DEL32 DEL7 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL42 DEL32 DEL45 DEL42 DEL32 DEL27 DEL9 DEL32 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL42 DEL42 DEL45 DEL32 DEL27 DEL32 DEL42 DEL45 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL41 DEL8 DEL25 DEL39 DEL42 DEL9 DEL59 DEL60 DEL39 DEL42 DEL9 DEL59 DEL60 DEL36 DEL8 DEL42 DEL42 DEL42 DEL32 DEL11 DEL36 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL42 DEL32 DEL11 DEL36 DEL42 DEL42 DEL32 DEL34 DEL27 DEL34 DEL42 DEL42 DEL32 DEL16 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL8 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL45 DEL27 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL42 DEL32 DEL11 DEL36 DEL42 DEL32 DEL21 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL38 DEL8 DEL25 DEL8 DEL8 DEL54 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21
Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.spi.QPropertyDefinition;
-import org.apache.jackrabbit.spi.ChildInfo;
+import org.apache.jackrabbit.spi.QPropertyDefinition;
-import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeConflictException;
+import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeConflictException;
+import org.apache.jackrabbit.jcr2spi.hierarchy.NodeEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.PropertyEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.HierarchyEntry;
+import org.apache.jackrabbit.name.QName;
+import org.apache.jackrabbit.name.Path;
+import org.apache.jackrabbit.name.MalformedPathException;
+import javax.jcr.ItemExistsException;
-import javax.jcr.nodetype.ConstraintViolationException;
-import javax.jcr.nodetype.NoSuchNodeTypeException;
+import java.util.List;
+import java.util.ArrayList;
-public class WorkspaceItemStateFactory implements ItemStateFactory {
+public class WorkspaceItemStateFactory extends AbstractItemStateFactory implements ItemStateFactory {
-    private ItemStateCache cache;
-
-    public WorkspaceItemStateFactory(RepositoryService service, SessionInfo sessionInfo, WorkspaceManager wspManager) {
+    public WorkspaceItemStateFactory(RepositoryService service, SessionInfo sessionInfo,
+                                     WorkspaceManager wspManager) {
-     * @see ItemStateFactory#createRootState(ItemStateManager)
+     * @see ItemStateFactory#createRootState(NodeEntry)
+     * @param entry
-    public NodeState createRootState(ItemStateManager ism) throws ItemStateException {
+    public NodeState createRootState(NodeEntry entry) throws ItemStateException {
-            return createNodeState(info, null);
+            return createNodeState(info, entry);
-     * @see ItemStateFactory#createNodeState(NodeId, ItemStateManager)
+     * @see ItemStateFactory#createNodeState(NodeId,NodeEntry)
-    public NodeState createNodeState(NodeId nodeId, ItemStateManager ism)
+    public NodeState createNodeState(NodeId nodeId, NodeEntry entry)
-            NodeId parentId = info.getParentId();
-            if (parentId != null) {
-                NodeState parent = (NodeState) ism.getItemState(parentId);
-                return parent.getChildNodeEntry(nodeId).getNodeState();
-            } else {
-                // special case for root state
-                return createNodeState(info, null);
-            }
+            return createNodeState(info, entry);
+        } catch (PathNotFoundException e) {
+            throw new NoSuchItemStateException(e.getMessage(), e);
-    /**
-     * Creates the node with information retrieved from the
-     * <code>RepositoryService</code>.
-     *
-     * @inheritDoc
-     * @see ItemStateFactory#createNodeState(NodeId, NodeState)
-     */
-    public NodeState createNodeState(NodeId nodeId, NodeState parent)
-            throws NoSuchItemStateException, ItemStateException {
+    public NodeState createDeepNodeState(NodeId nodeId, NodeEntry anyParent) throws NoSuchItemStateException, ItemStateException {
-            return createNodeState(info, parent);
+            // node for nodeId exists -> build missing entries in hierarchy
+            // Note, that the path contained in NodeId does not reveal which
+            // entries are missing -> calculate relative path.
+            Path anyParentPath = anyParent.getPath();
+            Path relPath = anyParentPath.computeRelativePath(info.getPath());
+            Path.PathElement[] missingElems = relPath.getElements();
+
+            NodeEntry entry = anyParent;
+            for (int i = 0; i < missingElems.length; i++) {
+                QName name = missingElems[i].getName();
+                int index = missingElems[i].getNormalizedIndex();
+                if (entry.hasNodeEntry(name, index)) {
+                    entry = entry.getNodeEntry(name, index);
+                } else {
+                    entry = entry.addNodeEntry(name, null, index);
+                }
+            }
+            if (entry == anyParent) {
+                throw new ItemStateException("Internal error while getting deep itemState");
+            }
+            return createNodeState(info, entry);
-        } catch (RepositoryException e) {
+        } catch (ItemNotFoundException e) {
+            throw new NoSuchItemStateException(e.getMessage(), e);
+        }  catch (RepositoryException e) {
-        }
-    }
-
-    /**
-     * Creates the node with information retrieved from <code>info</code>.
-     *
-     * @param info the <code>NodeInfo</code> to use to create the
-     * <code>NodeState</code>.
-     * @param parent the parent <code>NodeState</code>.
-     * @return the new <code>NodeState</code>.
-     */
-    private NodeState createNodeState(NodeInfo info, NodeState parent)
-            throws NoSuchItemStateException, ItemStateException {
-        try {
-            // retrieve definition
-            QNodeDefinition definition;
-            if (parent == null) {
-                // special case for root state
-                definition = wspManager.getNodeTypeRegistry().getRootNodeDef();
-            } else {
-                NodeTypeRegistry ntReg = wspManager.getNodeTypeRegistry();
-                EffectiveNodeType ent = ntReg.getEffectiveNodeType(parent.getNodeTypeNames());
-                definition = ent.getApplicableNodeDefinition(info.getQName(), info.getNodetype(), ntReg);
-            }
-
-            // build the node state
-            String uniqueID = null;
-            if (info.getId().getPath() == null) {
-                uniqueID = info.getId().getUniqueID();
-            }
-            NodeState state = new NodeState(info.getQName(), uniqueID, parent, info.getNodetype(),
-                definition, Status.EXISTING, this, service.getIdFactory(), true);
-
-            // names of child property entries
-            Set propNames = new HashSet();
-            for (IdIterator it = info.getPropertyIds(); it.hasNext(); ) {
-                PropertyId pId = (PropertyId) it.nextId();
-                propNames.add(pId.getQName());
-            }
-
-            // Build node-references object even if the state is not refereceable yet.
-            PropertyId[] references = info.getReferences();
-            NodeReferences nodeRefs = new NodeReferencesImpl(state, references);
-
-            state.init(info.getMixins(), propNames, nodeRefs);
-
-            state.addListener(cache);
-            cache.created(state);
-
-            return state;
-        } catch (NodeTypeConflictException e) {
-            String msg = "Internal error: failed to retrieve node definition.";
-            log.debug(msg);
-            throw new ItemStateException(msg, e);
-        } catch (ConstraintViolationException e) {
-            String msg = "Internal error: failed to retrieve node definition.";
-            log.debug(msg);
-            throw new ItemStateException(msg, e);
-        } catch (NoSuchNodeTypeException e) {
-            String msg = "internal error: failed to retrieve node definition.";
-            log.debug(msg);
-            throw new ItemStateException(msg, e);
-        } catch (RepositoryException e) {
+        } catch (MalformedPathException e) {
-     * @see ItemStateFactory#createPropertyState(PropertyId, NodeState)
+     * @see ItemStateFactory#createPropertyState(PropertyId,PropertyEntry)
-                                             NodeState parent)
+                                             PropertyEntry entry)
-            return createPropertyState(info, parent);
+            return createPropertyState(info, entry);
+        } catch (ItemNotFoundException e) {
+            throw new NoSuchItemStateException(e.getMessage(), e);
-    public ChildNodeEntries getChildNodeEntries(NodeState nodeState)
+    public PropertyState createDeepPropertyState(PropertyId propertyId, NodeEntry anyParent) throws NoSuchItemStateException, ItemStateException {
+        try {
+            PropertyInfo info = service.getPropertyInfo(sessionInfo, propertyId);
+            // prop for propertyId exists -> build missing entries in hierarchy
+            // Note, that the path contained in PropertyId does not reveal which
+            // entries are missing -> calculate relative path.
+            Path anyParentPath = anyParent.getPath();
+            Path relPath = anyParentPath.computeRelativePath(info.getPath());
+            Path.PathElement[] missingElems = relPath.getElements();
+            NodeEntry entry = anyParent;
+            int i = 0;
+            // NodeEntries except for the very last 'missingElem'
+            while (i < missingElems.length - 1) {
+                QName name = missingElems[i].getName();
+                int index = missingElems[i].getNormalizedIndex();
+                if (entry.hasNodeEntry(name, index)) {
+                    entry = entry.getNodeEntry(name, index);
+                } else {
+                    entry = entry.addNodeEntry(name, null, index);
+                }
+                i++;
+            }
+            // create PropertyEntry for the last element if not existing yet
+            QName propName = missingElems[i].getName();
+            PropertyEntry propEntry;
+            if (!entry.hasPropertyEntry(propName)) {
+                propEntry = entry.addPropertyEntry(propName);
+            } else {
+                propEntry = entry.getPropertyEntry(propName);
+            }
+            return createPropertyState(info, propEntry);
+        } catch (PathNotFoundException e) {
+            throw new NoSuchItemStateException(e.getMessage(), e);
+        } catch (ItemNotFoundException e) {
+            throw new NoSuchItemStateException(e.getMessage(), e);
+        } catch (RepositoryException e) {
+            throw new ItemStateException(e.getMessage(), e);
+        } catch (MalformedPathException e) {
+            throw new ItemStateException(e.getMessage(), e);
+        }
+    }
+
+    /**
+     * @inheritDoc
+     * @see ItemStateFactory#getChildNodeInfos(NodeId)
+     * @param nodeId
+     */
+    public Iterator getChildNodeInfos(NodeId nodeId)
-            ChildNodeEntries entries = new ChildNodeEntries(nodeState);
-            Iterator childInfos = service.getChildInfos(sessionInfo, nodeState.getNodeId());
-            while (childInfos.hasNext()) {
-                ChildInfo ci = (ChildInfo) childInfos.next();
-                entries.add(ci.getName(), ci.getUniqueID(), ci.getIndex());
-            }
-            return entries;
+            return service.getChildInfos(sessionInfo, nodeId);
+        } catch (ItemNotFoundException e) {
+            throw new NoSuchItemStateException(e.getMessage(), e);
+     * @inheritDoc
+     * @see ItemStateFactory#getNodeReferences(NodeState)
+     * @param nodeState
+     */
+    public NodeReferences getNodeReferences(NodeState nodeState) {
+        nodeState.checkIsWorkspaceState();
+        // shortcut
+        if (nodeState.getUniqueID() == null || !nodeState.hasPropertyName(QName.JCR_UUID)) {
+            // for sure not referenceable
+            return EmptyNodeReferences.getInstance();
+        }
+
+        // nodestate has a unique ID and is potentially mix:referenceable
+        // => try to retrieve references
+        try {
+            NodeInfo info = service.getNodeInfo(sessionInfo, nodeState.getNodeId());
+            return new NodeReferencesImpl(info.getReferences());
+        } catch (RepositoryException e) {
+            log.debug("No references for NodeState " + nodeState);
+            return EmptyNodeReferences.getInstance();
+        }
+    }
+
+    //------------------------------------------------------------< private >---
+    /**
+     * Creates the node with information retrieved from <code>info</code>.
+     *
+     * @param info the <code>NodeInfo</code> to use to create the <code>NodeState</code>.
+     * @param entry
+     * @return the new <code>NodeState</code>.
+     */
+    private NodeState createNodeState(NodeInfo info, NodeEntry entry) {
+        // make sure the entry has the correct ItemId
+        // this make not be the case, if the hierachy has not been completely
+        // resolved yet -> if uniqueID is present, set it on this entry or on
+        // the appropriate parent entry
+        String uniqueID = info.getId().getUniqueID();
+        Path path = info.getId().getPath();
+        if (path == null) {
+            entry.setUniqueID(uniqueID);
+        } else if (uniqueID != null) {
+            // uniqueID that applies to a parent NodeEntry -> get parentEntry
+            NodeEntry parent = getAncestor(entry, path.getLength());
+            parent.setUniqueID(uniqueID);
+        }
+
+        // retrieve definition
+        NodeTypeRegistry ntReg = wspManager.getNodeTypeRegistry();
+        QNodeDefinition definition = null;
+        NodeEntry parent = entry.getParent();
+        if (parent == null) {
+            // special case for root state
+            definition = wspManager.getNodeTypeRegistry().getRootNodeDef();
+        } else if (parent.isAvailable() && parent.getStatus() != Status.INVALIDATED) {
+            // try to retrieve definition if the parent is available
+            try {
+                NodeState parentState = parent.getNodeState();
+                EffectiveNodeType ent = ntReg.getEffectiveNodeType(parentState.getNodeTypeNames());
+                definition = ent.getApplicableNodeDefinition(info.getQName(), info.getNodetype(), ntReg);
+            } catch (RepositoryException e) {
+                // should not get here
+                log.warn("Internal error", e);
+            } catch (ItemStateException e) {
+                // should not get here
+                log.warn("Internal error", e);
+            } catch (NodeTypeConflictException e) {
+                // should not get here
+               log.warn("Internal error", e);
+            }
+        }
+
+        // now build the nodestate itself
+        NodeState state = new NodeState(entry, info.getNodetype(), info.getMixins(), definition, Status.EXISTING, true, this, ntReg);
+
+        // update NodeEntry from the information present in the NodeInfo (prop entries)
+        List propNames = new ArrayList();
+        for (IdIterator it = info.getPropertyIds(); it.hasNext(); ) {
+            PropertyId pId = (PropertyId) it.nextId();
+            QName propertyName = pId.getQName();
+            propNames.add(propertyName);
+        }
+        try {
+            entry.addPropertyEntries(propNames);
+        } catch (ItemExistsException e) {
+            // should not get here
+            log.warn("Internal error", e);
+        }
+
+        notifyCreated(state);
+        return state;
+    }
+
+    /**
-     * @param parent the parent <code>NodeState</code>.
+     * @param entry
-     * @throws ItemStateException if an error occurs while retrieving the
-     *                            <code>PropertyState</code>.
-    private PropertyState createPropertyState(PropertyInfo info, NodeState parent)
-        throws ItemStateException {
-        try {
-
-            // retrieve property definition
-            EffectiveNodeType ent = wspManager.getNodeTypeRegistry().getEffectiveNodeType(parent.getNodeTypeNames());
-            QPropertyDefinition def = ent.getApplicablePropertyDefinition(info.getQName(), info.getType(), info.isMultiValued());
-
-            // build the PropertyState
-            PropertyState state = new PropertyState(info.getQName(), parent,
-                def, Status.EXISTING, this, service.getIdFactory(), true);
-            state.init(info.getType(), info.getValues());
-            state.addListener(cache);
-            cache.created(state);
-
-            return state;
-        } catch (NodeTypeConflictException e) {
-            String msg = "internal error: failed to build property state.";
-            log.debug(msg);
-            throw new ItemStateException(msg, e);
-        } catch (RepositoryException e) {
-            String msg = "internal error: failed to build property state.";
-            log.debug(msg);
-            throw new ItemStateException(msg, e);
+    private PropertyState createPropertyState(PropertyInfo info, PropertyEntry entry) {
+        // make sure uuid part of id is correct
+        String uniqueID = info.getId().getUniqueID();
+        if (uniqueID != null) {
+            // uniqueID always applies to a parent NodeEntry -> get parentEntry
+            NodeEntry parent = getAncestor(entry, info.getId().getPath().getLength());
+            parent.setUniqueID(uniqueID);
+
+        QPropertyDefinition definition = null;
+        // try to retrieve property definition
+        if (entry.getParent().isAvailable() && entry.getStatus() != Status.INVALIDATED) {
+            NodeState parentState = null;
+            try {
+                parentState = entry.getParent().getNodeState();
+                EffectiveNodeType ent = wspManager.getNodeTypeRegistry().getEffectiveNodeType(parentState.getNodeTypeNames());
+                definition = ent.getApplicablePropertyDefinition(info.getQName(), info.getType(), info.isMultiValued());
+            } catch (ItemStateException e) {
+                // should not get here
+                log.warn("Internal error", e);
+            } catch (RepositoryException e) {
+                // should not get here
+                log.warn("Internal error", e);
+            } catch (NodeTypeConflictException e) {
+                // should not get here
+                log.warn("Internal error", e);
+            }
+        }
+
+        // build the PropertyState
+        PropertyState state = new PropertyState(entry, info.isMultiValued(), definition, Status.EXISTING, true, this, wspManager.getNodeTypeRegistry());
+        state.init(info.getType(), info.getValues());
+
+        //state.addListener(cache);
+        //cache.created(state);
+        notifyCreated(state);
+
+        return state;
-    /**
-     *
-     * @param cache
-     * @see ItemStateFactory#setCache(ItemStateCache)
-     */
-    public void setCache(ItemStateCache cache) {
-        this.cache = cache;
+    private static NodeEntry getAncestor(HierarchyEntry entry, int degree) {
+        NodeEntry parent = entry.getParent();
+        degree--;
+        while (parent != null && degree > 0) {
+            parent = parent.getParent();
+            degree--;
+        }
+        if (degree != 0) {
+            throw new IllegalArgumentException();
+        }
+        return parent;
-
-        private NodeState nodeState;
+        private PropertyId[] references;
-         * @param nodeState
-         * @param referenceIds
+         * @param references
-        private NodeReferencesImpl(NodeState nodeState, PropertyId[] referenceIds) {
-            this.nodeState = nodeState;
-
-            // TODO: improve. make usage of the references returned
-            // with NodeInfo that was just retrieved and implement a notification
-            // mechanism that updates this NodeReference object if references
-            // are modified.
+        private NodeReferencesImpl(PropertyId[] references) {
+            this.references = references;
-            // shortcut
-            if (nodeState.getUniqueID() == null) {
-                return true;
-            }
-            // nodestate has a unique ID and is potentially mix:referenceable
-            // => try to retrieve references
-            try {
-                NodeInfo info = service.getNodeInfo(sessionInfo, nodeState.getNodeId());
-                return info.getReferences().length > 0;
-            } catch (RepositoryException e) {
-                log.error("Internal error.",e);
-                return false;
-            }
+            return references.length <= 0;
-            // shortcut
-            if (nodeState.getUniqueID() == null) {
-                return Collections.EMPTY_SET.iterator();
-            }
-            // nodestate has a uniqueID and is potentially mix:referenceable
-            // => try to retrieve references
-            try {
-                NodeInfo info = service.getNodeInfo(sessionInfo, nodeState.getNodeId());
-                if (info.getReferences().length > 0) {
-                    Set referenceIds = new HashSet();
-                    referenceIds.addAll(Arrays.asList(info.getReferences()));
-                    return Collections.unmodifiableSet(referenceIds).iterator();
-                } else {
-                    return Collections.EMPTY_SET.iterator();
-                }
-            } catch (RepositoryException e) {
-                log.error("Internal error.", e);
+            if (references.length > 0) {
+                Set referenceIds = new HashSet();
+                referenceIds.addAll(Arrays.asList(references));
+                return Collections.unmodifiableSet(referenceIds).iterator();
+            } else {

MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 UPD40 UPD40 UPD40 INS40 INS40 INS43 INS31 INS31 INS31 INS31 UPD42 MOV42 MOV29 MOV83 MOV43 MOV42 MOV44 INS44 MOV43 MOV43 INS8 INS83 MOV43 INS42 INS44 INS44 MOV43 MOV43 MOV8 INS29 MOV43 UPD42 MOV44 MOV43 MOV43 INS83 INS43 INS42 INS44 MOV44 MOV43 MOV43 INS8 MOV29 MOV65 INS83 MOV43 INS42 MOV44 MOV43 MOV43 INS8 MOV43 INS42 MOV44 INS8 INS29 UPD83 MOV43 INS42 MOV44 INS44 INS8 INS83 INS83 INS43 INS42 INS44 INS44 INS8 INS65 UPD43 UPD42 INS43 INS42 INS54 INS43 INS42 INS43 INS42 MOV65 INS65 INS65 UPD43 UPD42 INS42 INS43 INS42 UPD43 UPD42 INS54 UPD65 UPD65 INS54 MOV65 INS21 INS25 MOV54 MOV65 INS65 INS65 MOV65 INS43 INS42 INS60 INS60 INS25 MOV60 INS60 MOV60 INS25 INS60 MOV60 MOV24 INS54 INS21 MOV41 INS43 UPD42 MOV60 INS25 INS60 INS25 INS60 MOV21 INS21 MOV41 INS42 INS43 INS42 INS39 INS42 INS60 INS21 INS61 INS25 INS41 MOV5 INS8 MOV8 INS42 UPD42 INS42 INS8 INS12 INS12 MOV12 INS42 INS42 MOV12 MOV12 INS12 INS68 UPD42 INS12 INS12 MOV12 INS42 UPD42 MOV8 MOV12 MOV12 MOV12 INS12 INS42 INS8 MOV12 MOV12 MOV12 INS32 INS27 INS8 MOV8 INS12 INS42 INS66 INS42 UPD42 MOV42 MOV43 INS59 INS43 INS59 INS27 INS8 INS25 MOV43 INS59 UPD43 MOV27 MOV8 INS25 MOV43 INS59 UPD43 INS8 INS12 INS32 UPD42 INS42 MOV43 INS27 INS8 MOV43 INS59 INS27 INS8 MOV43 INS59 INS32 UPD42 MOV42 INS43 INS59 INS37 INS27 INS8 INS27 INS8 INS42 UPD42 UPD42 MOV41 MOV60 INS41 INS44 INS8 INS44 INS8 MOV60 INS60 INS60 INS60 INS24 INS25 MOV41 INS44 INS8 INS42 INS42 MOV69 INS69 INS60 INS44 INS8 INS44 INS8 MOV60 MOV60 INS60 INS60 INS61 INS25 INS41 INS44 INS8 MOV44 INS8 INS42 INS41 UPD42 INS42 INS42 MOV27 INS38 INS41 MOV44 INS8 INS42 MOV32 INS42 INS42 INS32 INS42 INS33 INS21 INS27 INS8 INS42 INS33 UPD42 UPD42 INS32 INS27 INS8 INS42 INS14 UPD42 UPD42 INS14 INS60 INS21 INS44 INS8 UPD42 MOV42 UPD42 MOV42 UPD42 INS42 INS33 INS60 INS21 INS42 INS33 INS32 INS27 INS60 INS54 INS42 INS14 INS42 INS42 UPD42 MOV42 INS42 INS32 INS42 INS27 INS27 MOV21 INS21 INS42 INS34 INS53 UPD42 INS27 UPD43 UPD43 INS32 INS43 INS42 INS53 UPD43 MOV43 UPD42 MOV42 INS53 INS43 INS59 UPD43 INS5 INS59 INS43 INS59 INS58 INS27 INS37 INS8 INS27 INS8 INS43 INS42 INS53 INS43 INS43 INS59 INS43 INS42 INS53 INS43 INS42 INS53 INS43 INS43 INS5 INS59 UPD43 INS39 INS59 INS27 INS8 UPD43 INS43 INS38 INS8 INS8 INS32 INS43 INS42 INS53 UPD43 INS53 INS32 UPD43 INS53 INS32 INS32 INS14 INS21 INS41 INS32 INS42 INS32 INS42 INS33 INS60 INS21 INS42 INS42 INS32 INS27 INS54 MOV43 INS42 MOV32 MOV32 INS42 INS40 INS9 INS52 INS42 INS43 INS43 INS59 INS32 INS43 INS42 INS21 INS42 INS43 INS59 INS32 INS32 UPD42 MOV42 INS32 INS40 MOV43 INS59 INS8 INS12 INS12 INS12 MOV43 UPD42 MOV42 INS32 INS42 INS40 INS9 INS52 INS32 INS42 INS42 INS42 INS33 INS42 INS34 INS37 INS14 UPD42 INS40 INS34 INS40 UPD42 INS42 UPD42 INS42 INS42 INS42 INS42 INS14 UPD42 INS14 INS42 INS42 INS32 UPD42 INS42 INS32 INS43 INS85 INS42 INS32 INS42 INS42 INS42 INS39 INS59 UPD42 MOV42 INS40 INS42 MOV60 INS60 INS25 INS42 INS42 MOV53 INS42 INS42 INS14 INS42 INS42 INS42 INS32 UPD42 UPD42 INS42 INS14 INS42 INS14 INS42 UPD42 INS32 INS42 UPD42 INS43 INS85 INS42 INS32 UPD42 UPD42 INS42 INS42 INS34 INS42 INS27 INS60 INS60 INS25 INS21 UPD42 UPD42 INS32 INS42 UPD42 INS32 MOV21 MOV21 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS14 UPD42 INS14 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 INS14 INS42 INS42 INS40 INS42 INS42 MOV43 MOV32 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS42 INS42 INS32 INS40 INS8 INS12 INS12 INS12 UPD42 MOV42 INS42 INS42 MOV32 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS32 UPD42 UPD42 INS42 INS42 INS32 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS33 MOV21 MOV60 INS21 INS44 INS8 MOV44 INS8 MOV44 INS8 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS43 UPD42 INS43 INS32 INS42 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS40 INS42 INS42 INS42 INS34 UPD43 INS39 INS59 INS32 INS8 INS8 MOV43 INS32 INS42 INS42 INS42 INS42 INS42 INS43 INS32 INS42 INS43 INS32 INS42 INS42 INS42 UPD42 UPD42 INS40 INS42 INS42 INS40 INS34 INS43 INS59 INS39 INS59 INS32 INS8 INS8 INS37 INS2 INS42 INS42 INS42 INS42 INS7 INS7 INS43 INS32 MOV42 MOV43 INS32 INS42 INS43 INS32 MOV42 UPD42 MOV42 UPD42 MOV42 INS27 INS42 INS42 UPD42 MOV42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS60 MOV60 MOV21 MOV44 INS8 INS44 INS8 MOV44 INS8 UPD42 MOV42 UPD42 MOV42 INS45 INS42 UPD42 MOV42 INS42 INS32 INS7 MOV43 INS7 MOV43 INS42 MOV21 INS21 MOV21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV42 UPD42 MOV42 UPD42 INS42 INS32 INS42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS21 INS21 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 UPD42 MOV42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS21 INS21 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS45 INS42 INS42 INS42 INS32 MOV43 INS59 MOV43 INS21 MOV43 INS42 INS21 INS21 MOV32 UPD42 MOV42 INS42 INS32 UPD42 INS32 INS42 MOV32 INS32 UPD42 MOV42 INS2 UPD42 MOV42 INS2 INS42 INS7 INS7 INS2 UPD42 MOV42 INS2 INS42 INS7 INS7 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS32 UPD42 INS32 INS32 INS32 INS32 UPD42 MOV42 MOV32 INS42 INS32 UPD42 INS45 UPD42 INS42 INS42 INS45 INS42 UPD42 INS45 UPD42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 INS45 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS33 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS33 INS42 UPD42 UPD42 DEL83 DEL43 DEL42 DEL59 DEL23 DEL33 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL42 DEL42 DEL33 DEL33 DEL27 DEL32 DEL32 DEL41 DEL8 DEL8 DEL25 DEL44 DEL31 DEL42 DEL43 DEL8 DEL25 DEL33 DEL33 DEL27 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL32 DEL42 DEL42 DEL42 DEL40 DEL52 DEL32 DEL9 DEL14 DEL59 DEL60 DEL42 DEL43 DEL14 DEL42 DEL32 DEL32 DEL42 DEL42 DEL42 DEL14 DEL59 DEL60 DEL32 DEL21 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL32 DEL21 DEL42 DEL14 DEL53 DEL8 DEL66 DEL66 DEL42 DEL42 DEL43 DEL69 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL32 DEL21 DEL42 DEL14 DEL53 DEL42 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL31 DEL42 DEL42 DEL32 DEL42 DEL22 DEL34 DEL27 DEL42 DEL32 DEL41 DEL8 DEL42 DEL42 DEL44 DEL8 DEL42 DEL43 DEL42 DEL14 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL43 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL32 DEL42 DEL32 DEL32 DEL32 DEL32 DEL21 DEL8 DEL61 DEL42 DEL41 DEL8 DEL54 DEL8 DEL66 DEL42 DEL66 DEL66 DEL65 DEL42 DEL32 DEL45 DEL42 DEL59 DEL60 DEL42 DEL32 DEL42 DEL42 DEL40 DEL52 DEL32 DEL9 DEL14 DEL59 DEL60 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL45 DEL59 DEL60 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL52 DEL42 DEL22 DEL42 DEL42 DEL65 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL29 DEL83 DEL39 DEL42 DEL43 DEL42 DEL44 DEL8 DEL9 DEL8 DEL25 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL9 DEL41 DEL8 DEL12 DEL54 DEL8 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL22 DEL42 DEL32 DEL42 DEL42 DEL32 DEL33 DEL27 DEL40 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL40 DEL42 DEL32 DEL41 DEL8 DEL12 DEL54 DEL8
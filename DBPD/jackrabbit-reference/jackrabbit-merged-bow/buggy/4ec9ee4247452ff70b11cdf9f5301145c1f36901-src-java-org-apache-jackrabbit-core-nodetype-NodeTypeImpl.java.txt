- removed @author and @version (i.e. $Revision & $Id) tags
- removed tab characters from java source code

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@47648 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.log4j.Logger;
+import org.apache.log4j.Logger;
- *
- * @author Stefan Guggisberg
- * @version $Revision: 1.36 $, $Date: 2004/08/30 11:13:46 $
-	this.ent = ent;
-	this.ntMgr = ntMgr;
-	this.nsResolver = nsResolver;
-	try {
-	    // store a clone of the definition
-	    this.ntd = (NodeTypeDef) ntd.clone();
-	} catch (CloneNotSupportedException e) {
-	    // should never get here
-	    log.fatal("internal error", e);
-	    throw new InternalError(e.getMessage());
-	}
+        this.ent = ent;
+        this.ntMgr = ntMgr;
+        this.nsResolver = nsResolver;
+        try {
+            // store a clone of the definition
+            this.ntd = (NodeTypeDef) ntd.clone();
+        } catch (CloneNotSupportedException e) {
+            // should never get here
+            log.fatal("internal error", e);
+            throw new InternalError(e.getMessage());
+        }
-	    throws RepositoryException {
-	return getApplicableChildNodeDef(nodeName, null);
+            throws RepositoryException {
+        return getApplicableChildNodeDef(nodeName, null);
-	    throws RepositoryException {
-	return new NodeDefImpl(ent.getApplicableChildNodeDef(nodeName, nodeTypeName),
-		ntMgr, nsResolver);
+            throws RepositoryException {
+        return new NodeDefImpl(ent.getApplicableChildNodeDef(nodeName, nodeTypeName),
+                ntMgr, nsResolver);
-						    boolean multiValued)
-	    throws RepositoryException {
-	return new PropertyDefImpl(ent.getApplicablePropertyDef(propertyName, type, multiValued),
-		ntMgr, nsResolver);
+                                                    boolean multiValued)
+            throws RepositoryException {
+        return new PropertyDefImpl(ent.getApplicablePropertyDef(propertyName, type, multiValued),
+                ntMgr, nsResolver);
-	return !nodeTypeName.equals(ntd.getName()) && ent.includesNodeType(nodeTypeName);
+        return !nodeTypeName.equals(ntd.getName()) && ent.includesNodeType(nodeTypeName);
-	try {
-	    // return a clone of the definition
-	    return (NodeTypeDef) ntd.clone();
-	} catch (CloneNotSupportedException e) {
-	    // should never get here
-	    log.fatal("internal error", e);
-	    throw new InternalError(e.getMessage());
-	}
+        try {
+            // return a clone of the definition
+            return (NodeTypeDef) ntd.clone();
+        } catch (CloneNotSupportedException e) {
+            // should never get here
+            log.fatal("internal error", e);
+            throw new InternalError(e.getMessage());
+        }
-	ChildNodeDef[] cnda = ent.getAutoCreateNodeDefs();
-	NodeDef[] nodeDefs = new NodeDef[cnda.length];
-	for (int i = 0; i < cnda.length; i++) {
-	    nodeDefs[i] = new NodeDefImpl(cnda[i], ntMgr, nsResolver);
-	}
-	return nodeDefs;
+        ChildNodeDef[] cnda = ent.getAutoCreateNodeDefs();
+        NodeDef[] nodeDefs = new NodeDef[cnda.length];
+        for (int i = 0; i < cnda.length; i++) {
+            nodeDefs[i] = new NodeDefImpl(cnda[i], ntMgr, nsResolver);
+        }
+        return nodeDefs;
-	PropDef[] pda = ent.getAutoCreatePropDefs();
-	PropertyDef[] propDefs = new PropertyDef[pda.length];
-	for (int i = 0; i < pda.length; i++) {
-	    propDefs[i] = new PropertyDefImpl(pda[i], ntMgr, nsResolver);
-	}
-	return propDefs;
+        PropDef[] pda = ent.getAutoCreatePropDefs();
+        PropertyDef[] propDefs = new PropertyDef[pda.length];
+        for (int i = 0; i < pda.length; i++) {
+            propDefs[i] = new PropertyDefImpl(pda[i], ntMgr, nsResolver);
+        }
+        return propDefs;
-	PropDef[] pda = ent.getMandatoryPropDefs();
-	PropertyDef[] propDefs = new PropertyDef[pda.length];
-	for (int i = 0; i < pda.length; i++) {
-	    propDefs[i] = new PropertyDefImpl(pda[i], ntMgr, nsResolver);
-	}
-	return propDefs;
+        PropDef[] pda = ent.getMandatoryPropDefs();
+        PropertyDef[] propDefs = new PropertyDef[pda.length];
+        for (int i = 0; i < pda.length; i++) {
+            propDefs[i] = new PropertyDefImpl(pda[i], ntMgr, nsResolver);
+        }
+        return propDefs;
-	ChildNodeDef[] cnda = ent.getMandatoryNodeDefs();
-	NodeDef[] nodeDefs = new NodeDef[cnda.length];
-	for (int i = 0; i < cnda.length; i++) {
-	    nodeDefs[i] = new NodeDefImpl(cnda[i], ntMgr, nsResolver);
-	}
-	return nodeDefs;
+        ChildNodeDef[] cnda = ent.getMandatoryNodeDefs();
+        NodeDef[] nodeDefs = new NodeDef[cnda.length];
+        for (int i = 0; i < cnda.length; i++) {
+            nodeDefs[i] = new NodeDefImpl(cnda[i], ntMgr, nsResolver);
+        }
+        return nodeDefs;
-	    throws ValueFormatException, ConstraintViolationException, RepositoryException {
-	EffectiveNodeType.checkSetPropertyValueConstraints(def.unwrap(), values);
+            throws ValueFormatException, ConstraintViolationException, RepositoryException {
+        EffectiveNodeType.checkSetPropertyValueConstraints(def.unwrap(), values);
-	return ntd.getName();
+        return ntd.getName();
-	// declared supertypes
-	QName[] ntNames = ntd.getSupertypes();
-	HashSet declared = new HashSet();
-	for (int i = 0; i < ntNames.length; i++) {
-	    declared.add(ntNames[i]);
-	}
-	// all supertypes
-	ntNames = ent.getInheritedNodeTypes();
+        // declared supertypes
+        QName[] ntNames = ntd.getSupertypes();
+        HashSet declared = new HashSet();
+        for (int i = 0; i < ntNames.length; i++) {
+            declared.add(ntNames[i]);
+        }
+        // all supertypes
+        ntNames = ent.getInheritedNodeTypes();
-	// filter from all supertypes those that are not declared
-	ArrayList inherited = new ArrayList();
-	for (int i = 0; i < ntNames.length; i++) {
-	    if (!declared.contains(ntNames[i])) {
-		try {
-		    inherited.add(ntMgr.getNodeType(ntNames[i]));
-		} catch (NoSuchNodeTypeException e) {
-		    // should never get here
-		    log.error("undefined supertype", e);
-		    return new NodeType[0];
-		}
-	    }
-	}
+        // filter from all supertypes those that are not declared
+        ArrayList inherited = new ArrayList();
+        for (int i = 0; i < ntNames.length; i++) {
+            if (!declared.contains(ntNames[i])) {
+                try {
+                    inherited.add(ntMgr.getNodeType(ntNames[i]));
+                } catch (NoSuchNodeTypeException e) {
+                    // should never get here
+                    log.error("undefined supertype", e);
+                    return new NodeType[0];
+                }
+            }
+        }
-	return (NodeType[]) inherited.toArray(new NodeType[inherited.size()]);
+        return (NodeType[]) inherited.toArray(new NodeType[inherited.size()]);
-	try {
-	    return ntd.getName().toJCRName(nsResolver);
-	} catch (NoPrefixDeclaredException npde) {
-	    // should never get here
-	    log.error("encountered unregistered namespace in node type name", npde);
-	    return ntd.getName().toString();
-	}
+        try {
+            return ntd.getName().toJCRName(nsResolver);
+        } catch (NoPrefixDeclaredException npde) {
+            // should never get here
+            log.error("encountered unregistered namespace in node type name", npde);
+            return ntd.getName().toString();
+        }
-	return ntd.isMixin();
+        return ntd.isMixin();
-	return ntd.hasOrderableChildNodes();
+        return ntd.hasOrderableChildNodes();
-	QName[] ntNames = ent.getInheritedNodeTypes();
-	NodeType[] supertypes = new NodeType[ntNames.length];
-	for (int i = 0; i < ntNames.length; i++) {
-	    try {
-		supertypes[i] = ntMgr.getNodeType(ntNames[i]);
-	    } catch (NoSuchNodeTypeException e) {
-		// should never get here
-		log.error("undefined supertype", e);
-		return new NodeType[0];
-	    }
-	}
-	return supertypes;
+        QName[] ntNames = ent.getInheritedNodeTypes();
+        NodeType[] supertypes = new NodeType[ntNames.length];
+        for (int i = 0; i < ntNames.length; i++) {
+            try {
+                supertypes[i] = ntMgr.getNodeType(ntNames[i]);
+            } catch (NoSuchNodeTypeException e) {
+                // should never get here
+                log.error("undefined supertype", e);
+                return new NodeType[0];
+            }
+        }
+        return supertypes;
-	ChildNodeDef[] cnda = ent.getAllNodeDefs();
-	NodeDef[] nodeDefs = new NodeDef[cnda.length];
-	for (int i = 0; i < cnda.length; i++) {
-	    nodeDefs[i] = new NodeDefImpl(cnda[i], ntMgr, nsResolver);
-	}
-	return nodeDefs;
+        ChildNodeDef[] cnda = ent.getAllNodeDefs();
+        NodeDef[] nodeDefs = new NodeDef[cnda.length];
+        for (int i = 0; i < cnda.length; i++) {
+            nodeDefs[i] = new NodeDefImpl(cnda[i], ntMgr, nsResolver);
+        }
+        return nodeDefs;
-	PropDef[] pda = ent.getAllPropDefs();
-	PropertyDef[] propDefs = new PropertyDef[pda.length];
-	for (int i = 0; i < pda.length; i++) {
-	    propDefs[i] = new PropertyDefImpl(pda[i], ntMgr, nsResolver);
-	}
-	return propDefs;
+        PropDef[] pda = ent.getAllPropDefs();
+        PropertyDef[] propDefs = new PropertyDef[pda.length];
+        for (int i = 0; i < pda.length; i++) {
+            propDefs[i] = new PropertyDefImpl(pda[i], ntMgr, nsResolver);
+        }
+        return propDefs;
-	QName[] ntNames = ntd.getSupertypes();
-	NodeType[] supertypes = new NodeType[ntNames.length];
-	for (int i = 0; i < ntNames.length; i++) {
-	    try {
-		supertypes[i] = ntMgr.getNodeType(ntNames[i]);
-	    } catch (NoSuchNodeTypeException e) {
-		// should never get here
-		log.error("undefined supertype", e);
-		return new NodeType[0];
-	    }
-	}
-	return supertypes;
+        QName[] ntNames = ntd.getSupertypes();
+        NodeType[] supertypes = new NodeType[ntNames.length];
+        for (int i = 0; i < ntNames.length; i++) {
+            try {
+                supertypes[i] = ntMgr.getNodeType(ntNames[i]);
+            } catch (NoSuchNodeTypeException e) {
+                // should never get here
+                log.error("undefined supertype", e);
+                return new NodeType[0];
+            }
+        }
+        return supertypes;
-	ChildNodeDef[] cnda = ntd.getChildNodeDefs();
-	NodeDef[] nodeDefs = new NodeDef[cnda.length];
-	for (int i = 0; i < cnda.length; i++) {
-	    nodeDefs[i] = new NodeDefImpl(cnda[i], ntMgr, nsResolver);
-	}
-	return nodeDefs;
+        ChildNodeDef[] cnda = ntd.getChildNodeDefs();
+        NodeDef[] nodeDefs = new NodeDef[cnda.length];
+        for (int i = 0; i < cnda.length; i++) {
+            nodeDefs[i] = new NodeDefImpl(cnda[i], ntMgr, nsResolver);
+        }
+        return nodeDefs;
-	if (value == null) {
-	    // setting a property to null is equivalent of removing it
-	    return canRemoveItem(propertyName);
-	}
-	try {
-	    QName name = QName.fromJCRName(propertyName, nsResolver);
-	    int type = (value == null) ? PropertyType.UNDEFINED : value.getType();
-	    PropertyDefImpl def = getApplicablePropertyDef(name, type, false);
-	    if (def.isProtected()) {
-		return false;
-	    }
-	    if (def.isMultiple()) {
-		return false;
-	    }
-	    InternalValue internalValue = InternalValue.create(value, nsResolver);
-	    checkSetPropertyValueConstraints(def, new InternalValue[]{internalValue});
-	    return true;
-	} catch (BaseException be) {
-	    // implementation specific exception, fall through
-	} catch (RepositoryException re) {
-	    // fall through
-	}
-	return false;
+        if (value == null) {
+            // setting a property to null is equivalent of removing it
+            return canRemoveItem(propertyName);
+        }
+        try {
+            QName name = QName.fromJCRName(propertyName, nsResolver);
+            int type = (value == null) ? PropertyType.UNDEFINED : value.getType();
+            PropertyDefImpl def = getApplicablePropertyDef(name, type, false);
+            if (def.isProtected()) {
+                return false;
+            }
+            if (def.isMultiple()) {
+                return false;
+            }
+            InternalValue internalValue = InternalValue.create(value, nsResolver);
+            checkSetPropertyValueConstraints(def, new InternalValue[]{internalValue});
+            return true;
+        } catch (BaseException be) {
+            // implementation specific exception, fall through
+        } catch (RepositoryException re) {
+            // fall through
+        }
+        return false;
-	if (values == null) {
-	    // setting a property to null is equivalent of removing it
-	    return canRemoveItem(propertyName);
-	}
-	try {
-	    QName name = QName.fromJCRName(propertyName, nsResolver);
-	    int type = (values == null || values.length == 0) ? PropertyType.UNDEFINED : values[0].getType();
-	    PropertyDefImpl def = getApplicablePropertyDef(name, type, true);
-	    if (def.isProtected()) {
-		return false;
-	    }
-	    if (!def.isMultiple()) {
-		return false;
-	    }
-	    ArrayList list = new ArrayList();
-	    // convert values and compact array (purge null entries)
-	    for (int i = 0; i < values.length; i++) {
-		if (values[i] != null) {
-		    InternalValue internalValue = InternalValue.create(values[i], nsResolver);
-		    list.add(internalValue);
-		}
-	    }
-	    InternalValue[] internalValues = (InternalValue[]) list.toArray(new InternalValue[list.size()]);
-	    checkSetPropertyValueConstraints(def, internalValues);
-	    return true;
-	} catch (BaseException be) {
-	    // implementation specific exception, fall through
-	} catch (RepositoryException re) {
-	    // fall through
-	}
-	return false;
+        if (values == null) {
+            // setting a property to null is equivalent of removing it
+            return canRemoveItem(propertyName);
+        }
+        try {
+            QName name = QName.fromJCRName(propertyName, nsResolver);
+            int type = (values == null || values.length == 0) ? PropertyType.UNDEFINED : values[0].getType();
+            PropertyDefImpl def = getApplicablePropertyDef(name, type, true);
+            if (def.isProtected()) {
+                return false;
+            }
+            if (!def.isMultiple()) {
+                return false;
+            }
+            ArrayList list = new ArrayList();
+            // convert values and compact array (purge null entries)
+            for (int i = 0; i < values.length; i++) {
+                if (values[i] != null) {
+                    InternalValue internalValue = InternalValue.create(values[i], nsResolver);
+                    list.add(internalValue);
+                }
+            }
+            InternalValue[] internalValues = (InternalValue[]) list.toArray(new InternalValue[list.size()]);
+            checkSetPropertyValueConstraints(def, internalValues);
+            return true;
+        } catch (BaseException be) {
+            // implementation specific exception, fall through
+        } catch (RepositoryException re) {
+            // fall through
+        }
+        return false;
-	try {
-	    ent.checkAddNodeConstraints(QName.fromJCRName(childNodeName, nsResolver));
-	    return true;
-	} catch (BaseException be) {
-	    // implementation specific exception, fall through
-	} catch (RepositoryException re) {
-	    // fall through
-	}
-	return false;
+        try {
+            ent.checkAddNodeConstraints(QName.fromJCRName(childNodeName, nsResolver));
+            return true;
+        } catch (BaseException be) {
+            // implementation specific exception, fall through
+        } catch (RepositoryException re) {
+            // fall through
+        }
+        return false;
-	try {
-	    ent.checkAddNodeConstraints(QName.fromJCRName(childNodeName, nsResolver), QName.fromJCRName(nodeTypeName, nsResolver));
-	    return true;
-	} catch (BaseException be) {
-	    // implementation specific exception, fall through
-	} catch (RepositoryException re) {
-	    // fall through
-	}
-	return false;
+        try {
+            ent.checkAddNodeConstraints(QName.fromJCRName(childNodeName, nsResolver), QName.fromJCRName(nodeTypeName, nsResolver));
+            return true;
+        } catch (BaseException be) {
+            // implementation specific exception, fall through
+        } catch (RepositoryException re) {
+            // fall through
+        }
+        return false;
-	try {
-	    ent.checkRemoveItemConstraints(QName.fromJCRName(itemName, nsResolver));
-	    return true;
-	} catch (BaseException be) {
-	    // implementation specific exception, fall through
-	} catch (RepositoryException re) {
-	    // fall through
-	}
-	return false;
+        try {
+            ent.checkRemoveItemConstraints(QName.fromJCRName(itemName, nsResolver));
+            return true;
+        } catch (BaseException be) {
+            // implementation specific exception, fall through
+        } catch (RepositoryException re) {
+            // fall through
+        }
+        return false;
-	PropDef[] pda = ntd.getPropertyDefs();
-	PropertyDef[] propDefs = new PropertyDef[pda.length];
-	for (int i = 0; i < pda.length; i++) {
-	    propDefs[i] = new PropertyDefImpl(pda[i], ntMgr, nsResolver);
-	}
-	return propDefs;
+        PropDef[] pda = ntd.getPropertyDefs();
+        PropertyDef[] propDefs = new PropertyDef[pda.length];
+        for (int i = 0; i < pda.length; i++) {
+            propDefs[i] = new PropertyDefImpl(pda[i], ntMgr, nsResolver);
+        }
+        return propDefs;

MOV26 DEL66 DEL65 DEL66 DEL65
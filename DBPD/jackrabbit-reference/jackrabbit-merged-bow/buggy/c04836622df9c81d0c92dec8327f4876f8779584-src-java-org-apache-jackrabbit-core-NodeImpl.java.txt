- fixed restore bugs
- implemented Workspace.restore() [not tested yet]

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@157553 13f79535-47bb-0310-9956-ffa450edef68

-        // TODO: change if Version.getContainingVersionHistory() is introduced
-        if (!version.getParent().isSame(getVersionHistory())) {
+        if (!((VersionImpl) version).getContainingVersionHistory().isSame(getVersionHistory())) {
+            NodeImpl node;
+            try {
+                // check if versionable node exists
+                InternalFrozenNode fn = ((VersionImpl) version).getFrozenNode();
+                node = (NodeImpl) session.getNodeByUUID(fn.getFrozenUUID());
+                if (removeExisting) {
+                    try {
+                        Path dstPath = Path.create(getPrimaryPath(), relPath, session.getNamespaceResolver(), true);
+                        // move to respective location
+                        session.move(node.getPath(), dstPath.toJCRPath(session.getNamespaceResolver()));
+                        // need to refetch ?
+                        node = (NodeImpl) session.getNodeByUUID(fn.getFrozenUUID());
+                    } catch (MalformedPathException e) {
+                        throw new RepositoryException(e);
+                    } catch (NoPrefixDeclaredException e) {
+                        throw new RepositoryException("InternalError.", e);
+                    }
+                } else {
+                    throw new ItemExistsException("Unable to restore version. Versionable node already exists.");
+                }
+            } catch (ItemNotFoundException e) {
+                // not found, create new one
+                node = addNode(relPath, ((VersionImpl) version).getFrozenNode());
+            }
+
-            NodeImpl node = addNode(relPath, ((VersionImpl) version).getFrozenNode());
-        save();
+        // session.save/revert is done in internal restore
-    private void internalRestore(InternalVersion version, VersionSelector vsel,
+    protected InternalVersion[] internalRestore(InternalVersion version, VersionSelector vsel,
-        restoreFrozenState(version.getFrozenNode(), vsel, removeExisting);
+        HashSet restored = new HashSet();
+        restoreFrozenState(version.getFrozenNode(), vsel, restored, removeExisting);
+        restored.add(version);
+
+        return (InternalVersion[]) restored.toArray(new InternalVersion[restored.size()]);
-    void restoreFrozenState(InternalFrozenNode freeze, VersionSelector vsel, boolean removeExisting)
+    void restoreFrozenState(InternalFrozenNode freeze, VersionSelector vsel, Set restored, boolean removeExisting)
-        // restore the frozen nodes
-        InternalFreeze[] frozenNodes = freeze.getFrozenChildNodes();
-
-        // first delete all non frozen version histories, ie. all OPV!=Version
+        // first delete all non frozen version histories
-            if (n.getDefinition().getOnParentVersion() == OnParentVersionAction.COPY) {
-                n.remove();
+            if (!freeze.hasFrozenHistory(n.internalGetUUID())) {
+                n.internalRemove(true);
-        // now restore the frozen ones
+        // restore the frozen nodes
+        InternalFreeze[] frozenNodes = freeze.getFrozenChildNodes();
+                        // check if one of this restoretrees node
-                n.restoreFrozenState(f, vsel, removeExisting);
+                n.restoreFrozenState(f, vsel, restored, removeExisting);
-                // check if representing vh already exists somewhere
+                // check if representing versionable already exists somewhere
-                    if (hasNode(n.getQName())) {
+                    if (n.getParent().isSame(this)) {
-                    } else {
+                    } else if (removeExisting) {
+                    } else {
+                        // since we delete the OPV=Copy children beforehand, all
+                        // found nodes must be outside of this tree
+                        throw new ItemExistsException("Unable to restore node, item already exists outside of restored tree: " + n.safeGetJCRPath());
+                    // add this version to set
+                    restored.add(v);

UPD83 INS5 INS44 MOV60 INS25 INS43 INS85 INS60 INS21 INS41 INS43 INS42 MOV32 MOV8 INS8 INS42 INS43 INS59 INS32 INS11 INS42 INS60 INS54 MOV21 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS5 INS32 MOV43 INS59 INS8 INS12 INS43 INS43 INS85 INS42 INS42 INS3 INS38 INS36 UPD42 INS42 INS60 INS21 MOV25 INS44 MOV8 INS42 INS42 INS5 INS32 INS32 INS11 INS43 INS59 INS7 INS42 INS8 INS8 INS43 INS42 INS21 INS43 INS85 INS42 INS42 INS42 INS42 MOV32 INS43 INS42 INS42 INS42 INS32 INS42 INS11 INS54 INS53 INS42 INS7 INS42 UPD42 UPD42 INS9 INS42 INS42 INS36 INS42 INS43 INS32 INS8 INS12 INS12 INS14 INS42 MOV32 INS25 INS21 INS11 INS42 INS42 INS42 INS32 INS60 INS21 INS21 INS44 INS8 INS44 INS8 INS43 INS45 INS32 INS8 MOV25 INS32 INS43 INS42 INS42 INS42 INS43 INS59 INS32 INS7 INS43 INS42 INS53 INS43 INS42 INS53 INS42 INS32 INS42 INS52 INS42 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS11 INS42 INS14 INS42 INS14 INS42 INS42 INS53 INS42 INS42 INS32 INS42 INS32 INS9 INS42 INS42 INS42 INS42 INS32 INS43 INS32 INS43 INS42 INS43 INS45 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS43 INS27 INS42 INS42 INS42 INS45 INS32 MOV42 UPD42 MOV42 DEL42 DEL42 DEL59 DEL60 DEL42 DEL32 DEL21 DEL39 DEL42 DEL32 DEL40 DEL27 DEL42 DEL32 DEL32 DEL8
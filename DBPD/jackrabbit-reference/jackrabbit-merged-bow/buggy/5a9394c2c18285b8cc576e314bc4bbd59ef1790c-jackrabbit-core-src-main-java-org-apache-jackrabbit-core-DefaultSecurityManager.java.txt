JCR-2313 - Improvements to user management (2) [work in progress] 
-> see issue for details

JCR-2333 - ItemImpl#validateTransientItems: Incomplete validation of mandatory child item
-> patch2

JCR-2195 - Provide possibility to import protected items using Session/Workspace import functionality
-> deal with reference properties
-> make import handlers configurable
-> add userimporter

JCR-171 - Make the extraction of Session UserIDs from Subjects configurable
-> extend SecurityManagerConfig and retrieve uid from principal name if configured
     class is present in the subject

JCR-2351 - Make Authorizable.setProperty more noisy in case of failure

JCR-2331 - Configurable DefaultPolicy replacing Initialization within the ACProvider
-> initial steps. remove code that relies on the default-init
-> add TODOs

JCR-2291 - Issues with compiled permissions of ACL provider
-> remove code searching for DENY-read entries in case of default initialization of ac entries

and here and there minor improvement, usage of generics etc....

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@828791 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.api.security.user.User;
-import org.apache.jackrabbit.core.config.BeanConfig;
+import org.apache.jackrabbit.core.config.UserManagerConfig;
-     * session on the system workspace.
+     * System session.
-    private SystemSession securitySession;
+    private SystemSession systemSession;
-     * System Sessions PrincipalMangager used for internal access to Principals
-     */
-    private PrincipalManager systemPrincipalManager;
-
-    /**
-    private String anonymousId;
+    protected String anonymousId;
-        securitySession = (SystemSession) systemSession;
+        this.systemSession = (SystemSession) systemSession;
-        systemUserManager = createUserManager(securitySession);
-        createSystemUsers(systemUserManager, adminId, anonymousId);
+        systemUserManager = createUserManager(this.systemSession);
+        createSystemUsers(systemUserManager, this.systemSession, adminId, anonymousId);
-        acProviderFactory.init(securitySession);
+        acProviderFactory.init(this.systemSession);
-            workspaceAccessManager = new WorkspaceAccessManagerImpl();
+            workspaceAccessManager = createDefaultWorkspaceAccessManager();
-        workspaceAccessManager.init(securitySession);
+        workspaceAccessManager.init(this.systemSession);
-        PrincipalProvider defaultPP = new DefaultPrincipalProvider(securitySession, (UserManagerImpl) systemUserManager);
-        defaultPP.init(new Properties());
+        PrincipalProvider defaultPP = createDefaultPrincipalProvider();
-        // create the principal manager for the security workspace
-        systemPrincipalManager = new PrincipalManagerImpl(securitySession, principalProviderRegistry.getProviders());
-
-     * Creates a {@link UserManagerImpl} for the given session. May be overridden
-     * to return a custom implementation.
-     *
-     * @param session session
-     * @return user manager
-     * @throws RepositoryException if an error occurs
-     */
-    protected UserManagerImpl createUserManager(SessionImpl session) throws RepositoryException {
-        BeanConfig umc = repository.getConfig().getSecurityConfig().getSecurityManagerConfig().getUserManagerConfig();
-        Properties config = null;
-        if (umc != null) {
-            // TODO: deal with other user manager implementations.
-            String clName = umc.getClassName();
-            if (clName != null && !(UserManagerImpl.class.getName().equals(clName) || clName.length() == 0)) {
-                log.warn("Unsupported custom UserManager implementation: '" + clName + "' -> Ignored.");
-            }
-            config = umc.getParameters();
-        }
-        return new UserManagerImpl(session, adminId, config);
-    }
-
-    /**
-        if (session == securitySession) {
-            return systemPrincipalManager;
-        } else if (session instanceof SessionImpl) {
+        if (session instanceof SessionImpl) {
-            return new PrincipalManagerImpl(sImpl, principalProviderRegistry.getProviders());
+            return createPrincipalManager(sImpl);
-        if (session == securitySession) {
+        if (session == systemSession) {
-            String workspaceName = securitySession.getWorkspace().getName();
+            String workspaceName = systemSession.getWorkspace().getName();
-     * @see JackrabbitSecurityManager#getUserID(Subject)
+     * @see JackrabbitSecurityManager#getUserID(javax.security.auth.Subject, String)
-    public String getUserID(Subject subject) throws RepositoryException {
+    public String getUserID(Subject subject, String workspaceName) throws RepositoryException {
+
+        /* if there is a configure principal class that should be used to
+           determine the UserID -> try this one. */
+        Class cl = getConfig().getUserIdClass();
+        if (cl != null) {
+            Set<Principal> s = subject.getPrincipals(cl);
+            if (!s.isEmpty()) {
+                for (Principal p : s) {
+                    if (!(p instanceof java.security.acl.Group)) {
+                        return p.getName();
+                    }
+                }
+                // all principals found with the given p-Class were Group principals
+                log.debug("Only Group principals found with class '" + cl.getName() + "' -> Not used for UserID.");
+            } else {
+                log.debug("No principal found with class '" + cl.getName() + "'.");
+            }
+        }
+
-         Retrieve userID from the subject.
+         Fallback szenario to retrieve userID from the subject:
-         name must not be equals to the UserID by definition, the userID
-         may either be obtained from the login-credentials or from the
-         user manager. in the latter case the set of principals present with
-         the specified subject is used to search for the user.
+         name may not be equals to the UserID, the id is retrieved by
+         searching for the corresponding authorizable and if this doesn't
+         succeed an attempt is made to obtained it from the login-credentials.
-        // try simple access to userID over SimpleCredentials first.
-        Iterator<SimpleCredentials> creds = subject.getPublicCredentials(
-                SimpleCredentials.class).iterator();
-        if (creds.hasNext()) {
-            SimpleCredentials sc = creds.next();
-            uid = sc.getUserID();
-        } else {
-            // no SimpleCredentials: retrieve authorizables corresponding to
-            // a non-group principal. the first one present is used to determine
-            // the userID.
+
+        // first try to retrieve an authorizable corresponding to
+        // a non-group principal. the first one present is used
+        // to determine the userID.
+        try {
+            UserManager umgr = getSystemUserManager(workspaceName);
-                    Authorizable authorz = systemUserManager.getAuthorizable(p);
+                    Authorizable authorz = umgr.getAuthorizable(p);
+        } catch (RepositoryException e) {
+            // failed to access userid via user manager -> use fallback 2.
+            log.error("Unexpected error while retrieving UserID.", e);
+
+        // 2. if no matching user is found try simple access to userID over
+        // SimpleCredentials.
+        if (uid == null) {
+            Iterator<SimpleCredentials> creds = subject.getPublicCredentials(
+                    SimpleCredentials.class).iterator();
+            if (creds.hasNext()) {
+                SimpleCredentials sc = creds.next();
+                uid = sc.getUserID();
+            }
+        }
+
-     * {@link Subject}.<br>
+     * {@link Subject}. The workspace name is ignored and users are
+     * stored and retrieved from a specific (separate) workspace.<br>
-    public AuthContext getAuthContext(Credentials creds, Subject subject)
+    public AuthContext getAuthContext(Credentials creds, Subject subject, String workspaceName)
-        return authContextProvider.getAuthContext(creds, subject, securitySession,
-                principalProviderRegistry, adminId, anonymousId);
+        return getAuthContextProvider().getAuthContext(creds, subject, systemSession,
+                getPrincipalProviderRegistry(), adminId, anonymousId);
+    //----------------------------------------------------------< protected >---    
+    /**
+     * @return The <code>SecurityManagerConfig</code> configured for the
+     * repository this manager has been created for.
+     */
+    protected SecurityManagerConfig getConfig() {
+        return repository.getConfig().getSecurityConfig().getSecurityManagerConfig();
+    }   
+
+    /**
+     * @param workspaceName
+     * @return The system user manager. Since this implementation stores users
+     * in a dedicated workspace the system user manager is the same for all
+     * sessions irrespective of the workspace.
+     */
+    protected UserManager getSystemUserManager(String workspaceName) throws RepositoryException {
+        return systemUserManager;
+    }
+
+    /**
+     * Creates a {@link UserManagerImpl} for the given session. May be overridden
+     * to return a custom implementation.
+     *
+     * @param session session
+     * @return user manager
+     * @throws RepositoryException if an error occurs
+     */
+    protected UserManagerImpl createUserManager(SessionImpl session) throws RepositoryException {
+        UserManagerConfig umc = getConfig().getUserManagerConfig();
+        Properties params = (umc == null) ? null : umc.getParameters();
+
+        // since users are stored in and retrieved from a dedicated workspace
+        // only the system session assigned with that workspace will get the
+        // system user manager (special implementation that asserts the existance
+        // of the admin user).
+        if (session == systemSession) {
+            return new SystemUserManager(systemSession, params);
+        } else {
+            UserManagerImpl um;
+            if (umc != null) {
+                Class<?>[] paramTypes = new Class[] { SessionImpl.class, String.class, Properties.class };
+                um = (UserManagerImpl) umc.getUserManager(UserManagerImpl.class, paramTypes, (SessionImpl) session, adminId, params);
+                // TODO: should we make sure the implementation doesn't allow
+                // TODO: to change the autosave behavior? since the user manager
+                // TODO: writes to a separate workspace this would cause troubles.
+            } else {
+                um = new UserManagerImpl(session, adminId, params);
+            }
+            return um;
+        }
+    }
+
+    /**
+     * @param session The session used to create the principal manager.
+     * @return A new instance of PrincipalManagerImpl
+     * @throws javax.jcr.RepositoryException If an error occurs.
+     */
+    protected PrincipalManager createPrincipalManager(SessionImpl session) throws RepositoryException {
+        return new PrincipalManagerImpl(session, getPrincipalProviderRegistry().getProviders());
+    }
+
+    /**
+     * @return A nwe instance of WorkspaceAccessManagerImpl to be used as
+     * default workspace access manager if the configuration doesn't specify one.
+     */
+    protected WorkspaceAccessManager createDefaultWorkspaceAccessManager() {
+        return new WorkspaceAccessManagerImpl();
+    }
+
+    /**
+     * Creates the default principal provider used to create the
+     * {@link PrincipalProviderRegistry}.
+     * 
+     * @return An new instance of <code>DefaultPrincipalProvider</code>.
+     * @throws RepositoryException If an error occurs.
+     */
+    protected PrincipalProvider createDefaultPrincipalProvider() throws RepositoryException {
+        PrincipalProvider defaultPP = new DefaultPrincipalProvider(this.systemSession, (UserManagerImpl) systemUserManager);
+        defaultPP.init(new Properties());
+        return defaultPP;
+    }
+
+    /**
+     * @return The PrincipalProviderRegistry created during initialization.
+     */
+    protected PrincipalProviderRegistry getPrincipalProviderRegistry() {
+        return principalProviderRegistry;
+    }
+
+    /**
+     * @return The AuthContextProvider created during initialization.
+     */
+    protected AuthContextProvider getAuthContextProvider() {
+        return authContextProvider;
+    }
+
+    /**
+     * Throws <code>IllegalStateException</code> if this manager hasn't been
+     * initialized.
+     */
+    protected void checkInitialized() {
+        if (!initialized) {
+            throw new IllegalStateException("Not initialized");
+        }
+    }
+
+    /**
+     * @return The system session used to initialize this SecurityManager.
+     */
+    protected Session getSystemSession() {
+        return systemSession;
+    }
+
+    /**
+     * @return The repository used to initialize this SecurityManager.
+     */
+    protected Repository getRepository() {
+        return repository;
+    }
+     * @param session
-    private static void createSystemUsers(UserManager userManager,
-                                          String adminId,
-                                          String anonymousId) throws RepositoryException {
-        Principal pr = new PrincipalImpl(SecurityConstants.ADMINISTRATORS_NAME);
-        Group admins = (Group) userManager.getAuthorizable(pr);
-        if (admins == null) {
-            admins = userManager.createGroup(new PrincipalImpl(SecurityConstants.ADMINISTRATORS_NAME));
-            log.debug("...created administrators group with name '"+SecurityConstants.ADMINISTRATORS_NAME+"'");
-        }
+    static void createSystemUsers(UserManager userManager,
+                                  SystemSession session,
+                                  String adminId,
+                                  String anonymousId) throws RepositoryException {
+        Authorizable admin = null;
-            Authorizable admin = userManager.getAuthorizable(adminId);
+            admin = userManager.getAuthorizable(adminId);
-                log.info("...created admin-user with id \'" + adminId + "\' ...");
-                admins.addMember(admin);
-                log.info("...added admin \'" + adminId + "\' as member of the administrators group.");
+                if (!userManager.isAutoSave()) {
+                    session.save();
+                }
+                log.info("... created admin-user with id \'" + adminId + "\' ...");
+        // assume administrators groupID and principalName are the same.
+        // and avoid retrieving group by principal.
+        Group admins = (Group) userManager.getAuthorizable(SecurityConstants.ADMINISTRATORS_NAME);
+        if (admins == null) {
+            admins = userManager.createGroup(new PrincipalImpl(SecurityConstants.ADMINISTRATORS_NAME));
+            if (!userManager.isAutoSave()) {
+                session.save();
+            }
+            log.info("... created administrators group with name '"+SecurityConstants.ADMINISTRATORS_NAME+"'");
+        }
+
+        try {
+            if (admins != null && admins.addMember(admin)) {
+                if (!userManager.isAutoSave()) {
+                    session.save();
+                }
+                log.info("... added admin '" + adminId + "' as member of the administrators group.");
+            }
+        } catch (RepositoryException e) {
+            // administrator has full permissions anyway. just log a
+            // warning and ignore the error.
+            log.warn("Unexpected error while adding admin to the administrators group", e);
+        }
+
-                log.info("...created anonymous-user with id \'" + anonymousId + "\' ...");
+                if (!userManager.isAutoSave()) {
+                    session.save();
+                }
+                log.info("... created anonymous-user with id \'" + anonymousId + "\' ...");
-    private void checkInitialized() {
-        if (!initialized) {
-            throw new IllegalStateException("Not initialized");
-        }
-    }
-
-    private class WorkspaceAccessManagerImpl implements SecurityConstants, WorkspaceAccessManager {
+    private final class WorkspaceAccessManagerImpl implements SecurityConstants, WorkspaceAccessManager {
-         * @param securitySession
-        public void init(Session securitySession) throws RepositoryException {
+        public void init(Session systemSession) throws RepositoryException {
+
+    /**
+     * System user manager that (re) creates the admin user in case it doesn't
+     * exist yet (upon initial startup) or has been deleted.
+     */
+    protected final class  SystemUserManager extends UserManagerImpl {
+
+        private final SystemSession session;
+        private String adminPw;
+
+        protected SystemUserManager(SystemSession session, Properties config) throws RepositoryException {
+            super(session, adminId, config);
+            this.session = session;
+            adminPw = adminId; // The default value as defined upon #createSystemUsers
+        }
+
+        @Override
+        public Authorizable getAuthorizable(String id) throws RepositoryException {
+            Authorizable a = super.getAuthorizable(id);
+            if (a == null && adminId.equals(id)) {
+                log.info("Admin user does not exist.");
+                a = createAdmin(adminId, adminPw);
+            }
+            return a;
+        }
+
+        private User createAdmin(String adminId, String pw) throws RepositoryException {
+            User admin = createUser(adminId, pw);
+            if (!isAutoSave()) {
+                session.save();
+            }
+            log.info("... created admin user with id \'" + adminId + "\' and default pw.");
+            return admin;
+        }
+    }

MOV26 INS26 MOV31 INS40 UPD40 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS55 UPD83 INS44 INS44 INS29 INS83 INS43 INS42 INS8 INS29 INS83 INS43 INS42 INS44 INS43 INS8 MOV29 MOV83 MOV43 MOV42 MOV44 MOV43 INS8 INS29 INS83 MOV43 INS42 INS44 INS43 INS8 INS29 INS83 INS43 INS42 INS8 INS29 INS83 INS43 INS42 INS43 INS8 INS29 INS83 INS43 INS42 INS8 INS29 INS83 INS43 INS42 INS8 INS29 UPD83 INS29 INS83 MOV43 INS42 INS8 INS29 INS83 INS43 INS42 INS8 INS44 INS83 INS29 INS83 INS83 INS42 INS43 INS23 INS23 INS31 INS31 INS31 UPD42 INS60 MOV25 MOV43 INS42 INS60 INS25 INS54 INS25 INS43 INS42 INS65 INS42 INS41 INS65 UPD65 MOV65 INS42 INS43 INS42 INS42 INS41 MOV60 MOV60 INS25 INS65 INS65 INS65 INS43 INS42 INS42 INS41 INS65 INS42 INS41 INS65 INS65 INS65 INS42 INS42 MOV60 MOV21 INS41 INS65 INS42 INS41 INS65 INS42 INS41 INS65 INS65 INS41 INS65 INS42 INS41 INS65 INS43 INS42 INS25 INS60 INS54 INS65 INS42 INS83 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS42 INS44 INS44 INS43 INS8 INS78 INS83 INS43 INS42 INS44 INS43 INS8 INS83 INS43 INS42 INS44 INS44 INS43 INS8 UPD66 INS43 INS59 INS43 INS59 INS27 INS8 MOV8 INS12 INS27 INS8 INS66 UPD66 INS42 INS66 INS66 MOV32 INS42 INS66 UPD66 INS66 INS42 INS42 UPD43 INS27 INS8 INS8 INS42 INS66 INS66 INS40 INS66 INS42 INS14 INS66 INS66 MOV14 INS66 INS65 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS42 INS42 INS42 MOV43 MOV27 INS8 MOV43 INS59 INS8 INS12 INS43 INS42 INS66 INS66 INS42 INS42 INS42 INS42 INS43 INS42 INS43 INS42 INS42 INS46 INS21 INS21 INS42 INS42 INS43 INS42 INS42 MOV60 INS25 INS41 INS42 INS43 INS42 INS43 INS42 INS42 INS60 INS25 INS21 INS41 INS22 INS22 INS22 INS22 UPD42 MOV42 INS42 INS32 UPD42 INS69 INS42 INS42 INS32 INS42 INS33 INS60 INS25 INS60 INS44 INS8 INS42 INS33 MOV60 INS25 INS32 UPD42 INS32 UPD42 UPD42 INS16 INS42 INS42 INS41 INS60 INS25 INS41 MOV43 INS42 INS32 INS42 UPD42 INS33 INS21 INS25 INS42 INS11 INS25 INS25 INS44 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS7 INS42 INS43 MOV27 INS8 INS42 INS42 INS42 INS43 INS59 INS38 INS8 INS32 INS42 INS52 INS42 INS22 INS52 INS42 INS52 INS42 INS52 INS42 UPD42 MOV42 INS32 INS43 UPD43 INS32 INS42 INS74 INS59 INS38 INS8 INS8 INS43 INS59 INS43 INS42 INS21 MOV32 MOV8 UPD42 MOV42 UPD42 MOV42 INS32 INS36 INS33 MOV32 INS14 MOV43 INS59 MOV27 INS8 INS8 INS42 INS32 INS42 INS22 INS7 MOV27 INS8 MOV43 INS32 INS38 INS8 INS27 INS8 INS43 INS42 INS21 INS22 INS42 INS42 INS42 INS42 UPD42 INS48 UPD27 MOV32 MOV21 MOV21 INS42 INS42 INS32 INS32 INS21 INS42 INS42 INS27 INS52 INS42 INS32 UPD42 MOV42 UPD42 MOV42 MOV43 INS40 UPD42 INS42 INS43 MOV43 INS42 INS32 INS32 INS70 INS21 INS21 INS42 INS42 INS32 INS42 INS32 INS42 INS27 INS43 INS42 INS42 INS42 INS60 INS21 INS21 INS42 INS52 INS42 INS42 MOV32 MOV21 INS25 MOV21 INS42 INS42 INS40 INS32 INS21 UPD42 INS27 MOV32 INS25 MOV21 INS42 INS32 INS25 INS52 INS42 INS42 INS42 UPD42 UPD42 MOV42 UPD42 INS42 INS42 INS42 INS42 INS32 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS44 INS42 INS8 INS32 INS32 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS33 INS42 INS5 INS59 INS7 INS7 INS38 INS8 INS42 INS42 INS32 UPD45 INS42 INS33 INS38 INS8 INS42 INS42 INS45 INS42 INS38 INS8 UPD42 INS45 INS42 INS32 INS42 INS42 INS43 INS42 MOV25 INS42 INS42 INS27 INS42 INS42 INS27 INS74 INS85 INS42 INS3 INS42 INS11 INS42 INS14 INS32 INS21 INS42 INS42 INS32 MOV21 INS32 INS21 INS42 INS42 INS42 UPD42 INS42 INS38 INS8 INS45 INS32 INS45 INS45 INS32 INS45 INS43 INS76 INS5 INS4 INS43 INS32 INS43 INS42 INS42 INS42 MOV42 UPD42 MOV42 INS32 UPD45 INS42 INS42 INS32 UPD45 UPD45 INS42 INS42 INS32 UPD45 INS36 INS41 INS42 INS42 INS42 INS42 INS42 INS43 INS85 INS57 INS57 INS57 INS42 INS42 INS42 MOV57 INS42 INS11 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS62 INS32 UPD42 INS42 INS43 INS43 INS43 INS43 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS40 DEL29 DEL83 DEL42 DEL59 DEL23 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL42 DEL14 DEL41 DEL8 DEL31 DEL42 DEL32 DEL14 DEL42 DEL42 DEL27 DEL42 DEL41 DEL8 DEL25 DEL33 DEL42 DEL83 DEL42 DEL43 DEL40 DEL14 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL59 DEL60 DEL8 DEL25 DEL8 DEL25 DEL42 DEL65 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL34 DEL27 DEL27 DEL36 DEL38 DEL45 DEL42 DEL45 DEL27 DEL42
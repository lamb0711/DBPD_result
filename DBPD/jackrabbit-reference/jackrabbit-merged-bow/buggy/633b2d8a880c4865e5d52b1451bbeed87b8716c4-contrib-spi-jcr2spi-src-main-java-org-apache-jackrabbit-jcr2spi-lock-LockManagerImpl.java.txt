fixed: move, reorder (work in progress)
fixed: locktoken transfer
fixed: recursive transient removal of invalidated tree fails (restoreTests)
improve: simplify usage of workspace operations
fixed: store original itemId with transient operations in order to properly reflect the changelog upon batch creation
fixed: workspace import doesn't invalidate
fixed: session import uuid handling




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@513279 13f79535-47bb-0310-9956-ffa450edef68

+ * TODO: TOBEFIXED. Lock objects obtained through this mgr are not informed if another session is or becomes lock-holder and removes the lock again.
-     * delegated to {@link WorkspaceManager#removeLockToken(String)} and
-     * all locks stored in the local lock map are notified by the removed
-     * token in order to give them the chance to update their lock information.
+     * delegated to {@link WorkspaceManager#removeLockToken(String)}.
+     * All locks stored in the local lock map are notified by the removed
+     * token in order have them updated their lock information.
-        if (!found) {
-            String msg = "Unable to remove lock token: lock is held by another session.";
-            log.warn(msg);
-            throw new RepositoryException(msg);
-        }
-
-        // remove lock token from sessionInfo
+        // remove lock token from sessionInfo. call will fail, if the session
+        // is not lock holder.
-     * not even readable completely.
+     * not even readable completely. For this reason it seem equally reasonable
+     * to search for jcr:lockIsDeep property only and omitting all kind of
+     * verification regarding nodetypes present.
-        /**
-         * TODO: should not only rely on existence of jcr:lockIsDeep property
-         * but also verify that node.isNodeType("mix:lockable")==true;
-         * this would have a negative impact on performance though...
-         */
+        NodeId nId = nodeState.getNodeId();
-            lockInfo = wspManager.getLockInfo(nodeState.getNodeId());
+            lockInfo = wspManager.getLockInfo(nId);
-        if (lockNodeId.equals(nodeState.getId())) {
+        if (lockNodeId.equals(nId)) {
+        NodeState nState = nodeState;
+        // access first non-NEW state
+        while (nState.getStatus() == Status.NEW) {
+            try {
+                nState = nState.getParent();
+            } catch (ItemStateException e) {
+                // should never occur, since NEW states must have an accessible parent
+                throw new RepositoryException("Intenal error", e);
+            }
+        }
-        // accessed before (thus is known to the manager) irrespective if the
-        // current session is the lock holder or not.
-        if (lockMap.containsKey(nodeState)) {
-            return (LockImpl) lockMap.get(nodeState);
+        // store in the lock map. see below (LockImpl) for the conditions that
+        // must be met in order a lock can be stored.
+        if (lockMap.containsKey(nState)) {
+            return (LockImpl) lockMap.get(nState);
-            NodeState lockHoldingState = getLockHoldingState(nodeState);
+            NodeState lockHoldingState = getLockHoldingState(nState);
-                // no lock
+                // assume no lock is present (might not be correct due to incomplete hierarchy)
-            lState = buildLockState(nodeState);
+            // need correct information about lock status -> retrieve lockInfo
+            // from the persistent layer.
+            lState = buildLockState(nState);
-        // Lock has never been access -> build the lock object
-        // retrieve lock holding node. note that this may fail if the session
-        // does not have permission to see this node.
-        if (lState != null && lState.appliesToNodeState(nodeState)) {
-            Item lockHoldingNode = itemManager.getItem(lState.lockHoldingState.getHierarchyEntry());
-            return new LockImpl(lState, (Node)lockHoldingNode);
+        if (lState != null) {
+            // Test again if a Lock object is stored in the lockmap. Otherwise
+            // build the lock object and retrieve lock holding node. note that this
+            // may fail if the session does not have permission to see this node.
+            LockImpl lock;
+            if (lockMap.containsKey(lState.lockHoldingState)) {
+                lock = (LockImpl) lockMap.get(lState.lockHoldingState);
+                lock.lockState.lockInfo = lState.lockInfo;
+            } else {
+                Item lockHoldingNode = itemManager.getItem(lState.lockHoldingState.getHierarchyEntry());
+                lock = new LockImpl(lState, (Node)lockHoldingNode);
+            }
+            // test if lock applies to the original nodestate
+            if (lState.appliesToNodeState(nodeState)) {
+                return lock;
+            } else {
+                return null; // lock exists but doesn't apply to the given state
+            }
-            // lock exists but does not apply to the given node state
-            // passed to this method.
+            // no lock at all
-            } else if (isSessionScoped() && isHoldBySession()) {
+            } else if (isHoldBySession()) {
+                // TODO: TOBEFIXED. since another session may become lock-holder for
+                // an open-scoped lock, the map entry and the lock information
+                // stored therein may become outdated.

INS66 INS60 INS60 INS61 UPD66 UPD66 UPD66 UPD66 INS66 INS66 INS43 INS59 INS43 INS59 INS27 INS8 MOV27 INS8 INS42 INS42 MOV32 UPD42 MOV42 INS42 INS42 INS42 INS32 INS40 INS54 UPD42 INS60 INS25 INS25 INS42 INS42 INS8 INS12 INS43 INS59 INS32 INS8 MOV8 MOV32 INS8 INS8 MOV32 INS21 INS44 INS8 INS42 INS42 INS42 INS42 INS40 INS21 INS21 INS21 INS41 INS41 INS42 INS7 INS43 INS42 MOV53 UPD42 UPD42 UPD42 INS7 INS7 INS7 INS42 INS33 INS42 INS32 INS42 INS42 INS11 INS40 INS40 INS42 MOV14 INS42 INS42 INS45 UPD42 INS43 INS32 INS42 INS42 INS42 INS40 DEL42 DEL38 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL32 DEL41 DEL27 DEL42 DEL32 DEL27
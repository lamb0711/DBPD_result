JCR-1104 : JSR 283 support (security work in progress)

> introduce AccessManager.canRead(Path)
> retrieve Policy/ACE from ACProvider by Path rather than by ID
> add CompiledPermission.canReadAll for optimization
> fix ACLTemplate (various bugs) and add additional tests
> get rid of deprecated AccessManager.isGranted(ItemId, int) wherever possible
  and mark/simplify other usages
  - ItemManager
  - BatchedItemOperations
  - add TODO with QueryResultImpl that still uses the isGranted method.
  - EventConsumer: still uses isGranted. but various calls were replaced by private
    canRead -> simplify later optimization.
> remove unused ACLCache.java
> ItemManager:
  - make getItem consistent with itemExists (check perm even if obtained from cache)
  - replace getItemState by getItemData
  - get rid of duplicate code
  - add canRead(ItemData, Path) which is used (almost) everywhere and avoid permission
    check for NEW,non-protected items
  - consequently getItem(ItemId, boolean) is not required any more.
  - upon building LazyItemIterator for children: omit the duplicate permission
    check while building the set of childIds.
    the perm-check is executed upon the subsequent ItemManager.getItem call anyway 
> NodeImpl: createChildNode called ItemManager.getItem for an new item that has
  not yet been added as CNE to its parent -> replace by ItemManager.createItemInstance
  which omits the permission check.
> ItemImpl: 
  - fix javadoc
  - replace removed method ItemMgr.getItem(ItemId, boolean) by getItem(ItemId)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@649172 13f79535-47bb-0310-9956-ffa450edef68

+
+                public boolean canReadAll() throws RepositoryException {
+                    return false;
+                }
-        int perm = 0;
-        if ((actions & READ) == READ) {
-            perm |= Permission.READ;
-        }
-        if ((actions & WRITE) == WRITE) {
-            if (id.denotesNode()) {
-                // TODO: check again if correct
-                perm |= Permission.SET_PROPERTY;
-                perm |= Permission.ADD_NODE;
-            } else {
-                perm |= Permission.SET_PROPERTY;
+        if (actions == READ && compiledPermissions.canReadAll()) {
+            return true;
+        } else {
+            int perm = 0;
+            if ((actions & READ) == READ) {
+                perm |= Permission.READ;
+            if ((actions & WRITE) == WRITE) {
+                if (id.denotesNode()) {
+                    // TODO: check again if correct
+                    perm |= Permission.SET_PROPERTY;
+                    perm |= Permission.ADD_NODE;
+                } else {
+                    perm |= Permission.SET_PROPERTY;
+                }
+            }
+            if ((actions & REMOVE) == REMOVE) {
+                perm |= (id.denotesNode()) ? Permission.REMOVE_NODE : Permission.REMOVE_PROPERTY;
+            }
+            Path path = hierMgr.getPath(id);
+            return isGranted(path, perm);
-        if ((actions & REMOVE) == REMOVE) {
-            perm |= (id.denotesNode()) ? Permission.REMOVE_NODE : Permission.REMOVE_PROPERTY;
-        }
-        Path path = hierMgr.getPath(id);
-        return isGranted(path, perm);
+     * @see AccessManager#canRead(Path)
+     */
+    public boolean canRead(Path itemPath) throws ItemNotFoundException, RepositoryException {
+        Path path;
+        if (compiledPermissions.canReadAll()) {
+            return true;
+        } else {
+            return isGranted(itemPath, Permission.READ);
+        }
+    }
+
+    /**
-        return acProvider.getPolicy(getNodeId(absPath));
+        return acProvider.getPolicy(getPath(absPath));
-        return acProvider.getAccessControlEntries(getNodeId(absPath));
+        return acProvider.getAccessControlEntries(getPath(absPath));
-    private NodeId getNodeId(String absPath) throws RepositoryException {
-        NodeId id = hierMgr.resolveNodePath(resolver.getQPath(absPath));
+    private Path getPath(String absPath) throws RepositoryException {
+        Path path = resolver.getQPath(absPath);
+        NodeId id = hierMgr.resolveNodePath(path);
-        return id;
+        return path;

INS31 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS43 INS8 UPD43 UPD42 MOV21 INS25 INS65 INS43 INS42 INS42 INS42 INS60 INS25 UPD42 INS60 INS41 INS27 INS8 MOV8 INS68 INS42 INS43 INS59 INS32 INS8 INS8 INS43 MOV43 INS59 INS42 INS27 INS32 INS41 INS42 INS42 INS69 INS42 INS42 INS42 INS42 INS41 INS41 INS42 INS42 MOV32 INS42 INS32 INS42 INS42 INS42 INS42 INS9 INS43 INS9 INS32 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS31 INS83 INS39 INS42 INS43 INS8 INS42 INS41 INS9 DEL42 DEL42 DEL42 DEL32 DEL42 DEL41
Patch provided by Boni Gopalan for issue JCR-1784 (The UUID of the collection elements changes on update). I didn't modify the class AbstractMapperImpl. This modification is not necessary.
I also added unit tests for the annotation support. 

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@702237 13f79535-47bb-0310-9956-ffa450edef68

-        if (!elementClassDescriptor.hasIdField()) {
+        if (!elementClassDescriptor.hasIdField() && !elementClassDescriptor.hasUUIdField()) {
+        List<String> validUuidsForTheNode = new ArrayList<String>();
-
-
-            if (elementClassDescriptor.hasIdField()) {
+            
+            if (elementClassDescriptor.hasUUIdField()){
+            	elementJcrName = collectionDescriptor.getJcrElementName();
+            	elementJcrName = (elementJcrName == null)? COLLECTION_ELEMENT_NAME : elementJcrName;
+                String uuidFieldName = elementClassDescriptor.getUuidFieldDescriptor().getFieldName();
+                Object objUuid = ReflectionUtils.getNestedProperty(item, uuidFieldName);
+            	String currentItemUuid = (objUuid == null) ? null : objUuid.toString();
+            	if (currentItemUuid != null){
+            		//The Node already exists so we need to update the existing node 
+            		//rather than to replace it.
+            		Node nodeToUpdate = collectionNode.getSession().getNodeByUUID(currentItemUuid);
+            		objectConverter.update(session, currentItemUuid, item);
+            		validUuidsForTheNode.add(currentItemUuid);
+            	}
+            	else{
+            		objectConverter.insert(session, collectionNode, elementJcrName, item);
+            		validUuidsForTheNode.add(ReflectionUtils.getNestedProperty(item, uuidFieldName).toString());
+            	}
+            	
+            }
+            else if (elementClassDescriptor.hasIdField()) {
+        if (elementClassDescriptor.hasUUIdField()) {
+            NodeIterator nodeIterator = collectionNode.getNodes();
+            List<Node> removeNodes = new ArrayList<Node>();
+            while (nodeIterator.hasNext()) {
+            	Node currentNode = nodeIterator.nextNode();
+            	if (!validUuidsForTheNode.contains(currentNode.getUUID())) {
+                    removeNodes.add(currentNode);
+                }
+            }
+            for (Node aNode : removeNodes){
+            	aNode.remove();
+            }
+            return;
+        }
+        
+        // Delete JCR nodes that are not present in the collection
-}
+}

INS60 INS25 INS27 INS74 INS59 INS32 INS8 MOV38 INS38 INS43 INS43 INS42 INS14 INS25 INS42 INS42 INS60 INS60 INS61 INS70 INS41 INS32 INS42 INS42 INS74 INS32 INS8 MOV25 INS43 INS59 INS74 INS59 INS32 INS8 INS44 INS42 INS8 INS42 INS42 INS43 INS43 INS42 INS42 INS21 INS21 INS60 INS60 INS60 INS25 INS42 INS42 INS32 INS43 INS43 INS42 INS14 INS42 INS42 INS60 INS25 INS43 INS42 INS21 INS42 INS42 INS7 INS7 INS43 INS59 INS43 INS59 INS43 INS59 INS27 INS8 INS8 INS42 INS42 INS42 INS42 INS74 INS43 INS59 INS38 INS8 INS42 INS32 INS42 INS32 INS42 INS16 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS16 INS42 INS33 INS60 INS21 INS21 INS21 INS21 INS43 INS43 INS42 INS42 INS32 INS32 INS21 INS42 INS42 INS42 INS42 INS36 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS36 INS33 INS32 INS43 INS59 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS27 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS33 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42
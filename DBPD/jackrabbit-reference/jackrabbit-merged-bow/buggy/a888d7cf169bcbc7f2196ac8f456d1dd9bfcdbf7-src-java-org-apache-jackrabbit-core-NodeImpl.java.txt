fixed checking checked-out status according to spec

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@149506 13f79535-47bb-0310-9956-ffa450edef68

- *                     as applicable.
+  *                     as applicable.
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
+     * Same as {@link Node#isNodeType(String)}, but takes a <code>QName</code>
+     * instad of a <code>String</code>.
+     * @param ntName name of node type
+     * @return <code>true</code> if this node is of the specified node type;
+     *         otherwise <code>false</code>
+     */
+    public boolean isNodeType(QName ntName) throws RepositoryException {
+        // no need to perform sanity check; assume this has
+        // already been done by calling method
+
+        if (ntName.equals(nodeType.getQName())) {
+            return true;
+        }
+
+        if (nodeType.isDerivedFrom(ntName)) {
+            return true;
+        }
+
+        // check mixin types
+        Set mixinNames = ((NodeState) state).getMixinTypeNames();
+        if (mixinNames.isEmpty()) {
+            return false;
+        }
+        NodeTypeRegistry ntReg = session.getNodeTypeManager().getNodeTypeRegistry();
+        try {
+            EffectiveNodeType ent = ntReg.getEffectiveNodeType((QName[]) mixinNames.toArray(new QName[mixinNames.size()]));
+            return ent.includesNodeType(ntName);
+        } catch (NodeTypeConflictException ntce) {
+            String msg = "internal error: invalid mixin node type(s)";
+            log.error(msg, ntce);
+            throw new RepositoryException(msg, ntce);
+        }
+    }
+
+    /**
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write (only cheap call)
-        if (!isCheckedOut(false)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-     * @see Node#isNodeType(String)
-     */
-    public boolean isNodeType(QName ntName) throws RepositoryException {
-        // check state of this instance
-        sanityCheck();
-
-        if (ntName.equals(nodeType.getQName())) {
-            return true;
-        }
-
-        if (nodeType.isDerivedFrom(ntName)) {
-            return true;
-        }
-
-        // check mixin types
-        Set mixinNames = ((NodeState) state).getMixinTypeNames();
-        if (mixinNames.isEmpty()) {
-            return false;
-        }
-        NodeTypeRegistry ntReg = session.getNodeTypeManager().getNodeTypeRegistry();
-        try {
-            EffectiveNodeType ent = ntReg.getEffectiveNodeType((QName[]) mixinNames.toArray(new QName[mixinNames.size()]));
-            return ent.includesNodeType(ntName);
-        } catch (NodeTypeConflictException ntce) {
-            String msg = "internal error: invalid mixin node type(s)";
-            log.error(msg, ntce);
-            throw new RepositoryException(msg, ntce);
-        }
-    }
-
-
-    /**
-        // check if versioning allows write
-        if (!isCheckedOut(true)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write
-        if (!isCheckedOut(true)) {
+        // make sure this node is checked-out
+        if (!internalIsCheckedOut()) {
-        // check if versioning allows write
-        if (!isCheckedOut(true)) {
+        // check checked-out status
+        if (!internalIsCheckedOut()) {
-        // check if already checked out
-        if (isCheckedOut(false)) {
+        // check checked-out status
+        if (internalIsCheckedOut()) {
-        return isCheckedOut(true);
+        return internalIsCheckedOut();
-     * Same as {@link Node#isCheckedOut()} but if <code>inherit</code>
-     * is <code>true</code>, a non-versionable node will return the checked out
-     * state of its parent.
-     *
-     * @param inherit
+     * Determines the checked-out status of this node.
+     * @return a boolean
-    protected boolean isCheckedOut(boolean inherit) throws RepositoryException {
+    protected boolean internalIsCheckedOut() throws RepositoryException {
+        /**
+         * FIXME should not only rely on existence of jcr:isCheckedOut property
+         * but also verify that node.isNodeType("mix:versionable")==true;
+         * this would have a negative impact on performance though...
+         */
-            if (!inherit || node.isRepositoryRoot()) {
+            if (node.isRepositoryRoot()) {

MOV31 MOV31 MOV31 INS8 MOV8 MOV29 MOV43 MOV44 MOV44 MOV44 MOV43 MOV43 MOV43 MOV43 MOV29 MOV43 MOV44 MOV44 MOV44 MOV43 MOV43 MOV43 MOV43 UPD42 INS65 INS65 INS65 MOV21 INS25 MOV41 MOV21 MOV60 MOV41 INS25 MOV25 UPD65 INS66 UPD65 MOV65 INS66 INS66 INS42 INS66 INS66 INS66 INS38 MOV8 INS38 INS8 MOV8 UPD66 INS66 INS32 INS32 INS60 INS21 INS53 MOV60 MOV53 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 INS42 INS43 INS59 INS32 INS14 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV59 MOV14 UPD42 UPD42 UPD42 UPD42 MOV32 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 MOV43 INS32 INS45 INS42 MOV32 MOV45 INS42 MOV42 DEL9 DEL42 DEL32 DEL21 DEL9 DEL42 DEL9 DEL32 DEL38 DEL25 DEL8 DEL9 DEL9 DEL9 DEL9 DEL9 DEL9 DEL9 DEL9 DEL9 DEL9 DEL42 DEL9 DEL32 DEL38 DEL25 DEL9 DEL9 DEL9 DEL9 DEL9 DEL66 DEL42 DEL42 DEL68 DEL65 DEL66 DEL66 DEL42 DEL39 DEL42 DEL44 DEL42 DEL38 DEL27
work in progress

- replace ItemImpl by Item in ItemManager interface and adjust
  usages.
- change all setters on ItemState and derived classes from public to
  package private
- NodeState: use collection return value instead of set/list whereever possible
- WorkspaceManager: put ItemStateFactory to a separate class and
  remove unused inner class NodeReferenceImpl 
- add methods to NodeState/PropertyState that avoids return a null
  QItemDefinition and remove corresponding methods from NodeTypeManagerImpl
- remove ItemDefinitionManager.
- VersionHistoryImpl: add safety check if cne for root version really exists
- Fix ImporterImpl: ItemState.getDefinition() may return 'null' value.
  use method instead, that sets the definition if it is still missing.
- javadoc and code formatting


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@430031 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeConflictException;
+import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeRegistry;
+import org.apache.jackrabbit.jcr2spi.nodetype.EffectiveNodeType;
+import javax.jcr.RepositoryException;
-    
+
-            def = nodeState.getDefinition();
+            def = nodeState.def;
-            for (Iterator it = nodeState.getPropertyNames().iterator(); it.hasNext(); ) {
+            Iterator it = nodeState.getPropertyNames().iterator();
+            while (it.hasNext()) {
-            for (Iterator it = nodeState.getChildNodeEntries().iterator(); it.hasNext(); ) {
+            it = nodeState.getChildNodeEntries().iterator();
+            while (it.hasNext()) {
-    //-----------------------------------------------------< public methods >---
+    //----------------------< public READ methods and package private WRITE >---
+     * Sets the the parent <code>NodeState</code>.
+     *
+     * @param parent the parent <code>NodeState</code> or <code>null</code>
+     * if either this node state should represent the root node or this node
+     * state should be 'free floating', i.e. detached from the repository's
+     * hierarchy.
+     */
+    void setParent(NodeState parent) {
+        this.parent = parent;
+    }
+
+    /**
-     * Sets the Id of the parent <code>NodeState</code>.
-     *
-     * @param parent the parent <code>NodeState</code> or <code>null</code>
-     * if either this node state should represent the root node or this node
-     * state should be 'free floating', i.e. detached from the repository's
-     * hierarchy.
-     */
-    public void setParent(NodeState parent) {
-        this.parent = parent;
-    }
-
-    /**
+     * Set the node type name. Needed for deserialization and should therefore
+     * not change the internal status.
+     *
+     * @param nodeTypeName node type name
+     */
+    synchronized void setNodeTypeName(QName nodeTypeName) {
+        this.nodeTypeName = nodeTypeName;
+    }
+
+    /**
-    public synchronized void setMixinTypeNames(QName[] mixinTypeNames) {
+    synchronized void setMixinTypeNames(QName[] mixinTypeNames) {
-     * Returns the id of the definition applicable to this node state.
+     * Returns the {@link QNodeDefinition definition} defined for this
+     * node state or <code>null</code> if the definition has not been
+     * set before (i.e. the corresponding item has not been accessed before).
-     * @return the id of the definition
+     * @return definition of this state
+     * @see #getDefinition(NodeTypeRegistry) for the corresponding method
+     * that never returns <code>null</code>.
+     * Returns the definition applicable to this node state. Since the definition
+     * is not defined upon state creation this state may have to retrieve
+     * the definition from the given <code>NodeTypeRegistry</code> first.
+     *
+     * @param ntRegistry
+     * @return the definition of this state
+     * @see #getDefinition()
+     */
+    public QNodeDefinition getDefinition(NodeTypeRegistry ntRegistry)
+        throws RepositoryException {
+        // make sure the state has the definition set now
+        if (def == null) {
+            NodeState parentState = getParent();
+            try {
+                if (parentState == null) {
+                    // special case for root state
+                    def = ntRegistry.getRootNodeDef();
+                } else {
+                    ChildNodeEntry cne = parentState.getChildNodeEntry(getNodeId());
+                    EffectiveNodeType ent = ntRegistry.getEffectiveNodeType(parentState.getNodeTypeNames());
+                    setDefinition(ent.getApplicableNodeDefinition(cne.getName(), getNodeTypeName()));
+                }
+            } catch (NodeTypeConflictException e) {
+                String msg = "internal error: failed to build effective node type.";
+                log.debug(msg);
+                throw new RepositoryException(msg, e);
+            }
+
+        }
+        return def;
+    }
+
+    /**
-    public void setDefinition(QNodeDefinition def) {
+    void setDefinition(QNodeDefinition def) {
-     * specified <code>NodeId</code>.
-     *
-     * @param id the id of the child node
-     * @return <code>true</code> if there is a <code>ChildNodeEntry</code> with
-     *         the specified <code>name</code>.
-     */
-    public synchronized boolean hasChildNodeEntry(NodeId id) {
-        return childNodeEntries.get(id) != null;
-    }
-
-    /**
-     * Determines if there is a <code>ChildNodeEntry</code> with the
-     * Determines if there is a property entry with the specified
-     * <code>QName</code>.
-     *
-     * @param propName <code>QName</code> object specifying a property name
-     * @return <code>true</code> if there is a property entry with the specified
-     *         <code>QName</code>.
-     */
-    public synchronized boolean hasPropertyName(QName propName) {
-        return properties.containsKey(propName);
-    }
-
-    /**
-     * Returns a list of <code>ChildNodeEntry</code> objects denoting the
-     * child nodes of this node.
+     * Returns a unmodifiable collection of <code>ChildNodeEntry</code> objects
+     * denoting the child nodes of this node.
-     * @return list of <code>ChildNodeEntry</code> objects
+     * @return collection of <code>ChildNodeEntry</code> objects
-    public synchronized List getChildNodeEntries() {
-        return Collections.unmodifiableList(childNodeEntries);
+    public synchronized Collection getChildNodeEntries() {
+        // NOTE: List representation of 'ChildNodeEntries' is already unmodifiable
+        return childNodeEntries;
-     * Returns a list of <code>ChildNodeEntry</code>s with the specified name.
+     * Returns a unmodifiable list of <code>ChildNodeEntry</code>s with the
+     * specified name.
-        return Collections.unmodifiableList(childNodeEntries.get(nodeName));
+        // NOTE: SubList retrieved from 'ChildNodeEntries' is already unmodifiable
+        return childNodeEntries.get(nodeName);
-    public synchronized ChildNodeEntry addChildNodeEntry(QName nodeName,
+    synchronized ChildNodeEntry addChildNodeEntry(QName nodeName,
-    public synchronized boolean renameChildNodeEntry(QName oldName, int index,
+    synchronized boolean renameChildNodeEntry(QName oldName, int index,
-    public synchronized boolean removeChildNodeEntry(QName nodeName, int index) {
+    synchronized boolean removeChildNodeEntry(QName nodeName, int index) {
-    public synchronized boolean removeChildNodeEntry(NodeId id) {
+    synchronized boolean removeChildNodeEntry(NodeId id) {
-    public synchronized void removeAllChildNodeEntries() {
+    synchronized void removeAllChildNodeEntries() {
-    public synchronized void setChildNodeEntries(List nodeEntries) {
+    synchronized void setChildNodeEntries(List nodeEntries) {
+     * Determines if there is a property entry with the specified
+     * <code>QName</code>.
+     *
+     * @param propName <code>QName</code> object specifying a property name
+     * @return <code>true</code> if there is a property entry with the specified
+     *         <code>QName</code>.
+     */
+    public synchronized boolean hasPropertyName(QName propName) {
+        return properties.containsKey(propName);
+    }
+
+    /**
-    public synchronized Set getPropertyNames() {
+    public synchronized Collection getPropertyNames() {
-    public synchronized void addPropertyName(QName propName) {
+    synchronized void addPropertyName(QName propName) {
-    public synchronized boolean removePropertyName(QName propName) {
+    synchronized boolean removePropertyName(QName propName) {
-    public synchronized void removeAllPropertyNames() {
+    synchronized void removeAllPropertyNames() {
-    public synchronized void setPropertyNames(Set propNames) {
+    synchronized void setPropertyNames(Set propNames) {
-     * Set the node type name. Needed for deserialization and should therefore
-     * not change the internal status.
-     *
-     * @param nodeTypeName node type name
-     */
-    public synchronized void setNodeTypeName(QName nodeTypeName) {
-        this.nodeTypeName = nodeTypeName;
-    }
-
-    /**
-        return (PropertyState) propRef.resolve();
-    }
-
-    /**
-     * Returns the node state with the given relative path.
-     *
-     * @param relPath the relative path (actually PathElement) of the child node
-     *                state.
-     * @return the child node state
-     * @throws NoSuchItemStateException if there is no node state with the given
-     *                                  <code>relPath</code>.
-     * @throws ItemStateException       if an error occurs while retrieving the
-     *                                  node state.
-     */
-    public synchronized NodeState getNodeState(Path.PathElement relPath)
-            throws NoSuchItemStateException, ItemStateException {
-        ChildNodeEntry cne = childNodeEntries.get(relPath.getName(), relPath.getNormalizedIndex());
-        if (cne == null) {
-            Path p = Path.create(relPath.getName(), relPath.getIndex());
-            NodeId id = idFactory.createNodeId(getNodeId(), p);
-            throw new NoSuchItemStateException(id.toString());
-        }
-        return cne.getNodeState();
+        return propRef.getPropertyState();
-    //--------------------------------------------------< ItemState overrides >
+    /**
+     * TODO: find a better way to provide the index of a child node entry
+     * Returns the index of the given <code>ChildNodeEntry</code> and with
+     * <code>name</code>.
+     *
+     * @param name the name of the child node.
+     * @param cne  the <code>ChildNodeEntry</code> instance.
+     * @return the index of the child node entry or <code>0</code> if it is not
+     *         found in this <code>NodeState</code>.
+     */
+    int getChildNodeIndex(QName name, ChildNodeEntry cne) {
+        List sns = childNodeEntries.get(name);
+        return sns.indexOf(cne) + 1;
+    }
+
+    //---------------------------------------------------< Listener support >---
-    /**
-     * TODO: find a better way to provide the index of a child node entry
-     * Returns the index of the given <code>ChildNodeEntry</code> and with
-     * <code>name</code>.
-     *
-     * @param name the name of the child node.
-     * @param cne  the <code>ChildNodeEntry</code> instance.
-     * @return the index of the child node entry or <code>0</code> if it is not
-     *         found in this <code>NodeState</code>.
-     */
-    int getChildNodeIndex(QName name, ChildNodeEntry cne) {
-        List sns = childNodeEntries.get(name);
-        return sns.indexOf(cne) + 1;
-    }
-
-    //-------------------------------------------------< misc. helper methods >
+    //----------------------------------------------< Listener notification >---
-    //--------------------------------------------------------< inner classes >
+    //------------------------------------------------------< inner classes >---
-

INS26 INS26 INS26 INS26 MOV31 MOV31 MOV31 MOV31 MOV31 INS40 INS40 INS40 INS40 INS31 INS29 MOV83 MOV43 INS42 MOV8 INS43 INS42 INS44 UPD43 UPD43 UPD43 INS65 UPD65 MOV65 UPD65 MOV65 UPD65 INS42 INS43 INS42 UPD42 INS25 UPD42 UPD42 UPD66 UPD66 MOV66 INS65 INS66 UPD66 MOV66 UPD66 MOV66 UPD66 INS68 UPD66 UPD66 UPD66 INS66 INS66 UPD42 UPD66 INS68 UPD42 MOV42 INS27 INS8 INS42 UPD66 UPD66 UPD66 INS42 UPD66 INS66 MOV32 INS32 INS60 INS61 INS21 INS61 INS42 UPD66 MOV66 INS42 INS69 INS42 INS42 INS33 INS60 INS54 MOV42 UPD42 MOV42 MOV43 MOV59 MOV32 MOV8 INS7 MOV32 MOV8 INS43 MOV43 INS59 INS8 INS12 INS40 INS42 MOV32 INS42 INS42 INS32 INS25 INS44 INS8 UPD42 MOV42 INS27 INS8 INS8 INS43 INS42 INS60 INS21 MOV53 INS42 INS33 INS21 INS60 INS60 INS21 UPD42 MOV42 INS43 INS59 INS32 INS7 MOV43 INS59 UPD43 MOV43 INS59 INS32 INS42 INS42 INS45 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD43 INS42 INS42 INS42 INS32 INS42 INS32 UPD42 INS42 INS32 INS42 INS32 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 MOV32 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 MOV32 MOV32 INS42 INS42 UPD42 UPD42 DEL42 DEL42 DEL32 DEL58 DEL24 DEL42 DEL43 DEL42 DEL59 DEL58 DEL24 DEL83 DEL83 DEL83 DEL42 DEL66 DEL66 DEL42 DEL66 DEL66 DEL65 DEL42 DEL66 DEL66 DEL83 DEL42 DEL40 DEL43 DEL42 DEL44 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL32 DEL59 DEL60 DEL43 DEL42 DEL32 DEL59 DEL60 DEL8 DEL25 DEL42 DEL42 DEL32 DEL65 DEL65 DEL29 DEL83 DEL42 DEL31 DEL83 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL33 DEL27 DEL41 DEL8 DEL31 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL42 DEL43 DEL32 DEL11
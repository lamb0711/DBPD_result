Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.state.entry.ChildNodeEntry;
-import org.apache.jackrabbit.jcr2spi.state.PropertyState;
-import org.apache.jackrabbit.jcr2spi.state.ItemState;
-import org.apache.jackrabbit.jcr2spi.state.ItemStateManager;
+import org.apache.jackrabbit.jcr2spi.state.NodeReferences;
+import org.apache.jackrabbit.jcr2spi.state.Status;
+import org.apache.jackrabbit.jcr2spi.state.PropertyState;
+import org.apache.jackrabbit.jcr2spi.util.StateUtility;
+import org.apache.jackrabbit.jcr2spi.hierarchy.NodeEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.PropertyEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.HierarchyEntry;
-import org.apache.jackrabbit.spi.ItemId;
-import javax.jcr.Repository;
-import java.util.Collection;
-    private NodeDefinition definition;
-                       NodeState state, NodeDefinition definition,
-                       ItemLifeCycleListener[] listeners) {
+                       NodeState state, ItemLifeCycleListener[] listeners) {
-        this.definition = definition;
-     * @see Item#getParent()
-     */
-    public Node getParent() throws ItemNotFoundException, AccessDeniedException, RepositoryException {
-        checkStatus();
-
-        NodeState parentState = getItemState().getParent();
-        // special treatment for root node
-        if (parentState == null) {
-            String msg = "Root node doesn't have a parent.";
-            log.debug(msg);
-            throw new ItemNotFoundException(msg);
-        }
-
-        return (Node) itemMgr.getItem(parentState);
-    }
-
-    /**
-                // create and remove property is a nop.
-                // TODO: check if is correct to avoid any validation exception
-                prop = null;
+                // create and remove property is not valid // TODO: correct?
+                throw new ItemNotFoundException("Cannot remove a non-existing property.");
-                // TODO: check if is correct to avoid any validation exception
-                prop = null;
+                throw new ItemNotFoundException("Cannot remove a non-existing property.");
-        NodeState state = resolveRelativeNodePath(relPath);
-        if (state == null) {
+        NodeEntry nodeEntry = resolveRelativeNodePath(relPath);
+        if (nodeEntry == null) {
-        return (Node) itemMgr.getItem(state);
+        try {
+            return (Node) itemMgr.getItem(nodeEntry);
+        } catch (ItemNotFoundException e) {
+            throw new PathNotFoundException(relPath, e);
+        }
-            return itemMgr.getChildNodes(getNodeState());
+            return itemMgr.getChildNodes(getNodeEntry());
-        PropertyState state = resolveRelativePropertyPath(relPath);
-        if (state == null) {
+        PropertyEntry entry = resolveRelativePropertyPath(relPath);
+        if (entry == null) {
-        return (Property) itemMgr.getItem(state);
+        try {
+            return (Property) itemMgr.getItem(entry);
+        } catch (AccessDeniedException e) {
+            throw new PathNotFoundException(relPath.toString());
+        } catch (ItemNotFoundException e) {
+            throw new PathNotFoundException(relPath.toString());
+        }
-            return itemMgr.getChildProperties(getNodeState());
+            return itemMgr.getChildProperties(getNodeEntry());
-        return getNodeState().getIndex();
+        int index = getNodeEntry().getIndex();
+        if (index == Path.INDEX_UNDEFINED) {
+            throw new RepositoryException("Error while retrieving index.");
+        }
+        return index;
+        NodeReferences refs = getNodeState().getNodeReferences();
+        if (refs.isEmpty()) {
+            // there are no references, return empty iterator
+            return IteratorHelper.EMPTY;
+        } else {
+            return new LazyItemIterator(itemMgr, session.getHierarchyManager(), refs.iterator());
+        }
+        /*
+        */
-        NodeState childState = resolveRelativeNodePath(relPath);
-        return (childState != null) ? itemMgr.itemExists(childState) : false;
+        NodeEntry nodeEntry = resolveRelativeNodePath(relPath);
+        return (nodeEntry != null) ? itemMgr.itemExists(nodeEntry) : false;
-        PropertyState childState = resolveRelativePropertyPath(relPath);
-        return (childState != null) ? itemMgr.itemExists(childState) : false;
+        PropertyEntry childEntry = resolveRelativePropertyPath(relPath);
+        return (childEntry != null) ? itemMgr.itemExists(childEntry) : false;
-        return getNodeState().hasPropertyName(propertyName);
+        return getNodeEntry().hasPropertyEntry(propertyName);
-        return itemMgr.hasChildNodes(getNodeState());
+        return itemMgr.hasChildNodes(getNodeEntry());
-        return itemMgr.hasChildProperties(getNodeState());
+        return itemMgr.hasChildProperties(getNodeEntry());
-        checkStatus();        
+        checkStatus();
-            if (!isValidMixin(mixinQName)) {
+            if (!canAddMixin(mixinQName)) {
-        // merge existing mixins and new mixins to one Array without modifying
-        // the node state.
-        QName[] currentMixins = getNodeState().getMixinTypeNames();
-        QName[] allMixins = new QName[currentMixins.length + 1];
-        System.arraycopy(currentMixins, 0, allMixins, 0, currentMixins.length);
-        allMixins[currentMixins.length] = mixinQName;
-        // perform the operation
-        Operation op = SetMixin.create(getNodeState(), allMixins);
-        session.getSessionItemStateManager().execute(op);
+        // get mixin types present in the jcr:mixintypes property without
+        // modifying the NodeState.
+        List mixinValue = getMixinTypes();
+        if (mixinValue.contains(mixinQName)) {
+            log.warn("Mixin " + mixinName + " has already been transiently added -> Ignored.");
+            return;
+        } else {
+            mixinValue.add(mixinQName);
+            // perform the operation
+            Operation op = SetMixin.create(getNodeState(), (QName[]) mixinValue.toArray(new QName[mixinValue.size()]));
+            session.getSessionItemStateManager().execute(op);
+        }
-        List remainingMixins = new ArrayList(Arrays.asList(getNodeState().getMixinTypeNames()));
+        List mixinValue = getMixinTypes();
-        if (!remainingMixins.remove(ntName)) {
+        if (!mixinValue.remove(ntName)) {
-        // build effective node type of remaining mixin's & primary type
-        NodeTypeManagerImpl ntMgr = session.getNodeTypeManager();
-        EffectiveNodeType entRemaining;
-
-        // build effective node type representing primary type including remaining mixin's
-        QName[] allRemaining = (QName[]) remainingMixins.toArray(new QName[remainingMixins.size() + 1]);
-        allRemaining[remainingMixins.size()] = primaryTypeName;
-        try {
-            entRemaining = session.getValidator().getEffectiveNodeType(allRemaining);
-        } catch (NodeTypeConflictException e) {
-            throw new ConstraintViolationException(e);
-        }
-
-        NodeTypeImpl mixin = ntMgr.getNodeType(ntName);
-        if (mixin.isNodeType(QName.MIX_REFERENCEABLE) && !entRemaining.includesNodeType(QName.MIX_REFERENCEABLE)) {
-            PropertyIterator iter = getReferences();
-            if (iter.hasNext()) {
-                throw new ConstraintViolationException("Mixin type " + mixinName + " can not be removed: the node is being referenced through at least one property of type REFERENCE");
+        NodeTypeImpl mixin = session.getNodeTypeManager().getNodeType(ntName);
+        if (mixin.isNodeType(QName.MIX_REFERENCEABLE)) {
+            // build effective node type of remaining mixin's & primary type
+            EffectiveNodeType entRemaining;
+            QName[] allRemaining = (QName[]) mixinValue.toArray(new QName[mixinValue.size() + 1]);
+            allRemaining[mixinValue.size()] = primaryTypeName;
+            try {
+                entRemaining = session.getValidator().getEffectiveNodeType(allRemaining);
+            } catch (NodeTypeConflictException e) {
+                throw new ConstraintViolationException(e);
+            }
+
+            if (!entRemaining.includesNodeType(QName.MIX_REFERENCEABLE)) {
+                PropertyIterator iter = getReferences();
+                if (iter.hasNext()) {
+                    throw new ConstraintViolationException("Mixin type " + mixinName + " can not be removed: the node is being referenced through at least one property of type REFERENCE");
+                }
-        QName[] mixins = (QName[]) remainingMixins.toArray(new QName[remainingMixins.size()]);
+        QName[] mixins = (QName[]) mixinValue.toArray(new QName[mixinValue.size()]);
+     * Retrieves all mixins currently present on this node including those,
+     * that have been transiently added and excluding those, that have been
+     * transiently removed.<br>
+     * NOTE, that the result of this method, does NOT represent the list of
+     * mixin-types that currently affect this node. Instead if represents the
+     * current value of the jcr:mixinTypes property.
+     *
+     * @return
+     */
+    private List getMixinTypes() {
+        QName[] mixinValue = new QName[0];
+        if (getNodeEntry().hasPropertyEntry(QName.JCR_MIXINTYPES)) {
+            if (getNodeState().getStatus() == Status.EXISTING) {
+                mixinValue = getNodeState().getMixinTypeNames();
+            } else {
+                // possibility that a mixin has been transient added
+                try {
+                    PropertyState ps = getNodeState().getPropertyState(QName.JCR_MIXINTYPES);
+                    mixinValue = StateUtility.getMixinNames(ps);
+                } catch (ItemStateException e) {
+                    // should never occur
+                    log.error("Internal error", e);
+                }
+            } // else: no mixins present
+        }
+        List l = new ArrayList();
+        l.addAll(Arrays.asList(mixinValue));
+        return l;
+    }
+
+    /**
-        checkStatus();
-        if (!isSupportedOption(Repository.LEVEL_2_SUPPORTED)) {
+        if (!isWritable()) {
-            return isValidMixin(getQName(mixinName));
+            return canAddMixin(getQName(mixinName));
-        return definition;
+        QNodeDefinition qnd = getNodeState().getDefinition();
+        return session.getNodeTypeManager().getNodeDefinition(qnd);
-        // make sure the specified workspace is visible for the current session.
-        session.checkAccessibleWorkspace(srcWorkspaceName);
+        // test if the corresponding node exists in the src-workspace which includes
+        // a check if the specified source workspace is accessible
+        try {
+            getCorrespondingNodePath(srcWorkspaceName);
+        } catch (ItemNotFoundException e) {
+            // no corresponding node exists -> method has not effect
+            return;
+        }
-            List failedStates = new ArrayList();
-            while (failedIds.hasNext()) {
-                try {
-                    ItemId id = failedIds.nextId();
-                    ItemState state = session.getItemStateManager().getItemState(id);
-                    if (state.isNode()) {
-                        failedStates.add(state);
-                    } else {
-                        // should not occur
-                        throw new RepositoryException("Merge failed with internal error: NodeState expected.");
-                    }
-                } catch (ItemStateException e) {
-                    // should not occur
-                    throw new RepositoryException(e);
-                }
-            }
-            if (failedStates.isEmpty()) {
-                return IteratorHelper.EMPTY;
-            } else {
-                return new LazyItemIterator(itemMgr, failedStates);
-            }
+            return new LazyItemIterator(itemMgr, session.getHierarchyManager(), failedIds);
+        // NEW nodes with inherited-mixins -> mixin not yet active
+        if (getNodeState().getStatus() == Status.NEW &&
+            session.getNodeTypeManager().getNodeType(qName).isMixin()) {
+            return false;
+        }
+
-        if (getNodeState().getParent() == null) {
+        if (getNodeState().isRoot()) {
-        NodeState childState;
-        try {
-            List cne = getNodeState().getChildNodeEntries(nodeName);
-            if (definition.allowsSameNameSiblings()) {
-                // TODO TOBEFIXED find proper solution. problem with SNSs
-                childState = ((ChildNodeEntry)cne.get(cne.size()-1)).getNodeState();
-            } else {
-                childState = ((ChildNodeEntry)cne.get(0)).getNodeState();
-            }
-        } catch (ItemStateException e) {
-            // should not occur
-            throw new RepositoryException(e);
+        NodeEntry entry;
+        List cne = getNodeEntry().getNodeEntries(nodeName);
+        if (definition.allowsSameNameSiblings()) {
+            // TODO TOBEFIXED find proper solution. problem with SNSs
+            entry = ((NodeEntry)cne.get(cne.size()-1));
+        } else {
+            entry = ((NodeEntry)cne.get(0));
-        return (Node) itemMgr.getItem(childState);
+        return (Node) itemMgr.getItem(entry);
-            PropertyState pState = getNodeState().getPropertyState(qName);
-            return (Property) itemMgr.getItem(pState);
-        } catch (AccessDeniedException ade) {
-            throw new ItemNotFoundException(qName.toString());
-        } catch (NoSuchItemStateException e) {
+            PropertyEntry pEntry = getNodeEntry().getPropertyEntry(qName);
+            if (pEntry == null) {
+                throw new PathNotFoundException(qName.toString());
+            }
+            return (Property) itemMgr.getItem(pEntry);
+        } catch (AccessDeniedException e) {
-        } catch (ItemStateException e) {
-            String msg = "Error while accessing property " + qName.toString();
-            throw new RepositoryException(msg, e);
+        } catch (ItemNotFoundException e) {
+            throw new PathNotFoundException(qName.toString());
-    private boolean isValidMixin(QName mixinName) throws NoSuchNodeTypeException, NodeTypeConflictException {
+    private boolean canAddMixin(QName mixinName) throws NoSuchNodeTypeException,
+        NodeTypeConflictException {
-        // get list of existing nodetypes
-        QName[] existingNts = getNodeState().getNodeTypeNames();
-        // build effective node type representing primary type including existing mixin's
-        EffectiveNodeType entExisting = session.getValidator().getEffectiveNodeType(existingNts);
-
+
+        // get list of existing nodetypes
+        QName[] existingNts = getNodeState().getNodeTypeNames();
+        // build effective node type representing primary type including existing mixin's
+        EffectiveNodeType entExisting = session.getValidator().getEffectiveNodeType(existingNts);
+
+     * @return <code>NodeEntry</code> of this <code>Node</code>
+     */
+    private NodeEntry getNodeEntry() {
+        return (NodeEntry) getItemState().getHierarchyEntry();
+    }
+
+    /**
-     * Returns the id of the node at <code>relPath</code> or <code>null</code>
-     * if no node exists at <code>relPath</code>.
+     * Returns the <code>NodeEntry</code> at <code>relPath</code> or
+     * <code>null</code> if no node exists at <code>relPath</code>.
-     * @return the state of the node at <code>relPath</code> or <code>null</code>
-     * if no node exists at <code>relPath</code>.
+     * @return the HierarchyEntry of the node at <code>relPath</code> or
+     * <code>null</code> if no node exists at <code>relPath</code>.
-    private NodeState resolveRelativeNodePath(String relPath) throws RepositoryException {
-        NodeState targetState = null;
+    private NodeEntry resolveRelativeNodePath(String relPath) throws RepositoryException {
+        NodeEntry targetEntry = null;
-                    targetState = getNodeState();
+                    targetEntry = getNodeEntry();
-                    targetState = getNodeState().getParent();
-                } else if (pe.denotesName()) {
-                    // if relative path is just a 'name' -> retrieve the corresponding
-                    // child-node (if existing).
-                    int index = pe.getNormalizedIndex();
-                    ChildNodeEntry cne = getNodeState().getChildNodeEntry(pe.getName(), index);
-                    if (cne != null) {
-                        targetState = cne.getNodeState();
-                    } // else: there's no child node with that name
+                    targetEntry = getNodeEntry().getParent();
+                } else {
+                    targetEntry = getNodeEntry().getNodeEntry(pe.getName(), pe.getNormalizedIndex());
-            } else {
+            }
+            if (targetEntry == null) {
+                // rp length > 1 OR child entry has not yet been loaded.
-                ItemState itemState = session.getHierarchyManager().getItemState(p.getCanonicalPath());
-                if (itemState.isNode()) {
-                    targetState = (NodeState) itemState;
+                HierarchyEntry entry = session.getHierarchyManager().getHierarchyEntry(p.getCanonicalPath());
+                if (entry.denotesNode()) {
+                    targetEntry = (NodeEntry) entry;
-        } catch (ItemStateException e) {
-            // should not occure
-            String msg = "Invalid relative path: " + relPath;
-            log.debug(msg);
-            throw new RepositoryException(msg, e);
-        return targetState;
+        return targetEntry;
-     * @return the state of the property at <code>relPath</code> or
+     * @return the PropertyEntry of the property at <code>relPath</code> or
-    private PropertyState resolveRelativePropertyPath(String relPath) throws RepositoryException {
-        PropertyState targetState = null;
+    private PropertyEntry resolveRelativePropertyPath(String relPath) throws RepositoryException {
+        PropertyEntry targetEntry = null;
-                    if (getNodeState().hasPropertyName(propName)) {
-                        try {
-                            targetState = getNodeState().getPropertyState(propName);
-                        } catch (ItemStateException e) {
-                            // should not occur due, since existance has been checked
-                            throw new RepositoryException(e);
-                        } // else: there's no property with that name
-                    }
-                } // else: return null.
-            } else {
+                    targetEntry = getNodeEntry().getPropertyEntry(propName);
+                } // else: entry may not have been loaded yet -> try via H-Mgr
+            }
+
+            if (targetEntry == null) {
-                    ItemState itemState = session.getHierarchyManager().getItemState(p);
-                    if (!itemState.isNode()) {
-                        targetState = (PropertyState) itemState;
+                    HierarchyEntry entry = session.getHierarchyManager().getHierarchyEntry(p);
+                    if (!entry.denotesNode()) {
+                        targetEntry = (PropertyEntry) entry;
-        return targetState;
+        return targetEntry;

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV31 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 INS31 INS31 INS31 MOV29 INS39 UPD42 MOV43 INS8 INS29 INS83 INS43 INS42 INS8 MOV8 MOV29 MOV83 MOV43 MOV42 MOV44 MOV43 MOV43 INS8 UPD42 MOV60 MOV60 INS29 INS83 INS43 INS42 INS8 UPD43 UPD43 INS54 INS54 MOV21 INS60 MOV21 MOV60 MOV25 MOV21 MOV21 MOV21 MOV21 INS25 INS25 INS65 INS65 INS42 INS60 INS25 MOV60 INS21 INS41 INS60 INS54 INS25 MOV60 MOV25 MOV60 MOV21 INS60 INS41 MOV21 INS54 INS65 UPD42 MOV42 INS41 UPD42 UPD42 UPD43 INS8 INS12 UPD43 INS8 INS12 INS12 INS39 INS59 INS42 UPD43 UPD43 INS43 INS32 INS43 INS32 INS8 INS8 MOV43 MOV32 INS8 MOV5 INS66 INS66 INS66 INS66 INS66 INS66 MOV5 INS59 INS32 INS8 INS32 INS42 INS43 INS59 INS32 INS8 INS12 INS8 INS27 INS8 MOV32 INS43 INS59 INS11 MOV8 MOV12 MOV12 INS66 INS11 UPD66 UPD66 UPD66 UPD66 UPD43 UPD42 UPD66 UPD43 UPD42 UPD42 UPD42 UPD42 MOV41 INS44 INS8 UPD42 UPD42 UPD42 MOV41 INS44 INS8 INS44 INS8 INS42 INS32 UPD42 INS40 MOV53 UPD42 UPD42 MOV32 UPD42 UPD42 UPD42 INS42 UPD42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 MOV21 INS41 MOV21 MOV60 MOV21 UPD42 INS32 UPD42 INS32 MOV60 MOV60 MOV21 MOV54 MOV25 INS42 INS3 INS32 INS42 INS40 INS25 UPD42 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS42 MOV21 INS44 INS8 INS41 INS27 INS32 INS41 UPD42 INS42 INS42 MOV43 INS32 INS25 INS43 MOV32 UPD42 UPD42 INS25 UPD42 UPD42 INS25 INS43 INS42 INS53 MOV43 INS42 INS53 INS43 INS42 INS53 INS32 INS42 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 INS42 INS32 UPD42 MOV42 UPD42 INS32 INS42 INS42 MOV5 MOV38 MOV5 MOV5 INS34 INS42 INS27 INS8 INS8 INS42 INS42 INS42 UPD42 INS32 INS42 INS42 INS42 INS43 INS42 INS41 INS14 INS32 INS40 INS32 INS42 INS9 UPD42 INS42 INS42 INS42 UPD43 INS27 INS8 UPD42 MOV43 UPD42 MOV42 UPD42 MOV27 INS8 UPD27 MOV27 MOV27 INS8 INS27 MOV53 INS53 INS42 INS14 INS14 INS42 INS14 INS42 INS45 INS32 INS32 UPD42 UPD42 UPD42 UPD42 INS27 INS42 INS42 INS42 MOV42 MOV42 UPD42 MOV32 INS40 INS21 INS54 UPD42 INS42 UPD42 INS42 MOV43 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS42 UPD42 UPD42 MOV36 UPD42 MOV36 UPD42 UPD42 INS42 INS33 INS53 MOV60 INS25 UPD42 INS25 INS42 INS33 INS14 UPD42 INS43 INS42 INS42 UPD42 UPD42 INS43 INS32 INS43 INS32 UPD42 INS42 INS42 INS42 INS42 UPD42 INS45 INS42 INS45 INS11 INS5 UPD42 INS7 INS8 INS12 MOV42 UPD42 MOV42 INS42 INS42 INS42 UPD42 INS14 UPD42 INS43 MOV27 INS8 INS25 UPD43 MOV32 INS8 INS45 MOV43 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV5 INS32 INS43 INS85 UPD42 UPD42 UPD42 INS42 MOV32 INS60 INS21 MOV44 INS8 UPD43 UPD43 UPD42 INS43 INS32 INS42 INS21 MOV27 INS8 INS8 UPD42 UPD42 UPD42 UPD42 MOV60 INS21 UPD42 MOV42 INS42 INS3 INS42 MOV5 MOV43 INS59 INS7 INS21 UPD42 UPD42 INS42 INS42 INS42 INS7 INS21 INS21 UPD42 INS7 UPD43 MOV5 INS32 INS42 MOV32 INS42 INS32 INS32 INS42 INS32 INS7 INS7 UPD42 INS42 INS32 UPD42 UPD42 INS42 INS42 UPD42 UPD42 INS40 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS32 INS42 INS32 UPD43 UPD42 INS32 INS42 INS42 UPD42 UPD42 UPD42 INS32 INS42 INS32 INS42 MOV32 MOV32 UPD42 INS42 UPD42 INS42 INS42 UPD43 UPD42 UPD42 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL42 DEL33 DEL7 DEL21 DEL42 DEL33 DEL7 DEL21 DEL42 DEL42 DEL68 DEL65 DEL29 DEL42 DEL43 DEL42 DEL43 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL59 DEL60 DEL33 DEL42 DEL42 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL83 DEL39 DEL42 DEL41 DEL8 DEL31 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL42 DEL43 DEL42 DEL45 DEL42 DEL32 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL42 DEL42 DEL34 DEL42 DEL34 DEL40 DEL42 DEL40 DEL2 DEL42 DEL7 DEL42 DEL40 DEL34 DEL27 DEL3 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL32 DEL32 DEL14 DEL42 DEL43 DEL32 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL40 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL32 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL61 DEL42 DEL42 DEL32 DEL40 DEL41 DEL8 DEL42 DEL42 DEL14 DEL41 DEL8 DEL25 DEL8 DEL33 DEL27 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL42 DEL42 DEL32 DEL11 DEL41 DEL8 DEL42 DEL43 DEL43 DEL42 DEL44 DEL43 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL31 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL7 DEL21 DEL8 DEL42 DEL42 DEL32 DEL39 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL25 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL45 DEL42 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL25 DEL8
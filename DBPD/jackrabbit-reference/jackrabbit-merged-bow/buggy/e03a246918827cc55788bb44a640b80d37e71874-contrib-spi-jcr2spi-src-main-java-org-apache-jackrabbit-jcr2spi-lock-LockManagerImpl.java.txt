workaround for locks that might be unlocked by another session (to be improved)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@521354 13f79535-47bb-0310-9956-ffa450edef68

+import javax.jcr.ItemNotFoundException;
-        if (lockMap.containsKey(nState)) {
-            return (LockImpl) lockMap.get(nState);
+        LockImpl l = getLockFromMap(nState);
+        if (l != null) {
+            return l;
-                if (lockMap.containsKey(lockHoldingState)) {
-                    return (LockImpl) lockMap.get(lockHoldingState);
+                l = getLockFromMap(nState);
+                if (l != null) {
+                    return l;
-            LockImpl lock;
-            if (lockMap.containsKey(lState.lockHoldingState)) {
-                lock = (LockImpl) lockMap.get(lState.lockHoldingState);
+            LockImpl lock = getLockFromMap(lState.lockHoldingState);
+            if (lock != null) {
+    private LockImpl getLockFromMap(NodeState nodeState) {
+        try {
+            LockImpl l = (LockImpl) lockMap.get(nodeState);
+            if (l != null && l.isLive()) {
+                return l;
+            }
+        } catch (RepositoryException e) {
+            // ignore
+        }
+        return null;
+    }
+    
-                    PropertyState ps = lockHoldingState.getPropertyState(QName.JCR_LOCKISDEEP);
-                    ps.removeListener(this);
-                } catch (RepositoryException e) {
-                    log.warn("Internal error", e);
+                    if (lockHoldingState.hasPropertyName(QName.JCR_LOCKISDEEP)) {
+                        PropertyState ps = lockHoldingState.getPropertyState(QName.JCR_LOCKISDEEP);
+                        ps.removeListener(this);
+                    }
+                } catch (ItemNotFoundException e) {
+                    log.debug("jcr:isDeep doesn't exist any more.");
+                } catch (Exception e) {
+                    log.warn(e.getMessage());
+        /**
+         * @see ItemStateLifeCycleListener#statusChanged(ItemState, int)
+         */
+                    break;
-                   // not interested (Todo correct?)
+                   // not interested
+        private boolean reloadInfo = false; // TODO: find better solution
-                // TODO: TOBEFIXED. since another session may become lock-holder for
-                // an open-scoped lock, the map entry and the lock information
-                // stored therein may become outdated.
+                // open-scoped locks: the map entry and the lock information
+                // stored therein may become outdated if the token is transfered
+                // to another session -> info must be reloaded.
+                if (!isSessionScoped()) {
+                    reloadInfo = true;
+                }
+            } else {
+                // foreign lock: info must be reloaded.
+                reloadInfo = true;
+            updateLockInfo();
+            updateLockInfo();
+        /**
+         * @return <code>LockInfo</code> stored within the <code>LockState</code>
+         */
+
+        /**
+         * Make sure the lock info is really up to date.
+         * TODO: find better solution.
+         */
+        private void updateLockInfo() {
+            if (reloadInfo) {
+                try {
+                    lockState.reloadLockInfo();
+                } catch (LockException e) {
+                    lockState.unlocked();
+                } catch (RepositoryException e) {
+                    log.error("Internal error", e);
+                }
+            } // else: nothing to do.
+        }
+        /**
+         * @return true if this lock is hold by this session. false otherwise.
+         */

INS26 INS40 INS31 INS83 INS43 INS42 INS44 INS8 INS23 INS31 INS60 INS25 INS42 INS43 INS42 INS54 INS41 INS29 INS83 INS39 INS59 INS29 INS29 INS83 INS39 INS42 INS8 INS29 MOV43 INS59 INS27 MOV8 INS42 INS8 MOV12 INS33 INS65 INS42 INS9 INS21 INS21 INS65 INS65 INS25 INS65 INS42 INS32 INS42 INS33 INS60 INS25 INS8 INS68 INS10 INS32 INS32 INS66 INS66 INS66 INS42 INS8 INS66 UPD42 MOV42 MOV42 INS42 INS27 MOV43 INS59 INS27 INS8 INS54 INS42 INS42 INS69 INS69 INS8 INS42 INS42 INS54 INS21 INS25 INS32 INS42 INS33 INS42 INS11 INS27 INS32 INS41 MOV8 INS12 INS12 INS43 INS39 INS25 INS21 INS8 INS12 INS12 INS7 INS27 MOV8 INS42 INS40 MOV43 INS32 INS42 INS33 INS42 INS42 INS42 INS25 INS44 INS8 INS44 INS8 INS42 INS38 INS8 INS7 INS21 INS44 INS8 INS44 INS8 INS42 INS32 INS42 INS33 INS42 INS42 INS42 INS32 MOV8 INS43 INS42 INS21 INS43 INS42 INS21 INS32 INS21 INS42 INS9 INS32 INS43 INS42 INS21 INS43 INS42 INS21 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS40 INS42 INS32 INS42 INS32 INS42 INS7 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS32 INS42 INS9 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 DEL42 DEL42 DEL42 DEL32 DEL11 DEL42 DEL32 DEL25 DEL42 DEL42 DEL42 DEL32 DEL11 DEL42 DEL32 DEL25 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL42 DEL40 DEL32 DEL11 DEL7 DEL21 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL54
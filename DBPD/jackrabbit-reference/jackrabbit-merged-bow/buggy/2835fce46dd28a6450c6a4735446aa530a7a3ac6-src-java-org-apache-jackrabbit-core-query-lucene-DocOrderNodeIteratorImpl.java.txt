Create document order NodeIterator only when needed.

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@164248 13f79535-47bb-0310-9956-ffa450edef68

-    private final NodeIteratorImpl orderedNodes;
+    private NodeIteratorImpl orderedNodes;
-        long time = System.currentTimeMillis();
-        ScoreNode[] nodes = new ScoreNode[uuids.length];
-        for (int i = 0; i < uuids.length; i++) {
-            nodes[i] = new ScoreNode(uuids[i], scores[i]);
-        }
-
-        Arrays.sort(nodes, new Comparator() {
-            public int compare(Object o1, Object o2) {
-                ScoreNode n1 = (ScoreNode) o1;
-                ScoreNode n2 = (ScoreNode) o2;
-                try {
-                    NodeImpl node1 = (NodeImpl) itemMgr.getItem(new NodeId(n1.uuid));
-                    NodeImpl node2 = (NodeImpl) itemMgr.getItem(new NodeId(n2.uuid));
-                    Path.PathElement[] path1 = node1.getPrimaryPath().getElements();
-                    Path.PathElement[] path2 = node2.getPrimaryPath().getElements();
-
-                    // find nearest common ancestor
-                    int commonDepth = 0; // root
-                    while (path1.length > commonDepth && path2.length > commonDepth) {
-                        if (path1[commonDepth].equals(path2[commonDepth])) {
-                            commonDepth++;
-                        } else {
-                            break;
-                        }
-                    }
-                    // path elements at last depth were equal
-                    commonDepth--;
-
-                    // check if either path is an ancestor of the other
-                    if (path1.length - 1 == commonDepth) {
-                        // path1 itself is ancestor of path2
-                        return -1;
-                    }
-                    if (path2.length - 1 == commonDepth) {
-                        // path2 itself is ancestor of path1
-                        return 1;
-                    }
-                    // get common ancestor node
-                    NodeImpl commonNode = (NodeImpl) node1.getAncestor(commonDepth);
-                    // move node1/node2 to the commonDepth + 1
-                    // node1 and node2 then will be child nodes of commonNode
-                    node1 = (NodeImpl) node1.getAncestor(commonDepth + 1);
-                    node2 = (NodeImpl) node2.getAncestor(commonDepth + 1);
-                    for (NodeIterator it = commonNode.getNodes(); it.hasNext();) {
-                        Node child = it.nextNode();
-                        if (child.isSame(node1)) {
-                            return -1;
-                        } else if (child.isSame(node2)) {
-                            return 1;
-                        }
-                    }
-                    log.error("Internal error: unable to determine document order of nodes:");
-                    log.error("\tNode1: " + node1.getPath());
-                    log.error("\tNode2: " + node2.getPath());
-                    return 0;
-                } catch (RepositoryException e) {
-                    log.error("Exception while sorting nodes in document order: " + e.toString(), e);
-                    // todo ???
-                    return 0;
-                }
-            }
-        });
-
-        for (int i = 0; i < nodes.length; i++) {
-            uuids[i] = nodes[i].uuid;
-            scores[i] = nodes[i].score;
-        }
-        if (log.isDebugEnabled()) {
-            log.debug("" + uuids.length + " node(s) ordered in " + (System.currentTimeMillis() - time) + " ms");
-        }
-        orderedNodes = new NodeIteratorImpl(itemMgr, uuids, scores);
+        initOrderedIterator();
+        initOrderedIterator();
-        return orderedNodes.getSize();
+        return uuids.length;
+        initOrderedIterator();
+        initOrderedIterator();
+        initOrderedIterator();
+        initOrderedIterator();
+        initOrderedIterator();
+    /**
+     * Initializes the NodeIterator in document order, if needed.
+     */
+    private void initOrderedIterator() {
+        if (orderedNodes == null) {
+            long time = System.currentTimeMillis();
+            ScoreNode[] nodes = new ScoreNode[uuids.length];
+            for (int i = 0; i < uuids.length; i++) {
+                nodes[i] = new ScoreNode(uuids[i], scores[i]);
+            }
+
+            Arrays.sort(nodes, new Comparator() {
+                public int compare(Object o1, Object o2) {
+                    ScoreNode n1 = (ScoreNode) o1;
+                    ScoreNode n2 = (ScoreNode) o2;
+                    try {
+                        NodeImpl node1 = (NodeImpl) itemMgr.getItem(new NodeId(n1.uuid));
+                        NodeImpl node2 = (NodeImpl) itemMgr.getItem(new NodeId(n2.uuid));
+                        Path.PathElement[] path1 = node1.getPrimaryPath().getElements();
+                        Path.PathElement[] path2 = node2.getPrimaryPath().getElements();
+
+                        // find nearest common ancestor
+                        int commonDepth = 0; // root
+                        while (path1.length > commonDepth && path2.length > commonDepth) {
+                            if (path1[commonDepth].equals(path2[commonDepth])) {
+                                commonDepth++;
+                            } else {
+                                break;
+                            }
+                        }
+                        // path elements at last depth were equal
+                        commonDepth--;
+
+                        // check if either path is an ancestor of the other
+                        if (path1.length - 1 == commonDepth) {
+                            // path1 itself is ancestor of path2
+                            return -1;
+                        }
+                        if (path2.length - 1 == commonDepth) {
+                            // path2 itself is ancestor of path1
+                            return 1;
+                        }
+                        // get common ancestor node
+                        NodeImpl commonNode = (NodeImpl) node1.getAncestor(commonDepth);
+                        // move node1/node2 to the commonDepth + 1
+                        // node1 and node2 then will be child nodes of commonNode
+                        node1 = (NodeImpl) node1.getAncestor(commonDepth + 1);
+                        node2 = (NodeImpl) node2.getAncestor(commonDepth + 1);
+                        for (NodeIterator it = commonNode.getNodes(); it.hasNext();) {
+                            Node child = it.nextNode();
+                            if (child.isSame(node1)) {
+                                return -1;
+                            } else if (child.isSame(node2)) {
+                                return 1;
+                            }
+                        }
+                        log.error("Internal error: unable to determine document order of nodes:");
+                        log.error("\tNode1: " + node1.getPath());
+                        log.error("\tNode2: " + node2.getPath());
+                        return 0;
+                    } catch (RepositoryException e) {
+                        log.error("Exception while sorting nodes in document order: " + e.toString(), e);
+                        // todo ???
+                        return 0;
+                    }
+                }
+            });
+
+            for (int i = 0; i < nodes.length; i++) {
+                uuids[i] = nodes[i].uuid;
+                scores[i] = nodes[i].score;
+            }
+            if (log.isDebugEnabled()) {
+                log.debug("" + uuids.length + " node(s) ordered in " + (System.currentTimeMillis() - time) + " ms");
+            }
+            orderedNodes = new NodeIteratorImpl(itemMgr, uuids, scores);
+        }
+    }
+

MOV31 INS31 MOV29 INS42 MOV44 MOV44 MOV44 INS8 INS29 INS83 INS39 UPD42 INS8 MOV46 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS65 INS25 INS32 INS32 INS40 INS32 INS32 INS32 INS32 INS32 INS66 INS27 MOV8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 DEL83 DEL42 DEL42 DEL32
JCR-1990: Optimize queries with relative path in order by clause

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@746946 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.state.PropertyState;
+import org.apache.jackrabbit.core.PropertyId;
+import javax.jcr.PathNotFoundException;
+
-     * The rules that define this indexing aggregate.
+     * The node includes of this indexing aggregate.
-    private final Rule[] rules;
+    private final NodeInclude[] nodeIncludes;
+
+    /**
+     * The property includes of this indexing aggregate.
+     */
+    private final PropertyInclude[] propertyIncludes;
-                      HierarchyManager hmgr)
-            throws MalformedPathException, IllegalNameException, NamespaceException {
+                      HierarchyManager hmgr) throws MalformedPathException,
+            IllegalNameException, NamespaceException, PathNotFoundException {
-        this.rules = getRules(config);
+        this.nodeIncludes = getNodeIncludes(config);
+        this.propertyIncludes = getPropertyIncludes(config);
-     * @param nodeState
+     * @param nodeState the node state.
-        for (int i = 0; i < rules.length; i++) {
-            NodeState aggregateRoot = rules[i].matches(nodeState);
+        for (int i = 0; i < nodeIncludes.length; i++) {
+            NodeState aggregateRoot = nodeIncludes[i].matches(nodeState);
+            if (aggregateRoot != null
+                    && aggregateRoot.getNodeTypeName().equals(nodeTypeName)) {
+                return aggregateRoot;
+            }
+        }
+        // check property includes
+        for (int i = 0; i < propertyIncludes.length; i++) {
+            NodeState aggregateRoot = propertyIncludes[i].matches(nodeState);
-            for (int i = 0; i < rules.length; i++) {
-                nodeStates.addAll(Arrays.asList(rules[i].resolve(nodeState)));
+            for (int i = 0; i < nodeIncludes.length; i++) {
+                nodeStates.addAll(Arrays.asList(nodeIncludes[i].resolve(nodeState)));
+    /**
+     * {@inheritDoc}
+     */
+    public PropertyState[] getAggregatedPropertyStates(NodeState nodeState)
+            throws ItemStateException {
+        if (nodeState.getNodeTypeName().equals(nodeTypeName)) {
+            List propStates = new ArrayList();
+            for (int i = 0; i < propertyIncludes.length; i++) {
+                propStates.addAll(Arrays.asList(
+                        propertyIncludes[i].resolvePropertyStates(nodeState)));
+            }
+            if (propStates.size() > 0) {
+                return (PropertyState[]) propStates.toArray(
+                        new PropertyState[propStates.size()]);
+            }
+        }
+        return null;
+    }
+
-     * Creates rules defined in the <code>config</code>.
+     * Creates node includes defined in the <code>config</code>.
-     * @return the rules defined in the <code>config</code>.
+     * @return the node includes defined in the <code>config</code>.
-    private Rule[] getRules(Node config)
+    private NodeInclude[] getNodeIncludes(Node config)
-        List rules = new ArrayList();
+        List includes = new ArrayList();
-                rules.add(new Rule(builder.getPath(), ntName));
+                includes.add(new NodeInclude(builder.getPath(), ntName));
-        return (Rule[]) rules.toArray(new Rule[rules.size()]);
+        return (NodeInclude[]) includes.toArray(new NodeInclude[includes.size()]);
+    }
+
+    /**
+     * Creates property includes defined in the <code>config</code>.
+     *
+     * @param config the indexing aggregate configuration.
+     * @return the property includes defined in the <code>config</code>.
+     * @throws MalformedPathException if a path in the configuration is
+     *                                malformed.
+     * @throws IllegalNameException   if the node type name contains illegal
+     *                                characters.
+     * @throws NamespaceException if the node type contains an unknown
+     *                                prefix.
+     */
+    private PropertyInclude[] getPropertyIncludes(Node config) throws
+            MalformedPathException, IllegalNameException, NamespaceException,
+            PathNotFoundException {
+        List includes = new ArrayList();
+        NodeList childNodes = config.getChildNodes();
+        for (int i = 0; i < childNodes.getLength(); i++) {
+            Node n = childNodes.item(i);
+            if (n.getNodeName().equals("include-property")) {
+                String[] elements = Text.explode(getTextContent(n), '/');
+                PathBuilder builder = new PathBuilder();
+                for (int j = 0; j < elements.length; j++) {
+                    if (elements[j].equals("*")) {
+                        throw new IllegalNameException("* not supported in include-property");
+                    }
+                    builder.addLast(resolver.getQName(elements[j]));
+                }
+                includes.add(new PropertyInclude(builder.getPath()));
+            }
+        }
+        return (PropertyInclude[]) includes.toArray(new PropertyInclude[includes.size()]);
-    private final class Rule {
+    private abstract class AbstractInclude {
-        private final Name nodeTypeName;
+        protected final Name nodeTypeName;
-        private final Path pattern;
+        protected final Path pattern;
-        private Rule(Path pattern, Name nodeTypeName) {
+        AbstractInclude(Path pattern, Name nodeTypeName) {
+         * @throws ItemStateException if an error occurs while accessing node
+         *                            states.
+         * @throws RepositoryException if another error occurs.
-        /**
-         * Resolves the <code>nodeState</code> using this rule.
-         *
-         * @param nodeState the root node of the enclosing indexing aggregate.
-         * @return the descendant node states as defined by this rule.
-         * @throws ItemStateException if an error occurs while resolving the
-         *                            node states.
-         */
-        NodeState[] resolve(NodeState nodeState) throws ItemStateException {
-            List nodeStates = new ArrayList();
-            resolve(nodeState, nodeStates, 0);
-            return (NodeState[]) nodeStates.toArray(new NodeState[nodeStates.size()]);
-        }
-
-        private void resolve(NodeState nodeState, List collector, int offset)
+        protected void resolve(NodeState nodeState, List collector, int offset)
+
+    private final class NodeInclude extends AbstractInclude {
+
+        /**
+         * Creates a new node include with a relative path pattern and an
+         * optional node type name.
+         *
+         * @param nodeTypeName node type name or <code>null</code> if all node
+         *                     types are allowed.
+         * @param pattern      a relative path pattern.
+         */
+        NodeInclude(Path pattern, Name nodeTypeName) {
+            super(pattern, nodeTypeName);
+        }
+
+        /**
+         * Resolves the <code>nodeState</code> using this rule.
+         *
+         * @param nodeState the root node of the enclosing indexing aggregate.
+         * @return the descendant node states as defined by this rule.
+         * @throws ItemStateException if an error occurs while resolving the
+         *                            node states.
+         */
+        NodeState[] resolve(NodeState nodeState) throws ItemStateException {
+            List nodeStates = new ArrayList();
+            resolve(nodeState, nodeStates, 0);
+            return (NodeState[]) nodeStates.toArray(new NodeState[nodeStates.size()]);
+        }
+    }
+
+    private final class PropertyInclude extends AbstractInclude {
+
+        private final Name propertyName;
+
+        PropertyInclude(Path pattern)
+                throws PathNotFoundException {
+            super(pattern.getAncestor(1), null);
+            this.propertyName = pattern.getNameElement().getName();
+        }
+
+        /**
+         * Resolves the <code>nodeState</code> using this rule.
+         *
+         * @param nodeState the root node of the enclosing indexing aggregate.
+         * @return the descendant property states as defined by this rule.
+         * @throws ItemStateException if an error occurs while resolving the
+         *                            property states.
+         */
+        PropertyState[] resolvePropertyStates(NodeState nodeState)
+                throws ItemStateException {
+            List nodeStates = new ArrayList();
+            resolve(nodeState, nodeStates, 0);
+            List propStates = new ArrayList();
+            for (Iterator it = nodeStates.iterator(); it.hasNext(); ) {
+                NodeState state = (NodeState) it.next();
+                if (state.hasPropertyName(propertyName)) {
+                    PropertyId propId = new PropertyId(state.getNodeId(), propertyName);
+                    propStates.add(ism.getItemState(propId));
+                }
+            }
+            return (PropertyState[]) propStates.toArray(
+                    new PropertyState[propStates.size()]);
+        }
+    }

INS26 INS26 INS26 INS40 INS40 INS40 INS23 INS31 INS31 INS55 INS55 UPD5 INS29 INS83 INS83 INS5 INS59 INS43 INS29 INS83 INS5 INS42 INS44 INS43 INS8 UPD5 UPD42 INS29 INS83 INS5 INS42 INS44 INS43 INS43 INS43 INS43 INS8 UPD83 UPD42 INS83 INS83 INS42 INS43 INS31 MOV31 INS83 INS83 INS42 INS43 INS23 INS31 INS31 UPD43 UPD42 INS65 INS43 INS85 INS42 INS42 INS21 INS24 INS41 INS65 INS43 INS85 INS43 INS42 INS42 INS25 MOV41 UPD43 INS60 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS85 INS43 INS42 INS42 INS42 INS42 INS42 INS60 INS60 INS24 INS41 UPD83 UPD83 UPD42 UPD83 INS42 INS29 INS42 INS44 INS44 INS8 INS42 INS83 INS83 INS43 INS59 INS42 INS44 INS43 INS8 INS29 INS5 INS42 INS44 INS43 INS8 UPD66 UPD42 INS66 INS42 INS7 INS66 INS58 INS27 INS37 INS8 INS33 INS65 INS42 INS42 INS32 INS8 UPD66 UPD66 UPD42 INS43 INS59 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS43 INS59 INS43 INS59 INS58 INS27 INS37 INS8 INS11 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS46 INS42 INS42 INS43 INS42 INS42 INS46 INS21 INS65 INS65 INS65 INS65 INS43 INS85 INS43 INS42 INS42 INS60 INS21 INS60 INS24 INS41 INS22 INS32 UPD40 INS39 INS59 INS42 INS40 INS42 INS60 INS25 INS32 INS42 INS42 MOV60 INS24 INS25 INS42 INS42 INS14 UPD5 INS42 INS42 INS14 INS42 INS42 INS32 INS39 INS59 INS42 INS32 INS42 INS60 INS25 INS5 INS32 INS42 INS66 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS42 INS42 INS42 INS42 INS32 INS33 INS7 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS43 INS59 INS32 INS43 INS59 INS58 INS32 INS8 INS11 UPD42 UPD42 INS52 INS42 INS42 INS42 INS42 INS34 INS43 INS59 INS27 INS8 INS42 INS42 INS58 INS27 INS37 INS8 INS27 INS8 INS43 UPD43 UPD42 INS43 INS42 INS42 INS42 INS34 INS42 INS42 INS43 INS59 INS32 INS8 INS43 INS85 INS42 INS42 INS3 INS42 INS42 INS34 INS22 INS32 INS42 INS42 INS14 INS42 INS42 INS42 INS34 INS42 INS42 INS14 INS43 INS59 INS42 INS42 INS60 INS25 INS5 INS32 INS42 INS42 INS32 INS27 INS32 INS41 UPD40 UPD42 INS39 INS59 INS42 INS40 INS42 INS21 INS32 INS34 INS41 INS42 UPD42 UPD5 INS42 INS42 INS42 INS32 INS32 INS42 INS45 INS60 INS60 INS24 INS21 INS42 INS5 INS32 INS52 INS42 INS32 INS42 INS43 INS43 INS42 INS42 INS32 INS43 INS59 INS32 INS8 INS43 INS85 INS42 INS42 INS3 INS2 INS42 INS42 INS42 INS33 INS32 INS42 INS42 INS42 INS42 INS34 INS32 INS42 INS42 INS11 UPD43 UPD42 INS42 INS42 INS42 INS42 INS42 INS5 INS59 INS43 INS59 INS58 INS27 INS37 INS8 INS32 INS43 INS85 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS42 INS60 INS21 INS42 INS5 INS32 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS5 INS32 UPD42 UPD42 INS43 INS85 INS42 INS32 INS42 INS42 INS14 INS39 INS59 INS42 INS40 INS42 INS25 INS21 INS42 INS42 INS14 INS42 INS43 INS32 INS43 INS59 INS32 INS43 INS85 INS42 INS42 INS42 INS42 INS32 INS43 INS85 INS42 INS42 INS3 UPD43 INS42 INS42 INS42 INS32 INS13 INS43 INS42 INS34 INS32 INS8 INS32 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS2 INS42 INS42 INS42 INS5 INS32 UPD42 INS42 INS42 INS42 INS2 INS42 INS45 INS53 INS42 INS42 INS32 INS42 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS43 INS85 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS2 INS42 INS42 INS42 INS42 INS43 INS45 INS42 INS42 INS42 DEL83
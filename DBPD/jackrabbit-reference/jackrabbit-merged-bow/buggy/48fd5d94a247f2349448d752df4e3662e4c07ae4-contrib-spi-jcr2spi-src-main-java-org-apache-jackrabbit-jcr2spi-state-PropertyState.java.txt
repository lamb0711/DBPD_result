work in progress

- removeVersion missing
- LockManager/VersionManager: should not rely on observation (todo added)
- Add Operation.persisted() (Impl. still missing) in analogy to ChangeLog.persisted.
- ItemImpl.refresh behaves according to CacheBehaviour flag.
- NodeState: fix classcastexception when accessing state from propertiesInAttic
- ItemState: rename 'refresh()' to 'reload()
- ItemState: move code common to PropertyState and NodeState to ItemState
- ItemState: rename 'reset' to 'merge'
- add common interface ChildItemEntry
- SessionItemStateManager: avoid traversing twice during 'undo'

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@477095 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Set;
-        reset();
+        init(overlayedState.getType(), overlayedState.getValues());
-     * @see ItemState#refresh()
+     * @see ItemState#reload(boolean)
-    public void refresh() {
+    public void reload(boolean keepChanges) {
-            // refresh from persistent storage
+            // refresh from persistent storage ('keepChanges' not relevant).
-                init(tmp.getType(), tmp.getValues());
-                setStatus(Status.MODIFIED);
+                if (merge(tmp, false) || getStatus() == Status.INVALIDATED) {
+                    setStatus(Status.MODIFIED);
+                }
-                // does not exist anymore
+                // TODO: make sure the property-entry is removed from the parent state
+                // inform overlaying state and listeners
-                // todo also remove from parent? how do we make sure the parent
-                // todo does not get modified by this removal?
-                // parent.propertyStateRemoved(this);
-            // session state
-            if (getStatus() == Status.EXISTING || getStatus() == Status.INVALIDATED) {
-                // calling refresh on the workspace state will in turn
-                // also refresh / reset the session state
-                overlayedState.refresh();
+            /* session-state: if keepChanges is true only existing or invalidated
+               states must be updated. otherwise the state gets updated and might
+               be marked 'Stale' if transient changes are present and the
+               workspace-state is modified. */
+            if (!keepChanges || getStatus() == Status.EXISTING || getStatus() == Status.INVALIDATED) {
+                // calling refresh on the workspace state will in turn reset this state
+                overlayedState.reload(keepChanges);
-     * {@inheritDoc}
-     * @see ItemState#invalidate()
+     * If <code>keepChanges</code> is true, this method does nothing and returns
+     * false. Otherwise type and values of the other property state are compared
+     * to this state. If they differ, they will be copied to this state and
+     * this method returns true.
+     *
+     * @see ItemState#merge(ItemState, boolean)
-    public void invalidate() {
+    boolean merge(ItemState another, boolean keepChanges) {
+        if (another == null) {
+            return false;
+        }
+        if (another.isNode()) {
+            throw new IllegalArgumentException("Attempt to merge property state with node state.");
+        }
+        if (keepChanges || !diff(this, (PropertyState) another)) {
+            // nothing to do.
+            return false;
+        }
+
+        synchronized (another) {
+            PropertyState pState = (PropertyState) another;
+            init(pState.type, pState.values);
+        }
+        return true;
+    }
+
+    /**
+     * {@inheritDoc}
+     * @see ItemState#invalidate(boolean)
+     */
+    public void invalidate(boolean recursive) {
-                overlayedState.invalidate();
+                overlayedState.invalidate(recursive);
-                // TODO: improve.
-                /* retrieve property value and type from server even if
-                   changes were issued from this session (changelog).
-                   this is currently the only way to update the workspace
-                   state, which is not connected to its overlaying session-state.
-                */
-                try {
-                    PropertyState tmp = isf.createPropertyState(getPropertyId(), parent);
-                    init(tmp.getType(), tmp.getValues());
-                    setStatus(Status.MODIFIED);
-                } catch (ItemStateException e) {
-                    // TODO: rather throw?
-                    log.error("Internal Error", e);
-                }
+                // retrieve modified property value and type from server.
+                reload(false);
-                target, if it was modified. removal, add must be persisted on parent.
+                target, if it was modified. removal, add and implicit modification
+                of protected properties must be persisted by save on parent.
-
-    /**
-     * {@inheritDoc}
-     * @see ItemState#reset()
-     */
-    synchronized void reset() {
-        checkIsSessionState();
-        if (overlayedState != null) {
-            synchronized (overlayedState) {
-                PropertyState wspState = (PropertyState) overlayedState;
-                init(wspState.type, wspState.values);
-            }
-        }
-    }
-
-    /**
-     * @inheritDoc
-     * @see ItemState#remove()
-     */
-    void remove() {
-        checkIsSessionState();
-        if (getStatus() == Status.NEW) {
-            setStatus(Status.REMOVED);
-        } else {
-            setStatus(Status.EXISTING_REMOVED);
-        }
-        getParent().propertyStateRemoved(this);
-    }
-
-    /**
-     * @inheritDoc
-     * @see ItemState#revert(Set)
-     */
-    void revert(Set affectedItemStates) {
-        checkIsSessionState();
-
-        switch (getStatus()) {
-            case Status.EXISTING:
-                // nothing to do
-                break;
-            case Status.EXISTING_MODIFIED:
-            case Status.EXISTING_REMOVED:
-            case Status.STALE_MODIFIED:
-                // revert state from overlayed
-                reset();
-                setStatus(Status.EXISTING);
-                affectedItemStates.add(this);
-                break;
-            case Status.NEW:
-                // set removed
-                setStatus(Status.REMOVED);
-                // and remove from parent
-                getParent().propertyStateRemoved(this);
-                affectedItemStates.add(this);
-                break;
-            case Status.REMOVED:
-                // shouldn't happen actually, because a 'removed' state is not
-                // accessible anymore
-                log.warn("trying to revert an already removed property state");
-                getParent().propertyStateRemoved(this);
-                break;
-            case Status.STALE_DESTROYED:
-                // overlayed does not exist anymore
-                getParent().propertyStateRemoved(this);
-                affectedItemStates.add(this);
-                break;
-        }
-    }
-
-    /**
-     * @inheritDoc
-     * @see ItemState#collectTransientStates(Collection)
-     */
-    void collectTransientStates(Collection transientStates) {
-        checkIsSessionState();
-
-        switch (getStatus()) {
-            case Status.EXISTING_MODIFIED:
-            case Status.EXISTING_REMOVED:
-            case Status.NEW:
-            case Status.STALE_DESTROYED:
-            case Status.STALE_MODIFIED:
-                transientStates.add(this);
-                break;
-            case Status.EXISTING:
-            case Status.REMOVED:
-                log.debug("Collecting transient states: Ignored PropertyState with status " + getStatus());
-                break;
-            default:
-                // should never occur. status is validated upon setStatus(int)
-                log.error("Internal error: Invalid state " + getStatus());
-        }
-    }
-
+    
+
+    /**
+     * Returns true, if type and/or values of the given property states differ.
+     *
+     * @param p1
+     * @param p2
+     * @return if the 2 <code>PropertyState</code>s are different in terms of
+     * type and/or values.
+     */
+    private static boolean diff(PropertyState p1, PropertyState p2) {
+        // compare type
+        if (p1.getType() != p2.getType()) {
+            return true;
+        }
+
+        QValue[] vs1 = p1.getValues();
+        QValue[] vs2 = p2.getValues();
+        if (vs1.length != vs2.length) {
+            return true;
+        } else {
+            for (int i = 0; i < vs1.length; i++) {
+                boolean eq = (vs1[i] == null) ? vs2[i] == null : vs1[i].equals(vs2[i]);
+                if (!eq) {
+                    return true;
+                }
+            }
+        }
+        // no difference
+        return false;
+    }

MOV31 INS31 UPD42 INS44 UPD39 UPD42 INS44 INS44 INS44 MOV29 INS83 INS83 UPD39 MOV39 UPD42 MOV42 INS44 INS44 INS8 INS39 INS42 INS65 INS43 INS42 INS39 INS42 INS25 INS25 INS25 MOV51 INS41 INS39 INS42 INS65 UPD65 UPD65 INS65 MOV43 INS42 MOV43 INS42 MOV25 INS60 INS60 INS25 INS41 INS66 INS66 INS66 INS66 INS42 INS27 INS8 INS32 INS8 UPD27 MOV27 INS8 UPD42 INS9 INS21 INS66 INS42 INS42 INS66 INS66 INS27 INS5 INS59 INS5 INS59 INS27 INS8 INS8 INS9 UPD42 INS32 INS32 UPD42 INS69 UPD42 INS69 INS69 INS42 INS33 INS41 INS42 UPD42 MOV42 INS53 INS42 INS38 INS41 INS69 INS32 MOV32 INS32 INS41 INS43 INS85 INS42 INS32 INS43 INS85 INS42 INS32 INS40 INS40 INS41 INS24 INS42 INS42 INS42 INS42 INS39 INS43 INS39 INS9 INS14 INS32 INS9 INS43 INS39 UPD42 MOV42 INS9 INS42 UPD42 UPD42 MOV42 INS42 INS9 UPD42 MOV42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 INS9 INS58 INS27 INS37 INS8 INS25 INS27 INS42 INS43 INS45 INS42 INS52 INS11 INS42 UPD42 UPD40 UPD40 INS39 INS59 INS42 INS40 INS42 INS60 INS25 INS27 INS8 INS38 MOV27 INS42 INS43 INS42 INS43 INS42 INS42 INS34 INS39 INS59 INS38 INS8 INS32 INS27 MOV21 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS16 INS42 INS41 UPD42 MOV42 MOV42 INS9 INS32 INS40 INS36 INS27 INS32 INS9 UPD42 MOV42 INS27 INS2 INS33 INS2 UPD42 MOV42 INS2 INS2 INS33 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL40 DEL26 DEL42 DEL32 DEL42 DEL32 DEL32 DEL21 DEL65 DEL65 DEL83 DEL42 DEL33 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL40 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL42 DEL32 DEL21 DEL42 DEL32 DEL42 DEL52 DEL32 DEL21 DEL8 DEL31 DEL65 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL29 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL32 DEL21 DEL32 DEL40 DEL49 DEL10 DEL40 DEL49 DEL40 DEL49 DEL40 DEL49 DEL42 DEL32 DEL21 DEL42 DEL40 DEL32 DEL21 DEL52 DEL32 DEL21 DEL10 DEL40 DEL49 DEL42 DEL40 DEL32 DEL21 DEL42 DEL32 DEL42 DEL52 DEL32 DEL21 DEL42 DEL42 DEL52 DEL32 DEL21 DEL10 DEL40 DEL49 DEL42 DEL42 DEL45 DEL32 DEL21 DEL42 DEL32 DEL42 DEL52 DEL32 DEL21 DEL10 DEL40 DEL49 DEL42 DEL32 DEL42 DEL52 DEL32 DEL21 DEL42 DEL42 DEL52 DEL32 DEL21 DEL10 DEL50 DEL8 DEL31 DEL65 DEL42 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL29 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL32 DEL21 DEL42 DEL32 DEL40 DEL49 DEL40 DEL49 DEL40 DEL49 DEL40 DEL49 DEL40 DEL49 DEL42 DEL42 DEL52 DEL32 DEL21 DEL10 DEL40 DEL49 DEL40 DEL49 DEL42 DEL45 DEL42 DEL32 DEL27 DEL32 DEL21 DEL10 DEL49 DEL42 DEL42 DEL45 DEL42 DEL32 DEL27 DEL32 DEL21 DEL50 DEL8 DEL31 DEL42 DEL42 DEL68 DEL40 DEL27 DEL40 DEL32 DEL21 DEL8 DEL42 DEL40 DEL32 DEL21
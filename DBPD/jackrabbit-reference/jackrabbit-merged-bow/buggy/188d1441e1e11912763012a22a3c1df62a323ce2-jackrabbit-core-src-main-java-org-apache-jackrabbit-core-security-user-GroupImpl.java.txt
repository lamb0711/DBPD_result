JCR-2710: Add support for large number of users in a group 
work in progress

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@984740 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.JcrConstants;
+import org.apache.jackrabbit.commons.flat.BTreeManager;
+import org.apache.jackrabbit.commons.flat.ItemSequence;
+import org.apache.jackrabbit.commons.flat.PropertySequence;
+import org.apache.jackrabbit.commons.flat.Rank;
+import org.apache.jackrabbit.commons.flat.TreeManager;
+import org.apache.jackrabbit.util.Text;
+import javax.jcr.ItemNotFoundException;
+import javax.jcr.Property;
+import javax.jcr.PropertyType;
-import javax.jcr.ItemNotFoundException;
-import javax.jcr.PropertyType;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Comparator;
-import java.util.Set;
-import java.util.ArrayList;
-import java.util.Arrays;
+import java.util.Set;
-        if (authorizable == null || !(authorizable instanceof AuthorizableImpl)) {
+        if (!(authorizable instanceof AuthorizableImpl)) {
+            log.warn("Invalid Authorizable: {}", authorizable);
-            String msg = "Attempt to add a Group as member of itself (" + getID() + ").";
+            String msg = "Attempt to add a group as member of itself (" + getID() + ").";
-        Value[] values;
-        Value toAdd = getSession().getValueFactory().createValue(memberNode, true);
-        NodeImpl node = getNode();
-        if (node.hasProperty(P_MEMBERS)) {
-            Value[] old = node.getProperty(P_MEMBERS).getValues();
-            for (Value v : old) {
-                if (v.equals(toAdd)) {
-                    log.debug("Authorizable " + authImpl + " is already member of " + this);
-                    return false;
-                }
-            }
-
-            values = new Value[old.length + 1];
-            System.arraycopy(old, 0, values, 0, old.length);
-        } else {
-            values = new Value[1];
-        }
-        values[values.length - 1] = toAdd;
-
-        userManager.setProtectedProperty(node, P_MEMBERS, values, PropertyType.WEAKREFERENCE);
-        userManager.getMembershipCache().clear();
-        return true;
+        return getMembershipProvider(getNode()).addMember(authImpl);
+
-            return false;
-        }
-        NodeImpl node = getNode();
-        if (!node.hasProperty(P_MEMBERS)) {
-            log.debug("Group has no members -> cannot remove member " + authorizable.getID());
+            log.warn("Invalid Authorizable: {}", authorizable);
-        Value toRemove = getSession().getValueFactory().createValue(((AuthorizableImpl)authorizable).getNode(), true);
-
-        PropertyImpl property = node.getProperty(P_MEMBERS);
-        List<Value> valList = new ArrayList<Value>(Arrays.asList(property.getValues()));
-
-        if (valList.remove(toRemove)) {
-            try {
-                if (valList.isEmpty()) {
-                    userManager.removeProtectedItem(property, node);
-                } else {
-                    Value[] values = valList.toArray(new Value[valList.size()]);
-                    userManager.setProtectedProperty(node, P_MEMBERS, values);
-                }
-                userManager.getMembershipCache().clear();
-                return true;
-            } catch (RepositoryException e) {
-                // modification failed -> revert all pending changes.
-                node.refresh(false);
-                throw e;
-            }
-        } else {
-            // nothing changed
-            log.debug("Authorizable " + authorizable.getID() + " was not member of " + getID());
-            return false;
-        }
+        return getMembershipProvider(getNode()).removeMember((AuthorizableImpl) authorizable);
+
+    private MembershipProvider getMembershipProvider(NodeImpl node) throws RepositoryException {
+        MembershipProvider msp;
+        if (userManager.getGroupMembershipSplitSize() > 0) {
+            if (node.hasNode(N_MEMBERS) || !node.hasProperty(P_MEMBERS)) {
+                msp = new NodeBasedMembershipProvider(node);
+            }
+            else {
+                msp = new PropertyBasedMembershipProvider(node);
+            }
+        }
+        else {
+            if (node.hasProperty(P_MEMBERS) || !node.hasNode(N_MEMBERS)) {
+                msp = new PropertyBasedMembershipProvider(node);
+            }
+            else {
+                msp = new NodeBasedMembershipProvider(node);
+            }
+        }
+
+        if (node.hasProperty(P_MEMBERS) && node.hasNode(N_MEMBERS)) {
+            log.warn("Found members node and members property on node {}. Ignoring {} members", node,
+                    userManager.getGroupMembershipSplitSize() > 0 ? "property" : "node");
+        }
+
+        return msp;
+    }
+
-        Collection<Authorizable> members = new HashSet<Authorizable>();
-        if (getNode().hasProperty(P_MEMBERS)) {
-            Value[] vs = getNode().getProperty(P_MEMBERS).getValues();
-            for (Value v : vs) {
-                try {
-                    NodeImpl n = (NodeImpl) getSession().getNodeByIdentifier(v.getString());
-                    if (n.isNodeType(NT_REP_GROUP)) {
-                        if (type != UserManager.SEARCH_TYPE_USER) {
-                            Group group = userManager.createGroup(n);
-                            // only retrieve indirect group-members if the group is not
-                            // yet present (detected eventual circular membership).
-                            if (members.add(group) && includeIndirect) {
-                                members.addAll(((GroupImpl) group).getMembers(true, type));
-                            }
-                        } // else: groups are ignored
-                    } else if (n.isNodeType(NT_REP_USER)) {
-                        if (type != UserManager.SEARCH_TYPE_GROUP) {
-                            User user = userManager.createUser(n);
-                            members.add(user);
-                        }
-                    } else {
-                        // reference does point to an authorizable node -> not a
-                        // member of this group -> ignore
-                        log.debug("Group member entry with invalid node type " + n.getPrimaryNodeType().getName() + " -> Not included in member set.");
-                    }
-                } catch (ItemNotFoundException e) {
-                    // dangling weak reference -> clean upon next write.
-                    log.debug("Authorizable node referenced by " + getID() + " doesn't exist any more -> Ignored from member list.");
-                }
-            }
-        } // no rep:member property
-        return members;
+        return getMembershipProvider(getNode()).getMembers(includeIndirect, type);
+    private PropertySequence getPropertySequence(Node nMembers) throws RepositoryException {
+        Comparator<String> order = Rank.comparableComparator();
+        int maxChildren = userManager.getGroupMembershipSplitSize();
+        int minChildren = maxChildren/2;
+
+        TreeManager treeManager = new BTreeManager(nMembers, minChildren, maxChildren, order,
+                userManager.isAutoSave());
+
+        treeManager.getIgnoredProperties().addAll(Arrays.asList(
+                JcrConstants.JCR_CREATED,
+                "jcr:createdBy"));
+
+        return ItemSequence.createPropertySequence(treeManager);
+    }
+
+    private void collectMembers(Value memberRef, Collection<Authorizable> members, boolean includeIndirect,
+            int type) throws RepositoryException {
+
+        try {
+            NodeImpl member = (NodeImpl) getSession().getNodeByIdentifier(memberRef.getString());
+            if (member.isNodeType(NT_REP_GROUP)) {
+                if (type != UserManager.SEARCH_TYPE_USER) {
+                    Group group = userManager.createGroup(member);
+                    // only retrieve indirect group-members if the group is not
+                    // yet present (detected eventual circular membership).
+                    if (members.add(group) && includeIndirect) {
+                        members.addAll(((GroupImpl) group).getMembers(true, type));
+                    }
+                } // else: groups are ignored
+            } else if (member.isNodeType(NT_REP_USER)) {
+                if (type != UserManager.SEARCH_TYPE_GROUP) {
+                    User user = userManager.createUser(member);
+                    members.add(user);
+                }
+            } else {
+                // reference does point to an authorizable node -> not a
+                // member of this group -> ignore
+                log.debug("Group member entry with invalid node type {} -> " +
+                        "Not included in member set.", member.getPrimaryNodeType().getName());
+            }
+        } catch (ItemNotFoundException e) {
+            // dangling weak reference -> clean upon next write.
+            log.debug("Authorizable node referenced by {} doesn't exist any more -> " +
+            "Ignored from member list.", getID());
+        }
+    }
+
-    /**
-     *
-     */
+
+
+    private interface MembershipProvider {
+        boolean addMember(AuthorizableImpl authorizable) throws RepositoryException;
+        boolean removeMember(AuthorizableImpl authorizable) throws RepositoryException;
+        Collection<Authorizable> getMembers(boolean includeIndirect, int type) throws RepositoryException;
+    }
+
+    private class PropertyBasedMembershipProvider implements MembershipProvider {
+        private final NodeImpl node;
+
+        public PropertyBasedMembershipProvider(NodeImpl node) {
+            super();
+            this.node = node;
+        }
+
+        public boolean addMember(AuthorizableImpl authorizable) throws RepositoryException {
+            Node memberNode = authorizable.getNode();
+
+            Value[] values;
+            Value toAdd = getSession().getValueFactory().createValue(memberNode, true);
+            if (node.hasProperty(P_MEMBERS)) {
+                Value[] old = node.getProperty(P_MEMBERS).getValues();
+                for (Value v : old) {
+                    if (v.equals(toAdd)) {
+                        log.debug("Authorizable {} is already member of {}", authorizable, this);
+                        return false;
+                    }
+                }
+
+                values = new Value[old.length + 1];
+                System.arraycopy(old, 0, values, 0, old.length);
+            } else {
+                values = new Value[1];
+            }
+            values[values.length - 1] = toAdd;
+
+            userManager.setProtectedProperty(node, P_MEMBERS, values, PropertyType.WEAKREFERENCE);
+            userManager.getMembershipCache().clear();
+            return true;
+        }
+
+        public boolean removeMember(AuthorizableImpl authorizable) throws RepositoryException {
+            if (!node.hasProperty(P_MEMBERS)) {
+                log.debug("Group has no members -> cannot remove member {}", authorizable.getID());
+                return false;
+            }
+
+            Value toRemove = getSession().getValueFactory().createValue((authorizable).getNode(), true);
+
+            PropertyImpl property = node.getProperty(P_MEMBERS);
+            List<Value> valList = new ArrayList<Value>(Arrays.asList(property.getValues()));
+
+            if (valList.remove(toRemove)) {
+                try {
+                    if (valList.isEmpty()) {
+                        userManager.removeProtectedItem(property, node);
+                    } else {
+                        Value[] values = valList.toArray(new Value[valList.size()]);
+                        userManager.setProtectedProperty(node, P_MEMBERS, values);
+                    }
+                    userManager.getMembershipCache().clear();
+                    return true;
+                } catch (RepositoryException e) {
+                    // modification failed -> revert all pending changes.
+                    node.refresh(false);
+                    throw e;
+                }
+            } else {
+                // nothing changed
+                log.debug("Authorizable {} was not member of {}", authorizable.getID(), getID());
+                return false;
+            }
+        }
+
+        public Collection<Authorizable> getMembers(boolean includeIndirect, int type) throws RepositoryException {
+            Collection<Authorizable> members = new HashSet<Authorizable>();
+            if (node.hasProperty(P_MEMBERS)) {
+                for (Value member : node.getProperty(P_MEMBERS).getValues()) {
+                    collectMembers(member, members, includeIndirect, type);
+                }
+            }
+            return members;
+        }
+
+    }
+
+    private class NodeBasedMembershipProvider implements MembershipProvider {
+        private final NodeImpl node;
+
+        public NodeBasedMembershipProvider(NodeImpl node) {
+            super();
+            this.node = node;
+        }
+
+        public boolean addMember(AuthorizableImpl authorizable) throws RepositoryException {
+            NodeImpl nMembers = (node.hasNode(N_MEMBERS)
+                    ? node.getNode(N_MEMBERS)
+                    : userManager.addProtectedNode(node, N_MEMBERS, NT_REP_MEMBERS));
+
+            try {
+                PropertySequence properties = getPropertySequence(nMembers);
+                String propName = Text.escapeIllegalJcrChars(authorizable.getID());
+                if (properties.hasItem(propName)) {
+                    log.debug("Authorizable {} is already member of {}", authorizable, this);
+                    return false;
+                }
+                else {
+                    Value newMember = getSession().getValueFactory().createValue(authorizable.getNode(), true);
+                    properties.addProperty(propName, newMember);
+                }
+
+                if (userManager.isAutoSave()) {
+                    node.save();
+                }
+                userManager.getMembershipCache().clear();
+                return true;
+            }
+            catch (RepositoryException e) {
+                log.debug("addMember failed. Reverting changes", e);
+                nMembers.refresh(false);
+                throw e;
+            }
+        }
+
+        public boolean removeMember(AuthorizableImpl authorizable) throws RepositoryException {
+            if (!node.hasNode(N_MEMBERS)) {
+                log.debug("Group has no members -> cannot remove member {}", authorizable.getID());
+                return false;
+            }
+
+            NodeImpl nMembers = node.getNode(N_MEMBERS);
+            try {
+                PropertySequence properties = getPropertySequence(nMembers);
+                String propName = Text.escapeIllegalJcrChars(authorizable.getID());
+                if (properties.hasItem(propName)) {
+                    properties.removeProperty(propName);
+                    if (!properties.iterator().hasNext()) {
+                        userManager.removeProtectedItem(nMembers, node);
+                    }
+                }
+                else {
+                    log.debug("Authorizable {} was not member of {}", authorizable.getID(), getID());
+                    return false;
+                }
+
+                if (userManager.isAutoSave()) {
+                    node.save();
+                }
+                userManager.getMembershipCache().clear();
+                return true;
+            }
+            catch (RepositoryException e) {
+                log.debug("removeMember failed. Reverting changes", e);
+                nMembers.refresh(false);
+                throw e;
+            }
+        }
+
+        public Collection<Authorizable> getMembers(boolean includeIndirect, int type)
+                throws RepositoryException {
+
+            Collection<Authorizable> members = new HashSet<Authorizable>();
+            if (node.hasNode(N_MEMBERS)) {
+                for (Property member : getPropertySequence(node.getNode(N_MEMBERS))) {
+                    collectMembers(member.getValue(), members, includeIndirect, type);
+                }
+            }
+
+            return members;
+        }
+
+    }

MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV31 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS31 INS31 INS31 INS31 INS31 INS55 INS55 INS55 MOV29 INS83 INS39 INS42 MOV44 INS43 INS8 MOV29 INS83 INS39 INS42 MOV44 INS43 INS8 INS83 INS43 INS42 INS44 INS43 INS8 MOV29 INS83 MOV74 INS42 INS44 INS44 INS43 INS8 INS83 INS43 INS42 INS44 INS43 INS8 INS39 UPD42 INS44 INS44 MOV8 INS83 INS42 INS31 INS31 INS31 INS83 INS42 INS43 INS23 INS31 MOV31 MOV31 INS31 INS83 INS42 INS43 INS23 INS31 INS31 INS31 INS31 INS42 INS25 MOV60 MOV60 MOV25 MOV25 INS41 INS42 MOV25 INS41 INS42 MOV43 INS42 INS42 INS60 INS25 INS25 INS41 INS39 INS42 INS39 INS42 INS42 INS41 INS42 INS43 INS42 INS42 INS60 INS60 INS60 INS60 INS21 INS41 MOV43 INS42 INS74 INS42 INS39 INS42 INS44 INS43 INS39 INS42 INS44 INS43 INS74 INS42 INS44 INS44 INS43 INS42 INS83 INS83 INS43 INS59 INS83 INS42 INS44 INS8 INS44 INS44 INS83 INS74 INS42 INS44 INS44 INS43 INS8 INS42 INS83 INS83 INS43 INS59 INS83 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS43 INS8 INS83 INS74 INS42 INS44 INS44 INS43 INS8 MOV38 INS8 INS32 MOV32 INS43 INS59 INS27 INS8 INS8 INS27 INS8 INS42 INS32 INS42 INS74 INS59 INS39 INS59 INS39 INS59 INS43 INS59 INS32 INS32 INS43 INS43 INS43 INS42 INS42 INS43 INS42 INS42 INS43 INS43 INS39 INS42 INS39 INS42 INS42 INS42 INS42 MOV43 INS42 INS46 INS21 INS43 INS42 INS60 INS43 INS42 INS43 INS43 INS39 INS42 INS39 INS42 INS42 MOV60 INS25 MOV41 INS42 INS42 INS43 INS42 INS46 INS21 INS43 INS42 INS42 INS60 INS54 INS43 INS42 INS42 INS25 INS60 INS54 INS43 INS43 INS39 INS42 INS39 INS42 INS42 INS60 INS25 INS41 INS21 MOV41 INS32 INS42 INS42 INS21 MOV41 INS32 INS42 MOV11 INS42 INS42 INS32 INS34 INS25 INS25 INS32 INS32 INS21 INS32 INS42 INS42 INS42 INS43 INS43 INS42 INS32 INS42 INS32 INS42 INS27 INS42 INS42 INS14 INS32 INS42 INS32 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS7 INS42 INS43 MOV59 INS42 INS42 INS42 INS32 INS8 INS42 INS7 INS42 INS43 INS59 INS8 INS12 INS42 INS38 INS8 INS43 INS59 INS8 INS12 INS42 INS42 INS74 INS59 INS32 INS8 INS42 INS32 INS42 MOV32 INS32 INS42 MOV32 INS42 INS42 INS27 INS8 INS8 INS27 INS8 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS43 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS40 INS45 INS22 INS42 INS42 INS42 INS32 MOV41 MOV41 INS42 INS42 INS42 INS70 INS22 INS42 INS42 INS42 INS36 INS60 INS60 INS25 INS25 INS21 INS41 INS44 INS8 INS32 INS21 INS41 INS42 INS42 INS32 INS60 INS60 INS25 INS25 INS21 INS41 INS44 INS8 INS43 INS43 INS42 INS14 INS42 INS42 INS42 INS70 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS42 INS32 INS38 INS21 INS21 INS32 INS38 INS21 INS21 INS42 INS42 INS45 INS42 INS16 INS42 INS42 INS42 UPD42 UPD42 INS52 INS42 INS42 INS42 INS32 INS32 INS44 INS32 INS8 INS52 INS42 INS16 INS43 INS59 INS43 INS59 INS32 INS8 INS8 INS32 INS8 INS32 INS9 INS43 INS42 INS21 INS21 INS53 INS42 INS42 INS42 INS32 INS9 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS32 INS8 INS8 INS32 INS8 INS32 INS9 INS43 INS42 INS21 INS21 INS53 INS42 INS42 INS74 INS44 INS32 INS8 UPD45 INS42 INS42 INS42 INS32 INS7 INS7 INS42 INS42 INS42 INS32 INS7 INS7 INS27 INS45 INS45 UPD42 MOV32 INS42 INS42 INS45 INS32 INS36 INS42 INS45 INS32 MOV32 INS43 INS42 INS32 INS42 INS21 INS32 INS32 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS21 INS41 INS60 INS21 INS42 INS42 INS21 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS32 INS42 INS42 MOV32 INS42 INS42 INS42 INS21 INS25 INS21 INS41 INS42 INS42 INS21 INS32 INS42 INS42 INS32 INS32 INS42 INS43 INS43 INS43 INS42 INS42 INS32 INS21 INS42 INS42 INS42 INS42 INS14 INS42 INS14 INS42 INS42 INS42 INS42 INS14 INS42 INS14 INS32 INS34 UPD45 UPD45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS32 INS9 INS43 INS59 INS32 INS32 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS42 UPD42 UPD42 MOV32 INS32 INS38 INS8 INS32 INS9 INS32 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS42 UPD42 INS27 INS32 MOV41 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS52 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS21 INS42 INS42 INS45 INS32 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD45 MOV45 INS45 MOV32 MOV42 INS32 INS42 INS32 INS9 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS45 INS42 INS52 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 DEL36 DEL32 DEL45 DEL27 DEL42 DEL42 DEL32 DEL85 DEL5 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL43 DEL42 DEL44 DEL42 DEL70 DEL8 DEL25 DEL8 DEL29 DEL42 DEL42 DEL33 DEL27 DEL27 DEL8 DEL25 DEL60 DEL45 DEL42 DEL45 DEL52 DEL27 DEL42 DEL59 DEL60 DEL45 DEL45 DEL27 DEL45 DEL27
Simplify SearchManager and use SharedItemStateManager instead of SessionItemStateManager of system session.

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@156426 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.state.ItemStateManager;
+import java.util.List;
+import java.util.ArrayList;
- *
- * todo The SearchManager currently uses the system session to obtain an
- * ItemStateManager from where it reads persistent ItemStates. This is kind
- * of nasty, because the system session it is possible to change content through
- * the system session as well.
- * After switch to version 0.16 there is a shared ItemStateManager which
- * represents the persistent view of item states.
-     * HierarchyManager for path resolution
+     * The shared item state manager instance for the workspace.
-    private final HierarchyManager hmgr;
-
-    /**
-     * Session for accessing Nodes
-     */
-    private final SessionImpl session;
+    private final ItemStateManager itemMgr;
-    public SearchManager(SessionImpl session, SearchConfig config, NodeTypeRegistry ntReg)
-            throws RepositoryException {
-        this.session = session;
-        this.hmgr = session.getHierarchyManager();
+    /**
+     * Creates a new <code>SearchManager</code>.
+     * @param session the system session.
+     * @param config the search configuration.
+     * @param ntReg the node type registry.
+     * @param itemMgr the shared item state manager.
+     * @throws RepositoryException
+     */
+    public SearchManager(SessionImpl session,
+                         SearchConfig config,
+                         NodeTypeRegistry ntReg,
+                         ItemStateManager itemMgr) throws RepositoryException {
-
+        this.itemMgr = itemMgr;
-     * @param path the path of the node.
-    public void addNode(NodeState node, Path path)
+    public void addNode(NodeState node)
-        if (log.isDebugEnabled()) {
-            log.debug("add node to index: " + path);
-        }
-     * @param path the path of the node to delete.
-    public void deleteNode(Path path, String uuid) throws IOException {
-        if (log.isDebugEnabled()) {
-            log.debug("remove node from index: " + path.toString());
-        }
+    public void deleteNode(String uuid) throws IOException {
-        Set modified = new HashSet();
-        Set added = new HashSet();
-        // remember nodes we have to index at the end.
-        Set pendingNodes = new HashSet();
+        // nodes that need to be removed from the index.
+        Set removedNodes = new HashSet();
+        // nodes that need to be added to the index.
+        Set addedNodes = new HashSet();
+        // property events
+        List propEvents = new ArrayList();
-        // delete removed and modified nodes from index
-            try {
-                EventImpl e = (EventImpl) events.nextEvent();
-                long type = e.getType();
-                if (type == Event.NODE_ADDED) {
-
-                    // @todo use UUIDs for pending nodes?
-                    Path path = Path.create(e.getPath(),
-                            session.getNamespaceResolver(),
-                            true);
-                    pendingNodes.add(path);
-                    added.add(e.getChildUUID());
-                } else if (type == Event.NODE_REMOVED) {
-
-                    Path path = Path.create(e.getPath(),
-                            session.getNamespaceResolver(),
-                            true);
-                    deleteNode(path, e.getChildUUID());
-
-                } else if (type == Event.PROPERTY_ADDED
-                        || type == Event.PROPERTY_CHANGED
-                        || type == Event.PROPERTY_REMOVED) {
-
-                    Path path = Path.create(e.getPath(),
-                            session.getNamespaceResolver(),
-                            true).getAncestor(1);
-
-                    if (type == Event.PROPERTY_ADDED) {
-                        // do not delete and re-add if associated node got added too
-                        if (!added.contains(e.getParentUUID())) {
-                            deleteNode(path, e.getParentUUID());
-                            modified.add(e.getParentUUID());
-                            pendingNodes.add(path);
-                        }
-                    } else {
-                        if (!modified.contains(e.getParentUUID())) {
-                            deleteNode(path, e.getParentUUID());
-                            modified.add(e.getParentUUID());
-                            pendingNodes.add(path);
-                        } else {
-                            // already deleted
-                        }
-                    }
-
-                }
-            } catch (MalformedPathException e) {
-                log.error("error indexing node.", e);
-            } catch (RepositoryException e) {
-                log.error("error indexing node.", e);
-            } catch (IOException e) {
-                log.error("error indexing node.", e);
+            EventImpl e = (EventImpl) events.nextEvent();
+            long type = e.getType();
+            if (type == Event.NODE_ADDED) {
+                addedNodes.add(e.getChildUUID());
+            } else if (type == Event.NODE_REMOVED) {
+                removedNodes.add(e.getChildUUID());
+            } else {
+                propEvents.add(e);
-        for (Iterator it = pendingNodes.iterator(); it.hasNext();) {
+        // sort out property events
+        for (int i = 0; i < propEvents.size(); i++) {
+            EventImpl event = (EventImpl) propEvents.get(i);
+            String nodeUUID = event.getParentUUID();
+            if (event.getType() == Event.PROPERTY_ADDED) {
+                if (addedNodes.add(nodeUUID)) {
+                    // only property added
+                    // need to re-index
+                    removedNodes.add(nodeUUID);
+                } else {
+                    // the node where this prop belongs to is also new
+                }
+            } else if (event.getType() == Event.PROPERTY_CHANGED) {
+                // need to re-index
+                addedNodes.add(nodeUUID);
+                removedNodes.add(nodeUUID);
+            } else {
+                // property removed event is only generated when node still exists
+                addedNodes.add(nodeUUID);
+                removedNodes.add(nodeUUID);
+            }
+        }
+
+        for (Iterator it = removedNodes.iterator(); it.hasNext();) {
-                Path path = (Path) it.next();
-                ItemId id = hmgr.resolvePath(path);
-                addNode((NodeState) session.getItemStateManager().getItemState(id), path);
-            } catch (ItemStateException e) {
-                log.error("error indexing node.", e);
-            } catch (RepositoryException e) {
-                log.error("error indexing node.", e);
+                deleteNode((String) it.next());
-                log.error("error indexing node.", e);
+                log.error("Error deleting node from index.", e);
+            }
+        }
+        for (Iterator it = addedNodes.iterator(); it.hasNext();) {
+            try {
+                addNode((NodeState) itemMgr.getItemState(new NodeId((String) it.next())));
+            } catch (ItemStateException e) {
+                log.error("Error indexing node.", e);
+            } catch (RepositoryException e) {
+                log.error("Error indexing node.", e);
+            } catch (IOException e) {
+                log.error("Error indexing node.", e);

INS26 INS26 INS26 INS40 INS40 INS40 UPD43 INS29 INS44 MOV21 INS8 INS8 MOV60 MOV60 UPD42 UPD42 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 MOV21 MOV21 INS61 INS24 INS24 UPD66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 UPD43 MOV32 INS8 INS58 INS27 INS37 INS8 INS58 INS32 INS8 INS42 UPD42 UPD42 UPD42 UPD42 MOV60 MOV60 INS25 INS39 INS59 INS42 INS32 INS42 INS60 INS60 MOV25 INS43 INS59 UPD42 MOV42 INS42 INS54 UPD42 UPD43 MOV27 MOV8 INS25 INS42 INS34 INS42 INS42 UPD43 MOV43 INS59 INS43 INS59 INS25 UPD42 MOV42 INS42 INS32 INS8 MOV12 UPD42 MOV27 INS8 MOV8 UPD42 UPD42 MOV42 INS11 INS42 INS42 INS32 INS32 INS27 INS8 INS8 UPD42 MOV42 UPD42 MOV42 MOV21 MOV44 UPD42 MOV44 MOV44 MOV21 INS43 INS32 INS42 UPD42 MOV42 INS42 INS42 INS32 INS8 INS32 INS40 INS21 MOV21 MOV21 MOV21 UPD42 UPD42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS11 UPD42 UPD42 UPD42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 UPD42 UPD42 MOV42 UPD42 UPD42 MOV42 UPD42 UPD42 INS43 INS32 UPD45 UPD45 UPD45 UPD45 UPD42 UPD42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS14 INS43 MOV11 INS42 UPD43 UPD42 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL42 DEL32 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL9 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL9 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL32 DEL38 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL32 DEL42 DEL32 DEL32 DEL32 DEL38 DEL8 DEL8 DEL25 DEL8 DEL42 DEL45 DEL42 DEL40 DEL27 DEL42 DEL40 DEL27 DEL27 DEL42 DEL40 DEL27 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL9 DEL32 DEL34 DEL32 DEL59 DEL60 DEL8 DEL25 DEL25 DEL25 DEL8 DEL43 DEL42 DEL44 DEL45 DEL32 DEL21 DEL8 DEL12 DEL8 DEL12 DEL54 DEL8 DEL61 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL32 DEL42 DEL42 DEL42 DEL43 DEL42 DEL44
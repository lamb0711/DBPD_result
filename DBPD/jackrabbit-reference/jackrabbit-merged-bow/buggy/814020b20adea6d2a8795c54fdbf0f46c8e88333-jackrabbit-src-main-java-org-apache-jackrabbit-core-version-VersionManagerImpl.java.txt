JCR-455: InternalXAResource.rollback() can be called twice and without prepare
JCR-414: jcr:successors property not persisted correctly within a transaction


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@412995 13f79535-47bb-0310-9956-ffa450edef68

-public class VersionManagerImpl extends AbstractVersionManager
-        /*implements EventStateCollectionFactory*/ {
+public class VersionManagerImpl extends AbstractVersionManager {
-
-        return stateMgr.hasItemState(id);
+        aquireReadLock();
+        try {
+            return stateMgr.hasItemState(id);
+        } finally {
+            releaseReadLock();
+        }
-            InternalVersionItem item = (InternalVersionItem) versionItems.get(id);
-            if (item == null) {
-                if (stateMgr.hasItemState(id)) {
-                    NodeState state = (NodeState) stateMgr.getItemState(id);
-                    NodeStateEx pNode = new NodeStateEx(stateMgr, ntReg, state, null);
-                    NodeId parentId = pNode.getParentId();
-                    InternalVersionItem parent = getItem(parentId);
-                    QName ntName = state.getNodeTypeName();
-                    if (ntName.equals(QName.NT_FROZENNODE)) {
-                        item = new InternalFrozenNodeImpl(this, pNode, parent);
-                    } else if (ntName.equals(QName.NT_VERSIONEDCHILD)) {
-                        item = new InternalFrozenVHImpl(this, pNode, parent);
-                    } else if (ntName.equals(QName.NT_VERSION)) {
-                        item = ((InternalVersionHistory) parent).getVersion(id);
-                    } else if (ntName.equals(QName.NT_VERSIONHISTORY)) {
-                        item = new InternalVersionHistoryImpl(this, pNode);
-                    } else {
-                        return null;
+            synchronized (versionItems) {
+                InternalVersionItem item = (InternalVersionItem) versionItems.get(id);
+                if (item == null) {
+                    if (stateMgr.hasItemState(id)) {
+                        NodeState state = (NodeState) stateMgr.getItemState(id);
+                        NodeStateEx pNode = new NodeStateEx(stateMgr, ntReg, state, null);
+                        NodeId parentId = pNode.getParentId();
+                        InternalVersionItem parent = getItem(parentId);
+                        QName ntName = state.getNodeTypeName();
+                        if (ntName.equals(QName.NT_FROZENNODE)) {
+                            item = new InternalFrozenNodeImpl(this, pNode, parent);
+                        } else if (ntName.equals(QName.NT_VERSIONEDCHILD)) {
+                            item = new InternalFrozenVHImpl(this, pNode, parent);
+                        } else if (ntName.equals(QName.NT_VERSION)) {
+                            item = ((InternalVersionHistory) parent).getVersion(id);
+                        } else if (ntName.equals(QName.NT_VERSIONHISTORY)) {
+                            item = new InternalVersionHistoryImpl(this, pNode);
+                        } else {
+                            return null;
+                        }
+                    versionItems.put(id, item);
-                versionItems.put(id, item);
+                return item;
-            return item;
-     * versions tree were updated. Version manager should flush its own
-     * caches.
+     * versions tree were updated. Version histories are reloaded if possible.
+     * Matching items are removed from the cache.
+     *
-        Iterator iter = items.iterator();
-        while (iter.hasNext()) {
-            itemUpdated((InternalVersionItem) iter.next());
-        }
-    }
-
-    /**
-     * Update internal version item. Version histories are reloaded if possible.
-     * Matching items are removed from the cache.
-     * @param item item updated
-     */
-    private void itemUpdated(InternalVersionItem item) {
+        aquireReadLock();
-            aquireReadLock();
-            InternalVersionItem cached = (InternalVersionItem) versionItems.remove(item.getId());
-            if (cached != null) {
-                if (cached instanceof InternalVersionHistoryImpl) {
-                    InternalVersionHistoryImpl vh = (InternalVersionHistoryImpl) cached;
-                    try {
-                        vh.reload();
-                        versionItems.put(vh.getId(), vh);
-                    } catch (RepositoryException e) {
-                        log.warn("Unable to update version history: " + e.toString());
+            synchronized (versionItems) {
+                Iterator iter = items.iterator();
+                while (iter.hasNext()) {
+                    InternalVersionItem item = (InternalVersionItem) iter.next();
+                    InternalVersionItem cached = (InternalVersionItem) versionItems.remove(item.getId());
+                    if (cached != null) {
+                        if (cached instanceof InternalVersionHistoryImpl) {
+                            InternalVersionHistoryImpl vh = (InternalVersionHistoryImpl) cached;
+                            try {
+                                vh.reload();
+                                versionItems.put(vh.getId(), vh);
+                            } catch (RepositoryException e) {
+                                log.warn("Unable to update version history: " + e.toString());
+                            }
+                        }
+        aquireWriteLock();
+        } finally {
+            releaseWriteLock();
+        aquireReadLock();
+        } finally {
+            releaseReadLock();

INS8 UPD83 UPD42 MOV44 INS21 INS54 MOV65 MOV21 INS21 INS21 INS32 MOV8 INS8 INS66 UPD66 INS8 INS32 INS8 INS32 INS8 INS42 INS21 INS51 INS51 INS42 INS21 INS42 INS21 INS32 INS42 INS8 INS42 INS8 INS32 INS32 INS42 MOV60 MOV25 MOV41 MOV60 INS61 INS42 INS42 MOV32 MOV8 INS60 INS43 INS59 INS42 INS42 MOV11 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL32 DEL21 DEL8 DEL61 DEL8 DEL31 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL44
JCR-3803 - Local cache contention lead to performance degradation
Patch from Shashank Gupta

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1621913 13f79535-47bb-0310-9956-ffa450edef68

-     * The maximum size of cache in bytes.
-     */
-    private long maxSize;
-
-    /**
-     * @param maxSize maximum size of cache.
+     * @param maxSizeInBytes maximum size of cache.
-     * That is if current size exceed (cachePurgeTrigFactor * maxSize), the
+     * That is if current size exceed (cachePurgeTrigFactor * maxSizeInBytes), the
-     * just less (cachePurgeResizeFactor * maxSize).
+     * just less (cachePurgeResizeFactor * maxSizeInBytes).
-     * @throws RepositoryException
+     * @throws IOException
+     * @throws java.lang.ClassNotFoundException
-    public LocalCache(String path, String tmpPath, long size, double cachePurgeTrigFactor,
+    public LocalCache(String path, String tmpPath, long maxSizeInBytes, double cachePurgeTrigFactor,
-        this.maxSize = size;
-                (cachePurgeTrigFactor * size), (cachePurgeResizeFactor * size) });
-        cache = new LRUCache(size, cachePurgeTrigFactor, cachePurgeResizeFactor);
+                (cachePurgeTrigFactor * maxSizeInBytes), (cachePurgeResizeFactor * maxSizeInBytes) });
+        cache = new LRUCache(maxSizeInBytes, cachePurgeTrigFactor, cachePurgeResizeFactor);
-        synchronized (this) {
-            if (!f.exists() || isInPurgeMode()) {
-                OutputStream out = null;
-                File transFile = null;
-                try {
-                    TransientFileFactory tff = TransientFileFactory.getInstance();
-                    transFile = tff.createTransientFile("s3-", "tmp", tmp);
-                    out = new BufferedOutputStream(new FileOutputStream(transFile));
-                    length = IOUtils.copyLarge(in, out);
-                } finally {
-                    IOUtils.closeQuietly(out);
-                }
-                // rename the file to local fs cache
-                if (canAdmitFile(length)
-                    && (f.getParentFile().exists() || f.getParentFile().mkdirs())
-                    && transFile.renameTo(f) && f.exists()) {
-                    if (transFile.exists() && transFile.delete()) {
-                        LOG.info("tmp file [{}] not deleted successfully", transFile.getAbsolutePath());
-                    }
-                    transFile = null;
-                    LOG.debug("file [{}] added to local cache.", fileName);
-                    cache.put(fileName, f.length());
-                } else {
-                    f = transFile;
-                }
-            } else {
-                // f.exists and not in purge mode
-                f.setLastModified(System.currentTimeMillis());
-                cache.put(fileName, f.length());
+        if (!f.exists() || isInPurgeMode()) {
+            OutputStream out = null;
+            File transFile = null;
+            try {
+                TransientFileFactory tff = TransientFileFactory.getInstance();
+                transFile = tff.createTransientFile("s3-", "tmp", tmp);
+                out = new BufferedOutputStream(new FileOutputStream(transFile));
+                length = IOUtils.copyLarge(in, out);
+            } finally {
+                IOUtils.closeQuietly(out);
-            cache.tryPurge();
-            return new LazyFileInputStream(f);
+            // rename the file to local fs cache
+            if (canAdmitFile(length)
+                && (f.getParentFile().exists() || f.getParentFile().mkdirs())
+                && transFile.renameTo(f) && f.exists()) {
+                if (transFile.exists() && transFile.delete()) {
+                    LOG.info("tmp file [{}] not deleted successfully",
+                        transFile.getAbsolutePath());
+                }
+                transFile = null;
+                LOG.debug("file [{}] added to local cache.", fileName);
+                cache.put(fileName, f.length());
+            } else {
+                f = transFile;
+            }
+        } else {
+            // f.exists and not in purge mode
+            f.setLastModified(System.currentTimeMillis());
+            cache.put(fileName, f.length());
+        cache.tryPurge();
+        return new LazyFileInputStream(f);
-     * @throws IOException
-    public synchronized File store(String fileName, final File src) {
+    public File store(String fileName, final File src) {
-     * {@link AsyncUploadResult#setAsyncUpload(boolean)} to true.
+     * {@link AsyncUploadCacheResult#setAsyncUpload(boolean)} to true.
-     *         {@link AsyncUploadResult#setAsyncUpload(boolean)} to true, if
+     *         {@link AsyncUploadCacheResult#setAsyncUpload(boolean)} to true, if
-    public synchronized AsyncUploadCacheResult store(String fileName, File src, boolean tryForAsyncUpload) throws IOException {
+    public AsyncUploadCacheResult store(String fileName, File src, boolean tryForAsyncUpload) throws IOException {
-    public synchronized File getFileIfStored(String fileName) throws IOException {
+    public File getFileIfStored(String fileName) throws IOException {
-    public synchronized void delete(String fileName) {
+    public void delete(String fileName) {
-    public synchronized Long getFileLength(String fileName) {
+    public Long getFileLength(String fileName) {
-    private synchronized boolean canAdmitFile(final long length) {
+    private boolean canAdmitFile(final long length) {

MOV8 MOV65 INS65 UPD42 MOV21 MOV60 MOV60 UPD42 UPD66 UPD66 INS40 UPD42 UPD42 UPD42 UPD42 UPD42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL59 DEL23 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL51 DEL8 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83
JCR-3729 - S3 Datastore optimizations


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1577127 13f79535-47bb-0310-9956-ffa450edef68

+    
+    private AsyncUploadCache asyncUploadCache;
+     * @param asyncUploadCache {@link AsyncUploadCache}
-    public LocalCache(final String path, final String tmpPath,
-            final long maxSize, final double cachePurgeTrigFactor,
-            final double cachePurgeResizeFactor) throws RepositoryException {
-        this.maxSize = maxSize;
+    public LocalCache(String path, String tmpPath, long size, double cachePurgeTrigFactor,
+            double cachePurgeResizeFactor, AsyncUploadCache asyncUploadCache) throws IOException,
+            ClassNotFoundException {
+        this.maxSize = size;
-        cache = new LRUCache(maxSize, cachePurgeTrigFactor,
-            cachePurgeResizeFactor);
-        ArrayList<File> allFiles = new ArrayList<File>();
+        LOG.info("cachePurgeTrigFactor = " + cachePurgeTrigFactor + ", cachePurgeResizeFactor = " + cachePurgeResizeFactor
+            + ", cachePurgeTrigFactorSize = " + (cachePurgeTrigFactor * size) + ", cachePurgeResizeFactor = "
+            + (cachePurgeResizeFactor * size));
+        cache = new LRUCache(size, cachePurgeTrigFactor, cachePurgeResizeFactor);
+        this.asyncUploadCache = asyncUploadCache;
-        Iterator<File> it = FileUtils.iterateFiles(directory, null, true);
-        while (it.hasNext()) {
-            File f = it.next();
-            allFiles.add(f);
-        }
-        Collections.sort(allFiles, new Comparator<File>() {
-            @Override
-            public int compare(final File o1, final File o2) {
-                long l1 = o1.lastModified(), l2 = o2.lastModified();
-                return l1 < l2 ? -1 : l1 > l2 ? 1 : 0;
-            }
-        });
-        String dataStorePath = directory.getAbsolutePath();
-        long time = System.currentTimeMillis();
-        int count = 0;
-        int deletecount = 0;
-        for (File f : allFiles) {
-            if (f.exists()) {
-                long length = f.length();
-                String name = f.getPath();
-                if (name.startsWith(dataStorePath)) {
-                    name = name.substring(dataStorePath.length());
-                }
-                // convert to java path format
-                name = name.replace("\\", "/");
-                if (name.startsWith("/") || name.startsWith("\\")) {
-                    name = name.substring(1);
-                }
-                if ((cache.currentSizeInBytes + length) < cache.maxSizeInBytes) {
-                    count++;
-                    cache.put(name, length);
-                } else {
-                    if (tryDelete(name)) {
-                        deletecount++;
-                    }
-                }
-                long now = System.currentTimeMillis();
-                if (now > time + 5000) {
-                    LOG.info("Processed {" + (count + deletecount) + "}/{"
-                        + allFiles.size() + "}");
-                    time = now;
-                }
-            }
-        }
-        LOG.info("Cached {" + count + "}/{" + allFiles.size()
-            + "} , currentSizeInBytes = " + cache.currentSizeInBytes);
-        LOG.info("Deleted {" + deletecount + "}/{" + allFiles.size()
-            + "} files .");
+        new Thread(new CacheBuildJob()).start();
-     * @param in the inputstream.
+     * @param in {@link InputStream}
-    public synchronized InputStream store(String fileName, final InputStream in)
+    public InputStream store(String fileName, final InputStream in)
-        if (!f.exists() || isInPurgeMode()) {
-            OutputStream out = null;
-            File transFile = null;
-            try {
-                TransientFileFactory tff = TransientFileFactory.getInstance();
-                transFile = tff.createTransientFile("s3-", "tmp", tmp);
-                out = new BufferedOutputStream(new FileOutputStream(transFile));
-                length = IOUtils.copyLarge(in, out);
-            } finally {
-                IOUtils.closeQuietly(out);
-            }
-            // rename the file to local fs cache
-            if (canAdmitFile(length)
-                && (f.getParentFile().exists() || f.getParentFile().mkdirs())
-                && transFile.renameTo(f) && f.exists()) {
-                if (transFile.exists() && transFile.delete()) {
-                    LOG.warn("tmp file = " + transFile.getAbsolutePath()
-                        + " not deleted successfully");
+        synchronized (this) {
+            if (!f.exists() || isInPurgeMode()) {
+                OutputStream out = null;
+                File transFile = null;
+                try {
+                    TransientFileFactory tff = TransientFileFactory.getInstance();
+                    transFile = tff.createTransientFile("s3-", "tmp", tmp);
+                    out = new BufferedOutputStream(new FileOutputStream(transFile));
+                    length = IOUtils.copyLarge(in, out);
+                } finally {
+                    IOUtils.closeQuietly(out);
-                transFile = null;
-                toBeDeleted.remove(fileName);
-                if (cache.get(fileName) == null) {
+                // rename the file to local fs cache
+                if (canAdmitFile(length)
+                    && (f.getParentFile().exists() || f.getParentFile().mkdirs())
+                    && transFile.renameTo(f) && f.exists()) {
+                    if (transFile.exists() && transFile.delete()) {
+                        LOG.info("tmp file = " + transFile.getAbsolutePath()
+                            + " not deleted successfully");
+                    }
+                    transFile = null;
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug("file [" + fileName + "] added to local cache.");
+                    }
+                } else {
+                    f = transFile;
-                f = transFile;
-            }
-        } else {
-            // f.exists and not in purge mode
-            f.setLastModified(System.currentTimeMillis());
-            toBeDeleted.remove(fileName);
-            if (cache.get(fileName) == null) {
+                // f.exists and not in purge mode
+                f.setLastModified(System.currentTimeMillis());
+            cache.tryPurge();
+            return new LazyFileInputStream(f);
-        cache.tryPurge();
-        return new LazyFileInputStream(f);
-    public synchronized void store(String fileName, final File src)
-            throws IOException {
+    public synchronized File store(String fileName, final File src) {
+        try {
+            return store(fileName, src, false).getFile();
+        } catch (IOException ioe) {
+            LOG.warn("Exception in addding file [" + fileName + "] to local cache.", ioe);
+        }
+        return null;
+    }
+
+    /**
+     * This method add file to {@link LocalCache} and tries that file can be
+     * added to {@link AsyncUploadCache}. If file is added to
+     * {@link AsyncUploadCache} successfully, it sets
+     * {@link AsyncUploadResult#setAsyncUpload(boolean)} to true.
+     *
+     * @param fileName name of the file.
+     * @param src source file.
+     * @param tryForAsyncUpload If true it tries to add fileName to
+     *            {@link AsyncUploadCache}
+     * @return {@link AsyncUploadCacheResult}. This method sets
+     *         {@link AsyncUploadResult#setAsyncUpload(boolean)} to true, if
+     *         fileName is added to {@link AsyncUploadCache} successfully else
+     *         it sets {@link AsyncUploadCacheResult#setAsyncUpload(boolean)} to
+     *         false. {@link AsyncUploadCacheResult#getFile()} contains cached
+     *         file, if it is added to {@link LocalCache} or original file.
+     * @throws IOException
+     */
+    public synchronized AsyncUploadCacheResult store(String fileName, File src, boolean tryForAsyncUpload) throws IOException {
-        if (src.exists() && !dest.exists() && !src.equals(dest)
-            && canAdmitFile(src.length())
-            && (parent.exists() || parent.mkdirs()) && (src.renameTo(dest))) {
-            toBeDeleted.remove(fileName);
-            if (cache.get(fileName) == null) {
-                cache.put(fileName, dest.length());
+        AsyncUploadCacheResult result = new AsyncUploadCacheResult();
+        result.setFile(src);
+        result.setAsyncUpload(false);
+        boolean destExists = false;
+        if ((destExists = dest.exists())
+            || (src.exists() && !dest.exists() && !src.equals(dest) && canAdmitFile(src.length())
+                && (parent.exists() || parent.mkdirs()) && (src.renameTo(dest)))) {
+            if (destExists) {
+                dest.setLastModified(System.currentTimeMillis());
-
-        } else if (dest.exists()) {
-            dest.setLastModified(System.currentTimeMillis());
-            toBeDeleted.remove(fileName);
-            if (cache.get(fileName) == null) {
-                cache.put(fileName, dest.length());
+            cache.put(fileName, dest.length());
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("file [" + fileName + "] added to local cache.");
+            }
+            result.setFile(dest);
+            if (tryForAsyncUpload) {
+                result.setAsyncUpload(asyncUploadCache.add(fileName).canAsyncUpload());
+        return result;
-
+        File file = getFileIfStored(fileName);
+        return file == null ? null : new LazyFileInputStream(file);
+    }
+    public synchronized File getFileIfStored(String fileName) throws IOException {
-        synchronized (this) {
-            if (!f.exists() || isInPurgeMode()) {
-                log("purgeMode true or file doesn't exists: getIfStored returned");
-                return null;
-            }
+        // return file in purge mode = true and file present in asyncUploadCache
+        // as asyncUploadCache's files will be not be deleted in cache purge.
+        if (!f.exists() || (isInPurgeMode() && !asyncUploadCache.hasEntry(fileName, false))) {
+            log("purgeMode true or file doesn't exists: getFileIfStored returned");
+            return null;
+        } else {
+            // touch entry in LRU caches
+            cache.put(fileName, f.length());
-            return new LazyFileInputStream(f);
+            return f;
-    public Long getFileLength(String fileName) {
-        fileName = fileName.replace("\\", "/");
-        File f = getFile(fileName);
-        synchronized (this) {
-            if (!f.exists() || isInPurgeMode()) {
-                log("purgeMode true or file doesn't exists: getFileLength returned");
-                return null;
+    public synchronized Long getFileLength(String fileName) {
+        Long length = null;
+        try {
+            length = cache.get(fileName);
+            if( length == null ) {
+                File f = getFileIfStored(fileName);
+                if (f != null) {
+                    length = f.length();
+                }
-            f.setLastModified(System.currentTimeMillis());
-            return f.length();
+        } catch (IOException ignore) {
+
+        return length;
-        // order is important here
-        boolean value = !isInPurgeMode() && cache.canAdmitFile(length);
+      //order is important here
+        boolean value = !isInPurgeMode() && (cache.canAdmitFile(length));
-            log("cannot admit file of length=" + length
-                + " and currentSizeInBytes=" + cache.currentSizeInBytes);
+            log("cannot admit file of length=" + length + " and currentSizeInBytes=" + cache.currentSizeInBytes);
-        long cachePurgeResize;
+        final long cachePurgeResize;
-        private long cachePurgeTrigSize;
+        final long cachePurgeTrigSize;
-        public LRUCache(final long maxSizeInBytes,
+        LRUCache(final long maxSizeInBytes,
+            try {
+                // not removing file from local cache, if there is in progress
+                // async upload on it.
+                if (asyncUploadCache.hasEntry(fileName, false)) {
+                    LOG.info("AsyncUploadCache upload contains file [" + fileName
+                        + "]. Not removing it from LocalCache.");
+                    return null;
+                }
+            } catch (IOException e) {
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug("error: ", e);
+                }
+                return null;
+            }
-                    log("cache entry { " + fileName + "} with size {" + flength
-                        + "} removed.");
+                    log("cache entry { " + fileName + "} with size {" + flength + "} removed.");
-                    log(" file not exists. cache entry { " + fileName
-                        + "} with size {" + flength + "} removed.");
+                    log(" file not exists. cache entry { " + fileName + "} with size {" + flength + "} removed.");
-        public synchronized Long put(final String key, final Long value) {
-            long flength = value.longValue();
-            currentSizeInBytes += flength;
-            return super.put(key.replace("\\", "/"), value);
+        public synchronized Long put(final String fileName, final Long value) {
+            Long oldValue = cache.get(fileName);
+            if (oldValue == null) {
+                long flength = value.longValue();
+                currentSizeInBytes += flength;
+                return super.put(fileName.replace("\\", "/"), value);
+            }
+           toBeDeleted.remove(fileName);
+           return oldValue;
-                LOG.info("currentSizeInBytes[" + cache.currentSizeInBytes
-                    + "] exceeds (cachePurgeTrigSize)["
-                    + cache.cachePurgeTrigSize + "]");
+                LOG.info("currentSizeInBytes[" + cache.currentSizeInBytes + "] exceeds (cachePurgeTrigSize)[" + cache.cachePurgeTrigSize
+                    + "]");
+            } else {
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug("currentSizeInBytes[" + cache.currentSizeInBytes + "] and  (cachePurgeTrigSize)[" + cache.cachePurgeTrigSize
+                        + "], isInPurgeMode =[" + isInPurgeMode() + "]");
+                }
+    
+    /**
+     * This class implements {@link Runnable} interface to build LRU cache
+     * asynchronously.
+     */
+    private class CacheBuildJob implements Runnable {
+        public void run() {
+            long startTime = System.currentTimeMillis();
+            ArrayList<File> allFiles = new ArrayList<File>();
+            Iterator<File> it = FileUtils.iterateFiles(directory, null, true);
+            while (it.hasNext()) {
+                File f = it.next();
+                allFiles.add(f);
+            }
+            long t1 = System.currentTimeMillis();
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("Time taken to recursive [" + allFiles.size() + "] took [" + ((t1 - startTime) / 1000) + "]sec");
+            }
+            Collections.sort(allFiles, new Comparator<File>() {
+                public int compare(File o1, File o2) {
+                    long l1 = o1.lastModified(), l2 = o2.lastModified();
+                    return l1 < l2 ? -1 : l1 > l2 ? 1 : 0;
+                }
+            });
+            long t2 = System.currentTimeMillis();
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("Time taken to sort [" + allFiles.size() + "] took [" + ((t2 - t1) / 1000) + "]sec");
+            }
+            String dataStorePath = directory.getAbsolutePath();
+            long time = System.currentTimeMillis();
+            int count = 0;
+            for (File f : allFiles) {
+                if (f.exists()) {
+                    count++;
+                    String name = f.getPath();
+                    if (name.startsWith(dataStorePath)) {
+                        name = name.substring(dataStorePath.length());
+                    }
+                    // convert to java path format
+                    name = name.replace("\\", "/");
+                    if (name.startsWith("/") || name.startsWith("\\")) {
+                        name = name.substring(1);
+                    }
+                    store(name, f);
+                    long now = System.currentTimeMillis();
+                    if (now > time + 10000) {
+                        LOG.info("Processed {" + (count) + "}/{" + allFiles.size() + "}");
+                        time = now;
+                    }
+                }
+            }
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("Processed {" + count + "}/{" + allFiles.size() + "} , currentSizeInBytes = " + cache.currentSizeInBytes
+                    + ",  maxSizeInBytes = " + cache.maxSizeInBytes + ",  cache.filecount = " + cache.size());
+            }
+            long t3 = System.currentTimeMillis();
+            LOG.info("Time to build cache of  [" + allFiles.size() + "] took [" + ((t3 - startTime) / 1000) + "]sec");
+        }
+    }
+

INS23 INS31 INS31 INS31 INS31 INS55 INS83 INS43 INS59 MOV29 MOV83 UPD42 MOV42 MOV44 MOV44 INS44 INS44 INS44 INS44 INS43 INS43 INS8 MOV29 INS83 INS83 MOV43 INS42 INS44 MOV44 INS8 INS29 INS43 INS44 INS44 MOV29 INS83 MOV43 INS42 MOV44 MOV43 INS8 INS83 MOV43 UPD42 INS44 INS43 MOV29 INS83 INS83 MOV43 INS42 MOV44 INS8 INS29 INS83 INS42 INS43 MOV31 INS42 INS42 INS65 UPD42 UPD42 INS39 INS42 INS39 INS42 INS39 INS42 INS43 INS42 INS42 INS42 MOV21 MOV21 MOV21 INS21 INS21 INS21 INS21 INS51 INS43 INS42 INS54 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS39 INS42 INS60 INS21 INS21 INS60 INS41 MOV60 INS41 INS43 INS42 INS42 MOV25 INS60 INS54 INS41 INS83 UPD83 INS8 INS65 INS42 INS39 INS42 MOV60 INS42 INS66 INS65 INS42 INS32 INS7 INS7 INS32 UPD66 INS65 INS52 INS8 INS42 INS8 INS12 INS33 INS66 INS65 INS66 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS42 INS42 INS43 INS59 INS32 INS32 INS39 INS59 INS27 INS8 INS42 INS16 INS42 MOV8 INS43 INS59 INS8 INS12 INS42 INS54 UPD42 INS60 INS25 MOV21 INS41 INS66 INS65 INS66 INS66 INS60 INS60 INS25 INS25 INS25 INS60 INS42 UPD42 INS42 INS42 INS27 INS42 INS14 INS22 INS42 INS14 INS42 INS42 MOV25 MOV21 MOV41 INS41 INS44 INS8 INS42 INS42 INS42 INS68 INS42 INS42 INS68 INS42 INS68 INS68 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS9 INS36 INS36 INS25 MOV21 INS25 MOV21 MOV25 UPD42 INS27 INS33 INS14 INS36 MOV21 INS41 INS42 INS42 INS33 MOV21 INS25 INS44 INS8 INS8 INS12 INS43 INS59 INS27 MOV8 INS42 INS8 INS42 INS39 INS59 INS39 INS59 INS32 INS8 UPD39 INS32 INS8 INS32 INS8 INS39 INS59 INS45 INS42 INS45 INS42 INS45 INS36 INS45 INS36 MOV43 INS42 INS42 INS42 INS52 INS42 INS43 INS14 MOV8 INS32 INS43 INS42 INS21 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS43 INS7 MOV27 INS42 INS8 INS32 MOV8 INS42 UPD42 INS42 INS33 INS43 INS42 INS27 INS42 INS7 INS27 INS8 INS43 INS42 INS36 INS25 INS44 INS8 INS42 INS42 MOV32 INS42 INS33 INS25 INS42 INS32 INS42 INS32 INS42 INS42 MOV21 UPD42 INS32 INS42 INS42 INS21 INS42 INS42 MOV21 INS42 INS32 INS27 INS27 INS42 INS43 MOV21 INS32 INS42 INS42 INS32 INS39 INS39 INS39 INS42 INS42 MOV32 MOV21 INS42 INS42 UPD42 UPD42 UPD42 INS42 MOV32 INS38 UPD45 INS42 MOV32 INS42 INS33 INS60 INS25 INS42 MOV32 INS32 INS8 INS43 INS42 INS25 INS41 INS32 INS8 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 UPD45 INS45 INS36 UPD45 INS42 INS42 INS42 INS42 INS42 INS42 MOV42 INS42 INS9 INS42 INS42 INS27 INS42 INS32 INS32 INS43 INS59 INS27 INS8 INS42 INS42 INS42 INS9 INS21 MOV41 INS42 INS32 INS8 INS33 INS42 INS42 INS21 INS42 INS42 INS27 INS42 INS42 INS27 MOV21 MOV21 UPD42 INS27 INS25 INS21 INS45 INS42 INS45 UPD42 UPD42 INS27 INS42 INS42 INS32 INS42 INS42 INS42 INS9 INS42 INS42 INS32 INS42 INS33 INS21 INS32 INS42 INS42 INS21 UPD42 INS32 INS45 MOV32 INS45 INS36 INS45 INS45 INS32 INS45 INS36 INS45 UPD45 INS45 INS40 INS45 INS32 INS36 INS34 INS32 INS8 INS32 INS45 INS42 INS45 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS7 INS42 INS42 INS27 INS32 INS42 INS42 INS27 INS27 INS43 INS43 INS42 INS42 INS27 UPD42 UPD42 INS42 INS42 INS27 INS42 INS42 INS21 MOV42 UPD42 MOV42 MOV42 INS32 UPD42 MOV42 UPD42 MOV42 MOV42 INS42 MOV32 INS45 INS42 INS45 INS42 INS42 INS45 INS42 INS45 INS40 INS45 INS40 INS45 INS32 INS45 INS36 INS34 INS42 INS42 INS36 INS34 UPD34 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS27 UPD42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS32 INS45 INS42 INS45 INS42 INS42 INS42 DEL83 DEL83 DEL83 DEL32 DEL33 DEL27 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL33 DEL27 DEL25 DEL8 DEL39 DEL42 DEL33 DEL27 DEL8 DEL25 DEL33 DEL27 DEL42 DEL32 DEL32 DEL8 DEL25 DEL52 DEL42 DEL43 DEL42 DEL14 DEL41 DEL8 DEL51 DEL42 DEL45 DEL32 DEL42 DEL42 DEL45 DEL45 DEL32 DEL7 DEL21 DEL52 DEL42 DEL42 DEL32 DEL38 DEL42 DEL32 DEL27 DEL8 DEL25 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL32 DEL41 DEL8 DEL51 DEL8 DEL31 DEL83 DEL42 DEL83 DEL39 DEL42 DEL44 DEL83 DEL39 DEL42 DEL44 DEL83 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL14 DEL7 DEL42 DEL78 DEL83 DEL83 DEL34 DEL39 DEL42 DEL59 DEL60 DEL42 DEL40 DEL42 DEL27 DEL36 DEL40 DEL27 DEL8 DEL42 DEL42 DEL32 DEL42 DEL37 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL27 DEL45 DEL42
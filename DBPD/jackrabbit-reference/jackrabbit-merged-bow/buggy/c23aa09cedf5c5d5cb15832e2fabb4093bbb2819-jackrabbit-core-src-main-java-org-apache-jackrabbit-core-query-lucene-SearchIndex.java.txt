JCR-202: Add configuration options for search manager

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@530696 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.state.ItemStateManager;
+import org.apache.jackrabbit.uuid.UUID;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermDocs;
+import org.xml.sax.SAXException;
+import org.w3c.dom.Element;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.ParserConfigurationException;
+import java.util.HashMap;
+import java.util.Map;
+     * The namespace mappings used internally.
+     */
+    private NamespaceMappings nsMappings;
+
+    /**
+     * The path to the indexing configuration file.
+     */
+    private String indexingConfigPath;
+
+    /**
+     * The DOM with the indexing configuration or <code>null</code> if there
+     * is no such configuration.
+     */
+    private Element indexingConfiguration;
+
+    /**
+     * The indexing configuration.
+     */
+    private IndexingConfiguration indexingConfig;
+
+    /**
+     * The indexing configuration class.
+     * Implements {@link IndexingConfiguration}.
+     */
+    private Class indexingConfigurationClass = IndexingConfigurationImpl.class;
+
+    /**
+        indexingConfig = createIndexingConfiguration();
-        NamespaceMappings nsMappings;
+        final Map aggregateRoots = new HashMap();
+        final Set removedNodeIds = new HashSet();
+        final Set addedNodeIds = new HashSet();
-                return ((NodeId) super.next()).getUUID();
+                NodeId nodeId = (NodeId) super.next();
+                removedNodeIds.add(nodeId);
+                return nodeId.getUUID();
+                addedNodeIds.add(state.getNodeId());
+                removedNodeIds.remove(state.getNodeId());
+                retrieveAggregateRoot(state, aggregateRoots);
+
+        // remove any aggregateRoot nodes that are new
+        // and therefore already up-to-date
+        aggregateRoots.keySet().removeAll(addedNodeIds);
+
+        // based on removed NodeIds get affected aggregate root nodes
+        retrieveAggregateRoot(removedNodeIds, aggregateRoots);
+
+        // update aggregates if there are any affected
+        if (aggregateRoots.size() > 0) {
+            index.update(new AbstractIteratorDecorator(
+                    aggregateRoots.keySet().iterator()) {
+                public Object next() {
+                    return ((NodeId) super.next()).getUUID();
+                }
+            }, new AbstractIteratorDecorator(aggregateRoots.values().iterator()) {
+                public Object next() {
+                    NodeState state = (NodeState) super.next();
+                    try {
+                        return createDocument(state, getNamespaceMappings());
+                    } catch (RepositoryException e) {
+                        log.error("Exception while creating document for node: "
+                                + state.getNodeId() + ": " + e.toString());
+                    }
+                    return null;
+                }
+            });
+        }
-        return index.getNamespaceMappings();
+        return nsMappings;
-        return indexer.createDoc();
+        indexer.setIndexingConfiguration(indexingConfig);
+        Document doc = indexer.createDoc();
+        mergeAggregatedNodeIndexes(node, doc);
+        return doc;
+    /**
+     * @return the fulltext indexing configuration or <code>null</code> if there
+     *         is no configuration.
+     */
+    protected IndexingConfiguration createIndexingConfiguration() {
+        Element docElement = getIndexingConfigurationDOM();
+        if (docElement == null) {
+            return null;
+        }
+        try {
+            IndexingConfiguration idxCfg = (IndexingConfiguration)
+                    indexingConfigurationClass.newInstance();
+            idxCfg.init(docElement, getContext());
+            return idxCfg;
+        } catch (Exception e) {
+            log.warn("Exception initializing indexing configuration from: " +
+                    indexingConfigPath, e);
+        }
+        log.warn(indexingConfigPath + " ignored.");
+        return null;
+    }
+
+    /**
+     * Returns the document element of the indexing configuration or
+     * <code>null</code> if there is no indexing configuration.
+     *
+     * @return the indexing configuration or <code>null</code> if there is
+     *         none.
+     */
+    protected Element getIndexingConfigurationDOM() {
+        if (indexingConfiguration != null) {
+            return indexingConfiguration;
+        }
+        if (indexingConfigPath == null) {
+            return null;
+        }
+        File config = new File(indexingConfigPath);
+        if (!config.exists()) {
+            log.warn("File does not exist: " + indexingConfigPath);
+            return null;
+        } else if (!config.canRead()) {
+            log.warn("Cannot read file: " + indexingConfigPath);
+            return null;
+        }
+        try {
+            DocumentBuilderFactory factory =
+                    DocumentBuilderFactory.newInstance();
+            DocumentBuilder builder = factory.newDocumentBuilder();
+            builder.setEntityResolver(new IndexingConfigurationEntityResolver());
+            indexingConfiguration = builder.parse(config).getDocumentElement();
+        } catch (ParserConfigurationException e) {
+            log.warn("Unable to create XML parser", e);
+        } catch (IOException e) {
+            log.warn("Exception parsing " + indexingConfigPath, e);
+        } catch (SAXException e) {
+            log.warn("Exception parsing " + indexingConfigPath, e);
+        }
+        return indexingConfiguration;
+    }
+
+    /**
+     * Merges the fulltext indexed fields of the aggregated node states into
+     * <code>doc</code>.
+     *
+     * @param state the node state on which <code>doc</code> was created.
+     * @param doc the lucene document with index fields from <code>state</code>.
+     */
+    protected void mergeAggregatedNodeIndexes(NodeState state, Document doc) {
+        if (indexingConfig != null) {
+            AggregateRule aggregateRules[] = indexingConfig.getAggregateRules();
+            if (aggregateRules == null) {
+                return;
+            }
+            try {
+                for (int i = 0; i < aggregateRules.length; i++) {
+                    NodeState[] aggregates = aggregateRules[i].getAggregatedNodeStates(state);
+                    if (aggregates == null) {
+                        continue;
+                    }
+                    for (int j = 0; j < aggregates.length; j++) {
+                        Document aDoc = createDocument(aggregates[j],
+                                getNamespaceMappings());
+                        // transfer fields to doc if there are any
+                        Field[] fulltextFields = aDoc.getFields(FieldNames.FULLTEXT);
+                        if (fulltextFields != null) {
+                            for (int k = 0; k < fulltextFields.length; k++) {
+                                doc.add(fulltextFields[k]);
+                            }
+                            doc.add(new Field(FieldNames.AGGREGATED_NODE_UUID,
+                                    aggregates[j].getNodeId().getUUID().toString(),
+                                    Field.Store.NO,
+                                    Field.Index.NO_NORMS));
+                        }
+                    }
+                    // only use first aggregate definition that matches
+                    break;
+                }
+            } catch (Exception e) {
+                // do not fail if aggregate cannot be created
+                log.warn("Exception while building indexing aggregate for " +
+                        "node with UUID: " + state.getNodeId().getUUID(), e);
+            }
+        }
+    }
+
+    /**
+     * Retrieves the root of the indexing aggregate for <code>state</code> and
+     * puts it into <code>map</code>.
+     *
+     * @param state the node state for which we want to retrieve the aggregate
+     *              root.
+     * @param map   aggregate roots are collected in this map. Key=NodeId,
+     *              value=NodeState.
+     */
+    protected void retrieveAggregateRoot(NodeState state, Map map) {
+        if (indexingConfig != null) {
+            AggregateRule aggregateRules[] = indexingConfig.getAggregateRules();
+            if (aggregateRules == null) {
+                return;
+            }
+            try {
+                for (int i = 0; i < aggregateRules.length; i++) {
+                    NodeState root = aggregateRules[i].getAggregateRoot(state);
+                    if (root != null) {
+                        map.put(root.getNodeId(), root);
+                        break;
+                    }
+                }
+            } catch (Exception e) {
+                log.warn("Unable to get aggregate root for " +
+                        state.getNodeId().getUUID(), e);
+            }
+        }
+    }
+
+    /**
+     * Retrieves the root of the indexing aggregate for <code>removedNodeIds</code>
+     * and puts it into <code>map</code>.
+     *
+     * @param removedNodeIds the ids of removed nodes.
+     * @param map            aggregate roots are collected in this map.
+     *                       Key=NodeId, value=NodeState.
+     */
+    protected void retrieveAggregateRoot(Set removedNodeIds, Map map) {
+        if (indexingConfig != null) {
+            AggregateRule aggregateRules[] = indexingConfig.getAggregateRules();
+            if (aggregateRules == null) {
+                return;
+            }
+            int found = 0;
+            long time = System.currentTimeMillis();
+            try {
+                IndexReader reader = index.getIndexReader();
+                try {
+                    Term aggregateUUIDs = new Term(
+                            FieldNames.AGGREGATED_NODE_UUID, "");
+                    TermDocs tDocs = reader.termDocs();
+                    try {
+                        ItemStateManager ism = getContext().getItemStateManager();
+                        for (Iterator it = removedNodeIds.iterator(); it.hasNext(); ) {
+                            NodeId id = (NodeId) it.next();
+                            aggregateUUIDs = aggregateUUIDs.createTerm(
+                                    id.getUUID().toString());
+                            tDocs.seek(aggregateUUIDs);
+                            while (tDocs.next()) {
+                                Document doc = reader.document(tDocs.doc());
+                                String uuid = doc.get(FieldNames.UUID);
+                                NodeId nId = new NodeId(UUID.fromString(uuid));
+                                map.put(nId, ism.getItemState(nId));
+                                found++;
+                            }
+                        }
+                    } finally {
+                        tDocs.close();
+                    }
+                } finally {
+                    reader.close();
+                }
+            } catch (Exception e) {
+                log.warn("Exception while retrieving aggregate roots", e);
+            }
+            time = System.currentTimeMillis() - time;
+            log.debug("Retrieved {} aggregate roots in {} ms.",
+                    new Integer(found), new Long(time));
+        }
+    }
+
+    /**
+     * Sets the path to the indexing configuration file.
+     *
+     * @param path the path to the configuration file.
+     */
+    public void setIndexingConfiguration(String path) {
+        indexingConfigPath = path;
+    }
+
+    /**
+     * @return the path to the indexing configuration file.
+     */
+    public String getIndexingConfiguration() {
+        return indexingConfigPath;
+    }
+
+    /**
+     * Sets the name of the class that implements {@link IndexingConfiguration}.
+     * The default value is <code>org.apache.jackrabbit.core.query.lucene.IndexingConfigurationImpl</code>.
+     *
+     * @param className the name of the class that implements {@link
+     *                  IndexingConfiguration}.
+     */
+    public void setIndexingConfigurationClass(String className) {
+        try {
+            Class clazz = Class.forName(className);
+            if (IndexingConfiguration.class.isAssignableFrom(clazz)) {
+                indexingConfigurationClass = clazz;
+            } else {
+                log.warn("Invalid value for indexingConfigurationClass, {} " +
+                        "does not implement IndexingConfiguration interface.",
+                        className);
+            }
+        } catch (ClassNotFoundException e) {
+            log.warn("Invalid value for indexingConfigurationClass, class {} " +
+                    "not found.", className);
+        }
+    }
+
+    /**
+     * @return the class name of the indexing configuration implementation.
+     */
+    public String getIndexingConfigurationClass() {
+        return indexingConfigurationClass.getName();
+    }
+

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS29 INS83 MOV43 MOV59 INS29 INS83 INS43 INS59 INS29 INS83 INS43 INS59 INS29 INS83 INS43 INS59 INS29 INS83 INS43 INS59 INS29 INS83 INS43 INS42 INS8 INS29 INS83 INS43 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS43 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS43 INS42 INS8 INS65 INS65 INS42 INS42 INS65 INS42 INS42 INS65 INS42 INS42 INS65 INS42 INS42 INS57 INS21 INS60 INS60 INS60 INS21 INS21 INS25 INS21 INS60 INS21 INS65 INS42 INS60 INS25 INS54 INS21 INS41 INS65 INS65 INS42 INS25 INS25 INS60 INS25 INS54 INS41 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS25 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS25 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS25 INS65 INS65 INS43 INS42 INS21 INS65 INS42 INS41 INS65 INS65 INS43 INS42 INS54 INS65 INS42 INS41 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS43 INS7 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS32 INS32 INS27 INS8 INS42 INS32 INS43 INS59 INS32 INS42 INS66 INS66 INS43 INS59 INS27 INS8 INS8 INS12 INS32 INS33 INS66 INS66 INS66 INS66 INS27 INS8 INS27 INS8 INS43 INS59 INS38 INS8 INS25 INS8 INS12 INS12 INS12 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS27 INS8 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS27 INS8 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS27 INS8 INS66 INS42 INS66 INS42 INS7 INS66 INS42 INS66 INS65 INS66 INS66 INS42 INS66 INS65 INS66 INS42 INS8 INS12 INS66 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS14 INS14 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS34 INS21 INS42 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS41 INS60 INS21 INS41 INS44 INS8 INS42 INS42 INS27 INS42 INS33 INS41 INS42 INS33 INS41 INS42 INS42 INS14 INS32 INS21 INS41 INS38 INS8 INS60 INS60 INS21 INS21 INS44 INS8 INS44 INS8 INS44 INS8 INS42 INS33 INS60 INS25 INS54 INS42 INS33 INS60 INS25 INS54 INS42 INS33 INS60 INS25 INS60 INS60 INS54 INS21 INS21 INS42 INS42 INS42 INS42 INS60 INS25 INS44 INS8 INS42 INS42 INS42 INS43 INS43 INS43 INS43 INS42 INS1 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS43 INS59 INS32 INS42 INS43 INS42 INS21 INS42 INS45 INS42 INS33 INS43 INS42 INS42 INS42 INS32 INS33 INS32 INS21 INS41 INS43 INS59 INS43 INS59 INS32 INS7 INS43 INS42 INS21 INS43 INS42 INS21 INS43 INS42 INS21 INS43 INS59 INS27 INS8 INS8 INS12 INS43 INS59 INS27 INS8 INS8 INS12 INS43 INS59 INS27 INS8 INS39 INS59 INS39 INS59 INS8 INS12 INS7 INS32 INS43 INS59 INS32 INS8 INS8 INS43 INS42 INS21 INS42 INS42 INS42 INS42 INS31 INS42 INS42 MOV14 INS14 INS42 INS42 INS11 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS27 INS42 INS42 INS32 INS33 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS85 INS32 INS42 INS33 INS41 INS24 INS44 INS8 INS42 INS42 INS85 INS32 INS42 INS33 INS41 INS24 INS44 INS8 INS42 INS42 INS85 INS32 INS42 INS33 INS41 INS42 INS34 INS42 INS32 INS60 INS54 INS44 INS8 INS42 INS27 INS42 INS42 INS45 INS14 INS14 INS42 INS42 INS32 INS57 INS42 INS42 INS21 INS21 INS42 INS32 INS83 INS43 INS42 INS8 INS32 INS43 INS32 INS1 INS43 INS32 INS42 INS42 INS42 INS27 INS42 INS45 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS58 INS27 INS37 INS8 INS43 INS42 INS21 INS42 INS42 INS58 INS27 INS37 INS8 INS43 INS42 INS21 INS42 INS42 INS42 INS42 INS43 INS59 INS8 INS8 INS43 INS42 INS21 INS32 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS42 INS43 INS7 INS32 INS42 INS42 INS27 INS42 INS42 INS60 INS21 INS41 INS21 INS21 INS21 INS32 INS42 INS42 INS32 INS42 INS31 INS42 INS42 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS45 INS42 INS39 INS59 INS42 INS40 INS42 INS60 INS25 INS24 INS10 INS42 INS32 INS39 INS59 INS42 INS40 INS42 INS60 INS25 INS42 INS32 INS42 INS42 INS32 INS60 INS60 INS54 INS21 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS45 INS45 INS43 INS59 INS32 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS83 INS43 INS42 INS8 INS42 INS34 INS5 INS59 INS27 INS8 INS58 INS27 INS37 INS8 INS42 INS42 INS27 INS42 INS42 INS34 INS43 INS59 INS27 INS8 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS8 INS8 INS32 INS42 INS42 INS45 INS42 INS45 INS45 INS42 INS42 INS11 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS60 INS54 INS41 INS43 INS85 INS42 INS32 INS42 INS33 INS18 INS39 INS59 INS42 INS40 INS42 INS60 INS60 INS25 INS45 INS45 INS32 INS42 INS42 INS32 INS42 INS33 INS21 INS10 INS45 INS32 INS42 INS42 INS14 INS42 INS42 INS32 INS60 INS24 INS21 INS42 INS42 INS43 INS48 INS42 INS42 INS42 INS42 INS43 INS59 INS8 INS12 INS33 INS42 INS2 INS42 INS42 INS42 INS34 INS43 INS59 INS5 INS59 INS27 INS8 INS32 INS42 INS2 INS42 INS42 INS32 INS32 INS42 INS43 INS40 INS45 INS42 INS42 INS43 INS59 INS58 INS32 INS8 INS32 INS42 INS42 INS42 INS42 INS11 INS41 INS44 INS8 INS42 INS42 INS42 INS42 INS32 INS43 INS85 INS42 INS32 INS42 INS33 INS24 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS59 INS42 INS42 INS60 INS21 INS21 INS61 INS42 INS42 INS43 INS48 INS32 INS43 INS42 INS21 INS42 INS2 INS32 INS42 INS42 INS42 INS40 INS58 INS27 INS37 INS8 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS43 INS59 INS7 INS32 INS32 INS8 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS39 INS59 INS42 INS40 INS42 INS21 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS60 INS60 INS60 INS21 INS21 INS42 INS42 INS42 INS27 INS42 INS34 INS32 INS43 INS40 INS32 INS40 INS40 INS43 INS32 INS42 INS42 INS32 INS43 INS59 INS43 INS59 INS43 INS59 INS32 INS37 INS45 INS32 INS45 INS32 INS42 INS42 INS2 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS40 INS43 INS32 INS42 INS42 INS42 INS2 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL60 DEL42 DEL42 DEL42 DEL32
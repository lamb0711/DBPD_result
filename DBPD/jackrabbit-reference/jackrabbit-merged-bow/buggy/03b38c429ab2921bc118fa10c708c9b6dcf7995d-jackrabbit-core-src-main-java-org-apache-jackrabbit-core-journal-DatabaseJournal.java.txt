JCR-1456: Database connection pooling

Merge back all changes from the JCR-1456 sandbox branch.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@886191 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.persistence.bundle.util.ConnectionFactory;
+import org.apache.commons.io.IOUtils;
+import org.apache.jackrabbit.core.util.db.CheckSchemaOperation;
+import org.apache.jackrabbit.core.util.db.ConnectionFactory;
+import org.apache.jackrabbit.core.util.db.ConnectionHelper;
+import org.apache.jackrabbit.core.util.db.DatabaseAware;
+import org.apache.jackrabbit.core.util.db.DbUtility;
+import org.apache.jackrabbit.core.util.db.StreamWrapper;
-import org.apache.jackrabbit.util.Text;
+import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.sql.Connection;
-import java.sql.DatabaseMetaData;
-import java.sql.PreparedStatement;
-import java.sql.Statement;
+import javax.sql.DataSource;
-public class DatabaseJournal extends AbstractJournal {
-
-    /**
-     * Schema object prefix.
-     */
-    private static final String SCHEMA_OBJECT_PREFIX_VARIABLE =
-            "${schemaObjectPrefix}";
-
-    /**
-     * Default DDL script name.
-     */
-    private static final String DEFAULT_DDL_NAME = "default.ddl";
+public class DatabaseJournal extends AbstractJournal implements DatabaseAware {
-     * Default reconnect delay in milliseconds.
-     */
-    private static final long DEFAULT_RECONNECT_DELAY_MS = 10000;
-
-    /**
-     * Reconnect delay in milliseconds, bean property.
+     * DataSource logical name, bean property.
-    private long reconnectDelayMs;
+    private String dataSourceName;
-     * JDBC Connection used.
+     * The connection helper
-    private Connection connection;
-
-    /**
-     * Statement returning all revisions within a range.
-     */
-    private PreparedStatement selectRevisionsStmt;
-
-    /**
-     * Statement updating the global revision.
-     */
-    private PreparedStatement updateGlobalStmt;
-
-    /**
-     * Statement returning the global revision.
-     */
-    private PreparedStatement selectGlobalStmt;
-
-    /**
-     * Statement appending a new record.
-     */
-    private PreparedStatement insertRevisionStmt;
-
-    /**
-     * Statement returning the minimum of the local revisions.
-     */
-    private PreparedStatement selectMinLocalRevisionStmt;
-
-    /**
-     * Statement removing a set of revisions with from the journal table.
-     */
-    private PreparedStatement cleanRevisionStmt;
-
-    /**
-     * Statement returning the local revision of this cluster node.
-     */
-    private PreparedStatement getLocalRevisionStmt;
-
-    /**
-     * Statement for inserting the local revision of this cluster node.
-     */
-    private PreparedStatement insertLocalRevisionStmt;
-
-    /**
-     * Statement for updating the local revision of this cluster node.
-     */
-    private PreparedStatement updateLocalRevisionStmt;
+    private ConnectionHelper conHelper;
-     * Next time in milliseconds to reattempt connecting to the database.
-     */
-    private long reconnectTimeMs;
-
-    /**
-    private boolean janitorEnabled;
+    private boolean janitorEnabled = false;
+
-
+    
-
+    
-     * SQL statement for inserting the local revision of this cluster node.
+     * SQL statement for inserting the local revision of this cluster node. 
-     * SQL statement for updating the local revision of this cluster node.
+     * SQL statement for updating the local revision of this cluster node. 
+     * The repositories {@link ConnectionFactory}.
+     */
+    private ConnectionFactory connectionFactory;
+
+    public DatabaseJournal() {
+        databaseType = "default";
+        schemaObjectPrefix = "";
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void setConnectionFactory(ConnectionFactory connnectionFactory) {
+        this.connectionFactory = connnectionFactory;
+    }
+
+    /**
-        // Provide valid defaults for arguments
-        if (schemaObjectPrefix == null) {
-            schemaObjectPrefix = "";
-        }
-        if (reconnectDelayMs == 0) {
-            reconnectDelayMs = DEFAULT_RECONNECT_DELAY_MS;
-        }
-
-            connection = getConnection();
-            setAutoCommit(connection, true);
+            conHelper = createConnectionHelper(getDataSource());
+
+            // make sure schemaObjectPrefix consists of legal name characters only
+            schemaObjectPrefix = conHelper.prepareDbIdentifier(schemaObjectPrefix);
+
+            // check if schema objects exist and create them if necessary
-                checkSchema();
+                createCheckSchemaOperation().run();
+
-            prepareStatements();
+    private DataSource getDataSource() throws Exception {
+        if (getDataSourceName() == null || "".equals(getDataSourceName())) {
+            return connectionFactory.getDataSource(getDriver(), getUrl(), getUser(), getPassword());
+        } else {
+            return connectionFactory.getDataSource(dataSourceName);
+        }
+    }
+
+    /**
+     * This method is called from the {@link #init(String, NamespaceResolver)} method of this class and
+     * returns a {@link ConnectionHelper} instance which is assigned to the {@code conHelper} field.
+     * Subclasses may override it to return a specialized connection helper.
+     * 
+     * @param dataSrc the {@link DataSource} of this persistence manager
+     * @return a {@link ConnectionHelper}
+     * @throws Exception on error
+     */
+    protected ConnectionHelper createConnectionHelper(DataSource dataSrc) throws Exception {
+        return new ConnectionHelper(dataSrc, false);
+    }
+
+    /**
+     * This method is called from {@link #init(String, NamespaceResolver)} after the
+     * {@link #createConnectionHelper(DataSource)} method, and returns a default {@link CheckSchemaOperation}.
+     * Subclasses can overrride this implementation to get a customized implementation.
+     * 
+     * @return a new {@link CheckSchemaOperation} instance
+     */
+    protected CheckSchemaOperation createCheckSchemaOperation() {
+        InputStream in = DatabaseJournal.class.getResourceAsStream(databaseType + ".ddl");
+        return new CheckSchemaOperation(conHelper, in, schemaObjectPrefix + DEFAULT_JOURNAL_TABLE).addVariableReplacement(
+            CheckSchemaOperation.SCHEMA_OBJECT_PREFIX_VARIABLE, schemaObjectPrefix);
+    }
+
-        if (driver == null) {
+        if (driver == null && dataSourceName == null) {
-        if (url == null) {
+        if (url == null && dataSourceName == null) {
-
+        if (dataSourceName != null) {
+            try {
+                String configuredDatabaseType = connectionFactory.getDataBaseType(dataSourceName);
+                if (DatabaseJournal.class.getResourceAsStream(configuredDatabaseType + ".ddl") != null) {
+                    setDatabaseType(configuredDatabaseType);
+                }
+            } catch (RepositoryException e) {
+                throw new JournalException("failed to get database type", e);
+            }
+        }
-
-        try {
-            Class.forName(driver);
-        } catch (ClassNotFoundException e) {
-            String msg = "Unable to load driver class.";
-            throw new JournalException(msg, e);
-        }
-     * Creates a new database connection. This method is called inside
-     * {@link #init(String, org.apache.jackrabbit.spi.commons.namespace.NamespaceResolver)} or
-     * when a connection has been dropped and must be reacquired. Base
-     * implementation uses <code>java.sql.DriverManager</code> to get the
-     * connection. May be overridden by subclasses.
-     *
-     * @see #init()
-     * @return new connection
-     * @throws JournalException if the driver could not be loaded
-     * @throws SQLException if the connection could not be established
-     */
-    protected Connection getConnection() throws SQLException, JournalException {
-        try {
-            return ConnectionFactory.getConnection(driver, url, user, password);
-        } catch (RepositoryException e) {
-            String msg = "Unable to load driver class.";
-            throw new JournalException(msg, e);
-        }
-    }
-
-    /**
-    public RecordIterator getRecords(long startRevision)
-            throws JournalException {
-
+    public RecordIterator getRecords(long startRevision) throws JournalException {
-            checkConnection();
-
-            selectRevisionsStmt.clearParameters();
-            selectRevisionsStmt.clearWarnings();
-            selectRevisionsStmt.setLong(1, startRevision);
-            selectRevisionsStmt.execute();
-
-            return new DatabaseRecordIterator(
-                    selectRevisionsStmt.getResultSet(), getResolver(), getNamePathResolver());
+            return new DatabaseRecordIterator(conHelper.exec(selectRevisionsStmtSQL, new Object[]{new Long(
+                    startRevision)}, false, 0), getResolver(), getNamePathResolver());
-            close(true);
-
-            String msg = "Unable to return record iterator.";
-            throw new JournalException(msg, e);
+            throw new JournalException("Unable to return record iterator.", e);
-            checkConnection();
-
-            selectRevisionsStmt.clearParameters();
-            selectRevisionsStmt.clearWarnings();
-            selectRevisionsStmt.setLong(1, Long.MIN_VALUE);
-            selectRevisionsStmt.execute();
-
-            return new DatabaseRecordIterator(
-                    selectRevisionsStmt.getResultSet(), getResolver(), getNamePathResolver());
+            return new DatabaseRecordIterator(conHelper.exec(selectRevisionsStmtSQL, new Object[]{new Long(
+                    Long.MIN_VALUE)}, false, 0), getResolver(), getNamePathResolver());
-            close(true);
-
-            String msg = "Unable to return record iterator.";
-            throw new JournalException(msg, e);
+            throw new JournalException("Unable to return record iterator.", e);
-            checkConnection();
-                setAutoCommit(connection, false);
+                conHelper.startBatch();
-            close(true);
-
-            String msg = "Unable to set autocommit to false.";
-            throw new JournalException(msg, e);
+            throw new JournalException("Unable to set autocommit to false.", e);
-            updateGlobalStmt.clearParameters();
-            updateGlobalStmt.clearWarnings();
-            updateGlobalStmt.execute();
-
-            selectGlobalStmt.clearParameters();
-            selectGlobalStmt.clearWarnings();
-            selectGlobalStmt.execute();
-
-            rs = selectGlobalStmt.getResultSet();
+            conHelper.exec(updateGlobalStmtSQL);
+            rs = conHelper.exec(selectGlobalStmtSQL, null, false, 0);
-            close(true);
-
-            String msg = "Unable to lock global revision table.";
-            throw new JournalException(msg, e);
+            throw new JournalException("Unable to lock global revision table.", e);
-            close(rs);
+            DbUtility.close(rs);
-            if (successful) {
-                commit(connection);
-            } else {
-                rollback(connection);
+            try {
+                conHelper.endBatch(successful);;
+            } catch (SQLException e) {
+                log.error("failed to end batch", e);
-            setAutoCommit(connection, true);
-            checkConnection();
-
-            insertRevisionStmt.clearParameters();
-            insertRevisionStmt.clearWarnings();
-            insertRevisionStmt.setLong(1, record.getRevision());
-            insertRevisionStmt.setString(2, getId());
-            insertRevisionStmt.setString(3, record.getProducerId());
-            insertRevisionStmt.setBinaryStream(4, in, length);
-            insertRevisionStmt.execute();
+            conHelper.exec(insertRevisionStmtSQL, record.getRevision(), getId(), record.getProducerId(),
+                new StreamWrapper(in, length));
-            close(true);
-
-        close(false);
-     * Close database connections and statements. If closing was due to an
-     * error that occurred, calculates the next time a reconnect should
-     * be attempted.
-     *
-     * @param failure whether closing is due to a failure
-     */
-    private void close(boolean failure) {
-        if (failure) {
-            reconnectTimeMs = System.currentTimeMillis() + reconnectDelayMs;
-        }
-
-        close(selectRevisionsStmt);
-        selectRevisionsStmt = null;
-        close(updateGlobalStmt);
-        updateGlobalStmt = null;
-        close(selectGlobalStmt);
-        selectGlobalStmt = null;
-        close(insertRevisionStmt);
-        insertRevisionStmt = null;
-        close(selectMinLocalRevisionStmt);
-        selectMinLocalRevisionStmt = null;
-        close(cleanRevisionStmt);
-        cleanRevisionStmt = null;
-        close(getLocalRevisionStmt);
-        getLocalRevisionStmt = null;
-        close(insertLocalRevisionStmt);
-        insertLocalRevisionStmt = null;
-        close(updateLocalRevisionStmt);
-        updateLocalRevisionStmt = null;
-
-        close(connection);
-        connection = null;
-    }
-
-    /**
-     * Set the autocommit flag of a connection. Does nothing if the connection
-     * passed is <code>null</code> and logs any exception as warning.
-     *
-     * @param connection database connection
-     * @param autoCommit where to enable or disable autocommit
-     */
-    private static void setAutoCommit(Connection connection, boolean autoCommit) {
-        if (connection != null) {
-            try {
-                // JCR-1013: Setter may fail on a managed connection
-                if (connection.getAutoCommit() != autoCommit) {
-                    connection.setAutoCommit(autoCommit);
-                }
-            } catch (SQLException e) {
-                String msg = "Unable to set autocommit flag to " + autoCommit;
-                log.warn(msg, e);
-            }
-        }
-    }
-
-    /**
-     * Commit a connection. Does nothing if the connection passed is
-     * <code>null</code> and logs any exception as warning.
-     *
-     * @param connection connection.
-     */
-    private static void commit(Connection connection) {
-        if (connection != null) {
-            try {
-                connection.commit();
-            } catch (SQLException e) {
-                String msg = "Error while committing connection: " + e.getMessage();
-                log.warn(msg);
-            }
-        }
-    }
-
-    /**
-     * Rollback a connection. Does nothing if the connection passed is
-     * <code>null</code> and logs any exception as warning.
-     *
-     * @param connection connection.
-     */
-    private static void rollback(Connection connection) {
-        if (connection != null) {
-            try {
-                connection.rollback();
-            } catch (SQLException e) {
-                String msg = "Error while rolling back connection: " + e.getMessage();
-                log.warn(msg);
-            }
-        }
-    }
-
-    /**
-     * Closes the given database connection. Does nothing if the connection
-     * passed is <code>null</code> and logs any exception as warning.
-     *
-     * @param connection database connection
-     */
-    private static void close(Connection connection) {
-        if (connection != null) {
-            try {
-                connection.close();
-            } catch (SQLException e) {
-                String msg = "Error while closing connection: " + e.getMessage();
-                log.warn(msg);
-            }
-        }
-    }
-
-    /**
-     * Close some input stream.  Does nothing if the input stream
-     * passed is <code>null</code> and logs any exception as warning.
-     *
-     * @param in input stream, may be <code>null</code>.
-     */
-    private static void close(InputStream in) {
-        if (in != null) {
-            try {
-                in.close();
-            } catch (IOException e) {
-                String msg = "Error while closing input stream: " + e.getMessage();
-                log.warn(msg);
-            }
-        }
-    }
-
-    /**
-     * Close some statement.  Does nothing if the statement
-     * passed is <code>null</code> and logs any exception as warning.
-     *
-     * @param stmt statement, may be <code>null</code>.
-     */
-    private static void close(Statement stmt) {
-        if (stmt != null) {
-            try {
-                stmt.close();
-            } catch (SQLException e) {
-                String msg = "Error while closing statement: " + e.getMessage();
-                log.warn(msg);
-            }
-        }
-    }
-
-    /**
-     * Close some resultset.  Does nothing if the result set
-     * passed is <code>null</code> and logs any exception as warning.
-     *
-     * @param rs resultset, may be <code>null</code>.
-     */
-    private static void close(ResultSet rs) {
-        if (rs != null) {
-            try {
-                rs.close();
-            } catch (SQLException e) {
-                String msg = "Error while closing result set: " + e.getMessage();
-                log.warn(msg);
-            }
-        }
-    }
-
-    /**
-     * Checks the currently established connection. If the connection no longer
-     * exists, waits until at least <code>reconnectTimeMs</code> have passed
-     * since the error occurred and recreates the connection.
-     */
-    private void checkConnection() throws SQLException, JournalException {
-        if (connection == null) {
-            long delayMs = reconnectTimeMs - System.currentTimeMillis();
-            if (delayMs > 0) {
-                try {
-                    Thread.sleep(delayMs);
-                } catch (InterruptedException e) {
-                    /* ignore */
-                }
-            }
-            connection = getConnection();
-            prepareStatements();
-        }
-    }
-
-    /**
-     * Checks if the required schema objects exist and creates them if they
-     * don't exist yet.
-     *
-     * @throws Exception if an error occurs
-     */
-    private void checkSchema() throws Exception {
-        if (!tableExists(connection.getMetaData(), schemaObjectPrefix + DEFAULT_JOURNAL_TABLE)) {            // read ddl from resources
-            InputStream in = DatabaseJournal.class.getResourceAsStream(databaseType + ".ddl");
-            if (in == null) {
-                String msg = "No database-specific DDL found: '" + databaseType + ".ddl"
-                    + "', falling back to '" + DEFAULT_DDL_NAME + "'.";
-                log.info(msg);
-                in = DatabaseJournal.class.getResourceAsStream(DEFAULT_DDL_NAME);
-                if (in == null) {
-                    msg = "Unable to load '" + DEFAULT_DDL_NAME + "'.";
-                    throw new JournalException(msg);
-                }
-            }
-            BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-            Statement stmt = connection.createStatement();
-            try {
-                String sql = reader.readLine();
-                while (sql != null) {
-                    // Skip comments and empty lines
-                    if (!sql.startsWith("#") && sql.length() > 0) {
-                        // replace prefix variable
-                        sql = createSchemaSQL(sql);
-                        // execute sql stmt
-                        stmt.executeUpdate(sql);
-                    }
-                    // read next sql stmt
-                    sql = reader.readLine();
-                }
-            } finally {
-                close(in);
-                close(stmt);
-            }
-        }
-    }
-
-    /**
-        if (!tableExists(connection.getMetaData(), schemaObjectPrefix + LOCAL_REVISIONS_TABLE)) {
-            log.info("Creating " + schemaObjectPrefix + LOCAL_REVISIONS_TABLE + " table");
-            // read ddl from resources
-            InputStream in = DatabaseJournal.class.getResourceAsStream(databaseType + ".ddl");
-            if (in == null) {
-                String msg = "No database-specific DDL found: '" + databaseType + ".ddl" +
-                        "', falling back to '" + DEFAULT_DDL_NAME + "'.";
-                log.info(msg);
-                in = DatabaseJournal.class.getResourceAsStream(DEFAULT_DDL_NAME);
-                if (in == null) {
-                    msg = "Unable to load '" + DEFAULT_DDL_NAME + "'.";
-                    throw new JournalException(msg);
-                }
-            }
-            BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-            Statement stmt = connection.createStatement();
-            try {
-                String sql = reader.readLine();
-                while (sql != null) {
-                    // Skip comments and empty lines, and select only the statement
-                    // to create the LOCAL_REVISIONS table.
-                    if (!sql.startsWith("#") && sql.length() > 0
-                            && sql.indexOf(LOCAL_REVISIONS_TABLE) != -1) {
-                        // replace prefix variable
-                        sql = createSchemaSQL(sql);
-                        // execute sql stmt
-                        stmt.executeUpdate(sql);
-                    }
-                    // read next sql stmt
-                    sql = reader.readLine();
-                }
-            } finally {
-                close(in);
-                close(stmt);
-            }
-        }
-    }
-
-    /**
-     * Checks whether the required table(s) exist in the schema. May be
-     * overridden by subclasses to allow different table names.
-     *
-     * @param metaData database meta data
-     * @return <code>true</code> if the schema exists
-     * @throws SQLException if an SQL error occurs
-     */
-    protected boolean tableExists(DatabaseMetaData metaData, String tableName)
-        throws SQLException {
-
-        if (metaData.storesLowerCaseIdentifiers()) {
-            tableName = tableName.toLowerCase();
-        } else if (metaData.storesUpperCaseIdentifiers()) {
-            tableName = tableName.toUpperCase();
-        }
-
-        ResultSet rs = metaData.getTables(null, null, tableName, null);
-
+        InputStream localRevisionDDLStream = null;
+        InputStream in = DatabaseJournal.class.getResourceAsStream(databaseType + ".ddl");
-            return rs.next();
+            BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+            String sql = reader.readLine();
+            while (sql != null) {
+                // Skip comments and empty lines, and select only the statement to create the LOCAL_REVISIONS
+                // table.
+                if (!sql.startsWith("#") && sql.length() > 0 && sql.indexOf(LOCAL_REVISIONS_TABLE) != -1) {
+                    localRevisionDDLStream = new ByteArrayInputStream(sql.getBytes());
+                    break;
+                }
+                // read next sql stmt
+                sql = reader.readLine();
+            }
-            rs.close();
+            IOUtils.closeQuietly(in);
-    }
-
-    /**
-     * Creates an SQL statement for schema creation by variable substitution.
-     *
-     * @param sql a SQL string which may contain variables to substitute
-     * @return a valid SQL string
-     */
-    protected String createSchemaSQL(String sql) {
-        return Text.replace(sql, SCHEMA_OBJECT_PREFIX_VARIABLE, schemaObjectPrefix);
+        // Run the schema check for the single table
+        new CheckSchemaOperation(conHelper, localRevisionDDLStream, schemaObjectPrefix
+                + LOCAL_REVISIONS_TABLE).addVariableReplacement(
+            CheckSchemaOperation.SCHEMA_OBJECT_PREFIX_VARIABLE, schemaObjectPrefix).run();
-     * Prepares the SQL statements.
-     *
-     * @throws SQLException if an error occurs
-     */
-    private void prepareStatements() throws SQLException {
-        selectRevisionsStmt = connection.prepareStatement(selectRevisionsStmtSQL);
-        updateGlobalStmt = connection.prepareStatement(updateGlobalStmtSQL);
-        selectGlobalStmt = connection.prepareStatement(selectGlobalStmtSQL);
-        insertRevisionStmt = connection.prepareStatement(insertRevisionStmtSQL);
-        selectMinLocalRevisionStmt = connection.prepareStatement(selectMinLocalRevisionStmtSQL);
-        cleanRevisionStmt = connection.prepareStatement(cleanRevisionStmtSQL);
-        getLocalRevisionStmt = connection.prepareStatement(getLocalRevisionStmtSQL);
-        insertLocalRevisionStmt = connection.prepareStatement(insertLocalRevisionStmtSQL);
-        updateLocalRevisionStmt = connection.prepareStatement(updateLocalRevisionStmtSQL);
-    }
-
-    /**
-     *
+     * 
-     *
+     * 
-    public long getReconnectDelayMs() {
-        return reconnectDelayMs;
-    }
-
-     *
+     * 
-    * This method is deprecated; {@link #setDatabaseType} should be used instead.
-     *
+    * This method is deprecated; {@link #getDatabaseType} should be used instead.
+     * 
-    public void setReconnectDelayMs(long reconnectDelayMs) {
-        this.reconnectDelayMs = reconnectDelayMs;
-    }
-
+    public String getDataSourceName() {
+        return dataSourceName;
+    }
+
+    public void setDataSourceName(String dataSourceName) {
+        this.dataSourceName = dataSourceName;
+    }
+
-         * Indicates whether the init method has been called.
+         * Indicates whether the init method has been called. 
-        private boolean initialized;
+        private boolean initialized = false;
+            ResultSet rs = null;
-                // Check whether the connection is available
-                checkConnection();
-
-                getLocalRevisionStmt.clearParameters();
-                getLocalRevisionStmt.clearWarnings();
-                getLocalRevisionStmt.setString(1, getId());
-                getLocalRevisionStmt.execute();
-                ResultSet rs = getLocalRevisionStmt.getResultSet();
+                rs = conHelper.exec(getLocalRevisionStmtSQL, new Object[]{getId()}, false, 0);
-                rs.close();
-                    insertLocalRevisionStmt.clearParameters();
-                    insertLocalRevisionStmt.clearWarnings();
-                    insertLocalRevisionStmt.setLong(1, revision);
-                    insertLocalRevisionStmt.setString(2, getId());
-                    insertLocalRevisionStmt.execute();
+                    conHelper.exec(insertLocalRevisionStmtSQL, revision, getId());
-                DatabaseJournal.this.close(true);
+            } finally {
+                DbUtility.close(rs);
-                // Check whether the connection is available
-                checkConnection();
-                updateLocalRevisionStmt.clearParameters();
-                updateLocalRevisionStmt.clearWarnings();
-                updateLocalRevisionStmt.setLong(1, localRevision);
-                updateLocalRevisionStmt.setString(2, getId());
-                updateLocalRevisionStmt.execute();
+                conHelper.exec(updateLocalRevisionStmtSQL, localRevision, getId());
-                DatabaseJournal.this.close(true);
+                throw new JournalException("Failed to update local revision.", e);
-
+        
-        public synchronized void close() {
-            // Do nothing: The statements are closed in DatabaseJournal.close()
+        public void close() {
-
+        
+            ResultSet rs = null;
-
-                // Check whether the connection is available
-                checkConnection();
-
-                // Find the minimal local revision
-                selectMinLocalRevisionStmt.clearParameters();
-                selectMinLocalRevisionStmt.clearWarnings();
-                selectMinLocalRevisionStmt.execute();
-                ResultSet rs = selectMinLocalRevisionStmt.getResultSet();
+                rs = conHelper.exec(selectMinLocalRevisionStmtSQL, null, false, 0);
-                rs.close();
-                    cleanRevisionStmt.clearParameters();
-                    cleanRevisionStmt.clearWarnings();
-                    cleanRevisionStmt.setLong(1, minRevision);
-                    cleanRevisionStmt.execute();
+                    conHelper.exec(cleanRevisionStmtSQL, minRevision);
-                close(true);
+            } finally {
+                DbUtility.close(rs);

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 INS40 INS40 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 INS43 INS23 INS31 INS31 INS31 INS31 UPD42 MOV42 MOV43 UPD43 INS29 INS83 INS43 INS59 INS42 MOV8 INS29 MOV83 MOV39 INS42 INS44 INS8 INS83 INS43 INS42 INS43 INS8 INS29 UPD83 MOV83 INS43 INS42 INS44 MOV43 INS8 INS29 UPD83 MOV83 INS43 INS42 INS8 MOV29 UPD83 MOV43 UPD42 MOV44 MOV43 MOV29 UPD83 MOV43 UPD42 MOV43 MOV29 UPD39 UPD42 MOV44 MOV8 MOV43 UPD42 UPD42 UPD42 UPD42 UPD42 INS9 MOV65 UPD42 MOV42 UPD42 MOV42 INS21 INS65 INS43 INS42 MOV21 INS42 INS42 INS25 INS65 MOV65 UPD65 MOV65 UPD65 MOV65 UPD42 MOV42 UPD43 MOV43 UPD42 MOV42 INS41 INS65 UPD65 MOV65 UPD42 MOV42 MOV60 INS41 INS25 INS54 INS54 MOV60 INS21 MOV43 UPD42 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS7 INS65 INS42 INS27 INS8 MOV8 INS66 INS65 UPD66 MOV66 UPD66 MOV66 INS65 INS66 INS65 UPD66 MOV66 UPD66 MOV66 UPD42 UPD66 INS65 INS66 UPD66 INS65 UPD42 UPD66 UPD42 INS14 UPD66 MOV66 INS65 INS66 INS65 UPD66 MOV66 INS65 UPD66 MOV66 UPD66 MOV66 INS66 INS65 UPD66 INS32 INS27 INS27 INS27 INS8 INS8 MOV12 INS8 INS12 MOV27 INS8 UPD43 INS32 UPD42 INS9 INS60 INS60 INS42 INS42 INS45 INS22 INS42 INS27 INS32 INS41 INS41 INS68 UPD42 MOV42 UPD66 MOV66 INS42 INS42 INS43 INS42 INS9 INS68 INS68 UPD42 MOV42 UPD42 MOV42 INS14 UPD42 MOV42 INS40 UPD42 MOV42 MOV27 INS27 MOV27 INS27 INS42 INS33 MOV54 INS41 MOV44 INS8 INS41 MOV44 INS8 MOV44 INS8 INS54 INS21 UPD42 INS42 INS33 MOV60 INS32 UPD42 MOV42 UPD42 UPD66 INS43 INS59 INS8 INS8 INS43 INS59 INS8 INS52 INS42 INS7 INS32 INS33 INS45 UPD42 MOV42 INS32 INS32 INS32 INS42 INS69 INS69 UPD42 MOV42 INS42 MOV69 INS69 INS42 INS69 INS43 INS42 INS42 MOV27 INS42 INS33 INS42 INS33 INS14 INS53 INS14 MOV53 MOV53 INS8 INS12 INS32 INS14 INS42 INS40 INS42 UPD42 UPD42 INS42 INS42 INS33 INS21 MOV60 MOV25 INS25 MOV21 MOV21 MOV41 MOV21 INS42 INS42 INS33 INS21 INS21 UPD42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 INS32 INS32 INS32 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS43 INS43 INS43 INS43 UPD42 MOV42 INS60 INS25 MOV43 INS32 MOV32 MOV32 INS14 MOV43 INS32 MOV32 MOV32 UPD42 UPD42 INS42 INS42 MOV21 INS20 MOV44 INS8 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV32 MOV32 MOV32 INS14 INS42 UPD42 INS43 INS42 INS42 MOV27 INS7 MOV38 INS8 MOV53 INS7 INS32 UPD42 INS32 UPD42 MOV42 INS42 UPD42 MOV42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 MOV43 INS59 INS27 INS8 MOV43 INS42 INS42 INS42 INS3 INS9 INS34 INS43 INS45 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS3 INS9 INS34 INS45 UPD42 MOV43 INS45 UPD42 UPD42 INS42 INS33 INS9 INS34 INS45 INS32 MOV21 INS43 INS42 INS42 UPD42 MOV42 INS42 INS32 INS21 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 MOV32 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS33 INS21 UPD42 MOV42 INS5 INS4 UPD42 MOV42 INS5 INS4 UPD42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS10 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS3 INS9 INS34 INS32 INS45 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS33 INS9 INS34 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV57 INS42 INS27 INS32 INS45 INS43 INS85 INS14 INS43 INS85 INS14 INS42 UPD42 MOV42 INS45 UPD42 MOV42 INS5 INS4 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV32 UPD42 UPD42 INS42 INS42 INS45 INS42 INS42 MOV42 INS42 INS43 INS42 UPD42 MOV42 INS43 INS40 UPD42 INS14 INS43 INS85 MOV32 INS42 INS42 UPD42 MOV42 INS43 INS32 UPD42 MOV42 UPD42 MOV42 INS42 MOV42 INS42 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL43 DEL42 DEL45 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL45 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL39 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL59 DEL23 DEL42 DEL40 DEL43 DEL69 DEL68 DEL66 DEL66 DEL66 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL34 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL14 DEL41 DEL8 DEL42 DEL9 DEL32 DEL21 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL42 DEL42 DEL42 DEL32 DEL42 DEL27 DEL42 DEL33 DEL27 DEL25 DEL42 DEL34 DEL27 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL9 DEL32 DEL32 DEL42 DEL32 DEL21 DEL32 DEL21 DEL66 DEL32 DEL21 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL68 DEL65 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL42 DEL43 DEL45 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL29 DEL39 DEL42 DEL43 DEL43 DEL42 DEL44 DEL8 DEL42 DEL33 DEL27 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL27 DEL59 DEL60 DEL42 DEL34 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL25 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL32 DEL21 DEL8 DEL25 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL39 DEL42 DEL32 DEL32 DEL38 DEL42 DEL33 DEL27 DEL43 DEL42 DEL45 DEL42 DEL45 DEL45 DEL42 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL33 DEL27 DEL42 DEL45 DEL42 DEL45 DEL27 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL14 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL45 DEL32 DEL38 DEL42 DEL42 DEL32 DEL34 DEL27 DEL27 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL61 DEL8 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL34 DEL40 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL14 DEL41 DEL8 DEL42 DEL9 DEL32 DEL21 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL31 DEL42 DEL32 DEL21 DEL9 DEL42 DEL9 DEL32 DEL21 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL9 DEL32 DEL21 DEL43 DEL42 DEL45 DEL59 DEL60 DEL8 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL32 DEL7 DEL42 DEL32 DEL7 DEL42 DEL42 DEL32 DEL8 DEL42 DEL42 DEL32 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL33 DEL33 DEL42 DEL33 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL41 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL83 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL34 DEL32 DEL21 DEL42 DEL34 DEL32 DEL21 DEL42 DEL42 DEL34 DEL32 DEL21 DEL42 DEL42 DEL34 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL9 DEL32 DEL21 DEL42 DEL9 DEL32 DEL21 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL42 DEL33 DEL7 DEL21 DEL42 DEL32 DEL21 DEL42 DEL33 DEL7 DEL21 DEL42 DEL32 DEL21 DEL42 DEL33 DEL7 DEL21 DEL42 DEL32 DEL21 DEL42 DEL33 DEL7 DEL21 DEL42 DEL32 DEL21 DEL42 DEL33 DEL7 DEL21 DEL42 DEL32 DEL21 DEL42 DEL33 DEL7 DEL21 DEL42 DEL32 DEL21 DEL42 DEL33 DEL7 DEL21 DEL42 DEL32 DEL21 DEL42 DEL33 DEL7 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL33 DEL7 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL33 DEL7 DEL21 DEL8 DEL31 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL33 DEL27 DEL42 DEL32 DEL42 DEL27 DEL25 DEL8 DEL43 DEL42 DEL45 DEL42 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL31 DEL65 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL31 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL31 DEL29 DEL83 DEL39 DEL42 DEL43 DEL42 DEL44 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL44 DEL43 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL43 DEL42 DEL44 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL43 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL31 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL31 DEL65 DEL29 DEL83 DEL39 DEL42 DEL43 DEL42 DEL44 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL43 DEL42 DEL44 DEL42 DEL45 DEL32 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL31 DEL42 DEL45 DEL42 DEL45 DEL45 DEL42 DEL45 DEL27 DEL42 DEL42 DEL45 DEL42 DEL42 DEL45 DEL27 DEL32 DEL21 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL57 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL33 DEL27 DEL42 DEL45 DEL42 DEL45 DEL27 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL32 DEL38 DEL25 DEL8 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL31 DEL39 DEL39 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL34 DEL32 DEL21 DEL42 DEL32 DEL21 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL42 DEL34 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL52 DEL42 DEL9 DEL32 DEL21 DEL34 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL34 DEL42 DEL42 DEL34 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL52 DEL42 DEL9 DEL32 DEL21 DEL83 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL34 DEL42 DEL42 DEL32 DEL21 DEL42 DEL9 DEL32 DEL21
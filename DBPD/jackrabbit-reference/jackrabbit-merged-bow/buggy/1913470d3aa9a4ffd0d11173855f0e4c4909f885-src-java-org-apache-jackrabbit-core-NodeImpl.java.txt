- fixing: JCR-51 Node.restore fails with multiple mixin types

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@155256 13f79535-47bb-0310-9956-ffa450edef68

+        /*
+         to internal place to check this
+
+        */
-            throw new ItemNotFoundException("No corresponding node for " + safeGetJCRPath());
+            /*
+             * If this node does not have a corresponding node in the workspace
+             * <code>srcWorkspaceName</code>, then the <code>update</code> method
+             * has no effect (it does not traverse down the subtree).
+            */
+            return;
-        // not sure, if clone overrides 'this' node.
-        session.getWorkspace().clone(srcWorkspaceName, srcNode.getPath(), getPath(), true);
+
+        /*
+         * If this node does have a corresponding node in the workspace <code>srcWorkspaceName</code>,
+         * then this method traverses down the subtree rooted at this node and
+         * replaces the state of each node in the subtree rooted at this node with that
+         * of its corresponding node in the specified source workspace.
+         */
+        boolean removeExisting = false;
+        boolean replaceExisting = true;
+        try {
+            internalUpdate(srcNode, removeExisting, replaceExisting);
+        } catch (RepositoryException e) {
+            session.refresh(false);
+            throw e;
+        }
+        session.save();
+    }
+
+    /**
+     * updates this node with the state given by <code>srcNode</code>
+     * @param srcNode
+     * @param removeExisting
+     * @param replaceExisting
+     * @throws RepositoryException
+     */
+    private void internalUpdate(NodeImpl srcNode, boolean removeExisting, boolean replaceExisting)
+            throws RepositoryException {
+        /*
+         * The "state" of the node in this context means the set of properties and
+         * child nodes it has. In other words, when a node is updated, its set of
+         * properties and child nodes is replaced by that of its corresponding node in the
+         * source workspace. One repercussion of this is that if a node further down the
+         * subtree does not have a corresponding node, then that node is removed (thus
+         * aligning the state of its parent with <i>its</i> correspondee in the other
+         * workspace).
+         */
+
+        // update the properties
+        PropertyIterator iter = getProperties();
+        while (iter.hasNext()) {
+            PropertyImpl p = (PropertyImpl) iter.nextProperty();
+            if (!srcNode.hasProperty(p.getQName())) {
+                p.internalRemove(true);
+            }
+        }
+        iter = srcNode.getProperties();
+        while (iter.hasNext()) {
+            PropertyImpl p = (PropertyImpl) iter.nextProperty();
+            // ignore system types
+            if (p.getQName().equals(JCR_PRIMARYTYPE)
+                || p.getQName().equals(JCR_MIXINTYPES)
+                || p.getQName().equals(JCR_UUID)) {
+                continue;
+            }
+            if (p.getDefinition().isMultiple()) {
+                internalSetProperty(p.getQName(), p.internalGetValues());
+            } else {
+                internalSetProperty(p.getQName(), p.internalGetValue());
+            }
+        }
+
+        // update the nodes. remove all dst nodes first
+        NodeIterator niter = getNodes();
+        while (niter.hasNext()) {
+            ((NodeImpl) niter.nextNode()).internalRemove(true);
+        }
+        // add src ones
+        niter = srcNode.getNodes();
+        while (niter.hasNext()) {
+            NodeImpl child = (NodeImpl) niter.nextNode();
+            NodeImpl dstNode = null;
+            String uuid = child.internalGetUUID();
+            if (child.isNodeType(MIX_REFERENCEABLE)) {
+                // if child is referenceable, check if correspondance exist in this workspace
+                try {
+                    dstNode = (NodeImpl) session.getNodeByUUID(uuid);
+                    if (removeExisting) {
+                        // get applicable definition of target node at new location
+                        NodeTypeImpl nt = (NodeTypeImpl) dstNode.getPrimaryNodeType();
+                        NodeDefImpl newTargetDef;
+                        try {
+                            newTargetDef = ((NodeImpl) getParent()).getApplicableChildNodeDef(child.getQName(), nt.getQName());
+                        } catch (RepositoryException re) {
+                            String msg = dstNode.safeGetJCRPath() + ": no definition found in parent node's node type for new node";
+                            log.debug(msg);
+                            throw new ConstraintViolationException(msg, re);
+                        }
+
+                        // add target to new parent and remove from old one
+                        createChildNodeLink(child.getQName(), uuid);
+                        ((NodeImpl) dstNode.getParent()).removeChildNode(child.getQName(), child.getIndex() == 0 ? 1 : child.getIndex());
+                        // change definition of target if necessary
+                        NodeDefImpl oldTargetDef = (NodeDefImpl) dstNode.getDefinition();
+                        NodeDefId oldTargetDefId = new NodeDefId(oldTargetDef.unwrap());
+                        NodeDefId newTargetDefId = new NodeDefId(newTargetDef.unwrap());
+                        if (!oldTargetDefId.equals(newTargetDefId)) {
+                            dstNode.onRedefine(newTargetDefId);
+                        }
+                    } else if (replaceExisting) {
+                        // node exists outside of this update tree, so continue there
+                    } else {
+                        throw new ItemExistsException("Unable to update node: " + dstNode.safeGetJCRPath());
+                    }
+                } catch (ItemNotFoundException e) {
+                    // does not exist
+                }
+            } else {
+                // if child is not referenceable, adjust state
+                uuid = null;
+            }
+            if (dstNode == null) {
+                dstNode = internalAddChildNode(child.getQName(), (NodeTypeImpl) child.getPrimaryNodeType(), uuid);
+                // add mixins
+                NodeType[] mixins = child.getMixinNodeTypes();
+                for (int i=0; i<mixins.length; i++) {
+                    dstNode.addMixin(mixins[i].getName());
+                }
+            }
+            dstNode.internalUpdate(child, removeExisting, replaceExisting);
+        }
-        QName[] values = freeze.getFrozenMixinTypes();
-        NodeType[] mixins = getMixinNodeTypes();
-        for (int i = 0; i < values.length; i++) {
-            boolean found = false;
-            for (int j = 0; j < mixins.length; j++) {
-                if (values[i].equals(((NodeTypeImpl) mixins[j]).getQName())) {
-                    // clear
-                    mixins[j] = null;
-                    found = true;
-                    break;
-                }
-            }
-            if (!found) {
-                addMixin(values[i]);
-            }
-        }
-        // remove additional mixins
-        for (int i = 0; i < mixins.length; i++) {
-            if (mixins[i] != null) {
-                removeMixin(mixins[i].getName());
-            }
-        }
-
+        NodeState thisState = (NodeState) getOrCreateTransientItemState();
+        QName[] mixinNames = freeze.getFrozenMixinTypes();
+        Set mixins = new HashSet(Arrays.asList(mixinNames));
+        NodeTypeManagerImpl ntMgr = session.getNodeTypeManager();
+        thisState.setMixinTypeNames(mixins);
+        internalSetProperty(JCR_MIXINTYPES, InternalValue.create(mixinNames));
+        // adjust autocreate properties, that do not exist yet
+        for (int j=0; j<mixinNames.length; j++) {
+            NodeTypeImpl mixin = ntMgr.getNodeType(mixinNames[j]);
+            PropertyDef[] pda = mixin.getAutoCreatePropertyDefs();
+            for (int i = 0; i < pda.length; i++) {
+                PropertyDefImpl pd = (PropertyDefImpl) pda[i];
+                if (!hasProperty(pd.getQName())) {
+                    createChildProperty(pd.getQName(), pd.getRequiredType(), pd);
+                }
+            }
+        }
+

INS31 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS8 INS60 INS60 INS54 INS21 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS39 INS42 INS39 INS42 INS42 INS60 INS61 INS21 INS61 INS60 INS61 INS21 INS61 INS60 MOV60 INS60 INS21 INS21 INS24 INS39 INS59 INS39 INS59 INS8 INS12 INS32 INS66 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS8 INS7 INS32 INS8 INS43 INS59 INS32 INS8 INS7 INS32 INS8 INS43 INS59 INS43 INS43 INS59 INS32 INS32 MOV58 MOV27 MOV37 INS8 INS41 INS42 INS9 INS42 INS9 INS21 INS44 INS8 UPD42 MOV42 INS42 INS42 INS42 INS32 INS42 INS42 INS60 INS25 INS42 INS32 INS42 INS42 INS60 INS25 INS25 INS42 INS42 INS32 INS42 INS42 INS21 INS42 INS32 INS42 INS42 INS60 INS60 INS60 INS25 INS25 INS21 INS42 INS42 INS11 UPD42 INS42 UPD42 INS14 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 UPD40 INS60 INS60 INS24 INS32 INS43 INS42 INS21 INS53 INS42 INS43 INS59 INS38 INS8 INS42 INS42 INS43 INS59 INS27 INS8 INS32 INS8 INS8 INS42 INS32 INS42 INS42 INS43 INS59 INS43 INS59 MOV43 INS59 INS32 INS8 INS8 INS27 INS8 INS32 INS43 INS32 INS43 INS32 INS42 INS42 INS42 INS42 INS42 MOV43 INS59 INS5 INS59 MOV58 INS27 MOV37 INS8 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS32 INS42 INS42 INS42 INS11 INS32 INS21 INS42 INS42 INS11 INS32 INS32 INS32 INS18 INS32 INS42 INS21 INS21 INS36 INS42 INS9 INS42 INS42 INS11 INS42 INS42 INS33 INS42 INS32 INS42 INS42 INS42 INS54 INS21 INS42 INS33 INS21 MOV60 MOV24 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS85 INS42 INS32 INS42 INS40 INS60 MOV25 UPD42 MOV42 UPD42 MOV42 INS9 INS43 INS32 INS42 INS42 INS32 INS32 INS43 INS32 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS32 INS11 INS43 INS32 INS42 INS42 INS8 INS12 INS7 INS7 MOV8 INS42 UPD42 MOV42 INS2 INS42 INS42 INS42 INS43 INS59 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS32 INS32 INS43 INS32 INS42 INS42 INS42 INS21 INS25 INS44 INS8 INS42 INS33 INS42 INS32 UPD42 MOV42 MOV42 INS42 INS42 INS11 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS42 INS8 INS25 MOV43 INS42 INS42 INS32 INS11 INS42 INS42 INS43 INS2 INS42 INS32 INS42 INS11 INS60 INS60 INS54 INS21 INS21 INS60 INS60 INS60 INS25 INS42 INS8 INS8 INS42 INS42 INS43 INS32 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 UPD42 INS32 INS32 INS42 INS43 INS32 INS43 INS59 INS43 INS59 INS8 INS12 INS32 INS32 INS43 INS59 INS43 INS59 INS43 INS59 INS38 INS8 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS21 INS44 INS8 INS42 INS32 INS42 INS36 INS42 INS32 INS16 INS42 INS42 INS11 INS42 INS42 INS14 INS42 INS42 INS14 INS32 INS21 INS14 INS43 INS32 INS7 INS43 INS42 INS60 MOV21 INS53 INS42 INS42 INS11 INS42 INS42 INS27 INS34 INS32 INS43 INS32 INS43 INS32 INS43 INS32 INS42 INS42 INS42 INS32 INS43 INS27 INS42 INS42 INS42 INS42 INS32 INS42 INS43 INS59 INS14 INS43 INS32 INS32 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS36 INS42 INS32 INS32 INS42 INS42 INS27 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS42 INS42 INS32 INS45 INS42 INS43 INS32 INS42 INS42 INS42 INS42 DEL42 DEL32 DEL38 DEL42 DEL45 DEL42 DEL32 DEL45 DEL42 DEL42 DEL32 DEL27 DEL59 DEL60 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL45 DEL42 DEL32 DEL27 DEL14 DEL53 DEL32 DEL42 DEL42 DEL32 DEL32 DEL9 DEL32 DEL21 DEL42 DEL42 DEL2 DEL33 DEL27 DEL25 DEL8 DEL39 DEL9 DEL42 DEL40 DEL27 DEL42 DEL42 DEL2 DEL2 DEL11 DEL36 DEL42 DEL32 DEL32 DEL42 DEL42 DEL2 DEL33 DEL7 DEL21 DEL42 DEL9 DEL7 DEL21 DEL10 DEL8 DEL25 DEL8 DEL24 DEL8 DEL24 DEL42 DEL42 DEL42 DEL2
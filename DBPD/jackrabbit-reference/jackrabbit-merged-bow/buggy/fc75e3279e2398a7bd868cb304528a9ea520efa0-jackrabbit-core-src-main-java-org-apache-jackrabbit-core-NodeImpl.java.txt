JCR-890: concurrent read-only access to a session

Turn addMixin() and removeMixin() into SessionOperations

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@982520 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.HashMap;
-import java.util.Map;
-    private void setMixinTypesProperty(Set<Name> mixinNames) throws RepositoryException {
+    void setMixinTypesProperty(Set<Name> mixinNames) throws RepositoryException {
-    public void addMixin(Name mixinName)
-            throws NoSuchNodeTypeException, VersionException,
-            ConstraintViolationException, LockException, RepositoryException {
-        // check state of this instance
-        sanityCheck();
-
-        int options = ItemValidator.CHECK_LOCK | ItemValidator.CHECK_CHECKED_OUT
-                | ItemValidator.CHECK_CONSTRAINTS | ItemValidator.CHECK_HOLD;
-        int permissions = Permission.NODE_TYPE_MNGMT;
-        // special handling of mix:(simple)versionable. since adding the mixin alters
-        // the version storage jcr:versionManagement privilege is required
-        // in addition.
-        if (NameConstants.MIX_VERSIONABLE.equals(mixinName)
-                || NameConstants.MIX_SIMPLE_VERSIONABLE.equals(mixinName)) {
-            permissions |= Permission.VERSION_MNGMT;
-        }
-        session.getValidator().checkModify(this, options, permissions);
-
-        NodeTypeManagerImpl ntMgr = session.getNodeTypeManager();
-        NodeTypeImpl mixin = ntMgr.getNodeType(mixinName);
-        if (!mixin.isMixin()) {
-            throw new RepositoryException(mixinName + ": not a mixin node type");
-        }
-
-        final Name primaryTypeName = data.getNodeState().getNodeTypeName();
-        NodeTypeImpl primaryType = ntMgr.getNodeType(primaryTypeName);
-        if (primaryType.isDerivedFrom(mixinName)) {
-            // new mixin is already included in primary type
-            return;
-        }
-
-        // build effective node type of mixin's & primary type in order to detect conflicts
-        NodeTypeRegistry ntReg = ntMgr.getNodeTypeRegistry();
-        EffectiveNodeType entExisting;
-        try {
-            // existing mixin's
-            Set<Name> mixins = new HashSet<Name>(data.getNodeState().getMixinTypeNames());
-
-            // build effective node type representing primary type including existing mixin's
-            entExisting = ntReg.getEffectiveNodeType(primaryTypeName, mixins);
-            if (entExisting.includesNodeType(mixinName)) {
-                // new mixin is already included in existing mixin type(s)
-                return;
-            }
-
-            // add new mixin
-            mixins.add(mixinName);
-            // try to build new effective node type (will throw in case of conflicts)
-            ntReg.getEffectiveNodeType(primaryTypeName, mixins);
-        } catch (NodeTypeConflictException e) {
-            throw new ConstraintViolationException(e.getMessage(), e);
-        }
-
-        // do the actual modifications implied by the new mixin;
-        // try to revert the changes in case an exception occurs
-        try {
-            // modify the state of this node
-            NodeState thisState = (NodeState) getOrCreateTransientItemState();
-            // add mixin name
-            Set<Name> mixins = new HashSet<Name>(thisState.getMixinTypeNames());
-            mixins.add(mixinName);
-            thisState.setMixinTypeNames(mixins);
-
-            // set jcr:mixinTypes property
-            setMixinTypesProperty(mixins);
-
-            // add 'auto-create' properties defined in mixin type
-            for (PropertyDefinition aPda : mixin.getAutoCreatedPropertyDefinitions()) {
-                PropertyDefinitionImpl pd = (PropertyDefinitionImpl) aPda;
-                // make sure that the property is not already defined by primary type
-                // or existing mixin's
-                NodeTypeImpl declaringNT = (NodeTypeImpl) pd.getDeclaringNodeType();
-                if (!entExisting.includesNodeType(declaringNT.getQName())) {
-                    createChildProperty(pd.unwrap().getName(), pd.getRequiredType(), pd);
-                }
-            }
-
-            // recursively add 'auto-create' child nodes defined in mixin type
-            for (NodeDefinition aNda : mixin.getAutoCreatedNodeDefinitions()) {
-                NodeDefinitionImpl nd = (NodeDefinitionImpl) aNda;
-                // make sure that the child node is not already defined by primary type
-                // or existing mixin's
-                NodeTypeImpl declaringNT = (NodeTypeImpl) nd.getDeclaringNodeType();
-                if (!entExisting.includesNodeType(declaringNT.getQName())) {
-                    createChildNode(nd.unwrap().getName(), (NodeTypeImpl) nd.getDefaultPrimaryType(), null);
-                }
-            }
-        } catch (RepositoryException re) {
-            // try to undo the modifications by removing the mixin
-            try {
-                removeMixin(mixinName);
-            } catch (RepositoryException re1) {
-                // silently ignore & fall through
-            }
-            throw re;
-        }
+    public void addMixin(Name mixinName) throws RepositoryException {
+        perform(new AddMixinOperation(this, mixinName));
-    public void removeMixin(Name mixinName)
-            throws NoSuchNodeTypeException, VersionException,
-            ConstraintViolationException, LockException, RepositoryException {
-        // check state of this instance
-        sanityCheck();
-
-        int options = ItemValidator.CHECK_LOCK | ItemValidator.CHECK_CHECKED_OUT
-                | ItemValidator.CHECK_CONSTRAINTS | ItemValidator.CHECK_HOLD;
-        int permissions = Permission.NODE_TYPE_MNGMT;
-        session.getValidator().checkModify(this, options, permissions);
-
-        // check if mixin is assigned
-        final NodeState state = data.getNodeState();
-        if (!state.getMixinTypeNames().contains(mixinName)) {
-            throw new NoSuchNodeTypeException();
-        }
-
-        NodeTypeManagerImpl ntMgr = session.getNodeTypeManager();
-        NodeTypeRegistry ntReg = ntMgr.getNodeTypeRegistry();
-
-        // build effective node type of remaining mixin's & primary type
-        Set<Name> remainingMixins = new HashSet<Name>(state.getMixinTypeNames());
-        // remove name of target mixin
-        remainingMixins.remove(mixinName);
-        EffectiveNodeType entResulting;
-        try {
-            // build effective node type representing primary type including remaining mixin's
-            entResulting = ntReg.getEffectiveNodeType(
-                    state.getNodeTypeName(), remainingMixins);
-        } catch (NodeTypeConflictException e) {
-            throw new ConstraintViolationException(e.getMessage(), e);
-        }
-
-        /**
-         * mix:referenceable needs special handling because it has
-         * special semantics:
-         * it can only be removed if there no more references to this node
-         */
-        NodeTypeImpl mixin = ntMgr.getNodeType(mixinName);
-        if ((NameConstants.MIX_REFERENCEABLE.equals(mixinName)
-                || mixin.isDerivedFrom(NameConstants.MIX_REFERENCEABLE))
-                && !entResulting.includesNodeType(NameConstants.MIX_REFERENCEABLE)) {
-            // removing this mixin would effectively remove mix:referenceable:
-            // make sure no references exist
-            PropertyIterator iter = getReferences();
-            if (iter.hasNext()) {
-                throw new ConstraintViolationException(mixinName + " can not be removed: the node is being referenced"
-                        + " through at least one property of type REFERENCE");
-            }
-        }
-
-        /*
-         * mix:lockable: the mixin cannot be removed if the node is currently
-         * locked even if the editing session is the lock holder.
-         */
-        if ((NameConstants.MIX_LOCKABLE.equals(mixinName)
-                || mixin.isDerivedFrom(NameConstants.MIX_LOCKABLE))
-                && !entResulting.includesNodeType(NameConstants.MIX_LOCKABLE)
-                && isLocked()) {
-            throw new ConstraintViolationException(mixinName + " can not be removed: the node is locked.");
-        }
-
-        NodeState thisState = (NodeState) getOrCreateTransientItemState();
-
-        // collect information about properties and nodes which require
-        // further action as a result of the mixin removal;
-        // we need to do this *before* actually changing the assigned mixin types,
-        // otherwise we wouldn't be able to retrieve the current definition
-        // of an item.
-        Map<PropertyId, PropertyDefinition> affectedProps = new HashMap<PropertyId, PropertyDefinition>();
-        Map<ChildNodeEntry, NodeDefinition> affectedNodes = new HashMap<ChildNodeEntry, NodeDefinition>();
-        try {
-            Set<Name> names = thisState.getPropertyNames();
-            for (Name propName : names) {
-                PropertyId propId = new PropertyId(thisState.getNodeId(), propName);
-                PropertyState propState = (PropertyState) stateMgr.getItemState(propId);
-                PropertyDefinition oldDef = itemMgr.getDefinition(propState);
-                // check if property has been defined by mixin type (or one of its supertypes)
-                NodeTypeImpl declaringNT = (NodeTypeImpl) oldDef.getDeclaringNodeType();
-                if (!entResulting.includesNodeType(declaringNT.getQName())) {
-                    // the resulting effective node type doesn't include the
-                    // node type that declared this property
-                    affectedProps.put(propId, oldDef);
-                }
-            }
-
-            List<ChildNodeEntry> entries = thisState.getChildNodeEntries();
-            for (ChildNodeEntry entry : entries) {
-                NodeState nodeState = (NodeState) stateMgr.getItemState(entry.getId());
-                NodeDefinition oldDef = itemMgr.getDefinition(nodeState);
-                // check if node has been defined by mixin type (or one of its supertypes)
-                NodeTypeImpl declaringNT = (NodeTypeImpl) oldDef.getDeclaringNodeType();
-                if (!entResulting.includesNodeType(declaringNT.getQName())) {
-                    // the resulting effective node type doesn't include the
-                    // node type that declared this child node
-                    affectedNodes.put(entry, oldDef);
-                }
-            }
-        } catch (ItemStateException e) {
-            throw new RepositoryException("Internal Error: Failed to determine effect of removing mixin " + session.getJCRName(mixinName), e);
-        }
-
-        // modify the state of this node
-        thisState.setMixinTypeNames(remainingMixins);
-        // set jcr:mixinTypes property
-        setMixinTypesProperty(remainingMixins);
-
-        // process affected nodes & properties:
-        // 1. try to redefine item based on the resulting
-        //    new effective node type (see JCR-2130)
-        // 2. remove item if 1. fails
-        boolean success = false;
-        try {
-            for (PropertyId id : affectedProps.keySet()) {
-                PropertyImpl prop = (PropertyImpl) itemMgr.getItem(id);
-                PropertyDefinition oldDef = affectedProps.get(id);
-
-                if (oldDef.isProtected()) {
-                    // remove 'orphaned' protected properties immediately
-                    removeChildProperty(id.getName());
-                    continue;
-                }
-                // try to find new applicable definition first and
-                // redefine property if possible (JCR-2130)
-                try {
-                    PropertyDefinitionImpl newDef = getApplicablePropertyDefinition(
-                            id.getName(), prop.getType(),
-                            oldDef.isMultiple(), false);
-                    if (newDef.getRequiredType() != PropertyType.UNDEFINED
-                            && newDef.getRequiredType() != prop.getType()) {
-                        // value conversion required
-                        if (oldDef.isMultiple()) {
-                            // convert value
-                            Value[] values =
-                                    ValueHelper.convert(
-                                            prop.getValues(),
-                                            newDef.getRequiredType(),
-                                            session.getValueFactory());
-                            // redefine property
-                            prop.onRedefine(newDef.unwrap());
-                            // set converted values
-                            prop.setValue(values);
-                        } else {
-                            // convert value
-                            Value value =
-                                    ValueHelper.convert(
-                                            prop.getValue(),
-                                            newDef.getRequiredType(),
-                                            session.getValueFactory());
-                            // redefine property
-                            prop.onRedefine(newDef.unwrap());
-                            // set converted values
-                            prop.setValue(value);
-                        }
-                    } else {
-                        // redefine property
-                        prop.onRedefine(newDef.unwrap());
-                    }
-                } catch (ValueFormatException vfe) {
-                    // value conversion failed, remove it
-                    removeChildProperty(id.getName());
-                } catch (ConstraintViolationException cve) {
-                    // no suitable definition found for this property,
-                    // remove it
-                    removeChildProperty(id.getName());
-                }
-            }
-
-            for (ChildNodeEntry entry : affectedNodes.keySet()) {
-                NodeState nodeState = (NodeState) stateMgr.getItemState(entry.getId());
-                NodeImpl node = (NodeImpl) itemMgr.getItem(entry.getId());
-                NodeDefinition oldDef = affectedNodes.get(entry);
-
-                if (oldDef.isProtected()) {
-                    // remove 'orphaned' protected child node immediately
-                    removeChildNode(entry.getId());
-                    continue;
-                }
-
-                // try to find new applicable definition first and
-                // redefine node if possible (JCR-2130)
-                try {
-                    NodeDefinitionImpl newDef = getApplicableChildNodeDefinition(
-                            entry.getName(),
-                            nodeState.getNodeTypeName());
-                    // redefine node
-                    node.onRedefine(newDef.unwrap());
-                } catch (ConstraintViolationException cve) {
-                    // no suitable definition found for this child node,
-                    // remove it
-                    removeChildNode(entry.getId());
-                }
-            }
-            success = true;
-        } catch (ItemStateException e) {
-            throw new RepositoryException("Failed to clean up child items defined by removed mixin " + session.getJCRName(mixinName), e);
-        } finally {
-            if (!success) {
-                // TODO JCR-1914: revert any changes made so far
-            }
-        }
+    public void removeMixin(Name mixinName) throws RepositoryException {
+        perform(new RemoveMixinOperation(this, mixinName));
-    /**
-     * {@inheritDoc}
-     */
-    public void addMixin(String mixinName)
-            throws NoSuchNodeTypeException, VersionException,
-            ConstraintViolationException, LockException, RepositoryException {
+    /** Wrapper around {@link #addMixin(Name)}. */
+    public void addMixin(String mixinName) throws RepositoryException {
-                    "invalid mixin type name: " + mixinName, e);
+                    "Invalid mixin type name: " + mixinName, e);
-    /**
-     * {@inheritDoc}
-     */
-    public void removeMixin(String mixinName)
-            throws NoSuchNodeTypeException, VersionException,
-            ConstraintViolationException, LockException, RepositoryException {
+    /** Wrapper around {@link #removeMixin(Name)}. */
+    public void removeMixin(String mixinName) throws RepositoryException {
-                    "invalid mixin type name: " + mixinName, e);
+                    "Invalid mixin type name: " + mixinName, e);

MOV26 MOV26 MOV8 MOV8 INS21 INS21 INS32 INS32 INS66 UPD65 INS66 MOV8 INS66 UPD65 INS66 MOV8 INS42 INS14 INS42 INS14 INS68 INS68 UPD43 MOV43 INS52 INS42 UPD43 MOV43 INS52 INS42 INS42 INS69 INS42 INS69 UPD42 UPD42 MOV43 MOV43 UPD45 UPD45 DEL40 DEL26 DEL40 DEL26 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL32 DEL21 DEL39 DEL42 DEL40 DEL40 DEL40 DEL40 DEL27 DEL59 DEL60 DEL39 DEL42 DEL40 DEL59 DEL60 DEL40 DEL42 DEL42 DEL32 DEL40 DEL42 DEL42 DEL32 DEL27 DEL42 DEL40 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL52 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL38 DEL42 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL83 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL33 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL42 DEL53 DEL8 DEL12 DEL54 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL32 DEL21 DEL39 DEL42 DEL40 DEL40 DEL40 DEL40 DEL27 DEL59 DEL60 DEL39 DEL42 DEL40 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL52 DEL42 DEL42 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL38 DEL42 DEL43 DEL14 DEL53 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL40 DEL42 DEL42 DEL32 DEL42 DEL42 DEL40 DEL32 DEL27 DEL36 DEL42 DEL42 DEL40 DEL32 DEL38 DEL27 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL45 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL8 DEL25 DEL40 DEL42 DEL42 DEL32 DEL42 DEL42 DEL40 DEL32 DEL27 DEL36 DEL42 DEL42 DEL40 DEL32 DEL38 DEL42 DEL32 DEL27 DEL42 DEL43 DEL42 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL38 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL38 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL8 DEL42 DEL43 DEL42 DEL44 DEL45 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL18 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL9 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL40 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL27 DEL42 DEL42 DEL32 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL12 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL70 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL18 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL70 DEL42 DEL9 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL45 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL38 DEL8 DEL25 DEL8 DEL54 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43
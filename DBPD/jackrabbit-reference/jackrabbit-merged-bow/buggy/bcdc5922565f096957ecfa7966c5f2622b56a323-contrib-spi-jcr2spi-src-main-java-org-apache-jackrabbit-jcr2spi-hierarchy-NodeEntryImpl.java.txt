- NodeEntry: retrieving child node entries may throw RepositoryException -> adjust methods that add/remove/access child node entries.
- HierarchyEventListener: ignore local events


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@523326 13f79535-47bb-0310-9956-ffa450edef68

+        // TODO: deal with childNodeAttic
-        for (Iterator it = getAllChildEntries(false, true); it.hasNext();) {
+        for (Iterator it = getAllChildEntries(true, true); it.hasNext();) {
-        List namedEntries = childNodeEntries().get(nodeName);
-        if (namedEntries.isEmpty()) {
+        try {
+            List namedEntries = childNodeEntries().get(nodeName);
+            if (namedEntries.isEmpty()) {
+                return false;
+            } else {
+                // copy list since during validation the childNodeEntries may be
+                // modified if upon NodeEntry.getItemState the entry is removed.
+                List l = new ArrayList(namedEntries.size());
+                l.addAll(namedEntries);
+                return EntryValidation.containsValidNodeEntry(l.iterator());
+            }
+        } catch (RepositoryException e) {
+            log.debug("Unable to determine if a child node with name " + nodeName + " exists.");
-        } else {
-            // copy list since during validation the childNodeEntries may be
-            // modified if upon NodeEntry.getItemState the entry is removed.
-            List l = new ArrayList(namedEntries.size());
-            l.addAll(namedEntries);
-            return EntryValidation.containsValidNodeEntry(l.iterator());
-        return EntryValidation.isValidNodeEntry(childNodeEntries().get(nodeName, index));
+        try {
+            return EntryValidation.isValidNodeEntry(childNodeEntries().get(nodeName, index));
+        } catch (RepositoryException e) {
+            log.debug("Unable to determine if a child node with name " + nodeName + " exists.");
+            return false;
+        }
-    public synchronized NodeEntry getNodeEntry(QName nodeName, int index) {
+    public synchronized NodeEntry getNodeEntry(QName nodeName, int index) throws RepositoryException {
-    public synchronized NodeEntry getNodeEntry(NodeId childId) {
+    public synchronized NodeEntry getNodeEntry(NodeId childId) throws RepositoryException {
-    public synchronized Iterator getNodeEntries() {
+    public synchronized Iterator getNodeEntries() throws RepositoryException {
-     * Returns a unmodifiable list of <code>NodeEntry</code>s with the
-     * specified name.
-     *
-     * @param nodeName name of the child node entries that should be returned
-     * @return list of <code>NodeEntry</code> objects
+     * @see NodeEntry#getNodeEntries(QName)
-    public synchronized List getNodeEntries(QName nodeName) {
+    public synchronized List getNodeEntries(QName nodeName) throws RepositoryException {
-    public NodeEntry addNodeEntry(QName nodeName, String uniqueID, int index) {
+    public NodeEntry addNodeEntry(QName nodeName, String uniqueID, int index) throws RepositoryException {
-                                     QName primaryNodeType, QNodeDefinition definition) throws ItemExistsException {
+                                     QName primaryNodeType, QNodeDefinition definition) throws RepositoryException {
-    public void addPropertyEntries(Collection propNames) throws ItemExistsException {
+    public void addPropertyEntries(Collection propNames) throws ItemExistsException, RepositoryException {
-    public PropertyState addNewPropertyEntry(QName propName, QPropertyDefinition definition) throws ItemExistsException {
+    public PropertyState addNewPropertyEntry(QName propName, QPropertyDefinition definition)
+            throws ItemExistsException, RepositoryException {
-    public void orderBefore(NodeEntry beforeEntry) {
+    public void orderBefore(NodeEntry beforeEntry) throws RepositoryException {
-                NodeEntry cne;
-                if (uniqueChildID != null) {
-                    cne = childNodeEntries().get(eventName, uniqueChildID);
-                } else {
-                    cne = childNodeEntries().get(eventName, index);
-                }
-                if (cne == null) {
-                    internalAddNodeEntry(eventName, uniqueChildID, index, childNodeEntries());
-                } else {
-                    // child already exists -> deal with NEW entries, that were
-                    // added by some other session.
-                    // TODO: TOBEFIXED
-                }
+                if (childNodeEntries != null) {
+                    NodeEntry cne;
+                    if (uniqueChildID != null) {
+                        cne = childNodeEntries.get(eventName, uniqueChildID);
+                    } else {
+                        cne = childNodeEntries.get(eventName, index);
+                    }
+                    if (cne == null) {
+                        internalAddNodeEntry(eventName, uniqueChildID, index, childNodeEntries);
+                    } else {
+                        // child already exists -> deal with NEW entries, that were
+                        // added by some other session.
+                        // TODO: TOBEFIXED
+                    }
+                } // else: childNodeEntries not yet loaded -> ignore
-                if (child != null) {
+                if (child == null) {
+                    // prop-Entry has not been loaded yet -> add propEntry
+                    internalAddPropertyEntry(eventName);
+                } else if (child.isAvailable()) {
-                } else {
-                    // prop-Entry has not been loaded yet -> add propEntry
-                    internalAddPropertyEntry(eventName);
-                }
+                } // else: existing entry but state not yet built -> ignore event
-
-    private ChildNodeEntries childNodeEntries() {
-        if (childNodeEntries == null) {
-            loadChildNodeEntries();
-        } else if (childNodeEntries.getStatus() == ChildNodeEntries.STATUS_INVALIDATED) {
-            reloadChildNodeEntries(childNodeEntries);
-            childNodeEntries.setStatus(ChildNodeEntries.STATUS_OK);
+    private ChildNodeEntries childNodeEntries() throws InvalidItemStateException, RepositoryException {
+        try {
+            if (childNodeEntries == null) {
+                childNodeEntries = new ChildNodeEntries(this);
+                loadChildNodeEntries();
+            } else if (childNodeEntries.getStatus() == ChildNodeEntries.STATUS_INVALIDATED) {
+                reloadChildNodeEntries(childNodeEntries);
+                childNodeEntries.setStatus(ChildNodeEntries.STATUS_OK);
+            }
+        } catch (ItemNotFoundException e) {
+            log.debug("NodeEntry does not exist (anymore) -> remove.");
+            remove();
+            throw new InvalidItemStateException(e);
-    private void loadChildNodeEntries() {
-        try {
-            childNodeEntries = new ChildNodeEntries(this);
-            if (getStatus() == Status.NEW || Status.isTerminal(getStatus())) {
-                return; // cannot retrieve child-entries from persistent layer
-            }
+    private void loadChildNodeEntries() throws ItemNotFoundException, RepositoryException {
-            NodeId id = getWorkspaceId();
-            Iterator it = factory.getItemStateFactory().getChildNodeInfos(id);
-            // simply add all child entries to the empty collection
-            while (it.hasNext()) {
-                ChildInfo ci = (ChildInfo) it.next();
-                internalAddNodeEntry(ci.getName(), ci.getUniqueID(), ci.getIndex(), childNodeEntries);
-            }
-        } catch (ItemNotFoundException e) {
-            log.error("Cannot retrieve child node entries.", e);
-            // ignore (TODO correct?)
-        } catch (RepositoryException e) {
-            log.error("Cannot retrieve child node entries.", e);
-            // ignore (TODO correct?)
+        if (getStatus() == Status.NEW || Status.isTerminal(getStatus())) {
+            return; // cannot retrieve child-entries from persistent layer
+        }
+
+        NodeId id = getWorkspaceId();
+        Iterator it = factory.getItemStateFactory().getChildNodeInfos(id);
+        // simply add all child entries to the empty collection
+        while (it.hasNext()) {
+            ChildInfo ci = (ChildInfo) it.next();
+            internalAddNodeEntry(ci.getName(), ci.getUniqueID(), ci.getIndex(), childNodeEntries);
-    private void reloadChildNodeEntries(ChildNodeEntries cnEntries) {
+    private void reloadChildNodeEntries(ChildNodeEntries cnEntries) throws ItemNotFoundException, RepositoryException {
-        try {
-            NodeId id = getWorkspaceId();
-            Iterator it = factory.getItemStateFactory().getChildNodeInfos(id);
-            // create list from all ChildInfos (for multiple loop)
-            List cInfos = new ArrayList();
-            while (it.hasNext()) {
-                cInfos.add((ChildInfo) it.next());
-            }
-            // first make sure the ordering of all existing entries is ok
-            NodeEntry entry = null;
-            for (it = cInfos.iterator(); it.hasNext();) {
-                ChildInfo ci = (ChildInfo) it.next();
-                NodeEntry nextEntry = cnEntries.get(ci);
-                if (nextEntry != null) {
-                    if (entry != null) {
-                        cnEntries.reorder(entry, nextEntry);
-                    }
-                    entry = nextEntry;
+        NodeId id = getWorkspaceId();
+        Iterator it = factory.getItemStateFactory().getChildNodeInfos(id);
+        // create list from all ChildInfos (for multiple loop)
+        List cInfos = new ArrayList();
+        while (it.hasNext()) {
+            cInfos.add((ChildInfo) it.next());
+        }
+        // first make sure the ordering of all existing entries is ok
+        NodeEntry entry = null;
+        for (it = cInfos.iterator(); it.hasNext();) {
+            ChildInfo ci = (ChildInfo) it.next();
+            NodeEntry nextEntry = cnEntries.get(ci);
+            if (nextEntry != null) {
+                if (entry != null) {
+                    cnEntries.reorder(entry, nextEntry);
+                entry = nextEntry;
-            // then insert the 'new' entries
-            List newEntries = new ArrayList();
-            for (it = cInfos.iterator(); it.hasNext();) {
-                ChildInfo ci = (ChildInfo) it.next();
-                NodeEntry beforeEntry = cnEntries.get(ci);
-                if (beforeEntry == null) {
-                    NodeEntry ne = new NodeEntryImpl(this, ci.getName(), ci.getUniqueID(), factory);
-                    newEntries.add(ne);
-                } else {
-                    // insert all new entries from the list BEFORE the existing
-                    // 'nextEntry'. Then clear the list.
-                    for (int i = 0; i < newEntries.size(); i++) {
-                        cnEntries.add((NodeEntry) newEntries.get(i), beforeEntry);
-                    }
-                    newEntries.clear();
+        }
+        // then insert the 'new' entries
+        List newEntries = new ArrayList();
+        for (it = cInfos.iterator(); it.hasNext();) {
+            ChildInfo ci = (ChildInfo) it.next();
+            NodeEntry beforeEntry = cnEntries.get(ci);
+            if (beforeEntry == null) {
+                NodeEntry ne = new NodeEntryImpl(this, ci.getName(), ci.getUniqueID(), factory);
+                newEntries.add(ne);
+            } else {
+                // insert all new entries from the list BEFORE the existing
+                // 'nextEntry'. Then clear the list.
+                for (int i = 0; i < newEntries.size(); i++) {
+                    cnEntries.add((NodeEntry) newEntries.get(i), beforeEntry);
+                newEntries.clear();
-            // deal with new entries at the end
-            for (int i = 0; i < newEntries.size(); i++) {
-                cnEntries.add((NodeEntry) newEntries.get(i));
-            }
-        } catch (ItemNotFoundException e) {
-            log.error("Cannot retrieve child node entries.", e);
-            // ignore (TODO correct?)
-        } catch (RepositoryException e) {
-            log.error("Cannot retrieve child node entries.", e);
-            // ignore (TODO correct?)
+        }
+        // deal with new entries at the end
+        for (int i = 0; i < newEntries.size(); i++) {
+            cnEntries.add((NodeEntry) newEntries.get(i));
-    private int getChildIndex(NodeEntry cne) throws ItemNotFoundException {
+    private int getChildIndex(NodeEntry cne) throws ItemNotFoundException, RepositoryException {
-    private void createSiblingRevertInfos() {
+    private void createSiblingRevertInfos() throws RepositoryException {
-    private void revertTransientChanges() {
+    private void revertTransientChanges() throws RepositoryException {
-                    revertTransientChanges();
+                    try {
+                        revertTransientChanges();
+                    } catch (RepositoryException e) {
+                        log.warn("Internal error", e);
+                    }

INS8 INS8 INS43 INS43 INS43 INS43 INS43 UPD43 INS43 INS43 INS43 INS43 INS43 INS8 INS43 INS43 MOV8 INS43 INS43 MOV8 INS43 INS43 INS43 INS54 INS54 INS42 INS42 INS42 UPD65 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS54 MOV41 MOV42 MOV42 MOV42 INS42 MOV25 INS42 INS42 INS42 MOV8 INS12 MOV8 INS12 INS68 INS25 MOV8 INS12 INS44 INS8 MOV44 INS8 INS42 INS42 INS69 INS27 INS8 UPD27 INS25 MOV44 INS8 INS54 INS43 INS42 INS21 INS41 INS21 INS41 INS43 INS42 INS33 MOV60 INS25 INS25 INS32 MOV8 INS21 INS21 INS53 INS8 INS12 UPD9 INS42 INS32 INS9 INS42 INS32 INS9 INS42 MOV27 MOV8 MOV8 MOV27 MOV8 MOV8 INS42 INS42 MOV21 INS42 INS32 INS32 INS14 MOV21 MOV44 INS8 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS45 INS42 INS43 INS42 INS21 INS45 INS42 INS45 INS45 INS42 INS45 INS42 INS32 MOV42 INS42 INS42 INS45 INS42 MOV42 MOV42 DEL66 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL32 DEL32 DEL32 DEL25 DEL25 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8
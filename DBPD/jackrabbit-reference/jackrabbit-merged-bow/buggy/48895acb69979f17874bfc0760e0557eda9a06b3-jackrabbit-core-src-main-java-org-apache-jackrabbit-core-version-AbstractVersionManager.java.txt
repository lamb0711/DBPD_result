JCR-529 New versions added after a restore have bad version name


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@488639 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.List;
+
-import java.util.List;
-         * Saves the pending operations in the {@link StateManager}.
+         * Saves the pending operations in the {@link LocalItemStateManager}.
+     * @param history the version history
-            // 1. search a predecessor, suitable for generating the new name
-            Value[] values = node.getProperty(QName.JCR_PREDECESSORS).getValues();
-            InternalVersion best = null;
-            for (int i = 0; i < values.length; i++) {
-                InternalVersion pred = history.getVersion(NodeId.valueOf(values[i].getString()));
-                if (best == null || pred.getSuccessors().length < best.getSuccessors().length) {
-                    best = pred;
-                }
-            }
-
-            // 2. generate version name (assume no namespaces in version names)
-            String versionName = best.getName().getLocalName();
-            int pos = versionName.lastIndexOf('.');
-            if (pos > 0) {
-                String newVersionName = versionName.substring(0, pos + 1)
-                    + (Integer.parseInt(versionName.substring(pos + 1)) + 1);
-                if (history.hasVersion(new QName("", newVersionName))) {
-                    versionName += ".1";
-            	} else {
-                    versionName = newVersionName;
-            	}
-            } else {
-                versionName = String.valueOf(best.getSuccessors().length + 1) + ".0";
-            }
-
-            // 3. check for colliding names
-            while (history.hasVersion(new QName("", versionName))) {
-                versionName += ".1";
-            }
-
+            String versionName = calculateCheckinVersionName(history, node);
+    /**
+     * Calculates the name of the new version that will be created by a
+     * checkin call. The name is determined as follows:
+     * <ul>
+     * <li> first the predecessor version with the shortes name is searched.
+     * <li> if that predecessor version is the root version, the new version gets
+     *      the name "{number of successors}+1" + ".0"
+     * <li> if that predecessor version has no successor, the last digit of it's
+     *      version number is incremented.
+     * <li> if that predecessor version has successors but the incremented name
+     *      does not exist, that name is used.
+     * <li> otherwise a ".0" is added to the name until a non conflicting name
+     *      is found.
+     * <ul>
+     *
+     * Example Graph:
+     * <xmp>
+     * jcr:rootVersion
+     *  |     |
+     * 1.0   2.0
+     *  |
+     * 1.1
+     *  |
+     * 1.2 ---\  ------\
+     *  |      \        \
+     * 1.3   1.2.0   1.2.0.0
+     *  |      |
+     * 1.4   1.2.1 ----\
+     *  |      |        \
+     * 1.5   1.2.2   1.2.1.0
+     *  |      |        |
+     * 1.6     |     1.2.1.1
+     *  |-----/
+     * 1.7
+     * </xmp>
+     *
+     * @param history the version history
+     * @param node the node to checkin
+     * @return the new version name
+     * @throws RepositoryException if an error occurs.
+     */
+    protected String calculateCheckinVersionName(InternalVersionHistoryImpl history,
+                                                 NodeImpl node)
+            throws RepositoryException {
+        // 1. search a predecessor, suitable for generating the new name
+        Value[] values = node.getProperty(QName.JCR_PREDECESSORS).getValues();
+        InternalVersion best = null;
+        for (int i = 0; i < values.length; i++) {
+            InternalVersion pred = history.getVersion(NodeId.valueOf(values[i].getString()));
+            if (best == null
+                    || pred.getName().getLocalName().length() < best.getName().getLocalName().length()) {
+                best = pred;
+            }
+        }
+        // 2. generate version name (assume no namespaces in version names)
+        String versionName = best.getName().getLocalName();
+        int pos = versionName.lastIndexOf('.');
+        if (pos > 0) {
+            String newVersionName = versionName.substring(0, pos + 1)
+                + (Integer.parseInt(versionName.substring(pos + 1)) + 1);
+            while (history.hasVersion(new QName("", newVersionName))) {
+                versionName += ".0";
+                newVersionName = versionName;
+            }
+            return newVersionName;
+        } else {
+            // best is root version
+            return String.valueOf(best.getSuccessors().length + 1) + ".0";
+        }
+    }

MOV26 INS31 MOV29 INS83 MOV43 INS42 INS44 INS44 INS43 INS8 INS29 INS43 UPD42 MOV8 INS65 INS43 INS42 INS43 INS42 INS42 MOV60 INS54 INS65 INS65 INS65 INS65 INS65 INS42 INS42 INS66 INS42 INS42 INS8 MOV12 MOV8 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS60 MOV60 MOV21 MOV41 INS61 INS41 INS41 UPD42 INS43 INS59 MOV32 INS8 INS42 MOV27 INS42 INS42 INS32 MOV21 MOV21 INS42 INS42 INS42 INS32 INS32 INS32 INS42 INS32 INS42 UPD45 UPD42 UPD42 INS32 INS42 INS32 INS42 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 DEL32 DEL42 DEL22 DEL32 DEL42 DEL22 DEL8 DEL8 DEL25 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL43 DEL45 DEL42 DEL14 DEL32 DEL42 DEL45 DEL7 DEL21 DEL8 DEL61 DEL54 DEL8
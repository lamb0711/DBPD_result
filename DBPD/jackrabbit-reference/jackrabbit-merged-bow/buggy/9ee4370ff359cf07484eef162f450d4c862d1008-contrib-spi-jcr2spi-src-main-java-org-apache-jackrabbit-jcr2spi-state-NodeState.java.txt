SPI
- replace ChildNodeEntryImpl with new implementations
- CachingItemStateManager now uses ItemStateFactory
- WorkspaceManager implements ItemStateFactory
- Retrieving an ItemState now forces loading all ancestors by design
- NodeState does not maintain indexes of child node entries anymore. They are calculated on demand.
- ItemStateFactory methods do not require parent NodeState anymore. The parent NodeState is retrieved using an ItemStateManager. Which in turn may lead to recursive retrieval of ancestors if necessary.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@426536 13f79535-47bb-0310-9956-ffa450edef68

-    private static class ChildNodeEntries implements List, Cloneable {
+    private class ChildNodeEntries implements List, Cloneable {
-            int index = Path.INDEX_UNDEFINED;
-                index = siblings.size();
-            index++;
-            ChildNodeEntry entry = new ChildNodeEntryImpl(nodeName, id, index);
+            ChildNodeEntry entry = createChildNodeEntry(nodeName, id);
-            // update indices of subsequent same-name siblings
-            for (int i = index - 1; i < siblings.size(); i++) {
-                ChildNodeEntry oldEntry = (ChildNodeEntry) siblings.get(i);
-                ChildNodeEntry newEntry = new ChildNodeEntryImpl(nodeName, oldEntry.getId(), oldEntry.getIndex() - 1);
-                // overwrite old entry with updated entry in siblings list
-                siblings.set(i, newEntry);
-                // overwrite old entry with updated entry in ordered entries map
-                entries.put(newEntry.getId(), newEntry);
-            }
-
+        /**
+         * Creates a <code>ChildNodeEntry</code> instance based on
+         * <code>nodeName</code>, <code>id</code> and <code>index</code>.
+         *
+         * @param nodeName the name of the child node.
+         * @param id the id of the child node.
+         * @return
+         */
+        private ChildNodeEntry createChildNodeEntry(QName nodeName, NodeId id) {
+            if (id.getRelativePath() != null) {
+                return new PathElementReference(NodeState.this, nodeName, NodeState.this.idFactory);
+            } else {
+                return new UUIDReference(NodeState.this, id, nodeName);
+            }
+        }
+

INS42 INS31 INS29 INS83 MOV43 INS42 INS44 INS44 INS8 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS25 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS27 INS8 INS8 INS32 INS32 INS33 INS41 INS41 INS42 INS42 INS42 INS42 INS42 INS14 INS14 INS43 INS52 INS42 INS22 INS43 INS52 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS42 DEL83 DEL42 DEL39 DEL42 DEL40 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL37 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL14 DEL39 DEL42 DEL42 DEL34 DEL27 DEL59 DEL58 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL34 DEL27 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL24
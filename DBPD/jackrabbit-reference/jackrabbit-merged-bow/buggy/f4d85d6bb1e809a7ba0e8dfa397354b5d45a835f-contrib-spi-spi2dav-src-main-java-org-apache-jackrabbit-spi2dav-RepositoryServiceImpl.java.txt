work in progress

- ChangeLog: add target (item to be saved)
- TransientItemStateManager: changing itemstate from new to existing => needs to connect to overlayed state
- TransientISFactory move out of TransientISM
- RepositoryServiceImpl: simplify execution of wsp-operations
- Initial draft for observation
- WorkspaceManager: seperate notification of events resulting from transient modifications.
- WorkspaceManager: don't report events from wsp-operations as external mods.
- IteratorHelper; add EMPTY constant
- Event: add constant for ALL events

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@451313 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.httpclient.UsernamePasswordCredentials;
-import org.apache.commons.httpclient.HttpState;
+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;
-import org.apache.commons.collections.map.LRUMap;
+import org.apache.jackrabbit.webdav.client.methods.SubscribeMethod;
+import org.apache.jackrabbit.webdav.client.methods.UnSubscribeMethod;
+import org.apache.jackrabbit.webdav.client.methods.PollMethod;
+import org.apache.jackrabbit.webdav.DavMethods;
+import org.apache.jackrabbit.webdav.observation.EventDiscovery;
-import org.apache.jackrabbit.util.Text;
-import org.apache.jackrabbit.name.NamespaceResolver;
+import org.apache.jackrabbit.util.Text;
-import javax.jcr.SimpleCredentials;
+import java.util.HashMap;
-// TODO: improve handling of HttpClient
+
+    private static final EventType[] ALL_EVENTS = new EventType[5];
+    static {
+        ALL_EVENTS[0] = SubscriptionImpl.getEventType(javax.jcr.observation.Event.NODE_ADDED);
+        ALL_EVENTS[1] = SubscriptionImpl.getEventType(javax.jcr.observation.Event.NODE_REMOVED);
+        ALL_EVENTS[2] = SubscriptionImpl.getEventType(javax.jcr.observation.Event.PROPERTY_ADDED);
+        ALL_EVENTS[3] = SubscriptionImpl.getEventType(javax.jcr.observation.Event.PROPERTY_CHANGED);
+        ALL_EVENTS[4] = SubscriptionImpl.getEventType(javax.jcr.observation.Event.PROPERTY_REMOVED);
+    }
+    private static final SubscriptionInfo S_INFO = new SubscriptionInfo(ALL_EVENTS, true, DavConstants.INFINITE_TIMEOUT);
+
+    private static long POLL_INTERVAL = 30000;  // TODO: make configurable
+
-    private final HostConfiguration hostConfig;
-    // remember most frequently used http clients
-    private final Map clientCache = Collections.synchronizedMap(new LRUMap());
+    private final HttpClient client;
+            domFactory = DomUtil.BUILDER_FACTORY.newDocumentBuilder().newDocument();
+        } catch (ParserConfigurationException e) {
+            throw new RepositoryException(e);
+        }
+
+        try {
-            hostConfig = new HostConfiguration();
+            HostConfiguration hostConfig = new HostConfiguration();
-            domFactory = DomUtil.BUILDER_FACTORY.newDocumentBuilder().newDocument();
+            client = new HttpClient(new MultiThreadedHttpConnectionManager());
+            client.setHostConfiguration(hostConfig);
+            // always send authentication not waiting for 401
+            client.getParams().setAuthenticationPreemptive(true);
-        } catch (ParserConfigurationException e) {
-            throw new RepositoryException(e);
-    private HttpClient getClient(Credentials credentials) {
-        if (clientCache.containsKey(credentials)) {
-            return (HttpClient) clientCache.get(credentials);
-        } else {
-            HttpClient client = new HttpClient();
-            client.setHostConfiguration(hostConfig);
-            UsernamePasswordCredentials creds;
-            if (credentials == null) {
-                // NOTE: null credentials only work if 'missing-auth-mapping' param is set on the server
-                creds = null;
-            } else if (credentials instanceof SimpleCredentials) {
-                SimpleCredentials sCred = (SimpleCredentials) credentials;
-                creds = new UsernamePasswordCredentials(sCred.getUserID(),
-                    String.valueOf(sCred.getPassword()));
-            } else {
-                creds = new UsernamePasswordCredentials(credentials.toString());
-            }
-            HttpState httpState = client.getState();
-
-            // set authentication scope and credentials
-            AuthScope authscope = new AuthScope(hostConfig.getHost(), hostConfig.getPort());
-            httpState.setCredentials(authscope, creds);
-
-            // always send authentication not waiting for 401
-            client.getParams().setAuthenticationPreemptive(true);
-
-            clientCache.put(credentials, client);
-            return client;
+    private static void checkSessionInfo(SessionInfo sessionInfo) throws RepositoryException {
+        if (!(sessionInfo instanceof SessionInfoImpl)) {
+            throw new RepositoryException("Unknown SessionInfo implementation.");
-    HttpClient getClient(SessionInfo sessionInfo) {
-        Credentials credentials = null;
-        if (sessionInfo instanceof SessionInfoImpl) {
-            credentials = ((SessionInfoImpl) sessionInfo).getCredentials();
-        } else {
-            log.warn("Unexpected SessionInfo implementation. Using 'null' credentials for connection.");
-        }
-        return getClient(credentials);
+    private static boolean isLockMethod(DavMethod method) {
+        int code = DavMethods.getMethodCode(method.getName());
+        return DavMethods.DAV_LOCK == code || DavMethods.DAV_UNLOCK == code;
-        if (sessionInfo instanceof SessionInfoImpl) {
-            String txId = ((SessionInfoImpl) sessionInfo).getBatchId();
-            if (txId != null) {
-                CodedUrlHeader ch = new CodedUrlHeader(TransactionConstants.HEADER_TRANSACTIONID, txId);
-                method.setRequestHeader(ch.getHeaderName(), ch.getHeaderValue());
-            }
-        }
-    private URIResolver getURIResolver() {
-        return uriResolver;
+    private HttpClient getClient(org.apache.commons.httpclient.Credentials credentials) {
+        // NOTE: null credentials only work if 'missing-auth-mapping' param is
+        // set on the server
+        client.getState().setCredentials(AuthScope.ANY, credentials);
+        return client;
-    private NamespaceResolver getNamespaceResolver() {
-        return nsResolver;
-    }
-
-    private String getRepositoryUri() {
-        return uriResolver.getRepositoryUri();
-    }
-
-    private String getWorkspaceUri(String workspaceName) {
-        return uriResolver.getWorkspaceUri(workspaceName);
-    }
-
-    private String getRootItemUri(String workspaceName) {
-        return uriResolver.getRootItemUri(workspaceName);
+    HttpClient getClient(SessionInfo sessionInfo) throws RepositoryException {
+        checkSessionInfo(sessionInfo);
+        return getClient(((SessionInfoImpl) sessionInfo).getCredentials().getCredentials());
-    private String getItemUri(ItemId itemId, String workspaceName, SessionInfo sessionInfo) throws RepositoryException {
-        return uriResolver.getItemUri(itemId, workspaceName, sessionInfo);
-    }
-
-            return parentUri + NameFormat.format(childName, getNamespaceResolver());
+            return parentUri + NameFormat.format(childName, nsResolver);
-                parentId = getURIResolver().getNodeId(parentHref, sessionInfo);
+                parentId = uriResolver.getNodeId(parentHref, sessionInfo);
-    private EventIterator retrieveEvents() {
-        // todo
-        return null;
+    /**
+     * Execute a 'Workspace' operation that immediately needs to return events.
+     *
+     * @param method
+     * @param sessionInfo
+     * @return
+     * @throws RepositoryException
+     */
+    private EventIterator execute(DavMethod method, SessionInfo sessionInfo) throws RepositoryException {
+        // TODO: build specific subscrUri
+        // TODO: check if 'all event' subscription is ok
+        String subscrUri = uriResolver.getRootItemUri(sessionInfo.getWorkspaceName());
+        String subscrId = subscribe(subscrUri, S_INFO, null, sessionInfo);
+        try {
+            if (isLockMethod(method)) {
+                initMethod(method, sessionInfo, false);
+            } else {
+                initMethod(method, sessionInfo, true);
+            }
+            getClient(sessionInfo).executeMethod(method);
+            method.checkSuccess();
+
+            EventIterator events = poll(subscrUri, subscrId, sessionInfo);
+            return events;
+        } catch (IOException e) {
+            throw new RepositoryException(e);
+        } catch (DavException e) {
+            throw ExceptionConverter.generate(e);
+        } finally {
+            if (method != null) {
+                method.releaseConnection();
+            }
+            unsubscribe(subscrUri, subscrId, sessionInfo);
+        }
-            method = new ReportMethod(getRepositoryUri(), info);
+            method = new ReportMethod(uriResolver.getRepositoryUri(), info);
-            getClient((Credentials) null).executeMethod(method);
+            getClient((org.apache.commons.httpclient.Credentials) null).executeMethod(method);
-        if (credentials == null) {
-            // no credentials provided, use JAAS
-            throw new RepositoryException("JAAS authentication not implemented");
-        }
-
-        // interested in workspace href property only, which allows to retrieve the
-        // name of the workspace in case 'workspaceName' is 'null'.
-        DavPropertyNameSet nameSet = new DavPropertyNameSet();
-        nameSet.add(DeltaVConstants.WORKSPACE);
+        // check if the workspace with the given name is accessible
-            method = new PropFindMethod(getWorkspaceUri(workspaceName), nameSet, DavConstants.DEPTH_0);
-            getClient(credentials).executeMethod(method);
+            DavPropertyNameSet nameSet = new DavPropertyNameSet();
+            nameSet.add(DeltaVConstants.WORKSPACE);
+            method = new PropFindMethod(uriResolver.getWorkspaceUri(workspaceName), nameSet, DavConstants.DEPTH_0);
+            CredentialsWrapper dc = new CredentialsWrapper(credentials);
+            getClient(dc.getCredentials()).executeMethod(method);
+
-                throw new RepositoryException("Unable to retrieve default workspace name.");
+                throw new LoginException("Login failed: Unknown workspace '" + workspaceName+ " '.");
+
-                String wspName = Text.getName(wspHref, true);
-                return new SessionInfoImpl(credentials, wspName);
+                String wspName = Text.unescape(Text.getName(wspHref, true));
+                if (!wspName.equals(workspaceName)) {
+                    throw new LoginException("Login failed: Invalid workspace name " + workspaceName);
+                }
+                return new SessionInfoImpl(dc, workspaceName, new SubscriptionMgrImpl());
-                throw new RepositoryException("Unable to retrieve default workspace name.");
+                throw new LoginException("Login failed: Unknown workspace '" + workspaceName+ " '.");
-            method = new PropFindMethod(getRepositoryUri(), nameSet, DEPTH_1);
+            method = new PropFindMethod(uriResolver.getRepositoryUri(), nameSet, DEPTH_1);
-            method = new ReportMethod(getWorkspaceUri(sessionInfo.getWorkspaceName()), reportInfo);
+            method = new ReportMethod(uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName()), reportInfo);
-        String rootUri = getRootItemUri(sessionInfo.getWorkspaceName());
-        return getURIResolver().getNodeId(rootUri, sessionInfo);
+        String rootUri = uriResolver.getRootItemUri(sessionInfo.getWorkspaceName());
+        return uriResolver.getNodeId(rootUri, sessionInfo);
-                throw new ItemNotFoundException("Unable to retrieve the item with id " + itemId);
+                throw new ItemNotFoundException("Unable to retrieve the item definition for " + itemId);
-            // todo: make sure the server only sent a single response...
-            // todo: make sure the resourcetype matches the itemId type
-            QItemDefinition definition = null;
+            if (responses.length > 1) {
+                throw new RepositoryException("Internal error: ambigous item definition found '" + itemId + "'.");
+            }
+
+            // check if definition matches the type of the id
+            DavProperty rType = propertySet.get(DavPropertyName.RESOURCETYPE);
+            if (rType.getValue() == null && itemId.denotesNode()) {
+                throw new RepositoryException("Internal error: requested node definition and got property definition.");
+            }
+
+            // build the definition
+            QItemDefinition definition = null;
-                        definition = new QNodeDefinitionImpl(null, idfElem, getNamespaceResolver());
+                        definition = new QNodeDefinitionImpl(null, idfElem, nsResolver);
-                        definition = new QPropertyDefinitionImpl(null, idfElem, getNamespaceResolver());
+                        definition = new QPropertyDefinitionImpl(null, idfElem, nsResolver);
-            NodeInfoImpl nInfo = new NodeInfoImpl(id, parentId, propSet, getNamespaceResolver());
+            NodeInfoImpl nInfo = new NodeInfoImpl(id, parentId, propSet, nsResolver);
-                    PropertyId propertyId = getURIResolver().getPropertyId(propertyHref, sessionInfo);
+                    PropertyId propertyId = uriResolver.getPropertyId(propertyHref, sessionInfo);
-                //method.releaseConnection();
+                method.releaseConnection();
-            PropertyInfo pInfo = new PropertyInfoImpl(id, parentId, propSet, getNamespaceResolver(), valueFactory);
+            PropertyInfo pInfo = new PropertyInfoImpl(id, parentId, propSet, nsResolver, valueFactory);
-     * @see RepositoryService#createBatch(SessionInfo)
+     * @see RepositoryService#createBatch(ItemId, SessionInfo)
-    public Batch createBatch(SessionInfo sessionInfo) throws RepositoryException {
-        if (sessionInfo instanceof SessionInfoImpl) {
-            return new BatchImpl((SessionInfoImpl)sessionInfo);
-        } else {
-            throw new RepositoryException("Unknown SessionInfo implementation.");
-        }
+    public Batch createBatch(ItemId itemId, SessionInfo sessionInfo) throws RepositoryException {
+        return new BatchImpl(itemId, sessionInfo);
-            // TODO build empty eventIterator
-            return null;
+            return IteratorHelper.EMPTY;
+            EventIterator events;
+                    // add batchId as separate header
+                    CodedUrlHeader ch = new CodedUrlHeader(TransactionConstants.HEADER_TRANSACTIONID, batchImpl.batchId);
+                    method.setRequestHeader(ch.getHeaderName(), ch.getHeaderValue());
-                    if (!(success = method.succeeded())) {
-                        throw method.getResponseException();
-                    }
+                    method.checkSuccess();
+                success = true;
-                batchImpl.end(client, success);
+                events = batchImpl.end(client, success);
-            return retrieveEvents();
+            return events;
-        MkColMethod method = null;
-        try {
-            // TODO: improve. currently random name is built instead of retrieving name of new resource from top-level xml element within stream
-            QName nodeName = new QName(QName.NS_DEFAULT_URI, UUID.randomUUID().toString());
-            String uri = getItemUri(parentId, nodeName, sessionInfo);
-            method = new MkColMethod(uri);
-            initMethod(method, sessionInfo, true);
-            method.setRequestEntity(new InputStreamRequestEntity(xmlStream, "text/xml"));
+        // TODO: improve. currently random name is built instead of retrieving name of new resource from top-level xml element within stream
+        QName nodeName = new QName(QName.NS_DEFAULT_URI, UUID.randomUUID().toString());
+        String uri = getItemUri(parentId, nodeName, sessionInfo);
+        MkColMethod method = new MkColMethod(uri);
+        method.setRequestEntity(new InputStreamRequestEntity(xmlStream, "text/xml"));
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
-
-            return retrieveEvents();
-        } catch (IOException e) {
-            throw new RepositoryException(e);
-        } catch (DavException e) {
-            throw ExceptionConverter.generate(e);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        }
+        return execute(method, sessionInfo);
-        MoveMethod method = null;
-        try {
-            String uri = getItemUri(srcNodeId, sessionInfo);
-            String destUri = getItemUri(destParentNodeId, destName, sessionInfo);
-            method = new MoveMethod(uri, destUri, true);
-            initMethod(method, sessionInfo, true);
-
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
-
-            return retrieveEvents();
-        } catch (IOException e) {
-            throw new RepositoryException(e);
-        } catch (DavException e) {
-            throw ExceptionConverter.generate(e);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        }
+        String uri = getItemUri(srcNodeId, sessionInfo);
+        String destUri = getItemUri(destParentNodeId, destName, sessionInfo);
+        MoveMethod method = new MoveMethod(uri, destUri, true);
+        return execute(method, sessionInfo);
-        CopyMethod method = null;
-        try {
-            String uri = getItemUri(srcNodeId, srcWorkspaceName, sessionInfo);
-            String destUri = getItemUri(destParentNodeId, destName, sessionInfo);
-            method = new CopyMethod(uri, destUri, true, false);
-            initMethod(method, sessionInfo, true);
-
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
-
-            return retrieveEvents();
-        } catch (IOException e) {
-            throw new RepositoryException(e);
-        } catch (DavException e) {
-            throw ExceptionConverter.generate(e);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        }
+        String uri = uriResolver.getItemUri(srcNodeId, srcWorkspaceName, sessionInfo);
+        String destUri = getItemUri(destParentNodeId, destName, sessionInfo);
+        CopyMethod method = new CopyMethod(uri, destUri, true, false);
+        return execute(method, sessionInfo);
-        String workspUri = getWorkspaceUri(srcWorkspaceName);
+        String workspUri = uriResolver.getWorkspaceUri(srcWorkspaceName);
-        return null;
+        throw new UnsupportedOperationException("Missing implementation");
-        LockMethod method = null;
-            method = new LockMethod(uri, Scope.EXCLUSIVE, Type.WRITE, null, DavConstants.INFINITE_TIMEOUT, true);
-            initMethod(method, sessionInfo, false);
-
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
+            LockMethod method = new LockMethod(uri, Scope.EXCLUSIVE, Type.WRITE, null, DavConstants.INFINITE_TIMEOUT, true);
+            EventIterator events = execute(method, sessionInfo);
+            return events;
-            return retrieveEvents();
-        } catch (DavException e) {
-            throw ExceptionConverter.generate(e);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        LockMethod method = null;
-        try {
-            String uri = getItemUri(nodeId, sessionInfo);
-            // since sessionInfo does not allow to retrieve token by NodeId,
-            // pass all available lock tokens to the LOCK method (TODO: correct?)
-            method = new LockMethod(uri, DavConstants.INFINITE_TIMEOUT, sessionInfo.getLockTokens());
-            initMethod(method, sessionInfo, false);
-
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
-
-            return retrieveEvents();
-        } catch (IOException e) {
-            throw new RepositoryException(e);
-        } catch (DavException e) {
-            throw ExceptionConverter.generate(e);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        }
+        String uri = getItemUri(nodeId, sessionInfo);
+        // since sessionInfo does not allow to retrieve token by NodeId,
+        // pass all available lock tokens to the LOCK method (TODO: correct?)
+        LockMethod method = new LockMethod(uri, DavConstants.INFINITE_TIMEOUT, sessionInfo.getLockTokens());
+        return execute(method, sessionInfo);
-        UnLockMethod method = null;
-        try {
-            String uri = getItemUri(nodeId, sessionInfo);
-            // Note: since sessionInfo does not allow to identify the id of the
-            // lock holding node, we need to access the token via lockInfo
-            // TODO: review this.
-            LockInfo lInfo = getLockInfo(sessionInfo, nodeId);
-            String lockToken = lInfo.getLockToken();
+        String uri = getItemUri(nodeId, sessionInfo);
+        // Note: since sessionInfo does not allow to identify the id of the
+        // lock holding node, we need to access the token via lockInfo
+        // TODO: review this.
+        LockInfo lInfo = getLockInfo(sessionInfo, nodeId);
+        String lockToken = lInfo.getLockToken();
-            // TODO: ev. additional check if lt is present on the sessionInfo?
+        // TODO: ev. additional check if lt is present on the sessionInfo?
-            method = new UnLockMethod(uri, lockToken);
-            initMethod(method, sessionInfo, false);
+        UnLockMethod method = new UnLockMethod(uri, lockToken);
+        EventIterator events = execute(method, sessionInfo);
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
-
-            sessionInfo.removeLockToken(lockToken);
-
-            return retrieveEvents();
-        } catch (IOException e) {
-            throw new RepositoryException(e);
-        } catch (DavException e) {
-            throw ExceptionConverter.generate(e);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        }
+        sessionInfo.removeLockToken(lockToken);
+        return events;
-        CheckinMethod method = null;
-        try {
-            String uri = getItemUri(nodeId, sessionInfo);
-            method = new CheckinMethod(uri);
-            initMethod(method, sessionInfo, true);
+        String uri = getItemUri(nodeId, sessionInfo);
+        CheckinMethod method = new CheckinMethod(uri);
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
-
-            return retrieveEvents();
-        } catch (IOException e) {
-            throw new RepositoryException(e);
-        } catch (DavException e) {
-            throw ExceptionConverter.generate(e);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        }
+        return execute(method, sessionInfo);
-        CheckoutMethod method = null;
-        try {
-            String uri = getItemUri(nodeId, sessionInfo);
-            method = new CheckoutMethod(uri);
-            initMethod(method, sessionInfo, true);
+        String uri = getItemUri(nodeId, sessionInfo);
+        CheckoutMethod method = new CheckoutMethod(uri);
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
-
-            return retrieveEvents();
-        } catch (IOException e) {
-            throw new RepositoryException(e);
-        } catch (DavException e) {
-            throw ExceptionConverter.generate(e);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        }
+        return execute(method, sessionInfo);
-        String uri = getWorkspaceUri(sessionInfo.getWorkspaceName());
+        String uri = uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName());
-        UpdateMethod method = null;
-            method = new UpdateMethod(uri, uInfo);
-            initMethod(method, sessionInfo, true);
-
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
-
-            return retrieveEvents();
+            UpdateMethod method = new UpdateMethod(uri, uInfo);
+            return execute(method, sessionInfo);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        MergeMethod method = null;
-            String wspHref = getWorkspaceUri(srcWorkspaceName);
+            String wspHref = uriResolver.getWorkspaceUri(srcWorkspaceName);
-            method = new MergeMethod(getItemUri(nodeId, sessionInfo), mInfo);
-            initMethod(method, sessionInfo, true);
-
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
-
+            MergeMethod method = new MergeMethod(getItemUri(nodeId, sessionInfo), mInfo);
-            return retrieveEvents();
+            return execute(method, sessionInfo);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        PropPatchMethod method = null;
-            method = new PropPatchMethod(getItemUri(nodeId, sessionInfo), changeList);
-            initMethod(method, sessionInfo, true);
-
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
-
+            PropPatchMethod method = new PropPatchMethod(getItemUri(nodeId, sessionInfo), changeList);
-            return retrieveEvents();
+            return execute(method, sessionInfo);
-        } catch (DavException e) {
-            throw ExceptionConverter.generate(e);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        LabelMethod method = null;
-        try {
+         try {
-            method = new LabelMethod(uri, NameFormat.format(label, getNamespaceResolver()), (moveLabel) ? LabelInfo.TYPE_SET : LabelInfo.TYPE_ADD);
-            initMethod(method, sessionInfo, true);
-
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
-
-            return retrieveEvents();
+            LabelMethod method = new LabelMethod(uri, NameFormat.format(label, nsResolver), (moveLabel) ? LabelInfo.TYPE_SET : LabelInfo.TYPE_ADD);
+            return execute(method, sessionInfo);
-        } catch (DavException e) {
-            throw ExceptionConverter.generate(e);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        LabelMethod method = null;
-            method = new LabelMethod(uri, NameFormat.format(label, getNamespaceResolver()), LabelInfo.TYPE_REMOVE);
-            initMethod(method, sessionInfo, true);
-
-            getClient(sessionInfo).executeMethod(method);
-            method.checkSuccess();
-
-            return retrieveEvents();
+            LabelMethod method = new LabelMethod(uri, NameFormat.format(label, nsResolver), LabelInfo.TYPE_REMOVE);
+            return execute(method, sessionInfo);
-        } catch (DavException e) {
-            throw ExceptionConverter.generate(e);
-        } finally {
-            if (method != null) {
-                method.releaseConnection();
-            }
-        OptionsMethod method = new OptionsMethod(getWorkspaceUri(sessionInfo.getWorkspaceName()));
+        OptionsMethod method = new OptionsMethod(uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName()));
+        } finally {
+            if (method != null) {
+                method.releaseConnection();
+            }
+        SearchMethod method = null;
-            SearchMethod method = new SearchMethod(getWorkspaceUri(sessionInfo.getWorkspaceName()), statement, language);
+            String uri = uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName());
+            method = new SearchMethod(uri, statement, language);
-            return new QueryInfoImpl(ms, sessionInfo, getURIResolver(),
-                getNamespaceResolver(), valueFactory);
+            return new QueryInfoImpl(ms, sessionInfo, uriResolver,
+                nsResolver, valueFactory);
+        }  finally {
+            if (method != null) {
+                method.releaseConnection();
+            }
-     * @see RepositoryService#addEventListener(SessionInfo, NodeId, EventListener, int, boolean, String[], QName[])
+     * @see RepositoryService#addEventListener(SessionInfo,NodeId,EventListener,int,boolean,String[],QName[])
-        for (int i = 0; i < uuids.length; i++) {
+        for (int i = 0; uuids != null && i < uuids.length; i++) {
-        for (int i = 0; i < nodeTypeIds.length; i++) {
+        for (int i = 0; nodeTypeIds != null && i < nodeTypeIds.length; i++) {
-                String ntName = NameFormat.format(nodeTypeIds[i], getNamespaceResolver());
+                String ntName = NameFormat.format(nodeTypeIds[i], nsResolver);
-        // always 'noLocal' since local changes are reported by return values
+
-
+        String uri = getItemUri(nodeId, sessionInfo);
-        // TODO: missing implementation
+        checkSessionInfo(sessionInfo);
+        SubscriptionManager sMgr = ((SessionInfoImpl)sessionInfo).getSubscriptionManager();
+
+        if (sMgr.subscriptionExists(listener)) {
+            String subscriptionId = sMgr.getSubscriptionId(listener);
+            subscribe(uri, subscriptionInfo, subscriptionId, sessionInfo);
+            log.debug("Subscribed on server for listener " + listener);
+        } else {
+            String subscriptionId = subscribe(uri, subscriptionInfo, null, sessionInfo);
+            log.debug("Subscribed on server for listener " + listener);
+            sMgr.addSubscription(uri, subscriptionId, listener);
+            log.debug("Added subscription for listener " + listener);
+        }
-        // TODO: missing implementation
+        checkSessionInfo(sessionInfo);
+        SubscriptionManager sMgr = ((SessionInfoImpl)sessionInfo).getSubscriptionManager();
+        String subscriptionId = sMgr.getSubscriptionId(listener);
+
+        String uri = getItemUri(nodeId, sessionInfo);
+        sMgr.removeSubscription(listener);
+        log.debug("Removed subscription for listener " + listener);
+        unsubscribe(uri, subscriptionId, sessionInfo);
+        log.debug("Unsubscribed on server for listener " + listener);
+    }
+
+
+    private String subscribe(String uri, SubscriptionInfo subscriptionInfo, String subscriptionId, SessionInfo sessionInfo) throws RepositoryException {
+        SubscribeMethod method = null;
+        try {
+            if (subscriptionId != null) {
+                method = new SubscribeMethod(uri, subscriptionInfo, subscriptionId);
+            } else {
+                method = new SubscribeMethod(uri, subscriptionInfo);
+            }
+            getClient(sessionInfo).executeMethod(method);
+            method.checkSuccess();
+            return method.getSubscriptionId();
+        } catch (IOException e) {
+            throw new RepositoryException(e);
+        } catch (DavException e) {
+            throw ExceptionConverter.generate(e);
+        }  finally {
+            if (method != null) {
+                method.releaseConnection();
+            }
+        }
+    }
+
+    private void unsubscribe(String uri, String subscriptionId, SessionInfo sessionInfo) throws RepositoryException {
+        UnSubscribeMethod method = null;
+        try {
+            method = new UnSubscribeMethod(uri, subscriptionId);
+            getClient(sessionInfo).executeMethod(method);
+            method.checkSuccess();
+        } catch (IOException e) {
+            throw new RepositoryException(e);
+        } catch (DavException e) {
+            throw ExceptionConverter.generate(e);
+        }  finally {
+            if (method != null) {
+                method.releaseConnection();
+            }
+        }
+    }
+
+    private EventIterator poll(String uri, String subscriptionId,  SessionInfo sessionInfo) throws RepositoryException {
+        PollMethod method = null;
+        try {
+            method = new PollMethod(uri, subscriptionId);
+            getClient(sessionInfo).executeMethod(method);
+            method.checkSuccess();
+
+            EventDiscovery disc = method.getResponseAsEventDiscovery();
+            if (disc.isEmpty()) {
+                return IteratorHelper.EMPTY;
+            } else {
+                Element discEl = disc.toXml(domFactory);
+                return new EventIteratorImpl(discEl, uriResolver, sessionInfo);
+            }
+        } catch (IOException e) {
+            throw new RepositoryException(e);
+        } catch (DavException e) {
+            throw ExceptionConverter.generate(e);
+        }  finally {
+            if (method != null) {
+                method.releaseConnection();
+            }
+        }
-            method = new ReportMethod(getWorkspaceUri(sessionInfo.getWorkspaceName()), info);
+            method = new ReportMethod(uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName()), info);
-            String uri = getWorkspaceUri(sessionInfo.getWorkspaceName());
+            String uri = uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName());
-            method = new ReportMethod(getWorkspaceUri(sessionInfo.getWorkspaceName()), info);
+            String workspaceUri = uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName());
+            method = new ReportMethod(workspaceUri, info);
-                ntDefs.add(new QNodeTypeDefinitionImpl(it.nextElement(), getNamespaceResolver()));
+                ntDefs.add(new QNodeTypeDefinitionImpl(it.nextElement(), nsResolver));
+    /**
+     * The XML elements and attributes used in serialization
+     */
+    private static final Namespace SV_NAMESPACE = Namespace.getNamespace(QName.NS_SV_PREFIX, QName.NS_SV_URI);
+    private static final String NODE_ELEMENT = "node";
+    private static final String PROPERTY_ELEMENT = "property";
+    private static final String VALUE_ELEMENT = "value";
+    private static final String NAME_ATTRIBUTE = "name";
+    private static final String TYPE_ATTRIBUTE = "type";
+
-        private final SessionInfoImpl sessionInfo;
+        private final SessionInfo sessionInfo;
+        private final ItemId targetId;
+        private String batchId;
+        private String subscriptionId;
+
-        private BatchImpl(SessionInfoImpl sessionInfo) {
+        private BatchImpl(ItemId targetId, SessionInfo sessionInfo) {
+            this.targetId = targetId;
-                String uri = getRootItemUri(sessionInfo.getWorkspaceName());
+                String uri = getItemUri(targetId, sessionInfo);
+                // start special 'lock'
-                String batchId = method.getLockToken();
-                sessionInfo.setBatchId(batchId);
+                batchId = method.getLockToken();
+
+                // register subscription
+                String subscrUri = (targetId.denotesNode() ? uri : getItemUri(((PropertyId) targetId).getParentId(), sessionInfo));
+                subscriptionId = subscribe(subscrUri, S_INFO, null, sessionInfo);
-        private void end(HttpClient client, boolean discard) throws RepositoryException {
+        private EventIterator end(HttpClient client, boolean commit) throws RepositoryException {
-                String uri = getRootItemUri(sessionInfo.getWorkspaceName());
-                UnLockMethod method = new UnLockMethod(uri, sessionInfo.getBatchId());
+                String uri = getItemUri(targetId, sessionInfo);
+                UnLockMethod method = new UnLockMethod(uri, batchId);
-                method.setRequestBody(new TransactionInfo(!discard));
+                method.setRequestBody(new TransactionInfo(commit));
-                // make sure the batchId on the sessionInfo is reset.
-                sessionInfo.setBatchId(null);
+
+                // retrieve events && unsubscribe
+                String subscrUri = (targetId.denotesNode() ? uri : getItemUri(((PropertyId) targetId).getParentId(), sessionInfo));
+                EventIterator events = poll(subscrUri, subscriptionId, sessionInfo);
+                unsubscribe(subscrUri, subscriptionId, sessionInfo);
+
+                return events;
-         * The XML elements and attributes used in serialization
-         */
-        private final Namespace SV_NAMESPACE = Namespace.getNamespace(QName.NS_SV_PREFIX, QName.NS_SV_URI);
-        private final String NODE_ELEMENT = "node";
-        private final String PROPERTY_ELEMENT = "property";
-        private final String VALUE_ELEMENT = "value";
-        private final String NAME_ATTRIBUTE = "name";
-        private final String TYPE_ATTRIBUTE = "type";
-
-        /**
-                        DomUtil.setAttribute(propElement, NAME_ATTRIBUTE, SV_NAMESPACE, NameFormat.format(QName.JCR_PRIMARYTYPE, getNamespaceResolver()));
+                        DomUtil.setAttribute(propElement, NAME_ATTRIBUTE, SV_NAMESPACE, NameFormat.format(QName.JCR_PRIMARYTYPE, nsResolver));
-                        DomUtil.addChildElement(propElement, VALUE_ELEMENT, SV_NAMESPACE, NameFormat.format(nodetypeName, getNamespaceResolver()));
+                        DomUtil.addChildElement(propElement, VALUE_ELEMENT, SV_NAMESPACE, NameFormat.format(nodetypeName, nsResolver));
-                        DomUtil.setAttribute(propElement, NAME_ATTRIBUTE, SV_NAMESPACE, NameFormat.format(QName.JCR_UUID, getNamespaceResolver()));
+                        DomUtil.setAttribute(propElement, NAME_ATTRIBUTE, SV_NAMESPACE, NameFormat.format(QName.JCR_UUID, nsResolver));
-            Value jcrValue = ValueFormat.getJCRValue(qV, getNamespaceResolver(), valueFactory);
+            Value jcrValue = ValueFormat.getJCRValue(qV, nsResolver, valueFactory);
-                jcrValues[i] = ValueFormat.getJCRValue(v, getNamespaceResolver(), valueFactory);
+                jcrValues[i] = ValueFormat.getJCRValue(v, nsResolver, valueFactory);
-                Value jcrValue = ValueFormat.getJCRValue(qV, getNamespaceResolver(), valueFactory);
+                Value jcrValue = ValueFormat.getJCRValue(qV, nsResolver, valueFactory);
-                    jcrValues[i] = ValueFormat.getJCRValue(qV, getNamespaceResolver(), valueFactory);
+                    jcrValues[i] = ValueFormat.getJCRValue(qV, nsResolver, valueFactory);
-                Value jcrValue = ValueFormat.getJCRValue(qV, getNamespaceResolver(), valueFactory);
+                Value jcrValue = ValueFormat.getJCRValue(qV, nsResolver, valueFactory);
-                    jcrValues[i] = ValueFormat.getJCRValue(qV, getNamespaceResolver(), valueFactory);
+                    jcrValues[i] = ValueFormat.getJCRValue(qV, nsResolver, valueFactory);
-                    Value jcrValue = ValueFormat.getJCRValue(qV, getNamespaceResolver(), valueFactory);
+                    Value jcrValue = ValueFormat.getJCRValue(qV, nsResolver, valueFactory);
-                        jcrValues[i] = ValueFormat.getJCRValue(qV, getNamespaceResolver(), valueFactory);
+                        jcrValues[i] = ValueFormat.getJCRValue(qV, nsResolver, valueFactory);
-                        ntNames[i] = NameFormat.format(mixinNodeTypeIds[i], getNamespaceResolver());
+                        ntNames[i] = NameFormat.format(mixinNodeTypeIds[i], nsResolver);
+
+    /**
+     * <code>SubscriptionManager</code>...
+     */
+    private class SubscriptionMgrImpl implements SubscriptionManager {
+
+        private SessionInfo sessionInfo;
+
+        private final Map subscriptions = new HashMap();
+        private final Object subscriptionsLock = new Object();
+        private Map currentSubscriptions;
+
+        private Thread t;
+
+        public void setSessionInfo(SessionInfo sessionInfo) {
+            this.sessionInfo = sessionInfo;
+        }
+
+        public boolean subscriptionExists(EventListener listener) {
+            return getSubscriptions().containsKey(listener);
+        }
+
+        public String getSubscriptionId(EventListener listener) {
+            if (getSubscriptions().containsKey(listener)) {
+                return ((String[]) getSubscriptions().get(listener))[1];
+            } else {
+                return null;
+            }
+        }
+
+        public void addSubscription(String uri, String subscriptionId, EventListener listener) {
+            synchronized (subscriptionsLock) {
+                boolean doStart = subscriptions.isEmpty();
+                subscriptions.put(listener, new String[] {uri,subscriptionId});
+                currentSubscriptions = null;
+                if (doStart) {
+                    startPolling();
+                }
+            }
+        }
+
+        public synchronized void removeSubscription(EventListener listener) {
+            synchronized (subscriptionsLock) {
+                subscriptions.remove(listener);
+                currentSubscriptions = null;
+                if (subscriptions.isEmpty()) {
+                    stopPolling();
+                }
+            }
+        }
+
+        private Map getSubscriptions() {
+            synchronized (subscriptionsLock) {
+                if (currentSubscriptions == null) {
+                    currentSubscriptions = Collections.unmodifiableMap(new HashMap(subscriptions));
+                }
+                return currentSubscriptions;
+            }
+        }
+
+        private void startPolling() {
+            Runnable r = new Runnable() {
+                public void run() {
+                    while (t == Thread.currentThread()) {
+                        try {
+                            // sleep
+                            Thread.sleep(POLL_INTERVAL);
+                            // poll
+                            Iterator lstnIterator = getSubscriptions().keySet().iterator();
+                            while (lstnIterator.hasNext()) {
+                                EventListener listener = (EventListener) lstnIterator.next();
+                                String[] value = (String[]) getSubscriptions().get(listener);
+                                String uri = value[0];
+                                String subscriptionId = value[1];
+                                EventIterator eventIterator = poll(uri, subscriptionId, sessionInfo);
+                                listener.onEvent(eventIterator);
+                            }
+                        } catch (InterruptedException e) {
+                            log.debug("Polling thread interrupted: " + e.getMessage());
+                            return;
+                        } catch (RepositoryException e) {
+                            log.warn("Polling failed: ", e.getMessage());
+                        }
+                    }
+                }
+            };
+            t = new Thread(r);
+            t.start();
+        }
+
+        private void stopPolling() {
+            t.interrupt();
+        }
+    }

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 MOV23 MOV23 UPD40 UPD40 INS40 UPD40 UPD40 INS40 UPD40 INS28 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 MOV23 MOV23 MOV23 MOV23 MOV23 MOV23 INS55 INS83 INS5 INS83 INS8 INS83 INS43 INS59 INS83 INS83 INS39 INS59 INS83 INS83 MOV43 INS59 INS83 INS83 INS39 INS42 MOV44 MOV43 INS8 INS83 INS83 INS39 INS42 MOV44 INS8 INS83 MOV43 INS42 INS44 INS8 MOV43 INS42 MOV44 INS43 MOV8 INS29 INS83 INS43 INS42 INS44 MOV44 MOV43 INS8 MOV29 INS83 MOV43 INS42 MOV44 INS44 INS43 INS8 MOV8 MOV8 INS8 MOV8 MOV8 MOV29 INS83 INS39 INS42 MOV44 MOV44 MOV44 MOV43 INS8 INS83 MOV43 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS8 INS83 MOV43 INS42 INS44 INS44 INS44 INS43 INS8 INS83 INS83 INS83 INS83 INS83 INS83 INS23 INS23 INS23 INS31 INS29 INS83 INS42 INS43 INS23 INS23 INS23 INS23 INS23 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 INS31 MOV31 INS43 INS85 UPD42 INS3 INS21 INS21 INS21 INS21 INS21 INS42 INS42 INS14 INS42 INS34 INS42 INS54 INS25 UPD43 UPD42 INS60 INS41 INS43 INS42 INS21 MOV41 UPD42 MOV42 INS41 INS65 INS65 INS65 INS65 INS65 UPD42 MOV42 INS43 INS42 MOV60 INS60 INS54 INS43 INS42 UPD42 MOV42 INS41 INS60 INS41 INS60 INS41 MOV60 MOV60 INS60 INS41 INS53 INS60 INS41 INS60 INS60 MOV60 INS41 MOV60 INS41 INS60 MOV60 INS60 INS21 MOV60 INS25 INS21 MOV60 INS60 INS60 INS21 INS21 INS21 INS21 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS42 MOV60 INS54 INS43 INS42 INS43 INS42 INS43 INS42 INS42 MOV60 INS54 INS43 INS42 INS43 INS42 INS43 INS42 INS42 MOV60 INS54 UPD43 INS83 INS83 INS43 INS59 INS83 MOV43 INS59 INS83 MOV43 INS59 INS83 INS42 INS44 INS44 INS8 INS43 INS65 UPD42 MOV42 INS83 INS43 INS59 INS83 INS83 MOV43 INS59 INS83 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS43 INS59 UPD83 INS39 UPD42 UPD83 INS39 UPD42 INS44 UPD83 MOV43 UPD42 INS8 UPD83 INS39 INS42 INS44 INS44 INS8 UPD83 INS83 INS39 UPD42 INS8 INS43 INS42 INS8 INS83 INS39 INS42 INS8 UPD83 UPD42 INS42 INS5 INS34 INS7 INS7 INS7 INS7 INS7 UPD43 MOV43 INS42 INS9 INS40 INS8 MOV12 MOV21 INS38 MOV8 UPD42 INS39 INS59 INS27 INS40 INS32 INS32 INS32 INS66 INS42 INS42 INS42 INS42 MOV43 INS43 INS59 INS8 MOV12 MOV12 MOV8 MOV60 MOV8 INS42 INS14 INS43 INS59 INS32 MOV43 INS59 INS32 MOV43 INS59 INS32 INS14 MOV43 INS59 INS32 MOV43 INS59 INS43 INS59 INS42 INS32 INS32 INS43 MOV12 MOV43 INS59 MOV8 MOV43 MOV8 INS27 INS27 INS43 INS59 INS32 INS43 INS32 INS8 INS8 INS32 UPD43 INS43 INS59 INS43 INS59 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS43 INS8 MOV12 MOV12 MOV8 UPD42 MOV42 UPD42 MOV42 INS42 INS43 INS8 MOV12 MOV12 MOV8 INS42 INS42 INS42 INS43 INS8 MOV12 MOV12 MOV8 UPD42 INS42 INS42 INS42 INS42 INS43 INS42 INS43 INS42 INS21 INS21 INS42 UPD42 INS21 MOV60 MOV21 MOV60 MOV21 MOV21 MOV21 INS66 INS42 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS42 INS42 UPD43 INS43 INS42 UPD43 UPD42 INS25 INS43 INS42 UPD42 INS43 INS42 INS51 UPD43 UPD42 INS51 INS42 INS51 INS60 INS21 INS21 INS21 INS43 INS85 INS2 INS32 INS2 INS32 INS2 INS32 INS2 INS32 INS2 INS32 UPD42 MOV21 INS60 MOV21 MOV21 INS36 INS42 INS32 INS27 INS27 MOV32 UPD42 MOV42 INS40 MOV42 INS42 INS42 INS42 INS32 UPD42 INS42 INS42 INS32 INS25 MOV21 MOV21 MOV60 INS41 INS21 MOV60 MOV21 INS60 INS25 UPD42 MOV42 INS25 INS60 MOV25 INS69 MOV43 INS42 INS42 INS60 INS42 INS42 INS14 UPD42 MOV42 MOV42 MOV42 INS42 MOV14 UPD42 MOV42 MOV42 MOV42 INS42 MOV14 UPD42 MOV42 MOV42 MOV42 INS43 INS45 INS60 INS60 INS42 MOV14 UPD42 MOV42 MOV42 MOV42 INS42 MOV14 INS42 INS42 INS32 MOV14 UPD42 MOV42 MOV42 UPD42 MOV42 MOV14 UPD42 MOV42 MOV42 MOV42 INS42 INS60 INS41 INS60 INS41 INS60 INS41 INS60 INS41 INS60 INS41 INS42 INS14 MOV60 INS21 INS27 MOV27 INS27 MOV27 INS42 INS42 INS32 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS60 INS21 INS21 INS60 INS21 INS21 INS21 INS42 INS42 UPD42 UPD42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS27 INS42 INS25 MOV21 MOV21 INS41 INS42 MOV21 MOV21 MOV21 INS42 INS21 MOV21 MOV21 MOV60 INS25 INS60 INS42 INS42 INS7 INS7 MOV60 MOV60 MOV60 INS32 INS8 MOV12 MOV12 INS43 INS43 UPD42 INS42 INS32 UPD42 INS32 INS8 MOV8 INS42 INS42 INS42 INS8 UPD42 INS42 INS8 INS42 INS8 INS43 INS59 INS7 INS32 INS32 INS42 INS42 INS34 INS42 INS42 INS40 INS42 INS34 INS42 INS42 INS40 INS42 INS34 INS42 INS42 INS40 INS42 INS34 INS42 INS42 INS40 INS42 INS34 INS42 INS42 INS40 MOV43 INS59 MOV62 INS42 INS42 INS32 INS40 INS42 INS40 INS42 MOV32 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS33 INS42 INS32 INS8 INS8 UPD43 INS42 INS32 INS43 INS59 MOV27 INS8 INS42 INS27 INS8 INS43 INS59 INS27 MOV43 INS43 INS40 INS43 INS59 INS42 MOV43 MOV42 INS42 INS42 INS42 MOV43 INS59 INS43 INS59 INS42 UPD42 MOV42 MOV42 UPD42 MOV42 INS42 MOV43 INS59 INS32 MOV43 MOV43 INS59 INS32 INS43 INS59 INS32 MOV43 INS59 INS32 MOV43 INS59 INS32 MOV43 INS32 MOV43 INS7 INS42 INS33 INS42 INS33 INS42 INS42 INS42 UPD42 INS43 INS59 INS32 INS32 INS43 INS59 INS32 INS32 INS32 INS36 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS45 INS42 INS45 INS42 INS27 MOV8 INS8 INS32 INS7 INS7 UPD43 INS32 INS8 INS8 INS43 INS59 INS22 INS42 INS22 INS42 INS21 INS60 INS60 INS60 INS41 INS42 INS21 MOV60 MOV21 MOV60 MOV21 UPD42 MOV42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 MOV41 INS60 INS21 INS21 INS25 INS21 INS21 INS25 INS25 INS41 INS42 INS42 INS14 INS42 INS14 INS42 INS42 INS42 INS42 INS42 MOV14 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV21 MOV21 UPD42 UPD42 INS32 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS53 INS25 INS40 INS34 INS53 INS42 INS42 INS32 INS27 INS32 INS42 INS42 INS42 INS21 INS42 MOV14 INS42 INS42 INS32 INS42 MOV14 UPD42 MOV42 MOV42 MOV42 INS42 MOV14 UPD42 MOV42 MOV42 MOV42 INS42 INS42 MOV14 UPD42 MOV42 MOV42 UPD42 MOV42 INS42 MOV14 UPD42 MOV42 MOV42 MOV42 INS42 INS14 UPD42 MOV42 MOV42 MOV42 INS42 INS42 MOV32 UPD42 MOV32 INS42 INS14 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS11 INS42 INS33 INS21 INS42 INS42 INS42 INS14 INS42 INS14 UPD42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 INS41 INS60 MOV41 INS42 INS42 MOV32 INS52 INS42 INS52 INS42 INS43 INS7 MOV43 INS59 INS7 MOV43 INS59 MOV43 INS59 INS43 INS42 UPD42 MOV42 INS32 MOV8 MOV8 INS42 INS42 INS2 INS39 INS59 INS32 INS7 INS42 INS8 INS32 INS7 INS32 INS8 INS27 INS8 INS42 INS43 INS1 INS43 INS42 MOV43 INS14 UPD42 MOV42 INS42 INS42 INS42 INS42 INS32 MOV32 INS43 INS42 INS32 INS14 INS38 INS8 MOV32 INS14 INS42 INS42 INS40 INS32 INS33 INS42 INS42 MOV43 INS42 INS42 INS7 INS7 INS42 INS42 INS42 INS42 MOV43 MOV42 MOV32 MOV40 INS42 MOV43 INS42 MOV42 MOV42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS33 INS42 INS45 INS42 INS45 INS42 UPD43 MOV43 UPD42 MOV42 INS7 INS43 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS40 INS43 INS59 INS14 INS42 INS42 INS42 INS42 INS42 INS32 INS42 MOV32 INS42 INS36 INS42 INS32 INS42 INS32 INS42 INS14 INS42 INS36 INS42 UPD42 INS32 INS42 INS42 UPD42 UPD42 INS42 INS42 MOV21 INS36 INS34 INS42 INS32 INS42 INS42 UPD42 MOV42 INS3 INS42 INS33 INS21 INS42 INS42 UPD42 MOV42 INS42 INS33 UPD42 MOV42 UPD42 MOV42 INS21 INS42 INS33 INS21 INS42 INS31 INS42 INS42 INS43 INS42 INS42 INS42 UPD43 INS42 INS42 UPD42 MOV42 INS43 INS27 INS32 INS32 INS53 UPD42 UPD42 INS14 INS43 INS27 INS42 MOV43 INS27 INS42 INS42 UPD45 INS60 MOV21 MOV21 INS42 INS9 INS42 MOV32 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS42 INS14 INS42 INS42 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS16 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS33 INS42 INS42 INS42 INS42 MOV43 INS42 INS42 INS42 INS16 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV32 INS11 INS42 INS42 INS5 INS4 INS32 INS32 INS7 MOV83 INS39 INS42 INS8 INS42 UPD42 MOV42 INS40 INS42 INS45 INS42 INS45 INS42 INS42 MOV32 INS42 INS42 INS42 INS14 INS43 INS42 INS45 INS42 INS45 UPD45 INS45 INS42 INS45 MOV43 INS59 UPD42 MOV42 UPD43 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS32 INS42 INS32 INS5 INS32 INS43 INS85 INS42 INS42 INS42 UPD42 MOV42 INS42 INS32 INS61 INS43 INS27 INS42 INS42 INS14 UPD42 MOV42 UPD42 UPD42 MOV42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 UPD42 MOV42 MOV32 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS43 INS85 INS32 INS42 INS42 INS42 INS42 INS42 INS14 INS27 INS8 INS42 INS45 INS42 UPD42 MOV42 MOV43 INS40 INS40 INS36 INS42 INS36 UPD42 INS42 INS42 INS43 INS42 INS42 INS32 INS54 INS11 INS11 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS8 INS12 INS12 INS42 INS42 INS43 INS42 INS43 INS42 INS21 INS60 INS61 INS44 INS8 INS44 INS8 INS42 INS42 INS32 INS43 INS59 INS32 INS8 INS43 INS42 INS21 INS41 MOV43 INS42 INS21 INS42 INS42 INS42 UPD42 MOV42 INS42 INS32 INS42 INS42 INS60 INS60 INS60 INS60 INS60 INS21 INS42 INS32 INS32 INS32 INS42 INS43 INS59 INS5 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS32 INS42 INS42 INS27 INS42 INS42 INS45 INS32 INS32 INS42 INS42 INS42 INS11 INS43 INS85 INS42 INS11 INS42 INS42 INS2 INS42 INS42 INS2 INS42 INS42 INS32 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS43 INS32 INS42 INS5 INS32 INS42 INS34 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS85 INS32 INS42 INS42 UPD42 MOV42 INS42 DEL42 DEL42 DEL42 DEL14 DEL32 DEL59 DEL42 DEL83 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL11 DEL41 DEL8 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL33 DEL7 DEL21 DEL8 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL32 DEL42 DEL42 DEL32 DEL32 DEL14 DEL7 DEL21 DEL8 DEL25 DEL25 DEL43 DEL42 DEL59 DEL60 DEL43 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL42 DEL45 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL42 DEL42 DEL43 DEL62 DEL42 DEL33 DEL27 DEL42 DEL40 DEL42 DEL14 DEL59 DEL60 DEL8 DEL25 DEL8 DEL25 DEL42 DEL7 DEL83 DEL43 DEL42 DEL42 DEL41 DEL8 DEL31 DEL83 DEL43 DEL42 DEL42 DEL41 DEL8 DEL31 DEL32 DEL32 DEL42 DEL42 DEL33 DEL27 DEL45 DEL14 DEL53 DEL8 DEL25 DEL42 DEL42 DEL32 DEL45 DEL42 DEL32 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL32 DEL42 DEL32 DEL42 DEL42 DEL43 DEL62 DEL43 DEL42 DEL11 DEL14 DEL41 DEL8 DEL25 DEL8 DEL31 DEL33 DEL42 DEL32 DEL7 DEL36 DEL38 DEL42 DEL42 DEL32 DEL53 DEL8 DEL25 DEL42 DEL32 DEL42 DEL14 DEL7 DEL21 DEL9 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL41 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL54 DEL8 DEL42 DEL7 DEL21 DEL9 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL41 DEL42 DEL33 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL53 DEL8 DEL12 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL42 DEL33 DEL59 DEL60 DEL42 DEL7 DEL21 DEL9 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL41 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL53 DEL8 DEL12 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL33 DEL41 DEL42 DEL33 DEL59 DEL60 DEL42 DEL7 DEL21 DEL42 DEL32 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL53 DEL8 DEL12 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL7 DEL21 DEL9 DEL32 DEL21 DEL42 DEL32 DEL41 DEL42 DEL33 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL53 DEL8 DEL12 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL32 DEL42 DEL33 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL53 DEL8 DEL12 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL33 DEL42 DEL7 DEL21 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL32 DEL41 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL53 DEL8 DEL12 DEL54 DEL33 DEL42 DEL7 DEL21 DEL9 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL41 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL53 DEL8 DEL12 DEL54 DEL42 DEL7 DEL21 DEL9 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL41 DEL42 DEL7 DEL21 DEL9 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL41 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL32 DEL41 DEL32 DEL42 DEL7 DEL21 DEL9 DEL32 DEL21 DEL42 DEL32 DEL41 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL32 DEL42 DEL14 DEL7 DEL21 DEL9 DEL32 DEL21 DEL42 DEL32 DEL41 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL14 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL32 DEL42 DEL32 DEL32 DEL11 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL33 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL39 DEL42 DEL38 DEL42 DEL42 DEL32 DEL42 DEL32 DEL14 DEL33 DEL32 DEL32 DEL32 DEL32 DEL32 DEL32 DEL32 DEL32 DEL32 DEL32 DEL32 DEL32 DEL8 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL42 DEL32 DEL41 DEL8 DEL42
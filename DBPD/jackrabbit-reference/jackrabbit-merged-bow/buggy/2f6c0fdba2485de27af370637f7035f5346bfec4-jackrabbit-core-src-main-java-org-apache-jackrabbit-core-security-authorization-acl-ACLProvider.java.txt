minor improvement

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1022857 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.collections.map.LRUMap;
-import org.apache.jackrabbit.core.ItemImpl;
-import org.apache.jackrabbit.core.ItemManager;
-import org.apache.jackrabbit.core.id.ItemId;
-import org.apache.jackrabbit.core.id.PropertyId;
-import org.apache.jackrabbit.core.security.authorization.AccessControlListener;
-import org.apache.jackrabbit.core.security.authorization.AbstractCompiledPermissions;
-import org.apache.jackrabbit.core.security.authorization.AccessControlModifications;
-import org.apache.jackrabbit.core.security.authorization.PrivilegeRegistry;
-import javax.jcr.security.AccessControlEntry;
-import java.util.Iterator;
-     * the system acl editor.
-     */
-    private ACLEditor systemEditor;
-
-    /**
-        systemEditor = new ACLEditor(systemSession, this);
+        ACLEditor systemEditor = new ACLEditor(systemSession, this);
-            return new AclPermissions(principals);
+            return new CompiledPermissionsImpl(principals, session, entryCollector, this, true);
-            CompiledPermissions cp = new AclPermissions(principals, false);
-            return cp.canRead(null, rootNodeId);
+            CompiledPermissions cp = new CompiledPermissionsImpl(principals, session, entryCollector, this, false);
+            try {
+                return cp.canRead(null, rootNodeId);
+            } finally {
+                cp.close();
+            }
-     * @see #retrieveResultEntries(NodeImpl, EntryFilter)
-        return new CachingEntryCollector(systemSession, systemEditor, rootNodeId);
-    }
-
-    /**
-     * Retrieve an iterator of <code>AccessControlEntry</code> to be evaluated
-     * upon {@link AbstractCompiledPermissions#buildResult}.
-     *
-     * @param node Target node.
-     * @param filter The entry filter used to collect the access control entries.
-     * @return an iterator of <code>AccessControlEntry</code>.
-     * @throws RepositoryException If an error occurs.
-     */
-    protected Iterator<AccessControlEntry> retrieveResultEntries(NodeImpl node, EntryFilter filter) throws RepositoryException {
-        Iterator<AccessControlEntry> itr = entryCollector.collectEntries(node, filter).iterator();
-        return itr;
+        return new CachingEntryCollector(systemSession, rootNodeId);
-     * Returns the given <code>targetNode</code> unless the node itself stores
-     * access control information in which case it's nearest non-ac-parent is
-     * searched and returned.
-     *
-     * @param targetNode The node for which AC information needs to be retrieved.
-     * @param isAcItem true if the specified target node defines access control
-     * content; false otherwise.
-     * @return the given <code>targetNode</code> or the nearest non-ac-parent
-     * in case the <code>targetNode</code> itself defines access control content.
-     * @throws RepositoryException if an error occurs
-     */
-    private NodeImpl getNode(NodeImpl targetNode, boolean isAcItem) throws RepositoryException {
-        NodeImpl node;
-        if (isAcItem) {
-            Name ntName = ((NodeTypeImpl) targetNode.getPrimaryNodeType()).getQName();
-            if (ntName.equals(NT_REP_ACL)) {
-                node = (NodeImpl) targetNode.getParent();
-            } else {
-                node = (NodeImpl) targetNode.getParent().getParent();
-            }
-        } else {
-            node = targetNode;
-        }
-        return node;
-    }
-
-    /**
-    //------------------------------------------------< CompiledPermissions >---
+     * Returns the given <code>targetNode</code> unless the node itself stores
+     * access control information in which case it's nearest non-ac-parent is
+     * searched and returned.
+     * @param targetNode The node for which AC information needs to be retrieved.
+     * @param isAcItem true if the specified target node defines access control
+     * content; false otherwise.
+     * @return the given <code>targetNode</code> or the nearest non-ac-parent
+     * in case the <code>targetNode</code> itself defines access control content.
+     * @throws RepositoryException if an error occurs
-    private class AclPermissions extends AbstractCompiledPermissions implements AccessControlListener {
-
-        private final List<String> principalNames;
-        // TODO find optimal cache size and ev. make it configurable (see also JCR-2573).
-        private final Map<ItemId, Boolean> readCache = new LRUMap(5000);
-        private final Object monitor = new Object();
-
-        private AclPermissions(Set<Principal> principals) throws RepositoryException {
-            this(principals, true);
-        }
-
-        private AclPermissions(Set<Principal> principals, boolean listenToEvents) throws RepositoryException {
-            principalNames = new ArrayList<String>(principals.size());
-            for (Principal princ : principals) {
-                principalNames.add(princ.getName());
+    static NodeImpl getNode(NodeImpl targetNode, boolean isAcItem) throws RepositoryException {
+        NodeImpl node;
+        if (isAcItem) {
+            Name ntName = ((NodeTypeImpl) targetNode.getPrimaryNodeType()).getQName();
+            if (ntName.equals(NT_REP_ACL)) {
+                node = (NodeImpl) targetNode.getParent();
+            } else {
+                node = (NodeImpl) targetNode.getParent().getParent();
-
-            if (listenToEvents) {
-                /*
-                 Make sure this AclPermission recalculates the permissions if
-                 any ACL concerning it is modified.
-                 */
-                 entryCollector.addListener(this);
-            }
+        } else {
+            node = targetNode;
-
-        private Result buildResult(NodeImpl node, boolean isExistingNode, boolean isAcItem, EntryFilterImpl filter) throws RepositoryException {
-            // retrieve all ACEs at path or at the direct ancestor of path that
-            // apply for the principal names.
-            Iterator<AccessControlEntry> entries = retrieveResultEntries(getNode(node, isAcItem), filter);
-
-            /*
-             Calculate privileges and permissions:
-             Since the ACEs only define privileges on a node and do not allow
-             to add additional restrictions, the permissions can be determined
-             without taking the given target name or target item into account.
-             */
-            int allows = Permission.NONE;
-            int denies = Permission.NONE;
-
-            int allowPrivileges = PrivilegeRegistry.NO_PRIVILEGE;
-            int denyPrivileges = PrivilegeRegistry.NO_PRIVILEGE;
-            int parentAllows = PrivilegeRegistry.NO_PRIVILEGE;
-            int parentDenies = PrivilegeRegistry.NO_PRIVILEGE;
-
-            String parentPath = Text.getRelativeParent(filter.getPath(), 1);
-
-            while (entries.hasNext()) {
-                ACLTemplate.Entry ace = (ACLTemplate.Entry) entries.next();
-                /*
-                 Determine if the ACE also takes effect on the parent:
-                 Some permissions (e.g. add-node or removal) must be determined
-                 from privileges defined for the parent.
-                 A 'local' entry defined on the target node never effects the
-                 parent. For inherited ACEs determine if the ACE matches the
-                 parent path.
-                 */
-                int entryBits = ace.getPrivilegeBits();
-                boolean isLocal = isExistingNode && ace.isLocal(node.getNodeId());
-                boolean matchesParent = (!isLocal && ace.matches(parentPath));
-                if (matchesParent) {
-                    if (ace.isAllow()) {
-                        parentAllows |= Permission.diff(entryBits, parentDenies);
-                    } else {
-                        parentDenies |= Permission.diff(entryBits, parentAllows);
-                    }
-                }
-                if (ace.isAllow()) {
-                    allowPrivileges |= Permission.diff(entryBits, denyPrivileges);
-                    int permissions = PrivilegeRegistry.calculatePermissions(allowPrivileges, parentAllows, true, isAcItem);
-                    allows |= Permission.diff(permissions, denies);
-                } else {
-                    denyPrivileges |= Permission.diff(entryBits, allowPrivileges);
-                    int permissions = PrivilegeRegistry.calculatePermissions(denyPrivileges, parentDenies, false, isAcItem);
-                    denies |= Permission.diff(permissions, allows);
-                }
-            }
-            return new Result(allows, denies, allowPrivileges, denyPrivileges);
-        }
-
-        //------------------------------------< AbstractCompiledPermissions >---
-        /**
-         * @see AbstractCompiledPermissions#buildResult(Path)
-         */
-        @Override
-        protected Result buildResult(Path absPath) throws RepositoryException {
-            boolean existingNode = false;
-            NodeImpl node;
-
-            ItemManager itemMgr = session.getItemManager();
-            try {
-                ItemImpl item = itemMgr.getItem(absPath);
-                if (item.isNode()) {
-                    node = (NodeImpl) item;
-                    existingNode = true;
-                } else {
-                    node = (NodeImpl) item.getParent();
-                }
-            } catch (RepositoryException e) {
-                // path points to a non-persisted item.
-                // -> find the nearest persisted node starting from the root.
-                Path.Element[] elems = absPath.getElements();
-                NodeImpl parent = (NodeImpl) session.getRootNode();
-                for (int i = 1; i < elems.length - 1; i++) {
-                    Name name = elems[i].getName();
-                    int index = elems[i].getIndex();
-                    if (!parent.hasNode(name, index)) {
-                        // last persisted node reached
-                        break;
-                    }
-                    parent = parent.getNode(name, index);
-
-                }
-                node = parent;
-            }
-
-            if (node == null) {
-                // should never get here
-                throw new ItemNotFoundException("Item out of hierarchy.");
-            }
-
-            boolean isAcItem = isAcItem(absPath);
-            return buildResult(node, existingNode, isAcItem, new EntryFilterImpl(principalNames, absPath, session));
-        }
-
-        /**
-         * @see AbstractCompiledPermissions#clearCache()
-         */
-        @Override
-        protected void clearCache() {
-            synchronized (monitor) {
-                readCache.clear();
-            }
-            super.clearCache();
-        }
-
-        //--------------------------------------------< CompiledPermissions >---
-        /**
-         * @see CompiledPermissions#close()
-         */
-        @Override
-        public void close() {
-            entryCollector.removeListener(this);
-            super.close();
-        }
-
-        /**
-         * @see CompiledPermissions#canRead(Path, ItemId)
-         */
-        public boolean canRead(Path path, ItemId itemId) throws RepositoryException {
-            ItemId id = (itemId == null) ? session.getHierarchyManager().resolvePath(path) : itemId;
-            // no extra check for existence as method may only be called for existing items.
-            boolean isExistingNode = id.denotesNode();
-            boolean canRead;
-            synchronized (monitor) {
-                if (readCache.containsKey(id)) {
-                    canRead = readCache.get(id);
-                } else {
-                    ItemManager itemMgr = session.getItemManager();
-                    NodeId nodeId = (isExistingNode) ? (NodeId) id : ((PropertyId) id).getParentId();
-                    NodeImpl node = (NodeImpl) itemMgr.getItem(nodeId);
-                    // TODO: check again if retrieving the path can be avoided
-                    Path absPath = (path == null) ? session.getHierarchyManager().getPath(id) : path;
-                    Result result = buildResult(node, isExistingNode, isAcItem(node), new EntryFilterImpl(principalNames, absPath, session));
-
-                    canRead = result.grants(Permission.READ);
-                    readCache.put(id, canRead);
-                }
-            }
-            return canRead;
-        }
-
-        //----------------------------------------< ACLModificationListener >---
-        /**
-         * @see org.apache.jackrabbit.core.security.authorization.AccessControlListener#acModified(AccessControlModifications)
-         */
-        public void acModified(AccessControlModifications modifications) {
-            // ignore the details of the modifications and clear all caches.
-            clearCache();
-        }
+        return node;

MOV31 UPD83 INS60 MOV43 INS59 INS8 INS42 MOV14 INS60 INS54 MOV43 INS59 MOV8 INS8 INS42 INS14 INS21 UPD43 INS42 INS42 INS52 INS9 INS43 INS42 INS42 INS42 INS52 INS9 INS32 UPD42 INS42 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL66 DEL65 DEL29 DEL83 DEL42 DEL59 DEL23 DEL42 DEL7 DEL21 DEL42 DEL42 DEL43 DEL42 DEL9 DEL14 DEL59 DEL60 DEL42 DEL42 DEL43 DEL69 DEL42 DEL43 DEL69 DEL68 DEL65 DEL42 DEL66 DEL66 DEL42 DEL42 DEL67 DEL65 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL41 DEL8 DEL31 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL43 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL34 DEL14 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL23 DEL83 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL9 DEL17 DEL8 DEL31 DEL83 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL14 DEL7 DEL21 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL70 DEL42 DEL42 DEL42 DEL52 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL40 DEL59 DEL60 DEL39 DEL42 DEL40 DEL59 DEL60 DEL39 DEL42 DEL40 DEL59 DEL60 DEL39 DEL42 DEL40 DEL59 DEL60 DEL39 DEL42 DEL40 DEL59 DEL60 DEL39 DEL42 DEL40 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL34 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL40 DEL43 DEL42 DEL40 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL27 DEL59 DEL60 DEL39 DEL42 DEL42 DEL38 DEL42 DEL42 DEL42 DEL32 DEL27 DEL36 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL39 DEL42 DEL42 DEL42 DEL42 DEL42 DEL9 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL39 DEL42 DEL42 DEL42 DEL42 DEL42 DEL9 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL61 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL14 DEL41 DEL8 DEL31 DEL42 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL29 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL11 DEL7 DEL21 DEL42 DEL9 DEL7 DEL21 DEL8 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL40 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL34 DEL27 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL42 DEL42 DEL2 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL2 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL38 DEL10 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL24 DEL42 DEL42 DEL7 DEL21 DEL8 DEL12 DEL54 DEL42 DEL33 DEL27 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL14 DEL32 DEL41 DEL8 DEL31 DEL42 DEL42 DEL68 DEL65 DEL29 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL51 DEL42 DEL48 DEL21 DEL8 DEL31 DEL42 DEL42 DEL68 DEL65 DEL29 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL42 DEL52 DEL32 DEL21 DEL42 DEL48 DEL21 DEL8 DEL31 DEL42 DEL42 DEL42 DEL43 DEL69 DEL42 DEL43 DEL69 DEL68 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL33 DEL27 DEL36 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL16 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL36 DEL42 DEL43 DEL42 DEL11 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL16 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL33 DEL27 DEL36 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL16 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL14 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL40 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL51 DEL42 DEL41 DEL8 DEL31 DEL40 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL32 DEL21 DEL8 DEL31 DEL55
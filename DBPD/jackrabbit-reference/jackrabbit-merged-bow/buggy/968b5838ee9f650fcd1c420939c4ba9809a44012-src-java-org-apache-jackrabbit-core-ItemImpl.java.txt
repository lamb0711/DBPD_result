- fixed (JCR-69) removing source parent node after session move throws on save
  http://issues.apache.org/jira/browse/JCR-69
- fixed Session.move(): lock on source parent was not checked
  

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@157745 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.commons.collections.iterators.IteratorChain;
+import java.util.HashSet;
+import java.util.Set;
-                // build list of transient states that should be persisted
+                /**
+                 * build list of transient (i.e. new & modified) states that
+                 * should be persisted
+                 */
-                ItemState transientState;
-
-                /**
-                 * check that parent node is also included in the dirty items list
-                 * if dirty node was removed or added (adding/removing a parent/child
-                 * link requires that both parent and child are saved)
-                 */
-                Iterator iter = dirty.iterator();
-                while (iter.hasNext()) {
-                    transientState = (ItemState) iter.next();
-                    if (transientState.isNode()) {
-                        NodeState nodeState = (NodeState) transientState;
-                        ArrayList dirtyParents = new ArrayList();
-                        // removed parents
-                        dirtyParents.addAll(nodeState.getRemovedParentUUIDs());
-                        // added parents
-                        dirtyParents.addAll(nodeState.getAddedParentUUIDs());
-                        Iterator parentsIter = dirtyParents.iterator();
-                        while (parentsIter.hasNext()) {
-                            NodeId id = new NodeId((String) parentsIter.next());
-                            NodeState parentState;
-                            try {
-                                parentState = (NodeState) stateMgr.getTransientItemState(id);
-                            } catch (ItemStateException ise) {
-                                // should never get here...
-                                String msg = "inconsistency: failed to retrieve transient state for " + itemMgr.safeGetJCRPath(id);
-                                log.debug(msg);
-                                throw new RepositoryException(msg);
-                            }
-                            // check if parent is also going to be saved
-                            if (!dirty.contains(parentState)) {
-                                // need to save the parent too
-                                String msg = itemMgr.safeGetJCRPath(id) + " needs to be saved also.";
-                                log.debug(msg);
-                                throw new RepositoryException(msg);
-                            }
-                        }
-                    }
-                }
-
+                 * build set of item id's who are within the scope of
+                 * (i.e. affected by) this save operation
+                 */
+                Set affectedIds = new HashSet(dirty.size() + removed.size());
+                for (Iterator it =
+                        new IteratorChain(dirty.iterator(), removed.iterator());
+                     it.hasNext();) {
+                    affectedIds.add(((ItemState) it.next()).getId());
+                }
+
+                /**
+                 * make sure that this save operation is totally 'self-contained'
+                 * and independant; items within the scope of this save operation
+                 * must not have 'external' dependencies;
+                 * (e.g. adding/removing a parent/child link requires that both
+                 * parent and child are saved)
+                 */
+                for (Iterator it =
+                        new IteratorChain(dirty.iterator(), removed.iterator());
+                     it.hasNext();) {
+                    ItemState transientState = (ItemState) it.next();
+                    if (transientState.isNode()) {
+                        NodeState nodeState = (NodeState) transientState;
+                        Set dependentUUIDs = new HashSet();
+                        // removed parents
+                        dependentUUIDs.addAll(nodeState.getRemovedParentUUIDs());
+                        // added parents
+                        dependentUUIDs.addAll(nodeState.getAddedParentUUIDs());
+                        // removed child node entries
+                        for (Iterator cneIt =
+                                nodeState.getRemovedChildNodeEntries().iterator();
+                             cneIt.hasNext();) {
+                            NodeState.ChildNodeEntry cne =
+                                    (NodeState.ChildNodeEntry) cneIt.next();
+                            dependentUUIDs.add(cne.getUUID());
+                        }
+                        // added child node entries
+                        for (Iterator cneIt =
+                                nodeState.getAddedChildNodeEntries().iterator();
+                             cneIt.hasNext();) {
+                            NodeState.ChildNodeEntry cne =
+                                    (NodeState.ChildNodeEntry) cneIt.next();
+                            dependentUUIDs.add(cne.getUUID());
+                        }
+
+                        // now walk through dependencies and check whether they
+                        // are within the scope of this save operation
+                        Iterator depIt = dependentUUIDs.iterator();
+                        while (depIt.hasNext()) {
+                            NodeId id = new NodeId((String) depIt.next());
+                            if (!affectedIds.contains(id)) {
+                                // need to save the parent also
+                                String msg = itemMgr.safeGetJCRPath(id)
+                                        + " needs to be saved also.";
+                                log.debug(msg);
+                                throw new RepositoryException(msg);
+                            }
+                        }
+                    }
+                }
+
+                /**
-                    iter = dirty.iterator();
-                    while (iter.hasNext()) {
-                        transientState = (ItemState) iter.next();
+                    for (Iterator it = dirty.iterator(); it.hasNext();) {
+                        ItemState transientState = (ItemState) it.next();
-                iter = removed.iterator();
-                while (iter.hasNext()) {
-                    transientState = (ItemState) iter.next();
+                for (Iterator it = removed.iterator(); it.hasNext();) {
+                    ItemState transientState = (ItemState) it.next();

INS26 INS26 INS26 INS40 INS40 INS40 MOV60 INS24 INS24 INS24 INS43 INS58 INS32 INS8 INS58 INS32 MOV8 INS58 INS32 INS8 INS42 INS42 INS14 MOV43 INS59 UPD42 MOV42 MOV42 MOV21 MOV43 INS59 UPD42 MOV42 MOV42 INS60 INS24 INS43 INS59 INS42 INS42 INS60 MOV21 INS43 INS27 INS42 INS14 INS32 INS42 INS14 MOV43 INS59 INS58 INS32 MOV8 INS42 INS42 MOV32 INS43 INS59 INS42 INS32 INS32 INS43 MOV32 INS32 INS42 INS42 INS32 INS43 INS32 INS32 INS42 INS11 INS24 INS24 INS43 INS59 UPD42 MOV42 MOV42 INS60 INS42 INS42 INS11 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS36 INS42 INS42 INS42 INS42 INS42 INS42 INS43 MOV32 UPD43 INS58 INS32 INS8 INS58 INS32 INS8 INS43 INS42 INS42 MOV32 MOV43 INS59 MOV43 MOV32 INS11 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 INS43 INS59 INS42 INS42 INS60 INS21 INS43 INS59 INS42 INS42 INS60 INS21 INS42 UPD42 UPD42 INS42 INS11 UPD42 MOV43 INS32 UPD43 INS42 INS42 INS32 INS43 INS59 INS32 INS42 INS42 INS32 INS43 INS59 INS32 UPD42 MOV43 INS43 MOV32 INS42 INS42 UPD42 INS32 INS42 INS40 INS42 INS11 INS42 INS42 INS32 INS32 INS42 INS40 INS42 INS11 INS42 INS42 INS32 INS42 UPD42 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS42 INS43 INS32 INS42 INS42 MOV43 UPD42 UPD42 INS40 INS42 INS42 INS40 INS42 INS42 MOV43 UPD42 DEL42 DEL59 DEL60 DEL32 DEL61 DEL42 DEL42 DEL7 DEL42 DEL11 DEL7 DEL21 DEL42 DEL43 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL45 DEL42 DEL42 DEL42 DEL32 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL11 DEL7 DEL21 DEL42 DEL7 DEL21 DEL32 DEL61 DEL32 DEL42 DEL11 DEL7 DEL21 DEL8 DEL61
JCR-1359: Adding nodes from concurrently running sessions cause exceptions

- added synchronization to NodeStateMerger.merge method
- fixed @todo issue in NodeStateMerger.merge method (checking node type sameNameSibling setting)
- enabling execution of ConcurrentNodeModificationTest

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@634681 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.NodeId;
-        /**
-         * some examples for trivial non-conflicting changes:
-         * - s1 added child node a, s2 removes child node b
-         * - s1 adds child node a, s2 adds child node b
-         * - s1 adds child node a, s2 adds mixin type
-         *
-         * conflicting changes causing staleness:
-         * - s1 added non-sns child node or property a,
-         *   s2 added non-sns child node or property a => name clash
-         * - either session reordered child nodes
-         *   (some combinations could possibly be merged)
-         * - either session moved node
-         */
+        synchronized (overlayedState) {
+            synchronized (state) {
+                /**
+                 * some examples for trivial non-conflicting changes:
+                 * - s1 added child node a, s2 removes child node b
+                 * - s1 adds child node a, s2 adds child node b
+                 * - s1 adds child node a, s2 adds mixin type
+                 *
+                 * conflicting changes causing staleness:
+                 * - s1 added non-sns child node or property a,
+                 *   s2 added non-sns child node or property a => name clash
+                 * - either session reordered child nodes
+                 *   (some combinations could possibly be merged)
+                 * - either session moved node
+                 */
-        // compare current transient state with externally modified
-        // overlayed state and determine what has been changed by whom
+                // compare current transient state with externally modified
+                // overlayed state and determine what has been changed by whom
-        // child node entries order
-        if (!state.getReorderedChildNodeEntries().isEmpty()) {
-            // for now we don't even try to merge the result of
-            // a reorder operation
-            return false;
-        }
+                // child node entries order
+                if (!state.getReorderedChildNodeEntries().isEmpty()) {
+                    // for now we don't even try to merge the result of
+                    // a reorder operation
+                    return false;
+                }
-        // mixin types
-        if (!state.getMixinTypeNames().equals(overlayedState.getMixinTypeNames())) {
-            // the mixins have been modified but by just looking at the diff we
-            // can't determine where the change happened since the diffs of either
-            // removing a mixin from the overlayed or adding a mixin to the
-            // transient state would look identical...
-            return false;
-        }
+                // mixin types
+                if (!state.getMixinTypeNames().equals(overlayedState.getMixinTypeNames())) {
+                    // the mixins have been modified but by just looking at the diff we
+                    // can't determine where the change happened since the diffs of either
+                    // removing a mixin from the overlayed or adding a mixin to the
+                    // transient state would look identical...
+                    return false;
+                }
-        // parent id
-        if (state.getParentId() != null
-                && !state.getParentId().equals(overlayedState.getParentId())) {
-            return false;
-        }
+                // parent id
+                if (state.getParentId() != null
+                        && !state.getParentId().equals(overlayedState.getParentId())) {
+                    return false;
+                }
-        // child node entries
-        if (!state.getChildNodeEntries().equals(
-                overlayedState.getChildNodeEntries())) {
-            ArrayList added = new ArrayList();
-            ArrayList removed = new ArrayList();
+                // child node entries
+                if (!state.getChildNodeEntries().equals(
+                        overlayedState.getChildNodeEntries())) {
+                    ArrayList added = new ArrayList();
+                    ArrayList removed = new ArrayList();
-            for (Iterator iter = state.getAddedChildNodeEntries().iterator();
-                 iter.hasNext();) {
-                NodeState.ChildNodeEntry cne =
-                        (NodeState.ChildNodeEntry) iter.next();
+                    for (Iterator iter = state.getAddedChildNodeEntries().iterator();
+                         iter.hasNext();) {
+                        NodeState.ChildNodeEntry cne =
+                                (NodeState.ChildNodeEntry) iter.next();
-                if (context.isAdded(cne.getId())) {
-                    // a new child node entry has been added to this state;
-                    // check for name collisions with other state
-                    if (overlayedState.hasChildNodeEntry(cne.getName())) {
-                        // conflicting names
-                        if (cne.getIndex() < 2) {
-                            // todo check if same-name siblings are allowed
-                            return false;
+                        if (context.isAdded(cne.getId())) {
+                            // a new child node entry has been added to this state;
+                            // check for name collisions with other state
+                            if (overlayedState.hasChildNodeEntry(cne.getName())) {
+                                // conflicting names
+                                if (cne.getIndex() < 2) {
+                                    // check if same-name siblings are allowed
+                                    if (!context.allowsSameNameSiblings(cne.getId())) {
+                                        return false;
+                                    }
+                                }
+                                // assume same-name siblings are allowed since index is >= 2
+                            }
+
+                            added.add(cne);
-                        // assume same-name siblings are allowed since index is >= 2
-                    added.add(cne);
-                }
-            }
-
-            for (Iterator iter = state.getRemovedChildNodeEntries().iterator();
-                 iter.hasNext();) {
-                NodeState.ChildNodeEntry cne =
-                        (NodeState.ChildNodeEntry) iter.next();
-                if (context.isDeleted(cne.getId())) {
-                    // a child node entry has been removed from this node state
-                    removed.add(cne);
-                }
-            }
-
-            // copy child node antries from other state and
-            // re-apply changes made on this state
-            state.setChildNodeEntries(overlayedState.getChildNodeEntries());
-            for (Iterator iter = added.iterator(); iter.hasNext();) {
-                NodeState.ChildNodeEntry cne =
-                        (NodeState.ChildNodeEntry) iter.next();
-                state.addChildNodeEntry(cne.getName(), cne.getId());
-            }
-            for (Iterator iter = removed.iterator(); iter.hasNext();) {
-                NodeState.ChildNodeEntry cne =
-                        (NodeState.ChildNodeEntry) iter.next();
-                state.removeChildNodeEntry(cne.getId());
-            }
-        }
-
-        // property names
-        if (!state.getPropertyNames().equals(
-                overlayedState.getPropertyNames())) {
-            HashSet added = new HashSet();
-            HashSet removed = new HashSet();
-
-            for (Iterator iter = state.getAddedPropertyNames().iterator();
-                 iter.hasNext();) {
-                Name name = (Name) iter.next();
-                PropertyId propId =
-                        new PropertyId(state.getNodeId(), name);
-                if (context.isAdded(propId)) {
-                    // a new property name has been added to this state;
-                    // check for name collisions
-                    if (overlayedState.hasPropertyName(name)
-                            || overlayedState.hasChildNodeEntry(name)) {
-                        // conflicting names
-                        return false;
+                    for (Iterator iter = state.getRemovedChildNodeEntries().iterator();
+                         iter.hasNext();) {
+                        NodeState.ChildNodeEntry cne =
+                                (NodeState.ChildNodeEntry) iter.next();
+                        if (context.isDeleted(cne.getId())) {
+                            // a child node entry has been removed from this node state
+                            removed.add(cne);
+                        }
-                    added.add(name);
+                    // copy child node antries from other state and
+                    // re-apply changes made on this state
+                    state.setChildNodeEntries(overlayedState.getChildNodeEntries());
+                    for (Iterator iter = added.iterator(); iter.hasNext();) {
+                        NodeState.ChildNodeEntry cne =
+                                (NodeState.ChildNodeEntry) iter.next();
+                        state.addChildNodeEntry(cne.getName(), cne.getId());
+                    }
+                    for (Iterator iter = removed.iterator(); iter.hasNext();) {
+                        NodeState.ChildNodeEntry cne =
+                                (NodeState.ChildNodeEntry) iter.next();
+                        state.removeChildNodeEntry(cne.getId());
+                    }
-            }
-            for (Iterator iter = state.getRemovedPropertyNames().iterator();
-                 iter.hasNext();) {
-                Name name = (Name) iter.next();
-                PropertyId propId =
-                        new PropertyId(state.getNodeId(), name);
-                if (context.isDeleted(propId)) {
-                    // a property name has been removed from this state
-                    removed.add(name);
-                }
-            }
-            // copy property names from other and
-            // re-apply changes made on this state
-            state.setPropertyNames(overlayedState.getPropertyNames());
-            for (Iterator iter = added.iterator(); iter.hasNext();) {
-                Name name = (Name) iter.next();
-                state.addPropertyName(name);
-            }
-            for (Iterator iter = removed.iterator(); iter.hasNext();) {
-                Name name = (Name) iter.next();
-                state.removePropertyName(name);
+                // property names
+                if (!state.getPropertyNames().equals(
+                        overlayedState.getPropertyNames())) {
+                    HashSet added = new HashSet();
+                    HashSet removed = new HashSet();
+
+                    for (Iterator iter = state.getAddedPropertyNames().iterator();
+                         iter.hasNext();) {
+                        Name name = (Name) iter.next();
+                        PropertyId propId =
+                                new PropertyId(state.getNodeId(), name);
+                        if (context.isAdded(propId)) {
+                            // a new property name has been added to this state;
+                            // check for name collisions
+                            if (overlayedState.hasPropertyName(name)
+                                    || overlayedState.hasChildNodeEntry(name)) {
+                                // conflicting names
+                                return false;
+                            }
+
+                            added.add(name);
+                        }
+                    }
+                    for (Iterator iter = state.getRemovedPropertyNames().iterator();
+                         iter.hasNext();) {
+                        Name name = (Name) iter.next();
+                        PropertyId propId =
+                                new PropertyId(state.getNodeId(), name);
+                        if (context.isDeleted(propId)) {
+                            // a property name has been removed from this state
+                            removed.add(name);
+                        }
+                    }
+
+                    // copy property names from other and
+                    // re-apply changes made on this state
+                    state.setPropertyNames(overlayedState.getPropertyNames());
+                    for (Iterator iter = added.iterator(); iter.hasNext();) {
+                        Name name = (Name) iter.next();
+                        state.addPropertyName(name);
+                    }
+                    for (Iterator iter = removed.iterator(); iter.hasNext();) {
+                        Name name = (Name) iter.next();
+                        state.removePropertyName(name);
+                    }
+                }
+
+                // finally sync modification count
+                state.setModCount(overlayedState.getModCount());
+
+                return true;
-
-        // finally sync modification count
-        state.setModCount(overlayedState.getModCount());
-
-        return true;
+        boolean allowsSameNameSiblings(NodeId id);

INS26 INS40 INS31 INS51 INS39 INS42 INS44 INS42 INS8 INS43 INS42 INS51 INS42 INS42 INS8 MOV25 MOV25 MOV25 MOV25 MOV25 MOV21 MOV41 INS8 INS25 INS38 MOV8 INS32 INS42 INS42 INS32 INS42 INS42
JCR-1526: Various improvements to Path and PathImpl

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@646802 13f79535-47bb-0310-9956-ffa450edef68

+    private static final Path CURRENT_PATH = new PathImpl(new Path.Element[]{CURRENT_ELEMENT}, true);
+    private static final Path PARENT_PATH = new PathImpl(new Path.Element[]{PARENT_ELEMENT}, true);
-        public Path getNormalizedPath() throws RepositoryException {
+        public Path getNormalizedPath() {
-                    if (last.denotesRoot()) {
-                        // the first element is the root element;
-                        // ".." would refer to the parent of root
-                        throw new RepositoryException("Path can not be canonicalized: unresolvable '..' element");
-                    }
-                throw new RepositoryException("Path can not be normalized: would result in an empty path.");
+                return CURRENT_PATH;
-                Builder pb = new Builder(new Path.Element[] {CURRENT_ELEMENT});
-                return pb.getPath();
+                return CURRENT_PATH;
-                return this;
+                return this.getNormalizedPath();
-            int length = elements.length - degree;
-            if (length < 1) {
-                throw new PathNotFoundException("no such ancestor path of degree " + degree);
+
+            if (isAbsolute()) {
+                Path.Element[] normElems = getNormalizedPath().getElements();
+                int length = normElems.length - degree;
+                if (length < 1) {
+                    throw new PathNotFoundException("no such ancestor path of degree " + degree);
+                }
+                Path.Element[] ancestorElements = new Element[length];
+                System.arraycopy(normElems, 0, ancestorElements, 0, length);
+                return new PathImpl(ancestorElements, true);
+            } else {
+                Path.Element[] ancestorElements = new Element[elements.length + degree];
+                System.arraycopy(elements, 0, ancestorElements, 0, elements.length);
+
+                for (int i = elements.length; i < ancestorElements.length; i++) {
+                    ancestorElements[i] = PARENT_ELEMENT;
+                }
+                return new PathImpl(ancestorElements, false).getNormalizedPath();
-            Path.Element[] elements = new Element[length];
-            System.arraycopy(this.elements, 0, elements, 0, length);
-            return new PathImpl(elements, normalized);
-            return getDepth() - 1;
+            return (isAbsolute()) ? getDepth() : -1;
-                } else if (!elements[i].denotesCurrent()) {
+                } else if (elements[i].denotesName()) {
+                    // don't count root/current element.
+         * @see Path#isEquivalentTo(Path)
+         */
+        public boolean isEquivalentTo(Path other) throws RepositoryException {
+            if (other == null) {
+                throw new IllegalArgumentException("null argument");
+            }
+            if (isAbsolute() != other.isAbsolute()) {
+                throw new IllegalArgumentException("Cannot compare a relative path with an absolute path");
+            }
+
+            if (getDepth() != other.getDepth()) {
+                return false;
+            }
+
+            Element[] elems0 = getNormalizedPath().getElements();
+            Element[] elems1 = other.getNormalizedPath().getElements();
+
+            if (elems0.length != elems1.length)
+                return false;
+
+            for (int k = 0; k < elems0.length; k++) {
+                if (!elems0[k].equals(elems1[k]))
+                    return false;
+            }
+            return true;
+        }
+
+        /**
-            // make sure we're comparing normalized paths
-            Path p0 = getNormalizedPath();
-            Path p1 = other.getNormalizedPath();
-            if (p0.equals(p1)) {
+            int delta = other.getDepth() - getDepth();
+            if (delta <= 0)
-            }
-            // calculate depth of paths (might be negative)
-            if (p0.getDepth() >= p1.getDepth()) {
-                return false;
-            }
-            Path.Element[] elems0 = p0.getElements();
-            Path.Element[] elems1 = p1.getElements();
-            for (int i = 0; i < elems0.length; i++) {
-                if (!elems0[i].equals(elems1[i])) {
-                    return false;
-                }
-            }
-            return true;
+
+            return isEquivalentTo(other.getAncestor(delta));
-            if (from < 0 || to >= elements.length || from >= to) {
+            if (from < 0 || to > elements.length || from >= to) {
-        private boolean isNormalized = true;
-
-        /**
-         * flag indicating if the current path has leading parent '..' elements
-         */
-        private boolean leadingParent = true;
+        private boolean isNormalized;
+
-            for (int i = 0; i < elements.length; i++) {
-                Path.Element elem = elements[i];
-                leadingParent &= elem.denotesParent();
-                isNormalized &= !elem.denotesCurrent() && (leadingParent || !elem.denotesParent());
+            if (elements.length == 1) {
+                isNormalized = true;
+            } else {
+                boolean absolute = elements[0].denotesRoot();
+                isNormalized = true;
+                int parents = 0;
+                int named = 0;
+                for (int i = 0; i < elements.length; i++) {
+                    Path.Element elem = elements[i];
+                    if (elem.denotesName()) {
+                        named++;
+                    } else if (elem.denotesRoot()) {
+                        if (i > 0) {
+                            throw new IllegalArgumentException("Invalid path: The root element may only occur at the beginning.");
+                        }
+                    } else  if (elem.denotesParent()) {
+                        parents++;
+                        if (absolute || named > 0) {
+                            isNormalized = false;
+                        }
+                    } else /* current element */ {
+                        isNormalized = false;
+                    }
+                }
+                if (absolute && parents > named) {
+                    throw new IllegalArgumentException("Invalid path: Too many parent elements.");
+                }
+            // special path with a single element
+            if (elements.length == 1) {
+                if (elements[0].denotesRoot()) {
+                    return PathFactoryImpl.ROOT;
+                }
+                if (elements[0].denotesParent()) {
+                    return PathFactoryImpl.PARENT_PATH;
+                }
+                if (elements[0].denotesCurrent()) {
+                    return PathFactoryImpl.CURRENT_PATH;
+                }
+            }
+
+            // default: build a new path
-}
+}

INS23 INS23 INS83 INS83 INS83 INS43 MOV59 INS83 INS83 INS83 MOV43 INS59 INS31 INS42 UPD42 INS42 INS14 INS8 INS29 UPD42 INS44 MOV43 INS8 MOV29 INS83 INS39 INS42 MOV44 MOV43 MOV43 INS8 INS8 UPD43 INS9 INS43 INS3 INS9 MOV25 INS25 INS65 INS43 INS42 MOV25 MOV25 INS25 MOV60 MOV60 MOV25 MOV24 MOV41 INS25 INS25 INS60 INS25 INS41 INS25 INS25 MOV41 UPD42 INS42 INS5 INS4 INS32 MOV8 INS8 INS16 INS68 INS42 UPD27 MOV27 MOV8 INS5 INS5 UPD27 INS41 INS27 INS8 INS27 INS8 INS39 INS59 INS27 INS41 INS32 INS27 INS8 INS8 INS27 INS8 INS43 INS85 INS42 INS41 INS42 INS60 INS60 INS21 INS24 INS41 INS36 INS32 INS38 INS42 INS42 INS69 INS32 INS43 INS85 UPD42 INS32 INS43 INS85 UPD42 INS32 INS40 INS40 MOV9 UPD42 UPD42 INS42 INS33 INS53 INS32 INS32 INS53 INS42 INS27 INS42 INS34 INS9 INS42 INS32 INS40 INS34 INS21 INS60 INS21 INS60 INS60 INS24 INS25 INS40 INS34 INS25 INS25 INS25 INS40 INS42 INS42 INS5 INS59 INS5 INS59 INS32 INS58 INS27 INS37 INS8 INS32 INS32 INS42 INS34 MOV43 INS42 INS42 INS42 MOV32 INS42 INS42 MOV32 INS42 UPD42 INS41 INS14 INS42 INS42 INS42 INS14 INS32 INS32 INS42 INS42 INS42 UPD27 INS7 INS39 INS59 INS7 INS39 INS59 INS39 INS59 MOV58 MOV27 MOV37 INS8 INS27 INS8 INS32 INS8 INS32 INS8 INS32 INS8 INS32 INS43 INS85 INS42 INS32 UPD42 INS42 UPD42 UPD42 INS9 INS43 INS85 INS42 INS3 INS42 INS42 INS42 INS34 INS42 INS34 INS40 INS39 INS59 INS42 INS40 INS42 INS21 INS14 INS42 INS42 MOV32 INS9 INS43 INS45 INS43 INS45 INS42 INS42 INS42 INS42 INS9 INS42 INS32 MOV42 INS9 INS42 INS34 INS42 INS34 MOV60 INS25 INS42 INS27 INS53 INS2 INS42 INS41 INS2 INS42 INS41 INS2 INS42 INS41 INS52 INS42 INS40 INS32 INS42 UPD40 INS40 INS5 INS27 INS42 INS40 INS7 INS43 INS42 INS9 UPD42 INS42 INS42 INS2 UPD42 MOV42 INS32 INS8 INS25 INS42 INS42 INS14 INS42 INS34 INS40 INS42 INS34 INS40 INS42 INS34 INS40 INS42 INS43 INS85 INS40 INS42 INS2 INS42 INS42 UPD42 UPD42 INS42 INS34 INS42 INS42 INS21 INS32 INS8 INS25 INS43 INS45 INS42 INS42 INS42 INS37 MOV42 UPD42 MOV42 INS25 MOV32 INS8 INS8 INS42 INS42 INS27 INS8 INS21 INS25 INS21 INS42 INS34 INS53 INS37 INS27 INS8 INS7 INS14 INS42 UPD42 MOV42 INS27 INS21 INS42 INS9 INS43 INS45 INS42 INS34 INS7 INS42 INS42 INS9 DEL42 DEL42 DEL32 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL42 DEL43 DEL45 DEL14 DEL53 DEL42 DEL43 DEL60 DEL42 DEL42 DEL32 DEL52 DEL52 DEL42 DEL22 DEL42 DEL38 DEL34 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL41 DEL8 DEL42 DEL42 DEL42 DEL32 DEL9 DEL41 DEL8 DEL25 DEL40 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL40 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL9 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL42 DEL42 DEL32 DEL7 DEL21 DEL32 DEL38 DEL38 DEL27 DEL36 DEL27 DEL7 DEL21 DEL8 DEL24 DEL8
JCR-1104 - JSR 283 support
- shareble nodes (work in progress)
- simplify HierarchyManager.resolvePath

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@650774 13f79535-47bb-0310-9956-ffa450edef68

+     * Flags describing what items to return in {@link #resolvePath(Path, int)}.
+     */
+    static final int RETURN_NODE = 1;
+    static final int RETURN_PROPERTY = 2;
+    static final int RETURN_ANY = (RETURN_NODE | RETURN_PROPERTY);
+
+    /**
+
-     * Recursively invoked method that resolves a path into an item id.
+     * Internal implementation that iteratively resolves a path into an item.
-     * @param path  full path of item to resolve
-     * @param state intermediate state
-     * @param next  next path element index to resolve
-     * @param denotesNode flag indicating whether <code>path</code> refers to a
-     *                    node (<code>true</code>) or a property (<code>false</code>)
-     * @return the id of the item denoted by <code>path</code> or
-     *         <code>null</code> if no item exists at <code>path</code>.
-     * @throws ItemStateException if an error occurred
+     * @param elements path elements
+     * @param next index of next item in <code>elements</code> to inspect
+     * @param id id of item at path <code>elements[0]</code>..<code>elements[next - 1]</code>
+     * @param typesAllowed one of <code>RETURN_ANY</code>, <code>RETURN_NODE</code>
+     *                     or <code>RETURN_PROPERTY</code>
+     * @return id or <code>null</code>
+     * @throws ItemStateException if an intermediate item state is not found
+     * @throws MalformedPathException if building an intermediate path fails
-    private ItemId resolvePath(Path path, ItemState state, int next,
-                                 boolean denotesNode)
-            throws ItemStateException {
+    protected ItemId resolvePath(Path.Element[] elements, int next,
+                                 ItemId id, int typesAllowed)
+            throws ItemStateException, MalformedPathException {
-        // allow subclasses to process intermediate state
-        beforeResolvePath(path, state, next);
-
-        Path.Element[] elements = path.getElements();
-        if (elements.length == next) {
-            return state.getId();
+        PathBuilder builder = new PathBuilder();
+        for (int i = 0; i < next; i++) {
+            builder.addLast(elements[i]);
-        Path.Element elem = elements[next];
+        for (int i = next; i < elements.length; i++) {
+            Path.Element elem = elements[i];
+            NodeId parentId = (NodeId) id;
+            id = null;
-        Name name = elem.getName();
-        int index = elem.getIndex();
-        if (index == 0) {
-            index = 1;
-        }
-
-        NodeState parentState = (NodeState) state;
-        if (next == elements.length - 1) {
-            // last path element
-            if (denotesNode) {
-                if (parentState.hasChildNodeEntry(name, index)) {
-                    // child node
-                    NodeState.ChildNodeEntry nodeEntry =
-                            getChildNodeEntry(parentState, name, index);
-                    return nodeEntry.getId();
-                }
-            } else {
-                if (parentState.hasPropertyName(name) && (index <= 1)) {
-                    // property
-                    return new PropertyId(parentState.getNodeId(), name);
+            Name name = elem.getName();
+            int index = elem.getIndex();
+            if (index == 0) {
+                index = 1;
+            }
+            int typeExpected = typesAllowed;
+            if (i < elements.length - 1) {
+                // intermediate items must always be nodes
+                typeExpected = RETURN_NODE;
+            }
+            NodeState parentState = (NodeState) getItemState(parentId);
+            if ((typeExpected & RETURN_NODE) != 0) {
+                NodeState.ChildNodeEntry nodeEntry =
+                        getChildNodeEntry(parentState, name, index);
+                if (nodeEntry != null) {
+                    id = nodeEntry.getId();
-            // no such item
-            return null;
+            if (id == null && (typeExpected & RETURN_PROPERTY) != 0) {
+                if (parentState.hasPropertyName(name) && (index <= 1)) {
+                    // property
+                    id = new PropertyId(parentState.getNodeId(), name);
+                }
+            }
+            if (id == null) {
+                break;
+            }
+            builder.addLast(elements[i]);
+            pathResolved(id, builder);
-
-        // intermediate path element
-        ItemId childId;
-        if (parentState.hasChildNodeEntry(name, index)) {
-            // child node
-            NodeState.ChildNodeEntry nodeEntry =
-                    getChildNodeEntry(parentState, name, index);
-            childId = nodeEntry.getId();
-            // recurse
-            return resolvePath(path, getItemState(childId), next + 1, denotesNode);
-        }
-        // no such item
-        return null;
+        return id;
-     * Resolve a path into an item id. Recursively invoked method that may be
-     * overridden by some subclass to either return cached responses or add
-     * response to cache.
-     *
-     * @param path full path of item to resolve
-     * @param id   intermediate item id
-     * @param next next path element index to resolve
-     * @param denotesNode flag indicating whether <code>path</code> refers to a
-     *                    node (<code>true</code>) or a property (<code>false</code>)
-     * @return the id of the item denoted by <code>path</code>
-     * @throws RepositoryException if an error occurred
-     */
-    protected ItemId resolvePath(Path path, ItemId id, int next,
-                                 boolean denotesNode)
-            throws RepositoryException {
-
-        try {
-            return resolvePath(path, getItemState(id), next, denotesNode);
-        } catch (NoSuchItemStateException e) {
-            String msg = "failed to retrieve state of intermediary node";
-            log.debug(msg);
-            throw new RepositoryException(msg, e);
-        } catch (ItemStateException e) {
-            String msg = "failed to retrieve state of intermediary node";
-            log.debug(msg);
-            throw new RepositoryException(msg, e);
-        }
-    }
-
-    /**
-     * Called by recursively invoked method {@link #resolvePath(Path, ItemState, int, boolean)};
-     * May be overridden by some subclass to process/cache intermediate state.
-     *
-     * @param path  full path of item to resolve
-     * @param state intermediate state
-     * @param next  next path element index to resolve
-     */
-    protected void beforeResolvePath(Path path, ItemState state, int next) {
-        // do nothing
-    }
-
-    /**
+    /**
+     * Internal implementation of {@link #resolvePath(Path)} that will either
+     * resolve to a node or a property. Should be overridden by a subclass
+     * that can resolve an intermediate path into an <code>ItemId</code>. This
+     * subclass can then invoke {@link #resolvePath(Path.Element[], int, ItemId, int)}
+     * with a value of <code>next</code> greater than <code>1</code>.
+     *
+     * @param path path to resolve
+     * @param typesAllowed one of <code>RETURN_ANY</code>, <code>RETURN_NODE</code>
+     *                     or <code>RETURN_PROPERTY</code>
+     * @return id or <code>null</code>
+     * @throws RepositoryException if an error occurs
+     */
+    protected ItemId resolvePath(Path path, int typesAllowed)
+            throws RepositoryException {
+
+        Path.Element[] elements = path.getElements();
+        ItemId id = rootNodeId;
+
+        try {
+            return resolvePath(elements, 1, id, typesAllowed);
+        } catch (ItemStateException e) {
+            String msg = "failed to retrieve state of intermediary node";
+            log.debug(msg);
+            throw new RepositoryException(msg, e);
+        }
+    }
+
+    /**
+     * Called by {@link #resolvePath(Path.Element[], int, ItemId, int)}.
+     * May be overridden by some subclass to process/cache intermediate state.
+     *
+     * @param id      id of resolved item
+     * @param builder path builder containing path resolved
+     * @throws MalformedPathException if the path contained in <code>builder</code>
+     *                                is malformed
+     */
+    protected void pathResolved(ItemId id, PathBuilder builder)
+            throws MalformedPathException {
+
+        // do nothing
+    }
+
+
-    public ItemId resolvePath(Path path) throws RepositoryException {
+    public final ItemId resolvePath(Path path) throws RepositoryException {
-
-
-        // first try to resolve node path, then property path
-        ItemId id = resolvePath(path, rootNodeId, 1, true);
-        return (id != null) ? id : resolvePath(path, rootNodeId, 1, false);
+        return resolvePath(path, RETURN_ANY);
-        return (NodeId) resolvePath(path, rootNodeId, 1, true);
+        return (NodeId) resolvePath(path, RETURN_NODE);
-        return (PropertyId) resolvePath(path, rootNodeId, 1, false);
+        return (PropertyId) resolvePath(path, RETURN_PROPERTY);
-
-

MOV31 INS23 INS23 INS23 INS29 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 UPD83 INS44 MOV44 INS44 INS43 INS8 UPD42 INS43 INS83 MOV29 MOV44 MOV43 MOV29 MOV44 MOV43 INS65 INS42 INS34 INS42 INS34 INS42 INS36 INS65 INS5 INS42 INS39 INS42 INS42 INS60 INS24 INS24 INS41 INS65 UPD42 MOV60 INS60 UPD65 UPD43 UPD42 UPD43 UPD42 INS42 INS66 INS65 INS66 INS27 UPD66 UPD42 UPD66 UPD42 UPD66 UPD42 UPD66 UPD42 UPD66 UPD66 UPD66 UPD66 INS42 INS66 MOV43 INS85 INS43 INS59 INS58 INS27 INS37 INS8 INS58 INS27 INS37 MOV8 MOV60 MOV25 INS42 INS66 INS65 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 INS66 INS65 UPD66 MOV66 UPD42 UPD66 UPD42 UPD66 UPD66 UPD66 UPD66 INS43 INS59 UPD66 UPD66 UPD42 UPD66 UPD42 UPD66 UPD42 UPD66 INS66 UPD42 UPD42 INS32 INS68 INS42 INS42 UPD42 MOV42 INS42 INS14 INS39 INS59 INS42 INS42 INS42 INS21 INS39 INS59 INS42 INS40 INS42 INS60 INS60 INS21 INS25 MOV25 INS21 INS21 INS68 INS68 INS42 INS42 INS42 MOV42 MOV42 UPD42 MOV42 INS42 INS69 INS69 INS43 INS42 INS34 INS32 INS42 INS42 INS43 INS59 INS43 INS59 INS7 INS39 UPD27 MOV27 INS8 MOV43 INS27 INS27 INS27 INS8 INS32 INS32 INS42 MOV69 INS42 INS69 MOV69 INS69 INS69 INS69 INS69 UPD42 UPD42 INS43 INS39 UPD42 MOV42 INS42 INS42 INS2 INS40 INS42 INS2 INS42 INS42 INS11 INS42 INS33 UPD42 INS42 UPD42 INS21 INS36 INS34 INS25 INS27 INS27 INS42 INS33 INS10 INS42 INS42 INS2 INS42 INS42 INS42 INS5 MOV43 INS39 UPD42 INS34 MOV42 UPD42 INS5 UPD39 MOV43 INS39 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS7 MOV43 INS32 INS27 INS27 INS8 INS42 INS33 INS36 INS34 INS42 INS42 INS43 INS85 INS43 INS85 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS33 MOV21 INS27 INS21 INS40 INS40 INS42 INS42 INS7 UPD42 INS42 MOV14 DEL66 DEL43 DEL42 DEL44 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL40 DEL42 DEL27 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL42 DEL2 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL32 DEL41 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL40 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL8 DEL41 DEL33 DEL41 DEL8 DEL33 DEL41 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL39 DEL42 DEL44 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL43 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL34 DEL9 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL36 DEL42 DEL34 DEL9 DEL32 DEL16 DEL34 DEL9 DEL34 DEL9
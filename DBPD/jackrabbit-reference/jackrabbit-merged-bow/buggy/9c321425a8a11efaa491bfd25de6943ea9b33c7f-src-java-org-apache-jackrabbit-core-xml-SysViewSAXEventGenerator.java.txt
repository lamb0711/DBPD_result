reimplemented Session.export* according to latest spec

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@151373 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.state.ItemStateManager;
-import org.apache.jackrabbit.core.state.NodeState;
-import org.apache.jackrabbit.core.state.PropertyState;
+import javax.jcr.Value;
-    protected final HierarchyManager hierMgr;
-
-     * @param nodeState      the node state which should be serialized
-     * @param nodeName       name of the node to be serialized
-     * @param noRecurse      if true, only <code>nodeState</code> and its properties will
+     * @param node           the node state which should be serialized
+     * @param noRecurse      if true, only <code>node</code> and its properties will
-     *                       <code>nodeState</code> will be serialized.
-     * @param binaryAsLink   specifies if binary properties are turned into links
-     * @param stateProvider  item state provider for retrieving child item state
-     * @param nsReg          the namespace registry to be used for namespace declarations
-     * @param accessMgr      the access manager
-     * @param hierMgr        the hierarchy manager used to resolve paths
+     *                       <code>node</code> will be serialized.
+     * @param skipBinary     flag governing whether binary properties are to be serialized.
+     * @param session        the session to be used for resolving namespace mappings
-    public SysViewSAXEventGenerator(NodeState nodeState, QName nodeName,
-                                    boolean noRecurse, boolean binaryAsLink,
-                                    ItemStateManager stateProvider,
-                                    NamespaceRegistryImpl nsReg,
-                                    AccessManagerImpl accessMgr,
-                                    HierarchyManager hierMgr,
+    public SysViewSAXEventGenerator(NodeImpl node, boolean noRecurse,
+                                    boolean skipBinary,
+                                    SessionImpl session,
-        super(nodeState, nodeName, noRecurse, binaryAsLink,
-                stateProvider, nsReg, accessMgr, contentHandler);
-        this.hierMgr = hierMgr;
+        super(node, noRecurse, skipBinary, session, contentHandler);
-     * @see AbstractSAXEventGenerator#entering(NodeState, QName, int)
+     * @see AbstractSAXEventGenerator#entering(NodeImpl, int)
-    protected void entering(NodeState state, QName name, int level)
+    protected void entering(NodeImpl node, int level)
+        QName name = node.getQName();
+
-            if (state.getParentUUIDs().size() == 0) {
-                // use dummy name for root node
-                nodeName = NODENAME_ROOT.toJCRName(nsReg);
+            if (node.isRepositoryRoot()) {
+                // root node needs a name
+                nodeName = NODENAME_ROOT.toJCRName(session.getNamespaceResolver());
-                nodeName = name.toJCRName(nsReg);
+                nodeName = name.toJCRName(session.getNamespaceResolver());
+
-     * @see AbstractSAXEventGenerator#enteringProperties(NodeState, QName, int)
+     * @see AbstractSAXEventGenerator#enteringProperties(NodeImpl, int)
-    protected void enteringProperties(NodeState state, QName name, int level)
+    protected void enteringProperties(NodeImpl node, int level)
-     * @see AbstractSAXEventGenerator#leavingProperties(NodeState, QName, int)
+     * @see AbstractSAXEventGenerator#leavingProperties(NodeImpl, int)
-    protected void leavingProperties(NodeState state, QName name, int level)
+    protected void leavingProperties(NodeImpl node, int level)
-     * @see AbstractSAXEventGenerator#leaving(NodeState, QName, int)
+     * @see AbstractSAXEventGenerator#leaving(NodeImpl, int)
-    protected void leaving(NodeState state, QName name, int level)
+    protected void leaving(NodeImpl node, int level)
-     * @see AbstractSAXEventGenerator#entering(PropertyState, int)
+     * @see AbstractSAXEventGenerator#entering(PropertyImpl, int)
-    protected void entering(PropertyState state, int level)
+    protected void entering(PropertyImpl prop, int level)
-        String name;
+        if (prop.getType() == PropertyType.BINARY && skipBinary) {
+            return;
+        }
+
+        QName name = prop.getQName();
+        String propName;
-            name = state.getName().toJCRName(nsReg);
+            propName = name.toJCRName(session.getNamespaceResolver());
-        attrs.addAttribute(NS_SV_URI, NAME_ATTRIBUTE, NS_SV_PREFIX + ":" + NAME_ATTRIBUTE, CDATA_TYPE, name);
+        attrs.addAttribute(NS_SV_URI, NAME_ATTRIBUTE, NS_SV_PREFIX + ":" + NAME_ATTRIBUTE, CDATA_TYPE, propName);
-        int type = state.getType();
+        int type = prop.getType();
-        if (type == PropertyType.BINARY && binaryAsLink) {
-            typeName = PropertyType.TYPENAME_PATH;
-        }
-        InternalValue[] values = state.getValues();
-        if (values != null && values.length > 0) {
-            for (int i = 0; i < values.length; i++) {
-                if (values[i] != null) {
-                    // start value element
-                    contentHandler.startElement(NS_SV_URI, VALUE_ELEMENT, NS_SV_PREFIX + ":" + VALUE_ELEMENT, new AttributesImpl());
+        boolean multiValued = prop.getDefinition().isMultiple();
+        Value[] vals;
+        if (multiValued) {
+            vals = prop.getValues();
+        } else {
+            vals = new Value[]{prop.getValue()};
+        }
+        for (int i = 0; i < vals.length; i++) {
+            Value val = vals[i];
-                    // characters
-                    if (type == PropertyType.BINARY) {
-                        if (binaryAsLink) {
-                            String path;
-                            try {
-                                path = hierMgr.getPath(new PropertyId(state.getParentUUID(), state.getName())).toJCRPath(nsReg);
-                            } catch (NoPrefixDeclaredException npde) {
-                                // should never get here...
-                                String msg = "internal error: encountered unregistered namespace";
-                                log.debug(msg);
-                                throw new RepositoryException(msg, npde);
-                            }
-                            char[] chars = path.toCharArray();
-                            contentHandler.characters(chars, 0, chars.length);
-                        } else {
-                            // binary data, base64 encoding required
-                            BLOBFileValue blob = (BLOBFileValue) values[i].internalValue();
-                            InputStream in = blob.getStream();
-                            Writer writer = new Writer() {
-                                public void close() /*throws IOException*/ {
-                                }
+            // start value element
+            contentHandler.startElement(NS_SV_URI, VALUE_ELEMENT, NS_SV_PREFIX + ":" + VALUE_ELEMENT, new AttributesImpl());
-                                public void flush() /*throws IOException*/ {
-                                }
-
-                                public void write(char[] cbuf, int off, int len) throws IOException {
-                                    try {
-                                        contentHandler.characters(cbuf, off, len);
-                                    } catch (SAXException se) {
-                                        throw new IOException(se.toString());
-                                    }
-                                }
-                            };
-                            try {
-                                Base64.encode(in, writer);
-                                in.close();
-                                writer.close();
-                            } catch (IOException ioe) {
-                                // check if the exception wraps a SAXException
-                                Throwable t = ioe.getCause();
-                                if (t != null && t instanceof SAXException) {
-                                    throw (SAXException) t;
-                                } else {
-                                    throw new SAXException(ioe);
-                                }
-                            }
-                        }
-                    } else {
-                        char[] chars = values[i].toJCRValue(nsReg).getString().toCharArray();
-                        contentHandler.characters(chars, 0, chars.length);
+            // characters
+            if (prop.getType() == PropertyType.BINARY) {
+                // binary data, base64 encoding required
+                InputStream in = val.getStream();
+                Writer writer = new Writer() {
+                    public void close() /*throws IOException*/ {
-                    // end value element
-                    contentHandler.endElement(NS_SV_URI, VALUE_ELEMENT, NS_SV_PREFIX + ":" + VALUE_ELEMENT);
+                    public void flush() /*throws IOException*/ {
+                    }
+
+                    public void write(char[] cbuf, int off, int len) throws IOException {
+                        try {
+                            contentHandler.characters(cbuf, off, len);
+                        } catch (SAXException se) {
+                            throw new IOException(se.toString());
+                        }
+                    }
+                };
+                try {
+                    Base64.encode(in, writer);
+                    // no need to close our Writer implementation
+                    //writer.close();
+                } catch (IOException ioe) {
+                    // check if the exception wraps a SAXException
+                    Throwable t = ioe.getCause();
+                    if (t != null && t instanceof SAXException) {
+                        throw (SAXException) t;
+                    } else {
+                        throw new SAXException(ioe);
+                    }
+                } finally {
+                    try {
+                        in.close();
+                    } catch (IOException e) {
+                        // ignore
+                    }
+            } else {
+                char[] chars = val.getString().toCharArray();
+                contentHandler.characters(chars, 0, chars.length);
+            // end value element
+            contentHandler.endElement(NS_SV_URI, VALUE_ELEMENT, NS_SV_PREFIX + ":" + VALUE_ELEMENT);
-     * @see AbstractSAXEventGenerator#leaving(PropertyState, int)
+     * @see AbstractSAXEventGenerator#leaving(PropertyImpl, int)
-    protected void leaving(PropertyState state, int level)
+    protected void leaving(PropertyImpl prop, int level)
+        if (prop.getType() == PropertyType.BINARY && skipBinary) {
+            return;
+        }

MOV26 UPD40 MOV44 MOV43 MOV43 MOV44 MOV43 MOV43 MOV8 UPD43 UPD42 UPD42 UPD43 UPD42 UPD43 UPD42 INS60 UPD43 UPD42 UPD43 UPD42 UPD43 UPD42 UPD43 UPD42 INS25 INS60 MOV60 MOV54 MOV60 INS21 INS60 MOV60 MOV54 MOV21 MOV21 MOV60 INS60 INS25 INS24 UPD43 UPD42 INS25 UPD42 UPD66 UPD66 UPD66 UPD42 UPD66 UPD42 UPD66 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV43 INS59 UPD42 UPD42 UPD42 UPD42 INS27 INS8 MOV43 INS59 INS32 INS39 INS59 INS39 INS5 INS59 INS42 INS8 INS8 MOV58 INS27 MOV37 MOV8 UPD42 INS27 INS8 INS42 INS32 MOV69 MOV69 INS27 INS42 INS41 INS42 INS32 UPD42 INS42 INS42 INS42 INS42 MOV27 INS42 INS42 INS42 INS32 UPD42 INS43 INS85 INS42 MOV21 INS21 UPD42 MOV42 INS40 INS60 MOV21 MOV21 INS27 INS42 INS41 UPD43 INS42 INS42 INS32 UPD43 UPD43 UPD43 UPD43 INS32 MOV40 INS42 INS42 INS42 INS42 UPD42 INS42 INS7 INS7 INS43 INS59 INS27 INS8 UPD43 INS32 INS40 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 UPD42 INS42 UPD42 INS42 INS32 INS42 INS3 INS42 INS42 INS2 INS32 INS40 MOV60 MOV21 INS42 INS42 UPD42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS32 UPD42 MOV42 UPD42 MOV42 INS5 INS4 INS42 INS42 INS42 UPD42 MOV42 INS8 INS42 UPD42 MOV42 UPD42 MOV42 INS43 INS85 INS32 INS54 MOV42 MOV34 MOV40 INS32 INS32 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 INS8 INS12 INS32 UPD42 MOV42 INS42 UPD42 MOV42 INS42 MOV21 INS44 INS8 UPD42 MOV42 INS42 INS43 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL43 DEL69 DEL42 DEL43 DEL42 DEL44 DEL32 DEL42 DEL32 DEL34 DEL27 DEL42 DEL43 DEL69 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL69 DEL42 DEL43 DEL42 DEL44 DEL69 DEL42 DEL43 DEL42 DEL44 DEL32 DEL39 DEL85 DEL5 DEL42 DEL42 DEL2 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL32 DEL14 DEL32 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL2 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL27 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL40 DEL27 DEL42 DEL27 DEL42 DEL40 DEL7 DEL21 DEL8 DEL25 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL40 DEL34 DEL27 DEL27 DEL42 DEL40 DEL27 DEL42 DEL42 DEL2 DEL33 DEL27 DEL25 DEL8 DEL24 DEL8 DEL25 DEL8
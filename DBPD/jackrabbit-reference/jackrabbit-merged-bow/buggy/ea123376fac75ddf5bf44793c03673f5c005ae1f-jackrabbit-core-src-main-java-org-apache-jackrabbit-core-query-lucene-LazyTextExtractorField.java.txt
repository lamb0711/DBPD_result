JCR-1878: Use Apache Tika for text extraction

Replace jackrabbit-text-extractors with a direct Apache Tika dependency.

A simple backwards compatibility layer is included for existing textFilterClasses="..." configurations. Only the org.apache.jackrabbit.extractor classes are recognized and mapped to Tika alternatives.

Added two simple text extraction integration tests.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@815774 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.InputStream;
+import java.io.Reader;
+import java.util.concurrent.Executor;
+
+import org.apache.jackrabbit.core.value.InternalValue;
+import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.commons.io.IOUtils;
-import org.slf4j.LoggerFactory;
+import org.apache.lucene.document.Field.Store;
+import org.apache.lucene.document.Field.TermVector;
+import org.apache.tika.metadata.Metadata;
+import org.apache.tika.parser.Parser;
+import org.apache.tika.sax.BodyContentHandler;
-
-import java.io.Reader;
-import java.io.IOException;
+import org.slf4j.LoggerFactory;
+import org.xml.sax.ContentHandler;
-     * The serial version UID.
-     */
-    private static final long serialVersionUID = -2707986404659820071L;
-
-    /**
-    private static final Logger log = LoggerFactory.getLogger(LazyTextExtractorField.class);
+    private static final Logger log =
+        LoggerFactory.getLogger(LazyTextExtractorField.class);
-     * The reader from where to read the text extract.
+     * The extracted text content of the given binary value.
+     * Set to non-null when the text extraction task finishes.
-    private final Reader reader;
-
-    /**
-     * The extract as obtained lazily from {@link #reader}.
-     */
-    private String extract;
+    private volatile String extract = null;
-     * @param store when set <code>true</code> the string value is stored in the
-     *          index.
-     * @param withOffsets when set <code>true</code> a term vector with offsets
-     *          is written into the index.
+     * @param highlighting set to <code>true</code> to
+     *                     enable result highlighting support
-    public LazyTextExtractorField(String name,
-                                  Reader reader,
-                                  boolean store,
-                                  boolean withOffsets) {
-        super(name,
-                store ? Field.Store.YES : Field.Store.NO,
+    public LazyTextExtractorField(
+            Parser parser, InternalValue value, Metadata metadata,
+            Executor executor, boolean highlighting) {
+        super(FieldNames.FULLTEXT,
+                highlighting ? Store.YES : Store.NO,
-                withOffsets ? Field.TermVector.WITH_OFFSETS : Field.TermVector.NO);
-        this.reader = reader;
+                highlighting ? TermVector.WITH_OFFSETS : TermVector.NO);
+        executor.execute(new ParsingTask(parser, value, metadata));
-     * @return the string value of this field.
+     * Returns the extracted text. This method blocks until the text
+     * extraction task has been completed.
+     *
+     * @return the string value of this field
-    public String stringValue() {
-        if (extract == null) {
-            StringBuffer textExtract = new StringBuffer();
-            char[] buffer = new char[1024];
-            int len;
-            try {
-                while ((len = reader.read(buffer)) > -1) {
-                    textExtract.append(buffer, 0, len);
-                }
-            } catch (IOException e) {
-                log.warn("Exception reading value for field: "
-                        + e.getMessage());
-                log.debug("Dump:", e);
-            } finally {
-                IOUtils.closeQuietly(reader);
+    public synchronized String stringValue() {
+        try {
+            while (!isExtractorFinished()) {
+                wait();
-            extract = textExtract.toString();
+            return extract;
+        } catch (InterruptedException e) {
+            log.error("Text extraction thread was interrupted", e);
+            return "";
-        return extract;
-     * @return always <code>null</code>.
+     * @return always <code>null</code>
-     * @return always <code>null</code>.
+     * @return always <code>null</code>
-     * @return always <code>null</code>.
+     * @return always <code>null</code>
-     * @return <code>true</code> if the underlying reader is ready to provide
-     *          extracted text.
+     * Checks whether the text extraction task has finished.
+     *
+     * @return <code>true</code> if the extracted text is available
-        if (reader instanceof TextExtractorReader) {
-            return ((TextExtractorReader) reader).isExtractorFinished();
-        }
-        return true;
+        return extract != null;
+    }
+
+    private synchronized void setExtractedText(String value) {
+        extract = value;
+        notify();
-     * Disposes this field and closes the underlying reader.
-     *
-     * @throws IOException if an error occurs while closing the reader.
+     * Releases all resources associated with this field.
-    public void dispose() throws IOException {
-        reader.close();
+    public void dispose() {
+        // TODO: Cause the ContentHandler below to throw an exception
+
+    /**
+     * The background task for extracting text from a binary value.
+     */
+    private class ParsingTask implements Runnable {
+
+        private final Parser parser;
+
+        private final InternalValue value;
+
+        private final Metadata metadata;
+
+        public ParsingTask(
+                Parser parser, InternalValue value, Metadata metadata) {
+            this.parser = parser;
+            this.value = value;
+            this.metadata = metadata;
+        }
+
+        public void run() {
+            ContentHandler handler = new BodyContentHandler();
+            try {
+                InputStream stream = value.getStream();
+                try {
+                    parser.parse(stream, handler, metadata);
+                } finally {
+                    stream.close();
+                }
+            } catch (Throwable t) {
+                log.warn("Failed to extract text from a binary property", t);
+            } finally {
+                value.discard();
+            }
+            setExtractedText(handler.toString());
+        }
+
+    }
+

MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV23 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 UPD40 INS40 INS31 INS31 INS31 INS31 INS31 INS55 UPD83 MOV43 MOV29 INS83 INS42 INS44 INS44 MOV44 MOV44 MOV44 MOV8 MOV29 MOV83 INS83 MOV43 MOV42 INS8 INS29 INS83 INS39 INS42 INS8 INS83 INS83 INS39 INS42 MOV44 INS8 MOV29 MOV83 UPD39 MOV39 UPD42 MOV42 INS8 INS29 INS83 INS42 INS43 INS23 INS23 INS23 INS31 MOV31 UPD42 INS33 INS43 INS42 INS43 INS42 UPD43 UPD42 INS43 INS42 UPD42 INS65 INS54 INS65 INS65 INS41 UPD42 MOV21 INS21 UPD65 INS65 INS42 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS42 INS44 INS44 INS44 INS8 UPD42 INS8 UPD66 INS66 UPD42 UPD66 UPD66 UPD42 MOV42 INS42 UPD42 INS42 INS40 INS32 INS66 INS66 UPD66 MOV8 MOV12 UPD66 UPD66 UPD66 INS66 INS66 INS27 INS32 UPD66 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS21 INS21 INS21 INS60 INS54 INS21 UPD42 UPD40 UPD40 UPD42 UPD40 UPD40 INS42 INS42 INS14 MOV41 INS42 INS33 INS42 INS42 UPD42 MOV42 INS42 INS42 INS7 INS7 INS7 INS43 INS59 INS8 INS12 INS8 INS32 INS43 INS42 INS42 INS42 INS38 UPD43 INS41 INS22 INS42 INS22 INS42 INS22 INS42 INS42 INS42 INS14 INS60 INS54 INS44 INS8 INS21 INS42 INS32 INS42 INS32 UPD42 INS45 INS52 INS42 INS52 INS42 INS52 INS42 INS43 INS43 INS59 INS8 INS8 INS43 INS42 INS21 INS32 INS42 INS42 UPD42 MOV42 UPD42 INS45 MOV42 INS42 UPD42 MOV42 INS42 INS32 INS21 MOV21 INS42 INS32 INS42 INS42 UPD42 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 DEL83 DEL39 DEL34 DEL38 DEL42 DEL66 DEL66 DEL65 DEL39 DEL42 DEL42 DEL52 DEL42 DEL22 DEL42 DEL7 DEL42 DEL42 DEL42 DEL32 DEL7 DEL36 DEL34 DEL38 DEL27 DEL42 DEL42 DEL34 DEL42 DEL45 DEL42 DEL32 DEL27 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL66 DEL65 DEL29 DEL83 DEL83 DEL43 DEL42 DEL59 DEL23 DEL66 DEL42 DEL67 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL59 DEL23 DEL83 DEL42 DEL31 DEL42 DEL33 DEL27 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL39 DEL85 DEL5 DEL42 DEL39 DEL85 DEL5 DEL34 DEL3 DEL59 DEL60 DEL39 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL25 DEL8 DEL31 DEL42 DEL42 DEL32 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL43 DEL8 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL41 DEL8 DEL25 DEL9 DEL41 DEL8 DEL31
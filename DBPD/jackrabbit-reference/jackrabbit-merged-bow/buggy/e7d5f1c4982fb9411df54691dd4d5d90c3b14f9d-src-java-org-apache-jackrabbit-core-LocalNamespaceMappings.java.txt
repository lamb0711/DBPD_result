JCR-242: locally remap conflicting prefix if the registration of a new global prefix collides with a session-local prefix

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@327199 13f79535-47bb-0310-9956-ffa450edef68

-        implements NamespaceListener{
+        implements NamespaceListener {
-                throw new NamespaceException(prefix + ": prefix is already mapped to the namespace: " + globalURI);
+                throw new NamespaceException(prefix
+                        + ": prefix is already mapped to the namespace: "
+                        + globalURI);
+    /**
+     * {@inheritDoc}
+     */
+    public QName getQName(String name)
+            throws IllegalNameException, UnknownPrefixException {
+        if (prefixToURI.isEmpty()) {
+            // shortcut
+            return nsReg.getQName(name);
+        }
+        try {
+            // first try registry, this might result in a wrong QName because
+            // of locally overlayed mappings
+            QName candidate = nsReg.getQName(name);
+            // check if valid
+            String prefix = nsReg.getPrefix(candidate.getNamespaceURI());
+            if (!hiddenPrefixes.contains(prefix)) {
+                return candidate;
+            }
+        } catch (UnknownPrefixException e) {
+            // try using local mappings
+        } catch (NamespaceException e) {
+            // may be thrown by nsReg.getPrefix() but should never happend
+            // because we got the namespace from the nsReg itself
+            throw new UnknownPrefixException(name);
+        }
+        return super.getQName(name);
+    }
+
-    public QName getQName(String name)
-            throws IllegalNameException, UnknownPrefixException {
-        if (prefixToURI.isEmpty()) {
-            // shortcut
-            return nsReg.getQName(name);
-        }
-        try {
-            // first try registry, this might result in a wrong QName because
-            // of locally overlayed mappings
-            QName candidate = nsReg.getQName(name);
-            // check if valid
-            String prefix = nsReg.getPrefix(candidate.getNamespaceURI());
-            if (!hiddenPrefixes.contains(prefix)) {
-                return candidate;
-            }
-        } catch (UnknownPrefixException e) {
-            // try using local mappings
-        } catch (NamespaceException e) {
-            // may be thrown by nsReg.getPrefix() but should never happend
-            // because we got the namespace from the nsReg itself
-            throw new UnknownPrefixException(name);
-        }
-        return super.getQName(name);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
+    //----------------------------------------------------< NamespaceListener >
-     * This method gets called when the NamespaceRegistry remapped a namespace
-     * to a new prefix or if a new namespace is registered.
+     * This method gets called when a new namespace is registered in
+     * the global NamespaceRegistry. Overridden in order to check for/resolve
+     * collision of new global prefix with existing local prefix.
-    public void prefixRemapped(String prefix, String uri) {
-        // todo check overlayed mappings and adjust prefixes if necessary
+    public void namespaceAdded(String prefix, String uri) {
+        if (prefixToURI.containsKey(prefix)) {
+            // the new global prefix is already in use locally;
+            // need to change it locally by appending underscore(s)
+            // in order to guarantee unambiguous mappings
+            String uniquePrefix = prefix + "_";
+            while (prefixToURI.containsKey(uniquePrefix)) {
+                uniquePrefix += "_";
+            }
+            // add new local mapping
+            prefixToURI.put(uniquePrefix, uri);
+            uriToPrefix.put(uri, uniquePrefix);
+        }
+    }
+
+    /**
+     * @inheritDoc
+     * This method gets called when an existing namespace is remapped to a new
+     * prefix in the global NamespaceRegistry. Overridden in order to check
+     * for/resolve collision of new global prefix with existing local prefix.
+     */
+    public void namespaceRemapped(String oldPrefix, String newPrefix, String uri) {
+        if (prefixToURI.containsKey(newPrefix)) {
+            // the new global prefix is already in use locally;
+            // check uri
+            if (uriToPrefix.containsKey(uri)) {
+                // since namespace is already remapped locally to
+                // a different prefix there's no collision
+                return;
+            }
+            // need to change enw prefix locally by appending underscore(s)
+            // in order to guarantee unambiguous mappings
+            String uniquePrefix = newPrefix + "_";
+            while (prefixToURI.containsKey(uniquePrefix)) {
+                uniquePrefix += "_";
+            }
+            // add new local mapping
+            prefixToURI.put(uniquePrefix, uri);
+            uriToPrefix.put(uri, uniquePrefix);
+        }

MOV31 INS31 INS29 INS83 INS39 INS42 MOV44 MOV44 INS8 UPD42 INS44 INS44 INS44 INS8 INS65 INS25 INS43 INS42 INS43 INS42 INS43 INS42 INS25 INS66 INS66 INS66 INS32 INS8 UPD66 UPD66 INS66 INS42 INS42 INS42 INS32 INS8 INS42 INS42 INS42 INS60 INS61 INS21 INS21 INS42 INS42 INS42 INS25 INS60 INS61 INS21 INS21 INS43 INS59 INS32 INS8 INS32 INS32 INS32 INS8 INS43 INS59 INS32 INS8 INS32 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS41 INS42 INS42 INS27 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS7 INS42 INS45 INS7 INS42 INS45 INS42 INS45 DEL8
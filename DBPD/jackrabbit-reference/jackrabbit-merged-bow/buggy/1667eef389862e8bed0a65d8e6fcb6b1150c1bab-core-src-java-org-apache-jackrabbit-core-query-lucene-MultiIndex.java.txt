JCR-177: Commit volatile index to disc after some configurable idle time

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@231015 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Timer;
+import java.util.TimerTask;
- * the volatile index reaches a certain size (see {@link SearchIndex#setMinMergeDocs(int)} a
- * new persistent index is created with the index data from the volatile index.
- * the new persistent index is then added to the list of already existing
- * persistent indexes. Furhter operations on the new persistent index will
+ * the volatile index reaches a certain size (see {@link SearchIndex#setMinMergeDocs(int)})
+ * a new persistent index is created with the index data from the volatile index,
+ * the same happens when the volatile index has been idle for some time (see
+ * {@link SearchIndex#setVolatileIdleTime(int)}).
+ * The new persistent index is then added to the list of already existing
+ * persistent indexes. Further operations on the new persistent index will
+     * The last time this index was modified. That is, a document was added
+     * or removed.
+     */
+    private long lastModificationTime;
+
+    /**
+     * Timer to schedule commits of the volatile index after some idle time.
+     */
+    private final Timer commitTimer = new Timer(true);
+
+    /**
+        lastModificationTime = System.currentTimeMillis();
+        startCommitTimer();
+        lastModificationTime = System.currentTimeMillis();
+        lastModificationTime = System.currentTimeMillis();
+        lastModificationTime = System.currentTimeMillis();
+        // stop timer
+        commitTimer.cancel();
+
+        // commit / close indexes
+     * Starts the commit timer that periodically checks if the volatile index
+     * should be committed. The timer task will call {@link #checkCommit()}.
+     */
+    private void startCommitTimer() {
+        commitTimer.schedule(new TimerTask() {
+            public void run() {
+                checkCommit();
+            }
+        }, 0, 1000);
+    }
+
+    /**
+     * Checks the duration between the last modification to this index and the
+     * current time and commits the volatile index (if there are changes at all)
+     * if the duration (idle time) is more than {@link SearchIndex#getVolatileIdleTime()}
+     * seconds.
+     */
+    private synchronized void checkCommit() {
+        long idleTime = System.currentTimeMillis() - lastModificationTime;
+        // do not commit if volatileIdleTime is zero or negative
+        if (handler.getVolatileIdleTime() > 0
+                && idleTime > handler.getVolatileIdleTime() * 1000) {
+            try {
+                if (volatileIndex.getRedoLog().hasEntries()) {
+                    log.info("Committing in-memory index after being idle for " +
+                            idleTime + " ms.");
+                    commit();
+                }
+            } catch (IOException e) {
+                log.error("Unable to commit volatile index", e);
+            }
+        }
+    }
+
+    /**

INS26 INS26 INS40 INS40 INS23 INS23 INS31 INS31 INS29 INS83 INS39 INS59 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS83 INS39 INS42 INS8 UPD66 UPD66 INS66 INS65 INS66 UPD66 UPD66 INS65 INS42 INS65 INS42 INS42 INS14 INS21 INS21 INS21 INS21 INS21 INS21 INS65 INS21 INS65 INS60 INS25 INS68 INS66 INS66 INS66 INS43 INS9 INS7 INS32 INS7 INS7 INS7 INS32 INS66 INS66 INS65 INS66 INS32 INS66 INS66 INS66 INS65 INS66 INS39 INS59 INS27 INS8 INS42 INS42 INS69 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS68 INS42 INS42 INS14 INS34 INS34 INS68 INS42 INS27 INS27 INS27 INS54 INS39 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS1 INS42 INS42 INS32 INS42 INS32 INS34 INS42 INS27 INS8 INS12 INS42 INS31 INS42 INS42 INS42 INS42 INS32 INS34 INS25 INS44 INS8 INS83 INS39 INS42 INS8 INS42 INS42 INS32 INS8 INS43 INS42 INS21 INS21 INS32 INS42 INS21 INS21 INS42 INS32 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS27 INS42 INS45 INS42 INS45
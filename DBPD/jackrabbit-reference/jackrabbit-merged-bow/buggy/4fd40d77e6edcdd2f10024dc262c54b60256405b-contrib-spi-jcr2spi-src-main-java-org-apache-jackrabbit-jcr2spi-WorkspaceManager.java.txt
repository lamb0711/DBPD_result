- add commons-codec dependency to client project.xml
- add concurrent dependency to jcr2spi project.xml
- remove events again from operation methods on RepositoryService.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@472888 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.EventFilter;
+import java.util.Collections;
+import EDU.oswego.cs.dl.util.concurrent.Channel;
+import EDU.oswego.cs.dl.util.concurrent.Sync;
+import EDU.oswego.cs.dl.util.concurrent.Latch;
+import EDU.oswego.cs.dl.util.concurrent.LinkedQueue;
+
+     * A producer for this channel can request an immediate poll for events
+     * by placing a Sync into the channel. The Sync is released when the event
+     * poll finished.
+     */
+    private final Channel immediateEventRequests = new LinkedQueue();
+
+    /**
-    private Set listeners = new HashSet();
+    private final Set listeners = Collections.synchronizedSet(new HashSet());
+    /**
+     * Creates an event filter based on the parameters available in {@link
+     * javax.jcr.observation.ObservationManager#addEventListener}.
+     *
+     * @param eventTypes   A combination of one or more event type constants
+     *                     encoded as a bitmask.
+     * @param path         an absolute path.
+     * @param isDeep       a <code>boolean</code>.
+     * @param uuids        array of UUIDs.
+     * @param nodeTypes    array of node type names.
+     * @param noLocal      a <code>boolean</code>.
+     * @return the event filter instance with the given parameters.
+     * @throws UnsupportedRepositoryOperationException
+     *          if this implementation does not support observation.
+     */
+    public EventFilter createEventFilter(int eventTypes,
+                                         Path path,
+                                         boolean isDeep,
+                                         String[] uuids,
+                                         QName[] nodeTypes,
+                                         boolean noLocal)
+            throws UnsupportedRepositoryOperationException {
+        return service.createEventFilter(eventTypes, path, isDeep, uuids, nodeTypes, noLocal);
+    }
+
-        WorkspaceItemStateManager ism = new WorkspaceItemStateManager(isf, service.getIdFactory());
+        WorkspaceItemStateManager ism = new WorkspaceItemStateManager(this, isf, service.getIdFactory());
+        Sync eventSignal;
+            eventSignal = getEventPollingRequest();
+        }
+        try {
+            eventSignal.acquire();
+        } catch (InterruptedException e) {
+            Thread.interrupted();
+            log.warn("Interrupted while waiting for events from RepositoryService");
+        Sync eventSignal;
+            changes.persisted();
+            eventSignal = getEventPollingRequest();
+        }
+        try {
+            eventSignal.acquire();
+        } catch (InterruptedException e) {
+            Thread.interrupted();
+            log.warn("Interrupted while waiting for events from RepositoryService");
-     * changes have been applied to the repository. Depending on <code>changeLog</code>
-     * this method is called as a result of:
-     * <ul>
-     * <li>a local <code>save</code> of transient changes. In this case
-     * <code>changeLog</code> is non-<code>null</code>.</li>
-     * <li>an execution of a workspace operation. In this case
-     * <code>changeLog</code> is <code>null</code></li>
-     * <li>an external change to the workspace (another session modified the
-     * workspace). In this case <code>changeLog</code> is <code>null</code></li>
-     * </ul>
+     * changes have been applied to the repository.
-     * @param events    the events generated by the repository service as a
-     *                  response to the executed operation(s).
-     * @param changeLog the local <code>ChangeLog</code> which contains the
-     *                  affected transient <code>ItemState</code>s and the
-     *                  relevant {@link Operation}s that lead to the
-     *                  modifications. If <code>null</code> this method is
-     *                  called as a consequence of an external change or a call
-     *                  of a workspace operation. In that case there are no
-     *                  local transient changes.
+     * @param events the events generated by the repository service as the
+     *               effect of a change.
-    private void onEventReceived(EventBundle[] events, ChangeLog changeLog) {
+    private void onEventReceived(EventBundle[] events) {
-            EventBundle bundle = events[i];
-            if (bundle.isLocal() && changeLog != null) {
-                // local change from batch operation
-                for (int j = 0; j < lstnrs.length; j++) {
-                    lstnrs[j].onEvent(bundle, changeLog);
-                }
-            } else {
-                // external change or workspace operation
-                for (int j = 0; j < lstnrs.length; j++) {
-                    lstnrs[j].onEvent(bundle);
-                }
+            for (int j = 0; j < lstnrs.length; j++) {
+                lstnrs[j].onEvent(events[i]);
-        private EventBundle[] events;
-                    events = service.submit(batch);
-                    onEventReceived(events, changeLog);
+                    service.submit(batch);
-            boolean success = false;
-            try {
-                log.info("executing: " + workspaceOperation);
-                workspaceOperation.accept(this);
-                success = true;
-            } finally {
-                if (success && events != null) {
-                    // a workspace operation is like an external change: there
-                    // is no changelog to persist. but still the events must
-                    // be reported as local changes.
-                    onEventReceived(events, null);
-                }
-            }
+            log.info("executing: " + workspaceOperation);
+            workspaceOperation.accept(this);
-            events = service.clone(sessionInfo, operation.getWorkspaceName(), nId, destParentId, operation.getDestinationName(), operation.isRemoveExisting());
+            service.clone(sessionInfo, operation.getWorkspaceName(), nId, destParentId, operation.getDestinationName(), operation.isRemoveExisting());
-            events = service.copy(sessionInfo, operation.getWorkspaceName(), nId, destParentId, operation.getDestinationName());
+            service.copy(sessionInfo, operation.getWorkspaceName(), nId, destParentId, operation.getDestinationName());
-                events = service.move(sessionInfo, moveId, destParentId, operation.getDestinationName());
+                service.move(sessionInfo, moveId, destParentId, operation.getDestinationName());
-            events = service.update(sessionInfo, nId, operation.getSourceWorkspaceName());
+            service.update(sessionInfo, nId, operation.getSourceWorkspaceName());
-            events = service.checkout(sessionInfo, operation.getNodeState().getNodeId());
+            service.checkout(sessionInfo, operation.getNodeState().getNodeId());
-            events = service.checkin(sessionInfo, operation.getNodeState().getNodeId());
+            service.checkin(sessionInfo, operation.getNodeState().getNodeId());
-                events = service.restore(sessionInfo, vIds, operation.removeExisting());
+                service.restore(sessionInfo, vIds, operation.removeExisting());
-                events = service.restore(sessionInfo, targetId, vIds[0], operation.removeExisting());
+                service.restore(sessionInfo, targetId, vIds[0], operation.removeExisting());
-            events = service.merge(sessionInfo, nId, operation.getSourceWorkspaceName(), operation.bestEffort());
-            List externalEventBundles = new ArrayList();
-            for (int i = 0; i < events.length; i++) {
-                if (events[i].isLocal()) {
-                    // todo: improve.... inform operation about modified items (build mergefailed iterator)
-                    operation.getEventListener().onEvent(events[i]);
-                } else {
-                    // otherwise dispatch as external event
-                    externalEventBundles.add(events[i]);
-                }
-            }
-            if (!externalEventBundles.isEmpty()) {
-                EventBundle[] bundles = (EventBundle[]) externalEventBundles.toArray(new EventBundle[externalEventBundles.size()]);
-                onEventReceived(bundles, null);
-            }
+            // todo service should return ids of failed nodes
+            service.merge(sessionInfo, nId, operation.getSourceWorkspaceName(), operation.bestEffort());
-                events = service.resolveMergeConflict(sessionInfo, nId, mergeFailedIds, predecessorIds);
+                service.resolveMergeConflict(sessionInfo, nId, mergeFailedIds, predecessorIds);
-            events = service.lock(sessionInfo, nId, operation.isDeep(), operation.isSessionScoped());
+            service.lock(sessionInfo, nId, operation.isDeep(), operation.isSessionScoped());
-            events = service.refreshLock(sessionInfo, nId);
+            service.refreshLock(sessionInfo, nId);
-            events = service.unlock(sessionInfo, nId);
+            service.unlock(sessionInfo, nId);
-            events = service.addVersionLabel(sessionInfo, vhId, vId, operation.getLabel(), operation.moveLabel());
+            service.addVersionLabel(sessionInfo, vhId, vId, operation.getLabel(), operation.moveLabel());
-            events = service.removeVersionLabel(sessionInfo, vhId, vId, operation.getLabel());
+            service.removeVersionLabel(sessionInfo, vhId, vId, operation.getLabel());
+     * Requests an immediate poll for events. The returned Sync will be
+     * released by the event polling thread when events have been retrieved.
+     */
+    private Sync getEventPollingRequest() {
+        Sync signal;
+        if (externalChangeFeed != null) {
+            // observation supported
+            signal = new Latch();
+            try {
+                immediateEventRequests.put(signal);
+            } catch (InterruptedException e) {
+                log.warn("Unable to request immediate event poll: " + e);
+            }
+        } else {
+            // no observation, return a dummy sync which can be acquired immediately
+            signal = new Sync() {
+                public void acquire() {
+                }
+
+                public boolean attempt(long l) {
+                    return true;
+                }
+
+                public void release() {
+                    throw new UnsupportedOperationException();
+                }
+            };
+        }
+        return signal;
+    }
+
+    /**
-                    Thread.sleep(pollingInterval);
-                } catch (InterruptedException e) {
-                    // terminate
-                    break;
-                }
-                try {
+                    // wait for a signal to do an immediate poll but wait at
+                    // most EXTERNAL_EVENT_POLLING_INTERVAL
+                    Sync signal = (Sync) immediateEventRequests.poll(pollingInterval);
+
-                        EventBundle[] bundles = service.getEvents(sessionInfo, 0);
+                        // if this thread was waiting for updateMonitor and now
+                        // enters this synchronized block, then a user thread
+                        // has just finished an operation and will probably
+                        // request an immediate event poll. That's why we
+                        // check here again for a sync signal
+                        if (signal == null) {
+                            signal = (Sync) immediateEventRequests.poll(0);
+                        }
+
+                        if (signal != null) {
+                            log.debug("Request for immediate event poll");
+                        }
+
+                        // get filters from listeners
+                        List filters = new ArrayList();
+                        InternalEventListener[] iel = (InternalEventListener[]) listeners.toArray(new InternalEventListener[0]);
+                        for (int i = 0; i < iel.length; i++) {
+                            filters.addAll(iel[i].getEventFilters());
+                        }
+                        EventBundle[] bundles = service.getEvents(sessionInfo,
+                                0, (EventFilter[]) filters.toArray(
+                                        new EventFilter[filters.size()]));
-                            onEventReceived(bundles, null);
+                            onEventReceived(bundles);
+                        }
+                        if (signal != null) {
+                            log.debug("About to signal that events have been delivered");
+                            signal.release();
+                            log.debug("Event delivery signaled");
+                } catch (InterruptedException e) {
+                    // terminate
+                    break;

INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS31 INS31 INS29 INS83 INS83 INS43 INS59 INS83 INS29 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS44 INS44 INS43 INS8 INS8 INS8 INS29 INS83 INS43 INS42 INS8 INS65 INS42 INS42 INS14 INS32 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS39 INS42 INS43 INS42 INS39 INS42 INS5 INS42 INS5 INS42 INS39 INS42 INS42 INS41 INS60 MOV51 INS54 INS60 MOV51 INS54 MOV8 INS8 INS65 INS42 INS60 INS25 INS41 INS66 INS66 INS66 INS43 INS42 INS42 MOV14 INS66 INS65 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS43 INS85 INS43 INS85 INS32 INS43 INS59 INS8 INS12 INS43 INS59 INS8 INS12 UPD66 UPD66 UPD66 MOV8 MOV60 MOV21 INS66 INS66 INS43 INS59 INS27 INS8 INS8 INS42 INS42 INS67 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS21 INS44 INS8 INS42 INS42 INS21 INS21 INS21 INS44 INS8 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 INS42 INS42 INS42 INS33 INS21 INS54 INS21 INS8 INS40 INS42 INS52 INS7 INS32 INS43 INS42 INS21 INS21 INS32 INS7 INS32 INS43 INS42 INS21 INS21 INS7 INS8 INS12 INS7 INS54 INS42 INS32 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS32 MOV32 MOV32 MOV32 MOV32 INS42 INS14 INS21 INS44 INS8 INS42 INS14 INS8 MOV12 MOV12 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS45 INS43 INS32 INS43 INS42 INS21 INS43 INS1 INS60 MOV51 MOV2 MOV32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS31 INS31 INS31 INS43 INS59 INS42 INS42 INS27 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS8 INS42 INS42 INS11 INS25 INS25 MOV60 INS60 INS24 INS25 INS45 INS42 INS39 INS42 INS41 INS53 INS43 INS32 INS27 INS8 INS27 INS8 INS5 INS59 MOV58 INS27 MOV37 INS8 INS27 INS8 INS9 INS14 INS42 UPD42 MOV42 UPD42 MOV42 MOV42 INS42 INS33 INS21 INS42 INS33 INS21 UPD42 INS43 INS85 INS42 INS11 INS42 INS40 INS21 INS42 INS33 INS21 INS21 INS21 INS43 INS7 INS32 INS42 INS5 INS32 INS32 INS11 INS32 INS32 INS32 INS42 INS42 INS11 INS42 INS42 INS45 INS43 INS85 INS42 INS42 INS3 INS42 INS42 INS32 INS5 INS32 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS45 INS43 INS32 INS42 INS5 INS34 INS2 INS42 INS43 INS85 INS42 INS42 INS3 INS42 INS42 INS42 INS34 INS43 INS85 INS42 INS42 INS42 INS5 INS32 INS42 INS43 INS85 INS42 INS42 INS42 DEL8 DEL8 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL42 DEL66 DEL66 DEL66 DEL42 DEL65 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL2 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL33 DEL27 DEL27 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL24 DEL8 DEL25 DEL8 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL59 DEL23 DEL42 DEL7 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL42 DEL33 DEL27 DEL27 DEL42 DEL42 DEL33 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL42 DEL7 DEL42 DEL7 DEL42 DEL7 DEL42 DEL7 DEL42 DEL7 DEL42 DEL7 DEL42 DEL7 DEL42 DEL7 DEL42 DEL7 DEL42 DEL40 DEL27 DEL42 DEL42 DEL2 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL2 DEL32 DEL21 DEL8 DEL25 DEL8 DEL24 DEL42 DEL42 DEL32 DEL38 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL32 DEL3 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL33 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL7 DEL42 DEL7 DEL42 DEL7 DEL42 DEL7 DEL42 DEL7 DEL42 DEL7 DEL33 DEL32 DEL21 DEL8 DEL54 DEL8 DEL54 DEL8
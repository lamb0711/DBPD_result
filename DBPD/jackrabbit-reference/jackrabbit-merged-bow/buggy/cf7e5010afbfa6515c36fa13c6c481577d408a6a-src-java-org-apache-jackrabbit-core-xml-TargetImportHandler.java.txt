optimized value handling on import

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@160421 13f79535-47bb-0310-9956-ffa450edef68

+    /**
+     * Disposes all instances of <code>AppendableValue</code> contained in the
+     * given property info's value array.
+     * @param prop property info
+     */
-                    log.warn("error while disposing temporary value appender",
-                            ioe);
+                    log.warn("error while disposing temporary value", ioe);
+                    // fall through...
+     * <p/>
+     * <b>Important:</b> Note that in order to free resources
+     * <code>{@link #dispose()}</code> should be called as soon as an an
+     * <code>AppendableValue</code> object is not used anymore.
+        /**
+         * Append a portion of an array of characters.
+         * @param chars the characters to be appended
+         * @param start the index of the first character to append
+         * @param length the number of characters to append
+         * @throws IOException if an I/O error occurs
+         */
-                throws IllegalStateException, IOException;
+                throws IOException;
-         * @throws IOException
+         * Close this value. Once a value has been closed,
+         * further append() invocations will cause an IOException to be thrown.
+         *
+         * @throws IOException if an I/O error occurs
-         * @throws IOException
+         * Dispose this value, i.e. free all bound resources. Once a value has
+         * been disposed, further method invocations will cause an IOException
+         * to be thrown.
+         *
+         * @throws IOException if an I/O error occurs
-     * <code>StringBufferValue</code> represents an appendable serialized value
-     * that is internally backed by a <code>StringBuffer</code>.
+     * <code>BufferedStringValue</code> represents an appendable
+     * serialized value that is either buffered in-memory or backed
+     * by a temporary file if its size exceeds a certain limit.
+     * <p/>
+     * <b>Important:</b> Note that in order to free resources
+     * <code>{@link #dispose()}</code> should be called as soon as an
+     * <code>BufferedStringValue</code> instance is not used anymore.
-    protected class StringBufferValue implements AppendableValue {
-
-        private final StringBuffer buffer;
+    protected class BufferedStringValue implements AppendableValue {
-         * Constructs a new empty <code>StringBufferValue</code>.
+         * max size for buffering data in memory
-        protected StringBufferValue() {
-            buffer = new StringBuffer();
-        }
-
-        //--------------------------------------------------------< TextValue >
+        private static final int MAX_BUFFER_SIZE = 0x10000;
-         * {@inheritDoc}
+         * size of increment if capacity buffer needs to be enlarged
-        public long length() {
-            return buffer.length();
-        }
+        private static final int BUFFER_INCREMENT = 0x2000;
+        /**
+         * in-memory buffer
+         */
+        private char[] buffer;
+        /**
+         * current position within buffer (size of actual data in buffer)
+         */
+        private int bufferPos;
-         * {@inheritDoc}
+         * backing temporary file created when size of data exceeds
+         * MAX_BUFFER_SIZE
-        public String retrieve() {
-            return buffer.toString();
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public Reader reader() {
-            return new StringReader(buffer.toString());
-        }
-
-        //--------------------------------------------------< AppendableValue >
-        /**
-         * {@inheritDoc}
-         */
-        public void append(char[] chars, int start, int length) {
-            buffer.append(chars, start, length);
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public void close() {
-            // nop
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public void dispose() {
-            buffer.setLength(0);
-        }
-    }
-
-    /**
-     * <code>CLOBValue</code> represents an appendable serialized value
-     * that is internally backed by a temporary file.
-     */
-    protected class CLOBValue implements AppendableValue {
-
+        /**
+         * writer used to write to tmpFile; writer & tmpFile are always
+         * instantiated together, i.e. they are either both null or both not null.
+         */
-        protected CLOBValue() throws IOException {
-            tmpFile = File.createTempFile("bin", null);
-            writer = new FileWriter(tmpFile);
+        /**
+         * Constructs a new empty <code>BufferedStringValue</code>.
+         */
+        protected BufferedStringValue() {
+            buffer = new char[0x2000];
+            bufferPos = 0;
+            tmpFile = null;
+            writer = null;
-        public long length() throws IllegalStateException, IOException {
-            if (tmpFile == null) {
-                throw new IllegalStateException();
+        public long length() throws IOException {
+            if (buffer != null) {
+                return bufferPos;
+            } else if (tmpFile != null) {
+                writer.flush();
+                return tmpFile.length();
+            } else {
+                throw new IOException("this instance has already been disposed");
-            return tmpFile.length();
-        public String retrieve() throws IllegalStateException, IOException {
-            Reader reader = reader();
-            char[] chunk = new char[8192];
-            int read;
-            StringBuffer buf = new StringBuffer();
-            while ((read = reader.read(chunk)) > -1) {
-                buf.append(chunk, 0, read);
+        public String retrieve() throws IOException {
+            if (buffer != null) {
+                return new String(buffer, 0, bufferPos);
+            } else if (tmpFile != null) {
+                if (length() > Integer.MAX_VALUE) {
+                    throw new IOException("size of value is too big, use reader()");
+                }
+                StringBuffer sb = new StringBuffer((int) tmpFile.length());
+                char[] chunk = new char[0x2000];
+                int read;
+                Reader reader = new FileReader(tmpFile);
+                try {
+                    while ((read = reader.read(chunk)) > -1) {
+                        sb.append(chunk, 0, read);
+                    }
+                } finally {
+                    reader.close();
+                }
+                return sb.toString();
+            } else {
+                throw new IOException("this instance has already been disposed");
-            return buf.toString();
-        public Reader reader() throws IllegalStateException, IOException {
-            if (tmpFile == null) {
-                throw new IllegalStateException();
+        public Reader reader() throws IOException {
+            if (buffer != null) {
+                return new StringReader(new String(buffer, 0, bufferPos));
+            } else if (tmpFile != null) {
+                writer.flush();
+                return new FileReader(tmpFile);
+            } else {
+                throw new IOException("this instance has already been disposed");
-            return new FileReader(tmpFile);
-                throws IllegalStateException, IOException {
-            if (writer == null) {
-                throw new IllegalStateException();
+                throws IOException {
+            if (buffer != null) {
+                if (bufferPos + length > MAX_BUFFER_SIZE) {
+                    // threshold for keeping data in memory exceeded;
+                    // create temp file and spool buffer contents
+                    tmpFile = File.createTempFile("txt", null);
+                    writer = new FileWriter(tmpFile);
+                    writer.write(buffer, 0, bufferPos);
+                    writer.write(chars, start, length);
+                    // reset fields
+                    buffer = null;
+                    bufferPos = 0;
+                } else {
+                    if (bufferPos + length > buffer.length) {
+                        // reallocate new buffer and spool old buffer contents
+                        char[] newBuffer = new char[buffer.length + BUFFER_INCREMENT];
+                        System.arraycopy(buffer, 0, newBuffer, 0, bufferPos);
+                        buffer = newBuffer;
+                    }
+                    System.arraycopy(chars, start, buffer, bufferPos, length);
+                    bufferPos += length;
+                }
+            } else if (tmpFile != null) {
+                writer.write(chars, start, length);
+            } else {
+                throw new IOException("this instance has already been disposed");
-            writer.write(chars, start, length);
-            if (writer != null) {
+            if (buffer != null) {
+                // nop
+            } else if (tmpFile != null) {
-                writer = null;
+            } else {
+                throw new IOException("this instance has already been disposed");
-            close();
-            if (tmpFile != null) {
+            if (buffer != null) {
+                buffer = null;
+                bufferPos = 0;
+            } else if (tmpFile != null) {
+                writer.close();
+                writer = null;
+            } else {
+                throw new IOException("this instance has already been disposed");

INS55 INS29 MOV29 MOV83 UPD42 MOV42 MOV43 INS23 MOV23 INS23 INS23 MOV23 MOV23 MOV31 INS31 MOV31 INS31 INS31 MOV31 MOV31 INS65 INS65 INS29 INS83 INS39 INS42 MOV44 MOV44 MOV44 MOV43 MOV43 INS29 INS83 INS83 INS83 INS39 INS59 INS29 INS83 INS39 INS59 INS29 INS83 INS5 MOV59 INS29 INS83 INS39 INS59 INS29 INS29 UPD42 MOV29 MOV83 MOV39 MOV42 MOV43 INS8 INS8 MOV29 MOV83 MOV43 INS42 MOV43 INS8 MOV29 MOV83 MOV39 UPD42 MOV42 MOV44 MOV44 MOV44 MOV43 INS8 UPD42 MOV43 INS66 INS66 INS42 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS65 INS65 INS65 INS65 INS65 INS65 INS65 UPD66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 UPD66 INS65 INS42 INS34 INS65 INS42 INS34 INS65 INS39 INS85 INS65 INS42 INS65 INS65 INS21 INS21 MOV21 INS25 INS25 INS25 INS25 INS25 INS68 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS68 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 UPD66 INS7 INS7 INS27 INS8 INS25 INS27 INS8 INS25 INS27 INS8 INS25 INS27 INS8 INS25 UPD27 INS8 INS25 INS27 INS8 MOV25 INS42 INS42 INS3 INS42 INS34 INS42 INS33 INS42 INS33 MOV41 INS27 INS8 INS8 INS42 INS33 INS41 INS27 MOV8 INS8 INS42 INS33 MOV41 INS27 INS8 INS8 INS42 INS33 INS25 UPD27 MOV27 INS8 MOV8 UPD42 INS27 MOV8 MOV8 INS42 INS33 MOV21 INS21 INS8 INS5 INS34 INS42 INS42 INS33 INS21 MOV41 INS53 INS14 INS42 INS33 INS25 INS54 INS53 INS14 INS42 INS33 MOV21 MOV41 INS53 INS27 INS8 INS8 INS21 INS42 INS33 INS7 INS7 INS21 INS21 INS53 INS39 INS85 INS32 INS14 MOV43 INS42 INS34 INS42 INS27 INS8 MOV43 MOV5 MOV43 INS8 INS8 INS14 MOV43 INS14 INS14 INS27 INS42 MOV21 MOV21 INS21 MOV21 INS21 INS21 INS25 INS21 INS21 INS32 INS42 INS33 INS42 INS34 INS32 INS7 INS14 UPD42 MOV42 UPD42 MOV42 INS43 INS45 INS32 INS40 INS53 UPD42 INS14 UPD42 MOV61 INS21 UPD42 MOV43 INS45 INS43 INS42 INS34 INS42 UPD42 UPD42 INS43 INS45 INS42 INS42 INS32 INS7 INS7 INS27 INS8 INS32 INS7 INS42 INS42 INS42 INS42 INS42 UPD43 INS45 UPD43 INS45 INS42 INS42 INS42 INS33 INS43 INS45 INS42 INS42 INS14 MOV43 INS11 MOV5 UPD34 INS43 INS42 INS32 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS33 INS42 INS34 INS27 INS40 INS60 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS43 INS45 INS39 INS32 INS42 INS42 INS42 UPD45 INS42 INS42 INS5 INS59 INS32 INS7 UPD45 INS42 UPD42 MOV42 INS42 INS39 INS85 INS42 INS3 INS42 INS42 INS42 INS34 INS42 INS34 INS42 INS42 INS42 UPD42 INS5 INS27 INS39 INS85 INS40 UPD42 MOV42 DEL83 DEL39 DEL42 DEL39 DEL85 DEL5 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL14 DEL42 DEL42 DEL32 DEL43 DEL32 DEL42 DEL42 DEL32 DEL14 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL32 DEL42 DEL43 DEL65 DEL65 DEL29 DEL8 DEL31 DEL65 DEL65 DEL29 DEL83 DEL42 DEL32 DEL41 DEL8 DEL31 DEL65 DEL65 DEL29 DEL42 DEL43 DEL42 DEL8 DEL31 DEL65 DEL65 DEL29 DEL83 DEL39 DEL42 DEL8 DEL31 DEL65 DEL65 DEL29 DEL83 DEL39 DEL42 DEL8 DEL31 DEL65 DEL65 DEL29 DEL42 DEL42 DEL34 DEL32 DEL21 DEL8 DEL31 DEL55 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL83 DEL42 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL33 DEL27 DEL42 DEL43 DEL14 DEL53 DEL8 DEL25 DEL8 DEL31 DEL83 DEL42 DEL42 DEL43 DEL25 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL33 DEL27 DEL25 DEL8 DEL31 DEL55
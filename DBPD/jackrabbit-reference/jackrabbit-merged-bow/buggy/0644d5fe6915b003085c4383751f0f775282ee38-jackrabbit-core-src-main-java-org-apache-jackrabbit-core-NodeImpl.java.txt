JCR-1972: Preserving UUID and document version history on repository migration

Prepare to add the new checkin() signatures by cleaning up the deprecated versioning methods in NodeImpl.

Added a NodeImpl.getNodeState() method to avoid extra type casting.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@800478 13f79535-47bb-0310-9956-ffa450edef68

+import javax.jcr.version.VersionManager;
+import static org.apache.jackrabbit.spi.commons.name.NameConstants.JCR_ISCHECKEDOUT;
+     * Returns the node-state associated with this node.
+     *
+     * @return state associated with this node
+     */
+    NodeState getNodeState() {
+        return data.getNodeState();
+    }
+
+    /**
-        ChildNodeEntry entry = ((NodeState) parentNode.getItemState()).
-                getChildNodeEntry(getNodeId());
+        ChildNodeEntry entry =
+            parentNode.getNodeState().getChildNodeEntry(getNodeId());
-    public void update(String srcWorkspaceName)
-            throws NoSuchWorkspaceException, AccessDeniedException,
-            LockException, InvalidItemStateException, RepositoryException {
-        ((VersionManagerImpl) session.getWorkspace().getVersionManager()).update(this, srcWorkspaceName);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    public Version checkin()
-            throws VersionException, UnsupportedRepositoryOperationException,
-            InvalidItemStateException, LockException, RepositoryException {
-        return session.getWorkspace().getVersionManager().checkin(getPath());
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    public void checkout()
-            throws UnsupportedRepositoryOperationException, LockException,
-            RepositoryException {
-        session.getWorkspace().getVersionManager().checkout(getPath());
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    public NodeIterator merge(String srcWorkspace, boolean bestEffort)
-            throws NoSuchWorkspaceException, AccessDeniedException,
-            VersionException, LockException, InvalidItemStateException,
-            RepositoryException {
-        return session.getWorkspace().getVersionManager().merge(getPath(), srcWorkspace, bestEffort);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    public void cancelMerge(Version version)
-            throws VersionException, InvalidItemStateException,
-            UnsupportedRepositoryOperationException, RepositoryException {
-        session.getWorkspace().getVersionManager().cancelMerge(getPath(), version);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    public void doneMerge(Version version) throws VersionException,
-            InvalidItemStateException, UnsupportedRepositoryOperationException,
-            RepositoryException {
-        session.getWorkspace().getVersionManager().doneMerge(getPath(), version);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-        return internalIsCheckedOut();
-    }
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    public void restore(String versionName, boolean removeExisting)
-            throws VersionException, ItemExistsException,
-            UnsupportedRepositoryOperationException, LockException,
-            InvalidItemStateException, RepositoryException {
-
-        // checks
-        sanityCheck();
-        session.getWorkspace().getVersionManager().restore(getPath(), versionName, removeExisting);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    public void restore(Version version, boolean removeExisting)
-            throws VersionException, ItemExistsException,
-            UnsupportedRepositoryOperationException, LockException,
-            RepositoryException {
-
-        // do checks
-        sanityCheck();
-        session.getWorkspace().getVersionManager().restore(getPath(), version, removeExisting);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    public void restore(Version version, String relPath, boolean removeExisting)
-            throws PathNotFoundException, ItemExistsException, VersionException,
-            ConstraintViolationException, UnsupportedRepositoryOperationException,
-            LockException, InvalidItemStateException, RepositoryException {
-
-        // do checks
-        sanityCheck();
-        String path = getPath() + "/" + relPath;
-        session.getWorkspace().getVersionManager().restore(path, version, removeExisting);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    public void restoreByLabel(String versionLabel, boolean removeExisting)
-            throws VersionException, ItemExistsException,
-            UnsupportedRepositoryOperationException, LockException,
-            InvalidItemStateException, RepositoryException {
-
-        // do checks
-        sanityCheck();
-        session.getWorkspace().getVersionManager().restoreByLabel(getPath(), versionLabel, removeExisting);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    public VersionHistory getVersionHistory()
-            throws UnsupportedRepositoryOperationException, RepositoryException {
-        sanityCheck();
-        return session.getWorkspace().getVersionManager().getVersionHistory(getPath());
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Deprecated
-    public Version getBaseVersion()
-            throws UnsupportedRepositoryOperationException, RepositoryException {
-        // check state of this instance
-        sanityCheck();
-        return session.getWorkspace().getVersionManager().getBaseVersion(getPath());
-    }
-
-    //-----------------------------------< versioning support: implementation >
-    /**
-     * Determines the checked-out status of this node.
-     * <p/>
-     * A node is considered <i>checked-out</i> if it is versionable and
-     * checked-out, or is non-versionable but its nearest versionable ancestor
-     * is checked-out, or is non-versionable and there are no versionable
-     * ancestors.
-     *
-     * @return a boolean
-     * @see Node#isCheckedOut()
-     * @throws RepositoryException if an error occurs
-     */
-    protected boolean internalIsCheckedOut() throws RepositoryException {
-        /**
-         * try shortcut first:
-         * if current node is 'new' we can safely consider it checked-out
-         * since otherwise it would had been impossible to add it in the first
-         * place
-         */
+        // try shortcut first:
+        // if current node is 'new' we can safely consider it checked-out since
+        // otherwise it would had been impossible to add it in the first place
-        /**
-         * FIXME should not only rely on existence of jcr:isCheckedOut property
-         * but also verify that node.isNodeType("mix:versionable")==true;
-         * this would have a negative impact on performance though...
-         */
+        // FIXME should not only rely on existence of jcr:isCheckedOut property
+        // but also verify that node.isNodeType("mix:versionable")==true;
+        // this would have a negative impact on performance though...
-            NodeState state = (NodeState) getItemState();
-            while (!state.hasPropertyName(NameConstants.JCR_ISCHECKEDOUT)) {
+            NodeState state = getNodeState();
+            while (!state.hasPropertyName(JCR_ISCHECKEDOUT)) {
-                state = (NodeState) session.getItemStateManager().getItemState(parentId);
+                state = (NodeState)
+                    session.getItemStateManager().getItemState(parentId);
-            PropertyState ps = (PropertyState) session.getItemStateManager().getItemState(new PropertyId(state.getNodeId(), NameConstants.JCR_ISCHECKEDOUT));
+            PropertyId id = new PropertyId(state.getNodeId(), JCR_ISCHECKEDOUT);
+            PropertyState ps =
+                (PropertyState) session.getItemStateManager().getItemState(id);
-            throw new RepositoryException(e.getMessage());
+            throw new RepositoryException(e);
+    /**
+     * Returns the version manager of this workspace.
+     */
+    private VersionManagerImpl getVersionManagerImpl() {
+        return session.getWorkspaceImpl().getVersionManagerImpl();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void update(String srcWorkspaceName) throws RepositoryException {
+        getVersionManagerImpl().update(this, srcWorkspaceName);
+    }
+
+    /**
+     * Use {@link VersionManager#checkin(String)} instead
+     */
+    @Deprecated
+    public Version checkin() throws RepositoryException {
+        return getVersionManagerImpl().checkin(getPath());
+    }
+
+    /**
+     * Use {@link VersionManager#checkout(String)} instead
+     */
+    @Deprecated
+    public void checkout() throws RepositoryException {
+        getVersionManagerImpl().checkout(getPath());
+    }
+
+    /**
+     * Use {@link VersionManager#merge(String, String, boolean)} instead
+     */
+    @Deprecated
+    public NodeIterator merge(String srcWorkspace, boolean bestEffort)
+            throws RepositoryException {
+        return getVersionManagerImpl().merge(
+                getPath(), srcWorkspace, bestEffort);
+    }
+
+    /**
+     * Use {@link VersionManager#cancelMerge(String, Version)} instead
+     */
+    @Deprecated
+    public void cancelMerge(Version version) throws RepositoryException {
+        getVersionManagerImpl().cancelMerge(getPath(), version);
+    }
+
+    /**
+     * Use {@link VersionManager#doneMerge(String, Version)} instead
+     */
+    @Deprecated
+    public void doneMerge(Version version) throws RepositoryException {
+        getVersionManagerImpl().doneMerge(getPath(), version);
+    }
+
+    /**
+     * Use {@link VersionManager#restore(String, String, boolean)} instead
+     */
+    @Deprecated
+    public void restore(String versionName, boolean removeExisting)
+            throws RepositoryException {
+        getVersionManagerImpl().restore(getPath(), versionName, removeExisting);
+    }
+
+    /**
+     * Use {@link VersionManager#restore(String, Version, boolean)} instead
+     */
+    @Deprecated
+    public void restore(Version version, boolean removeExisting)
+            throws RepositoryException {
+        getVersionManagerImpl().restore(getPath(), version, removeExisting);
+    }
+
+    /**
+     * Use {@link VersionManager#restore(String, Version, boolean)} instead
+     */
+    @Deprecated
+    public void restore(Version version, String relPath, boolean removeExisting)
+            throws RepositoryException {
+        getVersionManagerImpl().restore(
+                getPath() + "/" + relPath, version, removeExisting);
+    }
+
+    /**
+     * Use {@link VersionManager#restoreByLabel(String, String, boolean)}
+     * instead
+     */
+    @Deprecated
+    public void restoreByLabel(String versionLabel, boolean removeExisting)
+            throws RepositoryException {
+        getVersionManagerImpl().restoreByLabel(
+                getPath(), versionLabel, removeExisting);
+    }
+
+    /**
+     * Use {@link VersionManager#getVersionHistory(String)} instead
+     */
+    @Deprecated
+    public VersionHistory getVersionHistory() throws RepositoryException {
+        return getVersionManagerImpl().getVersionHistory(getPath());
+    }
+
+    /**
+     * Use {@link VersionManager#getBaseVersion(String)} instead
+     */
+    @Deprecated
+    public Version getBaseVersion() throws RepositoryException {
+        return getVersionManagerImpl().getBaseVersion(getPath());
+    }
+

INS26 INS26 MOV31 INS40 INS40 INS31 INS31 INS29 MOV43 INS42 INS8 MOV29 UPD83 UPD42 INS29 INS83 MOV43 INS42 INS8 INS29 MOV78 INS83 INS42 MOV43 MOV78 MOV43 MOV78 MOV44 MOV43 MOV78 MOV43 MOV78 MOV44 MOV43 MOV78 MOV43 INS65 INS65 INS41 MOV21 INS65 INS41 INS65 INS66 INS66 INS32 MOV60 INS66 INS32 INS66 INS65 INS66 INS66 UPD65 INS66 INS66 UPD65 INS66 INS66 UPD65 INS66 INS66 UPD65 INS66 INS66 UPD65 INS66 INS66 UPD65 INS66 INS66 UPD65 INS66 INS66 UPD65 INS66 INS66 UPD65 INS66 INS66 UPD65 INS66 INS42 INS42 INS60 INS32 INS42 INS32 INS68 MOV32 INS68 MOV32 INS68 MOV32 INS68 MOV32 INS68 MOV32 INS68 MOV32 INS68 MOV32 INS68 MOV27 INS68 MOV32 INS68 MOV32 INS68 MOV32 INS32 MOV43 INS59 INS43 MOV43 INS42 INS42 UPD42 MOV42 INS42 INS42 INS69 UPD42 INS42 INS42 INS69 UPD42 INS42 INS42 INS69 INS69 INS69 UPD42 INS42 INS42 INS69 INS69 UPD42 INS42 INS42 INS69 INS69 UPD42 INS42 INS42 INS69 INS69 INS69 UPD42 INS42 INS42 INS69 INS69 INS69 UPD42 INS42 INS42 INS69 INS69 INS69 UPD42 INS42 INS42 INS69 INS69 INS69 UPD42 INS42 INS42 INS69 UPD42 INS42 INS42 INS69 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS42 UPD42 MOV14 UPD42 INS43 INS43 INS43 INS43 INS39 INS43 INS43 INS43 INS43 INS43 MOV43 INS39 INS43 INS43 INS39 INS43 INS43 INS39 INS43 INS43 INS39 INS43 INS43 INS42 INS42 INS42 MOV43 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS42 DEL32 DEL11 DEL36 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL66 DEL65 DEL42 DEL42 DEL68 DEL65 DEL42 DEL66 DEL65 DEL29 DEL40 DEL40 DEL42 DEL32 DEL11 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL32 DEL32 DEL11 DEL36 DEL83 DEL42 DEL42 DEL43 DEL42 DEL43 DEL43 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL32 DEL65 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL32 DEL21 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32
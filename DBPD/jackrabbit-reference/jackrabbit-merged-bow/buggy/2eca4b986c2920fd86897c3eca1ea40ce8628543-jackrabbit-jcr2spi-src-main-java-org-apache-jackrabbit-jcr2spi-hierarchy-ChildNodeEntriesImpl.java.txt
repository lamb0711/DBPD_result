JCR-1799 updating events swallowed (CacheBehavior.OBSERVATION)   	
JCR-1783 incomplete changelog when combining move with removal of new destination parent

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@704361 13f79535-47bb-0310-9956-ffa450edef68

-    /**
-     * Create a new <code>ChildNodeEntries</code> collection and retrieve
-     * the entries from the persistent layer if the parent is neither
-     * NEW nor in a terminal status.
-     */
-    ChildNodeEntriesImpl(NodeEntry parent, EntryFactory factory) throws ItemNotFoundException, RepositoryException {
-        this.parent = parent;
-        this.factory = factory;
-
-        if (parent.getStatus() != Status.NEW && !Status.isTerminal(parent.getStatus())) {
-            NodeId id = parent.getWorkspaceId();
-            Iterator childNodeInfos = factory.getItemStateFactory().getChildNodeInfos(id);
-            // simply add all child entries to the empty collection
-            while (childNodeInfos.hasNext()) {
-                ChildInfo ci = (ChildInfo) childNodeInfos.next();
-                NodeEntry entry = factory.createNodeEntry(parent, ci.getName(), ci.getUniqueID());
-                add(entry, ci.getIndex());
-            }
-        } /* else: cannot retrieve child-entries from persistent layer. the parent
-           * is NEW (transient only) or already removed from the persistent layer.
-           */
-
-        /* all child infos have been read from the persistent layer therefore
-           mark this child-node-entries as 'complete' */
-        complete = true;
-    }
-
-     * @see ChildNodeEntries#getStatus()
+     * @param childEntry
+     * @return The node entry that directly follows the given <code>childEntry</code>
+     * or <code>null</code> if the given <code>childEntry</code> has no successor
+     * or was not found in this <code>ChildNodeEntries</code>.
-    public int getStatus() {
-        return status;
+    NodeEntry getNext(NodeEntry childEntry) {
+        LinkedEntries.LinkNode ln = entries.getLinkNode(childEntry);
+        LinkedEntries.LinkNode nextLn = (ln == null) ? null : ln.getNextLinkNode();
+        return (nextLn == null) ? null : nextLn.getNodeEntry();
+    }
+
+    /**
+     * @see ChildNodeEntries#isComplete()
+     */
+    public boolean isComplete() {
+        return (status == STATUS_OK && complete) ||
+                parent.getStatus() == Status.NEW ||
+                Status.isTerminal(parent.getStatus());
-        if (status == STATUS_OK && complete ||
-            parent.getStatus() == Status.NEW || Status.isTerminal(parent.getStatus())) {
+        if (isComplete()) {
+    /**
+     * Update the child node entries according to the child-infos obtained
+     * from the persistent layer.
+     * NOTE: the status of the entries already present is not respected. Thus
+     * new or removed entries are not touched in order not to modify the
+     * transient status of the parent. Operations that affect the set or order
+     * of child entries (AddNode, Move, Reorder) currently assert the
+     * completeness of the ChildNodeEntries, therefore avoiding an update
+     * resulting in inconsistent entries.
+     *
+     * @param childNodeInfos
+     * @see HierarchyEntry#reload(boolean, boolean) that ignores items with
+     * pending changes.
+     * @see org.apache.jackrabbit.jcr2spi.operation.AddNode
+     * @see org.apache.jackrabbit.jcr2spi.operation.Move
+     * @see org.apache.jackrabbit.jcr2spi.operation.Reorder
+     */
-        // TODO: should existing (not-new) entries that are not present in the childInfos be removed?
-        // create list from all ChildInfos (for multiple loop)
-        List cInfos = new ArrayList();
+        // insert missing entries and reorder all if necessary.
+        LinkedEntries.LinkNode prevLN = null;
-            cInfos.add(childNodeInfos.next());
-        }
-        // first make sure the ordering of all existing entries is ok
-        NodeEntry entry = null;
-        for (Iterator it = cInfos.iterator(); it.hasNext();) {
-            ChildInfo ci = (ChildInfo) it.next();
-            NodeEntry nextEntry = get(ci);
-            if (nextEntry != null) {
-                if (entry != null) {
-                    reorder(entry, nextEntry);
-                }
-                entry = nextEntry;
+            ChildInfo ci = (ChildInfo) childNodeInfos.next();
+            LinkedEntries.LinkNode ln = entriesByName.getLinkNode(ci.getName(), ci.getIndex(), ci.getUniqueID());
+            if (ln == null) {
+                // add missing at the correct position.
+                NodeEntry entry = factory.createNodeEntry(parent, ci.getName(), ci.getUniqueID());
+                ln = internalAddAfter(entry, ci.getIndex(), prevLN);
+            } else if (prevLN != null) {
+                // assert correct order of existing
+                reorderAfter(ln, prevLN);
-        }
-        // then insert the 'new' entries
-        List newEntries = new ArrayList();
-        for (Iterator it = cInfos.iterator(); it.hasNext();) {
-            ChildInfo ci = (ChildInfo) it.next();
-            NodeEntry beforeEntry = get(ci);
-            if (beforeEntry == null) {
-                NodeEntry ne = factory.createNodeEntry(parent, ci.getName(), ci.getUniqueID());
-                newEntries.add(ne);
-            } else {
-                // insert all new entries from the list BEFORE the existing
-                // 'nextEntry'. Then clear the list.
-                for (int i = 0; i < newEntries.size(); i++) {
-                    add((NodeEntry) newEntries.get(i), beforeEntry);
-                }
-                newEntries.clear();
-            }
-        }
-        // deal with new entries at the end
-        for (int i = 0; i < newEntries.size(); i++) {
-            add((NodeEntry) newEntries.get(i));
+            prevLN = ln;
-     * @see ChildNodeEntries#get(ChildInfo)
-     */
-    public NodeEntry get(ChildInfo childInfo) {
-        String uniqueID = childInfo.getUniqueID();
-        NodeEntry child = null;
-        if (uniqueID != null) {
-            child = get(childInfo.getName(), uniqueID);
-        }
-        // try to load the child entry by name and index.
-        // this is required in case of a null uniqueID OR if the child entry has
-        // been created but never been resolved and therefore the uniqueID might
-        // be unknown.
-        if (child == null) {
-            int index = childInfo.getIndex();
-            child = entriesByName.getNodeEntry(childInfo.getName(), index);
-        }
-        return child;
-    }
-
-    /**
+     * @see ChildNodeEntries#add(NodeEntry, int, NodeEntry)
+     */
+    public synchronized void add(NodeEntry entry, int index, NodeEntry beforeEntry) {
+        if (beforeEntry != null) {
+            // the link node where the new entry is ordered before
+            LinkedEntries.LinkNode beforeLN = entries.getLinkNode(beforeEntry);
+            if (beforeLN == null) {
+                throw new NoSuchElementException();
+            }
+            LinkedEntries.LinkNode insertLN = internalAdd(entry, index);
+            reorder(entry.getName(), insertLN, beforeLN);
+        } else {
+            // 'before' is null -> simply append new entry at the end
+            add(entry);
+        }
+    }
+
+    /**
-        LinkedEntries.LinkNode ln = entries.add(entry);
-        entriesByName.put(nodeName, ln);
+        LinkedEntries.LinkNode ln = entries.add(entry, index);
+        entriesByName.put(nodeName, index, ln);
-     * @see ChildNodeEntries#add(NodeEntry, NodeEntry)
+     * Add the specified new entry after the specified <code>insertAfter</code>.
+     *
+     * @param newEntry
+     * @param index
+     * @param insertAfter
+     * @return
-    public synchronized void add(NodeEntry entry, NodeEntry beforeEntry) {
-        if (beforeEntry != null) {
-            // the link node where the new entry is ordered before
-            LinkedEntries.LinkNode beforeLN = entries.getLinkNode(beforeEntry);
-            if (beforeLN == null) {
-                throw new NoSuchElementException();
-            }
-            LinkedEntries.LinkNode insertLN = internalAdd(entry, Path.INDEX_UNDEFINED);
-            reorder(entry.getName(), insertLN, beforeLN);
-        } else {
-            // 'before' is null -> simply append new entry at the end
-            add(entry);
-        }
+    private LinkedEntries.LinkNode internalAddAfter(NodeEntry newEntry, int index,
+                                                    LinkedEntries.LinkNode insertAfter) {
+        LinkedEntries.LinkNode ln = entries.addAfter(newEntry, index, insertAfter);
+        entriesByName.put(newEntry.getName(), index, ln);
+        return ln;
-                    } else if (ln != insertLN && ln.getNodeEntry().getName().equals(insertName)) {
+                    } else if (ln != insertLN && insertName.equals(ln.qName)) {
+    /**
+     *
+     * @param insertEntry
+     * @param afterEntry
+     */
+    private void reorderAfter(LinkedEntries.LinkNode insertLN, LinkedEntries.LinkNode afterLN) {
+        // the link node to move
+        if (insertLN == null) {
+            throw new NoSuchElementException();
+        }
+        // the link node where insertLN is ordered after
+        if (afterLN == null) {
+            // move to first position
+            afterLN = entries.getHeader();
+        }
+
+        LinkedEntries.LinkNode currentAfter = afterLN.getNextLinkNode();
+        if (currentAfter == insertLN) {
+            log.debug("Already ordered behind 'afterEntry'.");
+            // nothing to do
+            return;
+        } else {
+            // reorder named map
+            Name insertName = insertLN.qName;
+            if (entriesByName.containsSiblings(insertName)) {
+                int position = -1; // default: reorder to the end.
+                if (afterLN == entries.getHeader()) {
+                    // move to the beginning
+                    position = 0;
+                } else {
+                    // count all SNS-entries that are before 'afterLN' in order to
+                    // determine the new position of the reordered node regarding
+                    // his siblings.
+                    position = 0;
+                    for (Iterator it = entries.linkNodeIterator(); it.hasNext(); ) {
+                        LinkedEntries.LinkNode ln = (LinkedEntries.LinkNode) it.next();
+                        if (!insertName.equals(ln.qName)) {
+                            continue; // not a SNS -> not relevant for position count
+                        }
+                        if (ln != insertLN) {
+                            position++;
+                        } // ln == inserLN -> not relevant for position count
+                        if (ln == afterLN) {
+                            break;
+                        }
+                    }
+                }
+                entriesByName.reorder(insertName, insertLN, position);
+            }
+            // reorder in linked list
+            entries.reorderNode(insertLN, afterLN.getNextLinkNode());
+        }
+    }
+
+        private LinkedEntries.LinkNode getHeader() {
+            return (LinkedEntries.LinkNode) header;
+        }
+
-         * Adds a child node entry to this list.
+         * Adds a child node entry at the end of this list.
+         * @param index
-        LinkedEntries.LinkNode add(NodeEntry cne) {
-            LinkedEntries.LinkNode ln = new LinkedEntries.LinkNode(cne);
+        LinkedEntries.LinkNode add(NodeEntry cne, int index) {
+            LinkedEntries.LinkNode ln = new LinkedEntries.LinkNode(cne, index);
+         * Adds the given child node entry to this list after the specified
+         * <code>entry</code> or at the beginning if <code>entry</code> is
+         * <code>null</code>.
+         *
+         * @param cne the child node entry to add.
+         * @param index
+         * @param node after which to insert the new entry
+         * @return the LinkNode which refers to the added <code>NodeEntry</code>.
+         */
+        LinkedEntries.LinkNode addAfter(NodeEntry cne, int index, LinkedEntries.LinkNode insertAfter) {
+            LinkedEntries.LinkNode newNode;
+            if (insertAfter == null) {
+                // insert at the beginning
+                newNode = new LinkedEntries.LinkNode(cne, index);
+                addFirst(cne);
+            } else if (insertAfter.getNextLinkNode() == null) {
+                newNode = add(cne, index);
+            } else {
+                newNode = new LinkedEntries.LinkNode(cne, index);
+                addNode(newNode, insertAfter.getNextLinkNode());
+            }
+            return newNode;
+        }
+
+        /**
-            return new LinkedEntries.LinkNode(value);
+            return new LinkedEntries.LinkNode(value, Path.INDEX_DEFAULT);
-            protected LinkNode(Object value) {
-                super(new WeakReference(value));
+            protected LinkNode(Object value, int index) {
+                // add weak reference from linkNode to the NodeEntry (value)
+                // unless the entry is a SNSibling. TODO: review again.
+                super(index > Path.INDEX_DEFAULT ? value : new WeakReference(value));
-                Reference val = (Reference) super.getValue();
+                Object val = super.getValue();
+                NodeEntry ne;
+                if (val == null) {
+                    ne = null;
+                } else if (val instanceof Reference) {
+                    ne = (NodeEntry) ((Reference) val).get();
+                } else {
+                    ne = (NodeEntry) val;
+                }
-                NodeEntry ne = (val == null) ?  null : (NodeEntry) val.get();
-        public void put(Name qName, LinkedEntries.LinkNode value) {
+        public LinkedEntries.LinkNode getLinkNode(Name qName, int index, String uniqueID) {
+            if (uniqueID != null) {
+                // -> try if any entry matches.
+                // if none matches it be might that entry doesn't have uniqueID
+                // set yet -> search without uniqueID
+                LinkedEntries.LinkNode val = (LinkedEntries.LinkNode) nameMap.get(qName);
+                if (val != null) {
+                    if (uniqueID.equals(val.getNodeEntry().getUniqueID())) {
+                        return val;
+                    }
+                } else {
+                    // look in snsMap
+                    List l = (List) snsMap.get(qName);
+                    if (l != null) {
+                        for (Iterator it = l.iterator(); it.hasNext();) {
+                            LinkedEntries.LinkNode ln = (LinkedEntries.LinkNode) it.next();
+                            if (uniqueID.equals(ln.getNodeEntry().getUniqueID())) {
+                                return ln;
+                            }
+                        }
+                    }
+                }
+            }
+            // no uniqueID passed or not match.
+            // try to load the child entry by name and index.
+            return getLinkNode(qName, index);
+        }
+
+        public void put(Name qName, int index, LinkedEntries.LinkNode value) {
+                // no same name siblings -> simply put to the name map.
-                l.add(value);
+                // sibling(s) already present -> insert into the list
+                int position = index - 1;
+                if (position < 0 || position > l.size()) {
+                    l.add(value); // invalid position -> append at the end.
+                } else {
+                    l.add(position, value); // insert with the correct index.
+                }
-            if (position < 0) {
+            sns.remove(insertValue);
+            if (position < 0 || position > sns.size()) {
-                sns.remove(insertValue);
-                sns.remove(insertValue);

MOV31 MOV31 INS31 INS31 INS31 MOV43 UPD42 INS8 UPD39 UPD42 INS29 MOV83 MOV39 MOV42 MOV44 MOV8 INS44 INS29 INS83 INS43 INS42 INS44 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS8 INS31 INS31 INS31 INS65 UPD65 UPD42 INS60 INS60 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS21 MOV21 INS39 INS42 INS65 INS65 INS65 INS65 INS65 INS40 MOV43 INS42 INS39 INS42 INS43 INS42 MOV60 INS21 INS41 INS65 INS65 INS43 INS42 MOV43 INS42 INS25 INS25 MOV60 INS25 INS83 INS43 INS42 INS8 INS44 INS29 INS43 INS42 INS44 INS44 INS44 INS8 INS83 INS43 INS42 INS44 INS44 INS44 INS8 INS44 INS42 UPD66 UPD66 UPD66 INS43 INS59 INS43 INS59 INS16 MOV27 INS32 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS68 INS66 INS66 INS40 INS40 INS40 UPD43 INS8 INS7 INS43 INS66 INS42 INS42 INS42 INS40 MOV43 INS32 INS42 INS42 INS42 INS40 INS27 INS8 INS27 INS8 UPD43 MOV27 MOV8 INS8 INS40 INS41 INS65 INS39 INS42 INS65 INS65 INS65 INS65 INS65 INS40 INS43 INS42 INS39 INS42 INS43 INS42 INS60 INS25 INS41 INS44 INS40 INS43 INS42 INS39 INS42 MOV43 INS42 INS25 INS41 INS39 INS42 MOV21 INS40 INS42 INS32 INS40 INS42 INS16 INS36 INS33 INS32 UPD42 INS42 INS42 INS42 INS69 INS69 INS40 INS42 INS33 MOV60 INS60 INS25 INS21 INS42 MOV42 INS69 INS40 INS42 UPD42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS33 INS53 INS42 INS33 INS21 INS40 UPD42 UPD42 INS42 INS41 INS60 INS25 MOV21 INS11 UPD66 INS42 MOV43 INS66 INS66 INS66 INS42 INS66 INS42 INS42 INS66 INS66 INS42 INS40 INS43 INS59 INS27 INS8 INS25 INS42 INS14 INS39 INS42 INS60 INS25 INS42 MOV27 INS8 INS32 INS8 INS27 INS42 INS42 INS42 INS36 INS33 INS32 INS27 UPD42 MOV42 UPD42 MOV42 INS36 INS39 INS39 INS43 INS59 INS27 MOV8 INS25 INS7 INS39 INS43 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS8 INS14 INS7 UPD42 UPD42 INS43 INS59 INS32 INS8 INS32 INS43 INS42 INS40 INS42 INS42 INS33 INS21 INS21 INS27 INS8 INS8 INS43 INS42 INS40 INS16 INS43 MOV43 INS59 MOV27 INS8 INS25 INS60 INS25 INS42 INS42 INS42 INS60 INS25 INS27 INS27 INS27 UPD42 MOV42 UPD42 MOV42 INS42 INS33 MOV27 INS40 INS42 INS32 INS42 INS33 INS27 INS8 INS42 INS42 INS40 MOV21 INS24 INS43 INS42 INS32 UPD42 UPD42 INS45 UPD42 MOV42 INS42 INS40 UPD42 MOV42 UPD42 MOV42 INS42 INS60 INS25 INS21 UPD42 MOV42 UPD42 MOV42 INS42 MOV32 INS40 MOV43 INS42 INS7 INS32 INS32 INS33 INS21 INS21 INS21 INS40 INS27 INS42 MOV14 INS42 MOV48 MOV42 INS21 INS62 INS8 INS8 INS43 INS59 INS27 INS8 INS8 INS39 INS59 INS27 MOV8 INS8 MOV42 MOV34 INS42 INS32 INS42 INS33 INS42 INS42 MOV32 INS32 MOV32 INS7 INS42 INS33 INS21 INS42 MOV58 MOV32 INS8 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS39 INS59 INS27 INS8 INS8 INS32 UPD42 UPD42 INS42 INS14 INS42 INS42 INS42 INS42 INS7 INS7 INS32 INS42 INS40 INS7 INS42 MOV43 INS21 INS21 INS40 INS42 INS11 INS42 INS33 INS25 INS60 INS25 INS42 INS27 MOV27 INS27 INS21 INS42 INS42 INS42 INS42 INS42 MOV32 INS32 INS60 INS25 UPD42 MOV42 INS38 UPD42 MOV42 MOV32 MOV21 MOV21 INS24 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS43 INS42 INS42 INS42 INS32 INS42 MOV14 INS42 INS42 INS32 INS42 INS33 INS7 INS7 INS43 INS32 INS32 INS8 MOV43 INS59 INS27 MOV8 INS42 INS34 INS42 INS34 INS42 INS32 INS32 UPD42 INS42 INS42 INS42 INS42 INS43 INS59 MOV27 MOV8 INS25 INS34 UPD42 UPD42 INS58 MOV32 INS8 INS40 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS11 INS42 INS11 INS40 INS42 INS42 INS42 INS42 INS42 INS32 INS41 INS42 INS11 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS11 INS27 INS8 UPD42 INS34 UPD42 INS34 INS43 INS59 MOV60 MOV25 MOV25 INS25 MOV43 INS32 MOV43 INS42 INS32 INS42 INS42 MOV43 INS32 INS58 MOV32 INS43 INS32 INS27 INS32 INS21 UPD42 MOV42 INS42 INS32 INS43 INS38 INS8 MOV27 MOV27 INS8 INS36 MOV42 INS42 INS42 INS42 INS42 INS42 MOV43 INS59 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS37 INS42 INS42 INS40 UPD42 INS11 INS32 INS18 UPD42 INS42 INS10 MOV11 INS42 INS32 MOV32 MOV32 INS8 INS42 INS43 INS32 UPD42 MOV42 UPD42 MOV42 INS40 INS42 INS42 INS42 INS42 INS41 INS40 UPD42 MOV42 UPD42 MOV42 UPD42 INS42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL32 DEL40 DEL27 DEL42 DEL42 DEL32 DEL32 DEL38 DEL27 DEL25 DEL8 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL61 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL8 DEL24 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL43 DEL42 DEL42 DEL43 DEL32 DEL11 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL42 DEL32 DEL21 DEL8 DEL24 DEL32 DEL21 DEL8 DEL25 DEL8 DEL24 DEL39 DEL34 DEL59 DEL58 DEL27 DEL42 DEL37 DEL42 DEL42 DEL42 DEL42 DEL32 DEL11 DEL32 DEL21 DEL8 DEL24 DEL8 DEL31 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL33 DEL59 DEL60 DEL39 DEL42 DEL32 DEL59 DEL60 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL40 DEL42 DEL43 DEL42 DEL43 DEL32 DEL11 DEL42 DEL33 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL9 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL7 DEL21 DEL8 DEL27 DEL33 DEL42 DEL42 DEL32 DEL7 DEL36 DEL33 DEL42 DEL32 DEL11 DEL16 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21
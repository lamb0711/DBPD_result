JCR-3233: Provide callback for consistency checker (work-in-progress)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1242775 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.persistence.check.ConsistencyChecker;
+import org.apache.jackrabbit.core.persistence.check.ConsistencyCheckListener;
-public class ConsistencyCheckerImpl implements ConsistencyChecker {
+public class ConsistencyCheckerImpl {
-    private static Logger log = LoggerFactory.getLogger(ConsistencyCheckerImpl.class);
+    private static Logger log = LoggerFactory
+            .getLogger(ConsistencyCheckerImpl.class);
-    private AbstractBundlePersistenceManager pm;
-    
+    private final AbstractBundlePersistenceManager pm;
+
+    private final ConsistencyCheckListener listener;
+
-    public ConsistencyCheckerImpl(AbstractBundlePersistenceManager pm) {
+    public ConsistencyCheckerImpl(AbstractBundlePersistenceManager pm,
+            ConsistencyCheckListener listener) {
+        this.listener = listener;
-    public ConsistencyReport check(String[] uuids, boolean recursive, boolean fix, String lostNFoundId)
-            throws RepositoryException {
+    public ConsistencyReport check(String[] uuids, boolean recursive,
+            boolean fix, String lostNFoundId) throws RepositoryException {
-        int total = internalCheckConsistency(uuids, recursive, fix, reports, lostNFoundId);
+        int total = internalCheckConsistency(uuids, recursive, fix, reports,
+                lostNFoundId);
-    
-    private int internalCheckConsistency(String[] uuids, boolean recursive, boolean fix, Set<ReportItem> reports,
-            String lostNFoundId) throws RepositoryException {
+
+    private int internalCheckConsistency(String[] uuids, boolean recursive,
+            boolean fix, Set<ReportItem> reports, String lostNFoundId)
+            throws RepositoryException {
-                    log.error("specified 'lost+found' node does not exist");
-                } else if (!NameConstants.NT_UNSTRUCTURED.equals(lfBundle.getNodeTypeName())) {
-                    log.error("specified 'lost+found' node is not of type nt:unstructured");
+                    error(lostNFoundId,
+                            "specified 'lost+found' node does not exist");
+                } else if (!NameConstants.NT_UNSTRUCTURED.equals(lfBundle
+                        .getNodeTypeName())) {
+                    error(lostNFoundId,
+                            "specified 'lost+found' node is not of type nt:unstructured");
-                log.error("finding 'lost+found' folder", ex);
+                error(lostNFoundId, "finding 'lost+found' folder", ex);
-                    
+
-                                log.error("No bundle found for id '" + id + "'");
+                                error(id.toString(), "No bundle found for id '"
+                                        + id + "'");
-                                checkBundleConsistency(id, bundle, fix, modifications, lostNFound, orphaned, reports);
+                                checkBundleConsistency(id, bundle, fix,
+                                        modifications, lostNFound, orphaned,
+                                        reports);
-                                if (count % 1000 == 0) {
-                                    log.info(pm + ": checked " + count + " bundles...");
+                                if (count % 1000 == 0 && listener == null) {
+                                    log.info(pm + ": checked " + count
+                                            + " bundles...");
-                    if (! allIds.isEmpty()) {
+                    if (!allIds.isEmpty()) {
-            //     a) load node bundle
-            //     b) check bundle, store any bundle-to-be-modified in collection
-            //     c) if recursive, add child uuids to list of uuids
+            // a) load node bundle
+            // b) check bundle, store any bundle-to-be-modified in collection
+            // c) if recursive, add child uuids to list of uuids
-                    log.error("Invalid id for consistency check, skipping: '" + uuids[i] + "': " + e);
+                    error(uuids[i],
+                            "Invalid id for consistency check, skipping: '"
+                                    + uuids[i] + "': " + e);
-            
-            // iterate over UUIDs (including ones that are newly added inside the loop!)
+
+            // iterate over UUIDs (including ones that are newly added inside
+            // the loop!)
-                        log.error("No bundle found for id '" + id + "'");
-                    }
-                    else {
-                        checkBundleConsistency(id, bundle, fix, modifications, lostNFound, orphaned, reports);
+                        if (!isVirtualNode(id)) {
+                            error(id.toString(), "No bundle found for id '"
+                                    + id + "'");
+                        }
+                    } else {
+                        checkBundleConsistency(id, bundle, fix, modifications,
+                                lostNFound, orphaned, reports);
-                            for (NodePropBundle.ChildNodeEntry entry : bundle.getChildNodeEntries()) {
+                            for (NodePropBundle.ChildNodeEntry entry : bundle
+                                    .getChildNodeEntries()) {
-                        if (count % 1000 == 0) {
-                            log.info(pm + ": checked " + count + "/" + idList.size() + " bundles...");
+                        if (count % 1000 == 0 && listener == null) {
+                            log.info(pm + ": checked " + count + "/"
+                                    + idList.size() + " bundles...");
-                    // problem already logged (loadBundle called with logDetailedErrors=true)
+                    // problem already logged (loadBundle called with
+                    // logDetailedErrors=true)
-            log.info(pm + ": Fixing " + modifications.size() + " inconsistent bundle(s)...");
+            info(null, pm + ": Fixing " + modifications.size()
+                    + " inconsistent bundle(s)...");
-                    log.info(pm + ": Fixing bundle '" + bundle.getId() + "'");
+                    info(bundle.getId().toString(), pm + ": Fixing bundle '"
+                            + bundle.getId() + "'");
-                    log.error(pm + ": Error storing fixed bundle: " + e);
+                    error(bundle.getId().toString(), pm
+                            + ": Error storing fixed bundle: " + e);
-                    log.error("specified 'lost+found' node does not exist");
-                } else if (!NameConstants.NT_UNSTRUCTURED.equals(lfBundle.getNodeTypeName())) {
-                    log.error("specified 'lost+found' node is not of type nt:unstructered");
+                    error(lostNFoundId, "specified 'lost+found' node does not exist");
+                } else if (!NameConstants.NT_UNSTRUCTURED.equals(lfBundle
+                        .getNodeTypeName())) {
+                    error(lostNFoundId, "specified 'lost+found' node is not of type nt:unstructered");
-                        String nodeName = orphan + "-" + System.currentTimeMillis();
-                        lfBundle.addChildNodeEntry(NF.create("", nodeName), orphan);
+                        String nodeName = orphan + "-"
+                                + System.currentTimeMillis();
+                        lfBundle.addChildNodeEntry(NF.create("", nodeName),
+                                orphan);
-                log.error("trying orphan adoption", ex);
+                error(null, "trying orphan adoption", ex);
-     *
-     * @param id node id for the bundle to check
-     * @param bundle the bundle to check
-     * @param fix if <code>true</code>, repair things that can be repaired
-     * @param modifications if <code>fix == true</code>, collect the repaired
-     * {@linkplain NodePropBundle bundles} here
+     * 
+     * @param id
+     *            node id for the bundle to check
+     * @param bundle
+     *            the bundle to check
+     * @param fix
+     *            if <code>true</code>, repair things that can be repaired
+     * @param modifications
+     *            if <code>fix == true</code>, collect the repaired
+     *            {@linkplain NodePropBundle bundles} here
-                                          boolean fix, Collection<NodePropBundle> modifications,
-                                          NodeId lostNFoundId, Set<NodeId> orphaned, Set<ReportItem> reports) {
-        //log.info(name + ": checking bundle '" + id + "'");
+            boolean fix, Collection<NodePropBundle> modifications,
+            NodeId lostNFoundId, Set<NodeId> orphaned, Set<ReportItem> reports) {
+        // log.info(name + ": checking bundle '" + id + "'");
-        // skip all system nodes except root node
-        if (id.toString().endsWith("babecafebabe")
-                && !id.toString().equals("cafebabe-cafe-babe-cafe-babecafebabe")) {
+        // skip all virtual nodes
+        if (isVirtualNode(id)) {
+        if (listener != null) {
+            listener.startCheck(id.toString());
+        }
+
-            // skip check for system nodes (root, system root, version storage, node types)
+            // skip check for system nodes (root, system root, version storage,
+            // node types)
-                    message = "NodeState '" + id + "' references inexistent child" + " '"
-                            + entry.getName() + "' with id " + "'" + entry.getId() + "'";
+                    message = "NodeState '" + id
+                            + "' references inexistent child" + " '"
+                            + entry.getName() + "' with id " + "'"
+                            + entry.getId() + "'";
-                        message = "ChildNode has invalid parent id: '" + cp + "' (instead of '" + id + "')";
+                        message = "ChildNode has invalid parent id: '" + cp
+                                + "' (instead of '" + id + "')";
-                // problem already logged (loadBundle called with logDetailedErrors=true)
+                // problem already logged (loadBundle called with
+                // logDetailedErrors=true)
-                
+
-                    String message = "NodeState '" + id + "' references inexistent parent id '" + parentId + "'";
+                    String message = "NodeState '" + id
+                            + "' references inexistent parent id '" + parentId
+                            + "'";
-                }
-                else {
+                } else {
-                    for (NodePropBundle.ChildNodeEntry entry : parentBundle.getChildNodeEntries()) {
-                        if (entry.getId().equals(id)){
+                    for (NodePropBundle.ChildNodeEntry entry : parentBundle
+                            .getChildNodeEntries()) {
+                        if (entry.getId().equals(id)) {
-                        String message = "NodeState '" + id + "' is not referenced by its parent node '" + parentId + "'";
+                        String message = "NodeState '" + id
+                                + "' is not referenced by its parent node '"
+                                + parentId + "'";
-                        parentBundle.addChildNodeEntry(NF.create("{}" + nodeName), id);
-                        log.info("NodeState '" + id + "' adds itself to its parent node '" + parentId + "' with a new name '" + nodeName + "'");
+                        parentBundle.addChildNodeEntry(
+                                NF.create("{}" + nodeName), id);
+                        log.info("NodeState '" + id
+                                + "' adds itself to its parent node '"
+                                + parentId + "' with a new name '" + nodeName
+                                + "'");
-            String message = "Error reading node '" + parentId + "' (parent of '" + id + "'): " + e;
+            String message = "Error reading node '" + parentId
+                    + "' (parent of '" + id + "'): " + e;
+    /**
+     * @return whether the id is for a virtual node (not needing checking)
+     */
+    private boolean isVirtualNode(NodeId id) {
+        String s = id.toString();
+        if ("cafebabe-cafe-babe-cafe-babecafebabe".equals(s)) {
+            // root node isn't virtual
+            return false;
+        }
+        else {
+            // all other system nodes are
+            return s.endsWith("babecafebabe");
+        }
+    }
+
+
-        if (reports != null) {
-            reports.add(new ReportItemImpl(id.toString(), message));
+
+        if (reports != null || listener != null) {
+            ReportItem ri = new ReportItemImpl(id.toString(), message);
+
+            if (reports != null) {
+                reports.add(ri);
+            }
+            if (listener != null) {
+                listener.report(ri);
+            }
+        }
+    }
+
+    private void info(String id, String message) {
+        if (this.listener == null) {
+            String idstring = id == null ? "" : ("Node " + id + ": ");
+            log.info(idstring + message);
+        } else {
+            listener.info(id, message);
+        }
+    }
+
+    private void error(String id, String message) {
+        if (this.listener == null) {
+            String idstring = id == null ? "" : ("Node " + id + ": ");
+            log.error(idstring + message);
+        } else {
+            listener.error(id, message);
+        }
+    }
+
+    private void error(String id, String message, Throwable ex) {
+        String idstring = id == null ? "" : ("Node " + id + ": ");
+        log.error(idstring + message, ex);
+        if (listener != null) {
+            listener.error(id, message);

UPD40 INS23 INS31 INS31 INS31 INS31 INS83 INS83 INS83 INS43 INS59 INS44 INS29 INS83 INS39 INS42 INS44 INS8 INS8 INS83 INS39 INS42 INS44 INS44 INS8 INS83 INS39 INS42 INS44 INS44 INS8 INS83 INS39 INS42 INS44 INS44 INS44 INS8 UPD42 MOV42 INS42 INS43 INS42 INS21 INS25 INS65 INS43 INS42 INS60 INS25 INS25 INS43 INS42 INS43 INS42 INS25 INS43 INS42 INS43 INS42 INS25 INS43 INS42 INS43 INS42 INS43 INS42 INS60 INS21 INS25 INS42 INS7 UPD66 UPD66 UPD66 UPD66 INS32 MOV8 INS27 INS8 INS66 INS42 INS43 INS59 INS32 INS8 INS8 INS27 INS8 INS42 INS42 INS27 INS8 INS8 INS42 INS42 INS27 INS8 INS8 INS42 INS42 INS42 INS43 INS59 INS32 INS27 INS8 INS22 INS42 INS42 INS42 INS42 INS33 INS21 INS42 INS42 MOV32 INS45 INS42 INS42 INS41 INS41 MOV27 INS27 INS60 MOV25 INS25 INS22 INS33 INS60 INS21 INS21 INS22 INS33 INS60 INS21 INS21 INS42 INS42 INS16 INS42 INS42 INS27 INS42 INS42 INS33 INS21 INS52 INS42 INS32 INS9 INS32 INS42 INS33 INS43 INS59 INS27 INS27 INS8 INS52 INS42 INS43 INS59 INS32 INS32 INS52 INS42 INS43 INS59 INS32 INS32 INS27 INS45 INS36 INS42 INS42 INS32 INS33 INS42 INS42 MOV32 INS42 INS42 INS45 INS42 INS42 MOV14 INS42 INS33 INS42 INS33 INS21 INS42 INS42 INS16 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS16 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS33 INS27 INS42 INS42 INS42 INS42 INS32 INS27 INS45 INS36 INS42 INS42 INS27 INS45 INS36 INS42 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS33 INS27 INS42 INS33 INS27 INS42 INS8 INS33 INS45 INS42 INS45 INS45 INS42 INS45 INS42 INS25 INS42 INS32 INS42 INS42 INS2 INS38 MOV8 INS27 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS32 MOV27 INS27 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS42 INS42 INS42 INS33 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS27 UPD42 MOV42 UPD42 MOV42 INS42 INS32 MOV27 INS27 UPD42 MOV42 UPD42 MOV42 INS42 INS33 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL45 DEL32 DEL42 DEL45 DEL32 DEL38 DEL27 DEL8
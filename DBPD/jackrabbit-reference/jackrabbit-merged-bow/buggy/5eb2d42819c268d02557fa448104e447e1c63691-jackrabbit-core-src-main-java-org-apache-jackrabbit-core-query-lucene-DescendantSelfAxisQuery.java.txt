JSR 283: Shareable nodes support in query

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@763188 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.ItemManager;
+                private ItemManager itemMgr = session.getItemManager();
+
+         * Reusable array that holds document numbers of parents.
+         */
+        private int[] pDocs = new int[1];
+
+        /**
+         * Reusable array that holds a single document number.
+         */
+        private final int[] singleDoc = new int[1];
+
+        /**
-                if (isValid(subScorer.doc())) {
-                    return true;
-                } else {
-                    // find next valid
-                    return next();
-                }
+                return isValid(subScorer.doc()) || next();
-            int parentDoc = hResolver.getParent(doc);
+            pDocs = hResolver.getParents(doc, pDocs);
+
+            if (pDocs.length == 0) {
+                return false;
+            }
-            ancestorDocs[ancestorCount++] = parentDoc;
+            // can only remember one parent doc per level
+            ancestorDocs[ancestorCount++] = pDocs[0];
-            while (parentDoc != -1 && (!contextHits.get(parentDoc) || ancestorCount < minLevels)) {
-                parentDoc = hResolver.getParent(parentDoc);
-                // resize array if needed
-                if (ancestorCount == ancestorDocs.length) {
-                    // double the size of the new array
-                    int[] copy = new int[ancestorDocs.length * 2];
-                    System.arraycopy(ancestorDocs, 0, copy, 0, ancestorDocs.length);
-                    ancestorDocs = copy;
+            while (pDocs.length != 0) {
+                boolean valid = false;
+                for (int i = 0; i < pDocs.length; i++) {
+                    if (ancestorCount >= minLevels && contextHits.get(pDocs[i])) {
+                        valid = true;
+                        break;
+                    }
-                ancestorDocs[ancestorCount++] = parentDoc;
+                if (valid) {
+                    break;
+                } else {
+                    // load next level
+                    pDocs = getParents(pDocs, singleDoc);
+                    // resize array if needed
+                    if (ancestorCount == ancestorDocs.length) {
+                        // double the size of the new array
+                        int[] copy = new int[ancestorDocs.length * 2];
+                        System.arraycopy(ancestorDocs, 0, copy, 0, ancestorDocs.length);
+                        ancestorDocs = copy;
+                    }
+                    if (pDocs.length != 0) {
+                        // can only remember one parent doc per level
+                        ancestorDocs[ancestorCount++] = pDocs[0];
+                    }
+                }
-            if (parentDoc != -1) {
-                // since current parentDoc is a descendant of one of the context
+
+            if (pDocs.length > 0) {
+                // since current parentDocs are descendants of one of the context
+
+        /**
+         * Returns the parent document numbers for the given <code>docs</code>.
+         *
+         * @param docs  the current document numbers, for which to get the
+         *              parents.
+         * @param pDocs an array of document numbers for reuse as return value.
+         * @return the parent document number for the given <code>docs</code>.
+         * @throws IOException if an error occurs while reading from the index.
+         */
+        private int[] getParents(int[] docs, int[] pDocs) throws IOException {
+            // optimize single doc
+            if (docs.length == 1) {
+                return hResolver.getParents(docs[0], pDocs);
+            } else {
+                pDocs = new int[0];
+                for (int i = 0; i < docs.length; i++) {
+                    int[] p = hResolver.getParents(docs[i], new int[0]);
+                    int[] tmp = new int[p.length + pDocs.length];
+                    System.arraycopy(pDocs, 0, tmp, 0, pDocs.length);
+                    System.arraycopy(p, 0, tmp, pDocs.length, p.length);
+                    pDocs = tmp;
+                }
+                return pDocs;
+            }
+        }

INS26 INS40 INS23 INS23 INS31 INS29 INS83 INS5 INS59 INS29 INS83 INS83 INS5 INS59 MOV8 INS29 INS83 INS5 INS42 INS44 INS44 INS43 INS8 INS65 INS39 INS85 INS42 INS3 INS65 INS39 INS85 INS42 INS3 MOV60 INS21 INS25 MOV21 INS65 INS65 INS65 INS65 INS65 INS39 INS85 INS5 INS42 INS5 INS42 INS42 INS25 INS66 INS5 INS34 INS66 INS5 INS34 INS42 INS7 INS27 INS8 INS27 INS8 UPD27 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS39 INS85 INS39 INS85 INS27 INS8 INS8 INS39 INS85 INS39 INS85 MOV21 MOV41 INS42 INS32 INS40 INS34 INS41 INS2 INS40 INS34 INS60 INS24 INS25 INS40 INS34 INS40 INS34 INS41 INS21 INS24 INS41 INS27 MOV42 UPD42 MOV42 MOV42 INS42 INS9 INS42 INS34 INS39 INS59 INS58 INS27 INS37 INS8 INS42 INS8 MOV8 INS32 INS7 INS58 INS27 INS37 INS8 INS42 INS23 MOV32 MOV32 INS42 INS9 INS39 INS59 INS42 INS40 INS42 INS25 INS10 INS25 INS42 INS42 INS2 INS42 INS42 INS3 INS39 INS59 INS42 INS40 INS42 INS60 INS60 INS21 INS21 INS21 INS83 INS43 INS59 INS42 INS34 INS27 INS8 INS27 INS8 INS42 INS34 INS5 INS34 INS42 INS34 INS5 INS59 INS5 INS59 INS32 INS32 INS7 INS42 INS42 INS32 INS27 INS32 INS21 INS10 UPD42 INS40 INS34 MOV21 INS39 INS85 INS39 INS85 INS42 INS32 INS39 INS85 INS42 INS3 INS42 INS42 INS42 INS34 INS42 INS34 INS40 INS42 INS42 INS42 INS34 INS42 INS40 INS40 INS42 INS42 INS42 INS42 INS42 INS42 MOV42 MOV42 INS2 INS7 UPD42 UPD42 UPD42 INS42 INS42 INS2 INS3 INS5 INS27 INS42 INS42 INS42 INS9 INS2 INS42 INS42 INS5 INS34 INS39 INS85 INS40 INS40 INS42 INS34 INS39 INS85 DEL9 DEL42 DEL25 DEL8 DEL39 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL34 DEL38 DEL27 DEL42 DEL32 DEL38 DEL42 DEL42 DEL27 DEL27 DEL36 DEL27 DEL42 DEL34 DEL38
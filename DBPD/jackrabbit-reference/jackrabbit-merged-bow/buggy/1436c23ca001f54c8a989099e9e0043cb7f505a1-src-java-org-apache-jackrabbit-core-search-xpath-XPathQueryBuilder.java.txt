- Removed JCRQL implementation
- Added proper QName support to search
- redesigned parsing and formating of queries (better separation of abstract query tree and concrete syntax)
- Some improvements in SQL: colon is now supported in identifier without having to use double quotes, LIKE now supports escaping

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@125778 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.search.TextsearchQueryNode;
+import org.apache.jackrabbit.core.search.NodeTypeQueryNode;
+import org.apache.jackrabbit.core.IllegalNameException;
+import org.apache.jackrabbit.core.UnknownPrefixException;
+import org.apache.jackrabbit.core.nodetype.NodeTypeRegistry;
-    private static final QName FN_NOT = new QName(SearchManager.NS_FN_URI, "not");
+    static final QName FN_NOT = new QName(SearchManager.NS_FN_URI, "not");
-    private static final QName FN_NOT_10 = new QName("", "not");
+    static final QName FN_NOT_10 = new QName("", "not");
-    private static final QName XS_DATETIME = new QName(SearchManager.NS_XS_URI, "dateTime");
+    static final QName XS_DATETIME = new QName(SearchManager.NS_XS_URI, "dateTime");
+
+    /** QName for jcrfn:like */
+    static final QName JCRFN_LIKE = new QName(SearchManager.NS_JCRFN_URI, "like");
+
+    /** QName for jcrfn:contains */
+    static final QName JCRFN_CONTAINS = new QName(SearchManager.NS_JCRFN_URI, "contains");
-            String nameTest = steps[0].getNameTest();
-            if (nameTest == null || nameTest.length() > 0) {
+            QName nameTest = steps[0].getNameTest();
+            if (nameTest == null || nameTest.getLocalName().length() > 0) {
+     * Creates a String representation of the query node tree in XPath syntax.
+     * @param root the root of the query node tree.
+     * @param resolver to resolve QNames.
+     * @return a String representation of the query node tree.
+     * @throws InvalidQueryException if the query node tree cannot be converted
+     *   into a String representation due to restrictions in XPath.
+     */
+    public static String toString(QueryRootNode root, NamespaceResolver resolver)
+            throws InvalidQueryException {
+        return QueryFormat.toString(root, resolver);
+    }
+
+    /**
-                ((PathQueryNode) data).addPathStep(new LocationStepQueryNode((QueryNode) data, "", false));
+                ((PathQueryNode) data).addPathStep(new LocationStepQueryNode((QueryNode) data, new QName("", ""), false));
-                ((PathQueryNode) data).addPathStep(new LocationStepQueryNode((QueryNode) data, "", false));
+                ((PathQueryNode) data).addPathStep(new LocationStepQueryNode((QueryNode) data, new QName("", ""), false));
-                    // @todo do what?
-                        || data instanceof RelationQueryNode) {
+                        || data instanceof RelationQueryNode
+                        || data instanceof PathQueryNode) {
-                if (queryNode instanceof LocationStepQueryNode) {
-                    ((LocationStepQueryNode) queryNode).setNameTest(child.getValue());
-                } else if (queryNode instanceof RelationQueryNode) {
-                    ((RelationQueryNode) queryNode).setProperty(child.getValue());
+                try {
+                    if (queryNode instanceof LocationStepQueryNode) {
+                        QName name = ISO9075.decode(QName.fromJCRName(child.getValue(), resolver));
+                        ((LocationStepQueryNode) queryNode).setNameTest(name);
+                    } else if (queryNode instanceof RelationQueryNode) {
+                        QName name = ISO9075.decode(QName.fromJCRName(child.getValue(), resolver));
+                        ((RelationQueryNode) queryNode).setProperty(name);
+                    } else if (queryNode instanceof PathQueryNode) {
+                        QName name = ISO9075.decode(QName.fromJCRName(child.getValue(), resolver));
+                        root.addSelectProperty(name);
+                    }
+                } catch (IllegalNameException e) {
+                    exceptions.add(new InvalidQueryException("Illegal name: " + child.getValue()));
+                } catch (UnknownPrefixException e) {
+                    exceptions.add(new InvalidQueryException("Unknown prefix: " + child.getValue()));
-        queryNode.addOperand(rqn);
+
+        // if property name is jcr:primaryType treat special
+        if (rqn.getProperty().equals(NodeTypeRegistry.JCR_PRIMARY_TYPE)) {
+            if (rqn.getType() == RelationQueryNode.TYPE_STRING) {
+                try {
+                    QName ntName = QName.fromJCRName(rqn.getStringValue(), resolver);
+                    NodeTypeQueryNode ntNode = new NodeTypeQueryNode(queryNode, ntName);
+                    queryNode.addOperand(ntNode);
+                } catch (IllegalNameException e) {
+                    exceptions.add(new InvalidQueryException("Not a valid name: " + rqn.getStringValue()));
+                } catch (UnknownPrefixException e) {
+                    exceptions.add(new InvalidQueryException("Unknown prefix in name: " + rqn.getStringValue()));
+                }
+            } else {
+                // value is not of type string
+                exceptions.add(new InvalidQueryException("Invalid type: jcr:primaryType must be a string"));
+            }
+        } else {
+            // property name is <> jcr:primaryType
+            queryNode.addOperand(rqn);
+        }
+                    // @todo is this needed?
+            } else if (JCRFN_CONTAINS.toJCRName(resolver).equals(fName)) {
+                // check number of arguments
+                if (node.jjtGetNumChildren() == 2) {
+                    SimpleNode literal = (SimpleNode) node.jjtGetChild(1).jjtGetChild(0);
+                    if (queryNode instanceof NAryQueryNode) {
+                        if (literal.getId() == XPathTreeConstants.JJTSTRINGLITERAL) {
+                            String value = literal.getValue();
+                            // strip quotes
+                            value = value.substring(1, value.length() - 1);
+                            TextsearchQueryNode contains = new TextsearchQueryNode(queryNode, value);
+                            ((NAryQueryNode) queryNode).addOperand(contains);
+                        } else {
+                            exceptions.add(new InvalidQueryException("Wrong argument type for jcrfn:contains"));
+                        }
+                    } else {
+                        exceptions.add(new InvalidQueryException("Unsupported location for function jcrfn:contains"));
+                    }
+                } else {
+                    // wrong number of arguments
+                    exceptions.add(new InvalidQueryException("Wrong number of arguments for jcrfn:contains"));
+                }
+            } else if (JCRFN_LIKE.toJCRName(resolver).equals(fName)) {
+                // check number of arguments
+                if (node.jjtGetNumChildren() == 3) {
+                    if (queryNode instanceof NAryQueryNode) {
+                        RelationQueryNode like = new RelationQueryNode(queryNode, RelationQueryNode.OPERATION_LIKE);
+                        ((NAryQueryNode) queryNode).addOperand(like);
+
+                        // assign property name
+                        node.jjtGetChild(1).jjtAccept(this, like);
+                        // check property name
+                        if (like.getProperty() == null) {
+                            exceptions.add(new InvalidQueryException("Wrong first argument type for jcrfn:like"));
+                        }
+
+                        SimpleNode literal = (SimpleNode) node.jjtGetChild(2).jjtGetChild(0);
+                        if (literal.getId() == XPathTreeConstants.JJTSTRINGLITERAL) {
+                            String value = literal.getValue();
+                            // strip quotes
+                            value = value.substring(1, value.length() - 1);
+                            like.setStringValue(value);
+                        } else {
+                            exceptions.add(new InvalidQueryException("Wrong second argument type for jcrfn:like"));
+                        }
+                    } else {
+                        exceptions.add(new InvalidQueryException("Unsupported location for function jcrfn:like"));
+                    }
+                } else {
+                    // wrong number of arguments
+                    exceptions.add(new InvalidQueryException("Wrong number of arguments for jcrfn:like"));
+                }

INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS31 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS43 INS8 INS65 INS42 INS42 INS14 INS65 INS42 INS42 INS14 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS42 INS41 MOV21 MOV21 INS25 INS66 INS43 INS40 INS45 INS66 INS43 INS40 INS45 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS32 INS32 INS8 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS40 INS25 MOV21 INS43 INS62 INS8 INS42 INS42 INS27 INS8 INS8 INS42 INS14 INS14 INS42 INS43 INS54 INS32 INS40 INS54 INS21 INS25 INS43 MOV45 INS45 INS43 MOV45 INS45 INS42 MOV8 INS12 INS12 INS42 INS42 INS8 INS12 INS12 INS32 INS32 INS8 INS25 INS32 INS42 INS42 INS44 INS8 INS44 INS8 INS60 INS60 INS21 INS44 INS8 INS44 INS8 INS42 INS42 INS14 INS32 INS42 INS42 INS25 INS32 INS8 MOV8 MOV42 INS42 INS8 INS25 INS43 INS42 INS21 INS43 INS42 INS21 INS43 INS59 INS43 INS59 INS32 INS43 INS42 INS21 INS43 INS42 INS21 INS43 INS45 INS42 INS42 INS42 INS27 INS8 INS8 INS32 INS42 INS42 INS25 INS60 MOV21 MOV62 MOV8 MOV25 INS42 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS34 INS60 INS25 INS21 INS42 INS42 INS42 INS27 INS8 INS8 INS43 INS59 INS60 MOV21 INS62 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS43 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS43 INS59 INS62 INS8 INS8 INS32 INS32 INS34 INS25 INS21 INS42 INS42 INS32 INS42 INS43 INS59 INS42 INS43 INS60 INS21 INS43 INS27 INS43 INS27 INS42 INS42 INS42 INS43 INS27 INS43 INS27 INS42 INS42 INS11 INS42 INS43 INS25 INS21 INS42 INS42 INS14 INS42 INS42 INS62 INS8 INS8 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS43 INS59 INS32 INS42 INS45 INS32 INS42 INS45 INS32 INS42 INS45 INS32 INS42 INS45 INS32 INS43 INS32 INS42 INS27 INS8 INS8 INS32 INS43 INS45 INS42 INS43 INS60 INS21 INS21 INS25 INS60 INS25 INS21 INS42 INS42 INS14 INS42 INS42 MOV32 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS34 INS32 INS40 INS60 INS21 INS60 INS21 INS21 INS42 INS42 INS14 INS42 INS42 INS43 INS59 INS32 INS32 INS27 INS8 INS43 INS59 INS27 INS8 INS8 INS32 INS43 INS45 INS42 INS42 MOV32 INS42 INS42 INS42 INS32 INS42 INS42 INS34 INS42 INS42 MOV43 INS59 INS7 INS43 INS59 INS32 INS32 INS43 INS45 INS42 INS42 INS14 INS36 INS42 INS42 INS32 INS42 INS52 INS42 INS32 INS33 INS21 INS42 INS42 INS11 INS32 INS40 INS60 INS21 INS21 INS21 INS42 INS42 INS14 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS14 INS36 INS42 INS42 INS42 INS42 INS14 INS42 INS43 INS42 INS40 INS11 INS42 INS42 INS34 INS42 INS42 INS32 INS43 INS32 INS42 INS42 INS43 INS59 INS7 INS32 INS32 INS43 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS27 INS43 INS42 INS42 INS11 INS43 INS45 INS42 INS43 INS42 INS42 INS42 INS14 INS42 INS32 INS42 INS34 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS32 INS34 INS42 INS43 INS42 INS42 INS42 INS43 INS45 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS34 INS27 INS43 INS45 INS42 INS42 INS42 INS42 INS32 INS34 INS42 INS42 INS42 DEL83 DEL83 DEL83
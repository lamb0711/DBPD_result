JCR-2498: Implement caching mechanism for ItemInfo batches

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@915810 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.HashMap;
-import java.util.Map;
-import java.util.NoSuchElementException;
+import org.apache.jackrabbit.spi.ItemInfoCache;
+import org.apache.jackrabbit.spi.ItemInfoCache.Entry;
-public class WorkspaceItemStateFactory extends AbstractItemStateFactory implements ItemStateFactory {
-
+public class WorkspaceItemStateFactory extends AbstractItemStateFactory {
+    public final ItemInfoCache cache;
+
-                                     ItemDefinitionProvider definitionProvider) {
+            ItemDefinitionProvider definitionProvider, ItemInfoCache cache) throws RepositoryException {
+
+        this.cache = cache;
-    /**
-     * @see ItemStateFactory#createRootState(NodeEntry)
-     */
-     * Creates the node with information retrieved from the
-     * <code>RepositoryService</code>.
-     *
-     * @see ItemStateFactory#createNodeState(NodeId,NodeEntry)
+     * Creates the node with information retrieved from the <code>RepositoryService</code>.
-    public NodeState createNodeState(NodeId nodeId, NodeEntry entry)
-            throws ItemNotFoundException, RepositoryException {
-        // build new node state from server information
-        try {
-            Iterator<? extends ItemInfo> infos = service.getItemInfos(sessionInfo, nodeId);
-            NodeState nodeState = createItemStates(nodeId, infos, entry, false);
+    public NodeState createNodeState(NodeId nodeId, NodeEntry entry) throws ItemNotFoundException,
+            RepositoryException {
-            if (nodeState == null) {
-                throw new ItemNotFoundException("HierarchyEntry does not belong to any existing ItemInfo.");
+        try {
+            // Get item info from cache and use it if up to date
+            long generation = entry.getGeneration();
+            Entry<NodeInfo> cached = cache.getNodeInfo(nodeId);
+            NodeInfo info;
+            if (isUpToDate(cached, generation)) {
+                info = cached.info;
-            return nodeState;
-        } catch (PathNotFoundException e) {
-            throw new ItemNotFoundException(e.getMessage());
+            else {
+                // otherwise retreive item info from service and cache the whole batch
+                Iterator<? extends ItemInfo> infos = service.getItemInfos(sessionInfo, nodeId);
+                info = first(infos, cache, generation);
+                if (info == null) {
+                    throw new ItemNotFoundException("NodeId: " + nodeId);
+                }
+            }
+
+            assertMatchingPath(info, entry);
+            return createNodeState(info, entry);
+        }
+        catch (PathNotFoundException e) {
+            throw new ItemNotFoundException(e);
-     * @see ItemStateFactory#createDeepNodeState(NodeId,NodeEntry)
+     * Creates the node with information retrieved from the <code>RepositoryService</code>.
+     * Intermediate entries are created as needed.
-    public NodeState createDeepNodeState(NodeId nodeId, NodeEntry anyParent) throws ItemNotFoundException, RepositoryException {
+    public NodeState createDeepNodeState(NodeId nodeId, NodeEntry anyParent) throws ItemNotFoundException,
+            RepositoryException {
+
-            Iterator<? extends ItemInfo> infos = service.getItemInfos(sessionInfo, nodeId);
-            return createItemStates(nodeId, infos, anyParent, true);
-        } catch (PathNotFoundException e) {
-            throw new ItemNotFoundException(e.getMessage());
+            // Get item info from cache
+            Iterator<? extends ItemInfo> infos = null;
+            Entry<NodeInfo> cached = cache.getNodeInfo(nodeId);
+            NodeInfo info;
+            if (cached == null) {
+                // or from service if not in cache
+                infos = service.getItemInfos(sessionInfo, nodeId);
+                info = first(infos, null, 0);
+                if (info == null) {
+                    throw new ItemNotFoundException("NodeId: " + nodeId);
+                }
+            }
+            else {
+                info = cached.info;
+            }
+
+            // Build the hierarchy entry for the item info
+            HierarchyEntry entry = createHierarchyEntries(info, anyParent);
+            if (entry == null || !entry.denotesNode()) {
+                throw new ItemNotFoundException(
+                        "HierarchyEntry does not belong to any existing ItemInfo. No ItemState was created.");
+            }
+            else {
+                // Now we can check wheter the item info from the cache is up to date
+                long generation = entry.getGeneration();
+                if (isOutdated(cached, generation)) {
+                    // if not, retreive the item info from the service and put the whole batch into the cache
+                    infos = service.getItemInfos(sessionInfo, nodeId);
+                    info = first(infos, cache, generation);
+                }
+                else if (infos != null) {
+                    // Otherwise put the whole batch retreived from the service earlier into the cache
+                    cache.put(info, generation);
+                    first(infos, cache, generation);
+                }
+
+                assertMatchingPath(info, entry);
+                return createNodeState(info, (NodeEntry) entry);
+            }
+        }
+        catch (PathNotFoundException e) {
+            throw new ItemNotFoundException(e);
-     * Creates the PropertyState with information retrieved from the
-     * <code>RepositoryService</code>.
-     *
-     * @see ItemStateFactory#createPropertyState(PropertyId,PropertyEntry)
+     * Creates the PropertyState with information retrieved from the <code>RepositoryService</code>.
-    public PropertyState createPropertyState(PropertyId propertyId,
-                                             PropertyEntry entry)
+    public PropertyState createPropertyState(PropertyId propertyId, PropertyEntry entry)
+
-            PropertyInfo info = service.getPropertyInfo(sessionInfo, propertyId);
+            // Get item info from cache and use it if up to date
+            Entry<PropertyInfo> cached = cache.getPropertyInfo(propertyId);
+            PropertyInfo info;
+            if (isUpToDate(cached, entry.getGeneration())) {
+                info = cached.info;
+            }
+            else {
+                // otherwise retreive item info from service and cache the whole batch
+                info = service.getPropertyInfo(sessionInfo, propertyId);
+                cache.put(info, entry.getGeneration());
+            }
+
-        } catch (PathNotFoundException e) {
-            throw new ItemNotFoundException(e.getMessage());
+        }
+        catch (PathNotFoundException e) {
+            throw new ItemNotFoundException(e);
-     * @see ItemStateFactory#createDeepPropertyState(PropertyId,NodeEntry)
+     * Creates the PropertyState with information retrieved from the <code>RepositoryService</code>.
+     * Intermediate entries are created as needed.
-    public PropertyState createDeepPropertyState(PropertyId propertyId, NodeEntry anyParent) throws ItemNotFoundException, RepositoryException {
+    public PropertyState createDeepPropertyState(PropertyId propertyId, NodeEntry anyParent)
+            throws RepositoryException {
+
-            PropertyInfo info = service.getPropertyInfo(sessionInfo, propertyId);
-            PropertyState propState = createDeepPropertyState(info, anyParent, null);
-            assertValidState(propState, info);
-            return propState;
-        } catch (PathNotFoundException e) {
-            throw new ItemNotFoundException(e.getMessage());
+            // Get item info from cache
+            Entry<PropertyInfo> cached = cache.getPropertyInfo(propertyId);
+            PropertyInfo info;
+            if (cached == null) {
+                // or from service if not in cache
+                info = service.getPropertyInfo(sessionInfo, propertyId);
+            }
+            else {
+                info = cached.info;
+            }
+
+            // Build the hierarchy entry for the item info
+            HierarchyEntry entry = createHierarchyEntries(info, anyParent);
+
+            if (entry == null || entry.denotesNode()) {
+                throw new ItemNotFoundException(
+                        "HierarchyEntry does not belong to any existing ItemInfo. No ItemState was created.");
+            }
+            else {
+                // Now we can check wheter the item info from the cache is up to date
+                long generation = entry.getGeneration();
+                if (isOutdated(cached, generation)) {
+                    // if not, retreive the item info from the service and put the whole batch into the cache
+                    info = service.getPropertyInfo(sessionInfo, propertyId);
+                    cache.put(info, generation);
+                }
+
+                assertMatchingPath(info, entry);
+                return createPropertyState(info, (PropertyEntry) entry);
+            }
+
+        }
+        catch (PathNotFoundException e) {
+            throw new ItemNotFoundException(e);
-    /**
-     * @see ItemStateFactory#getChildNodeInfos(NodeId)
-     * @param nodeId
-     */
-    public Iterator<ChildInfo> getChildNodeInfos(NodeId nodeId)
-            throws ItemNotFoundException, RepositoryException {
+    public Iterator<ChildInfo> getChildNodeInfos(NodeId nodeId) throws ItemNotFoundException,
+            RepositoryException {
+
-    /**
-     * @see ItemStateFactory#getNodeReferences(NodeState,org.apache.jackrabbit.spi.Name,boolean)
-     */
-        // shortcut
-        if (entry.getUniqueID() == null
-                || !entry.hasPropertyEntry(NameConstants.JCR_UUID)) {
+
+        // Shortcut
+        if (entry.getUniqueID() == null || !entry.hasPropertyEntry(NameConstants.JCR_UUID)) {
-        // nodestate has a unique ID and is potentially mix:referenceable
-        // => try to retrieve references
+        // Has a unique ID and is potentially mix:referenceable. Try to retrieve references
-        } catch (RepositoryException e) {
+        }
+        catch (RepositoryException e) {
+
-     *
-     * @param nodeId
-     * @param itemInfos
-     * @param entry
-     * @param isDeep
-     * @return
-     * @throws ItemNotFoundException
-     * @throws RepositoryException
+     * Returns the first item in the iterator if it exists and denotes a node.
+     * Otherwise returns <code>null</code>. If <code>cache</code> is not
+     * <code>null</code>, caches all items by the given <code>generation</code>.
+     * @param generation
-    private synchronized NodeState createItemStates(NodeId nodeId, Iterator<? extends ItemInfo> itemInfos,
-                                                    NodeEntry entry, boolean isDeep)
-            throws ItemNotFoundException, RepositoryException {
-        NodeState nodeState;
-        ItemInfos infos = new ItemInfos(itemInfos);
-
-        // first entry in the iterator is the originally requested Node.
-        NodeInfo first = first(infos);
-        if (first == null) {
-            throw new ItemNotFoundException("Node with id " + nodeId + " could not be found.");
-        }
-        else {
-            if (isDeep) {
-                // for a deep state, the hierarchy entry does not correspond to
-                // the given NodeEntry -> retrieve NodeState before executing
-                // validation check.
-                nodeState = createDeepNodeState(first, entry, infos);
-                assertValidState(nodeState, first);
-            } else {
-                // 'isDeep' == false -> the given NodeEntry must match to the
-                // first ItemInfo retrieved from the iterator.
-                assertMatchingPath(first, entry);
-                nodeState = createNodeState(first, entry);
-            }
-        }
-
-        // deal with all additional ItemInfos that may be present.
-        // Assuming locality of the itemInfos, we keep an estimate of a parent entry.
-        // This reduces the part of the hierarchy to traverse. For large batches this
-        // optimization results in about 25% speed up.
-        NodeEntry approxParentEntry = nodeState.getNodeEntry();
-        while (infos.hasNext()) {
-            ItemInfo info = infos.next();
-            if (info.denotesNode()) {
-                approxParentEntry = createDeepNodeState((NodeInfo) info, approxParentEntry, infos).getNodeEntry();
-            } else {
-                createDeepPropertyState((PropertyInfo) info, approxParentEntry, infos);
-            }
-        }
-        return nodeState;
-    }
-
-    private static NodeInfo first(ItemInfos infos) {
+    private static NodeInfo first(Iterator<? extends ItemInfo> infos, ItemInfoCache cache, long generation) {
+        ItemInfo first = null;
-            ItemInfo first = infos.next();
-            if (first.denotesNode()) {
-                return (NodeInfo) first;
+            first = infos.next();
+            if (cache != null) {
+                cache.put(first, generation);
+            }
+
+            if (!first.denotesNode()) {
+                first = null;
-        return null;
+        if (cache != null) {
+            while (infos.hasNext()) {
+                cache.put(infos.next(), generation);
+            }
+        }
+
+        return (NodeInfo) first;
-     * Creates the node with information retrieved from <code>info</code>.
+     * Create the node state with the information from <code>info</code>.
-     * @param entry
+     * @param entry  the hierarchy entry for of this state
-    private NodeState createNodeState(NodeInfo info, NodeEntry entry) throws ItemNotFoundException, RepositoryException {
-        // make sure the entry has the correct ItemId
+    private NodeState createNodeState(NodeInfo info, NodeEntry entry) throws ItemNotFoundException,
+            RepositoryException {
+
+        // Make sure the entry has the correct ItemId
-            log.warn("Internal error", e);
+            log.error("Internal error", e);
-     * Creates the property with information retrieved from <code>info</code>.
+     * Create the property state with the information from <code>info</code>.
-     * @param info   the <code>PropertyInfo</code> to use to create the
-     *               <code>PropertyState</code>.
-     * @param entry
+     * @param info the <code>PropertyInfo</code> to use to create the <code>PropertyState</code>.
+     * @param entry  the hierarchy entry for of this state
+     * @throws RepositoryException
+
+     * Create missing hierarchy entries on the path from <code>anyParent</code> to the path
+     * of the <code>itemInfo</code>.
-     * @return
+     * @return the hierarchy entry for <code>info</code>
-    private NodeState createDeepNodeState(NodeInfo info, NodeEntry anyParent, ItemInfos infos) throws RepositoryException {
-        try {
-            // node for nodeId exists -> build missing entries in hierarchy
-            // Note, that the path contained in NodeId does not reveal which
-            // entries are missing -> calculate relative path.
-            Path anyParentPath = anyParent.getWorkspacePath();
-            Path relPath = anyParentPath.computeRelativePath(info.getPath());
-            Path.Element[] missingElems = relPath.getElements();
+    private HierarchyEntry createHierarchyEntries(ItemInfo info, NodeEntry anyParent)
+            throws RepositoryException {
-            if (startsWithIllegalElement(missingElems)) {
-                log.error("Relative path to NodeEntry starts with illegal element -> ignore NodeInfo with path " + info.getPath());
-                return null;
+        // Calculate relative path of missing entries
+        Path anyParentPath = anyParent.getWorkspacePath();
+        Path relPath = anyParentPath.computeRelativePath(info.getPath());
+        Path.Element[] missingElems = relPath.getElements();
+
+        NodeEntry entry = anyParent;
+        int last = missingElems.length - 1;
+        for (int i = 0; i <= last; i++) {
+            if (missingElems[i].denotesParent()) {
+                // Walk up the hierarchy for 'negative' paths
+                // until the smallest common root is found
+                entry = entry.getParent();
+            else if (missingElems[i].denotesName()) {
+                // Add missing elements starting from the smallest common root
+                Name name = missingElems[i].getName();
+                int index = missingElems[i].getNormalizedIndex();
-            NodeEntry entry = anyParent;
-            for (int i = 0; i < missingElems.length; i++) {
-                if (missingElems[i].denotesParent()) {
-                    // Walk up the hierarchy for 'negative' paths
-                    // until the smallest common root is found
-                    entry = entry.getParent();
+                if (i == last && !info.denotesNode()) {
+                    return entry.getOrAddPropertyEntry(name);
-                else if (missingElems[i].denotesName()) {
-                    // Add missing elements starting from the smallest common root
-                    Name name = missingElems[i].getName();
-                    int index = missingElems[i].getNormalizedIndex();
-                    entry = createIntermediateNodeEntry(entry, name, index, infos);
+                else {
+                    entry = createNodeEntry(entry, name, index);
-                // else denotesCurrent -> ignore
-
-            return createNodeState(info, entry);
-        } catch (PathNotFoundException e) {
-            throw new ItemNotFoundException(e.getMessage());
+        return entry;
-    /**
-     *
-     * @param info
-     * @param anyParent
-     * @return
-     * @throws RepositoryException
-     */
-    private PropertyState createDeepPropertyState(PropertyInfo info, NodeEntry anyParent, ItemInfos infos) throws RepositoryException {
-        try {
-            // prop for propertyId exists -> build missing entries in hierarchy
-            // Note, that the path contained in PropertyId does not reveal which
-            // entries are missing -> calculate relative path.
-            Path anyParentPath = anyParent.getWorkspacePath();
-            Path relPath = anyParentPath.computeRelativePath(info.getPath());
-            Path.Element[] missingElems = relPath.getElements();
-
-            // make sure the missing elements don't start with . or .. in which
-            // case the info is not within the tree as it is expected
-            // (see also JCR-1797)
-            if (startsWithIllegalElement(missingElems)) {
-                log.error("Relative path to PropertyEntry starts with illegal element -> ignore PropertyInfo with path " + info.getPath());
-                return null;
-            }
-
-            NodeEntry entry = anyParent;
-            int i = 0;
-            // NodeEntries except for the very last 'missingElem'
-            while (i < missingElems.length - 1) {
-                if (missingElems[i].denotesParent()) {
-                    // Walk up the hierarchy for 'negative' paths
-                    // until the smallest common root is found
-                    entry = entry.getParent();
-                }
-                else if (missingElems[i].denotesName()) {
-                    // Add missing elements starting from the smallest common root
-                    Name name = missingElems[i].getName();
-                    int index = missingElems[i].getNormalizedIndex();
-                    entry = createIntermediateNodeEntry(entry, name, index, infos);
-                }
-                // else denotesCurrent -> ignore
-                i++;
-            }
-            // create PropertyEntry for the last element if not existing yet
-            Name propName = missingElems[i].getName();
-            PropertyEntry propEntry = entry.getOrAddPropertyEntry(propName);
-
-            return createPropertyState(info, propEntry);
-        } catch (PathNotFoundException e) {
-            throw new ItemNotFoundException(e.getMessage());
-        }
-    }
-
-    /**
-     *
-     * @param parentEntry
-     * @param name
-     * @param index
-     * @return
-     * @throws RepositoryException
-     */
-    private static NodeEntry createIntermediateNodeEntry(NodeEntry parentEntry,
-                                                         Name name, int index,
-                                                         ItemInfos infos) throws RepositoryException {
-        if (infos != null) {
-            Iterator<ChildInfo> childInfos = infos.getChildInfos(parentEntry.getWorkspaceId());
+    private NodeEntry createNodeEntry(NodeEntry parentEntry, Name name, int index) throws RepositoryException {
+        Entry<NodeInfo> cached = cache.getNodeInfo(parentEntry.getWorkspaceId());
+        if (isUpToDate(cached, parentEntry.getGeneration())) {
+            Iterator<ChildInfo> childInfos = cached.info.getChildInfos();
-        NodeEntry entry = parentEntry.getOrAddNodeEntry(name, index, null);
-        return entry;
+
+        return parentEntry.getOrAddNodeEntry(name, index, null);
-     * Validation check: make sure the state is not null (was really created)
-     * and matches with the specified ItemInfo (path).
-     *
-     * @param state
-     * @param info
-     * @throws ItemNotFoundException
-     * @throws RepositoryException
+     * Returns true iff <code>cache</code> is not <code>null</code> and
+     * the cached entry is up to date.
+     * @param cacheEntry
+     * @param generation
+     * @return
-    private static void assertValidState(ItemState state, ItemInfo info)
-            throws ItemNotFoundException, RepositoryException {
-        if (state == null) {
-            throw new ItemNotFoundException("HierarchyEntry does not belong to any existing ItemInfo. No ItemState was created.");
-        }
-        assertMatchingPath(info, state.getHierarchyEntry());
+    private static boolean isUpToDate(Entry<?> cacheEntry, long generation) {
+        return cacheEntry != null && cacheEntry.generation >= generation;
+    }
+
+    /**
+     * Returns true iff <code>cache</code> is not <code>null</code> and
+     * the cached entry is not up to date.
+     * @param cacheEntry
+     * @param generation
+     * @return
+     */
+    private static boolean isOutdated(Entry<?> cacheEntry, long generation) {
+        return cacheEntry != null && cacheEntry.generation < generation;
-     * @throws ItemNotFoundException
-    private static void assertMatchingPath(ItemInfo info, HierarchyEntry entry)
-            throws ItemNotFoundException, RepositoryException {
+    private static void assertMatchingPath(ItemInfo info, HierarchyEntry entry) throws RepositoryException {
-        if (!infoPath.equals(entry.getWorkspacePath())) {
+        Path wspPath = entry.getWorkspacePath();
+        if (!infoPath.equals(wspPath)) {
-            throw new ItemNotFoundException("HierarchyEntry does not belong the given ItemInfo.");
+            throw new ItemNotFoundException("HierarchyEntry " + infoPath + " does not match ItemInfo " + wspPath);
-     * Returns true if the given <code>missingElems</code> start with
-     * the root element, in which case the info is not within
-     * the tree as it is expected.
-     * See also #JCR-1797 for the corresponding enhancement request.
-     *
-     * @param missingElems
-     * @return true if the first element doesn't denote a named element.
-     */
-    private static boolean startsWithIllegalElement(Path.Element[] missingElems) {
-        if (missingElems.length > 0) {
-            return missingElems[0].denotesRoot();
-        }
-        return false;
-    }
-
-    /**
+            log.error("Parent of degree {} does not exist.", degree);
-
-    //--------------------------------------------------------------------------
-    /**
-     * Iterator
-     */
-    private class ItemInfos implements Iterator<ItemInfo> {
-
-        private final List<ItemInfo> prefetchQueue = new ArrayList<ItemInfo>();
-        private final Map<NodeId, NodeInfo> nodeInfos = new HashMap<NodeId, NodeInfo>();
-        private final Iterator<? extends ItemInfo> infos;
-
-        private ItemInfos(Iterator<? extends ItemInfo> infos) {
-            super();
-            this.infos = infos;
-        }
-
-        // ------------------------------------------------------< Iterator >---
-        /**
-         * @see Iterator#hasNext()
-         */
-        public boolean hasNext() {
-            if (!prefetchQueue.isEmpty()) {
-                return true;
-            } else {
-                return prefetch();
-            }
-        }
-
-        /**
-         * @see Iterator#next()
-         */
-        public ItemInfo next() {
-            if (prefetchQueue.isEmpty()) {
-                throw new NoSuchElementException();
-            } else {
-                ItemInfo next = prefetchQueue.remove(0);
-                if (next instanceof NodeInfo) {
-                    nodeInfos.remove(((NodeInfo) next).getId());
-                }
-                return next;
-            }
-        }
-
-        /**
-         * @see Iterator#remove()
-         */
-        public void remove() {
-            throw new UnsupportedOperationException();
-        }
-
-        // -------------------------------------------------------< private >---
-        /**
-         * @param parentId
-         * @return The children <code>NodeInfo</code>s for the parent identified
-         * by the given <code>parentId</code> or <code>null</code> if the parent
-         * has not been read yet, has already been processed (childInfo is up
-         * to date) or does not provide child infos.
-         */
-        private Iterator<ChildInfo> getChildInfos(NodeId parentId) {
-            NodeInfo nodeInfo = nodeInfos.get(parentId);
-            while (nodeInfo == null && prefetch()) {
-                nodeInfo = nodeInfos.get(parentId);
-            }
-            return nodeInfo == null? null : nodeInfo.getChildInfos();
-        }
-
-        /**
-         * @return <code>true</code> if the next info could be retrieved.
-         */
-        private boolean prefetch() {
-            if (infos.hasNext()) {
-                ItemInfo info = infos.next();
-                prefetchQueue.add(info);
-                if (info.denotesNode()) {
-                    NodeInfo nodeInfo = (NodeInfo) info;
-                    nodeInfos.put(nodeInfo.getId(), nodeInfo);
-                }
-                return true;
-            } else {
-                return false;
-            }
-        }
-    }

MOV26 MOV26 MOV31 UPD40 UPD40 INS23 INS31 INS31 INS31 INS31 MOV31 INS31 MOV31 INS83 INS83 INS43 INS59 INS44 MOV43 MOV29 MOV83 MOV43 MOV42 MOV44 MOV44 MOV43 MOV43 INS8 MOV29 MOV83 MOV43 INS42 MOV44 MOV44 MOV43 MOV43 INS8 INS29 INS83 MOV43 INS42 MOV44 MOV44 MOV43 MOV43 INS8 UPD83 MOV43 MOV44 MOV44 MOV43 MOV29 MOV83 MOV83 MOV43 UPD42 MOV42 MOV44 MOV44 INS44 INS8 UPD83 UPD43 UPD42 MOV44 MOV44 MOV43 INS8 UPD42 INS29 MOV83 INS83 INS39 INS42 INS44 MOV44 MOV8 INS83 INS42 INS44 INS44 INS8 UPD42 MOV42 INS42 INS43 INS42 INS21 INS54 INS54 INS65 INS54 UPD65 UPD43 UPD42 INS39 INS42 INS60 INS25 MOV25 MOV41 MOV65 INS65 MOV65 MOV65 UPD65 MOV65 UPD42 MOV60 MOV60 MOV60 MOV60 MOV60 INS24 MOV41 MOV60 INS41 INS65 UPD65 MOV65 MOV65 MOV65 INS74 INS42 INS39 INS42 INS41 UPD65 INS65 INS65 INS65 INS74 INS42 INS39 INS42 INS41 INS60 INS42 INS7 UPD66 INS8 MOV12 UPD66 UPD66 INS8 MOV12 INS66 INS8 INS12 INS66 INS66 INS66 UPD66 UPD66 UPD42 UPD42 MOV43 INS59 MOV32 INS8 INS27 INS8 UPD66 INS66 UPD66 UPD66 INS66 INS66 INS66 INS66 INS39 MOV58 INS27 MOV37 MOV8 INS74 INS32 MOV32 INS66 INS66 INS42 UPD42 UPD43 MOV43 INS76 INS27 UPD66 INS66 INS42 INS42 INS43 INS76 INS27 INS43 INS59 INS22 INS42 MOV60 INS60 INS60 INS25 INS21 MOV41 MOV60 MOV60 INS60 INS25 INS60 INS25 MOV60 MOV60 INS25 MOV21 MOV41 MOV44 MOV8 INS60 INS25 MOV44 INS42 INS33 INS21 INS25 INS25 INS42 INS33 INS61 UPD42 MOV27 INS42 INS42 INS43 MOV43 UPD42 INS42 INS42 INS32 INS60 UPD42 UPD27 MOV27 INS27 UPD42 MOV42 INS27 INS27 INS42 INS42 MOV32 INS21 INS52 INS42 INS39 INS74 INS59 MOV43 INS59 INS32 INS8 INS8 INS32 MOV74 INS74 MOV43 INS59 INS27 INS8 MOV8 INS43 INS59 INS27 INS8 INS8 INS74 MOV43 INS32 INS8 INS8 INS74 MOV59 MOV43 INS27 INS8 UPD43 INS27 MOV8 INS8 INS7 UPD27 MOV27 INS8 INS38 INS8 MOV32 INS8 INS42 UPD42 UPD42 INS42 INS42 MOV74 INS59 UPD42 INS40 INS42 INS42 INS33 INS40 INS42 INS42 INS32 UPD42 INS43 MOV43 INS42 INS32 INS42 INS42 INS42 INS42 INS21 MOV60 INS21 INS25 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 INS33 INS43 MOV43 UPD42 INS42 INS42 INS33 INS21 INS21 INS25 INS42 INS42 INS32 INS27 INS38 INS53 INS60 INS25 MOV21 INS41 INS43 MOV43 UPD42 UPD42 INS42 UPD42 MOV42 INS32 INS21 INS21 INS21 INS43 INS43 UPD42 UPD42 INS42 INS33 INS21 UPD42 INS32 INS27 INS32 MOV60 INS25 INS21 MOV41 INS42 MOV32 UPD42 MOV21 MOV32 MOV21 INS21 INS42 INS32 INS27 INS42 INS42 INS45 INS42 UPD42 UPD42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS7 INS7 INS27 INS8 INS42 UPD42 MOV42 UPD42 UPD42 UPD42 INS7 INS7 MOV27 MOV8 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS33 INS32 INS14 INS39 MOV59 MOV32 INS8 INS25 INS32 INS42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS7 INS7 INS32 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 MOV42 UPD42 MOV42 INS7 INS7 INS42 INS42 INS42 INS42 INS33 INS42 INS42 UPD39 INS32 INS8 INS32 MOV43 INS42 INS32 UPD42 INS25 INS40 INS42 INS45 INS42 INS45 INS42 INS42 INS40 INS42 INS32 INS42 INS33 INS53 INS42 INS32 INS42 INS32 UPD42 INS42 INS40 UPD42 MOV42 UPD42 MOV42 INS43 INS45 UPD42 INS32 UPD42 UPD42 INS42 MOV21 INS21 MOV27 INS8 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS11 INS42 INS40 INS42 MOV32 INS42 INS42 INS42 INS32 INS42 MOV32 INS42 INS40 UPD42 INS32 INS42 INS42 INS42 INS21 INS21 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS11 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 INS33 INS42 UPD42 MOV42 MOV32 INS42 INS27 INS8 INS8 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS14 INS42 INS42 INS42 INS42 MOV42 MOV42 INS33 INS34 UPD42 MOV42 INS42 INS42 INS7 INS21 INS21 MOV43 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS7 INS32 MOV43 INS42 INS27 INS38 INS41 MOV21 MOV43 INS27 MOV43 UPD42 INS42 INS32 INS32 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS32 INS45 INS42 UPD45 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 UPD42 MOV42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 UPD42 DEL40 DEL26 DEL43 DEL42 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL29 DEL66 DEL42 DEL42 DEL42 DEL43 DEL69 DEL42 DEL43 DEL69 DEL68 DEL65 DEL42 DEL43 DEL42 DEL42 DEL9 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL43 DEL69 DEL69 DEL68 DEL65 DEL43 DEL33 DEL45 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL11 DEL42 DEL32 DEL42 DEL45 DEL32 DEL27 DEL42 DEL42 DEL32 DEL43 DEL42 DEL42 DEL2 DEL39 DEL42 DEL42 DEL2 DEL42 DEL32 DEL45 DEL42 DEL65 DEL42 DEL43 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL32 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL43 DEL60 DEL40 DEL43 DEL85 DEL5 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL33 DEL41 DEL42 DEL34 DEL42 DEL42 DEL27 DEL61 DEL42 DEL43 DEL42 DEL42 DEL42 DEL2 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL33 DEL27 DEL25 DEL42 DEL41 DEL8 DEL32 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL31 DEL42 DEL42 DEL42 DEL43 DEL69 DEL42 DEL43 DEL69 DEL68 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL43 DEL76 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL9 DEL32 DEL41 DEL8 DEL54 DEL8 DEL31 DEL42 DEL42 DEL59 DEL60 DEL8 DEL42 DEL42 DEL32 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL31 DEL42 DEL42 DEL42 DEL43 DEL69 DEL69 DEL68 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL8 DEL54 DEL8 DEL31 DEL42 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL42 DEL65 DEL29 DEL42 DEL42 DEL42 DEL43 DEL69 DEL40 DEL43 DEL69 DEL39 DEL69 DEL68 DEL65 DEL29 DEL42 DEL65 DEL42 DEL65 DEL32 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL32 DEL38 DEL9 DEL41 DEL8 DEL32 DEL41 DEL8 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL65 DEL42 DEL65 DEL42 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL43 DEL60 DEL8 DEL42 DEL42 DEL11 DEL32 DEL21 DEL8 DEL25 DEL8 DEL61 DEL42 DEL41 DEL8 DEL31 DEL83 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL59 DEL60 DEL8 DEL25 DEL8 DEL25 DEL33 DEL41 DEL8 DEL31 DEL66 DEL42 DEL42 DEL68 DEL42 DEL43 DEL42 DEL42 DEL34 DEL32 DEL42 DEL42 DEL37 DEL21 DEL42 DEL42 DEL32 DEL42 DEL43 DEL14 DEL53 DEL8 DEL42 DEL62 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8 DEL25 DEL8 DEL42 DEL65 DEL42 DEL65 DEL65 DEL42 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL32 DEL33 DEL41 DEL8 DEL25 DEL42 DEL40 DEL27 DEL42 DEL42 DEL2 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL2 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL25 DEL8 DEL24 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL32 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL31 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL68 DEL66 DEL66 DEL66 DEL66 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL32 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL61 DEL42 DEL33 DEL27 DEL33 DEL42 DEL42 DEL32 DEL16 DEL41 DEL42 DEL42 DEL42 DEL32 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL9 DEL41 DEL8 DEL9 DEL41 DEL8 DEL25 DEL8 DEL39 DEL42 DEL43 DEL42 DEL43 DEL25 DEL8 DEL31 DEL42 DEL65 DEL42 DEL43 DEL45 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL40 DEL43 DEL85 DEL5 DEL42 DEL44 DEL40 DEL34 DEL27 DEL42 DEL34 DEL2 DEL42 DEL32 DEL41 DEL8 DEL25 DEL9 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL76 DEL74 DEL42 DEL59 DEL23 DEL83 DEL42 DEL46 DEL8 DEL31 DEL42 DEL42 DEL68 DEL65 DEL29 DEL83 DEL39 DEL42 DEL8 DEL31 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL14 DEL53 DEL8 DEL31 DEL29 DEL42 DEL43 DEL74 DEL42 DEL31 DEL55
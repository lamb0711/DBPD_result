JCR-2089: Use java.util.concurrent

Drop the use of concurrent.jar classes in DefaultISMLocking. Instead of using java.util.concurrent, I've simply implemented the required logic using just normal Java synchronization.

This commit notably streamlines the DefaultISMLocking code paths to reduce lock contention issues with heavily concurrent work loads.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@995411 13f79535-47bb-0310-9956-ffa450edef68

-import EDU.oswego.cs.dl.util.concurrent.ReadWriteLock;
-import EDU.oswego.cs.dl.util.concurrent.ReentrantWriterPreferenceReadWriteLock;
-import EDU.oswego.cs.dl.util.concurrent.Sync;
-
- * <code>DefaultISMLocking</code> implements the default locking strategy using
- * coarse grained locking on an ItemStateManager wide read-write lock. E.g.
- * while a write lock is held, no read lock can be acquired.
+ * Default item state locking strategy. The default strategy is simply to use
+ * a single coarse-grained read-write lock over the entire workspace.
-     * The internal read-write lock.
-	 * Thread concerning ReentrantWriterPreferenceReadWriteLock
+     * The read lock instance used by readers to release the acquired lock.
-    private final ReadWriteLock rwLock = new ReentrantWriterPreferenceReadWriteLock();
-    
-    /**
-     * The internal Xid aware read-write lock.
-     */
-    private final ReadWriteLock xidRwLock = new XidRWLock();
-    
-    /**
-     * {@inheritDoc}
-     */
-    public ReadLock acquireReadLock(ItemId id) throws InterruptedException {
-    	if (TransactionContext.getCurrentXid() == null) {
-            return new ReadLockImpl(rwLock.readLock());
-    	} else {
-            return new ReadLockImpl(xidRwLock.readLock());
-    	}
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public WriteLock acquireWriteLock(ChangeLog changeLog) throws InterruptedException {
-    	if (TransactionContext.getCurrentXid() == null) {
-    		return new WriteLockImpl(rwLock);
-    	} else {
-    		return new WriteLockImpl(xidRwLock);
-    	}
-    }
-
-    private static final class WriteLockImpl implements WriteLock {
-    	
-    	private ReadWriteLock readWriteLock;
-    	
-    	private WriteLockImpl(ReadWriteLock readWriteLock) throws InterruptedException {
-    		this.readWriteLock = readWriteLock;
-    		this.readWriteLock.writeLock().acquire();
-		}
-
-		/**
-		 * {@inheritDoc}
-		 */
-		public void release() {
-		    this.readWriteLock.writeLock().release();
-		}
-
-		/**
-		 * {@inheritDoc}
-		 */
-		public ReadLock downgrade() throws InterruptedException {
-		    ReadLock rLock = new ReadLockImpl(this.readWriteLock.readLock());
-		    release();
-		    return rLock;
-		}
-	}
-
-	private static final class ReadLockImpl implements ReadLock {
-
-        private final Sync readLock;
-
-        private ReadLockImpl(Sync readLock) throws InterruptedException {
-            this.readLock = readLock;
-            this.readLock.acquire();
-        }
-
-        /**
-         * {@inheritDoc}
-         */
+    private final ReadLock readLock = new ReadLock() {
-            readLock.release();
+            releaseReadLock();
+        }
+    };
+
+    /**
+     * The write lock instance used by writers to release or downgrade the
+     * acquired lock.
+     */
+    private final WriteLock writeLock = new WriteLock() {
+        public void release() {
+            releaseWriteLock(false);
+        }
+        public ReadLock downgrade() {
+            releaseWriteLock(true);
+            return readLock;
+        }
+    };
+
+    /**
+     * Number of writer threads waiting. While greater than zero, no new
+     * readers are allowed to proceed.
+     */
+    private int writersWaiting = 0;
+
+    /**
+     * The thread identifier of the current writer, or <code>null</code> if
+     * no write is in progress. A thread with the same identifier (i.e. the
+     * same thread or another thread in the same transaction) can re-acquire
+     * read or write locks without limitation, while all other readers and
+     * writers remain blocked.
+     */
+    private Object writerId = null;
+
+    /**
+     * Number of acquired write locks. All the concurrent write locks are
+     * guaranteed to share the same thread identifier (see {@link #writerId}).
+     */
+    private int writerCount = 0;
+
+    /**
+     * Number of acquired read locks.
+     */
+    private int readerCount = 0;
+
+    /**
+     * Increments the reader count and returns the acquired read lock once
+     * there are no more writers or the current writer shares the thread id
+     * with this reader.
+     */
+    public synchronized ReadLock acquireReadLock(ItemId id)
+            throws InterruptedException {
+        while (writerId != null
+                ? !isSameId(writerId, getCurrentId()) : writersWaiting > 0) {
+            wait();
+        }
+
+        readerCount++;
+        return readLock;
+    }
+
+    /**
+     * Decrements the reader count and notifies all pending threads if the
+     * lock is now available. Used by the {@link #readLock} instance.
+     */
+    private synchronized void releaseReadLock() {
+        readerCount--;
+        if (readerCount == 0 && writerId == null) {
+            notifyAll();
-	/**
-	 * Xid concerning ReentrantWriterPreferenceReadWriteLock
-	 */
-    private static final class XidRWLock extends ReentrantWriterPreferenceReadWriteLock {
+    /**
+     * Increments the writer count, sets the writer identifier and returns
+     * the acquired read lock once there are no other active readers or
+     * writers or the current writer shares the thread id with this writer.
+     */
+    public synchronized WriteLock acquireWriteLock(ChangeLog changeLog)
+            throws InterruptedException {
+        Object currentId = getCurrentId();
-        private Xid activeXid;
-
-        /**
-         * Check if the given Xid comes from the same globalTX
-         * @param otherXid
-         * @return true if same globalTX otherwise false
-         */
-        boolean isSameGlobalTx(Xid otherXid) {
-    	    return (activeXid == otherXid) || Arrays.equals(activeXid.getGlobalTransactionId(), otherXid.getGlobalTransactionId());
-    	}
-
-        /**
-         * Allow reader when there is no active Xid, or current Xid owns
-         * the write lock (reentrant).
-         */
-        protected boolean allowReader() {
-        	Xid currentXid = TransactionContext.getCurrentXid();
-        	return (activeXid == null && waitingWriters_ == 0) || isSameGlobalTx(currentXid);
-        }
-
-        /**
-         * {@inheritDoc}
-         */  
-        protected synchronized boolean startWrite() {
-        	Xid currentXid = TransactionContext.getCurrentXid();
-            if (activeXid != null && isSameGlobalTx(currentXid)) { // already held; re-acquire
-            	++writeHolds_;
-                return true;
-            } else if (writeHolds_ == 0) {
-            	if (activeReaders_ == 0 || (readers_.size() == 1 && readers_.get(currentXid) != null)) {
-            		activeXid = currentXid;
-            		writeHolds_ = 1;
-            		return true;
-            	} else {
-            		return false;
-            	}
-            } else {
-            	return false;
+        writersWaiting++;
+        try {
+            while (writerId != null
+                    ? !isSameId(writerId, currentId) : readerCount > 0) {
+                wait();
+        } finally {
+            writersWaiting--;
-        /**
-         * {@inheritDoc}
-         */
-        protected synchronized Signaller endWrite() {
-            --writeHolds_;
-            if (writeHolds_ > 0) {  // still being held
-            	return null;
-            } else {
-            	activeXid = null;
-                if (waitingReaders_ > 0 && allowReader()) {
-                    return readerLock_;
-                } else if (waitingWriters_ > 0) {
-                    return writerLock_;
-                } else {
-                    return null;
-                }
-            }
+        if (writerCount++ == 0) {
+            writerId = currentId;
-
-        /**
-         * {@inheritDoc}
-         */
-		protected synchronized boolean startRead() {
-			Xid currentXid = TransactionContext.getCurrentXid();
-		    Object c = readers_.get(currentXid);
-		    if (c != null) { // already held -- just increment hold count
-		    	readers_.put(currentXid, new Integer(((Integer)(c)).intValue()+1));
-		    	++activeReaders_;
-		    	return true;
-		    } else if (allowReader()) {
-		    	readers_.put(currentXid, IONE);
-		    	++activeReaders_;
-		    	return true;
-		    } else {
-		    	return false;
-		    }
-		}
-
-        /**
-         * {@inheritDoc}
-         */
-		protected synchronized Signaller endRead() {
-			Xid currentXid = TransactionContext.getCurrentXid();
-		    Object c = readers_.get(currentXid);
-		    if (c == null) {
-		    	throw new IllegalStateException();
-		    }
-		    --activeReaders_;
-		    if (c != IONE) { // more than one hold; decrement count
-		    	int h = ((Integer)(c)).intValue()-1;
-		    	Integer ih = (h == 1)? IONE : new Integer(h);
-		    	readers_.put(currentXid, ih);
-		    	return null;
-		    } else {
-		    	readers_.remove(currentXid);
-		    
-		    	if (writeHolds_ > 0) { // a write lock is still held
-		    		return null;
-		    	} else if (activeReaders_ == 0 && waitingWriters_ > 0) {
-		    		return writerLock_;
-		    	} else  {
-		    		return null;
-		    	}
-		    }
-		}
+        return writeLock;
+
+    /**
+     * Decrements the writer count (and possibly clears the writer identifier)
+     * and notifies all pending threads if the lock is now available. If the
+     * downgrade argument is true, then the reader count is incremented before
+     * notifying any pending threads. Used by the {@link #writeLock} instance.
+     */
+    private synchronized void releaseWriteLock(boolean downgrade) {
+        writerCount--;
+        if (downgrade) {
+            readerCount++;
+        }
+        if (writerCount == 0) {
+            writerId = null;
+            notifyAll();
+        }
+    }
+
+    /**
+     * Returns the current thread identifier. The identifier is either the
+     * current thread instance or the global transaction identifier when
+     * running under a transaction.
+     *
+     * @return current thread identifier
+     */
+    private Object getCurrentId() {
+        Xid xid = TransactionContext.getCurrentXid();
+        if (xid != null) {
+            return xid.getGlobalTransactionId();
+        } else {
+            return Thread.currentThread();
+        }
+    }
+
+    /**
+     * Compares the given thread identifiers for equality.
+     */
+    private boolean isSameId(Object a, Object b) {
+        if (a == b) {
+            return true;
+        } else if (a instanceof byte[] && b instanceof byte[]) {
+            return Arrays.equals((byte[]) a, (byte[]) b);
+        } else {
+            return false;
+        }
+    }
+

INS23 INS23 MOV23 INS23 INS23 INS23 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV29 MOV83 MOV83 MOV43 INS59 INS29 INS83 INS83 MOV43 INS59 INS29 INS39 INS29 INS83 INS43 INS59 INS29 INS83 INS39 INS59 INS29 INS83 INS39 MOV59 INS83 INS83 MOV43 UPD42 MOV44 MOV43 UPD83 INS83 UPD39 UPD42 UPD83 MOV43 UPD42 MOV44 MOV43 UPD83 INS39 INS42 INS44 UPD83 INS43 INS42 INS8 UPD83 INS39 INS42 INS44 INS44 INS8 UPD66 UPD66 UPD42 MOV42 INS14 INS65 INS42 INS14 INS65 UPD42 INS34 INS65 UPD42 MOV42 INS42 INS33 MOV65 INS42 INS34 MOV65 UPD42 INS34 INS65 INS61 INS21 INS41 INS21 INS25 INS65 INS21 INS54 MOV25 MOV41 INS39 INS42 INS25 INS65 INS65 UPD42 MOV42 MOV60 MOV25 INS65 MOV43 INS42 MOV43 INS42 MOV25 UPD66 MOV43 INS1 INS66 INS66 INS43 INS1 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 UPD65 INS66 UPD66 UPD66 MOV66 UPD66 MOV66 INS66 INS16 INS8 INS37 INS42 UPD66 UPD66 INS65 INS66 INS37 INS27 INS8 INS66 INS66 INS66 UPD43 INS37 INS8 INS8 INS27 INS42 INS66 INS66 INS66 INS66 UPD65 INS66 INS37 INS42 INS8 UPD27 INS66 INS66 INS66 INS66 MOV8 INS66 UPD27 MOV8 INS31 UPD42 MOV42 INS31 INS31 INS67 INS27 INS38 INS27 INS21 INS42 INS67 INS42 MOV27 MOV27 INS21 UPD42 UPD42 INS42 INS61 INS21 INS37 MOV34 INS67 INS42 INS21 UPD42 INS21 UPD42 UPD42 INS41 INS41 UPD42 INS42 MOV8 MOV83 INS39 INS42 INS8 MOV83 MOV39 MOV42 MOV8 MOV83 MOV43 MOV42 MOV8 INS42 UPD42 MOV42 INS33 INS32 INS42 INS34 INS32 INS42 UPD42 INS34 UPD42 INS33 INS32 UPD42 INS16 INS8 INS37 INS42 INS42 INS37 INS32 INS32 INS32 INS62 INS62 INS21 UPD42 MOV42 UPD42 MOV42 MOV32 UPD42 MOV42 UPD42 MOV42 INS27 INS38 INS27 INS21 INS42 UPD42 UPD42 INS42 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS5 INS42 INS5 INS32 INS32 INS32 UPD42 UPD42 UPD42 MOV42 MOV33 INS32 UPD42 MOV42 MOV34 INS32 INS39 INS85 INS39 INS85 INS42 INS42 INS11 INS11 UPD42 MOV42 INS42 INS9 UPD42 INS9 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS5 INS42 INS5 INS42 INS39 INS85 INS39 INS85 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL66 DEL66 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL43 DEL52 DEL42 DEL22 DEL42 DEL32 DEL14 DEL59 DEL60 DEL83 DEL42 DEL43 DEL65 DEL42 DEL65 DEL65 DEL39 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL27 DEL36 DEL42 DEL32 DEL32 DEL27 DEL41 DEL33 DEL34 DEL27 DEL36 DEL42 DEL32 DEL27 DEL41 DEL65 DEL65 DEL39 DEL42 DEL42 DEL27 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL42 DEL42 DEL32 DEL33 DEL27 DEL27 DEL36 DEL27 DEL42 DEL34 DEL7 DEL21 DEL9 DEL41 DEL9 DEL27 DEL32 DEL27 DEL27 DEL8 DEL8 DEL25 DEL25 DEL42 DEL43 DEL42 DEL42 DEL38 DEL33 DEL41 DEL8 DEL42 DEL34 DEL27 DEL32 DEL27 DEL42 DEL41 DEL8 DEL42 DEL34 DEL27 DEL42 DEL41 DEL8 DEL33 DEL41 DEL8 DEL25 DEL25 DEL65 DEL65 DEL42 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL36 DEL11 DEL36 DEL42 DEL32 DEL34 DEL27 DEL14 DEL32 DEL21 DEL42 DEL38 DEL21 DEL9 DEL41 DEL42 DEL42 DEL32 DEL21 DEL42 DEL38 DEL21 DEL9 DEL41 DEL42 DEL32 DEL9 DEL41 DEL8 DEL25 DEL83 DEL39 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL65 DEL65 DEL34 DEL42 DEL38 DEL21 DEL33 DEL41 DEL8 DEL42 DEL34 DEL27 DEL42 DEL34 DEL27 DEL42 DEL33 DEL41 DEL8 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL43 DEL14 DEL53 DEL8 DEL25 DEL42 DEL38 DEL21 DEL42 DEL42 DEL27 DEL39 DEL42 DEL42 DEL43 DEL42 DEL36 DEL11 DEL36 DEL42 DEL32 DEL34 DEL27 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL34 DEL27 DEL36 DEL42 DEL42 DEL43 DEL42 DEL14 DEL16 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL33 DEL41 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL43 DEL14 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL23 DEL65 DEL65 DEL29 DEL42 DEL42 DEL42 DEL32 DEL33 DEL27 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL41 DEL8 DEL42 DEL43 DEL42 DEL32 DEL14 DEL41 DEL8 DEL25 DEL8 DEL31 DEL65 DEL65 DEL29 DEL83 DEL42 DEL42 DEL42 DEL32 DEL33 DEL27 DEL42 DEL43 DEL42 DEL14 DEL41 DEL8 DEL42 DEL43 DEL42 DEL14 DEL41 DEL8 DEL25 DEL8 DEL31 DEL83 DEL83 DEL83 DEL42 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL31 DEL65 DEL65 DEL29 DEL31 DEL65 DEL65 DEL29 DEL42 DEL43 DEL31 DEL55 DEL83 DEL83 DEL83 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL8 DEL31 DEL29 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL55 DEL29 DEL83 DEL83 DEL83 DEL42 DEL42 DEL43 DEL83 DEL42 DEL43 DEL23 DEL55
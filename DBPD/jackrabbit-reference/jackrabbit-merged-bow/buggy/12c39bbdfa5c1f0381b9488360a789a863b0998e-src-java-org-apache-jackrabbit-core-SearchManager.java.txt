Redesigned query manager to support pluggable implementation for search index.

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@124906 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.fs.FileSystemResource;
-import org.apache.jackrabbit.core.search.NamespaceMappings;
-import org.apache.jackrabbit.core.search.OrderQueryNode;
-import org.apache.jackrabbit.core.search.QueryRootNode;
-import org.apache.jackrabbit.core.search.lucene.*;
+import org.apache.jackrabbit.core.search.QueryHandler;
-import org.apache.jackrabbit.core.state.ItemStateProvider;
-import org.apache.lucene.analysis.standard.StandardAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.Hits;
-import org.apache.lucene.search.Query;
+import javax.jcr.ItemNotFoundException;
+import javax.jcr.query.InvalidQueryException;
+import javax.jcr.query.Query;
-    /** Name of the file to persist search internal namespace mappings */
-    private static final String NS_MAPPING_FILE = "ns_mappings.properties";
-
-    /** The actual search index */
-    private final SearchIndex index;
-
-    /** State manager to retrieve content */
-    private final ItemStateProvider stateProvider;
-
-    /** Namespace resolver for search internal prefixes */
-    private final NamespaceMappings nsMappings;
+    /** QueryHandler where query execution is delegated to */
+    private final QueryHandler handler;
-            throws RepositoryException, IOException {
+            throws RepositoryException {
-        this.stateProvider = session.getItemStateManager();
-        index = new SearchIndex(fs, new StandardAnalyzer());
-        FileSystemResource mapFile = new FileSystemResource(fs, NS_MAPPING_FILE);
-        nsMappings = new NamespaceMappings(mapFile);
+        // initialize query handler
+        try {
+            Class handlerClass = Class.forName(config.getHandlerClassName());
+            handler = (QueryHandler) handlerClass.newInstance();
+            handler.init(fs, session.getItemStateManager());
+        } catch (Exception e) {
+            throw new RepositoryException(e.getMessage(), e);
+        }
+
-        BeanMap bm = new BeanMap(this);
+        BeanMap bm = new BeanMap(handler);
-     * @throws IOException if an error occurs while adding the node to
-     * the search index.
+     * @throws RepositoryException if an error occurs while indexing the node.
+     * @throws IOException if an error occurs while adding the node to the index.
-    public void addNode(NodeState node, Path path) throws IOException {
+    public void addNode(NodeState node, Path path)
+            throws RepositoryException, IOException {
-        Document doc = NodeIndexer.createDocument(node, stateProvider, path, nsMappings);
-        index.addDocument(doc);
+        handler.addNode(node);
-        index.removeDocument(new Term(FieldNames.UUID, uuid));
+        handler.deleteNode(uuid);
-     * {@link org.apache.jackrabbit.core.fs.FileSystem} passed in the
-     * constructor of this <code>SearchManager</code>.
+     * {@link org.apache.jackrabbit.core.fs.FileSystem} configured in
+     * {@link org.apache.jackrabbit.core.config.SearchConfig}.
-        index.close();
+            handler.close();
+        } catch (IOException e) {
+            log.error("Exception closing QueryHandler.", e);
-    public QueryResultImpl execute(ItemManager itemMgr,
-                                   QueryRootNode root,
-                                   SessionImpl session)
-            throws RepositoryException {
-
-        // build lucene query
-        Query query = LuceneQueryBuilder.createQuery(root,
-                session, nsMappings, index.getAnalyzer());
-
-        OrderQueryNode orderNode = root.getOrderNode();
-        // FIXME according to spec this should be descending
-        // by default. this contrasts to standard sql semantics
-        // where default is ascending.
-        boolean[] orderSpecs = null;
-        String[] orderProperties = null;
-        if (orderNode != null) {
-            orderProperties = orderNode.getOrderByProperties();
-            orderSpecs = orderNode.getOrderBySpecs();
-        } else {
-            orderProperties = new String[0];
-            orderSpecs = new boolean[0];
-        }
-
-
-        List uuids;
-        AccessManagerImpl accessMgr = session.getAccessManager();
-
-        // execute it
-        try {
-            Hits result = index.executeQuery(query, orderProperties, orderSpecs);
-            uuids = new ArrayList(result.length());
-            for (int i = 0; i < result.length(); i++) {
-                String uuid = result.doc(i).get(FieldNames.UUID);
-                // check access
-                if (accessMgr.isGranted(new NodeId(uuid), AccessManager.READ)) {
-                    uuids.add(uuid);
-                }
-            }
-        } catch (IOException e) {
-            uuids = Collections.EMPTY_LIST;
-        }
-
-        // return QueryResult
-        return new QueryResultImpl(itemMgr,
-                (String[]) uuids.toArray(new String[uuids.size()]),
-                root.getSelectProperties());
+    /**
+     * Creates a query object that can be executed on the workspace.
+     *
+     * @param session the session of the user executing the query.
+     * @param itemMgr the item manager of the user executing the query. Needed
+     *   to return <code>Node</code> instances in the result set.
+     * @param statement the actual query statement.
+     * @param language the syntax of the query statement.
+     * @return a <code>Query</code> instance to execute.
+     *
+     * @throws InvalidQueryException if the query is malformed or the
+     *   <code>language</code> is unknown.
+     * @throws RepositoryException if any other error occurs.
+     */
+    public Query createQuery(SessionImpl session,
+                             ItemManager itemMgr,
+                             String statement,
+                             String language)
+            throws InvalidQueryException, RepositoryException {
+        return handler.createQuery(session, itemMgr, statement, language);
+    }
+    
+    /**
+     * Creates a query object from a node that can be executed on the workspace.
+     *
+     * @param session the session of the user executing the query.
+     * @param itemMgr the item manager of the user executing the query. Needed
+     *   to return <code>Node</code> instances in the result set.
+     * @param absPath absolute path to a node of type nt:query.
+     * @return a <code>Query</code> instance to execute.
+     *
+     * @throws InvalidQueryException if <code>absPath</code> is not a valid
+     *   persisted query (that is, a node of type nt:query)
+     * @throws ItemNotFoundException if there is no node at <code>absPath</code>.
+     * @throws RepositoryException if any other error occurs.
+     */
+    public Query createQuery(SessionImpl session,
+                             ItemManager itemMgr,
+                             String absPath)
+            throws InvalidQueryException, ItemNotFoundException, RepositoryException {
+        return handler.createQuery(session, itemMgr, absPath);
+                    // @todo use UUIDs for pending nodes?
-                path = getIndexlessPath(path);
-                addNode((NodeState) stateProvider.getItemState(id), path);
+                addNode((NodeState) session.getItemStateManager().getItemState(id), path);
-    //---------------------< properties >---------------------------------------
-
-    public void setUseCompoundFile(boolean b) {
-        index.setUseCompoundFile(b);
-    }
-
-    public void setMinMergeDocs(int minMergeDocs) {
-        index.setMinMergeDocs(minMergeDocs);
-    }
-
-    public void setMaxMergeDocs(int maxMergeDocs) {
-        index.setMaxMergeDocs(maxMergeDocs);
-    }
-
-    public void setMergeFactor(int mergeFactor) {
-        index.setMergeFactor(mergeFactor);
-    }
-
-    //-----------------------< internal >---------------------------------------
-
-    /**
-     * Returns a <code>Path</code>, which contains the same sequence of path
-     * elements as <code>p</code>, but has cut off any existing indexes on the
-     * path elements.
-     *
-     * @param p the source path, possibly containing indexed path elements.
-     * @return a <code>Path</code> without indexed path elements.
-     */
-    private Path getIndexlessPath(Path p) {
-        boolean hasIndexes = false;
-        Path.PathElement[] elements = p.getElements();
-        for (int i = 0; i < elements.length && !hasIndexes; i++) {
-            hasIndexes = (elements[i].getIndex() > 0);
-        }
-
-        if (hasIndexes) {
-            // create Path without indexes
-            Path.PathBuilder builder = new Path.PathBuilder();
-            builder.addRoot();
-            for (int i = 1; i < elements.length; i++) {
-                builder.addLast(elements[i].getName());
-            }
-            try {
-                return builder.getPath();
-            } catch (MalformedPathException e) {
-                // will never happen, because Path p is always valid
-                log.error("internal error: malformed path.", e);
-            }
-        }
-        // return original path if it does not contain indexed path elements
-        return p;
-    }

MOV26 MOV26 MOV26 MOV23 MOV31 UPD40 UPD40 UPD40 UPD40 INS31 UPD43 INS43 INS29 MOV83 MOV43 INS42 MOV44 MOV44 INS44 INS44 INS43 MOV43 MOV8 UPD83 UPD43 UPD42 INS44 INS44 INS43 INS43 INS43 INS8 UPD42 UPD42 INS54 INS65 INS42 MOV65 INS65 INS65 INS65 INS65 UPD65 MOV65 INS65 INS65 MOV43 INS42 MOV43 INS42 UPD42 MOV42 INS41 INS65 INS65 UPD65 INS65 INS65 INS65 UPD42 UPD43 UPD42 INS43 INS42 MOV43 INS42 INS42 INS42 INS42 INS41 UPD66 INS8 INS12 MOV43 INS42 INS66 UPD66 UPD66 INS65 UPD66 INS12 UPD66 INS42 INS66 INS42 UPD66 MOV66 INS66 INS42 INS66 INS42 INS66 UPD66 INS42 INS66 INS66 INS42 INS66 INS32 INS66 INS42 INS66 INS42 UPD66 UPD66 UPD42 UPD66 UPD66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 UPD42 INS42 INS32 INS60 MOV21 INS21 INS44 INS8 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS40 INS21 MOV44 INS8 UPD42 MOV42 MOV42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 INS43 INS59 INS32 INS43 INS42 INS53 MOV43 INS42 INS32 INS21 INS42 INS42 INS32 UPD42 INS11 INS42 INS42 INS42 INS32 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS32 INS43 INS32 INS42 INS42 UPD43 MOV43 INS32 INS42 INS42 INS42 INS45 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 UPD42 INS42 INS42 MOV32 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL45 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL42 DEL43 DEL52 DEL42 DEL22 DEL7 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL14 DEL7 DEL21 DEL43 DEL42 DEL42 DEL43 DEL14 DEL14 DEL52 DEL66 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL40 DEL42 DEL14 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL85 DEL5 DEL42 DEL33 DEL59 DEL60 DEL85 DEL5 DEL42 DEL33 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL85 DEL5 DEL34 DEL3 DEL7 DEL21 DEL42 DEL39 DEL85 DEL5 DEL34 DEL3 DEL7 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL7 DEL21 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL40 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL43 DEL42 DEL14 DEL40 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL24 DEL8 DEL42 DEL40 DEL7 DEL21 DEL8 DEL12 DEL54 DEL42 DEL43 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL32 DEL3 DEL32 DEL11 DEL42 DEL42 DEL32 DEL14 DEL41 DEL42 DEL43 DEL42 DEL43 DEL42 DEL44 DEL31 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL66 DEL39 DEL42 DEL9 DEL59 DEL60 DEL40 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL38 DEL27 DEL42 DEL37 DEL42 DEL42 DEL42 DEL2 DEL42 DEL32 DEL34 DEL27 DEL36 DEL7 DEL21 DEL8 DEL24 DEL42 DEL40 DEL43 DEL42 DEL40 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL32 DEL32 DEL21 DEL8 DEL24 DEL42 DEL42 DEL32 DEL41 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL25 DEL42 DEL41 DEL8 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42
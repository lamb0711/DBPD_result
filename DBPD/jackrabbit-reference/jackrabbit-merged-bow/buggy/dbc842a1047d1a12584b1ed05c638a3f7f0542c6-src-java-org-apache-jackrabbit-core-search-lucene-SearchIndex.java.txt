Speed up indexing using a volatile index with redo log.

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@156632 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.state.NoSuchItemStateException;
+import org.apache.lucene.index.MultiReader;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.search.IndexSearcher;
+    /** The logger instance for this class */
+    /** Default name of the redo log file */
+    private static final String REDO_LOG = "redo.log";
+
-     * 512k default size
+     * Default merge size: 1000
-    //private static final long DEFAULT_MERGE_SIZE = 512 * 1024;
+    private static final long DEFAULT_MERGE_SIZE = 1000;
-    //private long mergeSize = DEFAULT_MERGE_SIZE;
+    /**
+     * The maximum number of entries in the redo log until the volatile index
+     * is merged into the persistent one.
+     */
+    private long mergeSize = DEFAULT_MERGE_SIZE;
+    /**
+     * The persistent index.
+     */
-    //private VolatileIndex volatileIndex;
+    /**
+     * The in-memory index.
+     */
+    private VolatileIndex volatileIndex;
+    /**
+     * The analyzer we use for indexing.
+     */
+    /**
+     * Internal namespace mappings.
+     */
+    /**
+     * Read-write lock to synchronize access on the index.
+     */
-        //volatileIndex = new VolatileIndex(analyzer);
+
+            // init volatile index
+            RedoLog redoLog = new RedoLog(new FileSystemResource(getFileSystem(), REDO_LOG));
+            if (redoLog.hasEntries()) {
+                log.warn("Found uncommitted redo log. Applying changes now...");
+                ItemStateManager itemMgr = getItemStateProvider();
+                // apply changes to persistent index
+                Iterator it = redoLog.getEntries().iterator();
+                while (it.hasNext()) {
+                    RedoLog.Entry entry = (RedoLog.Entry) it.next();
+                    if (entry.type == RedoLog.Entry.NODE_ADDED) {
+                        try {
+                            NodeState state = (NodeState) itemMgr.getItemState(new NodeId(entry.uuid));
+                            addNodePersistent(state);
+                        } catch (NoSuchItemStateException e) {
+                            // item does not exist anymore
+                        }
+                    } else {
+                        deleteNodePersistent(entry.uuid);
+                    }
+                }
+                log.warn("Redo changes applied.");
+                redoLog.clear();
+            }
+            volatileIndex = new VolatileIndex(analyzer, redoLog);
+            volatileIndex.setUseCompoundFile(false);
-            // FIXME: ??? do logging, simply return?
-            return;
+            throw new RepositoryException("Failed to aquire write lock.");
-            persistentIndex.addDocument(doc);
+            volatileIndex.addDocument(doc);
+            if (volatileIndex.getRedoLog().getSize() > mergeSize) {
+                log.info("Merging in-memory index");
+                persistentIndex.mergeIndex(volatileIndex);
+                // reset redo log
+                try {
+                    volatileIndex.getRedoLog().clear();
+                } catch (FileSystemException e) {
+                    log.error("Internal error: Unable to clear redo log.", e);
+                }
+                // create new volatile index
+                volatileIndex = new VolatileIndex(analyzer, volatileIndex.getRedoLog());
+                volatileIndex.setUseCompoundFile(false);
+            }
-
-        /*
-        volatileIndex.addDocument(doc);
-        if (volatileIndex.size() > mergeSize) {
-            persistentIndex.mergeIndex(volatileIndex);
-            // create new volatile index
-            volatileIndex = new VolatileIndex(analyzer);
-        }
-        */
-            // FIXME: ??? do logging, simply return?
-            return;
+            throw new IOException("Failed to aquire write lock.");
-            persistentIndex.removeDocument(idTerm);
+            // if the document cannot be deleted from the volatile index
+            // delete it from the persistent index.
+            if (volatileIndex.removeDocument(idTerm) == 0) {
+                persistentIndex.removeDocument(idTerm);
+            }
-        //volatileIndex.removeDocument(idTerm);
-        /*
+        log.info("Closing search index.");
-            persistentIndex.mergeIndex(volatileIndex);
+            if (volatileIndex.getRedoLog().hasEntries()) {
+                persistentIndex.mergeIndex(volatileIndex);
+                volatileIndex.getRedoLog().clear();
+            }
-            // FIXME do logging
+            log.error("Exception while closing search index.", e);
+        } catch (FileSystemException e) {
+            log.error("Exception while closing search index.", e);
-        */
-        log.info("Closing search index.");
+            MultiReader multiReader = new MultiReader(new IndexReader[]{ persistentIndex.getIndexReader(), volatileIndex.getIndexReader()});
-                hits = persistentIndex.getIndexSearcher().search(query,
-                        new Sort(sortFields));
+                hits = new IndexSearcher(multiReader).search(query, new Sort(sortFields));
-                hits = persistentIndex.getIndexSearcher().search(query);
+                hits = new IndexSearcher(multiReader).search(query);
-        addNode(node);
+        addNodePersistent(node);
+    /**
+     * Adds a node to the persistent index. This method will <b>not</b> aquire a
+     * write lock while writing!
+     * @param node the node to add.
+     * @throws IOException if an error occurs while writing to the index.
+     * @throws RepositoryException if any other error occurs
+     */
+    private void addNodePersistent(NodeState node)
+            throws IOException, RepositoryException {
+        Document doc = NodeIndexer.createDocument(node, getItemStateProvider(), nsMappings);
+        persistentIndex.addDocument(doc);
+    }
+
+    /**
+     * Removes a node from the persistent index. This method will <b>not</b>
+     * aquire a write lock while writing!
+     * @param uuid the uuid of the node to remove.
+     * @throws IOException if an error occurs while writing to the index.
+     */
+    private void deleteNodePersistent(String uuid) throws IOException {
+        Term idTerm = new Term(FieldNames.UUID, uuid);
+        persistentIndex.removeDocument(idTerm);
+    }
+
+
+    public void setRedoSize(int size) {
+        mergeSize = size;
+    }

INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS29 INS29 INS83 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS83 INS39 INS59 INS29 INS83 INS39 INS59 INS29 INS83 INS43 INS59 INS29 INS29 INS29 INS8 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS43 MOV8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS8 INS65 INS65 INS42 INS42 INS45 INS65 INS42 INS34 INS65 INS42 INS42 INS65 INS42 INS42 INS65 INS65 INS65 INS60 MOV54 INS54 MOV54 MOV21 INS54 INS21 MOV21 INS65 INS65 INS65 INS65 INS43 INS42 INS42 INS42 MOV21 INS65 INS65 INS65 INS43 INS42 INS42 INS60 INS21 INS39 INS42 INS21 INS66 INS66 INS66 INS66 INS66 UPD66 INS66 INS66 INS66 INS66 INS43 INS59 INS8 MOV8 INS8 INS8 INS12 INS12 INS32 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS43 INS59 INS32 INS7 INS60 INS25 INS21 INS21 INS42 INS42 INS32 INS21 INS25 INS25 INS25 INS44 INS8 INS44 INS8 INS42 INS42 INS60 UPD42 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS8 INS7 INS32 INS42 INS42 INS42 INS32 INS42 INS53 INS32 INS27 INS8 INS53 INS27 MOV8 INS32 INS8 INS43 INS42 INS21 INS43 INS42 INS21 INS43 INS59 INS43 INS40 INS42 INS42 INS42 INS14 INS42 INS42 INS21 INS60 INS60 INS61 INS21 INS21 INS42 INS14 INS42 INS42 INS9 INS42 INS14 INS42 INS42 INS42 INS32 INS42 INS21 INS21 INS54 INS21 INS21 INS14 INS32 INS34 INS32 INS42 INS21 INS21 INS42 INS32 INS42 INS32 INS42 INS42 INS14 INS42 INS43 INS14 INS32 INS43 INS59 INS43 INS59 INS32 INS8 INS32 INS32 INS43 INS42 INS42 INS43 INS45 INS32 INS42 INS32 INS32 INS8 INS12 INS7 INS32 INS43 INS45 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS42 INS43 INS3 INS42 INS43 INS32 INS42 INS42 INS42 INS45 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS60 INS25 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS21 INS44 INS8 INS42 INS14 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS5 INS4 INS42 INS42 INS42 INS32 INS42 INS43 INS59 INS27 INS8 INS8 INS32 INS43 INS42 INS21 INS43 INS42 INS32 INS42 INS42 INS43 INS85 INS32 INS32 INS14 INS14 INS42 INS42 INS40 INS42 INS11 INS40 INS40 INS54 INS21 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS43 INS42 INS43 INS32 INS8 INS12 INS32 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS40 INS42 INS42 INS60 INS21 INS44 INS8 INS42 INS40 INS43 INS59 INS32 INS43 INS42 INS42 INS42 INS11 INS42 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS14 INS43 INS40 INS42 DEL41 DEL41 DEL8 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL8 DEL54
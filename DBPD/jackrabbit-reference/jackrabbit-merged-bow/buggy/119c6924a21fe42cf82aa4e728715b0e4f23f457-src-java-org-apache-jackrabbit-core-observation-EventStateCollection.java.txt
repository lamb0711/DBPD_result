JCR-131: simplifying internal data model (NodeState) by limiting a node to *one* parent



git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@191499 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.nodetype.NodeTypeImpl;
-import org.apache.jackrabbit.core.SessionImpl;
-import org.apache.jackrabbit.core.Path;
-import org.apache.jackrabbit.core.NodeId;
-import org.apache.jackrabbit.core.MalformedPathException;
-import org.apache.jackrabbit.core.QName;
+import org.apache.jackrabbit.core.MalformedPathException;
+import org.apache.jackrabbit.core.NodeId;
+import org.apache.jackrabbit.core.Path;
+import org.apache.jackrabbit.core.QName;
+import org.apache.jackrabbit.core.SessionImpl;
+import org.apache.jackrabbit.core.nodetype.NodeTypeImpl;
+import org.apache.jackrabbit.core.state.ItemState;
-import org.apache.jackrabbit.core.state.ItemState;
-import org.apache.jackrabbit.core.state.NodeState;
+import org.apache.jackrabbit.core.state.NodeState;
-import javax.jcr.RepositoryException;
-import javax.jcr.nodetype.NoSuchNodeTypeException;
+import javax.jcr.RepositoryException;
+import java.util.Collection;
-import java.util.Arrays;
-import java.util.Collection;
+     *
-     * @param changes the changes on <code>ItemState</code>s.
-     * @param provider an <code>ItemStateProvider</code> to provide <code>ItemState</code>
-     * of items that are not contained in the <code>changes</code> collection.
+     * @param changes      the changes on <code>ItemState</code>s.
+     * @param provider     an <code>ItemStateProvider</code> to provide <code>ItemState</code>
+     *                     of items that are not contained in the <code>changes</code> collection.
-     * states for the item state changes.
+     *                            states for the item state changes.
-        HierarchyManager hmgr = new ChangeLogBasedHierarchyMgr(rootNodeUUID, provider, changes, session.getNamespaceResolver());
+        ChangeLogBasedHierarchyMgr hmgr =
+                new ChangeLogBasedHierarchyMgr(rootNodeUUID, provider, changes,
+                        session.getNamespaceResolver());
-                if (n.getAddedParentUUIDs().size() > 0 && n.getRemovedParentUUIDs().size() > 0) {
-                    // node moved
-                    // generate node removed & node added event
-                    String oldParentUUID = (String) n.getRemovedParentUUIDs().get(0);
-                    NodeState oldParent;
-                    try {
-                        oldParent = (NodeState) changes.get(new NodeId(oldParentUUID));
-                    } catch (NoSuchItemStateException e) {
-                        // old parent has been deleted, retrieve from
-                        // shared item state manager
-                        oldParent = (NodeState) provider.getItemState(new NodeId(oldParentUUID));
-                    }
-                    NodeTypeImpl oldParentNodeType = getNodeType(oldParent, session);
-                    Path newPath = getPath(n.getId(), hmgr);
-                    Path[] allPaths = getAllPaths(n.getId(), hmgr);
-                    List paths = new ArrayList(Arrays.asList(allPaths));
-                    paths.remove(newPath);
-                    if (paths.size() > 0) {
-                        Path removedPath = (Path) paths.get(0);
-                        events.add(EventState.childNodeRemoved(oldParentUUID,
-                                getParent(removedPath),
-                                n.getUUID(),
-                                removedPath.getNameElement(),
-                                oldParentNodeType,
-                                session));
+                if (n.hasOverlayedState()) {
+                    String oldParentUUID = n.getOverlayedState().getParentUUID();
+                    String newParentUUID = n.getParentUUID();
+                    if (newParentUUID != null &&
+                            !oldParentUUID.equals(newParentUUID)) {
+                        // node moved
+                        // generate node removed & node added event
+                        NodeState oldParent;
+                        try {
+                            oldParent = (NodeState) changes.get(new NodeId(oldParentUUID));
+                        } catch (NoSuchItemStateException e) {
+                            // old parent has been deleted, retrieve from
+                            // shared item state manager
+                            oldParent = (NodeState) provider.getItemState(new NodeId(oldParentUUID));
+                        }
-                        String newParentUUID = (String) n.getAddedParentUUIDs().get(0);
-                        NodeState newParent = (NodeState) changes.get(new NodeId(newParentUUID));
-                        NodeTypeImpl newParentNodeType = getNodeType(newParent, session);
-                        events.add(EventState.childNodeAdded(newParentUUID,
-                                getParent(newPath),
-                                n.getUUID(),
-                                newPath.getNameElement(),
-                                newParentNodeType,
-                                session));
-                    } else {
-                        log.error("Unable to calculate old path of moved node");
-                    }
-                } else {
-                    // a moved node always has a modified parent node
-                    NodeState parent = null;
-                    try {
-                        // root node does not have a parent UUID
-                        if (state.getParentUUID() != null) {
-                            parent = (NodeState) changes.get(new NodeId(state.getParentUUID()));
-                        }
-                    } catch (NoSuchItemStateException e) {
-                        // should never happen actually. this would mean
-                        // the parent of this modified node is deleted
-                        String msg = "Parent of node " + state.getId() + " is deleted.";
-                        log.error(msg);
-                        throw new ItemStateException(msg, e);
-                    }
-                    if (parent != null) {
-                        // check if node has been renamed
-                        NodeState.ChildNodeEntry moved = null;
-                        for (Iterator removedNodes = parent.getRemovedChildNodeEntries().iterator(); removedNodes.hasNext();) {
-                            NodeState.ChildNodeEntry child = (NodeState.ChildNodeEntry) removedNodes.next();
-                            if (child.getUUID().equals(n.getUUID())) {
-                                // found node re-added with different name
-                                moved = child;
-                            }
-                        }
-                        if (moved != null) {
-                            NodeTypeImpl nodeType = getNodeType(parent, session);
-                            Path newPath = getPath(state.getId(), hmgr);
-                            Path parentPath = getParent(newPath);
-                            Path oldPath;
-                            try {
-                                if (moved.getIndex() == 0) {
-                                    oldPath = Path.create(parentPath, moved.getName(), false);
-                                } else {
-                                    oldPath = Path.create(parentPath, moved.getName(), moved.getIndex(), false);
-                                }
-                            } catch (MalformedPathException e) {
-                                // should never happen actually
-                                String msg = "Malformed path for item: " + state.getId();
-                                log.error(msg);
-                                throw new ItemStateException(msg, e);
-                            }
-                            events.add(EventState.childNodeRemoved(parent.getUUID(),
-                                    parentPath,
+                        NodeTypeImpl oldParentNodeType = getNodeType(oldParent, session);
+                        Path newPath = getPath(n.getId(), hmgr);
+                        Path oldPath = getZombiePath(n.getId(), hmgr);
+                        if (!oldPath.equals(newPath)) {
+                            events.add(EventState.childNodeRemoved(oldParentUUID,
+                                    getParent(oldPath),
-                                    nodeType,
+                                    oldParentNodeType,
-                            events.add(EventState.childNodeAdded(parent.getUUID(),
-                                    parentPath,
+
+                            NodeState newParent = (NodeState) changes.get(new NodeId(newParentUUID));
+                            NodeTypeImpl newParentNodeType = getNodeType(newParent, session);
+                            events.add(EventState.childNodeAdded(newParentUUID,
+                                    getParent(newPath),
-                                    nodeType,
+                                    newParentNodeType,
+                        } else {
+                            log.error("Unable to calculate old path of moved node");
+                        }
+                    } else {
+                        // a moved node always has a modified parent node
+                        NodeState parent = null;
+                        try {
+                            // root node does not have a parent UUID
+                            if (state.getParentUUID() != null) {
+                                parent = (NodeState) changes.get(new NodeId(state.getParentUUID()));
+                            }
+                        } catch (NoSuchItemStateException e) {
+                            // should never happen actually. this would mean
+                            // the parent of this modified node is deleted
+                            String msg = "Parent of node " + state.getId() + " is deleted.";
+                            log.error(msg);
+                            throw new ItemStateException(msg, e);
+                        }
+                        if (parent != null) {
+                            // check if node has been renamed
+                            NodeState.ChildNodeEntry moved = null;
+                            for (Iterator removedNodes = parent.getRemovedChildNodeEntries().iterator(); removedNodes.hasNext();) {
+                                NodeState.ChildNodeEntry child = (NodeState.ChildNodeEntry) removedNodes.next();
+                                if (child.getUUID().equals(n.getUUID())) {
+                                    // found node re-added with different name
+                                    moved = child;
+                                }
+                            }
+                            if (moved != null) {
+                                NodeTypeImpl nodeType = getNodeType(parent, session);
+                                Path newPath = getPath(state.getId(), hmgr);
+                                Path parentPath = getParent(newPath);
+                                Path oldPath;
+                                try {
+                                    if (moved.getIndex() == 0) {
+                                        oldPath = Path.create(parentPath, moved.getName(), false);
+                                    } else {
+                                        oldPath = Path.create(parentPath, moved.getName(), moved.getIndex(), false);
+                                    }
+                                } catch (MalformedPathException e) {
+                                    // should never happen actually
+                                    String msg = "Malformed path for item: " + state.getId();
+                                    log.error(msg);
+                                    throw new ItemStateException(msg, e);
+                                }
+                                events.add(EventState.childNodeRemoved(parent.getUUID(),
+                                        parentPath,
+                                        n.getUUID(),
+                                        oldPath.getNameElement(),
+                                        nodeType,
+                                        session));
+                                events.add(EventState.childNodeAdded(parent.getUUID(),
+                                        parentPath,
+                                        n.getUUID(),
+                                        newPath.getNameElement(),
+                                        nodeType,
+                                        session));
+                            }
+
-                        List removedChild = overlayed.getChildNodeEntries(child.getUUID());
-                        if (removedChild.size() == 0) {
+                        NodeState.ChildNodeEntry entry = overlayed.getChildNodeEntry(child.getUUID());
+                        if (entry == null) {
-                        NodeState.ChildNodeEntry entry = (NodeState.ChildNodeEntry) removedChild.get(0);
-                Path[] paths = getAllPaths(state.getId(), hmgr);
-                for (int i = 0; i < paths.length; i++) {
-                    events.add(EventState.childNodeRemoved(n.getParentUUID(),
-                            getParent(paths[i]),
-                            n.getUUID(),
-                            paths[i].getNameElement(),
-                            nodeType,
-                            session));
-                }
+                Path path = getZombiePath(state.getId(), hmgr);
+                events.add(EventState.childNodeRemoved(n.getParentUUID(),
+                        getParent(path),
+                        n.getUUID(),
+                        path.getNameElement(),
+                        nodeType,
+                        session));
-                    Path[] paths = getAllPaths(state.getId(), hmgr);
-                    for (int i = 0; i < paths.length; i++) {
-                        events.add(EventState.propertyRemoved(state.getParentUUID(),
-                                getParent(paths[i]),
-                                paths[i].getNameElement(),
-                                nodeType,
-                                session));
-                    }
+                    Path path = getZombiePath(state.getId(), hmgr);
+                    events.add(EventState.propertyRemoved(state.getParentUUID(),
+                            getParent(path),
+                            path.getNameElement(),
+                            nodeType,
+                            session));
-                    // also node removed -> do not create an event
+                    // node removed as well -> do not create an event
+     *
-     * @param node the node.
+     *
+     * @param node    the node.
+     *
-     * path. E.g. <code>p</code> designates root.
+     *                            path. E.g. <code>p</code> designates root.
+     *
-     * Resolves all paths of the Item with id <code>itemId</code> including
-     * the zombie paths.
+     * Resolves the <i>zombie</i> (i.e. the old) path of the Item with id
+     * <code>itemId</code>.
+     *
-     * @return the paths of the item.
-     * @throws ItemStateException if the paths cannot be resolved.
+     * @return the path of the item.
+     * @throws ItemStateException if the path cannot be resolved.
-    private Path[] getAllPaths(ItemId itemId, HierarchyManager hmgr)
+    private Path getZombiePath(ItemId itemId, ChangeLogBasedHierarchyMgr hmgr)
-            return hmgr.getAllPaths(itemId, true);
+            return hmgr.getZombiePath(itemId);
-            String msg = "Unable to resolve paths for item: " + itemId;
+            String msg = "Unable to resolve zombie path for item: " + itemId;

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV43 UPD42 UPD43 UPD66 UPD66 UPD43 UPD66 UPD66 UPD66 UPD66 UPD66 UPD42 UPD42 INS25 INS60 MOV21 UPD42 INS32 INS8 MOV43 INS59 INS8 INS42 INS42 INS60 INS60 MOV25 INS42 INS32 MOV60 MOV60 MOV60 MOV21 UPD45 MOV43 INS59 MOV43 INS59 INS42 MOV32 INS42 MOV43 INS42 INS32 INS42 INS32 UPD27 INS38 INS42 INS42 UPD42 INS32 INS42 INS42 INS42 INS42 INS33 INS32 MOV43 INS38 MOV43 UPD42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 INS32 UPD42 INS42 INS33 INS42 INS42 UPD42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 DEL40 DEL26 DEL40 DEL26 DEL42 DEL42 DEL32 DEL42 DEL32 DEL34 DEL32 DEL32 DEL34 DEL27 DEL42 DEL42 DEL42 DEL32 DEL42 DEL34 DEL32 DEL11 DEL59 DEL60 DEL85 DEL5 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL32 DEL34 DEL27 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL34 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL34 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL34 DEL42 DEL40 DEL43 DEL42 DEL42 DEL34 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL2 DEL42 DEL42 DEL2 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL8 DEL24 DEL85 DEL5 DEL42 DEL42 DEL2 DEL42 DEL42 DEL2 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL8 DEL24 DEL8 DEL85 DEL5 DEL9
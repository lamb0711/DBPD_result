- JCR-2527: Fix and simplify CryptedSimpleCredentials
- minor improvements: comments, @Override annotation, redundant throws clause
- consistently use AbstractUserTest#buildPassword(String) for simple user creation


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@918412 13f79535-47bb-0310-9956-ffa450edef68

+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import java.security.MessageDigest;
+    private static final Logger log = LoggerFactory.getLogger(CryptedSimpleCredentials.class);
+
-     * Take {@link javax.jcr.SimpleCredentials SimpleCredentials} and
-     * digest the password if it is plain-text
+     * Build a new instance of <code>CryptedSimpleCredentials</code> from the
+     * given {@link javax.jcr.SimpleCredentials SimpleCredentials} and create
+     * the crypted password field using the {@link SecurityConstants#DEFAULT_DIGEST
+     * default digest}.
-        String algo =  getAlgorithm(password);
-        if (algo == null) {
-            // password is plain text
-            algorithm = SecurityConstants.DEFAULT_DIGEST;
-            cryptedPassword = crypt(password, algorithm);
-        } else {
-            // password is already encrypted
-            algorithm = algo;
-            cryptedPassword = password;
-        }
+        algorithm = SecurityConstants.DEFAULT_DIGEST;
+        cryptedPassword = crypt(password, algorithm);
-    public CryptedSimpleCredentials(String userId, String password) throws NoSuchAlgorithmException, UnsupportedEncodingException {
-        if (userId == null || userId.length() == 0 || password == null) {
-            throw new IllegalArgumentException("Invalid userID or password. Neither may be null, the userID must have a length > 0.");
+    /**
+     * Create a new instanceof <code>CryptedSimpleCredentials</code> from the
+     * given <code>userId</code> and <code>cryptedPassword</code> strings.
+     * In contrast to {@link CryptedSimpleCredentials(SimpleCredentials)} that
+     * expects the password to be plain text this constructor expects the
+     * password to be already crypted. However, it performs a simple validation
+     * and calls {@link Text#digest(String, byte[])} using the
+     * {@link SecurityConstants#DEFAULT_DIGEST default digest} in case the
+     * given password is found to be plain text.
+     *
+     * @param userId
+     * @param cryptedPassword
+     * @throws NoSuchAlgorithmException
+     * @throws UnsupportedEncodingException
+     */
+    public CryptedSimpleCredentials(String userId, String cryptedPassword) throws NoSuchAlgorithmException, UnsupportedEncodingException {
+        if (userId == null || userId.length() == 0) {
+            throw new IllegalArgumentException("Invalid userID: The userID must have a length > 0.");
+        }
+        if (cryptedPassword == null) {
+            throw new IllegalArgumentException("Password may not be null.");
-        String algo =  getAlgorithm(password);
+        String algo =  extractAlgorithm(cryptedPassword);
-            // password is plain text
+            // password is plain text including those starting with {invalidAlgorithm}
+            log.debug("Plain text password -> Using " + SecurityConstants.DEFAULT_DIGEST + " to create digest.");
-            cryptedPassword = crypt(password, algorithm);
+            this.cryptedPassword = crypt(cryptedPassword, algorithm);
-            // password is already encrypted
+            // password is already encrypted and started with {validAlgorithm}
-            cryptedPassword = password;
+            this.cryptedPassword = cryptedPassword;
-     * returns <code>true</code> if both match.
+     * returns <code>true</code> if both match. Successful match is defined to
+     * be the result of
+     * <ul>
+     * <li>Case-insensitive comparison of the UserIDs</li>
+     * <li>Equality of the passwords if the password contained in the simple
+     * credentials is hashed with the algorithm defined in this credentials object.</li>
+     * </ul>
-     * @param credentials
+     * NOTE, that the simple credentials are exptected to contain the plain text
+     * password.
+     *
+     * @param credentials An instance of simple credentials.
-            String toMatch = new String(credentials.getPassword());
-            String algr = getAlgorithm(toMatch);
-
-            if (algr == null && algorithm != null) {
-                // pw to match not crypted -> crypt with algorithm present here.
-                return crypt(toMatch, algorithm).equals(cryptedPassword);
-            } else if (algr != null && algorithm == null) {
-                // crypted pw to match but unknown algorithm here -> crypt this pw
-                return crypt(algr, cryptedPassword).equals(toMatch);
-            }
-
-            // both pw to compare define a algorithm and are crypted
-            // -> simple comparison of the 2 password strings.
-            return toMatch.equals(cryptedPassword);
+            // crypt the password retrieved from the given simple credentials
+            // and test if it is equal to the cryptedPassword field.
+            return cryptedPassword.equals(crypt(String.valueOf(credentials.getPassword()), algorithm));
+    /**
+     * @param pwd Plain text password
+     * @param algorithm The algorithm to be used for the digest.
+     * @return Digest of the given password with leading algorithm information.
+     * @throws NoSuchAlgorithmException
+     * @throws UnsupportedEncodingException
+     */
-    private static String getAlgorithm(String password) {
-        int end = password.indexOf("}");
-        if (password.startsWith("{") && end > 0) {
-            return password.substring(1, end);
-        } else {
-            return null;
+    /**
+     * Extract the algorithm from the given crypted password string. Returns the
+     * algorithm or <code>null</code> if the given string doesn't have a
+     * leading <code>{algorith}</code> such as created by {@link #crypt(String, String)
+     * or if the extracted string doesn't represent an available algorithm.
+     *
+     * @param cryptedPwd
+     * @return The algorithm or <code>null</code> if the given string doesn't have a
+     * leading <code>{algorith}</code> such as created by {@link #crypt(String, String)
+     * or if the extracted string isn't an available algorithm. 
+     */
+    private static String extractAlgorithm(String cryptedPwd) {
+        int end = cryptedPwd.indexOf("}");
+        if (cryptedPwd.startsWith("{") && end > 0) {
+            String algorithm = cryptedPwd.substring(1, end);
+            try {
+                MessageDigest.getInstance(algorithm);
+                return algorithm;
+            } catch (NoSuchAlgorithmException e) {
+                log.debug("Invalid algorithm detected " + algorithm);
+            }
+
+        // not starting with {} or invalid algorithm
+        return null;

INS26 INS26 INS26 INS40 INS40 INS40 INS23 INS83 INS83 INS83 INS43 INS59 INS29 INS29 INS29 UPD42 INS42 INS42 INS32 MOV21 MOV21 INS65 INS65 INS65 INS65 INS65 MOV43 UPD42 INS25 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 UPD42 MOV41 INS42 INS42 INS57 INS66 UPD66 UPD66 UPD66 INS65 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS42 INS42 INS42 INS42 MOV27 INS27 INS8 MOV43 UPD66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS66 INS66 INS66 INS65 INS42 INS66 INS66 INS65 INS42 INS43 INS67 INS66 INS66 INS68 INS67 INS66 INS42 INS33 INS53 INS21 INS41 INS68 INS66 INS68 INS66 INS60 INS54 INS42 INS42 INS42 INS42 INS42 INS69 INS69 INS42 INS42 INS14 UPD42 UPD42 INS32 INS32 INS42 INS69 INS69 INS42 INS69 INS69 UPD42 UPD42 INS43 INS59 INS8 INS12 MOV43 INS5 UPD45 INS43 INS45 INS42 INS42 INS27 INS22 INS22 UPD42 UPD42 MOV42 MOV42 INS32 MOV43 MOV43 MOV43 MOV43 INS42 INS42 INS32 INS21 INS41 INS44 INS8 INS39 INS85 INS42 INS45 INS40 INS45 INS52 INS42 UPD42 INS52 INS42 MOV42 INS32 UPD42 MOV42 UPD42 MOV42 MOV42 MOV34 MOV42 INS32 INS42 INS43 INS42 INS21 UPD42 MOV42 UPD42 MOV42 MOV32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS27 INS45 INS42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL8 DEL42 DEL42 DEL7 DEL21 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL27 DEL42 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL33 DEL27 DEL27 DEL42 DEL42 DEL32 DEL42 DEL32 DEL41 DEL8 DEL42 DEL33 DEL27 DEL42 DEL33 DEL27 DEL27 DEL32 DEL42 DEL32 DEL41 DEL8 DEL25 DEL25 DEL42 DEL42 DEL42 DEL32 DEL41 DEL32 DEL41 DEL8
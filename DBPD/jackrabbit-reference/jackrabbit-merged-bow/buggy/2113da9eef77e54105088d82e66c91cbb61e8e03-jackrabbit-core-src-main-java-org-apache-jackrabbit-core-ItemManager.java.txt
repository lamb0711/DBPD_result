JCR-1104 : JSR 283 support (security work in progress)

> introduce AccessManager.canRead(Path)
> retrieve Policy/ACE from ACProvider by Path rather than by ID
> add CompiledPermission.canReadAll for optimization
> fix ACLTemplate (various bugs) and add additional tests
> get rid of deprecated AccessManager.isGranted(ItemId, int) wherever possible
  and mark/simplify other usages
  - ItemManager
  - BatchedItemOperations
  - add TODO with QueryResultImpl that still uses the isGranted method.
  - EventConsumer: still uses isGranted. but various calls were replaced by private
    canRead -> simplify later optimization.
> remove unused ACLCache.java
> ItemManager:
  - make getItem consistent with itemExists (check perm even if obtained from cache)
  - replace getItemState by getItemData
  - get rid of duplicate code
  - add canRead(ItemData, Path) which is used (almost) everywhere and avoid permission
    check for NEW,non-protected items
  - consequently getItem(ItemId, boolean) is not required any more.
  - upon building LazyItemIterator for children: omit the duplicate permission
    check while building the set of childIds.
    the perm-check is executed upon the subsequent ItemManager.getItem call anyway 
> NodeImpl: createChildNode called ItemManager.getItem for an new item that has
  not yet been added as CNE to its parent -> replace by ItemManager.createItemInstance
  which omits the permission check.
> ItemImpl: 
  - fix javadoc
  - replace removed method ItemMgr.getItem(ItemId, boolean) by getItem(ItemId)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@649172 13f79535-47bb-0310-9956-ffa450edef68

-     * Retrieves state of item with given <code>id</code>. If the specified item
-     * doesn't exist an <code>ItemNotFoundException</code> will be thrown.
+     * Common implementation for all variants of item/node/propertyExists
+     * with both itemId or path param.
+     *
+     * @param itemId The id of the item to test.
+     * @param path Path of the item to check if known or <code>null</code>. In
+     * the latter case the test for access permission is executed using the
+     * itemId.
+     * @return true if the item with the given <code>itemId</code> exists AND
+     * can be read by this session.
+     */
+    private boolean itemExists(ItemId itemId, Path path) {
+        try {
+            // check sanity of session
+            session.sanityCheck();
+
+            // check if state exists for the given item
+            if (!itemStateProvider.hasItemState(itemId)) {
+                return false;
+            }
+
+            ItemData data = getItemData(itemId, path);
+            return data != null;
+        } catch (ItemNotFoundException infe) {
+            return false;
+        } catch (RepositoryException re) {
+            return false;
+        }
+    }
+
+    /**
+     * Common implementation for all variants of getItem/getNode/getProperty
+     * with both itemId or path parameter.
+     *
+     * @param itemId
+     * @param path Path of the item to retrieve or <code>null</code>. In
+     * the latter case the test for access permission is executed using the
+     * itemId.
+     * @return The item identified by the given <code>itemId</code>.
+     * @throws ItemNotFoundException
+     * @throws AccessDeniedException
+     * @throws RepositoryException
+     */
+    private ItemImpl getItem(ItemId itemId, Path path) throws ItemNotFoundException, AccessDeniedException, RepositoryException {
+        // check sanity of session
+        session.sanityCheck();
+
+        ItemData data = getItemData(itemId, path);
+        if (data == null) {
+            throw new AccessDeniedException("cannot read item " + itemId);
+        }
+        return createItemInstance(data);
+    }
+
+    /**
+     * Retrieves the data of the item with given <code>id</code>. If the
+     * specified item doesn't exist an <code>ItemNotFoundException</code> will
+     * be thrown.
-     * @param id id of item to be retrieved
+     * @param itemId id of item to be retrieved
+     * @param path The path of the item to retrieve the data for or
+     * <code>null</code>. In the latter case the id (instead of the path) is
+     * used to test if READ permission is granted.
-    private ItemState getItemState(ItemId id)
+    private ItemData getItemData(ItemId itemId, Path path)
-        // check privileges
-        if (!canRead(id)) {
-            // clear cache
-            evictItems(id);
-            throw new AccessDeniedException("cannot read item " + id);
+        ItemData data = retrieveItem(itemId);
+        if (data == null) {
+            // not yet in cache, need to create instance:
+            // - retrieve item state
+            // - create instance of item data
+            // NOTE: permission check & caching within createItemData
+            ItemState state;
+            try {
+                state = itemStateProvider.getItemState(itemId);
+            } catch (NoSuchItemStateException nsise) {
+                throw new ItemNotFoundException(itemId.toString());
+            } catch (ItemStateException ise) {
+                String msg = "failed to retrieve item state of item " + itemId;
+                log.error(msg, ise);
+                throw new RepositoryException(msg, ise);
+            }
+            // create item data including: perm check and caching.
+            data = createItemData(state, path);
+        } else {
+            // already cached: check if read-permission is granted in order
+            // to have a consistent behaviour to 'itemExists' above.
+            if (!canRead(data, path)) {
+                // item exists but read-perm has been revoked in the mean time.
+                // -> remove from cache
+                evictItems(itemId);
+                return null;
+            }
+        return data;
+    }
-        try {
-            return itemStateProvider.getItemState(id);
-        } catch (NoSuchItemStateException nsise) {
-            String msg = "no such item: " + id;
-            log.debug(msg);
-            throw new ItemNotFoundException(msg);
-        } catch (ItemStateException ise) {
-            String msg = "failed to retrieve item state of " + id;
-            log.error(msg);
-            throw new RepositoryException(msg, ise);
+    /**
+     * @param data
+     * @param path Path to be used for the permission check or <code>null</code>
+     * in which case the itemId present with the specified <code>data</code> is used.
+     * @return true if the item with the given <code>data</code> can be read;
+     * <code>false</code> otherwise.
+     * @throws AccessDeniedException
+     * @throws RepositoryException
+     */
+    private boolean canRead(ItemData data, Path path) throws AccessDeniedException, RepositoryException {
+        if (data.getState().getStatus() == ItemState.STATUS_NEW &&
+                !data.getDefinition().isProtected()) {
+            // NEW items can always be read as long they have been added
+            // through the API and NOT by the system (i.e. protected props).
+            return true;
+        } else {
+            return (path == null) ?
+                    canRead(data.getId()) :
+                    session.getAccessManager().canRead(path);
+    /**
+     * @param id
+     * @return true if the item with the given <code>id</code> can be read;
+     * <code>false</code> otherwise.
+     * @throws RepositoryException
+     */
-            return (id != null) && itemExists(id);
+            return (id != null) && itemExists(id, path);
-            return (id != null) && itemExists(id);
+            return (id != null) && itemExists(id, path);
-            return (id != null) && itemExists(id);
+            return (id != null) && itemExists(id, path);
-        try {
-            // check sanity of session
-            session.sanityCheck();
-
-            // check if state exists for the given item
-            if (!itemStateProvider.hasItemState(id)) {
-                return false;
-            }
-
-            // check privileges
-            if (!canRead(id)) {
-                // clear cache
-                evictItems(id);
-                // item exists but the session has not been granted read access
-                return false;
-            }
-            return true;
-        } catch (ItemNotFoundException infe) {
-            return false;
-        } catch (RepositoryException re) {
-            return false;
-        }
+        return itemExists(id, null);
-            return getItem(id);
+            return getItem(id, path);
-            return (NodeImpl) getItem(id);
+            return (NodeImpl) getItem(id, path);
-            return (PropertyImpl) getItem(id);
+            return (PropertyImpl) getItem(id, path);
-        // check sanity of session
-        session.sanityCheck();
-
-        ItemData data = retrieveItem(id);
-        if (data == null) {
-            // not yet in cache, need to create instance:
-            // check privileges
-            if (!canRead(id)) {
-                throw new AccessDeniedException("cannot read item " + id);
-            }
-            // create instance of item data
-            data = createItemData(id);
-            cacheItem(data);
-        }
-        return createItemInstance(data);
+        return getItem(id, null);
-
-            data = (AbstractNodeData) createItemData(id);
-            cacheItem(data);
+            data = (AbstractNodeData) getItemData(id, null);
+            // TODO: ev. need to check if read perm. is granted.
-     * Returns the item instance for the given item id.
-     *
-     * @param state the item state
-     * @param checkAccess whether to check access
-     * @return the item instance for the given item <code>state</code>.
-     * @throws RepositoryException
-     */
-    synchronized ItemImpl getItem(ItemId id, boolean isNew)
-            throws ItemNotFoundException, AccessDeniedException, RepositoryException {
-        // check sanity of session
-        session.sanityCheck();
-
-        // check cache
-        ItemData data = retrieveItem(id);
-        if (data == null) {
-            // not yet in cache, need to create instance:
-            // only check privileges if state is not new
-            if (!isNew && !canRead(id)) {
-                throw new AccessDeniedException("cannot read item " + id);
-            }
-            // create instance of item
-            data = createItemData(id);
-            cacheItem(data);
-        }
-        return createItemInstance(data);
-    }
-
-    /**
-     * new <code>ItemData</code> instance without looking at the cache and
-     * returns a new item instance.
+     * new <code>ItemData</code> instance without looking at the cache nor
+     * testing if the item can be read and returns a new item instance.
-
-        ItemData data = createItemData(state);
-        cacheItem(data);
+        ItemData data = createItemData(state, null, false);
-        ItemState state = getItemState(parentId);
-        if (!state.isNode()) {
+        ItemData data = getItemData(parentId, null);
+        if (!data.isNode()) {
-        NodeState nodeState = (NodeState) state;
-        Iterator iter = nodeState.getChildNodeEntries().iterator();
+        Iterator iter = ((NodeState) data.getState()).getChildNodeEntries().iterator();
-            // check read access
+            // make sure any of the properties can be read.
-        ItemState state = getItemState(parentId);
-        if (!state.isNode()) {
+        ItemData data = getItemData(parentId, null);
+        if (!data.isNode()) {
-        NodeState nodeState = (NodeState) state;
-        Iterator iter = nodeState.getChildNodeEntries().iterator();
+        Iterator iter = ((NodeState) data.getState()).getChildNodeEntries().iterator();
-            // check read access
-            if (canRead(entry.getId())) {
-                childIds.add(entry.getId());
-            }
+            // delay check for read-access until item is being built
+            // thus avoid duplicate check
+            childIds.add(entry.getId());
-        ItemState state = getItemState(parentId);
-        if (!state.isNode()) {
+        ItemData data = getItemData(parentId, null);
+        if (!data.isNode()) {
-        NodeState nodeState = (NodeState) state;
-        Iterator iter = nodeState.getPropertyNames().iterator();
+        Iterator iter = ((NodeState) data.getState()).getPropertyNames().iterator();
-            // check read access
+            // make sure any of the properties can be read.
-        ItemState state = getItemState(parentId);
-        if (!state.isNode()) {
+        ItemData data = getItemData(parentId, null);
+        if (!data.isNode()) {
-        NodeState nodeState = (NodeState) state;
-        Iterator iter = nodeState.getPropertyNames().iterator();
+        Iterator iter = ((NodeState) data.getState()).getPropertyNames().iterator();
-            // check read access
-            if (canRead(id)) {
-                childIds.add(id);
-            }
+            // delay check for read-access until item is being built
+            // thus avoid duplicate check
+            childIds.add(id);
-
-    private ItemData createItemData(ItemId id)
-            throws ItemNotFoundException, RepositoryException {
-
-        ItemState state;
-        try {
-            state = itemStateProvider.getItemState(id);
-        } catch (NoSuchItemStateException nsise) {
-            throw new ItemNotFoundException(id.toString());
-        } catch (ItemStateException ise) {
-            String msg = "failed to retrieve item state of item " + id;
-            log.error(msg, ise);
-            throw new RepositoryException(msg, ise);
-        }
-        return createItemData(state);
+    /**
+     * Same as {@link #createItemData(ItemState, Path, boolean)} where the
+     * permissionCheck flag is 'true'. This method will throw
+     * <code>AccessDeniedException</code> if reading the item data is not
+     * allowed.
+     *
+     * @param state
+     * @return
+     * @throws RepositoryException
+     */
+    private ItemData createItemData(ItemState state, Path path) throws RepositoryException {
+        return createItemData(state, path, true);
-    private ItemData createItemData(ItemState state) throws RepositoryException {
+    /**
+     * Builds the <code>ItemData</code> for the specified <code>state</code>.
+     * If <code>permissionCheck</code> is <code>true</code>, the access manager
+     * is used to determine if reading that item would be granted. If this is
+     * not the case an <code>AccessDeniedException</code> is thrown.
+     * Before returning the created <code>ItemData</code> it is put into the
+     * cache. In order to benefit from the cache {@link #getItemData(ItemId, Path)}
+     * should be called
+     *
+     * @param state
+     * @return
+     * @throws RepositoryException
+     */
+    private ItemData createItemData(ItemState state, Path path, boolean permissionCheck) throws RepositoryException {
+        ItemData data;
-            return new NodeData((NodeState) state, rootNodeDef);
+            data = new NodeData((NodeState) state, rootNodeDef);
-            return new NodeData(nodeState, getDefinition(nodeState));
+            data = new NodeData(nodeState, getDefinition(nodeState));
-            return new PropertyData(propertyState, getDefinition(propertyState));
+            data = new PropertyData(propertyState, getDefinition(propertyState));
+        // make sure read-perm. is granted before returning the data.
+        if (permissionCheck && !canRead(data, path)) {
+            throw new AccessDeniedException("cannot read item " + state.getId());
+        }
+        // before returning the data: put them into the cache.
+        cacheItem(data);
+        return data;
-     * @param item the item to cache
+     * @param data the item data to cache
-     * @param id id of the item to remove from the cache
+     * @param data The item data to remove from the cache

MOV31 MOV31 INS31 INS31 INS31 INS31 INS31 INS31 INS29 UPD83 INS44 INS44 INS29 MOV83 MOV43 UPD42 MOV42 MOV44 INS44 MOV43 MOV43 MOV43 INS8 MOV29 INS83 MOV43 INS42 INS44 INS44 MOV43 MOV43 MOV43 INS8 INS29 UPD83 MOV83 INS39 UPD42 MOV42 MOV44 INS44 MOV43 MOV43 INS8 INS29 INS8 MOV29 INS83 INS39 INS42 MOV44 MOV8 MOV29 INS83 INS39 INS42 MOV44 INS8 INS8 MOV29 INS44 MOV43 MOV43 MOV43 MOV29 INS83 MOV43 INS42 MOV44 MOV43 MOV43 INS43 MOV8 UPD83 INS43 INS42 MOV43 INS29 INS44 INS44 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS65 INS65 INS65 INS65 INS65 INS65 INS65 UPD42 INS43 INS42 MOV21 INS60 INS25 MOV41 INS65 INS43 INS42 UPD43 MOV43 UPD42 MOV42 MOV60 INS25 INS41 INS65 MOV65 MOV65 MOV65 MOV65 UPD43 UPD42 INS43 INS42 INS25 INS65 INS65 INS65 INS54 MOV41 MOV60 MOV25 INS54 INS65 INS65 INS65 INS43 INS42 INS42 UPD42 MOV42 MOV60 INS41 INS25 MOV25 INS25 MOV25 UPD65 UPD65 INS42 UPD43 UPD42 INS43 INS42 INS65 INS65 INS65 INS65 INS43 INS42 INS39 INS42 INS60 INS25 MOV21 INS41 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS66 INS66 INS42 INS42 INS66 INS66 INS66 INS66 INS42 INS42 INS42 INS42 INS43 INS59 MOV27 INS8 UPD66 UPD66 INS66 UPD42 INS42 INS66 INS66 INS66 UPD42 MOV42 UPD42 MOV43 MOV27 MOV8 INS8 INS42 INS42 INS66 INS66 INS66 INS66 UPD42 UPD42 MOV42 INS27 INS8 INS8 INS42 INS66 INS66 INS42 INS8 MOV12 INS32 INS8 MOV12 INS42 INS42 INS42 INS32 UPD66 UPD66 MOV43 INS38 MOV8 INS43 UPD43 MOV8 UPD43 INS38 MOV8 INS43 MOV43 INS66 INS65 INS66 INS66 UPD66 INS66 INS42 UPD42 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS42 INS42 INS42 INS43 INS59 INS27 INS8 INS42 UPD42 UPD66 UPD42 UPD66 INS60 MOV41 INS42 INS42 INS32 MOV53 UPD42 INS32 INS21 INS25 INS27 INS38 MOV41 INS41 INS21 MOV60 INS41 MOV21 MOV60 UPD42 MOV42 MOV42 INS33 INS42 INS33 INS41 UPD42 MOV42 MOV42 INS33 UPD42 INS32 INS42 UPD42 UPD42 MOV60 UPD42 UPD42 INS32 MOV42 INS42 UPD42 MOV21 INS68 UPD42 UPD42 INS42 INS9 INS68 INS42 INS42 INS21 INS42 INS38 INS53 INS43 INS59 INS27 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS7 INS38 INS8 INS32 INS40 INS32 INS16 INS32 INS27 INS32 INS42 INS42 INS42 INS11 INS33 INS9 UPD42 INS33 INS42 INS42 UPD42 INS33 UPD42 UPD42 INS33 INS42 INS42 UPD43 MOV43 UPD42 INS33 UPD42 INS42 INS69 INS69 INS69 INS42 INS69 INS69 INS7 INS21 INS21 INS32 INS14 INS42 INS42 INS32 INS42 INS33 MOV44 INS42 INS32 INS32 MOV21 MOV41 INS32 INS42 INS32 UPD42 MOV42 INS36 INS32 INS32 INS42 INS42 MOV36 INS32 INS42 INS42 INS42 MOV43 INS32 UPD42 MOV42 UPD42 MOV42 INS36 INS36 UPD42 UPD42 MOV42 INS36 INS36 MOV43 INS43 INS39 INS43 INS43 INS42 MOV14 INS7 INS7 INS42 INS42 INS42 MOV43 INS27 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV53 MOV42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS33 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS27 INS42 INS32 INS32 INS42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV42 MOV42 INS42 INS11 INS11 INS11 INS11 INS42 INS42 INS42 INS42 MOV14 INS42 MOV14 INS45 INS32 MOV43 UPD42 UPD42 UPD42 MOV42 MOV33 INS42 INS42 UPD42 MOV42 INS42 INS42 UPD42 INS33 INS43 INS32 INS43 INS32 INS43 INS32 INS43 INS32 INS42 INS42 UPD42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 DEL9 DEL42 DEL42 DEL32 DEL38 DEL32 DEL21 DEL8 DEL25 DEL45 DEL42 DEL27 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL53 DEL42 DEL43 DEL32 DEL41 DEL42 DEL42 DEL32 DEL27 DEL42 DEL43 DEL42 DEL42 DEL32 DEL38 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL43 DEL42 DEL45 DEL42 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL12 DEL44 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL31 DEL32 DEL11 DEL83 DEL39 DEL42 DEL8 DEL54 DEL8 DEL31 DEL32 DEL8 DEL54 DEL8 DEL31 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL38 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL38 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL25 DEL8 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL38 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL8 DEL25 DEL66 DEL42 DEL66 DEL66 DEL42 DEL39 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL38 DEL42 DEL42 DEL32 DEL38 DEL27 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL31 DEL41 DEL41 DEL41
JCR-726: Improve NodeTypeRegistry.effectiveNodeType()


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@502223 13f79535-47bb-0310-9956-ffa450edef68

+import EDU.oswego.cs.dl.util.concurrent.ConcurrentReaderHashMap;
+import org.apache.jackrabbit.core.cluster.NodeTypeEventChannel;
+import org.apache.jackrabbit.core.cluster.NodeTypeEventListener;
-import org.apache.jackrabbit.core.cluster.NodeTypeEventChannel;
-import org.apache.jackrabbit.core.cluster.NodeTypeEventListener;
-import javax.jcr.NamespaceRegistry;
-import javax.jcr.PropertyType;
-import javax.jcr.RepositoryException;
-import javax.jcr.nodetype.ConstraintViolationException;
-import javax.jcr.nodetype.NoSuchNodeTypeException;
-import javax.jcr.version.OnParentVersionAction;
-import java.util.ArrayList;
-import EDU.oswego.cs.dl.util.concurrent.ConcurrentReaderHashMap;
+import javax.jcr.NamespaceRegistry;
+import javax.jcr.PropertyType;
+import javax.jcr.RepositoryException;
+import javax.jcr.nodetype.ConstraintViolationException;
+import javax.jcr.nodetype.NoSuchNodeTypeException;
+import javax.jcr.version.OnParentVersionAction;
-    private final EffectiveNodeTypeCache entCache;
+    private EffectiveNodeTypeCache entCache;
-     * @throws InvalidNodeTypeDefException
-     * @throws RepositoryException
+     * @throws InvalidNodeTypeDefException if the given node type definition is invalid.
+     * @throws RepositoryException if a repository error occurs.
-     * @throws InvalidNodeTypeDefException
-     * @throws RepositoryException
+     * @throws InvalidNodeTypeDefException if the given node type definition is invalid.
+     * @throws RepositoryException if a repository error occurs.
-                msg.append(ntName
-                        + " can not be removed because the following node types depend on it: ");
+                msg.append(ntName).append(" can not be removed because the following node types depend on it: ");
-        entCache = new EffectiveNodeTypeCache();
+        // use the improved node type cache
+        // (replace with: entCache = new EffectiveNodeTypeCacheImpl();
+        // for the old one)
+        entCache = new BitsetENTCacheImpl();
-        EffectiveNodeType ent = entCache.get(new QName[]{ntName});
+        EffectiveNodeTypeCache.Key key = entCache.getKey(new QName[]{ntName});
+        EffectiveNodeType ent = entCache.get(key);
-     * @return
+     * @return the desired effective node type
-        EffectiveNodeTypeCache.WeightedKey key =
-                new EffectiveNodeTypeCache.WeightedKey(ntNames);
+        EffectiveNodeTypeCache.Key key = entCache.getKey(ntNames);
+        EffectiveNodeTypeCache.Key requested = key;
-            ArrayList tmpResults = new ArrayList();
-                // check if we've already built this aggregate
-                if (entCache.contains(key)) {
-                    tmpResults.add(entCache.get(key));
-                    // subtract the result from the temporary key
-                    // (which is 'empty' now)
-                    key = key.subtract(key);
-                    break;
-                }
-                /**
-                 * walk list of existing aggregates sorted by 'weight' of
-                 * aggregate (i.e. the cost of building it)
-                 */
-                boolean foundSubResult = false;
-                Iterator iter = entCache.keyIterator();
-                while (iter.hasNext()) {
-                    EffectiveNodeTypeCache.WeightedKey k =
-                            (EffectiveNodeTypeCache.WeightedKey) iter.next();
-                    /**
-                     * check if the existing aggregate is a 'subset' of the one
-                     * we're looking for
-                     */
-                    if (key.contains(k)) {
-                        tmpResults.add(entCache.get(k));
-                        // subtract the result from the temporary key
-                        key = key.subtract(k);
-                        foundSubResult = true;
-                        break;
+                // find the (sub) key that matches the current key the best
+                EffectiveNodeTypeCache.Key subKey = entCache.findBest(key);
+                if (subKey != null) {
+                    EffectiveNodeType ent = entCache.get(subKey);
+                    if (result == null) {
+                        result = ent;
+                    } else {
+                        result = result.merge(ent);
+                        // store intermediate result
+                        entCache.put(result);
-                }
-                if (!foundSubResult) {
+                    // subtract the result from the temporary key
+                    key = key.subtract(subKey);
+                } else {
-                    // add aggregate of remaining node types to result list
-                    tmpResults.add(result);
-            // merge the sub-aggregates into new effective node type
-            for (int i = 0; i < tmpResults.size(); i++) {
-                if (result == null) {
-                    result = (EffectiveNodeType) tmpResults.get(i);
-                } else {
-                    result = result.merge((EffectiveNodeType) tmpResults.get(i));
-                    // store intermediate result
-                    entCache.put(result);
-                }
-            }
+        }
+        // also put the requested key, since the merge could have removed some
+        // the redundant nodetypes
+        if (!entCache.contains(requested)) {
+            entCache.put(requested, result);
-                    validateNodeTypeDef(ntd, tmpENTCache, tmpNTDefCache, nsReg, lenient);
+                    validateNodeTypeDef(ntd, tmpENTCache, tmpNTDefCache, nsReg,
+                            lenient);
-        // since no exception was thrown so far the definitions are assumed to be valid
+        // since no exception was thrown so far the definitions are assumed to
+        // be valid
-        for (Iterator it = tmpENTCache.keyIterator(); it.hasNext(); ) {
-            EffectiveNodeTypeCache.WeightedKey k =
-                    (EffectiveNodeTypeCache.WeightedKey) it.next();
-            if (!entCache.contains(k)) {
-                entCache.put(tmpENTCache.get(k));
-            }
-        }
+        entCache = tmpENTCache;
-        /**
-         * remove all affected effective node types from aggregates cache
-         * (copy keys first to prevent ConcurrentModificationException)
-         */
-        ArrayList keys = new ArrayList(entCache.keySet());
-        for (Iterator keysIter = keys.iterator(); keysIter.hasNext();) {
-            EffectiveNodeTypeCache.WeightedKey k =
-                    (EffectiveNodeTypeCache.WeightedKey) keysIter.next();
-            EffectiveNodeType ent = entCache.get(k);
-            if (ent.includesNodeType(name)) {
-                entCache.remove(k);
-            }
-        }
+        entCache.invalidate(name);

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS60 INS60 INS60 INS25 MOV21 MOV21 INS66 INS66 INS66 INS66 INS43 MOV43 INS59 INS66 UPD43 MOV43 INS59 INS43 INS59 INS38 INS8 INS7 INS40 UPD42 INS42 MOV32 UPD40 MOV42 INS32 UPD40 MOV40 INS42 INS42 INS32 INS21 INS42 INS42 UPD42 UPD42 UPD43 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 UPD42 INS60 INS42 INS42 INS42 INS42 UPD43 MOV43 INS59 INS27 INS8 INS32 INS42 INS45 UPD40 INS42 INS32 INS42 INS33 INS60 INS25 INS21 MOV42 MOV42 INS42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV43 INS59 MOV27 INS8 INS8 INS7 INS42 INS32 INS21 INS21 MOV21 INS42 INS32 INS42 INS42 INS42 INS7 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 DEL40 DEL26 DEL83 DEL42 DEL45 DEL27 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL10 DEL8 DEL25 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL40 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL9 DEL7 DEL21 DEL10 DEL8 DEL25 DEL8 DEL61 DEL42 DEL38 DEL42 DEL42 DEL42 DEL32 DEL21 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL42 DEL42 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL24 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL40 DEL43 DEL42 DEL40 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL38 DEL8 DEL25 DEL8 DEL24 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL40 DEL43 DEL42 DEL40 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL8 DEL25 DEL8 DEL24
- adapted versioning again to spec 0.15
- added VirtualItemStateManager for reflecting virtual content


git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@55615 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.util.ChildrenCollectorFilter;
-import javax.jcr.util.TraversingItemVisitor;
-            ItemImpl item = itemMgr.getItem(nodePath);
+            Item item = itemMgr.getItem(nodePath);
-                throw new ItemExistsException(item.safeGetJCRPath());
+                throw new ItemExistsException(itemMgr.safeGetJCRPath(nodePath));
-                    throw new ItemExistsException(item.safeGetJCRPath());
+                    throw new ItemExistsException(itemMgr.safeGetJCRPath(nodePath));
-                VersionHistory hist = rep.getVersionManager().createVersionHistory(this);
+                VersionHistory hist = session.versionMgr.createVersionHistory(this);
-        Version v = rep.getVersionManager().checkin(this);
+        Version v = session.versionMgr.checkin(this);
-        internalSetProperty(VersionManager.PROPNAME_BASE_VERSION, InternalValue.create(new UUID(version.getUUID())));
+        internalSetProperty(VersionManager.PROPNAME_BASE_VERSION, InternalValue.create(new UUID(version.getId())));
-// ignore and try multiple below
+                    // ignore and try multiple below
-
-                    VersionHistory history = ((InternalFrozenVersionHistory) child).getVersionHistory(session);
+                    VersionHistory history = (VersionHistory) session.getNodeByUUID(((InternalFrozenVersionHistory) child).getVersionHistoryId());
-        return rep.getVersionManager().getVersionHistory(this);
+        return session.versionMgr.getVersionHistory(this);
-        return rep.getVersionManager().getBaseVersion(this);
+        return session.versionMgr.getBaseVersion(this);
-
-/**
- * <code>ChildrenCollectorFilter</code> is a utility class
- * which can be used to 'collect' child items of a
- * node whose names match a certain pattern. It implements the
- * <code>ItemVisitor</code> interface.
- */
-class ChildrenCollectorFilter extends TraversingItemVisitor.Default {
-    static final char WILDCARD_CHAR = '*';
-    static final String OR = "|";
-
-    private final Collection children;
-    private final boolean collectNodes;
-    private final boolean collectProperties;
-    private final String namePattern;
-
-    /**
-     * Constructs a <code>ChildrenCollectorFilter</code>
-     *
-     * @param namePattern       the pattern which should be applied to the names
-     *                          of the children
-     * @param children          where the matching children should be added
-     * @param collectNodes      true, if child nodes should be collected; otherwise false
-     * @param collectProperties true, if child properties should be collected; otherwise false
-     * @param maxLevel          umber of hierarchy levels to traverse
-     *                          (e.g. 1 for direct children only, 2 for children and their children, and so on)
-     */
-    ChildrenCollectorFilter(String namePattern, Collection children, boolean collectNodes, boolean collectProperties, int maxLevel) {
-        super(false, maxLevel);
-        this.namePattern = namePattern;
-        this.children = children;
-        this.collectNodes = collectNodes;
-        this.collectProperties = collectProperties;
-    }
-
-    /**
-     * @see TraversingItemVisitor#entering(Node, int)
-     */
-    protected void entering(Node node, int level)
-            throws RepositoryException {
-        if (level > 0 && collectNodes) {
-            if (matches(node.getName(), namePattern)) {
-                children.add(node);
-            }
-        }
-    }
-
-    /**
-     * @see TraversingItemVisitor#entering(Property, int)
-     */
-    protected void entering(Property property, int level)
-            throws RepositoryException {
-        if (level > 0 && collectProperties) {
-            if (matches(property.getName(), namePattern)) {
-                children.add(property);
-            }
-        }
-    }
-
-    /**
-     * Applies the name pattern against the specified name.
-     * <p/>
-     * The pattern may be a full name or a partial name with one or more
-     * wildcard characters ("*"), or a disjunction (using the "|" character
-     * to represent logical <i>OR</i>) of these. For example,
-     * <p/>
-     * <code>"jcr:*|foo:bar"</code>
-     * <p/>
-     * would match
-     * <p/>
-     * <code>"foo:bar"</code>, but also <code>"jcr:whatever"</code>.
-     *
-     * @param name the name to test the pattern with
-     * @return true if the specified name matches the pattern
-     */
-    static boolean matches(String name, String pattern) {
-        // split pattern
-        StringTokenizer st = new StringTokenizer(pattern, OR, false);
-        while (st.hasMoreTokens()) {
-            if (internalMatches(name, st.nextToken(), 0, 0)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Internal helper used to recursively match the pattern
-     *
-     * @param s       The string to be tested
-     * @param pattern The pattern
-     * @param sOff    offset within <code>s</code>
-     * @param pOff    offset within <code>pattern</code>.
-     * @return true if <code>s</code> matched pattern, else false.
-     */
-    private static boolean internalMatches(String s, String pattern, int sOff, int pOff) {
-        int pLen = pattern.length();
-        int sLen = s.length();
-
-        for (; ;) {
-            if (pOff >= pLen) {
-                if (sOff >= sLen) {
-                    return true;
-                } else if (s.charAt(sOff) == '[') {
-                    // check for subscript notation (e.g. "whatever[1]")
-
-                    // the entire pattern matched up to the subscript:
-                    // -> ignore the subscript
-                    return true;
-                } else {
-                    return false;
-                }
-            }
-            if (sOff >= sLen && pattern.charAt(pOff) != WILDCARD_CHAR) {
-                return false;
-            }
-
-            // check for a '*' as the next pattern char;
-            // this is handled by a recursive call for
-            // each postfix of the name.
-            if (pattern.charAt(pOff) == WILDCARD_CHAR) {
-                if (++pOff >= pLen) {
-                    return true;
-                }
-
-                for (; ;) {
-                    if (internalMatches(s, pattern, sOff, pOff)) {
-                        return true;
-                    }
-                    if (sOff >= sLen) {
-                        return false;
-                    }
-                    sOff++;
-                }
-            }
-
-            if (pOff < pLen && sOff < sLen) {
-                if (pattern.charAt(pOff) != s.charAt(sOff)) {
-                    return false;
-                }
-            }
-            pOff++;
-            sOff++;
-        }
-    }
-}

MOV26 UPD40 INS40 INS40 UPD43 INS40 UPD42 UPD42 UPD42 INS42 INS40 INS43 UPD42 INS42 INS42 INS11 MOV43 INS32 INS42 INS42 MOV32 UPD42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL42 DEL40 DEL43 DEL83 DEL83 DEL39 DEL42 DEL13 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL45 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL29 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL9 DEL42 DEL46 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL42 DEL42 DEL42 DEL43 DEL69 DEL39 DEL69 DEL68 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL34 DEL27 DEL42 DEL27 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL31 DEL42 DEL42 DEL42 DEL43 DEL69 DEL39 DEL69 DEL68 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL34 DEL27 DEL42 DEL27 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL31 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL9 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL34 DEL34 DEL32 DEL9 DEL41 DEL8 DEL25 DEL8 DEL61 DEL9 DEL41 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL27 DEL42 DEL42 DEL27 DEL9 DEL41 DEL8 DEL42 DEL42 DEL42 DEL32 DEL13 DEL27 DEL9 DEL41 DEL8 DEL9 DEL41 DEL8 DEL25 DEL25 DEL8 DEL25 DEL42 DEL42 DEL27 DEL42 DEL42 DEL42 DEL32 DEL42 DEL27 DEL27 DEL9 DEL41 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL42 DEL27 DEL42 DEL38 DEL42 DEL27 DEL9 DEL41 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL9 DEL41 DEL8 DEL25 DEL42 DEL42 DEL27 DEL9 DEL41 DEL8 DEL25 DEL42 DEL37 DEL21 DEL8 DEL24 DEL8 DEL25 DEL42 DEL42 DEL27 DEL42 DEL42 DEL27 DEL27 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL27 DEL9 DEL41 DEL8 DEL25 DEL8 DEL25 DEL42 DEL37 DEL21 DEL42 DEL37 DEL21 DEL8 DEL24 DEL8 DEL31 DEL55
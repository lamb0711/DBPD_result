reviewed references stuff in respect to VirtualItemStateProviders and added some clarifying comments

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@328088 13f79535-47bb-0310-9956-ffa450edef68

- * Shared <code>ItemStateManager</code>. Caches objects returned from a
+ * Shared <code>ItemStateManager</code> (SISM). Caches objects returned from a
+ * <p/>
+ * A shared item state manager operates on a <code>PersistenceManager</code>
+ * (PM) that is used to load and store the item states. Additionally, a SISM can
+ * have <code>VirtualItemStateProvider</code>s (VISP) that are used to provide
+ * additional, non-persistent, read-only states. Examples of VISP are the
+ * content representation of the NodeTypes (/jcr:system/jcr:nodeTypes) and the
+ * version store (/jcr:system/jcr:versionStore). those 2 VISP are added to the
+ * SISM during initialization of a workspace. i.e. they are 'mounted' to all
+ * workspaces. we assume, that VISP cannot be added dynamically, neither during
+ * runtime nor by configuration.
+ * <p/>
+ * The states from the VISP are readonly. by the exception for node references.
+ * remember that the referrers are stored in a {@link NodeReferences} state,
+ * having the ID of the target state.
+ * <br/>
+ * there are 5 types of referential relations to be distinguished:
+ * <ol>
+ * <li> normal --> normal (references from 'normal' states to 'normal' states)
+ *      this is the normal case and will be handled by the SISM.
+ *
+ * <li> normal --> virtual (references from 'normal' states to 'virtual' states)
+ *      those references should be handled by the VISP rather by the SISM.
+ *
+ * <li> virtual --> normal (references from 'virtual' states to 'normal' states)
+ *      such references are not supported. eg. references of versioned nodes do
+ *      not impose any constraints on the referenced nodes.
+ *
+ * <li> virtual --> virtual (references from 'virtual' states to 'virtual'
+ *      states of the same VISP).
+ *      intra-virtual references are handled by the item state manager of the VISP.
+ *
+ * <li> virtual --> virtual' (references from 'virtual' states to 'virtual'
+ *      states of different VISP).
+ *      those do currently not occurr and are therfor not supported.
+ * </ol>
+ * <p/>
+ * if VISP are not dynamic, there is not risk that NV-type references can dangle
+ * (since a VISP cannot be 'unmounted', leaving eventual references dangling).
+ * although multi-workspace-referrers are not explicitelt supported, the
+ * architecture of <code>NodeReferences</code> support multiple referrers with
+ * the same PropertyId. So the number of references can be tracked (an example
+ * of multi-workspace-refferres is a version referenced by the jcr:baseVersion
+ * of several (corresponding) nodes in multiple workspaces).
+ * <br/>
+ * As mentioned, VN-type references should not impose any constraints on the
+ * referrers (e.g. a normal node referenced by a versioned reference property).
+ * In case of the version store, the VN-type references are not stored at
+ * all, but reinforced as NN-type references in the normal states in case of a
+ * checkout operation.
+ * <br/>
+ * VV-type references should be handled by the respective VISP. they look as
+ * NN-type references in the scope if the VISP anyway...so no special treatment
+ * should be neccessairy.
+ * <br/>
+ * VV'-type references are currently not possible, since the version store and
+ * virtual nodetype representation don't allow such references.
-         * array of lists of dirty virtual node references
-         * (one array element per provider)
+         * array of lists of dirty virtual node references per virtual provider.
+         * since NV-type references must be persisted via the respective VISP
+         * and not by the SISM, they are filtered out below.
+         *
+         *       VISP are eventually replaced by a more general 'mounting'
+         *       mechanism, probably on the API level and not on the item state
+         *       layer.
+
+                // (see comment above)
-                    NodeId id = new NodeId(refs.getUUID());
+                    NodeId id = new NodeId(refs.getUUID());
-                    if (virtual) {
-                        continue;
+                    if (!virtual) {
+                        // if target of node reference does not lie in a virtual
+                        // space, add to modified set of normal provider.
+                        shared.modified(refs);
-                    shared.modified(refs);
-            if (!refs.hasReferences()) {
-                // no need to check existence of target if there are
-                // no references
-                continue;
-            }
-            for (int i = 0; i < virtualProviders.length; i++) {
-                VirtualItemStateProvider provider = virtualProviders[i];
-                if (provider.hasItemState(id)) {
-                    refs = null;
-                    break;
-                }
-            }
-            if (refs != null) {
+            // no need to check existence of target if there are no references
+            if (refs.hasReferences()) {
+                // please note:
+                // virtual providers are indirectly checked via 'hasItemState()'

UPD66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 MOV32 MOV60 INS38 INS42 MOV21 DEL42 DEL18 DEL38 DEL18 DEL8 DEL25 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL42 DEL42 DEL2 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL33 DEL7 DEL21 DEL10 DEL8 DEL25 DEL8 DEL24 DEL42 DEL33 DEL27
JCR-255 Workspace operations (copy/clone) do not handle references correctly

consolidated code that maintains/enforces referential integrity (RI):
SharedItemStateManager.store(ChangeLog) is now the only place where
RI is maintained and enforced

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@326916 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.state.NodeReferences;
-import org.apache.jackrabbit.core.state.NodeReferencesId;
-import org.apache.jackrabbit.name.MalformedPathException;
-import java.util.HashMap;
-    /**
-     * Get or create a node references object for a given target id.
-     *
-     * @param id target id
-     * @return node references object
-     * @throws ItemStateException if an error occurs
-     */
-    protected NodeReferences getOrCreateNodeReferences(NodeReferencesId id)
-            throws ItemStateException {
-
-        if (stateMgr.hasNodeReferences(id)) {
-            return stateMgr.getNodeReferences(id);
-        }
-        return new NodeReferences(id);
-    }
-
-    private Collection checkReferences(Iterator iterDirty, Iterator iterRemoved)
-            throws ReferentialIntegrityException, RepositoryException {
-
-        // map of target (node) id's and modified NodeReferences objects
-        HashMap dirtyNodeRefs = new HashMap();
-
-        // walk through dirty items and process REFERENCE properties:
-        // 1. verify that target node exists
-        // 2. update and collect the affected NodeReferences objects of the
-        //    target nodes in the dirtyNodeRefs map
-        while (iterDirty.hasNext()) {
-            ItemState transientState = (ItemState) iterDirty.next();
-            if (!transientState.isNode()) {
-                PropertyState propState = (PropertyState) transientState;
-                int type = propState.getType();
-                if (propState.getStatus() == ItemState.STATUS_EXISTING_MODIFIED) {
-                    // this is a modified property, check old type...
-                    PropertyState oldPropState = (PropertyState) propState.getOverlayedState();
-                    int oldType = oldPropState.getType();
-                    if (oldType == PropertyType.REFERENCE) {
-                        // this is a modified REFERENCE property:
-                        // remove the 'reference' stored in the old value
-                        InternalValue[] vals = oldPropState.getValues();
-                        for (int i = 0; vals != null && i < vals.length; i++) {
-                            String uuid = vals[i].toString();
-                            NodeReferencesId id = new NodeReferencesId(uuid);
-                            NodeReferences refs;
-                            if (dirtyNodeRefs.containsKey(id)) {
-                                refs = (NodeReferences) dirtyNodeRefs.get(id);
-                            } else {
-                                try {
-                                    refs = getOrCreateNodeReferences(id);
-                                } catch (ItemStateException e) {
-                                    String msg = itemMgr.safeGetJCRPath(id)
-                                            + ": failed to load node references";
-                                    log.debug(msg);
-                                    throw new RepositoryException(msg, e);
-                                }
-                                dirtyNodeRefs.put(id, refs);
-                            }
-                            // remove reference from target node
-                            refs.removeReference((PropertyId) propState.getId());
-                        }
-                    }
-                }
-                if (type == PropertyType.REFERENCE) {
-                    // this is a modified REFERENCE property:
-                    // add the 'reference' stored in the new value
-                    InternalValue[] vals = propState.getValues();
-                    for (int i = 0; vals != null && i < vals.length; i++) {
-                        String uuid = vals[i].toString();
-                        NodeReferencesId refsId = new NodeReferencesId(uuid);
-                        NodeId targetId = new NodeId(uuid);
-                        // verify that target exists
-                        if (!itemMgr.itemExists(targetId)) {
-                            String msg = itemMgr.safeGetJCRPath(propState.getId())
-                                    + ": target node of REFERENCE property does not exist";
-                            log.warn(msg);
-                            throw new ReferentialIntegrityException(msg);
-                        }
-                        // target is a new (unsaved) node; make sure that it is
-                        // within the scope of the current save operation
-                        // (by veryfying that it is a descendant of 'this' item)
-                        NodeImpl target = (NodeImpl) itemMgr.getItem(targetId);
-                        if (target.isNew()) {
-                            try {
-                                if (!target.getPrimaryPath().isDescendantOf(getPrimaryPath())) {
-                                    String msg = itemMgr.safeGetJCRPath(propState.getId())
-                                            + ": target node of REFERENCE property is a new node and must"
-                                            + " therefore either be saved first or be within the scope of"
-                                            + " the current save operation.";
-                                    log.warn(msg);
-                                    throw new ReferentialIntegrityException(msg);
-                                }
-                            } catch (MalformedPathException mpe) {
-                                // should never get here...
-                                String msg = itemMgr.safeGetJCRPath(propState.getId())
-                                        + ": failed to verify existence of target node";
-                                log.debug(msg);
-                                throw new RepositoryException(msg, mpe);
-                            }
-                        }
-                        NodeReferences refs;
-                        if (dirtyNodeRefs.containsKey(refsId)) {
-                            refs = (NodeReferences) dirtyNodeRefs.get(refsId);
-                        } else {
-                            try {
-                                refs = getOrCreateNodeReferences(refsId);
-                            } catch (ItemStateException e) {
-                                String msg = itemMgr.safeGetJCRPath(targetId)
-                                        + ": failed to load node references";
-                                log.debug(msg);
-                                throw new RepositoryException(msg, e);
-                            }
-                            dirtyNodeRefs.put(refsId, refs);
-                        }
-                        // add reference to target node
-                        refs.addReference((PropertyId) propState.getId());
-                    }
-                }
-            }
-        }
-
-        // walk through 'removed' items:
-        // 1. build list of removed nodes
-        // 2. process REFERENCE properties (update and collect the affected
-        //    NodeReferences objects of the target nodes)
-        ArrayList removedNodes = new ArrayList();
-        while (iterRemoved.hasNext()) {
-            ItemState transientState = (ItemState) iterRemoved.next();
-            if (transientState.isNode()) {
-                // removed node: collect for later processing
-                removedNodes.add(transientState);
-            } else {
-                PropertyState propState = (PropertyState) transientState;
-                if (propState.getType() == PropertyType.REFERENCE) {
-                    // this is a removed REFERENCE property:
-                    // remove the 'reference' stored in the value
-                    InternalValue[] vals = propState.getValues();
-                    for (int i = 0; i < vals.length; i++) {
-                        String uuid = vals[i].toString();
-                        NodeReferencesId id = new NodeReferencesId(uuid);
-                        NodeReferences refs;
-                        if (dirtyNodeRefs.containsKey(id)) {
-                            refs = (NodeReferences) dirtyNodeRefs.get(id);
-                        } else {
-                            try {
-                                refs = getOrCreateNodeReferences(id);
-                            } catch (ItemStateException e) {
-                                String msg = itemMgr.safeGetJCRPath(id)
-                                        + ": failed to load node references";
-                                log.debug(msg);
-                                throw new RepositoryException(msg, e);
-                            }
-                            dirtyNodeRefs.put(id, refs);
-                        }
-                        // remove reference to target node
-                        refs.removeReference((PropertyId) propState.getId());
-                    }
-                }
-            }
-        }
-
-        // now that all NodeReferences objects have been updated,
-        // walk through 'removed' nodes and verify that no node that is still
-        // being referenced is removed
-        Iterator iter = removedNodes.iterator();
-        while (iter.hasNext()) {
-            NodeState nodeState = (NodeState) iter.next();
-            // check if node is referenced
-            NodeReferencesId id = new NodeReferencesId(nodeState.getUUID());
-            NodeReferences refs = null;
-            if (dirtyNodeRefs.containsKey(id)) {
-                refs = (NodeReferences) dirtyNodeRefs.get(id);
-            } else {
-                try {
-                    if (stateMgr.hasNodeReferences(id)) {
-                        refs = stateMgr.getNodeReferences(id);
-                    }
-                } catch (ItemStateException e) {
-                    String msg = itemMgr.safeGetJCRPath(id)
-                            + ": failed to load node references";
-                    log.debug(msg);
-                    throw new RepositoryException(msg, e);
-                }
-            }
-            if (refs != null && refs.hasReferences()) {
-                String msg = nodeState.getId()
-                        + ": the node cannot be removed because it is being referenced.";
-                log.warn(msg);
-                throw new ReferentialIntegrityException(msg);
-            }
-        }
-
-        // return dirty NodeReferences objects
-        return dirtyNodeRefs.values();
-    }
-
-            /**
-             * referential integrity checks:
-             * make sure that a referenced node cannot be removed and
-             * that all references are updated and persisted
-             */
-            Collection dirtyRefs =
-                    checkReferences(dirty.iterator(), removed.iterator());
-
-
-                    // and the references as well
-                    dirtyRefs = checkReferences(dirty.iterator(), removed.iterator());
-                // store the references calculated above
-                for (Iterator it = dirtyRefs.iterator(); it.hasNext();) {
-                    stateMgr.store((NodeReferences) it.next());
-                }
-

DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL14 DEL41 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL32 DEL38 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL40 DEL27 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL40 DEL27 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL33 DEL27 DEL42 DEL40 DEL27 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL42 DEL42 DEL2 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL32 DEL21 DEL8 DEL24 DEL8 DEL25 DEL8 DEL25 DEL42 DEL40 DEL27 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL33 DEL27 DEL42 DEL40 DEL27 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL42 DEL42 DEL2 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL38 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL38 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL45 DEL45 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL25 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL32 DEL21 DEL8 DEL24 DEL8 DEL25 DEL8 DEL25 DEL8 DEL61 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL42 DEL32 DEL40 DEL27 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL42 DEL42 DEL2 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL32 DEL21 DEL8 DEL24 DEL8 DEL25 DEL8 DEL25 DEL8 DEL61 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL8 DEL61 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL7 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL32 DEL21 DEL8 DEL24
Make versioning transactional
- Added specialized XAVersion and XAVersionHistory objects that refresh their internal state when needed
- Defined new observation interface in order to have VersionManagerImpl use standard event dispatching
  instead of writing its own
- Added test cases verifying isolation of versioning operations in transactions


git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@368026 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.observation.ObservationManagerImpl;
+import org.apache.jackrabbit.core.observation.EventStateCollectionFactory;
+import javax.jcr.RepositoryException;
+     * Flag indicating whether this item state manager uses node references to
+     * verify integrity of its reference properties.
+     */
+    private final boolean usesReferences;
+
+    /**
-                                  NodeTypeRegistry ntReg)
+                                  NodeTypeRegistry ntReg,
+                                  boolean usesReferences)
+        this.usesReferences = usesReferences;
-     * Store modifications registered in a <code>ChangeLog</code>. The items
-     * contained in the <tt>ChangeLog</tt> are not states returned by this
-     * item state manager but rather must be reconnected to items provided
-     * by this state manager.<p/>
-     * After successfully storing the states the observation manager is informed
-     * about the changes, if an observation manager is passed to this method.<p/>
-     * NOTE: This method is not synchronized, because all methods it invokes
-     * on instance members (such as {@link PersistenceManager#store} are
-     * considered to be thread-safe. Should this ever change, the
-     * synchronization status has to be re-examined.
-     *
-     * @param local  change log containing local items
-     * @param obsMgr the observation manager to inform, or <code>null</code> if
-     *               no observation manager should be informed.
-     * @throws ReferentialIntegrityException if a new or modified REFERENCE
-     *                                       property refers to a non-existent
-     *                                       target or if a removed node is still
-     *                                       being referenced
-     * @throws StaleItemStateException       if at least one of the affected item
-     *                                       states has become stale
-     * @throws ItemStateException            if another error occurs
+     * Object representing a single update operation.
-    public void store(ChangeLog local, ObservationManagerImpl obsMgr)
-            throws ReferentialIntegrityException, StaleItemStateException,
-            ItemStateException {
-
-        ChangeLog shared = new ChangeLog();
+    class Update {
-         * array of lists of dirty virtual node references per virtual provider.
-         * since NV-type references must be persisted via the respective VISP
-         * and not by the SISM, they are filtered out below.
-         *
-         * todo: FIXME handling of virtual node references is erm...  messy
-         *       VISP are eventually replaced by a more general 'mounting'
-         *       mechanism, probably on the API level and not on the item state
-         *       layer.
+         * Local change log.
-        List[] virtualNodeReferences = new List[virtualProviders.length];
+        private final ChangeLog local;
-        EventStateCollection events = null;
-        if (obsMgr != null) {
-            events = obsMgr.createEventStateCollection();
-            events.prepareDeleted(local);
+        /**
+         * Event state collection factory.
+         */
+        private final EventStateCollectionFactory factory;
+
+        /**
+         * Virtual provider containing references to be left out when updating
+         * references.
+         */
+        private final VirtualItemStateProvider virtualProvider;
+
+        /**
+         * Shared change log.
+         */
+        private ChangeLog shared;
+
+        /**
+         * Virtual node references.
+         */
+        private List[] virtualNodeReferences;
+
+        /**
+         * Events to dispatch.
+         */
+        private EventStateCollection events;
+
+        /**
+         * Create a new instance of this class.
+         */
+        public Update(ChangeLog local, EventStateCollectionFactory factory,
+                      VirtualItemStateProvider virtualProvider) {
+            this.local = local;
+            this.factory = factory;
+            this.virtualProvider = virtualProvider;
-        acquireWriteLock();
-        boolean holdingWriteLock = true;
+        /**
+         * Begin update operation. Prepares everything upto the point where
+         * the persistence manager's <code>store</code> method may be invoked.
+         * If this method succeeds, a write lock will have been acquired on the
+         * item state manager and either {@link #end()} or {@link #cancel()} has
+         * to be called in order to release it.
+         */
+        public void begin() throws ItemStateException, ReferentialIntegrityException {
+            shared = new ChangeLog();
-        try {
-            /**
-             * Update node references based on modifications in change log
-             * (added/modified/removed REFERENCE properties)
-             */
-            updateReferences(local);
-            /**
-             * Check whether reference targets exist/were not removed
-             */
-            checkReferentialIntegrity(local);
+            virtualNodeReferences = new List[virtualProviders.length];
+
+            try {
+                events = factory.createEventStateCollection();
+            } catch (RepositoryException e) {
+                String msg = "Unable to create event state collection.";
+                log.error(msg);
+                throw new ItemStateException(msg, e);
+            }
+
+            acquireWriteLock();
+                if (usesReferences) {
+                    /**
+                     * Update node references based on modifications in change log
+                     * (added/modified/removed REFERENCE properties)
+                     */
+                    updateReferences(local, virtualProvider);
+                }
+
+                /**
+                 * Check whether reference targets exist/were not removed
+                 */
+                checkReferentialIntegrity(local);
+
-                if (events != null) {
-                    events.createEventStates(rootNodeUUID, local, this);
-                }
+                events.createEventStates(rootNodeUUID, local,
+                        SharedItemStateManager.this);
+                succeeded = true;
+
+            } finally {
+                if (!succeeded) {
+                    cancel();
+                }
+            }
+        }
+
+        /**
+         * End update operation. This will store the changes to the associated
+         * <code>PersistenceManager</code>. At the end of this operation, an
+         * eventual read or write lock on the item state manager will have
+         * been released.
+         * @throws ItemStateException if some error occurs
+         */
+        public void end() throws ItemStateException {
+            boolean succeeded = false;
+
+            try {
+            } finally {
+                if (!succeeded) {
+                    cancel();
+                }
+            }
+
+            boolean holdingWriteLock = true;
+
+            try {
+                /* Let the shared item listeners know about the change */
+                shared.persisted();
+
+                /* notify virtual providers about node references */
+                for (int i = 0; i < virtualNodeReferences.length; i++) {
+                    List virtualRefs = virtualNodeReferences[i];
+                    if (virtualRefs != null) {
+                        for (Iterator iter = virtualRefs.iterator(); iter.hasNext();) {
+                            NodeReferences refs = (NodeReferences) iter.next();
+                            virtualProviders[i].setNodeReferences(refs);
+                        }
+                    }
+                }
+
+                // downgrade to read lock
+                acquireReadLock();
+                rwLock.writeLock().release();
+                holdingWriteLock = false;
+
+                /* dispatch the events */
+                events.dispatch();
-
-                /**
-                 * If some store operation was unsuccessful, we have to reload
-                 * the state of modified and deleted items from persistent
-                 * storage.
-                 */
-                if (!succeeded) {
-                    local.disconnect();
-
-                    for (Iterator iter = shared.modifiedStates(); iter.hasNext();) {
-                        ItemState state = (ItemState) iter.next();
-                        try {
-                            state.copy(loadItemState(state.getId()));
-                        } catch (ItemStateException e) {
-                            state.discard();
-                        }
-                    }
-                    for (Iterator iter = shared.deletedStates(); iter.hasNext();) {
-                        ItemState state = (ItemState) iter.next();
-                        try {
-                            state.copy(loadItemState(state.getId()));
-                        } catch (ItemStateException e) {
-                            state.discard();
-                        }
-                    }
-                    for (Iterator iter = shared.addedStates(); iter.hasNext();) {
-                        ItemState state = (ItemState) iter.next();
-                        state.discard();
-                    }
+                if (holdingWriteLock) {
+                    // exception occured before downgrading lock
+                    rwLock.writeLock().release();
+                } else {
+                    rwLock.readLock().release();
-
-            /* Let the shared item listeners know about the change */
-            shared.persisted();
-
-            /* notify virtual providers about node references */
-            for (int i = 0; i < virtualNodeReferences.length; i++) {
-                List virtualRefs = virtualNodeReferences[i];
-                if (virtualRefs != null) {
-                    for (Iterator iter = virtualRefs.iterator(); iter.hasNext();) {
-                        NodeReferences refs = (NodeReferences) iter.next();
-                        virtualProviders[i].setNodeReferences(refs);
-                    }
-                }
-            }
-
-            // downgrade to read lock
-            acquireReadLock();
-            rwLock.writeLock().release();
-            holdingWriteLock = false;
-
-            /* dispatch the events */
-            if (events != null) {
-                events.dispatch();
-            }
-        } finally {
-            if (holdingWriteLock) {
-                // exception occured before downgrading lock
-                rwLock.writeLock().release();
-            } else {
-                rwLock.readLock().release();
-            }
+
+        /**
+         * Cancel update operation. At the end of this operation, the write lock
+         * on the item state manager will have been released.
+         */
+        public void cancel() {
+            local.disconnect();
+
+            for (Iterator iter = shared.modifiedStates(); iter.hasNext();) {
+                ItemState state = (ItemState) iter.next();
+                try {
+                    state.copy(loadItemState(state.getId()));
+                } catch (ItemStateException e) {
+                    state.discard();
+                }
+            }
+            for (Iterator iter = shared.deletedStates(); iter.hasNext();) {
+                ItemState state = (ItemState) iter.next();
+                try {
+                    state.copy(loadItemState(state.getId()));
+                } catch (ItemStateException e) {
+                    state.discard();
+                }
+            }
+            for (Iterator iter = shared.addedStates(); iter.hasNext();) {
+                ItemState state = (ItemState) iter.next();
+                state.discard();
+            }
+            rwLock.writeLock().release();
+        }
+    }
+
+    /**
+     * Begin update operation. This will return an object that can itself be
+     * ended/cancelled.
+     */
+    public Update beginUpdate(ChangeLog local, EventStateCollectionFactory factory,
+                              VirtualItemStateProvider virtualProvider)
+            throws ReferentialIntegrityException, StaleItemStateException,
+                   ItemStateException {
+
+        Update update = new Update(local, factory, virtualProvider);
+        update.begin();
+        return update;
+    }
+
+    /**
+     * Store modifications registered in a <code>ChangeLog</code>. The items
+     * contained in the <tt>ChangeLog</tt> are not states returned by this
+     * item state manager but rather must be reconnected to items provided
+     * by this state manager.<p/>
+     * After successfully storing the states the observation manager is informed
+     * about the changes, if an observation manager is passed to this method.<p/>
+     * NOTE: This method is not synchronized, because all methods it invokes
+     * on instance members (such as {@link PersistenceManager#store} are
+     * considered to be thread-safe. Should this ever change, the
+     * synchronization status has to be re-examined.
+     *
+     * @param local   change log containing local items
+     * @param factory event state collection factory
+     * @throws ReferentialIntegrityException if a new or modified REFERENCE
+     *                                       property refers to a non-existent
+     *                                       target or if a removed node is still
+     *                                       being referenced
+     * @throws StaleItemStateException       if at least one of the affected item
+     *                                       states has become stale
+     * @throws ItemStateException            if another error occurs
+     */
+    public void update(ChangeLog local, EventStateCollectionFactory factory)
+            throws ReferentialIntegrityException, StaleItemStateException,
+                   ItemStateException {
+
+        beginUpdate(local, factory, null).end();
+     * @param virtualProvider virtual provider that may already contain a
+     *                        node references object
-    protected void updateReferences(ChangeLog changes) throws ItemStateException {
+    protected void updateReferences(ChangeLog changes, 
+                                    VirtualItemStateProvider virtualProvider) 
+            throws ItemStateException {
+                        if (virtualProvider != null && 
+                                virtualProvider.hasNodeReferences(refsId)) {
+                            continue;
+                        }
+                        if (virtualProvider != null && 
+                                virtualProvider.hasNodeReferences(refsId)) {
+                            continue;
+                        }
+                        if (virtualProvider != null && 
+                                virtualProvider.hasNodeReferences(refsId)) {
+                            continue;
+                        }
+                        if (virtualProvider != null && 
+                                virtualProvider.hasNodeReferences(refsId)) {
+                            continue;
+                        }

INS26 UPD40 INS40 INS23 INS55 INS31 INS31 INS29 INS83 INS83 INS39 INS59 INS44 INS29 INS42 INS23 INS23 INS23 INS23 INS23 INS23 INS31 MOV31 MOV43 INS31 INS31 INS29 INS83 INS43 INS42 INS44 INS44 INS44 INS43 INS43 INS43 INS8 MOV29 INS83 INS39 INS42 MOV44 INS44 INS43 MOV43 INS43 INS8 INS44 INS65 INS42 INS39 INS42 INS21 INS65 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS43 INS59 INS29 INS83 MOV43 INS59 INS29 INS83 MOV5 INS59 INS29 INS83 MOV43 INS59 INS29 INS83 INS42 INS44 INS44 INS44 INS8 INS29 INS42 MOV8 INS29 INS83 INS39 INS42 INS43 INS8 INS29 INS83 INS39 INS42 MOV8 INS65 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS42 INS60 INS21 INS41 INS43 INS42 INS42 INS42 INS21 INS65 INS43 INS42 INS66 INS66 INS7 INS66 INS65 INS42 INS42 INS65 INS42 INS42 INS65 INS42 INS42 INS65 INS42 INS65 INS42 INS65 INS42 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS21 INS21 INS21 INS65 INS21 INS21 INS54 MOV21 INS65 INS65 INS42 INS60 INS54 MOV60 INS54 INS65 INS21 INS66 INS66 INS42 INS42 INS42 INS43 INS59 INS32 INS42 UPD66 UPD42 UPD66 INS42 INS32 INS42 INS66 INS66 INS42 INS22 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS42 INS7 INS7 INS7 INS66 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS7 INS7 INS8 INS12 INS66 INS66 INS66 INS66 INS42 INS66 INS39 INS59 INS8 INS8 INS8 MOV8 INS66 INS66 INS32 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS52 INS42 INS22 INS42 INS22 INS42 INS22 INS42 INS68 INS68 INS42 MOV14 INS42 MOV3 MOV21 INS44 INS8 INS25 MOV21 MOV21 INS42 INS9 MOV60 MOV21 INS21 MOV60 MOV25 INS25 MOV21 MOV24 MOV21 INS21 MOV21 MOV21 MOV32 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS7 INS43 INS42 INS60 MOV21 INS53 INS42 INS8 INS8 INS7 INS38 INS8 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS43 INS59 INS14 INS21 INS21 INS42 INS9 INS42 INS21 INS32 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS45 UPD42 MOV42 UPD42 MOV42 UPD42 INS43 INS42 INS42 INS32 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS25 INS25 INS25 INS25 INS27 INS8 INS27 INS8 INS27 INS8 INS27 INS8 INS27 INS32 INS18 INS27 INS32 INS18 INS27 INS32 INS18 INS27 INS32 INS18 INS42 INS33 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS42 DEL42 DEL42 DEL43 DEL42 DEL44 DEL32 DEL42 DEL33 DEL27 DEL8 DEL25 DEL42 DEL33 DEL27 DEL8 DEL25 DEL42 DEL59 DEL60 DEL42 DEL59 DEL60 DEL42 DEL33 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL54 DEL8 DEL66
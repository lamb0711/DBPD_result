JCR-3506 only load nodes once in batches. Because now despite the additional check overall performance has actually increased it is not necessary to be able to skip the reverse check anymore.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1442061 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.HashMap;
+import java.util.Map;
-    /**
-     * Whether to check whether all the nodes that are in the repository are indexed.
-     * When false only the check is made whether all nodes in the index are also in the repository.
-     */
-    private static final boolean CHECKREVERSE = Boolean.getBoolean("org.apache.jackrabbit.checker.index.reverse");
-
-     * All the document ids within the index.
+     * All the node ids and whether they were found in the index.
-    private Set<NodeId> documentIds;
+    private Map<NodeId, Boolean> nodeIds;
-        checkIndexToItems();
-        checkItemsToIndex();
+        loadNodes();
+        if (nodeIds != null) {
+            checkIndexConsistency();
+            checkIndexCompleteness();
+        }
-    private void checkIndexToItems() throws IOException {
+    private void loadNodes() {
+        log.info("Loading nodes");
+        try {
+            int count = 0;
+            Map<NodeId, Boolean> nodeIds = new HashMap<NodeId, Boolean>();
+            List<NodeId> batch = pm.getAllNodeIds(null, NODESATONCE);
+            while (!batch.isEmpty()) {
+                NodeId lastId = null;
+                for (NodeId nodeId : batch) {
+                    lastId = nodeId;
+
+                    count++;
+                    if (count % 1000 == 0) {
+                        log.info(pm + ": loaded " + count + " node ids...");
+                    }
+
+                    nodeIds.put(nodeId, Boolean.FALSE);
+
+                }
+                batch = pm.getAllNodeIds(lastId, NODESATONCE);
+            }
+            this.nodeIds = nodeIds;
+        } catch (ItemStateException e) {
+            log.error("Exception while loading items to check", e);
+        } catch (RepositoryException e) {
+            log.error("Exception while loading items to check", e);
+        }
+    }
+
+    private void checkIndexConsistency() throws IOException {
-        // collect all documents ids
-        documentIds = new HashSet<NodeId>();
-                if (stateMgr.hasItemState(id)) {
-                    if (!documentIds.add(id)) {
+                Boolean alreadyIndexed = nodeIds.put(id, Boolean.TRUE);
+                boolean nodeExists = alreadyIndexed != null;
+                if (nodeExists) {
+                    if (alreadyIndexed) {
-                if (parentId == null || documentIds.contains(parentId)) {
+
+                boolean parentExists = parentId != null && nodeIds.containsKey(parentId);
+                boolean parentIndexed = parentExists && nodeIds.get(parentId);
+                if (parentId == null || parentIndexed) {
+
-                if (stateMgr.hasItemState(parentId)) {
+                if (parentExists) {
+
-    private void checkItemsToIndex() {
-        if (!CHECKREVERSE) {
-            return;
-        }
-        if (pm == null) {
-            log.warn("Cannot run reverse index check with this PersistenceManager");
-            return;
-        }
+    private void checkIndexCompleteness() {
-        try {
-            int count = 0;
-            List<NodeId> batch = pm.getAllNodeIds(null, NODESATONCE);
-            while (!batch.isEmpty()) {
-                NodeId lastId = null;
-                for (NodeId nodeId : batch) {
-                    lastId = nodeId;
-
-                    count++;
-                    if (count % 1000 == 0) {
-                        log.info(pm + ": checked " + count + " node ids...");
+        int i = 0;
+        int size = nodeIds.size();
+        for (Map.Entry<NodeId, Boolean> entry : nodeIds.entrySet()) {
+            // check whether all nodes in the repository are indexed
+            NodeId nodeId = entry.getKey();
+            boolean indexed = entry.getValue();
+            try {
+                if (++i > 10 && i % (size / 10) == 0) {
+                    long progress = Math.round((100.0 * (float) i) / (float) size);
+                    log.info("progress: " + progress + "%");
+                }
+                if (!indexed && !isExcluded(nodeId)) {
+                    NodeState nodeState = getNodeState(nodeId);
+                    if (nodeState != null && !isBrokenNode(nodeId, nodeState)) {
+                        errors.add(new NodeAdded(nodeId));
-
-                    checkNode(nodeId);
-
-                batch = pm.getAllNodeIds(lastId, NODESATONCE);
+            } catch (ItemStateException e) {
+                log.error("Failed to check node: " + nodeId, e);
-        } catch (ItemStateException e) {
-            log.error("Exception while loading items to check", e);
-        } catch (RepositoryException e) {
-            log.error("Exception while loading items to check", e);
-        }
-
-    }
-
-    private void checkNode(final NodeId nodeId) {
-        try {
-            if (!documentIds.contains(nodeId) && !isExcluded(nodeId)) {
-                NodeState nodeState = getNodeState(nodeId);
-                if (nodeState != null && !isBrokenNode(nodeId, nodeState)) {
-                    errors.add(new NodeAdded(nodeId));
-                }
-            }
-        } catch (ItemStateException e) {
-            log.error("Failed to check node: " + nodeId, e);
-        StringBuffer path = new StringBuffer();
+        StringBuilder path = new StringBuilder();
-            while (ancestorId != null && !documentIds.contains(ancestorId)) {
+            while (ancestorId != null && nodeIds.containsKey(ancestorId) && nodeIds.get(ancestorId)) {
-                    documentIds.add(n.getNodeId());
+                    nodeIds.put(n.getNodeId(), Boolean.TRUE);
-                documentIds.add(node.getNodeId());
+                nodeIds.put(node.getNodeId(), Boolean.TRUE);

INS26 INS26 MOV31 INS40 INS40 UPD74 UPD42 UPD42 UPD42 INS8 UPD43 INS43 UPD42 INS21 INS25 MOV21 MOV21 INS60 INS60 INS70 UPD66 UPD42 INS42 INS32 INS27 INS8 INS39 INS59 INS39 INS59 INS44 INS32 MOV8 UPD43 INS42 INS42 INS33 MOV21 MOV21 UPD42 UPD45 INS60 INS21 INS42 INS34 INS42 INS32 INS74 INS42 INS42 INS42 INS60 INS60 UPD42 INS27 INS74 INS59 INS7 INS42 INS42 INS43 MOV43 INS43 INS43 INS59 INS39 INS59 UPD43 INS27 INS32 UPD42 UPD42 INS43 INS43 INS43 INS42 INS14 INS22 INS42 INS60 INS60 INS60 INS60 INS40 INS42 INS42 INS42 INS32 INS42 INS32 INS25 UPD42 MOV27 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS74 INS52 INS42 INS43 INS59 INS39 INS59 INS42 INS39 INS59 INS39 INS59 INS42 INS42 INS42 INS42 INS42 INS27 INS8 UPD42 MOV42 UPD42 MOV42 MOV42 UPD42 UPD42 INS40 INS43 MOV43 INS43 INS42 INS42 INS32 INS42 INS27 INS42 INS27 INS42 INS27 INS42 INS27 INS27 INS60 INS21 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS33 INS42 INS27 INS32 INS42 INS32 INS38 INS34 INS27 INS34 INS39 INS59 INS32 INS42 UPD42 UPD42 INS40 UPD42 INS42 INS40 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS36 INS42 INS32 INS42 INS42 INS27 INS27 INS42 INS42 INS27 INS45 INS42 INS45 INS42 INS34 INS36 INS11 UPD45 INS27 INS39 INS42 INS34 INS11 INS39 INS42 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL45 DEL32 DEL59 DEL23 DEL42 DEL38 DEL41 DEL8 DEL25 DEL42 DEL33 DEL27 DEL41 DEL8 DEL25 DEL42 DEL42 DEL43 DEL74 DEL14 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL83 DEL42 DEL44 DEL32 DEL38 DEL27
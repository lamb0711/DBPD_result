work in progress

- removeVersion missing
- LockManager/VersionManager: should not rely on observation (todo added)
- Add Operation.persisted() (Impl. still missing) in analogy to ChangeLog.persisted.
- ItemImpl.refresh behaves according to CacheBehaviour flag.
- NodeState: fix classcastexception when accessing state from propertiesInAttic
- ItemState: rename 'refresh()' to 'reload()
- ItemState: move code common to PropertyState and NodeState to ItemState
- ItemState: rename 'reset' to 'merge'
- add common interface ChildItemEntry
- SessionItemStateManager: avoid traversing twice during 'undo'

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@477095 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.operation.RemoveVersion;
+import javax.jcr.ReferentialIntegrityException;
-        Sync eventSignal;
-        synchronized (updateMonitor) {
+        if (cacheBehaviour == CacheBehaviour.OBSERVATION) {
+            Sync eventSignal;
+            synchronized (updateMonitor) {
+                new OperationVisitorImpl(sessionInfo).execute(operation);
+                eventSignal = getEventPollingRequest();
+            }
+            try {
+                eventSignal.acquire();
+            } catch (InterruptedException e) {
+                Thread.interrupted();
+                log.warn("Interrupted while waiting for events from RepositoryService");
+            }
+        } else {
+            // execute operation and delegate invalidation of affected item
+            // states to the operation.
-            eventSignal = getEventPollingRequest();
-        }
-        try {
-            eventSignal.acquire();
-        } catch (InterruptedException e) {
-            Thread.interrupted();
-            log.warn("Interrupted while waiting for events from RepositoryService");
+            operation.persisted();
-        Sync eventSignal;
-        synchronized (updateMonitor) {
+        if (cacheBehaviour == CacheBehaviour.OBSERVATION) {
+            // TODO: TOBEFIXED. processing events after changelog may lead to consistency problems (duplicate processing) (e.g. removal of SNSs).
+            // TODO: filtering of events required according to information present in the changelog.
+            Sync eventSignal;
+            synchronized (updateMonitor) {
+                new OperationVisitorImpl(sessionInfo).execute(changes);
+                changes.persisted();
+                eventSignal = getEventPollingRequest();
+            }
+            try {
+                eventSignal.acquire();
+            } catch (InterruptedException e) {
+                Thread.interrupted();
+                log.warn("Interrupted while waiting for events from RepositoryService");
+            }
+        } else {
-            eventSignal = getEventPollingRequest();
-        }
-        try {
-            eventSignal.acquire();
-        } catch (InterruptedException e) {
-            Thread.interrupted();
-            log.warn("Interrupted while waiting for events from RepositoryService");
+    /**
+     * Dispose this <code>WorkspaceManager</code>
+     */
-     * @param events the events generated by the repository service as the
-     *               effect of a change.
+     * @param eventBundles the event bundles generated by the repository service
+     * as the effect of an local or external change.
-    private void onEventReceived(EventBundle[] events) {
+    private void onEventReceived(EventBundle[] eventBundles) {
-        for (int i = 0; i < events.length; i++) {
+        for (int i = 0; i < eventBundles.length; i++) {
-                lstnrs[j].onEvent(events[i]);
+                lstnrs[j].onEvent(eventBundles[i]);
+
+        public void visit(RemoveVersion operation) throws VersionException, AccessDeniedException, ReferentialIntegrityException, RepositoryException {
+            NodeState versionState = (NodeState) operation.getRemoveState();
+            NodeState vhState = operation.getParentState();
+            service.removeVersion(sessionInfo, vhState.getNodeId(), versionState.getNodeId());
+        }
-
-
+                        long timeout = 0;
-                        EventBundle[] bundles = service.getEvents(sessionInfo,
-                                0, (EventFilter[]) filters.toArray(
-                                        new EventFilter[filters.size()]));
+                        EventFilter[] filtArr = (EventFilter[]) filters.toArray(new EventFilter[filters.size()]);
+
+                        EventBundle[] bundles = service.getEvents(sessionInfo, timeout, filtArr);

INS26 INS26 INS40 INS40 INS8 INS8 INS29 INS31 INS25 INS25 INS65 UPD42 INS83 INS39 INS42 INS44 INS43 INS43 INS43 INS43 INS8 INS27 MOV8 INS8 INS27 MOV8 INS8 INS66 UPD42 UPD66 UPD66 INS43 INS42 INS42 INS42 INS42 INS42 INS60 INS60 INS21 INS42 INS40 INS21 INS21 INS42 INS40 INS21 INS21 UPD40 INS42 INS43 INS59 INS43 INS59 INS32 INS32 INS32 INS32 INS32 INS42 INS42 INS11 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS32 INS14 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS60 INS60 INS39 INS59 INS5 MOV5 INS59 INS42 INS34 INS43 INS85 UPD42 MOV11 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 DEL42 DEL42 DEL42 DEL34 DEL32
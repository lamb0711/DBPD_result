JCR-1990: Optimize queries with relative path in order by clause

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@746946 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.HierarchyManager;
+import org.apache.jackrabbit.core.state.PropertyState;
+import org.apache.jackrabbit.core.state.ItemStateException;
+import org.apache.lucene.analysis.Token;
+     * The path factory.
+     */
+    protected static final PathFactory PATH_FACTORY = PathFactoryImpl.getInstance();
+
+    /**
-        PathFactory factory = PathFactoryImpl.getInstance();
-        ROOT_PATH = factory.create(NameConstants.ROOT);
+        ROOT_PATH = PATH_FACTORY.create(NameConstants.ROOT);
-            JCR_SYSTEM_PATH = factory.create(ROOT_PATH, NameConstants.JCR_SYSTEM, false);
+            JCR_SYSTEM_PATH = PATH_FACTORY.create(ROOT_PATH, NameConstants.JCR_SYSTEM, false);
+                ItemStateManager ism = getContext().getItemStateManager();
+                    boolean ruleMatched = false;
+                    // node includes
-                    if (aggregates == null) {
-                        continue;
-                    }
-                    for (int j = 0; j < aggregates.length; j++) {
-                        Document aDoc = createDocument(aggregates[j],
-                                getNamespaceMappings(),
-                                index.getIndexFormatVersion());
-                        // transfer fields to doc if there are any
-                        Fieldable[] fulltextFields = aDoc.getFieldables(FieldNames.FULLTEXT);
-                        if (fulltextFields != null) {
-                            for (int k = 0; k < fulltextFields.length; k++) {
-                                doc.add(fulltextFields[k]);
+                    if (aggregates != null) {
+                        ruleMatched = true;
+                        for (int j = 0; j < aggregates.length; j++) {
+                            Document aDoc = createDocument(aggregates[j],
+                                    getNamespaceMappings(),
+                                    index.getIndexFormatVersion());
+                            // transfer fields to doc if there are any
+                            Fieldable[] fulltextFields = aDoc.getFieldables(FieldNames.FULLTEXT);
+                            if (fulltextFields != null) {
+                                for (int k = 0; k < fulltextFields.length; k++) {
+                                    doc.add(fulltextFields[k]);
+                                }
+                                doc.add(new Field(FieldNames.AGGREGATED_NODE_UUID,
+                                        aggregates[j].getNodeId().getUUID().toString(),
+                                        Field.Store.NO,
+                                        Field.Index.NO_NORMS));
-                            doc.add(new Field(FieldNames.AGGREGATED_NODE_UUID,
-                                    aggregates[j].getNodeId().getUUID().toString(),
-                                    Field.Store.NO,
-                                    Field.Index.NO_NORMS));
+                    // property includes
+                    PropertyState[] propStates = aggregateRules[i].getAggregatedPropertyStates(state);
+                    if (propStates != null) {
+                        ruleMatched = true;
+                        for (int j = 0; j < propStates.length; j++) {
+                            PropertyState propState = propStates[j];
+                            String namePrefix = FieldNames.createNamedValue(
+                                    getNamespaceMappings().translateName(propState.getName()), "");
+                            NodeState parent = (NodeState) ism.getItemState(propState.getParentId());
+                            Document aDoc = createDocument(parent, getNamespaceMappings(), getIndex().getIndexFormatVersion());
+                            // find the right fields to transfer
+                            Fieldable[] fields = aDoc.getFieldables(FieldNames.PROPERTIES);
+                            for (int k = 0; k < fields.length; k++) {
+                                Fieldable field = fields[k];
+                                // assume properties fields use SingleTokenStream
+                                Token t = field.tokenStreamValue().next();
+                                String value = new String(t.termBuffer(), 0, t.termLength());
+                                if (value.startsWith(namePrefix)) {
+                                    // extract value
+                                    value = value.substring(namePrefix.length());
+                                    // create new named value
+                                    Path p = getRelativePath(state, propState);
+                                    String path = getNamespaceMappings().translatePath(p);
+                                    value = FieldNames.createNamedValue(path, value);
+                                    t.setTermText(value);
+                                    doc.add(new Field(field.name(), new SingletonTokenStream(t)));
+                                    doc.add(new Field(FieldNames.AGGREGATED_NODE_UUID,
+                                            parent.getNodeId().getUUID().toString(),
+                                            Field.Store.NO,
+                                            Field.Index.NO_NORMS));
+                                }
+                            }
+                        }
+                    }
+
-                    break;
+                    if (ruleMatched) {
+                        break;
+                    }
+     * Returns the relative path from <code>nodeState</code> to
+     * <code>propState</code>.
+     *
+     * @param nodeState a node state.
+     * @param propState a property state.
+     * @return the relative path.
+     * @throws RepositoryException if an error occurs while resolving paths.
+     * @throws ItemStateException  if an error occurs while reading item
+     *                             states.
+     */
+    protected Path getRelativePath(NodeState nodeState, PropertyState propState)
+            throws RepositoryException, ItemStateException {
+        HierarchyManager hmgr = getContext().getHierarchyManager();
+        Path nodePath = hmgr.getPath(nodeState.getId());
+        Path propPath = hmgr.getPath(propState.getId());
+        Path p = nodePath.computeRelativePath(propPath);
+        // make sure it does not contain indexes
+        boolean clean = true;
+        Path.Element[] elements = p.getElements();
+        for (int i = 0; i < elements.length; i++) {
+            if (elements[i].getIndex() != 0) {
+                elements[i] = PATH_FACTORY.createElement(elements[i].getName());
+                clean = false;
+            }
+        }
+        if (!clean) {
+            p = PATH_FACTORY.create(elements);
+        }
+        return p;
+    }
+
+    /**

INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS23 INS31 INS29 INS83 INS83 INS83 MOV43 MOV59 INS29 INS83 INS43 INS42 INS44 INS44 INS43 INS43 INS8 INS65 UPD42 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS60 INS60 INS60 INS60 INS60 INS60 INS24 INS25 INS41 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS39 INS59 INS5 INS59 INS58 INS27 INS37 INS8 INS38 INS8 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS9 INS43 INS85 INS42 INS32 INS39 INS59 INS42 INS40 INS42 INS25 INS42 INS21 UPD42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS34 INS27 INS8 INS7 INS60 INS42 INS42 INS42 INS42 INS42 INS32 INS34 INS21 INS21 INS42 INS32 UPD42 INS43 INS59 INS8 INS2 INS42 INS7 INS7 INS42 INS42 INS42 INS42 INS42 INS32 INS60 MOV60 INS25 INS60 INS25 INS25 INS42 INS42 INS2 INS32 INS42 INS9 INS32 INS42 INS39 INS59 INS27 MOV8 INS5 INS59 INS27 INS8 INS42 INS8 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS9 INS42 INS33 INS21 INS43 INS85 INS42 INS32 INS42 INS33 INS21 INS24 INS10 INS2 INS42 INS7 INS42 INS2 INS42 INS42 INS7 INS58 INS27 INS37 INS8 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS9 INS39 INS59 INS42 INS40 INS42 INS60 INS60 INS60 INS60 INS60 INS24 INS42 INS34 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS5 INS59 INS58 INS27 INS37 INS8 INS42 INS42 INS2 INS42 INS42 INS32 INS42 INS42 INS11 INS42 INS42 INS32 INS43 INS85 INS42 INS32 INS39 INS59 INS42 INS40 INS42 INS60 INS60 INS60 INS25 INS42 INS42 INS42 INS42 INS32 INS45 INS43 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS40 INS42 INS34 INS43 INS59 INS43 INS59 INS43 INS59 INS32 INS8 INS32 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS2 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS42 INS21 INS60 INS60 INS21 INS21 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS43 INS32 INS34 INS32 INS7 INS43 INS59 INS43 INS59 INS7 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS32 INS14 INS43 INS40 INS32 INS40 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 DEL60 DEL42 DEL33 DEL27 DEL18 DEL8 DEL25 DEL10
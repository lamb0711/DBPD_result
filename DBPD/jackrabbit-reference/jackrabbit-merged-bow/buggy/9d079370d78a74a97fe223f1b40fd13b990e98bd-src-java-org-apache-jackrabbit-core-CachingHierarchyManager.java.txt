True caching in CachingHierarchyManager

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@190372 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.collections.ReferenceMap;
+import org.apache.jackrabbit.core.state.ItemState;
+import org.apache.jackrabbit.core.state.ItemStateException;
+import org.apache.jackrabbit.core.state.ItemStateManager;
+import org.apache.jackrabbit.core.state.NodeState;
+import org.apache.jackrabbit.core.state.NodeStateListener;
+import org.apache.log4j.Logger;
+import org.apache.commons.collections.map.ReferenceMap;
-import java.util.Map;
+import java.util.List;
+import java.util.Iterator;
+import java.util.HashSet;
+import java.util.Set;
- * <code>CachingHierarchyManager</code> is a simple wrapper for a
- * <code>HierarchyManager</code> that caches the <code>ItemId</code> to <code>Path</code>
- * mappings returned by the underlying <code>HierarchyManager</code> for better
- * performance.
- * <p/>
- * Please keep in mind that this cache of <code>Path</code>s is not automatically
- * updated when the underlying hierarchy is changing. Therefore it should only be
- * used with caution and in special situations (usually only locally within a
- * narrow scope) where the underlying hierarchy is not expected to change.
+ * Implementation of a <code>HierarchyManager</code> that caches paths of
+ * items.
-public class CachingHierarchyManager implements HierarchyManager {
-
-    private final HierarchyManager delegatee;
-
-    // map of item id to list of paths
-    private Map pathCache = new ReferenceMap(ReferenceMap.HARD, ReferenceMap.HARD);
-    private Map zombiePathCache = new ReferenceMap(ReferenceMap.HARD, ReferenceMap.HARD);
-
-    // map of path to item id
-    private Map idCache = new ReferenceMap(ReferenceMap.HARD, ReferenceMap.HARD);
+public class CachingHierarchyManager extends HierarchyManagerImpl
+        implements NodeStateListener {
-     * @param hierMgr
+     * Default upper limit of cached states
-    public CachingHierarchyManager(HierarchyManager hierMgr) {
-        delegatee = hierMgr;
+    public static final int DEFAULT_UPPER_LIMIT = 100;
+
+    /**
+     * Logger instance
+     */
+    private static Logger log = Logger.getLogger(CachingHierarchyManager.class);
+
+    /**
+     * Mapping of paths to children in the path map
+     */
+    private final PathMap pathCache = new PathMap();
+
+    /**
+     * Mapping of item ids to <code>LRUEntry</code> in the path map
+     */
+    private final ReferenceMap idCache = new ReferenceMap(
+            ReferenceMap.HARD, ReferenceMap.HARD);
+
+    /**
+     * Set of items that were moved
+     */
+    private final Set movedIds = new HashSet();
+
+    /**
+     * Cache monitor object
+     */
+    private final Object cacheMonitor = new Object();
+
+    /**
+     * Upper limit
+     */
+    private final int upperLimit;
+
+    /**
+     * Head of LRU
+     */
+    private LRUEntry head;
+
+    /**
+     * Tail of LRU
+     */
+    private LRUEntry tail;
+
+    /**
+     * Create a new instance of this class. This hierarchy manager will not
+     * check for item states that have been moved into attic space
+     * @param rootNodeUUID root node UUID
+     * @param provider item state manager
+     * @param nsResolver namespace resolver
+     */
+    public CachingHierarchyManager(String rootNodeUUID,
+                                   ItemStateManager provider,
+                                   NamespaceResolver nsResolver) {
+        this(rootNodeUUID, provider, nsResolver, null);
-     * Returns the wrapped <code>HierarchyManager</code> instance
-     *
-     * @return the wrapped <code>HierarchyManager</code> instance
+     * Create a new instance of this class.
+     * @param rootNodeUUID root node UUID
+     * @param provider item state manager
+     * @param nsResolver namespace resolver
+     * @param attic item state manager for states in the attic space
-    public HierarchyManager unwrap() {
-        return delegatee;
-    }
+    public CachingHierarchyManager(String rootNodeUUID,
+                                   ItemStateManager provider,
+                                   NamespaceResolver nsResolver,
+                                   ItemStateManager attic) {
-    /**
-     * Clears the cache.
-     */
-    public synchronized void clearCache() {
-        pathCache.clear();
-        zombiePathCache.clear();
-        idCache.clear();
+        super(rootNodeUUID, provider, nsResolver, attic);
+
+        this.upperLimit = DEFAULT_UPPER_LIMIT;
+
+     *
+     * Check the item indicated inside our path cache first.
-        return delegatee.listParents(id);
-    }
-    /**
-     * {@inheritDoc}
-     */
-    public ItemId[] listChildren(NodeId id)
-            throws ItemNotFoundException, RepositoryException {
-        return delegatee.listChildren(id);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public ItemId[] listZombieChildren(NodeId id)
-            throws ItemNotFoundException, RepositoryException {
-        return delegatee.listZombieChildren(id);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public synchronized ItemId resolvePath(Path path)
-            throws PathNotFoundException, RepositoryException {
-        // check cache first
-        ItemId id = (ItemId) idCache.get(path);
-        if (id != null) {
-            return id;
+        if (id.denotesNode()) {
+            PathMap.Element element = get(id);
+            if (element != null) {
+                PathMap.Element parent = element.getParent();
+                if (parent != null) {
+                    LRUEntry entry = (LRUEntry) element.get();
+                    if (entry != null) {
+                        return new NodeId[] { (NodeId) entry.getId() };
+                    }
+                }
+            }
-        id = delegatee.resolvePath(path);
-        idCache.put(path, id);
-        return id;
+        return super.listParents(id);
+     *
+     * Check the path indicated inside our cache first.
+     */
+    public ItemId resolvePath(Path path)
+            throws PathNotFoundException, RepositoryException {
+
+        PathMap.Element element = map(path);
+        if (element == null) {
+            return super.resolvePath(path);
+        }
+        LRUEntry entry = (LRUEntry) element.get();
+        if (element.hasPath(path)) {
+            entry.touch();
+            return entry.getId();
+        }
+        return super.resolvePath(path, entry.getId(), element.getDepth() + 1);
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * Cache the intermediate item inside our cache.
+     */
+    protected ItemId resolvePath(Path path, ItemState state, int next)
+            throws PathNotFoundException, ItemStateException {
+
+        if (state.isNode() && !isCached(state.getId())) {
+            try {
+                Path.PathBuilder builder = new Path.PathBuilder();
+                Path.PathElement[] elements = path.getElements();
+                for (int i = 0; i < next; i++) {
+                    builder.addLast(elements[i]);
+                }
+                Path parentPath = builder.getPath();
+                cache(state, parentPath);
+            } catch (MalformedPathException mpe) {
+                log.warn("Failed to build path of " + state.getId(), mpe);
+            }
+        }
+        return super.resolvePath(path, state, next);
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * Overridden method simply checks whether we have an item matching the id
+     * and returns its path, otherwise calls base implementation.
-        return getAllPaths(id, false)[0];
+
+        if (id.denotesNode()) {
+            PathMap.Element element = get(id);
+            if (element != null) {
+                try {
+                    return element.getPath();
+                } catch (MalformedPathException mpe) {
+                    String msg = "Failed to build path of " + id;
+                    log.debug(msg);
+                    throw new RepositoryException(msg, mpe);
+                }
+            }
+        }
+        return super.getPath(id);
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * Overridden method tries to find a mapping for the intermediate item
+     * <code>state</code> and add its path elements to the builder currently
+     * being used. If no mapping is found, the item is cached instead after
+     * the base implementation has been invoked.
+     */
+    protected void getPath(Path.PathBuilder builder, ItemState state)
+            throws ItemStateException, RepositoryException {
+
+        if (state.isNode()) {
+            PathMap.Element element = get(state.getId());
+            if (element != null) {
+                try {
+                    Path.PathElement[] elements = element.getPath().getElements();
+                    for (int i = elements.length - 1; i >= 0; i--) {
+                        builder.addFirst(elements[i]);
+                    }
+                    return;
+                } catch (MalformedPathException mpe) {
+                    String msg = "Failed to build path of " + state.getId();
+                    log.debug(msg);
+                    throw new RepositoryException(msg, mpe);
+                }
+            }
+        }
+
+        super.getPath(builder, state);
+
+        if (state.isNode()) {
+            try {
+                cache(state, builder.getPath());
+            } catch (MalformedPathException mpe) {
+                log.warn("Failed to build path of " + state.getId());
+            }
+        }
-    public QName getName(ItemId itemId)
+    public QName getName(ItemId id)
-        if (itemId.denotesNode()) {
-            return getPath(itemId).getNameElement().getName();
-        } else {
-            PropertyId propId = (PropertyId) itemId;
-            return propId.getName();
+
+        if (id.denotesNode()) {
+            PathMap.Element element = get(id);
+            if (element != null) {
+                return element.getName();
+            }
+        return super.getName(id);
-        if (pathCache.containsKey(id)) {
-            return getPath(id).getAncestorCount();
-        } else {
-            return delegatee.getDepth(id);
+
+        if (id.denotesNode()) {
+            PathMap.Element element = get(id);
+            if (element != null) {
+                return element.getDepth();
+            }
+        return super.getDepth(id);
-        if (pathCache.containsKey(nodeId) && pathCache.containsKey(itemId)) {
-            // use cached Path objects rather than calling delegatee
-            try {
-                return getPath(nodeId).isAncestorOf(getPath(itemId));
-            } catch (MalformedPathException mpe) {
-                // should never get here...
-                String msg = "failed to determine degree of relationship of "
-                        + nodeId + " and " + itemId;
-                throw new ItemNotFoundException(msg, mpe);
+
+        if (itemId.denotesNode()) {
+            PathMap.Element element = get(nodeId);
+            if (element != null) {
+                PathMap.Element child = get(itemId);
+                if (child != null) {
+                    return element.isAncestorOf(child);
+                }
-        } else {
-            return delegatee.isAncestor(nodeId, itemId);
+        }
+        return super.isAncestor(nodeId, itemId);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public Path[] getAllPaths(ItemId id, boolean includeZombies)
+            throws ItemNotFoundException, RepositoryException {
+
+        if (!includeZombies) {
+            return new Path[] { getPath(id) };
+        }
+        return super.getAllPaths(id, includeZombies);
+    }
+
+    //----------------------------------------------------< ItemStateListener >
+
+    /**
+     * {@inheritDoc}
+     */
+    public void stateCreated(ItemState created) {
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void stateModified(ItemState modified) {
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void stateDestroyed(ItemState destroyed) {
+        destroyed.removeListener(this);
+        evict(destroyed.getId());
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void stateDiscarded(ItemState discarded) {
+        discarded.removeListener(this);
+        evict(discarded.getId());
+    }
+
+    /**
+     * Called when an <code>ItemState</code> has been overlaid by some
+     * other state that now takes its identity. This notification is sent
+     * on the state being overlaid.
+     *
+     * @param overlayer the <code>ItemState</code> that overlays this state
+     */
+    public void stateOverlaid(ItemState overlayer) {
+        if (overlayer.isNode()) {
+            overlayer.getOverlayedState().removeListener(this);
+            overlayer.addListener(this);
+        }
+    }
+
+    /**
+     * Called when an <code>ItemState</code> no longer overlayes some other
+     * item state. This notification is sent on the state overlaying another
+     * state.
+     *
+     * @param overlayer the <code>ItemState</code> that overlaid another
+     *        item state. To get the overlaid state, invoke
+     *        {@link ItemState#getOverlayedState()}
+     */
+    public void stateUncovered(ItemState overlayer) {
+        if (overlayer.isNode()) {
+            overlayer.removeListener(this);
+            overlayer.getOverlayedState().addListener(this);
-    public synchronized Path[] getAllPaths(ItemId id)
-            throws ItemNotFoundException, RepositoryException {
-        return getAllPaths(id, false);
+    public void nodeAdded(NodeState state, QName name, int index, String uuid) {
+        try {
+            Path path = Path.create(getPath(state.getId()), name, index, true);
+            insert(path, new NodeId(uuid));
+        } catch (PathNotFoundException e) {
+            log.warn("Added node does not have parent, ignoring event.");
+        } catch (MalformedPathException e) {
+            log.warn("Unable to create path of " + uuid, e);
+        } catch(ItemNotFoundException e) {
+            log.warn("Unable to get path of " + state.getId(), e);
+        } catch(RepositoryException e) {
+            log.warn("Unable to get path of " + state.getId(), e);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * Generate subsequent add and remove notifications for every replacement.
+     */
+    public void nodesReplaced(NodeState state) {
+        List entries = state.getReorderedChildNodeEntries();
+        if (entries.size() == 0) {
+            return;
+        }
+
+        Iterator iter = entries.iterator();
+        while (iter.hasNext()) {
+            NodeState.ChildNodeEntry now = (NodeState.ChildNodeEntry) iter.next();
+            NodeState.ChildNodeEntry old = null;
+
+            List list = ((NodeState) state.getOverlayedState()).
+                    getChildNodeEntries(now.getUUID());
+            if (list.size() > 0) {
+                old = (NodeState.ChildNodeEntry) list.get(0);
+            }
+            if (old == null) {
+                log.warn("Reordered child node not found in old list.");
+                continue;
+            }
+
+            nodeAdded(state, now.getName(), now.getIndex(), now.getUUID());
+            nodeRemoved(state, old.getName(), old.getIndex(), old.getUUID());
+        }
-    public synchronized Path[] getAllPaths(ItemId id, boolean includeZombies)
-            throws ItemNotFoundException, RepositoryException {
-        // check cache first
-        Path[] paths;
-        if (includeZombies) {
-            paths = (Path[]) zombiePathCache.get(id);
-            if (paths != null) {
-                return paths;
-            }
-            paths = delegatee.getAllPaths(id, includeZombies);
-            zombiePathCache.put(id, paths);
-        } else {
-            paths = (Path[]) pathCache.get(id);
-            if (paths != null) {
-                return paths;
-            }
-            paths = delegatee.getAllPaths(id, includeZombies);
-            pathCache.put(id, paths);
+    public void nodeRemoved(NodeState state, QName name, int index, String uuid) {
+        try {
+            Path path = Path.create(getPath(state.getId()), name, index, true);
+            remove(path, new NodeId(uuid));
+        } catch (PathNotFoundException e) {
+            log.warn("Added node does not have parent, ignoring event.");
+        } catch (MalformedPathException e) {
+            log.warn("Unable to create path of " + uuid, e);
+        } catch(ItemNotFoundException e) {
+            log.warn("Unable to get path of " + state.getId(), e);
+        } catch(RepositoryException e) {
+            log.warn("Unable to get path of " + state.getId(), e);
-        return paths;
+    }
+
+    //-------------------------------------------------------< private methods >
+
+    /**
+     * Return a cached element in the path map, given its id
+     * @param id node id
+     * @return cached element, <code>null</code> if not found
+     */
+    private PathMap.Element get(ItemId id) {
+        synchronized (cacheMonitor) {
+            LRUEntry entry = (LRUEntry) idCache.get(id);
+            if (entry != null) {
+                entry.touch();
+                return entry.getElement();
+            }
+            return null;
+        }
+    }
+
+    /**
+     * Return the nearest cached element in the path map, given a path.
+     * The returned element is guaranteed to have an associated object that
+     * is not <code>null</code>.
+     * @param path path
+     * @return cached element, <code>null</code> if not found
+     */
+    private PathMap.Element map(Path path) {
+        synchronized (cacheMonitor) {
+            PathMap.Element element = pathCache.map(path, false);
+            while (element != null) {
+                LRUEntry entry = (LRUEntry) element.get();
+                if (entry != null) {
+                    entry.touch();
+                    return element;
+                }
+                element = element.getParent();
+            }
+            return null;
+        }
+    }
+
+    /**
+     * Cache an item in the hierarchy given its id and path. Adds a listener
+     * for this item state to get notified about changes.
+     * @param state item state, may be <code>null</code>
+     * @param path path to item
+     */
+    private void cache(ItemState state, Path path) {
+        ItemId id = state.getId();
+
+        synchronized (cacheMonitor) {
+            if (idCache.get(id) != null) {
+                return;
+            }
+            if (idCache.size() >= upperLimit) {
+                removeLRU();
+            }
+
+            PathMap.Element element = pathCache.put(path);
+            LRUEntry entry = new LRUEntry(id, element);
+            element.set(entry);
+            idCache.put(id, entry);
+
+            state.addListener(this);
+        }
+    }
+
+    /**
+     * Remove least recently used item. Scans the LRU list from head to tail
+     * and removes the first item that has no children.
+     */
+    private void removeLRU() {
+        synchronized (cacheMonitor) {
+            LRUEntry entry = head;
+            while (entry != null) {
+                PathMap.Element element = entry.getElement();
+                if (element.getChildrenCount() == 0) {
+                    evict(entry, true);
+                    return;
+                }
+                entry = entry.getNext();
+            }
+        }
+    }
+
+    /**
+     * Return a flag indicating whether a certain element is cached.
+     * @param id item id
+     * @return <code>true</code> if the item is already cached;
+     *         <code>false</code> otherwise
+     */
+    private boolean isCached(ItemId id) {
+        synchronized (cacheMonitor) {
+            return idCache.get(id) != null;
+        }
+    }
+
+    /**
+     * Evict item from cache. Evicts the associated <code>LRUEntry</code>
+     * @param id item id
+     */
+    private void evict(ItemId id) {
+        synchronized (cacheMonitor) {
+            LRUEntry entry = (LRUEntry) idCache.get(id);
+            if (entry != null) {
+                evict(entry, true);
+            }
+        }
+    }
+
+    /**
+     * Evict item from cache
+     * @param entry LRU entry
+     * @param removeFromPathCache whether to remove from path cache
+     */
+    private void evict(LRUEntry entry, boolean removeFromPathCache) {
+        synchronized (cacheMonitor) {
+            if (removeFromPathCache) {
+                PathMap.Element element = entry.getElement();
+                evict(element);
+                element.remove();
+            } else {
+                idCache.remove(entry.getId());
+                entry.remove();
+            }
+        }
+    }
+
+    /**
+     * Evict path map element from cache. This will traverse all children
+     * of this element and evict the objects associated with them
+     * @param element path map element
+     */
+    private void evict(PathMap.Element element) {
+        synchronized (cacheMonitor) {
+            element.traverse(new PathMap.ElementVisitor() {
+                public void elementVisited(PathMap.Element element) {
+                    evict((LRUEntry) element.get(), false);
+                }
+            }, false);
+        }
+    }
+
+    /**
+     * Insert a node into the cache. This will automatically shift
+     * all indexes of sibling nodes having index greater or equal.
+     * @param path child path
+     * @param id node id
+     */
+    private void insert(Path path, ItemId id) throws PathNotFoundException {
+        synchronized (cacheMonitor) {
+            PathMap.Element element = null;
+
+            LRUEntry entry = (LRUEntry) idCache.get(id);
+            if (entry != null) {
+                element = entry.getElement();
+                element.remove();
+            }
+
+            PathMap.Element parent = pathCache.map(path.getAncestor(1), true);
+            if (parent != null) {
+                parent.insert(path.getNameElement());
+            }
+            if (element != null) {
+                pathCache.put(path, element);
+
+                /* Remember this as a move */
+                movedIds.add(id);
+            }
+        }
+    }
+
+    /**
+     * Remove an item from the cache in order to shift the indexes
+     * of items following this item.
+     * @param path child path
+     * @param id node id
+     */
+    private void remove(Path path, ItemId id) throws PathNotFoundException {
+        synchronized (cacheMonitor) {
+            /* If we remembered this as a move, ignore this event */
+            if (movedIds.remove(id)) {
+                return;
+            }
+            PathMap.Element parent = pathCache.map(path.getAncestor(1), true);
+            if (parent != null) {
+                PathMap.Element element = parent.remove(path.getNameElement());
+                if (element != null) {
+                    evict(element);
+                }
+            }
+        }
+    }
+
+    /**
+     * Entry in the LRU list
+     */
+    private class LRUEntry {
+
+        /**
+         * Previous entry
+         */
+        private LRUEntry previous;
+
+        /**
+         * Next entry
+         */
+        private LRUEntry next;
+
+        /**
+         * Item id
+         */
+        private final ItemId id;
+
+        /**
+         * Element in path map
+         */
+        private final PathMap.Element element;
+
+        /**
+         * Create a new instance of this class
+         * @param id item id
+         */
+        public LRUEntry(ItemId id, PathMap.Element element) {
+            this.id = id;
+            this.element = element;
+
+            append();
+        }
+
+        /**
+         * Append entry to end of LRU list
+         */
+        public void append() {
+            if (tail == null) {
+                head = tail = this;
+            } else {
+                previous = tail;
+                tail.next = this;
+                tail = this;
+            }
+        }
+
+        /**
+         * Remove entry from LRU list
+         */
+        public void remove() {
+            if (previous != null) {
+                previous.next = next;
+            }
+            if (next != null) {
+                next.previous = previous;
+            }
+            if (head == this) {
+                head = next;
+            }
+            if (tail == this) {
+                tail = previous;
+            }
+            previous = next = null;
+        }
+
+        /**
+         * Touch entry. Removes it from its current position in the LRU list
+         * and moves it to the end.
+         */
+        public void touch() {
+            remove();
+            append();
+        }
+
+        /**
+         * Return previous LRU entry
+         * @return previous LRU entry
+         */
+        public LRUEntry getPrevious() {
+            return previous;
+        }
+
+        /**
+         * Return next LRU entry
+         * @return next LRU entry
+         */
+        public LRUEntry getNext() {
+            return next;
+        }
+
+        /**
+         * Return item ID
+         * @return item ID
+         */
+        public ItemId getId() {
+            return id;
+        }
+
+        /**
+         * Return element in path map
+         * @return element in path map
+         */
+        public PathMap.Element getElement() {
+            return element;
+        }
-

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV23 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 INS40 INS40 UPD40 UPD43 INS43 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS55 UPD42 INS42 INS29 INS83 INS83 INS83 INS39 INS59 INS29 UPD83 UPD43 INS29 INS83 UPD43 INS29 INS83 MOV43 INS29 INS83 INS83 INS43 INS59 INS29 INS83 UPD43 INS29 INS83 INS83 INS39 INS59 INS29 INS83 INS43 INS59 INS29 INS83 INS43 INS59 INS44 INS44 INS42 INS44 INS44 INS44 INS44 MOV29 MOV83 MOV5 UPD42 MOV42 MOV44 MOV43 MOV43 INS8 INS29 MOV43 UPD42 INS43 MOV43 INS8 INS29 UPD83 MOV43 INS42 INS44 INS44 INS44 INS43 INS43 INS8 INS29 MOV43 UPD42 MOV44 MOV43 MOV43 INS29 UPD83 INS39 INS44 INS44 UPD43 INS8 MOV29 MOV43 MOV43 MOV29 INS44 MOV43 MOV43 MOV29 MOV83 MOV39 MOV42 MOV44 MOV44 MOV43 MOV43 INS8 MOV29 INS83 MOV5 INS42 MOV44 MOV44 MOV43 MOV43 INS8 MOV29 INS83 INS39 INS42 INS44 INS8 MOV29 INS83 INS39 INS42 INS44 INS8 MOV29 INS83 INS39 INS42 INS44 INS8 MOV29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 MOV29 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 MOV29 INS39 INS42 INS44 INS44 INS44 INS44 INS8 INS29 UPD83 MOV83 INS43 UPD42 MOV42 INS44 INS8 INS29 INS83 INS43 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 MOV44 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 MOV44 MOV43 INS8 INS29 INS83 INS39 INS42 INS44 MOV44 INS43 INS8 INS29 INS83 INS42 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 UPD66 UPD66 INS65 INS42 INS34 INS65 UPD42 UPD42 INS32 INS65 UPD42 INS65 INS65 INS42 INS42 INS14 INS65 UPD42 UPD42 INS65 INS42 INS65 INS42 INS42 INS65 INS42 INS42 INS65 INS65 INS65 INS43 INS42 UPD43 UPD42 INS43 INS42 INS17 INS65 INS65 INS65 UPD65 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS46 INS21 INS25 INS41 INS65 INS43 INS42 INS42 INS60 INS25 INS60 INS25 INS41 INS65 INS43 INS42 INS43 INS42 INS39 INS42 INS42 INS42 INS25 INS41 INS65 INS25 INS65 INS43 INS42 INS43 INS42 UPD42 INS25 INS21 INS25 UPD42 INS41 INS43 INS42 INS25 MOV41 INS25 INS41 INS25 INS41 INS43 INS42 INS43 INS42 INS43 INS42 INS21 INS21 INS43 INS42 INS21 INS21 INS65 INS65 INS43 INS42 INS25 INS65 INS65 INS43 INS42 INS25 INS43 INS42 INS43 INS42 INS39 INS42 INS43 INS42 MOV54 INS65 INS43 INS42 INS60 INS25 INS60 INS61 INS43 INS42 INS43 INS42 INS39 INS42 INS43 INS42 INS54 INS65 INS65 INS65 INS40 INS43 INS42 INS51 INS65 INS65 INS65 INS40 INS43 INS42 INS51 INS65 INS65 INS65 INS43 INS42 INS60 INS51 INS65 INS51 INS65 INS65 INS65 INS43 INS42 INS51 INS65 INS65 INS43 INS42 INS51 INS65 INS65 INS65 INS43 INS42 INS39 INS42 INS51 INS65 INS65 INS43 INS42 INS51 INS65 INS65 INS65 INS43 INS42 INS51 INS65 INS65 INS65 INS43 INS42 INS42 INS51 INS65 INS29 INS83 INS43 INS59 INS29 INS83 INS43 INS59 INS29 INS83 INS83 MOV43 INS59 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS42 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS43 INS42 INS8 INS29 INS83 INS43 INS42 INS8 INS29 INS83 MOV43 INS42 MOV8 INS29 INS83 INS43 INS42 INS8 INS66 INS66 INS42 INS42 INS57 INS66 UPD43 INS66 INS66 INS43 INS66 INS43 INS66 INS66 INS66 INS66 INS66 INS42 INS66 UPD42 INS66 INS42 INS66 INS42 UPD42 INS42 INS42 INS42 INS42 INS33 UPD66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 UPD66 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS65 UPD66 INS32 INS8 INS48 INS65 INS66 INS42 INS43 INS59 INS27 INS8 INS43 INS59 INS32 INS8 INS48 INS65 INS66 INS42 INS42 INS27 INS8 INS48 INS65 INS66 INS66 INS32 INS8 INS48 INS65 INS66 INS66 INS66 INS66 INS40 INS42 INS32 INS8 INS48 INS32 INS8 INS32 INS48 INS42 INS32 INS8 INS48 MOV32 INS8 INS48 INS38 INS8 INS48 INS42 INS42 INS42 INS32 INS32 INS42 INS32 INS32 INS66 INS66 INS66 INS42 INS66 INS42 INS32 INS8 INS66 INS66 INS66 INS42 INS66 INS66 INS65 INS42 INS32 INS8 INS42 INS42 INS42 INS12 INS12 INS12 INS65 INS66 INS42 INS43 INS59 INS27 INS8 INS43 INS59 INS32 INS8 INS42 INS42 INS42 INS8 INS12 INS12 INS12 INS12 INS66 INS42 INS66 INS66 UPD42 MOV42 INS42 INS8 INS66 INS66 INS66 INS42 INS66 INS66 MOV42 INS42 INS8 INS66 INS66 INS42 INS66 INS42 INS66 INS42 MOV43 INS59 INS42 INS8 INS66 INS66 INS42 INS8 INS66 INS42 INS66 INS66 INS66 INS42 INS42 INS8 INS66 INS42 INS66 INS42 INS42 INS8 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS8 INS66 INS66 INS42 INS66 INS40 INS42 INS8 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS8 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS8 INS66 INS65 INS42 INS42 INS65 INS42 INS42 INS65 INS42 INS65 INS40 INS42 INS65 INS65 INS43 INS42 INS43 INS42 INS21 INS21 INS21 INS65 INS25 INS65 INS25 INS25 INS25 INS25 INS21 INS65 INS21 INS21 INS65 INS65 INS42 MOV41 INS65 INS65 INS42 INS41 INS65 INS65 INS65 INS65 INS40 INS41 INS43 UPD42 INS42 INS42 INS22 INS42 UPD42 MOV42 UPD42 MOV42 INS60 INS25 INS42 INS42 INS40 INS42 INS32 INS42 INS33 INS41 INS42 INS42 INS11 INS42 INS42 INS42 INS21 MOV41 INS42 INS42 INS32 INS27 INS32 INS38 INS54 INS42 INS42 INS42 INS42 INS42 INS42 MOV60 INS25 INS42 INS42 INS42 INS42 INS60 INS25 INS42 INS42 INS42 INS42 INS42 INS54 UPD42 MOV42 UPD42 MOV42 INS25 INS42 INS42 INS42 UPD42 MOV42 INS60 INS25 INS42 INS42 INS60 INS25 INS42 INS42 INS42 INS42 INS41 INS42 INS42 INS42 INS42 INS42 INS52 UPD42 MOV42 INS32 INS42 INS42 INS52 UPD42 MOV42 INS32 INS42 INS42 INS21 INS21 INS68 INS42 INS42 INS21 INS21 INS60 INS21 INS44 INS8 INS44 INS8 INS44 INS44 INS8 INS42 INS42 INS32 INS32 INS34 INS41 INS42 INS42 INS32 INS42 INS42 INS60 INS60 INS60 INS25 INS25 INS21 INS21 INS60 INS21 INS44 INS8 INS44 INS8 INS44 INS8 INS44 INS8 MOV60 INS25 INS41 INS60 INS61 INS41 INS42 INS32 INS25 INS25 INS60 INS60 INS21 MOV21 INS21 INS60 INS61 INS41 INS60 INS25 INS25 INS21 INS60 INS60 MOV25 INS60 INS25 INS25 INS25 INS60 INS25 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS40 INS7 INS7 INS32 INS66 INS27 INS8 INS8 INS66 INS27 INS8 INS27 INS8 INS27 INS8 INS27 INS8 INS7 INS66 INS66 INS32 INS32 INS66 INS66 UPD42 INS66 INS66 INS42 INS66 INS66 INS66 INS66 INS42 INS42 INS52 INS42 INS43 INS59 INS27 INS8 INS42 INS42 INS48 INS43 INS32 INS32 INS42 INS42 INS32 INS34 INS42 INS42 INS32 INS8 INS12 INS43 MOV27 INS8 INS43 INS59 INS27 INS8 INS8 INS12 UPD43 INS27 INS8 INS43 INS59 INS27 MOV8 INS43 INS59 INS27 INS8 INS3 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS32 INS32 INS42 INS42 INS32 INS32 INS43 INS59 INS32 INS43 INS42 INS21 INS43 INS42 INS21 MOV43 INS42 INS21 INS43 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS43 INS59 INS27 INS8 INS27 INS8 INS32 INS32 INS43 INS59 INS32 INS43 INS42 INS21 INS43 INS42 INS21 MOV43 INS42 INS21 INS43 INS42 INS21 INS43 INS27 INS8 INS33 INS43 INS59 INS27 INS8 INS33 INS42 INS42 INS27 INS8 INS27 INS8 INS43 INS59 INS43 INS59 INS32 INS32 INS43 INS59 INS27 INS8 INS27 INS43 INS59 INS27 INS8 INS42 INS8 INS8 INS32 INS43 INS59 INS43 INS59 INS43 INS59 INS27 INS8 INS27 INS8 INS32 INS8 INS43 INS59 INS27 INS8 INS22 INS42 INS22 INS42 INS42 INS42 INS33 INS21 INS21 INS21 INS21 INS42 INS33 INS21 INS42 INS33 INS21 INS42 INS52 INS21 INS42 INS52 INS21 INS42 INS7 INS42 INS42 INS40 INS42 INS32 INS42 INS33 INS60 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS42 INS42 INS32 INS60 INS60 INS24 INS60 INS21 MOV44 INS8 INS40 UPD42 INS32 UPD42 INS54 INS40 INS42 INS32 INS42 INS33 INS54 INS21 INS44 INS8 INS40 UPD42 INS32 INS42 INS33 MOV41 INS40 INS42 INS32 INS42 INS33 INS40 INS42 INS32 INS42 INS33 INS60 INS25 MOV5 INS4 INS32 INS42 INS52 INS42 INS42 INS52 INS42 INS42 INS52 INS32 INS42 INS52 INS42 INS42 INS32 INS42 UPD42 MOV42 INS14 INS42 INS32 INS42 INS32 INS32 INS42 INS32 INS40 INS42 INS11 INS40 INS42 INS33 INS42 INS42 INS32 INS32 INS34 INS21 INS42 INS33 INS21 INS18 INS42 INS42 INS32 INS32 INS32 INS42 INS42 INS32 INS32 INS32 MOV42 INS42 INS32 INS42 INS42 INS14 INS42 INS32 INS42 INS32 INS32 INS42 INS32 UPD42 MOV42 UPD42 INS11 INS42 INS33 INS21 INS41 INS40 INS42 INS32 INS42 INS33 INS60 MOV25 MOV21 INS32 INS33 INS41 INS32 INS42 INS21 INS40 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS42 UPD42 UPD42 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS33 INS60 INS25 INS21 INS32 INS33 INS42 INS42 INS11 INS42 INS33 INS21 INS60 INS21 INS21 INS21 INS21 INS42 INS42 INS14 INS9 INS40 INS42 INS33 INS42 INS42 INS11 UPD42 INS21 INS21 INS40 INS42 INS32 INS42 INS33 INS21 INS42 INS33 MOV21 INS21 INS42 INS42 INS42 INS41 INS40 INS42 INS32 INS42 INS33 INS60 INS25 INS52 INS42 INS52 INS42 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS42 INS33 UPD42 MOV42 UPD42 MOV42 INS43 INS59 INS27 INS8 INS42 INS42 INS43 INS59 INS5 INS59 INS58 INS27 INS37 INS8 INS43 INS59 INS32 INS21 MOV42 UPD42 MOV42 INS8 INS12 UPD42 MOV42 INS32 INS8 INS12 INS32 INS43 INS42 INS21 INS42 INS42 INS42 MOV42 INS42 INS42 INS43 INS59 INS27 INS8 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS42 UPD42 MOV42 INS9 MOV43 INS42 INS42 INS42 INS45 INS42 INS42 INS27 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS27 INS42 INS43 INS32 INS36 INS42 INS32 INS42 INS42 INS7 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 UPD9 MOV9 INS43 INS42 INS42 INS42 INS45 INS42 INS42 INS27 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS27 INS42 INS43 INS32 INS32 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS9 INS43 INS59 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS43 INS42 INS42 INS43 INS59 INS27 INS8 INS7 INS42 INS42 INS42 INS43 INS32 INS32 INS43 INS59 INS32 INS32 INS32 INS32 INS43 INS1 INS43 MOV32 INS7 INS32 INS42 INS42 INS32 INS9 INS32 INS32 INS42 INS42 INS32 INS9 INS43 INS59 INS27 INS8 INS42 INS7 INS42 INS42 INS40 INS52 INS42 INS52 INS40 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS32 INS42 INS33 INS60 INS25 INS40 INS42 INS14 INS43 MOV85 INS42 INS32 INS39 INS59 INS42 INS42 INS42 INS21 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS41 INS44 INS8 INS42 UPD42 MOV42 INS60 INS24 INS41 INS44 INS8 INS42 INS42 INS32 INS42 INS32 UPD42 INS42 UPD42 INS40 INS42 INS32 INS42 INS33 INS41 INS32 INS45 INS42 UPD45 MOV45 INS32 INS45 INS32 INS40 INS42 INS42 INS11 UPD42 MOV42 UPD42 MOV42 INS42 INS11 INS42 INS42 INS45 UPD42 MOV42 INS32 INS42 INS45 INS42 INS45 INS32 INS45 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS11 UPD42 INS21 UPD42 INS42 INS42 INS40 INS42 INS32 INS32 INS34 INS21 INS41 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS40 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS40 INS31 INS42 UPD42 INS42 INS32 INS42 INS42 INS42 INS42 INS34 UPD42 MOV42 UPD42 MOV42 INS32 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS34 INS40 INS42 INS32 INS42 INS33 INS21 INS42 INS52 UPD42 MOV42 UPD42 MOV42 INS43 INS59 INS27 INS8 INS43 INS40 INS42 INS42 INS42 INS34 INS32 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS27 INS42 INS32 INS43 INS42 INS60 MOV21 INS53 INS5 INS59 INS58 INS27 INS37 INS8 INS43 INS42 INS60 INS21 INS53 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS32 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS43 INS32 INS43 INS32 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS43 INS32 INS32 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS83 INS39 INS42 INS44 INS8 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS32 INS32 INS42 INS42 INS11 INS42 INS33 MOV41 INS40 INS42 INS42 INS2 INS45 INS32 INS42 INS42 INS42 MOV43 INS59 INS14 INS43 INS85 INS42 INS32 INS39 INS59 INS42 INS34 INS42 INS21 INS42 INS43 INS59 INS32 INS14 INS45 INS32 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS40 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS43 INS42 INS21 INS42 INS42 INS42 INS42 INS43 INS32 INS3 INS42 INS42 INS42 UPD42 MOV42 INS42 INS27 UPD42 UPD42 UPD42 MOV43 INS42 INS42 INS40 INS32 INS42 INS42 INS27 INS32 INS42 INS42 INS27 INS42 INS42 INS42 MOV43 INS42 INS42 INS42 INS42 INS40 INS32 INS42 INS42 INS42 INS5 INS4 INS45 INS42 INS42 INS42 INS40 INS34 INS42 INS42 INS2 INS45 INS32 INS42 INS11 INS9 INS43 INS85 INS11 INS42 INS42 INS42 INS42 INS43 INS32 INS42 MOV43 INS32 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL40 DEL40 DEL42 DEL43 DEL40 DEL40 DEL42 DEL42 DEL7 DEL21 DEL43 DEL42 DEL42 DEL41 DEL42 DEL32 DEL83 DEL39 DEL32 DEL21 DEL32 DEL21 DEL32 DEL21 DEL8 DEL31 DEL83 DEL42 DEL8 DEL31 DEL85 DEL5 DEL42 DEL42 DEL8 DEL5 DEL42 DEL42 DEL44 DEL32 DEL41 DEL8 DEL42 DEL32 DEL11 DEL42 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL83 DEL9 DEL32 DEL34 DEL2 DEL41 DEL8 DEL42 DEL32 DEL42 DEL32 DEL32 DEL41 DEL8 DEL42 DEL42 DEL43 DEL42 DEL11 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL8 DEL25 DEL42 DEL32 DEL32 DEL41 DEL42 DEL42 DEL45 DEL42 DEL27 DEL59 DEL60 DEL42 DEL42 DEL14 DEL53 DEL32 DEL32 DEL27 DEL8 DEL32 DEL41 DEL8 DEL25 DEL8 DEL31 DEL83 DEL43 DEL85 DEL5 DEL42 DEL32 DEL41 DEL8 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL41 DEL83 DEL43 DEL42 DEL42 DEL43 DEL85 DEL5 DEL32 DEL11 DEL7 DEL21 DEL8 DEL42 DEL11 DEL7 DEL21 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL31
JCR-1104 - JSR 283 support
- shareble nodes (work in progress)
- prepare for returning stable paths on shareable nodes or their descendants

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@647767 13f79535-47bb-0310-9956-ffa450edef68

-public class ItemManager implements ItemLifeCycleListener, Dumpable, ItemStateListener {
+public class ItemManager implements Dumpable, ItemStateListener {
-            ItemImpl item = retrieveItem(id);
-            if (item != null) {
-                evictItem(id);
-            }
+            evictItems(id);
-                evictItem(id);
+                evictItems(id);
-        // check cache
-        ItemImpl item = retrieveItem(id);
-        if (item == null) {
+        ItemData data = retrieveItem(id);
+        if (data == null) {
-            // create instance of item
-            item = createItemInstance(id);
+            // create instance of item data
+            data = createItemData(id);
+            cacheItem(data);
-        return item;
+        return createItemInstance(data);
-     * but only one node with the given parent id.
+     * but there'is only one node with the given parent id.
-        // check sanity of session
-        session.sanityCheck();
-        // check shareable nodes
-        NodeImpl node = shareableNodesCache.retrieve(id, parentId);
-        if (node != null) {
-            return node;
+        if (parentId == null) {
+            return (NodeImpl) getItem(id);
-
-        node = (NodeImpl) getItem(id);
-        if (!node.getParentId().equals(parentId)) {
+        AbstractNodeData data = (AbstractNodeData) retrieveItem(id, parentId);
+        if (data == null) {
+            data = (AbstractNodeData) createItemData(id);
+            cacheItem(data);
+        }
+        if (!data.getParentId().equals(parentId)) {
-            if (!node.hasShareParent(parentId)) {
+            if (!data.getNodeState().containsShare(parentId)) {
-
-            node = new NodeImpl(node, parentId, new ItemLifeCycleListener[] { this });
-            node.notifyCreated();
+            data = new NodeDataRef(data, parentId);
+            cacheItem(data);
-        return node;
+        return createNodeInstance(data);
-     * Returns the item instance for the given item state.
+     * Returns the item instance for the given item id.
+     *
+     * @param checkAccess whether to check access
-    public synchronized ItemImpl getItem(ItemState state)
+    synchronized ItemImpl getItem(ItemId id, boolean isNew)
-        ItemId id = state.getId();
-        ItemImpl item = retrieveItem(id);
-        if (item == null) {
+        ItemData data = retrieveItem(id);
+        if (data == null) {
-            if (state.getStatus() != ItemState.STATUS_NEW && !canRead(id)) {
+            if (!isNew && !canRead(id)) {
-            item = createItemInstance(id);
+            data = createItemData(id);
+            cacheItem(data);
-        return item;
+        return createItemInstance(data);
+    }
+
+    /**
+     * Create an item instance from an item state. This method creates a
+     * new <code>ItemData</code> instance without looking at the cache and
+     * returns a new item instance.
+     *
+     * @param state item state
+     * @return item instance
+     * @throws RepositoryException if an error occurs
+     */
+    synchronized ItemImpl createItemInstance(ItemState state)
+            throws RepositoryException {
+
+        ItemData data = createItemData(state);
+        cacheItem(data);
+        return createItemInstance(data);
-    private ItemImpl createItemInstance(ItemId id)
+
+    private ItemData createItemData(ItemId id)
-        // create instance of item using its state object
-        ItemImpl item;
+
+        return createItemData(state);
+    }
+    private ItemData createItemData(ItemState state) throws RepositoryException {
+        ItemId id = state.getId();
-            item = createNodeInstance((NodeState) state, rootNodeDef);
+            return new NodeData((NodeState) state, rootNodeDef);
-            item = createNodeInstance((NodeState) state);
+            NodeState nodeState = (NodeState) state;
+            return new NodeData(nodeState, getDefinition(nodeState));
-            item = createPropertyInstance((PropertyState) state);
+            PropertyState propertyState = (PropertyState) state;
+            return new PropertyData(propertyState, getDefinition(propertyState));
-        return item;
-    NodeImpl createNodeInstance(NodeState state, NodeDefinition def)
-            throws RepositoryException {
-        NodeId id = state.getNodeId();
-        // we want to be informed on life cycle changes of the new node object
-        // in order to maintain item cache consistency
-        ItemLifeCycleListener[] listeners = new ItemLifeCycleListener[]{this};
-        NodeImpl node = null;
+    private ItemImpl createItemInstance(ItemData data) {
+        if (data.isNode()) {
+            return createNodeInstance((AbstractNodeData) data);
+        } else {
+            return createPropertyInstance((PropertyData) data);
+        }
+    }
+    private NodeImpl createNodeInstance(AbstractNodeData data) {
+        final NodeState state = data.getNodeState();
-            node = createVersionInstance(id, state, def, listeners);
-
+            return new VersionImpl(this, session, data);
-            node = createVersionHistoryInstance(id, state, def, listeners);
-
+            return new VersionHistoryImpl(this, session, data);
-            node = new NodeImpl(this, session, id, state, def, listeners);
+            return new NodeImpl(this, session, data);
-        node.notifyCreated();
-        return node;
-    NodeImpl createNodeInstance(NodeState state) throws RepositoryException {
-        // 1. get definition of the specified node
-        NodeDefinition def = getDefinition(state);
-        // 2. create instance
-        return createNodeInstance(state, def);
-    }
-
-    PropertyImpl createPropertyInstance(PropertyState state,
-                                        PropertyDefinition def) {
-        // we want to be informed on life cycle changes of the new property object
-        // in order to maintain item cache consistency
-        ItemLifeCycleListener[] listeners = new ItemLifeCycleListener[]{this};
-        // create property object
-        PropertyImpl property = new PropertyImpl(
-                this, session, state.getPropertyId(), state, def, listeners);
-        property.notifyCreated();
-        return property;
-    }
-
-    PropertyImpl createPropertyInstance(PropertyState state)
-            throws RepositoryException {
-        // 1. get definition for the specified property
-        PropertyDefinition def = getDefinition(state);
-        // 2. create instance
-        return createPropertyInstance(state, def);
-    }
-
-    /**
-     * Create a version instance.
-     * @param id node id
-     * @param state node state
-     * @param def node definition
-     * @param listeners listeners
-     * @return version instance
-     * @throws RepositoryException if an error occurs
-     */
-    protected VersionImpl createVersionInstance(
-            NodeId id, NodeState state, NodeDefinition def,
-            ItemLifeCycleListener[] listeners) throws RepositoryException {
-
-        return new VersionImpl(this, session, id, state, def, listeners);
-    }
-
-    /**
-     * Create a version history instance.
-     * @param id node id
-     * @param state node state
-     * @param def node definition
-     * @param listeners listeners
-     * @return version instance
-     * @throws RepositoryException if an error occurs
-     */
-    protected VersionHistoryImpl createVersionHistoryInstance(
-            NodeId id, NodeState state, NodeDefinition def,
-            ItemLifeCycleListener[] listeners) throws RepositoryException {
-
-        return new VersionHistoryImpl(this, session, id, state, def, listeners);
+    private PropertyImpl createPropertyInstance(PropertyData data) {
+        // check special nodes
+        return new PropertyImpl(this, session, data);
-    private ItemImpl retrieveItem(ItemId id) {
+    private ItemData retrieveItem(ItemId id) {
-            ItemImpl item = (ItemImpl) itemCache.get(id);
-            if (item == null && id.denotesNode()) {
-                item = shareableNodesCache.retrieve((NodeId) id);
+            ItemData data = (ItemData) itemCache.get(id);
+            if (data == null && id.denotesNode()) {
+                data = shareableNodesCache.retrieveFirst((NodeId) id);
-            return item;
+            return data;
+        }
+    }
+
+    /**
+     * Return a node from the cache.
+     *
+     * @param id id of the node that should be retrieved.
+     * @param parentId parent id of the node that should be retrieved
+     * @return reference stored in the corresponding cache entry
+     *         or <code>null</code> if there's no corresponding cache entry.
+     */
+    private AbstractNodeData retrieveItem(NodeId id, NodeId parentId) {
+        synchronized (itemCache) {
+            AbstractNodeData data = shareableNodesCache.retrieve(id, parentId);
+            if (data == null) {
+                data = (AbstractNodeData) itemCache.get(id);
+            }
+            return data;
-    private void cacheItem(ItemImpl item) {
+    private void cacheItem(ItemData data) {
-            ItemId id = item.getId();
+            if (data.isNode()) {
+                AbstractNodeData nd = (AbstractNodeData) data;
+                if (nd.getPrimaryParentId() != null) {
+                    shareableNodesCache.cache(nd);
+                    return;
+                }
+            }
+            ItemId id = data.getId();
-            itemCache.put(id, item);
+            itemCache.put(id, data);
+        }
+    }
+
+    /**
+     * Removes all cache entries with the given item id. If the item is
+     * shareable, there might be more than one cache entry for this item.
+     *
+     * @param id id of the items to remove from the cache
+     * @return <code>true</code> if the item was contained in this cache,
+     *         <code>false</code> otherwise.
+     */
+    private void evictItems(ItemId id) {
+        if (log.isDebugEnabled()) {
+            log.debug("removing items " + id + " from cache");
+        }
+        synchronized (itemCache) {
+            itemCache.remove(id);
+            if (id.denotesNode()) {
+                shareableNodesCache.evictAll((NodeId) id);
+            }
-     * @return <code>true</code> if the item was contained in this cache,
-     *         <code>false</code> otherwise.
-    private boolean evictItem(ItemId id) {
+    private void evictItem(ItemData data) {
-            log.debug("removing item " + id + " from cache");
+            log.debug("removing item " + data.getId() + " from cache");
-            return itemCache.remove(id) != null;
+            if (data.isNode()) {
+                shareableNodesCache.evict((AbstractNodeData) data);
+            }
+            ItemData cached = (ItemData) itemCache.get(data.getId());
+            if (cached == data) {
+                itemCache.remove(data.getId());
+            }
+
-    /**
-     * {@inheritDoc}
-     */
-    public void itemCreated(ItemImpl item) {
-        if (log.isDebugEnabled()) {
-            log.debug("created item " + item.getId());
-        }
-        // add instance to cache
-        if (item.isNode()) {
-            NodeImpl node = (NodeImpl) item;
-            if (node.isShareable()) {
-                shareableNodesCache.cache(node);
-                return;
-            }
-        }
-        cacheItem(item);
-    }
-    public void itemInvalidated(ItemId id, ItemImpl item) {
+    public void itemInvalidated(ItemId id, ItemData data) {
-        // remove instance from cache
-        evictItem(id);
-        if (item.isNode()) {
-            shareableNodesCache.evict((NodeImpl) item);
-        }
+        evictItem(data);
-    public void itemDestroyed(ItemId id, ItemImpl item) {
+    public void itemDestroyed(ItemId id, ItemData data) {
-        // we're no longer interested in this item
-        item.removeLifeCycleListener(this);
-        // remove instance from cache
-        evictItem(id);
-        if (item.isNode()) {
-            shareableNodesCache.evict((NodeImpl) item);
+        synchronized (itemCache) {
+            // remove instance from cache
+            evictItems(id);
-        ItemImpl item = retrieveItem(created.getId());
-        if (item != null) {
-            item.stateCreated(created);
+        ItemData data = retrieveItem(created.getId());
+        if (data != null) {
+            data.setStatus(ItemImpl.STATUS_NORMAL);
-        ItemImpl item = retrieveItem(modified.getId());
-        if (item != null) {
-            item.stateModified(modified);
+        ItemData data = retrieveItem(modified.getId());
+        if (data != null && data.getState() == modified) {
+            data.setStatus(ItemImpl.STATUS_MODIFIED);
+            /*
+            if (modified.isNode()) {
+                NodeState state = (NodeState) modified;
+                if (state.isShareable()) {
+                    //evictItem(modified.getId());
+                    NodeData nodeData = (NodeData) data;
+                    NodeData shareSibling = new NodeData(nodeData, state.getParentId());
+                    shareableNodesCache.cache(shareSibling);
+                }
+            }
+            */
-        ItemImpl item = retrieveItem(destroyed.getId());
-        if (item != null) {
-            item.stateDestroyed(destroyed);
+        ItemData data = retrieveItem(destroyed.getId());
+        if (data != null) {
+            data.setStatus(ItemImpl.STATUS_DESTROYED);
+            if (data.getState() == destroyed) {
+                data.setState(null);
+            }
+            itemDestroyed(destroyed.getId(), data);
-        ItemImpl item = retrieveItem(discarded.getId());
-        if (item != null) {
-            item.stateDiscarded(discarded);
+        ItemData data = retrieveItem(discarded.getId());
+        if (data != null && data.getState() == discarded) {
+            if (discarded.isTransient()) {
+                switch (discarded.getStatus()) {
+                /**
+                 * persistent item that has been transiently removed
+                 */
+                case ItemState.STATUS_EXISTING_REMOVED:
+                case ItemState.STATUS_EXISTING_MODIFIED:
+                case ItemState.STATUS_STALE_MODIFIED:
+                    ItemState persistentState = discarded.getOverlayedState();
+                    /**
+                     * the state is a transient wrapper for the underlying
+                     * persistent state, therefore restore the persistent state
+                     * and resurrect this item instance if necessary
+                     */
+                    SessionItemStateManager stateMgr = session.getItemStateManager();
+                    stateMgr.disconnectTransientItemState(discarded);
+                    data.setState(persistentState);
+                    return;
+
+                    /**
+                     * persistent item that has been transiently modified or
+                     * removed and the underlying persistent state has been
+                     * externally destroyed since the transient
+                     * modification/removal.
+                     */
+                case ItemState.STATUS_STALE_DESTROYED:
+                    /**
+                     * first notify the listeners that this instance has been
+                     * permanently invalidated
+                     */
+                    itemDestroyed(discarded.getId(), data);
+                    // now set state of this instance to 'destroyed'
+                    data.setStatus(ItemImpl.STATUS_DESTROYED);
+                    data.setState(null);
+                    return;
+
+                    /**
+                     * new item that has been transiently added
+                     */
+                case ItemState.STATUS_NEW:
+                    /**
+                     * first notify the listeners that this instance has been
+                     * permanently invalidated
+                     */
+                    itemDestroyed(discarded.getId(), data);
+                    // now set state of this instance to 'destroyed'
+                    // finally dispose state
+                    data.setStatus(ItemImpl.STATUS_DESTROYED);
+                    data.setState(null);
+                    return;
+                }
+            }
+
+            /**
+             * first notify the listeners that this instance has been
+             * invalidated
+             */
+            itemInvalidated(discarded.getId(), data);
+            // now render this instance 'invalid'
+            data.setStatus(ItemImpl.STATUS_INVALIDATED);
-     * Invoked by a shareable <code>NodeImpl</code> when it is has become
-     * transient and has therefore replaced its state. Will inform all other
-     * nodes in the shareable set about this change.
-     *
-     * @param node node that has changed its underlying state
-     */
-    public void becameTransient(NodeImpl node) {
-        NodeState state = (NodeState) node.getItemState();
-
-        NodeImpl n = (NodeImpl) retrieveItem(node.getId());
-        if (n != null && n != node) {
-            n.stateReplaced(state);
-        }
-        shareableNodesCache.stateReplaced(node);
-    }
-
-    /**
-     * Invoked by a shareable <code>NodeImpl</code> when it is has become
-     * persistent and has therefore replaced its state. Will inform all other
-     * nodes in the shareable set about this change.
-     *
-     * @param node node that has changed its underlying state
-     */
-    public void persisted(NodeImpl node) {
-        // item has possibly become shareable on this call: move it
-        // from the main cache to the cache of shareable nodes
-        if (evictItem(node.getNodeId())) {
-            shareableNodesCache.cache(node);
-        }
-
-        NodeState state = (NodeState) node.getItemState();
-
-        NodeImpl n = (NodeImpl) retrieveItem(node.getId());
-        if (n != null && n != node) {
-            n.stateReplaced(state);
-        }
-        shareableNodesCache.stateReplaced(node);
-    }
-
-    /**
-     * Cache of shareable nodes.
+     * Cache of shareable nodes. For performance reasons, methods are not
+     * synchronized and thread-safety must be guaranteed by caller.
-        public synchronized NodeImpl retrieve(NodeId id) {
+        public AbstractNodeData retrieveFirst(NodeId id) {
-                while (iter.hasNext()) {
-                    NodeImpl node = (NodeImpl) iter.next();
-                    if (node != null) {
-                        return node;
+                try {
+                    while (iter.hasNext()) {
+                        AbstractNodeData data = (AbstractNodeData) iter.next();
+                        if (data != null) {
+                            return data;
+                        }
+                } finally {
+                    iter = null;
-        public synchronized NodeImpl retrieve(NodeId id, NodeId parentId) {
+        public AbstractNodeData retrieve(NodeId id, NodeId parentId) {
-                return (NodeImpl) map.get(parentId);
+                return (AbstractNodeData) map.get(parentId);
-        public synchronized void cache(NodeImpl node) {
-            ReferenceMap map = (ReferenceMap) cache.get(node.getId());
+        public void cache(AbstractNodeData data) {
+            NodeId id = data.getNodeState().getNodeId();
+            ReferenceMap map = (ReferenceMap) cache.get(id);
-                cache.put(node.getId(), map);
+                cache.put(id, map);
-            Object old = map.put(node.getParentId(), node);
+            Object old = map.put(data.getPrimaryParentId(), data);
-        public synchronized void evict(NodeImpl node) {
-            ReferenceMap map = (ReferenceMap) cache.get(node.getId());
+        public void evict(AbstractNodeData data) {
+            ReferenceMap map = (ReferenceMap) cache.get(data.getId());
-                map.remove(node.getParentId());
+                map.remove(data.getPrimaryParentId());
-
-        /**
-         * Replace the state of all nodes that are in the same shared set
-         * as the given node.
-         *
-         * @param node node in shared set.
-         */
-        public synchronized void stateReplaced(NodeImpl node) {
-            NodeState state = (NodeState) node.getItemState();
-
-            ReferenceMap map = (ReferenceMap) cache.get(node.getId());
-            if (map != null) {
-                Iterator iter = map.values().iterator();
-                while (iter.hasNext()) {
-                    NodeImpl n = (NodeImpl) iter.next();
-                    if (n != null && n != node) {
-                        n.stateReplaced(state);
-                    }
-                }
-            }
-        }

MOV31 INS31 INS31 INS31 INS31 INS31 INS31 INS44 INS44 INS29 INS83 MOV43 UPD42 MOV42 MOV44 MOV43 INS8 INS43 UPD42 INS83 INS43 INS42 MOV44 MOV43 INS8 INS83 MOV43 UPD42 MOV42 INS44 INS8 INS83 MOV43 INS42 MOV44 MOV8 INS83 MOV43 MOV29 UPD83 UPD43 INS42 MOV44 INS8 MOV29 UPD83 MOV83 INS43 INS42 MOV44 MOV44 MOV8 INS29 UPD39 UPD42 MOV29 UPD83 UPD42 MOV29 MOV83 MOV39 MOV42 MOV44 INS8 INS25 INS60 INS25 INS65 INS43 INS42 INS39 INS42 INS65 INS65 INS65 MOV65 INS43 INS60 INS21 INS41 INS42 INS41 UPD42 MOV42 MOV60 MOV25 INS43 INS42 INS25 UPD43 UPD42 INS60 INS25 UPD43 UPD42 UPD42 INS51 UPD42 MOV42 UPD43 UPD42 UPD43 UPD42 INS65 INS65 MOV65 UPD43 UPD42 INS51 UPD43 UPD42 UPD43 UPD42 INS51 MOV60 INS25 UPD43 UPD42 UPD43 MOV8 UPD43 INS32 UPD66 INS27 INS8 INS43 INS59 UPD27 MOV27 INS8 INS32 UPD66 INS42 INS66 INS42 UPD43 INS32 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS43 MOV59 INS32 INS32 INS32 MOV32 UPD42 MOV42 INS32 INS8 INS8 UPD42 INS83 MOV43 INS59 MOV32 INS8 INS25 UPD42 INS14 INS42 INS8 UPD66 UPD66 UPD42 UPD66 UPD66 INS66 UPD42 UPD42 INS66 INS66 INS42 INS66 MOV32 UPD42 MOV32 INS42 INS8 UPD42 UPD42 INS42 INS8 UPD43 UPD43 INS27 UPD43 UPD43 INS27 INS8 UPD66 INS66 UPD42 UPD42 UPD43 UPD42 INS60 UPD43 UPD42 MOV53 UPD42 UPD42 UPD42 INS21 INS42 INS42 INS42 INS33 INS41 INS42 INS42 INS11 UPD42 MOV21 INS21 INS42 INS42 UPD42 UPD42 UPD42 INS21 INS42 INS42 UPD42 MOV42 UPD42 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS41 MOV32 UPD42 MOV42 UPD42 MOV42 MOV41 INS41 INS42 INS32 INS41 MOV32 INS8 INS8 MOV43 INS52 INS42 INS42 INS60 INS25 INS41 MOV60 INS25 INS25 INS21 MOV25 INS25 MOV60 MOV25 UPD42 MOV21 UPD42 UPD42 UPD42 UPD42 UPD42 INS27 INS27 UPD42 UPD42 UPD42 INS21 INS25 UPD42 UPD42 INS27 INS27 INS25 MOV21 MOV21 UPD42 MOV43 INS59 INS43 UPD42 MOV43 INS32 MOV11 INS43 INS32 INS32 INS32 UPD42 UPD42 INS14 INS60 INS41 INS60 INS41 INS32 INS42 INS42 INS14 INS41 INS41 INS43 INS59 MOV27 INS8 INS42 UPD43 INS27 INS8 UPD42 INS32 INS8 MOV32 INS32 MOV32 INS8 UPD43 INS27 UPD42 MOV42 MOV33 INS32 INS42 INS32 INS27 INS8 UPD42 MOV42 MOV33 INS32 INS42 INS32 INS8 INS54 INS42 INS32 INS42 UPD42 UPD42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS11 INS42 INS42 UPD42 UPD42 UPD42 UPD42 INS38 UPD42 INS42 INS42 INS43 MOV11 INS42 MOV43 INS59 INS14 MOV43 INS59 INS14 INS11 INS42 INS11 MOV43 INS52 INS42 INS42 INS14 INS14 UPD42 MOV42 INS42 INS11 INS21 UPD42 UPD42 INS42 INS33 INS21 INS42 INS42 INS60 INS25 UPD42 INS42 INS42 UPD42 INS21 UPD42 UPD42 INS42 INS42 UPD42 UPD42 UPD42 INS40 INS42 INS42 UPD42 UPD42 INS40 INS42 INS42 INS40 INS32 INS42 INS21 UPD42 INS32 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS50 UPD42 INS32 INS42 UPD42 UPD42 INS40 INS8 INS8 INS32 INS42 INS43 UPD42 MOV43 UPD42 INS43 INS32 INS32 UPD42 UPD43 UPD42 INS42 UPD42 INS42 INS42 MOV11 INS43 INS42 INS32 INS42 MOV11 UPD43 MOV43 UPD42 MOV42 INS32 INS43 INS42 INS43 INS42 MOV43 MOV52 MOV42 UPD42 MOV42 MOV43 INS52 INS42 INS42 INS43 INS32 UPD42 INS7 INS7 INS43 INS59 INS27 INS8 UPD42 UPD45 MOV32 UPD45 INS45 INS32 UPD43 INS32 INS42 INS42 INS32 UPD42 MOV42 INS42 INS32 INS49 INS49 INS49 INS60 INS60 INS21 INS21 INS41 INS49 INS21 INS21 INS21 INS41 INS49 INS21 INS21 INS21 INS41 UPD42 MOV42 UPD42 MOV42 MOV61 INS21 UPD43 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS32 INS42 MOV11 INS42 INS42 INS11 INS32 INS33 INS21 INS41 UPD42 UPD42 INS42 INS42 INS11 UPD42 INS42 INS42 INS32 UPD42 UPD42 INS32 INS42 INS42 INS33 INS42 INS42 INS40 INS40 INS40 UPD43 MOV43 MOV59 UPD43 MOV43 MOV59 MOV32 MOV32 INS40 INS32 MOV32 INS32 INS40 INS32 INS32 INS32 INS7 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS11 UPD43 INS43 INS42 INS42 INS42 INS32 INS43 INS42 INS42 INS42 UPD42 MOV42 INS42 UPD42 INS42 INS32 UPD42 UPD42 INS32 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 MOV32 INS42 UPD42 UPD42 INS40 INS42 INS42 INS33 INS42 INS32 INS42 INS42 INS42 INS40 UPD42 MOV42 UPD42 MOV42 INS33 INS42 INS33 INS43 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD43 UPD42 MOV42 UPD42 UPD42 UPD42 UPD43 UPD42 UPD42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL25 DEL8 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL8 DEL25 DEL42 DEL43 DEL85 DEL5 DEL52 DEL4 DEL3 DEL42 DEL83 DEL42 DEL42 DEL32 DEL40 DEL27 DEL42 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL25 DEL42 DEL41 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL52 DEL42 DEL42 DEL42 DEL42 DEL14 DEL7 DEL21 DEL42 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL52 DEL4 DEL3 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL43 DEL42 DEL44 DEL60 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL52 DEL4 DEL3 DEL59 DEL60 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL42 DEL44 DEL43 DEL42 DEL32 DEL59 DEL60 DEL8 DEL31 DEL43 DEL42 DEL42 DEL44 DEL31 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL44 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL85 DEL5 DEL42 DEL44 DEL43 DEL52 DEL42 DEL42 DEL42 DEL42 DEL42 DEL14 DEL41 DEL8 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL85 DEL5 DEL42 DEL44 DEL42 DEL43 DEL52 DEL42 DEL42 DEL42 DEL42 DEL42 DEL14 DEL41 DEL8 DEL31 DEL83 DEL42 DEL31 DEL42 DEL7 DEL33 DEL27 DEL41 DEL65 DEL65 DEL29 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL52 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL32 DEL21 DEL8 DEL25 DEL42 DEL27 DEL42 DEL42 DEL42 DEL43 DEL32 DEL11 DEL42 DEL43 DEL42 DEL32 DEL32 DEL11 DEL42 DEL42 DEL27 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL60 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL27 DEL27 DEL21 DEL8 DEL25 DEL21 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL32 DEL32 DEL11 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL27 DEL27 DEL8 DEL25 DEL8 DEL31 DEL83 DEL83 DEL83 DEL42 DEL32 DEL42 DEL32 DEL83 DEL42 DEL43 DEL42 DEL43 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL11 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL27 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL61 DEL8 DEL25 DEL8 DEL31
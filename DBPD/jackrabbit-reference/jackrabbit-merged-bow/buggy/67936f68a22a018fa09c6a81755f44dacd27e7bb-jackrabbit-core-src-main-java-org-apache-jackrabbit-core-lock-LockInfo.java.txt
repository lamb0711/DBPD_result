JCR-1590: JSR 283: Locking

Another code cleanup step: Merge AbstractLockInfo to LockInfo.


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@803509 13f79535-47bb-0310-9956-ffa450edef68

- * Lock information interface.
+ * Internal lock information.
-public interface LockInfo {
+public abstract class LockInfo {
-     * Return the ID of the lock holding node
-     * @return the id
+     * Constant for the undefined or infinite timeout.
-    public NodeId getId();
-    
-    /**
-     * Return the lock owner.
-     * 
-     * @return lock owner
-     */
-    public String getLockOwner();
-    
-    /**
-     * Return a flag indicating whether the lock is deep.
-     * 
-     * @return <code>true</code> if the lock is deep;
-     *         <code>false</code> otherwise
-     */
-    public boolean isDeep();
-    
-    /**
-     * Return a flag indicating whether the session given is lock holder. 
-     *
-     * @param session session to compare with
-     */
-    public boolean isLockHolder(Session session);
+    static final long TIMEOUT_INFINITE = Long.MAX_VALUE;
-     * Return the session currently holding the lock
-     *
-     * @return session currently holding the lock
+     * Constant for the expired timeout.
-    SessionImpl getLockHolder();
+    static final long TIMEOUT_EXPIRED = -1;
-     * Set the session currently holding the lock
-     *
-     * @param lockHolder session currently holding the lock
+     * Lock token
-    void setLockHolder(SessionImpl lockHolder);
+    protected final LockToken lockToken;
+
+    /**
+     * Flag indicating whether lock is session scoped
+     */
+    protected final boolean sessionScoped;
+
+    /**
+     * Flag indicating whether lock is deep
+     */
+    protected final boolean deep;
+
+    /**
+     * Lock owner, determined on creation time
+     */
+    protected final String lockOwner;
+
+    /**
+     * Flag indicating whether this lock is live
+     */
+    private boolean live;
+
+    /**
+     * Session currently holding lock
+     */
+    private SessionImpl lockHolder;
+
+    /**
+     * Create a new instance of this class.
+     *
+     * @param lockToken     lock token
+     * @param sessionScoped whether lock token is session scoped
+     * @param deep          whether lock is deep
+     * @param lockOwner     owner of lock
+     */
+    protected LockInfo(LockToken lockToken, boolean sessionScoped, boolean deep,
+                    String lockOwner) {
+        this(lockToken, sessionScoped, deep, lockOwner, TIMEOUT_INFINITE);
+    }
+
+    /**
+     * Create a new instance of this class.
+     *
+     * @param lockToken     lock token
+     * @param sessionScoped whether lock token is session scoped
+     * @param deep          whether lock is deep
+     * @param lockOwner     owner of lock
+     * @param timeoutHint   the timeoutHint
+     */
+    protected LockInfo(LockToken lockToken, boolean sessionScoped, boolean deep,
+                            String lockOwner, long timeoutHint) {
+        this.lockToken = lockToken;
+        this.sessionScoped = sessionScoped;
+        this.deep = deep;
+        this.lockOwner = lockOwner;
+        // TODO: TOBEFIXED for 2.0 respect and deal with timeout hint.
+    }
-    LockToken getLockToken();
+    public LockToken getLockToken() {
+        return lockToken;
+    }
+
+    /**
+     * Return the ID of the lock holding node
+     * @return the id
+     */
+    public NodeId getId() {
+        return lockToken.getId();
+    }
+
+    /**
+     * Return the lock owner.
+     * 
+     * @return lock owner
+     */
+    public String getLockOwner() {
+        return lockOwner;
+    }
+
+    /**
+     * Return a flag indicating whether the lock is deep.
+     * 
+     * @return <code>true</code> if the lock is deep;
+     *         <code>false</code> otherwise
+     */
+    public boolean isDeep() {
+        return deep;
+    }
+
+    /**
+     * Return a flag indicating whether the session given is lock holder. 
+     *
+     * @param session session to compare with
+     */
+    public boolean isLockHolder(Session session) {
+        return lockHolder == session;
+    }
+
+    /**
+     * Return the session currently holding the lock
+     *
+     * @return session currently holding the lock
+     */
+    public SessionImpl getLockHolder() {
+        return lockHolder;
+    }
+
+    /**
+     * Set the session currently holding the lock
+     *
+     * @param lockHolder session currently holding the lock
+     */
+    public void setLockHolder(SessionImpl lockHolder) {
+        this.lockHolder = lockHolder;
+    }
-    public boolean isLive();
+    public boolean isLive() {
+        return live;
+    }
+     *
-    void setLive(boolean live);
+    public void setLive(boolean live) {
+        this.live = live;
+    }
-    boolean mayChange();
+    public boolean mayChange() {
+        return live;
+    }
-    public boolean isSessionScoped();
+    public boolean isSessionScoped() {
+        return sessionScoped;
+    }
-    public long getSecondsRemaining();
+    public long getSecondsRemaining() {
+        // TODO: TOBEFIXED for 2.0
+        // TODO  - add support for timeout specified by the API user -> LockManager#lock
+        return isLive() ? TIMEOUT_INFINITE : TIMEOUT_EXPIRED;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public String toString() {
+        StringBuffer buffer = new StringBuffer();
+        buffer.append('(');
+        if (deep) {
+            buffer.append("deep ");
+        }
+        if (sessionScoped) {
+            buffer.append("session ");
+        }
+        buffer.append("holder:");
+        if (lockHolder != null) {
+            buffer.append(lockHolder.getUserID());
+        } else {
+            buffer.append("none");
+        }
+        buffer.append("owner:").append(lockOwner);
+        buffer.append(')');
+        return buffer.toString();
+    }

MOV31 INS83 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS29 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS39 INS59 INS29 INS83 INS43 INS59 INS29 INS83 INS42 INS44 INS44 INS44 INS44 INS8 INS29 INS83 INS42 INS44 INS44 INS44 INS44 INS44 INS8 INS83 INS8 INS8 INS8 INS8 INS8 INS83 INS8 INS83 INS8 INS8 INS83 INS8 INS83 INS8 INS8 INS8 INS29 INS83 INS43 INS42 INS8 UPD66 INS65 INS42 INS40 INS65 INS42 INS38 INS65 INS42 INS42 INS65 INS42 INS65 INS42 INS65 INS42 INS42 INS65 INS42 INS65 INS42 INS42 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS39 INS42 INS39 INS42 INS43 INS42 INS17 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS39 INS42 INS39 INS42 INS43 INS42 INS39 INS42 INS21 INS21 INS21 INS21 INS41 INS41 INS41 INS41 INS41 INS41 INS21 INS41 INS21 INS41 INS41 INS41 INS65 INS42 INS60 INS21 INS25 INS25 INS21 INS25 INS21 INS21 INS41 INS66 INS66 INS34 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS7 INS7 INS7 INS7 INS42 INS32 INS42 INS42 INS27 INS42 INS7 INS42 INS7 INS42 INS42 INS16 INS65 INS43 INS59 INS32 INS42 INS8 INS42 INS8 INS32 INS27 INS8 INS8 INS32 INS32 INS32 INS22 INS42 INS22 INS42 INS22 INS42 INS22 INS42 INS42 INS42 INS42 INS42 INS22 INS42 INS22 INS42 INS32 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS13 INS21 INS21 INS42 INS42 INS45 INS42 INS33 INS21 INS21 INS32 INS42 INS42 INS42 INS42 INS13 INS42 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS43 INS32 INS32 INS32 INS32 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS42
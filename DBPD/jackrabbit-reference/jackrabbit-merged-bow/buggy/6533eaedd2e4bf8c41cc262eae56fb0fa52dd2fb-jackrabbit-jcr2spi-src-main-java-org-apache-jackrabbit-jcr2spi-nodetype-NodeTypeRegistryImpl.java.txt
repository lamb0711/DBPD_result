JCR-1547: JCR2SPI: remove dependency to state-package within entprovider interface

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@650417 13f79535-47bb-0310-9956-ffa450edef68

+import EDU.oswego.cs.dl.util.concurrent.ConcurrentReaderHashMap;
-import org.apache.jackrabbit.jcr2spi.state.NodeState;
-import org.apache.jackrabbit.jcr2spi.state.Status;
-import org.apache.jackrabbit.jcr2spi.state.PropertyState;
-import org.apache.jackrabbit.jcr2spi.hierarchy.PropertyEntry;
-import org.apache.jackrabbit.spi.QPropertyDefinition;
+import org.apache.jackrabbit.spi.QPropertyDefinition;
+import org.apache.jackrabbit.spi.QItemDefinition;
-import org.apache.jackrabbit.spi.commons.nodetype.NodeTypeConflictException;
-import org.apache.jackrabbit.spi.commons.name.NameConstants;
-import org.slf4j.LoggerFactory;
+import org.slf4j.LoggerFactory;
-
-import EDU.oswego.cs.dl.util.concurrent.ConcurrentReaderHashMap;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.TreeSet;
+import java.util.HashMap;
-        EffectiveNodeTypeImpl ent = validator.validateNodeTypeDef(ntDef, registeredNTDefs);
+        EffectiveNodeType ent = validator.validateNodeTypeDef(ntDef, registeredNTDefs);
-        EffectiveNodeTypeImpl ent = validator.validateNodeTypeDef(ntd, registeredNTDefs);
+        EffectiveNodeType ent = validator.validateNodeTypeDef(ntd, registeredNTDefs);
-            throws NodeTypeConflictException, NoSuchNodeTypeException {
+            throws ConstraintViolationException, NoSuchNodeTypeException {
-        throws NodeTypeConflictException, NoSuchNodeTypeException {
+        throws ConstraintViolationException, NoSuchNodeTypeException {
-     * @see EffectiveNodeTypeProvider#getEffectiveNodeType(NodeState)
-     * @inheritDoc
-     * In case the status of the given node state is not {@link Status#EXISTING}
-     * the transiently added mixin types are taken into account as well.
+     * @see EffectiveNodeTypeProvider#getEffectiveNodeType(QNodeTypeDefinition, Map)
-    public EffectiveNodeType getEffectiveNodeType(NodeState nodeState) throws ConstraintViolationException, NoSuchNodeTypeException {
-        try {
-            Name[] allNtNames;
-            if (nodeState.getStatus() == Status.EXISTING) {
-                allNtNames = nodeState.getNodeTypeNames();
-            } else {
-                // TODO: check if correct (and only used for creating new)
-                Name primaryType = nodeState.getNodeTypeName();
-                allNtNames = new Name[] { primaryType }; // default
-                try {
-                    PropertyEntry pe = nodeState.getNodeEntry().getPropertyEntry(NameConstants.JCR_MIXINTYPES, true);
-                    if (pe != null) {
-                        PropertyState mixins = pe.getPropertyState();
-                        QValue[] values = mixins.getValues();
-                        allNtNames = new Name[values.length + 1];
-                        for (int i = 0; i < values.length; i++) {
-                            allNtNames[i] = values[i].getName();
-                        }
-                        allNtNames[values.length] = primaryType;
-                    } // else: no jcr:mixinTypes property exists -> ignore
-                } catch (RepositoryException e) {
-                    // unexpected error: ignore
-                }
+    public EffectiveNodeType getEffectiveNodeType(QNodeTypeDefinition ntd, Map ntdMap)
+            throws ConstraintViolationException, NoSuchNodeTypeException {
+        TreeSet mergedNodeTypes = new TreeSet();
+        TreeSet inheritedNodeTypes = new TreeSet();
+        TreeSet allNodeTypes = new TreeSet();
+        Map namedItemDefs = new HashMap();
+        List unnamedItemDefs = new ArrayList();
+        Set supportedMixins = null;
+
+        Name ntName = ntd.getName();
+        // prepare new instance
+        mergedNodeTypes.add(ntName);
+        allNodeTypes.add(ntName);
+
+        Name[] smixins = ntd.getSupportedMixinTypes();
+
+        if (smixins != null) {
+            supportedMixins = new HashSet();
+            for (int i = 0; i < smixins.length; i++) {
+                supportedMixins.add(smixins[i]);
-            return getEffectiveNodeType(allNtNames);
-        } catch (NodeTypeConflictException e) {
-            String msg = "Internal error: failed to build effective node type from node types defined with " + nodeState;
-            log.debug(msg);
-            throw new ConstraintViolationException(msg, e);
+
+        // map of all item definitions (maps id to definition)
+        // used to effectively detect ambiguous child definitions where
+        // ambiguity is defined in terms of definition identity
+        Set itemDefIds = new HashSet();
+
+        QNodeDefinition[] cnda = ntd.getChildNodeDefs();
+        for (int i = 0; i < cnda.length; i++) {
+            // check if child node definition would be ambiguous within
+            // this node type definition
+            if (itemDefIds.contains(cnda[i])) {
+                // conflict
+                String msg;
+                if (cnda[i].definesResidual()) {
+                    msg = ntName + " contains ambiguous residual child node definitions";
+                } else {
+                    msg = ntName + " contains ambiguous definitions for child node named "
+                            + cnda[i].getName();
+                }
+                log.debug(msg);
+                throw new ConstraintViolationException(msg);
+            } else {
+                itemDefIds.add(cnda[i]);
+            }
+            if (cnda[i].definesResidual()) {
+                // residual node definition
+                unnamedItemDefs.add(cnda[i]);
+            } else {
+                // named node definition
+                Name name = cnda[i].getName();
+                List defs = (List) namedItemDefs.get(name);
+                if (defs == null) {
+                    defs = new ArrayList();
+                    namedItemDefs.put(name, defs);
+                }
+                if (defs.size() > 0) {
+                    /**
+                     * there already exists at least one definition with that
+                     * name; make sure none of them is auto-create
+                     */
+                    for (int j = 0; j < defs.size(); j++) {
+                        QItemDefinition qDef = (QItemDefinition) defs.get(j);
+                        if (cnda[i].isAutoCreated() || qDef.isAutoCreated()) {
+                            // conflict
+                            String msg = "There are more than one 'auto-create' item definitions for '"
+                                    + name + "' in node type '" + ntName + "'";
+                            log.debug(msg);
+                            throw new ConstraintViolationException(msg);
+                        }
+                    }
+                }
+                defs.add(cnda[i]);
+            }
+        }
+        QPropertyDefinition[] pda = ntd.getPropertyDefs();
+        for (int i = 0; i < pda.length; i++) {
+            // check if property definition would be ambiguous within
+            // this node type definition
+            if (itemDefIds.contains(pda[i])) {
+                // conflict
+                String msg;
+                if (pda[i].definesResidual()) {
+                    msg = ntName + " contains ambiguous residual property definitions";
+                } else {
+                    msg = ntName + " contains ambiguous definitions for property named "
+                            + pda[i].getName();
+                }
+                log.debug(msg);
+                throw new ConstraintViolationException(msg);
+            } else {
+                itemDefIds.add(pda[i]);
+            }
+            if (pda[i].definesResidual()) {
+                // residual property definition
+                unnamedItemDefs.add(pda[i]);
+            } else {
+                // named property definition
+                Name name = pda[i].getName();
+                List defs = (List) namedItemDefs.get(name);
+                if (defs == null) {
+                    defs = new ArrayList();
+                    namedItemDefs.put(name, defs);
+                }
+                if (defs.size() > 0) {
+                    /**
+                     * there already exists at least one definition with that
+                     * name; make sure none of them is auto-create
+                     */
+                    for (int j = 0; j < defs.size(); j++) {
+                        QItemDefinition qDef = (QItemDefinition) defs.get(j);
+                        if (pda[i].isAutoCreated() || qDef.isAutoCreated()) {
+                            // conflict
+                            String msg = "There are more than one 'auto-create' item definitions for '"
+                                    + name + "' in node type '" + ntName + "'";
+                            log.debug(msg);
+                            throw new ConstraintViolationException(msg);
+                        }
+                    }
+                }
+                defs.add(pda[i]);
+            }
+        }
+
+        // create empty effective node type instance
+        EffectiveNodeTypeImpl ent = new EffectiveNodeTypeImpl(mergedNodeTypes,
+                inheritedNodeTypes, allNodeTypes, namedItemDefs,
+                unnamedItemDefs, supportedMixins);
+
+        // resolve supertypes recursively
+        Name[] supertypes = ntd.getSupertypes();
+        if (supertypes.length > 0) {
+            EffectiveNodeTypeImpl effSuperType = (EffectiveNodeTypeImpl) getEffectiveNodeType(supertypes, ntdMap);
+            ent.internalMerge(effSuperType, true);
+        }
+        return ent;
-                ent = EffectiveNodeTypeImpl.create(this, ntd, ntdCache);
+                ent = getEffectiveNodeType(ntd, ntdCache);
-            } catch (NodeTypeConflictException ntce) {
+            } catch (ConstraintViolationException e) {
-                throw new NoSuchNodeTypeException(msg, ntce);
+                throw new NoSuchNodeTypeException(msg, e);
-     * @throws NodeTypeConflictException
+     * @throws ConstraintViolationException
-        throws NodeTypeConflictException, NoSuchNodeTypeException {
+        throws ConstraintViolationException, NoSuchNodeTypeException {
-                        EffectiveNodeTypeImpl ent = EffectiveNodeTypeImpl.create(this, ntd, ntdCache);
+                        EffectiveNodeType ent = getEffectiveNodeType(ntd, ntdCache);
-                            result = ent;
+                            result = (EffectiveNodeTypeImpl) ent;
-                            result = result.merge(ent);
+                            result = result.merge((EffectiveNodeTypeImpl) ent);
-
-
-    private void internalRegister(QNodeTypeDefinition ntd, EffectiveNodeTypeImpl ent) {
+    private void internalRegister(QNodeTypeDefinition ntd, EffectiveNodeType ent) {

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 UPD40 UPD40 UPD40 UPD40 UPD40 UPD43 UPD43 INS44 UPD43 UPD42 UPD42 UPD43 UPD42 INS43 INS42 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS21 INS21 INS60 INS25 INS60 MOV60 INS24 MOV60 INS24 INS60 INS60 INS25 INS41 UPD42 UPD43 INS43 INS43 UPD42 INS42 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 MOV43 INS59 INS32 INS32 MOV5 INS59 INS27 INS8 INS43 INS59 UPD5 INS58 INS27 INS37 INS8 UPD5 INS58 MOV27 INS37 INS8 MOV43 INS59 MOV5 INS59 INS27 INS8 INS42 UPD42 UPD42 INS42 INS42 INS69 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS33 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS24 INS42 INS42 INS14 UPD43 INS42 INS32 INS39 INS59 INS42 INS40 INS42 INS25 INS25 UPD43 UPD42 INS39 INS59 UPD40 INS42 INS25 INS25 INS42 INS14 INS42 INS32 INS40 INS34 INS60 INS21 UPD43 INS43 INS43 INS43 INS43 INS43 INS43 INS42 INS42 INS42 INS42 INS7 MOV58 INS27 MOV37 INS8 INS43 UPD42 INS42 INS42 INS42 INS34 INS32 INS8 INS8 INS32 INS8 INS8 UPD42 UPD42 UPD42 INS42 INS34 INS32 INS8 INS8 INS32 INS8 INS8 MOV43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV43 INS59 INS32 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS40 INS21 INS42 UPD42 MOV42 UPD42 MOV42 INS2 INS60 INS25 INS21 MOV53 INS21 INS2 INS42 INS21 MOV60 INS60 INS25 INS25 INS21 INS42 INS42 INS2 INS60 INS25 INS21 INS53 INS21 INS2 INS42 INS21 INS60 INS60 INS25 INS25 INS21 INS42 INS11 INS42 INS42 INS42 INS9 INS43 INS32 INS42 INS42 MOV43 INS59 INS32 INS8 MOV8 INS32 INS32 INS42 INS42 INS32 INS43 INS43 INS59 INS27 INS8 INS27 INS8 INS32 UPD42 MOV42 MOV42 INS43 INS59 INS32 INS8 INS8 INS32 INS14 INS32 INS42 INS42 INS32 INS43 INS59 INS43 INS59 INS27 INS8 INS27 INS8 INS32 INS43 INS32 UPD43 UPD42 INS42 INS42 INS42 INS2 INS42 INS2 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS2 INS42 INS42 INS2 INS42 UPD42 INS42 INS42 INS11 INS42 INS33 MOV21 INS21 INS32 INS34 INS24 INS42 INS42 INS2 INS42 INS42 MOV2 UPD42 MOV42 INS21 MOV21 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS2 INS42 INS42 INS2 INS42 INS42 INS32 INS42 INS42 INS11 INS42 INS33 INS21 INS21 INS32 INS34 INS24 INS42 INS42 INS2 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS7 INS42 INS42 INS42 INS42 INS2 UPD42 INS43 INS32 INS32 INS42 INS42 INS58 INS27 INS37 INS8 INS42 INS42 UPD42 INS7 UPD42 MOV42 INS42 INS42 INS42 INS42 INS2 INS42 INS43 INS32 INS7 INS32 INS42 INS42 INS58 INS27 INS37 INS8 INS42 INS42 UPD42 UPD42 INS42 INS27 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS14 INS42 INS42 INS42 INS42 INS39 INS59 INS42 INS32 INS42 MOV60 INS25 INS42 INS27 INS42 INS27 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS14 INS42 INS42 INS42 INS42 INS39 INS59 INS42 INS32 INS42 INS60 INS25 INS42 INS45 INS42 INS45 INS32 INS43 INS42 INS34 INS42 INS42 UPD43 UPD27 MOV27 INS8 INS42 INS45 INS42 INS45 INS32 INS43 INS42 INS34 INS42 INS42 INS43 INS59 INS27 INS8 INS43 INS2 UPD42 MOV42 INS42 UPD42 UPD42 INS11 INS32 INS32 MOV60 MOV21 INS53 INS2 INS42 INS42 UPD42 MOV42 INS42 INS11 INS32 INS32 MOV60 INS21 INS53 INS42 INS42 INS42 INS43 INS32 INS2 INS42 INS42 INS42 UPD43 INS14 UPD42 MOV42 INS42 INS43 INS32 INS2 INS42 INS42 INS42 INS43 INS32 INS14 UPD42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 UPD42 INS27 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS11 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 UPD45 UPD42 INS45 INS42 INS43 INS42 INS11 INS42 INS43 INS42 INS42 DEL40 DEL26 DEL66 DEL42 DEL42 DEL67 DEL65 DEL66 DEL65 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL4 DEL3 DEL32 DEL40 DEL9 DEL32 DEL42 DEL33 DEL42 DEL42 DEL32 DEL40 DEL2 DEL42 DEL32 DEL40 DEL27 DEL42 DEL40 DEL34 DEL27 DEL3 DEL7 DEL21 DEL2 DEL32 DEL7 DEL21 DEL8 DEL24 DEL8 DEL25 DEL8 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL8 DEL25 DEL32 DEL41 DEL8 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL42 DEL52 DEL42 DEL52 DEL42 DEL42
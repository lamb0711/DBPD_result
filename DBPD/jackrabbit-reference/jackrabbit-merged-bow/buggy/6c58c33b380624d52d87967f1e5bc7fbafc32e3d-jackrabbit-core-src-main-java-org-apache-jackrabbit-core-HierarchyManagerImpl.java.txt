JCR-1104 - JSR 283 support
- shareble nodes (work in progress)
- improve share-cycle detection

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@646336 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Collections;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+     * Return all parents of a node. A shareable node has possibly more than
+     * one parent.
+     *
+     * @param state item state
+     * @return set of parent <code>NodeId</code>s. If state has no parent,
+     *         array has length <code>0</code>.
+     */
+    protected Set getParentIds(ItemState state) {
+        if (state.isNode()) {
+            // if this is a node, quickly check whether it is shareable and
+            // whether it contains more than one parent
+            NodeState ns = (NodeState) state;
+            Set s = ns.getSharedSet();
+            if (s.size() > 1) {
+                return s;
+            }
+        }
+        NodeId parentId = getParentId(state);
+        if (parentId != null) {
+            LinkedHashSet s = new LinkedHashSet();
+            s.add(parentId);
+            return s;
+        }
+        return Collections.EMPTY_SET;
+    }
+
+    /**
-        
+
-    
+
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean isShareAncestor(NodeId ancestor, NodeId descendant)
+            throws ItemNotFoundException, RepositoryException {
+        if (ancestor.equals(descendant)) {
+            // can't be ancestor of self
+            return false;
+        }
+        try {
+            ItemState state = getItemState(descendant);
+            Set parentIds = getParentIds(state);
+            while (parentIds.size() > 0) {
+                if (parentIds.contains(ancestor)) {
+                    return true;
+                }
+                Set grandparentIds = new LinkedHashSet();
+                Iterator iter = parentIds.iterator();
+                while (iter.hasNext()) {
+                    NodeId parentId = (NodeId) iter.next();
+                    grandparentIds.addAll(getParentIds(getItemState(parentId)));
+                }
+                parentIds = grandparentIds;
+            }
+            // not an ancestor
+            return false;
+        } catch (NoSuchItemStateException nsise) {
+            String msg = "failed to determine degree of relationship of "
+                    + ancestor + " and " + descendant;
+            log.debug(msg);
+            throw new ItemNotFoundException(msg, nsise);
+        } catch (ItemStateException ise) {
+            String msg = "failed to determine degree of relationship of "
+                    + ancestor + " and " + descendant;
+            log.debug(msg);
+            throw new RepositoryException(msg, ise);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public int getShareRelativeDepth(NodeId ancestor, ItemId descendant)
+            throws ItemNotFoundException, RepositoryException {
+
+        if (ancestor.equals(descendant)) {
+            return 0;
+        }
+        int depth = 1;
+        try {
+            ItemState state = getItemState(descendant);
+            if (state.hasOverlayedState()) {
+                state = state.getOverlayedState();
+            }
+            Set parentIds = getParentIds(state);
+            while (parentIds.size() > 0) {
+                if (parentIds.contains(ancestor)) {
+                    return depth;
+                }
+                depth++;
+                Set grandparentIds = new LinkedHashSet();
+                Iterator iter = parentIds.iterator();
+                while (iter.hasNext()) {
+                    NodeId parentId = (NodeId) iter.next();
+                    state = getItemState(parentId);
+                    if (state.hasOverlayedState()) {
+                        state = state.getOverlayedState();
+                    }
+                    grandparentIds.addAll(getParentIds(state));
+                }
+                parentIds = grandparentIds;
+            }
+            // not an ancestor
+            return -1;
+        } catch (NoSuchItemStateException nsise) {
+            String msg = "failed to determine degree of relationship of "
+                    + ancestor + " and " + descendant;
+            log.debug(msg);
+            throw new ItemNotFoundException(msg, nsise);
+        } catch (ItemStateException ise) {
+            String msg = "failed to determine degree of relationship of "
+                    + ancestor + " and " + descendant;
+            log.debug(msg);
+            throw new RepositoryException(msg, ise);
+        }
+    }
+

INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS31 INS31 INS31 INS29 INS83 INS43 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS43 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS43 INS43 INS8 INS65 INS65 INS65 INS42 INS43 INS42 INS25 INS60 INS25 INS41 INS65 INS43 INS42 INS43 INS42 INS42 INS42 INS25 INS54 INS65 INS43 INS42 INS43 INS42 INS42 INS42 INS25 INS60 INS54 INS66 INS66 INS42 INS66 INS66 INS66 INS42 INS32 INS8 INS43 INS59 INS27 INS8 INS40 INS65 INS42 INS42 INS32 INS8 INS8 INS12 INS12 INS65 INS42 INS42 INS32 INS8 INS39 INS59 INS8 INS12 INS12 INS42 INS42 INS60 INS60 INS25 INS42 INS42 INS32 INS42 INS33 INS60 INS21 INS41 INS42 INS42 INS42 INS41 INS60 INS60 INS61 INS41 INS44 INS8 INS44 INS8 INS42 INS42 INS42 INS41 INS42 INS34 INS60 INS25 INS60 INS61 INS41 INS44 INS8 INS44 INS8 INS43 INS59 INS43 INS59 INS27 INS8 INS42 INS42 INS43 INS59 INS32 INS42 INS9 INS43 INS59 INS43 INS59 INS27 INS8 INS9 INS43 INS42 INS60 INS21 INS53 INS43 INS42 INS60 INS21 INS53 INS34 INS43 INS59 INS32 INS8 INS43 INS59 INS27 INS8 INS38 INS43 INS42 INS60 INS21 INS53 INS43 INS42 INS60 INS21 INS53 INS42 INS42 INS11 INS42 INS42 INS32 INS32 INS34 INS41 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS34 INS25 INS60 INS60 INS61 INS21 INS42 INS43 INS59 INS32 INS14 INS42 INS43 INS59 INS32 INS14 INS42 INS42 INS32 INS42 INS42 INS21 INS42 INS42 INS32 INS32 INS34 INS25 INS21 INS60 INS60 INS61 INS21 INS34 INS42 INS43 INS59 INS32 INS14 INS42 INS43 INS59 INS32 INS14 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS8 INS43 INS59 INS43 INS59 INS32 INS8 INS7 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS7 INS42 INS42 INS42 INS42 INS32 INS8 INS37 INS43 INS59 INS43 INS59 INS32 INS8 INS7 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS41 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS60 INS21 INS42 INS42 INS45 INS42 INS45 INS42 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS41 INS42 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS60 INS21 INS25 INS21 INS42 INS42 INS45 INS42 INS45 INS42 INS42 INS45 INS42 INS45 INS42 INS42 INS9 INS43 INS42 INS42 INS43 INS59 INS32 INS42 INS42 INS42 INS43 INS42 INS42 INS43 INS59 INS7 INS32 INS8 INS32 INS42 INS42 INS42 INS11 INS42 INS42 INS32 INS42 INS42 INS42 INS11 INS42 INS32 INS42 INS42 INS21 INS42 INS42 INS32 INS43 INS32 INS42 INS32 INS43 INS32 INS42 INS42 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42
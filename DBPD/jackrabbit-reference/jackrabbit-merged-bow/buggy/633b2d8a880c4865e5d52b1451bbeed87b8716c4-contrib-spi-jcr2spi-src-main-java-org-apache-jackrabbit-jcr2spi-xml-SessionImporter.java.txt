fixed: move, reorder (work in progress)
fixed: locktoken transfer
fixed: recursive transient removal of invalidated tree fails (restoreTests)
improve: simplify usage of workspace operations
fixed: store original itemId with transient operations in order to properly reflect the changelog upon batch creation
fixed: workspace import doesn't invalidate
fixed: session import uuid handling




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@513279 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeConflictException;
+import org.apache.jackrabbit.uuid.UUID;
+import java.util.Arrays;
+import java.util.ArrayList;
+
-           // a valid child node with that name already exists...
-           NodeEntry entry = parentEntry.getNodeEntry(nodeInfo.getName(), Path.INDEX_DEFAULT);
-           NodeState existing = null;
-               existing = entry.getNodeState();
+               // a valid child node with that name already exists
+               NodeEntry entry = parentEntry.getNodeEntry(nodeInfo.getName(), Path.INDEX_DEFAULT);
+               NodeState existing = entry.getNodeState();
+
+               QNodeDefinition def = existing.getDefinition();
+               if (!def.allowsSameNameSiblings()) {
+                   // existing doesn't allow same-name siblings, check for conflicts
+                   EffectiveNodeType entExisting = session.getValidator().getEffectiveNodeType(existing);
+                   if (def.isProtected() && entExisting.includesNodeType(nodeInfo.getNodeTypeName()))
+                   {
+                       // skip protected node
+                       parents.push(null); // push null onto stack for skipped node
+                       log.debug("skipping protected node " + LogUtil.safeGetJCRPath(existing, session.getNamespaceResolver()));
+                       return;
+                   }
+                   if (def.isAutoCreated() && entExisting.includesNodeType(nodeInfo.getNodeTypeName()))
+                   {
+                       // this node has already been auto-created, no need to create it
+                       nodeState = existing;
+                   } else {
+                       throw new ItemExistsException(LogUtil.safeGetJCRPath(existing, session.getNamespaceResolver()));
+                   }
+               }
+           } catch (NoSuchItemStateException e) {
+               // 'existing' doesn't exist any more -> ignore
-               // should not occur. existance has been checked before
-               throw new RepositoryException(e);
-           }
-           QNodeDefinition def = existing.getDefinition();
-           if (!def.allowsSameNameSiblings()) {
-               // existing doesn't allow same-name siblings, check for conflicts
-               EffectiveNodeType entExisting = session.getValidator().getEffectiveNodeType(existing);
-               if (def.isProtected() && entExisting.includesNodeType(nodeInfo.getNodeTypeName())) {
-                   // skip protected node
-                   parents.push(null); // push null onto stack for skipped node
-                   log.debug("skipping protected node " + LogUtil.safeGetJCRPath(existing, session.getNamespaceResolver()));
-                   return;
-               }
-               if (def.isAutoCreated() && entExisting.includesNodeType(nodeInfo.getNodeTypeName())) {
-                   // this node has already been auto-created, no need to create it
-                   nodeState = existing;
-               } else {
-                   throw new ItemExistsException(LogUtil.safeGetJCRPath(existing, session.getNamespaceResolver()));
-               }
+               // undefined internal error
+               String msg = "Internal error. Failed to retrieve existing nodeState.";
+               log.debug(msg);
+               throw new RepositoryException(msg, e);
+               // make sure the import does not define a uuid without having
+               // a primaryType or mixin that makes the new node referenceable
+               checkIncludesMixReferenceable(nodeInfo);
+
-                   String msg = "Internal error: failed to retrieve node state";
+                   String msg = "Internal error: failed to retrieve conflicting node state";
+                String newUUID = UUID.randomUUID().toString();
-                nodeInfo.setUUID(null);
+                nodeInfo.setUUID(newUUID);
-                    EffectiveNodeType ent = session.getValidator().getEffectiveNodeType(nodeState);
-                    if (ent.includesNodeType(QName.MIX_REFERENCEABLE)) {
-                        refTracker.mappedUUIDs(originalUUID, nodeState.getUniqueID());
-                    }
+                    refTracker.mappedUUIDs(originalUUID, newUUID);
-                Operation op = Remove.create(conflicting.getNodeState(), parent);
+                Operation op = Remove.create(conflicting.getNodeState());
-                op = Remove.create(conflicting.getNodeState(), parent);
+                op = Remove.create(conflicting.getNodeState());
-                    Operation rm = Remove.create(conflicting, parent);
+                    Operation rm = Remove.create(conflicting);
+
+    /**
+     * Validate the given <code>NodeInfo</code>: make sure, that if a uuid is
+     * defined, the primary or the mixin types include mix:referenceable.
+     *
+     * @param nodeInfo
+     * @throws RepositoryException
+     */
+    private void checkIncludesMixReferenceable(Importer.NodeInfo nodeInfo) throws RepositoryException {
+        List l = new ArrayList();
+        l.add(nodeInfo.getNodeTypeName());
+        l.addAll(Arrays.asList(nodeInfo.getMixinNames()));
+        if (l.contains(QName.MIX_REFERENCEABLE)) {
+            // shortcut
+            return;
+        }
+        QName[] ntNames = (QName[]) l.toArray(new QName[l.size()]);
+        try {
+            EffectiveNodeType ent = session.getValidator().getEffectiveNodeType(ntNames);
+            if (!ent.includesNodeType(QName.MIX_REFERENCEABLE)) {
+                throw new ConstraintViolationException("XML defines jcr:uuid without defining import node to be referenceable.");
+            }
+        } catch (NodeTypeConflictException e) {
+            throw new RepositoryException("Internal error", e);
+        }
+    }

INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS31 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS65 INS65 INS65 INS43 INS42 INS42 INS60 INS21 INS21 INS25 INS60 INS54 INS8 INS60 INS66 INS66 INS42 INS42 INS40 INS43 INS59 INS32 INS32 INS32 INS8 INS5 INS59 MOV8 INS12 INS54 INS43 INS59 INS8 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS40 INS41 INS43 INS85 INS42 INS11 INS44 INS8 MOV8 INS12 INS12 INS42 INS42 INS32 INS42 INS21 INS43 INS42 INS42 INS42 INS42 INS32 INS42 INS5 INS32 INS38 INS43 INS42 INS53 INS44 INS8 INS44 INS8 INS21 INS32 INS42 INS32 INS42 INS42 INS42 INS43 INS85 INS42 INS42 INS3 MOV32 INS53 INS42 INS14 INS43 INS42 INS43 INS42 INS60 INS21 INS53 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS5 INS32 UPD42 INS14 INS43 INS45 INS42 MOV32 INS42 INS42 INS43 INS59 INS32 INS14 INS42 INS42 INS43 INS85 INS42 INS42 INS43 INS45 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 UPD45 DEL33 DEL42 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL33 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21
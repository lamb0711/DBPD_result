JCR-1592 - JSR 283: Activities


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@784261 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Iterator;
+import java.util.Map;
+import javax.jcr.version.ActivityViolationException;
+import org.apache.jackrabbit.core.ItemId;
+import org.apache.jackrabbit.core.state.NodeReferences;
+    /**
+     * The path to the version storage: /jcr:system/jcr:versionStorage/jcr:activities
+     */
+    private static final Path ACTIVITIES_PATH;
+
+
+            builder = new PathBuilder();
+            builder.addRoot();
+            builder.addLast(NameConstants.JCR_SYSTEM);
+            builder.addLast(NameConstants.JCR_VERSIONSTORAGE);
+            builder.addLast(NameConstants.JCR_ACTIVITIES);
+            ACTIVITIES_PATH = builder.getPath();
-    private final ReferenceMap versionItems = new ReferenceMap(ReferenceMap.HARD, ReferenceMap.WEAK);
+    private final Map<ItemId, InternalVersionItem> versionItems =
+            new ReferenceMap(ReferenceMap.HARD, ReferenceMap.WEAK);
-                              DelegatingObservationDispatcher obsMgr, NodeId rootId,
+                              DelegatingObservationDispatcher obsMgr,
+                              NodeId storageId,
+                              NodeId activitiesId,
-            if (!pMgr.exists(rootId)) {
-                NodeState root = pMgr.createNew(rootId);
+            if (!pMgr.exists(storageId)) {
+                NodeState root = pMgr.createNew(storageId);
-                PropertyState pt = pMgr.createNew(new PropertyId(rootId, NameConstants.JCR_PRIMARYTYPE));
+                PropertyState pt = pMgr.createNew(new PropertyId(storageId, NameConstants.JCR_PRIMARYTYPE));
-            sharedStateMgr = createItemStateManager(pMgr, rootId, ntReg, cacheFactory, ismLocking);
+
+            // check for jcr:activities
+            if (!pMgr.exists(activitiesId)) {
+                NodeState root = pMgr.createNew(activitiesId);
+                root.setParentId(storageId);
+                root.setDefinitionId(ntReg.getEffectiveNodeType(NameConstants.REP_VERSIONSTORAGE).getApplicableChildNodeDef(
+                        NameConstants.JCR_ACTIVITIES, NameConstants.REP_ACTIVITIES, ntReg).getId());
+                root.setNodeTypeName(NameConstants.REP_ACTIVITIES);
+                PropertyState pt = pMgr.createNew(new PropertyId(activitiesId, NameConstants.JCR_PRIMARYTYPE));
+                pt.setDefinitionId(ntReg.getEffectiveNodeType(NameConstants.REP_ACTIVITIES).getApplicablePropertyDef(
+                        NameConstants.JCR_PRIMARYTYPE, PropertyType.NAME, false).getId());
+                pt.setMultiValued(false);
+                pt.setType(PropertyType.NAME);
+                pt.setValues(new InternalValue[]{InternalValue.create(NameConstants.REP_ACTIVITIES)});
+                root.addPropertyName(pt.getName());
+
+                // add activities as child
+                NodeState historyState = pMgr.load(storageId);
+                historyState.addChildNodeEntry(NameConstants.JCR_ACTIVITIES, activitiesId);
+                                
+                ChangeLog cl = new ChangeLog();
+                cl.added(root);
+                cl.added(pt);
+                cl.modified(historyState);
+                pMgr.store(cl);
+            }
+
+            sharedStateMgr = createItemStateManager(pMgr, storageId, ntReg, cacheFactory, ismLocking);
-            NodeState nodeState = (NodeState) stateMgr.getItemState(rootId);
+            NodeState nodeState = (NodeState) stateMgr.getItemState(storageId);
+            nodeState = (NodeState) stateMgr.getItemState(activitiesId);
+            activitiesRoot =  new NodeStateEx(stateMgr, ntReg, nodeState, NameConstants.JCR_ACTIVITIES);
+
-                return createVersionHistory(node, copiedFrom);
+                return internalCreateVersionHistory(node, copiedFrom);
+     * <p/>
+     * This method must not be synchronized since it could cause deadlocks with
+     * item-reading listeners in the observation thread.
+     */
+    public NodeId createActivity(Session session, final String title) throws RepositoryException {
+        NodeStateEx state = (NodeStateEx)
+                escFactory.doSourced((SessionImpl) session, new SourcedTarget() {
+            public Object run() throws RepositoryException {
+                return internalCreateActivity(title);
+            }
+        });
+        return state.getNodeId();
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p/>
+     * This method must not be synchronized since it could cause deadlocks with
+     * item-reading listeners in the observation thread.
+     */
+    public void removeActivity(Session session, final NodeId nodeId)
+            throws RepositoryException {
+        escFactory.doSourced((SessionImpl) session, new SourcedTarget() {
+            public Object run() throws RepositoryException {
+                InternalActivityImpl act = (InternalActivityImpl) getItem(nodeId);
+                internalRemoveActivity(act);
+                return null;
+            }
+        });
+    }
+
+    /**
+     * {@inheritDoc}
-                InternalVersionItem item = (InternalVersionItem) versionItems.get(id);
+                InternalVersionItem item = versionItems.get(id);
-    
+    /**
+     * {@inheritDoc}
+     *
+     * this method currently does no modifications to the persistence and just
+     * checks if the checkout is valid in respect to a possible activity set on
+     * the session
+     */
+    public Version checkout(NodeImpl node) throws RepositoryException {
+        NodeId baseId = NodeId.valueOf(node.getProperty(NameConstants.JCR_BASEVERSION).getString());
+        NodeImpl activity = (NodeImpl) node.getSession().getWorkspace().getVersionManager().getActivity();
+        if (activity != null) {
+            // If there exists another workspace with node N' where N' also has version
+            // history H, N' is checked out and the jcr:activity property of N'
+            // references A, then the checkout fails with an
+            // ActivityViolationException indicating which workspace currently has
+            // the checkout.
+
+            // we're currently leverage the fact, that only references to "real"
+            // workspaces are recorded.
+            NodeId nodeId = activity.getNodeId();
+            NodeReferencesId refId = new NodeReferencesId(nodeId);
+            if (stateMgr.hasNodeReferences(refId)) {
+                try {
+                    NodeReferences refs = stateMgr.getNodeReferences(refId);
+                    if (refs.hasReferences()) {
+                        throw new ActivityViolationException("Unable to checkout. " +
+                                "Activity is already used for the same node in " +
+                                "another workspace.");
+                    }
+                } catch (ItemStateException e) {
+                    throw new RepositoryException("Error during checkout.", e);
+                }
+            }
+
+            // TODO:
+            // If there is a version in H that is not an eventual predecessor of N but
+            // whose jcr:activity references A, then the checkout fails with an
+            // ActivityViolationException
+            InternalActivityImpl a = (InternalActivityImpl) getItem(nodeId);
+            NodeId historyId = NodeId.valueOf(node.getProperty(NameConstants.JCR_VERSIONHISTORY).getString());
+            InternalVersionHistory history = (InternalVersionHistory) getItem(historyId);
+            InternalVersion version = a.getLatestVersion(history);
+            if (version != null) {
+                InternalVersion baseVersion = (InternalVersion) getItem(baseId);
+                while (baseVersion != null && !baseVersion.getId().equals(version.getId())) {
+                    baseVersion = baseVersion.getLinearPredecessor();
+                }
+                if (baseVersion == null) {
+                    throw new ActivityViolationException("Unable to checkout. " +
+                            "Activity is used by another version on a different branch: " + version.getName());
+                }
+            }
+        }
+        return (VersionImpl)
+                ((SessionImpl) node.getSession()).getNodeById(baseId);
+    }
+
-                    return checkin((InternalVersionHistoryImpl) vh, node, false);
+                    return internalCheckin((InternalVersionHistoryImpl) vh, node, false);
-                    return checkin((InternalVersionHistoryImpl) vh, node, true);
+                    return internalCheckin((InternalVersionHistoryImpl) vh, node, true);
-                removeVersion(vh, name);
+                internalRemoveVersion(vh, name);
-    public void itemsUpdated(Collection items) {
+    public void itemsUpdated(Collection<InternalVersionItem> items) {
-                Iterator iter = items.iterator();
-                while (iter.hasNext()) {
-                    InternalVersionItem item = (InternalVersionItem) iter.next();
-                    InternalVersionItem cached = (InternalVersionItem) versionItems.remove(item.getId());
+                for (InternalVersionItem item : items) {
+                    InternalVersionItem cached = versionItems.remove(item.getId());
-     * Return the shared item state manager.
+     * Returns the shared item state manager.
+     * @return the shared item state manager.
-         * @param obsMgr
+         * @param obsMgr dispatcher
-         * @param eventSource
-         * @param runnable
-         * @throws RepositoryException
+         * @param eventSource event source
+         * @param runnable the runnable to execute
+         * @return the return value of the executed runnable
+         * @throws RepositoryException if an error occurs

MOV26 INS26 INS26 INS26 UPD40 INS40 INS40 INS40 INS23 MOV44 INS31 INS31 INS31 INS29 INS83 INS83 INS83 INS43 INS59 INS74 INS44 INS29 INS83 INS43 INS42 INS44 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS29 INS83 INS43 INS42 INS44 INS43 INS8 INS65 INS42 INS42 INS43 INS43 MOV43 UPD42 INS43 INS42 INS65 INS42 INS43 INS42 INS83 INS43 INS42 INS42 INS60 INS41 INS65 INS43 INS42 INS83 INS43 INS42 INS42 INS21 INS65 INS42 INS43 INS42 INS42 INS60 INS60 INS25 INS41 INS74 INS65 INS66 UPD42 MOV42 INS42 INS42 INS65 INS66 INS66 INS66 INS42 INS42 INS43 INS59 INS32 INS65 INS66 INS66 INS66 INS42 INS42 INS32 INS65 INS66 INS66 INS66 INS42 INS43 INS59 INS43 INS59 INS27 INS8 INS11 MOV43 MOV43 UPD66 INS66 INS65 INS21 INS21 INS21 INS21 INS21 INS21 INS25 INS21 INS21 INS42 INS42 INS11 INS42 INS42 INS42 INS42 INS11 INS14 INS42 INS42 INS32 INS42 INS42 INS11 INS42 INS33 INS60 INS60 INS25 INS60 INS60 INS60 INS60 INS25 INS43 INS32 INS66 INS66 INS66 INS66 INS66 INS7 INS32 INS32 INS32 INS32 INS7 INS38 INS8 INS43 INS7 INS7 INS43 INS32 INS43 INS42 INS43 INS1 INS42 INS42 INS32 INS43 INS32 INS43 INS59 INS43 INS59 INS32 INS8 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS27 INS8 INS42 INS36 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS40 INS42 INS42 INS40 INS42 INS32 INS32 INS60 INS21 INS21 INS21 INS60 INS21 INS21 INS21 INS21 INS21 INS60 INS21 INS60 INS21 INS21 INS21 INS21 INS42 INS42 INS11 INS42 INS14 INS42 INS42 INS42 INS11 INS14 INS42 INS42 INS31 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS42 INS54 INS42 INS42 INS11 INS42 INS42 INS32 INS42 INS42 INS11 INS42 INS42 INS32 INS42 INS33 INS60 INS61 INS25 INS11 INS70 INS43 INS42 INS42 UPD42 INS42 INS42 INS42 MOV43 INS59 INS32 INS32 INS32 INS43 INS59 INS32 INS32 INS32 INS32 INS32 MOV43 INS59 INS32 INS43 INS59 INS32 INS32 INS32 INS32 UPD42 INS43 INS43 INS32 INS43 INS42 INS42 INS42 INS40 INS43 INS42 INS43 INS1 INS83 INS43 INS42 INS43 INS8 MOV43 INS42 INS42 INS40 INS32 INS42 INS42 INS42 INS43 INS42 INS8 INS12 INS43 INS32 INS42 INS42 INS32 INS43 INS32 INS42 INS42 INS42 INS43 INS59 INS27 INS8 INS27 INS8 INS43 INS32 INS44 INS42 MOV8 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS40 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS9 INS42 INS42 INS40 INS42 INS42 INS3 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS40 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS31 INS42 INS42 INS60 INS21 INS41 MOV32 INS32 INS42 INS42 INS60 INS25 INS44 INS8 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS27 INS38 INS21 INS42 INS33 INS53 INS42 INS42 INS42 MOV43 INS42 UPD42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS14 INS32 INS42 INS5 INS4 INS42 INS42 INS42 INS42 INS42 INS43 INS83 INS43 INS42 INS43 INS8 INS43 INS59 INS32 INS33 INS42 INS42 INS43 INS59 INS32 INS8 INS43 INS42 INS53 INS42 INS42 INS40 INS43 INS32 INS42 INS33 INS32 INS7 INS14 MOV43 UPD42 INS32 INS42 INS40 INS40 INS42 INS43 INS42 INS40 INS32 INS42 INS40 INS40 INS9 INS43 INS85 INS32 INS42 INS42 INS42 INS41 INS42 INS42 INS11 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS53 INS42 INS14 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS43 INS27 UPD42 MOV32 INS42 INS42 INS40 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS40 INS32 INS43 INS32 INS42 INS42 INS42 INS14 INS43 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS45 INS32 UPD42 INS42 INS42 INS42 INS42 INS42 INS43 INS27 INS42 INS42 INS42 INS41 MOV41 INS42 INS45 INS45 INS45 INS32 INS42 MOV11 INS42 INS9 UPD42 UPD9 DEL43 DEL11 DEL42 DEL42 DEL9 DEL32 DEL41 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL11 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61
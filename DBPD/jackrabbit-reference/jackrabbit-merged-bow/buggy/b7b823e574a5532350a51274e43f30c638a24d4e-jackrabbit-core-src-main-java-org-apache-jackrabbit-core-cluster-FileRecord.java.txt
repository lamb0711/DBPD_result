JCR-702: Allow database as backend for clustering
JCR-703: Add signature and major/minor version to the journal files used for clustering 


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@495239 13f79535-47bb-0310-9956-ffa450edef68

-import java.io.DataOutputStream;
-import java.io.InputStream;
-import java.io.DataInput;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.BufferedInputStream;
-import java.io.FileInputStream;
- * Represents a file-based record. Physically, a file record contains its length in the
- * first 4 bytes, immediately followed by its creator in a length-prefixed, UTF-encoded
- * string. All further fields are record-specific.
+ * Represents a file-based record. Physically, a file record starts with its creator
+ * in a length-prefixed, UTF-encoded string, followed by a 4 byte indicating the
+ * length of data. All further fields are record-specific.
-     * Indicator for a literal UUID.
+     * Record creator.
-    static final byte UUID_LITERAL = 'L';
+    //private final String creator;
+    private final byte[] creator;
-     * Indicator for a UUID index.
+     * Record length.
-    static final byte UUID_INDEX = 'I';
+    private final int length;
+
+    /**
+     * Input stream associated with record data.
+     */
+    private final DataInputStream dataIn;
-     * Underlying input stream.
-     */
-    private DataInputStream in;
-
-    /**
-     * File use when creating a new record.
-     */
-    private File file;
-
-    /**
-     * Underlying output stream.
-     */
-    private DataOutputStream out;
-
-    /**
-     * Record length.
-     */
-    private int length;
-
-    /**
-     * Creator of a record.
-     */
-    private String creator;
-
-    /**
-     * Bytes used by creator when written in UTF encoding and length-prefixed.
-     */
-    private int creatorLength;
-
-    /**
-     * Flag indicating whether bytes need to be skipped at the end.
+     * Flag indicating whether the data associated with this record has been consumed.
-     * Creates a new file record. Used when opening an existing record.
-     *
-     * @param revision revision this record represents
-     * @param in underlying input stream
-     * @throws IOException if reading the creator fails
-     */
-    public FileRecord(long revision, InputStream in)
-            throws IOException {
-
-        this.revision = revision;
-        if (in instanceof DataInputStream) {
-            this.in = (DataInputStream) in;
-        } else {
-            this.in = new DataInputStream(in);
-        }
-        this.length = this.in.readInt();
-
-        readCreator();
-    }
-
-    /**
-     * Creates a new file record. Used when creating a new record.
+     * Creates a new instance of this class. Used when opening an existing record.
-     * @param file underlying (temporary) file
-     * @throws IOException if writing the creator fails
+     * @param length record length
+     * @param dataIn input stream containing record data
-    public FileRecord(String creator, File file) throws IOException {
-
+    public FileRecord(byte[] creator, int length, DataInputStream dataIn) {
-        this.file = file;
-
-        this.out = new DataOutputStream(new FileOutputStream(file));
-
-        writeCreator();
+        this.length = length;
+        this.dataIn = dataIn;
-     * Set the journal revision associated with this record.
+     * Set the journal revision associated with this record. Called after creation
+     * of the file record.
-     * @param revision journal revision
+     * @param revision revision
-    public void setRevision(long revision) {
+    void setRevision(long revision) {
-     * Return the journal counter associated with the next record.
+     * Return the journal counter associated with the next record. A file record's
+     * size is the size of the length-prefixed creator string plus the size of
+     * the length-prefixed data.
-        return revision + length + 4;
+        return revision + FileRecordLog.getRecordSize(creator, length);
-    public String getCreator() {
+    public byte[] getCreator() {
-    public FileRecordInput getInput(NamespaceResolver resolver) {
+    public RecordInput getInput(NamespaceResolver resolver) {
-        return new FileRecordInput(in, resolver);
-    }
-
-    /**
-     * Return an output on this record.
-     *
-     * @param resolver resolver to use when mapping full names to prefixes
-     * @return record output
-     */
-    public FileRecordOutput getOutput(NamespaceResolver resolver) {
-        return new FileRecordOutput(this, out, resolver);
-    }
-
-    /**
-     * Append this record to some output stream.
-     *
-     * @param out outputstream to append to
-     */
-    void append(DataOutputStream out) throws IOException {
-        out.writeInt(length);
-
-        byte[] buffer = new byte[8192];
-        int len;
-
-        InputStream in = new BufferedInputStream(new FileInputStream(file));
-        try {
-            while ((len = in.read(buffer)) > 0) {
-                out.write(buffer, 0, len);
-            }
-            out.flush();
-        } finally {
-            in.close();
-        }
+        return new RecordInput(dataIn, resolver);
-    void skip() throws IOException {
+    public void skip() throws IOException {
-            long skiplen = length - creatorLength;
+            long skiplen = length;
-                long skipped = in.skip(skiplen);
+                long skipped = dataIn.skip(skiplen);
-
-    /**
-     * Invoked when output has been closed.
-     */
-    void closed() {
-        length = (int) file.length();
-    }
-
-    /**
-     * Read creator from the underlying data input stream.
-     *
-     * @throws IOException if an I/O error occurs
-     */
-    private void readCreator() throws IOException {
-        UTFByteCounter counter = new UTFByteCounter(in);
-        creator = DataInputStream.readUTF(counter);
-        creatorLength = counter.getBytes();
-    }
-
-    /**
-     * Write creator to the underlying data output stream.
-     *
-     * @throws IOException if an I/O error occurs
-     */
-    private void writeCreator() throws IOException {
-        out.writeUTF(creator);
-    }
-
-    /**
-     * UTF byte counter. Counts the bytes actually read from a given
-     * <code>DataInputStream</code> that make up a UTF-encoded string.
-     */
-    static class UTFByteCounter implements DataInput {
-
-        /**
-         * Underlying input stream.
-         */
-        private final DataInputStream in;
-
-        /**
-         * UTF length.
-         */
-        private int bytes;
-
-        /**
-         * Create a new instance of this class.
-         *
-         * @param in underlying data input stream
-         */
-        public UTFByteCounter(DataInputStream in) {
-            this.in = in;
-        }
-
-        /**
-         * Return the number of bytes read from the underlying input stream.
-         *
-         * @return number of bytes
-         */
-        public int getBytes() {
-            return bytes;
-        }
-
-        /**
-         * @see java.io.DataInputStream#readUnsignedShort()
-         *
-         * Remember number of bytes read.
-         */
-        public int readUnsignedShort() throws IOException {
-            try {
-                return in.readUnsignedShort();
-            } finally {
-                bytes += 2;
-            }
-        }
-
-        /**
-         * @see java.io.DataInputStream#readUnsignedShort()
-         *
-         * Remember number of bytes read.
-         */
-        public void readFully(byte b[]) throws IOException {
-            try {
-                in.readFully(b);
-            } finally {
-                bytes += b.length;
-            }
-        }
-
-        /**
-         * @see java.io.DataInputStream#readUnsignedShort()
-         *
-         * Remember number of bytes read.
-         */
-        public void readFully(byte b[], int off, int len) throws IOException {
-            try {
-                in.readFully(b, off, len);
-            } finally {
-                bytes += b.length;
-            }
-        }
-
-        /**
-         * Methods not implemented.
-         */
-        public byte readByte() throws IOException {
-            throw new IllegalStateException("Unexpected call, deliberately not implemented.");
-        }
-
-        public char readChar() throws IOException {
-            throw new IllegalStateException("Unexpected call, deliberately not implemented.");
-        }
-
-        public double readDouble() throws IOException {
-            throw new IllegalStateException("Unexpected call, deliberately not implemented.");
-        }
-
-        public float readFloat() throws IOException {
-            throw new IllegalStateException("Unexpected call, deliberately not implemented.");
-        }
-
-        public int readInt() throws IOException {
-            throw new IllegalStateException("Unexpected call, deliberately not implemented.");
-       }
-
-        public int readUnsignedByte() throws IOException {
-            throw new IllegalStateException("Unexpected call, deliberately not implemented.");
-        }
-
-        public long readLong() throws IOException {
-            throw new IllegalStateException("Unexpected call, deliberately not implemented.");
-        }
-
-        public short readShort() throws IOException {
-            throw new IllegalStateException("Unexpected call, deliberately not implemented.");
-        }
-
-        public boolean readBoolean() throws IOException {
-            throw new IllegalStateException("Unexpected call, deliberately not implemented.");
-        }
-
-        public int skipBytes(int n) throws IOException {
-            throw new IllegalStateException("Unexpected call, deliberately not implemented.");
-        }
-
-        public String readLine() throws IOException {
-            throw new IllegalStateException("Unexpected call, deliberately not implemented.");
-        }
-
-        public String readUTF() throws IOException {
-            throw new IllegalStateException("Unexpected call, deliberately not implemented.");
-        }
-    }

MOV23 UPD83 INS5 MOV59 INS83 UPD83 MOV43 INS44 INS8 MOV5 UPD43 INS83 UPD66 UPD66 UPD66 INS39 INS85 UPD42 MOV65 MOV5 UPD42 INS39 INS42 MOV43 INS42 MOV21 MOV21 MOV21 UPD42 UPD66 UPD66 UPD66 UPD66 UPD42 UPD66 UPD42 UPD66 UPD66 INS66 UPD66 UPD66 INS66 INS66 INS42 INS42 INS32 UPD43 UPD42 UPD42 INS42 INS42 INS42 INS42 UPD42 INS42 UPD42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL39 DEL42 DEL13 DEL59 DEL39 DEL13 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL23 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL59 DEL23 DEL42 DEL66 DEL65 DEL39 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL43 DEL42 DEL14 DEL42 DEL43 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL42 DEL43 DEL62 DEL52 DEL42 DEL22 DEL42 DEL11 DEL7 DEL21 DEL8 DEL8 DEL25 DEL42 DEL32 DEL21 DEL8 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL43 DEL42 DEL14 DEL14 DEL7 DEL21 DEL42 DEL32 DEL21 DEL8 DEL31 DEL83 DEL42 DEL34 DEL42 DEL43 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL52 DEL42 DEL42 DEL14 DEL41 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL34 DEL3 DEL59 DEL60 DEL39 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL14 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL36 DEL34 DEL27 DEL42 DEL42 DEL42 DEL34 DEL42 DEL32 DEL21 DEL8 DEL61 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL31 DEL42 DEL42 DEL27 DEL66 DEL65 DEL29 DEL39 DEL42 DEL42 DEL39 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL59 DEL23 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL40 DEL42 DEL68 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL41 DEL8 DEL42 DEL34 DEL7 DEL21 DEL8 DEL54 DEL8 DEL31 DEL40 DEL42 DEL68 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL39 DEL42 DEL85 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL40 DEL7 DEL21 DEL8 DEL54 DEL8 DEL31 DEL40 DEL42 DEL68 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL39 DEL42 DEL85 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL40 DEL7 DEL21 DEL8 DEL54 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL31 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL31 DEL55
JCR-3378 The ConnectionHelper can return a closed Connection in BatchMode

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1361941 13f79535-47bb-0310-9956-ffa450edef68

-import javax.transaction.xa.Xid;
-    private ThreadLocal<Connection> batchConnectionTl = new ThreadLocal<Connection>();
-    private Map<String, Connection> xaBatchConnectionMap = Collections.synchronizedMap(new HashMap<String, Connection>());
+    private Map<String, Connection> batchConnectionMap = Collections.synchronizedMap(new HashMap<String, Connection>());
-     * @return true if the current thread is running in batch mode, false otherwise.
+     * 
+     * @return true if the current thread or the active transaction is running in batch mode, false otherwise.
+            removeTransactionAwareBatchConnection();
-            removeTransactionAwareBatchConnection();
+        Connection batchConnection = getTransactionAwareBatchConnection(); 
-            	getTransactionAwareBatchConnection().commit();
+            	batchConnection.commit();
-            	getTransactionAwareBatchConnection().rollback();
+            	batchConnection.rollback();
-            DbUtility.close(getTransactionAwareBatchConnection(), null, null);
+            if (batchConnection != null) {
+            	DbUtility.close(batchConnection, null, null);
+            }
-     * Returns the Batch Connection. In XA Environment it is stored
-     * in a Cache-Map based on the current Xid. In Non-XA Environment a ThreadLocal is used.
+     * Returns the Batch Connection.
-    	Xid currentXid = TransactionContext.getCurrentXid();
-    	if (currentXid != null) {
-           	return xaBatchConnectionMap.get(xidtoString(currentXid.getGlobalTransactionId()));
-    	} else {
-    		return batchConnectionTl.get();
-    	}
+    	Object threadId = TransactionContext.getCurrentThreadId();
+       	return batchConnectionMap.get(threadIdToString(threadId));
-     * Setter for the Batch Connection. In XA Environment it will be stored
-     * in a Cache-Map based on the current Xid. In Non-XA Environment a ThreadLocal is used.
+     * Stores the given Connection to the batchConnectionMap.
+     * If we are running in a XA Environment the globalTransactionId will be used as Key.
+     * In Non-XA Environment the ThreadName is used.
-    	Xid currentXid = TransactionContext.getCurrentXid();
-    	if (currentXid != null) {
-       		xaBatchConnectionMap.put(xidtoString(currentXid.getGlobalTransactionId()), batchConnection);
-    	} else {
-    		batchConnectionTl.set(batchConnection);
-    	}
+    	Object threadId = TransactionContext.getCurrentThreadId();
+    	batchConnectionMap.put(threadIdToString(threadId), batchConnection);
-     * Removes the Batch Connection. In XA Environment it will be stored
-     * in a Cache-Map based on the current Xid. In Non-XA Environment a ThreadLocal is used.
+     * Removes the Batch Connection from the batchConnectionMap
-    	Xid currentXid = TransactionContext.getCurrentXid();
-    	if (currentXid != null) {
-       		xaBatchConnectionMap.remove(xidtoString(currentXid.getGlobalTransactionId()));
-    	} else {
-    		batchConnectionTl.remove();
-    	}
+    	Object threadId = TransactionContext.getCurrentThreadId();
+    	batchConnectionMap.remove(threadIdToString(threadId));
-     * Creates a comparable String from the given GlobalTransactionId byte[]
+     * Creates a comparable String from the given threadId
-     * @param gtrid
+     * @param threadId
-    private String xidtoString(byte[] gtrid) {
-        int hexVal;
-        StringBuffer sb = new StringBuffer(512);
-        sb.append(" gtrid(" + gtrid.length + ")={0x");
-        for (int i=0; i<gtrid.length; i++) {
-           hexVal = gtrid[i]&0xFF;
-           if ( hexVal < 0x10 )
-              sb.append("0" + Integer.toHexString(gtrid[i]&0xFF));
-           else
-              sb.append(Integer.toHexString(gtrid[i]&0xFF));
-           }
-        sb.append("}");
-        return sb.toString();
+    private String threadIdToString(Object threadId) {
+    	if (threadId instanceof byte[]) {
+    		byte[] gtrid = (byte[]) threadId;
+    		int hexVal;
+    		StringBuffer sb = new StringBuffer(512);
+    		sb.append(" gtrid(" + gtrid.length + ")={0x");
+    		for (int i=0; i< gtrid.length; i++) {
+    			hexVal = gtrid[i]&0xFF;
+    			if ( hexVal < 0x10 ) {
+    				sb.append("0" + Integer.toHexString(gtrid[i]&0xFF));
+    			} else {
+    				sb.append(Integer.toHexString(gtrid[i]&0xFF));
+    			}
+    		}
+    		sb.append("}");
+    		return sb.toString();
+    	} else {
+    		return threadId.toString();
+    	}

UPD42 INS8 UPD42 INS60 MOV41 MOV21 MOV21 INS43 UPD42 INS25 UPD66 MOV43 INS59 INS8 UPD66 UPD43 INS66 UPD66 UPD66 UPD43 UPD66 UPD43 UPD66 UPD42 INS42 INS62 MOV8 INS8 MOV25 INS42 MOV32 MOV21 INS25 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS5 INS60 INS41 INS27 INS8 UPD42 UPD42 UPD42 MOV42 UPD42 UPD42 UPD42 MOV42 UPD42 UPD42 UPD42 MOV42 INS39 INS85 INS5 INS59 INS32 INS42 INS33 MOV21 INS39 INS85 INS42 INS11 INS42 INS42 MOV5 INS42 INS8 INS8 UPD42 MOV42 UPD42 MOV42 INS42 MOV21 MOV21 DEL40 DEL26 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL23 DEL32 DEL32 DEL8 DEL66 DEL42 DEL32 DEL42 DEL33 DEL27 DEL8 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL32 DEL42 DEL33 DEL27 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL66 DEL42 DEL32 DEL42 DEL33 DEL27 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25
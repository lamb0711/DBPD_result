- Redesigned observation to also include workspace modifications
- Extended observation tests and moved them into the api.observation package

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@155583 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.*;
-import org.apache.jackrabbit.core.state.*;
+import org.apache.jackrabbit.core.SessionImpl;
+import org.apache.jackrabbit.core.HierarchyManager;
+import org.apache.jackrabbit.core.Path;
+import org.apache.jackrabbit.core.NodeId;
+import org.apache.jackrabbit.core.MalformedPathException;
+import org.apache.jackrabbit.core.state.ChangeLog;
+import org.apache.jackrabbit.core.state.ItemStateException;
+import org.apache.jackrabbit.core.state.ItemStateManager;
+import org.apache.jackrabbit.core.state.ItemState;
+import org.apache.jackrabbit.core.state.NodeState;
+import org.apache.jackrabbit.core.state.NoSuchItemStateException;
+import javax.jcr.PathNotFoundException;
+import javax.jcr.nodetype.NoSuchNodeTypeException;
-import java.util.Collection;
+import java.util.Arrays;
-     * The ItemStateProvider of the session that creates the events.
-     */
-    private final ItemStateManager provider;
-
-    /**
-                         ItemStateManager provider,
-        this.provider = provider;
-     * Creates {@link EventState}s for the {@link org.apache.jackrabbit.core.state.ItemState state}
-     * instances contained in the specified collection.
-     *
-     * @param states collection of transient <code>ItemState</code> for whom
-     *               to create {@link EventState}s.
-     * @see #createEventStates(org.apache.jackrabbit.core.state.ItemState)
+     * Creates {@link EventState} instances from <code>ItemState</code>
+     * <code>changes</code>.
+     * @param changes the changes on <code>ItemState</code>s.
+     * @param provider an <code>ItemStateProvider</code> to provide <code>ItemState</code>
+     * of items that are not contained in the <code>changes</code> collection.
+     * @throws ItemStateException if an error occurs while creating events
+     * states for the item state changes.
-    public void createEventStates(Collection states)
-            throws RepositoryException {
-        Iterator iter = states.iterator();
-        while (iter.hasNext()) {
-            createEventStates((ItemState) iter.next());
-        }
-    }
-
-    /**
-     * Creates {@link EventState}s for the passed {@link org.apache.jackrabbit.core.state.ItemState state}
-     * instance.
-     *
-     * @param state the transient <code>ItemState</code> for whom
-     *              to create {@link EventState}s.
-     */
-    public void createEventStates(ItemState state)
-            throws RepositoryException {
-        int status = state.getStatus();
-
-        if (status == ItemState.STATUS_EXISTING_MODIFIED
-                || status == ItemState.STATUS_NEW) {
-
+    public void createEventStates(ChangeLog changes, ItemStateManager provider) throws ItemStateException {
+        for (Iterator it = changes.modifiedStates(); it.hasNext();) {
+            ItemState state = (ItemState) it.next();
-                NodeState currentNode = (NodeState) state;
-                QName nodeTypeName = currentNode.getNodeTypeName();
-                NodeTypeImpl nodeType = session.getNodeTypeManager().getNodeType(nodeTypeName);
-                Path parentPath = hmgr.getPath(currentNode.getId());
-
-                // 1) check added properties
-                List addedProperties = currentNode.getAddedPropertyEntries();
-                for (Iterator it = addedProperties.iterator(); it.hasNext();) {
-                    NodeState.PropertyEntry prop = (NodeState.PropertyEntry) it.next();
-                    events.add(EventState.propertyAdded(currentNode.getUUID(),
-                            parentPath,
-                            Path.create(prop.getName(), 0),
-                            nodeType,
-                            session));
-                }
-
-                // 2) check removed properties
-                List removedProperties = currentNode.getRemovedPropertyEntries();
-                for (Iterator it = removedProperties.iterator(); it.hasNext();) {
-                    NodeState.PropertyEntry prop = (NodeState.PropertyEntry) it.next();
-                    events.add(EventState.propertyRemoved(currentNode.getUUID(),
-                            parentPath,
-                            Path.create(prop.getName(), 0),
-                            nodeType,
-                            session));
-                }
-
-                // 3) check for added nodes
-                List addedNodes = currentNode.getAddedChildNodeEntries();
-                for (Iterator it = addedNodes.iterator(); it.hasNext();) {
-                    NodeState.ChildNodeEntry child = (NodeState.ChildNodeEntry) it.next();
-                    events.add(EventState.childNodeAdded(currentNode.getUUID(),
-                            parentPath,
-                            child.getUUID(),
-                            Path.create(child.getName(), child.getIndex()),
-                            nodeType,
-                            session));
-                }
-
-                // 4) check for removed nodes
-                List removedNodes = currentNode.getRemovedChildNodeEntries();
-                for (Iterator it = removedNodes.iterator(); it.hasNext();) {
-                    NodeState.ChildNodeEntry child = (NodeState.ChildNodeEntry) it.next();
-                    events.add(EventState.childNodeRemoved(currentNode.getUUID(),
-                            parentPath,
-                            child.getUUID(),
-                            Path.create(child.getName(), child.getIndex()),
-                            nodeType,
-                            session));
-                }
-            } else {
-                // only add property changed event if property is existing
-                if (state.getStatus() == ItemState.STATUS_EXISTING_MODIFIED) {
-                    NodeId parentId = new NodeId(state.getParentUUID());
+                // node changed
+                // covers the following cases:
+                // 1) property added
+                // 2) property removed
+                // 3) child node added
+                // 4) child node removed
+                // 5) node moved
+                // cases 1) and 2) are detected with added and deleted states
+                // on the PropertyState itself.
+                // cases 3) and 4) are detected with added and deleted states
+                // on the NodeState itself.
+                // in case 5) two or three nodes change. two nodes are changed
+                // when a child node is renamed. three nodes are changed when
+                // a node is really moved. In any case we are only interested in
+                // the node that actually got moved.
+                NodeState n = (NodeState) state;
+                if (n.getAddedParentUUIDs().size() > 0 && n.getRemovedParentUUIDs().size() > 0) {
+                    // node moved
+                    // generate node removed & node added event
+                    String oldParentUUID = (String) n.getRemovedParentUUIDs().get(0);
+                    NodeTypeImpl nodeType = null;
-                        NodeState parentState = (NodeState) provider.getItemState(parentId);
-                        Path parentPath = hmgr.getPath(parentId);
-                        events.add(EventState.propertyChanged(state.getParentUUID(),
+                        nodeType = session.getNodeTypeManager().getNodeType(n.getNodeTypeName());
+                    } catch (NoSuchNodeTypeException e) {
+                        // should never happen actually
+                        String msg = "Item " + state.getId() + " has unknown node type: " + n.getNodeTypeName();
+                        log.error(msg);
+                        throw new ItemStateException(msg, e);
+                    }
+                    // FIXME find more efficient way
+                    Path newPath = null;
+                    Path[] allPaths = null;
+                    try {
+                        newPath = hmgr.getPath(n.getId());
+                        allPaths = hmgr.getAllPaths(n.getId(), true);
+                    } catch (RepositoryException e) {
+                        // should never happen actually
+                        String msg = "Unable to resolve path for item: " + n.getId();
+                        log.error(msg);
+                        throw new ItemStateException(msg, e);
+                    }
+                    List paths = new ArrayList(Arrays.asList(allPaths));
+                    paths.remove(newPath);
+                    if (paths.size() > 0) {
+                        Path removedPath = (Path) paths.get(0);
+                        Path parentPath = null;
+                        try {
+                            parentPath = removedPath.getAncestor(1);
+                        } catch (PathNotFoundException e) {
+                            // should never happen actually, root node cannot
+                            // be removed, thus path has always a parent
+                            String msg = "Path " + removedPath + " has no parent";
+                            log.error(msg);
+                            throw new ItemStateException(msg, e);
+                        }
+                        events.add(EventState.childNodeRemoved(oldParentUUID,
-                                Path.create(((PropertyState) state).getName(), 0),
-                                session.getNodeTypeManager().getNodeType(parentState.getNodeTypeName()),
+                                n.getUUID(),
+                                removedPath.getNameElement(),
+                                nodeType,
-                    } catch (ItemStateException e) {
-                        // should never happen
-                        log.error("internal error: item state exception", e);
+
+                        String newParentUUID = (String) n.getAddedParentUUIDs().get(0);
+                        try {
+                            parentPath = newPath.getAncestor(1);
+                        } catch (PathNotFoundException e) {
+                            // should never happen actually, root node cannot
+                            // be 'added', thus path has always a parent
+                            String msg = "Path " + removedPath + " has no parent";
+                            log.error(msg);
+                            throw new ItemStateException(msg, e);
+                        }
+                        events.add(EventState.childNodeAdded(newParentUUID,
+                                parentPath,
+                                n.getUUID(),
+                                newPath.getNameElement(),
+                                nodeType,
+                                session));
+                    } else {
+                        log.error("Unable to calculate old path of moved node");
+                    }
+                } else {
+                    // a moved node always has a modified parent node
+                    NodeState parent = null;
+                    try {
+                        // root node does not have a parent UUID
+                        if (state.getParentUUID() != null) {
+                            parent = (NodeState) changes.get(new NodeId(state.getParentUUID()));
+                        }
+                    } catch (NoSuchItemStateException e) {
+                        // should never happen actually. this would mean
+                        // the parent of this modified node is deleted
+                        String msg = "Parent of node " + state.getId() + " is deleted.";
+                        log.error(msg);
+                        throw new ItemStateException(msg, e);
+                    }
+                    if (parent != null) {
+                        // check if node has been renamed
+                        NodeState.ChildNodeEntry moved = null;
+                        for (Iterator removedNodes = parent.getRemovedChildNodeEntries().iterator(); removedNodes.hasNext();) {
+                            NodeState.ChildNodeEntry child = (NodeState.ChildNodeEntry) removedNodes.next();
+                            if (child.getUUID().equals(n.getUUID())) {
+                                // found node re-added with different name
+                                moved = child;
+                            }
+                        }
+                        if (moved != null) {
+                            NodeTypeImpl nodeType = null;
+                            try {
+                                nodeType = session.getNodeTypeManager().getNodeType(n.getNodeTypeName());
+                            } catch (NoSuchNodeTypeException e) {
+                                // should never happen actually
+                                String msg = "Item " + state.getId() + " has unknown node type: " + n.getNodeTypeName();
+                                log.error(msg);
+                                throw new ItemStateException(msg, e);
+                            }
+                            Path newPath = null;
+                            Path parentPath = null;
+                            Path oldPath = null;
+                            try {
+                                newPath = hmgr.getPath(state.getId());
+                                parentPath = newPath.getAncestor(1);
+                                oldPath = null;
+                                if (moved.getIndex() == 0) {
+                                    oldPath = Path.create(parentPath, moved.getName(), false);
+                                } else {
+                                    oldPath = Path.create(parentPath, moved.getName(), moved.getIndex(), false);
+                                }
+                            } catch (RepositoryException e) {
+                                // should never happen actually
+                                String msg = "Unable to resolve path for item: " + state.getId();
+                                log.error(msg);
+                                throw new ItemStateException(msg, e);
+                            } catch (MalformedPathException e) {
+                                // should never happen actually
+                                String msg = "Malformed path for item: " + state.getId();
+                                log.error(msg);
+                                throw new ItemStateException(msg, e);
+                            }
+                            events.add(EventState.childNodeRemoved(parent.getUUID(),
+                                    parentPath,
+                                    n.getUUID(),
+                                    oldPath.getNameElement(),
+                                    nodeType,
+                                    session));
+                            events.add(EventState.childNodeAdded(parent.getUUID(),
+                                    parentPath,
+                                    n.getUUID(),
+                                    newPath.getNameElement(),
+                                    nodeType,
+                                    session));
+                        }
+            } else {
+                // property changed
+                Path path = null;
+                Path parentPath = null;
+                try {
+                    path = hmgr.getPath(state.getId());
+                    parentPath = path.getAncestor(1);
+                } catch (RepositoryException e) {
+                    // should never happen actually
+                    String msg = "Unable to resolve path for item: " + state.getId();
+                    log.error(msg);
+                    throw new ItemStateException(msg, e);
+                }
+                NodeState parent = (NodeState) provider.getItemState(new NodeId(state.getParentUUID()));
+                NodeTypeImpl nodeType = null;
+                try {
+                    nodeType = session.getNodeTypeManager().getNodeType(parent.getNodeTypeName());
+                } catch (NoSuchNodeTypeException e) {
+                    // should never happen actually
+                    String msg = "Item " + parent.getId() + " has unknown node type: " + parent.getNodeTypeName();
+                    log.error(msg);
+                    throw new ItemStateException(msg, e);
+                }
+                events.add(EventState.propertyChanged(state.getParentUUID(),
+                        parentPath,
+                        path.getNameElement(),
+                        nodeType,
+                        session));
-        } else if (status == ItemState.STATUS_EXISTING_REMOVED) {
+        }
+        for (Iterator it = changes.addedStates(); it.hasNext();) {
+            ItemState state = (ItemState) it.next();
-                // zombie nodes
-                NodeState currentNode = (NodeState) state;
-                QName nodeTypeName = currentNode.getNodeTypeName();
-                NodeTypeImpl nodeType = session.getNodeTypeManager().getNodeType(nodeTypeName);
-
-                // FIXME replace by HierarchyManager.getPath(ItemId id, boolean includeZombie)
-                // when available.
-                Path[] parentPaths = hmgr.getAllPaths(currentNode.getId(), true);   // include zombie
-                for (int i = 0; i < parentPaths.length; i++) {
-                    List removedNodes = currentNode.getRemovedChildNodeEntries();
-                    for (Iterator it = removedNodes.iterator(); it.hasNext();) {
-                        NodeState.ChildNodeEntry child = (NodeState.ChildNodeEntry) it.next();
-                        events.add(EventState.childNodeRemoved(currentNode.getUUID(),
-                                parentPaths[i],
-                                child.getUUID(),
-                                Path.create(child.getName(), child.getIndex()),
+                // node created
+                NodeState n = (NodeState) state;
+                NodeTypeImpl nodeType = null;
+                try {
+                    nodeType = session.getNodeTypeManager().getNodeType(n.getNodeTypeName());
+                } catch (NoSuchNodeTypeException e) {
+                    // should never happen actually
+                    String msg = "Item " + state.getId() + " has unknown node type: " + n.getNodeTypeName();
+                    log.error(msg);
+                    throw new ItemStateException(msg, e);
+                }
+                Path path = null;
+                Path parentPath = null;
+                try {
+                    path = hmgr.getPath(n.getId());
+                    parentPath = path.getAncestor(1);
+                } catch (RepositoryException e) {
+                    // should never happen actually
+                    String msg = "Unable to resolve path for item: " + n.getId();
+                    log.error(msg);
+                    throw new ItemStateException(msg, e);
+                }
+                events.add(EventState.childNodeAdded(n.getParentUUID(),
+                        parentPath,
+                        n.getUUID(),
+                        path.getNameElement(),
+                        nodeType,
+                        session));
+            } else {
+                // property created / set
+                NodeState n = (NodeState) changes.get(new NodeId(state.getParentUUID()));
+                NodeTypeImpl nodeType = null;
+                try {
+                    nodeType = session.getNodeTypeManager().getNodeType(n.getNodeTypeName());
+                } catch (NoSuchNodeTypeException e) {
+                    // should never happen actually
+                    String msg = "Item " + state.getId() + " has unknown node type: " + n.getNodeTypeName();
+                    log.error(msg);
+                    throw new ItemStateException(msg, e);
+                }
+                Path path = null;
+                Path parentPath = null;
+                try {
+                    path = hmgr.getPath(state.getId());
+                    parentPath = path.getAncestor(1);
+                } catch (RepositoryException e) {
+                    // should never happen actually
+                    String msg = "Unable to resolve path for item: " + n.getId();
+                    log.error(msg);
+                    throw new ItemStateException(msg, e);
+                }
+                events.add(EventState.propertyAdded(state.getParentUUID(),
+                        parentPath,
+                        path.getNameElement(),
+                        nodeType,
+                        session));
+            }
+        }
+        for (Iterator it = changes.deletedStates(); it.hasNext();) {
+            ItemState state = (ItemState) it.next();
+            if (state.isNode()) {
+                // node deleted
+                NodeState n = (NodeState) state;
+                NodeTypeImpl nodeType = null;
+                try {
+                    nodeType = session.getNodeTypeManager().getNodeType(n.getNodeTypeName());
+                } catch (NoSuchNodeTypeException e) {
+                    // should never happen actually
+                    String msg = "Item " + state.getId() + " has unknown node type: " + n.getNodeTypeName();
+                    log.error(msg);
+                    throw new ItemStateException(msg, e);
+                }
+                try {
+                    Path[] paths = hmgr.getAllPaths(state.getId(), true);
+                    for (int i = 0; i < paths.length; i++) {
+                        Path parentPath = paths[i].getAncestor(1);
+                        events.add(EventState.childNodeRemoved(n.getParentUUID(),
+                                parentPath,
+                                n.getUUID(),
+                                paths[i].getNameElement(),
+                } catch (RepositoryException e) {
+                    // should never happen actually
+                    String msg = "Unable to resolve path for item: " + n.getId();
+                    log.error(msg);
+                    throw new ItemStateException(msg, e);
+                }
+            } else {
+                // property removed
+                // only create an event if node still exists
+                try {
+                    NodeState n = (NodeState) changes.get(new NodeId(state.getParentUUID()));
+                    // node state exists -> only property removed
+                    NodeTypeImpl nodeType = null;
+                    try {
+                        nodeType = session.getNodeTypeManager().getNodeType(n.getNodeTypeName());
+                    } catch (NoSuchNodeTypeException e) {
+                        // should never happen actually
+                        String msg = "Item " + state.getId() + " has unknown node type: " + n.getNodeTypeName();
+                        log.error(msg);
+                        throw new ItemStateException(msg, e);
+                    }
+                    Path paths[] = null;
+                    try {
+                        paths = hmgr.getAllPaths(state.getId(), true);
+                        for (int i = 0; i < paths.length; i++) {
+                            Path parentPath = paths[i].getAncestor(1);
+                            events.add(EventState.propertyRemoved(state.getParentUUID(),
+                                    parentPath,
+                                    paths[i].getNameElement(),
+                                    nodeType,
+                                    session));
+                        }
+                    } catch (RepositoryException e) {
+                        // should never happen actually
+                        String msg = "Unable to resolve path for item: " + n.getId();
+                        log.error(msg);
+                        throw new ItemStateException(msg, e);
+                    }
+                } catch (NoSuchItemStateException e) {
+                    // also node removed -> do not create an event
-    public void prepare() throws RepositoryException {
+    public void prepare() {

MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 UPD40 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 INS40 INS40 INS40 UPD40 INS31 MOV29 MOV83 MOV39 MOV42 MOV44 MOV44 INS43 INS8 INS65 INS65 UPD65 UPD43 UPD42 INS42 INS24 INS24 INS24 MOV66 MOV65 UPD66 MOV66 INS66 INS42 UPD66 MOV66 UPD42 UPD66 UPD66 INS42 INS66 INS66 UPD42 INS58 MOV32 INS8 INS58 MOV32 INS8 INS58 MOV32 INS8 MOV43 INS59 MOV60 INS25 MOV43 INS59 MOV60 INS25 MOV43 INS59 MOV60 MOV25 UPD42 MOV42 MOV32 MOV43 MOV32 INS8 INS8 INS42 INS32 INS43 MOV32 INS8 INS8 INS42 INS32 UPD43 INS32 INS8 INS8 UPD42 UPD42 UPD42 MOV60 INS25 INS60 INS60 INS54 MOV60 INS60 INS54 INS21 INS42 INS42 INS42 UPD42 MOV60 INS60 INS54 INS60 INS60 INS54 INS21 INS60 INS60 INS54 INS60 INS60 INS54 INS21 INS42 INS42 INS42 UPD42 INS42 INS42 INS60 INS60 INS54 INS54 INS54 MOV43 INS27 INS8 INS8 INS43 INS59 INS43 INS59 INS8 INS12 MOV43 INS43 INS59 INS8 INS12 INS32 INS43 INS43 INS43 INS59 INS8 INS12 INS43 INS59 INS43 INS59 INS8 INS12 INS32 INS43 INS59 INS43 INS59 INS8 INS12 INS43 INS59 INS43 INS59 INS8 MOV12 INS32 INS43 UPD43 MOV43 INS59 INS43 INS59 INS8 INS12 INS8 INS12 INS8 INS12 UPD42 INS27 INS27 INS60 INS60 INS54 INS60 MOV60 INS54 INS60 INS21 INS25 INS60 INS54 INS25 INS42 INS42 INS33 INS42 INS42 INS33 INS21 INS21 INS44 INS8 UPD42 INS42 INS42 INS33 INS21 INS44 INS8 MOV42 MOV42 INS32 INS42 INS42 UPD42 INS42 INS42 INS33 INS21 INS44 INS8 INS42 INS42 INS33 INS42 INS42 INS33 INS21 INS21 INS44 INS8 INS42 INS42 INS32 INS42 INS42 INS11 INS42 INS42 INS33 INS21 INS44 INS8 INS42 INS42 INS33 INS42 INS42 INS33 INS21 INS21 INS42 INS42 INS32 INS42 UPD42 INS42 INS11 INS42 UPD42 MOV42 INS33 INS21 INS44 INS8 MOV60 INS24 INS44 INS8 MOV60 INS60 INS54 INS60 INS54 INS44 INS8 INS32 INS34 INS32 INS34 INS43 INS59 MOV43 INS59 INS8 INS12 MOV43 INS59 MOV5 INS8 INS12 MOV43 INS59 INS32 INS27 INS8 INS8 MOV43 INS59 INS8 INS12 INS27 INS8 INS7 INS7 MOV43 INS42 MOV60 INS21 INS53 INS43 INS7 INS43 INS42 MOV60 INS21 INS53 MOV42 MOV42 MOV32 MOV42 INS32 INS42 INS42 INS7 INS43 INS42 INS60 INS21 INS53 INS7 INS7 INS43 INS42 INS60 INS21 INS53 INS42 INS42 INS32 INS42 INS32 INS32 INS42 INS42 UPD43 MOV43 INS32 INS7 INS43 INS42 INS60 INS21 INS53 INS7 INS7 INS43 INS60 INS53 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS43 INS42 INS7 INS43 INS42 MOV60 INS21 INS53 INS5 MOV58 MOV27 MOV37 INS8 INS43 INS42 INS60 INS21 INS53 UPD43 INS43 INS59 INS8 INS12 INS43 INS59 INS8 INS12 INS43 INS42 INS32 UPD42 MOV42 INS32 INS42 INS42 INS42 INS11 INS42 INS33 INS21 INS44 INS8 INS42 INS33 UPD42 INS33 INS21 INS21 INS44 INS8 INS42 INS14 INS42 INS42 INS42 INS32 INS34 INS60 INS60 INS54 MOV21 MOV60 INS54 MOV21 INS21 INS42 INS33 INS25 INS44 INS8 INS42 INS33 INS60 INS24 INS25 INS42 INS32 INS42 INS32 UPD43 INS32 INS14 INS42 INS14 INS42 INS32 INS42 INS43 INS32 INS14 INS42 INS42 INS42 INS32 INS42 INS43 INS59 INS32 INS14 INS42 INS32 INS42 INS32 INS42 INS43 INS59 INS32 INS14 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS14 INS42 INS32 INS42 INS43 INS59 INS32 INS14 INS42 INS32 INS42 INS32 INS42 INS43 INS59 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS43 INS32 INS14 INS43 INS85 UPD42 UPD40 INS60 INS21 INS42 INS43 INS59 INS32 INS14 UPD42 INS42 INS11 INS42 INS42 INS33 INS21 INS44 INS8 INS42 INS42 INS85 INS33 INS21 INS24 INS44 INS8 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS43 INS32 INS7 INS43 UPD42 MOV42 MOV60 INS21 INS53 INS7 INS7 MOV43 INS42 MOV60 INS21 INS53 INS43 INS32 INS42 INS42 INS43 INS59 MOV43 INS59 INS8 INS12 INS43 INS8 INS12 INS32 INS27 INS8 INS43 INS42 MOV60 INS21 INS53 MOV43 INS59 MOV58 MOV32 INS8 INS27 INS8 INS42 INS42 INS32 INS42 INS42 INS34 UPD42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS43 INS32 MOV32 INS42 INS32 INS42 UPD42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS34 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS43 INS32 INS32 MOV42 MOV32 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS34 INS42 INS42 INS27 UPD42 INS43 INS42 INS42 INS32 UPD42 MOV42 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS43 INS59 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS43 INS32 INS7 INS43 INS42 INS60 INS21 INS53 INS7 INS58 INS27 INS37 INS8 INS43 INS42 INS60 INS21 INS53 INS42 INS32 INS42 INS34 INS42 MOV32 INS42 INS43 INS32 INS14 INS42 INS32 INS42 INS32 UPD43 INS32 INS14 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS11 INS42 INS33 INS21 INS44 INS8 INS42 UPD42 INS11 INS21 INS44 INS8 INS42 INS42 INS45 INS32 INS33 INS21 INS42 UPD43 INS32 INS14 INS42 INS33 MOV43 UPD42 MOV60 INS25 INS42 INS33 INS60 INS54 INS60 INS60 INS60 INS54 INS21 INS21 MOV42 UPD42 MOV42 INS45 INS32 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS45 INS32 INS45 INS32 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS45 INS32 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS45 INS32 INS45 INS32 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS42 MOV42 INS45 INS32 INS45 INS32 INS42 UPD42 INS42 INS42 INS32 INS42 INS42 INS32 INS45 INS32 INS42 INS42 INS42 INS42 INS14 INS42 INS32 INS42 INS43 INS59 INS32 INS14 INS42 INS32 INS39 INS59 INS42 INS40 INS42 INS60 INS21 INS42 INS43 INS59 INS32 INS14 INS42 INS42 INS32 INS42 UPD42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 MOV42 MOV42 MOV32 INS42 INS42 INS32 INS9 UPD42 UPD42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS43 INS32 INS7 INS43 INS42 INS60 INS21 INS53 UPD42 MOV42 UPD42 MOV42 INS32 MOV32 INS43 INS32 INS7 INS43 INS42 INS60 INS21 INS53 UPD42 MOV42 UPD42 MOV42 INS32 MOV32 INS42 INS42 INS7 UPD42 UPD42 INS27 INS42 INS42 INS42 MOV43 INS42 INS42 UPD42 MOV43 INS32 INS8 MOV43 INS59 INS8 INS12 INS43 INS59 INS43 INS59 INS43 INS59 INS8 INS12 INS12 INS32 INS32 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS2 INS42 INS34 INS42 INS42 INS32 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS43 INS32 INS32 INS42 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS32 INS9 INS42 INS34 INS43 INS59 INS32 INS42 INS42 INS27 UPD42 MOV42 UPD42 MOV42 INS42 INS43 INS42 INS42 INS42 UPD42 MOV42 INS45 INS32 INS45 INS32 UPD42 MOV42 UPD42 INS42 INS42 INS45 INS32 UPD42 MOV42 INS42 INS42 INS42 INS34 INS42 INS32 INS42 INS43 INS59 INS32 INS14 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS42 INS32 UPD42 MOV42 INS34 INS42 INS32 UPD42 MOV42 INS43 INS59 INS32 INS14 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS42 INS11 INS45 INS32 INS45 INS32 MOV32 UPD42 MOV42 INS32 INS21 INS42 INS33 INS21 INS44 INS8 INS42 INS42 INS33 INS42 INS42 INS33 INS42 INS42 INS33 INS21 INS21 INS21 INS25 INS44 INS8 INS44 INS8 MOV42 MOV42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS2 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS45 INS32 INS45 INS32 INS42 INS42 INS42 INS42 UPD42 MOV42 MOV32 MOV42 MOV42 INS32 INS45 INS32 INS42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS34 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS34 INS42 UPD42 MOV42 INS27 UPD42 MOV42 UPD42 MOV42 INS42 INS43 INS42 INS42 MOV43 INS32 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 MOV43 INS42 INS42 INS7 INS7 INS43 INS42 INS60 INS21 INS53 INS7 INS7 INS7 INS27 INS8 INS8 MOV43 INS42 MOV60 INS21 INS53 INS43 INS42 INS60 INS21 INS53 MOV42 MOV42 MOV32 MOV42 MOV32 INS32 INS42 INS42 UPD42 MOV42 INS42 MOV32 INS42 MOV32 INS32 MOV42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS2 UPD42 INS34 MOV42 UPD42 MOV42 MOV32 INS42 INS32 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS42 INS42 MOV14 UPD42 INS42 INS42 INS42 MOV32 INS42 INS43 INS59 INS32 INS14 INS42 INS32 INS42 INS32 INS42 INS33 INS32 INS34 INS21 INS21 UPD43 INS32 INS14 INS42 INS43 INS59 INS32 INS14 UPD42 UPD42 UPD42 MOV42 INS42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 UPD42 UPD42 MOV2 UPD42 MOV42 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS34 INS42 INS42 INS7 INS7 UPD42 UPD42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 UPD42 MOV42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 UPD42 INS42 UPD42 MOV42 INS45 INS32 INS45 INS32 INS42 UPD42 UPD42 INS42 INS32 INS42 INS32 INS45 INS32 INS42 INS45 INS32 INS42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 MOV32 INS9 MOV42 MOV42 INS42 MOV32 MOV32 INS9 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL40 DEL65 DEL66 DEL65 DEL66 DEL42 DEL65 DEL42 DEL40 DEL43 DEL69 DEL68 DEL40 DEL43 DEL40 DEL43 DEL39 DEL32 DEL32 DEL42 DEL32 DEL34 DEL32 DEL32 DEL42 DEL32 DEL34 DEL32 DEL32 DEL40 DEL43 DEL40 DEL43 DEL32 DEL42 DEL32 DEL45 DEL40 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL59 DEL58 DEL42 DEL32 DEL32 DEL32 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL24 DEL8 DEL24 DEL8 DEL59 DEL60 DEL32 DEL32 DEL11 DEL32 DEL21 DEL8 DEL61 DEL8 DEL31 DEL66 DEL42 DEL65 DEL66 DEL40 DEL66 DEL65 DEL66 DEL65 DEL42 DEL66 DEL66 DEL42 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL44 DEL42 DEL40 DEL27 DEL42 DEL40 DEL27 DEL27 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL32 DEL59 DEL60 DEL43 DEL42 DEL32 DEL59 DEL58 DEL8 DEL24 DEL43 DEL42 DEL42 DEL32 DEL59 DEL58 DEL32 DEL40 DEL43 DEL42 DEL40 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL8 DEL24 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL24 DEL32 DEL59 DEL58 DEL32 DEL32 DEL32 DEL21 DEL8 DEL24 DEL8 DEL32 DEL40 DEL27 DEL42 DEL42 DEL42 DEL11 DEL36 DEL42 DEL32 DEL34 DEL32 DEL32 DEL42 DEL32 DEL32 DEL21 DEL8 DEL54 DEL8 DEL25 DEL8 DEL25 DEL8 DEL42 DEL40 DEL27 DEL8 DEL25 DEL25 DEL8 DEL31
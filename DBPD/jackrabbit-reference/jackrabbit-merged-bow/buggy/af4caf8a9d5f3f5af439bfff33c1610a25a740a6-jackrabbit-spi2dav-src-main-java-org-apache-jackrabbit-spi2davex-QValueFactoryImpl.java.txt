JCR-2689: Improve equals for binary values

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@980437 13f79535-47bb-0310-9956-ffa450edef68

+
+import static org.apache.jackrabbit.webdav.DavConstants.HEADER_ETAG;
+import static org.apache.jackrabbit.webdav.DavConstants.HEADER_LAST_MODIFIED;
+
-import org.apache.jackrabbit.spi.commons.value.ValueFactoryQImpl;
+import org.apache.jackrabbit.spi.commons.value.ValueFactoryQImpl;
+
+import java.util.Map;
+        private Map<String, String> headers;
+
-        private String uri;
-        private long length;
+        private final String uri;
+        private final long length;
-                // for both the value has not been loaded yet
-                if (!initialized) {
-                    if (other.uri != null) {
-                        return other.uri.equals(uri);
-                    } else {
-                        // need to load the binary value in order to be able
-                        // to compare the 2 values.
-                        try {
-                            loadBinary();
-                        } catch (RepositoryException e) {
-                            return false;
-                        } catch (IOException e) {
+
+                // Consider unequal urls as unequal values and both urls null as equal values
+                if (this.uri == null) {
+                    return other.uri == null;
+                }
+                if (!this.uri.equals(other.uri)) {
+                    return false;
+                }
+
+                // Consider both uninitialized as equal values
+                if (!this.preInitialized() && !other.preInitialized()) {
+                    return true;
+                }
+
+                try {
+                    // Initialized the one which is not
+                    if (!this.preInitialized()) {
+                        this.preInitialize(new String[] {HEADER_ETAG, HEADER_LAST_MODIFIED});
+                    } else if (!other.preInitialized()) {
+                        other.preInitialize(new String[] {HEADER_ETAG, HEADER_LAST_MODIFIED});
+                    }
+                } catch (RepositoryException e) {
+                    return false;
+                } catch (IOException e) {
+                    return false;
+                }
+
+                // If we have headers try to determine equality from them
+                if (headers != null && !headers.isEmpty()) {
+
+                    // Values are (un)equal if we have equal Etags
+                    if (containKey(HEADER_ETAG, this.headers, other.headers)) {
+                        return equalValue(HEADER_ETAG, this.headers, other.headers);
+                    }
+
+                    // Values are unequal if we have different Last-modified values
+                    if (containKey(HEADER_LAST_MODIFIED, this.headers, other.headers)) {
+                        if (!equalValue(HEADER_LAST_MODIFIED, this.headers, other.headers)) {
+
+                // Otherwise compare binaries
+                } else {
+                    return ((file == null ? other.file == null : file.equals(other.file))
+                        && Arrays.equals(buffer, other.buffer));
-                // both have been loaded
-                return ((file == null ? other.file == null : file.equals(other.file))
-                    && Arrays.equals(buffer, other.buffer));
+
+        /**
+         * Load the header with the given names. If none of the named headers exist, load binary.
+         */
+        private void preInitialize(String[] headerNames) throws IOException, RepositoryException {
+            headers = loader.loadHeaders(uri, headerNames);
+            if (headers.isEmpty()) {
+                loadBinary();
+            }
+        }
+
+        /**
+         * @return <code>true</code> if either initialized or headers have been
+         *         loaded, <code>false</code> otherwise.
+         */
+        private boolean preInitialized() {
+            return initialized || headers != null;
+        }
+
+        /**
+         * @return <code>true</code> if both maps contain the same value for
+         *         <code>key</code>, <code>false</code> otherwise. The
+         *         <code>key</code> must not map to <code>null</code> in either
+         *         map.
+         */
+        private boolean equalValue(String key, Map<String, String> map1, Map<String, String> map2) {
+            return map1.get(key).equals(map2.get(key));
+        }
+
+        /**
+         * @return <code>true</code> if both maps contains the <code>key</code>,
+         *         <code>false</code> otherwise.
+         */
+        private boolean containKey(String key, Map<String, String> map1, Map<String, String> map2) {
+            return map1.containsKey(key) && map2.containsKey(key);
+        }
+

MOV26 INS26 INS26 INS26 INS40 INS40 INS40 INS23 INS31 INS31 INS31 INS31 INS83 INS74 INS59 INS83 INS83 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS43 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS43 INS43 INS43 INS42 MOV25 INS25 MOV41 INS65 INS5 INS42 INS42 INS42 INS21 INS25 INS65 INS41 INS65 INS43 INS42 INS74 INS42 INS74 INS42 INS41 INS65 INS43 INS42 INS74 INS42 INS74 INS42 INS41 INS42 INS42 INS42 MOV62 INS8 INS66 INS43 INS85 INS7 INS32 MOV8 INS66 INS66 INS27 INS66 INS66 INS66 INS66 INS42 INS43 INS43 INS43 INS43 INS43 INS43 INS32 INS66 INS66 INS42 INS43 INS43 INS43 INS43 INS43 INS43 INS27 MOV60 INS25 INS25 INS25 INS54 INS25 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS27 INS8 INS38 INS8 INS27 INS8 INS8 MOV12 MOV12 INS27 INS8 MOV8 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS22 INS33 INS41 INS32 INS41 INS38 INS38 INS41 INS25 INS27 INS38 INS25 INS25 INS52 INS42 INS27 INS22 INS42 INS40 INS9 INS32 INS32 INS9 INS38 INS8 INS25 INS42 INS33 INS32 INS32 INS8 INS32 INS8 INS40 INS33 INS52 INS42 INS52 INS42 INS42 INS42 INS32 INS21 INS38 INS8 INS42 INS42 INS42 INS42 INS22 INS40 INS41 INS42 INS42 INS22 INS40 INS25 INS52 INS42 INS32 INS32 INS21 INS52 INS42 INS32 INS52 INS42 INS38 INS8 INS52 INS42 INS3 INS42 INS42 INS32 INS42 INS42 INS22 INS40 INS32 INS41 INS5 INS4 INS42 INS42 INS3 INS52 INS42 INS42 INS42 INS22 INS40 INS9 INS43 INS85 INS42 INS42 INS5 INS4 INS52 INS42 INS42 INS43 INS85 INS42 INS42 INS42 DEL42 DEL38 DEL40 DEL33 DEL27 DEL40 DEL42 DEL42 DEL32 DEL41 DEL8 DEL54 DEL8 DEL25 DEL8 DEL25 DEL25 DEL8
JCR-1799 updating events swallowed (CacheBehavior.OBSERVATION)   	
JCR-1783 incomplete changelog when combining move with removal of new destination parent

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@704361 13f79535-47bb-0310-9956-ffa450edef68

-            return createDeepPropertyState(info, anyParent, null);
+            PropertyState propState = createDeepPropertyState(info, anyParent, null);
+            assertValidState(propState, info);
+            return propState;
-                assertMatchingPath(first, nodeState.getNodeEntry());
+                assertValidState(nodeState, first);
-        // now build the nodestate itself
-        NodeState state = new NodeState(entry, info, this, definitionProvider);
-        state.setMixinTypeNames(info.getMixins());
+        if (Status.isTransient(entry.getStatus()) || Status.isStale(entry.getStatus())) {
+            log.debug("Node has pending changes; omit resetting the state.");
+            return entry.getNodeState();
+        }
-            entry.addPropertyEntries(propNames);
+            entry.setPropertyEntries(propNames);
-        notifyCreated(state);
-        return state;
+        // now build or update the nodestate itself
+        NodeState tmp = new NodeState(entry, info, this, definitionProvider);
+        entry.setItemState(tmp);
+
+        NodeState nState = entry.getNodeState();
+        if (nState == tmp) {
+            // tmp state was used as resolution for the given entry i.e. the
+            // entry was not available before. otherwise the 2 states were
+            // merged. see HierarchyEntryImpl#setItemState
+            notifyCreated(nState);
+        }
+        return nState;
-    private PropertyState createPropertyState(PropertyInfo info, PropertyEntry entry) {
+    private PropertyState createPropertyState(PropertyInfo info, PropertyEntry entry)
+            throws RepositoryException {
-        // build the PropertyState
-        PropertyState state = new PropertyState(entry, info, this, definitionProvider);
+        if (Status.isTransient(entry.getStatus()) || Status.isStale(entry.getStatus())) {
+            log.debug("Property has pending changes; omit resetting the state.");
+            return entry.getPropertyState();
+        }
-        notifyCreated(state);
-        return state;
+        // now build or update the nodestate itself
+        PropertyState tmp = new PropertyState(entry, info, this, definitionProvider);
+        entry.setItemState(tmp);
+
+        PropertyState pState = entry.getPropertyState();
+        if (pState == tmp) {
+            // tmp state was used as resolution for the given entry i.e. the
+            // entry was not available before. otherwise the 2 states were
+            // merged. see HierarchyEntryImpl#setItemState
+            notifyCreated(pState);
+        }
+        return pState;
-            Path anyParentPath = anyParent.getPath();
+            Path anyParentPath = anyParent.getWorkspacePath();
+            if (startsWithIllegalElement(missingElems)) {
+                log.error("Relative path to NodeEntry starts with illegal element -> ignore NodeInfo with path " + info.getPath());
+                return null;
+            }
+
-            NodeEntry entry = anyParent;
+            // make sure the missing elements don't start with . or .. in which
+            // case the info is not within the tree as it is expected
+            // (see also JCR-1797)
+            if (startsWithIllegalElement(missingElems)) {
+                log.error("Relative path to PropertyEntry starts with illegal element -> ignore PropertyInfo with path " + info.getPath());
+                return null;
+            }
+
+            NodeEntry entry = anyParent;
+     * Validation check: make sure the state is not null (was really created)
+     * and matches with the specified ItemInfo (path).
+     *
+     * @param state
+     * @param info
+     * @throws ItemNotFoundException
+     * @throws RepositoryException
+     */
+    private static void assertValidState(ItemState state, ItemInfo info)
+            throws ItemNotFoundException, RepositoryException {
+        if (state == null) {
+            throw new ItemNotFoundException("HierarchyEntry does not belong to any existing ItemInfo. No ItemState was created.");
+        }
+        assertMatchingPath(info, state.getHierarchyEntry());
+    }
+
+    /**
+     * Returns true if the given <code>missingElems</code> start with a parent (..),
+     * a current (.) or the root element, in which case the info is not within
+     * the tree as it is expected.
+     * See also #JCR-1797 for the corresponding enhancement request.
+     *
+     * @param missingElems
+     * @return
+     */
+    private static boolean startsWithIllegalElement(Path.Element[] missingElems) {
+        if (missingElems.length > 0) {
+            return !missingElems[0].denotesName();
+        }
+        return false;
+    }
+
+    /**

INS31 INS31 MOV60 INS43 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS43 INS43 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS8 INS25 INS21 INS60 INS25 INS42 INS25 INS21 INS60 INS25 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS42 INS42 INS25 INS21 INS65 INS65 INS65 INS5 INS42 INS25 INS41 INS27 INS8 INS32 INS43 INS59 INS27 INS8 UPD42 INS27 INS8 INS32 INS43 INS59 INS27 INS8 UPD42 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS8 INS32 INS66 INS66 INS66 INS66 INS42 INS43 INS85 INS27 INS8 INS9 INS60 INS21 INS32 INS32 INS21 INS41 UPD42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 MOV21 INS32 INS32 INS21 INS41 UPD42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 MOV21 INS25 INS25 INS42 INS33 INS53 INS42 INS42 INS32 INS40 INS40 INS34 INS41 INS43 INS59 INS32 INS42 UPD42 MOV42 UPD42 MOV42 MOV32 INS42 INS42 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS32 INS42 INS42 INS32 INS8 INS32 INS8 INS14 INS42 INS42 INS38 INS42 INS42 MOV32 INS42 INS42 INS42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 UPD42 INS42 INS42 INS21 INS41 INS42 INS42 INS21 INS41 INS43 INS45 INS32 UPD42 INS32 INS33 INS32 INS33 INS42 INS2 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS34 INS45 INS32 INS45 INS32 INS42 INS42 INS42 INS42 DEL42 DEL32 DEL32 DEL21
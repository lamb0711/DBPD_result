Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.observation.InternalEventListener;
+import org.apache.jackrabbit.jcr2spi.config.CacheBehaviour;
+import org.apache.jackrabbit.jcr2spi.hierarchy.NodeEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.HierarchyEntry;
-import org.apache.jackrabbit.name.QName;
-import org.apache.jackrabbit.spi.Event;
+import org.apache.jackrabbit.jcr2spi.state.ItemStateException;
+import org.apache.jackrabbit.jcr2spi.state.ItemStateLifeCycleListener;
+import org.apache.jackrabbit.jcr2spi.state.ItemState;
+import org.apache.jackrabbit.jcr2spi.state.PropertyState;
-import org.apache.jackrabbit.spi.EventBundle;
-import org.apache.jackrabbit.spi.EventFilter;
+import org.apache.jackrabbit.spi.NodeId;
+import org.apache.jackrabbit.name.QName;
-import javax.jcr.UnsupportedRepositoryOperationException;
-import java.util.Collection;
-import java.util.Collections;
+    private final CacheBehaviour cacheBehaviour;
-    public LockManagerImpl(WorkspaceManager wspManager, ItemManager itemManager) {
+    public LockManagerImpl(WorkspaceManager wspManager, ItemManager itemManager,
+                           CacheBehaviour cacheBehaviour) {
+        this.cacheBehaviour = cacheBehaviour;
-        // TODO: TOBEFIXED
-        if (nodeState.isWorkspaceState()) {
-            throw new RepositoryException("Internal error: Cannot create Lock for 'workspace' state.");
-        }
+        nodeState.checkIsSessionState();
-        // the overlayed workspace nodestate. See below.
-        Item item = itemManager.getItem(nodeState);
+        // the overlayed workspace nodestate.
+        Item item = itemManager.getItem(nodeState.getHierarchyEntry());
-        NodeState wspNodeState = getWorkspaceState(nodeState);
-        LockOperation op = LockOperation.create(wspNodeState, isDeep, isSessionScoped);
+        LockOperation op = LockOperation.create(nodeState, isDeep, isSessionScoped);
-        Lock lock = new LockImpl(new LockState(wspNodeState, op.getLockInfo()), lhNode);
+        Lock lock = new LockImpl(new LockState(nodeState, op.getLockInfo()), lhNode);
-        NodeState wspNodeState = getWorkspaceState(nodeState);
-        Operation op = LockRelease.create(wspNodeState);
+        Operation op = LockRelease.create(nodeState);
-        if (lockMap.containsKey(wspNodeState)) {
-            LockImpl l = (LockImpl) lockMap.remove(wspNodeState);
+        if (lockMap.containsKey(nodeState)) {
+            LockImpl l = (LockImpl) lockMap.remove(nodeState);
-        LockImpl l = getLockImpl(nodeState);
+        LockImpl l = getLockImpl(nodeState, false);
-        if (nodeState.isWorkspaceState()) {
-            LockState lSt = getLockState(nodeState);
-            return lSt != null;
-        } else {
-            LockImpl l = getLockImpl(nodeState);
-            return l != null;
-        }
+        nodeState.checkIsSessionState();
+
+        LockImpl l = getLockImpl(nodeState, false);
+        return l != null;
+        nodeState.checkIsSessionState();
+
-        if (nodeState.isWorkspaceState()) {
-            LockState lSt = getLockState(nodeState);
-            if (lSt != null && lSt.lockInfo.getLockToken() == null) {
-                // lock is present and token is null -> session is not lock-holder.
-                throw new LockException("Node with id '" + nodeState + "' is locked.");
-            } // else: state is not locked at all || session is lock-holder
-        } else {
-            LockImpl l = getLockImpl(nodeState);
-            if (l != null && l.getLockToken() == null) {
-                // lock is present and token is null -> session is not lock-holder.
-                throw new LockException("Node with id '" + nodeState + "' is locked.");
-            } // else: state is not locked at all || session is lock-holder
-        }
+        LockImpl l = getLockImpl(nodeState, true);
+        if (l != null && l.getLockToken() == null) {
+            // lock is present and token is null -> session is not lock-holder.
+            throw new LockException("Node with id '" + nodeState + "' is locked.");
+        } // else: state is not locked at all || session is lock-holder
-    /**
-     * The workspace state of the given node is returned. If the state is a new
-     * state (no overlayed state and not being workspace state itself), an
-     * <code>IllegalArgumentException</code> is thrown.
-     *
-     * @param nodeState
-     * @return The overlayed state or the given state, if this one does not have
-     * an overlayed state.
-     */
-    private NodeState getWorkspaceState(NodeState nodeState) {
-        NodeState wspState = (NodeState) nodeState.getWorkspaceState();
-        if (wspState == null) {
-            throw new IllegalArgumentException("NodeState " + nodeState + " has no overlayed state.");
-        }
-        return wspState;
-    }
+     * Note, that in certain cases it might not be possible to detect a lock
+     * being present due to the fact that the hierarchy might be imcomplete or
+     * not even readable completely.
-        while (!nodeState.hasPropertyName(QName.JCR_LOCKISDEEP)) {
-            NodeState parentState = nodeState.getParent();
-            if (parentState == null) {
+        NodeEntry entry = nodeState.getNodeEntry();
+        while (!entry.hasPropertyEntry(QName.JCR_LOCKISDEEP)) {
+            NodeEntry parent = entry.getParent();
+            if (parent == null) {
-            nodeState = parentState;
+            entry = parent;
-        return nodeState;
+        try {
+            return entry.getNodeState();
+        } catch (ItemStateException e) {
+            // may occur if the nodeState is not accessible
+            // for this case, assume that no lock exists and delegate final
+            // validation to the spi-implementation.
+            log.warn("Error while accessing lock holding NodeState", e);
+            return null;
+        }
-    private LockState getLockState(NodeState wspState) throws LockException, RepositoryException {
-        wspState.checkIsWorkspaceState();
-
-        if (lockMap.containsKey(wspState)) {
-            LockImpl lock = (LockImpl) lockMap.get(wspState);
-            return lock.lockState;
+    private LockState buildLockState(NodeState nodeState) throws RepositoryException {
+        NodeState lockHoldingState = null;
+        LockInfo lockInfo;
+        try {
+            lockInfo = wspManager.getLockInfo(nodeState.getNodeId());
+        } catch (LockException e) {
+            // no lock present
+            return null;
-        // try to retrieve a state (ev. a parent state) that holds a lock.
-        NodeState lockHoldingWspState = getLockHoldingState(wspState);
-        if (lockHoldingWspState == null) {
-            // no lock
+        NodeId lockNodeId = lockInfo.getNodeId();
+        if (lockNodeId.equals(nodeState.getId())) {
+            lockHoldingState = nodeState;
+        } else {
+            HierarchyEntry lockedEntry = wspManager.getHierarchyManager().getHierarchyEntry(lockNodeId);
+            if (lockedEntry.denotesNode()) {
+                try {
+                    lockHoldingState = ((NodeEntry) lockedEntry).getNodeState();
+                } catch (ItemStateException e) {
+                    log.warn("Cannot build LockState");
+                    throw new RepositoryException("Cannot build LockState", e);
+                }
+            } else {
+                // should never occur
+                throw new RepositoryException("Internal error.");
+            }
+        }
+
+        if (lockHoldingState == null) {
-            if (lockMap.containsKey(lockHoldingWspState)) {
-                LockImpl lock = (LockImpl) lockMap.get(lockHoldingWspState);
-                return lock.lockState;
-            }
-
-            LockState st = new LockState(lockHoldingWspState);
-            if (st.appliesToNodeState(wspState)) {
-                return st;
-            } else {
-                // lock exists but does not apply to the workspace node state
-                // passed to this method.
-                return null;
-            }
+            return new LockState(lockHoldingState, lockInfo);
+     * @param lazyLockDiscovery If true, no extra check with the server is made in order to
+     * determine, whether there is really no lock present. Otherwise, the server
+     * is asked if a lock is present.
-    private LockImpl getLockImpl(NodeState nodeState) throws RepositoryException {
+    private LockImpl getLockImpl(NodeState nodeState, boolean lazyLockDiscovery) throws RepositoryException {
+        nodeState.checkIsSessionState();
+
-        NodeState wspSt = (NodeState) nodeState.getWorkspaceState();
-        if (wspSt != null && lockMap.containsKey(nodeState)) {
+        if (lockMap.containsKey(nodeState)) {
-        // try to retrieve a state (ev. a parent state) that holds a lock.
-        NodeState lockHoldingState = getLockHoldingState(nodeState);
-        if (lockHoldingState == null) {
-            // no lock
-            return null;
-        } else {
-            NodeState lockHoldingWspState = getWorkspaceState(lockHoldingState);
-            // check lockMap again with the lockholding state
-            if (lockMap.containsKey(lockHoldingWspState)) {
-                return (LockImpl) lockMap.get(lockHoldingWspState);
-            }
-
-            if (lockHoldingWspState == lockHoldingState) {
-                // TODO: TOBEFIXED the Lock cannot be builded from a wsp-state since the Node cannot be retrieved.
-                throw new RepositoryException("Internal error: Cannot retrieve Lock for 'workspace' state " + nodeState);
-            }
-            LockState lstate = new LockState(lockHoldingWspState);
-            // Lock has never been access -> build the lock object
-            // retrieve lock holding node. note that this may fail if the session
-            // does not have permission to see this node.
-            Item lockHoldingNode = itemManager.getItem(lockHoldingState);
-            LockImpl l = new LockImpl(lstate, (Node)lockHoldingNode);
-
-            if (l.lockState.appliesToNodeState(nodeState)) {
-                return l;
-            } else {
-                // lock exists but does not apply to the workspace node state
-                // passed to this method.
+        LockState lState;
+        if (lazyLockDiscovery) {
+            // try to retrieve a state (ev. a parent state) that holds a lock.
+            NodeState lockHoldingState = getLockHoldingState(nodeState);
+            if (lockHoldingState == null) {
+                // no lock
+            } else {
+                // check lockMap again with the lockholding state
+                if (lockMap.containsKey(lockHoldingState)) {
+                    return (LockImpl) lockMap.get(lockHoldingState);
+                }
+                lState = buildLockState(lockHoldingState);
+        } else {
+            lState = buildLockState(nodeState);
+        }
+
+        // Lock has never been access -> build the lock object
+        // retrieve lock holding node. note that this may fail if the session
+        // does not have permission to see this node.
+        if (lState != null && lState.appliesToNodeState(nodeState)) {
+            Item lockHoldingNode = itemManager.getItem(lState.lockHoldingState.getHierarchyEntry());
+            return new LockImpl(lState, (Node)lockHoldingNode);
+        } else {
+            // lock exists but does not apply to the given node state
+            // passed to this method.
+            return null;
-    private class LockState implements InternalEventListener{
+    private class LockState implements ItemStateLifeCycleListener {
-        private EventFilter eventFilter;
-        private LockState(NodeState lockHoldingState, LockInfo lockInfo)
-            throws LockException, RepositoryException{
-            lockHoldingState.checkIsWorkspaceState();
+        private LockState(NodeState lockHoldingState, LockInfo lockInfo) {
+            lockHoldingState.checkIsSessionState();
-            if (lockInfo == null) {
-                // retrieve lock info from wsp-manager, in order to get the complete
-                // lockInfo including lock-token, which is not available from the
-                // child properties nor from the original lock request.
-                this.lockInfo = wspManager.getLockInfo(lockHoldingState.getNodeId());
-            } else {
-                this.lockInfo = lockInfo;
-            }
-
-            try {
-                // register as internal listener to the wsp manager in order to get
-                // informed if this lock ends his life.
-                eventFilter = wspManager.createEventFilter(Event.PROPERTY_REMOVED,
-                    lockHoldingState.getQPath(), false, null, null, true);
-                wspManager.addEventListener(this);
-            } catch (UnsupportedRepositoryOperationException e) {
-                eventFilter = null;
-            }
-        }
-
-        private LockState(NodeState lockHoldingState) throws LockException, RepositoryException {
-            this(lockHoldingState, null);
+            this.lockInfo = lockInfo;
-                NodeState wspState = getWorkspaceState(nodeState);
-                if (lockHoldingState == wspState) {
+                if (lockHoldingState == nodeState) {
-            wspManager.removeEventListener(this);
+            stopListening();
-        //------------------------------------------< InternalEventListener >---
-
-        /**
-         * @see InternalEventListener#getEventFilters()
-         */
-        public Collection getEventFilters() {
-            return (eventFilter == null) ?  Collections.EMPTY_LIST : Collections.singletonList(eventFilter);
+        private void startListening() {
+            if (cacheBehaviour == CacheBehaviour.OBSERVATION) {
+                try {
+                    PropertyState ps = lockHoldingState.getPropertyState(QName.JCR_LOCKISDEEP);
+                    ps.addListener(this);
+                } catch (ItemStateException e) {
+                    log.warn("Internal error", e);
+                }
+            }
-        /**
-         * @see InternalEventListener#onEvent(EventBundle)
-         */
-        public void onEvent(EventBundle eventBundle) {
+        private void stopListening() {
+            if (cacheBehaviour == CacheBehaviour.OBSERVATION) {
+                try {
+                    PropertyState ps = lockHoldingState.getPropertyState(QName.JCR_LOCKISDEEP);
+                    ps.removeListener(this);
+                } catch (ItemStateException e) {
+                    log.warn("Internal error", e);
+                }
+            }
+        }
+
+        //-------------------------------------< ItemStateLifeCycleListener >---
+        public void statusChanged(ItemState state, int previousStatus) {
-            // this lock has been release by someone else (and not by
-            // a call to LockManager#unlock -> clean up and set isLive
-            // flag to false.
-            unlocked();
+            switch (state.getStatus()) {
+                case Status.REMOVED:
+                    // this lock has been release by someone else (and not by
+                    // a call to LockManager#unlock -> clean up and set isLive
+                    // flag to false.
+                    unlocked();
+               default:
+                   // not interested (Todo correct?)
+            }
-            // if observation is supported -> store lock in the map
-            if (lockState.eventFilter != null) {
+            // if observation is supported OR if this is a session-scoped lock
+            // holded by this session -> store lock in the map
+            if (cacheBehaviour == CacheBehaviour.OBSERVATION) {
+                lockMap.put(lockState.lockHoldingState, this);
+                lockState.startListening();
+            } else if (isSessionScoped() && isHoldBySession()) {
+        //--------------------------------------------------------< private >---
+        private boolean isHoldBySession() {
+            return lockState.lockInfo.getLockToken() != null;
+        }
-}
+}

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 UPD40 UPD40 UPD40 UPD40 INS40 UPD40 UPD40 UPD40 INS23 INS31 INS31 MOV31 INS83 INS83 INS43 INS59 INS44 MOV8 MOV29 INS83 MOV43 UPD42 MOV42 MOV44 INS8 INS83 MOV43 INS42 MOV44 MOV43 INS8 INS44 INS8 UPD43 INS31 INS31 INS31 UPD42 MOV42 INS42 INS43 INS42 INS21 INS21 INS21 MOV60 MOV41 INS21 MOV25 MOV60 MOV61 INS54 INS60 INS60 INS54 MOV60 INS25 INS25 INS65 INS39 INS42 INS21 MOV25 MOV60 INS25 INS25 UPD42 INS83 INS42 MOV44 MOV44 MOV8 INS39 UPD42 MOV83 INS39 UPD42 MOV42 INS8 UPD42 INS44 INS83 INS39 INS42 INS8 INS42 INS7 INS32 INS32 INS32 INS66 INS66 INS66 UPD43 INS8 INS12 MOV43 INS59 UPD43 MOV43 INS59 INS8 INS12 UPD43 INS32 INS8 INS8 INS27 MOV8 MOV8 INS42 INS66 INS66 INS66 INS32 MOV32 MOV43 INS42 INS8 INS8 INS27 INS8 MOV8 INS21 MOV21 INS25 INS25 UPD43 UPD42 INS39 INS42 INS50 INS25 INS41 INS22 INS42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 UPD42 INS32 MOV41 INS44 INS8 INS42 INS33 UPD42 UPD42 MOV42 INS21 INS44 MOV8 UPD42 UPD42 INS42 UPD42 MOV42 INS32 INS21 MOV60 INS25 INS42 INS33 MOV42 UPD42 MOV42 INS42 MOV60 INS25 INS21 INS27 INS32 INS60 MOV41 INS32 MOV27 INS8 INS27 INS8 UPD42 INS32 INS49 MOV21 INS49 INS27 INS8 MOV25 INS27 INS52 INS42 INS32 UPD42 UPD42 INS9 INS9 INS9 MOV42 UPD42 MOV42 UPD42 UPD42 INS43 MOV8 INS32 UPD43 MOV43 UPD42 MOV42 MOV21 INS41 INS7 MOV43 INS42 UPD42 UPD42 UPD42 MOV42 INS42 INS7 UPD43 INS32 INS8 MOV8 INS14 MOV27 MOV8 INS8 INS7 INS42 INS33 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV43 INS59 MOV14 INS42 INS42 UPD42 UPD42 INS40 MOV54 INS42 INS40 INS54 INS42 INS42 INS40 INS42 INS40 INS21 INS21 UPD27 INS32 INS33 MOV42 INS42 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 UPD42 INS33 INS42 INS32 INS42 INS42 UPD42 UPD42 INS32 INS42 INS42 INS54 MOV43 INS42 INS42 MOV25 INS21 INS42 INS32 INS42 INS32 UPD42 INS8 INS12 INS32 INS32 INS32 INS32 INS40 INS42 UPD42 INS42 UPD42 INS45 UPD42 UPD42 MOV42 UPD42 MOV42 INS32 INS32 UPD42 MOV42 UPD42 MOV42 INS8 INS12 INS7 INS42 INS42 INS42 INS42 INS32 UPD42 INS60 INS60 INS21 INS44 INS8 INS42 INS42 INS40 INS52 INS42 INS42 INS42 INS42 UPD42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 INS21 INS44 MOV8 INS45 UPD42 INS42 INS32 UPD40 MOV40 UPD42 MOV42 INS43 INS59 UPD43 INS43 INS59 INS32 INS43 INS42 INS21 INS7 INS43 INS42 INS21 INS42 INS42 INS42 INS42 INS32 UPD42 UPD42 UPD42 INS32 UPD42 MOV42 INS42 INS32 INS42 INS42 INS52 UPD42 MOV42 INS32 INS42 INS32 INS42 INS32 MOV42 UPD42 MOV42 INS40 INS42 INS42 INS45 INS42 INS42 INS42 INS40 UPD42 MOV42 UPD42 MOV42 INS45 UPD42 MOV42 INS36 UPD42 MOV42 INS42 INS42 INS45 UPD45 INS42 UPD42 INS11 INS43 INS42 INS42 DEL32 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL41 DEL8 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL40 DEL42 DEL32 DEL33 DEL27 DEL27 DEL45 DEL42 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL8 DEL25 DEL8 DEL42 DEL43 DEL32 DEL11 DEL42 DEL42 DEL43 DEL32 DEL11 DEL45 DEL42 DEL27 DEL42 DEL66 DEL66 DEL66 DEL65 DEL42 DEL65 DEL66 DEL66 DEL65 DEL29 DEL83 DEL43 DEL42 DEL33 DEL27 DEL42 DEL43 DEL45 DEL42 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL83 DEL42 DEL8 DEL31 DEL83 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL32 DEL11 DEL59 DEL60 DEL40 DEL41 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL32 DEL40 DEL41 DEL8 DEL25 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL25 DEL8 DEL25 DEL8 DEL31 DEL42 DEL33 DEL27 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL27 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL32 DEL8 DEL25 DEL8 DEL25 DEL8 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL33 DEL17 DEL8 DEL31 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL52 DEL42 DEL43 DEL42 DEL43 DEL33 DEL42 DEL42 DEL42 DEL40 DEL32 DEL9 DEL33 DEL33 DEL9 DEL32 DEL7 DEL21 DEL42 DEL33 DEL7 DEL42 DEL42 DEL32 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL68 DEL65 DEL29 DEL83 DEL43 DEL42 DEL42 DEL33 DEL27 DEL36 DEL40 DEL32 DEL16 DEL41 DEL8 DEL31 DEL42 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL29 DEL40 DEL33
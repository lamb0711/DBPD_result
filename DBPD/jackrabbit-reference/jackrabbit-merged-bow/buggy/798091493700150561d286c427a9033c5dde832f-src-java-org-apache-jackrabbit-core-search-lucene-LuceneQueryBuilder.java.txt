JCR-106: Minimize use of fields in lucene index

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@161425 13f79535-47bb-0310-9956-ffa450edef68

-        BooleanQuery notQuery = new BooleanQuery();
-        try {
-            // first select any node
-            notQuery.add(new MatchAllQuery(primaryType.toJCRName(nsMappings)),
-                    false, false);
-        } catch (NoPrefixDeclaredException e) {
-            // will never happen, prefixes are created when unknown
-        }
-        for (int i = 0; i < result.length; i++) {
-            Query operand = (Query) result[i];
-            // then prohibit the nodes from the not clause
-            notQuery.add(operand, false, true);
+        if (result.length == 0) {
+            return data;
-        return notQuery;
+        // join the results
+        BooleanQuery b = new BooleanQuery();
+        for (int i = 0; i < result.length; i++) {
+            b.add((Query) result[i], false, false);
+        }
+        // negate
+        return new NotQuery(b);
-        return new TermQuery(new Term(field, value));
+        return new TermQuery(new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, value)));
-            return new TermQuery(new Term(field, (String) values.get(0)));
+            Term t = new Term(FieldNames.PROPERTIES,
+                    FieldNames.createNamedValue(field, (String) values.get(0)));
+            return new TermQuery(t);
-                b.add(new TermQuery(new Term(field, (String) it.next())), false, false);
+                Term t = new Term(FieldNames.PROPERTIES,
+                        FieldNames.createNamedValue(field, (String) it.next()));
+                b.add(new TermQuery(t), false, false);
-                    Query subQuery = new MatchAllQuery(FieldNames.UUID);
+                    Query subQuery = null;
+                    try {
+                        subQuery = new MatchAllQuery(primaryType.toJCRName(nsMappings));
+                    } catch (NoPrefixDeclaredException e) {
+                        // will never happen, prefixes are created when unknown
+                    }
-        String primaryTypeField = "";
-        String mvpField = "";
-            primaryTypeField = primaryType.toJCRName(nsMappings);
-            StringBuffer tmp = new StringBuffer();
-            tmp.append(nsMappings.getPrefix(node.getProperty().getNamespaceURI()));
-            tmp.append(':').append(FieldNames.MVP_PREFIX);
-            tmp.append(node.getProperty().getLocalName());
-            mvpField = tmp.toString();
-        } catch (NamespaceException e) {
-            // should never happen
-            exceptions.add(e);
-                if (stringValues.length == 1) {
-                    query = new TermQuery(new Term(field, stringValues[0]));
-                } else {
-                    BooleanQuery or = new BooleanQuery();
-                    for (int i = 0; i < stringValues.length; i++) {
-                        or.add(new TermQuery(new Term(field, stringValues[i])), false, false);
-                    }
-                    query = or;
-                }
-                break;
-            case QueryConstants.OPERATION_EQ_GENERAL:    // =
-                // search in single and multi valued properties
+            case QueryConstants.OPERATION_EQ_GENERAL:
-                    or.add(new TermQuery(new Term(field, stringValues[i])), false, false);
-                    or.add(new TermQuery(new Term(mvpField, stringValues[i])), false, false);
+                    or.add(new TermQuery(new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, stringValues[i]))), false, false);
+                if (node.getOperation() == QueryConstants.OPERATION_EQ_VALUE) {
+                    query = createSingleValueConstraint(or, field);
+                }
-                if (stringValues.length == 1) {
-                    query = new RangeQuery(new Term(field, stringValues[0]), null, true);
-                } else {
-                    or = new BooleanQuery();
-                    for (int i = 0; i < stringValues.length; i++) {
-                        or.add(new RangeQuery(new Term(field, stringValues[i]), null, true), false, false);
-                    }
-                    query = or;
-                }
-                break;
-            case QueryConstants.OPERATION_GE_GENERAL:   // >=
-                // search in single and multi valued properties
+            case QueryConstants.OPERATION_GE_GENERAL:
-                    or.add(new RangeQuery(new Term(field, stringValues[i]), null, true), false, false);
-                    or.add(new RangeQuery(new Term(mvpField, stringValues[i]), null, true), false, false);
+                    Term lower = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, stringValues[i]));
+                    Term upper = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, "\uFFFF"));
+                    or.add(new RangeQuery(lower, upper, true), false, false);
+                if (node.getOperation() == QueryConstants.OPERATION_GE_VALUE) {
+                    query = createSingleValueConstraint(or, field);
+                }
-                if (stringValues.length == 1) {
-                    query = new RangeQuery(new Term(field, stringValues[0]), null, false);
-                } else {
-                    or = new BooleanQuery();
-                    for (int i = 0; i < stringValues.length; i++) {
-                        or.add(new RangeQuery(new Term(field, stringValues[i]), null, false), false, false);
-                    }
-                    query = or;
-                }
-                break;
-            case QueryConstants.OPERATION_GT_GENERAL:      // >
+            case QueryConstants.OPERATION_GT_GENERAL:
-                    or.add(new RangeQuery(new Term(field, stringValues[i]), null, false), false, false);
-                    or.add(new RangeQuery(new Term(mvpField, stringValues[i]), null, false), false, false);
+                    Term lower = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, stringValues[i]));
+                    Term upper = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, "\uFFFF"));
+                    or.add(new RangeQuery(lower, upper, false), false, false);
-                break;
-            case QueryConstants.OPERATION_LE_VALUE:      // <=
-                if (stringValues.length == 1) {
-                    query = new RangeQuery(null, new Term(field, stringValues[0]), true);
-                } else {
-                    or = new BooleanQuery();
-                    for (int i = 0; i < stringValues.length; i++) {
-                        or.add(new RangeQuery(null, new Term(field, stringValues[i]), true), false, false);
-                    }
-                    query = or;
+                if (node.getOperation() == QueryConstants.OPERATION_GT_VALUE) {
+                    query = createSingleValueConstraint(or, field);
+            case QueryConstants.OPERATION_LE_VALUE:      // <=
-                    or.add(new RangeQuery(null, new Term(field, stringValues[i]), true), false, false);
-                    or.add(new RangeQuery(null, new Term(mvpField, stringValues[i]), true), false, false);
+                    Term lower = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, ""));
+                    Term upper = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, stringValues[i]));
+                    or.add(new RangeQuery(lower, upper, true), false, false);
+                if (node.getOperation() == QueryConstants.OPERATION_LE_VALUE) {
+                    query = createSingleValueConstraint(query, field);
+                }
-                    query = new WildcardQuery(new Term(field, stringValues[0]));
+                    Term t = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, stringValues[0]));
+                    query = new WildcardQuery(t);
-                if (stringValues.length == 1) {
-                    query = new RangeQuery(null, new Term(field, stringValues[0]), false);
-                } else {
-                    or = new BooleanQuery();
-                    for (int i = 0; i < stringValues.length; i++) {
-                        or.add(new RangeQuery(null, new Term(field, stringValues[i]), false), false, false);
-                    }
-                    query = or;
-                }
-                break;
-            case QueryConstants.OPERATION_LT_GENERAL:      // <
+            case QueryConstants.OPERATION_LT_GENERAL:
-                    or.add(new RangeQuery(null, new Term(field, stringValues[i]), false), false, false);
-                    or.add(new RangeQuery(null, new Term(mvpField, stringValues[i]), false), false, false);
+                    Term lower = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, ""));
+                    Term upper = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, stringValues[i]));
+                    or.add(new RangeQuery(lower, upper, false), false, false);
+                if (node.getOperation() == QueryConstants.OPERATION_LT_VALUE) {
+                    query = createSingleValueConstraint(or, field);
+                }
+                // match nodes with property 'field' that includes svp and mvp
+                // exclude all nodes where 'field' has the term in question
-                    notQuery.add(new TermQuery(new Term(field, stringValues[i])), false, true);
+                    Term t = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, stringValues[i]));
+                    notQuery.add(new TermQuery(t), false, true);
+                // and exclude all nodes where 'field' is multi valued
+                notQuery.add(new TermQuery(new Term(FieldNames.MVP, field)), false, true);
-                // search in single and multi valued properties
+                // that's:
+                // all nodes with property 'field'
+                // minus the nodes that have a single property 'field' that is
+                //    not equal to term in question
+                // minus the nodes that have a multi-valued property 'field' and
+                //    all values are equal to term in question
-                notQuery.add(new MatchAllQuery(mvpField), false, false);
-                    notQuery.add(new TermQuery(new Term(field, stringValues[i])), false, true);
-                    notQuery.add(new TermQuery(new Term(mvpField, stringValues[i])), false, true);
+                    // exclude the nodes that have the term and are single valued
+                    Term t = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, stringValues[i]));
+                    Query svp = new NotQuery(new TermQuery(new Term(FieldNames.MVP, field)));
+                    BooleanQuery and = new BooleanQuery();
+                    and.add(new TermQuery(t), true, false);
+                    and.add(svp, true, false);
+                    notQuery.add(and, false, true);
+                // todo above also excludes multi-valued properties that contain
+                //      multiple instances of only stringValues. e.g. text={foo, foo}
-                notQuery = new BooleanQuery();
-                notQuery.add(new MatchAllQuery(primaryTypeField), false, false);
-                notQuery.add(new MatchAllQuery(field), false, true);
-                query = notQuery;
+                query = new NotQuery(new MatchAllQuery(field));
-    
+
+    /**
+     * Wraps a constraint query around <code>q</code> that limits the nodes to
+     * those where <code>propName</code> is the name of a single value property
+     * on the node instance.
+     * @param q the query to wrap.
+     * @param propName the name of a property that only has one value.
+     * @return the wrapped query <code>q</code>.
+     */
+    private Query createSingleValueConstraint(Query q, String propName) {
+        // get nodes with multi-values in propName
+        Query mvp = new TermQuery(new Term(FieldNames.MVP, propName));
+        // now negate, that gives the nodes that have propName as single
+        // values but also all others
+        Query svp = new NotQuery(mvp);
+        // now join the two, which will result in those nodes where propName
+        // only contains a single value. This works because q already restricts
+        // the result to those nodes that have a property propName
+        BooleanQuery and = new BooleanQuery();
+        and.add(q, true, false);
+        and.add(svp, true, false);
+        return and;
+    }
+

INS31 MOV60 INS29 INS83 INS43 INS42 INS44 INS44 INS8 INS25 MOV21 MOV21 MOV49 MOV21 MOV21 MOV10 MOV21 MOV24 MOV21 MOV21 MOV21 MOV21 MOV21 INS65 INS65 INS65 INS65 INS42 INS43 INS42 MOV43 INS42 INS60 INS60 INS60 INS21 INS21 INS41 INS27 INS8 INS14 INS24 INS25 INS10 INS24 INS25 INS10 INS24 INS25 INS10 INS10 INS24 INS25 INS21 INS24 INS10 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS43 INS59 INS43 INS59 INS43 INS59 INS32 INS32 INS42 INS40 INS34 INS41 UPD42 INS43 INS42 MOV58 MOV27 MOV37 MOV8 INS27 MOV8 MOV58 MOV27 MOV37 INS8 INS27 MOV8 MOV58 MOV27 MOV37 INS8 MOV58 MOV27 MOV37 MOV27 MOV8 MOV58 MOV27 MOV37 INS8 INS27 INS8 MOV58 MOV27 MOV37 INS8 MOV32 MOV58 MOV27 MOV37 INS8 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS42 INS9 INS9 INS42 INS42 INS42 INS9 INS9 INS42 INS42 INS40 INS32 INS60 INS32 UPD40 MOV40 INS60 INS60 MOV21 INS32 UPD40 MOV40 INS60 INS60 MOV21 INS32 UPD40 INS60 INS60 INS32 UPD40 INS60 INS60 INS60 MOV21 INS32 INS40 MOV21 INS60 MOV21 INS60 INS60 INS60 MOV21 INS21 INS21 INS14 MOV43 INS14 INS43 INS42 INS43 UPD42 MOV11 UPD9 INS42 INS42 INS42 INS42 INS43 INS59 UPD42 MOV42 UPD42 MOV42 MOV43 INS59 INS43 INS59 UPD42 MOV42 UPD42 MOV42 MOV43 INS59 MOV43 INS59 INS42 INS42 MOV43 INS59 MOV43 INS59 INS42 INS42 MOV43 INS59 MOV43 INS59 MOV43 INS59 INS42 INS42 MOV43 INS59 MOV43 MOV43 INS59 MOV43 INS59 INS43 INS59 MOV32 MOV32 INS43 MOV14 MOV43 INS40 INS42 INS42 INS42 INS42 INS42 MOV14 INS42 INS60 INS14 INS32 INS42 MOV14 UPD42 MOV42 INS42 INS14 INS32 INS42 INS14 INS42 INS14 INS32 INS42 INS14 INS42 MOV14 INS32 INS42 INS14 INS14 INS42 INS14 UPD42 MOV42 MOV14 INS32 UPD42 MOV42 INS14 UPD42 INS14 INS9 UPD9 MOV43 INS40 INS42 INS14 UPD42 MOV42 INS14 INS42 INS42 INS14 UPD42 INS14 UPD9 UPD9 UPD42 INS42 UPD9 INS42 INS42 INS40 INS32 INS43 INS59 MOV54 MOV43 INS14 INS42 INS42 INS42 INS40 INS32 MOV43 INS40 INS32 MOV43 INS42 UPD42 MOV42 INS42 INS42 INS42 MOV43 INS40 INS32 MOV43 INS40 INS32 MOV43 INS42 INS42 INS42 INS42 INS42 MOV43 INS40 INS32 INS40 INS32 MOV43 INS42 UPD42 MOV42 INS42 INS42 INS42 MOV43 INS40 INS32 MOV43 UPD42 MOV42 MOV43 INS40 INS32 INS40 INS32 MOV43 INS42 UPD42 MOV42 INS42 INS42 INS42 MOV43 INS40 INS32 MOV43 UPD42 MOV42 MOV43 INS40 INS32 INS43 INS14 INS43 MOV43 UPD42 MOV42 INS42 INS42 INS42 MOV11 INS42 INS42 MOV14 UPD43 MOV43 INS40 INS32 INS42 INS42 INS42 MOV2 INS42 INS42 INS42 INS45 UPD42 MOV42 UPD42 MOV42 INS42 MOV2 UPD42 MOV42 UPD42 MOV42 INS42 INS45 UPD42 MOV42 INS42 INS42 INS45 INS42 INS42 INS42 MOV2 INS42 INS42 INS42 MOV2 INS42 INS42 INS42 INS45 INS42 INS42 INS42 MOV2 UPD42 MOV42 UPD42 MOV42 INS42 MOV2 UPD42 MOV42 INS42 INS42 MOV2 INS42 MOV43 INS14 INS42 INS40 INS32 INS42 INS33 UPD42 INS42 INS42 INS42 MOV2 MOV43 INS40 INS42 INS42 INS42 INS42 MOV11 INS7 INS42 MOV14 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL40 DEL14 DEL42 DEL42 DEL9 DEL9 DEL32 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL32 DEL21 DEL42 DEL42 DEL13 DEL32 DEL42 DEL40 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL12 DEL40 DEL34 DEL27 DEL42 DEL42 DEL42 DEL34 DEL2 DEL14 DEL14 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL24 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL10 DEL14 DEL42 DEL14 DEL14 DEL9 DEL9 DEL32 DEL21 DEL42 DEL42 DEL42 DEL14 DEL14 DEL9 DEL9 DEL32 DEL21 DEL8 DEL24 DEL42 DEL42 DEL34 DEL2 DEL14 DEL33 DEL9 DEL14 DEL10 DEL34 DEL27 DEL42 DEL43 DEL14 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL2 DEL14 DEL33 DEL9 DEL14 DEL9 DEL9 DEL32 DEL21 DEL8 DEL24 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL10 DEL42 DEL42 DEL43 DEL42 DEL42 DEL2 DEL14 DEL33 DEL33 DEL9 DEL14 DEL9 DEL9 DEL32 DEL21 DEL8 DEL24 DEL42 DEL43 DEL42 DEL14 DEL33 DEL9 DEL14 DEL10 DEL34 DEL27 DEL42 DEL42 DEL43 DEL14 DEL7 DEL21 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL42 DEL42 DEL2 DEL14 DEL33 DEL9 DEL14 DEL9 DEL9 DEL32 DEL21 DEL8 DEL24 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL10 DEL33 DEL42 DEL43 DEL42 DEL42 DEL42 DEL2 DEL14 DEL33 DEL9 DEL14 DEL9 DEL9 DEL32 DEL21 DEL8 DEL24 DEL10 DEL34 DEL42 DEL43 DEL33 DEL42 DEL42 DEL34 DEL2 DEL14 DEL9 DEL14 DEL42 DEL42 DEL43 DEL14 DEL7 DEL21 DEL42 DEL42 DEL42 DEL43 DEL33 DEL42 DEL14 DEL9 DEL14 DEL9 DEL9 DEL32 DEL21 DEL8 DEL24 DEL42 DEL42 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL43 DEL33 DEL42 DEL42 DEL42 DEL2 DEL14 DEL9 DEL14 DEL9 DEL9 DEL32 DEL21 DEL42 DEL43 DEL33 DEL14 DEL34 DEL42 DEL43 DEL33 DEL42 DEL42 DEL34 DEL2 DEL14 DEL9 DEL14 DEL10 DEL42 DEL34 DEL2 DEL14 DEL14 DEL10 DEL42 DEL42 DEL43 DEL14 DEL7 DEL21 DEL39 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL8 DEL24 DEL8 DEL25 DEL42 DEL42 DEL43 DEL33 DEL42 DEL42 DEL2 DEL14 DEL42 DEL10 DEL42 DEL43 DEL33 DEL42 DEL42 DEL2 DEL14 DEL9 DEL14 DEL9 DEL39 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL43 DEL33 DEL42 DEL42 DEL42 DEL2 DEL14 DEL9 DEL14 DEL9 DEL9 DEL32 DEL21 DEL8 DEL42 DEL42 DEL2 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL21 DEL8 DEL24 DEL42 DEL42 DEL2 DEL14 DEL14 DEL42 DEL43 DEL42 DEL14 DEL42 DEL42 DEL43 DEL42 DEL14 DEL9 DEL9 DEL32 DEL21 DEL39 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL42 DEL42 DEL42 DEL2 DEL14 DEL14 DEL9 DEL9 DEL32 DEL21 DEL8 DEL24 DEL10 DEL42 DEL42 DEL43 DEL14 DEL7 DEL21 DEL21 DEL21 DEL42
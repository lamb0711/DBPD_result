JCR-645

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@478892 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.List;
-import java.util.LinkedList;
+import java.util.HashMap;
+import java.util.Iterator;
-    // the list of prepared statements, used in close()
-    private List preparedStatements;
+    // internal flag governing whether an automatic reconnect should be
+    // attempted after a SQLException had been encountered    
+    protected boolean autoReconnect = true;
+    // time to sleep in ms before a reconnect is attempted
+    protected static final int SLEEP_BEFORE_RECONNECT = 10000;
-    // shared prepared statements for NodeState management
-    protected PreparedStatement nodeStateInsert;
-    protected PreparedStatement nodeStateUpdate;
-    protected PreparedStatement nodeStateSelect;
-    protected PreparedStatement nodeStateSelectExist;
-    protected PreparedStatement nodeStateDelete;
+    // the map of prepared statements (key: sql stmt, value: prepared stmt)
+    private HashMap preparedStatements = new HashMap();
-    // shared prepared statements for PropertyState management
-    protected PreparedStatement propertyStateInsert;
-    protected PreparedStatement propertyStateUpdate;
-    protected PreparedStatement propertyStateSelect;
-    protected PreparedStatement propertyStateSelectExist;
-    protected PreparedStatement propertyStateDelete;
+    // SQL statements for NodeState management
+    protected String nodeStateInsertSQL;
+    protected String nodeStateUpdateSQL;
+    protected String nodeStateSelectSQL;
+    protected String nodeStateSelectExistSQL;
+    protected String nodeStateDeleteSQL;
-    // shared prepared statements for NodeReference management
-    protected PreparedStatement nodeReferenceInsert;
-    protected PreparedStatement nodeReferenceUpdate;
-    protected PreparedStatement nodeReferenceSelect;
-    protected PreparedStatement nodeReferenceSelectExist;
-    protected PreparedStatement nodeReferenceDelete;
+    // SQL statements for PropertyState management
+    protected String propertyStateInsertSQL;
+    protected String propertyStateUpdateSQL;
+    protected String propertyStateSelectSQL;
+    protected String propertyStateSelectExistSQL;
+    protected String propertyStateDeleteSQL;
-    // shared prepared statements for BLOB management
+    // SQL statements for NodeReference management
+    protected String nodeReferenceInsertSQL;
+    protected String nodeReferenceUpdateSQL;
+    protected String nodeReferenceSelectSQL;
+    protected String nodeReferenceSelectExistSQL;
+    protected String nodeReferenceDeleteSQL;
+
+    // SQL statements for BLOB management
-    protected PreparedStatement blobInsert;
-    protected PreparedStatement blobUpdate;
-    protected PreparedStatement blobSelect;
-    protected PreparedStatement blobSelectExist;
-    protected PreparedStatement blobDelete;
+    protected String blobInsertSQL;
+    protected String blobUpdateSQL;
+    protected String blobSelectSQL;
+    protected String blobSelectExistSQL;
+    protected String blobDeleteSQL;
+
+
+        // build sql statements
+        buildSQLStatements();
+
-        preparedStatements = initPreparedStatements();
+        initPreparedStatements();
-            if (preparedStatements != null) {
-                while (!preparedStatements.isEmpty()) {
-                    closeStatement((PreparedStatement) preparedStatements.remove(0));
-                }
+            for (Iterator it = preparedStatements.values().iterator(); it.hasNext(); ) {
+                closeStatement((PreparedStatement) it.next());
-            preparedStatements = null;
+            preparedStatements.clear();
-        ItemStateException ise = null;
+        // temporarily disable automatic reconnect feature
+        // since the changes need to be persisted atomically
+        autoReconnect = false;
-            super.store(changeLog);
-        } catch (ItemStateException e) {
-            ise = e;
-        } finally {
+            ItemStateException ise = null;
+            // number of attempts to store the changes
+            int trials = 2;
+            while (true) {
+                try {
+                    super.store(changeLog);
+                    break;
+                } catch (ItemStateException e) {
+                    // catch exception and fall through...
+                    ise = e;
+                }
+
+                if (ise != null && ise.getCause() instanceof SQLException
+                        && --trials > 0) {
+                    // a SQLException has been thrown, try to reconnect
+                    log.warn("storing changes failed, about to reconnect...", ise.getCause());
+
+                    // try to reconnect
+                    if (reestablishConnection()) {
+                        // now let's give it another try
+                        ise = null;
+                        continue;
+                    } else {
+                        // reconnect failed, proceed with error processing
+                        break;
+                    }
+                }
+            }
+
+        } finally {
+            // re-enable automatic reconnect feature
+            autoReconnect = true;
-        PreparedStatement stmt = nodeStateSelect;
-        synchronized (stmt) {
+        synchronized (nodeStateSelectSQL) {
-                stmt.setString(1, id.toString());
-                stmt.execute();
+                Statement stmt = executeStmt(nodeStateSelectSQL, new Object[]{id.toString()});
-                resetStatement(stmt);
-        PreparedStatement stmt = propertyStateSelect;
-        synchronized (stmt) {
+        synchronized (propertyStateSelectSQL) {
-                stmt.setString(1, id.toString());
-                stmt.execute();
+                Statement stmt = executeStmt(propertyStateSelectSQL, new Object[]{id.toString()});
-                resetStatement(stmt);
-        PreparedStatement stmt = (update) ? nodeStateUpdate : nodeStateInsert;
+        String sql = (update) ? nodeStateUpdateSQL : nodeStateInsertSQL;
-            // not have to additionally synchronize on the preparedStatement
-
-            stmt.setBytes(1, out.toByteArray());
-            stmt.setString(2, state.getNodeId().toString());
-            stmt.executeUpdate();
+            // not have to additionally synchronize on the sql statement
+            executeStmt(sql, new Object[]{out.toByteArray(), state.getNodeId().toString()});
-        } finally {
-            resetStatement(stmt);
-        PreparedStatement stmt = (update) ? propertyStateUpdate : propertyStateInsert;
+        String sql = (update) ? propertyStateUpdateSQL : propertyStateInsertSQL;
-            // not have to additionally synchronize on the preparedStatement
-
-            stmt.setBytes(1, out.toByteArray());
-            stmt.setString(2, state.getPropertyId().toString());
-            stmt.executeUpdate();
+            // not have to additionally synchronize on the sql statement
+            executeStmt(sql, new Object[]{out.toByteArray(), state.getPropertyId().toString()});
-        } finally {
-            resetStatement(stmt);
-        PreparedStatement stmt = nodeStateDelete;
-            stmt.setString(1, state.getNodeId().toString());
-            stmt.executeUpdate();
+            // we are synchronized on this instance, therefore we do not
+            // not have to additionally synchronize on the sql statement
+            executeStmt(nodeStateDeleteSQL, new Object[]{state.getNodeId().toString()});
-        } finally {
-            resetStatement(stmt);
-        PreparedStatement stmt = propertyStateDelete;
-            stmt.setString(1, state.getPropertyId().toString());
-            stmt.executeUpdate();
+            // we are synchronized on this instance, therefore we do not
+            // not have to additionally synchronize on the sql statement
+            executeStmt(propertyStateDeleteSQL, new Object[]{state.getPropertyId().toString()});
-        } finally {
-            resetStatement(stmt);
-        PreparedStatement stmt = nodeReferenceSelect;
-        synchronized (stmt) {
+        synchronized (nodeReferenceSelectSQL) {
-                stmt.setString(1, targetId.toString());
-                stmt.execute();
+                Statement stmt = executeStmt(
+                        nodeReferenceSelectSQL, new Object[]{targetId.toString()});
-                resetStatement(stmt);
-        PreparedStatement stmt = (update) ? nodeReferenceUpdate : nodeReferenceInsert;
+        String sql = (update) ? nodeReferenceUpdateSQL : nodeReferenceInsertSQL;
-            // not have to additionally synchronize on the preparedStatement
-
-            stmt.setBytes(1, out.toByteArray());
-            stmt.setString(2, refs.getId().toString());
-            stmt.executeUpdate();
+            // not have to additionally synchronize on the sql statement
+            executeStmt(sql, new Object[]{out.toByteArray(), refs.getId().toString()});
-        } finally {
-            resetStatement(stmt);
-        PreparedStatement stmt = nodeReferenceDelete;
-            stmt.setString(1, refs.getId().toString());
-            stmt.executeUpdate();
+            // we are synchronized on this instance, therefore we do not
+            // not have to additionally synchronize on the sql statement
+            executeStmt(nodeReferenceDeleteSQL, new Object[]{refs.getId().toString()});
-        } finally {
-            resetStatement(stmt);
-        PreparedStatement stmt = nodeStateSelectExist;
-        synchronized (stmt) {
+        synchronized (nodeStateSelectExistSQL) {
-                stmt.setString(1, id.toString());
-                stmt.execute();
+                Statement stmt = executeStmt(nodeStateSelectExistSQL, new Object[]{id.toString()});
-                resetStatement(stmt);
-        PreparedStatement stmt = propertyStateSelectExist;
-        synchronized (stmt) {
+        synchronized (propertyStateSelectExistSQL) {
-                stmt.setString(1, id.toString());
-                stmt.execute();
+                Statement stmt = executeStmt(
+                        propertyStateSelectExistSQL, new Object[]{id.toString()});
-                resetStatement(stmt);
-        PreparedStatement stmt = nodeReferenceSelectExist;
-        synchronized (stmt) {
+        synchronized (nodeReferenceSelectExistSQL) {
-                stmt.setString(1, targetId.toString());
-                stmt.execute();
+                Statement stmt = executeStmt(
+                        nodeReferenceSelectExistSQL, new Object[]{targetId.toString()});
-                resetStatement(stmt);
+     * Re-establishes the database connection. This method is called by
+     * {@link #store(ChangeLog)} and {@link #executeStmt(String, Object[])}
+     * after a <code>SQLException</code> had been encountered.
+     * @return true if the connection could be successfully re-established,
+     *         false otherwise.
+     */
+    protected synchronized boolean reestablishConnection() {
+        // in any case try to shut down current connection
+        // gracefully in order to avoid potential memory leaks
+
+        // close shared prepared statements
+        for (Iterator it = preparedStatements.values().iterator(); it.hasNext(); ) {
+            closeStatement((PreparedStatement) it.next());
+        }
+        preparedStatements.clear();
+        try {
+            closeConnection(con);
+        } catch (Exception ignore) {
+        }
+
+        // sleep for a while to give database a chance
+        // to restart before a reconnect is attempted
+
+        try {
+            Thread.sleep(SLEEP_BEFORE_RECONNECT);
+        } catch (InterruptedException ignore) {
+        }
+
+        // now try to re-establish connection
+
+        try {
+            initConnection();
+            initPreparedStatements();
+            return true;
+        } catch (Exception e) {
+            log.error("failed to re-establish connection", e);
+            // reconnect failed
+            return false;
+        }
+    }
+
+    /**
+     * Executes the given SQL statement with the specified parameters.
+     * If a <code>SQLException</code> is encountered and
+     * <code>autoReconnect==true</code> <i>one</i> attempt is made to re-establish
+     * the database connection and re-execute the statement.
+     *
+     * @param sql    statement to execute
+     * @param params parameters to set
+     * @return the <code>Statement</code> object that had been executed
+     * @throws SQLException if an error occurs
+     */
+    protected Statement executeStmt(String sql, Object[] params)
+            throws SQLException {
+        int trials = autoReconnect ? 2 : 1;
+        while (true) {
+            PreparedStatement stmt = (PreparedStatement) preparedStatements.get(sql);
+            try {
+                for (int i = 0; i < params.length; i++) {
+                    if (params[i] instanceof SizedInputStream) {
+                        SizedInputStream in = (SizedInputStream) params[i];
+                        stmt.setBinaryStream(i + 1, in, (int) in.getSize());
+                    } else {
+                        stmt.setObject(i + 1, params[i]);
+                    }
+                }
+                stmt.execute();
+                resetStatement(stmt);
+                return stmt;
+            } catch (SQLException se) {
+                if (--trials == 0) {
+                    // no more trials, re-throw
+                    throw se;
+                }
+                log.warn("execute failed, about to reconnect...", se.getMessage());
+
+                // try to reconnect
+                if (reestablishConnection()) {
+                    // reconnect succeeded; check whether it's possible to
+                    // re-execute the prepared stmt with the given parameters
+                    for (int i = 0; i < params.length; i++) {
+                        if (params[i] instanceof SizedInputStream) {
+                            SizedInputStream in = (SizedInputStream) params[i];
+                            if (in.isConsumed()) {
+                                // we're unable to re-execute the prepared stmt
+                                // since an InputStream paramater has already
+                                // been 'consumed';
+                                // re-throw previous SQLException
+                                throw se;
+                            }
+                        }
+                    }
+
+                    // try again to execute the statement
+                    continue;
+                } else {
+                    // reconnect failed, re-throw previous SQLException
+                    throw se;
+                }
+            }
+        }
+    }
+
+    /**
-     * Initializes the prepared statements and returns them in a list. please
-     * note that this list is used to close the statements in the {@link #close()}
-     * call.
-     *
-     * @return the list of prepared statements
-     * @throws SQLException
+     * Builds the SQL statements
-    protected List initPreparedStatements() throws SQLException {
-        List stmts = new LinkedList();
+    protected void buildSQLStatements() {
+        nodeStateInsertSQL = "insert into "
+                + schemaObjectPrefix + "NODE (NODE_DATA, NODE_ID) values (?, ?)";
-        stmts.add(nodeStateInsert =
-                con.prepareStatement("insert into "
-                + schemaObjectPrefix + "NODE (NODE_DATA, NODE_ID) values (?, ?)"));
-        stmts.add(nodeStateUpdate =
-                con.prepareStatement("update "
-                + schemaObjectPrefix + "NODE set NODE_DATA = ? where NODE_ID = ?"));
-        stmts.add(nodeStateSelect =
-                con.prepareStatement("select NODE_DATA from "
-                + schemaObjectPrefix + "NODE where NODE_ID = ?"));
-        stmts.add(nodeStateSelectExist =
-                con.prepareStatement("select 1 from "
-                + schemaObjectPrefix + "NODE where NODE_ID = ?"));
-        stmts.add(nodeStateDelete =
-                con.prepareStatement("delete from "
-                + schemaObjectPrefix + "NODE where NODE_ID = ?"));
+        nodeStateUpdateSQL = "update "
+                + schemaObjectPrefix + "NODE set NODE_DATA = ? where NODE_ID = ?";
+        nodeStateSelectSQL = "select NODE_DATA from "
+                + schemaObjectPrefix + "NODE where NODE_ID = ?";
+        nodeStateSelectExistSQL = "select 1 from "
+                + schemaObjectPrefix + "NODE where NODE_ID = ?";
+        nodeStateDeleteSQL = "delete from "
+                + schemaObjectPrefix + "NODE where NODE_ID = ?";
-        stmts.add(propertyStateInsert =
-                con.prepareStatement("insert into "
-                + schemaObjectPrefix + "PROP (PROP_DATA, PROP_ID) values (?, ?)"));
-        stmts.add(propertyStateUpdate =
-                con.prepareStatement("update "
-                + schemaObjectPrefix + "PROP set PROP_DATA = ? where PROP_ID = ?"));
-        stmts.add(propertyStateSelect =
-                con.prepareStatement("select PROP_DATA from "
-                + schemaObjectPrefix + "PROP where PROP_ID = ?"));
-        stmts.add(propertyStateSelectExist =
-                con.prepareStatement("select 1 from "
-                + schemaObjectPrefix + "PROP where PROP_ID = ?"));
-        stmts.add(propertyStateDelete =
-                con.prepareStatement("delete from "
-                + schemaObjectPrefix + "PROP where PROP_ID = ?"));
+        propertyStateInsertSQL = "insert into "
+                + schemaObjectPrefix + "PROP (PROP_DATA, PROP_ID) values (?, ?)";
+        propertyStateUpdateSQL = "update "
+                + schemaObjectPrefix + "PROP set PROP_DATA = ? where PROP_ID = ?";
+        propertyStateSelectSQL = "select PROP_DATA from "
+                + schemaObjectPrefix + "PROP where PROP_ID = ?";
+        propertyStateSelectExistSQL = "select 1 from "
+                + schemaObjectPrefix + "PROP where PROP_ID = ?";
+        propertyStateDeleteSQL = "delete from "
+                + schemaObjectPrefix + "PROP where PROP_ID = ?";
-        stmts.add(nodeReferenceInsert =
-                con.prepareStatement("insert into "
-                + schemaObjectPrefix + "REFS (REFS_DATA, NODE_ID) values (?, ?)"));
-        stmts.add(nodeReferenceUpdate =
-                con.prepareStatement("update "
-                + schemaObjectPrefix + "REFS set REFS_DATA = ? where NODE_ID = ?"));
-        stmts.add(nodeReferenceSelect =
-                con.prepareStatement("select REFS_DATA from "
-                + schemaObjectPrefix + "REFS where NODE_ID = ?"));
-        stmts.add(nodeReferenceSelectExist =
-                con.prepareStatement("select 1 from "
-                + schemaObjectPrefix + "REFS where NODE_ID = ?"));
-        stmts.add(nodeReferenceDelete =
-                con.prepareStatement("delete from "
-                + schemaObjectPrefix + "REFS where NODE_ID = ?"));
+        nodeReferenceInsertSQL = "insert into "
+                + schemaObjectPrefix + "REFS (REFS_DATA, NODE_ID) values (?, ?)";
+        nodeReferenceUpdateSQL = "update "
+                + schemaObjectPrefix + "REFS set REFS_DATA = ? where NODE_ID = ?";
+        nodeReferenceSelectSQL = "select REFS_DATA from "
+                + schemaObjectPrefix + "REFS where NODE_ID = ?";
+        nodeReferenceSelectExistSQL = "select 1 from "
+                + schemaObjectPrefix + "REFS where NODE_ID = ?";
+        nodeReferenceDeleteSQL = "delete from "
+                + schemaObjectPrefix + "REFS where NODE_ID = ?";
-            stmts.add(blobInsert =
-                    con.prepareStatement("insert into "
-                    + schemaObjectPrefix + "BINVAL (BINVAL_DATA, BINVAL_ID) values (?, ?)"));
-            stmts.add(blobUpdate =
-                    con.prepareStatement("update "
-                    + schemaObjectPrefix + "BINVAL set BINVAL_DATA = ? where BINVAL_ID = ?"));
-            stmts.add(blobSelect =
-                    con.prepareStatement("select BINVAL_DATA from "
-                    + schemaObjectPrefix + "BINVAL where BINVAL_ID = ?"));
-            stmts.add(blobSelectExist =
-                    con.prepareStatement("select 1 from "
-                    + schemaObjectPrefix + "BINVAL where BINVAL_ID = ?"));
-            stmts.add(blobDelete =
-                    con.prepareStatement("delete from "
-                    + schemaObjectPrefix + "BINVAL where BINVAL_ID = ?"));
+            blobInsertSQL = "insert into "
+                    + schemaObjectPrefix + "BINVAL (BINVAL_DATA, BINVAL_ID) values (?, ?)";
+            blobUpdateSQL = "update "
+                    + schemaObjectPrefix + "BINVAL set BINVAL_DATA = ? where BINVAL_ID = ?";
+            blobSelectSQL =
+                    "select BINVAL_DATA from "
+                    + schemaObjectPrefix + "BINVAL where BINVAL_ID = ?";
+            blobSelectExistSQL =
+                    "select 1 from "
+                    + schemaObjectPrefix + "BINVAL where BINVAL_ID = ?";
+            blobDeleteSQL = "delete from "
+                    + schemaObjectPrefix + "BINVAL where BINVAL_ID = ?";
-        return stmts;
+    }
+
+    /**
+     * Initializes the map of prepared statements.
+     *
+     * @throws SQLException if an error occurs
+     */
+    protected void initPreparedStatements() throws SQLException {
+        preparedStatements.put(
+                nodeStateInsertSQL, con.prepareStatement(nodeStateInsertSQL));
+        preparedStatements.put(
+                nodeStateUpdateSQL, con.prepareStatement(nodeStateUpdateSQL));
+        preparedStatements.put(
+                nodeStateSelectSQL, con.prepareStatement(nodeStateSelectSQL));
+        preparedStatements.put(
+                nodeStateSelectExistSQL, con.prepareStatement(nodeStateSelectExistSQL));
+        preparedStatements.put(
+                nodeStateDeleteSQL, con.prepareStatement(nodeStateDeleteSQL));
+
+        preparedStatements.put(
+                propertyStateInsertSQL, con.prepareStatement(propertyStateInsertSQL));
+        preparedStatements.put(
+                propertyStateUpdateSQL, con.prepareStatement(propertyStateUpdateSQL));
+        preparedStatements.put(
+                propertyStateSelectSQL, con.prepareStatement(propertyStateSelectSQL));
+        preparedStatements.put(
+                propertyStateSelectExistSQL, con.prepareStatement(propertyStateSelectExistSQL));
+        preparedStatements.put(
+                propertyStateDeleteSQL, con.prepareStatement(propertyStateDeleteSQL));
+
+        preparedStatements.put(
+                nodeReferenceInsertSQL, con.prepareStatement(nodeReferenceInsertSQL));
+        preparedStatements.put(
+                nodeReferenceUpdateSQL, con.prepareStatement(nodeReferenceUpdateSQL));
+        preparedStatements.put(
+                nodeReferenceSelectSQL, con.prepareStatement(nodeReferenceSelectSQL));
+        preparedStatements.put(
+                nodeReferenceSelectExistSQL, con.prepareStatement(nodeReferenceSelectExistSQL));
+        preparedStatements.put(
+                nodeReferenceDeleteSQL, con.prepareStatement(nodeReferenceDeleteSQL));
+
+        if (!externalBLOBs) {
+            preparedStatements.put(blobInsertSQL, con.prepareStatement(blobInsertSQL));
+            preparedStatements.put(blobUpdateSQL, con.prepareStatement(blobUpdateSQL));
+            preparedStatements.put(blobSelectSQL, con.prepareStatement(blobSelectSQL));
+            preparedStatements.put(blobSelectExistSQL, con.prepareStatement(blobSelectExistSQL));
+            preparedStatements.put(blobDeleteSQL, con.prepareStatement(blobDeleteSQL));
+        }
+
+    class SizedInputStream extends FilterInputStream {
+        private final long size;
+        private boolean consumed = false;
+
+        SizedInputStream(InputStream in, long size) {
+            super(in);
+            this.size = size;
+        }
+
+        long getSize() {
+            return size;
+        }
+
+        boolean isConsumed() {
+            return consumed;
+        }
+
+        public int read() throws IOException {
+            consumed = true;
+            return super.read();
+        }
+
+        public long skip(long n) throws IOException {
+            consumed = true;
+            return super.skip(n);
+        }
+
+        public int read(byte b[]) throws IOException {
+            consumed = true;
+            return super.read(b);
+        }
+
+        public int read(byte b[], int off, int len) throws IOException {
+            consumed = true;
+            return super.read(b, off, len);
+        }
+    }
+
-            PreparedStatement stmt = blobSelect;
-            synchronized (stmt) {
-                try {
-                    stmt.setString(1, blobId);
-                    stmt.execute();
-                    final ResultSet rs = stmt.getResultSet();
-                    if (!rs.next()) {
-                        closeResultSet(rs);
-                        throw new Exception("no such BLOB: " + blobId);
-                    }
-                    InputStream in = rs.getBinaryStream(1);
-                    if (in == null) {
-                        // some databases treat zero-length values as NULL;
-                        // return empty InputStream in such a case
-                        closeResultSet(rs);
-                        return new ByteArrayInputStream(new byte[0]);
-                    }
-
-                    /**
-                     * return an InputStream wrapper in order to
-                     * close the ResultSet when the stream is closed
-                     */
-                    return new FilterInputStream(in) {
-                        public void close() throws IOException {
-                            in.close();
-                            // now it's safe to close ResultSet
-                            closeResultSet(rs);
-                        }
-                    };
-                } finally {
-                    resetStatement(stmt);
+            synchronized (blobSelectSQL) {
+                Statement stmt = executeStmt(blobSelectSQL, new Object[]{blobId});
+                final ResultSet rs = stmt.getResultSet();
+                if (!rs.next()) {
+                    closeResultSet(rs);
+                    throw new Exception("no such BLOB: " + blobId);
+                InputStream in = rs.getBinaryStream(1);
+                if (in == null) {
+                    // some databases treat zero-length values as NULL;
+                    // return empty InputStream in such a case
+                    closeResultSet(rs);
+                    return new ByteArrayInputStream(new byte[0]);
+                }
+
+                /**
+                 * return an InputStream wrapper in order to
+                 * close the ResultSet when the stream is closed
+                 */
+                return new FilterInputStream(in) {
+                    public void close() throws IOException {
+                        in.close();
+                        // now it's safe to close ResultSet
+                        closeResultSet(rs);
+                    }
+                };
-            PreparedStatement stmt = blobSelectExist;
-            try {
-                stmt.setString(1, blobId);
-                stmt.execute();
-                ResultSet rs = stmt.getResultSet();
-                // a BLOB exists if the result has at least one entry
-                boolean exists = rs.next();
-                resetStatement(stmt);
-                closeResultSet(rs);
+            Statement stmt = executeStmt(blobSelectExistSQL, new Object[]{blobId});
+            ResultSet rs = stmt.getResultSet();
+            // a BLOB exists if the result has at least one entry
+            boolean exists = rs.next();
+            closeResultSet(rs);
-                stmt = (exists) ? blobUpdate : blobInsert;
-                stmt.setBinaryStream(1, in, (int) size);
-                stmt.setString(2, blobId);
-                stmt.executeUpdate();
-            } finally {
-                resetStatement(stmt);
-            }
+            String sql = (exists) ? blobUpdateSQL : blobInsertSQL;
+            executeStmt(sql, new Object[]{new SizedInputStream(in, size), blobId});
-            PreparedStatement stmt = blobDelete;
-            try {
-                stmt.setString(1, blobId);
-                return stmt.executeUpdate() == 1;
-            } finally {
-                resetStatement(stmt);
-            }
+            Statement stmt = executeStmt(blobDeleteSQL, new Object[]{blobId});
+            return stmt.getUpdateCount() == 1;

UPD40 UPD40 INS23 INS23 INS31 INS31 INS31 INS55 INS83 INS39 INS59 INS83 INS83 INS83 INS39 INS59 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 INS29 INS83 INS83 INS39 INS42 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS43 INS8 INS39 UPD42 INS29 INS83 INS39 INS42 MOV43 INS8 INS42 INS43 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS42 INS9 INS42 INS34 UPD42 INS14 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS21 INS21 INS60 MOV60 INS65 INS65 INS24 INS21 INS54 INS54 INS54 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS5 INS42 INS42 INS60 INS61 UPD65 INS65 INS65 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS25 INS42 INS83 INS83 INS39 INS59 INS83 INS39 INS59 INS42 INS44 INS44 INS8 INS39 INS42 INS8 INS39 INS42 INS8 INS83 INS39 INS42 INS43 INS8 INS83 INS39 INS42 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS8 MOV8 INS43 INS32 MOV32 INS7 INS8 UPD42 UPD42 INS43 INS59 UPD43 UPD42 UPD43 UPD42 UPD42 UPD42 INS66 INS65 INS66 INS65 INS66 INS66 INS66 INS58 INS32 INS8 INS32 INS8 INS12 INS8 INS12 INS8 INS12 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS43 INS85 INS39 INS59 INS9 INS8 UPD66 MOV7 MOV7 MOV7 MOV7 MOV7 MOV7 MOV7 MOV7 MOV7 MOV7 MOV7 MOV7 MOV7 MOV7 MOV7 INS66 INS42 INS66 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS38 INS8 INS42 INS42 INS9 INS43 INS42 INS39 INS42 INS46 INS21 INS41 INS41 INS42 INS21 INS41 INS39 INS42 INS42 INS21 INS41 INS39 INS42 INS85 INS42 INS21 INS41 INS39 INS42 INS85 INS39 INS42 INS39 INS42 INS42 INS21 INS41 INS51 INS60 MOV60 MOV60 MOV21 INS60 INS21 INS60 MOV41 INS42 INS42 INS24 INS42 INS9 MOV60 INS60 INS61 INS21 INS42 INS42 INS16 INS21 UPD42 UPD42 UPD42 UPD42 INS68 INS68 INS43 INS59 INS42 INS42 INS21 INS42 INS42 INS21 INS44 INS8 INS21 INS44 INS8 INS21 INS21 INS41 INS44 INS8 INS42 INS42 INS16 INS60 INS54 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS21 INS21 INS21 INS21 INS21 INS42 INS42 INS7 INS42 INS42 INS7 INS48 INS7 INS48 INS7 INS48 INS7 INS48 INS42 MOV8 UPD43 MOV43 INS59 INS43 INS59 INS32 UPD43 MOV43 INS59 INS58 INS32 INS8 INS32 INS39 INS59 INS9 INS8 INS7 MOV36 INS42 INS42 INS32 UPD42 UPD42 UPD42 UPD42 INS42 INS69 INS42 INS69 INS69 INS42 INS42 INS32 INS32 INS32 INS43 INS42 INS32 INS43 INS42 INS32 INS32 INS9 INS43 INS42 INS21 INS41 INS42 INS34 INS34 MOV43 INS59 INS8 INS12 MOV7 MOV7 MOV7 MOV7 MOV7 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS32 INS32 INS22 INS42 INS42 INS9 INS42 INS42 INS9 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS60 UPD42 MOV42 INS32 INS42 INS42 MOV16 UPD42 MOV42 INS42 INS3 UPD42 MOV42 INS32 INS43 INS59 INS42 INS42 MOV21 INS42 INS42 INS42 INS34 INS54 INS25 INS42 INS9 INS60 INS60 UPD42 MOV42 UPD42 MOV42 INS3 UPD42 UPD42 INS3 UPD42 UPD42 INS3 UPD42 UPD42 INS3 INS60 UPD42 UPD42 INS3 UPD42 UPD42 INS3 INS60 INS60 INS60 INS43 INS43 INS5 INS32 INS42 INS42 INS11 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS9 INS42 INS11 INS24 MOV21 MOV21 INS41 INS44 INS8 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 UPD42 MOV27 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS52 INS42 INS43 INS59 UPD42 MOV42 UPD42 MOV42 INS3 UPD42 UPD42 INS5 INS4 UPD42 MOV42 UPD42 MOV42 INS3 UPD42 INS42 INS42 INS32 MOV8 MOV12 INS27 INS8 INS43 INS59 INS43 INS59 INS5 INS4 INS5 INS4 INS5 INS4 INS5 INS4 INS43 INS59 INS5 INS4 INS5 INS4 INS43 INS59 INS43 INS59 INS43 INS59 INS42 INS42 INS43 INS85 INS42 INS42 MOV43 INS32 INS42 INS42 INS45 INS42 MOV43 INS32 INS58 INS27 INS37 INS8 INS42 INS43 INS42 INS25 INS21 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS5 INS4 INS43 INS85 INS14 INS42 INS5 INS4 INS32 UPD42 MOV42 INS10 INS27 INS27 INS21 INS25 INS42 INS42 INS32 INS42 INS42 INS32 INS43 INS85 MOV32 MOV32 INS43 INS85 MOV32 MOV32 INS43 INS85 MOV32 INS43 INS85 MOV32 INS42 INS42 INS32 INS43 INS85 MOV32 MOV32 INS43 INS85 MOV32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS39 INS59 INS42 INS40 INS42 INS25 INS42 INS27 INS8 INS32 INS32 INS8 INS8 UPD42 MOV42 UPD42 MOV42 INS3 INS43 INS85 INS42 INS42 INS43 INS42 INS42 INS43 INS85 INS42 MOV42 INS42 INS27 INS62 INS38 INS34 INS32 INS32 INS8 INS8 UPD42 MOV42 UPD42 MOV42 INS3 UPD42 MOV42 UPD42 MOV42 INS3 INS42 UPD42 MOV42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS3 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS3 UPD42 MOV42 UPD42 MOV42 INS3 UPD42 MOV42 UPD42 MOV42 INS3 INS42 INS34 INS62 INS8 INS8 INS38 INS34 INS53 INS42 INS42 INS45 INS32 INS42 INS24 INS18 INS53 INS5 INS4 INS42 INS42 INS42 UPD42 UPD42 INS42 INS33 INS32 INS43 INS42 INS42 INS42 INS45 INS32 INS42 INS21 INS18 INS10 INS5 INS4 INS5 INS4 INS5 INS4 INS5 INS4 INS5 INS4 INS5 INS4 INS2 INS43 INS60 INS21 INS21 INS42 INS42 INS42 INS42 INS58 INS27 INS37 INS8 INS42 INS43 INS85 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS43 INS85 MOV32 INS43 INS85 MOV32 INS43 INS85 MOV32 INS43 INS85 MOV32 INS43 INS85 MOV32 INS43 INS85 MOV32 INS42 INS42 INS42 INS43 INS59 INS32 INS32 INS39 INS59 INS42 INS40 INS42 INS25 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS27 INS42 INS11 INS42 INS42 INS27 INS2 INS42 INS34 INS62 INS8 INS43 INS2 INS42 INS34 INS39 INS32 INS42 INS34 INS42 INS42 INS2 INS43 INS60 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS8 INS42 INS42 INS11 INS42 INS42 INS53 INS43 INS2 INS42 INS42 INS42 INS42 DEL42 DEL7 DEL34 DEL42 DEL33 DEL27 DEL32 DEL38 DEL8 DEL61 DEL8 DEL25 DEL42 DEL33 DEL7 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL34 DEL32 DEL21 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL34 DEL32 DEL21 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL34 DEL32 DEL21 DEL42 DEL42 DEL34 DEL32 DEL21 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL42 DEL42 DEL16 DEL59 DEL60 DEL34 DEL42 DEL42 DEL34 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL34 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL34 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL34 DEL32 DEL21 DEL32 DEL21 DEL34 DEL42 DEL42 DEL34 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL34 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL34 DEL32 DEL21 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL34 DEL32 DEL21 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL59 DEL60 DEL34 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL66 DEL66 DEL42 DEL68 DEL65 DEL66 DEL65 DEL42 DEL65 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL41 DEL42 DEL34 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL51 DEL8 DEL42 DEL59 DEL60 DEL34 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL7 DEL21 DEL42 DEL42 DEL34 DEL42 DEL39 DEL42 DEL11 DEL32 DEL21 DEL42 DEL42 DEL34 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL42 DEL59 DEL60 DEL34 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54
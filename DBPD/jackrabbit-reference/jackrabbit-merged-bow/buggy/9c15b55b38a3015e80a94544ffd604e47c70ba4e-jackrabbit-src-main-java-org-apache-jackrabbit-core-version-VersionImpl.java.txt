Removing superfluous AbstractVersion and AbstractVersionHistory


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@424021 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.NodeImpl;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import javax.jcr.InvalidItemStateException;
+import javax.jcr.Item;
+import javax.jcr.NodeIterator;
+import javax.jcr.RepositoryException;
+import javax.jcr.nodetype.ConstraintViolationException;
+import javax.jcr.version.Version;
+import javax.jcr.version.VersionHistory;
+import java.util.Calendar;
- * This Class implements a Version that extends the node interface
+ * Base implementation of the {@link javax.jcr.version.Version} interface.
-public class VersionImpl extends AbstractVersion {
+public class VersionImpl extends NodeImpl implements Version {
-     * creates a new version node
-     *
-     * @param itemMgr
-     * @param session
-     * @param id
-     * @param state
-     * @param definition
-     * @param listeners
-     * @param version
+     * Logger instance.
+     */
+    private static Logger log = LoggerFactory.getLogger(VersionImpl.class);
+
+    /**
+     * Create a new instance of this class.
+     * @param itemMgr item manager
+     * @param session session
+     * @param id node id
+     * @param state node state
+     * @param definition node definition
+     * @param listeners life cycle listeners
-                       NodeState state, NodeDefinition definition,
-                       ItemLifeCycleListener[] listeners,
-                       InternalVersion version) {
+                          NodeState state, NodeDefinition definition,
+                          ItemLifeCycleListener[] listeners) {
+    /**
+     * Returns the internal version. Subclass responsibility.
+     * @return internal version
+     * @throws RepositoryException if the internal version is not available
+     */
+    protected InternalVersion getInternalVersion() throws RepositoryException {
+        InternalVersion version =
+                session.getVersionManager().getVersion((NodeId) id);
+        if (version == null) {
+            throw new InvalidItemStateException(id + ": the item does not exist anymore");
+        }
+        return version;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public Calendar getCreated() throws RepositoryException {
+        return getInternalVersion().getCreated();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public Version[] getSuccessors() throws RepositoryException {
+        // need to wrap it around proper node
+        InternalVersion[] suc = getInternalVersion().getSuccessors();
+        Version[] ret = new Version[suc.length];
+        for (int i = 0; i < suc.length; i++) {
+            ret[i] = (Version) session.getNodeById(suc[i].getId());
+        }
+        return ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public Version[] getPredecessors() throws RepositoryException {
+        // need to wrap it around proper node
+        InternalVersion[] pred = getInternalVersion().getPredecessors();
+        Version[] ret = new Version[pred.length];
+        for (int i = 0; i < pred.length; i++) {
+            ret[i] = (Version) session.getNodeById(pred[i].getId());
+        }
+        return ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public VersionHistory getContainingHistory() throws RepositoryException {
+        return (VersionHistory) getParent();
+    }
+
+    /**
+     * Returns the frozen node of this version
+     *
+     * @return
+     * @throws javax.jcr.RepositoryException
+     */
+    public InternalFrozenNode getFrozenNode() throws RepositoryException {
+        return getInternalVersion().getFrozenNode();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean isSame(Item otherItem) {
+        if (otherItem instanceof VersionImpl) {
+            // since all versions live in the same workspace, we can compare the uuids
+            try {
+                InternalVersion other = ((VersionImpl) otherItem).getInternalVersion();
+                return other.getId().equals(getInternalVersion().getId());
+            } catch (RepositoryException e) {
+                log.warn("Unable to retrieve internal version objects: " + e.getMessage());
+                log.debug("Stack dump:", e);
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Checks if this version is more recent than the given version <code>v</code>.
+     * A version is more recent if and only if it is a successor (or a successor
+     * of a successor, etc., to any degree of separation) of the compared one.
+     *
+     * @param v the version to check
+     * @return <code>true</code> if the version is more recent;
+     *         <code>false</code> otherwise.
+     */
+    public boolean isMoreRecent(VersionImpl v) throws RepositoryException {
+        return getInternalVersion().isMoreRecent(v.getInternalVersion());
+    }
+
+    /**
+     * Checks if this is the root version.
+     * @return <code>true</code> if this version is the root version;
+     *         <code>false</code> otherwise.
+     */
+    public boolean isRootVersion() throws RepositoryException {
+        return getInternalVersion().isRootVersion();
+    }
+
+    //--------------------------------------< Overwrite "protected" methods >---
+
+
+    /**
+     * Always throws a {@link javax.jcr.nodetype.ConstraintViolationException} since this node
+     * is protected.
+     *
+     * @throws javax.jcr.nodetype.ConstraintViolationException
+     */
+    public void update(String srcWorkspaceName) throws ConstraintViolationException {
+        String msg = "update operation not allowed on a version node: " + safeGetJCRPath();
+        log.debug(msg);
+        throw new ConstraintViolationException(msg);
+    }
+
+    /**
+     * Always throws a {@link javax.jcr.nodetype.ConstraintViolationException} since this node
+     * is protected.
+     *
+     * @throws javax.jcr.nodetype.ConstraintViolationException
+     */
+    public NodeIterator merge(String srcWorkspace, boolean bestEffort)
+            throws ConstraintViolationException {
+        String msg = "merge operation not allowed on a version node: " + safeGetJCRPath();
+        log.debug(msg);
+        throw new ConstraintViolationException(msg);
+    }
+

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS43 UPD43 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS42 UPD42 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS43 INS42 INS43 INS8 INS29 INS83 INS43 INS42 INS43 INS8 INS29 INS83 INS5 INS42 INS43 INS8 INS29 INS83 INS5 INS42 INS43 INS8 INS29 INS83 INS43 INS42 INS43 INS8 INS29 INS83 INS43 INS42 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS43 INS8 UPD66 INS65 INS66 INS65 INS42 INS42 INS32 INS65 INS65 INS65 INS42 INS42 INS60 INS25 INS41 INS65 INS42 INS42 INS41 INS65 INS43 INS85 INS42 INS60 INS60 INS24 INS41 INS65 INS43 INS85 INS42 INS60 INS60 INS24 INS41 INS65 INS42 INS42 INS41 INS65 INS65 INS65 INS42 INS42 INS41 INS65 INS43 INS42 INS25 INS41 INS65 INS65 INS65 INS43 INS42 INS42 INS41 INS65 INS65 INS42 INS41 INS65 INS65 INS43 INS42 INS42 INS60 INS21 INS53 INS65 INS65 INS42 INS43 INS42 INS39 INS42 INS42 INS60 INS21 INS53 INS40 INS66 INS42 INS42 INS57 UPD66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 MOV43 INS59 INS27 INS8 INS42 INS65 INS32 INS65 INS42 INS5 INS59 INS5 INS59 INS58 INS27 INS37 INS8 INS42 INS65 INS42 INS5 INS59 INS5 INS59 INS58 INS27 INS37 INS8 INS42 INS65 INS11 INS66 INS40 INS32 INS65 INS42 INS62 INS8 INS9 INS66 INS66 INS66 INS42 INS66 INS66 INS66 INS42 INS32 INS66 INS66 INS66 INS32 INS66 INS65 INS66 INS66 INS40 INS42 INS43 INS59 INS32 INS14 INS66 INS65 INS66 INS66 INS40 INS42 INS43 INS59 INS32 INS14 INS43 INS42 INS32 INS42 INS33 INS53 INS32 INS42 INS43 INS85 INS42 INS32 INS43 INS85 INS42 INS3 INS39 INS59 INS42 INS40 INS42 INS21 INS43 INS85 INS42 INS32 INS43 INS85 INS42 INS3 INS39 INS59 INS42 INS40 INS42 INS21 INS43 INS32 INS32 INS42 INS42 INS43 INS54 INS32 INS42 INS32 INS32 INS42 INS40 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS40 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS32 INS42 INS11 INS14 INS42 INS42 INS32 INS42 INS42 INS5 INS40 INS42 INS34 INS7 INS42 INS32 INS42 INS42 INS5 INS40 INS42 INS34 INS7 INS42 INS42 INS42 INS42 INS8 INS12 INS42 INS42 INS42 INS42 INS45 INS32 INS42 INS45 INS32 INS42 INS42 INS42 INS43 INS42 INS43 INS27 INS42 INS43 INS85 INS2 INS11 INS42 INS43 INS85 INS2 INS11 INS60 INS41 INS44 INS8 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS43 INS32 INS43 INS59 INS32 INS43 INS42 INS21 INS21 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS32 INS42 INS32 INS32 INS2 INS42 INS2 INS42 INS36 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS45 INS32 INS43 INS42 INS42 INS42 INS42 DEL42 DEL65 DEL42 DEL44
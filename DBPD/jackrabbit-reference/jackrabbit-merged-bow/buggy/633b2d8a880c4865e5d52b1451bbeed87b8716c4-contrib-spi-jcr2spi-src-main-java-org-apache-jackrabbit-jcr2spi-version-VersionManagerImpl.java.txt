fixed: move, reorder (work in progress)
fixed: locktoken transfer
fixed: recursive transient removal of invalidated tree fails (restoreTests)
improve: simplify usage of workspace operations
fixed: store original itemId with transient operations in order to properly reflect the changelog upon batch creation
fixed: workspace import doesn't invalidate
fixed: session import uuid handling




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@513279 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.QValue;
-    public void resolveMergeConflict(NodeState nodeState, NodeState versionState, boolean done) throws RepositoryException {
+    public void resolveMergeConflict(NodeState nodeState, NodeState versionState,
+                                     boolean done) throws RepositoryException {
-        NodeState wspVState = getWorkspaceState(versionState);
-        Operation op = ResolveMergeConflict.create(wspState, wspVState, done);
-        workspaceManager.execute(op);
+        NodeId vId = getWorkspaceState(versionState).getNodeId();
+        try {
+            PropertyState mergeFailedState = wspState.getPropertyState(QName.JCR_MERGEFAILED);
+            QValue[] vs = mergeFailedState.getValues();
+
+            NodeId[] mergeFailedIds = new NodeId[vs.length - 1];
+            for (int i = 0, j = 0; i < vs.length; i++) {
+                NodeId id = workspaceManager.getIdFactory().createNodeId(vs[i].getString());
+                if (!id.equals(vId)) {
+                    mergeFailedIds[j] = id;
+                    j++;
+                }
+                // else: the version id is being solved by this call and not
+                // part of 'jcr:mergefailed' any more
+            }
+
+            PropertyState predecessorState = wspState.getPropertyState(QName.JCR_PREDECESSORS);
+            vs = predecessorState.getValues();
+
+            int noOfPredecessors = (done) ? vs.length + 1 : vs.length;
+            NodeId[] predecessorIds = new NodeId[noOfPredecessors];
+
+            int i = 0;
+            while (i < vs.length) {
+                predecessorIds[i] = workspaceManager.getIdFactory().createNodeId(vs[i].getString());
+                i++;
+            }
+            if (done) {
+                predecessorIds[i] = vId;
+            }
+            Operation op = ResolveMergeConflict.create(wspState, mergeFailedIds, predecessorIds, done);
+            workspaceManager.execute(op);
+
+        } catch (ItemStateException e) {
+            throw new RepositoryException(e);
+        }

INS26 INS40 INS8 MOV60 MOV60 INS54 UPD43 INS8 INS12 UPD42 UPD42 INS32 INS60 INS60 INS60 INS24 INS60 INS21 INS60 INS60 INS60 INS61 INS25 MOV60 MOV21 INS44 INS8 MOV32 INS42 INS43 INS59 INS5 INS59 INS5 INS59 INS58 INS27 INS37 INS8 INS43 INS59 INS7 INS39 INS59 INS5 INS59 INS39 INS59 INS27 INS8 INS42 INS8 INS43 INS42 INS53 INS42 INS42 INS32 INS43 INS85 INS42 INS32 INS43 INS85 INS42 INS3 INS39 INS59 INS59 INS42 INS40 INS42 INS60 INS25 INS42 INS42 INS32 INS42 INS32 INS42 INS16 INS43 INS85 INS42 INS3 INS42 INS34 INS42 INS40 INS21 INS21 INS21 INS42 INS14 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS5 INS27 INS42 INS34 INS42 INS34 INS43 INS59 INS38 INS8 INS42 INS42 INS40 INS42 INS42 INS36 INS27 INS40 INS42 INS5 INS42 INS7 INS37 INS7 UPD42 INS42 INS43 INS42 INS43 INS85 INS40 INS34 INS42 INS42 INS32 INS32 INS21 INS21 INS42 INS40 INS34 INS43 INS85 INS2 INS32 INS42 INS2 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS7 INS37 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS2 INS42 INS2 INS42 INS42 INS42 INS42 INS2 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL8
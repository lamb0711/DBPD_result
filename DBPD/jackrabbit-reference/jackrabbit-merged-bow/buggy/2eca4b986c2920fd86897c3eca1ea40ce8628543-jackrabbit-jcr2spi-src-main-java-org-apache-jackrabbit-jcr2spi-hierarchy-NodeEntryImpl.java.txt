JCR-1799 updating events swallowed (CacheBehavior.OBSERVATION)   	
JCR-1783 incomplete changelog when combining move with removal of new destination parent

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@704361 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.spi.Name;
-import org.apache.jackrabbit.spi.Path;
-import org.apache.jackrabbit.spi.NodeId;
+import org.apache.commons.collections.iterators.IteratorChain;
+import org.apache.jackrabbit.commons.iterator.RangeIteratorAdapter;
+import org.apache.jackrabbit.jcr2spi.operation.AddNode;
+import org.apache.jackrabbit.jcr2spi.operation.AddProperty;
+import org.apache.jackrabbit.jcr2spi.operation.Move;
+import org.apache.jackrabbit.jcr2spi.operation.Operation;
+import org.apache.jackrabbit.jcr2spi.operation.Remove;
+import org.apache.jackrabbit.jcr2spi.operation.ReorderNodes;
+import org.apache.jackrabbit.jcr2spi.operation.SetMixin;
+import org.apache.jackrabbit.jcr2spi.state.ItemState;
+import org.apache.jackrabbit.jcr2spi.state.NodeState;
+import org.apache.jackrabbit.jcr2spi.state.PropertyState;
+import org.apache.jackrabbit.jcr2spi.state.Status;
+import org.apache.jackrabbit.jcr2spi.util.StateUtility;
+import org.apache.jackrabbit.spi.ChildInfo;
+import org.apache.jackrabbit.spi.IdFactory;
+import org.apache.jackrabbit.spi.Name;
+import org.apache.jackrabbit.spi.NodeId;
+import org.apache.jackrabbit.spi.Path;
+import org.apache.jackrabbit.spi.PathFactory;
+import org.apache.jackrabbit.spi.PropertyId;
-import org.apache.jackrabbit.spi.IdFactory;
-import org.apache.jackrabbit.spi.PropertyId;
-import org.apache.jackrabbit.spi.PathFactory;
-import org.apache.jackrabbit.spi.ChildInfo;
-import org.apache.jackrabbit.jcr2spi.state.NodeState;
-import org.apache.jackrabbit.jcr2spi.state.ItemState;
-import org.apache.jackrabbit.jcr2spi.state.ChangeLog;
-import org.apache.jackrabbit.jcr2spi.state.Status;
-import org.apache.jackrabbit.jcr2spi.state.PropertyState;
-import org.apache.jackrabbit.jcr2spi.state.ItemStateLifeCycleListener;
-import org.apache.jackrabbit.jcr2spi.util.StateUtility;
+import org.apache.jackrabbit.spi.QValue;
-import org.apache.jackrabbit.commons.iterator.RangeIteratorAdapter;
-import org.apache.commons.collections.iterators.IteratorChain;
-import javax.jcr.ItemExistsException;
-import javax.jcr.RepositoryException;
-import javax.jcr.PathNotFoundException;
-import javax.jcr.ItemNotFoundException;
-import java.util.Iterator;
-import java.util.List;
+import javax.jcr.ItemExistsException;
+import javax.jcr.ItemNotFoundException;
+import javax.jcr.PathNotFoundException;
+import javax.jcr.RepositoryException;
-import java.util.Set;
+import java.util.Iterator;
+import java.util.List;
-import java.util.LinkedHashMap;
+import java.util.Set;
-        if (getStatus() != Status.NEW && childNodeEntries != null) {
+        if (getStatus() != Status.NEW) {
+        // NOTE: childNodeAttic must not be cleared for the move of child entries
+        // will be separately reverted.
-        revertTransientChanges();
-        removeEntry(this);
-        if (getStatus() != Status.STALE_DESTROYED) {
-            NodeEntry removed = parent.childNodeEntries.remove(this);
-            if (removed == null) {
-                // try attic
-                parent.childNodeAttic.remove(this);
+        ItemState state = internalGetItemState();
+        if (state != null) {
+            if (getStatus() == Status.EXISTING_MODIFIED) {
+                state.setStatus(Status.STALE_DESTROYED);
+            } else {
+                state.setStatus(Status.REMOVED);
+                parent.internalRemoveChildEntry(this);
+        } else {
+            // unresolved: ignore.
+            parent.internalRemoveChildEntry(this);
-        // TODO: deal with childNodeAttic
-        // now traverse all child-entries and mark the attached states removed
-        // without removing the child-entries themselves. this is not required
-        // since this (i.e. the parent is removed as well).
+        // now remove all child-entries.
-            removeEntry(ce);
+            ce.remove();
-     * If the underlying state is available and transiently modified, new or
-     * stale, it gets added to the changeLog. Subsequently this call is repeated
-     * recursively to collect all child states that meet the condition,
-     * including those property states that have been moved to the attic.
-     *
-     * @inheritDoc
-     * @see HierarchyEntry#collectStates(ChangeLog, boolean)
+     * @see HierarchyEntry#complete(Operation)
-    public synchronized void collectStates(ChangeLog changeLog, boolean throwOnStale) throws InvalidItemStateException {
-        super.collectStates(changeLog, throwOnStale);
-
-        // collect transient child states including properties in attic.
-        for (Iterator it = getAllChildEntries(true); it.hasNext();) {
-            HierarchyEntry ce = (HierarchyEntry) it.next();
-            ce.collectStates(changeLog, throwOnStale);
+    public void complete(Operation operation) throws RepositoryException {
+        if (operation instanceof AddNode) {
+            complete((AddNode) operation);
+        } else if (operation instanceof AddProperty) {
+            complete((AddProperty) operation);
+        } else if (operation instanceof SetMixin) {
+            complete((SetMixin) operation);
+        } else if (operation instanceof Remove) {
+            complete((Remove) operation);
+        } else if (operation instanceof ReorderNodes) {
+            complete((ReorderNodes) operation);
+        } else if (operation instanceof Move) {
+            complete((Move) operation);
+        } else {
+            throw new IllegalArgumentException();
-
-    public NodeId getId() {
+    public NodeId getId() throws InvalidItemStateException, RepositoryException {
-    public NodeId getWorkspaceId() {
+    public NodeId getWorkspaceId() throws InvalidItemStateException, RepositoryException {
-            return idFactory.createNodeId(parentId, pf.create(getWorkspaceName(), getWorkspaceIndex()));
+            return idFactory.createNodeId(parentId, pf.create(getName(true), getIndex(true)));
-    public int getIndex() {
-        if (parent == null) {
-            // the root state may never have siblings
-            return Path.INDEX_DEFAULT;
-        }
-
-        NodeState state = (NodeState) internalGetItemState();
-        try {
-            if (state == null || !state.hasDefinition() || state.getDefinition().allowsSameNameSiblings()) {
-                return parent.getChildIndex(this);
-            } else {
-                return Path.INDEX_DEFAULT;
-            }
-        } catch (RepositoryException e) {
-            log.error("Error while building Index. ", e.getMessage());
-            return Path.INDEX_UNDEFINED;
-        }
+    public int getIndex() throws InvalidItemStateException, RepositoryException {
+        return getIndex(false);
+                // shortcut: entry is NEW and still unresolved remaining path
+                // elements -> hierarchy doesn't exist anyway.
+                if (entry.getStatus() == Status.NEW) {
+                    throw new PathNotFoundException(path.toString());
+                }
+
-     * @inheritDoc
-     * @inheritDoc
-     * @inheritDoc
-     * @inheritDoc
-            NodeId cId = factory.getIdFactory().createNodeId(getId(), pf.create(nodeName, index));
+            NodeId cId = factory.getIdFactory().createNodeId(getWorkspaceId(), pf.create(nodeName, index));
-     * @inheritDoc
-     *
-     * @param childInfos
-     * @throws RepositoryException
+     * @see NodeEntry#setNodeEntries(Iterator)
-     * @inheritDoc
-     * @see NodeEntry#getOrAddNodeEntry(Name,int,String)
+     * @see NodeEntry#addNodeEntry(Name, String, int)
-     * @inheritDoc
-    public NodeState addNewNodeEntry(Name nodeName, String uniqueID,
+    public NodeEntry addNewNodeEntry(Name nodeName, String uniqueID,
-        if (!entry.isAvailable()) {
-            entry.setItemState(state);
-        }
-        return state;
-    }
-
-    /**
-     * @param nodeName
-     * @param uniqueID
-     * @param index
-     * @return the added entry.
-     */
-    private NodeEntry internalAddNodeEntry(Name nodeName, String uniqueID, int index) {
-        NodeEntry entry = factory.createNodeEntry(this, nodeName, uniqueID);
-        childNodeEntries.add(entry, index);
+        entry.setItemState(state);
-     * @inheritDoc
-     * @inheritDoc
-     * @inheritDoc
-     * @see NodeEntry#getOrAddPropertyEntry(Name)
+     * @see NodeEntry#addPropertyEntry(Name)
-     * Internal method that adds a PropertyEntry without checking of that entry
-     * exists.
-     *
-     * @param propName
-     * @param notifySpecial
-     * @return the added entry.
+     * @see NodeEntry#setPropertyEntries(Collection)
-    private PropertyEntry internalAddPropertyEntry(Name propName, boolean notifySpecial) {
-        PropertyEntry entry = factory.createPropertyEntry(this, propName);
-        properties.add(entry);
-
-        // if property-name is jcr:uuid or jcr:mixin this affects this entry
-        // and the attached nodeState.
-        if (notifySpecial && StateUtility.isUuidOrMixin(propName)) {
-            notifyUUIDorMIXINModified(entry);
-        }
-        return entry;
-    }
-
-    /**
-     * @inheritDoc
-     * @see NodeEntry#addPropertyEntries(Collection)
-     */
-    public void addPropertyEntries(Collection propNames) throws ItemExistsException, RepositoryException {
+    public void setPropertyEntries(Collection propNames) throws ItemExistsException, RepositoryException {
-                // addPropertyEntries is used by WorkspaceItemStateFactory upon
+                // setPropertyEntries is used by WorkspaceItemStateFactory upon
-     * @inheritDoc
-    public PropertyState addNewPropertyEntry(Name propName, QPropertyDefinition definition)
+    public PropertyEntry addNewPropertyEntry(Name propName, QPropertyDefinition definition, QValue[] values, int propertyType)
-
-                    properties.remove(propName);
+                    properties.remove(existing);
-                properties.remove(propName);
+                properties.remove(existing);
-                properties.remove(propName);
+                properties.remove(existing);
+        PropertyState state = factory.getItemStateFactory().createNewPropertyState(entry, definition, values, propertyType);
+        entry.setItemState(state);
+
+        // add the property entry if creating the new state was successful
-        PropertyState state = factory.getItemStateFactory().createNewPropertyState(entry, definition);
-        if (!entry.isAvailable()) {
-            entry.setItemState(state);
-        }
-
-        return state;
-    }
-
-    /**
-     * @param propName
-     */
-    void internalRemovePropertyEntry(Name propName) {
-        if (!properties.remove(propName)) {
-            propertiesInAttic.remove(propName);
-        }
-        // special properties
-        if (StateUtility.isUuidOrMixin(propName)) {
-            notifyUUIDorMIXINRemoved(propName);
-        }
+        return entry;
-            createSiblingRevertInfos();
-            parent.createRevertInfo();
+            createRevertInfo();
-            NodeEntry previousBefore = parent.childNodeEntries.reorder(this, beforeEntry);
-            parent.revertInfo.reordered(this, previousBefore);
+            parent.childNodeEntries.reorder(this, beforeEntry);
-       if (transientMove && !isTransientlyMoved() && Status.NEW != getStatus()) {
-           createSiblingRevertInfos();
+       if (transientMove) {
-           parent.childNodeAttic.add(this);
+           if (Status.NEW != getStatus()) {
+               if (newParent != revertInfo.oldParent) {
+                   revertInfo.oldParent.childNodeAttic.add(this);
+               } else {
+                   // entry is either rename OR moved back to it's original
+                   // parent. for the latter case make sure, there is no attic
+                   // entry remaing refering to the entry that is being added.
+                   revertInfo.oldParent.childNodeAttic.remove(this);
+               }
+           }
-     * @param childEvent
-        Name eventName = childEvent.getPath().getNameElement().getName();
+        ItemId eventId = childEvent.getItemId();
+        Path eventPath = childEvent.getPath();
+        Name eventName = eventPath.getNameElement().getName();
+        HierarchyEntry child = lookupEntry(eventId, eventPath);
+
-                int index = childEvent.getPath().getNameElement().getNormalizedIndex();
-                String uniqueChildID = null;
-                if (childEvent.getItemId().getPath() == null) {
-                    uniqueChildID = childEvent.getItemId().getUniqueID();
-                }
-
-                // TODO: TOBEFIXED for SNSs
-                // first check if no matching child entry exists.
-                NodeEntry cne;
-                if (uniqueChildID != null) {
-                    cne = childNodeEntries.get(eventName, uniqueChildID);
-                    if (cne == null) {
-                        // entry may exist but without having uniqueID resolved
-                        cne = childNodeEntries.get(eventName, index);
+            case Event.PROPERTY_ADDED:
+                if (child == null || child.getStatus() == Status.REMOVED) {
+                    // no such child or a colliding new child existed but got
+                    // removed already -> add the new entry.
+                    if (childEvent.getType() ==  Event.NODE_ADDED) {
+                        String uniqueChildID = (eventId.getPath() == null) ? eventId.getUniqueID() : null;
+                        int index = eventPath.getNameElement().getNormalizedIndex();
+                        internalAddNodeEntry(eventName, uniqueChildID, index);
+                    } else {
+                        internalAddPropertyEntry(eventName, true);
-                    cne = childNodeEntries.get(eventName, index);
-                }
-                if (cne == null) {
-                    internalAddNodeEntry(eventName, uniqueChildID, index);
-                } else {
-                    // child already exists -> deal with NEW entries, that were
-                    // added by some other session.
-                    // TODO: TOBEFIXED
-                }
-                break;
-
-            case Event.PROPERTY_ADDED:
-                // create a new property reference if it has not been
-                // added by some earlier 'add' event
-                HierarchyEntry child = lookupEntry(childEvent.getItemId(), childEvent.getPath());
-                if (child == null) {
-                    internalAddPropertyEntry(eventName, true);
-                } else {
-                    child.reload(false, true);
+                    // item already present
+                    int status = child.getStatus();
+                    if (Status.NEW == status) {
+                        // event conflicts with a transiently added item on this
+                        // node entry -> mark the parent node (this) stale.
+                        internalGetItemState().setStatus(Status.MODIFIED);
+                    } // else: child already added -> ignore
-                child = lookupEntry(childEvent.getItemId(), childEvent.getPath());
-                    child.remove();
+                    int status = child.getStatus();
+                    if (Status.isTransient(status) || Status.isStale(status)) {
+                        if (Status.EXISTING_REMOVED == status) {
+                            // colliding item removal -> mark parent stale
+                            internalGetItemState().setStatus(Status.MODIFIED);
+                        }
+                        // pending changes -> don't remove entry in the hierarchy
+                        // but rather change status to 'STALE_DESTROYED'
+                        ItemState childState = ((HierarchyEntryImpl) child).internalGetItemState();
+                        childState.setStatus(Status.STALE_DESTROYED);
+                    } else {
+                        // no pending changes -> save to remove the entry.
+                        child.remove();
+                    }
-                child = lookupEntry(childEvent.getItemId(), childEvent.getPath());
+                    int status = child.getStatus();
+                    // if the child has pending changes -> stale.
-                    child.reload(false, false);
-                    // special cases: jcr:uuid and jcr:mixinTypes affect the parent
-                    // (i.e. this NodeEntry) since both props are protected
-                    if (StateUtility.isUuidOrMixin(eventName)) {
-                        notifyUUIDorMIXINModified((PropertyEntry) child);
+                    if (Status.isStale(status))  {
+                        // ignore. nothing to do.
+                    } else if (Status.isTransient(child.getStatus())) {
+                        // pending changes -> don't reload entry but rather
+                        // mark it stale
+                        ((HierarchyEntryImpl) child).internalGetItemState().setStatus(Status.MODIFIED);
+                    } else {
+                        // no pending changes -> invalidate and force reload
+                        // upon next access.
+                        child.invalidate(false);
+                        // special cases: jcr:uuid and jcr:mixinTypes affect the
+                        // parent (i.e. this NodeEntry)
+                        if (StateUtility.isUuidOrMixin(eventName)) {
+                            notifyUUIDorMIXINModified((PropertyEntry) child);
+                        }
-     * @inheritDoc
-        int index = (wspPath) ? nEntry.getWorkspaceIndex() : nEntry.getIndex();
-        Name name = (wspPath) ? nEntry.getWorkspaceName() : nEntry.getName();
-        // add to path
-        if (index == Path.INDEX_UNDEFINED) {
-            throw new RepositoryException("Invalid index " + index + " with nodeEntry " + nEntry);
-        }
-
-        // TODO: check again. special treatment for default index for consistency with PathFormat.parse
+        int index = nEntry.getIndex(wspPath);
+        Name name = nEntry.getName(wspPath);
-     * @throws IllegalArgumentException if <code>this</code> is not the parent
-     * of the given <code>ItemState</code>.
+     * @param nodeName
+     * @param uniqueID
+     * @param index
+     * @return the added entry.
-    synchronized void revertPropertyRemoval(PropertyEntry propertyEntry) {
-        if (propertyEntry.getParent() != this) {
-            throw new IllegalArgumentException("Internal error: Parent mismatch.");
+    private NodeEntry internalAddNodeEntry(Name nodeName, String uniqueID, int index) {
+        NodeEntry entry = factory.createNodeEntry(this, nodeName, uniqueID);
+        childNodeEntries.add(entry, index);
+        return entry;
+    }
+
+    /**
+     * Internal method that adds a PropertyEntry without checking of that entry
+     * exists.
+     *
+     * @param propName
+     * @param notifySpecial
+     * @return the added entry.
+     */
+    private PropertyEntry internalAddPropertyEntry(Name propName, boolean notifySpecial) {
+        PropertyEntry entry = factory.createPropertyEntry(this, propName);
+        properties.add(entry);
+
+        // if property-name is jcr:uuid or jcr:mixin this affects this entry
+        // and the attached nodeState.
+        if (notifySpecial && StateUtility.isUuidOrMixin(propName)) {
+            notifyUUIDorMIXINModified(entry);
-        Name propName = propertyEntry.getName();
-        if (propertiesInAttic.containsKey(propName)) {
-            properties.add((PropertyEntry) propertiesInAttic.remove(propName));
-        } // else: propEntry has never been moved to the attic (see 'getOrAddPropertyEntry')
+        return entry;
+    }
+
+    /**
+     *
+     * @param childEntry
+     */
+    void internalRemoveChildEntry(HierarchyEntry childEntry) {
+        if (childEntry.denotesNode()) {
+            if (childNodeEntries.remove((NodeEntry) childEntry) == null) {
+                childNodeAttic.remove((NodeEntryImpl) childEntry);
+            }
+        } else {
+            Name propName = childEntry.getName();
+            PropertyEntry atticEntry = (PropertyEntry) propertiesInAttic.get(propName);
+            if (atticEntry == null) {
+                properties.remove((PropertyEntry) childEntry);
+            } else if (atticEntry == childEntry) {
+                propertiesInAttic.remove(propName);
+            } // else: no such prop-entry. should not get here
+
+            // special properties
+            if (StateUtility.isUuidOrMixin(propName)) {
+                notifyUUIDorMIXINRemoved(propName);
+            }
+        }
-        return getWorkspaceName().equals(oldName) && getWorkspaceIndex() == oldIndex;
+        try {
+            return getName(true).equals(oldName) && getIndex(true) == oldIndex;
+        } catch (RepositoryException e) {
+            // should not get here
+            return false;
+        }
-        return getWorkspaceName().equals(oldName);
+        return getName(true).equals(oldName);
-    private Name getWorkspaceName() {
-        if (revertInfo != null) {
+    private Name getName(boolean wspName) {
+        if (wspName && revertInfo != null) {
-            return getName();
+            return name;
-    private int getWorkspaceIndex() {
-        if (revertInfo != null) {
+    private int getIndex(boolean wspIndex) throws InvalidItemStateException, RepositoryException {
+        if (parent == null) {
+            // the root state may never have siblings
+            return Path.INDEX_DEFAULT;
+        }
+
+        if (wspIndex && revertInfo != null) {
-            return getIndex();
+            NodeState state = (NodeState) internalGetItemState();
+            if (state == null || !state.hasDefinition() || state.getDefinition().allowsSameNameSiblings()) {
+                return parent.getChildIndex(this, wspIndex);
+            } else {
+                return Path.INDEX_DEFAULT;
+            }
-     *
-        // a NEW hierarchyEntry may never be affected by an external modification
-        // -> return null.
-        return (child == null || child.getStatus() == Status.NEW) ? null : child;
+        return child;
+     * @param wspIndex if <code>true</code> transiently removed siblings are respected.
-    private int getChildIndex(NodeEntry cne) throws ItemNotFoundException, RepositoryException {
-        List sns = childNodeEntries.get(cne.getName());
-        // index is one based
-        int index = Path.INDEX_DEFAULT;
-        for (Iterator it = sns.iterator(); it.hasNext(); ) {
-            NodeEntry entry = (NodeEntry) it.next();
-            if (entry == cne) {
-                return index;
-            }
-            // skip entries that belong to removed or invalid states.
-            // NOTE, that in this case the nodestate must be available from the cne.
-            if (EntryValidation.isValidNodeEntry(entry)) {
-                index++;
+    private int getChildIndex(NodeEntry cne, boolean wspIndex) throws ItemNotFoundException, RepositoryException {
+        List sns = new ArrayList(childNodeEntries.get(cne.getName()));
+
+        if (wspIndex) {
+            List atticSiblings = childNodeAttic.get(cne.getName());
+            for (Iterator it = atticSiblings.iterator(); it.hasNext();) {
+                NodeEntryImpl sibl = (NodeEntryImpl) it.next();
+                if (sibl.revertInfo != null) {
+                    sns.add(sibl.revertInfo.oldIndex - 1, sibl);
+                } else {
+                    log.error("Sibling in attic doesn't have revertInfo....");
+                }
-        // not found (should not occur)
-        throw new ItemNotFoundException("No valid child entry for NodeEntry " + cne);
+
+        if (sns.isEmpty()) {
+            // the given node entry is not connected with his parent any more
+            // -> throw
+            String msg = "NodeEntry " + cne.getName() + " is disconnected from its parent -> remove.";
+            cne.remove();
+            throw new InvalidItemStateException(msg);
+
+        } else if (sns.size() == 1) {
+            // no siblings -> simply return the default index.
+            return Path.INDEX_DEFAULT;
+
+        } else {
+            // siblings exist.
+            int index = Path.INDEX_DEFAULT;
+            for (Iterator it = sns.iterator(); it.hasNext(); ) {
+                NodeEntry entry = (NodeEntry) it.next();
+                if (entry == cne) {
+                    return index;
+                }
+                // for wsp index ignore all transiently added items.
+                // otherwise: skip entries that belong to removed or invalid states.
+                // NOTE, that in this case the nodestate must be available from the cne.
+                boolean isValid = (wspIndex) ?
+                        EntryValidation.isValidWorkspaceNodeEntry(entry) :
+                        EntryValidation.isValidNodeEntry(entry);
+                if (isValid) {
+                    index++;
+                }
+            }
+            // not found, since child entries are only weakly connected to the
+            // LinkNode in ChildNodeEntries, equality may not determine the
+            // correct matching entry -> return default index.
+            return Path.INDEX_DEFAULT;
+        }
-        // in case of reordered/moved SNSs we also have to look for a child
-        // entry, which hold the given index before
+        // special treatment for potentially moved/reordered/removed sns
+        // TODO: check again
+        if (childIndex > Path.INDEX_DEFAULT) {
+            List siblingsInAttic = childNodeAttic.get(childName);
+            if (siblings.size() < childIndex && childIndex <= siblings.size() + siblingsInAttic.size()) {
+                return true;
+            }
+        }
-    private void createRevertInfo() {
-        if (revertInfo == null) {
-            revertInfo = new RevertInfo(parent, name, getIndex());
+    private void createRevertInfo() throws RepositoryException {
+        if (revertInfo == null && getStatus() != Status.NEW) {
+            revertInfo = new RevertInfo();
-    /**
-     * Special handling for MOVE and REORDER with same-name-siblings
-     */
-    private void createSiblingRevertInfos() throws RepositoryException {
-        if (revertInfo != null) {
-            return; // nothing to do
+    private void complete(AddNode operation) throws RepositoryException {
+        if (operation.getParentState().getHierarchyEntry() != this) {
+            throw new IllegalArgumentException();
-        // for SNSs without UniqueID remember original index in order to
-        // be able to build the workspaceID TODO: improve
-        List sns = parent.getCompleteChildNodeEntries().get(name);
-        if (sns.size() > 1) {
-            for (Iterator it = sns.iterator(); it.hasNext();) {
-                NodeEntryImpl sibling = (NodeEntryImpl) it.next();
-                if (sibling.getUniqueID() == null && Status.NEW != sibling.getStatus()) {
-                    sibling.createRevertInfo();
+
+        for (Iterator it = operation.getAddedStates().iterator(); it.hasNext();) {
+            HierarchyEntry he = ((ItemState) it.next()).getHierarchyEntry();
+            if (he.getStatus() == Status.NEW) {
+                switch (operation.getStatus()) {
+                    case Operation.STATUS_PERSISTED:
+                        ((HierarchyEntryImpl) he).internalGetItemState().setStatus(Status.EXISTING);
+                        he.invalidate(false);
+                        break;
+                    case Operation.STATUS_UNDO:
+                        he.revert();
+                        break;
+                    default: // ignore
-            }
+            } // entry isn't NEW any more -> ignore
-    /**
-     * Revert a transient move and reordering of child entries
-     */
-    private void revertTransientChanges() throws RepositoryException {
-        if (revertInfo == null) {
-            return; // nothing to do
+    private void complete(AddProperty operation) throws RepositoryException {
+        if (operation.getParentState().getHierarchyEntry() != this) {
+            throw new IllegalArgumentException();
+        }
+        PropertyEntry pe = getPropertyEntry(operation.getPropertyName());
+        if (pe != null && pe.getStatus() == Status.NEW) {
+            switch (operation.getStatus()) {
+                case Operation.STATUS_PERSISTED:
+                    // for autocreated/protected props, mark to be reloaded
+                    // upon next access.
+                    PropertyState addedState = (PropertyState) ((PropertyEntryImpl) pe).internalGetItemState();
+                    addedState.setStatus(Status.EXISTING);
+                    QPropertyDefinition pd = addedState.getDefinition();
+                    if (pd.isAutoCreated() || pd.isProtected()) {
+                        pe.invalidate(true);
+                    } // else: assume added property is up to date.
+                    break;
+                case Operation.STATUS_UNDO:
+                    pe.revert();
+                    break;
+                default: // ignore
+            }
+        } // else: no such prop entry or entry has already been persisted
+          //       e.g due to external modifications merged into this NodeEntry.
+    }
+
+    private void complete(Remove operation) throws RepositoryException {
+        HierarchyEntry rmEntry = operation.getRemoveState().getHierarchyEntry();
+        if (rmEntry.getParent() != this) {
+            throw new IllegalArgumentException();
+        }
+        switch (operation.getStatus()) {
+            case Operation.STATUS_PERSISTED:
+                if (Status.isTerminal(rmEntry.getStatus())) {
+                    log.debug("Removal of State " + rmEntry + " has already been completed.");
+                }
+                rmEntry.remove();
+                break;
+            case Operation.STATUS_UNDO:
+                if (!rmEntry.denotesNode()) {
+                    Name propName = ((PropertyEntry) rmEntry).getName();
+                    if (propertiesInAttic.containsKey(propName)) {
+                        properties.add((PropertyEntry) propertiesInAttic.remove(propName));
+                    } // else: propEntry has never been moved to the attic (see 'addPropertyEntry')
+                }
+                rmEntry.revert();
+            default: // ignore
-        if (isTransientlyMoved())  {
-            // move NodeEntry back to its original parent
-            // TODO improve for simple renaming
+    }
+
+    private void complete(SetMixin operation) throws RepositoryException {
+        if (operation.getNodeState().getHierarchyEntry() != this) {
+            throw new IllegalArgumentException();
+        }
+        PropertyEntry pe = getPropertyEntry(NameConstants.JCR_MIXINTYPES);
+        if (pe != null) {
+            PropertyState pState = pe.getPropertyState();
+            switch (operation.getStatus()) {
+                case Operation.STATUS_PERSISTED:
+                    Name[] mixins = StateUtility.getMixinNames(pState);
+                    getNodeState().setMixinTypeNames(mixins);
+                    if (pState.getStatus() == Status.NEW || pState.getStatus() == Status.EXISTING_MODIFIED) {
+                        pState.setStatus(Status.EXISTING);
+                    }
+                    break;
+                case Operation.STATUS_UNDO:
+                    pe.revert();
+                    break;
+                default: // ignore
+            }
+        } // else: no such prop-Entry (should not occur)
+    }
+
+    private void complete(ReorderNodes operation) throws RepositoryException {
+        HierarchyEntry he = operation.getInsertNode().getHierarchyEntry();
+        if (he != this) {
+            throw new IllegalArgumentException();
+        }
+        // NOTE: if reorder occured in combination with a 'move' the clean-up
+        // of the revertInfo is postponed until {@link #complete(Move)}.
+        switch (operation.getStatus()) {
+            case Operation.STATUS_PERSISTED:
+                if (revertInfo != null && !revertInfo.isMoved()) {
+                    revertInfo.dispose(true);
+                }
+                break;
+            case Operation.STATUS_UNDO:
+                if (he.getStatus() == Status.NEW) {
+                    he.revert();
+                } else if (revertInfo != null && !revertInfo.isMoved()) {
+                    revertInfo.dispose(false);
+                }
+                break;
+            default: // ignore
+        }
+    }
+
+    private void complete(Move operation) throws RepositoryException {
+        HierarchyEntry he = operation.getSourceState().getHierarchyEntry();
+        if (he != this) {
+            throw new IllegalArgumentException();
+        }
+        switch (operation.getStatus()) {
+            case Operation.STATUS_PERSISTED:
+                if (getStatus() != Status.NEW && revertInfo != null) {
+                    revertInfo.oldParent.childNodeAttic.remove(this);
+                    revertInfo.dispose(true);
+                }
+                // and mark the moved state existing
+                // internalGetItemState().setStatus(Status.EXISTING);
+                break;
+            case Operation.STATUS_UNDO:
+                if (getStatus() == Status.NEW) {
+                    revert();
+                } else if (revertInfo != null) {
+                    revertMove();
+                    revertInfo.dispose(false);
+                }
+                break;
+            default: // ignore
+        }
+    }
+
+    private void revertMove() {
+        NodeEntryImpl oldParent = revertInfo.oldParent;
+        if (oldParent == parent) {
+            // simple renaming
-            revertInfo.oldParent.childNodeAttic.remove(this);
+        } else {
+            // move NodeEntry back to its original parent
+            parent.childNodeEntries.remove(this);
+            oldParent.childNodeAttic.remove(this);
-            parent = revertInfo.oldParent;
-            name = revertInfo.oldName;
-            ItemState state = internalGetItemState();
-            if (state != null && !Status.isTerminal(state.getStatus())) {
-                parent.childNodeEntries.add(this, revertInfo.oldIndex);
-            }
+            parent = oldParent;
-        // revert reordering of child-node-entries
-        revertInfo.revertReordering();
-
-        revertInfo.dispose();
-        revertInfo = null;
-    }
-
-    /**
-     * This entry has be set to 'EXISTING' again -> move and/or reordering of
-     * child entries has been completed and the 'revertInfo' needs to be
-     * reset/removed.
-     */
-    private void completeTransientChanges() {
-        // old parent can forget this one
-        // root entry does not have oldParent
-        if (revertInfo.oldParent != null) {
-            revertInfo.oldParent.childNodeAttic.remove(this);
-        }
-        revertInfo.dispose();
-        revertInfo = null;
+        // now restore moved entry with the old name and index and re-add
+        // it to its original parent
+        name = revertInfo.oldName;
+        parent.childNodeEntries.add(this, revertInfo.oldIndex, revertInfo.oldSuccessor);
-     * Upon move of this entry or upon reorder of its child-entries store
-     * original hierarchy information for later revert and in order to be able
-     * to build the workspace id(s).
+     * Upon move or reorder of this entry the original hierarchy information is
+     * store in the RevertInfo for later operation undo and in order to be able
+     * to build the workspace id / path.
-    private class RevertInfo implements ItemStateLifeCycleListener {
+    private class RevertInfo {
+        private final NodeEntryImpl oldSuccessor;
-        private Map reorderedChildren;
-
-        private RevertInfo(NodeEntryImpl oldParent, Name oldName, int oldIndex) {
-            this.oldParent = oldParent;
-            this.oldName = oldName;
-            this.oldIndex = oldIndex;
-
-            ItemState state = internalGetItemState();
-            if (state != null) {
-                state.addListener(this);
-            } // else: should never be null.
-        }
-
-        private void dispose() {
-            ItemState state = internalGetItemState();
-            if (state != null) {
-                state.removeListener(this);
-            }
-
-            if (reorderedChildren != null) {
-                // special handling of SNS-children  TODO: improve
-                // since reordered sns-children are not marked modified (unless they
-                // got modified by some other action, their revertInfo
-                // must be disposed manually
-                for (Iterator it = reorderedChildren.keySet().iterator(); it.hasNext();) {
-                    NodeEntry ne = (NodeEntry) it.next();
-                    List sns = childNodeEntries.get(ne.getName());
-                    if (sns.size() > 1) {
-                        for (Iterator snsIt = sns.iterator(); snsIt.hasNext();) {
-                            NodeEntryImpl sibling = (NodeEntryImpl) snsIt.next();
-                            if (sibling.revertInfo != null && Status.EXISTING == sibling.getStatus()) {
-                                sibling.revertInfo.dispose();
-                                sibling.revertInfo = null;
-                            }
-                        }
-                    }
-                }
-                reorderedChildren.clear();
-            }
+        private RevertInfo() throws InvalidItemStateException, RepositoryException {
+            this.oldParent = parent;
+            this.oldName = name;
+            this.oldIndex = getIndex();
+            this.oldSuccessor = (NodeEntryImpl) ((ChildNodeEntriesImpl) parent.childNodeEntries).getNext(NodeEntryImpl.this);
-        private void reordered(NodeEntry insertEntry, NodeEntry previousBefore) {
-            if (reorderedChildren == null) {
-                reorderedChildren = new LinkedHashMap();
-            }
-            reorderedChildren.put(insertEntry, previousBefore);
-        }
-
-        private void revertReordering() {
-            if (reorderedChildren == null) {
-                return; // nothing to do
-            }
-            // revert all 'reorder' calls in in reverse other they were performed
-            NodeEntry[] reordered = (NodeEntry[]) reorderedChildren.keySet().toArray(new NodeEntry[reorderedChildren.size()]);
-            for (int i = reordered.length-1; i >= 0; i--) {
-                NodeEntry ordered = reordered[i];
-                if (isValidReorderedChild(ordered)) {
-                    NodeEntry previousBefore = (NodeEntry) reorderedChildren.get(ordered);
-                    if (previousBefore == null || isValidReorderedChild(previousBefore)) {
-                        childNodeEntries.reorder(ordered, previousBefore);
-                    }
-                }
-            }
-        }
-
-        private boolean isValidReorderedChild(NodeEntry child) {
-            if (Status.isTerminal(child.getStatus())) {
-                log.warn("Cannot revert reordering. 'previousBefore' does not exist any more.");
-                return false;
-            }
-            if (child.isTransientlyMoved()) {
-                // child has been moved away -> move back
+        private void dispose(boolean persisted) {
+            if (!persisted) {
+                NodeEntryImpl ne = NodeEntryImpl.this;
+                ChildNodeEntriesImpl parentCNEs = (ChildNodeEntriesImpl) parent.childNodeEntries;
+                parentCNEs.reorder(ne, revertInfo.oldSuccessor);
-                    child.revert();
+                    if (oldIndex != ne.getIndex()) {
+                        // TODO: TOBEFIXED
+                        log.warn("Reverting didn't restore the correct index.");
+                    }
-                    log.error("Internal error", e);
-                    return false;
+                    log.warn("Unable to calculate index.", e.getMessage());
-            return true;
-        }
-
-        /**
-         * @see ItemStateLifeCycleListener#statusChanged(ItemState, int)
-         */
-        public void statusChanged(ItemState state, int previousStatus) {
-            switch (state.getStatus()) {
-                case Status.EXISTING:
-                    // stop listening
-                    state.removeListener(this);
-                    completeTransientChanges();
-                    break;
-
-                case Status.REMOVED:
-                case Status.STALE_DESTROYED:
-                    // stop listening
-                    state.removeListener(this);
-                    // remove from the attic
-                    try {
-                        revertTransientChanges();
-                    } catch (RepositoryException e) {
-                        log.warn("Internal error", e);
-                    }
-                    break;
-            }
+            revertInfo = null;

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 MOV31 MOV31 MOV31 MOV31 MOV31 INS40 INS40 UPD40 INS40 UPD40 UPD40 INS40 INS40 INS31 INS31 INS31 INS31 INS31 MOV31 INS55 UPD42 INS43 MOV43 INS43 INS43 INS43 MOV29 INS83 UPD39 UPD42 INS43 INS43 MOV43 UPD42 INS43 INS44 INS44 MOV21 MOV29 MOV83 MOV39 MOV42 MOV44 INS8 INS29 INS39 INS42 INS44 INS8 INS8 UPD42 INS44 UPD83 INS44 INS43 INS43 INS44 INS8 INS43 UPD39 INS42 INS44 INS43 INS8 UPD42 INS44 UPD42 INS44 INS43 INS8 MOV83 MOV39 UPD42 MOV42 INS44 INS43 INS8 MOV83 MOV39 UPD42 MOV42 MOV44 INS43 INS8 INS83 INS39 INS42 INS44 MOV43 INS8 UPD39 UPD42 INS29 INS83 INS42 MOV23 MOV23 MOV23 INS23 INS31 MOV31 INS31 MOV60 MOV25 UPD43 UPD42 INS42 INS25 INS42 INS42 INS42 UPD42 MOV42 INS42 INS41 UPD65 UPD42 MOV42 MOV21 INS41 INS42 INS5 INS42 INS39 INS42 MOV21 INS41 MOV60 INS60 MOV60 INS60 INS50 INS65 MOV43 INS42 INS25 INS54 INS39 INS42 INS39 INS42 INS42 INS42 INS25 INS65 INS39 INS42 MOV60 INS25 INS25 INS25 INS42 INS43 INS42 INS42 INS25 INS24 INS43 INS42 INS43 INS42 INS42 MOV60 INS25 INS50 INS43 INS42 UPD42 MOV42 INS25 MOV60 MOV25 UPD43 UPD42 INS42 INS60 MOV25 INS50 INS43 INS42 MOV60 INS25 INS50 INS60 INS25 MOV21 MOV21 INS65 INS83 INS83 INS43 INS59 INS83 INS42 INS43 MOV43 MOV8 UPD83 MOV83 MOV39 INS42 MOV44 INS8 MOV27 UPD43 UPD27 INS8 INS8 UPD42 INS62 INS8 INS25 INS32 INS68 MOV69 INS42 INS43 INS85 INS42 INS42 INS8 INS43 INS43 INS59 MOV43 INS59 MOV32 MOV49 MOV49 INS25 INS10 MOV49 MOV49 INS25 MOV10 MOV49 MOV25 INS10 INS49 MOV53 INS42 INS32 INS8 INS8 INS8 INS12 INS27 INS27 MOV8 MOV8 INS42 INS42 INS66 INS42 INS8 INS32 INS8 INS25 INS27 INS8 INS27 INS42 INS27 MOV8 INS58 MOV32 INS8 INS42 INS27 UPD43 INS27 INS42 UPD43 INS27 INS8 INS32 INS49 INS25 INS21 INS10 INS49 INS25 INS21 INS49 INS42 INS27 INS8 UPD43 UPD42 INS43 INS59 UPD27 INS32 INS49 INS25 INS10 INS49 INS25 INS10 INS49 INS42 UPD43 INS27 INS8 INS32 INS49 INS25 INS10 INS49 INS25 INS10 INS49 MOV43 INS59 INS27 MOV8 INS8 INS66 INS66 INS66 INS42 INS42 UPD42 MOV42 INS21 UPD39 UPD42 INS25 MOV21 UPD42 UPD42 UPD42 INS25 INS21 UPD42 INS42 INS43 MOV21 INS62 INS8 INS25 INS42 INS9 INS42 INS42 INS69 UPD42 UPD42 UPD42 INS42 MOV21 INS25 INS42 UPD42 MOV32 INS42 INS42 MOV32 INS42 INS32 MOV27 INS8 INS8 MOV27 INS8 INS25 INS32 INS32 UPD42 MOV42 UPD42 MOV42 INS25 INS60 INS60 INS25 MOV25 MOV41 MOV44 INS8 INS42 INS27 INS42 INS27 MOV60 INS14 INS60 INS24 INS42 INS42 INS60 INS21 INS53 INS27 INS8 MOV8 INS42 INS40 INS60 INS25 MOV27 INS27 INS32 INS52 MOV43 INS59 MOV60 MOV25 INS32 INS52 INS53 UPD42 UPD42 INS27 INS27 INS50 UPD42 UPD42 INS32 INS32 INS52 INS53 INS42 INS42 INS40 INS32 MOV8 MOV32 INS40 INS38 MOV8 INS32 INS32 INS52 INS53 UPD42 UPD42 UPD42 MOV60 INS50 UPD42 MOV42 INS42 INS32 UPD42 INS52 INS53 UPD42 MOV42 UPD42 MOV42 INS40 UPD27 MOV27 MOV8 INS40 INS27 INS8 INS25 UPD42 INS42 INS32 INS42 INS52 INS53 UPD42 MOV42 INS42 INS40 INS27 INS8 INS40 INS27 INS8 INS25 INS42 INS40 INS42 INS42 MOV21 INS21 MOV21 INS21 INS40 UPD42 INS52 INS40 INS40 INS7 INS38 INS8 UPD42 UPD27 MOV27 INS8 MOV8 INS32 UPD43 INS42 INS32 INS42 INS43 INS21 INS62 INS8 INS25 INS43 INS42 INS42 MOV32 MOV27 INS8 INS42 INS42 INS42 MOV27 INS25 INS60 INS25 INS60 INS25 MOV32 INS8 MOV42 MOV42 INS42 MOV42 MOV42 INS42 INS27 INS8 MOV43 INS59 MOV43 INS59 INS27 INS8 MOV25 MOV41 UPD42 INS9 INS42 INS33 INS42 INS42 INS33 INS43 MOV32 INS43 INS59 INS58 MOV32 INS8 INS43 INS59 INS32 INS14 INS32 INS34 INS41 INS41 INS43 INS59 INS27 INS8 MOV42 MOV33 INS32 INS40 INS32 INS42 INS42 INS32 MOV43 INS27 INS32 INS42 INS14 UPD42 MOV42 INS32 INS42 INS33 MOV32 INS40 INS32 INS49 INS60 INS21 INS60 INS25 INS10 INS49 INS21 INS10 INS49 INS32 INS42 INS42 INS42 INS14 MOV42 MOV42 MOV32 UPD42 UPD42 INS32 INS60 INS42 INS42 INS32 INS42 INS14 UPD42 INS40 UPD43 INS32 INS49 INS60 INS21 INS25 INS10 INS49 INS21 INS10 INS49 INS32 INS42 INS14 MOV27 INS38 INS21 INS32 INS40 INS21 INS27 INS8 INS32 INS42 INS14 INS27 INS27 MOV21 INS21 INS32 INS40 INS21 MOV27 MOV8 INS32 INS7 UPD42 UPD42 MOV32 INS22 INS11 INS42 INS60 INS60 INS21 INS54 UPD40 INS21 INS21 INS42 INS42 INS52 UPD42 UPD42 UPD42 INS42 INS11 UPD42 MOV42 INS32 INS42 INS43 INS21 INS62 INS8 INS25 INS42 INS25 UPD42 MOV42 UPD40 INS27 INS8 MOV8 INS39 MOV59 MOV27 MOV8 INS39 MOV59 INS27 INS8 MOV8 INS60 INS25 INS32 INS33 INS21 INS42 INS32 INS42 INS11 INS42 INS33 INS21 INS27 INS42 INS42 INS42 INS32 MOV43 INS59 INS42 INS42 INS60 INS25 INS42 INS42 INS27 INS42 INS42 INS43 INS42 INS42 INS42 INS40 INS40 INS42 INS42 INS32 INS27 INS27 MOV41 INS42 INS42 INS42 INS32 INS42 UPD42 INS32 INS32 INS40 INS50 INS42 INS42 INS43 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS42 INS42 INS40 MOV43 INS59 INS32 UPD43 MOV43 MOV59 UPD27 MOV27 MOV8 INS40 INS32 INS42 UPD42 MOV42 INS43 UPD42 UPD42 MOV42 UPD42 MOV42 INS43 MOV59 INS42 INS42 INS43 UPD42 UPD42 INS32 UPD42 MOV42 UPD42 MOV42 INS40 INS5 INS59 INS32 UPD27 MOV27 MOV8 INS40 MOV32 INS42 INS42 UPD43 MOV43 INS32 INS32 INS42 INS42 INS32 MOV27 INS38 INS21 INS42 INS42 INS43 INS32 INS40 INS42 INS33 INS32 INS42 INS32 INS21 INS40 UPD42 MOV42 INS52 INS40 UPD42 INS52 INS42 INS42 INS52 INS42 MOV43 INS32 MOV43 INS59 INS43 INS59 MOV32 INS8 MOV12 INS32 INS32 INS43 INS42 INS42 INS11 INS42 INS32 INS42 INS43 INS21 INS62 INS8 INS25 INS25 INS27 INS8 MOV8 INS32 INS40 INS60 INS60 MOV21 INS42 INS32 INS40 INS42 INS42 INS32 INS32 INS32 MOV25 INS60 MOV21 INS39 INS59 INS32 INS8 MOV25 UPD42 MOV42 UPD42 MOV42 INS11 INS32 UPD42 MOV42 UPD42 MOV42 INS43 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS43 INS59 INS27 INS8 INS8 INS45 INS32 INS45 INS42 INS60 INS42 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS42 INS36 INS42 INS42 INS42 INS32 INS49 INS21 INS21 INS10 INS49 INS21 INS10 INS49 INS42 UPD42 MOV42 INS11 UPD42 MOV42 UPD42 MOV42 INS40 UPD42 UPD42 INS32 MOV32 MOV32 INS42 INS42 INS42 UPD42 INS42 INS27 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS43 INS85 UPD42 MOV42 MOV32 INS32 UPD42 MOV42 UPD42 MOV42 UPD27 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS9 UPD42 MOV42 UPD42 MOV42 INS32 INS32 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS9 UPD42 MOV42 INS32 INS36 UPD42 MOV42 MOV52 INS42 INS52 INS42 INS42 INS11 UPD42 UPD42 INS42 INS40 INS25 INS42 INS42 INS40 INS42 INS42 INS40 INS42 UPD42 INS42 INS43 INS42 UPD42 MOV42 INS11 INS42 INS32 INS42 INS43 INS21 INS62 INS8 INS8 UPD42 INS9 UPD42 INS9 INS27 INS8 UPD42 INS42 INS40 MOV21 MOV21 INS42 INS42 MOV43 INS59 MOV39 MOV59 INS42 INS42 INS32 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV43 INS59 INS42 INS32 INS42 INS42 INS42 INS32 INS8 MOV43 INS42 INS42 INS42 INS11 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS11 UPD42 INS9 UPD42 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV11 INS40 INS33 INS21 INS21 INS42 INS42 INS39 INS59 INS42 INS42 INS42 INS32 INS32 MOV11 INS42 UPD42 MOV42 INS40 INS32 INS32 INS40 INS32 INS43 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 INS45 INS42 INS45 INS36 UPD42 MOV42 INS42 UPD42 UPD42 UPD42 MOV42 INS32 UPD40 INS40 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 INS9 INS42 UPD42 UPD42 INS9 INS11 INS42 INS42 INS43 INS40 INS27 INS8 INS42 INS43 INS42 UPD42 MOV42 INS11 INS42 INS32 INS42 INS43 MOV21 INS53 INS32 INS40 INS53 UPD42 UPD42 MOV32 INS42 INS16 MOV32 UPD42 MOV42 INS40 INS40 UPD42 INS42 INS32 UPD42 UPD42 INS40 INS42 INS42 INS42 INS42 MOV32 INS21 INS43 INS42 INS43 INS42 INS32 INS32 INS42 INS16 INS42 INS42 INS42 INS42 MOV43 INS32 INS42 INS40 INS42 INS42 INS9 INS42 INS42 INS42 INS36 UPD42 MOV42 UPD42 UPD42 INS9 INS11 INS42 INS42 UPD42 UPD42 INS42 INS40 INS43 INS40 INS42 INS42 INS32 MOV21 INS42 INS43 INS42 INS42 INS11 INS42 INS14 INS42 INS42 INS14 UPD42 INS40 UPD42 INS52 UPD42 MOV42 INS36 INS32 INS33 UPD42 INS32 INS36 UPD42 MOV42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS45 INS36 INS32 MOV32 UPD42 MOV42 INS36 INS42 INS11 INS43 INS42 INS42 INS42 INS42 UPD42 UPD45 INS42 INS43 INS42 UPD42 INS11 INS43 INS43 INS32 INS27 INS42 INS42 UPD42 MOV42 INS32 UPD42 MOV42 INS40 INS11 INS32 INS42 INS40 UPD42 INS40 INS34 INS42 INS42 INS42 INS42 INS11 INS43 INS42 INS42 UPD45 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS32 INS33 UPD42 MOV42 INS43 INS42 INS36 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS43 INS42 INS42 DEL42 DEL33 DEL27 DEL27 DEL42 DEL32 DEL21 DEL40 DEL52 DEL40 DEL42 DEL52 DEL32 DEL21 DEL8 DEL25 DEL66 DEL66 DEL66 DEL66 DEL65 DEL65 DEL39 DEL69 DEL83 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL48 DEL42 DEL42 DEL42 DEL43 DEL42 DEL9 DEL32 DEL59 DEL58 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL8 DEL24 DEL42 DEL65 DEL29 DEL43 DEL42 DEL44 DEL65 DEL65 DEL65 DEL65 DEL65 DEL42 DEL42 DEL65 DEL65 DEL65 DEL42 DEL42 DEL32 DEL38 DEL8 DEL25 DEL42 DEL41 DEL65 DEL65 DEL65 DEL65 DEL65 DEL42 DEL42 DEL32 DEL38 DEL8 DEL25 DEL42 DEL41 DEL42 DEL32 DEL21 DEL42 DEL42 DEL59 DEL60 DEL40 DEL42 DEL52 DEL42 DEL32 DEL42 DEL42 DEL32 DEL38 DEL27 DEL8 DEL42 DEL65 DEL42 DEL32 DEL42 DEL32 DEL42 DEL33 DEL27 DEL42 DEL32 DEL42 DEL33 DEL42 DEL42 DEL32 DEL42 DEL32 DEL33 DEL42 DEL42 DEL32 DEL7 DEL42 DEL33 DEL42 DEL42 DEL42 DEL32 DEL7 DEL9 DEL9 DEL9 DEL60 DEL60 DEL25 DEL60 DEL42 DEL33 DEL27 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL8 DEL8 DEL25 DEL10 DEL8 DEL25 DEL42 DEL42 DEL32 DEL32 DEL32 DEL7 DEL21 DEL25 DEL10 DEL42 DEL42 DEL32 DEL32 DEL32 DEL7 DEL21 DEL10 DEL49 DEL50 DEL8 DEL31 DEL65 DEL42 DEL36 DEL42 DEL42 DEL32 DEL32 DEL16 DEL42 DEL36 DEL42 DEL42 DEL32 DEL32 DEL16 DEL42 DEL40 DEL27 DEL45 DEL42 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL38 DEL42 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL44 DEL31 DEL8 DEL42 DEL32 DEL54 DEL36 DEL33 DEL42 DEL16 DEL42 DEL43 DEL45 DEL42 DEL27 DEL14 DEL53 DEL27 DEL42 DEL42 DEL45 DEL42 DEL43 DEL32 DEL41 DEL42 DEL8 DEL66 DEL65 DEL29 DEL41 DEL42 DEL32 DEL34 DEL27 DEL33 DEL27 DEL40 DEL27 DEL42 DEL43 DEL42 DEL32 DEL59 DEL58 DEL60 DEL25 DEL8 DEL24 DEL66 DEL65 DEL29 DEL32 DEL40 DEL52 DEL40 DEL42 DEL42 DEL42 DEL32 DEL52 DEL27 DEL25 DEL60 DEL41 DEL8 DEL25 DEL42 DEL32 DEL42 DEL40 DEL7 DEL21 DEL32 DEL38 DEL27 DEL25 DEL8 DEL25 DEL21 DEL32 DEL21 DEL42 DEL33 DEL7 DEL21 DEL8 DEL42 DEL42 DEL32 DEL32 DEL33 DEL40 DEL40 DEL40 DEL33 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL58 DEL32 DEL34 DEL27 DEL59 DEL58 DEL42 DEL32 DEL42 DEL32 DEL11 DEL59 DEL60 DEL25 DEL8 DEL24 DEL8 DEL25 DEL8 DEL24 DEL21 DEL33 DEL42 DEL14 DEL7 DEL21 DEL42 DEL33 DEL41 DEL42 DEL42 DEL42 DEL2 DEL42 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL32 DEL21 DEL42 DEL42 DEL45 DEL42 DEL42 DEL42 DEL32 DEL25 DEL42 DEL32 DEL8 DEL9 DEL41 DEL8 DEL12 DEL54 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL32 DEL21 DEL8 DEL25 DEL52 DEL42 DEL40 DEL41 DEL66 DEL66 DEL66 DEL65 DEL29 DEL40 DEL33 DEL27 DEL25 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL42 DEL42 DEL44 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL31 DEL83 DEL39 DEL42 DEL42 DEL33 DEL27 DEL42 DEL42 DEL52 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL25 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL32 DEL42 DEL43 DEL85 DEL5 DEL32 DEL3 DEL32 DEL11 DEL59 DEL60 DEL39 DEL42 DEL40 DEL34 DEL27 DEL59 DEL58 DEL42 DEL34 DEL27 DEL42 DEL37 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL32 DEL27 DEL25 DEL8 DEL25 DEL8 DEL24 DEL8 DEL31 DEL42 DEL42 DEL69 DEL39 DEL69 DEL68 DEL65 DEL29 DEL42 DEL42 DEL44 DEL42 DEL42 DEL32 DEL40 DEL49 DEL42 DEL42 DEL52 DEL32 DEL21 DEL42 DEL32 DEL21 DEL10 DEL40 DEL49 DEL40 DEL49 DEL21 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL10 DEL50 DEL8 DEL31 DEL55
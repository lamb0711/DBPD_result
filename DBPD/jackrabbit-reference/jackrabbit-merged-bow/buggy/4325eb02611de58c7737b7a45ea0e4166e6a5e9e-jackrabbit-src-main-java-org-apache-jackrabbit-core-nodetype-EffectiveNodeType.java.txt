JCR-274: committing sandro's patch with some modifications (mainly formatting related)
thanks sandro!


git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@373516 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Arrays;
+import java.util.Map;
-import java.util.Arrays;
-     * Factory method: creates an effective node type
-     * representation of an existing (i.e. registered) node type.
+     * Factory method: creates an effective node type representation of an
+     * existing (i.e. registered) node type.
-     * Factory method: creates an effective node type
-     * representation of a node type definition. Whereas all referenced
-     * node types must exist (i.e. must be registered), the definition itself
-     * is not required to be registered.
+     * Factory method: creates an effective node type representation of a
+     * node type definition. Whereas all referenced node types must exist
+     * (i.e. must be registered), the definition itself is not required to be
+     * registered.
+        return create(ntReg, ntd, null, null);
+    }
+
+    /**
+     * Package private factory method.
+     * <p/>
+     * Creates an effective node type representation of a node type definition.
+     * Whereas all referenced node types must exist (i.e. must be registered),
+     * the definition itself is not required to be registered.
+     * todo check javadoc/param names
+     * @param ntReg
+     * @param ntd
+     * @param anEntCache
+     * @param aRegisteredNTDefCache
+     * @return
+     * @throws NodeTypeConflictException
+     * @throws NoSuchNodeTypeException
+     */
+    static EffectiveNodeType create(NodeTypeRegistry ntReg,
+                                    NodeTypeDef ntd,
+                                    EffectiveNodeTypeCache anEntCache,
+                                    Map aRegisteredNTDefCache)
+            throws NodeTypeConflictException, NoSuchNodeTypeException {
-            ent.internalMerge(ntReg.getEffectiveNodeType(supertypes), true);
+            if (anEntCache == null || aRegisteredNTDefCache == null) {
+                ent.internalMerge(ntReg.getEffectiveNodeType(supertypes), true);
+            } else {
+                ent.internalMerge(ntReg.getEffectiveNodeType(supertypes, anEntCache, aRegisteredNTDefCache), true);
+            }
-     * Factory method: creates a new 'empty' effective node type instance
+     * Package private factory method for creating a new 'empty' effective
+     * node type instance.
-     * @return
+     * @return an 'empty' effective node type instance.
-    public void checkRequiredPrimaryType(QName nodeTypeName, QName[] requiredPrimaryTypes)
+    public void checkRequiredPrimaryType(QName nodeTypeName,
+                                         QName[] requiredPrimaryTypes)

MOV26 INS26 INS40 INS31 MOV29 INS83 INS83 INS43 INS42 INS44 INS44 INS43 INS43 INS8 INS29 INS44 INS44 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS42 INS42 INS32 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS8 UPD66 INS66 INS66 INS42 INS42 INS42 INS33 INS33 INS25 INS27 MOV8 INS8 INS27 INS27 INS21 INS42 INS33 INS42 INS33 INS32 INS42 INS42 INS32 INS9 INS42 INS42 INS42 INS42 INS42 DEL83
JCR-1588 - JSR 283: Access Control (work in progress)
JCR-1590 - JSR 283: Locking
JCR-1915 - Node.setPrimaryNodeType should only redefine child-definitions that are not covered by the new effective nt
JCR-1875 - Failing Node.unlock() might leave inconsistent transient state
JCR-538 - Failing Node.checkin() or Node.checkout() might leave inconsistent transient state

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@732693 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.lock.LockManager;
+import org.apache.jackrabbit.core.security.authorization.Permission;
+import org.apache.jackrabbit.core.security.AccessManager;
+import org.apache.jackrabbit.api.jsr283.lock.LockManager;
+        } else {
+            // adding a node with explicit specifying the node type name
+            // requires the editing session to have nt_management privilege.
+            session.getAccessManager().checkPermission(nodePath, Permission.NODE_TYPE_MNGMT);
+        // check permissions
+        Path p = getPrimaryPath();
+        AccessManager acMgr = session.getAccessManager();
+        acMgr.checkPermission(p, Permission.NODE_TYPE_MNGMT);
+        // special handling of mix:versionable. since adding the mixin alters
+        // the version storage jcr:versionManagement privilege is required
+        // in addition.
+        if (NameConstants.MIX_VERSIONABLE.equals(mixinName)) {
+            acMgr.checkPermission(p, Permission.VERSION_MNGMT);
+        }
+        // check permission
+        session.getAccessManager().checkPermission(getPrimaryPath(), Permission.NODE_TYPE_MNGMT);
-        // walk through properties and child nodes and remove those that have been
-        // defined by the specified mixin type
-
-        // use temp set to avoid ConcurrentModificationException
-        HashSet set = new HashSet(thisState.getPropertyNames());
-        for (Iterator iter = set.iterator(); iter.hasNext();) {
-            Name propName = (Name) iter.next();
-            PropertyImpl prop = (PropertyImpl) itemMgr.getItem(
-                    new PropertyId(thisState.getNodeId(), propName));
-            // check if property has been defined by mixin type (or one of its supertypes)
-            NodeTypeImpl declaringNT = (NodeTypeImpl) prop.getDefinition().getDeclaringNodeType();
-            if (!entRemaining.includesNodeType(declaringNT.getQName())) {
-                // the remaining effective node type doesn't include the
-                // node type that declared this property, it is thus safe
-                // to remove it
-                removeChildProperty(propName);
+        // walk through properties and child nodes and remove those that have
+        // been defined by the specified mixin type
+        boolean success = false;
+        try {
+            // use temp set to avoid ConcurrentModificationException
+            HashSet set = new HashSet(thisState.getPropertyNames());
+            for (Iterator iter = set.iterator(); iter.hasNext();) {
+                Name propName = (Name) iter.next();
+                PropertyState propState = (PropertyState) stateMgr.getItemState(new PropertyId(thisState.getNodeId(), propName));
+                // check if property has been defined by mixin type (or one of its supertypes)
+                PropertyDefinition def = ntMgr.getPropertyDefinition(propState.getDefinitionId());
+                NodeTypeImpl declaringNT = (NodeTypeImpl) def.getDeclaringNodeType();
+                if (!entRemaining.includesNodeType(declaringNT.getQName())) {
+                    // the remaining effective node type doesn't include the
+                    // node type that declared this property, it is thus safe
+                    // to remove it
+                    removeChildProperty(propName);
+                }
-        }
-        // use temp array to avoid ConcurrentModificationException
-        ArrayList list = new ArrayList(thisState.getChildNodeEntries());
-        // start from tail to avoid problems with same-name siblings
-        for (int i = list.size() - 1; i >= 0; i--) {
-            ChildNodeEntry entry = (ChildNodeEntry) list.get(i);
-            NodeImpl node = (NodeImpl) itemMgr.getItem(entry.getId());
-            // check if node has been defined by mixin type (or one of its supertypes)
-            NodeTypeImpl declaringNT = (NodeTypeImpl) node.getDefinition().getDeclaringNodeType();
-            if (!entRemaining.includesNodeType(declaringNT.getQName())) {
-                // the remaining effective node type doesn't include the
-                // node type that declared this child node, it is thus safe
-                // to remove it
-                removeChildNode(entry.getName(), entry.getIndex());
+            // use temp array to avoid ConcurrentModificationException
+            ArrayList list = new ArrayList(thisState.getChildNodeEntries());
+            // start from tail to avoid problems with same-name siblings
+            for (int i = list.size() - 1; i >= 0; i--) {
+                ChildNodeEntry entry = (ChildNodeEntry) list.get(i);
+                NodeState nodeState = (NodeState) stateMgr.getItemState(entry.getId());
+                NodeDefinition def = ntMgr.getNodeDefinition(nodeState.getDefinitionId());
+                // check if node has been defined by mixin type (or one of its supertypes)
+                NodeTypeImpl declaringNT = (NodeTypeImpl) def.getDeclaringNodeType();
+                if (!entRemaining.includesNodeType(declaringNT.getQName())) {
+                    // the remaining effective node type doesn't include the
+                    // node type that declared this child node, it is thus safe
+                    // to remove it
+                    removeChildNode(entry.getName(), entry.getIndex());
+                }
+            }
+            success = true;
+        } catch (ItemStateException e) {
+            throw new RepositoryException("Failed to clean up child items defined by removed mixin " + session.getJCRName(mixinName));
+        } finally {
+            if (!success) {
+                // TODO revert changes made to the jcr:mixinTypes property
+
+        // check permissions
+        Path p = getPrimaryPath();
+        AccessManager acMgr = session.getAccessManager();
+        if (!acMgr.isGranted(p, Permission.NODE_TYPE_MNGMT)) {
+            return false;
+        }
+        // special handling of mix:versionable. since adding the mixin alters
+        // the version storage jcr:versionManagement privilege is required
+        // in addition.
+        if (NameConstants.MIX_VERSIONABLE.equals(ntName)) {
+            if (!acMgr.isGranted(p, Permission.VERSION_MNGMT)) {
+                return false;
+            }
+        }
+
+        // check permission
+        session.getAccessManager().checkPermission(getPrimaryPath(), Permission.VERSION_MNGMT);
-        internalSetProperty(NameConstants.JCR_ISCHECKEDOUT, InternalValue.create(false));
-        internalSetProperty(NameConstants.JCR_BASEVERSION, InternalValue.create(new UUID(v.getUUID())));
-        internalSetProperty(NameConstants.JCR_PREDECESSORS, InternalValue.EMPTY_ARRAY, PropertyType.REFERENCE);
-        save();
+        boolean success = false;
+        try {
+            internalSetProperty(NameConstants.JCR_ISCHECKEDOUT, InternalValue.create(false));
+            internalSetProperty(NameConstants.JCR_BASEVERSION, InternalValue.create(new UUID(v.getUUID())));
+            internalSetProperty(NameConstants.JCR_PREDECESSORS, InternalValue.EMPTY_ARRAY, PropertyType.REFERENCE);
+            save();
+            success = true;
+        } finally {
+            if (!success) {
+                try {
+                    // TODO: need to revert changes made within the version manager as well.
+                    refresh(false);
+                } catch (RepositoryException e) {
+                    // cleanup failed
+                    log.error("Error while cleaning up after failed Node.checkin", e);
+                }
+            }
+        }
+        // check permission
+        session.getAccessManager().checkPermission(getPrimaryPath(), Permission.VERSION_MNGMT);
-        boolean hasPendingChanges = session.hasPendingChanges();
-
+        boolean hasPendingChanges = hasPendingChanges();
-        props[0] = internalSetProperty(NameConstants.JCR_ISCHECKEDOUT, InternalValue.create(true));
-        props[1] = internalSetProperty(NameConstants.JCR_PREDECESSORS,
-                new InternalValue[]{
-                        InternalValue.create(new UUID(getBaseVersion().getUUID()))
-                });
-        if (hasPendingChanges) {
-            for (int i = 0; i < props.length; i++) {
-                props[i].save();
+        boolean success = false;
+        try {
+            props[0] = internalSetProperty(NameConstants.JCR_ISCHECKEDOUT, InternalValue.create(true));
+            props[1] = internalSetProperty(NameConstants.JCR_PREDECESSORS,
+                    new InternalValue[]{
+                            InternalValue.create(new UUID(getBaseVersion().getUUID()))
+                    });
+            if (hasPendingChanges) {
+                for (int i = 0; i < props.length; i++) {
+                    props[i].save();
+                }
+            } else {
+                save();
-        } else {
-            try {
-                session.save();
-            } catch (RepositoryException e) {
-                session.refresh(false);
-                throw e;
+            success = true;
+        } finally {
+            if (!success) {
+                for (int i = 0; i < props.length; i++) {
+                    if (props[i] != null) {
+                        try {
+                            props[i].refresh(false);
+                        } catch (RepositoryException e) {
+                            log.error("Error while cleaning up after failed Node.checkout", e);
+                        }
+                    }
+                }
-     * {@inheritDoc}
+     * Perform {@link Node#cancelMerge(Version)} or {@link Node#doneMerge(Version)}
+     * depending on the value of <code>cancel</code>.
+        // check permission
+        session.getAccessManager().checkPermission(getPrimaryPath(), Permission.VERSION_MNGMT);
-        // remove version from mergeFailed list
-        internalSetMergeFailed(failed);
+        boolean success = false;
+        try {
+            // remove version from mergeFailed list
+            internalSetMergeFailed(failed);
-        if (!cancel) {
-            // add version to jcr:predecessors list
-            Value[] vals = getProperty(NameConstants.JCR_PREDECESSORS).getValues();
-            InternalValue[] v = new InternalValue[vals.length + 1];
-            for (int i = 0; i < vals.length; i++) {
-                v[i] = InternalValue.create(UUID.fromString(vals[i].getString()));
+            if (!cancel) {
+                // add version to jcr:predecessors list
+                Value[] vals = getProperty(NameConstants.JCR_PREDECESSORS).getValues();
+                InternalValue[] v = new InternalValue[vals.length + 1];
+                for (int i = 0; i < vals.length; i++) {
+                    v[i] = InternalValue.create(UUID.fromString(vals[i].getString()));
+                }
+                v[vals.length] = InternalValue.create(UUID.fromString(version.getUUID()));
+                internalSetProperty(NameConstants.JCR_PREDECESSORS, v);
-            v[vals.length] = InternalValue.create(UUID.fromString(version.getUUID()));
-            internalSetProperty(NameConstants.JCR_PREDECESSORS, v);
-        }
-        // save
-        save();
+            save();
+            success = true;
+        } finally {
+            if (!success) {
+                try {
+                    refresh(false);
+                } catch (RepositoryException e) {
+                    log.error("Error while reverting changes upon failed Node.doneMerge or Node.cancelMerge, respectively.", e);
+                }
+            }
+        }
-     * {@inheritDoc}
+     * Executes the Node#update or Node#merge call.
+     *
+     * @param srcWorkspaceName Name of the source workspace as passed to
+     * {@link Node#merge(String, boolean)} or {@link Node#update(String)}.
+     * @param failedIds List to place the failed ids or <code>null</code> if
+     * {@link Node#update(String)} should be executed.
+     * @param bestEffort Flag passed to {@link Node#merge(String, boolean)} or
+     * false if {@link Node#update(String)} should be executed.
+     * @throws NoSuchWorkspaceException
+     * @throws AccessDeniedException
+     * @throws LockException
+     * @throws InvalidItemStateException
+     * @throws RepositoryException
+        // check permission
+        session.getAccessManager().checkPermission(getPrimaryPath(), Permission.VERSION_MNGMT);
+        boolean success = false;
-            try {
-                internalMerge(srcSession, failedIds, bestEffort, removeExisting, replaceExisting);
-            } catch (RepositoryException e) {
+            internalMerge(srcSession, failedIds, bestEffort, removeExisting, replaceExisting);
+            session.save();
+            success = true;
+        } finally {
+            if (!success) {
-                } catch (RepositoryException e1) {
-                    // ignore
+                } catch (RepositoryException e) {
+                    log.error("Error while cleaning up after failed merge/update", e);
-                throw e;
-            session.save();
-        } finally {
+        boolean success = false;
-        } catch (RepositoryException e) {
-            // revert session
-            try {
-                log.error("reverting changes applied during restore...");
-                session.refresh(false);
-            } catch (RepositoryException e1) {
-                // ignore this
+            session.save();
+            success = true;
+        } finally {
+            if (!success) {
+                // revert session
+                try {
+                    log.debug("reverting changes applied during restore...");
+                    session.refresh(false);
+                } catch (RepositoryException e) {
+                    log.error("Error while reverting changes applied during restore.", e);
+                }
-            throw e;
-        session.save();
+        // check permission
+        session.getAccessManager().checkPermission(getPrimaryPath(), Permission.VERSION_MNGMT);
+
-
-        // check for pending changes
-        if (hasPendingChanges()) {
-            String msg = "Unable to lock node. Node has pending changes: " + this;
-            log.debug(msg);
-            throw new InvalidItemStateException(msg);
-        }
-
-        checkLockable();
-
-        LockManager lockMgr = session.getLockManager();
-        synchronized (lockMgr) {
-            Lock lock = lockMgr.lock(this, isDeep, isSessionScoped);
-
-            boolean succeeded = false;
-
-            try {
-                // add properties to content
-                internalSetProperty(NameConstants.JCR_LOCKOWNER,
-                        InternalValue.create(getSession().getUserID()));
-                internalSetProperty(NameConstants.JCR_LOCKISDEEP,
-                        InternalValue.create(isDeep));
-                save();
-                succeeded = true;
-            } finally {
-                if (!succeeded) {
-                    // failed to set lock meta-data content, cleanup
-                    try {
-                        lockMgr.unlock(this);
-                        refresh(false);
-                    } catch (RepositoryException re) {
-                        // cleanup failed
-                        log.error("error while cleaning up after failed lock attempt", re);
-                    }
-                }
-            }
-
-            return lock;
-        }
+        LockManager lockMgr = ((WorkspaceImpl) session.getWorkspace()).get283LockManager();
+        return lockMgr.lock(getPath(), isDeep, isSessionScoped, Long.MAX_VALUE, null);
-
-        if (isNew()) {
-            throw new LockException("New node can not be locked: " + this);
-        }
-        return session.getLockManager().getLock(this);
+        LockManager lockMgr = ((WorkspaceImpl) session.getWorkspace()).get283LockManager();
+        return lockMgr.getLock(getPath());
-
-        // check for pending changes
-        if (hasPendingChanges()) {
-            String msg = "Unable to unlock node. Node has pending changes: " + this;
-            log.debug(msg);
-            throw new InvalidItemStateException(msg);
-        }
-
-        checkLockable();
-
-        LockManager lockMgr = session.getLockManager();
-        synchronized (lockMgr) {
-            if (lockMgr.isLockHolder(session, this)) {
-                // save first, and unlock later. this guards concurrent access
-
-                // remove properties in content
-                internalSetProperty(NameConstants.JCR_LOCKOWNER, (InternalValue) null);
-                internalSetProperty(NameConstants.JCR_LOCKISDEEP, (InternalValue) null);
-                save();
-            }
-            lockMgr.unlock(this);
-        }
+        LockManager lockMgr = ((WorkspaceImpl) session.getWorkspace()).get283LockManager();
+        lockMgr.unlock(getPath());
-
-        if (!isNodeType(NameConstants.MIX_LOCKABLE) || isNew()) {
-            // a node that is new or not lockable never holds a lock
-            return false;
-        }
-        return session.getLockManager().holdsLock(this);
+        LockManager lockMgr = ((WorkspaceImpl) session.getWorkspace()).get283LockManager();
+        return lockMgr.holdsLock(getPath());
-
-        if (isNew()) {
-            return false;
-        }
-        return session.getLockManager().isLocked(this);
-    }
-
-    /**
-     * Checks if this node is lockable, i.e. has 'mix:lockable'.
-     *
-     * @throws LockException       if this node is not lockable
-     * @throws RepositoryException if another error occurs
-     */
-    private void checkLockable() throws LockException, RepositoryException {
-        if (!isNodeType(NameConstants.MIX_LOCKABLE)) {
-            String msg =
-                "Unable to perform a locking operation on"
-                + " a non-lockable node: " + this;
-            log.debug(msg);
-            throw new LockException(msg);
-        }
+        LockManager lockMgr = ((WorkspaceImpl) session.getWorkspace()).get283LockManager();
+        return lockMgr.isLocked(getPath());
+        // check permission
+        session.getAccessManager().checkPermission(getPrimaryPath(), Permission.NODE_TYPE_MNGMT);
-        EffectiveNodeType entNew, entOld;
+        EffectiveNodeType entNew, entOld, entAll;
-            ntReg.getEffectiveNodeType(ntName, state.getMixinTypeNames());
+            entAll = ntReg.getEffectiveNodeType(ntName, state.getMixinTypeNames());
+        Set allDefs = new HashSet(Arrays.asList(entAll.getAllItemDefs()));
-                if (!newDefs.contains(ntReg.getPropDef(propState.getDefinitionId()))) {
+                if (!allDefs.contains(ntReg.getPropDef(propState.getDefinitionId()))) {
-
-                    PropertyDefinitionImpl pdi = null;
-                        pdi = getApplicablePropertyDefinition(
+                        PropertyDefinitionImpl pdi = getApplicablePropertyDefinition(
-                        // value conversion failed,
-                        // remove it
+                        // value conversion failed, remove it
-                NodeState nodeState =
-                        (NodeState) stateMgr.getItemState(entry.getId());
-                if (!newDefs.contains(ntReg.getNodeDef(nodeState.getDefinitionId()))) {
+                NodeState nodeState = (NodeState) stateMgr.getItemState(entry.getId());
+                if (!allDefs.contains(ntReg.getNodeDef(nodeState.getDefinitionId()))) {
-
-                    NodeDefinitionImpl ndi = null;
-                        NodeImpl node = (NodeImpl) itemMgr.getItem(nodeState.getId());
-                        ndi = getApplicableChildNodeDefinition(
+                        NodeDefinitionImpl ndi = getApplicableChildNodeDefinition(
-                        // redefine property
+                        // redefine node
+                        NodeImpl node = (NodeImpl) itemMgr.getItem(nodeState.getId());
-        // create new 'auto-create' items
+        // create items that are defined as auto-created by the new primary node
+        // type and at the same time were not present with the old nt

MOV26 INS26 INS26 INS40 INS40 UPD40 INS31 MOV29 MOV43 MOV43 MOV43 MOV29 MOV43 MOV43 MOV43 MOV29 MOV83 MOV39 MOV42 MOV43 INS8 MOV29 UPD83 UPD39 UPD42 MOV43 INS8 INS60 INS60 INS21 INS25 INS21 INS60 INS54 INS60 INS60 INS25 INS25 INS21 INS60 INS54 INS21 INS60 INS54 INS21 INS60 INS54 INS65 UPD65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS21 INS60 INS60 INS21 MOV21 INS41 MOV21 INS60 INS41 INS60 MOV21 MOV21 INS60 MOV41 MOV21 INS60 INS41 INS21 INS60 INS8 INS43 INS59 INS43 INS59 INS32 INS32 INS8 INS32 INS39 INS59 INS8 INS12 INS8 INS43 INS59 INS43 INS59 INS38 MOV8 INS32 INS8 INS32 INS39 INS59 INS8 INS8 INS32 INS39 INS59 INS8 INS8 INS66 UPD65 INS66 INS65 INS66 INS32 INS39 INS59 INS8 INS8 INS66 INS42 INS66 UPD65 INS66 INS65 INS66 INS42 INS66 INS65 INS66 INS42 INS66 INS65 INS66 INS66 INS65 INS66 INS42 INS42 INS42 INS42 INS42 INS32 INS39 INS59 MOV8 INS8 INS39 INS59 INS8 INS32 MOV43 INS32 MOV43 INS59 INS32 UPD43 MOV43 INS59 INS43 INS59 INS43 INS59 INS32 INS32 INS59 INS43 INS59 INS21 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS40 INS40 INS42 INS42 INS21 INS32 INS42 INS32 INS40 INS42 INS9 MOV60 MOV24 MOV60 MOV24 INS21 INS44 INS8 INS25 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS40 INS42 INS42 INS25 INS32 INS42 INS32 INS40 INS42 INS9 MOV21 MOV21 MOV21 MOV21 INS21 INS25 INS32 INS42 INS32 INS40 MOV32 INS42 INS9 MOV21 MOV21 MOV25 INS21 INS25 INS68 INS68 INS32 INS42 INS32 INS40 INS42 INS9 MOV21 MOV25 MOV21 INS21 INS25 INS68 INS68 INS68 INS68 INS68 INS32 INS42 INS32 INS40 INS42 INS9 MOV21 MOV21 INS21 INS25 MOV25 INS42 INS9 MOV21 INS21 INS25 INS32 INS42 INS32 INS40 INS42 INS42 INS32 MOV42 MOV42 UPD40 MOV40 INS33 INS42 INS32 INS42 MOV42 INS32 UPD42 INS42 INS32 INS32 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 INS32 UPD42 MOV42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 INS32 INS32 INS42 INS32 INS40 INS42 INS42 INS42 INS14 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS7 INS43 INS42 INS53 INS38 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS38 MOV8 INS42 INS42 INS42 INS7 INS38 INS8 INS42 INS42 INS42 INS8 INS7 INS38 INS8 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS42 INS7 INS38 INS8 INS42 INS42 INS69 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS69 INS42 INS42 INS69 INS42 INS42 INS42 INS7 INS38 INS8 INS7 INS38 MOV8 INS42 INS42 INS42 INS36 UPD42 UPD42 MOV42 INS36 INS42 INS42 INS36 UPD42 MOV42 INS42 INS36 UPD42 MOV42 UPD42 MOV42 INS36 INS42 UPD42 MOV42 INS42 INS42 INS42 INS7 INS43 INS32 INS32 INS42 INS42 INS40 INS42 INS42 INS42 INS40 INS60 INS60 INS60 INS42 INS9 INS42 INS14 INS42 INS32 INS42 INS9 INS42 INS54 MOV21 INS42 INS9 INS42 INS24 INS43 INS43 INS42 INS9 INS42 INS54 INS43 INS39 INS43 MOV43 INS43 INS39 MOV43 INS42 INS9 INS42 MOV54 INS42 INS9 INS42 INS11 INS11 INS11 INS11 INS11 INS42 MOV32 INS42 INS42 INS42 INS32 INS42 INS42 UPD43 INS43 INS59 MOV43 UPD43 UPD43 MOV43 INS59 MOV43 INS59 MOV43 INS27 INS42 INS42 INS42 INS40 INS8 INS12 INS58 INS27 INS37 INS8 INS42 INS42 INS8 INS12 INS42 INS42 INS42 MOV8 INS43 INS32 INS43 INS32 INS43 INS32 INS43 INS32 INS43 INS32 INS42 INS42 UPD42 UPD42 INS42 INS42 INS32 UPD42 UPD42 UPD42 UPD42 MOV42 INS32 INS42 INS11 INS45 INS32 INS21 MOV44 INS8 INS39 INS59 INS42 INS40 INS42 INS25 MOV21 INS44 INS8 INS42 MOV42 INS42 UPD42 MOV42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 INS42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 UPD43 INS42 INS42 INS32 INS43 INS32 UPD43 INS42 INS42 MOV32 MOV43 INS32 INS42 INS42 INS42 INS32 INS21 INS42 INS34 INS27 INS8 INS43 INS42 INS21 MOV43 MOV42 INS21 UPD42 INS21 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS42 UPD42 MOV42 MOV42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 MOV42 INS42 INS9 INS32 INS2 INS33 INS54 INS42 INS32 INS32 UPD42 INS32 INS60 INS60 INS42 INS42 INS45 INS42 INS42 INS42 INS8 INS12 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS42 MOV43 INS59 MOV43 INS59 INS21 INS44 INS8 INS42 MOV32 INS42 MOV32 INS32 INS43 INS42 INS21 INS2 INS42 INS9 INS42 INS32 INS42 INS42 INS42 INS42 INS45 INS42 DEL42 DEL32 DEL32 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL8 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL54 DEL8 DEL42 DEL44 DEL8 DEL12 DEL54 DEL42 DEL53 DEL8 DEL8 DEL42 DEL53 DEL12 DEL42 DEL45 DEL52 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL42 DEL32 DEL21 DEL42 DEL42 DEL43 DEL42 DEL42 DEL52 DEL32 DEL59 DEL60 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL32 DEL21 DEL42 DEL40 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL8 DEL42 DEL38 DEL42 DEL42 DEL52 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL54 DEL42 DEL41 DEL8 DEL51 DEL42 DEL32 DEL43 DEL45 DEL52 DEL27 DEL14 DEL53 DEL8 DEL25 DEL32 DEL52 DEL32 DEL41 DEL52 DEL42 DEL32 DEL42 DEL45 DEL52 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL42 DEL32 DEL21 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL52 DEL32 DEL42 DEL40 DEL42 DEL43 DEL33 DEL11 DEL32 DEL21 DEL42 DEL40 DEL42 DEL43 DEL33 DEL11 DEL32 DEL21 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL51 DEL32 DEL52 DEL42 DEL40 DEL32 DEL38 DEL42 DEL32 DEL27 DEL25 DEL32 DEL52 DEL32 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL32 DEL25 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL43 DEL43 DEL40 DEL32 DEL38 DEL42 DEL45 DEL45 DEL52 DEL27 DEL59 DEL60 DEL32 DEL21 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL8 DEL42 DEL33 DEL59 DEL60 DEL42 DEL7 DEL21 DEL42 DEL33 DEL59 DEL60 DEL42 DEL7 DEL21
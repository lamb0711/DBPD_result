work in progress

- NodeInfo does not load information about child-node-entries
  -> add separate SPI call
  -> add initial draft ChildInfo interface
  -> ChildNodeEntries are not built upon creation of the NodeState
  -> ItemStateFactory: add method to retrieve ChildNodeEntries

- respect CacheBehaviour while persisting transient modifications

- LockInfo.getNodeId() -> not used so far -> remove

- SessionItemStateManager: getHierarchyManager() only used by SessionImpl -> moved

- Improve TODO comments
- Javadoc


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@482657 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.config.CacheBehaviour;
-    private ChildNodeEntries childNodeEntries = new ChildNodeEntries(this);
+    private ChildNodeEntries childNodeEntries;
-                init(wspState.getMixinTypeNames(), wspState.getChildNodeEntries(), wspState.getPropertyNames(), wspState.getNodeReferences());
+                init(wspState.getMixinTypeNames(), wspState.getPropertyNames(), wspState.getNodeReferences());
-     * @param childEntries
-    void init(QName[] mixinTypeNames, Collection childEntries, Collection propertyNames, NodeReferences references) {
+    void init(QName[] mixinTypeNames, Collection propertyNames, NodeReferences references) {
-        // add child node entries
-        childNodeEntries.removeAll();
-        it = childEntries.iterator();
-        while (it.hasNext()) {
-            ChildNodeEntry cne = (ChildNodeEntry) it.next();
-            childNodeEntries.add(cne.getName(), cne.getUUID(), cne.getIndex());
-        }
+    private ChildNodeEntries childNodeEntries() {
+        if (childNodeEntries == null) {
+            try {
+                childNodeEntries = isf.getChildNodeEntries(this);
+            } catch (ItemStateException e) {
+                // TODO improve
+                throw new IllegalStateException();
+            }
+        }
+        return childNodeEntries;
+    }
-                NodeState tmp = isf.createNodeState(getNodeId(), parent);
+                NodeState tmp = isf.createNodeState(getNodeId(), getParent());
-                parent.childNodeEntries.remove(this);
+                getParent().childNodeEntries().remove(this);
-                // todo rather throw? remove from parent?
+                // TODO rather throw? remove from parent?
-                    if (!childNodeEntries.contains(childName, index, cne.getUUID())) {
+                    if (!childNodeEntries().contains(childName, index, cne.getUUID())) {
-                        childNodeEntries.add(childName, cne.getUUID(), index);
+                        childNodeEntries().add(childName, cne.getUUID(), index);
-                        toRemove = !nState.childNodeEntries.contains(childName, index, cne.getUUID());
+                        toRemove = !nState.childNodeEntries().contains(childName, index, cne.getUUID());
-                            childNodeEntries.remove(childName, ((ChildNodeEntry)ce).getIndex());
+                            childNodeEntries().remove(childName, ((ChildNodeEntry)ce).getIndex());
-            for (Iterator it = getAllChildEntries(false, false); it.hasNext();) {
+            // invalidate all child entries including properties present in the
+            // attic (removed props shadowed by a new property with the same name).
+            for (Iterator it = getAllChildEntries(false, true); it.hasNext();) {
-            // TODO: props-in-attic?
-            // todo only invalidate if existing?
+            // TODO only invalidate if existing?
-        NodeState parent = getParent();
-        } else if (parent != null) {
+        }
+
+        NodeState parent = getParent();
+        if (parent == null) {
+           // root node
+            return idFactory.createNodeId((String) null, Path.ROOT);
+        } else {
-            for (Iterator it = parent.childNodeEntries.get(name).iterator(); it.hasNext(); ) {
+            for (Iterator it = parent.childNodeEntries().get(name).iterator(); it.hasNext(); ) {
-        } else {
-            // root node
-            return idFactory.createNodeId((String) null, Path.ROOT);
-                getParent().childNodeEntries.replaceEntry(this);
+                getParent().childNodeEntries().replaceEntry(this);
-        if (parent == null) {
+        if (getParent() == null) {
-            ChildNodeEntry entry = getParent().childNodeEntries.get(this);
+            ChildNodeEntry entry = getParent().childNodeEntries().get(this);
-        return containsValidChildNodeEntry(childNodeEntries);
+        return containsValidChildNodeEntry(childNodeEntries());
-        return containsValidChildNodeEntry(childNodeEntries.get(name));
+        return containsValidChildNodeEntry(childNodeEntries().get(name));
-        return isValidChildNodeEntry(childNodeEntries.get(name, index));
+        return isValidChildNodeEntry(childNodeEntries().get(name, index));
-        ChildNodeEntry cne = childNodeEntries.get(nodeName, index);
+        ChildNodeEntry cne = childNodeEntries().get(nodeName, index);
-            cne = childNodeEntries.get(null, uuid);
+            cne = childNodeEntries().get(null, uuid);
-            cne = childNodeEntries.get(nameElement.getName(), nameElement.getIndex());
+            cne = childNodeEntries().get(nameElement.getName(), nameElement.getIndex());
-        for (Iterator it = childNodeEntries.iterator(); it.hasNext();) {
+        for (Iterator it = childNodeEntries().iterator(); it.hasNext();) {
-        for (Iterator it = childNodeEntries.get(nodeName).iterator(); it.hasNext();) {
+        for (Iterator it = childNodeEntries().get(nodeName).iterator(); it.hasNext();) {
-        List sns = childNodeEntries.get(cne.getName());
+        List sns = childNodeEntries().get(cne.getName());
-                ChildNodeEntry cne = (uuid != null) ? childNodeEntries.get(name, uuid) : childNodeEntries.get(name, index);
+                ChildNodeEntry cne = (uuid != null) ? childNodeEntries().get(name, uuid) : childNodeEntries().get(name, index);
-                    cne = childNodeEntries.add(name, uuid, index);
+                    cne = childNodeEntries().add(name, uuid, index);
-                    childNodeEntries.remove(name, index);
+                    childNodeEntries().remove(name, index);
-     * @see ItemState#persisted(ChangeLog)
+     * @see ItemState#persisted(ChangeLog, CacheBehaviour)
-    void persisted(ChangeLog changeLog) throws IllegalStateException {
-        // TODO: review...in case of CacheBehaviour.MANUAL and .INVALIDATION, some states must be invalidate (e.g. autocreated)
+    void persisted(ChangeLog changeLog, CacheBehaviour cacheBehaviour)
+        throws IllegalStateException {
+        checkIsSessionState();
+
-                    overlayedParent.childNodeEntries.remove((NodeState)state.overlayedState);
+                    overlayedParent.childNodeEntries().remove((NodeState)state.overlayedState);
-            // TODO: only retrieve overlayed state, if necessary
+            // TODO: improve. only retrieve overlayed state, if necessary
-                    int index = parent.childNodeEntries.get((NodeState)addedState).getIndex();
+                    int index = parent.childNodeEntries().get((NodeState)addedState).getIndex();
-                        cne = overlayedParent.childNodeEntries.add(addedState.getQName(), null, index);
+                        cne = overlayedParent.childNodeEntries().add(addedState.getQName(), null, index);
-                        overlayedParent.childNodeEntries.replaceEntry(overlayed);
+                        overlayedParent.childNodeEntries().replaceEntry(overlayed);
-                    NodeState newParent = (NodeState) modState.parent.overlayedState;
+                    NodeState newParent = (NodeState) modState.getParent().overlayedState;
-                        overlayed.parent.moveEntry(newParent, overlayed, modNodeState.getQName(), modNodeState.getDefinition());
+                        overlayed.getParent().moveEntry(newParent, overlayed, modNodeState.getQName(), modNodeState.getDefinition());
-            adjustNodeState(parent, (PropertyState[]) l.toArray(new PropertyState[l.size()]));
+            if (cacheBehaviour == CacheBehaviour.OBSERVATION) {
+                adjustNodeState(parent, (PropertyState[]) l.toArray(new PropertyState[l.size()]));
+            } else {
+                // TODO: improve. invalidate necessary states only
+                parent.invalidate(false);
+            }
-                // error: state has not been processed
-                // TODO: discard state and force reload of all data
+                // should not occur: state has not been processed
+                log.error("State " + state + " has not been processed upon ChangeLog.persisted => invalidate");
+                state.invalidate(false);
-        childNodeEntries.add(child);
+        childNodeEntries().add(child);
-                    childNodeEntries.remove((NodeState) childState);
+                    childNodeEntries().remove((NodeState) childState);
-                // TODO: not correct. removing a NEW state may even remove the 'modified'
+                // TODO: TOBEFIXED. removing a NEW state may even remove the 'modified'
-        childNodeEntries.reorder(insertNode, beforeNode);
+        childNodeEntries().reorder(insertNode, beforeNode);
-        ChildNodeEntry oldEntry = childNodeEntries.remove(childState);
+        ChildNodeEntry oldEntry = childNodeEntries().remove(childState);
-            newParent.childNodeEntries.add(childState);
+            newParent.childNodeEntries().add(childState);
-            List children = new ArrayList(childNodeEntries);
+            List children = new ArrayList(childNodeEntries());
-                its = new Iterator[] {propertiesInAttic.values().iterator(), properties.values().iterator(), childNodeEntries.iterator()};
+                its = new Iterator[] {propertiesInAttic.values().iterator(), properties.values().iterator(), childNodeEntries().iterator()};
-                its = new Iterator[] {properties.values().iterator(),
-                    childNodeEntries.iterator()};
+                its = new Iterator[] {properties.values().iterator(), childNodeEntries().iterator()};
-        if (modState.parent == null) {
+        if (modState.getParent() == null) {
-            return modState.overlayedState.parent != modState.parent.overlayedState;
+            return modState.overlayedState.getParent() != modState.getParent().overlayedState;

INS26 INS40 INS31 INS83 MOV43 INS42 INS8 MOV60 INS44 INS25 INS41 MOV25 MOV8 INS43 INS42 INS21 INS27 INS8 INS42 UPD27 INS42 INS32 INS42 INS33 INS54 MOV42 INS32 INS32 INS69 INS42 INS25 INS32 INS32 INS32 INS8 INS12 INS42 MOV42 INS32 INS32 INS32 INS32 INS43 INS27 INS8 INS8 MOV42 MOV42 INS32 INS42 INS42 INS21 INS44 INS8 MOV42 MOV42 MOV42 INS32 MOV42 INS42 INS42 INS40 MOV21 INS21 INS21 INS21 MOV42 INS32 INS32 INS22 INS7 INS43 INS42 INS53 INS32 INS32 INS32 MOV42 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS42 INS42 INS32 INS40 INS42 INS32 INS42 INS42 INS32 INS42 INS14 UPD9 INS32 MOV32 INS42 MOV42 MOV42 MOV42 MOV42 MOV42 INS32 MOV42 INS42 INS42 INS9 INS42 INS42 INS27 INS42 INS42 INS9 MOV42 INS42 INS42 INS42 INS42 INS42 INS52 INS43 INS32 INS32 INS32 MOV32 INS42 MOV42 MOV43 INS45 INS42 INS45 INS42 UPD42 MOV42 INS32 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 MOV43 INS22 INS32 INS32 MOV42 INS32 INS32 INS32 INS32 INS42 INS32 MOV42 MOV42 MOV42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 MOV42 DEL52 DEL14 DEL42 DEL42 DEL32 DEL42 DEL65 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL61 DEL40 DEL40 DEL40 DEL42 DEL22 DEL42 DEL22 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL42 DEL40 DEL40 DEL40
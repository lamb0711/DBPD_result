JCR-2028: JSR 283 JCR Path

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@772659 13f79535-47bb-0310-9956-ffa450edef68

+    private static final int STATE_IDENTIFIER = 8;
+    private static final int STATE_URI = 9;
+    private static final int STATE_URI_END = 10;
-     * <code>resolver</code> to convert prefixes into namespace URI's.
+     * <code>resolver</code> to convert prefixes into namespace URI's. If
+     * resolver is <code>null</code> this method only checks the format of the
+     * passed String and returns <code>null</code>.
-     * @return qualified path.
+     * @return A path object.
-     * Parses the give <code>jcrPath</code> and returns a <code>Path</code>. If
+     * Parses <code>jcrPath</code> into a qualified path using
+     * <code>resolver</code> to convert prefixes into namespace URI's. If the
+     * specified <code>jcrPath</code> is an identifier based absolute path
+     * beginning with an identifier segment the specified
+     * <code>IdentifierResolver</code> will be used to resolve it to an
+     * absolute path.<p/>
+     * If <code>namResolver</code> is <code>null</code> or if <code>identifierResolver</code>
+     * is <code>null</code> and the path starts with an identifier segment, this
+     * method only checks the format of the string and returns <code>null</code>.
+     *
+     * @param jcrPath the jcr path.
+     * @param nameResolver the namespace resolver.
+     * @param identifierResolver the resolver to validate any trailing identifier
+     * segment and resolve to an absolute path.
+     * @param factory
+     * @return A path object.
+     * @throws MalformedPathException If the <code>jcrPath</code> is malformed.
+     * @throws IllegalNameException if any of the jcrNames is malformed.
+     * @throws NamespaceException If an unresolvable prefix is encountered.
+     * @since JCR 2.0
+     */
+    public static Path parse(String jcrPath, NameResolver nameResolver,
+                             IdentifierResolver identifierResolver, PathFactory factory)
+            throws MalformedPathException, IllegalNameException, NamespaceException {
+        return parse(null, jcrPath, nameResolver, identifierResolver, factory);
+    }
+
+    /**
+     * Parses <code>jcrPath</code> into a qualified path using
+     * <code>resolver</code> to convert prefixes into namespace URI's. If the
+     * specified <code>jcrPath</code> is an identifier based absolute path
+     * beginning with an identifier segment the specified
+     * <code>IdentifierResolver</code> will be used to resolve it to an
+     * absolute path.<p/>
+     * If <code>namResolver</code> is <code>null</code> or if <code>identifierResolver</code>
+     * is <code>null</code> and the path starts with an identifier segment, this
+     * method only checks the format of the string and returns <code>null</code>.
+     *
+     * @param jcrPath the jcr path.
+     * @param nameResolver the namespace resolver.
+     * @param identifierResolver the resolver to validate any trailing identifier
+     * segment and resolve to an absolute path.
+     * @param factory
+     * @param normalizeIdentifier
+     * @return A path object.
+     * @throws MalformedPathException If the <code>jcrPath</code> is malformed.
+     * @throws IllegalNameException if any of the jcrNames is malformed.
+     * @throws NamespaceException If an unresolvable prefix is encountered.
+     * @since JCR 2.0
+     */
+    public static Path parse(String jcrPath, NameResolver nameResolver,
+                             IdentifierResolver identifierResolver,
+                             PathFactory factory, boolean normalizeIdentifier)
+            throws MalformedPathException, IllegalNameException, NamespaceException {
+        return parse(null, jcrPath, nameResolver, identifierResolver, factory, normalizeIdentifier);
+    }
+
+    /**
+     * Parses the given <code>jcrPath</code> and returns a <code>Path</code>. If
-     * returned list. If <code>resolver</code> is <code>null</code>, this method
-     * only checks the format of the string and returns <code>null</code>.
+     * built path before it is returned. If <code>resolver</code> is
+     * <code>null</code>, this method only checks the format of the string and
+     * returns <code>null</code>.
-     * @return the fully qualified Path.
+     * @return the <code>Path</code> object.
+        return parse(parent, jcrPath, resolver, null, factory);
+    }
+
+    /**
+     * Parses the given <code>jcrPath</code> and returns a <code>Path</code>. If
+     * <code>parent</code> is not <code>null</code>, it is prepended to the
+     * built path before it is returned. If the specifed <code>jcrPath</code>
+     * is an identifier based absolute path beginning with an identifier segment
+     * the given <code>identifierResolver</code> will be used to resolve it to an
+     * absolute path.<p/>
+     * If <code>nameResolver</code> is <code>null</code> or if <code>identifierResolver</code>
+     * is <code>null</code> and the path starts with an identifier segment, this
+     * method only checks the format of the string and returns <code>null</code>.
+     *
+     * @param parent the parent path.
+     * @param jcrPath the jcr path.
+     * @param nameResolver the namespace resolver.
+     * @param identifierResolver the resolver to validate any trailing identifier
+     * segment and resolve it to an absolute path.
+     * @param factory The path factory.
+     * @return the <code>Path</code> object.
+     * @throws MalformedPathException
+     * @throws IllegalNameException
+     * @throws NamespaceException
+     */
+    public static Path parse(Path parent, String jcrPath, NameResolver nameResolver,
+                             IdentifierResolver identifierResolver, PathFactory factory)
+            throws MalformedPathException, IllegalNameException, NamespaceException {
+        return parse(parent, jcrPath, nameResolver, identifierResolver, factory, true);
+    }
+
+    /**
+     * Parses the given <code>jcrPath</code> and returns a <code>Path</code>. If
+     * <code>parent</code> is not <code>null</code>, it is prepended to the
+     * built path before it is returned. If the specifed <code>jcrPath</code>
+     * is an identifier based absolute path beginning with an identifier segment
+     * the given <code>identifierResolver</code> will be used to resolve it to an
+     * absolute path.<p/>
+     * If <code>nameResolver</code> is <code>null</code> or if <code>identifierResolver</code>
+     * is <code>null</code> and the path starts with an identifier segment, this
+     * method only checks the format of the string and returns <code>null</code>.
+     *
+     * @param parent the parent path.
+     * @param jcrPath the jcr path.
+     * @param nameResolver the namespace resolver.
+     * @param identifierResolver the resolver to validate any trailing identifier
+     * segment and resolve it to an absolute path.
+     * @param factory The path factory.
+     * @param normalizeIdentifier
+     * @return the <code>Path</code> object.
+     * @throws MalformedPathException
+     * @throws IllegalNameException
+     * @throws NamespaceException
+     */
+    private static Path parse(Path parent, String jcrPath, NameResolver nameResolver,
+                             IdentifierResolver identifierResolver, PathFactory factory,
+                             boolean normalizeIdentifier)
+            throws MalformedPathException, IllegalNameException, NamespaceException {
+        
-                throw new MalformedPathException("'" + jcrPath + "' is not a relative path");
+                throw new MalformedPathException("'" + jcrPath + "' is not a relative path.");
-        int state = STATE_PREFIX_START;
+        int state;
+        if (jcrPath.charAt(0) == '[') {
+            if (parent != null) {
+                throw new MalformedPathException("'" + jcrPath + "' is not a relative path.");
+            }
+            state = STATE_IDENTIFIER;
+            pos++;
+        } else {
+            state = STATE_PREFIX_START;
+        }
+
+
+
+        boolean checkFormat = (nameResolver == null);
+
-                            || state == STATE_INDEX_END) {
+                            || state == STATE_INDEX_END
+                            || state == STATE_URI_END) {
-                        if (resolver != null) {
-                            Name qName = resolver.getQName(name);
+                        if (checkFormat) {
+                            NameParser.checkFormat(name);
+                        } else {
+                            Name qName = nameResolver.getQName(name);
+                    } else if (state == STATE_IDENTIFIER) {
+                        if (c == EOF) {
+                            // eof identifier reached                            
+                            if (jcrPath.charAt(pos - 2) != ']') {
+                                throw new MalformedPathException("'" + jcrPath + "' is not a valid path: Unterminated identifier segment.");
+                            }
+                            String identifier = jcrPath.substring(lastPos, pos - 2);
+                            if (checkFormat) {
+                                if (identifierResolver != null) {
+                                    identifierResolver.checkFormat(identifier);
+                                } // else ignore. TODO: rather throw?
+                            } else if (identifierResolver == null) {
+                                throw new MalformedPathException("'" + jcrPath + "' is not a valid path: Identifier segments are not supported.");
+                            } else if (normalizeIdentifier) {
+                                builder.addAll(identifierResolver.getPath(identifier).getElements());
+                            } else {
+                                identifierResolver.checkFormat(identifier);
+                                builder.addLast(factory.createElement(identifier));
+                            }
+                            state = STATE_PREFIX_START;
+                            lastPos = pos;
+                        }
-                    } else {
+                    } else if (state != STATE_URI) {
+                    } else if (state == STATE_IDENTIFIER || state == STATE_URI) {
+                        // nothing do
+                    } else if (state == STATE_IDENTIFIER) {
+                        // nothing do
+                    } else if (state == STATE_IDENTIFIER) {
+                        // nothing do
-                    } else if (state == STATE_INDEX_END) {
-                        throw new MalformedPathException("'" + jcrPath + "' is not a valid path. '" + c + "' not valid after index. '/' expected.");
-                    throw new MalformedPathException("'" + jcrPath + "' is not a valid path. Whitespace not a allowed in name.");
-
+                    if (state != STATE_IDENTIFIER) {
+                        throw new MalformedPathException("'" + jcrPath + "' is not a valid path. Whitespace not a allowed in name.");
+                    }
-                    throw new MalformedPathException("'" + jcrPath + "' is not a valid path. '" + c + "' not a valid name character.");
+                    if (state != STATE_IDENTIFIER) {
+                        // TODO for JCR 2.0 remove limitation of ' and "
+                        throw new MalformedPathException("'" + jcrPath + "' is not a valid path. '" + c + "' not a valid name character.");
+                    }
+                case '{':
+                    if (state == STATE_PREFIX_START) {
+                        state = STATE_URI;
+                    }
+                    break;
+                case '}':
+                    if (state == STATE_URI) {
+                        state = STATE_URI_END;
+                    }
+                    break;
+                
-        if (resolver == null) {
+        if (checkFormat) {
-            parse(jcrPath, null, PathFactoryImpl.getInstance());
+            parse(jcrPath, null, null, PathFactoryImpl.getInstance());

INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS43 INS43 INS43 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS44 INS43 INS43 INS43 INS8 MOV29 INS83 INS83 INS43 INS42 INS44 INS44 MOV44 INS44 INS43 INS43 INS43 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS44 INS43 INS43 INS43 INS8 INS29 UPD83 INS44 INS44 INS44 INS42 INS34 INS42 INS34 INS42 INS34 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS42 INS42 INS42 INS41 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS39 INS42 INS60 INS25 INS60 UPD66 INS66 INS66 UPD66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS42 INS32 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS42 INS32 UPD66 UPD66 UPD66 INS66 UPD66 INS42 INS42 INS42 INS32 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS42 INS42 MOV39 INS59 INS27 INS8 INS8 INS39 INS59 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 MOV42 INS32 INS13 INS25 INS21 INS21 INS21 INS42 INS36 INS42 INS42 INS34 INS27 INS8 INS7 INS37 INS7 INS27 INS25 INS25 INS25 INS10 INS49 INS25 INS10 INS49 INS42 INS33 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS27 INS25 INS25 INS25 INS27 INS8 INS27 INS8 INS13 INS27 INS8 INS13 INS27 INS8 INS33 INS14 MOV27 INS27 INS27 INS8 MOV25 INS25 INS27 INS8 MOV8 INS27 INS8 MOV8 INS42 INS42 MOV53 INS42 INS42 INS53 INS42 INS42 INS21 INS42 INS42 INS21 INS43 INS27 INS42 INS42 INS42 INS8 INS42 INS42 INS25 INS27 INS8 MOV8 INS42 INS42 UPD42 MOV42 UPD42 MOV42 MOV14 INS7 INS7 UPD45 INS42 INS45 INS42 INS45 INS21 INS27 INS8 INS27 INS27 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS25 INS60 INS25 INS21 INS21 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS8 INS43 INS59 INS42 INS8 INS25 INS7 INS7 INS27 MOV8 INS42 INS42 UPD42 INS32 INS13 INS53 INS42 INS42 INS32 INS25 INS27 INS8 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS14 INS42 INS42 INS42 INS27 INS27 INS8 INS42 INS33 INS53 INS42 INS8 INS8 INS42 INS34 INS43 INS27 INS42 INS34 INS42 INS33 INS21 INS14 INS21 INS21 INS21 INS42 INS45 INS42 INS45 INS32 INS43 INS27 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS45 INS42 INS45 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL42 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL27 DEL42 DEL43 DEL45 DEL42 DEL45 DEL42 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL53 DEL42 DEL33 DEL27
[JCR-614] Weird locking behaviour in CachingHierarchyManager


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@469853 13f79535-47bb-0310-9956-ffa450edef68

-import javax.jcr.ItemNotFoundException;
-import javax.jcr.PathNotFoundException;
-import javax.jcr.RepositoryException;
+import javax.jcr.ItemNotFoundException;
+import javax.jcr.PathNotFoundException;
+import javax.jcr.RepositoryException;
+
-                removeLRU();
+                /**
+                 * Remove least recently used item. Scans the LRU list from head to tail
+                 * and removes the first item that has no children.
+                 */
+                LRUEntry entry = head;
+                while (entry != null) {
+                    PathMap.Element element = entry.getElement();
+                    if (element.getChildrenCount() == 0) {
+                        evict(entry, true);
+                        return;
+                    }
+                    entry = entry.getNext();
+                }
-     * Remove least recently used item. Scans the LRU list from head to tail
-     * and removes the first item that has no children.
-     */
-    private void removeLRU() {
-        synchronized (cacheMonitor) {
-            LRUEntry entry = head;
-            while (entry != null) {
-                PathMap.Element element = entry.getElement();
-                if (element.getChildrenCount() == 0) {
-                    evict(entry, true);
-                    return;
-                }
-                entry = entry.getNext();
-            }
-        }
-    }
-
-    /**
-        synchronized (cacheMonitor) {
-            if (removeFromPathCache) {
-                PathMap.Element element = entry.getElement();
-                remove(element);
-                element.remove();
-            } else {
-                idCache.remove(entry.getId());
-                entry.remove();
-            }
+        // assert: synchronized (cacheMonitor)
+        if (removeFromPathCache) {
+            PathMap.Element element = entry.getElement();
+            remove(element);
+            element.remove();
+        } else {
+            idCache.remove(entry.getId());
+            entry.remove();
-        synchronized (cacheMonitor) {
-            if (removeFromPathCache) {
-                PathMap.Element element = entry.getElement();
-                element.traverse(new PathMap.ElementVisitor() {
-                    public void elementVisited(PathMap.Element element) {
-                        evict((LRUEntry) element.get(), false);
-                    }
-                }, false);
-                element.remove(false);
-            } else {
-                idCache.remove(entry.getId());
-                entry.remove();
-            }
+        // assert: synchronized (cacheMonitor)
+        if (removeFromPathCache) {
+            PathMap.Element element = entry.getElement();
+            element.traverse(new PathMap.ElementVisitor() {
+                public void elementVisited(PathMap.Element element) {
+                    evict((LRUEntry) element.get(), false);
+                }
+            }, false);
+            element.remove(false);
+        } else {
+            idCache.remove(entry.getId());
+            entry.remove();
-        synchronized (cacheMonitor) {
-            element.traverse(new PathMap.ElementVisitor() {
-                public void elementVisited(PathMap.Element element) {
-                    remove((LRUEntry) element.get(), false);
-                }
-            }, false);
-        }
+        // assert: synchronized (cacheMonitor)
+        element.traverse(new PathMap.ElementVisitor() {
+            public void elementVisited(PathMap.Element element) {
+                remove((LRUEntry) element.get(), false);
+            }
+        }, false);

MOV26 MOV26 MOV26 MOV8 MOV8 MOV8 INS25 MOV27 MOV8 MOV25 MOV27 MOV21 MOV41 MOV32 MOV42 MOV42 MOV9 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL51 DEL8 DEL31 DEL42 DEL51 DEL8 DEL42 DEL51 DEL8 DEL42 DEL51 DEL8
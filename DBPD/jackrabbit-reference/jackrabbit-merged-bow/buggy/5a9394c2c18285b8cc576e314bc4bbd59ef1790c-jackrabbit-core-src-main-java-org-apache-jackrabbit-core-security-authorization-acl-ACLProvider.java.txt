JCR-2313 - Improvements to user management (2) [work in progress] 
-> see issue for details

JCR-2333 - ItemImpl#validateTransientItems: Incomplete validation of mandatory child item
-> patch2

JCR-2195 - Provide possibility to import protected items using Session/Workspace import functionality
-> deal with reference properties
-> make import handlers configurable
-> add userimporter

JCR-171 - Make the extraction of Session UserIDs from Subjects configurable
-> extend SecurityManagerConfig and retrieve uid from principal name if configured
     class is present in the subject

JCR-2351 - Make Authorizable.setProperty more noisy in case of failure

JCR-2331 - Configurable DefaultPolicy replacing Initialization within the ACProvider
-> initial steps. remove code that relies on the default-init
-> add TODOs

JCR-2291 - Issues with compiled permissions of ACL provider
-> remove code searching for DENY-read entries in case of default initialization of ac entries

and here and there minor improvement, usage of generics etc....

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@828791 13f79535-47bb-0310-9956-ffa450edef68

+import java.security.acl.Group;
-import java.util.LinkedHashMap;
+import java.util.Iterator;
-import javax.jcr.query.Query;
-import javax.jcr.query.QueryManager;
-import org.apache.jackrabbit.core.security.authorization.AccessControlEntryIterator;
+import org.apache.commons.collections.iterators.IteratorChain;
-    /**
-     * Flag indicating whether or not this provider should be create the default
-     * ACLs upon initialization.
-     */
-    private boolean initializedWithDefaults;
-
-     * @see AbstractAccessControlProvider#isAcItem(Path)
+     * @see org.apache.jackrabbit.core.security.authorization.AccessControlUtils#isAcItem(Path)
-     * @see AbstractAccessControlProvider#isAcItem(ItemImpl)
+     * @see org.apache.jackrabbit.core.security.authorization.AccessControlUtils#isAcItem(ItemImpl)
+    @Override
-        initializedWithDefaults = !configuration.containsKey(PARAM_OMIT_DEFAULT_PERMISSIONS);
+        // TODO: replace by configurable default policy (see JCR-2331)
+        boolean initializedWithDefaults = !configuration.containsKey(PARAM_OMIT_DEFAULT_PERMISSIONS);
-    //------------------------------------------------------------< private >---
+    //----------------------------------------------------------< protected >---
+    /**
+     * Retrieve an iterator of <code>AccessControlEntry</code> to be evaluated
+     * upon {@link AbstractCompiledPermissions#buildResult}.
+     *
+     * @param node Target node.
+     * @param principalNames List of principal names.
+     * @return an iterator of <code>AccessControlEntry</code>.
+     * @throws RepositoryException If an error occurs.
+     */
+    protected Iterator<AccessControlEntry> retrieveResultEntries(NodeImpl node, List<String> principalNames) throws RepositoryException {
+        return new Entries(node, principalNames).iterator();
+    }
+    //------------------------------------------------------------< private >---
-        private final String jcrReadPrivilegeName;
-
-        /**
-         * flag indicating that there is not 'deny READ'.
-         * -> simplify {@link #grants(Path, int)} in case of permissions == READ
-         */
-        private boolean readAllowed;
-            jcrReadPrivilegeName = session.getAccessControlManager().privilegeFromName(Privilege.JCR_READ).getName();
-                 Determine if there is any 'denyRead' entry (since the default
-                 is that everyone can READ everywhere -> makes evaluation for
-                 the most common check (can-read) easy.
-                */
-                readAllowed = isReadAllowed(principalNames);
-
-                /*
-        /**
-         * If this provider defines read-permission for everyone (defined upon
-         * init with default values), search if there is any ACE that defines
-         * permissions for any of the principals AND denies-READ. Otherwise
-         * this shortcut is not possible.
-         *
-         * @param principalnames names of the principals
-         * @return true if read is allowed everywhere.
-         */
-        private boolean isReadAllowed(Collection<String> principalnames) {
-            boolean isReadAllowed = false;
-            if (initializedWithDefaults) {
-                try {
-                    QueryManager qm = session.getWorkspace().getQueryManager();
-                    StringBuffer stmt = new StringBuffer("/jcr:root");
-                    stmt.append("//element(*,");
-                    stmt.append(resolver.getJCRName(NT_REP_DENY_ACE));
-                    stmt.append(")[(");
-
-                    // where the rep:principalName property exactly matches any of
-                    // the given principalsNames
-                    int i = 0;
-                    for (String principalname : principalnames) {
-                        stmt.append("@").append(resolver.getJCRName(P_PRINCIPAL_NAME)).append(" eq ");
-                        stmt.append("'").append(principalname).append("'");
-                        if (++i < principalnames.size()) {
-                            stmt.append(" or ");
-                        }
-                    }
-                    // AND rep:privileges contains the READ privilege
-                    stmt.append(") and @");
-                    stmt.append(resolver.getJCRName(P_PRIVILEGES));
-                    stmt.append(" = '").append(jcrReadPrivilegeName).append("']");
-
-                    Query q = qm.createQuery(stmt.toString(), Query.XPATH);
-
-                    NodeIterator it = q.execute().getNodes();
-                    isReadAllowed =  !it.hasNext();
-                } catch (RepositoryException e) {
-                    log.error(e.toString());
-                    // unable to determine... -> no shortcut upon grants
-                }
-            }
-            return isReadAllowed;
-        }
-
+        @Override
-            AccessControlEntryIterator entries = new Entries(getNode(node), principalNames).iterator();
+            Iterator<AccessControlEntry> entries = retrieveResultEntries(getNode(node), principalNames);
-            List localACEs;
+            List<AccessControlEntry> localACEs;
-                localACEs = Collections.EMPTY_LIST;
+                localACEs = Collections.emptyList();
-        /**
-         *
-         * @param absPath absolute path
-         * @param permissions permission bits
-         * @return <code>true</code> if the permissions are granted
-         * @throws RepositoryException
-         * @see CompiledPermissions#grants(Path, int)
-         */
-        public boolean grants(Path absPath, int permissions) throws RepositoryException {
-            if (permissions == Permission.READ && readAllowed && !isAcItem(absPath)) {
-                return true;
-            } else {
-                return super.grants(absPath, permissions);
-            }
-        }
-
-                                // and reset the readAllowed flag, if the new
-                                // ACE denies READ.
-                                if (readAllowed && n.isNodeType(NT_REP_DENY_ACE)) {
-                                    Value[] vs = n.getProperty(P_PRIVILEGES).getValues();
-                                    for (Value v : vs) {
-                                        if (jcrReadPrivilegeName.equals(v.getString())) {
-                                            readAllowed = false;
-                                        }
-                                    }
-                                }
-                            readAllowed = isReadAllowed(principalNames);
-                                    readAllowed = isReadAllowed(principalNames);
-        private final Map<String, List<AccessControlEntry>> principalNamesToEntries;
+        private final Collection<String> principalNames;
+        private final List<AccessControlEntry> userAces = new ArrayList();
+        private final List<AccessControlEntry> groupAces = new ArrayList();
-            principalNamesToEntries = new LinkedHashMap<String, List<AccessControlEntry>>();
-            for (String name : principalNames) {
-                principalNamesToEntries.put(name, new ArrayList<AccessControlEntry>());
-            }
+            this.principalNames = principalNames;
-                ACLTemplate.collectEntries(aclNode, principalNamesToEntries);
+                //collectEntries(aclNode, principalNamesToEntries);
+                collectEntriesFromAcl(aclNode);
-            // then, recursively look for access controlled parents up the hierarchy.
+            // recursively look for access controlled parents up the hierarchy.
-        private AccessControlEntryIterator iterator() {
-            List<AccessControlEntry> entries = new ArrayList<AccessControlEntry>();
-            for (List<AccessControlEntry> list: principalNamesToEntries.values()) {
-                entries.addAll(list);
+        /**
+         * Separately collect the entries defined for the user and group
+         * principals.
+         *
+         * @param aclNode acl node
+         * @throws RepositoryException if an error occurs
+         */
+        private void collectEntriesFromAcl(NodeImpl aclNode) throws RepositoryException {
+            SessionImpl sImpl = (SessionImpl) aclNode.getSession();
+            PrincipalManager principalMgr = sImpl.getPrincipalManager();
+            AccessControlManager acMgr = sImpl.getAccessControlManager();
+
+            NodeIterator itr = aclNode.getNodes();
+            while (itr.hasNext()) {
+                NodeImpl aceNode = (NodeImpl) itr.nextNode();
+                String principalName = aceNode.getProperty(AccessControlConstants.P_PRINCIPAL_NAME).getString();
+                // only process aceNode if 'principalName' is contained in the given set
+                if (principalNames.contains(principalName)) {
+                    Principal princ = principalMgr.getPrincipal(principalName);
+                    if (princ == null) {
+                        log.warn("Principal with name " + principalName + " unknown to PrincipalManager -> Ignored from AC evaluation.");
+                        continue;
+                    }
+
+                    Value[] privValues = aceNode.getProperty(AccessControlConstants.P_PRIVILEGES).getValues();
+                    Privilege[] privs = new Privilege[privValues.length];
+                    for (int i = 0; i < privValues.length; i++) {
+                        privs[i] = acMgr.privilegeFromName(privValues[i].getString());
+                    }
+                    // create a new ACEImpl (omitting validation check)
+                    AccessControlEntry ace = new ACLTemplate.Entry(
+                            princ,
+                            privs,
+                            aceNode.isNodeType(AccessControlConstants.NT_REP_GRANT_ACE),
+                            sImpl.getValueFactory());
+                    // add it to the proper list (e.g. separated by principals)
+                    if (princ instanceof Group) {
+                        groupAces.add(ace);
+                    } else {
+                        userAces.add(ace);
+                    }
+                }
-            return new AccessControlEntryIterator(entries);
+        }
+
+        private Iterator<AccessControlEntry> iterator() {
+            return new IteratorChain(userAces.iterator(), groupAces.iterator());
-

MOV26 MOV26 MOV26 UPD40 UPD40 UPD40 INS31 INS78 INS29 INS83 INS74 INS42 INS44 INS44 MOV43 INS8 INS23 INS23 INS31 INS31 INS31 INS42 INS60 MOV65 INS65 INS65 INS65 INS65 INS43 INS43 INS43 INS42 INS74 INS42 INS41 INS78 MOV74 INS83 INS83 MOV74 MOV59 INS83 INS83 MOV74 INS59 INS83 MOV42 MOV44 MOV44 MOV43 INS8 INS29 INS83 INS39 INS42 INS44 MOV43 INS8 INS83 UPD74 MOV74 INS42 INS8 INS39 INS59 UPD66 UPD66 INS65 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS42 INS42 MOV43 MOV43 INS32 INS42 UPD42 UPD42 INS42 MOV14 MOV21 MOV21 INS65 INS65 INS65 INS43 UPD42 MOV42 INS60 INS60 INS60 INS60 INS61 INS43 MOV41 INS40 INS40 INS42 MOV38 INS67 INS14 INS42 INS74 MOV74 MOV43 MOV43 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS43 INS59 INS43 INS59 INS43 INS59 MOV43 INS59 INS32 INS8 INS42 INS42 INS42 MOV43 INS42 INS42 INS43 MOV43 INS22 INS42 INS42 INS42 INS11 INS42 INS42 INS32 UPD42 MOV42 INS42 INS32 INS42 INS32 INS42 INS42 MOV60 INS60 INS25 UPD43 INS32 INS32 INS42 UPD42 MOV42 INS42 MOV32 UPD42 INS42 INS42 INS52 INS42 INS43 INS32 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS43 INS59 MOV43 INS59 INS32 INS8 UPD42 INS42 INS42 INS42 INS42 INS32 UPD42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS11 INS42 INS32 INS42 INS42 INS42 INS60 INS25 INS60 INS60 INS24 INS60 INS25 INS42 INS42 INS25 INS43 INS32 INS32 INS42 INS43 INS59 INS27 INS8 MOV5 INS59 INS5 INS59 INS58 INS27 INS37 INS8 INS43 INS59 INS62 INS8 INS8 MOV27 MOV8 UPD42 MOV42 INS42 INS42 INS42 INS42 INS40 UPD42 MOV42 INS42 INS32 INS42 INS33 INS21 INS18 INS42 INS32 INS43 INS85 INS42 INS3 INS39 MOV59 INS42 INS40 INS42 INS21 MOV42 INS42 INS14 INS42 INS43 INS21 MOV21 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS5 INS40 INS7 INS43 INS42 INS42 INS32 INS32 INS42 INS32 INS8 INS42 INS42 INS27 INS42 INS42 INS40 INS43 INS85 INS2 INS32 INS40 INS42 INS42 INS40 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 UPD42 UPD42 UPD42 MOV21 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS32 INS2 INS42 INS42 INS42 DEL40 DEL26 DEL29 DEL83 DEL39 DEL42 DEL59 DEL23 DEL42 DEL42 DEL42 DEL7 DEL21 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL66 DEL42 DEL42 DEL43 DEL69 DEL39 DEL69 DEL68 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL59 DEL23 DEL42 DEL42 DEL42 DEL32 DEL42 DEL40 DEL32 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL44 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL14 DEL59 DEL60 DEL42 DEL42 DEL45 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL45 DEL32 DEL21 DEL39 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL45 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL45 DEL32 DEL21 DEL42 DEL42 DEL45 DEL32 DEL42 DEL42 DEL32 DEL42 DEL45 DEL32 DEL21 DEL42 DEL38 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL45 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL42 DEL42 DEL45 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL45 DEL32 DEL42 DEL42 DEL32 DEL42 DEL45 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL40 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL38 DEL7 DEL21 DEL8 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL43 DEL42 DEL14 DEL40 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL42 DEL65 DEL42 DEL42 DEL42 DEL43 DEL69 DEL39 DEL69 DEL68 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL40 DEL27 DEL42 DEL27 DEL42 DEL42 DEL32 DEL38 DEL27 DEL9 DEL41 DEL8 DEL42 DEL42 DEL42 DEL48 DEL41 DEL8 DEL25 DEL8 DEL31 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL8 DEL70 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL43 DEL74 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL83 DEL44 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL8 DEL31 DEL42 DEL42 DEL42 DEL83 DEL43 DEL42 DEL43 DEL43 DEL74 DEL42 DEL44 DEL32 DEL8 DEL70 DEL8 DEL31
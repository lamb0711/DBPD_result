JCR-1799 updating events swallowed (CacheBehavior.OBSERVATION)   	
JCR-1783 incomplete changelog when combining move with removal of new destination parent

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@704361 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.state.ItemState;
+import org.apache.jackrabbit.jcr2spi.state.Status;
+import org.apache.jackrabbit.jcr2spi.state.ItemStateFactory;
-import org.apache.jackrabbit.jcr2spi.state.ItemState;
-import org.apache.jackrabbit.jcr2spi.state.ChangeLog;
-import org.apache.jackrabbit.jcr2spi.state.Status;
-import javax.jcr.RepositoryException;
+import javax.jcr.RepositoryException;
-                // only set 'target' if not already by upon resolution
-                if (!isAvailable()) {
+                // set the item state unless 'setItemState' has already been
+                // called by the ItemStateFactory (recall internalGetItemState)
+                if (internalGetItemState() == null) {
-     *
-    /**
-     *
-     * @param entry
-     */
-    static void removeEntry(HierarchyEntryImpl entry) {
-        ItemState state = entry.internalGetItemState();
-        if (state != null) {
-            state.setStatus(Status.REMOVED);
-        }
-    }
-        if (state == null || (denotesNode() && !state.isNode()) || (!denotesNode() && state.isNode())) {
+        ItemState currentState = internalGetItemState();
+        if (state == null || state == currentState || denotesNode() != state.isNode()) {
-        if (isAvailable()) {
-            throw new IllegalStateException("HierarchyEntry has already been resolved.");
+        if (currentState == null) {
+            // not connected yet to an item state. either a new entry or
+            // an unresolved hierarchy entry.
+            target = new WeakReference(state);
+        } else {
+            // was already resolved before -> merge the existing state
+            // with the passed state.
+            int currentStatus = currentState.getStatus();
+            boolean keepChanges = Status.isTransient(currentStatus) || Status.isStale(currentStatus);
+            boolean modified = currentState.merge(state, keepChanges);
+            if (currentStatus == Status.INVALIDATED) {
+                currentState.setStatus(Status.EXISTING);
+            } else if (modified) {
+                currentState.setStatus(Status.MODIFIED);
+            } // else: not modified. just leave status as it is.
-        target = new WeakReference(state);
-            // session-state TODO: only invalidate if existing?
-            if (state.getStatus() == Status.EXISTING) {
-                state.setStatus(Status.INVALIDATED);
-            }
+            state.setStatus(Status.INVALIDATED);
-                // revert state from overlayed
+                // revert state modifications
-                // revert state from overlayed
+                // revert state modifications
-                if (!denotesNode()) {
-                    parent.revertPropertyRemoval((PropertyEntry) this);
-                }
-                remove();
+                // however: don't remove the complete hierarchy
+                state.setStatus(Status.REMOVED);
+                parent.internalRemoveChildEntry(this);
-                // overlayed does not exist any more -> remove it
+                // overlayed does not exist any more -> reverting of pending
+                // transient changes (that lead to the stale status) can be
+                // omitted and the entry is complete removed instead.
-                // State was implicitely reverted
+                // State was implicitely reverted or external modifications
+                // reverted the modification.
-     /**
+    /**
-        ItemState state = internalGetItemState();
-        if (state == null) {
-            // nothing to do. entry will be validated upon resolution.
+        int status = getStatus();
+        if (status == Status._UNDEFINED_) {
+            // unresolved: entry will be loaded and validated upon resolution.
-        /*
-        if keepChanges is true only existing or invalidated states must be
-        updated. otherwise the state gets updated and might be marked 'Stale'
-        if transient changes are present and the workspace-state is modified.
-        */
-        // TODO: check again if 'reload' is not possible for transiently-modified state
-        if (!keepChanges || state.getStatus() == Status.EXISTING
-            || state.getStatus() == Status.INVALIDATED) {
-            // reload the workspace state from the persistent layer
-            state.reload(keepChanges);
+        if (Status.isTransient(status) || Status.isStale(status) || Status.isTerminal(status)) {
+            // transient || stale: avoid reloading
+            // new || terminal: cannot be reloaded from persistent layer anyway.
+            log.debug("Skip reload for item with status " + Status.getName(status) + ".");
+            return;
+        }
+        /**
+         * Retrieved a fresh ItemState from the persistent layer. Which will
+         * then be merged into the current state.
+         */
+        try {
+            ItemStateFactory isf = factory.getItemStateFactory();
+            if (denotesNode()) {
+                NodeEntry ne = (NodeEntry) this;
+                isf.createNodeState(ne.getWorkspaceId(), ne);
+            } else {
+                PropertyEntry pe = (PropertyEntry) this;
+                isf.createPropertyState(pe.getWorkspaceId(), pe);
+            }
+        } catch (ItemNotFoundException e) {
+            // remove hierarchyEntry including all children
+            log.debug("Item '" + getName() + "' cannot be found on the persistent layer -> remove.");
+            remove();
+        } catch (RepositoryException e) {
+            // TODO: rather throw?
+            log.error("Exception while reloading item: " + e);
-            // check if upon reload the item has been removed -> nothing to do
-            if (Status.isTerminal(state.getStatus())) {
-                return;
-            }
-                remove();
+                state.setStatus(Status.REMOVED);
+                parent.internalRemoveChildEntry(this);
-
-    /**
-     * {@inheritDoc}
-     * @see HierarchyEntry#collectStates(ChangeLog, boolean)
-     */
-    public void collectStates(ChangeLog changeLog, boolean throwOnStale) throws InvalidItemStateException {
-        ItemState state = internalGetItemState();
-        if (state == null) {
-            // nothing to do
-            return;
-        }
-
-        if (throwOnStale && Status.isStale(state.getStatus())) {
-            String msg = "Cannot save changes: " + state + " has been modified externally.";
-            log.debug(msg);
-            throw new InvalidItemStateException(msg);
-        }
-        // only interested in transient modifications or stale states
-        switch (state.getStatus()) {
-            case Status.NEW:
-                changeLog.added(state);
-                break;
-            case Status.EXISTING_MODIFIED:
-            case Status.STALE_MODIFIED:
-            case Status.STALE_DESTROYED:
-                changeLog.modified(state);
-                break;
-            case Status.EXISTING_REMOVED:
-                changeLog.deleted(state);
-                break;
-            default:
-                log.debug("Collecting states: Ignored ItemState with status " + Status.getName(state.getStatus()));
-        }
-    }

MOV26 MOV26 MOV26 MOV26 MOV31 UPD40 INS31 MOV29 UPD83 MOV83 INS83 MOV39 UPD42 MOV42 MOV44 INS8 MOV8 MOV29 UPD42 MOV44 MOV44 MOV60 MOV25 INS25 MOV60 INS25 INS54 UPD27 MOV27 MOV8 INS8 MOV27 INS10 INS21 INS39 MOV8 INS27 INS8 INS8 INS12 INS12 MOV21 INS21 UPD42 UPD27 MOV27 UPD42 MOV21 INS60 INS60 INS60 INS25 MOV32 UPD42 UPD42 INS40 INS32 MOV32 INS32 MOV21 INS41 INS60 INS25 INS44 INS8 INS44 INS8 INS32 INS27 MOV32 INS39 INS59 INS39 INS59 INS39 INS59 INS27 INS8 INS25 UPD42 UPD42 INS40 INS42 UPD42 INS52 UPD42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS43 INS59 MOV32 INS8 INS8 INS43 INS42 INS21 MOV21 INS43 INS42 INS21 INS42 INS42 INS52 INS42 INS42 INS42 INS32 INS42 INS27 INS42 INS32 INS42 UPD40 MOV40 INS21 INS42 MOV8 INS27 UPD42 MOV42 INS42 INS32 INS60 INS21 INS60 INS21 INS42 MOV32 INS42 INS32 INS27 UPD42 MOV42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS45 INS32 INS45 UPD42 MOV42 UPD42 MOV42 INS43 INS59 MOV32 INS43 INS59 MOV32 INS42 INS42 INS27 INS32 INS33 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 INS40 UPD42 MOV42 INS42 INS42 INS42 INS42 INS11 INS42 UPD42 INS32 UPD42 INS42 INS42 MOV11 INS42 UPD42 INS32 UPD42 UPD45 INS45 INS45 INS42 UPD42 MOV42 UPD42 UPD42 INS40 INS43 INS52 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 DEL32 DEL38 DEL42 DEL65 DEL29 DEL42 DEL43 DEL42 DEL44 DEL25 DEL8 DEL31 DEL42 DEL42 DEL42 DEL32 DEL38 DEL27 DEL36 DEL42 DEL32 DEL38 DEL36 DEL42 DEL83 DEL83 DEL39 DEL42 DEL32 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL8 DEL31 DEL42 DEL42 DEL32 DEL40 DEL27 DEL25 DEL8 DEL38 DEL21 DEL8 DEL25 DEL10 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL41 DEL8 DEL25 DEL42 DEL38 DEL42 DEL42 DEL32 DEL27 DEL27 DEL32 DEL40 DEL27 DEL27 DEL25 DEL8 DEL31 DEL65 DEL65 DEL42 DEL42 DEL42 DEL43 DEL69 DEL39 DEL69 DEL68 DEL65 DEL29 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL33 DEL41 DEL8 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL27 DEL42 DEL43 DEL42 DEL45 DEL42 DEL45 DEL27 DEL59 DEL60 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL32 DEL40 DEL49 DEL42 DEL42 DEL42 DEL32 DEL21 DEL10 DEL40 DEL49 DEL40 DEL49 DEL40 DEL49 DEL21 DEL10 DEL40 DEL49 DEL21 DEL10 DEL49 DEL21 DEL50 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL25
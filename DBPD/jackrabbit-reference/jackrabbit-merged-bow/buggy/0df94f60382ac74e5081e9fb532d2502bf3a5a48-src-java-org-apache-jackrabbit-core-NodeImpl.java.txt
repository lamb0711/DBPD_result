- fixing verisoning issues (version labels still missing)

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@151144 13f79535-47bb-0310-9956-ffa450edef68

-        if (isNodeType(NodeTypeRegistry.MIX_REFERENCEABLE)) {
-            String uuid = ((NodeState) state).getUUID();
-        }
-/*
+        // aquire session of other workspace (throws NoSuchWorkspaceException)
-        SessionImpl srcSession = rep.getSystemSession(srcWorkspaceName);
-        Node root = session.getRootNode();
-        // if (isRepositoryRoot()) [don't know, if this works correctly with workspaces]
-        if (isSame(root)) {
-            return (NodeImpl) srcSession.getRootNode();
-        }
-
-        // if this node is referenceable, return the corresponding one
-        if (isNodeType(NodeTypeRegistry.MIX_REFERENCEABLE)) {
-            try {
-                return (NodeImpl) srcSession.getNodeByUUID(getUUID());
-            } catch (ItemNotFoundException e) {
-                return null;
-            }
-        }
+        SessionImpl srcSession = rep.getSystemSession(workspaceName);
-        while (!m1.isSame(root) && !m1.isNodeType(NodeTypeRegistry.MIX_REFERENCEABLE)) {
+        while (!m1.isRepositoryRoot() && !m1.isNodeType(NodeTypeRegistry.MIX_REFERENCEABLE)) {
-        // special treatment for root
-        if (m1.isSame(root)) {
-            return (NodeImpl) srcSession.getItem(getPath());
+
+        // if root is common ancestor, corresponding path is same as ours
+        if (m1.isRepositoryRoot()) {
+            return getPath();
-        // calculate relative path. please note, that this cannot be done
+        // get corresponding ancestor
+        Node m2 = srcSession.getNodeByUUID(m1.getUUID());
+
+        // return path of m2, if m1 == n1
+        if (m1 == this) {
+            return m2.getPath();
+        }
+
+        // calculate relative path from the referenceable ancestor to this node.
+        // please note, that this cannot be done
+
+        // @todo: replace as soon as implemented
+        // Path relPath = m1.getPrimaryPath().getRelativePath(getPrimaryPath());
+
-        try {
-            return (NodeImpl) srcSession.getNodeByUUID(m1.getUUID()).getNode(relPath);
-        } catch (ItemNotFoundException e) {
-            return null;
-        }
-*/
-        // @todo implement Node#getCorrespondingNodePath
-        throw new RepositoryException("not yet implemented");
+        return m2.getNode(relPath).getPath();
-        // @todo FIXME semantics of isCheckedOut() have changed!
-        if (!isCheckedOut()) {
+        if (!internalIsCheckedOut()) {
-            String msg = "Unable to checkin node. Clear 'jcr:mergeFailed' first. " + safeGetJCRPath();
+            String msg = "Unable to checkin node. Node has unresolved merge operation. " + safeGetJCRPath();
-        NodeImpl srcNode = getCorrespondingNode(srcWorkspaceName);
+        // @todo FIXME need to get session with same credentials as current
+        SessionImpl srcSession = rep.getSystemSession(srcWorkspaceName);
+
+        NodeImpl srcNode = getCorrespondingNode(srcSession);
-        NodeImpl srcNode = doMergeTest(srcWorkspace, bestEffort);
+        // if same workspace, ignore
+        if (srcWorkspace.equals(session.getWorkspace().getName())) {
+            return;
+        }
+
+        // @todo FIXME need to get session with same credentials as current
+        SessionImpl srcSession = rep.getSystemSession(srcWorkspace);
+
+        NodeImpl srcNode = doMergeTest(srcSession, bestEffort);
+
-        save();
+        // session.save/revert is done in internal restore
-        if (!version.getParent().getUUID().equals(getVersionHistory().getUUID())) {
+        // TODO: change if Version.getContainingVersionHistory() is introduced
+        if (!version.getParent().isSame(getVersionHistory())) {
+
-        save();
+        // session.save/revert is done in internal restore
-            node.getParent().save();
+            // session.save/revert is done in internal restore
-
-    /**
-     * Returns the corresponding node in the <code>scrWorkspaceName</code> of
-     * this node.
+/**
+     * Returns the corresponding node in the workspace of the given session.
-     * @param srcWorkspaceName
+     * @param srcSession
-    private NodeImpl getCorrespondingNode(String srcWorkspaceName)
-            throws NoSuchWorkspaceException, AccessDeniedException,
-            RepositoryException {
+    private NodeImpl getCorrespondingNode(Session srcSession)
+            throws AccessDeniedException, RepositoryException {
-        // @todo FIXME need to get session with same credentials as current
-        SessionImpl srcSession = rep.getSystemSession(srcWorkspaceName);
-        Node root = session.getRootNode();
-        // if (isRepositoryRoot()) [don't know, if this works correctly with workspaces]
-        if (isSame(root)) {
-            return (NodeImpl) srcSession.getRootNode();
+    // search nearest ancestor that is referenceable
+    NodeImpl m1 = this;
+    while (!m1.isRepositoryRoot() && !m1.isNodeType(NodeTypeRegistry.MIX_REFERENCEABLE)) {
+        m1 = (NodeImpl) m1.getParent();
+    }
+
+    try {
+        // get corresponding ancestor
+        NodeImpl m2 = (NodeImpl) srcSession.getNodeByUUID(m1.getUUID());
+
+        // return path of m2, if m1 == n1
+        if (m1 == this) {
+            return m2;
-        // if this node is referenceable, return the corresponding one
-        if (isNodeType(NodeTypeRegistry.MIX_REFERENCEABLE)) {
-            try {
-                return (NodeImpl) srcSession.getNodeByUUID(getUUID());
-            } catch (ItemNotFoundException e) {
-                return null;
-            }
-        }
-
-        // search nearest ancestor that is referenceable
-        NodeImpl m1 = this;
-        while (!m1.isSame(root) && !m1.isNodeType(NodeTypeRegistry.MIX_REFERENCEABLE)) {
-            m1 = (NodeImpl) m1.getParent();
-        }
-        // special treatment for root
-        if (m1.isSame(root)) {
-            return (NodeImpl) srcSession.getItem(getPath());
-        }
-
-        // calculate relative path. please note, that this cannot be done
+        // calculate relative path from the referenceable ancestor to this node.
+        // please note, that this cannot be done
+
+        // @todo: replace as soon as implemented
+        // Path relPath = m1.getPrimaryPath().getRelativePath(getPrimaryPath());
+
-        try {
-            return (NodeImpl) srcSession.getNodeByUUID(m1.getUUID()).getNode(relPath);
-        } catch (ItemNotFoundException e) {
-            return null;
-        }
+        return (NodeImpl) m2.getNode(relPath);
+
+    } catch (ItemNotFoundException e) {
+        return null;
+}
-     * @param srcWorkspace
+     * @param srcSession
-    private NodeImpl doMergeTest(String srcWorkspace, boolean bestEffort)
+    private NodeImpl doMergeTest(Session srcSession, boolean bestEffort)
-        NodeImpl srcNode = getCorrespondingNode(srcWorkspace);
+        NodeImpl srcNode = getCorrespondingNode(srcSession);
-        internalRestore(((VersionImpl) version).getInternalVersion(), vsel, removeExisting);
-    }
-
-    /**
-     * Checks if any frozen uuid in the given frozen node or its descendants
-     * collides with the one in the workspace. if 'removeExisting' is true,
-     * collisions will be removed, otherwise an ItemExistsException is thrown.
-     * If a frozen version history is already restored outside this nodes
-     * subtree, a exception is thrown, too, if the removeExisting is true.
-     * @param f
-     * @param removeExisting
-     * @throws RepositoryException
-     */
-    private void checkUUIDCollisions(InternalFrozenNode f, boolean removeExisting)
-            throws RepositoryException {
-
-        if (itemMgr.itemExists(new NodeId(f.getFrozenUUID()))) {
-            NodeImpl node = (NodeImpl) session.getNodeByUUID(f.getFrozenUUID());
-            if (removeExisting) {
-                node.remove();
-            } else {
-                throw new ItemExistsException("Unable to restore. UUID collides with " + node.safeGetJCRPath());
+        try {
+            internalRestore(((VersionImpl) version).getInternalVersion(), vsel, removeExisting);
+        } catch (RepositoryException e) {
+            // revert session
+            try {
+                log.error("reverting changes applied during restore...");
+                session.refresh(false);
+            } catch (RepositoryException e1) {
+                // ignore this
+            throw e;
-        InternalFreeze[] fs = f.getFrozenChildNodes();
-        for (int i=0; i<fs.length; i++) {
-            if (fs[i] instanceof InternalFrozenNode) {
-                checkUUIDCollisions((InternalFrozenNode) fs[i], removeExisting);
-            } else if (!removeExisting) {
-                InternalFrozenVersionHistory fh = (InternalFrozenVersionHistory) fs[i];
-                VersionHistoryImpl history = (VersionHistoryImpl) session.getNodeByUUID(fh.getVersionHistoryId());
-                String nodeId = history.getVersionedUUID();
-
-                // check if representing vh already exists somewhere
-                if (itemMgr.itemExists(new NodeId(nodeId))) {
-                    NodeImpl n = (NodeImpl) session.getNodeByUUID(nodeId);
-                    try {
-                        if (!n.getPrimaryPath().isDescendantOf(getPrimaryPath())) {
-                            throw new ItemExistsException("Unable to restore. Same node already restored at " + n.safeGetJCRPath());
-                        }
-                    } catch (MalformedPathException e) {
-                        throw new RepositoryException(e);
-                    }
-                }
-            }
-        }
+        session.save();
-    private void internalRestore(InternalVersion version, VersionSelector vsel, boolean removeExisting)
+    private void internalRestore(InternalVersion version, VersionSelector vsel,
+                                 boolean removeExisting)
-        // first check, if any uuid conflicts would occurr
-        checkUUIDCollisions(version.getFrozenNode(), removeExisting);
-
-        internalSetProperty(VersionManager.PROPNAME_PREDECESSORS, new InternalValue[0]);
+        internalSetProperty(VersionManager.PROPNAME_PREDECESSORS, new InternalValue[0], PropertyType.REFERENCE);
-     * Creates the frozen state from a node
+     * Restores the properties and child nodes from the frozen state.
+     * @param vsel
+     * @param removeExisting
+
+
+
-        // remove additional
+        // remove additional mixins
-        // first delete all non frozen version histories
+        // first delete all non frozen version histories, ie. all OPV!=Version
-            // this is a bit lousy
-            boolean found = false;
-            for (int i=0; i<frozenNodes.length; i++) {
-                InternalFreeze child = frozenNodes[i];
-                if (child instanceof InternalFrozenVersionHistory) {
-                    if (n.internalGetUUID().equals(child.getId())) {
-                        found = true;
-                        break;
-                    }
-                }
-            }
-            if (!found) {
+            if (n.getDefinition().getOnParentVersion()==OnParentVersionAction.COPY) {
+
+        // now restore the frozen ones
+                // check for existing
+                if (f.getFrozenUUID()!=null) {
+                    try {
+                        NodeImpl existing = (NodeImpl) session.getNodeByUUID(f.getFrozenUUID());
+                        if (removeExisting) {
+                            existing.remove();
+                        } else {
+                            // since we delete the OPV=Copy children beforehand, all
+                            // found nodes must be outside of this tree
+                            throw new ItemExistsException("Unable to restore node, item already exists outside of restored tree: " + existing.safeGetJCRPath());
+                        }
+                    } catch (ItemNotFoundException e) {
+                        // ignore, item with uuid does not exist
+                    }
+                }
+
-                String nodeId = history.getVersionedUUID();
+                String nodeId = history.getVersionableUUID();
-                        orderBefore(n.getName(), "");
+                        // orderBefore(n.getName(), "");

MOV31 INS31 MOV29 MOV83 MOV43 MOV42 MOV44 MOV43 MOV43 MOV43 MOV43 MOV8 MOV43 UPD42 MOV43 MOV43 INS8 MOV21 INS61 INS25 INS60 MOV41 INS60 INS25 INS60 INS60 MOV65 MOV65 MOV65 MOV65 UPD43 UPD42 INS60 MOV61 INS54 UPD43 UPD42 INS54 INS21 INS65 MOV65 INS27 INS8 MOV32 INS8 MOV43 INS59 INS27 INS32 INS43 INS59 INS43 INS32 INS8 UPD43 MOV43 INS59 MOV43 MOV59 UPD66 INS66 INS66 INS66 INS66 INS66 UPD66 INS66 UPD66 UPD66 INS66 UPD66 INS66 INS66 UPD42 UPD42 INS43 INS59 INS8 MOV12 UPD42 UPD42 MOV8 INS12 INS32 UPD66 INS42 INS8 INS38 INS38 INS21 INS42 UPD42 INS41 INS42 INS32 INS42 INS52 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS41 UPD42 INS42 INS32 MOV32 UPD42 MOV42 INS42 INS52 MOV60 INS25 INS60 INS41 INS44 INS8 INS42 INS42 INS40 MOV60 MOV25 UPD42 INS32 INS32 INS7 MOV32 MOV42 MOV42 MOV32 INS32 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 UPD42 INS32 INS42 INS42 INS42 INS42 UPD42 INS42 MOV32 MOV43 INS27 MOV8 MOV43 INS59 INS11 UPD42 MOV43 INS42 INS54 INS53 INS27 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS40 INS42 INS11 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 UPD42 MOV11 UPD42 MOV42 INS52 INS41 UPD42 MOV42 INS32 MOV43 INS32 INS8 INS12 INS42 INS32 INS40 INS25 MOV43 MOV32 UPD45 MOV32 INS42 INS32 UPD42 MOV42 INS27 UPD42 MOV42 INS42 UPD42 MOV42 INS21 INS21 INS44 INS8 INS32 INS42 INS27 INS8 UPD42 UPD42 UPD42 MOV42 INS32 INS34 INS32 INS32 MOV43 INS42 INS42 INS42 MOV32 INS33 INS54 MOV32 UPD42 MOV42 INS42 INS42 INS45 INS42 INS42 INS9 INS8 INS12 UPD42 UPD42 MOV60 INS25 INS44 INS8 UPD42 INS42 INS8 INS8 INS43 INS42 UPD42 INS21 INS53 INS42 INS32 INS14 INS42 INS42 MOV43 INS27 INS45 INS32 INS42 INS42 DEL42 DEL32 DEL59 DEL60 DEL32 DEL11 DEL41 DEL8 DEL25 DEL32 DEL11 DEL41 DEL8 DEL42 DEL43 DEL42 DEL44 DEL33 DEL41 DEL8 DEL12 DEL54 DEL8 DEL25 DEL40 DEL42 DEL42 DEL42 DEL32 DEL32 DEL11 DEL8 DEL54 DEL42 DEL40 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL59 DEL60 DEL8 DEL25 DEL45 DEL14 DEL53 DEL8 DEL31 DEL60 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL32 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL42 DEL65 DEL39 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL42 DEL2 DEL11 DEL42 DEL32 DEL21 DEL42 DEL42 DEL43 DEL14 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL45 DEL42 DEL42 DEL32 DEL27 DEL14 DEL53 DEL8 DEL25 DEL8 DEL25 DEL39 DEL42 DEL34 DEL59 DEL58 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL42 DEL43 DEL62 DEL42 DEL38 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL2 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL11 DEL59 DEL60 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL43 DEL42 DEL14 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL32 DEL32 DEL38 DEL45 DEL32 DEL27 DEL14 DEL53 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL25 DEL25 DEL8 DEL24 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL31 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL42 DEL38 DEL39 DEL42 DEL9 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL42 DEL42 DEL2 DEL59 DEL60 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL9 DEL7 DEL21 DEL10 DEL8 DEL25 DEL8 DEL25 DEL8 DEL24 DEL8 DEL42 DEL42 DEL42 DEL32 DEL45 DEL32 DEL21
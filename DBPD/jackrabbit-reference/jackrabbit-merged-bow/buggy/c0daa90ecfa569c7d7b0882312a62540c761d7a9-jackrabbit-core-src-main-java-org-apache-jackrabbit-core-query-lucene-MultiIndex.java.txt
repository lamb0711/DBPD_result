JCR-2035: IndexingQueue not checked on initial index creation

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@760906 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.commons.conversion.PathResolver;
+import org.apache.jackrabbit.spi.commons.conversion.DefaultNamePathResolver;
+     * @param rootPath the path of the node from where to start.
-    void createInitialIndex(ItemStateManager stateMgr, NodeId rootId, Path rootPath)
+    void createInitialIndex(ItemStateManager stateMgr,
+                            NodeId rootId,
+                            Path rootPath)
+                long count = 0;
-                createIndex(rootState, rootPath, stateMgr);
+                count = createIndex(rootState, rootPath, stateMgr, count);
+                log.info("Created initial index for {} nodes", new Long(count));
+     * @param path     the path of the current node.
+     * @param count    the number of nodes already indexed.
+     * @return the number of nodes indexed so far.
-    private void createIndex(NodeState node, Path path, ItemStateManager stateMgr)
+    private long createIndex(NodeState node,
+                             Path path,
+                             ItemStateManager stateMgr,
+                             long count)
-            return;
+            return count;
+        if (++count % 100 == 0) {
+            PathResolver resolver = new DefaultNamePathResolver(
+                    handler.getContext().getNamespaceRegistry());
+            log.info("indexing... {} ({})", resolver.getJCRPath(path), new Long(count));
+        }
+        if (count % 10 == 0) {
+            checkIndexingQueue(true);
+        }
-                createIndex(childState, childPath, stateMgr);
+                count = createIndex(childState, childPath, stateMgr, count);
+        return count;
-     * Checks the indexing queue for finished text extrator jobs and
-     * updates the index accordingly if there are any new ones.
+     * Checks the indexing queue for finished text extrator jobs and updates the
+     * index accordingly if there are any new ones. This method is synchronized
+     * and should only be called by the timer task that periodically checks if
+     * there are documents ready in the indexing queue. A new transaction is
+     * used when documents are transfered from the indexing queue to the index.
+        checkIndexingQueue(false);
+    }
+
+    /**
+     * Checks the indexing queue for finished text extrator jobs and updates the
+     * index accordingly if there are any new ones.
+     *
+     * @param transactionPresent whether a transaction is in progress and the
+     *                           current {@link #getTransactionId()} should be
+     *                           used. If <code>false</code> a new transaction
+     *                           is created when documents are transfered from
+     *                           the indexing queue to the index.
+     */
+    private void checkIndexingQueue(boolean transactionPresent) {
-            log.debug("updating index with {} nodes from indexing queue.",
+            log.info("updating index with {} nodes from indexing queue.",
-            Iterator it = finished.keySet().iterator();
-            while (it.hasNext()) {
+            for (Iterator it = finished.keySet().iterator(); it.hasNext(); ) {
-                update(finished.keySet(), finished.values());
+                if (transactionPresent) {
+                    for (Iterator it = finished.keySet().iterator(); it.hasNext(); ) {
+                        executeAndLog(new DeleteNode(getTransactionId(), (UUID) it.next()));
+                    }
+                    for (Iterator it = finished.values().iterator(); it.hasNext(); ) {
+                        executeAndLog(new AddNode(
+                                getTransactionId(), (Document) it.next()));
+                    }
+                } else {
+                    update(finished.keySet(), finished.values());
+                }

INS26 INS26 INS40 INS40 INS31 UPD39 INS44 INS29 INS83 INS83 INS39 INS42 INS8 INS44 INS65 INS65 INS65 INS65 INS39 INS42 INS25 INS25 INS41 INS65 INS21 INS65 INS39 INS42 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS27 INS8 INS27 INS8 INS42 INS66 INS66 INS66 INS66 INS66 INS32 UPD66 UPD66 INS42 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS27 INS34 INS60 INS21 INS27 INS34 INS21 INS42 INS9 INS68 INS24 INS42 INS38 INS34 INS43 INS59 INS32 INS42 INS34 INS32 INS42 INS58 MOV32 MOV8 INS8 INS60 INS21 INS42 INS42 INS42 INS14 INS42 INS42 INS45 INS32 INS14 INS42 INS9 UPD42 MOV43 MOV59 INS25 INS39 INS59 INS7 INS32 INS43 INS32 INS42 INS42 INS42 INS43 INS42 INS7 INS42 INS8 MOV8 INS42 INS34 INS42 INS32 INS42 INS42 INS45 INS14 INS42 INS32 INS42 INS42 INS42 INS32 INS24 INS24 MOV42 MOV42 MOV42 MOV42 INS42 INS43 INS42 INS42 INS42 MOV42 MOV42 MOV42 MOV42 INS42 INS58 INS32 INS8 INS58 INS32 INS8 INS42 INS43 INS59 INS42 INS42 INS21 INS43 INS59 INS42 INS42 INS21 INS42 INS42 INS32 INS32 INS42 INS42 INS32 INS32 INS32 INS42 INS42 INS14 INS32 INS42 INS42 INS14 INS42 INS42 INS43 INS32 INS11 INS42 INS42 INS43 INS32 INS11 INS42 INS42 INS43 INS32 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS42 DEL32 DEL32 DEL83 DEL60 DEL61
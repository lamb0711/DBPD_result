cleaning up NodeTypeRegistry and EffectiveNodeType code:
- removing NodeTypeRegistry field from EffectiveNodeType
- reviewing access modifiers
- make those methods static that don't affect the state of an instance
- etc etc

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@414843 13f79535-47bb-0310-9956-ffa450edef68

-     * FIXME
-     * flag used to temporarily disable checking that auto-created properties
-     * have a default value; this check has to be disabled while validating
-     * built-in node types because there are properties defined in built-in
-     * node types which are auto-created but don't have a fixed default value
-     * that can be exposed in a property definition because it is
-     * system-generated (e.g. jcr:primaryType in nt:base).
-     */
-    private boolean checkAutoCreatePropHasDefault = true;
-
-    /**
-    /**
-     * Protected constructor
-     *
-     * @param nsReg
-     * @param ntStore
-     * @throws RepositoryException
-     */
-    protected NodeTypeRegistry(NamespaceRegistry nsReg, FileSystem ntStore)
-            throws RepositoryException {
-        this.nsReg = nsReg;
-        this.ntStore = ntStore;
-        customNodeTypesResource =
-                new FileSystemResource(this.ntStore, CUSTOM_NODETYPES_RESOURCE_NAME);
-        try {
-            // make sure path to resource exists
-            if (!customNodeTypesResource.exists()) {
-                customNodeTypesResource.makeParentDirs();
-            }
-        } catch (FileSystemException fse) {
-            String error = "internal error: invalid resource: "
-                    + customNodeTypesResource.getPath();
-            log.debug(error);
-            throw new RepositoryException(error, fse);
-        }
-
-        entCache = new EffectiveNodeTypeCache();
-        registeredNTDefs = new HashMap();
-        propDefs = new HashMap();
-        nodeDefs = new HashMap();
-
-        // setup definition of root node
-        rootNodeDef = createRootNodeDef();
-        nodeDefs.put(rootNodeDef.getId(), rootNodeDef);
-
-        // load and register pre-defined (i.e. built-in) node types
-        /**
-         * temporarily disable checking that auto-created properties have
-         * default values
-         */
-        checkAutoCreatePropHasDefault = false;
-        builtInNTDefs = new NodeTypeDefStore();
-        try {
-            // load built-in node type definitions
-            loadBuiltInNodeTypeDefs(builtInNTDefs);
-
-            // validate & register built-in node types
-            internalRegister(builtInNTDefs.all());
-        } catch (InvalidNodeTypeDefException intde) {
-            String error =
-                    "internal error: invalid built-in node type definition stored in "
-                    + BUILTIN_NODETYPES_RESOURCE_PATH;
-            log.debug(error);
-            throw new RepositoryException(error, intde);
-        } finally {
-            /**
-             * re-enable checking that auto-created properties have default values
-             */
-            checkAutoCreatePropHasDefault = true;
-        }
-
-        // load and register custom node types
-        customNTDefs = new NodeTypeDefStore();
-
-        // load custom node type definitions
-        loadCustomNodeTypeDefs(customNTDefs);
-
-        // validate & register custom node types
-        try {
-            internalRegister(customNTDefs.all());
-        } catch (InvalidNodeTypeDefException intde) {
-            String error =
-                    "internal error: invalid custom node type definition stored in "
-                    + customNodeTypesResource.getPath();
-            log.debug(error);
-            throw new RepositoryException(error, intde);
-        }
-    }
-
-    private static NodeDef createRootNodeDef() {
-        NodeDefImpl def = new NodeDefImpl();
-
-        // FIXME need a fake declaring node type:
-        // rep:root is not quite correct but better than a non-existing node type
-        def.setDeclaringNodeType(QName.REP_ROOT);
-        def.setRequiredPrimaryTypes(new QName[]{QName.REP_ROOT});
-        def.setDefaultPrimaryType(QName.REP_ROOT);
-        def.setMandatory(true);
-        def.setProtected(false);
-        def.setOnParentVersion(OnParentVersionAction.VERSION);
-        def.setAllowsSameNameSiblings(false);
-        def.setAutoCreated(true);
-        return def;
-    }
-
-    private EffectiveNodeType internalRegister(NodeTypeDef ntd)
-            throws InvalidNodeTypeDefException, RepositoryException {
-        QName name = ntd.getName();
-        if (name != null && registeredNTDefs.containsKey(name)) {
-            String msg = name + " already exists";
-            log.debug(msg);
-            throw new InvalidNodeTypeDefException(msg);
-        }
-
-        EffectiveNodeType ent = validateNodeTypeDef(ntd, entCache, registeredNTDefs);
-
-        // store new effective node type instance
-        entCache.put(ent);
-
-        // register clone of node type definition
-        ntd = (NodeTypeDef) ntd.clone();
-        registeredNTDefs.put(name, ntd);
-
-        // store property & child node definitions of new node type by id
-        PropDef[] pda = ntd.getPropertyDefs();
-        for (int i = 0; i < pda.length; i++) {
-            propDefs.put(pda[i].getId(), pda[i]);
-        }
-        NodeDef[] nda = ntd.getChildNodeDefs();
-        for (int i = 0; i < nda.length; i++) {
-            nodeDefs.put(nda[i].getId(), nda[i]);
-        }
-
-        return ent;
-    }
-
-    /**
-     * Validates and registers the specified collection of <code>NodeTypeDef</code>
-     * objects. An <code>InvalidNodeTypeDefException</code> is thrown if the
-     * validation of any of the contained <code>NodeTypeDef</code> objects fails.
-     * <p/>
-     * Note that in the case an exception is thrown no node type will be
-     * eventually registered.
-     *
-     * @param ntDefs collection of <code>NodeTypeDef</code> objects
-     * @throws InvalidNodeTypeDefException
-     * @throws RepositoryException
-     * @see #registerNodeType
-     */
-    private synchronized void internalRegister(Collection ntDefs)
-            throws InvalidNodeTypeDefException, RepositoryException {
-
-        // @todo review
-
-        // cache of pre-built aggregations of node types
-        EffectiveNodeTypeCache anEntCache = (EffectiveNodeTypeCache) entCache.clone();
-
-        // map of node type names and node type definitions
-        Map aRegisteredNTDefCache = new HashMap(registeredNTDefs);
-
-        // temporarily register the node type definition
-        // and do some preliminary checks
-        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
-            NodeTypeDef ntd = (NodeTypeDef) iter.next();
-            QName name = ntd.getName();
-            if (name != null && registeredNTDefs.containsKey(name)) {
-                String msg = name + " already exists";
-                log.debug(msg);
-                throw new InvalidNodeTypeDefException(msg);
-            }
-            // add definition to temporary cache
-            aRegisteredNTDefCache.put(ntd.getName(), ntd);
-        }
-
-        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
-            NodeTypeDef ntd = (NodeTypeDef) iter.next();
-
-            EffectiveNodeType ent = validateNodeTypeDef(ntd, anEntCache, aRegisteredNTDefCache);
-
-            // store new effective node type instance
-            anEntCache.put(ent);
-        }
-
-        // todo add newly created ENTs to entCache
-
-        // since no exception was thrown so far the definitions are assumed to be valid
-        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
-            NodeTypeDef ntd = (NodeTypeDef) iter.next();
-
-            // register clone of node type definition
-            ntd = (NodeTypeDef) ntd.clone();
-            registeredNTDefs.put(ntd.getName(), ntd);
-            // store property & child node definitions of new node type by id
-            PropDef[] pda = ntd.getPropertyDefs();
-            for (int i = 0; i < pda.length; i++) {
-                propDefs.put(pda[i].getId(), pda[i]);
-            }
-            NodeDef[] nda = ntd.getChildNodeDefs();
-            for (int i = 0; i < nda.length; i++) {
-                nodeDefs.put(nda[i].getId(), nda[i]);
-            }
-        }
-    }
-
-    private void internalUnregister(QName name) throws NoSuchNodeTypeException {
-        NodeTypeDef ntd = (NodeTypeDef) registeredNTDefs.get(name);
-        if (ntd == null) {
-            throw new NoSuchNodeTypeException(name.toString());
-        }
-        registeredNTDefs.remove(name);
-        /**
-         * remove all affected effective node types from aggregates cache
-         * (copy keys first to prevent ConcurrentModificationException)
-         */
-        ArrayList keys = new ArrayList(entCache.keySet());
-        for (Iterator keysIter = keys.iterator(); keysIter.hasNext();) {
-            EffectiveNodeTypeCache.WeightedKey k =
-                    (EffectiveNodeTypeCache.WeightedKey) keysIter.next();
-            EffectiveNodeType ent = entCache.get(k);
-            if (ent.includesNodeType(name)) {
-                entCache.remove(k);
-            }
-        }
-
-        // remove property & child node definitions
-        PropDef[] pda = ntd.getPropertyDefs();
-        for (int i = 0; i < pda.length; i++) {
-            propDefs.remove(pda[i].getId());
-        }
-        NodeDef[] nda = ntd.getChildNodeDefs();
-        for (int i = 0; i < nda.length; i++) {
-            nodeDefs.remove(nda[i].getId());
-        }
-    }
-
-    private void internalUnregister(Collection ntNames)
-            throws NoSuchNodeTypeException {
-        for (Iterator iter = ntNames.iterator(); iter.hasNext();) {
-            QName name = (QName) iter.next();
-            internalUnregister(name);
-        }
-    }
-
-    /**
-     * Add a <code>NodeTypeRegistryListener</code>
-     *
-     * @param listener the new listener to be informed on (un)registration
-     *                 of node types
-     */
-    public void addListener(NodeTypeRegistryListener listener) {
-        if (!listeners.containsKey(listener)) {
-            listeners.put(listener, listener);
-        }
-    }
-
-    /**
-     * Remove a <code>NodeTypeRegistryListener</code>
-     *
-     * @param listener an existing listener
-     */
-    public void removeListener(NodeTypeRegistryListener listener) {
-        listeners.remove(listener);
-    }
-
-    /**
-     * Notify the listeners that a node type <code>ntName</code> has been registered.
-     */
-    private void notifyRegistered(QName ntName) {
-        // copy listeners to array to avoid ConcurrentModificationException
-        NodeTypeRegistryListener[] la =
-                new NodeTypeRegistryListener[listeners.size()];
-        Iterator iter = listeners.values().iterator();
-        int cnt = 0;
-        while (iter.hasNext()) {
-            la[cnt++] = (NodeTypeRegistryListener) iter.next();
-        }
-        for (int i = 0; i < la.length; i++) {
-            if (la[i] != null) {
-                la[i].nodeTypeRegistered(ntName);
-            }
-        }
-    }
-
-    /**
-     * Notify the listeners that a node type <code>ntName</code> has been re-registered.
-     */
-    private void notifyReRegistered(QName ntName) {
-        // copy listeners to array to avoid ConcurrentModificationException
-        NodeTypeRegistryListener[] la =
-                new NodeTypeRegistryListener[listeners.size()];
-        Iterator iter = listeners.values().iterator();
-        int cnt = 0;
-        while (iter.hasNext()) {
-            la[cnt++] = (NodeTypeRegistryListener) iter.next();
-        }
-        for (int i = 0; i < la.length; i++) {
-            if (la[i] != null) {
-                la[i].nodeTypeReRegistered(ntName);
-            }
-        }
-    }
-
-    /**
-     * Notify the listeners that a node type <code>ntName</code> has been unregistered.
-     */
-    private void notifyUnregistered(QName ntName) {
-        // copy listeners to array to avoid ConcurrentModificationException
-        NodeTypeRegistryListener[] la =
-                new NodeTypeRegistryListener[listeners.size()];
-        Iterator iter = listeners.values().iterator();
-        int cnt = 0;
-        while (iter.hasNext()) {
-            la[cnt++] = (NodeTypeRegistryListener) iter.next();
-        }
-        for (int i = 0; i < la.length; i++) {
-            if (la[i] != null) {
-                la[i].nodeTypeUnregistered(ntName);
-            }
-        }
-    }
-
-    /**
-     * Utility method for verifying that the namespace of a <code>QName</code>
-     * is registered; a <code>null</code> argument is silently ignored.
-     *
-     * @param name name whose namespace is to be checked
-     * @throws RepositoryException if the namespace of the given name is not
-     *                             registered or if an unspecified error occured
-     */
-    private void checkNamespace(QName name) throws RepositoryException {
-        if (name != null) {
-            // make sure namespace uri denotes a registered namespace
-            nsReg.getPrefix(name.getNamespaceURI());
-        }
-    }
-
-    /**
-     * Validates the specified NodeTypeDef within the context of the two other parameter and
-     * returns an EffectiveNodeType.
-     *
-     * @param ntd
-     * @param anEntCache
-     * @param aRegisteredNTDefCache
-     * @return The EffectiveNodeType
-     * @throws InvalidNodeTypeDefException
-     * @throws RepositoryException
-     */
-    private EffectiveNodeType validateNodeTypeDef(NodeTypeDef ntd,
-                                                  EffectiveNodeTypeCache anEntCache,
-                                                  Map aRegisteredNTDefCache)
-            throws InvalidNodeTypeDefException, RepositoryException {
-
-        /**
-         * the effective (i.e. merged and resolved) node type resulting from
-         * the specified node type definition;
-         * the effective node type will finally be created after the definition
-         * has been verified and checked for conflicts etc.; in some cases it
-         * will be created already at an earlier stage during the validation
-         * of child node definitions
-         */
-        EffectiveNodeType ent = null;
-
-        QName name = ntd.getName();
-        if (name == null) {
-            String msg = "no name specified";
-            log.debug(msg);
-            throw new InvalidNodeTypeDefException(msg);
-        }
-        checkNamespace(name);
-
-        // validate supertypes
-        QName[] supertypes = ntd.getSupertypes();
-        if (supertypes != null && supertypes.length > 0) {
-            for (int i = 0; i < supertypes.length; i++) {
-                checkNamespace(supertypes[i]);
-                /**
-                 * simple check for infinite recursion
-                 * (won't trap recursion on a deeper inheritance level)
-                 */
-                if (name.equals(supertypes[i])) {
-                    String msg = "[" + name + "] invalid supertype: "
-                            + supertypes[i] + " (infinite recursion))";
-                    log.debug(msg);
-                    throw new InvalidNodeTypeDefException(msg);
-                }
-                if (!aRegisteredNTDefCache.containsKey(supertypes[i])) {
-                    String msg = "[" + name + "] invalid supertype: "
-                            + supertypes[i];
-                    log.debug(msg);
-                    throw new InvalidNodeTypeDefException(msg);
-                }
-            }
-
-            /**
-             * check for circularity in inheritance chain
-             * ('a' extends 'b' extends 'a')
-             */
-            Stack inheritanceChain = new Stack();
-            inheritanceChain.push(name);
-            checkForCircularInheritance(supertypes, inheritanceChain, aRegisteredNTDefCache);
-        }
-
-        /**
-         * note that infinite recursion through inheritance is automatically
-         * being checked by the following call to getEffectiveNodeType()
-         * as it's impossible to register a node type definition which
-         * references a supertype that isn't registered yet...
-         */
-
-        /**
-         * build effective (i.e. merged and resolved) node type from supertypes
-         * and check for conflicts
-         */
-        if (supertypes != null && supertypes.length > 0) {
-            try {
-                EffectiveNodeType est = getEffectiveNodeType(supertypes, anEntCache, aRegisteredNTDefCache);
-                // make sure that all primary types except nt:base extend from nt:base
-                if (!ntd.isMixin() && !QName.NT_BASE.equals(ntd.getName())
-                        && !est.includesNodeType(QName.NT_BASE)) {
-                    String msg = "[" + name + "] all primary node types except"
-                            + " nt:base itself must be (directly or indirectly) derived from nt:base";
-                    log.debug(msg);
-                    throw new InvalidNodeTypeDefException(msg);
-                }
-            } catch (NodeTypeConflictException ntce) {
-                String msg = "[" + name + "] failed to validate supertypes";
-                log.debug(msg);
-                throw new InvalidNodeTypeDefException(msg, ntce);
-            } catch (NoSuchNodeTypeException nsnte) {
-                String msg = "[" + name + "] failed to validate supertypes";
-                log.debug(msg);
-                throw new InvalidNodeTypeDefException(msg, nsnte);
-            }
-        } else {
-            // no supertypes specified: has to be either a mixin type or nt:base
-            if (!ntd.isMixin() && !QName.NT_BASE.equals(ntd.getName())) {
-                String msg = "[" + name
-                        + "] all primary node types except nt:base itself must be (directly or indirectly) derived from nt:base";
-                log.debug(msg);
-                throw new InvalidNodeTypeDefException(msg);
-            }
-        }
-
-        checkNamespace(ntd.getPrimaryItemName());
-
-        // validate property definitions
-        PropDef[] pda = ntd.getPropertyDefs();
-        for (int i = 0; i < pda.length; i++) {
-            PropDef pd = pda[i];
-            /**
-             * sanity check:
-             * make sure declaring node type matches name of node type definition
-             */
-            if (!name.equals(pd.getDeclaringNodeType())) {
-                String msg = "[" + name + "#" + pd.getName()
-                        + "] invalid declaring node type specified";
-                log.debug(msg);
-                throw new InvalidNodeTypeDefException(msg);
-            }
-            checkNamespace(pd.getName());
-            // check that auto-created properties specify a name
-            if (pd.definesResidual() && pd.isAutoCreated()) {
-                String msg = "[" + name + "#" + pd.getName()
-                        + "] auto-created properties must specify a name";
-                log.debug(msg);
-                throw new InvalidNodeTypeDefException(msg);
-            }
-            // check that auto-created properties specify a type
-            if (pd.getRequiredType() == PropertyType.UNDEFINED
-                    && pd.isAutoCreated()) {
-                String msg = "[" + name + "#" + pd.getName()
-                        + "] auto-created properties must specify a type";
-                log.debug(msg);
-                throw new InvalidNodeTypeDefException(msg);
-            }
-            /**
-             * check default values:
-             * make sure type of value is consistent with required property type
-             */
-            InternalValue[] defVals = pd.getDefaultValues();
-            if (defVals != null && defVals.length != 0) {
-                int reqType = pd.getRequiredType();
-                for (int j = 0; j < defVals.length; j++) {
-                    if (reqType == PropertyType.UNDEFINED) {
-                        reqType = defVals[j].getType();
-                    } else {
-                        if (defVals[j].getType() != reqType) {
-                            String msg = "[" + name + "#" + pd.getName()
-                                    + "] type of default value(s) is not consistent with required property type";
-                            log.debug(msg);
-                            throw new InvalidNodeTypeDefException(msg);
-                        }
-                    }
-                }
-            } else {
-                // no default values specified
-                if (checkAutoCreatePropHasDefault) {
-                    // auto-created properties must have a default value
-                    if (pd.isAutoCreated()) {
-                        String msg = "[" + name + "#" + pd.getName()
-                                + "] auto-created property must have a default value";
-                        log.debug(msg);
-                        throw new InvalidNodeTypeDefException(msg);
-                    }
-                }
-            }
-
-            // check that default values satisfy value constraints
-            ValueConstraint[] constraints = pd.getValueConstraints();
-            if (constraints != null && constraints.length > 0) {
-                if (defVals != null && defVals.length > 0) {
-                    // check value constraints on every value
-                    for (int j = 0; j < defVals.length; j++) {
-                        // constraints are OR-ed together
-                        boolean satisfied = false;
-                        ConstraintViolationException cve = null;
-                        for (int k = 0; k < constraints.length; k++) {
-                            try {
-                                constraints[k].check(defVals[j]);
-                                // at least one constraint is satisfied
-                                satisfied = true;
-                                break;
-                            } catch (ConstraintViolationException e) {
-                                cve = e;
-                                continue;
-                            }
-                        }
-                        if (!satisfied) {
-                            // report last exception we encountered
-                            String msg = "[" + name + "#" + pd.getName()
-                                    + "] default value does not satisfy value constraint";
-                            log.debug(msg);
-                            throw new InvalidNodeTypeDefException(msg, cve);
-                        }
-                    }
-                }
-
-                /**
-                 * ReferenceConstraint:
-                 * the specified node type must be registered, with one notable
-                 * exception: the node type just being registered
-                 */
-                if (pd.getRequiredType() == PropertyType.REFERENCE) {
-                    for (int j = 0; j < constraints.length; j++) {
-                        ReferenceConstraint rc = (ReferenceConstraint) constraints[j];
-                        QName ntName = rc.getNodeTypeName();
-                        if (!name.equals(ntName) && !aRegisteredNTDefCache.containsKey(ntName)) {
-                            String msg = "[" + name + "#" + pd.getName()
-                                    + "] invalid REFERENCE value constraint '"
-                                    + ntName + "' (unknown node type)";
-                            log.debug(msg);
-                            throw new InvalidNodeTypeDefException(msg);
-                        }
-                    }
-                }
-            }
-        }
-
-        // validate child-node definitions
-        NodeDef[] cnda = ntd.getChildNodeDefs();
-        for (int i = 0; i < cnda.length; i++) {
-            NodeDef cnd = cnda[i];
-            /**
-             * sanity check:
-             * make sure declaring node type matches name of node type definition
-             */
-            if (!name.equals(cnd.getDeclaringNodeType())) {
-                String msg = "[" + name + "#" + cnd.getName()
-                        + "] invalid declaring node type specified";
-                log.debug(msg);
-                throw new InvalidNodeTypeDefException(msg);
-            }
-            checkNamespace(cnd.getName());
-            // check that auto-created child-nodes specify a name
-            if (cnd.definesResidual() && cnd.isAutoCreated()) {
-                String msg = "[" + name + "#" + cnd.getName()
-                        + "] auto-created child-nodes must specify a name";
-                log.debug(msg);
-                throw new InvalidNodeTypeDefException(msg);
-            }
-            // check that auto-created child-nodes specify a default primary type
-            if (cnd.getDefaultPrimaryType() == null
-                    && cnd.isAutoCreated()) {
-                String msg = "[" + name + "#" + cnd.getName()
-                        + "] auto-created child-nodes must specify a default primary type";
-                log.debug(msg);
-                throw new InvalidNodeTypeDefException(msg);
-            }
-            // check default primary type
-            QName dpt = cnd.getDefaultPrimaryType();
-            checkNamespace(dpt);
-            boolean referenceToSelf = false;
-            EffectiveNodeType defaultENT = null;
-            if (dpt != null) {
-                // check if this node type specifies itself as default primary type
-                if (name.equals(dpt)) {
-                    referenceToSelf = true;
-                }
-                /**
-                 * the default primary type must be registered, with one notable
-                 * exception: the node type just being registered
-                 */
-                if (!name.equals(dpt) && !aRegisteredNTDefCache.containsKey(dpt)) {
-                    String msg = "[" + name + "#" + cnd.getName()
-                            + "] invalid default primary type '" + dpt + "'";
-                    log.debug(msg);
-                    throw new InvalidNodeTypeDefException(msg);
-                }
-                /**
-                 * build effective (i.e. merged and resolved) node type from
-                 * default primary type and check for conflicts
-                 */
-                try {
-                    if (!referenceToSelf) {
-                        defaultENT = getEffectiveNodeType(dpt, anEntCache, aRegisteredNTDefCache);
-                    } else {
-                        /**
-                         * the default primary type is identical with the node
-                         * type just being registered; we have to instantiate it
-                         * 'manually'
-                         */
-                        ent = EffectiveNodeType.create(this, ntd, anEntCache, aRegisteredNTDefCache);
-                        defaultENT = ent;
-                    }
-                    if (cnd.isAutoCreated()) {
-                        /**
-                         * check for circularity through default primary types
-                         * of auto-created child nodes (node type 'a' defines
-                         * auto-created child node with default primary type 'a')
-                         */
-                        Stack definingNTs = new Stack();
-                        definingNTs.push(name);
-                        checkForCircularNodeAutoCreation(defaultENT, definingNTs, anEntCache, aRegisteredNTDefCache);
-                    }
-                } catch (NodeTypeConflictException ntce) {
-                    String msg = "[" + name + "#" + cnd.getName()
-                            + "] failed to validate default primary type";
-                    log.debug(msg);
-                    throw new InvalidNodeTypeDefException(msg, ntce);
-                } catch (NoSuchNodeTypeException nsnte) {
-                    String msg = "[" + name + "#" + cnd.getName()
-                            + "] failed to validate default primary type";
-                    log.debug(msg);
-                    throw new InvalidNodeTypeDefException(msg, nsnte);
-                }
-            }
-
-            // check required primary types
-            QName[] reqTypes = cnd.getRequiredPrimaryTypes();
-            if (reqTypes != null && reqTypes.length > 0) {
-                for (int n = 0; n < reqTypes.length; n++) {
-                    QName rpt = reqTypes[n];
-                    checkNamespace(rpt);
-                    referenceToSelf = false;
-                    /**
-                     * check if this node type specifies itself as required
-                     * primary type
-                     */
-                    if (name.equals(rpt)) {
-                        referenceToSelf = true;
-                    }
-                    /**
-                     * the required primary type must be registered, with one
-                     * notable exception: the node type just being registered
-                     */
-                    if (!name.equals(rpt) && !aRegisteredNTDefCache.containsKey(rpt)) {
-                        String msg = "[" + name + "#" + cnd.getName()
-                                + "] invalid required primary type: " + rpt;
-                        log.debug(msg);
-                        throw new InvalidNodeTypeDefException(msg);
-                    }
-                    /**
-                     * check if default primary type satisfies the required
-                     * primary type constraint
-                     */
-                    if (defaultENT != null && !defaultENT.includesNodeType(rpt)) {
-                        String msg = "[" + name + "#" + cnd.getName()
-                                + "] default primary type does not satisfy required primary type constraint "
-                                + rpt;
-                        log.debug(msg);
-                        throw new InvalidNodeTypeDefException(msg);
-                    }
-                    /**
-                     * build effective (i.e. merged and resolved) node type from
-                     * required primary type constraint and check for conflicts
-                     */
-                    try {
-                        if (!referenceToSelf) {
-                            getEffectiveNodeType(rpt, anEntCache, aRegisteredNTDefCache);
-                        } else {
-                            /**
-                             * the required primary type is identical with the
-                             * node type just being registered; we have to
-                             * instantiate it 'manually'
-                             */
-                            if (ent == null) {
-                                ent = EffectiveNodeType.create(this, ntd, anEntCache, aRegisteredNTDefCache);
-                            }
-                        }
-                    } catch (NodeTypeConflictException ntce) {
-                        String msg = "[" + name + "#" + cnd.getName()
-                                + "] failed to validate required primary type constraint";
-                        log.debug(msg);
-                        throw new InvalidNodeTypeDefException(msg, ntce);
-                    } catch (NoSuchNodeTypeException nsnte) {
-                        String msg = "[" + name + "#" + cnd.getName()
-                                + "] failed to validate required primary type constraint";
-                        log.debug(msg);
-                        throw new InvalidNodeTypeDefException(msg, nsnte);
-                    }
-                }
-            }
-        }
-
-        /**
-         * now build effective (i.e. merged and resolved) node type from
-         * this node type definition; this will potentially detect more
-         * conflicts or problems
-         */
-        if (ent == null) {
-            try {
-                ent = EffectiveNodeType.create(this, ntd, anEntCache, aRegisteredNTDefCache);
-            } catch (NodeTypeConflictException ntce) {
-                String msg = "[" + name + "] failed to resolve node type definition";
-                log.debug(msg);
-                throw new InvalidNodeTypeDefException(msg, ntce);
-            } catch (NoSuchNodeTypeException nsnte) {
-                String msg = "[" + name + "] failed to resolve node type definition";
-                log.debug(msg);
-                throw new InvalidNodeTypeDefException(msg, nsnte);
-            }
-        }
-        return ent;
-    }
-
-    /**
-     * @param ntName
-     * @param anEntCache
-     * @param aRegisteredNTDefCache
-     * @return
-     * @throws NoSuchNodeTypeException
-     */
-    public synchronized EffectiveNodeType getEffectiveNodeType(QName ntName,
-                                                               EffectiveNodeTypeCache anEntCache,
-                                                               Map aRegisteredNTDefCache)
-            throws NoSuchNodeTypeException {
-        // 1. check if effective node type has already been built
-        EffectiveNodeType ent = anEntCache.get(new QName[]{ntName});
-        if (ent != null) {
-            return ent;
-        }
-
-        // 2. make sure that the specified node type exists
-        if (!aRegisteredNTDefCache.containsKey(ntName)) {
-            throw new NoSuchNodeTypeException(ntName.toString());
-        }
-
-        // 3. build effective node type
-        try {
-            NodeTypeDef ntd = (NodeTypeDef) aRegisteredNTDefCache.get(ntName);
-            ent = EffectiveNodeType.create(this, ntd, anEntCache, aRegisteredNTDefCache);
-            // store new effective node type
-            anEntCache.put(ent);
-            return ent;
-        } catch (NodeTypeConflictException ntce) {
-            // should never get here as all registered node types have to be valid!
-            String msg = "internal error: encountered invalid registered node type " + ntName;
-            log.debug(msg);
-            throw new NoSuchNodeTypeException(msg, ntce);
-        }
-    }
-
-    /**
-     * @param ntNames
-     * @param anEntCache
-     * @param aRegisteredNTDefCache
-     * @return
-     * @throws NodeTypeConflictException
-     * @throws NoSuchNodeTypeException
-     */
-    public synchronized EffectiveNodeType getEffectiveNodeType(QName[] ntNames,
-                                                               EffectiveNodeTypeCache anEntCache,
-                                                               Map aRegisteredNTDefCache)
-            throws NodeTypeConflictException, NoSuchNodeTypeException {
-
-        EffectiveNodeTypeCache.WeightedKey key =
-                new EffectiveNodeTypeCache.WeightedKey(ntNames);
-
-        // 1. check if aggregate has already been built
-        if (anEntCache.contains(key)) {
-            return anEntCache.get(key);
-        }
-
-        // 2. make sure every single node type exists
-        for (int i = 0; i < ntNames.length; i++) {
-            if (!aRegisteredNTDefCache.containsKey(ntNames[i])) {
-                throw new NoSuchNodeTypeException(ntNames[i].toString());
-            }
-        }
-        // 3. build aggregate
-        EffectiveNodeType result = null;
-
-        // build list of 'best' existing sub-aggregates
-        ArrayList tmpResults = new ArrayList();
-        while (key.getNames().length > 0) {
-            // check if we've already built this aggregate
-            if (anEntCache.contains(key)) {
-                tmpResults.add(anEntCache.get(key));
-                // subtract the result from the temporary key
-                // (which is 'empty' now)
-                key = key.subtract(key);
-                break;
-            }
-            /**
-             * walk list of existing aggregates sorted by 'weight' of
-             * aggregate (i.e. the cost of building it)
-             */
-            boolean foundSubResult = false;
-            Iterator iter = anEntCache.keyIterator();
-            while (iter.hasNext()) {
-                EffectiveNodeTypeCache.WeightedKey k =
-                        (EffectiveNodeTypeCache.WeightedKey) iter.next();
-                /**
-                 * check if the existing aggregate is a 'subset' of the one
-                 * we're looking for
-                 */
-                if (key.contains(k)) {
-                    tmpResults.add(anEntCache.get(k));
-                    // subtract the result from the temporary key
-                    key = key.subtract(k);
-                    foundSubResult = true;
-                    break;
-                }
-            }
-            if (!foundSubResult) {
-                /**
-                 * no matching sub-aggregates found:
-                 * build aggregate of remaining node types through iteration
-                 */
-                QName[] remainder = key.getNames();
-                for (int i = 0; i < remainder.length; i++) {
-                    NodeTypeDef ntd = (NodeTypeDef) aRegisteredNTDefCache.get(remainder[i]);
-                    EffectiveNodeType ent =
-                            EffectiveNodeType.create(this, ntd, anEntCache, aRegisteredNTDefCache);
-                    // store new effective node type
-                    anEntCache.put(ent);
-                    if (result == null) {
-                        result = ent;
-                    } else {
-                        result = result.merge(ent);
-                        // store intermediate result (sub-aggregate)
-                        anEntCache.put(result);
-                    }
-                }
-                // add aggregate of remaining node types to result list
-                tmpResults.add(result);
-                break;
-            }
-        }
-        // merge the sub-aggregates into new effective node type
-        for (int i = 0; i < tmpResults.size(); i++) {
-            if (result == null) {
-                result = (EffectiveNodeType) tmpResults.get(i);
-            } else {
-                result = result.merge((EffectiveNodeType) tmpResults.get(i));
-                // store intermediate result
-                anEntCache.put(result);
-            }
-        }
-        // we're done
-        return result;
-    }
-
+    //----------------------------------------< public NodeTypeRegistry 'api' >
-     * @return the definition of the root node
-     */
-    public NodeDef getRootNodeDef() {
-        return rootNodeDef;
-    }
-
-    /**
-     * @param ntName
-     * @return
-     * @throws NoSuchNodeTypeException
-     */
-    public synchronized EffectiveNodeType getEffectiveNodeType(QName ntName)
-            throws NoSuchNodeTypeException {
-        return getEffectiveNodeType(ntName, entCache, registeredNTDefs);
-    }
-
-    /**
-     * @param ntNames
-     * @return
-     * @throws NodeTypeConflictException
-     * @throws NoSuchNodeTypeException
-     */
-    public synchronized EffectiveNodeType getEffectiveNodeType(QName[] ntNames)
-            throws NodeTypeConflictException, NoSuchNodeTypeException {
-        return getEffectiveNodeType(ntNames, entCache, registeredNTDefs);
-    }
-
-    void checkForCircularInheritance(QName[] supertypes,
-                                     Stack inheritanceChain,
-                                     Map aRegisteredNTDefCache)
-            throws InvalidNodeTypeDefException, RepositoryException {
-        for (int i = 0; i < supertypes.length; i++) {
-            QName nt = supertypes[i];
-            int pos = inheritanceChain.lastIndexOf(nt);
-            if (pos >= 0) {
-                StringBuffer buf = new StringBuffer();
-                for (int j = 0; j < inheritanceChain.size(); j++) {
-                    if (j == pos) {
-                        buf.append("--> ");
-                    }
-                    buf.append(inheritanceChain.get(j));
-                    buf.append(" extends ");
-                }
-                buf.append("--> ");
-                buf.append(nt);
-                throw new InvalidNodeTypeDefException("circular inheritance detected: " + buf.toString());
-            }
-
-            try {
-
-                NodeTypeDef ntd = (NodeTypeDef) aRegisteredNTDefCache.get(nt);
-                QName[] sta = ntd.getSupertypes();
-                if (sta != null && sta.length > 0) {
-                    // check recursively
-                    inheritanceChain.push(nt);
-                    checkForCircularInheritance(sta, inheritanceChain, aRegisteredNTDefCache);
-                    inheritanceChain.pop();
-                }
-            } catch (NoSuchNodeTypeException nsnte) {
-                String msg = "unknown supertype: " + nt;
-                log.debug(msg);
-                throw new InvalidNodeTypeDefException(msg, nsnte);
-            }
-        }
-    }
-
-    void checkForCircularNodeAutoCreation(EffectiveNodeType childNodeENT,
-                                          Stack definingParentNTs, EffectiveNodeTypeCache anEntCache, Map aRegisteredNTDefCache)
-            throws InvalidNodeTypeDefException {
-        // check for circularity through default node types of auto-created child nodes
-        // (node type 'a' defines auto-created child node with default node type 'a')
-        QName[] childNodeNTs = childNodeENT.getAllNodeTypes();
-        for (int i = 0; i < childNodeNTs.length; i++) {
-            QName nt = childNodeNTs[i];
-            int pos = definingParentNTs.lastIndexOf(nt);
-            if (pos >= 0) {
-                StringBuffer buf = new StringBuffer();
-                for (int j = 0; j < definingParentNTs.size(); j++) {
-                    if (j == pos) {
-                        buf.append("--> ");
-                    }
-                    buf.append("node type ");
-                    buf.append(definingParentNTs.get(j));
-                    buf.append(" defines auto-created child node with default ");
-                }
-                buf.append("--> ");
-                buf.append("node type ");
-                buf.append(nt);
-                throw new InvalidNodeTypeDefException("circular node auto-creation detected: "
-                        + buf.toString());
-            }
-        }
-
-        NodeDef[] nodeDefs = childNodeENT.getAutoCreateNodeDefs();
-        for (int i = 0; i < nodeDefs.length; i++) {
-            QName dnt = nodeDefs[i].getDefaultPrimaryType();
-            QName definingNT = nodeDefs[i].getDeclaringNodeType();
-            try {
-                if (dnt != null) {
-                    // check recursively
-                    definingParentNTs.push(definingNT);
-                    checkForCircularNodeAutoCreation(getEffectiveNodeType(dnt, anEntCache, aRegisteredNTDefCache),
-                            definingParentNTs, anEntCache, aRegisteredNTDefCache);
-                    definingParentNTs.pop();
-                }
-            } catch (NoSuchNodeTypeException nsnte) {
-                String msg = definingNT
-                        + " defines invalid default node type for child node " + nodeDefs[i].getName();
-                log.debug(msg);
-                throw new InvalidNodeTypeDefException(msg, nsnte);
-            }
-        }
-    }
-
-    /**
-        validateNodeTypeDef(ntd, this.entCache, this.registeredNTDefs);
+        validateNodeTypeDef(ntd, entCache, registeredNTDefs, nsReg, false);
+     * @param ntName
+     * @return
+     * @throws NoSuchNodeTypeException
+     */
+    public synchronized EffectiveNodeType getEffectiveNodeType(QName ntName)
+            throws NoSuchNodeTypeException {
+        return getEffectiveNodeType(ntName, entCache, registeredNTDefs);
+    }
+
+    /**
+     * @param ntNames
+     * @return
+     * @throws NodeTypeConflictException
+     * @throws NoSuchNodeTypeException
+     */
+    public synchronized EffectiveNodeType getEffectiveNodeType(QName[] ntNames)
+            throws NodeTypeConflictException, NoSuchNodeTypeException {
+        return getEffectiveNodeType(ntNames, entCache, registeredNTDefs);
+    }
+
+    /**
+    /**
+     * Add a <code>NodeTypeRegistryListener</code>
+     *
+     * @param listener the new listener to be informed on (un)registration
+     *                 of node types
+     */
+    public void addListener(NodeTypeRegistryListener listener) {
+        if (!listeners.containsKey(listener)) {
+            listeners.put(listener, listener);
+        }
+    }
+
+    /**
+     * Remove a <code>NodeTypeRegistryListener</code>
+     *
+     * @param listener an existing listener
+     */
+    public void removeListener(NodeTypeRegistryListener listener) {
+        listeners.remove(listener);
+    }
+
+     * Protected constructor
+     *
+     * @param nsReg
+     * @param ntStore
+     * @throws RepositoryException
+     */
+    protected NodeTypeRegistry(NamespaceRegistry nsReg, FileSystem ntStore)
+            throws RepositoryException {
+        this.nsReg = nsReg;
+        this.ntStore = ntStore;
+        customNodeTypesResource =
+                new FileSystemResource(this.ntStore, CUSTOM_NODETYPES_RESOURCE_NAME);
+        try {
+            // make sure path to resource exists
+            if (!customNodeTypesResource.exists()) {
+                customNodeTypesResource.makeParentDirs();
+            }
+        } catch (FileSystemException fse) {
+            String error = "internal error: invalid resource: "
+                    + customNodeTypesResource.getPath();
+            log.debug(error);
+            throw new RepositoryException(error, fse);
+        }
+
+        entCache = new EffectiveNodeTypeCache();
+        registeredNTDefs = new HashMap();
+        propDefs = new HashMap();
+        nodeDefs = new HashMap();
+
+        // setup definition of root node
+        rootNodeDef = createRootNodeDef();
+        nodeDefs.put(rootNodeDef.getId(), rootNodeDef);
+
+        // load and register pre-defined (i.e. built-in) node types
+        builtInNTDefs = new NodeTypeDefStore();
+        try {
+            // load built-in node type definitions
+            loadBuiltInNodeTypeDefs(builtInNTDefs);
+
+            // register built-in node types
+            internalRegister(builtInNTDefs.all(), true);
+        } catch (InvalidNodeTypeDefException intde) {
+            String error =
+                    "internal error: invalid built-in node type definition stored in "
+                    + BUILTIN_NODETYPES_RESOURCE_PATH;
+            log.debug(error);
+            throw new RepositoryException(error, intde);
+        }
+
+        // load and register custom node types
+        customNTDefs = new NodeTypeDefStore();
+
+        // load custom node type definitions
+        loadCustomNodeTypeDefs(customNTDefs);
+
+        // validate & register custom node types
+        try {
+            internalRegister(customNTDefs.all());
+        } catch (InvalidNodeTypeDefException intde) {
+            String error =
+                    "internal error: invalid custom node type definition stored in "
+                    + customNodeTypesResource.getPath();
+            log.debug(error);
+            throw new RepositoryException(error, intde);
+        }
+    }
+
+    /**
+
+    //-------------------------------------------------------< implementation >
+    /**
+     * @return the definition of the root node
+     */
+    public NodeDef getRootNodeDef() {
+        return rootNodeDef;
+    }
+
+    /**
+     * @param ntName
+     * @param entCache
+     * @param ntdCache
+     * @return
+     * @throws NoSuchNodeTypeException
+     * @param entCache cache of already-built effective node types
+     * @param ntdCache cache of node type definitions
+     * @return
+     * @throws NoSuchNodeTypeException if a node type reference (e.g. a supertype)
+     *                                 could not be resolved.
+     */
+    static EffectiveNodeType getEffectiveNodeType(QName ntName,
+                                                         EffectiveNodeTypeCache entCache,
+                                                         Map ntdCache)
+            throws NoSuchNodeTypeException {
+        // 1. check if effective node type has already been built
+        EffectiveNodeType ent = entCache.get(new QName[]{ntName});
+        if (ent != null) {
+            return ent;
+        }
+
+        // 2. make sure we've got the definition of the specified node type
+        if (!ntdCache.containsKey(ntName)) {
+            throw new NoSuchNodeTypeException(ntName.toString());
+        }
+
+        // 3. build effective node type
+        try {
+            NodeTypeDef ntd = (NodeTypeDef) ntdCache.get(ntName);
+            ent = EffectiveNodeType.create(ntd, entCache, ntdCache);
+            // store new effective node type
+            entCache.put(ent);
+            return ent;
+        } catch (NodeTypeConflictException ntce) {
+            // should never get here as all known node types should be valid!
+            String msg = "internal error: encountered invalid registered node type " + ntName;
+            log.debug(msg);
+            throw new NoSuchNodeTypeException(msg, ntce);
+        }
+    }
+
+    /**
+     * Returns an effective node type representation of the given node types.
+     *
+     * @param ntNames  array of node type names
+     * @param entCache cache of already-built effective node types
+     * @param ntdCache cache of node type definitions
+     * @return
+     * @throws NodeTypeConflictException if the effective node type representation
+     *                                   could not be built due to conflicting
+     *                                   node type definitions.
+     * @throws NoSuchNodeTypeException if a node type reference (e.g. a supertype)
+     *                                 could not be resolved.
+     */
+    static EffectiveNodeType getEffectiveNodeType(QName[] ntNames,
+                                                         EffectiveNodeTypeCache entCache,
+                                                         Map ntdCache)
+            throws NodeTypeConflictException, NoSuchNodeTypeException {
+
+        EffectiveNodeTypeCache.WeightedKey key =
+                new EffectiveNodeTypeCache.WeightedKey(ntNames);
+
+        // 1. check if aggregate has already been built
+        if (entCache.contains(key)) {
+            return entCache.get(key);
+        }
+
+        // 2. make sure we've got the definitions of the specified node types
+        for (int i = 0; i < ntNames.length; i++) {
+            if (!ntdCache.containsKey(ntNames[i])) {
+                throw new NoSuchNodeTypeException(ntNames[i].toString());
+            }
+        }
+
+        // 3. build aggregate
+        EffectiveNodeType result = null;
+
+        // build list of 'best' existing sub-aggregates
+        ArrayList tmpResults = new ArrayList();
+        while (key.getNames().length > 0) {
+            // check if we've already built this aggregate
+            if (entCache.contains(key)) {
+                tmpResults.add(entCache.get(key));
+                // subtract the result from the temporary key
+                // (which is 'empty' now)
+                key = key.subtract(key);
+                break;
+            }
+            /**
+             * walk list of existing aggregates sorted by 'weight' of
+             * aggregate (i.e. the cost of building it)
+             */
+            boolean foundSubResult = false;
+            Iterator iter = entCache.keyIterator();
+            while (iter.hasNext()) {
+                EffectiveNodeTypeCache.WeightedKey k =
+                        (EffectiveNodeTypeCache.WeightedKey) iter.next();
+                /**
+                 * check if the existing aggregate is a 'subset' of the one
+                 * we're looking for
+                 */
+                if (key.contains(k)) {
+                    tmpResults.add(entCache.get(k));
+                    // subtract the result from the temporary key
+                    key = key.subtract(k);
+                    foundSubResult = true;
+                    break;
+                }
+            }
+            if (!foundSubResult) {
+                /**
+                 * no matching sub-aggregates found:
+                 * build aggregate of remaining node types through iteration
+                 */
+                QName[] remainder = key.getNames();
+                for (int i = 0; i < remainder.length; i++) {
+                    NodeTypeDef ntd = (NodeTypeDef) ntdCache.get(remainder[i]);
+                    EffectiveNodeType ent =
+                            EffectiveNodeType.create(ntd, entCache, ntdCache);
+                    // store new effective node type
+                    entCache.put(ent);
+                    if (result == null) {
+                        result = ent;
+                    } else {
+                        result = result.merge(ent);
+                        // store intermediate result (sub-aggregate)
+                        entCache.put(result);
+                    }
+                }
+                // add aggregate of remaining node types to result list
+                tmpResults.add(result);
+                break;
+            }
+        }
+        // merge the sub-aggregates into new effective node type
+        for (int i = 0; i < tmpResults.size(); i++) {
+            if (result == null) {
+                result = (EffectiveNodeType) tmpResults.get(i);
+            } else {
+                result = result.merge((EffectiveNodeType) tmpResults.get(i));
+                // store intermediate result
+                entCache.put(result);
+            }
+        }
+        // we're done
+        return result;
+    }
+
+    static void checkForCircularInheritance(QName[] supertypes,
+                                     Stack inheritanceChain,
+                                     Map ntDefCache)
+            throws InvalidNodeTypeDefException, RepositoryException {
+        for (int i = 0; i < supertypes.length; i++) {
+            QName nt = supertypes[i];
+            int pos = inheritanceChain.lastIndexOf(nt);
+            if (pos >= 0) {
+                StringBuffer buf = new StringBuffer();
+                for (int j = 0; j < inheritanceChain.size(); j++) {
+                    if (j == pos) {
+                        buf.append("--> ");
+                    }
+                    buf.append(inheritanceChain.get(j));
+                    buf.append(" extends ");
+                }
+                buf.append("--> ");
+                buf.append(nt);
+                throw new InvalidNodeTypeDefException("circular inheritance detected: " + buf.toString());
+            }
+
+            try {
+
+                NodeTypeDef ntd = (NodeTypeDef) ntDefCache.get(nt);
+                QName[] sta = ntd.getSupertypes();
+                if (sta != null && sta.length > 0) {
+                    // check recursively
+                    inheritanceChain.push(nt);
+                    checkForCircularInheritance(sta, inheritanceChain, ntDefCache);
+                    inheritanceChain.pop();
+                }
+            } catch (NoSuchNodeTypeException nsnte) {
+                String msg = "unknown supertype: " + nt;
+                log.debug(msg);
+                throw new InvalidNodeTypeDefException(msg, nsnte);
+            }
+        }
+    }
+
+    static void checkForCircularNodeAutoCreation(EffectiveNodeType childNodeENT,
+                                                 Stack definingParentNTs,
+                                                 EffectiveNodeTypeCache anEntCache,
+                                                 Map ntDefCache)
+            throws InvalidNodeTypeDefException {
+        // check for circularity through default node types of auto-created child nodes
+        // (node type 'a' defines auto-created child node with default node type 'a')
+        QName[] childNodeNTs = childNodeENT.getAllNodeTypes();
+        for (int i = 0; i < childNodeNTs.length; i++) {
+            QName nt = childNodeNTs[i];
+            int pos = definingParentNTs.lastIndexOf(nt);
+            if (pos >= 0) {
+                StringBuffer buf = new StringBuffer();
+                for (int j = 0; j < definingParentNTs.size(); j++) {
+                    if (j == pos) {
+                        buf.append("--> ");
+                    }
+                    buf.append("node type ");
+                    buf.append(definingParentNTs.get(j));
+                    buf.append(" defines auto-created child node with default ");
+                }
+                buf.append("--> ");
+                buf.append("node type ");
+                buf.append(nt);
+                throw new InvalidNodeTypeDefException("circular node auto-creation detected: "
+                        + buf.toString());
+            }
+        }
+
+        NodeDef[] nodeDefs = childNodeENT.getAutoCreateNodeDefs();
+        for (int i = 0; i < nodeDefs.length; i++) {
+            QName dnt = nodeDefs[i].getDefaultPrimaryType();
+            QName definingNT = nodeDefs[i].getDeclaringNodeType();
+            try {
+                if (dnt != null) {
+                    // check recursively
+                    definingParentNTs.push(definingNT);
+                    checkForCircularNodeAutoCreation(getEffectiveNodeType(dnt, anEntCache, ntDefCache),
+                            definingParentNTs, anEntCache, ntDefCache);
+                    definingParentNTs.pop();
+                }
+            } catch (NoSuchNodeTypeException nsnte) {
+                String msg = definingNT
+                        + " defines invalid default node type for child node " + nodeDefs[i].getName();
+                log.debug(msg);
+                throw new InvalidNodeTypeDefException(msg, nsnte);
+            }
+        }
+    }
+
+    private EffectiveNodeType internalRegister(NodeTypeDef ntd)
+            throws InvalidNodeTypeDefException, RepositoryException {
+        QName name = ntd.getName();
+        if (name != null && registeredNTDefs.containsKey(name)) {
+            String msg = name + " already exists";
+            log.debug(msg);
+            throw new InvalidNodeTypeDefException(msg);
+        }
+
+        EffectiveNodeType ent =
+                validateNodeTypeDef(ntd, entCache, registeredNTDefs, nsReg, false);
+
+        // store new effective node type instance
+        entCache.put(ent);
+
+        // register clone of node type definition
+        ntd = (NodeTypeDef) ntd.clone();
+        registeredNTDefs.put(name, ntd);
+
+        // store property & child node definitions of new node type by id
+        PropDef[] pda = ntd.getPropertyDefs();
+        for (int i = 0; i < pda.length; i++) {
+            propDefs.put(pda[i].getId(), pda[i]);
+        }
+        NodeDef[] nda = ntd.getChildNodeDefs();
+        for (int i = 0; i < nda.length; i++) {
+            nodeDefs.put(nda[i].getId(), nda[i]);
+        }
+
+        return ent;
+    }
+
+    /**
+     * Validates and registers the specified collection of <code>NodeTypeDef</code>
+     * objects. An <code>InvalidNodeTypeDefException</code> is thrown if the
+     * validation of any of the contained <code>NodeTypeDef</code> objects fails.
+     * <p/>
+     * Note that in the case an exception is thrown no node type will be
+     * eventually registered.
+     *
+     * @param ntDefs collection of <code>NodeTypeDef</code> objects
+     * @throws InvalidNodeTypeDefException
+     * @throws RepositoryException
+     * @see #registerNodeType
+     */
+    private void internalRegister(Collection ntDefs)
+            throws InvalidNodeTypeDefException, RepositoryException {
+        internalRegister(ntDefs, false);
+    }
+
+    /**
+     * Same as {@link #internalRegister(java.util.Collection)} except for the
+     * additional <code>lenient</code> parameter which governs whether
+     * validation can be lenient (e.g. for built-in node types) or has to be
+     * strict (such as in the case of custom node types). This differentiation
+     * is unfortunately required as there are e.g. properties defined in built-in
+     * node types which are auto-created but don't have a fixed default value
+     * that can be exposed in a property definition because it is
+     * system-generated (such as jcr:primaryType in nt:base).
+     */
+    private void internalRegister(Collection ntDefs, boolean lenient)
+            throws InvalidNodeTypeDefException, RepositoryException {
+
+        // create working copies of current ent & ntd caches:
+        // cache of pre-built aggregations of node types
+        EffectiveNodeTypeCache tmpENTCache = (EffectiveNodeTypeCache) entCache.clone();
+        // map of node type names and node type definitions
+        Map tmpNTDefCache = new HashMap(registeredNTDefs);
+
+        // temporarily register the node type definition
+        // and do some preliminary checks
+        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
+            NodeTypeDef ntd = (NodeTypeDef) iter.next();
+            QName name = ntd.getName();
+            if (name != null && registeredNTDefs.containsKey(name)) {
+                String msg = name + " already exists";
+                log.debug(msg);
+                throw new InvalidNodeTypeDefException(msg);
+            }
+            // add definition to temporary cache
+            tmpNTDefCache.put(ntd.getName(), ntd);
+        }
+
+        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
+            NodeTypeDef ntd = (NodeTypeDef) iter.next();
+
+            EffectiveNodeType ent =
+                    validateNodeTypeDef(ntd, tmpENTCache, tmpNTDefCache, nsReg, lenient);
+
+            // store new effective node type instance
+            tmpENTCache.put(ent);
+        }
+
+        // since no exception was thrown so far the definitions are assumed to be valid
+        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
+            NodeTypeDef ntd = (NodeTypeDef) iter.next();
+
+            // register clone of node type definition
+            ntd = (NodeTypeDef) ntd.clone();
+            registeredNTDefs.put(ntd.getName(), ntd);
+            // store property & child node definitions of new node type by id
+            PropDef[] pda = ntd.getPropertyDefs();
+            for (int i = 0; i < pda.length; i++) {
+                propDefs.put(pda[i].getId(), pda[i]);
+            }
+            NodeDef[] nda = ntd.getChildNodeDefs();
+            for (int i = 0; i < nda.length; i++) {
+                nodeDefs.put(nda[i].getId(), nda[i]);
+            }
+        }
+
+        // finally add newly created effective node types to entCache
+        for (Iterator it = tmpENTCache.keyIterator(); it.hasNext(); ) {
+            EffectiveNodeTypeCache.WeightedKey k =
+                    (EffectiveNodeTypeCache.WeightedKey) it.next();
+            if (!entCache.contains(k)) {
+                entCache.put(tmpENTCache.get(k));
+            }
+        }
+    }
+
+    private void internalUnregister(QName name) throws NoSuchNodeTypeException {
+        NodeTypeDef ntd = (NodeTypeDef) registeredNTDefs.get(name);
+        if (ntd == null) {
+            throw new NoSuchNodeTypeException(name.toString());
+        }
+        registeredNTDefs.remove(name);
+        /**
+         * remove all affected effective node types from aggregates cache
+         * (copy keys first to prevent ConcurrentModificationException)
+         */
+        ArrayList keys = new ArrayList(entCache.keySet());
+        for (Iterator keysIter = keys.iterator(); keysIter.hasNext();) {
+            EffectiveNodeTypeCache.WeightedKey k =
+                    (EffectiveNodeTypeCache.WeightedKey) keysIter.next();
+            EffectiveNodeType ent = entCache.get(k);
+            if (ent.includesNodeType(name)) {
+                entCache.remove(k);
+            }
+        }
+
+        // remove property & child node definitions
+        PropDef[] pda = ntd.getPropertyDefs();
+        for (int i = 0; i < pda.length; i++) {
+            propDefs.remove(pda[i].getId());
+        }
+        NodeDef[] nda = ntd.getChildNodeDefs();
+        for (int i = 0; i < nda.length; i++) {
+            nodeDefs.remove(nda[i].getId());
+        }
+    }
+
+    private void internalUnregister(Collection ntNames)
+            throws NoSuchNodeTypeException {
+        for (Iterator iter = ntNames.iterator(); iter.hasNext();) {
+            QName name = (QName) iter.next();
+            internalUnregister(name);
+        }
+    }
+
+    /**
+     * Utility method for verifying that the namespace of a <code>QName</code>
+     * is registered; a <code>null</code> argument is silently ignored.
+     *
+     * @param name name whose namespace is to be checked
+     * @param nsReg namespace registry to be used for checking
+     * @throws RepositoryException if the namespace of the given name is not
+     *                             registered or if an unspecified error occured
+     */
+    private static void checkNamespace(QName name, NamespaceRegistry nsReg)
+            throws RepositoryException {
+        if (name != null) {
+            // make sure namespace uri denotes a registered namespace
+            nsReg.getPrefix(name.getNamespaceURI());
+        }
+    }
+
+    /**
+     * Validates the specified <code>NodeTypeDef</code> within the context of
+     * the two other given collections and returns an <code>EffectiveNodeType</code>.
+     *
+     * @param ntd
+     * @param entCache
+     * @param ntdCache cache of 'known' node type definitions, used to resolve dependencies
+     * @param nsReg    namespace registry used for validating qualified names
+     * @param lenient flag governing whether validation can be lenient or has to be strict
+     * @return an effective node type representation of the specified <code>NodeTypeDef</code>
+     * @throws InvalidNodeTypeDefException
+     * @throws RepositoryException         if another error occurs
+     */
+    private static EffectiveNodeType validateNodeTypeDef(NodeTypeDef ntd,
+                                                         EffectiveNodeTypeCache entCache,
+                                                         Map ntdCache,
+                                                         NamespaceRegistry nsReg,
+                                                         boolean lenient)
+            throws InvalidNodeTypeDefException, RepositoryException {
+
+        /**
+         * the effective (i.e. merged and resolved) node type resulting from
+         * the specified node type definition;
+         * the effective node type will finally be created after the definition
+         * has been verified and checked for conflicts etc.; in some cases it
+         * will be created already at an earlier stage during the validation
+         * of child node definitions
+         */
+        EffectiveNodeType ent = null;
+
+        QName name = ntd.getName();
+        if (name == null) {
+            String msg = "no name specified";
+            log.debug(msg);
+            throw new InvalidNodeTypeDefException(msg);
+        }
+        checkNamespace(name, nsReg);
+
+        // validate supertypes
+        QName[] supertypes = ntd.getSupertypes();
+        if (supertypes != null && supertypes.length > 0) {
+            for (int i = 0; i < supertypes.length; i++) {
+                checkNamespace(supertypes[i], nsReg);
+                /**
+                 * simple check for infinite recursion
+                 * (won't trap recursion on a deeper inheritance level)
+                 */
+                if (name.equals(supertypes[i])) {
+                    String msg = "[" + name + "] invalid supertype: "
+                            + supertypes[i] + " (infinite recursion))";
+                    log.debug(msg);
+                    throw new InvalidNodeTypeDefException(msg);
+                }
+                if (!ntdCache.containsKey(supertypes[i])) {
+                    String msg = "[" + name + "] invalid supertype: "
+                            + supertypes[i];
+                    log.debug(msg);
+                    throw new InvalidNodeTypeDefException(msg);
+                }
+            }
+
+            /**
+             * check for circularity in inheritance chain
+             * ('a' extends 'b' extends 'a')
+             */
+            Stack inheritanceChain = new Stack();
+            inheritanceChain.push(name);
+            checkForCircularInheritance(supertypes, inheritanceChain, ntdCache);
+        }
+
+        /**
+         * note that infinite recursion through inheritance is automatically
+         * being checked by the following call to getEffectiveNodeType(...)
+         * as it's impossible to register a node type definition which
+         * references a supertype that isn't registered yet...
+         */
+
+        /**
+         * build effective (i.e. merged and resolved) node type from supertypes
+         * and check for conflicts
+         */
+        if (supertypes != null && supertypes.length > 0) {
+            try {
+                EffectiveNodeType est = getEffectiveNodeType(supertypes, entCache, ntdCache);
+                // make sure that all primary types except nt:base extend from nt:base
+                if (!ntd.isMixin() && !QName.NT_BASE.equals(ntd.getName())
+                        && !est.includesNodeType(QName.NT_BASE)) {
+                    String msg = "[" + name + "] all primary node types except"
+                            + " nt:base itself must be (directly or indirectly) derived from nt:base";
+                    log.debug(msg);
+                    throw new InvalidNodeTypeDefException(msg);
+                }
+            } catch (NodeTypeConflictException ntce) {
+                String msg = "[" + name + "] failed to validate supertypes";
+                log.debug(msg);
+                throw new InvalidNodeTypeDefException(msg, ntce);
+            } catch (NoSuchNodeTypeException nsnte) {
+                String msg = "[" + name + "] failed to validate supertypes";
+                log.debug(msg);
+                throw new InvalidNodeTypeDefException(msg, nsnte);
+            }
+        } else {
+            // no supertypes specified: has to be either a mixin type or nt:base
+            if (!ntd.isMixin() && !QName.NT_BASE.equals(ntd.getName())) {
+                String msg = "[" + name
+                        + "] all primary node types except nt:base itself must be (directly or indirectly) derived from nt:base";
+                log.debug(msg);
+                throw new InvalidNodeTypeDefException(msg);
+            }
+        }
+
+        checkNamespace(ntd.getPrimaryItemName(), nsReg);
+
+        // validate property definitions
+        PropDef[] pda = ntd.getPropertyDefs();
+        for (int i = 0; i < pda.length; i++) {
+            PropDef pd = pda[i];
+            /**
+             * sanity check:
+             * make sure declaring node type matches name of node type definition
+             */
+            if (!name.equals(pd.getDeclaringNodeType())) {
+                String msg = "[" + name + "#" + pd.getName()
+                        + "] invalid declaring node type specified";
+                log.debug(msg);
+                throw new InvalidNodeTypeDefException(msg);
+            }
+            checkNamespace(pd.getName(), nsReg);
+            // check that auto-created properties specify a name
+            if (pd.definesResidual() && pd.isAutoCreated()) {
+                String msg = "[" + name + "#" + pd.getName()
+                        + "] auto-created properties must specify a name";
+                log.debug(msg);
+                throw new InvalidNodeTypeDefException(msg);
+            }
+            // check that auto-created properties specify a type
+            if (pd.getRequiredType() == PropertyType.UNDEFINED
+                    && pd.isAutoCreated()) {
+                String msg = "[" + name + "#" + pd.getName()
+                        + "] auto-created properties must specify a type";
+                log.debug(msg);
+                throw new InvalidNodeTypeDefException(msg);
+            }
+            /**
+             * check default values:
+             * make sure type of value is consistent with required property type
+             */
+            InternalValue[] defVals = pd.getDefaultValues();
+            if (defVals != null && defVals.length != 0) {
+                int reqType = pd.getRequiredType();
+                for (int j = 0; j < defVals.length; j++) {
+                    if (reqType == PropertyType.UNDEFINED) {
+                        reqType = defVals[j].getType();
+                    } else {
+                        if (defVals[j].getType() != reqType) {
+                            String msg = "[" + name + "#" + pd.getName()
+                                    + "] type of default value(s) is not consistent with required property type";
+                            log.debug(msg);
+                            throw new InvalidNodeTypeDefException(msg);
+                        }
+                    }
+                }
+            } else {
+                // no default values specified
+                if (!lenient) {
+                    // auto-created properties must have a default value
+                    if (pd.isAutoCreated()) {
+                        String msg = "[" + name + "#" + pd.getName()
+                                + "] auto-created property must have a default value";
+                        log.debug(msg);
+                        throw new InvalidNodeTypeDefException(msg);
+                    }
+                }
+            }
+
+            // check that default values satisfy value constraints
+            ValueConstraint[] constraints = pd.getValueConstraints();
+            if (constraints != null && constraints.length > 0) {
+                if (defVals != null && defVals.length > 0) {
+                    // check value constraints on every value
+                    for (int j = 0; j < defVals.length; j++) {
+                        // constraints are OR-ed together
+                        boolean satisfied = false;
+                        ConstraintViolationException cve = null;
+                        for (int k = 0; k < constraints.length; k++) {
+                            try {
+                                constraints[k].check(defVals[j]);
+                                // at least one constraint is satisfied
+                                satisfied = true;
+                                break;
+                            } catch (ConstraintViolationException e) {
+                                cve = e;
+                                continue;
+                            }
+                        }
+                        if (!satisfied) {
+                            // report last exception we encountered
+                            String msg = "[" + name + "#" + pd.getName()
+                                    + "] default value does not satisfy value constraint";
+                            log.debug(msg);
+                            throw new InvalidNodeTypeDefException(msg, cve);
+                        }
+                    }
+                }
+
+                /**
+                 * ReferenceConstraint:
+                 * the specified node type must be registered, with one notable
+                 * exception: the node type just being registered
+                 */
+                if (pd.getRequiredType() == PropertyType.REFERENCE) {
+                    for (int j = 0; j < constraints.length; j++) {
+                        ReferenceConstraint rc = (ReferenceConstraint) constraints[j];
+                        QName ntName = rc.getNodeTypeName();
+                        if (!name.equals(ntName) && !ntdCache.containsKey(ntName)) {
+                            String msg = "[" + name + "#" + pd.getName()
+                                    + "] invalid REFERENCE value constraint '"
+                                    + ntName + "' (unknown node type)";
+                            log.debug(msg);
+                            throw new InvalidNodeTypeDefException(msg);
+                        }
+                    }
+                }
+            }
+        }
+
+        // validate child-node definitions
+        NodeDef[] cnda = ntd.getChildNodeDefs();
+        for (int i = 0; i < cnda.length; i++) {
+            NodeDef cnd = cnda[i];
+            /**
+             * sanity check:
+             * make sure declaring node type matches name of node type definition
+             */
+            if (!name.equals(cnd.getDeclaringNodeType())) {
+                String msg = "[" + name + "#" + cnd.getName()
+                        + "] invalid declaring node type specified";
+                log.debug(msg);
+                throw new InvalidNodeTypeDefException(msg);
+            }
+            checkNamespace(cnd.getName(), nsReg);
+            // check that auto-created child-nodes specify a name
+            if (cnd.definesResidual() && cnd.isAutoCreated()) {
+                String msg = "[" + name + "#" + cnd.getName()
+                        + "] auto-created child-nodes must specify a name";
+                log.debug(msg);
+                throw new InvalidNodeTypeDefException(msg);
+            }
+            // check that auto-created child-nodes specify a default primary type
+            if (cnd.getDefaultPrimaryType() == null
+                    && cnd.isAutoCreated()) {
+                String msg = "[" + name + "#" + cnd.getName()
+                        + "] auto-created child-nodes must specify a default primary type";
+                log.debug(msg);
+                throw new InvalidNodeTypeDefException(msg);
+            }
+            // check default primary type
+            QName dpt = cnd.getDefaultPrimaryType();
+            checkNamespace(dpt, nsReg);
+            boolean referenceToSelf = false;
+            EffectiveNodeType defaultENT = null;
+            if (dpt != null) {
+                // check if this node type specifies itself as default primary type
+                if (name.equals(dpt)) {
+                    referenceToSelf = true;
+                }
+                /**
+                 * the default primary type must be registered, with one notable
+                 * exception: the node type just being registered
+                 */
+                if (!name.equals(dpt) && !ntdCache.containsKey(dpt)) {
+                    String msg = "[" + name + "#" + cnd.getName()
+                            + "] invalid default primary type '" + dpt + "'";
+                    log.debug(msg);
+                    throw new InvalidNodeTypeDefException(msg);
+                }
+                /**
+                 * build effective (i.e. merged and resolved) node type from
+                 * default primary type and check for conflicts
+                 */
+                try {
+                    if (!referenceToSelf) {
+                        defaultENT = getEffectiveNodeType(dpt, entCache, ntdCache);
+                    } else {
+                        /**
+                         * the default primary type is identical with the node
+                         * type just being registered; we have to instantiate it
+                         * 'manually'
+                         */
+                        ent = EffectiveNodeType.create(ntd, entCache, ntdCache);
+                        defaultENT = ent;
+                    }
+                    if (cnd.isAutoCreated()) {
+                        /**
+                         * check for circularity through default primary types
+                         * of auto-created child nodes (node type 'a' defines
+                         * auto-created child node with default primary type 'a')
+                         */
+                        Stack definingNTs = new Stack();
+                        definingNTs.push(name);
+                        checkForCircularNodeAutoCreation(defaultENT, definingNTs, entCache, ntdCache);
+                    }
+                } catch (NodeTypeConflictException ntce) {
+                    String msg = "[" + name + "#" + cnd.getName()
+                            + "] failed to validate default primary type";
+                    log.debug(msg);
+                    throw new InvalidNodeTypeDefException(msg, ntce);
+                } catch (NoSuchNodeTypeException nsnte) {
+                    String msg = "[" + name + "#" + cnd.getName()
+                            + "] failed to validate default primary type";
+                    log.debug(msg);
+                    throw new InvalidNodeTypeDefException(msg, nsnte);
+                }
+            }
+
+            // check required primary types
+            QName[] reqTypes = cnd.getRequiredPrimaryTypes();
+            if (reqTypes != null && reqTypes.length > 0) {
+                for (int n = 0; n < reqTypes.length; n++) {
+                    QName rpt = reqTypes[n];
+                    checkNamespace(rpt, nsReg);
+                    referenceToSelf = false;
+                    /**
+                     * check if this node type specifies itself as required
+                     * primary type
+                     */
+                    if (name.equals(rpt)) {
+                        referenceToSelf = true;
+                    }
+                    /**
+                     * the required primary type must be registered, with one
+                     * notable exception: the node type just being registered
+                     */
+                    if (!name.equals(rpt) && !ntdCache.containsKey(rpt)) {
+                        String msg = "[" + name + "#" + cnd.getName()
+                                + "] invalid required primary type: " + rpt;
+                        log.debug(msg);
+                        throw new InvalidNodeTypeDefException(msg);
+                    }
+                    /**
+                     * check if default primary type satisfies the required
+                     * primary type constraint
+                     */
+                    if (defaultENT != null && !defaultENT.includesNodeType(rpt)) {
+                        String msg = "[" + name + "#" + cnd.getName()
+                                + "] default primary type does not satisfy required primary type constraint "
+                                + rpt;
+                        log.debug(msg);
+                        throw new InvalidNodeTypeDefException(msg);
+                    }
+                    /**
+                     * build effective (i.e. merged and resolved) node type from
+                     * required primary type constraint and check for conflicts
+                     */
+                    try {
+                        if (!referenceToSelf) {
+                            getEffectiveNodeType(rpt, entCache, ntdCache);
+                        } else {
+                            /**
+                             * the required primary type is identical with the
+                             * node type just being registered; we have to
+                             * instantiate it 'manually'
+                             */
+                            if (ent == null) {
+                                ent = EffectiveNodeType.create(ntd, entCache, ntdCache);
+                            }
+                        }
+                    } catch (NodeTypeConflictException ntce) {
+                        String msg = "[" + name + "#" + cnd.getName()
+                                + "] failed to validate required primary type constraint";
+                        log.debug(msg);
+                        throw new InvalidNodeTypeDefException(msg, ntce);
+                    } catch (NoSuchNodeTypeException nsnte) {
+                        String msg = "[" + name + "#" + cnd.getName()
+                                + "] failed to validate required primary type constraint";
+                        log.debug(msg);
+                        throw new InvalidNodeTypeDefException(msg, nsnte);
+                    }
+                }
+            }
+        }
+
+        /**
+         * now build effective (i.e. merged and resolved) node type from
+         * this node type definition; this will potentially detect more
+         * conflicts or problems
+         */
+        if (ent == null) {
+            try {
+                ent = EffectiveNodeType.create(ntd, entCache, ntdCache);
+            } catch (NodeTypeConflictException ntce) {
+                String msg = "[" + name + "] failed to resolve node type definition";
+                log.debug(msg);
+                throw new InvalidNodeTypeDefException(msg, ntce);
+            } catch (NoSuchNodeTypeException nsnte) {
+                String msg = "[" + name + "] failed to resolve node type definition";
+                log.debug(msg);
+                throw new InvalidNodeTypeDefException(msg, nsnte);
+            }
+        }
+        return ent;
+    }
+
+    private static NodeDef createRootNodeDef() {
+        NodeDefImpl def = new NodeDefImpl();
+
+        // FIXME need a fake declaring node type:
+        // rep:root is not quite correct but better than a non-existing node type
+        def.setDeclaringNodeType(QName.REP_ROOT);
+        def.setRequiredPrimaryTypes(new QName[]{QName.REP_ROOT});
+        def.setDefaultPrimaryType(QName.REP_ROOT);
+        def.setMandatory(true);
+        def.setProtected(false);
+        def.setOnParentVersion(OnParentVersionAction.VERSION);
+        def.setAllowsSameNameSiblings(false);
+        def.setAutoCreated(true);
+        return def;
+    }
+
+    /**
+     * Notify the listeners that a node type <code>ntName</code> has been registered.
+     */
+    private void notifyRegistered(QName ntName) {
+        // copy listeners to array to avoid ConcurrentModificationException
+        NodeTypeRegistryListener[] la =
+                new NodeTypeRegistryListener[listeners.size()];
+        Iterator iter = listeners.values().iterator();
+        int cnt = 0;
+        while (iter.hasNext()) {
+            la[cnt++] = (NodeTypeRegistryListener) iter.next();
+        }
+        for (int i = 0; i < la.length; i++) {
+            if (la[i] != null) {
+                la[i].nodeTypeRegistered(ntName);
+            }
+        }
+    }
+
+    /**
+     * Notify the listeners that a node type <code>ntName</code> has been re-registered.
+     */
+    private void notifyReRegistered(QName ntName) {
+        // copy listeners to array to avoid ConcurrentModificationException
+        NodeTypeRegistryListener[] la =
+                new NodeTypeRegistryListener[listeners.size()];
+        Iterator iter = listeners.values().iterator();
+        int cnt = 0;
+        while (iter.hasNext()) {
+            la[cnt++] = (NodeTypeRegistryListener) iter.next();
+        }
+        for (int i = 0; i < la.length; i++) {
+            if (la[i] != null) {
+                la[i].nodeTypeReRegistered(ntName);
+            }
+        }
+    }
+
+    /**
+     * Notify the listeners that a node type <code>ntName</code> has been unregistered.
+     */
+    private void notifyUnregistered(QName ntName) {
+        // copy listeners to array to avoid ConcurrentModificationException
+        NodeTypeRegistryListener[] la =
+                new NodeTypeRegistryListener[listeners.size()];
+        Iterator iter = listeners.values().iterator();
+        int cnt = 0;
+        while (iter.hasNext()) {
+            la[cnt++] = (NodeTypeRegistryListener) iter.next();
+        }
+        for (int i = 0; i < la.length; i++) {
+            if (la[i] != null) {
+                la[i].nodeTypeUnregistered(ntName);
+            }
+        }
+    }

MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 INS31 UPD83 MOV44 UPD83 MOV44 INS83 MOV44 INS83 MOV44 MOV29 INS83 INS39 INS42 INS44 INS43 INS43 INS8 INS29 INS44 INS83 INS44 INS83 INS44 INS44 INS44 INS65 INS65 INS65 INS65 UPD42 UPD42 INS65 UPD42 UPD42 UPD42 UPD42 INS43 INS42 INS42 INS42 INS21 INS65 INS39 INS42 INS24 INS65 INS43 INS42 INS65 INS65 UPD42 MOV43 INS42 INS43 INS42 INS39 INS42 UPD42 UPD42 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS66 UPD42 INS66 UPD42 INS66 INS66 INS66 INS66 INS66 INS66 MOV43 INS42 INS32 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS58 INS32 INS8 INS42 INS66 INS42 UPD66 UPD66 UPD42 UPD42 INS66 INS42 INS66 INS42 INS66 UPD66 INS66 INS42 INS42 INS42 INS42 INS9 UPD42 INS42 INS42 INS9 INS68 UPD42 UPD42 INS43 INS59 INS42 INS42 INS60 INS25 INS42 INS42 UPD42 UPD42 MOV43 INS42 INS9 INS42 INS69 INS42 INS42 INS32 INS43 INS59 INS38 INS8 INS9 UPD42 UPD42 UPD42 INS43 UPD42 UPD42 INS42 INS42 INS40 INS42 INS11 INS32 INS21 UPD42 INS42 INS42 INS42 MOV43 UPD42 UPD42 UPD42 UPD42 MOV43 INS40 UPD42 UPD42 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS32 MOV43 INS38 UPD42 UPD42 INS40 INS42 INS42 INS42 INS42 INS32 INS42 INS42 UPD42 MOV43 INS42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL9 DEL7 DEL21 DEL42 DEL9 DEL7 DEL21 DEL8 DEL83 DEL52 DEL83 DEL52 DEL42 DEL44 DEL83 DEL42 DEL52 DEL52 DEL52
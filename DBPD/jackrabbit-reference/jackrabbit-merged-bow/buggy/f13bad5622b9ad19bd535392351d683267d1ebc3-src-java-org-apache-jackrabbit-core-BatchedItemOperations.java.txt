more NodeState optimizations: 
- changed get/setPropertyNames from List to Set since the spec does not
  mandate that properties have to maintain order


git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@202166 13f79535-47bb-0310-9956-ffa450edef68

-        // remove child nodes
-        // use temp array to avoid ConcurrentModificationException
-        ArrayList tmp = new ArrayList(targetState.getChildNodeEntries());
-        // remove from tail to avoid problems with same-name siblings
-        for (int i = tmp.size() - 1; i >= 0; i--) {
-            NodeState.ChildNodeEntry entry = (NodeState.ChildNodeEntry) tmp.get(i);
-            NodeId nodeId = new NodeId(entry.getUUID());
-            try {
-                NodeState nodeState = (NodeState) stateMgr.getItemState(nodeId);
-                // check if child node can be removed
-                // (access rights, locking & versioning status);
-                // referential integrity (references) is checked
-                // on commit
-                checkRemoveNode(nodeState, (NodeId) targetState.getId(),
-                        CHECK_ACCESS
-                        | CHECK_LOCK
-                        | CHECK_VERSIONING);
-                // remove child node
-                recursiveRemoveNodeState(nodeState);
-            } catch (ItemStateException ise) {
-                String msg = "internal error: failed to retrieve state of "
-                        + nodeId;
-                log.debug(msg);
-                throw new RepositoryException(msg, ise);
+        if (targetState.hasChildNodeEntries()) {
+            // remove child nodes
+            // use temp array to avoid ConcurrentModificationException
+            ArrayList tmp = new ArrayList(targetState.getChildNodeEntries());
+            // remove from tail to avoid problems with same-name siblings
+            for (int i = tmp.size() - 1; i >= 0; i--) {
+                NodeState.ChildNodeEntry entry = (NodeState.ChildNodeEntry) tmp.get(i);
+                NodeId nodeId = new NodeId(entry.getUUID());
+                try {
+                    NodeState nodeState = (NodeState) stateMgr.getItemState(nodeId);
+                    // check if child node can be removed
+                    // (access rights, locking & versioning status);
+                    // referential integrity (references) is checked
+                    // on commit
+                    checkRemoveNode(nodeState, (NodeId) targetState.getId(),
+                            CHECK_ACCESS
+                            | CHECK_LOCK
+                            | CHECK_VERSIONING);
+                    // remove child node
+                    recursiveRemoveNodeState(nodeState);
+                } catch (ItemStateException ise) {
+                    String msg = "internal error: failed to retrieve state of "
+                            + nodeId;
+                    log.debug(msg);
+                    throw new RepositoryException(msg, ise);
+                }
+                // remove child node entry
+                targetState.removeChildNodeEntry(entry.getName(), entry.getIndex());
-            // remove child node entry
-            targetState.removeChildNodeEntry(entry.getName(), entry.getIndex());
-        // use temp array to avoid ConcurrentModificationException
-        tmp = new ArrayList(targetState.getPropertyNames());
-        for (int i = 0; i < tmp.size(); i++) {
-            QName propName = (QName) tmp.get(i);
+        // use temp set to avoid ConcurrentModificationException
+        HashSet tmp = new HashSet(targetState.getPropertyNames());
+        for (Iterator iter = tmp.iterator(); iter.hasNext();) {
+            QName propName = (QName) iter.next();

INS25 INS60 INS32 INS8 INS43 INS59 INS58 INS32 INS42 INS42 MOV60 MOV24 INS42 INS42 MOV14 INS43 INS59 INS42 INS42 UPD43 INS42 INS42 INS32 MOV43 UPD42 MOV42 UPD42 MOV42 MOV43 UPD42 UPD42 DEL42 DEL7 DEL21 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL32 DEL27 DEL42 DEL37 DEL42
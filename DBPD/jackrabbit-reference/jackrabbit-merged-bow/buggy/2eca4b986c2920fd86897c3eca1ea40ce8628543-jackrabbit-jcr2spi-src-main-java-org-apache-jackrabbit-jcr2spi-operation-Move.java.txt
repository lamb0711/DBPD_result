JCR-1799 updating events swallowed (CacheBehavior.OBSERVATION)   	
JCR-1783 incomplete changelog when combining move with removal of new destination parent

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@704361 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.util.LogUtil;
-import org.apache.jackrabbit.spi.Path;
+import org.apache.jackrabbit.jcr2spi.util.LogUtil;
+import org.apache.jackrabbit.spi.Path;
-import org.slf4j.LoggerFactory;
+import org.slf4j.LoggerFactory;
-import javax.jcr.RepositoryException;
-import javax.jcr.UnsupportedRepositoryOperationException;
-import javax.jcr.version.VersionException;
+import javax.jcr.RepositoryException;
+import javax.jcr.UnsupportedRepositoryOperationException;
+import javax.jcr.lock.LockException;
-import javax.jcr.lock.LockException;
+import javax.jcr.version.VersionException;
-    private Move(NodeState srcNodeState, NodeState srcParentState, NodeState destParentState, Name destName, boolean sessionMove) {
+    private Move(NodeState srcNodeState, NodeState srcParentState, NodeState destParentState, Name destName, boolean sessionMove)
+            throws RepositoryException {
+        assert status == STATUS_PENDING;
-    public void persisted() {
+    public void persisted() throws RepositoryException {
+        assert status == STATUS_PENDING;
+        status = STATUS_PERSISTED;
-            throw new UnsupportedOperationException("persisted() not implemented for transient modification.");
-        }
-        // non-recursive invalidation
-        try {
-            srcState.getNodeEntry().move(destName, destParentState.getNodeEntry(), false);
-            // TODO: TOBEFIXED. moved state ev. got a new definition.
-        } catch (RepositoryException e) {
-            // should not occure
-            log.error("Internal error", e);
-            srcParentState.getHierarchyEntry().invalidate(false);
-            destParentState.getHierarchyEntry().invalidate(false);
-            srcState.getHierarchyEntry().invalidate(false);
+            srcState.getNodeEntry().complete(this);
+        } else {
+            // non-recursive invalidation
+            try {
+                srcState.getNodeEntry().move(destName, destParentState.getNodeEntry(), false);
+                // TODO: TOBEFIXED. moved state ev. got a new definition.
+            } catch (RepositoryException e) {
+                // should not occure
+                log.error("Internal error", e);
+                srcParentState.getHierarchyEntry().invalidate(false);
+                destParentState.getHierarchyEntry().invalidate(false);
+                srcState.getHierarchyEntry().invalidate(false);
+            }
+
+    /**
+     * @see Operation#undo()
+     */
+    public void undo() throws RepositoryException {
+        assert status == STATUS_PENDING;
+        if (sessionMove) {
+            status = STATUS_UNDO;
+            srcState.getHierarchyEntry().complete(this);
+        } else {
+            super.undo();
+        }
+    }
+
-        // for session-move perform a lazy check for existing items at destination.
-        // since the hierarchy may not be complete it is possible that an conflict
-        // is only detected upon saving the 'move'.
-        NodeEntry destEntry = (NodeEntry) destParentState.getHierarchyEntry();
-        if (destEntry.hasPropertyEntry(destName) && sessionMove) {
-            throw new ItemExistsException("Move destination already exists (Property).");
-        }
-        // force childnodeentries list to be present before the move is executed
-        // on the hierarchy entry.
-        if (destEntry.hasNodeEntry(destName)) {
-            NodeEntry existing = destEntry.getNodeEntry(destName, Path.INDEX_DEFAULT);
-            if (existing != null && sessionMove) {
-                try {
-                    if (!existing.getNodeState().getDefinition().allowsSameNameSiblings()) {
-                        throw new ItemExistsException("Node existing at move destination does not allow same name siblings.");
+        if (sessionMove) {
+            NodeEntry destEntry = (NodeEntry) destParentState.getHierarchyEntry();
+            if (destEntry.hasPropertyEntry(destName)) {
+                // TODO: remove for 283
+                throw new ItemExistsException("Move destination already exists (Property).");
+            }
+
+            // force childnodeentries list to be present before the move is executed
+            // on the hierarchy entry.
+            assertChildNodeEntries(srcParentState);
+            assertChildNodeEntries(destParentState);
+
+            if (destEntry.hasNodeEntry(destName)) {
+                NodeEntry existing = destEntry.getNodeEntry(destName, Path.INDEX_DEFAULT);
+                if (existing != null && sessionMove) {
+                    try {
+                        if (!existing.getNodeState().getDefinition().allowsSameNameSiblings()) {
+                            throw new ItemExistsException("Node existing at move destination does not allow same name siblings.");
+                        }
+                    } catch (ItemNotFoundException e) {
+                        // existing apparent not valid any more -> probably no conflict
-                } catch (ItemNotFoundException e) {
-                    // existing apparent not valid any more -> probably no conflict

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS31 INS43 INS43 INS8 INS29 INS83 INS39 INS42 INS43 INS8 INS42 INS6 INS42 INS6 INS21 INS25 INS65 INS42 INS6 INS25 INS25 INS27 INS27 INS7 INS42 INS8 MOV8 INS68 INS27 INS42 INS8 INS8 INS42 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS21 INS21 INS21 MOV60 MOV25 INS21 INS21 MOV25 INS32 INS7 INS32 INS48 MOV32 INS32 INS32 INS32 INS42 INS52 INS42 INS42 INS32 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL42 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL42 DEL27
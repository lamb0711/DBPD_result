JCR-473: Some enhancements to jackrabbit commons

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@420449 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.util.XMLChar;
-import javax.jcr.NamespaceException;
-import javax.jcr.PathNotFoundException;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
+import javax.jcr.PathNotFoundException;
-    private static final PathElement ROOT_ELEMENT = new RootElement();
+    public static final PathElement ROOT_ELEMENT = new RootElement();
-    private static final PathElement CURRENT_ELEMENT = new CurrentElement();
+    public static final PathElement CURRENT_ELEMENT = new CurrentElement();
-    private static final PathElement PARENT_ELEMENT = new ParentElement();
+    public static final PathElement PARENT_ELEMENT = new ParentElement();
-     * Pattern used to validate and parse path elements:<p>
-     * <ul>
-     * <li>group 1 is .
-     * <li>group 2 is ..
-     * <li>group 3 is namespace prefix incl. delimiter (colon)
-     * <li>group 4 is namespace prefix excl. delimiter (colon)
-     * <li>group 5 is localName
-     * <li>group 6 is index incl. brackets
-     * <li>group 7 is index excl. brackets
-     * </ul>
+     * Constant representing an undefined index value
-    private static final Pattern PATH_ELEMENT_PATTERN =
-            Pattern.compile("(\\.)|"
-            + "(\\.\\.)|"
-            + "(([^ /:\\[\\]*'\"|](?:[^/:\\[\\]*'\"|]*[^ /:\\[\\]*'\"|])?):)?"
-            + "([^ /:\\[\\]*'\"|](?:[^/:\\[\\]*'\"|]*[^ /:\\[\\]*'\"|])?)"
-            + "(\\[([1-9]\\d*)\\])?");
+    public static final int INDEX_UNDEFINED = 0;
-     * Matcher instance as thread-local.
+     * Constant representing the default (initial) index value.
-    private static final ThreadLocal PATH_ELEMENT_MATCHER = new ThreadLocal() {
-        protected Object initialValue() {
-            return PATH_ELEMENT_PATTERN.matcher("dummy");
-        }
-    };
+    public static final int INDEX_DEFAULT = 1;
+
+    /**
+     * Constant defining the depth of the root path
+     */
+    public static final int ROOT_DEPTH = 0;
+     * @param elements
+     * @return
+     */
+    public static Path create(PathElement[] elements) {
+        // Path constructor uses elements array as is
+        // need to copy here because Path.create() is public
+        PathElement[] tmp = new PathElement[elements.length];
+        System.arraycopy(elements, 0, tmp, 0, elements.length);
+        return new Path(tmp, true);
+    }
+
+    /**
+     * @deprecated Use PathFormat#parse(String, NamespaceResolver)} instead.
-        Path path = parse(jcrPath, null, resolver);
+        Path path = PathFormat.parse(jcrPath, resolver);
+     * @deprecated Use {@link PathFormat#create(Path, String, NamespaceResolver)} instead.
-        Path path = parse(relJCRPath, parent, resolver);
+        Path path = PathFormat.parse(parent, relJCRPath, resolver);
-     * @throws MalformedPathException
+     * @throws MalformedPathException if <code>relPath</code> is absolute
-        PathBuilder pb = new PathBuilder(parent.getElements());
+        PathBuilder pb = new PathBuilder(parent);
-     * @param parent
-     * @param name
+     * @param parent the parent path
+     * @param name the name of the new path element.
-     * @return
-     * @throws MalformedPathException
+     * @return the new path.
-    public static Path create(Path parent, QName name, boolean normalize)
-            throws MalformedPathException {
-        PathBuilder pb = new PathBuilder(parent.getElements());
+    public static Path create(Path parent, QName name, boolean normalize) throws MalformedPathException {
+        PathBuilder pb = new PathBuilder(parent);
-     * and the give name and index. If <code>normalize</code> is
-     * <code>true</code>, the returned path will be normalized
-     * (or canonicalized, if the parent path is absolute).
+     * and the give name and index.
-     * @param parent
-     * @param name
-     * @param index
+     * @param parent the paren tpath.
+     * @param name the name of the new path element.
+     * @param index the index of the new path element.
-     * @return
-     * @throws MalformedPathException
+     * @return the new path.
-    public static Path create(Path parent, QName name, int index,
-                              boolean normalize)
+    public static Path create(Path parent, QName name, int index, boolean normalize)
-        PathBuilder pb = new PathBuilder(parent.getElements());
+        PathBuilder pb = new PathBuilder(parent);
-        if (index < 0) {
+        if (index < INDEX_UNDEFINED) {
-        if (index < 1) {
+        if (index < INDEX_DEFAULT) {
+     * @deprecated use {@link PathFormat#parse(Path, String, NamespaceResolver)} instead.
-        // shortcut
-        if ("/".equals(jcrPath)) {
-            return ROOT;
-        }
-
-        // split path into path elements
-        String[] elems = Text.explode(jcrPath, '/', true);
-        if (elems.length == 0) {
-            throw new MalformedPathException("empty path");
-        }
-
-        ArrayList list = new ArrayList();
-        boolean isNormalized = true;
-        boolean leadingParent = true;
-        if (master != null) {
-            isNormalized = master.normalized;
-            // a master path was specified; the 'path' argument is assumed
-            // to be a relative path
-            for (int i = 0; i < master.elements.length; i++) {
-                list.add(master.elements[i]);
-                leadingParent &= master.elements[i].denotesParent();
-            }
-        }
-
-        for (int i = 0; i < elems.length; i++) {
-            // validate & parse path element
-            String prefix;
-            String localName;
-            int index;
-
-            String elem = elems[i];
-            if (i == 0 && elem.length() == 0) {
-                // path is absolute, i.e. the first element is the root element
-                if (!list.isEmpty()) {
-                    throw new MalformedPathException("'" + jcrPath + "' is not a relative path");
-                }
-                list.add(ROOT_ELEMENT);
-                leadingParent = false;
-                continue;
-            }
-            if (elem.length() == 0 && i == elems.length - 1) {
-                // ignore trailing '/'
-                break;
-            }
-            Matcher matcher = (Matcher) PATH_ELEMENT_MATCHER.get();
-            matcher.reset(elem);
-            if (matcher.matches()) {
-                if (resolver == null) {
-                    // check only
-                    continue;
-                }
-
-                if (matcher.group(1) != null) {
-                    // group 1 is .
-                    list.add(CURRENT_ELEMENT);
-                    leadingParent = false;
-                    isNormalized = false;
-                } else if (matcher.group(2) != null) {
-                    // group 2 is ..
-                    list.add(PARENT_ELEMENT);
-                    isNormalized &= leadingParent;
-                } else {
-                    // element is a name
-
-                    // check for prefix (group 3)
-                    if (matcher.group(3) != null) {
-                        // prefix specified
-                        // group 4 is namespace prefix excl. delimiter (colon)
-                        prefix = matcher.group(4);
-                        // check if the prefix is a valid XML prefix
-                        if (!XMLChar.isValidNCName(prefix)) {
-                            // illegal syntax for prefix
-                            throw new MalformedPathException("'" + jcrPath + "' is not a valid path: '"
-                                    + elem + "' specifies an illegal namespace prefix");
-                        }
-                    } else {
-                        // no prefix specified
-                        prefix = "";
-                    }
-
-                    // group 5 is localName
-                    localName = matcher.group(5);
-
-                    // check for index (group 6)
-                    if (matcher.group(6) != null) {
-                        // index specified
-                        // group 7 is index excl. brackets
-                        index = Integer.parseInt(matcher.group(7));
-                    } else {
-                        // no index specified
-                        index = 0;
-                    }
-
-                    String nsURI;
-                    try {
-                        nsURI = resolver.getURI(prefix);
-                    } catch (NamespaceException nse) {
-                        // unknown prefix
-                        throw new MalformedPathException("'" + jcrPath + "' is not a valid path: '"
-                                + elem + "' specifies an unmapped namespace prefix");
-                    }
-
-                    PathElement element;
-                    if (index == 0) {
-                        element = new PathElement(nsURI, localName);
-                    } else {
-                        element = new PathElement(nsURI, localName, index);
-                    }
-                    list.add(element);
-                    leadingParent = false;
-                }
-            } else {
-                // illegal syntax for path element
-                throw new MalformedPathException("'" + jcrPath + "' is not a valid path: '"
-                        + elem + "' is not a legal path element");
-            }
-        }
-        if (resolver != null) {
-            return new Path((PathElement[]) list.toArray(new PathElement[list.size()]),
-                    isNormalized);
-        } else {
-            return null;
-        }
+        return PathFormat.parse(master, jcrPath, resolver);
+     * @deprecated Use {@link PathFormat#checkFormat(String)} instead.
-        parse(jcrPath, null, null);
+        PathFormat.checkFormat(jcrPath);
-        for (int i = 0; i < p0.elements.length && i < p1.elements.length; i++) {
-            if (!p0.elements[i].equals(p1.elements[i])) {
+        for (int i = 0; i < p0.getElements().length && i < p1.getElements().length; i++) {
+            if (!p0.getElement(i).equals(p1.getElement(i))) {
-        if (lengthCommon < p0.elements.length) {
+        if (lengthCommon < p0.getElements().length) {
-            int tmp = p0.elements.length - lengthCommon;
+            int tmp = p0.getElements().length - lengthCommon;
-        for (int i = lengthCommon; i < p1.elements.length; i++) {
-            pb.addLast(p1.elements[i]);
+        for (int i = lengthCommon; i < p1.getElements().length; i++) {
+            pb.addLast(p1.getElement(i));
-        int depth = 0;
+        int depth = ROOT_DEPTH;
-        for (int i = 0; i < p0.elements.length; i++) {
-            if (!p0.elements[i].equals(p1.elements[i])) {
+        for (int i = 0; i < p0.getElements().length; i++) {
+            if (!p0.getElement(i).equals(p1.getElement(i))) {
+     * Returns the <code>i</code><sup>th</sup> element of this path.
+     *
+     * @param i element index.
+     * @return the <code>i</code><sup>th</sup> element of this path.
+     * @throws ArrayIndexOutOfBoundsException if this path does not have an
+     * element at index <code>i</code>.
+     */
+    public PathElement getElement(int i) {
+        return elements[i];
+    }
+
+    /**
+     * @deprecated Use {@link PathFormat#format(Path, NamespaceResolver} instead.
-    public String toJCRPath(NamespaceResolver resolver)
-            throws NoPrefixDeclaredException {
-        if (denotesRoot()) {
-            // shortcut
-            return "/";
-        }
-        StringBuffer sb = new StringBuffer();
-        for (int i = 0; i < elements.length; i++) {
-            if (i > 0) {
-                sb.append('/');
-            }
-            PathElement element = elements[i];
-            // name
-            element.toJCRName(resolver, sb);
-        }
-        return sb.toString();
+    public String toJCRPath(NamespaceResolver resolver) throws NoPrefixDeclaredException {
+        return PathFormat.format(this, resolver);
+    //---------------------------------------------------------------< Object >
-            return Arrays.equals(elements, other.elements);
+            return Arrays.equals(elements, other.getElements());
+         * Creates a new PathBuilder and initialized it with elements of the
+         * given path.
+         *
+         * @param parent
+         */
+        public PathBuilder(Path parent) {
+            this();
+            addAll(parent.getElements());
+        }
+
+        /**
-            super(QName.NS_DEFAULT_URI, "");
+            super(QName.ROOT);
-        // PathElement override
+        /**
+         * Returns true.
+         * @return true
+         * @see PathElement#denotesRoot()
+         */
-        // PathElement override
+        /**
+         * Returns false.
+         * @return false
+         * @see PathElement#denotesCurrent()
+         */
-        // PathElement override
+        /**
+         * Returns false.
+         * @return false
+         * @see PathElement#denotesParent()
+         */
-        // PathElement override
+        /**
+         * Returns false.
+         * @return false
+         * @see PathElement#denotesName()
+         */
-        // PathElement override
-        public String toJCRName(NamespaceResolver resolver)
-                throws NoPrefixDeclaredException {
-            return "";
-        }
-
-        // Object override
+        /**
+         * @return {@link #LITERAL}
+         * @see Object#toString()
+         */
-        // PathElement override
+        /**
+         * Returns false.
+         * @return false
+         * @see PathElement#denotesRoot()
+         */
-        // PathElement override
+        /**
+         * Returns true.
+         * @return true
+         */
-        // PathElement override
+        /**
+         * Returns false.
+         * @return false
+         * @see PathElement#denotesParent()
+         */
-        // PathElement override
+        /**
+         * Returns false.
+         * @return false
+         * @see PathElement#denotesName()
+         */
-        // PathElement override
+        /**
+         * Returns the JCR name of this path element.
+         *
+         * @param resolver
+         * @return {@link #LITERAL}
+         */
-        // Object override
+
+        /**
+         * @return {@link #LITERAL}
+         * @see Object#toString()
+         */
-    public static final class ParentElement extends PathElement {
+    private static final class ParentElement extends PathElement {
-        // PathElement override
+        /**
+         * Returns false.
+         * @return false
+         * @see PathElement#denotesRoot()
+         */
-        // PathElement override
+        /**
+         * Returns false.
+         * @return false
+         * @see PathElement#denotesCurrent()
+         */
-        // PathElement override
+        /**
+         * Returns true.
+         * @return true
+         * @see PathElement#denotesParent()
+         */
-        // PathElement override
+        /**
+         * Returns false.
+         * @return false
+         * @see PathElement#denotesName()
+         */
-        // PathElement override
+        /**
+         * Returns the JCR name of this path element.
+         *
+         * @param resolver
+         * @return {@link #LITERAL}
+         */
-        // Object override
+        /**
+         * @return {@link #LITERAL}
+         * @see Object#toString()
+         */
-            this.index = 0;
+            this.index = INDEX_UNDEFINED;
-            if (index < 1) {
+            if (index < INDEX_DEFAULT) {
+         * Returns the normalized index of this path element, i.e. the index
+         * is always equals or greater that {@link #INDEX_DEFAULT}.
+         */
+        public int getNormalizedIndex() {
+            if (index == INDEX_UNDEFINED) {
+                return INDEX_DEFAULT;
+            } else {
+                return index;
+            }
+        }
+
+        /**
-            name.toJCRName(resolver, buf);
+            NameFormat.format(name, resolver, buf);
+         * @see Object#toString()
-            if (index > 0) {
+            if (index > INDEX_UNDEFINED) {

MOV26 INS23 INS31 INS31 INS31 UPD83 UPD83 UPD83 UPD83 INS39 UPD83 INS39 INS29 INS83 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS43 INS42 INS44 INS8 MOV29 INS83 INS83 MOV43 INS42 MOV44 MOV44 MOV44 MOV43 INS8 INS29 INS83 MOV43 INS42 INS44 INS8 INS8 INS31 INS31 UPD83 INS31 INS31 INS31 UPD42 INS34 UPD42 INS34 INS65 UPD42 MOV42 MOV34 INS65 INS65 INS42 INS5 INS42 MOV60 INS21 INS41 INS65 INS65 INS65 INS65 INS65 INS41 INS65 INS65 INS65 INS65 INS65 INS39 INS42 MOV41 INS65 INS41 INS29 INS83 INS42 INS44 INS8 INS29 MOV8 INS29 MOV8 INS29 MOV8 INS29 MOV8 INS29 MOV83 MOV43 MOV42 MOV8 INS29 MOV8 INS29 INS29 INS29 MOV8 INS29 MOV43 MOV8 INS29 MOV43 INS29 MOV8 INS29 MOV8 INS29 MOV8 INS29 MOV8 INS29 MOV83 MOV43 MOV42 MOV44 MOV43 MOV8 INS29 MOV83 MOV43 MOV42 MOV8 INS29 INS83 INS39 INS42 INS8 UPD66 UPD66 INS66 INS42 INS43 INS85 MOV5 INS32 INS14 INS66 INS66 INS65 INS66 INS66 MOV43 INS66 INS66 INS66 MOV43 MOV66 UPD66 MOV66 INS42 UPD66 MOV66 INS66 INS66 INS66 MOV43 INS66 INS65 INS66 INS32 INS66 INS65 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 MOV2 INS66 INS65 INS66 INS32 INS65 MOV65 INS43 INS42 INS17 INS21 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS25 INS65 UPD42 MOV42 UPD42 INS3 INS42 INS42 UPD42 MOV42 INS34 UPD42 MOV42 INS34 INS40 INS43 INS42 INS9 INS68 INS42 INS42 INS68 UPD42 MOV42 INS42 UPD42 MOV42 INS42 MOV42 INS68 UPD42 INS42 INS22 INS22 INS42 INS22 INS66 UPD42 MOV42 UPD42 MOV42 INS52 MOV42 INS66 INS66 INS42 INS32 UPD40 INS66 INS66 INS68 INS66 INS66 INS68 INS66 INS66 INS68 INS66 INS66 INS68 INS66 INS65 INS68 INS66 INS66 INS68 INS66 INS66 INS66 INS66 INS68 INS66 INS66 INS68 INS66 INS42 INS66 INS65 INS66 INS65 INS68 INS66 INS66 INS68 INS66 INS66 INS68 INS66 INS66 INS68 INS66 INS66 INS68 INS66 INS42 INS66 INS65 INS66 INS65 INS68 INS66 INS66 INS65 INS66 INS27 INS8 INS8 INS68 MOV5 INS40 UPD42 MOV42 INS42 INS42 INS42 INS69 INS69 INS69 INS42 INS42 MOV43 INS42 MOV43 INS42 MOV43 INS42 INS42 INS42 INS69 INS69 INS69 INS42 INS42 INS69 INS22 INS22 MOV8 INS32 INS42 INS32 INS42 INS32 INS42 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS67 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS67 INS67 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS67 INS67 INS42 INS42 INS42 INS42 INS67 INS42 INS42 INS41 INS41 UPD42 INS42 UPD42 INS42 INS42 INS42 INS43 MOV43 INS43 MOV43 MOV43 INS43 MOV43 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS22 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL42 DEL43 DEL42 DEL42 DEL45 DEL45 DEL45 DEL45 DEL45 DEL27 DEL32 DEL42 DEL43 DEL42 DEL43 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL45 DEL32 DEL41 DEL8 DEL31 DEL1 DEL14 DEL39 DEL33 DEL42 DEL42 DEL42 DEL32 DEL42 DEL65 DEL42 DEL42 DEL32 DEL66 DEL65 DEL42 DEL65 DEL34 DEL34 DEL83 DEL83 DEL42 DEL45 DEL42 DEL42 DEL32 DEL42 DEL41 DEL8 DEL25 DEL85 DEL5 DEL42 DEL42 DEL42 DEL42 DEL13 DEL9 DEL32 DEL59 DEL60 DEL40 DEL34 DEL27 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL39 DEL42 DEL9 DEL59 DEL60 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL40 DEL7 DEL21 DEL39 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL40 DEL42 DEL2 DEL32 DEL21 DEL42 DEL40 DEL42 DEL2 DEL42 DEL32 DEL7 DEL21 DEL8 DEL24 DEL8 DEL25 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL59 DEL60 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL2 DEL59 DEL60 DEL42 DEL34 DEL27 DEL42 DEL32 DEL34 DEL27 DEL27 DEL42 DEL32 DEL38 DEL42 DEL43 DEL45 DEL42 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL18 DEL8 DEL25 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL40 DEL34 DEL27 DEL27 DEL27 DEL25 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL33 DEL27 DEL18 DEL8 DEL25 DEL42 DEL42 DEL34 DEL32 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL42 DEL9 DEL7 DEL21 DEL8 DEL42 DEL42 DEL34 DEL32 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL7 DEL21 DEL8 DEL42 DEL34 DEL32 DEL33 DEL27 DEL42 DEL42 DEL34 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL38 DEL42 DEL43 DEL45 DEL42 DEL45 DEL42 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL8 DEL42 DEL45 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL34 DEL32 DEL7 DEL21 DEL42 DEL42 DEL34 DEL32 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL34 DEL32 DEL32 DEL7 DEL21 DEL8 DEL42 DEL34 DEL7 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL45 DEL42 DEL45 DEL42 DEL45 DEL27 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL34 DEL27 DEL42 DEL42 DEL43 DEL42 DEL42 DEL14 DEL7 DEL21 DEL8 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL14 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL25 DEL8 DEL42 DEL43 DEL45 DEL42 DEL45 DEL42 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL8 DEL24 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL3 DEL32 DEL11 DEL42 DEL14 DEL41 DEL8 DEL8 DEL25 DEL8 DEL31 DEL33 DEL33 DEL40 DEL40 DEL40 DEL42 DEL2 DEL40 DEL42 DEL2 DEL10 DEL8 DEL40 DEL40 DEL40 DEL40 DEL42 DEL2 DEL34 DEL40 DEL40 DEL42 DEL2 DEL40 DEL42 DEL2 DEL33 DEL42 DEL32 DEL45 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL34 DEL27 DEL42 DEL42 DEL13 DEL32 DEL21 DEL8 DEL25 DEL42 DEL59 DEL60 DEL42 DEL32 DEL21 DEL8 DEL24 DEL42 DEL42 DEL32 DEL41 DEL8 DEL40 DEL45 DEL83 DEL42 DEL45 DEL41 DEL8 DEL31 DEL31 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL31 DEL42 DEL43 DEL31 DEL34 DEL34 DEL34
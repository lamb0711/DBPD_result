JCR-2762: Optimize bundle serialization

Use a variable-length encoding for internal counts and lengths that are never negative and almost always small.

Optimize the property state header from 12 to 2 bytes in most cases.

Drop serialization of definition identifiers as they are no longer used in Jackrabbit.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1022487 13f79535-47bb-0310-9956-ffa450edef68

-        // definitionId
-        out.writeUTF("");
-
-        out.writeShort(bundle.getModCount());
+        writeInt(bundle.getModCount());
-     * Serializes a <code>PropertyState</code> to the data output stream
+     * Serializes a property entry. The serialization begins with a single
+     * byte that encodes the type and multi-valuedness of the property:
+     * <pre>
+     * +-------------------------------+
+     * |   mv count    |     type      |
+     * +-------------------------------+
+     * </pre>
+     * <p>
+     * The lower four bits encode the property type (0-12 in JCR 2.0) and
+     * higher bits indicate whether this is a multi-valued property and how
+     * many property values there are. A value of 0 is reserved for
+     * single-valued properties (that are guaranteed to always have just a
+     * single value), and all non-zero values indicate a multi-valued property.
+     * <p>
+     * In multi-valued properties the exact value of the "mv count" field is
+     * the number of property values plus one and truncated at 15 (the highest
+     * four-bit value). If there are 14 or more (14 + 1 == 15) property values,
+     * then the number of additional values is serialized as a variable-length
+     * integer (see {@link #writeInt(int)}) right after this byte.
+     * <p>
+     * The modification count of the property state is written next as a
+     * variable-length integer, followed by the serializations of all the
+     * values of this property.
-        // type & mod count
-        out.writeInt(state.getType() | (state.getModCount() << 16));
-        // multiValued
-        out.writeBoolean(state.isMultiValued());
-        // definitionId
-        out.writeUTF("");
-        // values
-        out.writeInt(values.length); // count
+
+        int type = state.getType();
+        assert 0 <= type && type <= 0x0f;
+        if (state.isMultiValued()) {
+            int len = values.length + 1;
+            if (len < 0x0f) {
+                out.writeByte(len << 4 | type);
+            } else {
+                out.writeByte(0xf0 | type);
+                writeInt(len - 0x0f);
+            }
+        } else {
+            assert values.length == 1;
+            out.writeByte(type);
+        }
+
+        writeInt(state.getModCount());
+
+        // values
-                    out.writeInt(bytes.length); // length of byte[]
+                    writeInt(bytes.length); // length of byte[]
+    /**
+     * Serializes an integer using a variable-length encoding that favors
+     * small positive numbers. The serialization consists of one to five
+     * bytes of the following format:
+     * <pre>
+     * +-------------------------------+
+     * | c | 7 least significant bits  |
+     * +-------------------------------+
+     * </pre>
+     * <p>
+     * If the given integer fits in seven bits (i.e. the value between
+     * 0 and 127, inclusive), then it is written as-is in a single byte.
+     * Otherwise the continuation flag <code>c</code> is set and the least
+     * significant seven bits are written together with the flag as a single
+     * byte. The integer is then shifed right seven bits and the process
+     * continues from the beginning.
+     * <p>
+     * This format uses a single byte for values 0-127, two bytes for
+     * 128-16343, three for 16343-2097151, four for 2097152-268435455
+     * and five bytes for all other 32-bit numbers (including negative ones).
+     *
+     * @param integer integer value
+     * @throws IOException if an I/O error occurs
+     */
+    private void writeInt(int value) throws IOException {
+        int b = value & 0x7f;
+        if (b == value) {
+            out.writeByte(b);
+        } else {
+            out.writeByte(b | 0x80);
+            writeInt(value >>> 7);
+        }
+    }
+

INS31 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS60 INS6 INS25 INS21 INS65 INS65 INS65 INS39 INS42 INS42 INS60 INS25 UPD66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS39 INS59 INS27 MOV32 INS8 INS8 INS32 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS39 INS59 INS27 INS8 INS8 UPD42 INS68 INS42 MOV32 INS27 INS27 INS60 INS25 INS6 MOV21 INS42 MOV32 INS42 INS27 INS42 INS42 INS21 INS21 INS21 INS42 INS69 INS34 INS42 INS42 INS34 INS39 INS59 INS27 INS8 INS8 INS27 INS42 INS34 INS32 INS32 INS32 INS39 INS42 INS27 INS42 INS34 MOV21 MOV21 MOV21 INS40 INS34 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS27 INS40 INS34 INS42 INS34 INS42 INS34 UPD42 UPD42 INS27 UPD42 INS27 INS27 INS42 INS34 INS42 INS42 INS34 INS42 UPD34 MOV34 DEL42 DEL42 DEL45 DEL32 DEL21 DEL42 DEL27 DEL36 DEL42 DEL45 DEL40 DEL42
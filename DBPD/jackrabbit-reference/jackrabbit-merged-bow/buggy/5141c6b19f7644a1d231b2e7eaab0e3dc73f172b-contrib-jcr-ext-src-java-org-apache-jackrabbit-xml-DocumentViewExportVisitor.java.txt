JCR-EXT: Upgrade DocumentViewExportVisitor to JCR 1.0.

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@328808 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
-import javax.jcr.Item;
-import org.apache.jackrabbit.name.IllegalNameException;
-import org.apache.jackrabbit.name.NoPrefixDeclaredException;
-import org.apache.jackrabbit.name.SessionNamespaceResolver;
-import org.apache.jackrabbit.name.UnknownPrefixException;
- *     Node parent = ...;
+ *     final Node parent = ...;
- *                 return (node.getDepth() <= root.getDepth() + 2);
+ *                 return (node.getDepth() <= parent.getDepth() + 2);
- * can be implemented in terms of the above method and the XMLSerializer
- * class from the Xerces library:
+ * can be implemented in terms of the above method:
- * import org.apache.xml.serialize.XMLSerializer;
- * import org.apache.xml.serialize.OutputFormat;
- *
- *             XMLSerializer serializer =
- *                 new XMLSerializer(output, new OutputFormat());
- *             exportDocView(
- *                     absPath, serializer.asContentHandler(),
- *                     binaryAsLink, noRecurse);
+ *             SAXTransformerFactory factory = (SAXTransformerFactory)
+ *                 SAXTransformerFactory.newInstance();
+ *             TransformerHandler handler = factory.newTransformerHandler();
+ *             handler.setResult(new StreamResult(out));
+ *             exportDocumentView(absPath, handler, skipBinary, noRecurse);
+ *         } catch (TransformerConfigurationException e) {
+ *             throw new IOException(
+ *                     "Unable to configure a SAX transformer: " + e.getMessage());
- *             throw new IOException(e.getMessage());
+ *             throw new IOException(
+ *                     "Unable to serialize a SAX stream: " + e.getMessage());
-    protected Node root;
+    private Node root;
+
+    /**
+     * The current session.
+     */
+    private Session session;
+
+    /**
+     * The prefix mapped to the <code>http://www.jcp.org/jcr/1.0</code>
+     * namespace in the current session.
+     */
+    private String jcr;
+                session = node.getSession();
+                jcr = session.getNamespacePrefix(QName.NS_JCR_URI); 
-                Session session = root.getSession();
-                    handler.startPrefixMapping(prefixes[i],
-                            session.getNamespaceURI(prefixes[i]));
+                    String uri = session.getNamespaceURI(prefixes[i]);
+                    if (!uri.equals(QName.NS_XML_URI)) {
+                        handler.startPrefixMapping(prefixes[i], uri);
+                    }
-            if (!node.getName().equals(QName.JCR_XMLTEXT)) {
-                exportNode(node);
+            String name = node.getName();
+            if (!name.equals(jcr + ":xmltext")) {
+                int colon = name.indexOf(':');
+                if (colon != -1) {
+                    String prefix = name.substring(0, colon);
+                    name = name.substring(colon + 1);
+                    exportNode(node, prefix, escapeName(name));
+                } else if (name.length() > 0) {
+                    exportNode(node, "", escapeName(name));
+                } else {
+                    exportNode(node, jcr, "root");
+                }
+                String[] prefixes = session.getNamespacePrefixes();
+                for (int i = 0; i < prefixes.length; i++) {
+                    String uri = session.getNamespaceURI(prefixes[i]);
+                    if (!uri.equals(QName.NS_XML_URI)) {
+                        handler.endPrefixMapping(prefixes[i]);
+                    }
+                }
+        } catch (IOException e) {
+            throw new RepositoryException(e);
-            Property property = node.getProperty(
-                    QName.JCR_XMLCHARACTERS.toJCRName(
-                            new SessionNamespaceResolver(node.getSession())));
-            char[] characters = property.getString().toCharArray();
+            Property property = node.getProperty(jcr + ":xmlcharacters");
+            char[] characters = filterXML(property.getString());
-        } catch (NoPrefixDeclaredException ex) {
-            throw new RepositoryException(
-                    "The JCR namespace prefix is not available", ex);
-     * with the same name as this node, and maps node properties to
-     * attributes of the generated element. If the noRecurse flag is false,
-     * then child nodes are serialized as sub-elements.
+     * with the given name, and maps node properties to attributes of the
+     * generated element. If the noRecurse flag is false, then child nodes
+     * are serialized as sub-elements.
+     * @param prefix namespace prefix
+     * @param name escaped local name
+     * @throws IOException if a problem with binary values occurred
-    private void exportNode(Node node)
-            throws SAXException, RepositoryException {
-        QName name = getName(node);
-        String localName = escapeName(name.getLocalName());
-        String prefixedName =
-            node.getSession().getNamespacePrefix(name.getNamespaceURI())
-            + ":" + localName;
+    private void exportNode(Node node, String prefix, String name)
+            throws IOException, SAXException, RepositoryException {
+        // Set up element name components
+        String prefixedName = name;
+        if (prefix.length() > 0) {
+            prefixedName = prefix + ":" + name;
+        } else {
+            prefixedName = name;
+        }
+        String uri = session.getNamespaceURI(prefix);
+        if (uri.length() == 0) {
+            uri = null;
+        }
-        handler.startElement(
-                name.getNamespaceURI(), localName, prefixedName,
-                getAttributes(node));
+        handler.startElement(uri, name, prefixedName, getAttributes(node));
-        handler.endElement(
-                name.getNamespaceURI(), name.getLocalName(), node.getName());
+        handler.endElement(uri, name, prefixedName);
+     * @throws IOException if a problem with binary values occurred
-    private Attributes getAttributes(Node node) throws RepositoryException {
-        try {
-            AttributesImpl attributes = new AttributesImpl();
-            
-            PropertyIterator properties = node.getProperties();
-            while (properties.hasNext()) {
-                Property property = properties.nextProperty();
-                /*
-                 return !property.getName().equals(XMLCHARACTERS)
-                 && (!skipBinary || property.getType() != PropertyType.BINARY);
-                 */
-                if (includeProperty(property)) {
-                    QName name = getName(property);
-                    attributes.addAttribute(
-                            name.getNamespaceURI(),
-                            escapeName(name.getLocalName()),
-                            escapeName(name.toJCRName(
-                                    new SessionNamespaceResolver(property.getSession()))),
-                                    "CDATA", escapeValue(property));
+    private Attributes getAttributes(Node node)
+            throws IOException, RepositoryException {
+        AttributesImpl attributes = new AttributesImpl();
+        
+        PropertyIterator properties = node.getProperties();
+        while (properties.hasNext()) {
+            Property property = properties.nextProperty();
+            if (!(skipBinary && property.getType() == PropertyType.BINARY)
+                    && includeProperty(property)) {
+                String name = property.getName();
+                String value = escapeValue(property);
+
+                String prefixedName;
+                String uri;
+                int colon = name.indexOf(':');
+                if (colon != -1) {
+                    String prefix = name.substring(0, colon);
+                    uri = session.getNamespaceURI(prefix);
+                    name = escapeName(name.substring(colon + 1));
+                    prefixedName = prefix + ":" + name;
+                } else {
+                    uri = session.getNamespaceURI("");
+                    name = escapeName(name);
+                    prefixedName = name;
+                attributes.addAttribute(uri, name, prefixedName, "CDATA", value);
-            
-            return attributes;
-        } catch (NoPrefixDeclaredException e) {
-            throw new RepositoryException(e);
+        
+        return attributes;
-    /**
-     * Returns the qualified XML name of the given item. If the item name
-     * is prefixed, then the respective namespace URI is looked up from the
-     * session and returned as a part of the qualified name. If the item
-     * name is not prefixed, then the returned qualified name will use the
-     * null namespace and the default prefix. The local part of the qualified
-     * name will be escaped using ISO 9075 rules. If the given item is the
-     * root node, then the special name "jcr:root" is returned
-     * <p>
-     * See section 6.4.2 of the JCR specification for more details about
-     * name handling in the XML document view serialization.
-     *
-     * @param item the given item
-     * @return qualified XML name of the item
-     * @throws RepositoryException on repository errors
-     * @see Name
-     */
-    private QName getName(Item item) throws RepositoryException {
-        try {
-            String name = item.getName();
-            if (name.length() > 0) {
-                return QName.fromJCRName(name, new SessionNamespaceResolver(item.getSession()));
-            } else {
-                return QName.JCR_ROOT;
+    private static char[] filterXML(String value) {
+        char[] characters = value.toCharArray();
+        for (int i = 0; i < characters.length; i++) {
+            if (XMLChar.isInvalid(characters[i])) {
+                characters[i] = ' '; // TODO: What's the correct escape?
-        } catch (IllegalNameException e) {
-            throw new RepositoryException(e);
-        } catch (UnknownPrefixException e) {
-            throw new RepositoryException(e);
+        return characters;
-     * Escapes the given character into a hex escape sequence
-     * <code>_xXXXX_</code> where <code>XXXX</code> is the (uppercase)
-     * hexadecimal representation of the given character.
+     * Escapes the given JCR name according to the rules of section
+     * 6.4.3 of the JSR 170 specification.
-     * @param ch character to be escaped
-     * @return escape string
-     */
-    private static String escapeChar(char ch) {
-        String hex = "000" + Integer.toHexString((int) ch).toUpperCase();
-        return "_x" + hex.substring(hex.length() - 4) + "_";
-    }
-
-    /**
-     * Escapes the given name or prefix according to the rules of section
-     * 6.4.3 of the JSR 170 specification (version 0.16.2).
-     *
-     * @param name original name or prefix
-     * @return escaped name or prefix
+     * @param name JCR name
+     * @return escaped name
-        if (name.length() == 0) {
-            return name;
-        }
-
-        // First character
-        if (!XMLChar.isNameStart(name.charAt(0))
-            || name.startsWith("_x")
-            || (name.length() >= 3
-                && "xml".equalsIgnoreCase(name.substring(0, 3)))) {
-            buffer.append(escapeChar(name.charAt(0)));
-        } else {
-            buffer.append(name.charAt(0));
+        int colon = name.indexOf(':');
+        if (colon != -1) {
+            buffer.append(name.substring(0, colon + 1));
+            name = name.substring(colon + 1);
-        // Rest of the characters
-        for (int i = 1; i < name.length(); i++) {
-            if (!XMLChar.isName(name.charAt(i)) || name.startsWith("_x", i)) {
-                buffer.append(escapeChar(name.charAt(i)));
+        Pattern pattern = Pattern.compile("_([0-9a-fA-F]{4}_)");
+        Matcher matcher = pattern.matcher(name);
+        char[] characters = filterXML(matcher.replaceAll("_x005f_$1"));
+
+        for (int i = 0; i < characters.length; i++) {
+            char ch = characters[i];
+            if ((i == 0) ? XMLChar.isNCNameStart(ch) : XMLChar.isNCName(ch)) {
+                String hex = Integer.toHexString((int) ch);
+                buffer.append("_x");
+                for (int j = 4; j > hex.length(); j--) {
+                    buffer.append('0');
+                }
+                buffer.append(hex);
+                buffer.append('_');
-                buffer.append(name.charAt(i));
+                buffer.append(ch);
-     * Escapes the given value according to the rules of section 6.4.4 of
-     * the JSR 170 specification (version 0.16.2).
+     * Returns the string representation of the given value. Binary values
+     * are encoded in Base64, while other values are just converted to their
+     * string format.
+     * @param escape whether to apply value escapes
+     * @throws IOException if a problem with binary values occurred
+     * @throws RepositoryException on repository errors
-    private static String escapeValue(String value) {
-        StringBuffer buffer = new StringBuffer();
-
-        for (int i = 1; i < value.length(); i++) {
-            if (value.charAt(i) == ' ') {
-                buffer.append("_x0020_");
-            } else if (value.startsWith("_x", i)) {
-                buffer.append("_x005F_");
-            } else {
-                buffer.append(value.charAt(i));
+    private static String escapeValue(Value value, boolean escape)
+            throws IOException, RepositoryException {
+        if (value.getType() == PropertyType.BINARY) {
+            ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+            InputStream input = value.getStream();
+            try {
+                byte[] bytes = new byte[4096];
+                for (int n = input.read(bytes); n != -1; n = input.read(bytes)) {
+                    buffer.write(bytes, 0, n);
+                }
+            } finally {
+                input.close();
+            return new String(Base64.encodeBase64(buffer.toByteArray()), "ASCII");
+        } else if (escape) {
+            StringBuffer buffer = new StringBuffer();
+            Pattern pattern = Pattern.compile("_([0-9a-fA-F]{4}_)");
+            Matcher matcher = pattern.matcher(value.getString());
+            char[] characters = filterXML(matcher.replaceAll("_x005f_$1"));
+            for (int i = 0; i < characters.length; i++) {
+                if (characters[i] == ' ') {
+                    buffer.append("_x0020_");
+                } else if (characters[i] == '\t') {
+                    buffer.append("_x0009_");
+                } else if (characters[i] == '\r') {
+                    buffer.append("_x000D_");
+                } else if (characters[i] == '\n') {
+                    buffer.append("_x000A_");
+                } else {
+                    buffer.append(characters[i]);
+                }
+            }
+            return buffer.toString();
+        } else {
+            return new String(filterXML(value.getString()));
-
-        return buffer.toString();
+     * @throws IOException if a problem with binary values occurred
-            throws RepositoryException {
-        try {
-            if (property.getDefinition().isMultiple()) {
-                StringBuffer buffer = new StringBuffer();
-
-                Value[] values = property.getValues();
-                for (int i = 0; i < values.length; i++) {
-                    if (i > 0) {
-                        buffer.append(' ');
-                    }
-                    if (values[i].getType() == PropertyType.BINARY) {
-                        buffer.append(encodeValue(values[i].getStream()));
-                    } else {
-                        buffer.append(escapeValue(values[i].getString()));
-                    }
+            throws IOException, RepositoryException {
+        if (property.getDefinition().isMultiple()) {
+            StringBuffer buffer = new StringBuffer();
+            Value[] values = property.getValues();
+            for (int i = 0; i < values.length; i++) {
+                if (i > 0) {
+                    buffer.append(' ');
-
-                return buffer.toString();
-            } else if (property.getType() == PropertyType.BINARY) {
-                return encodeValue(property.getStream());
-            } else {
-                return property.getString();
+                buffer.append(escapeValue(values[i], true));
-        } catch (IOException ex) {
-            throw new RepositoryException(ex);
+            return buffer.toString();
+        } else {
+            return escapeValue(property.getValue(), false);
-    /**
-     * Encodes the given binary stream using Base64 encoding.
-     *
-     * @param input original binary value
-     * @return Base64-encoded value
-     * @throws IOException on IO errors
-     */
-    private static String encodeValue(InputStream input) throws IOException {
-        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
-        byte[] bytes = new byte[4096];
-        for (int n = input.read(bytes); n != -1; n = input.read(bytes)) {
-            buffer.write(bytes, 0, n);
-        }
-        return
-            new String(Base64.encodeBase64(buffer.toByteArray()), "US-ASCII");
-    }
-

MOV26 UPD40 UPD40 INS23 INS23 INS31 INS31 UPD83 INS29 INS83 MOV43 INS59 INS29 INS83 MOV43 INS59 INS44 INS44 INS43 INS8 MOV29 INS83 MOV43 MOV42 MOV44 INS43 MOV43 INS8 INS5 UPD42 MOV44 INS8 MOV43 MOV29 MOV83 MOV83 MOV43 MOV42 INS44 INS44 MOV43 MOV43 INS8 INS43 MOV8 UPD66 UPD66 UPD66 INS66 INS66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 INS66 INS65 INS42 INS65 INS42 INS65 INS65 INS65 MOV43 INS42 INS43 INS42 INS42 INS60 INS25 INS60 INS25 MOV21 MOV25 MOV21 INS65 INS42 MOV60 MOV60 INS61 MOV41 INS39 INS85 INS60 INS24 INS41 INS60 INS25 INS60 INS60 INS60 INS65 INS65 MOV65 INS43 INS42 INS39 INS42 INS25 INS65 MOV42 INS66 INS66 INS66 INS12 UPD66 UPD66 UPD66 INS42 INS66 INS42 INS66 INS42 INS66 UPD42 MOV42 MOV43 INS59 INS27 INS8 INS8 MOV43 INS59 INS27 INS8 INS42 INS66 MOV32 INS8 INS5 INS59 INS58 INS27 MOV37 INS8 INS42 UPD66 UPD66 UPD66 UPD66 INS39 INS59 INS27 INS8 INS43 INS59 INS43 INS59 INS5 INS59 INS37 UPD66 UPD66 INS66 INS42 INS66 INS42 INS66 INS42 INS27 MOV8 INS25 INS42 INS66 MOV8 INS60 INS25 INS44 MOV8 UPD42 MOV42 INS42 INS32 INS34 INS21 INS21 INS42 INS32 INS32 INS34 INS21 UPD42 MOV42 UPD42 UPD42 MOV42 MOV42 UPD42 MOV42 MOV60 INS25 INS39 INS85 INS42 INS32 INS39 INS59 INS42 INS40 INS25 INS42 INS32 INS42 INS38 INS21 INS21 INS42 INS42 INS32 INS42 INS42 INS32 INS39 INS85 INS42 INS32 INS40 INS42 INS60 INS32 INS40 INS60 INS54 INS42 INS8 INS8 INS43 INS59 INS8 MOV27 INS8 MOV43 INS42 UPD42 MOV42 UPD42 MOV42 INS7 INS7 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 INS7 INS27 INS8 INS42 INS42 INS42 INS34 INS32 INS8 MOV42 UPD42 MOV42 INS13 INS34 INS32 INS7 UPD42 MOV42 UPD42 MOV42 INS45 INS42 UPD42 MOV42 MOV42 UPD42 MOV42 MOV32 UPD34 INS39 INS59 INS16 INS8 INS42 INS42 MOV43 INS59 INS8 INS8 MOV60 INS60 INS60 INS60 MOV24 MOV41 INS41 MOV8 INS21 INS21 INS42 INS42 MOV32 INS60 INS25 INS60 INS24 MOV21 INS42 MOV32 INS42 INS27 INS42 INS42 INS42 INS33 INS38 MOV32 MOV60 INS60 INS60 INS60 INS60 INS25 INS21 UPD42 MOV42 UPD42 MOV42 INS2 INS21 UPD42 MOV42 UPD42 MOV42 MOV32 INS42 INS32 UPD42 UPD42 INS45 INS42 INS2 INS36 INS32 INS32 MOV60 INS21 INS24 INS21 INS21 INS42 INS32 MOV60 MOV24 INS21 UPD45 INS43 INS59 INS43 INS59 INS5 INS59 INS14 MOV25 UPD42 INS9 INS7 INS7 INS42 INS27 INS39 INS59 INS27 MOV8 INS25 INS5 INS59 INS58 INS27 INS37 INS8 INS27 UPD42 INS42 INS45 INS42 INS36 UPD43 INS43 INS59 INS43 INS59 INS43 INS59 INS39 INS59 INS27 INS8 INS8 INS32 INS42 INS42 INS7 UPD42 INS27 INS42 UPD42 MOV42 INS27 INS42 INS42 INS27 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS32 INS58 UPD27 MOV27 INS37 INS8 INS32 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS39 INS85 INS42 INS32 INS40 INS43 INS32 MOV32 UPD42 INS42 MOV32 INS42 INS32 INS60 INS25 INS42 INS45 INS42 INS32 INS42 INS38 INS60 INS21 MOV27 INS8 INS8 INS43 INS85 INS42 INS32 INS39 INS59 INS42 INS40 INS42 INS60 MOV25 INS42 INS45 INS27 UPD42 INS42 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS38 INS60 INS21 INS21 INS21 INS21 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS2 INS13 INS42 INS34 INS42 UPD34 MOV34 INS42 INS34 MOV32 UPD42 MOV42 UPD42 MOV42 MOV45 INS39 INS59 INS42 INS42 INS21 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS13 UPD42 MOV42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS32 INS42 INS32 UPD34 INS25 INS42 INS42 INS32 UPD42 INS42 MOV2 UPD42 MOV42 MOV42 INS42 INS42 INS40 INS43 INS59 INS38 INS8 INS42 INS42 INS13 INS34 INS43 INS59 INS7 INS21 INS21 INS42 INS42 INS42 INS42 INS34 INS43 INS59 INS38 INS42 MOV27 INS42 MOV42 UPD42 MOV42 INS13 INS34 MOV43 INS59 INS7 INS7 INS7 INS7 INS7 INS7 INS42 INS42 INS42 INS34 INS32 INS42 INS42 INS42 INS42 INS45 INS2 INS27 INS8 MOV25 INS42 INS42 UPD42 INS9 INS42 INS42 MOV32 INS32 MOV21 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS32 INS32 INS42 INS42 INS32 INS32 INS21 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS27 INS42 INS32 INS42 INS32 INS42 INS42 MOV42 MOV42 INS13 INS42 INS42 INS2 INS13 INS21 INS27 INS8 INS25 INS42 INS42 INS40 INS42 INS42 INS34 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS45 INS42 INS42 INS2 INS42 INS42 INS40 INS32 MOV42 UPD42 MOV42 INS34 UPD42 MOV42 INS42 INS42 INS42 INS42 INS32 INS42 INS45 INS42 UPD42 MOV42 UPD42 MOV42 INS45 UPD42 MOV42 MOV42 INS42 INS42 INS32 INS2 INS13 INS21 INS27 MOV8 MOV8 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS2 INS42 INS42 INS27 INS42 INS42 INS45 INS42 INS42 INS32 INS2 INS13 INS42 INS42 INS42 INS34 INS42 INS42 UPD45 MOV45 INS42 INS42 UPD45 INS2 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL66 DEL66 DEL66 DEL42 DEL32 DEL59 DEL60 DEL40 DEL40 DEL42 DEL42 DEL43 DEL14 DEL32 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL45 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL32 DEL32 DEL45 DEL42 DEL27 DEL59 DEL60 DEL8 DEL42 DEL83 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL42 DEL42 DEL43 DEL42 DEL32 DEL14 DEL32 DEL32 DEL45 DEL32 DEL21 DEL8 DEL25 DEL8 DEL61 DEL8 DEL42 DEL43 DEL42 DEL44 DEL12 DEL54 DEL8 DEL31 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL42 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL32 DEL41 DEL8 DEL40 DEL41 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL39 DEL42 DEL44 DEL45 DEL32 DEL45 DEL27 DEL41 DEL8 DEL32 DEL34 DEL27 DEL42 DEL41 DEL8 DEL25 DEL34 DEL32 DEL38 DEL42 DEL45 DEL32 DEL42 DEL42 DEL32 DEL27 DEL45 DEL42 DEL34 DEL34 DEL32 DEL32 DEL27 DEL36 DEL27 DEL42 DEL42 DEL42 DEL34 DEL32 DEL32 DEL32 DEL21 DEL8 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL45 DEL42 DEL32 DEL27 DEL34 DEL32 DEL32 DEL38 DEL42 DEL32 DEL27 DEL32 DEL32 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL8 DEL31 DEL42 DEL42 DEL32 DEL42 DEL42 DEL2 DEL42 DEL32 DEL40 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL2 DEL42 DEL32 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL42 DEL44 DEL31
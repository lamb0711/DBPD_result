JCR-275: added NodeTypeRegistry.unregisterNodeTypes(Collection)
- some additional cleaning up of implementation

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@376692 13f79535-47bb-0310-9956-ffa450edef68

-        try {
-            ntd = (NodeTypeDef) ntd.clone();
-        } catch (CloneNotSupportedException e) {
-            // should never get here
-            log.fatal("internal error", e);
-            throw new InternalError(e.getMessage());
-        }
+        ntd = (NodeTypeDef) ntd.clone();
-    private void internalUnregister(QName name)
-            throws NoSuchNodeTypeException, RepositoryException {
-        if (!registeredNTDefs.containsKey(name)) {
-            throw new NoSuchNodeTypeException(name.toString());
-        }
-        if (builtInNTDefs.contains(name)) {
-            throw new RepositoryException(name.toString()
-                    + ": can't unregister built-in node type.");
+    /**
+     * Validates and registers the specified collection of <code>NodeTypeDef</code>
+     * objects. An <code>InvalidNodeTypeDefException</code> is thrown if the
+     * validation of any of the contained <code>NodeTypeDef</code> objects fails.
+     * <p/>
+     * Note that in the case an exception is thrown no node type will be
+     * eventually registered.
+     *
+     * @param ntDefs collection of <code>NodeTypeDef</code> objects
+     * @throws InvalidNodeTypeDefException
+     * @throws RepositoryException
+     * @see #registerNodeType
+     */
+    private synchronized void internalRegister(Collection ntDefs)
+            throws InvalidNodeTypeDefException, RepositoryException {
+
+        // @todo review
+
+        // cache of pre-built aggregations of node types
+        EffectiveNodeTypeCache anEntCache = new EffectiveNodeTypeCache(entCache);
+
+        // map of node type names and node type definitions
+        Map aRegisteredNTDefCache = new HashMap(registeredNTDefs);
+
+        // temporarily register the node type definition
+        // and do some preliminary checks
+        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
+            NodeTypeDef ntd = (NodeTypeDef) iter.next();
+            QName name = ntd.getName();
+            if (name != null && registeredNTDefs.containsKey(name)) {
+                String msg = name + " already exists";
+                log.debug(msg);
+                throw new InvalidNodeTypeDefException(msg);
+            }
+            // add definition to temporary cache
+            aRegisteredNTDefCache.put(ntd.getName(), ntd);
+        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
+            NodeTypeDef ntd = (NodeTypeDef) iter.next();
+
+            EffectiveNodeType ent = validateNodeTypeDef(ntd, anEntCache, aRegisteredNTDefCache);
+
+            // store new effective node type instance
+            anEntCache.put(ent);
+        }
+
+        // since no exception was thrown so far the definitions are assumed to be valid
+        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
+            NodeTypeDef ntd = (NodeTypeDef) iter.next();
+
+            // register clone of node type definition
+            ntd = (NodeTypeDef) ntd.clone();
+            registeredNTDefs.put(ntd.getName(), ntd);
+            // store property & child node definitions of new node type by id
+            PropDef[] pda = ntd.getPropertyDefs();
+            for (int i = 0; i < pda.length; i++) {
+                propDefs.put(pda[i].getId(), pda[i]);
+            }
+            NodeDef[] nda = ntd.getChildNodeDefs();
+            for (int i = 0; i < nda.length; i++) {
+                nodeDefs.put(nda[i].getId(), nda[i]);
+            }
+        }
+    }
+
+    private void internalUnregister(QName name) throws NoSuchNodeTypeException {
+        if (ntd == null) {
+            throw new NoSuchNodeTypeException(name.toString());
+        }
-         * (collect keys first to prevent ConcurrentModificationException)
+         * (copy keys first to prevent ConcurrentModificationException)
-        Iterator iter = entCache.keys();
-        ArrayList keys = new ArrayList();
-        while (iter.hasNext()) {
-            keys.add(iter.next());
-        }
-        iter = keys.iterator();
-        while (iter.hasNext()) {
+        ArrayList keys = new ArrayList(entCache.keySet());
+        for (Iterator keysIter = keys.iterator(); keysIter.hasNext();) {
-                    (EffectiveNodeTypeCache.WeightedKey) iter.next();
+                    (EffectiveNodeTypeCache.WeightedKey) keysIter.next();
+    private void internalUnregister(Collection ntNames)
+            throws NoSuchNodeTypeException {
+        for (Iterator iter = ntNames.iterator(); iter.hasNext();) {
+            QName name = (QName) iter.next();
+            internalUnregister(name);
+        }
+    }
+
-    private EffectiveNodeType validateNodeTypeDef(NodeTypeDef ntd, EffectiveNodeTypeCache anEntCache, Map aRegisteredNTDefCache)
+    private EffectiveNodeType validateNodeTypeDef(NodeTypeDef ntd,
+                                                  EffectiveNodeTypeCache anEntCache,
+                                                  Map aRegisteredNTDefCache)
-    public synchronized EffectiveNodeType getEffectiveNodeType(QName ntName, EffectiveNodeTypeCache anEntCache, Map aRegisteredNTDefCache)
+    public synchronized EffectiveNodeType getEffectiveNodeType(QName ntName,
+                                                               EffectiveNodeTypeCache anEntCache,
+                                                               Map aRegisteredNTDefCache)
-            NodeTypeDef def = (NodeTypeDef) aRegisteredNTDefCache.get(ntName);
-            NodeTypeDef ntDef4ENT;
-            // return clone to make sure nobody messes around with the 'live' definition
-            try {
-                ntDef4ENT = (NodeTypeDef) def.clone();
-            } catch (CloneNotSupportedException e) {
-                // should never get here
-                log.fatal("internal error", e);
-                throw new InternalError(e.getMessage());
-            }
-            ent = EffectiveNodeType.create(this, ntDef4ENT, anEntCache, aRegisteredNTDefCache);
+            NodeTypeDef ntd = (NodeTypeDef) aRegisteredNTDefCache.get(ntName);
+            ent = EffectiveNodeType.create(this, ntd, anEntCache, aRegisteredNTDefCache);
-    public synchronized EffectiveNodeType getEffectiveNodeType(QName[] ntNames, EffectiveNodeTypeCache anEntCache, Map aRegisteredNTDefCache)
+    public synchronized EffectiveNodeType getEffectiveNodeType(QName[] ntNames,
+                                                               EffectiveNodeTypeCache anEntCache,
+                                                               Map aRegisteredNTDefCache)
-            Iterator iter = anEntCache.keys();
+            Iterator iter = anEntCache.keyIterator();
-                    NodeTypeDef def = (NodeTypeDef) aRegisteredNTDefCache.get(remainder[i]);
-                    NodeTypeDef clonedDef;
-                    // return clone to make sure nobody messes around with the 'live' definition
-                    try {
-                        clonedDef = (NodeTypeDef) def.clone();
-                    } catch (CloneNotSupportedException e) {
-                        // should never get here
-                        log.fatal("internal error", e);
-                        throw new InternalError(e.getMessage());
-                    }
-
+                    NodeTypeDef ntd = (NodeTypeDef) aRegisteredNTDefCache.get(remainder[i]);
-                            EffectiveNodeType.create(this, clonedDef, anEntCache, aRegisteredNTDefCache);
+                            EffectiveNodeType.create(this, ntd, anEntCache, aRegisteredNTDefCache);
-    void checkForCircularInheritance(QName[] supertypes, Stack inheritanceChain, Map aRegisteredNTDefCache)
+    void checkForCircularInheritance(QName[] supertypes,
+                                     Stack inheritanceChain,
+                                     Map aRegisteredNTDefCache)
-     * a registered <code>EffectiveNodeType</code> instance.
+     * an  <code>EffectiveNodeType</code> object representing the newly
+     * registered node type.
-     * <p/>
-     * Note that in the case an exception is thrown, some node types might have
-     * been nevertheless successfully registered.
-     * @param newNTDefs a collection of <code>NodeTypeDef<code>s
+     * @param ntDefs a collection of <code>NodeTypeDef<code> objects
-    public synchronized void registerNodeTypes(Collection newNTDefs)
+    public synchronized void registerNodeTypes(Collection ntDefs)
-        // exceptions that might be thrown by internalRegister(Collection)
-        RepositoryException re = null;
-        InvalidNodeTypeDefException intde = null;
-
-        try {
-            internalRegister(newNTDefs);
-        } catch (RepositoryException e) {
-            // store exception so it can be re-thrown later on
-            re = e;
-        } catch (InvalidNodeTypeDefException e) {
-            // store exception so it can be re-thrown later on
-            intde = e;
+        // validate and register new node type definitions
+        internalRegister(ntDefs);
+        // persist new node type definitions
+        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
+            NodeTypeDef ntDef = (NodeTypeDef) iter.next();
+            customNTDefs.add(ntDef);
-        boolean allNodeTypeDefsAreValid = re == null && intde == null;
-        if (allNodeTypeDefsAreValid) {
-            Iterator validNTDsIterator = newNTDefs.iterator();
-            while (validNTDsIterator.hasNext()) {
-                NodeTypeDef ntd = (NodeTypeDef) validNTDsIterator.next();
-                // store property & child node definitions of new node type by id
-                customNTDefs.add(ntd);
-            }
-            persistCustomNodeTypeDefs(customNTDefs);
-            // notify listeners
-            for (Iterator iter = newNTDefs.iterator(); iter.hasNext();) {
-                NodeTypeDef ntDef = (NodeTypeDef) iter.next();
-                notifyRegistered(ntDef.getName());
-            }
-        } else {
-            // re-throw the exception
-            if (re != null) {
-                throw re;
-            } else if (intde != null) {
-                throw intde;
-            }
-        }
-    }
-
-    /**
-     * Validates and registers the specified collection of <code>NodeTypeDef</code>
-     * objects. An <code>InvalidNodeTypeDefException</code> is thrown if the
-     * validation of any of the contained <code>NodeTypeDef</code> objects fails.
-     * <p/>
-     * Note that in the case an exception is thrown no node type will be
-     * registered.
-     *
-     * @param newNTDefs collection of <code>NodeTypeDef</code> objects
-     * @throws InvalidNodeTypeDefException
-     * @throws RepositoryException
-     * @see #registerNodeType
-     */
-    private synchronized void internalRegister(Collection newNTDefs)
-            throws InvalidNodeTypeDefException, RepositoryException {
-
-        // cache of pre-built aggregations of node types
-        EffectiveNodeTypeCache anEntCache = new EffectiveNodeTypeCache(entCache);
-        
-        // map of node type names and node type definitions
-        Map aRegisteredNTDefCache = new HashMap(registeredNTDefs);
-        
-        // temporarily register a clone of the node type definition
-        // and do some checks by the way
-        Iterator ntdNameIterator = newNTDefs.iterator();
-        while (ntdNameIterator.hasNext()) {
-            Object ntdObject = ntdNameIterator.next();
-            // check if the right type is used
-            if (!(ntdObject instanceof NodeTypeDef)) {
-                String msg = "The specified object is not of type "
-                        + NodeTypeDef.class.getName();
-                log.debug(msg);
-                throw new InvalidNodeTypeDefException(msg);
-            } else {
-                // check if the ntd is new
-                NodeTypeDef ntd = (NodeTypeDef) ntdObject;
-                QName name = ntd.getName();
-                if (name != null && registeredNTDefs.containsKey(name)) {
-                    String msg = name + " already exists";
-                    log.debug(msg);
-                    throw new InvalidNodeTypeDefException(msg);
-                }
-                // clone the ntd and add it to the cache
-                NodeTypeDef clonedNTD;
-                try {
-                    clonedNTD = (NodeTypeDef) ntd.clone();
-                } catch (CloneNotSupportedException e) {
-                    // should never get here
-                    log.fatal("internal error", e);
-                    throw new InternalError(e.getMessage());
-                }
-                aRegisteredNTDefCache.put(clonedNTD.getName(), clonedNTD);
-            }
-        }
-        Iterator ntdIterator = newNTDefs.iterator();
-        while (ntdIterator.hasNext()) {
-            NodeTypeDef ntd = (NodeTypeDef) ntdIterator.next();
-
-            EffectiveNodeType ent = validateNodeTypeDef(ntd, anEntCache, aRegisteredNTDefCache);
-
-            // store new effective node type instance
-            anEntCache.put(ent);
-        }
-        // as no exception occured at this point, the ntds are valid
-        Iterator validNTDsIterator = newNTDefs.iterator();
-        while (validNTDsIterator.hasNext()) {
-            NodeTypeDef ntd = (NodeTypeDef) validNTDsIterator.next();
-            registeredNTDefs.put(ntd.getName(), ntd);
-            // store property & child node definitions of new node type by id
-            PropDef[] pda = ntd.getPropertyDefs();
-            for (int i = 0; i < pda.length; i++) {
-                propDefs.put(pda[i].getId(), pda[i]);
-            }
-            NodeDef[] nda = ntd.getChildNodeDefs();
-            for (int i = 0; i < nda.length; i++) {
-                nodeDefs.put(nda[i].getId(), nda[i]);
-            }
-        }
-    }
-
-    /**
-     * @param nodeTypeName
-     * @throws NoSuchNodeTypeException
-     * @throws RepositoryException
-     */
-    public synchronized void unregisterNodeType(QName nodeTypeName)
-            throws NoSuchNodeTypeException, RepositoryException {
-        if (!registeredNTDefs.containsKey(nodeTypeName)) {
-            throw new NoSuchNodeTypeException(nodeTypeName.toString());
-        }
-        if (builtInNTDefs.contains(nodeTypeName)) {
-            throw new RepositoryException(nodeTypeName.toString()
-                    + ": can't unregister built-in node type.");
-        }
-
-        /**
-         * check if there are node types that have dependencies on the given
-         * node type
-         */
-        Set dependentNTs = getDependentNodeTypes(nodeTypeName);
-        if (dependentNTs.size() > 0) {
-            StringBuffer msg = new StringBuffer();
-            msg.append(nodeTypeName
-                    + " could not be removed because the following node types are referencing it: ");
-            Iterator iterator = dependentNTs.iterator();
-            while (iterator.hasNext()) {
-                msg.append(iterator.next());
-                msg.append(" ");
-            }
-            throw new RepositoryException(msg.toString());
-        }
-
-        // make sure node type is not currently in use
-        checkForReferencesInContent(nodeTypeName);
-
-        internalUnregister(nodeTypeName);
-
-        // persist removal of node type definition
-        customNTDefs.remove(nodeTypeName);
-
-        notifyUnregistered(nodeTypeName);
+        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
+            NodeTypeDef ntDef = (NodeTypeDef) iter.next();
+            notifyRegistered(ntDef.getName());
+        }
+    }
+
+    /**
+     * Same as <code>{@link #unregisterNodeType(QName)}</code> except
+     * that a set of node types is unregistered instead of just one.
+     * <p/>
+     * This method can be used to unregister a set of node types that depend on
+     * each other.
+     *
+     * @param ntNames a collection of <code>QName</code> objects denoting the
+     *                node types to be unregistered
+     * @throws NoSuchNodeTypeException if any of the specified names does not
+     *                                 denote a registered node type.
+     * @throws RepositoryException if another error occurs
+     * @see #unregisterNodeType(QName)
+     */
+    public synchronized void unregisterNodeTypes(Collection ntNames)
+            throws NoSuchNodeTypeException, RepositoryException {
+        // do some preliminary checks
+        for (Iterator iter = ntNames.iterator(); iter.hasNext();) {
+            QName ntName = (QName) iter.next();
+            if (!registeredNTDefs.containsKey(ntName)) {
+                throw new NoSuchNodeTypeException(ntName.toString());
+            }
+            if (builtInNTDefs.contains(ntName)) {
+                throw new RepositoryException(ntName.toString()
+                        + ": can't unregister built-in node type.");
+            }
+            // check for node types other than those to be unregistered
+            // that depend on the given node types
+            Set dependents = getDependentNodeTypes(ntName);
+            dependents.removeAll(ntNames);
+            if (dependents.size() > 0) {
+                StringBuffer msg = new StringBuffer();
+                msg.append(ntName
+                        + " can not be removed because the following node types depend on it: ");
+                for (Iterator depIter = dependents.iterator(); depIter.hasNext();) {
+                    msg.append(depIter.next());
+                    msg.append(" ");
+                }
+                throw new RepositoryException(msg.toString());
+            }
+        }
+
+        // make sure node types are not currently in use
+        for (Iterator iter = ntNames.iterator(); iter.hasNext();) {
+            QName ntName = (QName) iter.next();
+            checkForReferencesInContent(ntName);
+        }
+
+        // all preconditions are met, node types can now safely be unregistered
+        internalUnregister(ntNames);
+
+        // persist removal of node type definitions & notify listeners
+        for (Iterator iter = ntNames.iterator(); iter.hasNext();) {
+            QName ntName = (QName) iter.next();
+            customNTDefs.remove(ntName);
+            notifyUnregistered(ntName);
+        }
+        persistCustomNodeTypeDefs(customNTDefs);
+    }
+
+    /**
+     * Unregisters the specified node type. In order for a node type to be
+     * successfully unregistered it must meet the following conditions:
+     * <ol>
+     * <li>the node type must obviously be registered.</li>
+     * <li>a built-in node type can not be unregistered.</li>
+     * <li>the node type must not have dependents, i.e. other node types that
+     * are referencing it.</li>
+     * <li>the node type must not be currently used by any workspace.</li>
+     * </ol>
+     *
+     * @param ntName name of the node type to be unregistered
+     * @throws NoSuchNodeTypeException if <code>ntName</code> does not
+     *                                 denote a registered node type.
+     * @throws RepositoryException if another error occurs.
+     * @see #unregisterNodeTypes(Collection)
+     */
+    public synchronized void unregisterNodeType(QName ntName)
+            throws NoSuchNodeTypeException, RepositoryException {
+        HashSet ntNames = new HashSet();
+        ntNames.add(ntName);
+        unregisterNodeTypes(ntNames);
-     * @param nodeTypeName
+     * @param nodeTypeName node type name
-        try {
-            return (NodeTypeDef) def.clone();
-        } catch (CloneNotSupportedException e) {
-            // should never get here
-            log.fatal("internal error", e);
-            throw new InternalError(e.getMessage());
-        }
+        return (NodeTypeDef) def.clone();

MOV31 INS31 INS31 MOV25 INS83 INS39 INS42 INS44 INS43 INS8 INS44 MOV8 UPD42 MOV44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS43 MOV43 INS8 INS21 UPD42 INS24 INS24 INS24 INS24 INS43 INS42 INS42 INS24 UPD43 MOV43 UPD42 MOV42 INS21 INS24 INS65 INS65 UPD42 INS24 INS24 MOV21 INS24 MOV21 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS42 INS60 INS21 INS21 MOV41 INS7 UPD66 UPD42 INS58 MOV32 MOV8 INS58 MOV32 MOV8 INS58 INS32 MOV8 INS27 MOV43 INS58 INS32 MOV8 INS42 INS58 INS32 INS8 UPD66 INS66 UPD42 UPD66 UPD42 INS32 INS58 INS32 INS8 INS66 INS65 INS66 INS66 INS66 INS66 INS66 UPD42 INS66 INS66 INS66 INS66 INS66 INS68 INS58 INS32 INS8 INS58 INS32 INS8 INS58 INS32 INS8 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS68 INS42 INS43 INS59 INS32 INS32 INS66 INS42 INS11 MOV43 INS59 INS43 INS59 MOV60 INS43 INS59 UPD42 MOV42 MOV42 MOV21 INS42 INS33 INS43 INS59 UPD42 MOV42 UPD42 MOV42 INS60 INS43 INS59 INS42 INS42 INS60 INS21 INS42 INS42 MOV43 INS59 UPD42 MOV42 MOV42 MOV60 MOV21 INS68 INS42 INS69 MOV43 INS59 INS42 INS42 INS60 MOV25 MOV25 MOV60 INS21 MOV25 MOV43 INS59 INS42 INS42 INS60 MOV21 UPD42 MOV43 INS59 INS42 INS42 INS60 MOV21 MOV21 INS42 INS69 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS43 INS32 UPD42 MOV42 MOV32 MOV43 UPD42 MOV42 UPD42 MOV42 MOV32 MOV43 INS42 UPD42 MOV42 MOV32 MOV43 MOV43 INS32 UPD42 MOV42 INS42 MOV32 MOV43 INS59 INS42 INS42 INS32 INS43 INS59 INS32 UPD42 MOV42 MOV32 MOV43 INS42 INS69 INS43 INS42 INS32 INS43 INS59 INS32 INS42 INS32 INS43 INS59 INS42 INS32 INS43 INS59 INS43 INS43 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS11 INS42 INS42 INS42 INS42 INS11 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 INS43 INS42 INS42 INS42 MOV42 INS42 INS11 UPD42 UPD42 INS42 INS42 INS42 INS24 INS42 INS42 INS42 INS42 INS11 UPD42 INS42 INS42 INS42 INS42 INS11 UPD42 UPD42 INS42 INS42 MOV43 MOV32 UPD42 MOV43 MOV43 MOV43 INS32 INS43 INS32 UPD42 UPD42 MOV43 INS42 INS43 INS32 UPD42 UPD42 UPD42 INS58 INS32 INS8 INS43 INS32 INS43 INS32 UPD42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 MOV43 INS59 UPD42 MOV42 MOV42 MOV21 MOV21 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 UPD45 UPD42 MOV42 MOV32 UPD42 UPD42 UPD42 UPD42 UPD42 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL43 DEL32 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL43 DEL62 DEL36 DEL38 DEL42 DEL43 DEL42 DEL45 DEL57 DEL42 DEL32 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL8 DEL61 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL59 DEL60 DEL32 DEL61 DEL42 DEL42 DEL42 DEL32 DEL43 DEL42 DEL42 DEL32 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL32 DEL21 DEL8 DEL61 DEL42 DEL7 DEL21 DEL61 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL53 DEL8 DEL12 DEL54 DEL66 DEL66 DEL66 DEL59 DEL60 DEL32 DEL8 DEL61 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL44 DEL42 DEL42 DEL7 DEL21 DEL8 DEL12 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL7 DEL21 DEL8 DEL12 DEL54 DEL39 DEL42 DEL42 DEL33 DEL27 DEL42 DEL33 DEL27 DEL27 DEL59 DEL60 DEL42 DEL42 DEL33 DEL27 DEL42 DEL53 DEL8 DEL42 DEL33 DEL27 DEL42 DEL53 DEL8 DEL25 DEL25 DEL8 DEL25 DEL8 DEL43 DEL42 DEL44 DEL59 DEL60 DEL32 DEL8 DEL61 DEL8 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL53 DEL8 DEL12 DEL54
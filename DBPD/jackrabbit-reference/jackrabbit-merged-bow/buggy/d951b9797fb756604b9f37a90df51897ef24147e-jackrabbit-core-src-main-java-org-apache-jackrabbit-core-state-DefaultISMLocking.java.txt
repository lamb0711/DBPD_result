JCR-2753 Deadlock in DefaultISMLocking - reverting revision 995411 and 995412

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@999298 13f79535-47bb-0310-9956-ffa450edef68

+import EDU.oswego.cs.dl.util.concurrent.ReadWriteLock;
+import EDU.oswego.cs.dl.util.concurrent.ReentrantWriterPreferenceReadWriteLock;
+import EDU.oswego.cs.dl.util.concurrent.Sync;
+
- * Default item state locking strategy. The default strategy is simply to use
- * a single coarse-grained read-write lock over the entire workspace.
+ * <code>DefaultISMLocking</code> implements the default locking strategy using
+ * coarse grained locking on an ItemStateManager wide read-write lock. E.g.
+ * while a write lock is held, no read lock can be acquired.
-     * The read lock instance used by readers to release the acquired lock.
+     * The internal read-write lock.
+	 * Thread concerning ReentrantWriterPreferenceReadWriteLock
-    private final ReadLock readLock = new ReadLock() {
-        public void release() {
-            releaseReadLock();
-        }
-    };
-
+    private final ReadWriteLock rwLock = new ReentrantWriterPreferenceReadWriteLock();
+    
-     * The write lock instance used by writers to release or downgrade the
-     * acquired lock.
+     * The internal Xid aware read-write lock.
-    private final WriteLock writeLock = new WriteLock() {
-        public void release() {
-            releaseWriteLock(false);
-        }
-        public ReadLock downgrade() {
-            releaseWriteLock(true);
-            return readLock;
-        }
-    };
-
+    private final ReadWriteLock xidRwLock = new XidRWLock();
+    
-     * Number of writer threads waiting. While greater than zero, no new
-     * readers are allowed to proceed.
+     * {@inheritDoc}
-    private int writersWaiting = 0;
-
-    /**
-     * The thread identifier of the current writer, or <code>null</code> if
-     * no write is in progress. A thread with the same identifier (i.e. the
-     * same thread or another thread in the same transaction) can re-acquire
-     * read or write locks without limitation, while all other readers and
-     * writers remain blocked.
-     */
-    private Object writerId = null;
-
-    /**
-     * Number of acquired write locks. All the concurrent write locks are
-     * guaranteed to share the same thread identifier (see {@link #writerId}).
-     */
-    private int writerCount = 0;
-
-    /**
-     * Number of acquired read locks.
-     */
-    private int readerCount = 0;
-
-    /**
-     * Increments the reader count and returns the acquired read lock once
-     * there are no more writers or the current writer shares the thread id
-     * with this reader.
-     */
-    public synchronized ReadLock acquireReadLock(ItemId id)
-            throws InterruptedException {
-        while (writerId != null
-                ? !isSameId(writerId, getCurrentId()) : writersWaiting > 0) {
-            wait();
-        }
-
-        readerCount++;
-        return readLock;
+    public ReadLock acquireReadLock(ItemId id) throws InterruptedException {
+    	if (TransactionContext.getCurrentXid() == null) {
+            return new ReadLockImpl(rwLock.readLock());
+    	} else {
+            return new ReadLockImpl(xidRwLock.readLock());
+    	}
-     * Decrements the reader count and notifies all pending threads if the
-     * lock is now available. Used by the {@link #readLock} instance.
+     * {@inheritDoc}
-    private synchronized void releaseReadLock() {
-        readerCount--;
-        if (readerCount == 0 && writerId == null) {
-            notifyAll();
+    public WriteLock acquireWriteLock(ChangeLog changeLog) throws InterruptedException {
+    	if (TransactionContext.getCurrentXid() == null) {
+    		return new WriteLockImpl(rwLock);
+    	} else {
+    		return new WriteLockImpl(xidRwLock);
+    	}
+    }
+
+    private static final class WriteLockImpl implements WriteLock {
+    	
+    	private ReadWriteLock readWriteLock;
+    	
+    	private WriteLockImpl(ReadWriteLock readWriteLock) throws InterruptedException {
+    		this.readWriteLock = readWriteLock;
+    		this.readWriteLock.writeLock().acquire();
+		}
+
+		/**
+		 * {@inheritDoc}
+		 */
+		public void release() {
+		    this.readWriteLock.writeLock().release();
+		}
+
+		/**
+		 * {@inheritDoc}
+		 */
+		public ReadLock downgrade() throws InterruptedException {
+		    ReadLock rLock = new ReadLockImpl(this.readWriteLock.readLock());
+		    release();
+		    return rLock;
+		}
+	}
+
+	private static final class ReadLockImpl implements ReadLock {
+
+        private final Sync readLock;
+
+        private ReadLockImpl(Sync readLock) throws InterruptedException {
+            this.readLock = readLock;
+            this.readLock.acquire();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public void release() {
+            readLock.release();
-    /**
-     * Increments the writer count, sets the writer identifier and returns
-     * the acquired read lock once there are no other active readers or
-     * writers or the current writer shares the thread id with this writer.
-     */
-    public synchronized WriteLock acquireWriteLock(ChangeLog changeLog)
-            throws InterruptedException {
-        Object currentId = getCurrentId();
+	/**
+	 * Xid concerning ReentrantWriterPreferenceReadWriteLock
+	 */
+    private static final class XidRWLock extends ReentrantWriterPreferenceReadWriteLock {
-        writersWaiting++;
-        try {
-            while (writerId != null
-                    ? !isSameId(writerId, currentId) : readerCount > 0) {
-                wait();
+        private Xid activeXid;
+
+        /**
+         * Check if the given Xid comes from the same globalTX
+         * @param otherXid
+         * @return true if same globalTX otherwise false
+         */
+        boolean isSameGlobalTx(Xid otherXid) {
+    	    return (activeXid == otherXid) || Arrays.equals(activeXid.getGlobalTransactionId(), otherXid.getGlobalTransactionId());
+    	}
+
+        /**
+         * Allow reader when there is no active Xid, or current Xid owns
+         * the write lock (reentrant).
+         */
+        protected boolean allowReader() {
+        	Xid currentXid = TransactionContext.getCurrentXid();
+        	return (activeXid == null && waitingWriters_ == 0) || isSameGlobalTx(currentXid);
+        }
+
+        /**
+         * {@inheritDoc}
+         */  
+        protected synchronized boolean startWrite() {
+        	Xid currentXid = TransactionContext.getCurrentXid();
+            if (activeXid != null && isSameGlobalTx(currentXid)) { // already held; re-acquire
+            	++writeHolds_;
+                return true;
+            } else if (writeHolds_ == 0) {
+            	if (activeReaders_ == 0 || (readers_.size() == 1 && readers_.get(currentXid) != null)) {
+            		activeXid = currentXid;
+            		writeHolds_ = 1;
+            		return true;
+            	} else {
+            		return false;
+            	}
+            } else {
+            	return false;
-        } finally {
-            writersWaiting--;
-        if (writerCount++ == 0) {
-            writerId = currentId;
+        /**
+         * {@inheritDoc}
+         */
+        protected synchronized Signaller endWrite() {
+            --writeHolds_;
+            if (writeHolds_ > 0) {  // still being held
+            	return null;
+            } else {
+            	activeXid = null;
+                if (waitingReaders_ > 0 && allowReader()) {
+                    return readerLock_;
+                } else if (waitingWriters_ > 0) {
+                    return writerLock_;
+                } else {
+                    return null;
+                }
+            }
-        return writeLock;
+
+        /**
+         * {@inheritDoc}
+         */
+		protected synchronized boolean startRead() {
+			Xid currentXid = TransactionContext.getCurrentXid();
+		    Object c = readers_.get(currentXid);
+		    if (c != null) { // already held -- just increment hold count
+		    	readers_.put(currentXid, new Integer(((Integer)(c)).intValue()+1));
+		    	++activeReaders_;
+		    	return true;
+		    } else if (allowReader()) {
+		    	readers_.put(currentXid, IONE);
+		    	++activeReaders_;
+		    	return true;
+		    } else {
+		    	return false;
+		    }
+		}
+
+        /**
+         * {@inheritDoc}
+         */
+		protected synchronized Signaller endRead() {
+			Xid currentXid = TransactionContext.getCurrentXid();
+		    Object c = readers_.get(currentXid);
+		    if (c == null) {
+		    	throw new IllegalStateException();
+		    }
+		    --activeReaders_;
+		    if (c != IONE) { // more than one hold; decrement count
+		    	int h = ((Integer)(c)).intValue()-1;
+		    	Integer ih = (h == 1)? IONE : new Integer(h);
+		    	readers_.put(currentXid, ih);
+		    	return null;
+		    } else {
+		    	readers_.remove(currentXid);
+		    
+		    	if (writeHolds_ > 0) { // a write lock is still held
+		    		return null;
+		    	} else if (activeReaders_ == 0 && waitingWriters_ > 0) {
+		    		return writerLock_;
+		    	} else  {
+		    		return null;
+		    	}
+		    }
+		}
-
-    /**
-     * Decrements the writer count (and possibly clears the writer identifier)
-     * and notifies all pending threads if the lock is now available. If the
-     * downgrade argument is true, then the reader count is incremented before
-     * notifying any pending threads. Used by the {@link #writeLock} instance.
-     */
-    private synchronized void releaseWriteLock(boolean downgrade) {
-        writerCount--;
-        if (downgrade) {
-            readerCount++;
-        }
-        if (writerCount == 0) {
-            writerId = null;
-            notifyAll();
-        }
-    }
-
-    /**
-     * Returns the current thread identifier. The identifier is either the
-     * current thread instance or the global transaction identifier when
-     * running under a transaction.
-     *
-     * @return current thread identifier
-     */
-    private Object getCurrentId() {
-        Xid xid = TransactionContext.getCurrentXid();
-        if (xid != null) {
-            return xid.getGlobalTransactionId();
-        } else {
-            return Thread.currentThread();
-        }
-    }
-
-    /**
-     * Compares the given thread identifiers for equality.
-     */
-    private boolean isSameId(Object a, Object b) {
-        if (a == b) {
-            return true;
-        } else if (a instanceof byte[] && b instanceof byte[]) {
-            return Arrays.equals((byte[]) a, (byte[]) b);
-        } else {
-            return false;
-        }
-    }
-

INS26 INS26 INS26 INS40 INS40 INS40 INS23 INS23 INS31 INS31 INS55 INS55 INS55 MOV29 MOV83 MOV83 INS43 INS59 INS29 INS83 INS83 INS43 INS59 INS29 MOV83 MOV43 INS42 MOV44 MOV43 INS8 INS29 INS83 MOV43 INS42 MOV44 MOV43 INS8 INS83 INS83 INS83 INS42 MOV43 INS23 INS31 INS31 INS31 INS83 INS83 INS83 INS42 MOV43 MOV23 INS31 INS31 INS29 INS83 INS83 INS83 INS42 INS43 INS23 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 UPD66 UPD66 INS66 INS42 UPD42 MOV42 INS14 INS65 INS42 INS42 INS14 INS65 INS25 INS65 INS25 INS83 INS43 INS59 INS83 INS42 INS44 INS43 INS8 INS29 MOV83 MOV39 MOV42 MOV8 INS29 MOV83 MOV43 MOV42 INS43 MOV8 INS83 INS43 INS83 INS42 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS8 MOV65 INS42 INS83 INS43 MOV59 INS39 UPD42 INS44 UPD83 UPD39 UPD42 UPD83 INS39 UPD42 UPD83 INS43 INS42 UPD83 INS83 INS39 INS42 INS8 UPD83 INS83 INS43 INS42 INS8 UPD66 INS66 INS43 INS66 INS43 INS65 INS27 INS8 INS8 INS65 INS27 INS8 INS8 INS42 INS42 INS43 INS42 INS42 INS21 INS21 INS65 INS65 INS42 INS60 INS42 UPD42 INS43 INS42 INS42 INS21 INS21 MOV65 INS21 UPD66 INS42 UPD42 INS65 INS65 INS65 INS43 INS42 INS41 MOV60 INS41 INS65 INS25 INS42 INS65 INS60 INS60 MOV25 INS65 INS42 INS60 INS60 INS25 INS21 INS25 INS42 INS42 INS32 INS33 INS41 INS41 INS32 INS33 INS41 INS41 UPD42 MOV42 INS7 INS32 INS65 INS32 INS65 MOV43 INS59 UPD42 UPD42 MOV42 INS7 INS32 UPD65 INS32 UPD66 MOV66 INS42 UPD66 MOV66 INS42 INS27 UPD66 UPD66 INS27 INS65 UPD43 INS27 MOV8 INS25 UPD65 INS38 UPD27 INS8 INS65 INS43 INS59 MOV43 INS59 INS25 INS65 INS43 INS59 MOV43 INS59 INS27 INS8 INS38 INS27 INS8 INS8 INS42 INS42 INS14 INS14 INS42 INS42 INS14 INS14 INS22 INS42 INS32 INS42 INS32 INS42 INS42 INS14 UPD42 INS22 INS42 INS22 INS42 INS42 INS42 INS36 INS32 UPD42 INS36 INS32 UPD42 UPD42 INS27 INS32 INS21 INS27 INS8 INS8 INS42 UPD42 INS41 INS25 UPD42 MOV42 INS42 INS32 INS42 INS32 UPD42 INS21 INS21 INS41 INS32 MOV8 INS8 INS42 INS42 INS32 INS42 INS32 INS42 INS33 INS53 INS42 INS42 INS42 INS60 INS60 INS21 INS41 INS21 MOV25 INS43 INS32 INS43 INS32 INS43 INS42 INS43 INS42 INS52 INS42 INS22 INS42 INS22 INS42 INS43 INS32 INS52 INS42 INS52 INS42 INS27 UPD42 MOV42 UPD42 MOV42 MOV32 INS32 INS27 UPD42 MOV42 INS42 INS42 UPD42 UPD42 MOV42 MOV33 UPD42 MOV42 UPD42 MOV42 INS38 UPD42 MOV42 MOV34 MOV25 MOV41 INS33 INS27 INS8 INS25 INS42 INS42 INS42 INS42 INS42 INS32 INS38 INS9 INS42 INS21 INS21 INS41 INS41 INS42 INS42 INS42 INS42 INS42 INS14 INS39 INS59 INS43 INS59 INS32 INS33 INS32 UPD27 INS8 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS52 INS42 INS52 INS42 INS42 INS22 INS42 INS42 UPD42 MOV42 INS42 UPD42 INS42 UPD42 MOV42 MOV27 MOV27 INS42 INS27 MOV8 INS9 UPD42 INS27 INS32 INS41 INS27 INS8 INS8 INS42 INS42 UPD42 MOV42 INS14 INS42 INS32 INS38 INS9 INS9 INS43 INS42 INS27 INS42 INS42 INS16 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS34 INS41 INS8 INS52 INS42 UPD42 INS33 UPD42 INS34 INS27 INS36 INS21 INS41 INS42 INS34 UPD42 MOV42 INS42 INS42 INS34 INS41 INS41 INS43 INS27 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS32 INS34 INS36 INS42 INS14 INS33 INS27 INS27 INS41 INS42 MOV34 INS27 INS7 INS9 INS42 INS33 INS42 INS32 INS34 INS36 INS42 INS27 INS43 INS42 INS42 INS34 INS42 INS34 INS42 INS33 INS27 INS27 UPD42 UPD42 INS42 INS34 INS36 INS42 INS11 INS42 INS34 INS42 INS32 INS34 INS32 INS33 INS11 INS43 INS36 INS42 INS42 INS42 INS42 INS42 INS43 INS36 INS42 INS42 INS42 INS42 DEL42 DEL9 DEL32 DEL9 DEL66 DEL66 DEL65 DEL29 DEL39 DEL34 DEL66 DEL66 DEL42 DEL67 DEL66 DEL34 DEL66 DEL65 DEL83 DEL83 DEL33 DEL27 DEL32 DEL38 DEL42 DEL34 DEL27 DEL16 DEL32 DEL21 DEL8 DEL61 DEL42 DEL37 DEL21 DEL42 DEL41 DEL42 DEL67 DEL65 DEL66 DEL83 DEL34 DEL33 DEL42 DEL37 DEL21 DEL27 DEL32 DEL21 DEL8 DEL25 DEL66 DEL66 DEL66 DEL65 DEL42 DEL37 DEL27 DEL42 DEL42 DEL37 DEL21 DEL27 DEL42 DEL32 DEL38 DEL27 DEL16 DEL42 DEL32 DEL21 DEL8 DEL61 DEL8 DEL42 DEL37 DEL21 DEL8 DEL54 DEL66 DEL66 DEL66 DEL66 DEL42 DEL67 DEL66 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL37 DEL42 DEL42 DEL37 DEL21 DEL8 DEL25 DEL32 DEL21 DEL66 DEL66 DEL66 DEL65 DEL66 DEL65 DEL42 DEL32 DEL41 DEL32 DEL41 DEL43 DEL42 DEL8 DEL66 DEL65 DEL42 DEL42 DEL39 DEL85 DEL5 DEL62 DEL42 DEL39 DEL85 DEL5 DEL62 DEL42 DEL42 DEL39 DEL85 DEL5 DEL42 DEL11 DEL39 DEL85 DEL5 DEL42 DEL11 DEL32 DEL39 DEL42 DEL42 DEL44 DEL42 DEL44 DEL8 DEL39 DEL42 DEL32 DEL21 DEL8 DEL31 DEL1 DEL14 DEL59 DEL23 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL31 DEL31 DEL1 DEL14 DEL59 DEL23 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL43 DEL42 DEL33 DEL59 DEL23 DEL29 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL29 DEL83 DEL39 DEL23
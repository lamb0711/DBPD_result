- JCR-17 Creating and saving a mix:versionable node creates two VersionHistory nodes
- JCR-18 Multithreading issue with versioning


git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@76106 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.HashSet;
-import java.util.NoSuchElementException;
-import java.util.Set;
-import java.util.Stack;
+import java.util.*;
- * graph following the successor nodes.
+ * graph following the successor nodes. When this iterator is created, it gathers
+ * the id's of the versions and returns them when iterating. please note, that
+ * a version can be deleted while traversing this iterator and the 'nextVesion'
+ * would produce a  ConcurrentModificationException.
+     * the id's of the versions to return
+     */
+    private LinkedList versions = new LinkedList();
+
+    /**
-     * the traversal stack
-     */
-    private Stack successors = new Stack();
-
-    /**
-     * the set of versions already returned. due to the topology of the version
-     * graph it is possible to reach a version via different paths.
-     */
-    private Set visited = new HashSet();
-
-    /**
-        successors.push(rootVersion);
+
+        addVersion(rootVersion);
-        if (successors.isEmpty()) {
+        if (versions.isEmpty()) {
-        InternalVersion ret = (InternalVersion) successors.pop();
-        visited.add(ret);
+        String id = (String) versions.removeFirst();
-        push(ret.getSuccessors());
-            return (Version) session.getNodeByUUID(ret.getId());
+            return (Version) session.getNodeByUUID(id);
-            throw new NoSuchElementException("Unable to provide element: " + e.toString());
+            throw new ConcurrentModificationException("Unable to provide element: " + e.toString());
-        return -1;
+        return versions.size();
-        return !successors.isEmpty();
+        return !versions.isEmpty();
-     * Pushes the versions on the stack
-     *
-     * @param versions
+     * Adds the version 'v' to the list of versions to return and then calls
+     * it self recursively with all the verions prodecessors.
+     * @param v
-    private void push(InternalVersion[] versions) {
-        for (int i = 0; i < versions.length; i++) {
-            if (!visited.contains(versions[i])) {
-                successors.push(versions[i]);
+    private synchronized void addVersion(InternalVersion v) {
+        String id = v.getId();
+        if (!versions.contains(id)) {
+            versions.add(id);
+            InternalVersion[] vs = v.getSuccessors();
+            for (int i=0; i<vs.length; i++) {
+                addVersion(vs[i]);

MOV23 UPD40 UPD43 INS83 UPD42 UPD66 INS66 INS66 INS66 UPD42 UPD42 MOV43 UPD42 INS60 MOV25 UPD66 UPD43 UPD43 INS32 UPD66 INS66 UPD42 INS43 INS59 INS8 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS32 INS21 INS60 INS24 INS43 UPD42 INS42 INS42 UPD42 INS42 INS32 MOV5 INS59 MOV58 INS27 MOV37 INS8 INS42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS32 INS42 INS40 MOV21 UPD42 MOV42 UPD43 INS42 INS42 UPD42 UPD42 UPD42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL23 DEL66 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL32 DEL34 DEL38 DEL42 DEL42 DEL2 DEL42 DEL8 DEL42 DEL40 DEL27 DEL8 DEL24
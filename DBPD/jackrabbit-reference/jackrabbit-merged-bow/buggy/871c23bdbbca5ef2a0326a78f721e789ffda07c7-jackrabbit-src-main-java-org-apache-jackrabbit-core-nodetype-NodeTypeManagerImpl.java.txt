JCR-545: New method on NodeTypeManagerImpl to reregister nodetypes

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@469959 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.HashMap;
+     * @param nsReg      namespace registry
+    /**
+     * Registers the node types defined in the given input stream depending
+     * on the content type specified for the stream. This will also register
+     * any namespaces identified in the input stream if they have not already
+     * been registered.
+     *
+     * @param in node type XML stream
+     * @param contentType type of the input stream
+     * @param reregisterExisting flag indicating whether node types should be
+     *                           reregistered if they already exist
+     * @return registered node types
+     * @throws IOException if the input stream could not be read or parsed
+     * @throws RepositoryException if the node types are invalid or another
+     *                             repository error occurs
+     */
+    public NodeType[] registerNodeTypes(InputStream in, String contentType,
+            boolean reregisterExisting)
+            throws IOException, RepositoryException {
+
+        try {
+            Map namespaceMap = new HashMap();
+            List nodeTypeDefs = new ArrayList();
+
+            if (contentType.equalsIgnoreCase(TEXT_XML)
+                    || contentType.equalsIgnoreCase(APPLICATION_XML)) {
+                try {
+                    NodeTypeReader ntr = new NodeTypeReader(in);
+
+                    Properties namespaces = ntr.getNamespaces();
+                    if (namespaces != null) {
+                        Enumeration prefixes = namespaces.propertyNames();
+                        while (prefixes.hasMoreElements()) {
+                            String prefix = (String) prefixes.nextElement();
+                            String uri = namespaces.getProperty(prefix);
+                            namespaceMap.put(prefix, uri);
+                        }
+                    }
+
+                    NodeTypeDef[] defs = ntr.getNodeTypeDefs();
+                    nodeTypeDefs.addAll(Arrays.asList(defs));
+                } catch (IllegalNameException e) {
+                    throw new RepositoryException("Illegal JCR name syntax", e);
+                } catch (UnknownPrefixException e) {
+                    throw new RepositoryException("Unknown namespace prefix", e);
+                }
+            } else if (contentType.equalsIgnoreCase(TEXT_X_JCR_CND)) {
+                try {
+                    NamespaceMapping mapping = new NamespaceMapping(nsResolver);
+                    CompactNodeTypeDefReader reader = new CompactNodeTypeDefReader(
+                            new InputStreamReader(in), "cnd input stream", mapping);
+
+                    namespaceMap.putAll(mapping.getPrefixToURIMapping());
+
+                    nodeTypeDefs.addAll(reader.getNodeTypeDefs());
+                } catch (ParseException e) {
+                    throw new IOException(e.getMessage());
+                }
+            } else {
+                throw new UnsupportedRepositoryOperationException(
+                        "Unsupported content type: " + contentType);
+            }
+
+            Iterator iterator = namespaceMap.entrySet().iterator();
+            while (iterator.hasNext()) {
+                Map.Entry entry = (Map.Entry) iterator.next();
+                nsReg.safeRegisterNamespace((String) entry.getKey(),
+                        (String) entry.getValue());
+            }
+
+            if (reregisterExisting) {
+                // split the node types into new and already registered node types.
+                // this way we can register new node types together with already
+                // registered node types which make circular dependencies possible
+                List newNodeTypeDefs = new ArrayList();
+                List registeredNodeTypeDefs = new ArrayList();
+                for (Iterator iter = nodeTypeDefs.iterator(); iter.hasNext();) {
+                    NodeTypeDef nodeTypeDef = (NodeTypeDef) iter.next();
+                    if (ntReg.isRegistered(nodeTypeDef.getName())) {
+                        registeredNodeTypeDefs.add(nodeTypeDef);
+                    } else {
+                        newNodeTypeDefs.add(nodeTypeDef);
+                    }
+                }
+
+                ArrayList nodeTypes = new ArrayList();
+
+                // register new node types
+                nodeTypes.addAll(Arrays.asList(registerNodeTypes(newNodeTypeDefs)));
+
+                // reregister already existing node types
+                for (Iterator iter = registeredNodeTypeDefs.iterator(); iter.hasNext();) {
+                    NodeTypeDef nodeTypeDef = (NodeTypeDef) iter.next();
+                    ntReg.reregisterNodeType(nodeTypeDef);
+                    nodeTypes.add(getNodeType(nodeTypeDef.getName()));
+                }
+                return (NodeType[]) nodeTypes.toArray(new NodeTypeDef[nodeTypes.size()]);
+            } else {
+                return registerNodeTypes(nodeTypeDefs);
+            }
+
+        } catch (InvalidNodeTypeDefException e) {
+            throw new RepositoryException("Invalid node type definition", e);
+        }
+    }
+
+     *
+     * @param defs a collection of <code>NodeTypeDef<code> objects
+     * @returns registered node types
+     * @throws InvalidNodeTypeDefException
+     * @throws RepositoryException
-            NodeTypeReader ntr = new NodeTypeReader(in.getByteStream());
-
-            Properties namespaces = ntr.getNamespaces();
-            if (namespaces != null) {
-                Enumeration prefixes = namespaces.propertyNames();
-                while (prefixes.hasMoreElements()) {
-                    String prefix = (String) prefixes.nextElement();
-                    nsReg.safeRegisterNamespace(
-                            prefix, namespaces.getProperty(prefix));
-                }
-            }
-
-            NodeTypeDef[] defs = ntr.getNodeTypeDefs();
-            return registerNodeTypes(Arrays.asList(defs));
-        } catch (IllegalNameException e) {
-            throw new RepositoryException("Illegal JCR name syntax", e);
-        } catch (UnknownPrefixException e) {
-            throw new RepositoryException("Unknown namespace prefix", e);
-        } catch (InvalidNodeTypeDefException e) {
-            throw new RepositoryException("Invalid node type definition", e);
+            return registerNodeTypes(in.getByteStream(), TEXT_XML);
-        try {
-          if (contentType.equalsIgnoreCase(TEXT_XML)
-                  || contentType.equalsIgnoreCase(APPLICATION_XML)) {
-              return registerNodeTypes(new InputSource(in));
-          } else if (contentType.equalsIgnoreCase(TEXT_X_JCR_CND)) {
-              NamespaceMapping mapping = new NamespaceMapping(nsResolver);
-              CompactNodeTypeDefReader reader = new CompactNodeTypeDefReader(
-                      new InputStreamReader(in), "cnd input stream", mapping);
-
-              Map nsMap = mapping.getPrefixToURIMapping();
-              Iterator iterator = nsMap.entrySet().iterator();
-              while (iterator.hasNext()) {
-                  Map.Entry entry = (Map.Entry) iterator.next();
-                  nsReg.safeRegisterNamespace(
-                          (String) entry.getKey(), (String) entry.getValue());
-              }
-
-              return registerNodeTypes(reader.getNodeTypeDefs());
-          } else {
-              throw new UnsupportedRepositoryOperationException(
-                      "Unsupported content type: " + contentType);
-          }
-        } catch (InvalidNodeTypeDefException e) {
-            throw new RepositoryException("Invalid node type definition", e);
-        } catch (SAXException e) {
-            throw new IOException(e.getMessage());
-        } catch (ParseException e) {
-            throw new IOException(e.getMessage());
-        }
+        return registerNodeTypes(in, contentType, false);

INS26 MOV31 INS40 INS31 INS31 INS29 MOV5 MOV44 MOV44 INS44 MOV43 MOV43 INS8 MOV29 MOV83 MOV5 MOV42 MOV44 MOV43 MOV43 INS8 MOV29 INS83 INS5 INS42 INS44 INS44 MOV43 INS43 INS8 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS39 INS42 INS54 INS65 INS65 INS65 INS65 INS54 INS43 INS85 INS43 INS42 UPD43 MOV43 UPD42 MOV42 UPD42 MOV42 INS41 INS42 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS8 MOV12 INS42 INS66 INS66 INS42 INS42 INS8 MOV12 UPD42 MOV42 INS42 UPD42 INS32 INS60 INS60 INS25 INS60 MOV61 INS25 MOV41 UPD42 MOV42 INS42 UPD42 MOV42 INS9 MOV43 INS59 INS43 INS59 MOV27 MOV8 MOV25 INS43 INS59 INS42 INS8 INS8 INS42 INS14 INS42 INS42 INS14 INS8 INS42 INS42 INS32 INS60 INS60 INS24 INS60 INS21 INS24 INS41 INS41 MOV32 INS42 INS43 INS43 INS54 INS32 INS42 INS43 INS59 INS43 INS59 INS58 INS32 INS8 INS43 INS59 INS32 INS58 INS32 INS8 INS11 INS32 INS42 INS42 INS21 MOV8 MOV12 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS14 INS43 INS59 INS42 INS42 INS60 INS25 INS42 INS42 INS14 INS42 INS42 INS32 MOV43 INS59 INS42 INS42 INS60 INS21 INS21 INS5 INS32 INS42 INS42 MOV43 MOV32 INS21 INS21 INS43 INS43 INS42 INS42 INS32 INS43 INS59 INS32 INS8 INS8 INS43 INS42 INS42 INS32 INS42 INS32 INS43 INS59 INS32 INS32 INS43 INS85 INS42 INS42 INS3 UPD42 INS42 INS32 MOV32 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS32 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS5 INS32 MOV43 INS42 UPD42 MOV42 UPD42 MOV42 MOV32 UPD42 INS42 INS42 INS43 INS32 INS42 INS42 INS32 INS32 INS43 INS32 INS42 INS32 INS43 INS85 INS42 INS42 INS60 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS42 INS42 INS42 INS42 INS42 MOV32 UPD42 UPD42 INS42 DEL41 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL45 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL59 DEL60 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL41 DEL42 DEL43 DEL42 DEL14 DEL8 DEL25 DEL8 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL31
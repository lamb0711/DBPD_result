JCR-193, JCR-216, JCR-203, JCR 184 + various minor fixes

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@293331 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.util.ISO9075;
-    /** the default logger */
+    /**
+     * the default logger
+     */
+
-    /** is created on initProperties */
+    /**
+     * is created on initProperties
+     */
-                           DavSession session, ResourceFilter filter)
-        throws RepositoryException, DavException {
+                           DavSession session, ResourceConfig config)
+            throws RepositoryException, DavException {
-        this.filter = filter;
+        this.filter = config.getResourceFilter();
+
-                init(session.getRepositorySession().getItem(locator.getResourcePath()));
+                Item item = session.getRepositorySession().getItem(locator.getJcrPath());
+                if (item != null && item.isNode()) {
+                    node = (Node) item;
+                    if (isFilteredNode(node)) {
+                        log.debug("Cannot to access resource based on a filtered repository item: " + locator.getResourcePath());
+                        throw new DavException(DavServletResponse.SC_FORBIDDEN);
+                    }
+                    // define what is a resource in webdav
+                    isCollection = config.isCollectionResource(node);
+                }
-     * Init the webdav resource and retrieve the relevant property.
-     *
-     * @param repositoryItem
-     * @throws RepositoryException
-     */
-    private void init(Item repositoryItem) throws RepositoryException, DavException {
-        if (repositoryItem == null || !repositoryItem.isNode()) {
-            return;
-        }
-        node = (Node)repositoryItem;
-        if (isFilteredNode(node)) {
-            log.debug("Cannot to access resource based on a filtered repository item: " + locator.getResourcePath());
-            throw new DavException(DavServletResponse.SC_FORBIDDEN);
-        }
-        // define what is a resource in webdav
-        if (node.isNodeType(NT_RESOURCE) || node.isNodeType(NT_FILE)) {
-            isCollection = false;
-        }
-    }
-
-    /**
+     * Returns the the last segment of the resource path.<p>
+     * Note that this must not correspond to the name of the underlaying
+     * repository item for two reasons:<ul>
+     * <li>SameNameSiblings have an index appended to their item name.</li>
+     * <li>the resource path may differ from the item path.</li>
+     * </ul>
+     * Using the item name as DAV:displayname caused problems with XP built-in
+     * client in case of resources representing SameNameSibling nodes.
+     *
-        String name = null;
-        if (exists()) {
-            try {
-                name = node.getName();
-            } catch (RepositoryException e) {
-                // ignore
-            }
-        }
-        if (name == null && getResourcePath() != null) {
-            name = Text.getName(getResourcePath());
-        }
-        return name;
+        String resPath = getResourcePath();
+        return (resPath != null) ? Text.getName(resPath) : resPath;
-	initProperties();
-	return nodeResource == null ? 0 : nodeResource.getModificationTime();
+        initProperties();
+        return nodeResource == null ? 0 : nodeResource.getModificationTime();
-	initProperties();
-	return nodeResource == null ? null : nodeResource.getStream();
+        initProperties();
+        return nodeResource == null ? null : nodeResource.getStream();
-        if (exists()) {
-            try {
-                nodeResource = new NodeResource(this, node);
-                properties.add(new DefaultDavProperty(DavPropertyName.GETCONTENTLENGTH, nodeResource.getContentLength()+""));
-                properties.add(new DefaultDavProperty(DavPropertyName.CREATIONDATE, nodeResource.getCreationDate()));
-                properties.add(new DefaultDavProperty(DavPropertyName.GETLASTMODIFIED, nodeResource.getLastModified()));
-                setContentType(nodeResource.getContentType());
-                setContentLanguage(nodeResource.getContentLanguage());
-                properties.add(new DefaultDavProperty(DavPropertyName.GETETAG, nodeResource.getETag()));
-            } catch (RepositoryException e) {
-                // should not occure....
-            }
+        if (!exists() || nodeResource != null) {
+            return;
+        }
-            if (getDisplayName() != null) {
-                properties.add(new DefaultDavProperty(DavPropertyName.DISPLAYNAME, getDisplayName()));
-            }
-            if (isCollection()) {
-                properties.add(new ResourceType(ResourceType.COLLECTION));
-                // Windows XP support
-                properties.add(new DefaultDavProperty(DavPropertyName.ISCOLLECTION, "1"));
-            } else {
-                properties.add(new ResourceType(ResourceType.DEFAULT_RESOURCE));
-                // Windows XP support
-                properties.add(new DefaultDavProperty(DavPropertyName.ISCOLLECTION, "0"));
-            }
+        try {
+            nodeResource = new NodeResource(this, node);
+            properties.add(new DefaultDavProperty(DavPropertyName.GETCONTENTLENGTH, nodeResource.getContentLength() + ""));
+            properties.add(new DefaultDavProperty(DavPropertyName.CREATIONDATE, nodeResource.getCreationDate()));
+            properties.add(new DefaultDavProperty(DavPropertyName.GETLASTMODIFIED, nodeResource.getLastModified()));
+            setContentType(nodeResource.getContentType());
+            setContentLanguage(nodeResource.getContentLanguage());
+            properties.add(new DefaultDavProperty(DavPropertyName.GETETAG, nodeResource.getETag()));
+        } catch (RepositoryException e) {
+            // should not occure....
+        }
-            /* set current lock information. If no lock is set to this resource,
-            an empty lockdiscovery will be returned in the response. */
-            properties.add(new LockDiscovery(getLock(Type.WRITE, Scope.EXCLUSIVE)));
+        if (getDisplayName() != null) {
+            properties.add(new DefaultDavProperty(DavPropertyName.DISPLAYNAME, getDisplayName()));
+        }
+        if (isCollection()) {
+            properties.add(new ResourceType(ResourceType.COLLECTION));
+            // Windows XP support
+            properties.add(new DefaultDavProperty(DavPropertyName.ISCOLLECTION, "1"));
+        } else {
+            properties.add(new ResourceType(ResourceType.DEFAULT_RESOURCE));
+            // Windows XP support
+            properties.add(new DefaultDavProperty(DavPropertyName.ISCOLLECTION, "0"));
+        }
-            /* lock support information: all locks are lockable. */
-            SupportedLock supportedLock = new SupportedLock();
-            supportedLock.addEntry(Type.WRITE, Scope.EXCLUSIVE);
-            properties.add(supportedLock);
+        /* set current lock information. If no lock is set to this resource,
+        an empty lockdiscovery will be returned in the response. */
+        properties.add(new LockDiscovery(getLock(Type.WRITE, Scope.EXCLUSIVE)));
-            // non-protected JCR properties defined on the underlaying jcr node
-            try {
-                // todo: should filter be respected for properties as well?
-                PropertyIterator it = node.getProperties();
-                while (it.hasNext()) {
-                    Property p = it.nextProperty();
-                    String pName = p.getName();
-                    PropertyDefinition def = p.getDefinition();
-                    if (def.isMultiple()) {
-                        log.debug("Multivalue property '" +  pName + "' not added to webdav property set.");
-                        continue;
-                    }
-                    DavPropertyName name = getDavName(pName, node.getSession());
-                    String value = p.getValue().getString();
-                    properties.add(new DefaultDavProperty(name, value, def.isProtected()));
+        /* lock support information: all locks are lockable. */
+        SupportedLock supportedLock = new SupportedLock();
+        supportedLock.addEntry(Type.WRITE, Scope.EXCLUSIVE);
+        properties.add(supportedLock);
+
+        // non-protected JCR properties defined on the underlaying jcr node
+        try {
+            // todo: should filter be respected for properties as well?
+            PropertyIterator it = node.getProperties();
+            while (it.hasNext()) {
+                Property p = it.nextProperty();
+                String pName = p.getName();
+                PropertyDefinition def = p.getDefinition();
+                if (def.isMultiple()) {
+                    log.debug("Multivalue property '" + pName + "' not added to webdav property set.");
+                    continue;
-            } catch (RepositoryException e) {
-                log.error("Unexpected error while retrieving properties: " + e.getMessage());
+                DavPropertyName name = getDavName(pName, node.getSession());
+                String value = p.getValue().getString();
+                properties.add(new DefaultDavProperty(name, value, def.isProtected()));
+        } catch (RepositoryException e) {
+            log.error("Unexpected error while retrieving properties: " + e.getMessage());
+            JcrDavException je = new JcrDavException(e);
-                throw new JcrDavException(e);
+                // should not happen...
-            throw new JcrDavException(e);
+            throw je;
-            throw new JcrDavException(e);
+            JcrDavException je = new JcrDavException(e);
+            try {
+                node.refresh(false);
+            } catch (RepositoryException re) {
+                // should not happen...
+            }
+            throw je;
-    public void alterProperties(DavPropertySet setProperties,
-                                DavPropertyNameSet removePropertyNames)
-        throws DavException {
+    /**
+     * @see DavResource#alterProperties(org.apache.jackrabbit.webdav.property.DavPropertySet, org.apache.jackrabbit.webdav.property.DavPropertyNameSet)
+     */
+    public MultiStatusResponse alterProperties(DavPropertySet setProperties,
+                                               DavPropertyNameSet removePropertyNames)
+            throws DavException {
-        try {
-            DavPropertyIterator setIter = setProperties.iterator();
-            while (setIter.hasNext()) {
-                DavProperty prop = setIter.nextProperty();
+
+        MultiStatusResponse msr = new MultiStatusResponse(getHref());
+        boolean success = true;
+
+        // loop over set and remove Sets and remember all properties and propertyNames
+        // that have successfully been altered
+        List successList = new ArrayList();
+        DavPropertyIterator setIter = setProperties.iterator();
+        while (setIter.hasNext()) {
+            DavProperty prop = setIter.nextProperty();
+            try {
+                successList.add(prop);
+            } catch (RepositoryException e) {
+                msr.add(prop.getName(), new JcrDavException(e).getErrorCode());
+                success = false;
-            Iterator remNameIter = removePropertyNames.iterator();
-            while (remNameIter.hasNext()) {
-                DavPropertyName propName = (DavPropertyName) remNameIter.next();
+        }
+
+        Iterator remNameIter = removePropertyNames.iterator();
+        while (remNameIter.hasNext()) {
+            DavPropertyName propName = (DavPropertyName) remNameIter.next();
+            try {
+                successList.add(propName);
+            } catch (RepositoryException e) {
+                msr.add(propName, new JcrDavException(e).getErrorCode());
+                success = false;
-            // save all changes together (reverted in case this fails)
-            node.save();
+        }
+
+        try {
+            if (success) {
+                // save all changes together (reverted in case this fails)
+                node.save();
+            } else {
+                // set/remove of at least a single prop failed: undo modifications.
+                node.refresh(false);
+            }
+            /* loop over list of properties/names that were successfully altered
+               and them to the multistatus response respecting the resulte of the
+               complete action. in case of failure set the status to 'failed-dependency'
+               in order to indicate, that altering those names/properties would
+               have succeeded, if no other error occured.*/
+            Iterator it = successList.iterator();
+            while (it.hasNext()) {
+                Object o = it.next();
+                int status = (success) ? DavServletResponse.SC_OK : DavServletResponse.SC_FAILED_DEPENDENCY;
+                if (o instanceof DavProperty) {
+                    msr.add(((DavProperty) o).getName(), status);
+                } else {
+                    msr.add((DavPropertyName) o, status);
+                }
+            }
+            return msr;
-                throw new JcrDavException(e);
+                // should not happen
-                parentPath="/";
+                parentPath = "/";
-                while(it.hasNext()) {
+                while (it.hasNext()) {
-                        list.add(buildResourceFromItem(n));
+                        DavResourceLocator resourceLocator = locator.getFactory().createResourceLocator(locator.getPrefix(), locator.getWorkspacePath(), n.getPath(), false);
+                        DavResource childRes = factory.createResource(resourceLocator, session);
+                        list.add(childRes);
-        if (isLocked(this)) {
+        if (isLocked(this) || isLocked(member)) {
-            ctx.setSystemId(member.getDisplayName());
+            String sysId = Text.getName(member.getLocator().getJcrPath());
+            ctx.setSystemId(sysId);
+        } catch (DavException e) {
+            // TODO: hack needed in order not to fall into the general Exception
+            throw e;
+            // TODO: remove this! why do the commands throw an unspecific exception?
-	    ActiveLock lock = getLock(Type.WRITE, Scope.EXCLUSIVE);
-	    if (lock != null && lockManager.hasLock(lock.getToken(), member)) {
-		lockManager.releaseLock(lock.getToken(), member);
-	    }
+            ActiveLock lock = getLock(Type.WRITE, Scope.EXCLUSIVE);
+            if (lock != null && lockManager.hasLock(lock.getToken(), member)) {
+                lockManager.releaseLock(lock.getToken(), member);
+            }
-            Session s = session.getRepositorySession();
-            Item memItem = s.getItem(member.getResourcePath());
+            String itemPath = member.getLocator().getJcrPath();
+            Item memItem = session.getRepositorySession().getItem(itemPath);
-            s.save();
+            session.getRepositorySession().save();
-            session.getRepositorySession().getWorkspace().move(getResourcePath(), destination.getResourcePath());
+            String destItemPath = destination.getLocator().getJcrPath();
+            session.getRepositorySession().getWorkspace().move(locator.getJcrPath(), destItemPath);
-            session.getRepositorySession().getWorkspace().copy(getResourcePath(), destination.getResourcePath());
+            String destItemPath = destination.getLocator().getJcrPath();
+            session.getRepositorySession().getWorkspace().copy(locator.getJcrPath(), destItemPath);
-	    if (isJsrLockable()) {
-                try {
+            try {
+                if (node.isLocked()) {
-                } catch (RepositoryException e) {
-                    // LockException: no lock applies to this node >> ignore
-                    // RepositoryException, AccessDeniedException or another error >> ignore
+            } catch (RepositoryException e) {
+                // LockException (no lock applies) >> should never occur
+                // RepositoryException, AccessDeniedException or another error >> ignore
-            // could not retrieve jcr-lock (either not jcr-lockable or the lock has
-            // been created before the node was made jcr-lockable. test if a simple
-            // webdav lock is present.
+            // could not retrieve a jcr-lock. test if a simple webdav lock is present.
-        return (writeLock != null) ? new ActiveLock[] {writeLock} : new ActiveLock[0];
+        return (writeLock != null) ? new ActiveLock[]{writeLock} : new ActiveLock[0];
-	ActiveLock lock = null;
+        ActiveLock lock = null;
-            // todo: deal with existing locks, that may have been created, before the node was jcr-lockable...            
+            // TODO: deal with existing locks, that may have been created, before the node was jcr-lockable...
-		try {
-		    // try to execute the lock operation
-		    Lock jcrLock = node.lock(lockInfo.isDeep(), false);
-		    if (jcrLock != null) {
-			lock = new JcrActiveLock(jcrLock);
-		    }
-		} catch (RepositoryException e) {
-		    throw new JcrDavException(e);
-		}
-	    } else {
-		// create a new webdav lock
-		lock = lockManager.createLock(lockInfo, this);
-	    }
-	} else {
-	    throw new DavException(DavServletResponse.SC_PRECONDITION_FAILED, "Unsupported lock type or scope.");
-	}
-	return lock;
+                try {
+                    // try to execute the lock operation
+                    Lock jcrLock = node.lock(lockInfo.isDeep(), false);
+                    if (jcrLock != null) {
+                        lock = new JcrActiveLock(jcrLock);
+                    }
+                } catch (RepositoryException e) {
+                    throw new JcrDavException(e);
+                }
+            } else {
+                // create a new webdav lock
+                lock = lockManager.createLock(lockInfo, this);
+            }
+        } else {
+            throw new DavException(DavServletResponse.SC_PRECONDITION_FAILED, "Unsupported lock type or scope.");
+        }
+        return lock;
-    public ActiveLock refreshLock(LockInfo lockInfo, String lockToken) throws DavException{
+    public ActiveLock refreshLock(LockInfo lockInfo, String lockToken) throws DavException {
-           throw new DavException(DavServletResponse.SC_PRECONDITION_FAILED, "No lock with the given type/scope present on resource " + getResourcePath());
+            throw new DavException(DavServletResponse.SC_PRECONDITION_FAILED, "No lock with the given type/scope present on resource " + getResourcePath());
-        
+
+     *
-    
+
-     * Returns true, if this webdav resource allows for locking without checking
-     * its current lock status.
+     * Returns true, if the underlaying node is nodetype jcr:lockable,
+     * without checking its current lock status. If the node is not jcr-lockable
+     * an attempt is made to add the mix:lockable mixin type.
-                lockable =  node.isNodeType(MIX_LOCKABLE);
+                lockable = node.isNodeType(MIX_LOCKABLE);
+                // not jcr-lockable: try to make the node jcr-lockable
+                if (!lockable && node.canAddMixin(MIX_LOCKABLE)) {
+                    node.addMixin(MIX_LOCKABLE);
+                    node.save();
+                    lockable = true;
+                }
-                // not jcr-lockable
+                // -> node is definitely not jcr-lockable.
-                   return false;
+                    return false;
-     * @param item
-     * @return
-     * @throws DavException
-     * @throws RepositoryException
-     */
-    private DavResource buildResourceFromItem(Item item) throws DavException, RepositoryException {
-        DavResourceLocator parentloc = locator.getFactory().createResourceLocator(locator.getPrefix(), locator.getWorkspacePath(), item.getPath());
-        return factory.createResource(parentloc, session);
-    }
-
-    /**
-     * webdav namespaces a new prefix is assigned.
+     * webdav namespaces a new prefix is assigned.<br>
+     * Please note, that the local part of the jcrName is checked for XML
+     * compatibility by calling {@link ISO9075#encode(String)}
-     * @return namespace
+     * @param session
+     * @return a <code>DavPropertyName</code> for the given jcr name.
+        // make sure the local name is xml compliant
+        String localName = ISO9075.encode(Text.getLocalName(jcrName));
-        DavPropertyName name = DavPropertyName.create(Text.getLocalName(jcrName), namespace);
+        DavPropertyName name = DavPropertyName.create(localName, namespace);
-     * extra effort is made to generated a unique prefix. 
+     * extra effort is made to generated a unique prefix.
-        String pName = propName.getName();
+        // remove any encoding necessary for xml compliance
+        String pName = ISO9075.decode(propName.getName());
-
+                // avoid trouble with default namespace
+                if (prefix == null || "".equals(prefix)) {
+                    prefix = "_pre" + nsReg.getPrefixes().length + 1;
+                }
-     *
-        node.getProperty(getJcrName(propertyName)).remove();
+        String jcrName = getJcrName(propertyName);
+        if (node.hasProperty(jcrName)) {
+            node.getProperty(jcrName).remove();
+        }
+        // removal of non existing property succeeds
-        // todo: filtered nodetypes should be checked as well in order to prevent problems.
+        // TODO: filtered nodetypes should be checked as well in order to prevent problems.

INS26 INS40 INS31 INS31 MOV29 UPD83 MOV83 MOV43 UPD42 MOV42 INS8 MOV8 INS29 INS83 INS43 INS42 MOV44 MOV44 MOV43 INS8 MOV8 MOV60 INS8 UPD43 UPD42 INS65 INS60 INS41 INS25 INS65 UPD42 MOV42 MOV25 MOV25 INS60 INS60 INS60 MOV60 MOV61 MOV60 MOV61 INS54 MOV60 MOV41 INS65 INS60 INS60 INS25 UPD66 UPD66 UPD42 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 MOV43 INS59 INS16 INS27 MOV8 INS68 INS43 INS59 INS39 INS59 INS43 INS59 INS8 INS8 MOV12 INS27 INS12 INS8 MOV8 MOV27 UPD66 UPD66 INS66 UPD66 INS66 INS66 INS65 INS42 UPD66 INS43 MOV43 INS59 UPD66 INS43 INS59 INS32 INS8 INS32 INS42 MOV32 INS36 INS32 INS42 INS38 INS27 INS42 INS42 INS69 INS69 INS42 INS42 INS14 INS42 INS9 INS42 INS42 INS14 MOV60 INS54 INS54 MOV25 INS60 INS61 MOV41 INS32 INS32 INS60 INS21 INS44 INS8 INS60 INS21 INS60 MOV25 INS68 INS42 UPD42 INS42 INS32 INS32 INS42 INS42 MOV32 INS42 INS42 INS42 MOV21 INS42 INS42 INS8 INS27 UPD42 MOV42 UPD42 MOV42 INS42 MOV32 INS42 INS33 INS60 INS53 INS60 INS54 INS53 INS43 INS43 INS43 INS32 UPD43 MOV43 INS8 INS12 INS8 INS12 INS42 INS8 INS43 MOV59 INS32 INS8 UPD42 MOV42 MOV52 INS42 INS42 INS43 INS59 INS32 MOV43 INS42 INS53 UPD43 INS43 INS59 INS32 INS43 INS59 INS8 INS8 INS42 INS42 INS69 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS60 INS25 UPD42 MOV42 MOV33 INS43 INS59 INS42 INS43 INS59 INS8 INS12 INS42 INS40 INS40 INS42 UPD42 MOV42 UPD42 MOV21 INS21 INS44 INS8 MOV21 INS21 INS44 INS8 INS21 INS42 UPD42 INS32 UPD42 MOV42 INS42 INS60 INS60 INS25 INS42 INS42 INS32 INS42 INS42 INS42 INS42 UPD42 UPD42 INS32 INS32 INS42 INS42 INS32 MOV32 INS42 INS32 INS42 INS42 INS42 INS32 UPD42 INS42 INS25 MOV21 INS25 INS43 MOV43 INS59 INS27 INS8 INS42 INS42 INS14 INS42 INS42 INS14 INS21 INS44 INS8 INS32 INS43 INS42 INS21 INS21 INS32 INS43 INS42 INS21 INS21 INS32 INS32 INS42 INS42 INS43 INS59 INS39 INS59 INS62 INS8 MOV8 UPD42 MOV42 UPD42 MOV42 INS32 INS32 INS42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 UPD42 UPD42 INS32 MOV8 INS27 INS8 INS42 INS25 INS42 INS42 INS32 INS27 INS32 INS21 MOV25 INS21 MOV43 MOV42 MOV43 MOV42 INS32 INS43 INS42 INS42 INS42 INS42 INS42 INS32 INS7 INS42 INS42 INS42 INS42 INS32 INS7 MOV42 UPD42 MOV42 INS42 INS42 INS9 INS42 INS42 INS32 INS42 INS16 INS42 INS43 INS21 MOV32 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS38 INS32 INS21 MOV21 INS21 INS27 INS8 MOV32 INS42 INS32 INS42 INS33 INS42 INS42 INS7 INS7 INS42 INS42 INS9 INS42 INS42 INS42 INS32 INS32 INS42 INS9 INS42 INS42 INS42 INS32 INS42 INS9 UPD42 MOV42 UPD42 MOV42 INS36 INS40 INS40 UPD42 MOV42 INS32 INS32 UPD42 INS42 INS42 INS42 INS42 INS32 INS7 INS27 INS32 INS21 INS42 INS42 INS42 INS11 MOV21 INS42 INS32 INS42 INS42 INS14 INS42 INS14 INS42 INS42 INS42 INS42 INS32 INS42 INS42 UPD42 MOV42 INS11 INS42 INS60 INS60 INS42 INS42 INS42 INS42 INS9 INS42 INS33 INS45 INS42 INS42 INS7 MOV43 INS42 MOV32 INS42 INS42 INS42 INS43 INS42 INS43 INS42 INS36 UPD42 MOV42 INS43 INS42 MOV43 INS59 MOV43 INS59 INS42 INS27 INS42 UPD42 MOV42 INS43 INS42 INS42 INS11 INS42 INS42 INS32 INS42 INS32 UPD42 MOV42 INS45 INS22 INS34 INS42 INS43 INS42 MOV32 INS42 MOV32 MOV32 INS32 INS9 INS42 INS42 INS42 INS42 INS32 INS42 MOV42 MOV42 INS42 INS42 INS42 INS42 INS42 DEL42 DEL32 DEL32 DEL8 DEL66 DEL65 DEL42 DEL65 DEL42 DEL65 DEL29 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL27 DEL32 DEL38 DEL27 DEL25 DEL42 DEL42 DEL11 DEL7 DEL21 DEL8 DEL31 DEL83 DEL42 DEL60 DEL32 DEL42 DEL32 DEL7 DEL21 DEL8 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL8 DEL25 DEL42 DEL33 DEL27 DEL32 DEL33 DEL27 DEL27 DEL25 DEL8 DEL31 DEL25 DEL8 DEL42 DEL43 DEL42 DEL14 DEL53 DEL14 DEL53 DEL14 DEL53 DEL8 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL27 DEL42 DEL9 DEL7 DEL33 DEL42 DEL42 DEL42 DEL32 DEL32 DEL7 DEL42 DEL43 DEL42 DEL14 DEL53 DEL83 DEL39 DEL42 DEL8 DEL54 DEL8 DEL31 DEL42 DEL32 DEL32 DEL32 DEL21 DEL32 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL42 DEL32 DEL25 DEL8 DEL8 DEL42 DEL65 DEL65 DEL42 DEL65 DEL42 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL42 DEL8
JCR-2313: Improvements to user management (2)  [NOTE: work in progress]

- calculate jcr:uuid of user/group nodes from the ID  and consequently 
   -> simplify getAuthorizable(String id)
   -> enabled intermediatePath param upon creation
   -> remove some limitations of the built-in node structure
- remove referees concept form API and node type definition.
- typo and inconsistencies in javadoc


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@818433 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.id.NodeId;
-import org.apache.jackrabbit.spi.commons.name.NameConstants;
+import javax.jcr.Session;
+import javax.jcr.ItemNotFoundException;
+import java.util.UUID;
+import java.io.UnsupportedEncodingException;
- * created below {@link UserConstants#GROUPS_PATH}.</li>
- * <li>In order to structure the users and groups tree and void creating a flat
+ * created below {@link UserConstants#GROUPS_PATH} (unless otherwise configured).</li>
+ * <li>The Id of an authorizable is stored in the jcr:uuid property (md5 hash).</li>
+ * <li>In order to structure the users and groups tree and avoid creating a flat
- * introduced.</li>
+ * introduced using
+ *    <ul>
+ *    <li>the specified intermediate path passed to the create methods</li>
+ *    <li>or some built-in logic if the intermediate path is missing.</li>
+ *    </ul>
+ * </li>
+ * </ul>
+ *
+ * The built-in logic applies the following rules:
+ * <ul>
- * <li>Searching authorizables by ID always starts looking at that specific
- * hierarchy level. Parent nodes are expected to consist of folder structure only.</li>
+ * <li>Parent nodes are expected to consist of folder structure only.</li>
- * <li>Any intermediate path passed to either
- * {@link #createUser(String, String, Principal, String) createUser} or
- * {@link #createGroup(Principal, String) createGroup} are ignored. This allows
- * to directly find authorizables by ID without having to search or traverse
- * the complete tree.<br>
- * See also {@link #PARAM_COMPATIBILE_JR16}.
- * </li>
- * Example: Creating an non-existing authorizable with ID 'aSmith' would result
- * in the following structure:
+ * Examples:
+ * Creating an non-existing user with ID 'aSmith' without specifying an
+ * intermediate path would result in the following structure:
+ * Creating a non-existing user with ID 'aSmith' specifying an intermediate
+ * path 'some/tree' would result in the following structure:
+ *
+ * <pre>
+ * + rep:security            [nt:unstructured]
+ *   + rep:authorizables     [rep:AuthorizableFolder]
+ *     + rep:users           [rep:AuthorizableFolder]
+ *       + some              [rep:AuthorizableFolder]
+ *         + tree            [rep:AuthorizableFolder]
+ *           + aSmith        [rep:User]
+ * </pre>
+ *
+ * <li>{@link #PARAM_USERS_PATH}: Defines where user nodes are created.
+ * If missing set to {@link #USERS_PATH}.</li>
+ * <li>{@link #PARAM_GROUPS_PATH}. Defines where group nodes are created.
+ * If missing set to {@link #GROUPS_PATH}.</li>
- * levels that are used by default store authorizable nodes.<br>The value is
+ * levels that are used by default to store authorizable nodes.<br>The value is
- * <p/>
- * <strong>NOTE:</strong> Changing the default depth once users and groups
- * have been created in the repository will cause inconsistencies, due to
- * the fact that the resolution of ID to an authorizable relies on the
- * structure defined by the default depth.<br>
- * It is recommended to remove all authorizable nodes that will not be
- * reachable any more, before this config option is changed.
- * <ul>
- * <li>If default depth is increased:<br>
- * All authorizables on levels &lt; default depth are not reachable any more.</li>
- * <li>If default depth is decreased:<br>
- * All authorizables on levels &gt; default depth aren't reachable any more
- * unless the {@link #PARAM_AUTO_EXPAND_TREE} flag is set to <code>true</code>.</li>
- * </ul>
+     * Configuration option to change the {@link #USERS_PATH default path} for
+     * creating users.
+     */
+    public static final String PARAM_USERS_PATH = "usersPath";
+
+    /**
+     * Configuration option to change the {@link #GROUPS_PATH default path} for
+     * creating groups.
+     */
+    public static final String PARAM_GROUPS_PATH = "groupsPath";
+
+    /**
-    private final IdResolver idResolver;
+    private final NodeCreator nodeCreator;
+
+    /**
+     * Configuration value defining the node where User nodes will be created.
+     * Default value is {@link #USERS_PATH}.
+     */
+    private final String usersPath;
+
+    /**
+     * Configuration value defining the node where Group nodes will be created.
+     * Default value is {@link #GROUPS_PATH}.
+     */
+    private final String groupsPath;
+     * Flat storing the batch modus.
+     * If this option is turned on changes made through this user manager will
+     * only be persisted upon an explicit call to {@link javax.jcr.Session#save()},
+     * which must be the editing session object. Otherwise (default behavior)
+     * changes are immediately persisted.
+     *
+     * @see #setPersistenceModus(boolean, Session)
+     */
+    boolean batchModus = false;
+
+    /**
-     * <li>{@link #PARAM_COMPATIBILE_JR16}. By default this option is disabled.</li>
+     * <li>{@link #PARAM_USERS_PATH}. If missing set to {@link #USERS_PATH}.</li>
+     * <li>{@link #PARAM_GROUPS_PATH}. If missing set to {@link #GROUPS_PATH}.</li>
+        nodeCreator = new NodeCreator(config);
+
+        Object param = (config != null) ? config.get(PARAM_USERS_PATH) : null;
+        usersPath = (param != null) ? param.toString() : USERS_PATH;
+
+        param = (config != null) ? config.get(PARAM_GROUPS_PATH) : null;
+        groupsPath = (param != null) ? param.toString() : GROUPS_PATH;
+
+        param = (config != null) ? config.get(PARAM_COMPATIBILE_JR16) : null;
+        compatibleJR16 = (param != null) && Boolean.parseBoolean(param.toString());
+
+        authResolver.setSearchRoots(usersPath, groupsPath);
+    }
-        idResolver = new IdResolver(config);
-        boolean compatMode = false;
-        if (config != null && config.containsKey(PARAM_COMPATIBILE_JR16)) {
-            compatMode = Boolean.parseBoolean(config.get(PARAM_COMPATIBILE_JR16).toString());
+    /**
+     * @param batched If <code>true</code> changes made through this manager and
+     * to authorizables are only persisted upon explict call to {@link
+     * javax.jcr.Session#save()}.
+     * @throws RepositoryException If the passed <code>editingSession</code> is
+     * not the same this UserManager is writing to.
+     */
+    /* COMMENTED. WORK IN PROGRESS
+    public void setPersistenceModus(boolean batched, Session editingSession) throws RepositoryException {
+        if (editingSession != session) {
+            throw new RepositoryException("Cannot change persistence modus: Session mismatch.");
-        compatibleJR16 = compatMode;
+        batchModus = batched;
+    }
+    */
+
+    /**
+     * Implementation specific methods releaving where users are created within
+     * the content.
+     *
+     * @return root path for user content.
+     * @see #PARAM_USERS_PATH For the corresponding configuration parameter.
+     */
+    public String getUsersPath() {
+        return usersPath;
+    }
+
+    /**
+     * Implementation specific methods releaving where groups are created within
+     * the content.
+     *
+     * @return root path for group content.
+     * @see #PARAM_GROUPS_PATH For the corresponding configuration parameter.
+     */
+    public String getGroupsPath() {
+        return groupsPath;
-        NodeImpl n = getUserNode(id);
-        if (n != null) {
-            authorz = createUser(n);
-        } else {
-            n = getGroupNode(id);
-            if (n != null) {
-                authorz = createGroup(n);
-            }
+        NodeId nodeId = buildNodeId(id);        
+        NodeImpl n = null;
+        try {
+            n = session.getNodeById(nodeId);
+        } catch (ItemNotFoundException e) {
+            if (compatibleJR16) {
+                // backwards-compatibility with JR < 2.0 user/group structure that doesn't
+                // allow to determine existance of an authorizable from the id directly.
+                // search for it the node belonging to that id
+                n = (NodeImpl) authResolver.findNode(P_USERID, id, NT_REP_USER);
+                if (n == null) {
+                    // no user -> look for group.
+                    // NOTE: JR < 2.0 always returned groupIDs that didn't contain any
+                    // illegal JCR chars. Since Group.getID() now unescapes the node
+                    // name additional escaping is required.
+                    Name nodeName = session.getQName(Text.escapeIllegalJcrChars(id));
+                    n = (NodeImpl) authResolver.findNode(nodeName, NT_REP_GROUP);
+                }
+            } // else: no matching node found -> ignore exception.
+
+        if (n != null) {
+            if (n.isNodeType(NT_REP_USER)) {
+                authorz = createUser(n);
+            } else if (n.isNodeType(NT_REP_GROUP)) {
+                authorz = createGroup(n);
+            } // else some other node but not an authorizable -> return null.
+        } // else no matching node -> return null.
-        if (hasAuthorizableOrReferee(principal)) {
+        if (hasAuthorizable(principal)) {
-        if (intermediatePath != null) {
-            log.debug("Intermediate path param " + intermediatePath + " is ignored.");
-        }
-        NodeImpl parent = null;
-            NodeImpl userNode = (NodeImpl) idResolver.createUserNode(userID);
+            NodeImpl userNode = (NodeImpl) nodeCreator.createUserNode(userID, intermediatePath);
-            session.save();
+            if (!batchModus) {
+                session.save();
+            }
-        if (hasAuthorizableOrReferee(principal)) {
+        if (hasAuthorizable(principal)) {
-        if (intermediatePath != null) {
-            log.debug("Intermediate path param " + intermediatePath + " is ignored.");
-        }
-        NodeImpl parent = null;
-            NodeImpl groupNode = (NodeImpl) idResolver.createGroupNode(groupID);
+            NodeImpl groupNode = (NodeImpl) nodeCreator.createGroupNode(groupID, intermediatePath);
-            session.save();
+            if (!batchModus) {
+                session.save();
+            }
-    boolean hasAuthorizableOrReferee(Principal principal) throws RepositoryException {
-        Set<Name> s = new HashSet<Name>(2);
-        s.add(P_PRINCIPAL_NAME);
-        s.add(P_REFEREES);
-        NodeIterator res = authResolver.findNodes(s, principal.getName(), NT_REP_AUTHORIZABLE, true, 1);
-        return res.hasNext();
+    private boolean hasAuthorizable(Principal principal) throws RepositoryException {
+        return getAuthorizable(principal) != null;
-        node.save();
+        if (!batchModus) {
+            node.save();
+        }
-        node.save();
+        if (!batchModus) {
+            node.save();
+        }
-        node.save();
+        if (!batchModus) {
+            node.save();
+        }
-        parent.save();
+        if (!batchModus) {
+            parent.save();
+        }
-        String escHint = principalName;
-        String groupID = escHint;
+        String groupID = principalName;
-            groupID = escHint + "_" + i;
+            groupID = principalName + "_" + i;
-        if (!Text.isDescendant(USERS_PATH, userNode.getPath())) {
+        if (!Text.isDescendant(usersPath, userNode.getPath())) {
-        User user = doCreateUser(userNode);
-        return user;
+        return doCreateUser(userNode);
-        Group group = GroupImpl.create(groupNode, this);
-        return group;
-    }
-
-    /**
-     * Resolve the given <code>userID</code> to an rep:user node in the repository.
-     *
-     * @param userID A valid userID.
-     * @return the node associated with the given userID or <code>null</code>.
-     * @throws RepositoryException If an error occurs.
-     */
-    private NodeImpl getUserNode(String userID) throws RepositoryException {
-        NodeImpl n = (NodeImpl) idResolver.findNode(userID, false);
-        if (n == null && compatibleJR16) {
-            // backwards-compatibility with JR < 2.0 user structure that doesn't
-            // allow to determine the auth-path from the id directly.
-            // search for it the node belonging to that userID
-            n = (NodeImpl) authResolver.findNode(P_USERID, userID, NT_REP_USER);
-        } // else: no such user -> return null.
-        return n;
-    }
-
-    /**
-     * Resolve the given <code>groupID</code> to an rep:group node in the repository.
-     *
-     * @param groupID A valid groupID.
-     * @return the node associated with the given userID or <code>null</code>.
-     * @throws RepositoryException If an error occurs.
-     */
-    private NodeImpl getGroupNode(String groupID) throws RepositoryException {
-        NodeImpl n = (NodeImpl) idResolver.findNode(groupID, true);
-        if (n == null && compatibleJR16) {
-            // backwards-compatibility with JR < 2.0 group structure that doesn't
-            // allow to determine the auth-path from the id directly
-            // search for it the node belonging to that groupID.
-            // NOTE: JR < 2.0 always returned groupIDs that didn't contain any
-            // illegal JCR chars. Since Group.getID() now unescapes the node
-            // name additional escaping is required.
-            Name nodeName = session.getQName(Text.escapeIllegalJcrChars(groupID));
-            n = (NodeImpl) authResolver.findNode(nodeName, NT_REP_GROUP);
-        } // else: no such group -> return null.
-        return n;
+        return GroupImpl.create(groupNode, this);
+    /**
+     *
+     * @param id
+     * @return
+     * @throws RepositoryException
+     */
+    private static NodeId buildNodeId(String id) throws RepositoryException {
+        try {
+            UUID uuid = UUID.nameUUIDFromBytes(id.getBytes("UTF-8"));
+            return new NodeId(uuid);
+        } catch (UnsupportedEncodingException e) {
+            throw new RepositoryException("Unexpected error while build ID hash", e);
+        }
+    }
+
-     * Inner class creating and finding the JCR nodes corresponding the a given
+     * Inner class creating the JCR nodes corresponding the a given
-     * <li>Users are created below /rep:security/rep:authorizables/rep:users</li>
-     * <li>Groups are created below /rep:security/rep:authorizables/rep:users</li>
+     * <li>Users are created below /rep:security/rep:authorizables/rep:users or
+     * the corresponding path configured.</li>
+     * <li>Groups are created below /rep:security/rep:authorizables/rep:groups or
+     * the corresponding path configured.</li>
-     * structure, whose depth is defined by the <code>defaultDepth</code> config
-     * option.<br>
+     * structure based on the defined intermediate path or some internal logic
+     * with a depth defined by the <code>defaultDepth</code> config option.<br>
-     * <li>The names of the intermediate folders are caculated from the leading
-     * chars of the escaped node name.</li>
+     * <li>If no intermediate path is passed the names of the intermediate
+     * folders are calculated from the leading chars of the escaped node name.</li>
-    private class IdResolver {
+    private class NodeCreator {
-        private IdResolver(Properties config) {
+        private NodeCreator(Properties config) {
-        public Node createUserNode(String userID) throws RepositoryException {
-            return createAuthorizableNode(userID, false);
+        public Node createUserNode(String userID, String intermediatePath) throws RepositoryException {
+            return createAuthorizableNode(userID, false, intermediatePath);
-        public Node createGroupNode(String groupID) throws RepositoryException {
-            return createAuthorizableNode(groupID, true);
+        public Node createGroupNode(String groupID, String intermediatePath) throws RepositoryException {
+            return createAuthorizableNode(groupID, true, intermediatePath);
-        public Node findNode(String id, boolean isGroup) throws RepositoryException {
-            String defaultFolderPath = getDefaultFolderPath(id, isGroup);
+        private Node createAuthorizableNode(String id, boolean isGroup, String intermediatePath) throws RepositoryException {
-            if (session.nodeExists(defaultFolderPath)) {
-                Node folder = session.getNode(defaultFolderPath);
-                Name expectedNt = (isGroup) ? NT_REP_GROUP : NT_REP_USER;
-
-                // traverse the potentially existing hierarchy looking for the
-                // authorizable node.
-                int segmLength = defaultDepth +1;
-                while (folder != null) {
-                    if (folder.hasNode(escapedId)) {
-                        NodeImpl aNode = (NodeImpl) folder.getNode(escapedId);
-                        if (aNode.isNodeType(expectedNt)) {
-                            // done. found the right auth-node
-                            return aNode;
-                        } else {
-                            folder = aNode;
-                        }
-                    } else {
-                        // no child node with name 'escapedId' -> look for
-                        // additional levels that may exist.
-                        Node parent = folder;
-                        folder = null;
-                        if (id.length() >= segmLength) {
-                            String folderName = Text.escapeIllegalJcrChars(id.substring(0, segmLength));
-                            if (parent.hasNode(folderName)) {
-                                NodeImpl f = (NodeImpl) parent.getNode(folderName);
-                                if (f.isNodeType(NT_REP_AUTHORIZABLE_FOLDER)) {
-                                    folder = f;
-                                } // else: matching node isn't an authorizable-folder
-                            } // else: failed to find a suitable next level
-                        } // else: id is shorter than required length at the current level.
-                    }
-                    segmLength++;
-                }
-            } // else: no node at default-path
-
-            // no matching node found -> authorizable doesn't exist.
-            return null;
-        }
-
-        private Node createAuthorizableNode(String id, boolean isGroup) throws RepositoryException {
-            String escapedId = Text.escapeIllegalJcrChars(id);
-
+            Node folder;
-            Node folder = createDefaultFolderNodes(id, escapedId, isGroup);
+            folder = createDefaultFolderNodes(id, escapedId, isGroup, intermediatePath);
-            folder = createIntermediateFolderNodes(id, escapedId, folder);
+            if (intermediatePath == null) {
+                // internal logic only
+                folder = createIntermediateFolderNodes(id, escapedId, folder);
+            }
-            Node authNode = addNode((NodeImpl) folder, nodeName, ntName);
+            NodeId nid = buildNodeId(id);
-            return authNode;
+            return addNode((NodeImpl) folder, nodeName, ntName, nid);
-        private Node createDefaultFolderNodes(String id, String escapedId, boolean isGroup) throws RepositoryException {
+        private Node createDefaultFolderNodes(String id, String escapedId,
+                                              boolean isGroup, String intermediatePath) throws RepositoryException {
-            // first create the levels that are always present -> see #getDefaultFolderPath
-            String defaultPath = getDefaultFolderPath(id, isGroup);
+            String defaultPath = getDefaultFolderPath(id, isGroup, intermediatePath);
+                if (!folder.isNodeType(NT_REP_AUTHORIZABLE_FOLDER)) {
+                    throw new RepositoryException("Invalid intermediate path. Must be of type rep:AuthorizableFolder.");
+                }
-                String repSecurity = SECURITY_ROOT_PATH.substring(1);
-                    } else {
-                        Name ntName;
-                        if (repSecurity.equals(segment)) {
-                            // rep:security node
-                            ntName = NameConstants.NT_UNSTRUCTURED;
-                        } else {
-                            ntName = NT_REP_AUTHORIZABLE_FOLDER;
+                        if (!folder.isNodeType(NT_REP_AUTHORIZABLE_FOLDER)) {
+                            throw new RepositoryException("Invalid intermediate path. Must be of type rep:AuthorizableFolder.");
-                        NodeImpl added = addNode(folder, session.getQName(segment), ntName);
-                        folder = added;
+                    } else {
+                        folder = addNode(folder, session.getQName(segment), NT_REP_AUTHORIZABLE_FOLDER);
-            // validation check if authorizable to be create doesn't conflict.
+            // validation check if authorizable to be created doesn't conflict.
-        private String getDefaultFolderPath(String id, boolean isGroup) {
+        private String getDefaultFolderPath(String id, boolean isGroup, String intermediatePath) {
-                bld.append(GROUPS_PATH);
+                bld.append(groupsPath);
-                bld.append(USERS_PATH);
+                bld.append(usersPath);
-            StringBuilder lastSegment = new StringBuilder(defaultDepth);
-            int idLength = id.length();
-            for (int i = 0; i < defaultDepth; i++) {
-                if (idLength > i) {
-                    lastSegment.append(id.charAt(i));
-                } else {
-                    // escapedID is too short -> append the last char again
-                    lastSegment.append(id.charAt(idLength-1));
+
+            if (intermediatePath == null) {
+                // internal logic
+                StringBuilder lastSegment = new StringBuilder(defaultDepth);
+                int idLength = id.length();
+                for (int i = 0; i < defaultDepth; i++) {
+                    if (idLength > i) {
+                        lastSegment.append(id.charAt(i));
+                    } else {
+                        // escapedID is too short -> append the last char again
+                        lastSegment.append(id.charAt(idLength-1));
+                    }
+                    bld.append(DELIMITER).append(Text.escapeIllegalJcrChars(lastSegment.toString()));
-                bld.append(DELIMITER).append(Text.escapeIllegalJcrChars(lastSegment.toString()));
+            } else {
+                // structure defined by intermediate path
+                if (intermediatePath.startsWith(bld.toString())) {
+                    intermediatePath = intermediatePath.substring(bld.toString().length());
+                }
+                if (intermediatePath.length() > 0 && !"/".equals(intermediatePath)) {
+                    if (!intermediatePath.startsWith("/")) {
+                        bld.append("/");
+                    }
+                    bld.append(intermediatePath);
+                }
-            int idLength = id.length();
-
+            

MOV26 INS26 INS26 INS26 INS26 MOV23 MOV31 UPD40 INS40 INS40 INS40 INS40 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 MOV65 MOV65 INS29 UPD83 INS83 MOV43 INS29 INS83 INS83 INS83 MOV43 INS59 INS83 INS83 INS43 INS59 INS29 INS83 INS83 MOV43 INS59 INS29 INS83 INS83 MOV43 INS59 INS29 INS39 INS59 MOV21 MOV60 MOV29 UPD83 MOV83 MOV43 UPD42 MOV42 INS8 INS29 INS83 MOV43 INS42 INS8 MOV29 INS83 INS39 INS42 MOV44 MOV43 INS8 INS8 INS83 UPD43 UPD42 MOV44 MOV43 UPD42 UPD66 INS66 UPD66 UPD66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 UPD66 UPD66 INS66 UPD66 MOV66 UPD66 UPD66 MOV66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS65 UPD66 UPD66 INS65 UPD66 INS65 UPD66 UPD66 INS65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS65 UPD42 INS45 INS65 INS42 INS45 UPD42 MOV42 UPD42 MOV42 INS65 INS42 INS65 INS42 INS65 INS65 INS42 INS9 INS21 INS21 INS21 INS21 MOV21 INS65 UPD65 INS41 INS65 INS65 INS65 INS41 INS60 INS60 INS54 INS41 MOV21 INS25 INS25 INS25 INS25 UPD42 INS54 UPD42 MOV43 INS42 INS44 MOV43 MOV43 UPD42 MOV44 INS44 MOV43 INS8 INS44 INS44 INS44 INS8 INS67 INS67 INS67 INS67 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS68 INS66 INS65 UPD66 INS65 INS66 INS65 INS66 INS66 INS43 INS7 INS7 INS7 INS7 INS32 UPD66 MOV66 UPD66 MOV66 UPD66 INS67 UPD66 INS42 INS66 INS66 INS66 INS67 INS66 INS42 INS43 INS59 MOV43 INS59 INS8 INS12 INS27 INS38 INS8 INS38 INS8 INS38 MOV8 INS38 INS8 MOV43 MOV32 MOV32 UPD42 INS8 INS12 UPD66 UPD66 INS66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 INS43 INS42 INS43 INS42 INS41 INS43 INS42 INS60 INS21 INS25 INS43 INS42 INS43 INS42 MOV60 INS25 INS25 MOV41 INS42 INS42 INS42 INS42 INS67 INS66 INS67 INS66 INS67 INS67 INS68 INS42 INS69 INS69 INS67 INS67 INS67 UPD42 INS42 INS42 INS16 INS42 INS16 INS42 INS16 INS42 INS16 INS42 INS16 UPD42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS44 INS8 INS25 UPD42 INS25 UPD42 INS25 INS32 INS33 INS42 MOV21 INS42 MOV21 INS42 INS42 MOV21 UPD42 MOV60 INS41 INS44 INS8 UPD42 MOV42 MOV42 INS32 INS42 MOV43 INS59 INS7 INS27 INS8 UPD43 MOV32 INS42 INS42 INS42 INS8 INS8 INS27 MOV8 INS8 INS42 INS42 INS42 INS42 INS40 INS42 INS39 INS43 UPD42 INS42 INS42 INS42 UPD43 INS36 INS32 INS33 INS36 INS32 INS42 INS36 INS32 INS33 INS36 INS32 INS42 INS36 MOV32 INS33 INS36 INS32 INS42 INS42 INS7 INS43 INS42 INS25 INS32 MOV8 MOV25 INS38 INS8 MOV43 INS38 INS8 UPD42 MOV42 UPD42 MOV42 UPD42 UPD43 INS14 INS43 INS42 INS53 INS42 UPD42 MOV42 UPD42 MOV42 INS9 UPD42 MOV42 MOV42 INS42 INS32 INS42 INS33 MOV21 UPD42 INS42 INS32 INS42 INS25 INS21 INS21 INS42 INS33 INS25 INS25 UPD42 MOV42 UPD42 MOV27 INS42 INS42 INS42 INS27 INS42 INS42 INS27 MOV42 UPD42 MOV42 UPD42 MOV42 INS27 INS42 INS42 INS27 INS27 MOV42 MOV42 MOV32 INS42 INS32 INS42 INS42 INS8 INS42 UPD42 MOV42 UPD42 MOV42 INS32 INS42 MOV21 INS42 MOV21 UPD42 UPD42 INS43 INS42 INS42 INS14 MOV42 MOV42 MOV42 MOV42 INS42 INS42 INS42 INS42 INS38 INS8 INS32 INS32 INS32 INS8 INS27 INS8 INS42 INS33 INS42 INS33 INS42 INS33 INS42 INS33 INS42 INS33 INS42 INS42 INS42 INS42 INS21 INS25 INS42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 MOV42 INS43 INS45 INS42 INS32 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS21 INS27 INS38 INS25 INS21 INS7 MOV27 INS8 UPD42 INS42 UPD42 INS42 UPD42 UPD42 INS45 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS7 INS32 INS34 INS32 INS38 INS8 INS32 INS42 INS11 MOV60 MOV21 MOV43 INS45 INS25 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS32 INS21 INS42 INS42 INS42 MOV43 INS32 INS43 INS38 INS8 INS42 INS42 INS32 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS32 INS53 MOV32 INS32 INS42 INS42 INS42 INS45 INS42 UPD42 INS32 INS42 INS42 INS42 INS14 UPD42 INS42 INS42 INS42 INS42 MOV42 INS42 MOV43 INS45 DEL66 DEL42 DEL69 DEL69 DEL42 DEL43 DEL69 DEL69 DEL68 DEL65 DEL42 DEL42 DEL43 DEL69 DEL69 DEL68 DEL65 DEL42 DEL67 DEL65 DEL66 DEL66 DEL66 DEL66 DEL66 DEL42 DEL67 DEL65 DEL66 DEL66 DEL42 DEL43 DEL39 DEL42 DEL9 DEL32 DEL32 DEL27 DEL8 DEL25 DEL42 DEL42 DEL7 DEL65 DEL42 DEL65 DEL42 DEL42 DEL33 DEL27 DEL42 DEL32 DEL7 DEL21 DEL42 DEL33 DEL27 DEL42 DEL42 DEL45 DEL42 DEL45 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL33 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL45 DEL42 DEL45 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL33 DEL59 DEL60 DEL39 DEL42 DEL42 DEL43 DEL43 DEL74 DEL42 DEL43 DEL42 DEL43 DEL74 DEL34 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL9 DEL34 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL42 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL9 DEL32 DEL11 DEL59 DEL60 DEL42 DEL27 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL66 DEL65 DEL66 DEL66 DEL66 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL9 DEL32 DEL11 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL27 DEL8 DEL25 DEL42 DEL41 DEL43 DEL42 DEL83 DEL42 DEL42 DEL42 DEL9 DEL32 DEL41 DEL8 DEL31 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL36 DEL42 DEL42 DEL16 DEL59 DEL60 DEL39 DEL42 DEL42 DEL34 DEL27 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL41 DEL8 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL33 DEL7 DEL21 DEL42 DEL42 DEL32 DEL42 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL34 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL42 DEL37 DEL21 DEL8 DEL61 DEL8 DEL25 DEL33 DEL41 DEL8 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL40 DEL7 DEL21 DEL8 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60
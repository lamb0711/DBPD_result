Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.hierarchy.NodeEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.PropertyEntry;
-import org.apache.jackrabbit.spi.ItemId;
-import org.apache.jackrabbit.spi.IdFactory;
-import java.util.Set;
-import java.util.HashSet;
-import java.util.Collection;
-import java.util.Collections;
-                                   IdFactory idFactory,
-                                   QValueFactory qValueFactory) {
+                                   QValueFactory qValueFactory,
+                                   ItemStateFactory isf) {
+        
-        this.transientStateMgr = new TransientItemStateManager(idFactory, workspaceItemStateMgr);
+        this.transientStateMgr = new TransientItemStateManager();
+        isf.addCreationListener(transientStateMgr);
+
-    //---------------------------------------------------< ItemStateManager >---
-    /**
-     * {@inheritDoc}
-     * @see ItemStateManager#getRootState()
-     */
-    public NodeState getRootState() throws ItemStateException {
-        // always retrieve from transientStateMgr
-        return transientStateMgr.getRootState();
-    }
-
-    /**
-     * {@inheritDoc}
-     * @see ItemStateManager#getItemState(ItemId)
-     */
-    public ItemState getItemState(ItemId id)
-            throws NoSuchItemStateException, ItemStateException {
-
-        ItemState itemState = transientStateMgr.getItemState(id);
-        // check status of ItemState. Transient ISM also returns removed ItemStates
-        if (itemState.isValid()) {
-            return itemState;
-        } else {
-            throw new NoSuchItemStateException(id.toString());
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     * @see ItemStateManager#hasItemState(ItemId)
-     */
-    public boolean hasItemState(ItemId id) {
-        // first check if the specified item exists at all in the transient ISM
-        if (transientStateMgr.hasItemState(id)) {
-            // retrieve item and check state
-            try {
-                ItemState itemState = transientStateMgr.getItemState(id);
-                if (itemState.isValid()) {
-                    return true;
-                }
-            } catch (ItemStateException e) {
-                // has been removed in the meantime
-            }
-        }
-        return false;
-    }
-
-    /**
-     * {@inheritDoc}
-     * Since node references cannot be managed within the transient space,
-     * this call is delegated to the workspace itemstate manager.
-     *
-     * @see ItemStateManager#getReferingStates(NodeState)
-     * @param nodeState
-     */
-    public Collection getReferingStates(NodeState nodeState) throws ItemStateException {
-        NodeState wspState = (NodeState) nodeState.getWorkspaceState();
-        if (wspState == null) {
-            // new state => unable to determine references
-            return Collections.EMPTY_SET;
-        }
-
-        Collection rs = workspaceItemStateMgr.getReferingStates(wspState);
-        if (rs.isEmpty()) {
-            return rs;
-        } else {
-            // retrieve session-propertystates
-            Set refStates = new HashSet();
-            for (Iterator it =  rs.iterator(); it.hasNext();) {
-                PropertyState wState = (PropertyState) it.next();
-                ItemState sState = wState.getSessionState();
-                if (sState == null) {
-                    // overlaying state has not been build up to now
-                   sState = getItemState(wState.getPropertyId());
-                }
-                // add property state to list of refering states unless it has
-                // be removed in the transient layer.
-                if (sState.isValid()) {
-                   refStates.add(sState);
-                }
-            }
-            return Collections.unmodifiableCollection(refStates);
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     * Since node references cannot be managed within the transient space,
-     * this call is delegated to the workspace itemstate manager.
-     *
-     * @see ItemStateManager#hasReferingStates(NodeState)
-     * @param nodeState
-     */
-    public boolean hasReferingStates(NodeState nodeState) {
-        try {
-            return !getReferingStates(nodeState).isEmpty();
-        } catch (ItemStateException e) {
-            log.warn("Internal error", e);
-            return false;
-        }
-    }
-
-    //------------------------------------------< UpdatableItemStateManager >---
-    /**
-     * {@inheritDoc}
-     */
-    public void execute(Operation operation) throws RepositoryException {
-        operation.accept(this);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void execute(ChangeLog changes) throws RepositoryException {
-        throw new UnsupportedOperationException("Not implemented for SessionItemStateManager");
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void dispose() {
-        // discard all transient changes
-        transientStateMgr.dispose();
-        // dispose our (i.e. 'local') state manager
-        workspaceItemStateMgr.dispose();
-    }
-
-    //--------------------------------------------------------------------------
-     *         <code>false</code> otherwise.
+     * <code>false</code> otherwise.
-     *                            and descendant items is not a closed set of
-     *                            changes. That is, at least another item needs
-     *                            to be canceled as well in another sub-tree.
+     * and descendant items is not a closed set of changes. That is, at least
+     * another item needs to be canceled as well in another sub-tree.
-                state.revert();
+                state.getHierarchyEntry().revert();
-     * Adjust references at the end of a successful {@link Session#importXML(String, InputStream, int) XML import}.
+     * Adjust references at the end of a successful
+     * {@link Session#importXML(String, InputStream, int) XML import}.
-    //-------------------------------------------< Transient state handling >---
-
+    //------------------------------------------< UpdatableItemStateManager >---
-     *
-     * @param itemState
-     * @param throwOnStale Throws StaleItemStateException if either the given
-     * <code>ItemState</code> or any of its decendants is stale and the flag is true.
-     * @return
-     * @throws StaleItemStateException if a stale <code>ItemState</code> is
-     * encountered while traversing the state hierarchy. The <code>changeLog</code>
-     * might have been populated with some transient item states. A client should
-     * therefore not reuse the <code>changeLog</code> if such an exception is thrown.
-     * @throws ItemStateException if <code>state</code> is a new item state.
+     * {@inheritDoc}
+     * @see UpdatableItemStateManager#execute(Operation)
-    private ChangeLog getChangeLog(ItemState itemState, boolean throwOnStale) throws StaleItemStateException, ItemStateException, ConstraintViolationException {
-        // build changelog for affected and decendant states only
-        ChangeLog changeLog = new ChangeLog(itemState);
-        // fail-fast test: check status of this item's state
-        if (itemState.getStatus() == Status.NEW) {
-            String msg = "Cannot save an item with status NEW (" +itemState+ ").";
-            log.debug(msg);
-            throw new ItemStateException(msg);
-        }
-        if (throwOnStale && Status.isStale(itemState.getStatus())) {
-            String msg =  "Attempt to save an item, that has been externally modified (" +itemState+ ").";
-            log.debug(msg);
-            throw new StaleItemStateException(msg);
-        }
-        // collect transient/stale states that should be persisted or reverted
-        itemState.collectStates(changeLog, throwOnStale);
-
-        changeLog.collectOperations(transientStateMgr.getOperations());
-        changeLog.checkIsSelfContained();
-        return changeLog;
+    public void execute(Operation operation) throws RepositoryException {
+        operation.accept(this);
-    //--------------------------------------------------------------------------
+    /**
+     * {@inheritDoc}
+     * @see UpdatableItemStateManager#execute(ChangeLog)
+     */
+    public void execute(ChangeLog changes) throws RepositoryException {
+        throw new UnsupportedOperationException("Not implemented for SessionItemStateManager");
+    }
+     * {@inheritDoc}
+     * @see UpdatableItemStateManager#dispose()
+     */
+    public void dispose() {
+        // discard all transient changes
+        transientStateMgr.dispose();
+        // dispose our (i.e. 'local') state manager
+        workspaceItemStateMgr.dispose();
+    }
+
+    //---------------------------------------------------< OperationVisitor >---
+    /**
+     * @see OperationVisitor#visit(AddNode)
+     * @see OperationVisitor#visit(AddProperty)
-        QPropertyDefinition pDef = validator.getApplicablePropertyDefinition(propertyName, operation.getPropertyType(), operation.isMultiValued(), parent);
+        QPropertyDefinition pDef = operation.getDefinition();
+     * @see OperationVisitor#visit(Move)
+     * @see OperationVisitor#visit(Remove)
-        // remember operation unless new state got removed
+        // unless new state got removed remember operation and mark parent modified.
+            operation.getParentState().markModified();
+     * @see OperationVisitor#visit(SetMixin)
+        NodeEntry nEntry = (NodeEntry) nState.getHierarchyEntry();
-        // new array of mixinNames to be set on the nodestate (and corresponding property state)
-        if (mixinNames != null && mixinNames.length > 0) {
-            // update/create corresponding property state
-            if (nState.hasPropertyName(QName.JCR_MIXINTYPES)) {
-                // execute value of existing property
-                try {
-                    PropertyState pState = nState.getPropertyState(QName.JCR_MIXINTYPES);
+        try {
+            // new array of mixinNames to be set on the nodestate (and corresponding property state)
+            PropertyEntry mixinEntry = nEntry.getPropertyEntry(QName.JCR_MIXINTYPES);
+            if (mixinNames != null && mixinNames.length > 0) {
+                // update/create corresponding property state
+                if (mixinEntry != null) {
+                    // execute value of existing property
+                    PropertyState pState = mixinEntry.getPropertyState();
-                } catch (ItemStateException e) {
-                    // should not occur, since existance has been asserted before
-                    throw new RepositoryException(e);
+                } else {
+                    // create new jcr:mixinTypes property
+                    EffectiveNodeType ent = validator.getEffectiveNodeType(nState);
+                    QPropertyDefinition pd = ent.getApplicablePropertyDefinition(QName.JCR_MIXINTYPES, PropertyType.NAME, true);
+                    QValue[] mixinValue = getQValues(mixinNames, qValueFactory);
+                    int options = ItemStateValidator.CHECK_LOCK | ItemStateValidator.CHECK_VERSIONING;
+                    addPropertyState(nState, pd.getQName(), pd.getRequiredType(), mixinValue, pd, options);
+                nState.markModified();
+                transientStateMgr.addOperation(operation);
-                // create new jcr:mixinTypes property
-                EffectiveNodeType ent = validator.getEffectiveNodeType(nState);
-                QPropertyDefinition pd = ent.getApplicablePropertyDefinition(QName.JCR_MIXINTYPES, PropertyType.NAME, true);
-                QValue[] mixinValue = getQValues(mixinNames, qValueFactory);
-                int options = ItemStateValidator.CHECK_LOCK | ItemStateValidator.CHECK_VERSIONING;
-                addPropertyState(nState, pd.getQName(), pd.getRequiredType(), mixinValue, pd, options);
-            }
-        } else {
-            // remove the jcr:mixinTypes property state if already present
-            if (nState.hasPropertyName(QName.JCR_MIXINTYPES)) {
-                try {
-                    PropertyState pState = nState.getPropertyState(QName.JCR_MIXINTYPES);
+                // remove the jcr:mixinTypes property state if already present
+                if (mixinEntry != null) {
+                    PropertyState pState = mixinEntry.getPropertyState();
+                    boolean newMixinState = pState.getStatus() == Status.NEW;
-                } catch (ItemStateException e) {
-                    // should not occur, since existance has been asserted before
-                    throw new RepositoryException(e);
+                    // only added the remove-mixin operation if it doesn't revert
+                    // a previous 'add-mixin' (which has been removed automatically
+                    // upon notification of removing the prop-state).
+                    if (!newMixinState) {
+                        nState.markModified();
+                        transientStateMgr.addOperation(operation);
+                    }
+        } catch (ItemStateException e) {
+            // should not occur, since existance has been asserted before
+            throw new RepositoryException(e);
-
-        nState.markModified();
-        transientStateMgr.addOperation(operation);
+     * @see OperationVisitor#visit(SetPropertyValue)
+     * @see OperationVisitor#visit(ReorderNodes)
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(Clone)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(Clone)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(Clone)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(Clone)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(Update)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(Restore)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(Merge)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(ResolveMergeConflict)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(LockOperation)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(LockRefresh)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(LockRelease)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(AddLabel)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(RemoveLabel)
+     */
+    /**
+     * @throws UnsupportedOperationException
+     * @see OperationVisitor#visit(RemoveVersion)
+     */
+     * @param itemState
+     * @param throwOnStale Throws StaleItemStateException if either the given
+     * <code>ItemState</code> or any of its decendants is stale and the flag is true.
+     * @return
+     * @throws StaleItemStateException if a stale <code>ItemState</code> is
+     * encountered while traversing the state hierarchy. The <code>changeLog</code>
+     * might have been populated with some transient item states. A client should
+     * therefore not reuse the <code>changeLog</code> if such an exception is thrown.
+     * @throws ItemStateException if <code>state</code> is a new item state.
+     */
+    private ChangeLog getChangeLog(ItemState itemState, boolean throwOnStale) throws StaleItemStateException, ItemStateException, ConstraintViolationException {
+        // build changelog for affected and decendant states only
+        ChangeLog changeLog = new ChangeLog(itemState);
+        // fail-fast test: check status of this item's state
+        if (itemState.getStatus() == Status.NEW) {
+            String msg = "Cannot save an item with status NEW (" +itemState+ ").";
+            log.debug(msg);
+            throw new ItemStateException(msg);
+        }
+        if (throwOnStale && Status.isStale(itemState.getStatus())) {
+            String msg =  "Attempt to save an item, that has been externally modified (" +itemState+ ").";
+            log.debug(msg);
+            throw new StaleItemStateException(msg);
+        }
+        // collect transient/stale states that should be persisted or reverted
+        itemState.getHierarchyEntry().collectStates(changeLog, throwOnStale);
+
+        changeLog.collectOperations(transientStateMgr.getOperations());
+        changeLog.checkIsSelfContained();
+        return changeLog;
+    }
+
+    /**
+     *
-            itemState.remove();
+            itemState.getHierarchyEntry().transientRemove();

MOV26 MOV26 MOV31 MOV31 MOV31 MOV31 UPD40 UPD40 MOV44 INS29 MOV29 INS29 INS29 INS29 INS29 INS29 INS29 INS29 INS29 INS29 INS29 INS29 INS29 INS29 INS29 UPD43 UPD42 INS21 MOV65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS60 INS54 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 UPD42 INS32 UPD66 UPD66 UPD66 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS68 INS43 INS59 INS8 MOV12 INS68 INS68 INS42 INS68 INS42 INS68 INS42 INS68 INS42 INS68 INS42 INS68 INS42 INS68 INS42 INS68 INS42 INS68 INS42 INS68 INS42 INS68 INS42 INS68 INS42 INS68 INS42 INS68 INS42 INS68 INS42 INS42 INS42 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS21 INS42 INS42 INS69 INS42 INS42 INS11 INS60 MOV25 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS69 INS32 INS43 INS43 INS43 INS43 MOV42 UPD42 MOV42 INS43 INS43 INS32 INS43 INS43 INS32 INS43 INS59 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 MOV42 UPD42 MOV42 INS42 INS42 INS32 MOV21 MOV21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 UPD42 INS42 INS42 INS42 UPD42 MOV42 INS40 INS27 MOV8 INS27 MOV42 INS42 INS32 INS42 INS33 INS42 INS42 INS42 INS42 INS33 MOV60 INS60 MOV60 MOV21 INS25 MOV42 INS42 MOV43 MOV43 INS39 INS59 INS38 INS8 INS42 INS27 INS42 INS21 INS21 UPD42 UPD42 INS32 INS40 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL42 DEL42 DEL65 DEL65 DEL42 DEL42 DEL68 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL65 DEL65 DEL42 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL41 DEL8 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL53 DEL8 DEL25 DEL8 DEL31 DEL65 DEL65 DEL42 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL9 DEL41 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL8 DEL25 DEL9 DEL41 DEL8 DEL31 DEL65 DEL66 DEL66 DEL65 DEL42 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL42 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL33 DEL27 DEL40 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL41 DEL8 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL24 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL8 DEL31 DEL65 DEL66 DEL66 DEL65 DEL42 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL42 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL32 DEL38 DEL41 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL9 DEL41 DEL8 DEL12 DEL54 DEL8 DEL31 DEL66 DEL29 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL40 DEL42 DEL42 DEL40 DEL32 DEL54 DEL8 DEL42 DEL42 DEL40 DEL32 DEL40 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54
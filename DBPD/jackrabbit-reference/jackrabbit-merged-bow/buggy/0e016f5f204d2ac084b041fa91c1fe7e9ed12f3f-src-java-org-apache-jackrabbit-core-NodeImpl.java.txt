fixed bug in Node.removeMixin(): mix:referenceable could be indirectly removed even if there existed references to the target node

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@155627 13f79535-47bb-0310-9956-ffa450edef68

-        if (MIX_REFERENCEABLE.equals(mixinName)) {
-            /**
-             * mix:referenceable needs special handling because it has
-             * special semantics:
-             * it can only be removed if there no more references to this node
-             */
-            PropertyIterator iter = getReferences();
-            if (iter.hasNext()) {
-                throw new ConstraintViolationException(mixinName + " can not be removed: the node is being referenced through at least one property of type REFERENCE");
-            }
-        }
-
-        // modify the state of this node
-        NodeState thisState = (NodeState) getOrCreateTransientItemState();
-        // remove mixin name
-        Set mixins = new HashSet(thisState.getMixinTypeNames());
-        mixins.remove(mixinName);
-        thisState.setMixinTypeNames(mixins);
-
-        // set jcr:mixinTypes property
-        setMixinTypesProperty(mixins);
-
-        // build effective node type of remaining mixin's & primary type
+
+        // build effective node type of remaining mixin's & primary type
+        Set remainingMixins = new HashSet(((NodeState) state).getMixinTypeNames());
+        // remove name of target mixin
+        remainingMixins.remove(mixinName);
-            HashSet set = new HashSet(mixins);
+            HashSet set = new HashSet(remainingMixins);
-        NodeTypeImpl mixin = session.getNodeTypeManager().getNodeType(mixinName);
+        /**
+         * mix:referenceable needs special handling because it has
+         * special semantics:
+         * it can only be removed if there no more references to this node
+         */
+        NodeTypeImpl mixin = ntMgr.getNodeType(mixinName);
+        if ((MIX_REFERENCEABLE.equals(mixinName) ||
+                mixin.isDerivedFrom(MIX_REFERENCEABLE)) &&
+                !entRemaining.includesNodeType(MIX_REFERENCEABLE)) {
+            // removing this mixin would effectively remove mix:referenceable:
+            // make sure no references exist
+            PropertyIterator iter = getReferences();
+            if (iter.hasNext()) {
+                throw new ConstraintViolationException(mixinName + " can not be removed: the node is being referenced through at least one property of type REFERENCE");
+            }
+        }
+
+        // modify the state of this node
+        NodeState thisState = (NodeState) getOrCreateTransientItemState();
+        thisState.setMixinTypeNames(remainingMixins);
+
+        // set jcr:mixinTypes property
+        setMixinTypesProperty(remainingMixins);

MOV25 MOV60 MOV60 MOV21 MOV21 INS60 INS21 MOV43 INS59 INS27 INS32 UPD42 UPD42 INS42 INS32 INS36 INS38 INS42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 MOV43 MOV43 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS27 INS32 INS36 MOV32 INS32 INS42 INS42 INS42 INS11 MOV43 UPD42 INS42 INS42 INS42 INS43 INS42 INS42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60
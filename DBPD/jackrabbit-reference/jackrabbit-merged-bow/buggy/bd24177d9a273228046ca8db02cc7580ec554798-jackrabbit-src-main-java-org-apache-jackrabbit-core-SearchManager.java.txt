JCR-257: Use separate index for jcr:system tree
- shut down unused query handler when it had been idle for some configurable time

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@358016 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Timer;
+import java.util.TimerTask;
+import java.util.Properties;
+import java.util.WeakHashMap;
+import java.util.Map;
+import java.util.Collections;
+     * Name of the parameter that specifies the idle time for a query handler.
+     */
+    private static final String PARAM_IDLE_TIME = "idleTime";
+
+    /**
+     * Class instance that is shared for all <code>SearchManager</code> instances.
+     * Each workspace will schedule a task to check if the query handler can
+     * be shutdown after it had been idle for some time.
+     */
+    private static final Timer IDLE_TIMER = new Timer(true);
+
+    /**
+     * Idle time in seconds after which the query handler is shut down.
+     */
+    private static final int DEFAULT_IDLE_TIME = -1;
+
+    /**
+     * The time when the query handler was last accessed.
+     */
+    private long lastAccess = System.currentTimeMillis();
+
+    /**
+     * The search configuration.
+     */
+    private final SearchConfig config;
+
+    /**
+     * The node type registry.
+     */
+    private final NodeTypeRegistry ntReg;
+
+    /**
+     * The root node for this search manager.
+     */
+    private final String rootNodeUUID;
+
+    /**
-    private final QueryHandler handler;
+    private QueryHandler handler;
+
+    /**
+     * QueryHandler of the parent search manager or <code>null</code> if there
+     * is none.
+     */
+    private final QueryHandler parentHandler;
+     * UUID of the node that should be excluded from indexing or <code>null</code>
+     * if no node should be excluded.
+     */
+    private final String excludedNodeUUID;
+
+    /**
+     * Task that checks if the query handler can be shut down because it
+     * had been idle for {@link #idleTime} seconds.
+     */
+    private final TimerTask idleChecker;
+
+    /**
+     * Idle time in seconds. After the query handler had been idle for this
+     * amount of time it is shut down. Defaults to -1 and causes the search
+     * manager to never shut down.
+     */
+    private int idleTime;
+
+    /**
+     * Weakly references all {@link javax.jcr.query.Query} instances created
+     * by this <code>SearchManager</code>.
+     * If this map is empty and this search manager had been idle for at least
+     * {@link #idleTime} seconds, then the query handler is shut down.
+     */
+    private final Map activeQueries = Collections.synchronizedMap(new WeakHashMap() {
+
+    });
+
+    /**
-     * @param config           the search configuration.
+     * @param config the search configuration.
-     * @param ntReg            the node type registry.
-     * @param itemMgr          the shared item state manager.
+     * @param ntReg the node type registry.
+     * @param itemMgr the shared item state manager.
+        this.config = config;
+        this.ntReg = ntReg;
+        this.rootNodeUUID = rootNodeUUID;
+        this.parentHandler = (parentMgr != null) ? parentMgr.handler : null;
+        this.excludedNodeUUID = excludedNodeUUID;
-        queryImplClassName = config.getParameters().getProperty(PARAM_QUERY_IMPL, DEFAULT_QUERY_IMPL_CLASS);
-
-        QueryHandler parentHandler = null;
-        if (parentMgr != null) {
-            parentHandler = parentMgr.handler;
+        Properties params = config.getParameters();
+        queryImplClassName = params.getProperty(PARAM_QUERY_IMPL, DEFAULT_QUERY_IMPL_CLASS);
+        String idleTimeString = params.getProperty(PARAM_IDLE_TIME, String.valueOf(DEFAULT_IDLE_TIME));
+        try {
+            idleTime = Integer.decode(idleTimeString).intValue();
+        } catch (NumberFormatException e) {
+            idleTime = DEFAULT_IDLE_TIME;
-        try {
-            handler = (QueryHandler) config.newInstance();
-            QueryHandlerContext context
-                    = new QueryHandlerContext(fs, itemMgr, rootNodeUUID, ntReg,
-                            parentHandler, excludedNodeUUID);
-            handler.init(context);
-        } catch (Exception e) {
-            throw new RepositoryException(e.getMessage(), e);
+        initializeQueryHandler();
+
+        idleChecker = new TimerTask() {
+            public void run() {
+                if (lastAccess + (idleTime * 1000) < System.currentTimeMillis()) {
+                    int inUse = activeQueries.size();
+                    if (inUse == 0) {
+                        try {
+                            shutdownQueryHandler();
+                        } catch (IOException e) {
+                            log.warn("Unable to shutdown idle query handler", e);
+                        }
+                    } else {
+                        log.debug("SearchManager is idle but " + inUse +
+                                " queries are still in use.");
+                    }
+                }
+            }
+        };
+
+        if (idleTime > -1) {
+            IDLE_TIMER.schedule(idleChecker, 0, 1000);
-            handler.close();
+            idleChecker.cancel();
+            shutdownQueryHandler();
+
+        ensureInitialized();
+        ensureInitialized();
-        try {
-            handler.updateNodes(removedNodes.iterator(), addedStates);
-        } catch (RepositoryException e) {
-            log.error("Error indexing node.", e);
-        } catch (IOException e) {
-            log.error("Error indexing node.", e);
+        if (removedNodes.size() > 0 || addedNodes.size() > 0) {
+            try {
+                ensureInitialized();
+                handler.updateNodes(removedNodes.iterator(), addedStates);
+            } catch (RepositoryException e) {
+                log.error("Error indexing node.", e);
+            } catch (IOException e) {
+                log.error("Error indexing node.", e);
+            }
+                // track query instances
+                activeQueries.put(obj, null);
+
+    //------------------------< internal >--------------------------------------
+
+    /**
+     * Initializes the query handler.
+     *
+     * @throws RepositoryException if the query handler cannot be initialized.
+     */
+    private void initializeQueryHandler() throws RepositoryException {
+        // initialize query handler
+        try {
+            handler = (QueryHandler) config.newInstance();
+            QueryHandlerContext context
+                    = new QueryHandlerContext(fs, itemMgr, rootNodeUUID,
+                            ntReg, parentHandler, excludedNodeUUID);
+            handler.init(context);
+        } catch (Exception e) {
+            throw new RepositoryException(e.getMessage(), e);
+        }
+    }
+
+    /**
+     * Shuts down the query handler. If the query handler is already shut down
+     * this method does nothing.
+     *
+     * @throws IOException if an error occurs while shutting down the query
+     *                     handler.
+     */
+    private synchronized void shutdownQueryHandler() throws IOException {
+        if (handler != null) {
+            handler.close();
+            handler = null;
+        }
+    }
+
+    /**
+     * Ensures that the query handler is initialized and updates the last
+     * access to the current time.
+     *
+     * @throws RepositoryException if the query handler cannot be initialized.
+     */
+    private synchronized void ensureInitialized() throws RepositoryException {
+        lastAccess = System.currentTimeMillis();
+        if (handler == null) {
+            initializeQueryHandler();
+        }
+    }

INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS29 INS83 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS83 INS39 INS59 INS29 INS83 INS39 INS59 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 MOV43 INS59 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS39 INS59 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS39 INS42 INS43 INS8 INS29 INS83 INS83 INS39 INS42 INS43 INS8 INS29 INS83 INS83 INS39 INS42 INS43 INS8 INS65 INS42 INS42 INS45 INS65 INS42 INS42 INS14 INS65 INS42 INS38 INS65 INS42 INS32 INS65 INS42 INS42 INS65 INS42 INS42 INS65 INS42 INS42 INS65 INS42 INS65 INS42 INS42 INS65 INS42 INS42 INS65 INS42 INS65 INS42 INS42 INS32 INS21 INS21 INS21 INS21 INS21 INS60 INS54 INS21 INS21 INS25 INS21 INS21 INS25 INS65 INS65 INS42 MOV54 INS65 INS65 INS42 INS25 INS65 INS65 INS42 INS21 INS25 INS66 INS66 INS66 INS66 INS43 INS9 INS66 INS34 INS66 INS42 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS42 INS42 INS14 UPD66 UPD66 UPD66 INS7 INS7 INS7 INS7 INS7 INS43 INS59 INS43 INS8 INS12 INS32 INS7 INS27 INS8 INS32 INS32 INS27 INS8 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS66 INS27 INS8 INS66 INS66 INS42 INS66 INS7 INS27 INS8 INS42 INS67 INS40 INS67 INS43 INS1 INS22 INS42 INS22 INS42 INS22 INS42 INS22 INS16 INS22 INS42 INS42 INS42 MOV32 INS42 INS42 INS32 MOV21 INS44 INS8 INS42 INS42 INS14 INS42 INS38 INS21 INS21 INS21 INS42 INS42 INS27 INS27 MOV54 INS42 INS33 MOV21 INS21 INS42 INS32 INS42 INS33 INS21 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS36 INS40 INS33 INS52 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS42 INS21 INS43 INS1 INS34 INS32 INS32 INS32 INS32 INS34 INS32 INS34 INS7 INS42 INS42 INS32 MOV27 INS42 INS42 INS42 INS42 INS32 INS42 INS7 INS42 INS31 INS42 INS42 INS42 INS34 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS21 INS42 INS33 INS42 INS32 INS42 INS42 INS42 INS83 INS39 INS42 INS8 INS32 INS32 INS42 INS42 INS42 INS25 INS42 INS42 INS42 INS42 INS33 INS27 INS8 INS27 INS32 INS60 INS25 INS42 INS36 INS42 INS42 INS39 INS59 INS27 INS8 INS8 INS27 INS42 INS32 INS42 INS34 INS54 INS21 INS42 INS34 INS42 INS42 INS8 INS12 INS32 INS21 INS44 INS8 INS42 INS42 INS27 INS32 INS43 INS42 INS21 INS45 INS42 INS45 INS42 INS42 INS32 INS42 INS42 INS45 INS42 DEL83 DEL42 DEL33 DEL42 DEL40 DEL8 DEL25
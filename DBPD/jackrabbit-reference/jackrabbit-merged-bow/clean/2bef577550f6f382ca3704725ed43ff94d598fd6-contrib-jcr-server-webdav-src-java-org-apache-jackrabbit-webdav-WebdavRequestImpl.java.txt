JCR-258 - remove JDOM dependency from jcr-server contribution
JCR-295 - usage of Cache-Control header 
JCR-297 - log output while parsing xml
minor consistency issues and improvements

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@368683 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.webdav.header.LabelHeader;
+import org.apache.jackrabbit.webdav.header.OverwriteHeader;
+import org.apache.jackrabbit.webdav.header.TimeoutHeader;
+import org.apache.jackrabbit.webdav.property.DavProperty;
-import org.apache.jackrabbit.webdav.property.DavProperty;
-import org.apache.jackrabbit.webdav.version.DeltaVConstants;
-import org.apache.jackrabbit.util.Text;
+import org.apache.jackrabbit.webdav.xml.DomUtil;
+import org.apache.jackrabbit.webdav.xml.ElementIterator;
-import org.jdom.Document;
-import org.jdom.Element;
-import org.jdom.JDOMException;
-import org.jdom.input.SAXBuilder;
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.xml.sax.SAXException;
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
-import java.util.List;
+    private static final DocumentBuilderFactory BUILDER_FACTORY = DocumentBuilderFactory.newInstance();
-        boolean doOverwrite = true;
-        String overwriteHeader = httpRequest.getHeader(HEADER_OVERWRITE);
-        if (overwriteHeader != null && !overwriteHeader.equalsIgnoreCase(NO_OVERWRITE)) {
-            doOverwrite = false;
-        }
-        return doOverwrite;
+        return new OverwriteHeader(httpRequest).isOverwrite();
-     * Parse the request timeout header and convert the timeout value
-     * into a long indicating the number of milliseconds until expiration time
-     * is reached.<br>
-     * NOTE: If the requested timeout is 'infinite' {@link Long.MAX_VALUE}
-     * is returned.
+     * Parse the Timeout header and return a long representing the value.
+     * {@link #UNDEFINED_TIMEOUT} is used as default value if no header
+     * is available or if the parsing fails.
-     * @return milliseconds the lock is requested to live.
+     * @return milliseconds indicating length of the timeout.
+     * @see TimeoutHeader#parse(javax.servlet.http.HttpServletRequest, long)
-        String timeoutStr = httpRequest.getHeader(HEADER_TIMEOUT);
-        long timeout = UNDEFINED_TIMEOUT;
-        if (timeoutStr != null && timeoutStr.length() > 0) {
-            int secondsInd = timeoutStr.indexOf("Second-");
-            if (secondsInd >= 0) {
-                secondsInd += 7; // read over "Second-"
-                int i = secondsInd;
-                while (i < timeoutStr.length() && Character.isDigit(timeoutStr.charAt(i))) {
-                    i++;
-                }
-                try {
-                    timeout = 1000L * Long.parseLong(timeoutStr.substring(secondsInd, i));
-                } catch (NumberFormatException ignore) {
-                    // ignore an let the lock define the default timeout
-                    log.error("Invalid timeout format: " + timeoutStr);
-                }
-            } else if (timeoutStr.equalsIgnoreCase(TIMEOUT_INFINITE)) {
-                timeout = INFINITE_TIMEOUT;
-            }
-        }
-        return timeout;
+        return TimeoutHeader.parse(httpRequest, UNDEFINED_TIMEOUT).getTimeout();
+        /*
+        Don't attempt to parse the body if the contentlength header is 0
+        NOTE: a value of -1 indicates that the length is unknown, thus we have to parse the body.
+        NOTE that http1.1 request using chunked transfer coding will therefore not be detected here
+        */
+        if (httpRequest.getContentLength() == 0) {
+            return requestDocument;
+        }
-                    SAXBuilder builder = new SAXBuilder(false);
-                    requestDocument = builder.build(in);
+                BUILDER_FACTORY.setNamespaceAware(true);
+                DocumentBuilder docBuilder = BUILDER_FACTORY.newDocumentBuilder();
+                requestDocument = docBuilder.parse(in);
-            } catch (JDOMException e) {
+        } catch (ParserConfigurationException e) {
+        } catch (SAXException e) {
+            log.debug("Unable to build an XML Document from the request body: " + e.getMessage());
-    public int getPropFindType() {
+    public int getPropFindType() throws DavException {
-    public DavPropertyNameSet getPropFindProperties() {
+    public DavPropertyNameSet getPropFindProperties() throws DavException {
-    private void parsePropFindRequest() {
-
+    private void parsePropFindRequest() throws DavException {
-
-        // TODO: spec requires a 'BAD REQUEST' error code
+        // TODO: invalid XML -> spec requires a 'BAD REQUEST' error code
-        // propfind httpRequest with invalid body >> treat as if empty body
-        Element root = requestDocument.getRootElement();
-        if (!root.getName().equals(XML_PROPFIND)) {
+        // propfind httpRequest with invalid body
+        Element root = requestDocument.getDocumentElement();
+        if (!XML_PROPFIND.equals(root.getLocalName())) {
-            return;
+            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "PropFind-Request has no <profind> tag.");
-        List childList = root.getChildren();
-        for (int i = 0; i < childList.size(); i++) {
-            Element child = (Element) childList.get(i);
-            String nodeName = child.getName();
+        ElementIterator it = DomUtil.getChildren(root);
+        while (it.hasNext()) {
+            Element child = it.nextElement();
+            String nodeName = child.getLocalName();
-    public DavPropertySet getPropPatchSetProperties() {
+    public DavPropertySet getPropPatchSetProperties() throws DavException {
-    public DavPropertyNameSet getPropPatchRemoveProperties() {
+    public DavPropertyNameSet getPropPatchRemoveProperties() throws DavException {
-    private void parsePropPatchRequest() {
+    private void parsePropPatchRequest() throws DavException {
-            return;
+            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "Invalid request body.");
-        Element root = requestDocument.getRootElement();
-        if (!root.getName().equals(XML_PROPERTYUPDATE)) {
+        Element root = requestDocument.getDocumentElement();
+        if (!DomUtil.matches(root, XML_PROPERTYUPDATE, NAMESPACE)) {
-            return;
+            throw new DavException(DavServletResponse.SC_BAD_REQUEST, "PropPatch-Request has no <propertyupdate> tag.");
-        List setList = root.getChildren(XML_SET, NAMESPACE);
-        if (!setList.isEmpty()) {
-            Iterator setIter = setList.iterator();
-            while (setIter.hasNext()) {
-                Element propElem = ((Element) setIter.next()).getChild(XML_PROP, NAMESPACE);
-                Iterator it = propElem.getChildren().iterator();
+        ElementIterator it = DomUtil.getChildren(root, XML_SET, NAMESPACE);
-                    Element propertyElem = (Element) it.next();
-                    proppatchSet.add(DefaultDavProperty.createFromXml(propertyElem));
+            Element propEl = DomUtil.getChildElement(it.nextElement(), XML_PROP, NAMESPACE);
+            if (propEl != null) {
+                ElementIterator properties = DomUtil.getChildren(propEl);
+                while (properties.hasNext()) {
+                   proppatchSet.add(DefaultDavProperty.createFromXml(properties.nextElement()));
-        List removeList = root.getChildren(XML_REMOVE, NAMESPACE);
-        if (!removeList.isEmpty()) {
-            Iterator removeIter = removeList.iterator();
-            while (removeIter.hasNext()) {
-                Element propElem = ((Element) removeIter.next()).getChild(XML_PROP, NAMESPACE);
-                Iterator it = propElem.getChildren().iterator();
+        it = DomUtil.getChildren(root, XML_REMOVE, NAMESPACE);
-                    Element propertyElem = (Element) it.next();
-                    proppatchRemove.add(DavPropertyName.createFromXml(propertyElem));
+            Element propEl = DomUtil.getChildElement(it.nextElement(), XML_PROP, NAMESPACE);
+            if (propEl != null) {
+                ElementIterator names = DomUtil.getChildren(propEl);
+                while (names.hasNext()) {
+                    proppatchRemove.add(DavPropertyName.createFromXml(names.nextElement()));
-            Element root = requestDocument.getRootElement();
-            if (root.getName().equals(XML_LOCKINFO)) {
+            Element root = requestDocument.getDocumentElement();
+            if (root.getLocalName().equals(XML_LOCKINFO)) {
-                return new TransactionInfo(requestDocument.getRootElement());
+                return new TransactionInfo(requestDocument.getDocumentElement());
-            Element root = requestDocument.getRootElement();
-            if (ObservationConstants.XML_SUBSCRIPTIONINFO.equals(root.getName())) {
+            Element root = requestDocument.getDocumentElement();
+            if (ObservationConstants.XML_SUBSCRIPTIONINFO.equals(root.getLocalName())) {
-    public OrderPatch getOrderPatch() {
+    public OrderPatch getOrderPatch() throws DavException {
-            Element root = requestDocument.getRootElement();
-            if (!OrderingConstants.XML_ORDERPATCH.equals(root.getName()) ||
-                    root.getChild(OrderingConstants.XML_ORDERING_TYPE) == null) {
-                log.error("ORDERPATH request body must start with an 'orderpatch' element, which must contain an 'ordering-type' child element.");
-                return op;
-            }
-
+            Element root = requestDocument.getDocumentElement();
-                op = new OrderPatch(root);
+                op = OrderPatch.createFromXml(root);
+                throw new DavException(DavServletResponse.SC_BAD_REQUEST);
-        String label = getHeader(DeltaVConstants.HEADER_LABEL);
+        LabelHeader label = LabelHeader.parse(this);
-            label = Text.unescape(label);
+            return label.getLabel();
-        return label;
+        return null;
-            Element root = requestDocument.getRootElement();
+            Element root = requestDocument.getDocumentElement();
-                mInfo = new MergeInfo(requestDocument.getRootElement());
+                mInfo = new MergeInfo(requestDocument.getDocumentElement());
-                uInfo = new UpdateInfo(requestDocument.getRootElement());
+                uInfo = new UpdateInfo(requestDocument.getDocumentElement());
-            rInfo = new ReportInfo(requestDocument.getRootElement(), getDepth(DEPTH_0));
+            rInfo = new ReportInfo(requestDocument.getDocumentElement(), getDepth(DEPTH_0));
-            info = new OptionsInfo(requestDocument.getRootElement());
+            info = OptionsInfo.createFromXml(requestDocument.getDocumentElement());

MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 UPD40 INS40 INS40 UPD40 INS40 UPD40 UPD40 UPD40 UPD40 UPD40 INS40 INS23 INS31 INS31 INS31 INS31 INS83 INS83 INS83 INS43 INS59 MOV29 INS83 INS39 INS42 INS8 INS43 INS43 INS43 INS43 INS43 INS43 MOV29 MOV83 MOV43 MOV42 INS43 INS8 MOV29 INS83 MOV43 INS42 INS8 MOV29 INS83 MOV43 INS42 INS8 MOV29 MOV43 UPD42 UPD42 MOV42 UPD42 MOV42 MOV32 INS41 INS65 INS41 INS25 INS42 INS42 INS42 INS61 INS42 INS42 INS42 MOV61 INS21 MOV61 UPD42 MOV42 MOV60 MOV60 INS25 MOV41 INS60 INS25 INS41 MOV60 MOV60 MOV25 MOV41 MOV60 INS60 INS41 UPD42 UPD42 INS32 UPD66 INS66 UPD66 UPD66 INS68 INS32 INS27 INS8 INS12 MOV43 UPD43 INS32 MOV8 MOV43 UPD43 MOV32 INS7 MOV32 MOV27 INS8 MOV8 INS43 INS59 MOV27 INS8 INS33 MOV27 MOV43 INS59 MOV42 MOV27 INS14 UPD42 MOV42 INS67 INS42 INS42 INS69 INS69 INS32 INS42 INS32 INS34 INS41 INS44 INS8 INS53 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 INS53 INS53 UPD42 UPD42 INS25 INS42 INS32 INS25 MOV60 MOV54 INS42 INS42 INS32 MOV41 INS42 INS32 INS43 INS42 INS42 INS43 INS39 INS42 INS42 MOV42 INS42 INS42 INS42 INS42 UPD43 INS43 INS42 INS21 UPD42 INS42 INS42 INS14 UPD42 INS42 MOV43 INS14 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 INS42 INS14 UPD42 INS42 MOV43 INS27 INS8 UPD42 MOV42 MOV42 INS42 MOV42 MOV42 MOV43 INS27 INS8 MOV43 MOV43 MOV43 INS42 INS42 INS52 INS32 MOV43 INS42 INS42 INS40 INS21 UPD42 INS42 INS32 UPD42 INS43 INS40 INS45 INS32 INS43 INS40 INS45 INS43 INS40 INS45 UPD42 INS42 INS33 MOV60 MOV61 UPD42 INS42 INS33 MOV60 MOV61 UPD42 INS42 INS42 INS32 INS32 UPD43 INS42 INS42 INS27 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 INS42 INS42 INS42 INS42 INS32 UPD43 INS32 INS8 INS42 INS42 INS32 UPD43 INS32 INS8 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS53 UPD42 INS42 INS42 INS32 INS42 INS42 INS9 UPD42 UPD42 INS32 INS45 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 MOV21 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 MOV21 UPD42 INS32 INS14 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 UPD42 INS42 INS42 UPD42 MOV42 MOV42 UPD42 UPD42 MOV42 MOV42 UPD42 UPD42 INS42 UPD42 MOV42 UPD42 MOV42 INS43 INS40 UPD43 INS32 UPD43 INS42 UPD42 INS42 INS42 MOV42 UPD42 INS32 INS32 UPD42 MOV42 INS42 INS42 UPD42 MOV42 DEL42 DEL83 DEL39 DEL42 DEL39 DEL42 DEL9 DEL59 DEL60 DEL43 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL38 DEL27 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL40 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL34 DEL27 DEL27 DEL39 DEL42 DEL42 DEL42 DEL45 DEL32 DEL59 DEL60 DEL42 DEL34 DEL27 DEL42 DEL34 DEL7 DEL21 DEL39 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL27 DEL42 DEL37 DEL21 DEL8 DEL61 DEL42 DEL34 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL27 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL25 DEL8 DEL25 DEL42 DEL41 DEL42 DEL43 DEL9 DEL14 DEL42 DEL42 DEL41 DEL42 DEL32 DEL11 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL32 DEL27 DEL42 DEL37 DEL24 DEL41 DEL32 DEL41 DEL42 DEL42 DEL32 DEL42 DEL43 DEL32 DEL11 DEL36 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL32 DEL11 DEL59 DEL60 DEL8 DEL42 DEL42 DEL32 DEL42 DEL43 DEL32 DEL11 DEL36 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL32 DEL11 DEL59 DEL60 DEL8 DEL42 DEL42 DEL32 DEL38 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL25 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL38 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL25 DEL32 DEL14 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL42 DEL40 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL40 DEL42 DEL42 DEL42 DEL32 DEL32 DEL38 DEL42 DEL42 DEL40 DEL32 DEL33 DEL27 DEL27 DEL42 DEL42 DEL45 DEL32 DEL21 DEL42 DEL41 DEL8 DEL25 DEL42 DEL83 DEL42 DEL8 DEL25 DEL8 DEL31 DEL42 DEL43 DEL32 DEL14
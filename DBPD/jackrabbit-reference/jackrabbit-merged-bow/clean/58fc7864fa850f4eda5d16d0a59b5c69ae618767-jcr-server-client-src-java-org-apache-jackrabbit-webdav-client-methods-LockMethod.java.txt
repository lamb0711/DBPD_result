- add methods for observation to client
- minor improvements to observation impl in jcr-server
- fix client LockMethod and adjust LockDiscovery accordingly
- fix client MergeMethod adjust corresponding Info object accordingly
- improve UpdateInfo
- use CodedURLHeader instaed of building locktoken header manually

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@421206 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.webdav.header.CodedUrlHeader;
+import org.apache.jackrabbit.webdav.DavException;
+import org.apache.jackrabbit.webdav.xml.DomUtil;
-import org.apache.jackrabbit.webdav.lock.ActiveLock;
+import org.apache.jackrabbit.webdav.header.CodedUrlHeader;
+import org.apache.jackrabbit.webdav.lock.LockDiscovery;
+import org.apache.commons.httpclient.HttpMethodBase;
+import org.apache.commons.httpclient.HttpState;
+import org.apache.commons.httpclient.HttpConnection;
+import org.apache.commons.httpclient.Header;
+import org.w3c.dom.Element;
+    private final boolean isRefresh;
+    private LockDiscovery lockDiscovery;
+
-        if (lockInfo != null) {
+        if (lockInfo != null && !lockInfo.isRefreshLock()) {
-            if (!lockInfo.isRefreshLock()) {
-                DepthHeader dh = new DepthHeader(lockInfo.isDeep());
-                setRequestHeader(dh);
-                setRequestHeader(DavConstants.HEADER_CONTENT_TYPE, "text/xml; charset=UTF-8");
-                setRequestBody(lockInfo);
-            }
+            DepthHeader dh = new DepthHeader(lockInfo.isDeep());
+            setRequestHeader(dh);
+            setRequestHeader(DavConstants.HEADER_CONTENT_TYPE, "text/xml; charset=UTF-8");
+            setRequestBody(lockInfo);
+            isRefresh = false;
+        } else {
+            throw new IllegalArgumentException("Cannot create a LOCK request without lock info. Use the constructor taking lock tokens in order to build a LOCK request for refresh.");
-     * Create a new 'Refresh' lock method.
+     * Create a new Lock method used to 'REFRESH' an existing lock.
+        isRefresh = true;
-    public ActiveLock getResponseAsLock() throws IOException {
+    /**
+     *
+     * @return
+     * @throws IOException
+     * @throws DavException
+     */
+    public LockDiscovery getResponseAsLockDiscovery() throws IOException, DavException {
-        // todo -> build lockdiscovery-prop -> retrieve activelock
-        return null;
+        // lockDiscovery has been build while processing the response body.
+        // if its still null, this indicates that either the method failed
+        // or that the response body could not be parsed.
+        // in either case this is an error and will be reported to the caller.
+        if (lockDiscovery != null) {
+            return lockDiscovery;
+        } else {
+            DavException dx = getResponseException();
+            if (dx != null) {
+                throw dx;
+            } else {
+                throw new DavException(getStatusCode(), getName() + " resulted with unexpected status: " + getStatusLine());
+            }
+        }
+    /**
+     *
+     * @return
+     */
-        CodedUrlHeader cuh = new CodedUrlHeader(DavConstants.HEADER_LOCK_TOKEN, getResponseHeader(DavConstants.HEADER_LOCK_TOKEN).getValue());
-        return cuh.getCodedUrl();
+        Header ltHeader = getResponseHeader(DavConstants.HEADER_LOCK_TOKEN);
+        if (ltHeader != null) {
+            CodedUrlHeader cuh = new CodedUrlHeader(DavConstants.HEADER_LOCK_TOKEN, ltHeader.getValue());
+            return cuh.getCodedUrl();
+        } else {
+            // not Lock-Token header must be sent in response to a 'refresh'.
+            // see the validation performed while processing the response.
+            return null;
+        }
+    //----------------------------------------------------------< DavMethod >---
+    /**
+     * @return true, if the status code indicates success and if the response
+     * contains a Lock-Token header for a request used to create a new lock.
+     */
+    public boolean succeeded() {
+        checkUsed();
+        String lt = getLockToken();
+        boolean containsRequiredHeader = (isRefresh) ? lt == null : lt != null;
+        return getSuccess() && containsRequiredHeader;
+    }
+
+    //-----------------------------------------------------< HttpMethodBase >---
+    /**
+     * Retrieves the DAV:lockdiscovery property present in the response body
+     * and builds 'ActiveLock' objects from the corresponding DAV:activelock
+     * child elements inside the lock discovery. If parsing the response body
+     * fails for whatever reason or if the DAV:lockdiscovery did not contain
+     * at least a single DAV:activelock entry (the one created by the LOCK
+     * call) this methods in addition resets the 'success' flag to false.
+     *
+     * @param httpState
+     * @param httpConnection
+     * @see HttpMethodBase#processResponseBody(HttpState, HttpConnection)
+     */
+    protected void processResponseBody(HttpState httpState, HttpConnection httpConnection) {
+        // in case of successful response code -> parse xml body into lockDiscovery.
+        if (getSuccess()) {
+            try {
+                setSuccess(buildDiscoveryFromRoot(getRootElement()));
+            } catch (IOException e) {
+                log.error("Error while parsing multistatus response: " + e);
+                setSuccess(false);
+            }
+        }
+    }
+
+    //------------------------------------------------------------< private >---
+    /**
+     * Builds a new <code>LockDiscovery</code> object from the root XML
+     * present in the response body and returns true if the object could be
+     * created successfully.
+     *
+     * @param root
+     * @return if a <code>LockDiscovery</code> object could be created from the
+     * given XML, false otherwise.
+     */
+    private boolean buildDiscoveryFromRoot(Element root) {
+        if (DomUtil.matches(root, XML_PROP, NAMESPACE) && DomUtil.hasChildElement(root, PROPERTY_LOCKDISCOVERY, NAMESPACE)) {
+            Element lde = DomUtil.getChildElement(root, PROPERTY_LOCKDISCOVERY, NAMESPACE);
+            if (DomUtil.hasChildElement(lde, XML_ACTIVELOCK, NAMESPACE)) {
+                lockDiscovery = LockDiscovery.createFromXml(lde);
+                return true;
+            } else {
+                log.debug("The DAV:lockdiscovery must contain a least a single DAV:activelock in response to a successful LOCK request.");
+            }
+        } else {
+            log.debug("Missing DAV:prop response body in LOCK method.");
+        }
+        return false;
+    }

MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 UPD40 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS31 INS31 INS31 INS83 INS83 INS39 INS59 INS83 INS43 INS59 MOV8 INS29 UPD43 UPD42 INS43 INS8 INS29 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS42 INS42 INS42 MOV46 INS21 INS65 INS65 INS65 UPD42 INS42 MOV21 INS25 INS65 INS60 INS25 INS65 INS21 INS60 INS60 INS41 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS25 INS65 INS65 INS65 INS43 INS42 INS25 INS41 INS27 INS8 UPD66 INS7 INS42 INS42 INS27 INS8 INS8 INS43 INS59 INS27 INS8 MOV8 INS66 INS66 INS32 INS43 INS59 INS39 INS59 INS27 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS68 INS42 INS42 INS32 INS8 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS27 INS8 INS8 INS9 MOV27 MOV38 MOV60 MOV21 INS21 INS53 INS42 INS9 INS42 INS33 INS41 INS60 INS25 INS42 INS42 MOV32 INS42 INS33 MOV60 MOV41 INS42 INS42 INS42 INS32 INS42 INS16 INS32 INS42 INS42 INS42 INS69 INS69 INS42 INS54 INS32 INS32 INS60 INS25 INS21 INS7 INS14 INS42 INS43 INS59 INS27 INS8 INS8 MOV43 INS42 INS36 INS27 INS27 INS42 INS43 INS43 INS8 INS12 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS8 INS8 INS32 INS42 INS9 INS43 INS45 INS42 INS42 INS32 INS42 INS33 INS53 INS53 INS42 INS42 INS33 INS42 INS33 INS42 INS42 INS21 INS44 INS8 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS21 INS41 INS21 INS42 INS42 INS45 INS42 INS42 INS42 INS14 MOV43 INS32 INS43 INS42 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS7 INS9 INS32 INS43 INS32 INS27 INS42 INS42 INS32 INS42 INS32 INS32 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS32 INS45 INS32 INS42 INS32 INS42 INS42 INS27 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 DEL25 DEL8
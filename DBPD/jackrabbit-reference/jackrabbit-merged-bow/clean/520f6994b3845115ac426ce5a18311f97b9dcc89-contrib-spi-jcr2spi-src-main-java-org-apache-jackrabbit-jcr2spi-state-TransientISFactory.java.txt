work in progress.

- nodestates must always be connected to their cne upon creation
  TODO: add some sort of caching to avoid traffic overhead
- add TODO for refresh, that currently doesn't work properly
- ItemState.refresh only takes changelog and returns the ids of the
  processed states. cleanup of events is left to caller.
- move of NodeStates does not work
- PathResolver: force start to be an NodeState
- all MODIFIED status for SessionStates as well in order to make sure
  that listeners are informed about external changes even if the 
  state is EXISTING.

next TODO: make sure, that public getChildNodeEntry/ies and hasChildNodeEntry check for validity of the connected NodeState. don't return entries, where the nodestate is (transiently) removed or stale.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@472818 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.state.entry.ChildNodeEntry;
-    private final ItemStateManager parent;
+    private final ItemStateManager workspaceItemStateMgr;
-    TransientISFactory(IdFactory idFactory, ItemStateManager parent) {
+    TransientISFactory(IdFactory idFactory, ItemStateManager workspaceItemStateMgr) {
-        this.parent = parent;
+        this.workspaceItemStateMgr = workspaceItemStateMgr;
-        NodeState overlayedState = (NodeState) parent.getRootState();
+        NodeState overlayedState = (NodeState) workspaceItemStateMgr.getRootState();
-            NodeState overlayedState = (NodeState) parent.getItemState(nodeId);
+            NodeState overlayedState = (NodeState) workspaceItemStateMgr.getItemState(nodeId);
-            NodeState parentState = null;
-            if (overlayedParent != null) {
+            if (overlayedParent == null) {
+                // special case root state
+                return createRootState(ism);
+            }
+            
+            NodeState parentState = (NodeState) overlayedParent.getSessionState();
+            if (parentState == null) {
-            nodeState = new NodeState(overlayedState, parentState, Status.EXISTING, this, idFactory);
-            nodeState.addListener(cache);
-            cache.created(nodeState);
+            ChildNodeEntry cne = parentState.getChildNodeEntry(nodeId);
+            if (cne != null) {
+                nodeState = cne.getNodeState();
+                nodeState.addListener(cache);
+                cache.created(nodeState);
+            } else {
+                throw new NoSuchItemStateException("No such item " + nodeId.toString());
+            }
-            NodeState overlayedState = (NodeState) parent.getItemState(nodeId);
+            NodeState overlayedState = (NodeState) workspaceItemStateMgr.getItemState(nodeId);
-            PropertyState overlayedState = (PropertyState) parent.getItemState(propertyId);
+            PropertyState overlayedState = (PropertyState) workspaceItemStateMgr.getItemState(propertyId);

INS26 INS40 UPD42 UPD42 MOV43 UPD42 INS25 INS60 INS60 INS25 UPD42 MOV43 MOV43 INS27 INS8 MOV43 INS59 UPD27 INS43 INS59 INS27 INS8 INS8 MOV43 MOV43 UPD42 INS42 INS33 INS41 INS42 INS11 UPD42 INS42 INS42 INS32 INS42 INS33 INS21 MOV21 MOV21 INS53 MOV43 INS32 INS43 INS32 INS42 INS42 INS42 INS7 INS14 MOV43 MOV43 UPD42 INS42 INS42 MOV42 INS42 INS42 INS42 INS32 INS43 INS27 UPD42 UPD42 INS42 INS42 INS42 INS45 INS32 INS42 INS42 DEL42 DEL33 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL40 DEL52 DEL42 DEL14 DEL7 DEL21
- adapting to latest jackrabbit changes

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@209471 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.log4j.Logger;
-import org.apache.jackrabbit.webdav.lock.LockInfo;
-import org.apache.jackrabbit.webdav.lock.Type;
-import org.apache.jackrabbit.webdav.lock.Scope;
-import org.apache.jackrabbit.webdav.property.*;
-import org.apache.jackrabbit.webdav.transaction.*;
-import org.apache.jackrabbit.webdav.observation.*;
-import org.apache.jackrabbit.webdav.version.*;
-import org.apache.jackrabbit.webdav.version.report.ReportInfo;
-import org.apache.jackrabbit.webdav.ordering.*;
+import org.apache.jackrabbit.webdav.header.CodedUrlHeader;
-import org.apache.jackrabbit.webdav.header.CodedUrlHeader;
+import org.apache.jackrabbit.webdav.lock.LockInfo;
+import org.apache.jackrabbit.webdav.lock.Scope;
+import org.apache.jackrabbit.webdav.lock.Type;
+import org.apache.jackrabbit.webdav.observation.ObservationConstants;
+import org.apache.jackrabbit.webdav.observation.SubscriptionInfo;
+import org.apache.jackrabbit.webdav.ordering.OrderPatch;
+import org.apache.jackrabbit.webdav.ordering.OrderingConstants;
+import org.apache.jackrabbit.webdav.ordering.Position;
+import org.apache.jackrabbit.webdav.property.DavPropertyName;
+import org.apache.jackrabbit.webdav.property.DavPropertyNameSet;
+import org.apache.jackrabbit.webdav.property.DavPropertySet;
+import org.apache.jackrabbit.webdav.property.DefaultDavProperty;
+import org.apache.jackrabbit.webdav.transaction.TransactionConstants;
+import org.apache.jackrabbit.webdav.transaction.TransactionInfo;
+import org.apache.jackrabbit.webdav.version.DeltaVConstants;
+import org.apache.jackrabbit.webdav.version.LabelInfo;
+import org.apache.jackrabbit.webdav.version.MergeInfo;
+import org.apache.jackrabbit.webdav.version.OptionsInfo;
+import org.apache.jackrabbit.webdav.version.UpdateInfo;
+import org.apache.jackrabbit.webdav.version.report.ReportInfo;
-import org.jdom.input.SAXBuilder;
-import org.jdom.JDOMException;
+import org.apache.log4j.Logger;
+import org.jdom.JDOMException;
+import org.jdom.input.SAXBuilder;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.Cookie;
-import javax.servlet.http.HttpSession;
-import javax.servlet.ServletInputStream;
-import java.io.InputStream;
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
+import javax.servlet.ServletInputStream;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpSession;
-import java.util.*;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
+import java.util.Enumeration;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
-	String scheme = getScheme();
-	hrefPrefix = scheme + "://" + host + getContextPath();
+        String scheme = getScheme();
+        hrefPrefix = scheme + "://" + host + getContextPath();
-                String ifHeaderToken = (String)it.next();
+                String ifHeaderToken = (String) it.next();
-	    try {
-		URI uri = new URI(destination);
-		if (uri.getAuthority().equals(httpRequest.getHeader("Host"))) {
-		    destination = Text.unescape(uri.getPath());
-		}
-	    } catch (URISyntaxException e) {
-		log.debug("Destination is path is not a valid URI ("+e.getMessage()+".");
-		int pos = destination.lastIndexOf(":");
-		if (pos > 0) {
-		    destination = destination.substring(destination.indexOf("/",pos));
-		    log.debug("Tried to retrieve resource destination path from invalid URI: "+destination);
-		}
-	    }
-
-	    // cut off the context path
-	    String contextPath = httpRequest.getContextPath();
-	    if (destination.startsWith(contextPath)) {
-		destination = destination.substring(contextPath.length());
-	    }
-	}
-	return factory.createResourceLocator(hrefPrefix, destination);
+            try {
+                URI uri = new URI(destination);
+                if (uri.getAuthority().equals(httpRequest.getHeader("Host"))) {
+                    destination = Text.unescape(uri.getRawPath());
+                }
+            } catch (URISyntaxException e) {
+                log.debug("Destination is path is not a valid URI (" + e.getMessage() + ".");
+                int pos = destination.lastIndexOf(":");
+                if (pos > 0) {
+                    destination = Text.unescape(destination.substring(destination.indexOf("/", pos)));
+                    log.debug("Tried to retrieve resource destination path from invalid URI: " + destination);
+                }
+            }
+            // cut off the context path
+            String contextPath = httpRequest.getContextPath();
+            if (destination.startsWith(contextPath)) {
+                destination = destination.substring(contextPath.length());
+            }
+        }
+        return factory.createResourceLocator(hrefPrefix, destination);
-	boolean doOverwrite = true;
-	String overwriteHeader = httpRequest.getHeader(HEADER_OVERWRITE);
-	if (overwriteHeader != null && !overwriteHeader.equalsIgnoreCase(NO_OVERWRITE)){
-	    doOverwrite = false;
-	}
-	return doOverwrite;
+        boolean doOverwrite = true;
+        String overwriteHeader = httpRequest.getHeader(HEADER_OVERWRITE);
+        if (overwriteHeader != null && !overwriteHeader.equalsIgnoreCase(NO_OVERWRITE)) {
+            doOverwrite = false;
+        }
+        return doOverwrite;
-	return DepthHeader.parse(httpRequest, defaultValue).getDepth();
+        return DepthHeader.parse(httpRequest, defaultValue).getDepth();
-	String timeoutStr = httpRequest.getHeader(HEADER_TIMEOUT);
-	long timeout = UNDEFINED_TIMEOUT;
-	if (timeoutStr != null && timeoutStr.length() > 0) {
-	    int secondsInd = timeoutStr.indexOf("Second-");
-	    if (secondsInd >= 0) {
-		secondsInd += 7; // read over "Second-"
-		int i = secondsInd;
+        String timeoutStr = httpRequest.getHeader(HEADER_TIMEOUT);
+        long timeout = UNDEFINED_TIMEOUT;
+        if (timeoutStr != null && timeoutStr.length() > 0) {
+            int secondsInd = timeoutStr.indexOf("Second-");
+            if (secondsInd >= 0) {
+                secondsInd += 7; // read over "Second-"
+                int i = secondsInd;
-		try {
-		    timeout = 1000L * Long.parseLong(timeoutStr.substring(secondsInd, i));
-		} catch (NumberFormatException ignore) {
-		    // ignore an let the lock define the default timeout
-                    log.error("Invalid timeout format: "+timeoutStr);
-		}
-	    } else if (timeoutStr.equalsIgnoreCase(TIMEOUT_INFINITE)) {
-		timeout = INFINITE_TIMEOUT;
-	    }
-	}
-	return timeout;
+                try {
+                    timeout = 1000L * Long.parseLong(timeoutStr.substring(secondsInd, i));
+                } catch (NumberFormatException ignore) {
+                    // ignore an let the lock define the default timeout
+                    log.error("Invalid timeout format: " + timeoutStr);
+                }
+            } else if (timeoutStr.equalsIgnoreCase(TIMEOUT_INFINITE)) {
+                timeout = INFINITE_TIMEOUT;
+            }
+        }
+        return timeout;
-		SAXBuilder builder = new SAXBuilder(false);
+                SAXBuilder builder = new SAXBuilder(false);
-	// propfind httpRequest with empty body or invalid Xml >> retrieve all property
-	// TODO: spec requires a 'BAD REQUEST' error code
-	if (requestDocument == null) {
-	    return;
-	}
+        // propfind httpRequest with empty body or invalid Xml >> retrieve all property
+        // TODO: spec requires a 'BAD REQUEST' error code
+        if (requestDocument == null) {
+            return;
+        }
-	// propfind httpRequest with invalid body >> treat as if empty body
-	Element root = requestDocument.getRootElement();
-	if (!root.getName().equals(XML_PROPFIND)) {
-	    log.info("PropFind-Request has no <profind> tag.");
-	    return;
-	}
+        // propfind httpRequest with invalid body >> treat as if empty body
+        Element root = requestDocument.getRootElement();
+        if (!root.getName().equals(XML_PROPFIND)) {
+            log.info("PropFind-Request has no <profind> tag.");
+            return;
+        }
-	List childList = root.getChildren();
-	for (int i = 0; i < childList.size(); i++) {
-	    Element child = (Element) childList.get(i);
-	    String nodeName = child.getName();
-	    if (XML_PROP.equals(nodeName)) {
-		propfindType = PROPFIND_BY_PROPERTY;
-		propfindProps = new DavPropertyNameSet(child);
+        List childList = root.getChildren();
+        for (int i = 0; i < childList.size(); i++) {
+            Element child = (Element) childList.get(i);
+            String nodeName = child.getName();
+            if (XML_PROP.equals(nodeName)) {
+                propfindType = PROPFIND_BY_PROPERTY;
+                propfindProps = new DavPropertyNameSet(child);
-	    } else if (XML_PROPNAME.equals(nodeName)) {
-		propfindType = PROPFIND_PROPERTY_NAMES;
+            } else if (XML_PROPNAME.equals(nodeName)) {
+                propfindType = PROPFIND_PROPERTY_NAMES;
-	    } else if (XML_ALLPROP.equals(nodeName)) {
-		propfindType = PROPFIND_ALL_PROP;
+            } else if (XML_ALLPROP.equals(nodeName)) {
+                propfindType = PROPFIND_ALL_PROP;
-	    }
-	}
+            }
+        }
-     * parsing the request body.
+     *         parsing the request body.
-	Document requestDocument = getRequestDocument();
+        Document requestDocument = getRequestDocument();
-	// 'create Lock' request and missing for a 'refresh Lock' request
-	if (requestDocument != null) {
-	    Element root = requestDocument.getRootElement();
-	    if (root.getName().equals(XML_LOCKINFO)) {
+        // 'create Lock' request and missing for a 'refresh Lock' request
+        if (requestDocument != null) {
+            Element root = requestDocument.getRootElement();
+            if (root.getName().equals(XML_LOCKINFO)) {
-	    } else {
-		log.debug("Lock-Request has no <lockinfo> tag.");
-	    }
-	} else {
+            } else {
+                log.debug("Lock-Request has no <lockinfo> tag.");
+            }
+        } else {
-     * request processing are fulfilled.
-     * @param resource
-     * @return
+     *         request processing are fulfilled.
-    
+
-                    log.error("Cannot parse Position header: "+e.getMessage());
+                    log.error("Cannot parse Position header: " + e.getMessage());
-     * body or <code>null</code> if the
+     *         body or <code>null</code> if the
-               lInfo = new LabelInfo(root, depth);
+                lInfo = new LabelInfo(root, depth);
-               mInfo = new MergeInfo(requestDocument.getRootElement());
+                mInfo = new MergeInfo(requestDocument.getRootElement());
-               uInfo = new UpdateInfo(requestDocument.getRootElement());
+                uInfo = new UpdateInfo(requestDocument.getRootElement());
-       httpRequest.removeAttribute(s);
+        httpRequest.removeAttribute(s);

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 UPD40 INS40 UPD40 UPD40 INS40 UPD40 INS40 INS40 INS40 INS40 UPD40 INS32 UPD42 INS42 INS42 MOV32 DEL42 DEL65 DEL65
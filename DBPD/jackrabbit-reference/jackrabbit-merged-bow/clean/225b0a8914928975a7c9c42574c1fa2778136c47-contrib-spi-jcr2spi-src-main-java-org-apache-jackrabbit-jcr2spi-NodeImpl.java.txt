work in progress

- HierarchyManager: changes methods to take ItemState instead of ItemId
- HierarchyManager: remove log-utility methods (saveGetJCRPath)
- HierarchyManager: remove CachingHierachyManager. not used
- ItemManager: changes methods to take ItemState instead of ItemId
- ItemStateValidator: remove utility methods not related to validation
- new class LogUtil that provides static saveGetJCRPath methods previously
  present on HierarchyManager, ItemStateValidator
- NodeState: add method 'getPropertyEntries()'
- create interface ChildPropertyEntry
- let PropertyReference implement ChildPropertyEntry

TODO: query/NodeIteratorImpl needs to be fixed. 


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@429652 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.state.ItemState;
+import org.apache.jackrabbit.jcr2spi.version.VersionImpl;
-import org.apache.jackrabbit.spi.ItemId;
-        return (Node) itemMgr.getItem(parentState.getNodeId());
+        return (Node) itemMgr.getItem(parentState);
-        NodeId id = resolveRelativeNodePath(relPath);
-        if (id == null) {
+        NodeState state = resolveRelativeNodePath(relPath);
+        if (state == null) {
-        return (Node) itemMgr.getItem(id);
+        return (Node) itemMgr.getItem(state);
-            return itemMgr.getChildNodes(getNodeId());
+            return itemMgr.getChildNodes(getNodeState());
-        PropertyId id = resolveRelativePropertyPath(relPath);
-        if (id == null) {
+        PropertyState state = resolveRelativePropertyPath(relPath);
+        if (state == null) {
-        return (Property) itemMgr.getItem(id);
+        return (Property) itemMgr.getItem(state);
-            return itemMgr.getChildProperties(getNodeId());
+            return itemMgr.getChildProperties(getNodeState());
-        NodeId id = resolveRelativeNodePath(relPath);
-        return (id != null) ? itemMgr.itemExists(id) : false;
+        NodeState childState = resolveRelativeNodePath(relPath);
+        return (childState != null) ? itemMgr.itemExists(childState) : false;
-        PropertyId pId = resolveRelativePropertyPath(relPath);
-        return (pId != null) ? itemMgr.itemExists(pId) : false;
+        PropertyState childState = resolveRelativePropertyPath(relPath);
+        return (childState != null) ? itemMgr.itemExists(childState) : false;
-        return itemMgr.hasChildNodes(getNodeId());
+        return itemMgr.hasChildNodes(getNodeState());
-        return itemMgr.hasChildProperties(getNodeId());
+        return itemMgr.hasChildProperties(getNodeState());
-        ItemId versionId = session.getHierarchyManager().getItemId(version);
-        if (versionId.denotesNode()) {
-            session.getVersionManager().resolveMergeConflict(getNodeId(), (NodeId) versionId, done);
+        if (version instanceof VersionImpl) {
+            session.getVersionManager().resolveMergeConflict(getNodeId(), (NodeId) ((VersionImpl)version).getId(), done);
-        ItemId versionId = session.getHierarchyManager().getItemId(version);
-        if (versionId.denotesNode()) {
-            session.getVersionManager().restore(nodeId, (NodeId) versionId, removeExisting);
+        if (version instanceof VersionImpl) {
+            session.getVersionManager().restore(nodeId, (NodeId) ((VersionImpl)version).getId(), removeExisting);
-        return session.getLockManager().lock(getNodeId(), isDeep, isSessionScoped);
+        return session.getLockManager().lock(getNodeId(), this, isDeep, isSessionScoped);
-        return session.getHierarchyManager().getQName(getId());
+        return session.getHierarchyManager().getQName(getNodeState());
-        NodeId childId;
-        List cne = getNodeState().getChildNodeEntries(nodeName);
-        if (definition.allowsSameNameSiblings()) {
-            // TODO: find proper solution. problem with same-name-siblings
-            childId = ((ChildNodeEntry)cne.get(cne.size()-1)).getId();
-        } else {
-            childId = ((ChildNodeEntry)cne.get(0)).getId();
+        NodeState childState;
+        try {
+            List cne = getNodeState().getChildNodeEntries(nodeName);
+            if (definition.allowsSameNameSiblings()) {
+                // TODO: find proper solution. problem with same-name-siblings
+                childState = ((ChildNodeEntry)cne.get(cne.size()-1)).getNodeState();
+            } else {
+                childState = ((ChildNodeEntry)cne.get(0)).getNodeState();
+            }
+        } catch (ItemStateException e) {
+            // should not occur
+            throw new RepositoryException(e);
-        return (Node) itemMgr.getItem(childId);
+        return (Node) itemMgr.getItem(childState);
-            return (Property) itemMgr.getItem(pState.getId());
+            return (Property) itemMgr.getItem(pState);
-     * @return the id of the node at <code>relPath</code> or <code>null</code>
+     * @return the state of the node at <code>relPath</code> or <code>null</code>
-    private NodeId resolveRelativeNodePath(String relPath) throws RepositoryException {
-        NodeId targetId = null;
+    private NodeState resolveRelativeNodePath(String relPath) throws RepositoryException {
+        NodeState targetState = null;
-                        targetId = cne.getId();
+                        targetState = cne.getNodeState();
-                ItemId id = session.getHierarchyManager().getItemId(p.getCanonicalPath());
-                if (id.denotesNode()) {
-                    targetId = (NodeId) id;
+                ItemState itemState = session.getHierarchyManager().getItemState(p.getCanonicalPath());
+                if (itemState.isNode()) {
+                    targetState = (NodeState) itemState;
+        } catch (ItemStateException e) {
+            // should not occure
+            String msg = "Invalid relative path: " + relPath;
+            log.debug(msg);
+            throw new RepositoryException(msg, e);
-        return targetId;
+        return targetState;
-     * @return the id of the property at <code>relPath</code> or
+     * @return the state of the property at <code>relPath</code> or
-    private PropertyId resolveRelativePropertyPath(String relPath) throws RepositoryException {
+    private PropertyState resolveRelativePropertyPath(String relPath) throws RepositoryException {
-                        return getNodeState().getPropertyState(propName).getPropertyId();
+                        return getNodeState().getPropertyState(propName);
-                ItemId id = session.getHierarchyManager().getItemId(p);
-                if (!id.denotesNode()) {
-                    return (PropertyId) id;
+                ItemState itemState = session.getHierarchyManager().getItemState(p);
+                if (!itemState.isNode()) {
+                    return (PropertyState) itemState;

MOV26 INS26 UPD40 INS40 UPD43 UPD43 INS54 UPD42 UPD42 UPD43 UPD43 UPD43 UPD43 INS62 INS62 UPD43 INS8 INS12 UPD66 UPD43 INS12 UPD42 UPD66 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS43 INS42 INS43 INS52 UPD42 UPD42 MOV60 MOV25 INS44 INS8 UPD42 UPD42 INS44 INS8 MOV42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 UPD42 INS43 INS42 INS53 UPD42 INS43 INS42 INS60 INS21 INS53 UPD42 UPD42 INS11 INS11 INS42 INS14 INS42 INS43 INS59 INS32 INS14 UPD42 UPD42 MOV43 INS32 MOV43 INS32 INS43 INS42 MOV42 UPD43 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 UPD43 INS36 INS42 INS36 INS42 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 INS45 INS42 INS42 UPD42 UPD42 INS11 INS11 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS43 UPD42 MOV42 INS43 UPD42 MOV42 UPD42 UPD43 UPD42 INS42 INS42 UPD43 UPD42 MOV32 UPD42 UPD42 UPD42 UPD42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL11 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL11 DEL42 DEL32 DEL42 DEL32
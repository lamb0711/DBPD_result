work in progress.

- nodestates must always be connected to their cne upon creation
  TODO: add some sort of caching to avoid traffic overhead
- add TODO for refresh, that currently doesn't work properly
- ItemState.refresh only takes changelog and returns the ids of the
  processed states. cleanup of events is left to caller.
- move of NodeStates does not work
- PathResolver: force start to be an NodeState
- all MODIFIED status for SessionStates as well in order to make sure
  that listeners are informed about external changes even if the 
  state is EXISTING.

next TODO: make sure, that public getChildNodeEntry/ies and hasChildNodeEntry check for validity of the connected NodeState. don't return entries, where the nodestate is (transiently) removed or stale.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@472818 13f79535-47bb-0310-9956-ffa450edef68

-        assertAvailability();
-        assertAvailability();
-    private void assertAvailability() {
-        // TODO: TOBEFIXED. duality of creating states via ISM or via factory may result in a cached state, that is not connected to its cne.
-        if (uuid != null && parent != null) {
-            // make sure this state is connected to its childNode-entry
-            ChildNodeEntry cne = parent.childNodeEntries.get(name, uuid);
-            if (cne != null && !cne.isAvailable()) {
-                parent.childNodeEntries.replaceEntry(this);
-            }
-        }
-    }
-
-     * Determines if there are any child node entries.
+     * Determines if there are any valid child node entries.
-     *         <code>false</code> otherwise.
+     * <code>false</code> otherwise.
-     * Determines if there is a <code>ChildNodeEntry</code> with the
+     * Determines if there is a valid <code>ChildNodeEntry</code> with the
-     *         the specified <code>name</code> and <code>index</code>.
+     * the specified <code>name</code> and <code>index</code>.
+     * <code>NodeId</code> or <code>null</code> if there's no matching
+     * entry.
+     *
+     * @param nodeId the id of the child node state.
+     * @return the <code>ChildNodeEntry</code> with the specified
+     * <code>NodeId</code> or <code>null</code> if there's no matching entry.
+     */
+    public synchronized ChildNodeEntry getChildNodeEntry(NodeId nodeId) {
+        String uuid = nodeId.getUUID();
+        Path path = nodeId.getPath();
+        if (uuid != null && path == null) {
+            // retrieve child-entry by uuid
+            return childNodeEntries.get(null, uuid);
+        } else {
+           // retrieve child-entry by name and index
+            Path.PathElement nameElement = path.getNameElement();
+            return childNodeEntries.get(nameElement.getName(), nameElement.getIndex());
+        }
+    }
+
+    /**
+     * Returns the <code>ChildNodeEntry</code> with the specified
-     *         <code>NodeState</code> or <code>null</code> if there's no
-     *         matching entry.
+     * <code>NodeState</code> or <code>null</code> if there's no matching entry.
-            // then it must be valid
+            // then it must be valid // TODO check if this assumption is correct.
-     * @param propertyName the name of the property state to return.
-     * @throws NoSuchItemStateException if there is no property state with the
-     *                                  given name.
-     * @throws ItemStateException       if an error occurs while retrieving the
-     *                                  property state.
+     * @param propertyName The name of the property state to return.
+     * @throws NoSuchItemStateException If there is no (valid) property state
+     * with the given name.
+     * @throws ItemStateException If an error occurs while retrieving the
+     * property state.
-            throws NoSuchItemStateException, ItemStateException {
-        PropertyState propState = getAnyPropertyState(propertyName);
-        if (propState.isValid()) {
-            return propState;
-        } else {
-            throw new NoSuchItemStateException(idFactory.createPropertyId(getNodeId(), propertyName).toString());
-        }
-    }
+        throws NoSuchItemStateException, ItemStateException {
-    /**
-     * Returns the property state with the given name and also takes removed
-     * property states into account.
-     *
-     * @param propertyName the name of the property state to return.
-     * @throws NoSuchItemStateException if there is no property state with the
-     *                                  given name.
-     * @throws ItemStateException       if an error occurs while retrieving the
-     *                                  property state.
-     */
-    public synchronized PropertyState getAnyPropertyState(QName propertyName)
-            throws NoSuchItemStateException, ItemStateException {
+        } else {
+            PropertyState propState = propEntry.getPropertyState();
+            if (propState.isValid()) {
+                return propState;
+            } else {
+                throw new NoSuchItemStateException(idFactory.createPropertyId(getNodeId(), propertyName).toString());
+            }
-        return propEntry.getPropertyState();
-     * @return the index of the child node entry or <code>0</code> if it is not
-     *         found in this <code>NodeState</code>.
+     * @return the index of the child node entry or <code>Path.INDEX_UNDEFINED</code>
+     * if it is not found in this <code>NodeState</code>.
+                // TODO: check if assuption is correct
-     * @see ItemState#refresh(Collection,ChangeLog)
+     * @see ItemState#refresh(ChangeLog)
-    void refresh(Collection events, ChangeLog changeLog) throws IllegalStateException {
+    Set refresh(ChangeLog changeLog) throws IllegalStateException {
-        HashMap modParents = new HashMap();
+        Map modParents = new HashMap();
+        Set processedIds = new HashSet();
-            removeEvent(events, state);
+            processedIds.add(state.getId());
-                removeEvent(events, addedState);
+                processedIds.add(addedState.getId());
-                continue;
-            }
-            // push changes down to overlayed state
-            int type = ((PropertyState) modState).getType();
-            QValue[] values = ((PropertyState) modState).getValues();
-            ((PropertyState) modState.overlayedState).init(type, values);
+                NodeState modNodeState = (NodeState) modState;
+                // handle moved nodes
+                if (isMovedState(modNodeState)) {
+                    // move overlayed state as well
+                    NodeState newParent = (NodeState) modState.parent.overlayedState;
+                    NodeState overlayed = (NodeState) modState.overlayedState;
+                    ItemId removedId = overlayed.getId();
+                    try {
+                        overlayed.parent.moveEntry(newParent, overlayed, modNodeState.getQName(), modNodeState.getDefinition());
+                    } catch (RepositoryException e) {
+                        // should never occur
+                        log.error("Internal error while moving childnode entries.", e);
+                    }
+                    // and mark the moved state existing
+                    modNodeState.setStatus(Status.EXISTING);
+                    it.remove();
-            modState.setStatus(Status.EXISTING);
-            // if property state defines a modified jcr:mixinTypes
-            // the parent is listed as modified state and needs to be
-            // processed at the end.
-            if (isUuidOrMixin(modState.getQName())) {
-                modifiedParent(this, modState, modParents);
+                    processedIds.add(removedId);
+                    processedIds.add(modNodeState.getId());
+                } else {
+                    modifiedParent((NodeState)modState, null, modParents);
+                }
+            } else {
+                // push changes down to overlayed state
+                int type = ((PropertyState) modState).getType();
+                QValue[] values = ((PropertyState) modState).getValues();
+                ((PropertyState) modState.overlayedState).init(type, values);
+
+                modState.setStatus(Status.EXISTING);
+                // if property state defines a modified jcr:mixinTypes
+                // the parent is listed as modified state and needs to be
+                // processed at the end.
+                if (isUuidOrMixin(modState.getQName())) {
+                    modifiedParent(modState.getParent(), modState, modParents);
+                }
+                it.remove();
+                // remove the property-modification event from the set
+                processedIds.add(modState.getId());
-            // remove the processed event from the set
-            it.remove();
-            removeEvent(events, modState);
-        /* process all parent states that need their uuid or mixin-types being
-           adjusted because that property has been added or modified */
+        /* process all parent states that are marked modified and eventually
+           need their uuid or mixin-types being adjusted because that property
+           has been added, modified or removed */
+
+        return processedIds;
+        // TODO: TOBEFIXED. revert must include an update with the latest state present on the server
+        moveEntry(newParent, childState, newName, newDefinition);
+        // mark both this and newParent modified
+        markModified();
+        childState.markModified();
+        newParent.markModified();
+    }
+
+    private void moveEntry(NodeState newParent, NodeState childState, QName newName, QNodeDefinition newDefinition) throws RepositoryException {
-            childState.rename(newName);
+            childState.name = newName;
-            throw new RepositoryException("Unexpected error: Child state to be renamed does not exist.");
+            throw new RepositoryException("Unexpected error: Child state to be moved does not exist.");
-        // mark both this and newParent modified
-        markModified();
-        childState.markModified();
-        newParent.markModified();
-    }
-
-    /**
-     * Renames this node to <code>newName</code>.
-     *
-     * @param newName the new name for this node state.
-     * @throws IllegalStateException if this is the root node.
-     */
-    private synchronized void rename(QName newName) {
-        checkIsSessionState();
-        if (getParent() == null) {
-            throw new IllegalStateException("root node cannot be renamed");
-        }
-        name = newName;
+                // TODO: check if this assumption is correct
-    //------------------------------------------------------< inner classes >---
+
+    private static boolean isMovedState(NodeState modState) {
+        return modState.overlayedState.parent != modState.parent.overlayedState;
+    }

MOV31 INS31 MOV43 UPD42 INS8 MOV43 MOV43 MOV43 INS8 INS43 INS42 INS8 UPD42 INS44 INS44 INS44 INS43 MOV8 INS83 INS83 INS39 INS42 INS44 INS8 UPD65 UPD43 UPD42 INS60 MOV60 MOV25 MOV42 MOV42 INS60 INS25 UPD42 MOV42 INS60 INS41 MOV21 INS21 MOV21 MOV21 MOV21 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS43 INS42 INS41 UPD66 UPD66 UPD66 INS66 UPD66 UPD42 UPD66 UPD66 UPD66 UPD42 INS43 INS59 UPD43 MOV27 INS8 UPD66 INS43 INS59 MOV27 INS8 MOV8 UPD66 UPD66 UPD43 INS43 INS59 INS8 INS42 INS32 INS42 UPD42 MOV42 INS42 INS42 INS27 UPD42 MOV42 INS42 INS32 UPD42 UPD42 INS32 UPD27 INS41 INS60 INS41 INS42 INS42 MOV11 MOV53 UPD42 INS42 INS42 INS14 MOV60 INS25 INS42 INS42 INS42 INS42 INS42 INS40 INS40 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 INS32 INS43 INS59 INS32 INS43 MOV32 INS8 MOV8 INS7 INS42 INS42 INS33 INS42 INS40 INS42 INS32 UPD42 MOV42 UPD42 MOV42 MOV32 INS32 INS42 INS42 INS42 UPD42 UPD42 INS32 INS60 INS25 INS40 INS42 UPD45 INS42 INS42 INS42 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 MOV42 MOV42 MOV42 INS42 INS43 INS59 INS32 INS8 INS8 INS42 INS42 INS32 INS42 UPD42 UPD42 INS32 INS42 INS42 INS11 INS42 INS42 INS60 INS60 INS60 INS54 INS21 INS21 INS21 INS21 INS21 UPD42 UPD42 INS32 INS42 MOV42 INS42 INS43 INS42 INS43 INS59 INS43 INS59 INS43 INS59 INS8 INS12 INS32 INS32 INS32 INS32 INS32 MOV42 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS11 INS42 INS42 INS32 INS21 INS44 INS8 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS11 INS33 INS42 INS32 INS42 INS43 INS40 INS43 INS40 INS42 INS42 INS32 INS43 INS42 INS21 INS42 INS42 INS43 INS42 MOV42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS32 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL83 DEL39 DEL42 DEL42 DEL40 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL38 DEL27 DEL40 DEL42 DEL52 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL31 DEL42 DEL42 DEL66 DEL66 DEL65 DEL41 DEL8 DEL66 DEL42 DEL43 DEL69 DEL39 DEL42 DEL43 DEL42 DEL44 DEL18 DEL8 DEL25 DEL52 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL42 DEL32 DEL33 DEL27 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL42 DEL42 DEL7 DEL21 DEL8
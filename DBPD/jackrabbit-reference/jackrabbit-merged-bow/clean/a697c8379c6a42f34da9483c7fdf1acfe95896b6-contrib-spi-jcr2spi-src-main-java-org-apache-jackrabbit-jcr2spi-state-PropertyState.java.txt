work in progress

- version always protected
- versionHistory always protected
- fix Node.getReferences && reference properties
- mixinTypes are 'active' upon save only (and not before). therefore
  cleanup after removeMixin is done only after save.
  adding new states defined by a new mixin are only added after the
  node has been saved.
- nodestates identified by a uuid only were created a second time upon
  ChildNodeEntry.resolve => fix needs to be improved
- Events/ChangeLog are processed by the save-target state
- ChangeLog.persisted not used any more

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@467956 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Collection;
+import java.util.Iterator;
-    private QName name;
+    private final QName name;
+
+    /**
+     * Property definition
+     */
+    private final QPropertyDefinition def;
-     * Property definition
-     */
-    private QPropertyDefinition def;
-
-    /**
-                            int initialStatus, IdFactory idFactory) {
-        super(overlayedState, parent, initialStatus, idFactory);
+                            int initialStatus, ItemStateFactory isf, IdFactory idFactory) {
+        super(overlayedState, parent, initialStatus, isf, idFactory);
+        this.name = overlayedState.name;
+        this.def = overlayedState.def;
+
-                            int initialStatus, IdFactory idFactory, boolean isWorkspaceState) {
-        super(parent, initialStatus, idFactory, isWorkspaceState);
+                            int initialStatus, ItemStateFactory isf, IdFactory idFactory,
+                            boolean isWorkspaceState) {
+        super(parent, initialStatus, isf, idFactory, isWorkspaceState);
-
-        type = PropertyType.UNDEFINED;
-        values = QValue.EMPTY_ARRAY;
+        init(PropertyType.UNDEFINED, QValue.EMPTY_ARRAY);
+        // free old values as necessary
+        QValue[] oldValues = this.values;
+        if (oldValues != null) {
+            for (int i = 0; i < oldValues.length; i++) {
+                QValue old = oldValues[i];
+                if (old != null) {
+                    // make sure temporarily allocated data is discarded
+                    // before overwriting it (see QValue#discard())
+                    old.discard();
+                }
+            }
+        }
-        return idFactory.createPropertyId(parent.getNodeId(), getQName());
+        return idFactory.createPropertyId(getParent().getNodeId(), getQName());
-     * @see ItemState#refresh(Event, ChangeLog)
+     * @see ItemState#refresh(Event)
-    synchronized void refresh(Event event, ChangeLog changeLog) {
+    synchronized void refresh(Event event) {
-                if (event.getItemId().equals(getId())) {
-                    setStatus(Status.REMOVED);
-                } else {
-                    // ILLEGAL
-                    throw new IllegalArgumentException("EventId " + event.getItemId() + " does not match id of this property state.");
-                }
+                setStatus(Status.REMOVED);
-                if (event.getItemId().equals(getId())) {
+                // TODO: improve.
+                /* retrieve property value and type from server even if
+                   changes were issued from this session (changelog).
+                   this is currently the only way to update the workspace
+                   state, which is not connected to its overlaying session-state.
+                */
+                try {
+                    PropertyState tmp = isf.createPropertyState(getPropertyId(), parent);
+                    init(tmp.getType(), tmp.getValues());
-                } else {
-                    // ILLEGAL
-                    throw new IllegalArgumentException("EventId " + event.getItemId() + " does not match id of this property state.");
+                } catch (ItemStateException e) {
+                    // TODO: rather throw?
+                    log.error("Internal Error", e);
+     * @see ItemState#refresh(Collection,ChangeLog)
+     */
+    void refresh(Collection events, ChangeLog changeLog) throws IllegalStateException {
+        for (Iterator it = changeLog.modifiedStates(); it.hasNext();) {
+            ItemState modState = (ItemState) it.next();
+            if (modState == this) {
+                /*
+                NOTE: overlayedState must be existing, otherwise save was not
+                possible on prop. Similarly a property can only be the changelog
+                target, if it was modified. removal, add must be persisted on parent.
+                */
+                // push changes to overlayed state and reset status
+                ((PropertyState) overlayedState).init(getType(), getValues());
+                setStatus(Status.EXISTING);
+                // parent must not be informed, since all properties that
+                // affect the parent state (uuid, mixins) are protected.
+                removeEvent(events, modState);
+            }
+        }
+    }
+
+    /**
+     * {@inheritDoc}
-                name = wspState.name;
-                type = wspState.type;
-                def = wspState.def;
-                values = wspState.values;
+                init(wspState.type, wspState.values);
-    synchronized void merge() {
-        reset();
-    }
-
-
-        parent.propertyStateRemoved(this);
+        getParent().propertyStateRemoved(this);
-                parent.propertyStateRemoved(this);
+                getParent().propertyStateRemoved(this);
-                parent.propertyStateRemoved(this);
+                getParent().propertyStateRemoved(this);
-                parent.propertyStateRemoved(this);
+                getParent().propertyStateRemoved(this);
-     * @see ItemState#collectTransientStates(Set)
+     * @see ItemState#collectTransientStates(Collection)
-    void collectTransientStates(Set transientStates) {
+    void collectTransientStates(Collection transientStates) {
-
-        this.values = values;
-        this.type = type;
+        init(type, values);
+

INS26 INS26 MOV23 MOV31 INS40 INS40 INS83 INS83 INS44 INS44 INS8 INS29 INS42 INS44 MOV44 INS43 INS8 INS43 INS42 INS21 INS21 INS43 INS42 INS21 INS60 INS25 MOV21 MOV21 INS65 INS65 INS43 INS42 INS42 INS24 UPD43 INS42 INS42 INS7 INS7 INS42 INS42 INS32 INS5 INS59 INS27 INS8 MOV21 INS10 INS54 INS65 INS68 INS42 INS58 INS32 INS8 UPD42 INS32 INS22 INS40 INS22 INS40 INS42 INS40 INS40 INS43 INS85 INS42 MOV22 INS42 INS33 INS24 INS8 INS12 INS42 INS42 INS69 MOV69 INS43 INS59 INS42 INS42 INS60 INS25 INS32 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS42 INS58 INS27 INS37 INS8 INS32 INS60 INS21 MOV21 INS44 INS8 INS43 INS42 INS42 INS32 INS43 INS59 INS27 INS8 UPD42 MOV42 INS32 INS32 INS32 UPD43 INS39 INS59 INS42 INS40 INS42 INS60 INS25 UPD42 MOV42 INS43 INS59 INS32 INS43 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS52 INS21 INS21 MOV21 INS21 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 INS42 INS34 INS43 INS59 INS27 INS8 INS42 INS42 INS32 UPD42 MOV42 MOV32 INS32 UPD42 MOV42 INS32 INS43 INS32 INS32 INS32 INS32 INS42 INS42 INS2 INS42 INS33 INS21 UPD42 MOV42 INS42 MOV32 UPD42 MOV42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS45 INS42 INS42 INS42 INS42 INS36 INS42 INS32 INS32 INS42 INS40 UPD42 INS42 INS42 INS42 INS40 INS40 INS42 INS42 INS32 UPD42 INS11 INS42 INS42 INS42 INS42 INS43 INS42 INS42 DEL42 DEL40 DEL7 DEL21 DEL42 DEL40 DEL7 DEL21 DEL8 DEL42 DEL42 DEL32 DEL32 DEL8 DEL42 DEL43 DEL45 DEL32 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL10 DEL32 DEL32 DEL8 DEL43 DEL45 DEL42 DEL32 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL83 DEL42 DEL8 DEL42 DEL40 DEL7 DEL21 DEL42 DEL40 DEL7 DEL21 DEL42 DEL40 DEL7 DEL21 DEL42 DEL40 DEL7 DEL21 DEL42 DEL7 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21
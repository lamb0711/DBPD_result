JCR-1104 - JSR 283 support
- shareble nodes (work in progress)


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@638398 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.nodetype.NodeTypeConflictException;
+import javax.jcr.UnsupportedRepositoryOperationException;
+    
+    /**
+     * Clones the subtree at the node <code>srcAbsPath</code> in to the new
+     * location at <code>destAbsPath</code>. This operation is only supported:
+     * <ul>
+     * <li>If the source element has the mixin <code>mix:shareable</code> (or some
+     * derived node type)</li>
+     * <li>If the parent node of <code>destAbsPath</code> has not already a shareable
+     * node in the same shared set as the node at <code>srcPath</code>.</li>
+     * </ul>
+     * 
+     * @param srcPath source path
+     * @param destPath destination path
+     * @return the node id of the destination's parent
+     * 
+     * @throws ConstraintViolationException if the operation would violate a
+     * node-type or other implementation-specific constraint.
+     * @throws VersionException if the parent node of <code>destAbsPath</code> is
+     * versionable and checked-in, or is non-versionable but its nearest versionable ancestor is
+     * checked-in. This exception will also be thrown if <code>removeExisting</code> is <code>true</code>,
+     * and a UUID conflict occurs that would require the moving and/or altering of a node that is checked-in.
+     * @throws AccessDeniedException if the current session does not have
+     * sufficient access rights to complete the operation.
+     * @throws PathNotFoundException if the node at <code>srcAbsPath</code> in
+     * <code>srcWorkspace</code> or the parent of <code>destAbsPath</code> in this workspace does not exist.
+     * @throws ItemExistsException if a property already exists at
+     * <code>destAbsPath</code> or a node already exist there, and same name
+     * siblings are not allowed or if <code>removeExisting</code> is false and a
+     * UUID conflict occurs.
+     * @throws LockException if a lock prevents the clone.
+     * @throws RepositoryException if the last element of <code>destAbsPath</code>
+     * has an index or if another error occurs.
+     */
+    public NodeId clone(Path srcPath, Path destPath) 
+            throws ConstraintViolationException, AccessDeniedException,
+                   VersionException, PathNotFoundException, ItemExistsException,
+                   LockException, RepositoryException, IllegalStateException {
+
+        // check precondition
+        checkInEditMode();
+
+        // 1. check paths & retrieve state
+        NodeState srcState = getNodeState(srcPath);
+
+        Path.Element destName = destPath.getNameElement();
+        Path destParentPath = destPath.getAncestor(1);
+        NodeState destParentState = getNodeState(destParentPath);
+        int ind = destName.getIndex();
+        if (ind > 0) {
+            // subscript in name element
+            String msg = "invalid destination path (subscript in name element is not allowed)";
+            log.debug(msg);
+            throw new RepositoryException(msg);
+        }
+        
+        // 2. check access rights, lock status, node type constraints, etc.
+        checkAddNode(destParentState, destName.getName(),
+                srcState.getNodeTypeName(), CHECK_ACCESS | CHECK_LOCK
+                | CHECK_VERSIONING | CHECK_CONSTRAINTS);
+        
+        // 3. verify that source has mixin mix:shareable
+        if (!isShareable(srcState)) {
+            String msg = "Cloning inside a workspace is only allowed for shareable nodes.";
+            log.debug(msg);
+            throw new RepositoryException(msg);
+        }
+        
+        // 4. do clone operation (modify and store affected states)
+        if (!srcState.addShare(destParentState.getNodeId())) {
+            String msg = "Adding a shareable node twice to the same parent is not supported.";
+            log.debug(msg);
+            throw new UnsupportedRepositoryOperationException(msg);
+        }
+        destParentState.addChildNodeEntry(destName.getName(), srcState.getNodeId());
+
+        // store states
+        stateMgr.store(srcState);
+        stateMgr.store(destParentState);
+        return destParentState.getNodeId();
+    }
+
+    
-        if (!stateMgr.inEditMode()) {
-            throw new IllegalStateException("not in edit mode");
-        }
-
+        checkInEditMode();
+        
+            // check shareable case
+            if (target.isShareable()) {
+                String msg = "Moving a shareable node is not supported.";
+                log.debug(msg);
+                throw new UnsupportedRepositoryOperationException(msg);
+            }
+
+
+
+    
+    /**
+     * Check that the updatable item state manager is in edit mode.
+     * 
+     * @throws IllegalStateException if it isn't
+     */
+    private void checkInEditMode() throws IllegalStateException {
+        if (!stateMgr.inEditMode()) {
+            throw new IllegalStateException("not in edit mode");
+        }
+    }
+    
+    /**
+     * Determines whether the specified node is <i>shareable</i>, i.e.
+     * whether the mixin type <code>mix:shareable</code> is either
+     * directly assigned or indirectly inherited.
+     *
+     * @param state node state to check
+     * @return true if the specified node is <i>shareable</i>, false otherwise.
+     * @throws ItemStateException if an error occurs
+     */
+    private boolean isShareable(NodeState state) throws RepositoryException {
+        // shortcut: check some wellknown built-in types first
+        Name primary = state.getNodeTypeName();
+        Set mixins = state.getMixinTypeNames();
+        if (mixins.contains(NameConstants.MIX_SHAREABLE)) {
+            return true;
+        }
+        // build effective node type
+        Name[] types = new Name[mixins.size() + 1];
+        mixins.toArray(types);
+        // primary type
+        types[types.length - 1] = primary;
+        
+        try {
+            return ntReg.getEffectiveNodeType(types).includesNodeType(NameConstants.MIX_REFERENCEABLE);
+        } catch (NodeTypeConflictException ntce) {
+            String msg = "internal error: failed to build effective node type for node "
+                    + state.getNodeId();
+            log.debug(msg);
+            throw new RepositoryException(msg, ntce);
+        }
+    }

INS26 INS26 INS40 INS40 INS31 INS31 INS31 INS29 INS83 INS43 INS42 INS44 INS44 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS8 INS29 INS83 INS39 INS42 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS60 INS60 INS60 INS60 INS60 INS25 INS21 INS25 INS25 INS21 INS21 INS21 INS41 INS21 INS65 INS65 INS42 MOV25 INS65 INS65 INS65 INS65 INS43 INS42 INS42 INS60 INS60 INS25 INS60 INS21 INS21 INS54 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS32 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS39 INS59 INS27 INS8 INS32 INS38 INS8 INS38 INS8 INS32 INS32 INS32 INS32 INS32 INS66 INS42 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS43 INS59 INS43 INS59 INS32 INS8 INS5 INS59 INS32 INS7 INS8 INS12 INS42 INS42 INS42 INS32 INS40 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS42 INS34 INS60 INS21 INS53 INS42 INS42 INS32 INS32 INS27 INS32 INS60 INS21 INS53 INS32 INS60 INS21 INS53 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS25 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS40 INS41 INS43 INS85 INS42 INS3 INS42 INS42 INS42 INS2 INS42 INS41 INS44 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS14 INS42 INS42 INS32 INS43 INS59 INS32 INS14 INS42 INS42 INS42 INS42 INS32 INS8 INS42 INS42 INS42 INS42 INS9 INS42 INS5 INS27 INS42 INS27 INS32 INS43 INS42 INS60 INS21 INS53 INS42 INS42 INS45 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS60 INS21 INS53 INS43 INS85 INS32 INS34 INS40 INS34 INS32 INS42 INS40 INS42 INS43 INS59 INS32 INS14 INS42 INS42 INS42 INS43 INS59 INS32 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS43 INS42 INS45 INS32 INS42 INS42 INS42 INS42
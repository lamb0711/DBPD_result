work in progress

- Restore: pass NodeState(s) and Path instead of NodeId(s)
- LockManager: make sure lockmanager only remembers workspace states
- LockManager: make sure operations are executed using workspace states
- LockManager: improve isLocked/getLock/checkIsLocked and respect locks that
have been accessed before.
- VersionManager: make sure operations are executed using workspace states
- VersionManager: add checkIsCheckedOut
- VersionManager: force manager to have a WorkspaceManager
- NodeReferences:
  > make interface package protected
  > clarify method naming
  > add implementation to WorkspaceItemStateFactory
  > add NodeReferences field to NodeState
  > TO_IMPROVE: references are currently always retrieve from the SPI.
- ItemStateManager + NodeReferences
  > rename interfaces methods
  > change method signature to take NodeState instead of NodeId
  > 'getReferences' returns the property states directly

- remove some JR DIFFs. 

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@432234 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.PropertyId;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.Collections;
+import java.util.Set;
+import java.util.HashSet;
-     * @see ItemStateManager#getNodeReferences(NodeId)
+     * @see ItemStateManager#getReferingStates(NodeState)
+     * @param nodeState
-    public NodeReferences getNodeReferences(NodeId id)
-            throws NoSuchItemStateException, ItemStateException {
-        // TODO: implement
-        return null;
+    public Collection getReferingStates(NodeState nodeState) throws ItemStateException {
+        if (hasReferingStates(nodeState)) {
+            Set refStates = new HashSet();
+            Iterator it =  nodeState.getNodeReferences().iterator();
+            while (it.hasNext()) {
+                PropertyId pId = (PropertyId) it.next();
+                refStates.add(getItemState(pId));
+            }
+            return Collections.unmodifiableCollection(refStates);
+        } else {
+            return Collections.EMPTY_SET;
+        }
-     * @see ItemStateManager#hasNodeReferences(NodeId)
+     * @see ItemStateManager#hasReferingStates(NodeState)
+     * @param nodeState
-    public boolean hasNodeReferences(NodeId id) {
-        // TODO: caching implement
-        return false;
+    public boolean hasReferingStates(NodeState nodeState) {
+        NodeReferences nr = nodeState.getNodeReferences();
+        return nr != null && !nr.isEmpty();

INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS43 UPD42 INS8 UPD42 INS65 INS42 UPD43 UPD42 INS25 INS65 UPD43 UPD42 INS60 INS42 UPD42 INS32 INS8 INS8 INS42 UPD42 MOV43 INS59 INS27 UPD42 INS42 INS42 INS60 INS60 INS61 INS41 MOV41 UPD42 INS42 INS32 INS27 INS38 UPD43 INS43 INS59 INS43 INS59 INS32 INS8 INS32 INS40 UPD43 INS42 INS42 INS42 INS33 INS32 UPD42 INS42 INS42 INS14 UPD42 MOV42 INS42 INS32 INS42 INS42 INS60 INS21 INS42 INS42 INS42 UPD42 INS42 INS42 INS43 INS32 INS42 INS43 INS59 INS32 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS32 INS43 INS32 INS42 INS42 INS42 INS42 INS42 DEL43 DEL33 DEL8 DEL9
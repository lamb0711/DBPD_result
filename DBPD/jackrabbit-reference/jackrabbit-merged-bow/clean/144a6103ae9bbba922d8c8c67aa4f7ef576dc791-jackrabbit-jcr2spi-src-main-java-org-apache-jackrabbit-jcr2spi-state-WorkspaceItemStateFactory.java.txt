JCR-1797: SPI: RepositoryService.getItemInfos should be allowed to return entries outside of the requested tree.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@794302 13f79535-47bb-0310-9956-ffa450edef68

-        NodeEntry parentEntry = nodeState.getNodeEntry();
+        // Assuming locality of the itemInfos, we keep an estimate of a parent entry.
+        // This reduces the part of the hierarchy to traverse. For large batches this
+        // optimization results in about 25% speed up.
+        NodeEntry approxParentEntry = nodeState.getNodeEntry();
-                createDeepNodeState((NodeInfo) info, parentEntry, infos);
+                approxParentEntry = createDeepNodeState((NodeInfo) info, approxParentEntry, infos).getNodeEntry();
-                createDeepPropertyState((PropertyInfo) info, parentEntry, infos);
+                createDeepPropertyState((PropertyInfo) info, approxParentEntry, infos);
-                Name name = missingElems[i].getName();
-                int index = missingElems[i].getNormalizedIndex();
-                entry = createIntermediateNodeEntry(entry, name, index, infos);
+                if (missingElems[i].denotesParent()) {
+                    // Walk up the hierarchy for 'negative' paths
+                    // until the smallest common root is found
+                    entry = entry.getParent();
+                }
+                else if (missingElems[i].denotesName()) {
+                    // Add missing elements starting from the smallest common root
+                    Name name = missingElems[i].getName();
+                    int index = missingElems[i].getNormalizedIndex();
+                    entry = createIntermediateNodeEntry(entry, name, index, infos);
+                }
+                // else denotesCurrent -> ignore
-                Name name = missingElems[i].getName();
-                int index = missingElems[i].getNormalizedIndex();
-                entry = createIntermediateNodeEntry(entry, name, index, infos);
+                if (missingElems[i].denotesParent()) {
+                    // Walk up the hierarchy for 'negative' paths
+                    // until the smallest common root is found
+                    entry = entry.getParent();
+                }
+                else if (missingElems[i].denotesName()) {
+                    // Add missing elements starting from the smallest common root
+                    Name name = missingElems[i].getName();
+                    int index = missingElems[i].getNormalizedIndex();
+                    entry = createIntermediateNodeEntry(entry, name, index, infos);
+                }
+                // else denotesCurrent -> ignore
-     * Returns true if the given <code>missingElems</code> start with a parent (..),
-     * a current (.) or the root element, in which case the info is not within
+     * Returns true if the given <code>missingElems</code> start with
+     * the root element, in which case the info is not within
-            return !missingElems[0].denotesName();
+            return missingElems[0].denotesRoot();

UPD66 UPD66 UPD42 INS8 INS8 MOV32 INS25 INS25 MOV21 UPD42 INS7 INS32 INS8 INS25 MOV32 INS8 INS25 INS42 INS32 UPD42 INS2 INS42 INS21 INS32 MOV8 UPD42 INS21 MOV32 INS8 MOV32 INS42 INS42 INS42 INS7 INS2 INS42 INS7 UPD42 MOV60 MOV60 MOV21 UPD42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS32 INS2 INS42 INS2 INS42 INS42 INS42 INS42 INS42 DEL8 DEL38
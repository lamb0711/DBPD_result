- Implement ItemState.revert() and use in SessionItemStateManager.undo()
- Removed some JR diffs

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@432582 13f79535-47bb-0310-9956-ffa450edef68

+     * Reverts all property and child node states that belong to this
+     * <code>NodeState</code> and finally reverts this <code>NodeState</code>.
+     *
+     * @inheritDoc
+     * @see ItemState#revert(Set)
+     */
+    public void revert(Set affectedItemStates) {
+        if (overlayedState == null) {
+            throw new IllegalStateException("revert cannot be called on workspace state");
+        }
+        // copy to new list, when a property is reverted it may call this node
+        // state to remove itself from properties.
+        List props = new ArrayList(properties.values());
+        for (Iterator it = props.iterator(); it.hasNext(); ) {
+            PropertyReference ref = (PropertyReference) it.next();
+            if (ref.isResolved()) {
+                try {
+                    PropertyState propState = ref.getPropertyState();
+                    propState.revert(affectedItemStates);
+                } catch (ItemStateException e) {
+                    // should not happen because PropertyReference is resolved
+                    log.warn("Unable to get PropertyState from resolved PropertyReference");
+                }
+            } else {
+                // not touched or accessed before
+            }
+        }
+
+        // revert property states in attic
+        props.clear();
+        props.addAll(propertiesInAttic.values());
+        for (Iterator it = props.iterator(); it.hasNext(); ) {
+            PropertyReference ref = (PropertyReference) it.next();
+            try {
+                PropertyState propState = ref.getPropertyState();
+                propState.revert(affectedItemStates);
+            } catch (ItemStateException e) {
+                // probably stale destroyed property
+                // cleaned up when propertiesInAttic is cleared
+            }
+        }
+        propertiesInAttic.clear();
+
+        // now revert child node states
+        List children = new ArrayList(childNodeEntries);
+        for (Iterator it = children.iterator(); it.hasNext(); ) {
+            ChildNodeReference ref = (ChildNodeReference) it.next();
+            if (ref.isResolved()) {
+                try {
+                    NodeState nodeState = ref.getNodeState();
+                    nodeState.revert(affectedItemStates);
+                } catch (ItemStateException e) {
+                    // should not happen because ChildNodeReference is resolved
+                    log.warn("Unable to get NodeState from resolved ChildNodeReference");
+                }
+            } else {
+                // not touched or accessed before
+            }
+        }
+
+        // now revert this node state
+        switch (status) {
+            case STATUS_EXISTING:
+                // nothing to do
+                break;
+            case STATUS_EXISTING_MODIFIED:
+            case STATUS_EXISTING_REMOVED:
+            case STATUS_STALE_MODIFIED:
+                // revert state from overlayed
+                pull();
+                setStatus(STATUS_EXISTING);
+                affectedItemStates.add(this);
+                break;
+            case STATUS_NEW:
+                // set removed
+                setStatus(STATUS_REMOVED);
+                // remove from parent
+                parent.childNodeStateRemoved(this);
+                affectedItemStates.add(this);
+                break;
+            case STATUS_REMOVED:
+                // shouldn't happen actually, because a 'removed' state is not
+                // accessible anymore
+                log.warn("trying to revert an already removed node state");
+                parent.childNodeStateRemoved(this);
+                break;
+            case STATUS_STALE_DESTROYED:
+                // overlayed state does not exist anymore
+                parent.childNodeStateRemoved(this);
+                affectedItemStates.add(this);
+                break;
+        }
+    }
+
+    /**

INS31 INS29 INS83 INS39 INS42 INS44 INS8 INS65 INS65 INS65 INS43 INS42 INS25 INS60 INS24 INS21 INS21 INS24 INS21 INS60 INS24 INS50 INS66 INS66 INS68 INS42 INS27 INS8 INS43 INS59 INS58 INS32 INS8 INS32 INS32 INS58 INS32 INS8 INS32 INS43 INS59 INS58 INS32 INS8 INS42 INS49 INS10 INS49 INS49 INS49 INS21 INS21 INS21 INS10 INS49 INS21 INS21 INS21 INS10 INS49 INS21 INS21 INS10 INS49 INS21 INS21 INS10 INS42 INS42 INS69 INS42 INS33 INS53 INS42 INS42 INS14 INS43 INS59 INS42 INS42 INS60 INS25 INS42 INS42 INS42 INS42 INS32 INS43 INS59 INS42 INS42 INS60 INS54 INS42 INS42 INS42 INS42 INS14 INS43 INS59 INS42 INS42 INS60 INS25 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS42 INS32 INS32 INS32 INS42 INS32 INS32 INS42 INS32 INS32 INS43 INS14 INS43 INS32 INS42 INS42 INS32 INS43 INS59 INS32 INS8 INS8 INS42 INS42 INS42 INS42 INS32 INS43 INS59 INS8 INS12 INS43 INS42 INS42 INS42 INS32 INS43 INS59 INS32 INS8 INS8 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS52 INS42 INS42 INS45 INS42 INS42 INS52 INS42 INS42 INS52 INS42 INS42 INS52 INS42 INS43 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS54 INS42 INS42 INS42 INS42 INS11 INS60 INS21 INS44 INS8 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS54 INS42 INS43 INS32 INS8 INS12 INS43 INS32 INS43 INS59 INS32 INS43 INS42 INS43 INS32 INS8 INS12 INS42 INS42 INS42 INS60 INS21 INS44 INS8 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS60 INS21 INS44 INS8 INS43 INS59 INS32 INS43 INS42 INS21 INS42 INS42 INS43 INS59 INS32 INS43 INS42 INS21 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS45
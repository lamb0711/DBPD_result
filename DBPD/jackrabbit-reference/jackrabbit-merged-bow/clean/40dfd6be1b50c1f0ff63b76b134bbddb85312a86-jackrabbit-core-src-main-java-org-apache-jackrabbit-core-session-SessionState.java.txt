JCR-2741: Improved logging for session operations

Restructure the SessionState code for more consistent handling and logging of operations.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@995004 13f79535-47bb-0310-9956-ffa450edef68

-                    + " for a trace of where the session was closed", closed);
+                    + " for a trace of where the session was closed.", closed);
-        LogState state = new LogState(
+        // Set MDC variables to reflect the current session and this operation
+        LogState logState = new LogState(
-            if (log.isDebugEnabled()) {
-                long start = System.nanoTime();
-                try {
-                    return internalPerform(operation);
-                } finally {
-                    log.debug("{} performed in {}ns",
-                            operation, System.nanoTime() - start);
+            // Acquire the exclusive lock for accessing session internals.
+            // No other session should be holding the lock, so we log a
+            // message to let the user know of such cases.
+            if (!lock.tryLock()) {
+                if (isWriteOperation
+                        && operation instanceof SessionWriteOperation) {
+                    log.warn("Attempt to perform {} while another thread"
+                            + " is concurrently modifying the session."
+                            + " Blocking until the other thread is finished"
+                            + " using this session.", operation);
+                } else {
+                    log.debug("Attempt to perform {} while another thread"
+                            + " is concurrently accessing the session."
+                            + " Blocking until the other thread is finished"
+                            + " using this session.", operation);
-            } else {
-                return internalPerform(operation);
+                lock.lock();
+            }
+
+            try {
+                // Check that the session is still alive
+                checkAlive();
+
+                // Raise the isWriteOperation flag for write operations.
+                // The flag is used to set the appropriate log level above.
+                boolean wasWriteOperation = isWriteOperation;
+                if (!wasWriteOperation
+                        && operation instanceof SessionWriteOperation) {
+                    isWriteOperation = true;
+                }
+                try {
+                    // Perform the actual operation, optionally with debug logs
+                    if (log.isDebugEnabled()) {
+                        log.debug("Performing {}", operation);
+                        long start = System.nanoTime();
+                        try {
+                            return operation.perform(context);
+                        } finally {
+                            log.debug("{} performed in {}ns",
+                                    operation, System.nanoTime() - start);
+                        }
+                    } else {
+                        return operation.perform(context);
+                    }
+                } finally {
+                    isWriteOperation = wasWriteOperation;
+                }
+            } finally {
+                lock.unlock();
-            state.reset();
+            logState.reset();
+        }
+    }
+
+    /**
+     * Closes this session.
+     *
+     * @return <code>true</code> if the session was closed, or
+     *         <code>false</code> if the session had already been closed
+     */
+    public boolean close() {
+        LogState logState = new LogState(
+                "jcr.session", context.toString(),
+                "jcr.operation", "close()");
+        try {
+            if (!lock.tryLock()) {
+                log.warn("Attempt to close a session while another thread is"
+                        + " concurrently accessing the session. Blocking until"
+                        + " the other thread is finished using this session.");
+                lock.lock();
+            }
+            try {
+                if (isAlive()) {
+                    closed = new Exception(
+                            "Stack trace of where " + context + " was closed");
+                    return true;
+                } else {
+                    log.warn("This session has already been closed. See the"
+                            + " chained exception for a trace of where the "
+                            + " session was closed.", closed);
+                    return false;
+                }
+            } finally {
+                lock.unlock();
+            }
+        } finally {
+            logState.reset();
-    /**
-     * The actual implementation of the {@link #perform(SessionOperation)}
-     * method, extracted since the public method is already filled with
-     * somewhat complex logging and timing logic.
-     *
-     * @param operation session operation
-     * @return the return value of the executed operation
-     * @throws RepositoryException if the operation fails or
-     *                             if the session has already been closed
-     */
-    private <T> T internalPerform(SessionOperation<T> operation)
-            throws RepositoryException {
-        if (!lock.tryLock()) {
-            if (isWriteOperation && operation instanceof SessionWriteOperation) {
-                log.warn("Attempt to perform {} while another thread is"
-                        + " concurrently modifying the session. Blocking until"
-                        + " the other thread is finished using this session.",
-                        operation);
-            } else {
-                log.debug("Attempt to perform {} while another thread is"
-                        + " concurrently accessing the session. Blocking until"
-                        + " the other thread is finished using this session.",
-                        operation);
-            }
-            lock.lock();
-        }
-        boolean wasWriteOperation = isWriteOperation;
-        if (!wasWriteOperation && operation instanceof SessionWriteOperation) {
-            isWriteOperation = true;
-        }
-        try {
-            checkAlive();
-            log.debug("Performing {}", operation);
-            return operation.perform(context);
-        } finally {
-            isWriteOperation = wasWriteOperation;
-            lock.unlock();
-        }
-    }
-
-    /**
-     * Closes this session.
-     *
-     * @return <code>true</code> if the session was closed, or
-     *         <code>false</code> if the session had already been closed
-     */
-    public boolean close() {
-        if (!lock.tryLock()) {
-            log.warn("Attempt to close a session while another thread is"
-                    + " concurrently accessing the session. Blocking until"
-                    + " the other thread is finished using this session.");
-            lock.lock();
-        }
-        try {
-            if (isAlive()) {
-                closed = new Exception();
-                return true;
-            } else {
-                log.warn("This session has already been closed", closed);
-                return false;
-            }
-        } finally {
-            lock.unlock();
-        }
-    }
-

MOV55 INS8 INS8 MOV60 INS54 INS60 INS54 INS8 INS8 INS43 INS59 MOV8 INS8 UPD42 INS25 INS54 INS21 INS42 INS42 INS14 INS21 MOV38 INS8 MOV8 INS8 INS32 INS43 INS45 INS32 INS45 INS45 INS32 INS25 MOV21 MOV21 MOV60 MOV25 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD45 MOV27 INS8 INS8 INS32 INS21 INS21 INS42 INS42 INS32 INS32 MOV7 INS42 INS42 INS27 INS42 INS42 INS42 INS27 INS42 MOV21 MOV41 INS27 INS45 INS45 INS45 INS45 INS45 INS45 INS45 INS45 INS27 INS45 INS45 INS45 UPD42 MOV42 INS45 INS42 INS45 INS42 UPD42 UPD42 DEL42 DEL42 DEL32 DEL66 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL73 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL45 DEL45 DEL45 DEL27 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL45 DEL45 DEL45 DEL27 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL31 DEL45
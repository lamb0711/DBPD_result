JCR-1745: Mark pending nodes in IndexingQueue directly in index

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@697873 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.fs.RandomAccessOutputStream;
-import java.io.OutputStreamWriter;
-import java.io.Writer;
-import java.io.BufferedOutputStream;
- * <code>IndexingQueueStore</code> implements the persistent store to keep
- * track of pending document in an indexing queue.
+ * <code>IndexingQueueStore</code> implements a store that keeps the uuids of
+ * nodes that are pending in the indexing queue. Until Jackrabbit 1.4 this store
+ * was also persisted to a {@link FileSystem}. Starting with 1.5 the pending
+ * nodes are marked directly in the index with a special field.
+ * See {@link FieldNames#REINDEXING_REQUIRED}.
-     * The file system where to write the pending document UUIDs.
+     * The file system from where to read pending document UUIDs.
-     * Non-null if we are currently writing to the file.
-     */
-    private Writer out;
-
-    /**
-     * @throws IOException if an error occurs while writing.
-    public void addUUID(String uuid) throws IOException {
-        writeEntry(ADD, uuid, getLog());
+    public void addUUID(String uuid) {
-     * @throws IOException if an error occurs while writing.
-    public void removeUUID(String uuid) throws IOException {
-        writeEntry(REMOVE, uuid, getLog());
+    public void removeUUID(String uuid) {
-     * Commits the pending changes to the file.
-     *
-     * @throws IOException if an error occurs while writing.
+     * Closes this queue store.
-    public void commit() throws IOException {
-        if (out != null) {
-            out.flush();
-            if (pending.size() == 0) {
-                out.close();
-                out = null;
-                // truncate log
-                try {
-                    fs.getOutputStream(fileName).close();
-                } catch (FileSystemException e) {
-                    // ignore
+    public void close() {
+        if (pending.isEmpty()) {
+            try {
+                if (fs.exists(fileName)) {
+                    fs.deleteFile(fileName);
+            } catch (FileSystemException e) {
+                log.warn("unable to delete " + fileName);
-    /**
-     * Flushes and closes this queue store.
-     *
-     * @throws IOException if an error occurs while writing.
-     */
-    public void close() throws IOException {
-        commit();
-        if (out != null) {
-            out.close();
-        }
-    }
-
-
-    /**
-     * Writes an entry to the log file.
-     *
-     * @param op     the operation. Either {@link #ADD} or {@link #REMOVE}.
-     * @param uuid   the uuid of the added or removed node.
-     * @param writer the writer where the entry is written to.
-     * @throws IOException if an error occurs when writing the entry.
-     */
-    private static void writeEntry(String op, String uuid, Writer writer) throws IOException {
-        StringBuffer buf = new StringBuffer(op);
-        buf.append(' ').append(uuid).append('\n');
-        writer.write(buf.toString());
-    }
-
-    /**
-     * Returns the writer to the log file.
-     *
-     * @return the writer to the log file.
-     * @throws IOException if an error occurs while opening the log file.
-     */
-    private Writer getLog() throws IOException {
-        if (out == null) {
-            // open file
-            try {
-                long len = 0;
-                if (fs.exists(fileName)) {
-                    len = fs.length(fileName);
-                }
-                RandomAccessOutputStream raos
-                        = fs.getRandomAccessOutputStream(fileName);
-                raos.seek(len);
-                // use buffering
-                out = new OutputStreamWriter(
-                        new BufferedOutputStream(raos, 1024),
-                        ENCODING);
-            } catch (FileSystemException e) {
-                if (out != null) {
-                    out.close();
-                    out = null;
-                }
-                throw Util.createIOException(e);
-            }
-        }
-        return out;
-    }

MOV31 INS29 INS42 INS23 INS65 INS29 INS83 INS83 MOV43 MOV59 UPD83 INS39 INS42 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 INS65 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 MOV65 MOV66 UPD65 MOV65 UPD42 MOV42 UPD66 UPD66 INS32 INS42 UPD42 INS42 INS42 MOV12 INS21 INS32 INS32 INS42 INS42 INS27 MOV42 UPD42 MOV42 MOV42 INS45 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL65 DEL29 DEL42 DEL42 DEL65 DEL29 DEL83 DEL83 DEL23 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL42 DEL32 DEL21 DEL42 DEL33 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL25 DEL8 DEL25 DEL8 DEL31 DEL66 DEL65 DEL42 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL32 DEL21 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL65 DEL42 DEL66 DEL42 DEL67 DEL65 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL13 DEL32 DEL42 DEL42 DEL32 DEL42 DEL13 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL33 DEL27 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL32 DEL7 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL34 DEL14 DEL42 DEL14 DEL7 DEL21 DEL42 DEL43 DEL42 DEL44 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL42 DEL33 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL53 DEL8 DEL12 DEL42 DEL41
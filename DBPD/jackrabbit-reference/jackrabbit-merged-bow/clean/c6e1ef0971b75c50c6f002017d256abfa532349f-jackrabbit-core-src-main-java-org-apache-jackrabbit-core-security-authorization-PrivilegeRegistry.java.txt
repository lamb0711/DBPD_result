JCR-2887 : Split PrivilegeRegistry in a per-session manager instance and a repository level registry [work in progress]

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1092723 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.spi.commons.iterator.Iterators;
-     * A custom privilege for which bits were not calculated
-     */
-    private static final int UNDEFINED = -1;
-
-    /**
-     * No privileges 
+     * No privileges
-    private final Map<Integer, Set<Name>> bitsToNames = new HashMap<Integer, Set<Name>>();
+    private final Map<PrivilegeBits, Set<Name>> bitsToNames = new HashMap<PrivilegeBits, Set<Name>>();
+    private PrivilegeBits nextBits = PrivilegeBits.getInstance(RETENTION_MNGMT).nextBits();
+
-     * and calls {@link PrivilegeManagerImpl#getPrivileges(int)}.
+     * and calls {@link PrivilegeManagerImpl#getPrivileges(PrivilegeBits)}.
-     * @deprecated Use {@link PrivilegeManagerImpl#getPrivileges(int)} instead.
+     * @deprecated Use {@link PrivilegeManagerImpl#getPrivileges(PrivilegeBits)} instead.
-        Set<Privilege> prvs = new PrivilegeManagerImpl(this, resolver).getPrivileges(bits);
+        Set<Privilege> prvs = new PrivilegeManagerImpl(this, resolver).getPrivileges(PrivilegeBits.getInstance(bits));
-                    bits |= createJcrWriteDefinition().bits;
+                    bits |= createJcrWriteDefinition().bits.longValue();
-                    bits |= createRepWriteDefinition(jcrWrite.bits).bits;
+                    bits |= createRepWriteDefinition(jcrWrite).bits.longValue();
+    public static int calculatePermissions(PrivilegeBits privs, PrivilegeBits parentPrivs, boolean isAllow, boolean protectsPolicy) {
+        return calculatePermissions(privs.longValue(), parentPrivs.longValue(), isAllow, protectsPolicy);
+    }
+
+    /**
+     * Build the permissions granted by evaluating the given privileges. Note,
+     * that only built-in privileges can be mapped to permissions. Any other
+     * privileges will be ignored.
+     *
+     * @param privs The privileges granted on the Node itself (for properties
+     * the ACL of the direct ancestor).
+     * @param parentPrivs The privileges granted on the parent of the Node. Not
+     * relevant for properties since it only is used to determine permissions
+     * on a Node (add_child_nodes, remove_child_nodes).
+     * @param isAllow <code>true</code> if the privileges are granted; <code>false</code>
+     * otherwise.
+     * @param protectsPolicy If <code>true</code> the affected item itself
+     * defines access control related information.
+     * @return the permissions granted evaluating the given privileges.
+     * @deprecated Use {@link #calculatePermissions(PrivilegeBits, PrivilegeBits, boolean, boolean)} instead.
+     */
+        return calculatePermissions((long) privs, (long) parentPrivs, isAllow, protectsPolicy);
+    }
+
+    private static int calculatePermissions(long privs, long parentPrivs, boolean isAllow, boolean protectsPolicy) {
-     * Calculates the bits of the specified definitions. Note, that custom
-     * privileges don't have a integer representation as they are not used
-     * for permission calculation.
-     *
-     * @param defs
-     * @return
-     */
-    int getBits(Definition[] defs) {
-        int bits = NO_PRIVILEGE;
-        for (Definition def : defs) {
-            bits |= def.bits;
-        }
-        return bits;
-    }
-
-    /**
-     * @param bits The privilege bits.
+     * @param privilegeBits The privilege bits.
-    Name[] getNames(int bits) {
-        if (bits <= NO_PRIVILEGE) {
+    Name[] getNames(PrivilegeBits privilegeBits) {
+        if (privilegeBits == null || privilegeBits.isEmpty()) {
-        } else if (bitsToNames.containsKey(bits)) {
+        } else if (bitsToNames.containsKey(privilegeBits)) {
-            Set<Name> ips = bitsToNames.get(bits);
+            Set<Name> ips = bitsToNames.get(privilegeBits);
+            long bits = privilegeBits.longValue();
-            int repWrite = registeredPrivileges.get(REP_WRITE_NAME).bits;
-            int jcrWrite = registeredPrivileges.get(NameConstants.JCR_WRITE).bits;
+            long repWrite = registeredPrivileges.get(REP_WRITE_NAME).bits.longValue();
+            long jcrWrite = registeredPrivileges.get(NameConstants.JCR_WRITE).bits.longValue();
+            // include matching custom privilege names
+            Set<Name> customNames = new HashSet<Name>();
+            Set<Definition> aggr = new HashSet<Definition>();
+            for (Definition def : registeredPrivileges.values()) {
+                if (def.isCustom && privilegeBits.includes(def.bits)) {
+                    customNames.add(def.name);
+                    if (!def.declaredAggregateNames.isEmpty()) {
+                        aggr.add(def);
+                    }
+                }
+            }
+            // avoid redundant entries in case of aggregate privileges.
+            for (Definition aggregate : aggr) {
+                customNames.removeAll(aggregate.declaredAggregateNames);
+            }
+            names.addAll(customNames);
+
+            // remember this resolution.
-                bitsToNames.put(bits, names);
+                bitsToNames.put(privilegeBits, names);
-            if (def.bits > NO_PRIVILEGE) {
-                bitsToNames.put(def.bits, Collections.singleton(def.name));
-            }
+            bitsToNames.put(def.bits, Collections.singleton(def.name));
-
+            bitsToNames.remove(all.bits);
+            
-            all = new Definition(NameConstants.JCR_ALL, false, allAggrNames, all.bits);
-            registeredPrivileges.put(NameConstants.JCR_ALL, all);
-            bitsToNames.put(all.bits, Collections.singleton(NameConstants.JCR_ALL));
+            PrivilegeBits allbits = PrivilegeBits.getInstance(all.bits);
+            for (Definition d : definitions.values()) {
+                allbits.add(d.bits);
+            }
+
+            Definition newAll = new Definition(NameConstants.JCR_ALL, false, allAggrNames, allbits.unmodifiable(), false);
+            registeredPrivileges.put(NameConstants.JCR_ALL, newAll);
+            bitsToNames.put(newAll.bits, Collections.singleton(NameConstants.JCR_ALL));
-        Definition repWrite = createRepWriteDefinition(jcrWrite.bits);
+        Definition repWrite = createRepWriteDefinition(jcrWrite);
-                definitions.put(name, new Definition(stub, NO_PRIVILEGE));
+                definitions.put(name, new Definition(stub, nextBits()));
-
-                int bts = NO_PRIVILEGE;
-                for (Name n : stub.declaredAggregateNames) {
-                    Definition aggr = null;
-                    if (registeredPrivileges.containsKey(n)) {
-                        aggr = registeredPrivileges.get(n);
-                    } else if (definitions.containsKey(n)) {
-                        aggr = definitions.get(n);
+                PrivilegeBits bts = getAggregateBits(stub.declaredAggregateNames, definitions);
+                if (!bts.isEmpty()) {
+                    // make sure the same aggregation is not yet covered by an
+                    // already registered privilege
+                    if (bitsToNames.containsKey(bts) && bitsToNames.get(bts).size() == 1) {
+                        Name existingName = bitsToNames.get(bts).iterator().next();
+                        throw new RepositoryException("Custom aggregate privilege '" + stub.name + "' is already covered by '" + existingName.toString() + "'");
-
-                    if (aggr == null) {
-                        // unknown dependency
-                        bts = UNDEFINED;
-                        break;
-                    } else if (!aggr.isCustom()) {
-                        throw new RepositoryException("Custom privileges may only aggregate custom privileges.");
-                    } // else: a known custom privilege -> try next.
-                }
-
-                if (bts == NO_PRIVILEGE) {
-                    Definition def = new Definition(stub, bts);
-
-                    // final validation if a custom aggregated has not yet been defined.
-                    Iterator<Definition> it = Iterators.iteratorChain(registeredPrivileges.values().iterator(), definitions.values().iterator());
-                    while (it.hasNext()) {
-                        Definition d = it.next();
-                        if (isEquivalentAggregate(d, def, definitions)) {
-                            throw new RepositoryException("Custom aggregate privilege '" + def.name + "' is already defined by '"+ d.name+"'");
+                    // ... nor is present within the set of definitions that have
+                    // been created before for registration.
+                    for (Definition d : definitions.values()) {
+                        if (bts.equals(d.bits)) {
+                            throw new RepositoryException("Custom aggregate privilege '" + stub.name + "' is already defined by '"+ d.name+"'");
+                    // now its save to create the new definition
+                    Definition def = new Definition(stub, bts);
-    private boolean isEquivalentAggregate(Definition d, Definition otherDef,
-                                          Map<Name, Definition> unregistered) {
-        // either of the definitions isn't an aggregate.
-        if (d.declaredAggregateNames.isEmpty() || otherDef.declaredAggregateNames.isEmpty()) {
-            return false;
-        }
-        // two aggregates that defined the same declared aggregate names
-        if (d.declaredAggregateNames.equals(otherDef.declaredAggregateNames)) {
-            return true;
-        }
-        // two aggregates that defined the same aggregation of simple definitions.
-        Set<Name> aggrNames = getAggrNames(d, unregistered);
-        Set<Name> otherAggrNames = getAggrNames(otherDef, unregistered);
-        return aggrNames.size() == otherAggrNames.size() && aggrNames.containsAll(otherAggrNames);
+    /**
+     *
+     * @return
+     */
+    private PrivilegeBits nextBits() {
+        PrivilegeBits b = nextBits;
+        nextBits = nextBits.nextBits();
+        return b;
-    private Set<Name> getAggrNames(Definition def, Map<Name, Definition> unregistered) {
-        Set<Name> names = new HashSet<Name>();
-        for (Name n : def.declaredAggregateNames) {
-            Definition a = (unregistered.containsKey(n)) ? unregistered.get(n) : registeredPrivileges.get(n);
-            if (a.declaredAggregateNames.isEmpty()) {
-                names.add(a.name);
+    /**
+     *
+     * @param declaredAggregateNames
+     * @param toRegister
+     * @return
+     */
+    private PrivilegeBits getAggregateBits(Set<Name> declaredAggregateNames, Map<Name, Definition> toRegister) {
+        PrivilegeBits bts = PrivilegeBits.getInstance();
+        for (Name n : declaredAggregateNames) {
+            if (registeredPrivileges.containsKey(n)) {
+                bts.add(registeredPrivileges.get(n).bits);
+            } else if (toRegister.containsKey(n)) {
+                Definition def = toRegister.get(n);
+                bts.add(def.bits);
-                names.addAll(getAggrNames(a, unregistered));
+                // unknown dependency (should not get here) -> return the empty set.
+                return PrivilegeBits.EMPTY;
-        return names;
+        return bts.unmodifiable();
-    private static Definition createRepWriteDefinition(int jcrWriteBits) {
+    private static Definition createRepWriteDefinition(Definition jcrWrite) {
-        int repWriteBits = jcrWriteBits | PRIVILEGE_NAMES.get(NameConstants.JCR_NODE_TYPE_MANAGEMENT);
+        long repWriteBits = jcrWrite.bits.longValue() | PRIVILEGE_NAMES.get(NameConstants.JCR_NODE_TYPE_MANAGEMENT);
-        private final int bits;
+        private final PrivilegeBits bits;
+        private final boolean isCustom;
-        private Definition(DefinitionStub stub, int bits) {
-            this(stub.name, stub.isAbstract, stub.declaredAggregateNames, bits);
+        private int hashCode;
+
+        private Definition(DefinitionStub stub, PrivilegeBits bits) {
+            this(stub.name, stub.isAbstract, stub.declaredAggregateNames, bits, true);
-        private Definition(Name name, boolean isAbstract, int bits) {
-            this(name, isAbstract, Collections.<Name>emptySet(), bits);
+        private Definition(Name name, boolean isAbstract, long bits) {
+            this(name, isAbstract, Collections.<Name>emptySet(), PrivilegeBits.getInstance(bits), false);
-        private Definition(Name name, boolean isAbstract, Set<Name> declaredAggregateNames, int bits) {
+        private Definition(Name name, boolean isAbstract, Set<Name> declaredAggregateNames, long bits) {
+            this(name, isAbstract, declaredAggregateNames, PrivilegeBits.getInstance(bits), false);
+        }
+
+        private Definition(Name name, boolean isAbstract, Set<Name> declaredAggregateNames, PrivilegeBits bits, boolean isCustom) {
-            if (bits < NO_PRIVILEGE) {
-                throw new IllegalArgumentException("Failed to build int representation of PrivilegeDefinition.");
+            if (bits == null || bits.isEmpty()) {
+                throw new IllegalArgumentException("Failed to build bit representation of PrivilegeDefinition.");
+            this.isCustom = isCustom;
+        PrivilegeBits getBits() {
+            return bits;
+        }
+
-        boolean isCustom() {
-            return bits == NO_PRIVILEGE;
+        //---------------------------------------------------------< Object >---
+        @Override
+        public int hashCode() {
+            if (hashCode == 0) {
+                int h = 17;
+                h = 37 * h + name.hashCode();
+                h = 37 * h + Boolean.valueOf(isAbstract).hashCode();
+                h = 37 * h + bits.hashCode();
+                hashCode = h;
+            }
+            return hashCode;
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (obj instanceof Definition) {
+                Definition other = (Definition) obj;
+                return name.equals(other.name)
+                        && isAbstract==other.isAbstract
+                        && bits.equals(other.bits);
+            }
+            return false;

MOV31 INS23 INS23 INS31 MOV29 UPD83 MOV83 MOV83 MOV83 MOV39 MOV59 UPD74 INS83 INS43 MOV59 MOV29 INS83 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS8 INS83 INS83 UPD42 MOV44 MOV44 INS44 UPD83 INS44 INS44 INS29 INS43 INS42 INS29 INS43 INS42 INS44 MOV44 INS23 INS23 INS23 INS31 INS31 INS31 UPD43 INS42 UPD42 INS32 INS43 INS42 INS43 INS42 INS39 INS42 INS39 INS42 INS41 INS65 INS65 INS65 INS65 INS39 UPD42 INS39 INS42 INS41 INS39 INS42 INS39 INS42 INS43 INS42 INS65 UPD42 MOV42 INS21 INS65 INS65 INS65 INS42 INS74 INS42 UPD42 UPD42 MOV83 MOV83 INS43 MOV59 INS83 INS83 INS39 INS59 INS83 MOV39 INS59 INS83 INS42 INS44 INS44 INS44 INS44 INS8 INS44 INS43 INS42 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 UPD42 INS44 INS8 UPD66 UPD42 UPD74 INS32 INS42 INS42 INS42 INS32 UPD66 UPD66 UPD66 UPD42 INS66 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS66 INS66 INS65 INS66 INS32 UPD42 INS42 UPD27 MOV8 INS43 INS7 INS42 INS42 INS42 MOV43 MOV43 INS43 MOV44 INS42 INS32 UPD39 INS42 INS42 INS42 INS43 UPD39 INS43 INS42 INS39 INS42 INS74 INS42 INS39 INS42 INS17 INS43 INS39 INS42 INS21 INS42 MOV41 INS42 INS25 INS41 INS42 INS43 INS42 MOV25 INS25 MOV41 UPD43 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS68 INS42 INS11 INS11 INS42 INS42 INS27 INS32 INS21 INS60 INS70 INS60 UPD42 MOV42 UPD42 INS42 INS42 INS32 UPD42 MOV42 UPD42 INS32 INS25 INS42 INS42 INS42 INS9 INS32 INS9 INS42 INS43 INS43 INS42 INS42 INS42 INS32 INS9 INS42 UPD27 INS7 INS27 INS8 INS42 INS42 INS27 INS62 INS8 UPD42 INS32 INS42 INS42 INS42 INS42 INS42 INS69 INS69 INS69 INS69 INS39 INS42 INS39 INS42 UPD42 MOV42 INS33 INS42 INS42 UPD42 INS60 INS60 INS60 INS70 INS70 INS21 INS32 INS43 INS59 INS44 INS32 INS8 INS43 INS59 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 MOV32 MOV8 INS25 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS32 INS22 INS42 INS42 INS34 INS60 INS21 INS21 INS21 INS21 INS42 INS52 INS42 INS43 INS60 MOV41 INS43 INS43 INS42 INS42 MOV42 INS43 INS43 INS39 INS39 INS39 INS59 UPD39 UPD39 MOV74 INS59 INS74 INS59 MOV44 INS32 INS8 INS44 INS42 INS8 INS32 INS42 INS42 INS40 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS21 INS42 INS42 INS14 UPD42 UPD40 INS60 INS25 INS32 INS8 MOV8 INS40 INS42 MOV42 INS33 INS42 INS42 INS52 INS42 INS39 INS59 INS7 INS7 INS7 INS7 INS42 MOV43 INS59 UPD27 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS42 INS14 INS43 INS43 INS42 INS14 INS42 INS42 INS25 INS43 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS32 MOV43 MOV40 MOV9 MOV42 INS32 INS9 INS43 INS59 INS38 INS8 INS32 UPD42 MOV42 MOV42 MOV42 INS60 MOV21 INS41 UPD45 INS42 INS34 INS42 INS27 INS42 INS27 INS42 INS27 INS42 INS42 INS42 INS11 INS27 INS32 UPD42 INS42 INS42 MOV22 INS42 MOV22 INS42 INS42 INS74 INS42 INS42 INS74 INS27 INS8 INS42 INS32 INS42 INS42 INS40 MOV42 INS42 INS42 INS42 MOV42 INS32 INS32 INS25 INS70 MOV60 MOV21 MOV21 INS42 INS42 INS22 MOV43 INS59 INS40 INS27 INS32 INS27 INS32 INS27 INS32 INS43 INS42 INS32 INS27 INS42 INS42 INS40 INS43 INS43 INS43 MOV43 INS40 INS32 INS21 INS25 INS42 INS42 INS40 UPD42 MOV43 INS32 INS42 INS40 INS42 UPD42 MOV42 UPD42 MOV42 INS27 INS8 MOV44 MOV32 INS8 MOV32 INS42 INS42 INS32 UPD42 UPD40 INS34 INS42 INS42 INS42 INS34 INS42 INS32 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS40 INS32 INS38 INS8 MOV42 INS42 INS32 INS27 MOV60 INS53 MOV25 UPD42 MOV42 MOV42 MOV42 INS42 INS42 INS42 INS32 INS42 INS42 INS40 INS32 INS21 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS32 INS34 INS43 INS14 MOV42 MOV22 INS42 INS32 INS40 INS42 INS32 INS32 INS42 UPD42 MOV42 UPD42 MOV43 INS27 UPD42 UPD42 INS40 INS22 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS45 INS40 INS45 INS32 INS45 MOV32 MOV42 UPD42 MOV42 UPD42 MOV42 MOV43 INS42 UPD42 INS42 UPD42 UPD40 DEL40 DEL26 DEL23 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL39 DEL23 DEL34 DEL38 DEL39 DEL39 DEL40 DEL22 DEL85 DEL5 DEL39 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL40 DEL7 DEL21 DEL8 DEL70 DEL39 DEL42 DEL42 DEL40 DEL42 DEL27 DEL25 DEL8 DEL42 DEL40 DEL14 DEL7 DEL21 DEL40 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL42 DEL42 DEL39 DEL42 DEL59 DEL60 DEL40 DEL42 DEL33 DEL59 DEL60 DEL42 DEL32 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL7 DEL21 DEL10 DEL8 DEL42 DEL42 DEL32 DEL38 DEL45 DEL14 DEL53 DEL8 DEL25 DEL25 DEL8 DEL70 DEL42 DEL42 DEL27 DEL32 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL61 DEL8 DEL25 DEL39 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL27 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL42 DEL32 DEL27 DEL74 DEL42 DEL42 DEL43 DEL42 DEL44 DEL43 DEL42 DEL43 DEL74 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL42 DEL43 DEL42 DEL44 DEL40 DEL42 DEL7 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL32 DEL36 DEL42 DEL42 DEL42 DEL32 DEL32 DEL16 DEL59 DEL60 DEL40 DEL42 DEL32 DEL8 DEL25 DEL42 DEL39 DEL42 DEL44 DEL42 DEL23 DEL39 DEL42 DEL39 DEL42 DEL40 DEL42 DEL40 DEL32 DEL42 DEL42 DEL8
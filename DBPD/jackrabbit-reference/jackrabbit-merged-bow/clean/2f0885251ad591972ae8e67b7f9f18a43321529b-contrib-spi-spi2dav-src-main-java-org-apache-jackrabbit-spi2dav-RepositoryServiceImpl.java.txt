Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.webdav.lock.ActiveLock;
+import org.apache.jackrabbit.name.MalformedPathException;
-    private static boolean isLockMethod(DavMethod method) {
+    private static boolean isUnLockMethod(DavMethod method) {
-        return DavMethods.DAV_LOCK == code || DavMethods.DAV_UNLOCK == code;
+        return DavMethods.DAV_UNLOCK == code;
-            initMethod(method, sessionInfo, !isLockMethod(method));
+            initMethod(method, sessionInfo, !isUnLockMethod(method));
+        nameSet.add(ItemResourceConstants.JCR_PATH);
+            Object type = propSet.get(DavPropertyName.RESOURCETYPE).getValue();
+            if (type == null) {
+                // the given id points to a Property instead of a Node
+                throw new ItemNotFoundException("No node for id " + nodeId);
+            }
+
+        } catch (MalformedPathException e) {
+            throw new RepositoryException(e);
+        nameSet.add(ItemResourceConstants.JCR_PATH);
+        nameSet.add(ItemResourceConstants.JCR_PATH);
-
+        } catch (MalformedPathException e) {
+            throw new RepositoryException(e);
+        nameSet.add(ItemResourceConstants.JCR_PARENT);
-                return new LockInfoImpl(LockDiscovery.createFromXml(p.toXml(domFactory)), nodeId);
-            } else {
+                LockDiscovery ld = LockDiscovery.createFromXml(p.toXml(domFactory));
+                NodeId parentId = getParentId(ps, sessionInfo);
+                return retrieveLockInfo(ld, sessionInfo, nodeId, parentId);
+            }  else {
-
-            return new LockInfoImpl(disc, nodeId);
+            return retrieveLockInfo(disc, sessionInfo, nodeId, null);
+    private LockInfo retrieveLockInfo(LockDiscovery lockDiscovery, SessionInfo sessionInfo,
+                                      NodeId nodeId, NodeId parentId)
+        throws LockException, RepositoryException {
+        List activeLocks = (List) lockDiscovery.getValue();
+        Iterator it = activeLocks.iterator();
+        ActiveLock activeLock = null;
+        while (it.hasNext()) {
+            ActiveLock l = (ActiveLock) it.next();
+            Scope sc = l.getScope();
+            if (l.getType() == Type.WRITE && (sc == Scope.EXCLUSIVE || sc == ItemResourceConstants.EXCLUSIVE_SESSION)) {
+                if (activeLock != null) {
+                    throw new RepositoryException("Node " + nodeId + " contains multiple exclusive write locks.");
+                } else {
+                    activeLock = l;
+                }
+            }
+        }
+        if (activeLock == null) {
+            throw new LockException("No lock present on node " + nodeId);
+        }
+        if (activeLock.isDeep() && parentId != null) {
+            // try if lock is inherited
+            try {
+                return getLockInfo(sessionInfo, parentId);
+            } catch (LockException e) {
+                // no lock on parent
+                return new LockInfoImpl(activeLock, nodeId);
+            }
+        }
+        // no deep lock or parentID == null or lock is not present on parent
+        // -> nodeID is lockHolding Id.
+        return new LockInfoImpl(activeLock, nodeId);
+    }
+

INS26 INS26 INS40 INS40 INS31 UPD42 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS43 INS43 INS8 INS21 INS21 INS21 INS21 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS60 INS60 INS60 INS61 INS25 INS25 INS41 MOV27 INS32 INS12 INS32 INS32 INS12 INS32 INS42 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS43 INS59 INS32 INS8 INS27 INS8 INS27 INS8 INS14 INS42 INS42 INS40 INS60 INS25 INS44 INS8 INS42 INS42 INS40 INS42 INS42 INS40 INS44 INS8 INS42 INS42 INS40 INS41 INS42 INS42 INS11 INS42 INS42 INS32 INS42 INS42 INS33 INS42 INS42 INS60 INS60 INS25 INS42 INS33 INS53 INS32 INS27 INS54 MOV43 INS42 INS42 INS43 INS59 INS27 INS8 INS43 INS42 INS53 INS43 INS42 INS53 INS32 INS43 INS32 INS42 INS42 INS43 INS59 INS43 INS59 INS27 INS8 INS14 INS42 INS42 INS42 INS33 INS8 INS12 INS42 INS42 INS32 INS42 INS33 INS53 INS42 INS14 INS42 INS14 INS60 INS60 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS32 INS27 INS36 INS25 INS43 INS27 INS41 INS44 INS8 INS32 INS42 INS14 INS43 INS42 INS43 INS42 INS43 INS59 INS43 INS59 INS32 INS43 INS32 INS42 INS42 INS32 INS40 INS27 INS27 INS8 INS8 INS42 INS45 INS42 INS32 INS43 INS42 MOV41 UPD42 INS42 INS42 INS40 INS43 INS27 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS27 INS42 INS33 INS53 INS21 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS40 INS14 INS7 UPD42 INS43 INS27 INS42 INS42 INS42 INS45 INS42 INS45 DEL40 DEL42 DEL27 DEL27 DEL42 DEL14
JCR-1516: Add Compact Namespace and Node Type Definition support to spi-commons

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@644745 13f79535-47bb-0310-9956-ffa450edef68

-package org.apache.jackrabbit.jcr2spi.nodetype;
+package org.apache.jackrabbit.spi.commons.nodetype;
-import org.apache.jackrabbit.spi.commons.conversion.IllegalNameException;
+import org.apache.jackrabbit.spi.NameFactory;
-import org.apache.jackrabbit.spi.commons.nodetype.InvalidConstraintException;
+    // TODO improve. don't rely on a specific factory impl
+    static final NameFactory NAME_FACTORY = NameFactoryImpl.getInstance();
+
+     * Check if the specified value matches the this constraint.
-     * @param value
-     * @throws ConstraintViolationException
-     * @throws RepositoryException
+     * @param value The value to be tested.
+     * @throws ConstraintViolationException If the specified value is
+     * <code>null</code> or does not matches the constraint.
+     * @throws RepositoryException If another error occurs.
-
-                return new NameConstraint(qualifiedDefinition);
+                return NameConstraint.create(qualifiedDefinition);
-                return new PathConstraint(qualifiedDefinition);
+                return PathConstraint.create(qualifiedDefinition);
-                return new ReferenceConstraint(qualifiedDefinition);
+                return ReferenceConstraint.create(qualifiedDefinition);
-                return new NameConstraint(definition, resolver);
+                return NameConstraint.create(definition, resolver);
-                return new PathConstraint(definition, resolver);
+                return PathConstraint.create(definition, resolver);
-                return new ReferenceConstraint(definition, resolver);
+                return ReferenceConstraint.create(definition, resolver);
+
-    PathConstraint(String qualifiedDefinition) {
-        super(qualifiedDefinition);
+    static PathConstraint create(String qualifiedDefinition) throws InvalidConstraintException {
-        deep = qualifiedDefinition.endsWith("*");
+        boolean deep = qualifiedDefinition.endsWith("*");
+        Path path;
-        path = PathFactoryImpl.getInstance().create(qualifiedDefinition);
+        if (deep) {
+            path = PathFactoryImpl.getInstance().create(qualifiedDefinition.substring(0, qualifiedDefinition.length() - 1));
+        } else {
+            path = PathFactoryImpl.getInstance().create(qualifiedDefinition);
+        }
+        return new PathConstraint(qualifiedDefinition, path, deep);
-    PathConstraint(String definition, PathResolver resolver)
+    static PathConstraint create(String definition, PathResolver resolver)
-        super(definition);
-
-        // constraint format: absolute or relative path with optional trailing wildcard
-        deep = definition.endsWith("*");
-        if (deep) {
-            // trim trailing wildcard before building path
-            definition = definition.substring(0, definition.length() - 1);
-        }
-            path = resolver.getQPath(definition);
+            StringBuffer qualifiedDefinition = new StringBuffer();
+            // constraint format: absolute or relative path with optional
+            // trailing wildcard
+            boolean deep = definition.endsWith("/*");
+            if (deep) {
+                // trim trailing wildcard before building path
+                if (definition.equals("/*")) {
+                    definition = "/";
+                    qualifiedDefinition.append('*');
+                } else {
+                    definition = definition.substring(0, definition.length() - 2);
+                    qualifiedDefinition.append("/*");
+                }
+            }
+            Path path = resolver.getQPath(definition);
+            qualifiedDefinition.insert(0, path.getString());
+
+            return new PathConstraint(qualifiedDefinition.toString(), path, deep);
+    private PathConstraint(String qualifiedDefinition, Path path, boolean deep) throws InvalidConstraintException {
+        super(qualifiedDefinition);
+        this.path = path;
+        this.deep = deep;
+    }
+
-     * Returns the String representation of the path.
-     *
-     * @return String representation of the path.
-     * @see ValueConstraint#getQualifiedDefinition()
-     */
-    public String getQualifiedDefinition() {
-        return path.toString();
-    }
-
-    /**
-    NameConstraint(String qualifiedDefinition) {
-        super(qualifiedDefinition);
+    static NameConstraint create(String qualifiedDefinition) {
-        // TODO improve. don't rely on a specific factory impl
-        name = NameFactoryImpl.getInstance().create(qualifiedDefinition);
+        return new NameConstraint(qualifiedDefinition, NAME_FACTORY.create(qualifiedDefinition));
-    NameConstraint(String definition, NameResolver resolver)
+    static NameConstraint create(String definition, NameResolver resolver)
-        super(definition);
-            name = resolver.getQName(definition);
+            Name name = resolver.getQName(definition);
+            return new NameConstraint(name.toString(), name);
-            String msg = "invalid name specified as value constraint: "
-                    + definition;
+            String msg = "Invalid name constraint: " + definition;
-            String msg = "invalid name specified as value constraint: "
-                    + definition;
+            String msg = "Invalid name constraint: " + definition;
+    private NameConstraint(String qualifiedDefinition, Name name) {
+        super(qualifiedDefinition);
+        this.name = name;
+    }
+
-     * Returns the String representation of the qualified name
-     *
-     * @return String representation of the qualified name
-     * @see ValueConstraint#getQualifiedDefinition()
-     */
-    public String getQualifiedDefinition() {
-        return name.toString();
-    }
-
-    /**
-    ReferenceConstraint(String qualifiedDefinition) {
-        super(qualifiedDefinition);
-        // format: qualified node type name
-        // TODO improve. don't rely on a specific factory impl
-        ntName = NameFactoryImpl.getInstance().create(qualifiedDefinition);
+    static ReferenceConstraint create(String qualifiedDefinition) {
+        // constraint format: String representation of qualified name
+        return new ReferenceConstraint(qualifiedDefinition, NAME_FACTORY.create(qualifiedDefinition));
-    ReferenceConstraint(String definition, NamePathResolver resolver) throws InvalidConstraintException {
-        super(definition);
-
-        // format: node type name
+    static ReferenceConstraint create(String definition, NameResolver resolver)
+            throws InvalidConstraintException {
+        // constraint format: JCR name in prefix form
-            ntName = resolver.getQName(definition);
-        } catch (IllegalNameException ine) {
-            String msg = "invalid node type name specified as value constraint: "
-                    + definition;
+            Name name = resolver.getQName(definition);
+            return new ReferenceConstraint(name.toString(), name);
+        } catch (NameException e) {
+            String msg = "Invalid name constraint: " + definition;
-            throw new InvalidConstraintException(msg, ine);
+            throw new InvalidConstraintException(msg, e);
-            String msg = "invalid node type name specified as value constraint: "
-                    + definition;
+            String msg = "Invalid name constraint: " + definition;
+    private ReferenceConstraint(String qualifiedDefinition, Name ntName) {
+        super(qualifiedDefinition);
+        this.ntName = ntName;
+    }
+
-     * qualified nodetype name into a JCR name.
+     * qualified <code>Name</code> into a JCR name.
-        } catch (NamespaceException npde) {
+        } catch (NamespaceException e) {
-     * Returns the String representation of the qualified nodetype name.
-     *
-     * @return String representation of the qualified nodetype name.
-     */
-    public String getQualifiedDefinition() {
-        return ntName.toString();
-    }
-
-    /**
+

MOV26 MOV31 MOV31 UPD40 UPD40 INS23 INS31 INS31 INS83 INS83 INS43 INS59 INS83 INS43 INS42 MOV44 INS43 INS8 INS83 INS43 INS42 UPD83 MOV83 INS42 INS44 INS44 INS44 INS43 MOV8 INS83 INS43 INS42 INS83 INS43 INS42 INS83 INS42 INS44 INS44 INS83 INS43 INS42 INS83 INS43 INS42 UPD83 INS42 INS44 INS44 INS42 INS42 MOV32 INS65 INS42 INS42 INS60 INS60 INS25 INS41 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS42 MOV46 INS21 INS21 INS42 INS41 INS42 MOV12 INS43 INS42 INS43 INS42 MOV46 INS21 INS42 INS41 INS42 UPD43 INS54 INS43 INS42 INS43 INS42 MOV46 INS21 INS42 INS66 INS66 INS66 INS66 INS66 INS39 INS59 INS43 INS59 INS42 INS8 MOV8 INS14 MOV42 INS42 INS7 INS7 INS14 MOV42 INS42 INS7 INS14 UPD42 INS8 MOV12 INS12 MOV42 INS42 INS7 UPD66 INS32 INS32 INS32 INS32 INS32 INS32 INS42 MOV32 INS42 INS42 INS21 MOV43 INS42 INS42 INS42 INS60 INS60 INS25 INS60 INS41 INS22 INS42 INS22 INS42 MOV43 INS42 INS32 INS60 INS41 MOV44 MOV44 INS22 INS42 MOV43 INS42 INS32 INS60 INS41 INS44 MOV44 MOV8 INS22 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS43 INS59 INS39 INS59 INS42 INS8 INS43 INS59 INS32 INS14 INS52 INS42 INS52 INS42 UPD42 MOV42 MOV42 MOV42 INS43 INS59 INS14 MOV21 INS52 INS42 UPD42 MOV42 MOV42 MOV42 INS43 INS59 INS14 INS43 INS42 MOV21 INS52 INS42 UPD42 INS42 INS32 INS42 INS42 INS14 INS42 INS32 MOV25 INS42 INS42 MOV32 INS42 INS42 INS34 INS32 MOV43 INS32 INS42 INS42 INS42 INS42 MOV32 MOV43 MOV32 INS42 MOV43 INS42 INS42 MOV32 MOV43 INS32 INS42 INS42 MOV43 INS32 INS42 INS32 INS43 INS42 INS42 INS45 INS32 INS8 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS34 INS27 INS42 INS42 INS42 INS45 INS21 INS21 INS21 UPD45 UPD45 UPD45 UPD45 INS32 INS34 INS7 INS32 INS32 INS42 INS42 INS42 INS45 INS42 INS42 INS13 INS42 INS42 INS45 UPD34 DEL40 DEL26 DEL42 DEL14 DEL42 DEL14 DEL42 DEL14 DEL42 DEL42 DEL14 DEL42 DEL42 DEL14 DEL42 DEL42 DEL14 DEL42 DEL7 DEL21 DEL42 DEL31 DEL42 DEL42 DEL46 DEL42 DEL42 DEL42 DEL45 DEL32 DEL7 DEL21 DEL42 DEL42 DEL7 DEL42 DEL42 DEL32 DEL41 DEL66 DEL65 DEL66 DEL65 DEL42 DEL42 DEL68 DEL65 DEL29 DEL43 DEL42 DEL31 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL46 DEL42 DEL7 DEL21 DEL66 DEL65 DEL66 DEL65 DEL42 DEL42 DEL68 DEL65 DEL29 DEL83 DEL43 DEL42 DEL41 DEL42 DEL42 DEL42 DEL32 DEL32 DEL7 DEL21 DEL42 DEL42 DEL46 DEL42 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL12 DEL54 DEL66 DEL65 DEL66 DEL65 DEL29 DEL43 DEL42 DEL42 DEL42 DEL32 DEL41
reduced potential lock contention

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@487589 13f79535-47bb-0310-9956-ffa450edef68

+import EDU.oswego.cs.dl.util.concurrent.ConcurrentReaderHashMap;
+
-    private final HashMap registeredNTDefs;
+    private final ConcurrentReaderHashMap registeredNTDefs;
-    private final HashMap propDefs;
+    private final ConcurrentReaderHashMap propDefs;
-    private final HashMap nodeDefs;
+    private final ConcurrentReaderHashMap nodeDefs;
-    public synchronized QName[] getRegisteredNodeTypes() {
+    public QName[] getRegisteredNodeTypes() {
-    public synchronized void unregisterNodeType(QName ntName)
+    public void unregisterNodeType(QName ntName)
-    public synchronized EffectiveNodeType getEffectiveNodeType(QName ntName)
+    public EffectiveNodeType getEffectiveNodeType(QName ntName)
-    public synchronized EffectiveNodeType getEffectiveNodeType(QName[] ntNames)
+    public EffectiveNodeType getEffectiveNodeType(QName[] ntNames)
-    public synchronized Set getDependentNodeTypes(QName nodeTypeName)
+    public Set getDependentNodeTypes(QName nodeTypeName)
-    public synchronized NodeTypeDef getNodeTypeDef(QName nodeTypeName)
+    public NodeTypeDef getNodeTypeDef(QName nodeTypeName)
-        if (!registeredNTDefs.containsKey(nodeTypeName)) {
+        NodeTypeDef def = (NodeTypeDef) registeredNTDefs.get(nodeTypeName);
+        if (def == null) {
-        NodeTypeDef def = (NodeTypeDef) registeredNTDefs.get(nodeTypeName);
-    public synchronized boolean isRegistered(QName nodeTypeName) {
+    public boolean isRegistered(QName nodeTypeName) {
-
-    public synchronized boolean isBuiltIn(QName nodeTypeName) {
+    public boolean isBuiltIn(QName nodeTypeName) {
-        registeredNTDefs = new HashMap();
-        propDefs = new HashMap();
-        nodeDefs = new HashMap();
+        registeredNTDefs = new ConcurrentReaderHashMap();
+        propDefs = new ConcurrentReaderHashMap();
+        nodeDefs = new ConcurrentReaderHashMap();
-                                                         EffectiveNodeTypeCache entCache,
-                                                         Map ntdCache)
+                                                  EffectiveNodeTypeCache entCache,
+                                                  Map ntdCache)
-        if (!ntdCache.containsKey(ntName)) {
+        NodeTypeDef ntd = (NodeTypeDef) ntdCache.get(ntName);
+        if (ntd == null) {
-        try {
-            NodeTypeDef ntd = (NodeTypeDef) ntdCache.get(ntName);
-            ent = EffectiveNodeType.create(ntd, entCache, ntdCache);
-            // store new effective node type
-            entCache.put(ent);
-            return ent;
-        } catch (NodeTypeConflictException ntce) {
-            // should never get here as all known node types should be valid!
-            String msg = "internal error: encountered invalid registered node type " + ntName;
-            log.debug(msg);
-            throw new NoSuchNodeTypeException(msg, ntce);
+        synchronized (entCache) {
+            try {
+                ent = EffectiveNodeType.create(ntd, entCache, ntdCache);
+                // store new effective node type
+                entCache.put(ent);
+                return ent;
+            } catch (NodeTypeConflictException ntce) {
+                // should never get here as all known node types should be valid!
+                String msg = "internal error: encountered invalid registered node type " + ntName;
+                log.debug(msg);
+                throw new NoSuchNodeTypeException(msg, ntce);
+            }
-                                                         EffectiveNodeTypeCache entCache,
-                                                         Map ntdCache)
+                                                  EffectiveNodeTypeCache entCache,
+                                                  Map ntdCache)
-
-        // build list of 'best' existing sub-aggregates
-        ArrayList tmpResults = new ArrayList();
-        while (key.getNames().length > 0) {
-            // check if we've already built this aggregate
-            if (entCache.contains(key)) {
-                tmpResults.add(entCache.get(key));
-                // subtract the result from the temporary key
-                // (which is 'empty' now)
-                key = key.subtract(key);
-                break;
-            }
-            /**
-             * walk list of existing aggregates sorted by 'weight' of
-             * aggregate (i.e. the cost of building it)
-             */
-            boolean foundSubResult = false;
-            Iterator iter = entCache.keyIterator();
-            while (iter.hasNext()) {
-                EffectiveNodeTypeCache.WeightedKey k =
-                        (EffectiveNodeTypeCache.WeightedKey) iter.next();
-                /**
-                 * check if the existing aggregate is a 'subset' of the one
-                 * we're looking for
-                 */
-                if (key.contains(k)) {
-                    tmpResults.add(entCache.get(k));
+        synchronized (entCache) {
+            // build list of 'best' existing sub-aggregates
+            ArrayList tmpResults = new ArrayList();
+            while (key.getNames().length > 0) {
+                // check if we've already built this aggregate
+                if (entCache.contains(key)) {
+                    tmpResults.add(entCache.get(key));
-                    key = key.subtract(k);
-                    foundSubResult = true;
+                    // (which is 'empty' now)
+                    key = key.subtract(key);
+                    break;
+                }
+                /**
+                 * walk list of existing aggregates sorted by 'weight' of
+                 * aggregate (i.e. the cost of building it)
+                 */
+                boolean foundSubResult = false;
+                Iterator iter = entCache.keyIterator();
+                while (iter.hasNext()) {
+                    EffectiveNodeTypeCache.WeightedKey k =
+                            (EffectiveNodeTypeCache.WeightedKey) iter.next();
+                    /**
+                     * check if the existing aggregate is a 'subset' of the one
+                     * we're looking for
+                     */
+                    if (key.contains(k)) {
+                        tmpResults.add(entCache.get(k));
+                        // subtract the result from the temporary key
+                        key = key.subtract(k);
+                        foundSubResult = true;
+                        break;
+                    }
+                }
+                if (!foundSubResult) {
+                    /**
+                     * no matching sub-aggregates found:
+                     * build aggregate of remaining node types through iteration
+                     */
+                    QName[] remainder = key.getNames();
+                    for (int i = 0; i < remainder.length; i++) {
+                        NodeTypeDef ntd = (NodeTypeDef) ntdCache.get(remainder[i]);
+                        EffectiveNodeType ent =
+                                EffectiveNodeType.create(ntd, entCache, ntdCache);
+                        // store new effective node type
+                        entCache.put(ent);
+                        if (result == null) {
+                            result = ent;
+                        } else {
+                            result = result.merge(ent);
+                            // store intermediate result (sub-aggregate)
+                            entCache.put(result);
+                        }
+                    }
+                    // add aggregate of remaining node types to result list
+                    tmpResults.add(result);
-            if (!foundSubResult) {
-                /**
-                 * no matching sub-aggregates found:
-                 * build aggregate of remaining node types through iteration
-                 */
-                QName[] remainder = key.getNames();
-                for (int i = 0; i < remainder.length; i++) {
-                    NodeTypeDef ntd = (NodeTypeDef) ntdCache.get(remainder[i]);
-                    EffectiveNodeType ent =
-                            EffectiveNodeType.create(ntd, entCache, ntdCache);
-                    // store new effective node type
-                    entCache.put(ent);
-                    if (result == null) {
-                        result = ent;
-                    } else {
-                        result = result.merge(ent);
-                        // store intermediate result (sub-aggregate)
-                        entCache.put(result);
-                    }
+            // merge the sub-aggregates into new effective node type
+            for (int i = 0; i < tmpResults.size(); i++) {
+                if (result == null) {
+                    result = (EffectiveNodeType) tmpResults.get(i);
+                } else {
+                    result = result.merge((EffectiveNodeType) tmpResults.get(i));
+                    // store intermediate result
+                    entCache.put(result);
-                // add aggregate of remaining node types to result list
-                tmpResults.add(result);
-                break;
-            }
-        }
-        // merge the sub-aggregates into new effective node type
-        for (int i = 0; i < tmpResults.size(); i++) {
-            if (result == null) {
-                result = (EffectiveNodeType) tmpResults.get(i);
-            } else {
-                result = result.merge((EffectiveNodeType) tmpResults.get(i));
-                // store intermediate result
-                entCache.put(result);
-                                     Stack inheritanceChain,
-                                     Map ntDefCache)
+                                            Stack inheritanceChain,
+                                            Map ntDefCache)

INS26 INS40 UPD43 UPD43 UPD43 MOV25 UPD42 UPD42 UPD42 MOV60 INS51 INS51 INS27 INS27 INS42 INS8 INS42 INS8 INS42 INS33 INS42 INS33 MOV54 MOV60 MOV61 MOV24 UPD43 UPD43 UPD43 UPD42 UPD42 UPD42 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL42 DEL42 DEL42 DEL32 DEL38 DEL83 DEL83 DEL42 DEL42 DEL42 DEL32 DEL38
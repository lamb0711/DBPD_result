- removed @author and @version (i.e. $Revision & $Id) tags
- removed tab characters from java source code

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@47648 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.lucene.search.FilteredTermEnum;
-import org.apache.lucene.index.Term;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.FilteredTermEnum;
- * @author Marcel Reutegger
- * @version $Revision:  $, $Date:  $
-	super(reader, term);
-	pattern = createRegexp(term.text());
+        super(reader, term);
+        pattern = createRegexp(term.text());
-	// FIXME optimize term enum. find start term text
-	setEnum(reader.terms(new Term(term.field(), "")));
+        // FIXME optimize term enum. find start term text
+        setEnum(reader.terms(new Term(term.field(), "")));
-	if (term.field() == field) {
-	    return pattern.matcher(term.text()).matches();
-	}
-	endEnum = true;
-	return false;
+        if (term.field() == field) {
+            return pattern.matcher(term.text()).matches();
+        }
+        endEnum = true;
+        return false;
-	return 1.0f;
+        return 1.0f;
-	return endEnum;
+        return endEnum;
-	// - escape all non alphabetic characters
-	// - escape constructs like \<alphabetic char> into \\<alphabetic char>
-	// - replace non escaped ? _ * % into . and .*
-	StringBuffer regexp = new StringBuffer();
-	boolean escaped = false;
-	for (int i = 0; i < likePattern.length(); i++) {
-	    if (likePattern.charAt(i) == '\\') {
-		if (escaped) {
-		    regexp.append("\\\\");
-		    escaped = false;
-		} else {
-		    escaped = true;
-		}
-	    } else {
-		if (Character.isLetter(likePattern.charAt(i))) {
-		    if (escaped) {
-			regexp.append("\\\\").append(likePattern.charAt(i));
-			escaped = false;
-		    } else {
-			regexp.append(likePattern.charAt(i));
-		    }
-		} else {
-		    if (escaped) {
-			regexp.append('\\').append(likePattern.charAt(i));
-			escaped = false;
-		    } else {
-			switch (likePattern.charAt(i)) {
-			    case '?':
-			    case '_':
-				regexp.append('.');
-				break;
-			    case '*':
-			    case '%':
-				regexp.append(".*");
-				break;
-			    default:
-				regexp.append('\\').append(likePattern.charAt(i));
-			}
-		    }
-		}
-	    }
-	}
-	return Pattern.compile(regexp.toString());
+        // - escape all non alphabetic characters
+        // - escape constructs like \<alphabetic char> into \\<alphabetic char>
+        // - replace non escaped ? _ * % into . and .*
+        StringBuffer regexp = new StringBuffer();
+        boolean escaped = false;
+        for (int i = 0; i < likePattern.length(); i++) {
+            if (likePattern.charAt(i) == '\\') {
+                if (escaped) {
+                    regexp.append("\\\\");
+                    escaped = false;
+                } else {
+                    escaped = true;
+                }
+            } else {
+                if (Character.isLetter(likePattern.charAt(i))) {
+                    if (escaped) {
+                        regexp.append("\\\\").append(likePattern.charAt(i));
+                        escaped = false;
+                    } else {
+                        regexp.append(likePattern.charAt(i));
+                    }
+                } else {
+                    if (escaped) {
+                        regexp.append('\\').append(likePattern.charAt(i));
+                        escaped = false;
+                    } else {
+                        switch (likePattern.charAt(i)) {
+                            case '?':
+                            case '_':
+                                regexp.append('.');
+                                break;
+                            case '*':
+                            case '%':
+                                regexp.append(".*");
+                                break;
+                            default:
+                                regexp.append('\\').append(likePattern.charAt(i));
+                        }
+                    }
+                }
+            }
+        }
+        return Pattern.compile(regexp.toString());

MOV26 MOV26 DEL66 DEL65 DEL66 DEL65
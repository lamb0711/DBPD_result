JCR-190: Caching in QueryHandler does not scale well

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@234492 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.TermDocs;
-import org.apache.lucene.document.Document;
-import java.util.HashSet;
-import java.util.Set;
-            return new DescendantSelfAxisScorer(searcher.getSimilarity(), reader);
+            CachingMultiReader index = (CachingMultiReader) reader;
+            return new DescendantSelfAxisScorer(searcher.getSimilarity(), index);
-        private final IndexReader reader;
+        private final CachingMultiReader reader;
-        private final BitSet hits;
+        private final BitSet contextHits;
-         * List of UUIDs of selected nodes by the context query
-         */
-        private Set contextUUIDs = null;
-
-        /**
+         * Set <code>true</code> once the sub contextHits have been calculated.
+         */
+        private boolean subHitsCalculated = false;
+
+        /**
-        protected DescendantSelfAxisScorer(Similarity similarity, IndexReader reader) {
+        protected DescendantSelfAxisScorer(Similarity similarity, CachingMultiReader reader) {
-            this.hits = new BitSet(reader.maxDoc());
+            // todo reuse BitSets?
+            this.contextHits = new BitSet(reader.maxDoc());
-                    String uuid = reader.document(nextDoc).get(FieldNames.UUID);
-                    if (contextUUIDs.contains(uuid)) {
+                    if (contextHits.get(nextDoc)) {
-                Document d = reader.document(nextDoc);
-                String parentUUID = d.get(FieldNames.PARENT);
-                while (parentUUID != null && !contextUUIDs.contains(parentUUID)) {
+                int parentDoc = reader.getParent(nextDoc);
+                while (parentDoc != -1 && !contextHits.get(parentDoc)) {
-                    TermDocs ancestor = reader.termDocs(new Term(FieldNames.UUID, parentUUID));
-                    try {
-                        if (ancestor.next()) {
-                            d = reader.document(ancestor.doc());
-                            parentUUID = d.get(FieldNames.PARENT);
-                            if (parentUUID.length() == 0) {
-                                parentUUID = null;
-                            }
-                        } else {
-                            parentUUID = null;
-                        }
-                    } finally {
-                        ancestor.close();
-                    }
+                    parentDoc = reader.getParent(parentDoc);
-                if (parentUUID != null) {
-                    // since current doc is a descendant of one of the context
-                    // docs we can promote uuid of doc to the context uuids
-                    contextUUIDs.add(d.get(FieldNames.UUID));
+
+                if (parentDoc != -1) {
+                    // since current parentDoc is a descendant of one of the context
+                    // docs we can promote parentDoc to the context hits
+                    contextHits.set(parentDoc);
+
-            if (contextUUIDs == null) {
-                contextUUIDs = new HashSet();
+            if (!subHitsCalculated) {
+
-                        // @todo maintain cache of doc id hierarchy
-                        hits.set(doc);
+                        contextHits.set(doc);
-                for (int i = hits.nextSetBit(0); i >= 0; i = hits.nextSetBit(i + 1)) {
-                    contextUUIDs.add(reader.document(i).get(FieldNames.UUID));
+
+                if (contextHits.isEmpty()) {
+                    // no need to execute sub scorer, context is empty
+                } else {
+                    subScorer.score(new HitCollector() {
+                        public void collect(int doc, float score) {
+                            subHits.set(doc);
+                        }
+                    });
-                // reuse for final hits
-                hits.clear();
-
-                subScorer.score(new HitCollector() {
-                    public void collect(int doc, float score) {
-                        subHits.set(doc);
-                    }
-                });
+                subHitsCalculated = true;

MOV23 UPD43 INS39 INS60 UPD42 UPD42 UPD42 INS9 UPD43 INS43 INS59 UPD66 UPD42 INS38 INS42 INS42 INS11 UPD42 INS42 INS25 INS43 INS42 UPD42 INS39 INS8 INS32 INS8 INS8 INS7 INS42 UPD42 MOV21 UPD42 INS38 UPD42 MOV42 INS42 MOV21 INS42 INS9 UPD42 UPD42 INS38 INS34 UPD42 UPD42 UPD42 INS34 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 UPD42 UPD42 MOV42 UPD42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL42 DEL43 DEL33 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL40 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL40 DEL32 DEL59 DEL60 DEL33 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL43 DEL40 DEL42 DEL14 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL40 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL33 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL33 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL33 DEL42 DEL40 DEL32 DEL42 DEL33 DEL27 DEL42 DEL42 DEL43 DEL14 DEL7 DEL21 DEL39 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL58 DEL42 DEL34 DEL27 DEL42 DEL42 DEL42 DEL34 DEL27 DEL32 DEL7 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL40 DEL32 DEL32 DEL21 DEL8 DEL24 DEL42 DEL42 DEL32
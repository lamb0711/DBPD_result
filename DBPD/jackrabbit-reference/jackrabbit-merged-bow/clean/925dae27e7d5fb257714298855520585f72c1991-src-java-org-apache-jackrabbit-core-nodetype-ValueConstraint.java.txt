- fixed value constraint handling as spec'ed
- misc. minor fixes

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@109221 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.BLOBFileValue;
-import org.apache.jackrabbit.core.InternalValue;
-import org.apache.jackrabbit.core.NamespaceResolver;
-import org.apache.jackrabbit.core.QName;
+import org.apache.jackrabbit.core.*;
-import javax.jcr.*;
+import javax.jcr.DateValue;
+import javax.jcr.PropertyType;
+import javax.jcr.RepositoryException;
+import javax.jcr.ValueFormatException;
+    /**
+     * Returns the original (raw) definition of this constraint.
+     *
+     * @return the original (raw) definition of this constraint.
+     */
-    public static ValueConstraint create(int type, String definition) throws InvalidConstraintException {
+    /**
+     * For constraints that are not namespace prefix mapping sensitive this
+     * method returns the same result as <code>{@link #getDefinition()}</code>.
+     * <p/>
+     * Those that are namespace prefix mapping sensitive (e.g.
+     * <code>NameConstraint</code>, <code>PathConstraint</code> and
+     * <code>ReferenceConstraint</code>) use the given <code>nsResolver</code>
+     * to reflect the current mapping in the returned value.
+     *
+     * @return the definition of this constraint.
+     */
+    public String getDefinition(NamespaceResolver nsResolver) {
+        return definition;
+    }
+
+    public static ValueConstraint create(int type, String definition,
+                                         NamespaceResolver nsResolver)
+            throws InvalidConstraintException {
-                // @todo implement NAME value constraint
-                //return new NameConstraint(definition, nsResolver);
-                return new StringConstraint(".*");
+                return new NameConstraint(definition, nsResolver);
-                // @todo implement PATH value constraint
-                //return new PathConstraint(definition, nsResolver);
-                return new StringConstraint(".*");
+                return new PathConstraint(definition, nsResolver);
-                // @todo implement REFERENCE value constraint
-                //return new ReferenceConstraint(definition, ntReg, nsResolver);
-                return new ReferenceConstraint(definition, null, null);
+                return new ReferenceConstraint(definition, nsResolver);
-    final Pattern pattern;
+    final Path path;
+    final boolean deep;
-    PathConstraint(String definition) throws InvalidConstraintException {
+    PathConstraint(String definition, NamespaceResolver nsResolver)
+            throws InvalidConstraintException {
-        // constraint format: regexp
+        // constraint format: absolute or relative path with optional trailing wildcard
+        deep = definition.endsWith("*");
+        if (deep) {
+            // trim trailing wildcard before building path
+            definition = definition.substring(0, definition.length() - 1);
+        }
-            pattern = Pattern.compile(definition);
-        } catch (PatternSyntaxException pse) {
-            String msg = "'" + definition + "' is not valid regular expression syntax";
-            log.error(msg, pse);
-            throw new InvalidConstraintException(msg, pse);
+            path = Path.create(definition, nsResolver, false);
+        } catch (MalformedPathException mpe) {
+            String msg = "invalid path expression specified as value constraint: " + definition;
+            log.error(msg, mpe);
+            throw new InvalidConstraintException(msg, mpe);
-    void check(String text) throws ConstraintViolationException {
-        if (text == null) {
-            throw new ConstraintViolationException("null value does not satisfy the constraint '" + definition + "'");
-        }
-        Matcher matcher = pattern.matcher(text);
-        if (!matcher.matches()) {
-            throw new ConstraintViolationException("'" + text + "' does not satisfy the constraint '" + definition + "'");
+    public String getDefinition(NamespaceResolver nsResolver) {
+        try {
+            String p = path.toJCRPath(nsResolver);
+            if (deep) {
+                return (path.denotesRoot() ? p + "*" : p + "/*");
+            } else {
+                return p;
+            }
+        } catch (NoPrefixDeclaredException npde) {
+            // should never get here, return raw definition as fallback
+            return definition;
-        // @todo check PATH value constraint (need a NamespaceResolver)
-        /*
-            Path p = (Path) value.internalValue();
-            check(p.toJCRPath(nsResolver));
-            return;
+                Path p = (Path) value.internalValue();
+                // normalize paths before comparing them
+                Path p0 = path.getNormalizedPath();
+                Path p1 = p.getNormalizedPath();
+                if (deep) {
+                    try {
+                        if (!p0.isAncestorOf(p1)) {
+                            throw new ConstraintViolationException(p + " does not satisfy the constraint '" + definition + "'");
+                        }
+                    } catch (MalformedPathException mpe) {
+                        // can't compare relative with absolute path
+                        throw new ConstraintViolationException(p + " does not satisfy the constraint '" + definition + "'");
+                    }
+                } else {
+                    // exact match required
+                    if (!p0.equals(p1)) {
+                        throw new ConstraintViolationException(p + " does not satisfy the constraint '" + definition + "'");
+                    }
+                }
+                return;
-            String msg = "PATH constraint can not be applied to value of type: " + PropertyType.nameFromValue(value.getType());
-            log.error(msg);
-            throw new RepositoryException(msg);
+                String msg = "PATH constraint can not be applied to value of type: " + PropertyType.nameFromValue(value.getType());
+                log.error(msg);
+                throw new RepositoryException(msg);
-        */
-        log.warn("validation of PATH constraint is not yet implemented");
-    final Pattern pattern;
+    final QName name;
-    NameConstraint(String definition) throws InvalidConstraintException {
+    NameConstraint(String definition, NamespaceResolver nsResolver)
+            throws InvalidConstraintException {
-        // constraint format: regexp
+        // constraint format: JCR name in prefix form
-            pattern = Pattern.compile(definition);
-        } catch (PatternSyntaxException pse) {
-            String msg = "'" + definition + "' is not valid regular expression syntax";
-            log.error(msg, pse);
-            throw new InvalidConstraintException(msg, pse);
+            QName.checkFormat(definition);
+            name = QName.fromJCRName(definition, nsResolver);
+        } catch (IllegalNameException ine) {
+            String msg = "invalid name specified as value constraint: " + definition;
+            log.error(msg, ine);
+            throw new InvalidConstraintException(msg, ine);
+        } catch (UnknownPrefixException upe) {
+            String msg = "invalid name specified as value constraint: " + definition;
+            log.error(msg, upe);
+            throw new InvalidConstraintException(msg, upe);
-    void check(String text) throws ConstraintViolationException {
-        if (text == null) {
-            throw new ConstraintViolationException("null value does not satisfy the constraint '" + definition + "'");
-        }
-        Matcher matcher = pattern.matcher(text);
-        if (!matcher.matches()) {
-            throw new ConstraintViolationException("'" + text + "' does not satisfy the constraint '" + definition + "'");
+    public String getDefinition(NamespaceResolver nsResolver) {
+        try {
+            return name.toJCRName(nsResolver);
+        } catch (NoPrefixDeclaredException npde) {
+            // should never get here, return raw definition as fallback
+            return definition;
-        // @todo check NAME value constraint (need a NamespaceResolver)
-        /*
-            QName name = (QName) value.internalValue();
-            check(name.toJCRName(nsResolver);
-            return;
+                QName n = (QName) value.internalValue();
+                if (!name.equals(n)) {
+                    throw new ConstraintViolationException(n + " does not satisfy the constraint '" + definition + "'");
+                }
+                return;
-            String msg = "NAME constraint can not be applied to value of type: " + PropertyType.nameFromValue(value.getType());
-            log.error(msg);
-            throw new RepositoryException(msg);
+                String msg = "NAME constraint can not be applied to value of type: " + PropertyType.nameFromValue(value.getType());
+                log.error(msg);
+                throw new RepositoryException(msg);
-        */
-        log.warn("validation of NAME constraint is not yet implemented");
-    final QName[] ntNames;
+    final QName ntName;
-    ReferenceConstraint(String definition, NodeTypeRegistry ntReg, NamespaceResolver nsResolver) throws InvalidConstraintException {
+    ReferenceConstraint(String definition, NamespaceResolver nsResolver) throws InvalidConstraintException {
-        // format: comma-separated list of node type names
-        String[] strings = definition.split(",\\s*");
-        ntNames = new QName[strings.length];
-        /*
-        for (int i = 0; i < strings.length; i++) {
-            // every node type specified must be registered
-            String s = strings[i];
-            try {
-            ntNames[i] = QName.fromJCRName(s, nsResolver);
-            } catch (UnknownPrefixException upe) {
-            String msg = "invalid node type specified as value constraint: " + s;
+        // format: node type name
+        try {
+            ntName = QName.fromJCRName(definition, nsResolver);
+        } catch (IllegalNameException ine) {
+            String msg = "invalid node type name specified as value constraint: " + definition;
+            log.error(msg, ine);
+            throw new InvalidConstraintException(msg, ine);
+        } catch (UnknownPrefixException upe) {
+            String msg = "invalid node type name specified as value constraint: " + definition;
-            }
-            try {
-            ntReg.getEffectiveNodeType(ntNames[i]);
-            } catch (Exception e) {
-            String msg = "invalid node type specified as value constraint: " + ntNames[i];
-            log.error(msg, e);
-            throw new InvalidConstraintException(msg, e);
-            }
-        */
-    QName[] getNodeTypeNames() {
-        return ntNames;
+    public String getDefinition(NamespaceResolver nsResolver) {
+        try {
+            return ntName.toJCRName(nsResolver);
+        } catch (NoPrefixDeclaredException npde) {
+            // should never get here, return raw definition as fallback
+            return definition;
+        }
-    void check(Node target) throws ConstraintViolationException {
-        if (target == null) {
-            throw new ConstraintViolationException("null value does not satisfy the constraint '" + definition + "'");
-        }
+    QName getNodeTypeName() {
+        return ntName;
-        // @todo check REFERENCE value constraint (need a session)
+        // @todo check REFERENCE value constraint (requires a session)
-            UUID targetUUID = (UUID) value.internalValue();
-            check(session.getNodeByUUID(targetUUID.toString()));
-            return;
+                UUID targetUUID = (UUID) value.internalValue();
+                NodeImpl targetNode = (NodeImpl) session.getNodeByUUID(targetUUID.toString());
+                if (!targetNode.isNodeType(ntName)) {
+                    throw new ConstraintViolationException("the node with uuid " + targetUUID + " does not satisfy the constraint '" + definition + "'");
+                }
+                return;
-            String msg = "REFERENCE constraint can not be applied to value of type: " + PropertyType.nameFromValue(value.getType());
-            log.error(msg);
-            throw new RepositoryException(msg);
+                String msg = "REFERENCE constraint can not be applied to value of type: " + PropertyType.nameFromValue(value.getType());
+                log.error(msg);
+                throw new RepositoryException(msg);

MOV26 UPD40 UPD40 UPD40 UPD40 UPD40 INS31 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS29 INS43 INS29 INS83 INS43 INS42 INS44 INS8 INS44 UPD43 INS83 INS39 INS59 INS44 INS83 MOV43 INS42 INS44 INS8 MOV39 MOV42 MOV44 MOV43 MOV43 INS8 UPD43 MOV42 MOV44 INS44 MOV43 INS8 INS83 INS43 INS42 MOV44 INS8 INS39 INS42 MOV44 MOV43 MOV43 INS8 INS43 MOV42 MOV44 MOV44 MOV43 INS8 INS83 INS43 INS42 MOV43 INS42 INS8 INS65 INS65 INS42 INS65 INS65 INS42 INS43 INS42 INS41 INS43 INS42 UPD42 UPD42 INS42 INS43 INS42 INS21 INS25 INS43 INS42 INS54 MOV25 INS50 UPD42 UPD42 INS43 INS42 MOV46 INS54 INS42 INS54 MOV25 INS50 INS42 UPD42 UPD43 UPD42 MOV46 INS54 INS42 UPD43 UPD42 INS54 INS41 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS42 INS42 INS7 INS42 INS8 INS42 INS8 INS12 INS32 INS49 INS60 INS60 INS60 INS25 INS41 INS49 INS60 INS21 INS53 INS42 MOV8 MOV12 INS12 INS8 INS12 INS32 INS49 INS60 INS25 INS41 INS49 INS60 INS21 INS53 UPD42 INS8 INS12 INS12 UPD42 INS8 INS12 INS42 INS68 INS42 INS32 INS21 INS60 INS25 INS44 INS8 INS42 INS42 INS40 INS43 INS59 INS43 INS59 INS43 INS59 INS42 INS8 INS8 MOV43 INS59 MOV32 INS14 INS21 INS44 INS8 INS41 INS44 INS8 INS42 INS42 INS40 MOV43 INS59 MOV38 MOV8 INS43 INS59 MOV32 INS14 INS21 INS44 INS8 INS44 INS8 INS41 INS44 INS8 INS42 UPD43 INS42 INS42 UPD43 INS42 INS42 INS42 INS42 INS42 INS45 INS7 UPD43 UPD42 MOV43 INS59 INS42 INS8 INS8 INS43 INS42 INS41 UPD42 MOV42 INS42 INS11 INS42 INS42 INS32 INS42 INS42 INS32 INS54 MOV25 INS42 INS27 UPD42 INS42 INS43 INS42 INS32 UPD43 UPD42 INS43 UPD42 MOV42 INS60 INS21 INS53 INS32 INS43 INS42 INS41 INS42 INS11 INS42 INS42 INS27 UPD42 INS42 INS43 INS42 INS7 INS43 INS42 MOV60 MOV21 INS53 INS43 INS42 INS60 INS21 INS53 INS32 INS43 INS42 INS41 UPD42 UPD42 INS42 INS32 UPD42 UPD42 MOV43 INS42 INS32 INS41 INS41 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS42 INS8 INS12 INS45 INS32 INS42 INS42 INS42 INS42 UPD42 UPD42 MOV43 INS42 MOV43 INS59 INS32 INS14 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 MOV43 INS32 UPD42 UPD42 INS42 INS45 INS32 INS42 INS42 INS32 INS42 INS43 INS32 INS14 INS42 INS43 INS59 INS32 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS27 UPD42 UPD42 INS42 INS9 UPD42 UPD42 INS42 INS42 INS42 INS36 INS42 INS42 INS42 INS42 MOV25 INS44 INS8 INS42 INS42 INS32 UPD42 UPD42 INS42 UPD42 UPD42 INS42 INS27 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 MOV43 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 UPD42 INS27 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS32 INS34 UPD45 INS16 INS38 INS43 INS42 INS53 UPD42 UPD42 INS42 INS42 INS42 UPD45 UPD45 MOV45 MOV42 UPD42 MOV42 UPD42 UPD45 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS32 INS27 INS27 INS32 UPD42 MOV42 INS14 MOV43 INS42 INS42 INS42 INS45 INS42 INS45 INS42 INS42 INS42 MOV43 INS27 UPD42 UPD45 MOV43 INS42 INS45 INS42 INS45 INS42 UPD45 DEL45 DEL45 DEL33 DEL33 DEL45 DEL42 DEL33 DEL27 DEL42 DEL43 DEL45 DEL45 DEL42 DEL44 DEL43 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL31 DEL39 DEL42 DEL42 DEL43 DEL21 DEL8 DEL31 DEL45 DEL45 DEL45 DEL54 DEL8 DEL31 DEL39 DEL42 DEL44 DEL42 DEL33 DEL27 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL43 DEL42 DEL32 DEL59 DEL60 DEL25 DEL8 DEL31 DEL39 DEL42 DEL42 DEL43 DEL21 DEL8 DEL31 DEL85 DEL5 DEL85 DEL5 DEL42 DEL42 DEL45 DEL32 DEL42 DEL85 DEL5 DEL40 DEL3 DEL7 DEL8 DEL31 DEL85 DEL5 DEL42 DEL42 DEL41 DEL8 DEL31 DEL39 DEL42 DEL42 DEL33 DEL27 DEL45 DEL42 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25
- added RepositoryImpl.createSession 
- working on Workspace methods (work in progress)

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@157258 13f79535-47bb-0310-9956-ffa450edef68

-     * @param nodePath
+     * @param parentId
+     * @param nodeName
-     * @throws PathNotFoundException
+     * @throws ItemNotFoundException
-    public void checkAddNode(Path nodePath, QName nodeTypeName)
+    public void checkAddNode(NodeId parentId, QName nodeName, QName nodeTypeName)
-            PathNotFoundException, ItemExistsException, RepositoryException {
+            ItemNotFoundException, ItemExistsException, RepositoryException {
+
+        NodeState parentState = getNodeState(parentId);
+
+        // 1. access rights
-
-        Path parentPath = nodePath.getAncestor(1);
-        NodeState parentState = getNodeState(parentPath);
-
-        // 1. check path & access rights
-
-        Path.PathElement nodeName = nodePath.getNameElement();
-        try {
-            // check access rights
-            if (!accessMgr.isGranted(parentState.getId(), AccessManager.READ)) {
-                throw new PathNotFoundException(hierMgr.safeGetJCRPath(parentPath));
-            }
-            if (!accessMgr.isGranted(parentState.getId(), AccessManager.WRITE)) {
-                throw new AccessDeniedException(hierMgr.safeGetJCRPath(parentPath) + ": not allowed to add child node");
-            }
-        } catch (ItemNotFoundException infe) {
-            String msg = "internal error: failed to check access rights for "
-                    + hierMgr.safeGetJCRPath(parentPath);
-            log.debug(msg);
-            throw new RepositoryException(msg, infe);
+        if (!accessMgr.isGranted(parentId, AccessManager.READ)) {
+            throw new ItemNotFoundException(hierMgr.safeGetJCRPath(parentId));
+        }
+        if (!accessMgr.isGranted(parentId, AccessManager.WRITE)) {
+            throw new AccessDeniedException(hierMgr.safeGetJCRPath(parentId)
+                    + ": not allowed to add child node");
-            throw new ConstraintViolationException(hierMgr.safeGetJCRPath(parentPath) + ": cannot add child node to protected parent node");
+            throw new ConstraintViolationException(hierMgr.safeGetJCRPath(parentId)
+                    + ": cannot add child node to protected parent node");
-        entParent.checkAddNodeConstraints(nodeName.getName(), nodeTypeName);
+        entParent.checkAddNodeConstraints(nodeName, nodeTypeName);
-                findApplicableDefinition(nodeName.getName(), nodeTypeName, parentState);
+                findApplicableDefinition(nodeName, nodeTypeName, parentState);
-        if (parentState.hasPropertyEntry(nodeName.getName())) {
+        if (parentState.hasPropertyEntry(nodeName)) {
-            throw new ItemExistsException(hierMgr.safeGetJCRPath(nodePath));
+            throw new ItemExistsException("cannot add child node '"
+                    + nodeName.getLocalName() + "' to "
+                    + hierMgr.safeGetJCRPath(parentId)
+                    + ": colliding with same-named existing property");
-        if (parentState.hasChildNodeEntry(nodeName.getName())) {
+        if (parentState.hasChildNodeEntry(nodeName)) {
-            NodeState.ChildNodeEntry entry = parentState.getChildNodeEntry(nodeName.getName(), 1);
+            NodeState.ChildNodeEntry entry = parentState.getChildNodeEntry(nodeName, 1);
-            ChildNodeDef conflictingTargetDef = ntReg.getNodeDef(conflictingState.getDefinitionId());
+            ChildNodeDef conflictingTargetDef =
+                    ntReg.getNodeDef(conflictingState.getDefinitionId());
-                throw new ItemExistsException(hierMgr.safeGetJCRPath(nodePath));
+                throw new ItemExistsException("cannot add child node '"
+                        + nodeName.getLocalName() + "' to "
+                        + hierMgr.safeGetJCRPath(parentId)
+                        + ": colliding with same-named existing node");
+     * @param parentPath
+     * @param nodeName
+     * @param nodeTypeName
+     * @throws ConstraintViolationException
+     * @throws AccessDeniedException
+     * @throws PathNotFoundException
+     * @throws ItemExistsException
+     * @throws RepositoryException
+     */
+    public void checkAddNode(Path parentPath, QName nodeName, QName nodeTypeName)
+            throws ConstraintViolationException, AccessDeniedException,
+            PathNotFoundException, ItemExistsException, RepositoryException {
+        NodeState parentState = getNodeState(parentPath);
+        checkAddNode((NodeId) parentState.getId(), nodeName, nodeTypeName);
+    }
+
+    /**
+     * @param nodeId
+     * @throws ConstraintViolationException
+     * @throws AccessDeniedException
+     * @throws ItemNotFoundException
+     * @throws RepositoryException
+     */
+    public void checkRemoveNode(NodeId nodeId)
+            throws ConstraintViolationException, AccessDeniedException,
+            ItemNotFoundException, RepositoryException {
+
+        NodeState targetState = getNodeState(nodeId);
+        if (targetState.getParentUUID() == null) {
+            // root or orphaned node
+            throw new ConstraintViolationException("cannot remove root node");
+        }
+        NodeId parentId = new NodeId(targetState.getParentUUID());
+        NodeState parentState = getNodeState(parentId);
+
+        // 1. access rights
+
+        AccessManager accessMgr = session.getAccessManager();
+        try {
+            if (!accessMgr.isGranted(targetState.getId(), AccessManager.READ)) {
+                throw new PathNotFoundException(hierMgr.safeGetJCRPath(nodeId));
+            }
+            if (!accessMgr.isGranted(targetState.getId(), AccessManager.REMOVE)) {
+                throw new AccessDeniedException(hierMgr.safeGetJCRPath(parentId)
+                        + ": not allowed to remove node");
+            }
+        } catch (ItemNotFoundException infe) {
+            String msg = "internal error: failed to check access rights for "
+                    + hierMgr.safeGetJCRPath(nodeId);
+            log.debug(msg);
+            throw new RepositoryException(msg, infe);
+        }
+
+        // 2. check node type constraints
+
+        NodeTypeRegistry ntReg = rep.getNodeTypeRegistry();
+        ChildNodeDef parentDef = ntReg.getNodeDef(parentState.getDefinitionId());
+        if (parentDef.isProtected()) {
+            throw new ConstraintViolationException(hierMgr.safeGetJCRPath(parentId)
+                    + ": cannot remove child node of protected parent node");
+        }
+        ChildNodeDef targetDef = ntReg.getNodeDef(targetState.getDefinitionId());
+        if (targetDef.isMandatory()) {
+            throw new ConstraintViolationException(hierMgr.safeGetJCRPath(nodeId)
+                    + ": cannot remove mandatory node");
+        }
+        if (targetDef.isProtected()) {
+            throw new ConstraintViolationException(hierMgr.safeGetJCRPath(nodeId)
+                    + ": cannot remove protected node");
+        }
+    }
+
+    /**
-            PathNotFoundException, LockException, RepositoryException {
-
-        AccessManager accessMgr = session.getAccessManager();
-
+            PathNotFoundException, RepositoryException {
-        Path parentPath = nodePath.getAncestor(1);
-        NodeState parentState = getNodeState(parentPath);
-
-        // 1. check path & access rights
-
-        try {
-            // check access rights
-            if (!accessMgr.isGranted(targetState.getId(), AccessManager.READ)) {
-                throw new PathNotFoundException(hierMgr.safeGetJCRPath(nodePath));
-            }
-            if (!accessMgr.isGranted(targetState.getId(), AccessManager.REMOVE)) {
-                throw new AccessDeniedException(hierMgr.safeGetJCRPath(parentPath) + ": not allowed to remove node");
-            }
-        } catch (ItemNotFoundException infe) {
-            String msg = "internal error: failed to check access rights for " + hierMgr.safeGetJCRPath(nodePath);
-            log.debug(msg);
-            throw new RepositoryException(msg, infe);
-        }
-
-        // 2. check node type constraints
-
-        NodeTypeRegistry ntReg = rep.getNodeTypeRegistry();
-        ChildNodeDef parentDef = ntReg.getNodeDef(parentState.getDefinitionId());
-        if (parentDef.isProtected()) {
-            throw new ConstraintViolationException(hierMgr.safeGetJCRPath(parentPath) + ": cannot remove child node of protected parent node");
-        }
-        ChildNodeDef targetDef = ntReg.getNodeDef(targetState.getDefinitionId());
-        if (targetDef.isMandatory()) {
-            throw new ConstraintViolationException(hierMgr.safeGetJCRPath(nodePath) + ": cannot remove mandatory node");
-        }
-        if (targetDef.isProtected()) {
-            throw new ConstraintViolationException(hierMgr.safeGetJCRPath(nodePath) + ": cannot remove protected node");
-        }
+        checkRemoveNode((NodeId) targetState.getId());
+     * @param id
+     * @return
+     * @throws ItemNotFoundException
+     * @throws RepositoryException
+     */
+    protected NodeState getNodeState(NodeId id)
+            throws ItemNotFoundException, RepositoryException {
+        try {
+            return (NodeState) stateMgr.getItemState(id);
+        } catch (NoSuchItemStateException nsise) {
+            throw new ItemNotFoundException(hierMgr.safeGetJCRPath(id));
+        } catch (ItemStateException ise) {
+            String msg = "internal error: failed to retrieve state of "
+                    + hierMgr.safeGetJCRPath(id);
+            log.debug(msg);
+            throw new RepositoryException(msg, ise);
+        }
+    }
+
+    /**
-        checkAddNode(destPath, srcState.getNodeTypeName());
+        checkAddNode(destParentPath, destName.getName(), srcState.getNodeTypeName());
-        // acquire session on other workspace (throws NoSuchWorkspaceException)
-        // @todo FIXME need to get session with same credentials as current
-        SessionImpl srcSession = rep.getSystemSession(srcWorkspace);
+        // create session on other workspace for current subject
+        // (may throw NoSuchWorkspaceException and AccessDeniedException)
+        SessionImpl srcSession =
+                rep.createSession(session.getSubject(), srcWorkspace);
-        // acquire session on other workspace (throws NoSuchWorkspaceException)
-        // @todo FIXME need to get session with same credentials as current
-        SessionImpl srcSession = rep.getSystemSession(srcWorkspace);
-
+        // create session on other workspace for current subject
+        // (may throw NoSuchWorkspaceException and AccessDeniedException)
+        SessionImpl srcSession =
+                rep.createSession(session.getSubject(), srcWorkspace);
-        checkAddNode(destPath, targetState.getNodeTypeName());
+        checkAddNode(destParentPath, destName.getName(), targetState.getNodeTypeName());
+

INS31 INS31 INS31 INS29 INS44 INS43 MOV60 MOV29 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS43 MOV43 INS43 INS43 INS8 INS29 INS44 UPD43 MOV60 MOV29 INS83 INS39 INS42 MOV44 INS43 INS43 MOV43 INS43 INS8 INS29 INS83 INS43 INS42 INS44 INS43 INS43 INS8 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 UPD43 UPD42 INS42 MOV25 MOV25 INS65 MOV43 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS42 INS42 MOV60 INS21 INS65 INS65 INS65 INS65 INS65 INS43 INS42 UPD42 INS60 INS25 INS42 INS42 INS42 MOV60 INS21 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS42 INS42 INS54 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD43 INS42 UPD42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS27 INS8 INS43 INS32 INS42 INS42 INS42 INS42 INS8 INS12 INS12 MOV43 MOV43 UPD42 UPD42 MOV42 MOV42 MOV42 INS42 INS11 INS42 INS42 INS42 INS42 INS32 INS32 INS33 INS53 INS42 UPD42 INS14 INS42 INS11 INS41 INS44 INS8 INS44 INS8 UPD42 INS32 UPD42 INS32 UPD42 UPD42 UPD42 MOV42 INS42 MOV42 INS43 MOV32 INS42 INS42 INS42 INS42 INS14 INS43 INS32 UPD42 INS43 INS32 INS11 INS43 INS42 INS53 INS43 INS42 INS60 MOV21 INS53 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 UPD43 INS27 INS42 INS43 INS45 INS42 UPD42 MOV42 UPD42 MOV42 MOV43 MOV43 INS42 INS42 INS42 INS43 INS32 INS42 INS14 INS42 MOV43 INS59 INS14 UPD42 MOV42 INS42 UPD42 MOV42 INS42 UPD42 UPD42 INS45 INS32 INS45 INS32 INS45 MOV42 INS42 INS42 INS42 INS42 INS42 INS43 INS32 INS42 INS27 INS43 INS42 INS42 UPD42 UPD42 INS42 INS42 MOV42 MOV42 UPD42 MOV42 INS27 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS45 INS32 INS42 INS45 INS32 INS45 INS32 INS45 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 MOV42 MOV42 UPD42 MOV42 UPD42 DEL34 DEL42 DEL32 DEL40 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL45 DEL42 DEL42 DEL42 DEL32 DEL27 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL32 DEL42 DEL32 DEL42 DEL32 DEL32 DEL34 DEL32
JCR-1799 updating events swallowed (CacheBehavior.OBSERVATION)   	
JCR-1783 incomplete changelog when combining move with removal of new destination parent

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@704361 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.List;
+import java.util.ArrayList;
-        if (!hasPendingChanges()) {
+        if (!transientStateMgr.hasPendingChanges()) {
-
-        ChangeLog changeLog = getChangeLog(state, true);
+        ChangeLog changeLog = transientStateMgr.getChangeLog(state, true);
-
-        try {
-            ChangeLog changeLog = getChangeLog(itemState, false);
-            if (!changeLog.isEmpty()) {
-                // let changelog revert all changes
-                changeLog.undo();
-                // remove transient states and related operations from the t-statemanager
-                transientStateMgr.dispose(changeLog);
-                changeLog.reset();
-            }
-        } catch (InvalidItemStateException e) {
-            // should never get here
-            String msg = "Unable to undo item.";
-            log.debug(msg);
-            throw new RepositoryException(e);
+        // short cut
+        if (!transientStateMgr.hasPendingChanges()) {
+            return;
+        }
+        ChangeLog changeLog = transientStateMgr.getChangeLog(itemState, false);
+        if (!changeLog.isEmpty()) {
+            // let changelog revert all changes
+            changeLog.undo();
+            // remove transient states and related operations from the t-statemanager
+            transientStateMgr.dispose(changeLog);
+            changeLog.reset();
-        addNodeState(parent, operation.getNodeName(), operation.getNodeTypeName(), operation.getUuid(), def, options);
+        List newStates = addNodeState(parent, operation.getNodeName(), operation.getNodeTypeName(), operation.getUuid(), def, options);
+        operation.addedState(newStates);
-        // unless new state got removed remember operation and mark parent modified.
-        if (!Status.isTerminal(state.getStatus())) {
-            transientStateMgr.addOperation(operation);
-            operation.getParentState().markModified();
-        }
+        
+        transientStateMgr.addOperation(operation);
+        operation.getParentState().markModified();
-        NodeEntry nEntry = (NodeEntry) nState.getHierarchyEntry();
+        NodeEntry nEntry = nState.getNodeEntry();
-        // new array of mixinNames to be set on the nodestate (and corresponding property state)
+        // assert the existence of the property entry and set the array of
+        // mixinNames to be set on the corresponding property state
-        if (mixinNames != null && mixinNames.length > 0) {
+        if (mixinNames.length > 0) {
-        } else {
+        } else if (mixinEntry != null) {
-            if (mixinEntry != null) {
-                PropertyState pState = mixinEntry.getPropertyState();
-                boolean newMixinState = pState.getStatus() == Status.NEW;
-                int options = ItemStateValidator.CHECK_LOCK | ItemStateValidator.CHECK_VERSIONING;
-                removeItemState(pState, options);
-                // only added the remove-mixin operation if it doesn't revert
-                // a previous 'add-mixin' (which has been removed automatically
-                // upon notification of removing the prop-state).
-                if (!newMixinState) {
-                    nState.markModified();
-                    transientStateMgr.addOperation(operation);
-                }
-            }
-        }
+            PropertyState pState = mixinEntry.getPropertyState();
+            boolean newMixinState = pState.getStatus() == Status.NEW;
+            int options = ItemStateValidator.CHECK_LOCK | ItemStateValidator.CHECK_VERSIONING;
+            removeItemState(pState, options);
+
+            nState.markModified();
+            transientStateMgr.addOperation(operation);
+        } // else: empty Name array and no mixin-prop-entry (should not occur)
-     * @param itemState
-     * @param throwOnStale Throws InvalidItemStateException if either the given
-     * <code>ItemState</code> or any of its decendants is stale and the flag is true.
-     * @return
-     * @throws InvalidItemStateException if a stale <code>ItemState</code> is
-     * encountered while traversing the state hierarchy. The <code>changeLog</code>
-     * might have been populated with some transient item states. A client should
-     * therefore not reuse the <code>changeLog</code> if such an exception is thrown.
-     * @throws RepositoryException if <code>state</code> is a new item state.
-     */
-    private ChangeLog getChangeLog(ItemState itemState, boolean throwOnStale) throws InvalidItemStateException, ConstraintViolationException, RepositoryException {
-        // build changelog for affected and decendant states only
-        ChangeLog changeLog = new ChangeLog(itemState);
-        // fail-fast test: check status of this item's state
-        if (itemState.getStatus() == Status.NEW) {
-            String msg = "Cannot save/revert an item with status NEW (" +itemState+ ").";
-            log.debug(msg);
-            throw new RepositoryException(msg);
-        }
-        if (throwOnStale && Status.isStale(itemState.getStatus())) {
-            String msg =  "Attempt to save/revert an item, that has been externally modified (" +itemState+ ").";
-            log.debug(msg);
-            throw new InvalidItemStateException(msg);
-        }
-        // collect transient/stale states that should be persisted or reverted
-        itemState.getHierarchyEntry().collectStates(changeLog, throwOnStale);
-
-        changeLog.collectOperations(transientStateMgr.getOperations());
-        changeLog.checkIsSelfContained();
-        return changeLog;
-    }
-
-    /**
-     *
-    private void addPropertyState(NodeState parent, Name propertyName,
+    private PropertyState addPropertyState(NodeState parent, Name propertyName,
-        transientStateMgr.createNewPropertyState(propertyName, parent, pDef, values, propertyType);
+        return transientStateMgr.createNewPropertyState(propertyName, parent, pDef, values, propertyType);
-    private void addNodeState(NodeState parent, Name nodeName, Name nodeTypeName,
+    private List addNodeState(NodeState parent, Name nodeName, Name nodeTypeName,
+        List addedStates = new ArrayList();
+
-        // state for consistency between 'addNode' and importXML // TODO review
+        // state for consistency between 'addNode' and importXML
+        addedStates.add(nodeState);
-            addPropertyState(nodeState, NameConstants.JCR_UUID, PropertyType.STRING, value, pDef, 0);
+            addedStates.add(addPropertyState(nodeState, NameConstants.JCR_UUID, PropertyType.STRING, value, pDef, 0));
-                    addPropertyState(nodeState, pd.getName(), pd.getRequiredType(), autoValue, pd, propOptions);
+                    addedStates.add(addPropertyState(nodeState, pd.getName(), pd.getRequiredType(), autoValue, pd, propOptions));
-            addNodeState(nodeState, nd.getName(), nd.getDefaultPrimaryType(), null, nd, opt);
+            addedStates.addAll(addNodeState(nodeState, nd.getName(), nd.getDefaultPrimaryType(), null, nd, opt));
+        return addedStates;

INS26 INS26 INS40 INS40 MOV8 MOV8 INS43 INS43 INS25 INS60 MOV60 MOV60 MOV21 INS42 INS41 INS42 INS60 INS21 INS41 INS38 INS8 INS43 INS59 INS32 MOV27 MOV25 MOV32 INS43 INS59 INS32 INS42 INS32 INS41 INS42 INS42 MOV32 INS42 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV42 UPD42 MOV42 MOV21 MOV21 INS43 INS32 INS32 INS42 INS42 INS42 MOV32 INS42 INS42 MOV32 INS32 INS42 INS42 MOV32 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL38 DEL25 DEL8 DEL42 DEL43 DEL32 DEL11 DEL42 DEL33 DEL27 DEL27 DEL42 DEL38 DEL8 DEL25 DEL8 DEL42 DEL65 DEL42 DEL66 DEL66 DEL65 DEL65 DEL42 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL40 DEL27 DEL42 DEL43 DEL42 DEL45 DEL42 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL27 DEL42 DEL43 DEL42 DEL45 DEL42 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL39 DEL21 DEL39
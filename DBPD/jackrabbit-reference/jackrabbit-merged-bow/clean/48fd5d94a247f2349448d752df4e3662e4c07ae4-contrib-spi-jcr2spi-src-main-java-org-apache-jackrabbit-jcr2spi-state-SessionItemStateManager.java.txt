work in progress

- removeVersion missing
- LockManager/VersionManager: should not rely on observation (todo added)
- Add Operation.persisted() (Impl. still missing) in analogy to ChangeLog.persisted.
- ItemImpl.refresh behaves according to CacheBehaviour flag.
- NodeState: fix classcastexception when accessing state from propertiesInAttic
- ItemState: rename 'refresh()' to 'reload()
- ItemState: move code common to PropertyState and NodeState to ItemState
- ItemState: rename 'reset' to 'merge'
- add common interface ChildItemEntry
- SessionItemStateManager: avoid traversing twice during 'undo'

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@477095 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.operation.RemoveVersion;
+import org.apache.commons.collections.iterators.IteratorChain;
-import java.util.LinkedHashSet;
-        ChangeLog changeLog = getChangeLog(state);
+        ChangeLog changeLog = getChangeLog(state, true);
-        }
-        // remove operations just processed
-        transientStateMgr.disposeOperations(changeLog.getOperations());
-        // now its save to clear the changeLog
-        changeLog.reset();
+            // remove states and operations just processed from the transient ISM
+            transientStateMgr.dispose(changeLog);
+            // now its save to clear the changeLog
+            changeLog.reset();
+        }
-        // check if self contained
-        ChangeLog changeLog = new ChangeLog(itemState);
-        collectTransientStates(itemState, changeLog, false);
-        changeLog.checkIsSelfContained();
-        changeLog.collectOperations(transientStateMgr.getOperations());
+        ChangeLog changeLog = getChangeLog(itemState, false);
+        if (!changeLog.isEmpty()) {
+            // now do it for real
+            // TODO: check if states are reverted in correct order
+            Iterator[] its = new Iterator[] {changeLog.addedStates(), changeLog.deletedStates(), changeLog.modifiedStates()};
+            IteratorChain chain = new IteratorChain(its);
+            while (chain.hasNext()) {
+                ItemState state = (ItemState) chain.next();
+                state.revert();
+            }
-        // now do it for real
-        Set affectedItemStates = new HashSet();
-        itemState.revert(affectedItemStates);
-
-        // remove all canceled operations
-        transientStateMgr.disposeOperations(changeLog.getOperations());
+            // remove transient states and related operations from the t-statemanager
+            transientStateMgr.dispose(changeLog);
+            changeLog.reset();
+        }
+     * @param throwOnStale Throws StaleItemStateException if either the given
+     * <code>ItemState</code> or any of its decendants is stale and the flag is true.
-     * @throws StaleItemStateException
-     * @throws ItemStateException
-     */
-    private ChangeLog getChangeLog(ItemState itemState) throws StaleItemStateException, ItemStateException, ConstraintViolationException {
-        // build changelog for affected and decendant states only
-        ChangeLog changeLog = new ChangeLog(itemState);
-        collectTransientStates(itemState, changeLog, true);
-        changeLog.collectOperations(transientStateMgr.getOperations());
-
-        changeLog.checkIsSelfContained();
-        return changeLog;
-    }
-
-    /**
-     * Builds a <code>ChangeLog</code> of transient (i.e. new, modified or
-     * deleted) item states that are within the scope of <code>state</code>.
-     *
-     *                                 encountered while traversing the state
-     *                                 hierarchy. The <code>changeLog</code>
-     *                                 might have been populated with some
-     *                                 transient item states. A client should
-     *                                 therefore not reuse the <code>changeLog</code>
-     *                                 if such an exception is thrown.
+     * encountered while traversing the state hierarchy. The <code>changeLog</code>
+     * might have been populated with some transient item states. A client should
+     * therefore not reuse the <code>changeLog</code> if such an exception is thrown.
-    private void collectTransientStates(ItemState state, ChangeLog changeLog, boolean throwOnStale)
-            throws StaleItemStateException, ItemStateException {
+    private ChangeLog getChangeLog(ItemState itemState, boolean throwOnStale) throws StaleItemStateException, ItemStateException, ConstraintViolationException {
+        // build changelog for affected and decendant states only
+        ChangeLog changeLog = new ChangeLog(itemState);
-        if (state.getStatus() == Status.NEW) {
-            String msg = LogUtil.safeGetJCRPath(state, nsResolver) + ": cannot save a new item.";
+        if (itemState.getStatus() == Status.NEW) {
+            String msg = "Cannot save an item with status NEW (" +LogUtil.safeGetJCRPath(itemState, nsResolver)+ ").";
-
-        if (throwOnStale && Status.isStale(state.getStatus())) {
-            String msg = LogUtil.safeGetJCRPath(state, nsResolver) + ": the item cannot be saved because it has been modified/removed externally.";
+        if (throwOnStale && Status.isStale(itemState.getStatus())) {
+            String msg =  "Attempt to save an item, that has been externally modified (" +LogUtil.safeGetJCRPath(itemState, nsResolver)+ ").";
+        // collect transient/stale states that should be persisted or reverted
+        itemState.collectStates(changeLog, throwOnStale);
-        // Set of transient states that should be persisted
-        Set transientStates = new LinkedHashSet();
-        state.collectTransientStates(transientStates);
-
-        for (Iterator it = transientStates.iterator(); it.hasNext();) {
-            ItemState transientState = (ItemState) it.next();
-            // fail-fast test: check status of transient state
-            switch (transientState.getStatus()) {
-                case Status.NEW:
-                    changeLog.added(transientState);
-                    break;
-                case Status.EXISTING_MODIFIED:
-                    changeLog.modified(transientState);
-                    break;
-                case Status.EXISTING_REMOVED:
-                    changeLog.deleted(transientState);
-                    break;
-                case Status.STALE_MODIFIED:
-                    if (throwOnStale) {
-                        String msg = transientState.getId() + ": the item cannot be saved because it has been modified externally.";
-                        log.debug(msg);
-                        throw new StaleItemStateException(msg);
-                    } else {
-                        changeLog.modified(transientState);
-                    }
-                case Status.STALE_DESTROYED:
-                    if (throwOnStale) {
-                        String msg = transientState.getId() + ": the item cannot be saved because it has been deleted externally.";
-                        log.debug(msg);
-                        throw new StaleItemStateException(msg);
-                    }
-                default:
-                    log.debug("unexpected state status (" + transientState.getStatus() + ")");
-                    // ignore
-                    break;
-            }
-        }
+        changeLog.collectOperations(transientStateMgr.getOperations());
+        changeLog.checkIsSelfContained();
+        return changeLog;
+    public void visit(RemoveVersion operation) throws VersionException, AccessDeniedException, ReferentialIntegrityException, RepositoryException {
+        throw new UnsupportedOperationException("Internal error: RemoveVersion cannot be handled by session ItemStateManager.");
+    }
+
-        // recursively remove the complete tree including the given node state.
+        // recursively remove the given state and all child states.
+            // TODO: defaults???

MOV26 INS26 UPD40 INS40 INS31 INS31 INS31 MOV29 MOV83 MOV39 MOV42 MOV44 MOV43 MOV43 INS8 MOV29 MOV83 MOV43 INS42 MOV44 MOV44 MOV43 MOV43 MOV43 INS8 INS83 INS39 INS42 INS44 INS43 INS43 INS43 INS43 INS8 MOV60 INS25 MOV65 UPD65 INS65 MOV60 MOV25 MOV25 MOV21 MOV21 MOV21 MOV41 INS43 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 MOV53 MOV43 INS38 INS8 INS42 UPD66 UPD66 UPD66 UPD66 UPD66 INS42 INS21 MOV21 INS32 INS32 INS60 MOV60 INS61 MOV21 MOV21 UPD42 UPD42 INS42 UPD42 UPD43 INS45 INS9 INS32 INS42 INS42 INS9 UPD42 MOV42 UPD42 MOV42 INS5 INS59 UPD43 INS32 INS8 UPD42 UPD42 INS42 INS42 INS42 INS43 INS85 INS42 INS3 UPD42 UPD42 INS42 INS42 INS60 MOV21 UPD42 MOV42 UPD42 UPD42 UPD42 INS42 INS5 INS4 UPD43 INS42 MOV43 INS59 INS45 UPD45 INS45 UPD45 MOV43 INS85 INS32 INS32 INS32 UPD42 INS42 INS11 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV43 INS32 INS42 INS42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL43 DEL42 DEL43 DEL42 DEL14 DEL42 DEL42 DEL32 DEL42 DEL9 DEL42 DEL9 DEL32 DEL21 DEL32 DEL21 DEL32 DEL32 DEL21 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL42 DEL65 DEL42 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL43 DEL8 DEL31 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL32 DEL40 DEL49 DEL42 DEL42 DEL42 DEL32 DEL21 DEL10 DEL40 DEL49 DEL42 DEL42 DEL42 DEL32 DEL21 DEL10 DEL40 DEL49 DEL42 DEL42 DEL42 DEL32 DEL21 DEL10 DEL40 DEL49 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL43 DEL42 DEL14 DEL53 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL40 DEL49 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL49 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL45 DEL27 DEL32 DEL21 DEL10 DEL50 DEL8 DEL24 DEL8 DEL31 DEL42
JCR-1564: JSR 283 namespace handling
    - JSR 283 -based namespace handling in AbstractSession

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@655567 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import javax.jcr.NamespaceException;
+import javax.jcr.NamespaceRegistry;
+import org.apache.jackrabbit.util.XMLChar;
+     * Local namespace mappings. Prefixes as keys and namespace URIs as values.
+     */
+    private final Map namespaces = new HashMap();
+
+    //------------------------------------------------< Namespace handling >--
+
+    /**
+     * Returns the namespace prefix mapped to the given URI. The mapping is
+     * added to the set of session-local namespace mappings unless it already
+     * exists there.
+     * <p>
+     * This behaviour is based on JSR 283 (JCR 2.0), but remains backwards
+     * compatible with JCR 1.0.
+     *
+     * @param uri namespace URI
+     * @return namespace prefix
+     * @throws NamespaceException if the namespace is not found
+     * @throws RepositoryException if a repository error occurs
+     */
+    public String getNamespacePrefix(String uri)
+            throws NamespaceException, RepositoryException {
+        Iterator iterator = namespaces.entrySet().iterator();
+        while (iterator.hasNext()) {
+            Map.Entry entry = (Map.Entry) iterator.next();
+            if (entry.getValue().equals(uri)) {
+                return (String) entry.getKey();
+            }
+        }
+
+        // The following throws an exception if the URI is not found, that's OK
+        String prefix = getWorkspace().getNamespaceRegistry().getPrefix(uri);
+
+        // Generate a new prefix if the global mapping is already taken
+        String base = prefix;
+        for (int i = 2; namespaces.containsKey(prefix); i++) {
+            prefix = base + i;
+        }
+
+        namespaces.put(prefix, uri);
+        return prefix;
+    }
+
+    /**
+     * Returns the namespace URI mapped to the given prefix. The mapping is
+     * added to the set of session-local namespace mappings unless it already
+     * exists there.
+     * <p>
+     * This behaviour is based on JSR 283 (JCR 2.0), but remains backwards
+     * compatible with JCR 1.0.
+     *
+     * @param prefix namespace prefix
+     * @return namespace URI
+     * @throws NamespaceException if the namespace is not found
+     * @throws RepositoryException if a repository error occurs
+     */
+    public String getNamespaceURI(String prefix)
+            throws NamespaceException, RepositoryException {
+        String uri = (String) namespaces.get(prefix);
+
+        if (uri == null) {
+            // Not in local mappings, try the global ones
+            uri = getWorkspace().getNamespaceRegistry().getURI(prefix);
+            if (namespaces.containsValue(uri)) {
+                // The global URI is locally mapped to some other prefix,
+                // so there are no mappings for this prefix
+                throw new NamespaceException("Namespace not found: " + prefix);
+            }
+            // Add the mapping to the local set, we already know that
+            // the prefix is not taken
+            namespaces.put(prefix, uri);
+        }
+
+        return uri;
+    }
+
+    /**
+     * Returns the prefixes of all known namespace mappings. All global
+     * mappings not already included in the local set of namespace mappings
+     * are added there.
+     * <p>
+     * This behaviour is based on JSR 283 (JCR 2.0), but remains backwards
+     * compatible with JCR 1.0.
+     *
+     * @return namespace prefixes
+     * @throws RepositoryException if a repository error occurs
+     */
+    public String[] getNamespacePrefixes() throws RepositoryException {
+        NamespaceRegistry registry = getWorkspace().getNamespaceRegistry();
+        String[] uris = registry.getURIs();
+        for (int i = 0; i < uris.length; i++) {
+            getNamespacePrefix(uris[i]);
+        }
+
+        return (String[])
+            namespaces.keySet().toArray(new String[namespaces.size()]);
+    }
+
+    /**
+     * Modifies the session local namespace mappings to contain the given
+     * prefix to URI mapping.
+     * <p>
+     * This behaviour is based on JSR 283 (JCR 2.0), but remains backwards
+     * compatible with JCR 1.0.
+     *
+     * @param prefix namespace prefix
+     * @param uri namespace URI
+     * @throws NamespaceException if the mapping is illegal
+     * @throws RepositoryException if a repository error occurs
+     */
+    public void setNamespacePrefix(String prefix, String uri)
+            throws NamespaceException, RepositoryException {
+        if (prefix == null) {
+            throw new IllegalArgumentException("Prefix must not be null");
+        } else if (uri == null) {
+            throw new IllegalArgumentException("Namespace must not be null");
+        } else if (prefix.length() == 0) {
+            throw new NamespaceException(
+                    "Empty prefix is reserved and can not be remapped");
+        } else if (uri.length() == 0) {
+            throw new NamespaceException(
+                    "Default namespace is reserved and can not be remapped");
+        } else if (prefix.toLowerCase().startsWith("xml")) {
+            throw new NamespaceException(
+                    "XML prefixes are reserved: " + prefix);
+        } else if (!XMLChar.isValidNCName(prefix)) {
+            throw new NamespaceException(
+                    "Prefix is not a valid XML NCName: " + prefix);
+        }
+
+        // FIXME Figure out how this should be handled
+        // Currently JSR 283 does not specify this exception, but for
+        // compatibility with JCR 1.0 TCK it probably should.
+        // Note that the solution here also affects the remove() code below
+        String previous = (String) namespaces.get(prefix);
+        if (previous != null && !previous.equals(uri)) {
+            throw new NamespaceException("Namespace already mapped");
+        }
+
+        namespaces.remove(prefix);
+        Iterator iterator = namespaces.entrySet().iterator();
+        while (iterator.hasNext()) {
+            Map.Entry entry = (Map.Entry) iterator.next();
+            if (entry.getValue().equals(uri)) {
+                iterator.remove();
+            }
+        }
+
+        namespaces.put(prefix, uri);
+    }
+
+    //---------------------------------------------< XML export and import >--
+
+    /**
+    //-----------------------------------------------------< Item handling >--
+
+    //--------------------------------------------------< Session handling >--
+

INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS31 INS31 INS31 INS31 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS43 INS42 INS44 INS43 INS43 INS8 INS29 INS83 INS43 INS42 INS44 INS43 INS43 INS8 INS29 INS83 INS5 INS42 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS43 INS43 INS8 INS65 INS42 INS42 INS14 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS42 INS42 INS60 INS61 INS60 INS60 INS24 INS21 INS41 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS42 INS42 INS60 INS25 INS41 INS65 INS65 INS65 INS43 INS85 INS42 INS60 INS60 INS24 INS41 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS42 INS42 INS25 INS60 INS25 INS21 INS60 INS61 INS21 INS66 INS43 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS43 INS59 INS32 INS8 INS43 INS59 INS43 INS59 INS58 INS32 INS37 INS8 INS32 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS43 INS59 INS27 INS8 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS43 INS59 INS5 INS59 INS58 INS27 INS37 INS8 INS11 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS27 INS8 INS25 INS43 INS59 INS27 INS8 INS32 INS43 INS59 INS32 INS8 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS60 INS25 INS42 INS42 INS32 INS42 INS42 INS42 INS39 INS59 INS42 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS33 INS21 INS25 INS21 INS42 INS42 INS32 INS43 INS85 INS42 INS32 INS39 INS59 INS42 INS40 INS42 INS21 INS5 INS32 INS42 INS33 INS53 INS27 INS8 INS25 INS42 INS42 INS11 INS27 INS38 INS53 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS60 INS25 INS42 INS42 INS42 INS42 INS32 INS42 INS43 INS59 INS32 INS8 INS32 INS42 INS42 INS42 INS34 INS7 INS43 INS32 INS7 INS32 INS8 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS34 INS32 INS43 INS85 INS32 INS42 INS3 INS14 INS42 INS33 INS53 INS27 INS8 INS25 INS43 INS32 INS42 INS33 INS32 INS14 INS32 INS42 INS43 INS59 INS32 INS8 INS42 INS42 INS40 INS42 INS11 INS32 INS42 INS42 INS41 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS2 INS42 INS42 INS42 INS5 INS32 INS43 INS45 INS14 INS32 INS34 INS53 INS27 INS8 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS45 INS42 INS42 INS40 INS42 INS11 INS32 INS42 INS42 INS21 INS43 INS32 INS42 INS42 INS11 INS42 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS43 INS85 INS42 INS42 INS42 INS43 INS45 INS42 INS42 INS14 INS32 INS34 INS53 INS32 INS8 INS25 INS42 INS43 INS32 INS42 INS42 INS32 INS40 INS42 INS42 INS43 INS32 INS32 INS42 INS43 INS27 INS42 INS42 INS43 INS45 INS42 INS42 INS14 INS32 INS42 INS45 INS53 INS38 INS8 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS43 INS45 INS42 INS42 INS14 INS32 INS53 INS42 INS43 INS27 INS42 INS42 INS42 INS14 INS42 INS45 INS42 INS43 INS27 INS42 INS45 INS42
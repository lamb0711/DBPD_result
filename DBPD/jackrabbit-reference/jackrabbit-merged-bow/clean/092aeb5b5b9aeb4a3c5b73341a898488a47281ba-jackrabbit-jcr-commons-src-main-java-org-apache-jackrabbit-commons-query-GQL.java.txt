JCR-2361: Add parser callback to GQL
- added callback
- used generics where possible
- fixed a bug in order by where relative paths were mangled

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@828996 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.util.ISO9075;
-import org.apache.jackrabbit.util.Text;
-import org.apache.jackrabbit.commons.iterator.RowIteratorAdapter;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.NoSuchElementException;
-import javax.jcr.query.QueryManager;
-import javax.jcr.query.RowIterator;
-import javax.jcr.query.Row;
-import javax.jcr.query.Query;
-import javax.jcr.Node;
-import javax.jcr.Session;
-import javax.jcr.RepositoryException;
-import javax.jcr.Value;
+import javax.jcr.Node;
-import javax.jcr.nodetype.NodeTypeManager;
-import javax.jcr.nodetype.NodeTypeIterator;
-import javax.jcr.nodetype.NodeType;
+import javax.jcr.RepositoryException;
+import javax.jcr.Session;
+import javax.jcr.Value;
+import javax.jcr.nodetype.NodeType;
+import javax.jcr.nodetype.NodeTypeIterator;
+import javax.jcr.nodetype.NodeTypeManager;
-import java.util.List;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.HashMap;
-import java.util.Arrays;
-import java.util.NoSuchElementException;
-import java.util.Collection;
+import javax.jcr.query.Query;
+import javax.jcr.query.QueryManager;
+import javax.jcr.query.Row;
+import javax.jcr.query.RowIterator;
+
+import org.apache.jackrabbit.commons.iterator.RowIteratorAdapter;
+import org.apache.jackrabbit.util.ISO9075;
+import org.apache.jackrabbit.util.Text;
+ * <p/>
+ * <b>Parser callbacks</b>
+ * <p/>
+ * You can get callbacks for each field and query term pair using the method
+ * {@link #parse(String, Session, ParserCallback)}. This may be useful when you
+ * want to do some transformation on the GQL before it is actually executed.
-    private final List conditions = new ArrayList();
+    private final List<Expression> conditions = new ArrayList<Expression>();
-    private Map ntNames;
+    private Map<String, String[]> ntNames;
-    private Map childNodeNames;
+    private Map<String, String> childNodeNames;
-    private Map propertyNames;
+    private Map<String, String> propertyNames;
+     * Parses the given <code>statement</code> and generates callbacks for each
+     * GQL term parsed.
+     *
+     * @param statement the GQL statement.
+     * @param session   the current session to resolve namespace prefixes.
+     * @param callback  the callback handler.
+     * @throws RepositoryException if an error occurs while parsing.
+     */
+    public static void parse(String statement,
+                             Session session,
+                             ParserCallback callback)
+            throws RepositoryException {
+        GQL query = new GQL(statement, session, null, null);
+        query.parse(callback);
+    }
+
+    /**
+    /**
+     * Defines a callback interface that may be implemented by client code to
+     * get a callback for each GQL term that is parsed.
+     */
+    public interface ParserCallback {
+
+        /**
+         * A GQL term was parsed.
+         *
+         * @param property the name of the property or an empty string if the
+         *                 term is not prefixed.
+         * @param value    the value of the term.
+         * @param optional whether this term is prefixed with an OR operator.
+         * @throws RepositoryException if an error occurs while processing the
+         *                             term.
+         */
+        public void term(String property, String value, boolean optional)
+                throws RepositoryException;
+    }
+
-            List resultRows = new ArrayList();
+            List<Row> resultRows = new ArrayList<Row>();
-            return new RowIterAdapter(resultRows, nodes.getSize());
+            return new RowIterAdapter(resultRows, resultRows.size());
-        parse();
+        parse(new ParserCallback() {
+            public void term(String property, String value, boolean optional)
+                    throws RepositoryException {
+                pushExpression(property, value, optional);
+            }
+        });
-        for (Iterator it = conditions.iterator(); it.hasNext(); ) {
-            predicate.addOperand((Expression) it.next());
+        for (Expression condition : conditions) {
+            predicate.addOperand(condition);
-        for (int i = 0; i < resolvedNames.length; i++) {
+        for (String resolvedName : resolvedNames) {
-                NodeType base = ntMgr.getNodeType(resolvedNames[i]);
+                NodeType base = ntMgr.getNodeType(resolvedName);
-                    addTypeConstraint(new MixinComparision(resolvedNames[i]));
+                    addTypeConstraint(new MixinComparision(resolvedName));
-                    addTypeConstraint(new PrimaryTypeComparision(resolvedNames[i]));
+                    addTypeConstraint(new PrimaryTypeComparision(resolvedName));
-
-                addTypeConstraint(new PrimaryTypeComparision(resolvedNames[i]));
+                addTypeConstraint(new PrimaryTypeComparision(resolvedName));
-                ntNames = new HashMap();
+                ntNames = new HashMap<String, String[]>();
-                    String[] nts = (String[]) ntNames.get(localName);
+                    String[] nts = ntNames.get(localName);
-            names = (String[]) ntNames.get(ntName);
+            names = ntNames.get(ntName);
-            propertyNames = new HashMap();
+            propertyNames = new HashMap<String, String>();
-                for (int i = 0; i < defs.length; i++) {
-                    String pn = defs[i].getName();
+                for (PropertyDefinition def : defs) {
+                    String pn = def.getName();
-        String pn = (String) propertyNames.get(name);
+        String pn = propertyNames.get(name);
-            childNodeNames = new HashMap();
+            childNodeNames = new HashMap<String, String>();
-                for (int i = 0; i < defs.length; i++) {
-                    String cnn = defs[i].getName();
+                for (NodeDefinition def : defs) {
+                    String cnn = def.getName();
-        String cnn = (String) childNodeNames.get(name);
+        String cnn = childNodeNames.get(name);
+     * @param callback the parser callback.
-    private void parse() throws RepositoryException {
+    private void parse(ParserCallback callback) throws RepositoryException {
-        for (int i = 0; i < stmt.length; i++) {
-            char c = stmt[i];
+        for (char c : stmt) {
-                                pushExpression(p, v, optional);
+                                callback.term(p, v, optional);
-                // noise
+                    // noise
-                for (int i = 0; i < nts.length; i++) {
-                    collectNodeTypes(nts[i]);
+                for (String nt : nts) {
+                    collectNodeTypes(nt);
-                Expression last = (Expression) conditions.get(conditions.size() - 1);
+                Expression last = conditions.get(conditions.size() - 1);
-                    buffer.append(slash);
-                    String name;
-                        // last part
-                        buffer.append("@");
-                        name = resolvePropertyName(parts[i]);
+                        if (!parts[i].equals(".")) {
+                            // last part
+                            buffer.append(slash);
+                            buffer.append("@");
+                            buffer.append(ISO9075.encode(
+                                    resolvePropertyName(parts[i])));
+                        }
-                        name = resolveChildNodeName(parts[i]);
+                        buffer.append(slash);
+                        buffer.append(ISO9075.encode(
+                                resolveChildNodeName(parts[i])));
-                    buffer.append(ISO9075.encode(name));
-        private final List operands = new ArrayList();
+        private final List<Expression> operands = new ArrayList<Expression>();
-            for (Iterator it = operands.iterator(); it.hasNext(); ) {
+            for (Expression expr : operands) {
-                Expression expr = (Expression) it.next();
-            List names = new ArrayList(Arrays.asList(Text.explode(value, ',')));
+            List<String> names = new ArrayList<String>(Arrays.asList(Text.explode(value, ',')));
-            for (Iterator it = names.iterator(); it.hasNext(); ) {
-                String name = (String) it.next();
+            for (String name : names) {
-                    name = resolvePropertyName(name);
-                    buffer.append("@").append(ISO9075.encode(name));
+                    name = createPropertyName(resolvePropertyName(name));
+                    buffer.append(name);
+        private String createPropertyName(String name) {
+            if (name.contains("/")) {
+                String[] labels = name.split("/");
+
+                name = "";
+                for (int i = 0; i < labels.length; i++) {
+                    String label = ISO9075.encode(labels[i]);
+                    if (i < (labels.length - 1)) {
+                        name += label + "/";
+                    } else {
+                        name += "@" + label;
+                    }
+                }
+                return name;
+            } else {
+                return "@" + ISO9075.encode(name);
+            }
+        }
+

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS31 INS55 INS74 INS74 INS74 INS74 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS42 INS31 MOV8 INS44 INS31 INS66 INS66 INS66 INS66 INS65 INS66 INS66 MOV43 INS43 MOV43 INS43 INS5 MOV43 INS43 INS43 MOV43 INS43 INS43 INS65 INS65 INS65 INS65 INS65 MOV43 INS42 INS43 INS42 INS43 INS42 INS42 INS60 INS21 INS65 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS21 INS70 MOV60 MOV60 INS70 INS65 INS43 INS42 INS70 INS74 INS83 INS43 INS42 INS44 INS8 INS68 INS42 INS74 INS42 INS43 INS85 INS42 INS42 INS42 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS43 INS59 INS32 INS66 INS66 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS39 INS42 INS42 INS32 INS44 INS42 INS8 INS44 INS42 MOV8 MOV43 MOV43 INS42 INS66 INS42 INS44 INS42 MOV8 MOV43 MOV43 INS70 INS70 INS42 INS43 INS42 INS25 INS42 INS69 INS69 INS69 MOV43 INS43 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 MOV42 INS14 MOV43 INS42 MOV21 UPD43 MOV43 UPD42 MOV42 INS54 MOV32 MOV32 INS39 INS42 INS42 INS74 INS44 INS42 MOV8 INS74 INS44 INS42 MOV8 INS42 INS32 INS8 INS8 MOV43 INS43 INS43 INS42 INS43 INS42 INS42 INS33 INS33 INS74 INS43 INS1 UPD42 INS8 INS12 MOV43 MOV43 MOV43 INS42 MOV43 INS43 INS43 INS42 INS42 INS42 INS45 INS60 INS21 INS24 INS41 INS41 INS42 INS42 INS42 MOV43 INS43 UPD42 MOV42 INS31 UPD42 MOV42 MOV60 MOV25 MOV60 MOV61 MOV44 MOV8 MOV32 INS70 INS70 INS42 UPD42 MOV42 INS74 UPD42 MOV42 MOV5 INS59 INS7 MOV58 INS27 MOV37 INS8 INS42 INS27 INS42 INS74 UPD42 UPD42 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS8 INS8 INS43 INS42 INS74 INS44 INS42 MOV8 INS74 INS44 INS42 MOV8 INS70 MOV43 INS43 INS42 INS32 INS42 INS45 INS42 INS40 INS60 INS25 INS45 MOV32 MOV43 INS43 INS43 INS42 INS43 INS42 INS39 INS42 INS42 INS21 INS21 INS42 MOV43 INS43 INS43 INS43 INS42 MOV43 INS43 INS43 INS43 INS42 INS44 INS42 INS8 INS8 UPD42 MOV42 INS42 INS42 INS45 MOV43 INS59 INS27 INS8 INS8 INS42 INS42 INS42 INS32 INS42 INS32 INS74 MOV5 MOV42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 MOV43 MOV43 INS42 MOV21 INS25 INS21 INS32 MOV42 MOV42 UPD42 INS42 INS32 INS42 INS36 INS21 INS21 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS14 INS42 MOV43 INS43 MOV5 MOV32 MOV42 MOV43 INS38 MOV8 INS32 INS32 INS42 MOV32 INS42 INS42 INS2 INS27 INS7 INS7 INS42 MOV43 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS32 MOV21 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS40 INS34 INS42 INS27 INS42 INS27 INS2 INS42 INS45 INS32 INS42 INS42 MOV32 INS42 INS45 INS45 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 MOV32 DEL40 DEL26 DEL32 DEL21 DEL42 DEL32 DEL11 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL32 DEL8 DEL24 DEL42 DEL42 DEL2 DEL42 DEL42 DEL2 DEL42 DEL42 DEL2 DEL42 DEL42 DEL42 DEL2 DEL14 DEL32 DEL21 DEL8 DEL12 DEL54 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL24 DEL8 DEL11 DEL11 DEL42 DEL42 DEL2 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL24 DEL11 DEL42 DEL42 DEL2 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL24 DEL11 DEL39 DEL42 DEL42 DEL42 DEL2 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL24 DEL42 DEL42 DEL2 DEL42 DEL40 DEL27 DEL8 DEL24 DEL11 DEL42 DEL59 DEL60 DEL42 DEL7 DEL42 DEL7 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL45 DEL32 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24
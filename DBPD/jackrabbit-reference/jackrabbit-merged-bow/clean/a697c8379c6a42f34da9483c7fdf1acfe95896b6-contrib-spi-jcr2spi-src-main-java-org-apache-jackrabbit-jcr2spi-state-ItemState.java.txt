work in progress

- version always protected
- versionHistory always protected
- fix Node.getReferences && reference properties
- mixinTypes are 'active' upon save only (and not before). therefore
  cleanup after removeMixin is done only after save.
  adding new states defined by a new mixin are only added after the
  node has been saved.
- nodestates identified by a uuid only were created a second time upon
  ChildNodeEntry.resolve => fix needs to be improved
- Events/ChangeLog are processed by the save-target state
- ChangeLog.persisted not used any more

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@467956 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Iterator;
+import java.util.Collections;
-     * accepts call to {@link #refresh(Event, ChangeLog)}, while the latter
+     * accepts call to {@link #refresh(Event)}, while the latter
+     * The <code>ItemStateFactory</code> which is used to create new
+     * <code>ItemState</code> instances.
+     */
+    final ItemStateFactory isf;
+
+    /**
-    protected ItemState(NodeState parent, int initialStatus, IdFactory idFactory,
+    protected ItemState(NodeState parent, int initialStatus, ItemStateFactory isf, IdFactory idFactory,
+        this.isf = isf;
-                        int initialStatus, IdFactory idFactory) {
+                        int initialStatus, ItemStateFactory isf, IdFactory idFactory) {
+        this.isf = isf;
-        return status == Status.EXISTING || status == Status.EXISTING_MODIFIED || status == Status.NEW;
+        return Status.isValid(getStatus());
-        if (getParent() == null) {
+        if (parent == null) {
-        } catch (NoSuchItemStateException e) {
-            String msg = "Failed to build path of " + this;
-            log.debug(msg);
-            throw new ItemNotFoundException(msg, e);
-        } catch (ItemStateException e) {
-            String msg = "Failed to build path of " + this;
-            log.debug(msg);
-            throw new RepositoryException(msg, e);
-            throws ItemStateException, RepositoryException {
+        throws ItemNotFoundException {
-        if (Status.isTerminalStatus(oldStatus)) {
+        if (Status.isTerminal(oldStatus)) {
-            if (la[i] instanceof ItemStateLifeCycleListener) {
-                ((ItemStateLifeCycleListener) la[i]).statusChanged(this, oldStatus);
+            if (la[i] != null) {
+                la[i].statusChanged(this, oldStatus);
-            assert (!listeners.contains(listener));
+    /**
+     * Unmodifiable iterator over the listeners present on this item state.
+     * 
+     * @return
+     */
+    public Iterator getListeners() {
+        return Collections.unmodifiableCollection(listeners).iterator();
+    }
+    //-----------------------------------------< ItemStateLifeCycleListener >---
+    /**
+     *
+     * @param state
+     * @param previousStatus
+     */
+    public void statusChanged(ItemState state, int previousStatus) {
+        checkIsSessionState();
+
+        // the given state is the overlayed state this state (session) is listening to.
+        if (state == overlayedState) {
+            switch (state.getStatus()) {
+                case Status.MODIFIED:
+                    // underlying state has been modified by external changes
+                    if (status == Status.EXISTING) {
+                        synchronized (this) {
+                            reset();
+                        }
+                    } else if (status == Status.EXISTING_MODIFIED) {
+                        setStatus(Status.STALE_MODIFIED);
+                    }
+                    // else: this status is EXISTING_REMOVED => ignore.
+                    // no other status is possible.
+                    break;
+                case Status.REMOVED:
+                    if (status == Status.EXISTING_MODIFIED) {
+                        setStatus(Status.STALE_DESTROYED);
+                    } else {
+                        setStatus(Status.REMOVED);
+                    }
+                    break;
+                default:
+                    // Should never occur, since 'setStatus(int)' already validates
+                    log.error("Workspace state cannot have its state changed to " + state.getStatus());
+                    break;
+            }
+        }
+    }
+
+
-     * the given event (and ev. changelog).
+     * an external modification indicated by the given event.
+     * @throws IllegalStateException if this state is a 'session' state.
+     */
+    abstract void refresh(Event event);
+
+    /**
+     * Returns the overlaying item state or <code>null</code> if that state
+     * has not been created yet or has been disconnected.
+     *
+     * @return
+     */
+    ItemState getSessionState() {
+        checkIsWorkspaceState();
+        ItemStateLifeCycleListener[] la;
+        synchronized (listeners) {
+            la = (ItemStateLifeCycleListener[]) listeners.toArray(new ItemStateLifeCycleListener[listeners.size()]);
+        }
+        for (int i = 0; i < la.length; i++) {
+            if (la[i] instanceof ItemState) {
+                return (ItemState) la[i];
+            }
+        }
+        return null;
+    }
+
+    //----------------------------------------------------< Session - State >---
+    /**
+     * Used on the target state of a save call AFTER the changelog has been
+     * successfully submitted to the SPI..
+     *
+     * @param events
-    abstract void refresh(Event event, ChangeLog changeLog);
+    abstract void refresh(Collection events, ChangeLog changeLog) throws IllegalStateException;
-
-    //----------------------------------------------------< Session - State >---
-     * Merge the state information from the overlayed state into this state
-     */
-    abstract void merge();
-
-    /**
-     * Returns <code>true</code> if this item state represents new or modified
-     * state or <code>false</code> if it represents existing, unmodified state.
-     *
-     * @return <code>true</code> if this item state is modified or new,
-     *         otherwise <code>false</code>
-     */
-    private boolean isTransient() {
-        checkIsSessionState();
-        return status == Status.EXISTING_MODIFIED || status == Status.NEW;
-    }
-
-    /**
-     * call the method {@link #collectTransientStates(java.util.Set)} on those
+     * call the method {@link #collectTransientStates(Collection)} on those
-     *                        collected while the <code>ItemState</code>
-     *                        hierarchy is traversed.
-    abstract void collectTransientStates(Set transientStates);
+    abstract void collectTransientStates(Collection transientStates);
-    //-----------------------------------------< ItemStateLifeCycleListener >---
+
+    //--------------------------------------------------------------------------
-     * @param state
-     * @param previousStatus
+     * @param events
+     * @param processedState
-    public void statusChanged(ItemState state, int previousStatus) {
-        // workspace-states never are listening to another state
-        checkIsSessionState();
-        state.checkIsWorkspaceState();
-
-        switch (state.getStatus()) {
-            case Status.EXISTING:
-                // nothing to do
+    static void removeEvent(Collection events, ItemState processedState) {
+        for (Iterator it = events.iterator(); it.hasNext();) {
+            if (((Event)it.next()).getItemId().equals(processedState.getId())) {
+                it.remove();
-            case Status.MODIFIED:
-                if (previousStatus == Status.EXISTING) {
-                    // underlying state has been modified
-                    if (isTransient()) {
-                        setStatus(Status.STALE_MODIFIED);
-                    } else {
-                        synchronized (this) {
-                            // this instance represents existing state, update it
-                            merge();
-                            setStatus(Status.EXISTING);
-                        }
-                    }
-                }
-                break;
-            case Status.REMOVED:
-                if (isTransient()) {
-                    setStatus(Status.STALE_DESTROYED);
-                } else {
-                    setStatus(Status.REMOVED);
-                }
-                break;
-            default:
-                // Should never occur, since 'setStatus(int)' already validates
-                log.error("Workspace state cannot have its state changed to " + state.getStatus());
-                break;
+            }

INS26 INS26 MOV31 MOV31 MOV31 INS40 INS40 INS23 INS31 INS31 INS29 INS83 INS43 INS59 INS44 INS44 MOV43 INS29 INS83 INS43 INS42 INS8 UPD42 MOV44 INS43 INS42 INS44 INS43 INS29 INS83 INS39 INS42 INS44 INS44 INS8 INS65 INS42 INS42 INS43 INS42 INS21 INS43 INS42 INS21 INS65 INS65 INS42 INS41 INS25 INS65 MOV65 UPD65 INS42 INS60 INS51 INS24 INS41 INS65 INS43 INS42 INS42 UPD43 INS65 INS65 INS43 INS42 INS43 INS42 INS24 INS66 INS66 INS42 INS7 INS42 INS7 INS32 INS66 INS32 INS27 INS8 INS66 INS66 INS42 UPD66 UPD66 UPD66 INS5 INS59 INS42 INS8 INS58 INS27 INS37 INS8 INS33 UPD66 UPD66 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS58 INS32 INS8 INS22 INS42 INS22 INS42 INS42 INS42 INS32 INS42 UPD42 INS32 INS42 INS42 INS42 MOV50 UPD42 INS43 INS85 INS42 INS21 INS39 INS59 UPD42 MOV42 UPD40 MOV40 INS42 INS25 INS43 INS59 INS42 INS42 INS25 INS52 INS42 INS52 INS42 INS42 INS27 INS8 INS42 INS42 INS42 INS25 INS42 INS7 INS42 INS34 INS62 MOV8 INS42 INS42 INS32 INS32 INS8 INS2 INS33 INS21 MOV27 MOV8 INS25 MOV27 INS42 INS11 INS2 INS43 INS41 UPD43 INS42 INS42 INS32 INS42 INS32 INS21 INS10 INS42 INS42 INS32 MOV27 MOV8 INS5 INS32 INS42 INS42 INS42 MOV11 INS42 INS36 INS42 INS42 INS42 INS32 MOV2 INS42 INS52 INS42 INS43 INS85 INS42 INS42 INS3 UPD43 INS11 INS42 INS42 INS42 INS5 INS32 UPD42 INS43 INS32 INS43 INS85 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 DEL42 DEL43 DEL69 DEL27 DEL42 DEL40 DEL27 DEL27 DEL42 DEL32 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL45 DEL52 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL45 DEL52 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL62 DEL42 DEL42 DEL42 DEL32 DEL38 DEL36 DEL6 DEL40 DEL49 DEL10 DEL42 DEL32 DEL21 DEL40 DEL42 DEL40 DEL27 DEL42 DEL32 DEL25 DEL8 DEL25 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL66 DEL66 DEL83 DEL39 DEL42 DEL36 DEL42 DEL52 DEL42 DEL32 DEL21 DEL27 DEL27 DEL41 DEL40 DEL66 DEL66
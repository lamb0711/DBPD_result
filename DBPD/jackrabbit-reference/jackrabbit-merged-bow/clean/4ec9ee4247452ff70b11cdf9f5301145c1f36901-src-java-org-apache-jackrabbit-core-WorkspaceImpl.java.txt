- removed @author and @version (i.e. $Revision & $Id) tags
- removed tab characters from java source code

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@47648 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.log4j.Logger;
+import org.apache.jackrabbit.core.search.QueryManagerImpl;
+import org.apache.jackrabbit.core.util.uuid.UUID;
-import org.apache.jackrabbit.core.util.uuid.UUID;
-import org.apache.jackrabbit.core.search.QueryManagerImpl;
+import org.apache.log4j.Logger;
- *
- * @author Stefan Guggisberg
- * @version $Revision: 1.69 $, $Date: 2004/09/06 16:42:48 $
-		  ReferenceManager refMgr, RepositoryImpl rep, SessionImpl session) {
-	this.wspName = wspName;
-	this.rep = rep;
-	this.persistentStateMgr = persistentStateMgr;
-	this.refMgr = refMgr;
-	hierMgr = new HierarchyManagerImpl(rep.getRootNodeUUID(), persistentStateMgr, session.getNamespaceResolver());
-	this.session = session;
+                  ReferenceManager refMgr, RepositoryImpl rep, SessionImpl session) {
+        this.wspName = wspName;
+        this.rep = rep;
+        this.persistentStateMgr = persistentStateMgr;
+        this.refMgr = refMgr;
+        hierMgr = new HierarchyManagerImpl(rep.getRootNodeUUID(), persistentStateMgr, session.getNamespaceResolver());
+        this.session = session;
-	return rep;
+        return rep;
-	return persistentStateMgr;
+        return persistentStateMgr;
-	return refMgr;
+        return refMgr;
-	ps.println("Workspace: " + wspName + " (" + this + ")");
-	ps.println();
-	persistentStateMgr.dump(ps);
+        ps.println("Workspace: " + wspName + " (" + this + ")");
+        ps.println();
+        persistentStateMgr.dump(ps);
-	try {
-	    ObservationManager om = getObservationManager();
-	    EventListenerIterator it = om.getRegisteredEventListeners();
-	    while (it.hasNext()) {
-		EventListener l = it.nextEventListener();
-		log.debug("removing EventListener: " + l);
-		om.removeEventListener(l);
-	    }
-	} catch (RepositoryException e) {
-	    log.error("Exception while disposing Workspace:", e);
-	}
+        try {
+            ObservationManager om = getObservationManager();
+            EventListenerIterator it = om.getRegisteredEventListeners();
+            while (it.hasNext()) {
+                EventListener l = it.nextEventListener();
+                log.debug("removing EventListener: " + l);
+                om.removeEventListener(l);
+            }
+        } catch (RepositoryException e) {
+            log.error("Exception while disposing Workspace:", e);
+        }
-						      NamespaceResolver nsResolver,
-						      HierarchyManagerImpl hierMgr,
-						      PersistentItemStateManager stateMgr)
-	    throws PathNotFoundException, RepositoryException {
-	try {
-	    return getNodeState(Path.create(nodePath, nsResolver, true), hierMgr, stateMgr);
-	} catch (MalformedPathException mpe) {
-	    String msg = "invalid path: " + nodePath;
-	    log.error(msg, mpe);
-	    throw new RepositoryException(msg, mpe);
-	}
+                                                      NamespaceResolver nsResolver,
+                                                      HierarchyManagerImpl hierMgr,
+                                                      PersistentItemStateManager stateMgr)
+            throws PathNotFoundException, RepositoryException {
+        try {
+            return getNodeState(Path.create(nodePath, nsResolver, true), hierMgr, stateMgr);
+        } catch (MalformedPathException mpe) {
+            String msg = "invalid path: " + nodePath;
+            log.error(msg, mpe);
+            throw new RepositoryException(msg, mpe);
+        }
-							    NamespaceResolver nsResolver,
-							    HierarchyManagerImpl hierMgr,
-							    PersistentItemStateManager stateMgr)
+                                                            NamespaceResolver nsResolver,
+                                                            HierarchyManagerImpl hierMgr,
+                                                            PersistentItemStateManager stateMgr)
-	    throws PathNotFoundException, RepositoryException {
-	try {
-	    return getNodeState(Path.create(path, nsResolver, true).getAncestor(1), hierMgr, stateMgr);
-	} catch (MalformedPathException mpe) {
-	    String msg = "invalid path: " + path;
-	    log.error(msg, mpe);
-	    throw new RepositoryException(msg, mpe);
-	}
+            throws PathNotFoundException, RepositoryException {
+        try {
+            return getNodeState(Path.create(path, nsResolver, true).getAncestor(1), hierMgr, stateMgr);
+        } catch (MalformedPathException mpe) {
+            String msg = "invalid path: " + path;
+            log.error(msg, mpe);
+            throw new RepositoryException(msg, mpe);
+        }
-						      HierarchyManagerImpl hierMgr,
-						      PersistentItemStateManager stateMgr)
-	    throws PathNotFoundException, RepositoryException {
-	try {
-	    ItemId id = hierMgr.resolvePath(nodePath);
-	    if (!id.denotesNode()) {
-		throw new PathNotFoundException(hierMgr.safeGetJCRPath(nodePath));
-	    }
-	    return getNodeState((NodeId) id, stateMgr);
-	} catch (NoSuchItemStateException nsise) {
-	    throw new PathNotFoundException(hierMgr.safeGetJCRPath(nodePath));
-	} catch (ItemStateException ise) {
-	    String msg = "internal error: failed to retrieve state of " + hierMgr.safeGetJCRPath(nodePath);
-	    log.error(msg, ise);
-	    throw new RepositoryException(msg, ise);
-	}
+                                                      HierarchyManagerImpl hierMgr,
+                                                      PersistentItemStateManager stateMgr)
+            throws PathNotFoundException, RepositoryException {
+        try {
+            ItemId id = hierMgr.resolvePath(nodePath);
+            if (!id.denotesNode()) {
+                throw new PathNotFoundException(hierMgr.safeGetJCRPath(nodePath));
+            }
+            return getNodeState((NodeId) id, stateMgr);
+        } catch (NoSuchItemStateException nsise) {
+            throw new PathNotFoundException(hierMgr.safeGetJCRPath(nodePath));
+        } catch (ItemStateException ise) {
+            String msg = "internal error: failed to retrieve state of " + hierMgr.safeGetJCRPath(nodePath);
+            log.error(msg, ise);
+            throw new RepositoryException(msg, ise);
+        }
-						      PersistentItemStateManager stateMgr)
-	    throws NoSuchItemStateException, ItemStateException {
-	return (PersistentNodeState) stateMgr.getItemState(id);
+                                                      PersistentItemStateManager stateMgr)
+            throws NoSuchItemStateException, ItemStateException {
+        return (PersistentNodeState) stateMgr.getItemState(id);
-				       NodeTypeRegistry ntReg,
-				       AccessManagerImpl accessMgr,
-				       HierarchyManagerImpl hierMgr,
-				       PersistentItemStateManager stateMgr)
-	    throws ConstraintViolationException, AccessDeniedException,
-	    PathNotFoundException, ItemExistsException, RepositoryException {
+                                       NodeTypeRegistry ntReg,
+                                       AccessManagerImpl accessMgr,
+                                       HierarchyManagerImpl hierMgr,
+                                       PersistentItemStateManager stateMgr)
+            throws ConstraintViolationException, AccessDeniedException,
+            PathNotFoundException, ItemExistsException, RepositoryException {
-	Path parentPath = nodePath.getAncestor(1);
-	PersistentNodeState parentState = getNodeState(parentPath, hierMgr, stateMgr);
+        Path parentPath = nodePath.getAncestor(1);
+        PersistentNodeState parentState = getNodeState(parentPath, hierMgr, stateMgr);
-	// 1. check path & access rights
+        // 1. check path & access rights
-	Path.PathElement nodeName = nodePath.getNameElement();
-	try {
-	    // check access rights
-	    if (!accessMgr.isGranted(parentState.getId(), Permission.READ_ITEM)) {
-		throw new PathNotFoundException(hierMgr.safeGetJCRPath(parentPath));
-	    }
-	    if (!accessMgr.isGranted(parentState.getId(), Permission.ADD_NODE)) {
-		throw new AccessDeniedException(hierMgr.safeGetJCRPath(parentPath) + ": not allowed to add child node");
-	    }
-	} catch (ItemNotFoundException infe) {
-	    String msg = "internal error: failed to check access rights for " + hierMgr.safeGetJCRPath(parentPath);
-	    log.error(msg, infe);
-	    throw new RepositoryException(msg, infe);
-	}
+        Path.PathElement nodeName = nodePath.getNameElement();
+        try {
+            // check access rights
+            if (!accessMgr.isGranted(parentState.getId(), Permission.READ_ITEM)) {
+                throw new PathNotFoundException(hierMgr.safeGetJCRPath(parentPath));
+            }
+            if (!accessMgr.isGranted(parentState.getId(), Permission.ADD_NODE)) {
+                throw new AccessDeniedException(hierMgr.safeGetJCRPath(parentPath) + ": not allowed to add child node");
+            }
+        } catch (ItemNotFoundException infe) {
+            String msg = "internal error: failed to check access rights for " + hierMgr.safeGetJCRPath(parentPath);
+            log.error(msg, infe);
+            throw new RepositoryException(msg, infe);
+        }
-	// 2. check node type constraints
+        // 2. check node type constraints
-	ChildNodeDef parentDef = ntReg.getNodeDef(parentState.getDefinitionId());
-	if (parentDef.isProtected()) {
-	    throw new ConstraintViolationException(hierMgr.safeGetJCRPath(parentPath) + ": cannot add child node to protected parent node");
-	}
-	EffectiveNodeType entParent = getEffectiveNodeType(parentState, ntReg);
-	entParent.checkAddNodeConstraints(nodeName.getName(), nodeTypeName);
-	ChildNodeDef newNodeDef = findApplicableDefinition(nodeName.getName(), nodeTypeName, parentState, ntReg);
+        ChildNodeDef parentDef = ntReg.getNodeDef(parentState.getDefinitionId());
+        if (parentDef.isProtected()) {
+            throw new ConstraintViolationException(hierMgr.safeGetJCRPath(parentPath) + ": cannot add child node to protected parent node");
+        }
+        EffectiveNodeType entParent = getEffectiveNodeType(parentState, ntReg);
+        entParent.checkAddNodeConstraints(nodeName.getName(), nodeTypeName);
+        ChildNodeDef newNodeDef = findApplicableDefinition(nodeName.getName(), nodeTypeName, parentState, ntReg);
-	// 3. check for name collisions
+        // 3. check for name collisions
-	if (parentState.hasPropertyEntry(nodeName.getName())) {
-	    // there's already a property with that name
-	    throw new ItemExistsException(hierMgr.safeGetJCRPath(nodePath));
-	}
-	if (parentState.hasChildNodeEntry(nodeName.getName())) {
-	    // there's already a node with that name...
+        if (parentState.hasPropertyEntry(nodeName.getName())) {
+            // there's already a property with that name
+            throw new ItemExistsException(hierMgr.safeGetJCRPath(nodePath));
+        }
+        if (parentState.hasChildNodeEntry(nodeName.getName())) {
+            // there's already a node with that name...
-	    // get definition of existing conflicting node
-	    NodeState.ChildNodeEntry entry = parentState.getChildNodeEntry(nodeName.getName(), 1);
-	    NodeState conflictingState;
-	    NodeId conflictingId = new NodeId(entry.getUUID());
-	    try {
-		conflictingState = (NodeState) stateMgr.getItemState(conflictingId);
-	    } catch (ItemStateException ise) {
-		String msg = "internal error: failed to retrieve state of " + hierMgr.safeGetJCRPath(conflictingId);
-		log.error(msg, ise);
-		throw new RepositoryException(msg, ise);
-	    }
-	    ChildNodeDef conflictingTargetDef = ntReg.getNodeDef(conflictingState.getDefinitionId());
-	    // check same-name sibling setting of both target and existing node
-	    if (!conflictingTargetDef.allowSameNameSibs()
-		    || !newNodeDef.allowSameNameSibs()) {
-		throw new ItemExistsException(hierMgr.safeGetJCRPath(nodePath));
-	    }
-	}
+            // get definition of existing conflicting node
+            NodeState.ChildNodeEntry entry = parentState.getChildNodeEntry(nodeName.getName(), 1);
+            NodeState conflictingState;
+            NodeId conflictingId = new NodeId(entry.getUUID());
+            try {
+                conflictingState = (NodeState) stateMgr.getItemState(conflictingId);
+            } catch (ItemStateException ise) {
+                String msg = "internal error: failed to retrieve state of " + hierMgr.safeGetJCRPath(conflictingId);
+                log.error(msg, ise);
+                throw new RepositoryException(msg, ise);
+            }
+            ChildNodeDef conflictingTargetDef = ntReg.getNodeDef(conflictingState.getDefinitionId());
+            // check same-name sibling setting of both target and existing node
+            if (!conflictingTargetDef.allowSameNameSibs()
+                    || !newNodeDef.allowSameNameSibs()) {
+                throw new ItemExistsException(hierMgr.safeGetJCRPath(nodePath));
+            }
+        }
-					  NodeTypeRegistry ntReg,
-					  AccessManagerImpl accessMgr,
-					  HierarchyManagerImpl hierMgr,
-					  PersistentItemStateManager stateMgr)
-	    throws ConstraintViolationException, AccessDeniedException,
-	    PathNotFoundException, RepositoryException {
+                                          NodeTypeRegistry ntReg,
+                                          AccessManagerImpl accessMgr,
+                                          HierarchyManagerImpl hierMgr,
+                                          PersistentItemStateManager stateMgr)
+            throws ConstraintViolationException, AccessDeniedException,
+            PathNotFoundException, RepositoryException {
-	PersistentNodeState targetState = getNodeState(nodePath, hierMgr, stateMgr);
-	Path parentPath = nodePath.getAncestor(1);
-	PersistentNodeState parentState = getNodeState(parentPath, hierMgr, stateMgr);
+        PersistentNodeState targetState = getNodeState(nodePath, hierMgr, stateMgr);
+        Path parentPath = nodePath.getAncestor(1);
+        PersistentNodeState parentState = getNodeState(parentPath, hierMgr, stateMgr);
-	// 1. check path & access rights
+        // 1. check path & access rights
-	try {
-	    // check access rights
-	    if (!accessMgr.isGranted(targetState.getId(), Permission.READ_ITEM)) {
-		throw new PathNotFoundException(hierMgr.safeGetJCRPath(nodePath));
-	    }
-	    if (!accessMgr.isGranted(parentState.getId(), Permission.REMOVE_ITEM)) {
-		throw new AccessDeniedException(hierMgr.safeGetJCRPath(parentPath) + ": not allowed to remove child node");
-	    }
-	} catch (ItemNotFoundException infe) {
-	    String msg = "internal error: failed to check access rights for " + hierMgr.safeGetJCRPath(nodePath);
-	    log.error(msg, infe);
-	    throw new RepositoryException(msg, infe);
-	}
+        try {
+            // check access rights
+            if (!accessMgr.isGranted(targetState.getId(), Permission.READ_ITEM)) {
+                throw new PathNotFoundException(hierMgr.safeGetJCRPath(nodePath));
+            }
+            if (!accessMgr.isGranted(parentState.getId(), Permission.REMOVE_ITEM)) {
+                throw new AccessDeniedException(hierMgr.safeGetJCRPath(parentPath) + ": not allowed to remove child node");
+            }
+        } catch (ItemNotFoundException infe) {
+            String msg = "internal error: failed to check access rights for " + hierMgr.safeGetJCRPath(nodePath);
+            log.error(msg, infe);
+            throw new RepositoryException(msg, infe);
+        }
-	// 2. check node type constraints
+        // 2. check node type constraints
-	ChildNodeDef parentDef = ntReg.getNodeDef(parentState.getDefinitionId());
-	if (parentDef.isProtected()) {
-	    throw new ConstraintViolationException(hierMgr.safeGetJCRPath(parentPath) + ": cannot remove child node of protected parent node");
-	}
-	ChildNodeDef targetDef = ntReg.getNodeDef(targetState.getDefinitionId());
-	if (targetDef.isMandatory()) {
-	    throw new ConstraintViolationException(hierMgr.safeGetJCRPath(nodePath) + ": cannot remove mandatory node");
-	}
-	if (targetDef.isProtected()) {
-	    throw new ConstraintViolationException(hierMgr.safeGetJCRPath(nodePath) + ": cannot remove protected node");
-	}
+        ChildNodeDef parentDef = ntReg.getNodeDef(parentState.getDefinitionId());
+        if (parentDef.isProtected()) {
+            throw new ConstraintViolationException(hierMgr.safeGetJCRPath(parentPath) + ": cannot remove child node of protected parent node");
+        }
+        ChildNodeDef targetDef = ntReg.getNodeDef(targetState.getDefinitionId());
+        if (targetDef.isMandatory()) {
+            throw new ConstraintViolationException(hierMgr.safeGetJCRPath(nodePath) + ": cannot remove mandatory node");
+        }
+        if (targetDef.isProtected()) {
+            throw new ConstraintViolationException(hierMgr.safeGetJCRPath(nodePath) + ": cannot remove protected node");
+        }
-							    NodeTypeRegistry ntReg)
-	    throws RepositoryException {
-	// build effective node type of mixins & primary type:
-	// existing mixin's
-	HashSet set = new HashSet(((NodeState) state).getMixinTypeNames());
-	// primary type
-	set.add(state.getNodeTypeName());
-	try {
-	    return ntReg.buildEffectiveNodeType((QName[]) set.toArray(new QName[set.size()]));
-	} catch (NodeTypeConflictException ntce) {
-	    String msg = "internal error: failed to build effective node type for node " + state.getUUID();
-	    log.error(msg, ntce);
-	    throw new RepositoryException(msg, ntce);
-	}
+                                                            NodeTypeRegistry ntReg)
+            throws RepositoryException {
+        // build effective node type of mixins & primary type:
+        // existing mixin's
+        HashSet set = new HashSet(((NodeState) state).getMixinTypeNames());
+        // primary type
+        set.add(state.getNodeTypeName());
+        try {
+            return ntReg.buildEffectiveNodeType((QName[]) set.toArray(new QName[set.size()]));
+        } catch (NodeTypeConflictException ntce) {
+            String msg = "internal error: failed to build effective node type for node " + state.getUUID();
+            log.error(msg, ntce);
+            throw new RepositoryException(msg, ntce);
+        }
-							   QName nodeTypeName,
-							   NodeState parentState,
-							   NodeTypeRegistry ntReg)
-	    throws RepositoryException, ConstraintViolationException {
-	EffectiveNodeType entParent = getEffectiveNodeType(parentState, ntReg);
-	return entParent.getApplicableChildNodeDef(name, nodeTypeName);
+                                                           QName nodeTypeName,
+                                                           NodeState parentState,
+                                                           NodeTypeRegistry ntReg)
+            throws RepositoryException, ConstraintViolationException {
+        EffectiveNodeType entParent = getEffectiveNodeType(parentState, ntReg);
+        return entParent.getApplicableChildNodeDef(name, nodeTypeName);
-						     String parentUUID,
-						     NodeTypeRegistry ntReg,
-						     HierarchyManagerImpl srcHierMgr,
-						     PersistentItemStateManager srcStateMgr,
-						     PersistentItemStateManager destStateMgr,
-						     boolean clone)
-	    throws RepositoryException {
-	PersistentNodeState newState;
-	try {
-	    String uuid;
-	    if (clone) {
-		uuid = srcState.getUUID();
-	    } else {
-		uuid = UUID.randomUUID().toString();	// create new version 4 uuid
-	    }
-	    newState = destStateMgr.createNodeState(uuid, srcState.getNodeTypeName(), parentUUID);
-	    // copy node state
-	    // @todo special handling required for nodes with special semantics (e.g. those defined by mix:versionable, et.al.)
-	    // FIXME delegate to 'node type instance handler'
-	    newState.setMixinTypeNames(srcState.getMixinTypeNames());
-	    newState.setDefinitionId(srcState.getDefinitionId());
-	    // copy child nodes
-	    Iterator iter = srcState.getChildNodeEntries().iterator();
-	    while (iter.hasNext()) {
-		NodeState.ChildNodeEntry entry = (NodeState.ChildNodeEntry) iter.next();
-		NodeState srcChildState = (NodeState) srcStateMgr.getItemState(new NodeId(entry.getUUID()));
-		// recursive copying of child node
-		PersistentNodeState newChildState = copyNodeState(srcChildState, uuid,
-			ntReg, srcHierMgr, srcStateMgr, destStateMgr, clone);
-		// persist new child node
-		newChildState.store();
-		// add new child node entry to new node
-		newState.addChildNodeEntry(entry.getName(), newChildState.getUUID());
-	    }
-	    // copy properties
-	    iter = srcState.getPropertyEntries().iterator();
-	    while (iter.hasNext()) {
-		NodeState.PropertyEntry entry = (NodeState.PropertyEntry) iter.next();
-		PropertyState srcChildState = (PropertyState) srcStateMgr.getItemState(new PropertyId(srcState.getUUID(), entry.getName()));
-		PersistentPropertyState newChildState = copyPropertyState(srcChildState, uuid, entry.getName(),
-			ntReg, srcHierMgr, srcStateMgr, destStateMgr);
-		// persist new property
-		newChildState.store();
-		// add new property entry to new node
-		newState.addPropertyEntry(entry.getName());
-	    }
-	    return newState;
-	} catch (ItemStateException ise) {
-	    String msg = "internal error: failed to copy state of " + srcHierMgr.safeGetJCRPath(srcState.getId());
-	    log.error(msg, ise);
-	    throw new RepositoryException(msg, ise);
-	}
+                                                     String parentUUID,
+                                                     NodeTypeRegistry ntReg,
+                                                     HierarchyManagerImpl srcHierMgr,
+                                                     PersistentItemStateManager srcStateMgr,
+                                                     PersistentItemStateManager destStateMgr,
+                                                     boolean clone)
+            throws RepositoryException {
+        PersistentNodeState newState;
+        try {
+            String uuid;
+            if (clone) {
+                uuid = srcState.getUUID();
+            } else {
+                uuid = UUID.randomUUID().toString();	// create new version 4 uuid
+            }
+            newState = destStateMgr.createNodeState(uuid, srcState.getNodeTypeName(), parentUUID);
+            // copy node state
+            // @todo special handling required for nodes with special semantics (e.g. those defined by mix:versionable, et.al.)
+            // FIXME delegate to 'node type instance handler'
+            newState.setMixinTypeNames(srcState.getMixinTypeNames());
+            newState.setDefinitionId(srcState.getDefinitionId());
+            // copy child nodes
+            Iterator iter = srcState.getChildNodeEntries().iterator();
+            while (iter.hasNext()) {
+                NodeState.ChildNodeEntry entry = (NodeState.ChildNodeEntry) iter.next();
+                NodeState srcChildState = (NodeState) srcStateMgr.getItemState(new NodeId(entry.getUUID()));
+                // recursive copying of child node
+                PersistentNodeState newChildState = copyNodeState(srcChildState, uuid,
+                        ntReg, srcHierMgr, srcStateMgr, destStateMgr, clone);
+                // persist new child node
+                newChildState.store();
+                // add new child node entry to new node
+                newState.addChildNodeEntry(entry.getName(), newChildState.getUUID());
+            }
+            // copy properties
+            iter = srcState.getPropertyEntries().iterator();
+            while (iter.hasNext()) {
+                NodeState.PropertyEntry entry = (NodeState.PropertyEntry) iter.next();
+                PropertyState srcChildState = (PropertyState) srcStateMgr.getItemState(new PropertyId(srcState.getUUID(), entry.getName()));
+                PersistentPropertyState newChildState = copyPropertyState(srcChildState, uuid, entry.getName(),
+                        ntReg, srcHierMgr, srcStateMgr, destStateMgr);
+                // persist new property
+                newChildState.store();
+                // add new property entry to new node
+                newState.addPropertyEntry(entry.getName());
+            }
+            return newState;
+        } catch (ItemStateException ise) {
+            String msg = "internal error: failed to copy state of " + srcHierMgr.safeGetJCRPath(srcState.getId());
+            log.error(msg, ise);
+            throw new RepositoryException(msg, ise);
+        }
-							     String parentUUID,
-							     QName propName,
-							     NodeTypeRegistry ntReg,
-							     HierarchyManagerImpl srcHierMgr,
-							     PersistentItemStateManager srcStateMgr,
-							     PersistentItemStateManager destStateMgr)
-	    throws RepositoryException {
-	// @todo special handling required for properties with special semantics (e.g. those defined by mix:versionable, mix:lockable, et.al.)
-	PersistentPropertyState newState;
-	try {
-	    newState = destStateMgr.createPropertyState(parentUUID, propName);
-	    PropDefId defId = srcState.getDefinitionId();
-	    newState.setDefinitionId(defId);
-	    newState.setType(srcState.getType());
-	    InternalValue[] values = srcState.getValues();
-	    if (values != null) {
-		InternalValue[] newValues = new InternalValue[values.length];
-		for (int i = 0; i < values.length; i++) {
-		    newValues[i] = values[i] != null ? values[i].createCopy() : null;
-		}
-		newState.setValues(values);
-		// FIXME delegate to 'node type instance handler'
-		if (defId != null) {
-		    PropDef def = ntReg.getPropDef(defId);
-		    if (def.getDeclaringNodeType().equals(NodeTypeRegistry.MIX_REFERENCEABLE)) {
-			if (propName.equals(ItemImpl.PROPNAME_UUID)) {
-			    // set correct value of jcr:uuid property
-			    newState.setValues(new InternalValue[]{InternalValue.create(parentUUID)});
-			}
-		    }
-		}
-	    }
-	    return newState;
-	} catch (ItemStateException ise) {
-	    String msg = "internal error: failed to copy state of " + srcHierMgr.safeGetJCRPath(srcState.getId());
-	    log.error(msg, ise);
-	    throw new RepositoryException(msg, ise);
-	}
+                                                             String parentUUID,
+                                                             QName propName,
+                                                             NodeTypeRegistry ntReg,
+                                                             HierarchyManagerImpl srcHierMgr,
+                                                             PersistentItemStateManager srcStateMgr,
+                                                             PersistentItemStateManager destStateMgr)
+            throws RepositoryException {
+        // @todo special handling required for properties with special semantics (e.g. those defined by mix:versionable, mix:lockable, et.al.)
+        PersistentPropertyState newState;
+        try {
+            newState = destStateMgr.createPropertyState(parentUUID, propName);
+            PropDefId defId = srcState.getDefinitionId();
+            newState.setDefinitionId(defId);
+            newState.setType(srcState.getType());
+            InternalValue[] values = srcState.getValues();
+            if (values != null) {
+                InternalValue[] newValues = new InternalValue[values.length];
+                for (int i = 0; i < values.length; i++) {
+                    newValues[i] = values[i] != null ? values[i].createCopy() : null;
+                }
+                newState.setValues(values);
+                // FIXME delegate to 'node type instance handler'
+                if (defId != null) {
+                    PropDef def = ntReg.getPropDef(defId);
+                    if (def.getDeclaringNodeType().equals(NodeTypeRegistry.MIX_REFERENCEABLE)) {
+                        if (propName.equals(ItemImpl.PROPNAME_UUID)) {
+                            // set correct value of jcr:uuid property
+                            newState.setValues(new InternalValue[]{InternalValue.create(parentUUID)});
+                        }
+                    }
+                }
+            }
+            return newState;
+        } catch (ItemStateException ise) {
+            String msg = "internal error: failed to copy state of " + srcHierMgr.safeGetJCRPath(srcState.getId());
+            log.error(msg, ise);
+            throw new RepositoryException(msg, ise);
+        }
-				     PersistentItemStateManager srcStateMgr,
-				     HierarchyManagerImpl srcHierMgr,
-				     String destAbsPath,
-				     PersistentItemStateManager destStateMgr,
-				     HierarchyManagerImpl destHierMgr,
-				     AccessManagerImpl accessMgr,
-				     NamespaceResolver nsResolver,
-				     NodeTypeRegistry ntReg,
-				     boolean clone)
-	    throws ConstraintViolationException, AccessDeniedException,
-	    PathNotFoundException, ItemExistsException, RepositoryException {
+                                     PersistentItemStateManager srcStateMgr,
+                                     HierarchyManagerImpl srcHierMgr,
+                                     String destAbsPath,
+                                     PersistentItemStateManager destStateMgr,
+                                     HierarchyManagerImpl destHierMgr,
+                                     AccessManagerImpl accessMgr,
+                                     NamespaceResolver nsResolver,
+                                     NodeTypeRegistry ntReg,
+                                     boolean clone)
+            throws ConstraintViolationException, AccessDeniedException,
+            PathNotFoundException, ItemExistsException, RepositoryException {
-	// 1. check paths & retrieve state
+        // 1. check paths & retrieve state
-	Path srcPath;
-	PersistentNodeState srcState;
-	try {
-	    srcPath = Path.create(srcAbsPath, nsResolver, true);
-	    srcState = getNodeState(srcPath, srcHierMgr, srcStateMgr);
-	} catch (MalformedPathException mpe) {
-	    String msg = "invalid path: " + srcAbsPath;
-	    log.error(msg, mpe);
-	    throw new RepositoryException(msg, mpe);
-	}
+        Path srcPath;
+        PersistentNodeState srcState;
+        try {
+            srcPath = Path.create(srcAbsPath, nsResolver, true);
+            srcState = getNodeState(srcPath, srcHierMgr, srcStateMgr);
+        } catch (MalformedPathException mpe) {
+            String msg = "invalid path: " + srcAbsPath;
+            log.error(msg, mpe);
+            throw new RepositoryException(msg, mpe);
+        }
-	Path destPath;
-	Path.PathElement destName;
-	Path destParentPath;
-	PersistentNodeState destParentState;
-	try {
-	    destPath = Path.create(destAbsPath, nsResolver, true);
-	    destName = destPath.getNameElement();
-	    destParentPath = destPath.getAncestor(1);
-	    destParentState = getNodeState(destParentPath, destHierMgr, destStateMgr);
-	} catch (MalformedPathException mpe) {
-	    String msg = "invalid path: " + destAbsPath;
-	    log.error(msg, mpe);
-	    throw new RepositoryException(msg, mpe);
-	}
-	int ind = destName.getIndex();
-	if (ind > 0) {
-	    // subscript in name element
-	    String msg = destAbsPath + ": invalid destination path (subscript in name element is not allowed)";
-	    log.error(msg);
-	    throw new RepositoryException(msg);
-	}
+        Path destPath;
+        Path.PathElement destName;
+        Path destParentPath;
+        PersistentNodeState destParentState;
+        try {
+            destPath = Path.create(destAbsPath, nsResolver, true);
+            destName = destPath.getNameElement();
+            destParentPath = destPath.getAncestor(1);
+            destParentState = getNodeState(destParentPath, destHierMgr, destStateMgr);
+        } catch (MalformedPathException mpe) {
+            String msg = "invalid path: " + destAbsPath;
+            log.error(msg, mpe);
+            throw new RepositoryException(msg, mpe);
+        }
+        int ind = destName.getIndex();
+        if (ind > 0) {
+            // subscript in name element
+            String msg = destAbsPath + ": invalid destination path (subscript in name element is not allowed)";
+            log.error(msg);
+            throw new RepositoryException(msg);
+        }
-	// 2. check access rights & node type constraints
+        // 2. check access rights & node type constraints
-	try {
-	    // check read access right on source node
-	    if (!accessMgr.isGranted(srcState.getId(), Permission.READ_ITEM)) {
-		throw new PathNotFoundException(srcAbsPath);
-	    }
-	} catch (ItemNotFoundException infe) {
-	    String msg = "internal error: failed to check access rights for " + srcAbsPath;
-	    log.error(msg, infe);
-	    throw new RepositoryException(msg, infe);
-	}
-	// check node type constraints
-	checkAddNode(destPath, srcState.getNodeTypeName(), ntReg, accessMgr, destHierMgr, destStateMgr);
+        try {
+            // check read access right on source node
+            if (!accessMgr.isGranted(srcState.getId(), Permission.READ_ITEM)) {
+                throw new PathNotFoundException(srcAbsPath);
+            }
+        } catch (ItemNotFoundException infe) {
+            String msg = "internal error: failed to check access rights for " + srcAbsPath;
+            log.error(msg, infe);
+            throw new RepositoryException(msg, infe);
+        }
+        // check node type constraints
+        checkAddNode(destPath, srcState.getNodeTypeName(), ntReg, accessMgr, destHierMgr, destStateMgr);
-	// 3. do copy operation (modify and persist affected states)
+        // 3. do copy operation (modify and persist affected states)
-	// create deep copy of source node state
-	PersistentNodeState newState = copyNodeState(srcState, destParentState.getUUID(),
-		ntReg, srcHierMgr, srcStateMgr, destStateMgr, clone);
+        // create deep copy of source node state
+        PersistentNodeState newState = copyNodeState(srcState, destParentState.getUUID(),
+                ntReg, srcHierMgr, srcStateMgr, destStateMgr, clone);
-	// add to new parent
-	destParentState.addChildNodeEntry(destName.getName(), newState.getUUID());
+        // add to new parent
+        destParentState.addChildNodeEntry(destName.getName(), newState.getUUID());
-	// change definition (id) of new node
-	ChildNodeDef newNodeDef = findApplicableDefinition(destName.getName(), srcState.getNodeTypeName(), destParentState, ntReg);
-	newState.setDefinitionId(new NodeDefId(newNodeDef));
+        // change definition (id) of new node
+        ChildNodeDef newNodeDef = findApplicableDefinition(destName.getName(), srcState.getNodeTypeName(), destParentState, ntReg);
+        newState.setDefinitionId(new NodeDefId(newNodeDef));
-	// persist states
-	try {
-	    newState.store();
-	    destParentState.store();
-	} catch (ItemStateException ise) {
-	    String msg = "internal error: failed to persist state of " + destAbsPath;
-	    log.error(msg, ise);
-	    throw new RepositoryException(msg, ise);
-	}
+        // persist states
+        try {
+            newState.store();
+            destParentState.store();
+        } catch (ItemStateException ise) {
+            String msg = "internal error: failed to persist state of " + destAbsPath;
+            log.error(msg, ise);
+            throw new RepositoryException(msg, ise);
+        }
-	return wspName;
+        return wspName;
-	return session;
+        return session;
-	return rep.getNamespaceRegistry();
+        return rep.getNamespaceRegistry();
-	return session.getNodeTypeManager();
+        return session.getNodeTypeManager();
-	    throws NoSuchWorkspaceException, ConstraintViolationException,
-	    AccessDeniedException, PathNotFoundException,
-	    ItemExistsException, RepositoryException {
-	// clone (i.e. pull) subtree at srcAbsPath from srcWorkspace
-	// to 'this' workspace at destAbsPath
-	PersistentItemStateManager srcStateMgr = rep.getWorkspaceStateManager(srcWorkspace);
-	// FIXME need to setup a hierarchy manager for source workspace
-	HierarchyManagerImpl srcHierMgr = new HierarchyManagerImpl(rep.getRootNodeUUID(), srcStateMgr, session.getNamespaceResolver());
-	// do cross-workspace copy
-	internalCopy(srcAbsPath, srcStateMgr, srcHierMgr,
-		destAbsPath, persistentStateMgr, hierMgr,
-		session.getAccessManager(), session.getNamespaceResolver(),
-		rep.getNodeTypeRegistry(), true);
+            throws NoSuchWorkspaceException, ConstraintViolationException,
+            AccessDeniedException, PathNotFoundException,
+            ItemExistsException, RepositoryException {
+        // clone (i.e. pull) subtree at srcAbsPath from srcWorkspace
+        // to 'this' workspace at destAbsPath
+        PersistentItemStateManager srcStateMgr = rep.getWorkspaceStateManager(srcWorkspace);
+        // FIXME need to setup a hierarchy manager for source workspace
+        HierarchyManagerImpl srcHierMgr = new HierarchyManagerImpl(rep.getRootNodeUUID(), srcStateMgr, session.getNamespaceResolver());
+        // do cross-workspace copy
+        internalCopy(srcAbsPath, srcStateMgr, srcHierMgr,
+                destAbsPath, persistentStateMgr, hierMgr,
+                session.getAccessManager(), session.getNamespaceResolver(),
+                rep.getNodeTypeRegistry(), true);
-	    throws ConstraintViolationException, AccessDeniedException,
-	    PathNotFoundException, ItemExistsException, RepositoryException {
-	// do intra-workspace copy
-	internalCopy(srcAbsPath, persistentStateMgr, hierMgr,
-		destAbsPath, persistentStateMgr, hierMgr,
-		session.getAccessManager(), session.getNamespaceResolver(),
-		rep.getNodeTypeRegistry(), false);
+            throws ConstraintViolationException, AccessDeniedException,
+            PathNotFoundException, ItemExistsException, RepositoryException {
+        // do intra-workspace copy
+        internalCopy(srcAbsPath, persistentStateMgr, hierMgr,
+                destAbsPath, persistentStateMgr, hierMgr,
+                session.getAccessManager(), session.getNamespaceResolver(),
+                rep.getNodeTypeRegistry(), false);
-	    throws ConstraintViolationException, AccessDeniedException,
-	    PathNotFoundException, ItemExistsException, RepositoryException {
+            throws ConstraintViolationException, AccessDeniedException,
+            PathNotFoundException, ItemExistsException, RepositoryException {
-	// intra-workspace move...
+        // intra-workspace move...
-	// 1. check paths & retrieve state
+        // 1. check paths & retrieve state
-	Path srcPath;
-	Path.PathElement srcName;
-	Path srcParentPath;
-	PersistentNodeState targetState;
-	PersistentNodeState srcParentState;
-	try {
-	    srcPath = Path.create(srcAbsPath, session.getNamespaceResolver(), true);
-	    srcName = srcPath.getNameElement();
-	    srcParentPath = srcPath.getAncestor(1);
-	    targetState = getNodeState(srcPath, hierMgr, persistentStateMgr);
-	    srcParentState = getNodeState(srcParentPath, hierMgr, persistentStateMgr);
-	} catch (MalformedPathException mpe) {
-	    String msg = "invalid path: " + srcAbsPath;
-	    log.error(msg, mpe);
-	    throw new RepositoryException(msg, mpe);
-	}
+        Path srcPath;
+        Path.PathElement srcName;
+        Path srcParentPath;
+        PersistentNodeState targetState;
+        PersistentNodeState srcParentState;
+        try {
+            srcPath = Path.create(srcAbsPath, session.getNamespaceResolver(), true);
+            srcName = srcPath.getNameElement();
+            srcParentPath = srcPath.getAncestor(1);
+            targetState = getNodeState(srcPath, hierMgr, persistentStateMgr);
+            srcParentState = getNodeState(srcParentPath, hierMgr, persistentStateMgr);
+        } catch (MalformedPathException mpe) {
+            String msg = "invalid path: " + srcAbsPath;
+            log.error(msg, mpe);
+            throw new RepositoryException(msg, mpe);
+        }
-	Path destPath;
-	Path.PathElement destName;
-	Path destParentPath;
-	PersistentNodeState destParentState;
-	try {
-	    destPath = Path.create(destAbsPath, session.getNamespaceResolver(), true);
-	    destName = destPath.getNameElement();
-	    destParentPath = destPath.getAncestor(1);
-	    destParentState = getNodeState(destParentPath, hierMgr, persistentStateMgr);
-	} catch (MalformedPathException mpe) {
-	    String msg = "invalid path: " + destAbsPath;
-	    log.error(msg, mpe);
-	    throw new RepositoryException(msg, mpe);
-	}
-	int ind = destName.getIndex();
-	if (ind > 0) {
-	    // subscript in name element
-	    String msg = destAbsPath + ": invalid destination path (subscript in name element is not allowed)";
-	    log.error(msg);
-	    throw new RepositoryException(msg);
-	}
+        Path destPath;
+        Path.PathElement destName;
+        Path destParentPath;
+        PersistentNodeState destParentState;
+        try {
+            destPath = Path.create(destAbsPath, session.getNamespaceResolver(), true);
+            destName = destPath.getNameElement();
+            destParentPath = destPath.getAncestor(1);
+            destParentState = getNodeState(destParentPath, hierMgr, persistentStateMgr);
+        } catch (MalformedPathException mpe) {
+            String msg = "invalid path: " + destAbsPath;
+            log.error(msg, mpe);
+            throw new RepositoryException(msg, mpe);
+        }
+        int ind = destName.getIndex();
+        if (ind > 0) {
+            // subscript in name element
+            String msg = destAbsPath + ": invalid destination path (subscript in name element is not allowed)";
+            log.error(msg);
+            throw new RepositoryException(msg);
+        }
-	// 2. check node type constraints & access rights
+        // 2. check node type constraints & access rights
-	checkRemoveNode(srcPath, rep.getNodeTypeRegistry(), session.getAccessManager(), hierMgr, persistentStateMgr);
-	checkAddNode(destPath, targetState.getNodeTypeName(),
-		rep.getNodeTypeRegistry(), session.getAccessManager(),
-		hierMgr, persistentStateMgr);
+        checkRemoveNode(srcPath, rep.getNodeTypeRegistry(), session.getAccessManager(), hierMgr, persistentStateMgr);
+        checkAddNode(destPath, targetState.getNodeTypeName(),
+                rep.getNodeTypeRegistry(), session.getAccessManager(),
+                hierMgr, persistentStateMgr);
-	// 3. do move operation (modify and persist affected states)
+        // 3. do move operation (modify and persist affected states)
-	boolean renameOnly = srcParentState.getUUID().equals(destParentState.getUUID());
+        boolean renameOnly = srcParentState.getUUID().equals(destParentState.getUUID());
-	// add to new parent
-	if (!renameOnly) {
-	    targetState.addParentUUID(destParentState.getUUID());
-	}
-	destParentState.addChildNodeEntry(destName.getName(), targetState.getUUID());
+        // add to new parent
+        if (!renameOnly) {
+            targetState.addParentUUID(destParentState.getUUID());
+        }
+        destParentState.addChildNodeEntry(destName.getName(), targetState.getUUID());
-	// change definition (id) of target node
-	ChildNodeDef newTargetDef = findApplicableDefinition(destName.getName(), targetState.getNodeTypeName(), destParentState, rep.getNodeTypeRegistry());
-	targetState.setDefinitionId(new NodeDefId(newTargetDef));
+        // change definition (id) of target node
+        ChildNodeDef newTargetDef = findApplicableDefinition(destName.getName(), targetState.getNodeTypeName(), destParentState, rep.getNodeTypeRegistry());
+        targetState.setDefinitionId(new NodeDefId(newTargetDef));
-	// remove from old parent
-	if (!renameOnly) {
-	    targetState.removeParentUUID(srcParentState.getUUID());
-	}
-	int srcNameIndex = srcName.getIndex() == 0 ? 1 : srcName.getIndex();
+        // remove from old parent
+        if (!renameOnly) {
+            targetState.removeParentUUID(srcParentState.getUUID());
+        }
+        int srcNameIndex = srcName.getIndex() == 0 ? 1 : srcName.getIndex();
-	srcParentState.removeChildNodeEntry(srcName.getName(), srcNameIndex);
+        srcParentState.removeChildNodeEntry(srcName.getName(), srcNameIndex);
-	// persist states
-	try {
-	    targetState.store();
-	    if (renameOnly) {
-		srcParentState.store();
-	    } else {
-		destParentState.store();
-		srcParentState.store();
-	    }
-	} catch (ItemStateException ise) {
-	    String msg = "internal error: failed to persist state of " + destAbsPath;
-	    log.error(msg, ise);
-	    throw new RepositoryException(msg, ise);
-	}
+        // persist states
+        try {
+            targetState.store();
+            if (renameOnly) {
+                srcParentState.store();
+            } else {
+                destParentState.store();
+                srcParentState.store();
+            }
+        } catch (ItemStateException ise) {
+            String msg = "internal error: failed to persist state of " + destAbsPath;
+            log.error(msg, ise);
+            throw new RepositoryException(msg, ise);
+        }
-	return session.getAccessManager();
+        return session.getAccessManager();
-	    throws UnsupportedRepositoryOperationException, RepositoryException {
-	if (obsMgr == null) {
-	    try {
-		obsMgr = rep.getObservationManagerFactory(wspName).createObservationManager(session, session.getItemManager());
-	    } catch (NoSuchWorkspaceException nswe) {
-		// should never get here
-		String msg = "internal error: failed to instantiate observation manager";
-		log.error(msg, nswe);
-		throw new RepositoryException(msg, nswe);
-	    }
-	}
-	return obsMgr;
+            throws UnsupportedRepositoryOperationException, RepositoryException {
+        if (obsMgr == null) {
+            try {
+                obsMgr = rep.getObservationManagerFactory(wspName).createObservationManager(session, session.getItemManager());
+            } catch (NoSuchWorkspaceException nswe) {
+                // should never get here
+                String msg = "internal error: failed to instantiate observation manager";
+                log.error(msg, nswe);
+                throw new RepositoryException(msg, nswe);
+            }
+        }
+        return obsMgr;
-	if (queryManager == null) {
-	    try {
-		SearchManager searchManager = rep.getSearchManager(wspName);
-		if (searchManager == null) {
-		    throw new UnsupportedOperationException("No search manager configured for this workspace.");
-		}
-		queryManager = new QueryManagerImpl(session, session.getItemManager(), searchManager);
-	    } catch (NoSuchWorkspaceException e) {
-		String msg = "internal error: failed to instantiate query manager";
-		log.error(msg, e);
-		return null;
-	    } catch (RepositoryException e) {
-		String msg = "internal error: failed to instantiate query manager";
-		log.error(msg, e);
-		return null;
-	    }
-	}
-	return queryManager;
+        if (queryManager == null) {
+            try {
+                SearchManager searchManager = rep.getSearchManager(wspName);
+                if (searchManager == null) {
+                    throw new UnsupportedOperationException("No search manager configured for this workspace.");
+                }
+                queryManager = new QueryManagerImpl(session, session.getItemManager(), searchManager);
+            } catch (NoSuchWorkspaceException e) {
+                String msg = "internal error: failed to instantiate query manager";
+                log.error(msg, e);
+                return null;
+            } catch (RepositoryException e) {
+                String msg = "internal error: failed to instantiate query manager";
+                log.error(msg, e);
+                return null;
+            }
+        }
+        return queryManager;
-	// @todo implement versioning support
-	throw new UnsupportedRepositoryOperationException();
+        // @todo implement versioning support
+        throw new UnsupportedRepositoryOperationException();
-	    throws InvalidSerializedDataException, PathNotFoundException, SAXException, RepositoryException {
-	// check path & retrieve state
-	Path path;
-	Path.PathElement name;
-	PersistentNodeState state;
-	try {
-	    path = Path.create(absPath, session.getNamespaceResolver(), true);
-	    name = path.getNameElement();
-	    state = getNodeState(path, hierMgr, persistentStateMgr);
-	} catch (MalformedPathException mpe) {
-	    String msg = "invalid path: " + absPath;
-	    log.error(msg, mpe);
-	    throw new RepositoryException(msg, mpe);
-	}
+            throws InvalidSerializedDataException, PathNotFoundException, SAXException, RepositoryException {
+        // check path & retrieve state
+        Path path;
+        Path.PathElement name;
+        PersistentNodeState state;
+        try {
+            path = Path.create(absPath, session.getNamespaceResolver(), true);
+            name = path.getNameElement();
+            state = getNodeState(path, hierMgr, persistentStateMgr);
+        } catch (MalformedPathException mpe) {
+            String msg = "invalid path: " + absPath;
+            log.error(msg, mpe);
+            throw new RepositoryException(msg, mpe);
+        }
-	// check read access
-	if (!session.getAccessManager().isGranted(state.getId(), Permission.READ_ITEM)) {
-	    throw new PathNotFoundException(absPath);
-	}
+        // check read access
+        if (!session.getAccessManager().isGranted(state.getId(), Permission.READ_ITEM)) {
+            throw new PathNotFoundException(absPath);
+        }
-	new DocViewSAXEventGenerator(state, name.getName(), noRecurse, binaryAsLink,
-		persistentStateMgr, (NamespaceRegistryImpl) rep.getNamespaceRegistry(),
-		session.getAccessManager(), hierMgr, contentHandler).serialize();
+        new DocViewSAXEventGenerator(state, name.getName(), noRecurse, binaryAsLink,
+                persistentStateMgr, (NamespaceRegistryImpl) rep.getNamespaceRegistry(),
+                session.getAccessManager(), hierMgr, contentHandler).serialize();
-	    throws InvalidSerializedDataException, IOException, PathNotFoundException, RepositoryException {
-	OutputFormat format = new OutputFormat("xml", "UTF-8", true);
-	XMLSerializer serializer = new XMLSerializer(out, format);
-	try {
-	    exportDocView(absPath, serializer.asContentHandler(), binaryAsLink, noRecurse);
-	} catch (SAXException se) {
-	    throw new RepositoryException(se);
-	}
+            throws InvalidSerializedDataException, IOException, PathNotFoundException, RepositoryException {
+        OutputFormat format = new OutputFormat("xml", "UTF-8", true);
+        XMLSerializer serializer = new XMLSerializer(out, format);
+        try {
+            exportDocView(absPath, serializer.asContentHandler(), binaryAsLink, noRecurse);
+        } catch (SAXException se) {
+            throw new RepositoryException(se);
+        }
-	    throws PathNotFoundException, SAXException, RepositoryException {
-	// check path & retrieve state
-	Path path;
-	Path.PathElement name;
-	PersistentNodeState state;
-	try {
-	    path = Path.create(absPath, session.getNamespaceResolver(), true);
-	    name = path.getNameElement();
-	    state = getNodeState(path, hierMgr, persistentStateMgr);
-	} catch (MalformedPathException mpe) {
-	    String msg = "invalid path: " + absPath;
-	    log.error(msg, mpe);
-	    throw new RepositoryException(msg, mpe);
-	}
+            throws PathNotFoundException, SAXException, RepositoryException {
+        // check path & retrieve state
+        Path path;
+        Path.PathElement name;
+        PersistentNodeState state;
+        try {
+            path = Path.create(absPath, session.getNamespaceResolver(), true);
+            name = path.getNameElement();
+            state = getNodeState(path, hierMgr, persistentStateMgr);
+        } catch (MalformedPathException mpe) {
+            String msg = "invalid path: " + absPath;
+            log.error(msg, mpe);
+            throw new RepositoryException(msg, mpe);
+        }
-	// check read access
-	if (!session.getAccessManager().isGranted(state.getId(), Permission.READ_ITEM)) {
-	    throw new PathNotFoundException(absPath);
-	}
+        // check read access
+        if (!session.getAccessManager().isGranted(state.getId(), Permission.READ_ITEM)) {
+            throw new PathNotFoundException(absPath);
+        }
-	new SysViewSAXEventGenerator(state, name.getName(), noRecurse, binaryAsLink,
-		persistentStateMgr, (NamespaceRegistryImpl) rep.getNamespaceRegistry(),
-		session.getAccessManager(), hierMgr, contentHandler).serialize();
+        new SysViewSAXEventGenerator(state, name.getName(), noRecurse, binaryAsLink,
+                persistentStateMgr, (NamespaceRegistryImpl) rep.getNamespaceRegistry(),
+                session.getAccessManager(), hierMgr, contentHandler).serialize();
-	OutputFormat format = new OutputFormat("xml", "UTF-8", true);
-	XMLSerializer serializer = new XMLSerializer(out, format);
-	try {
-	    exportSysView(absPath, serializer.asContentHandler(), binaryAsLink, noRecurse);
-	} catch (SAXException se) {
-	    throw new RepositoryException(se);
-	}
+        OutputFormat format = new OutputFormat("xml", "UTF-8", true);
+        XMLSerializer serializer = new XMLSerializer(out, format);
+        try {
+            exportSysView(absPath, serializer.asContentHandler(), binaryAsLink, noRecurse);
+        } catch (SAXException se) {
+            throw new RepositoryException(se);
+        }

MOV26 MOV26 MOV26 DEL66 DEL65 DEL66 DEL65
JCR-1119 SimpleFieldsHelper emits a lot warnings

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@574864 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.ocm.exception.JcrMappingException;
+	    Value propValue;
-			Value propValue = node.getProperty(propertyName).getValue();
-			// HINT: lazy initialize target bean - The bean can be null when it is inline
-			if (null != propValue && null == initializedBean) 
-			{
-				initializedBean = ReflectionUtils.newInstance(classDescriptor.getClassName());
-			}
-
-			AtomicTypeConverter converter = getAtomicTypeConverter(fieldDescriptor, initializedBean, fieldName);
-			Object fieldValue = converter.getObject(propValue);
-			ReflectionUtils.setNestedProperty(initializedBean, fieldName, fieldValue);
+			propValue = node.getProperty(propertyName).getValue();
-		else 
+		else if (fieldDescriptor.getJcrDefaultValue() != null)
-			log.warn("Class '" + classDescriptor.getClassName() + "' has an unmapped property : " 	+ propertyName);
+		    ValueFactory vf = node.getSession().getValueFactory();
+		    propValue = vf.createValue(fieldDescriptor.getJcrDefaultValue());
-		return initializedBean;
+		else
+		{
+		    PropertyDefinition propDef = getPropertyDefinition(node, propertyName);
+		    
+		    if (propDef != null && propDef.getDefaultValues() != null && propDef.getDefaultValues().length == 1)
+		    {
+                log.debug("retrieveSimpleField: Use default value from property definition for missing mapped property " + propertyName + " of class '" + classDescriptor.getClassName() + "'");
+		        propValue = propDef.getDefaultValues()[0];
+		    } else
+		    {
+                log.debug("retrieveSimpleField: No default value available for missing mapped property " + propertyName + " of class '" + classDescriptor.getClassName() + "'");
+		        propValue = null;
+		    }
+		}
+		
+        // HINT: lazy initialize target bean - The bean can be null when it is inline
+		if (initializedBean == null)
+		{
+		    
+		    // if we do not have a value, we do nothing at all and just return null
+		    if (propValue == null)
+		    {
+		        return null;
+		    }
+		    
+		    // otherwise create the bean to set the value
+		    initializedBean = ReflectionUtils.newInstance(classDescriptor.getClassName());
+		}
+
+        AtomicTypeConverter converter = getAtomicTypeConverter(fieldDescriptor, initializedBean, fieldName);
+        Object fieldValue = (propValue != null) ? converter.getObject(propValue) : null;
+        ReflectionUtils.setNestedProperty(initializedBean, fieldName, fieldValue);
+
+        return initializedBean;
-		// 1. Check in the primary node type
-		PropertyDefinition[] propertyDefinitions = objectNode.getPrimaryNodeType().getPropertyDefinitions();
-		for (int i = 0; i < propertyDefinitions.length; i++) {
-			PropertyDefinition definition = propertyDefinitions[i];
-			if (definition.getName().equals(fieldDescriptor.getJcrName()))
-			{
-			    return definition.isProtected();
-			}
-		}
-		
-		// 2. Check in the secondary node types
-		NodeType[] nodeTypes =  objectNode.getMixinNodeTypes();
-		for(int nodeTypeIndex = 0; nodeTypeIndex < nodeTypes.length; nodeTypeIndex++)
+		// 1. Check if the property already exists and may be queried
+		if (objectNode.hasProperty(jcrName))
-			propertyDefinitions = nodeTypes[nodeTypeIndex].getPropertyDefinitions();
-			for (int propDefIndex = 0; propDefIndex < propertyDefinitions.length; propDefIndex++) {
-				PropertyDefinition definition = propertyDefinitions[propDefIndex];
-				if (definition.getName().equals(fieldDescriptor.getJcrName()))
-				{
-				    return definition.isProtected();
-				}
-			}
+		    return objectNode.getProperty(jcrName).getDefinition().isProtected();
+		}
+		    
+		// 2. Find a definition for the property and checks its protected status
+		PropertyDefinition definition = getPropertyDefinition(objectNode, jcrName);
+		if (definition != null)
+		{
+		    return definition.isProtected();
-		return false;
-		
+		return false;		
-		PropertyDefinition[] propertyDefinitions = objectNode.getPrimaryNodeType().getPropertyDefinitions();
-		for (int i = 0; i < propertyDefinitions.length; i++) {
-			PropertyDefinition definition = propertyDefinitions[i];
-			if (definition.getName().equals(fieldDescriptor.getJcrName()) && definition.isMandatory() && (value == null)) {
-				throw new ObjectContentManagerException("Class of type:" + fieldDescriptor.getClassDescriptor().getClassName()
-						+ " has property: " + fieldDescriptor.getFieldName() + " declared as JCR property: "
-						+ fieldDescriptor.getJcrName() + " This property is mandatory but property in bean has value null");
-			}
-		}
+	    if (value == null)
+	    {
+	        PropertyDefinition definition = getPropertyDefinition(objectNode, fieldDescriptor.getJcrName());
+	        if (definition != null)
+	        {
+	            if (definition.isMandatory() && !definition.isAutoCreated())
+	            {
+	                throw new ObjectContentManagerException("Class of type:" + fieldDescriptor.getClassDescriptor().getClassName()
+                        + " has property: " + fieldDescriptor.getFieldName() + " declared as JCR property: "
+                        + fieldDescriptor.getJcrName() + " This property is mandatory but property in bean has value null");
+	            }
+	        }
+	    }
+	
+	
+	/**
+	 * Returns the <code>PropertyDefinition</code> for the name property in
+	 * the given node type. If the node type has no matching node type
+	 * definition <code>null</code> is returned.
+	 * <p>
+	 * This method scans as follows: If a PropertyDefinition with the exact
+	 * name is found which is single-valued, this property definition is
+	 * returned. Otherwise the first residual property definition which is
+	 * single-valued is returned. Otherwise <code>null</code> is returned.
+	 * 
+	 * @param nodeType The <code>NodeType</code> to search for matching node
+	 *         type definitions for the given property.
+	 * @param propertyName The name of the property for which the
+	 *         <code>PropertyDefinition</code> is requested.
+	 *         
+	 * @return The <code>PropertyDefinition</code> for the given property or
+	 *         <code>null</code> if none can be found in the type.
+	 */
+	private PropertyDefinition getPropertyDefinition(NodeType nodeType, String propertyName) {
+        PropertyDefinition[] pd = nodeType.getPropertyDefinitions();
+        PropertyDefinition candidate = null;
+        for (int i=0; i < pd.length; i++)
+        {
+            // ignore multi-value properties
+            if (pd[i].isMultiple())
+            {
+                continue;
+            }
+            
+            // if we have an exact match, use this and return
+            if (propertyName.equals(pd[i].getName()))
+            {
+                return pd[i];
+            }
+            
+            // if we have a residual property definition consider as candidate
+            if (pd[i].getName() == null && candidate == null)
+            {
+                candidate = pd[i];
+            }
+        }
+        
+        // return the potential residal candidate definition
+        return candidate;
+	}
+	
+	/**
+	 * Returns a <code>PropertyDefinition</code> for the given property name.
+	 * This method first looks for a matching property definition in the
+	 * primary node type and then in the list of mixin node types of the node.
+	 * Only single-valued property definitions are considered by this method.
+	 * If a definition whose name is the same as the <code>propertyName</code>
+	 * is found, this definition is returned. Otherwise a residual property
+	 * definition may be returned.
+	 * 
+	 * @param node The <code>Node</code> whose primary and mixin node types are
+	 *         to be scanned for a single-valued property definition.
+	 * @param propertyName The name of the property for which the property
+	 *         definition is to be returned.
+	 *         
+	 * @return The <code>PropertyDefinition</code> for the named property or
+	 *         <code>null</code> if no single-valued exact or residual property
+	 *         definintion may be found in the node's primary or mixin node
+	 *         types.
+	 *         
+	 * @throws RepositoryException If an error occurrs accessing the primary or
+	 *         mixin node types of the node.
+	 */
+	private PropertyDefinition getPropertyDefinition(Node node, String propertyName) throws RepositoryException {
+	    
+	    // try to find the definition in the primary node type
+        NodeType nt = node.getPrimaryNodeType();
+        PropertyDefinition propDef = getPropertyDefinition(nt, propertyName);
+        
+        // return the definition if it is not residual
+        if (propDef != null && propDef.getName() != null)
+        {
+            return propDef;
+        }
+        
+        // otherwise look it up in any of the mixin node types
+        NodeType[] mixins = node.getMixinNodeTypes();
+        for (int i = 0; mixins != null && i < mixins.length; i++)
+        {
+            PropertyDefinition candidate = getPropertyDefinition(mixins[i], propertyName);
+            
+            // use this property definition if not residual
+            if (candidate != null && candidate.getName() != null)
+            {
+                return propDef;
+            }
+            
+            // otherwise use this if we do not have a candidate yet
+            if (propDef == null)
+            {
+                propDef = candidate;
+            }
+        }
+
+        // nothing found
+        return propDef;
+	}

INS31 INS31 INS31 MOV83 MOV39 MOV42 MOV44 MOV44 MOV44 MOV43 MOV43 INS8 MOV8 INS29 INS83 INS43 INS42 INS44 INS44 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS43 INS8 INS60 INS25 MOV25 MOV60 MOV60 MOV21 MOV25 INS25 INS60 MOV25 MOV41 INS65 INS65 INS65 INS65 MOV42 INS43 INS42 INS43 INS42 INS60 INS60 MOV24 INS41 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS42 MOV60 INS60 INS25 INS60 MOV24 INS41 MOV43 INS59 MOV32 INS8 INS25 INS27 INS32 INS8 MOV43 INS59 INS27 MOV27 INS8 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS66 INS66 INS42 INS42 MOV5 MOV59 MOV43 INS59 MOV58 MOV37 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS43 INS43 INS59 INS27 INS8 MOV5 INS59 MOV58 INS27 MOV37 INS42 INS42 INS21 INS27 INS8 MOV8 MOV42 INS33 INS25 INS16 INS42 INS42 INS42 INS41 INS42 INS32 INS42 INS33 INS60 INS25 UPD42 INS42 INS33 UPD40 INS25 INS25 INS42 UPD42 INS42 INS42 INS32 INS27 INS27 INS41 INS42 INS32 INS27 INS27 INS25 INS25 INS7 INS32 INS33 INS60 INS21 INS25 INS27 INS8 INS36 MOV32 INS33 INS32 INS42 INS42 INS42 MOV43 INS59 INS27 INS8 UPD42 MOV42 INS32 INS8 INS27 INS8 UPD42 UPD42 INS42 INS42 INS42 UPD42 MOV42 INS33 INS32 INS33 INS42 INS42 INS42 INS42 INS33 UPD42 MOV42 UPD40 MOV40 INS43 INS27 INS8 INS27 INS8 INS42 MOV32 INS42 INS42 INS43 INS59 INS7 INS43 INS27 MOV8 INS8 INS42 INS33 INS41 INS27 INS32 INS42 INS42 MOV32 INS42 INS33 INS25 INS2 INS42 INS18 UPD42 MOV42 INS27 INS27 INS21 INS42 INS42 INS42 INS42 INS32 INS27 INS27 INS41 INS42 INS33 INS21 INS42 INS42 INS32 INS42 INS32 INS42 UPD42 INS32 INS27 INS27 INS21 INS21 INS21 INS33 INS42 INS33 INS32 INS42 UPD42 MOV42 UPD42 MOV42 MOV27 MOV8 UPD42 MOV42 MOV42 INS2 UPD42 INS2 INS32 INS33 INS42 INS33 INS7 INS42 INS2 INS42 INS42 INS33 INS32 INS33 INS42 INS7 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS27 INS22 INS34 INS7 INS32 INS7 INS42 INS42 INS42 INS38 INS42 INS42 INS42 INS42 INS2 INS42 INS42 INS2 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS32 INS33 INS32 INS42 UPD42 MOV32 INS42 INS2 INS42 INS42 INS27 INS42 INS33 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD45 INS45 INS45 INS32 INS34 INS45 INS42 INS45 INS32 INS45 INS42 INS42 INS42 INS42 INS42 INS42 DEL40 DEL26 DEL45 DEL33 DEL42 DEL27 DEL33 DEL27 DEL27 DEL25 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL43 DEL85 DEL5 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL42 DEL2 DEL42 DEL32 DEL7 DEL21 DEL8 DEL24 DEL8 DEL31 DEL42 DEL42 DEL42 DEL2 DEL59 DEL60 DEL32 DEL42 DEL36 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL40 DEL27 DEL24 DEL8 DEL42 DEL32 DEL42 DEL2 DEL59 DEL60 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL39 DEL42 DEL34 DEL59 DEL58 DEL27 DEL42 DEL37 DEL42 DEL2
- added 'multiValued' flag to ProperyState
- misc. minor fixes and java doc corrections

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@106895 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.OutputStream;
-            ValueConstraint[] constraints = pd.getValueConstraints();
+            /**
+             * check default values:
+             * make sure type of value is consistent with required property type
+             */
+            if (defVals != null && defVals.length != 0) {
+                int reqType = pd.getRequiredType();
+                for (int j = 0; j < defVals.length; j++) {
+                    if (reqType == PropertyType.UNDEFINED) {
+                        reqType = defVals[j].getType();
+                    } else {
+                        if (defVals[j].getType() != reqType) {
+                            String reason = "type of default value(s) is not consistent with required property type";
+                            log.error(reason);
+                            throw new InvalidNodeTypeDefException(reason);
+                        }
+                    }
+                }
+            }
+            /**
+             * todo check that auto-created properties have have at least either default values or system generated values
+             */
+            // check that default values satisfy value constraints
+            ValueConstraint[] constraints = pd.getValueConstraints();
-                // check that default values satisfy value constraints
-     * <li>Default values in property definitions must satisfy value constrains
-     * in the same property child-node definition</li>
+     * <li>Default values in property definitions must satisfy value constraints
+     * specified in the same property definition</li>
-     * <li>Nodetypes specified as constraints in child-node definitions
+     * <li>Node types specified as constraints in child-node definitions
-     * node type constraints in the same child-node definition</li>
+     * node type constraints specified in the same child-node definition</li>
+        OutputStream out = null;
-            customNTDefs.store(customNodeTypesResource.getOutputStream(), nsReg);
+            out = customNodeTypesResource.getOutputStream();
+            customNTDefs.store(out, nsReg);
+        } finally {
+            if (out != null) {
+                try {
+                    out.close();
+                } catch (IOException ioe) {
+                    // ignore
+                }
+            }
+     * Same as <code>{@link #registerNodeType(NodeTypeDef)}</code> except
+     * that a collection of <code>NodeTypeDef</code>s is registered instead of
+     * just one.
+     * <p/>
+     * This method can be used to register a set of node types that have
+     * dependencies on each other.
+     * <p/>
+     * Note that in the case an exception is thrown, some node types might have
+     * been nevertheless successfully registered.
+     *
+     * @param ntDefs a collection of <code>NodeTypeDef<code>s
+     * @throws InvalidNodeTypeDefException
+     * @throws RepositoryException
+     */
+    public synchronized void registerNodeTypes(Collection ntDefs)
+            throws InvalidNodeTypeDefException, RepositoryException {
+        // exceptions that might be thrown by internalRegister(Collection)
+        RepositoryException re = null;
+        InvalidNodeTypeDefException intde = null;
+
+        // store names of currently registered node types before proceeding
+        HashSet oldNTNames = new HashSet(registeredNTDefs.keySet());
+
+        try {
+            // validate and register new node type definitions
+            internalRegister(ntDefs);
+        } catch (RepositoryException e) {
+            // store exception so it can be re-thrown later on
+            re = e;
+        } catch (InvalidNodeTypeDefException e) {
+            // store exception so it can be re-thrown later on
+            intde = e;
+        }
+
+        /**
+         * build set of names of actually registered new node types
+         * (potentially a subset of those specified in ntDefs if an exception
+         * had been thrown)
+         */
+        HashSet newNTNames = new HashSet(registeredNTDefs.keySet());
+        newNTNames.removeAll(oldNTNames);
+
+        if (newNTNames.size() > 0) {
+            // persist new node type definitions
+            for (Iterator iter = newNTNames.iterator(); iter.hasNext(); ) {
+                QName ntName = (QName) iter.next();
+                customNTDefs.add((NodeTypeDef) registeredNTDefs.get(ntName));
+            }
+            OutputStream out = null;
+            try {
+                out = customNodeTypesResource.getOutputStream();
+                customNTDefs.store(out, nsReg);
+            } catch (IOException ioe) {
+                String error = "internal error: failed to write custom node type definition to " + customNodeTypesResource.getPath();
+                log.error(error, ioe);
+                throw new RepositoryException(error, ioe);
+            } catch (FileSystemException fse) {
+                String error = "internal error: failed to write custom node type definition to " + customNodeTypesResource.getPath();
+                log.error(error, fse);
+                throw new RepositoryException(error, fse);
+            } finally {
+                if (out != null) {
+                    try {
+                        out.close();
+                    } catch (IOException ioe) {
+                        // ignore
+                    }
+                }
+            }
+
+            // notify listeners
+            for (Iterator iter = newNTNames.iterator(); iter.hasNext(); ) {
+                QName ntName = (QName) iter.next();
+                notifyRegistered(ntName);
+            }
+        }
+
+        // re-throw exception as necessary
+        if (re != null) {
+            throw re;
+        } else if (intde != null) {
+            throw intde;
+        }
+    }
+
+    /**
+        OutputStream out = null;
-            customNTDefs.store(customNodeTypesResource.getOutputStream(), nsReg);
+            out = customNodeTypesResource.getOutputStream();
+            customNTDefs.store(out, nsReg);
+        } finally {
+            if (out != null) {
+                try {
+                    out.close();
+                } catch (IOException ioe) {
+                    // ignore
+                }
+            }

INS26 INS40 INS31 INS29 INS83 INS83 INS39 INS42 INS44 INS43 INS43 INS8 INS60 INS65 INS65 INS65 INS65 INS43 INS42 INS42 INS42 INS60 INS60 INS60 INS54 INS60 INS21 INS25 INS25 INS60 INS54 MOV60 UPD66 UPD66 UPD66 UPD66 INS43 INS59 INS8 INS8 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS43 INS59 INS8 INS12 INS12 INS43 INS59 INS32 INS27 INS8 INS27 INS8 INS25 INS43 INS59 INS8 INS12 INS12 INS8 INS25 INS42 INS42 INS33 MOV21 INS21 INS25 INS68 INS42 INS42 INS33 INS42 INS42 INS33 INS42 INS42 INS14 INS21 INS44 INS8 INS44 INS8 INS42 INS42 INS14 INS42 INS42 INS42 INS32 INS34 INS24 INS60 MOV54 INS24 INS42 INS33 INS53 INS27 INS8 INS42 INS42 INS33 INS21 INS21 INS44 INS8 INS44 INS8 INS25 INS27 INS8 INS7 INS32 INS27 INS8 INS42 INS69 INS43 INS32 INS32 INS43 INS42 INS21 INS43 INS42 INS21 INS43 INS32 INS42 INS42 INS58 INS32 INS8 INS43 INS59 INS8 INS8 INS58 INS32 INS8 INS42 INS42 INS33 INS53 INS7 INS32 INS43 INS42 INS60 INS21 INS53 INS43 INS42 INS60 INS21 INS53 INS27 INS8 INS27 INS27 INS60 INS24 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS33 INS54 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS42 INS7 INS42 INS42 INS42 INS43 INS59 INS42 INS42 INS60 INS21 INS42 INS42 INS33 MOV21 INS21 INS25 INS43 INS59 INS42 INS42 INS60 INS21 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS14 INS42 INS43 INS59 INS32 INS14 INS42 INS33 INS54 INS42 INS33 INS40 INS34 INS39 INS59 INS58 INS27 INS37 INS8 MOV8 INS12 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS59 INS32 INS7 INS32 INS27 INS8 INS42 INS42 INS32 INS43 INS59 INS32 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS8 INS12 INS42 INS32 INS39 INS59 INS42 INS40 INS42 INS25 INS21 INS44 INS8 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS11 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS33 INS54 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS45 INS32 INS42 INS45 INS32 INS42 INS21 INS44 INS8 INS42 INS42 INS42 INS34 INS27 INS8 INS8 INS32 INS43 INS42 INS43 INS32 INS43 INS32 MOV8 INS12 INS43 INS32 INS42 INS42 INS42 INS42 INS32 INS43 INS42 INS42 INS40 INS21 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS44 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS27 INS8 INS32 INS43 INS42 INS42 INS32 INS32 INS42 INS60 INS21 INS53 INS42 INS42 INS42 INS2 INS42 INS2 INS42 INS43 INS59 INS32 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS43 INS42 INS42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32
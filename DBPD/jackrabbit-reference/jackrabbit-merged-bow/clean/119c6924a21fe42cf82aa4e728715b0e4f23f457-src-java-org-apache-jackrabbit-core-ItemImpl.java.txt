JCR-131: simplifying internal data model (NodeState) by limiting a node to *one* parent



git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@191499 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.collections.ReferenceMap;
+import org.apache.commons.collections.map.ReferenceMap;
-import org.apache.jackrabbit.core.nodetype.NodeDef;
+import org.apache.jackrabbit.core.nodetype.NodeDef;
+import javax.jcr.ItemExistsException;
-import javax.jcr.ItemExistsException;
-import javax.jcr.nodetype.NodeType;
-import javax.jcr.nodetype.NodeDefinition;
-import javax.jcr.nodetype.PropertyDefinition;
+import javax.jcr.nodetype.NodeDefinition;
+import javax.jcr.nodetype.NodeType;
+import javax.jcr.nodetype.PropertyDefinition;
-                throw new InvalidItemStateException(id + ": the item does not exist anymore");
+            throw new InvalidItemStateException(id + ": the item does not exist anymore");
-                        String msg = safeGetJCRPath() + ": cannot save a new item.";
+                        String msg = safeGetJCRPath()
+                                + ": cannot save a new item.";
-                        String msg = safeGetJCRPath() + ": the item cannot be saved because it has been modified externally.";
+                        String msg = safeGetJCRPath()
+                                + ": the item cannot be saved because it has been modified externally.";
-                        String msg = safeGetJCRPath() + ": the item cannot be saved because it has been deleted externally.";
+                        String msg = safeGetJCRPath()
+                                + ": the item cannot be saved because it has been deleted externally.";
-                                + ": the item cannot be saved because it has been modified externally.";
+                                    + ": the item cannot be saved because it has been modified externally.";
-                                + ": the item cannot be saved because it has been deleted externally.";
+                                    + ": the item cannot be saved because it has been deleted externally.";
-                    String msg = transientState.getId() + ": the item cannot be removed because it has been modified externally.";
+                    String msg = transientState.getId()
+                            + ": the item cannot be removed because it has been modified externally.";
-                        + ": the item cannot be removed because it has already been deleted externally.";
+                            + ": the item cannot be removed because it has already been deleted externally.";
+     *
-            try {
-                /**
-                 * turn on temporary path caching for better performance
-                 * (assuming that the paths won't change during this save() call)
-                 */
-                stateMgr.enablePathCaching(true);
+            /**
+             * build list of transient (i.e. new & modified) states that
+             * should be persisted
+             */
+            Collection dirty = getTransientStates();
+            if (dirty.size() == 0) {
+                // no transient items, nothing to do here
+                return;
+            }
-                /**
-                 * build list of transient (i.e. new & modified) states that
-                 * should be persisted
-                 */
-                Collection dirty = getTransientStates();
-                if (dirty.size() == 0) {
-                    // no transient items, nothing to do here
-                    return;
-                }
+            /**
+             * build list of transient descendents in the attic
+             * (i.e. those marked as 'removed')
+             */
+            Collection removed = getRemovedStates();
-                /**
-                 * build list of transient descendents in the attic
-                 * (i.e. those marked as 'removed')
-                 */
-                Collection removed = getRemovedStates();
+            /**
+             * build set of item id's who are within the scope of
+             * (i.e. affected by) this save operation
+             */
+            Set affectedIds = new HashSet(dirty.size() + removed.size());
+            for (Iterator it =
+                    new IteratorChain(dirty.iterator(), removed.iterator());
+                 it.hasNext();) {
+                affectedIds.add(((ItemState) it.next()).getId());
+            }
-                /**
-                 * build set of item id's who are within the scope of
-                 * (i.e. affected by) this save operation
-                 */
-                Set affectedIds = new HashSet(dirty.size() + removed.size());
-                for (Iterator it =
-                        new IteratorChain(dirty.iterator(), removed.iterator());
-                     it.hasNext();) {
-                    affectedIds.add(((ItemState) it.next()).getId());
-                }
-
-                /**
-                 * make sure that this save operation is totally 'self-contained'
-                 * and independant; items within the scope of this save operation
-                 * must not have 'external' dependencies;
-                 * (e.g. adding/removing a parent/child link requires that both
-                 * parent and child are saved)
-                 */
-                for (Iterator it =
-                        new IteratorChain(dirty.iterator(), removed.iterator());
-                     it.hasNext();) {
-                    ItemState transientState = (ItemState) it.next();
-                    if (transientState.isNode()) {
-                        NodeState nodeState = (NodeState) transientState;
-                        Set dependentUUIDs = new HashSet();
-                        // removed parents
-                        dependentUUIDs.addAll(nodeState.getRemovedParentUUIDs());
-                        // added parents
-                        dependentUUIDs.addAll(nodeState.getAddedParentUUIDs());
-                        // removed child node entries
-                        for (Iterator cneIt =
-                                nodeState.getRemovedChildNodeEntries().iterator();
-                             cneIt.hasNext();) {
-                            NodeState.ChildNodeEntry cne =
-                                    (NodeState.ChildNodeEntry) cneIt.next();
-                            dependentUUIDs.add(cne.getUUID());
-                        }
-                        // added child node entries
-                        for (Iterator cneIt =
-                                nodeState.getAddedChildNodeEntries().iterator();
-                             cneIt.hasNext();) {
-                            NodeState.ChildNodeEntry cne =
-                                    (NodeState.ChildNodeEntry) cneIt.next();
-                            dependentUUIDs.add(cne.getUUID());
-                        }
-
-                        // now walk through dependencies and check whether they
-                        // are within the scope of this save operation
-                        Iterator depIt = dependentUUIDs.iterator();
-                        while (depIt.hasNext()) {
-                            NodeId id = new NodeId((String) depIt.next());
-                            if (!affectedIds.contains(id)) {
-                                // need to save the parent as well
-                                String msg = itemMgr.safeGetJCRPath(id)
-                                        + " needs to be saved as well.";
-                                log.debug(msg);
-                                throw new ConstraintViolationException(msg);
+            /**
+             * make sure that this save operation is totally 'self-contained'
+             * and independant; items within the scope of this save operation
+             * must not have 'external' dependencies;
+             * (e.g. moving a node requires that the target node including both
+             * old and new parents are saved)
+             */
+            for (Iterator it =
+                    new IteratorChain(dirty.iterator(), removed.iterator());
+                 it.hasNext();) {
+                ItemState transientState = (ItemState) it.next();
+                if (transientState.isNode()) {
+                    NodeState nodeState = (NodeState) transientState;
+                    Set dependentUUIDs = new HashSet();
+                    if (nodeState.hasOverlayedState()) {
+                        String oldParentUUID =
+                                nodeState.getOverlayedState().getParentUUID();
+                        String newParentUUID = nodeState.getParentUUID();
+                        if (oldParentUUID != null) {
+                            if (newParentUUID == null) {
+                                // node has been removed, add old parent
+                                // to dependencies
+                                dependentUUIDs.add(oldParentUUID);
+                            } else {
+                                if (oldParentUUID != null &&
+                                        !oldParentUUID.equals(newParentUUID)) {
+                                    // node has been moved, add old and new parent
+                                    // to dependencies
+                                    dependentUUIDs.add(oldParentUUID);
+                                    dependentUUIDs.add(newParentUUID);
+                                }
-                }
-
-                /**
-                 * validate access and node type constraints
-                 * (this will also validate child removals)
-                 */
-                validateTransientItems(dirty.iterator(), removed.iterator());
-
-                /**
-                 * referential integrity checks:
-                 * make sure that a referenced node cannot be removed and
-                 * that all references are updated and persisted
-                 */
-                Collection dirtyRefs =
-                        checkReferences(dirty.iterator(), removed.iterator());
-
-
-                // start the update operation
-                try {
-                    stateMgr.edit();
-                } catch (IllegalStateException e) {
-                    String msg = "Unable to start edit operation";
-                    log.debug(msg);
-                    throw new RepositoryException(msg, e);
-                }
-
-                boolean succeeded = false;
-
-                try {
-
-                    // process transient items marked as 'removed'
-                    removeTransientItems(removed.iterator());
-
-                    // initialize version histories for new nodes (might generate new transient state)
-                    if (initVersionHistories(dirty.iterator())) {
-                        // re-build the list of transient states because the previous call
-                        // generated new transient state
-                        dirty = getTransientStates();
-
-                        // and the references as well
-                        dirtyRefs = checkReferences(dirty.iterator(), removed.iterator());
+                    // removed child node entries
+                    for (Iterator cneIt =
+                            nodeState.getRemovedChildNodeEntries().iterator();
+                         cneIt.hasNext();) {
+                        NodeState.ChildNodeEntry cne =
+                                (NodeState.ChildNodeEntry) cneIt.next();
+                        dependentUUIDs.add(cne.getUUID());
+                    }
+                    // added child node entries
+                    for (Iterator cneIt =
+                            nodeState.getAddedChildNodeEntries().iterator();
+                         cneIt.hasNext();) {
+                        NodeState.ChildNodeEntry cne =
+                                (NodeState.ChildNodeEntry) cneIt.next();
+                        dependentUUIDs.add(cne.getUUID());
-                    // process 'new' or 'modified' transient states
-                    persistTransientItems(dirty.iterator());
-
-                    // dispose the transient states marked 'new' or 'modified'
-                    // at this point item state data is pushed down one level,
-                    // node instances are disconnected from the transient
-                    // item state and connected to the 'overlayed' item state.
-                    // transient item states must be removed now. otherwise
-                    // the session item state provider will return an orphaned
-                    // item state which is not referenced by any node instance.
-                    for (Iterator it = dirty.iterator(); it.hasNext();) {
-                        ItemState transientState = (ItemState) it.next();
-                        // dispose the transient state, it is no longer used
-                        stateMgr.disposeTransientItemState(transientState);
-                    }
-
-                    // store the references calculated above
-                    for (Iterator it = dirtyRefs.iterator(); it.hasNext();) {
-                        stateMgr.store((NodeReferences) it.next());
-                    }
-
-                    // end update operation
-                    stateMgr.update();
-                    // update operation succeeded
-                    succeeded = true;
-                } catch (ItemStateException e) {
-                    String msg = safeGetJCRPath() + ": unable to update item.";
-                    log.debug(msg);
-                    throw new RepositoryException(msg, e);
-                } finally {
-                    if (!succeeded) {
-                        // update operation failed, cancel all modifications
-                        stateMgr.cancel();
+                    // now walk through dependencies and check whether they
+                    // are within the scope of this save operation
+                    Iterator depIt = dependentUUIDs.iterator();
+                    while (depIt.hasNext()) {
+                        NodeId id = new NodeId((String) depIt.next());
+                        if (!affectedIds.contains(id)) {
+                            // need to save the parent as well
+                            String msg = itemMgr.safeGetJCRPath(id)
+                                    + " needs to be saved as well.";
+                            log.debug(msg);
+                            throw new ConstraintViolationException(msg);
+                        }
+            }
-                // now it is safe to dispose the transient states:
-                // dispose the transient states marked 'removed'.
-                // item states in attic are removed after store, because
-                // the observation mechanism needs to build paths of removed
-                // items in store().
-                for (Iterator it = removed.iterator(); it.hasNext();) {
+            /**
+             * validate access and node type constraints
+             * (this will also validate child removals)
+             */
+            validateTransientItems(dirty.iterator(), removed.iterator());
+
+            /**
+             * referential integrity checks:
+             * make sure that a referenced node cannot be removed and
+             * that all references are updated and persisted
+             */
+            Collection dirtyRefs =
+                    checkReferences(dirty.iterator(), removed.iterator());
+
+
+            // start the update operation
+            try {
+                stateMgr.edit();
+            } catch (IllegalStateException e) {
+                String msg = "Unable to start edit operation";
+                log.debug(msg);
+                throw new RepositoryException(msg, e);
+            }
+
+            boolean succeeded = false;
+
+            try {
+
+                // process transient items marked as 'removed'
+                removeTransientItems(removed.iterator());
+
+                // initialize version histories for new nodes (might generate new transient state)
+                if (initVersionHistories(dirty.iterator())) {
+                    // re-build the list of transient states because the previous call
+                    // generated new transient state
+                    dirty = getTransientStates();
+
+                    // and the references as well
+                    dirtyRefs = checkReferences(dirty.iterator(), removed.iterator());
+                }
+
+                // process 'new' or 'modified' transient states
+                persistTransientItems(dirty.iterator());
+
+                // dispose the transient states marked 'new' or 'modified'
+                // at this point item state data is pushed down one level,
+                // node instances are disconnected from the transient
+                // item state and connected to the 'overlayed' item state.
+                // transient item states must be removed now. otherwise
+                // the session item state provider will return an orphaned
+                // item state which is not referenced by any node instance.
+                for (Iterator it = dirty.iterator(); it.hasNext();) {
-                    stateMgr.disposeTransientItemStateInAttic(transientState);
+                    stateMgr.disposeTransientItemState(transientState);
+
+                // store the references calculated above
+                for (Iterator it = dirtyRefs.iterator(); it.hasNext();) {
+                    stateMgr.store((NodeReferences) it.next());
+                }
+
+                // end update operation
+                stateMgr.update();
+                // update operation succeeded
+                succeeded = true;
+            } catch (ItemStateException e) {
+                String msg = safeGetJCRPath() + ": unable to update item.";
+                log.debug(msg);
+                throw new RepositoryException(msg, e);
-                // turn off temporary path caching
-                stateMgr.enablePathCaching(false);
+                if (!succeeded) {
+                    // update operation failed, cancel all modifications
+                    stateMgr.cancel();
+                }
+            }
+
+            // now it is safe to dispose the transient states:
+            // dispose the transient states marked 'removed'.
+            // item states in attic are removed after store, because
+            // the observation mechanism needs to build paths of removed
+            // items in store().
+            for (Iterator it = removed.iterator(); it.hasNext();) {
+                ItemState transientState = (ItemState) it.next();
+                // dispose the transient state, it is no longer used
+                stateMgr.disposeTransientItemStateInAttic(transientState);

MOV26 MOV26 MOV26 MOV26 UPD40 MOV8 MOV21 INS51 INS42 MOV8 INS25 INS32 INS8 INS42 INS42 INS60 INS60 INS25 INS43 INS59 INS43 INS59 INS27 INS8 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS33 INS25 INS32 INS42 INS42 INS42 INS27 INS8 INS8 INS42 INS42 INS42 INS33 MOV21 INS25 INS27 INS8 UPD42 UPD42 MOV42 INS27 INS38 MOV21 INS21 INS42 INS33 INS32 INS32 INS42 INS42 INS42 UPD42 UPD42 MOV42 INS42 INS42 INS42 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL54 DEL42 DEL51 DEL8
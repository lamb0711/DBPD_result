JCR-3265 double check for false positives in consistency checker for reliable consistency in clustered setup

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1350205 13f79535-47bb-0310-9956-ffa450edef68

+            final NodeId childNodeId = entry.getId();
+
-            if (entry.getId().toString().endsWith("babecafebabe")) {
+            if (childNodeId.toString().endsWith("babecafebabe")) {
-                NodePropBundle child = pm.loadBundle(entry.getId());
+                final NodePropBundle childBundle = pm.loadBundle(childNodeId);
-                if (child == null) {
-                    message = "NodeState '" + id
-                            + "' references inexistent child" + " '"
-                            + entry.getName() + "' with id " + "'"
-                            + entry.getId() + "'";
-                    log.error(message);
-                    missingChildren.add(entry);
+                if (childBundle == null) {
+                    // double check whether we still exist and the child entry is still there
+                    bundle = pm.loadBundle(id);
+
+                    if (bundle != null) {
+                        boolean stillThere = false;
+                        for (NodePropBundle.ChildNodeEntry entryRetry : bundle.getChildNodeEntries()) {
+                            if (entryRetry.getId().equals(childNodeId)) {
+                                stillThere = true;
+                                break;
+                            }
+                        }
+                        if (stillThere) {
+                            message = "NodeState '" + id
+                                    + "' references inexistent child" + " '"
+                                    + entry.getName() + "' with id " + "'"
+                                    + childNodeId + "'";
+                            log.error(message);
+                            missingChildren.add(entry);
+                        }
+                    }
-                    NodeId cp = child.getParentId();
-                    if (cp == null) {
-                        message = "ChildNode has invalid parent id: <null>";
-                        log.error(message);
-                    } else if (!cp.equals(id)) {
-                        message = "ChildNode has invalid parent id: '" + cp
-                                + "' (instead of '" + id + "')";
-                        log.error(message);
+                    NodeId cp = childBundle.getParentId();
+                    if (cp == null || !cp.equals(id)) {
+                        // double check whether the child entry is still there
+                        bundle = pm.loadBundle(id);
+                        if (bundle != null) {
+                            boolean stillThere = false;
+                            for (NodePropBundle.ChildNodeEntry entryRetry : bundle.getChildNodeEntries()) {
+                                if (entryRetry.getId().equals(childNodeId)) {
+                                    stillThere = true;
+                                    break;
+                                }
+                            }
+                            if (stillThere) {
+                                if (cp == null) {
+                                    message = "ChildNode has invalid parent id: <null>";
+                                    log.error(message);
+                                } else if (!cp.equals(id)) {
+                                    message = "ChildNode has invalid parent id: '" + cp
+                                            + "' (instead of '" + id + "')";
+                                    log.error(message);
+                                }
+                            }
+                        }
-                    String message = "NodeState '" + id
-                            + "' references inexistent parent id '" + parentId
-                            + "'";
-                    log.error(message);
-                    addMessage(reports, id, message);
-                    orphaned.add(id);
-                    if (lostNFoundId != null) {
-                        bundle.setParentId(lostNFoundId);
-                        modifications.add(bundle);
+                    // double check whether we still exist and the parent is still the same
+                    bundle = pm.loadBundle(id);
+                    if (bundle != null) {
+                        if (parentId.equals(bundle.getParentId())) {
+                            String message = "NodeState '" + id
+                                    + "' references inexistent parent id '" + parentId
+                                    + "'";
+                            log.error(message);
+                            addMessage(reports, id, message);
+                            orphaned.add(id);
+                            if (lostNFoundId != null) {
+                                bundle.setParentId(lostNFoundId);
+                                modifications.add(bundle);
+                            }
+                        }
-                    for (NodePropBundle.ChildNodeEntry entry : parentBundle
-                            .getChildNodeEntries()) {
+                    for (NodePropBundle.ChildNodeEntry entry : parentBundle.getChildNodeEntries()) {
-                        String message = "NodeState '" + id
-                                + "' is not referenced by its parent node '"
-                                + parentId + "'";
-                        log.error(message);
-                        addMessage(reports, id, message);
+                        // double check whether we still exist and the parent is still the same
+                        bundle = pm.loadBundle(id);
+                        if (bundle != null) {
+                            if (parentId.equals(bundle.getParentId())) {
+                                String message = "NodeState '" + id
+                                        + "' is not referenced by its parent node '"
+                                        + parentId + "'";
+                                log.error(message);
+                                addMessage(reports, id, message);
-                        int l = (int) System.currentTimeMillis();
-                        int r = new Random().nextInt();
-                        int n = l + r;
-                        String nodeName = Integer.toHexString(n);
-                        parentBundle.addChildNodeEntry(
-                                NF.create("{}" + nodeName), id);
-                        log.info("NodeState '" + id
-                                + "' adds itself to its parent node '"
-                                + parentId + "' with a new name '" + nodeName
-                                + "'");
-                        modifications.add(parentBundle);
+                                int l = (int) System.currentTimeMillis();
+                                int r = new Random().nextInt();
+                                int n = l + r;
+                                String nodeName = Integer.toHexString(n);
+                                parentBundle.addChildNodeEntry(
+                                        NF.create("{}" + nodeName), id);
+                                log.info("NodeState '" + id
+                                        + "' adds itself to its parent node '"
+                                        + parentId + "' with a new name '" + nodeName
+                                        + "'");
+                                modifications.add(parentBundle);
+                            }
+                        }
+

MOV60 INS83 INS43 INS42 UPD42 MOV32 INS60 INS25 UPD42 MOV42 INS83 MOV43 INS59 INS27 INS8 INS8 INS8 INS42 INS32 INS42 INS33 INS21 INS25 INS60 INS25 INS21 INS25 INS25 INS42 INS42 INS42 INS7 INS27 INS8 MOV43 INS59 INS27 INS8 INS7 INS27 INS8 MOV38 INS8 INS42 INS32 INS42 INS33 INS60 INS70 INS25 INS42 INS32 INS27 INS38 INS21 INS25 INS42 INS32 INS42 INS33 INS25 INS21 INS25 INS42 INS42 INS42 INS39 INS59 INS44 INS32 INS8 INS42 MOV8 INS42 INS42 INS42 INS33 INS32 INS7 INS27 INS8 INS42 INS42 INS42 INS32 MOV8 INS7 INS27 INS8 INS42 INS9 INS43 INS42 INS42 INS42 INS25 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS60 INS70 MOV25 INS42 INS42 INS32 INS42 INS32 INS42 INS33 MOV25 INS40 INS32 INS8 INS42 INS42 INS42 INS39 INS59 INS44 INS32 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS21 INS10 INS42 INS9 INS43 INS42 INS42 INS42 INS25 INS42 INS42 INS32 INS42 INS42 INS7 INS42 INS40 INS32 INS8 INS42 INS42 INS42 INS9 INS32 INS42 INS42 INS21 INS10 INS42 INS42 INS7 INS42 INS9 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60
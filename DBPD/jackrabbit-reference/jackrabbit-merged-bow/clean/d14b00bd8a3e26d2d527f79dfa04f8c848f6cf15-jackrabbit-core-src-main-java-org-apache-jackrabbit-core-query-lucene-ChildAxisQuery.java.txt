JCR-1041: Avoid using BitSets in ChildAxisQuery to minimize memory usage

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@566042 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.query.lucene.hits.AdaptingHits;
+import org.apache.jackrabbit.core.query.lucene.hits.Hits;
+import org.apache.jackrabbit.core.query.lucene.hits.HitsIntersection;
+import org.apache.jackrabbit.core.query.lucene.hits.ScorerHits;
-import java.util.BitSet;
-         * BitSet storing the id's of selected documents
-         */
-        private final BitSet hits;
-
-        /**
-         * List of UUIDs of selected nodes
-         */
-        private List uuids = null;
-
-        /**
+         * A <code>Hits</code> instance containing all hits
+         */
+        private Hits hits;
+
+        /**
-            this.hits = new BitSet(reader.maxDoc());
-            nextDoc = hits.nextSetBit(nextDoc + 1);
+            do {
+                nextDoc = hits.next();
+            } while (nextDoc >= 0 && !indexIsValid(nextDoc));
+            
-            nextDoc = hits.nextSetBit(target);
-            return nextDoc > -1;
+            nextDoc = hits.skipTo(target);
+            while (!indexIsValid(nextDoc))
+                next();
+            return nextDoc > -1;            
-            if (uuids == null) {
-                uuids = new ArrayList();
+            if (hits == null) {
+                
+                // collect all context nodes
+                List uuids = new ArrayList();
+                final Hits contextHits = new AdaptingHits();
-                        hits.set(doc);
+                        contextHits.set(doc);
-                // collect nameTest hits
-                final BitSet nameTestHits = new BitSet();
-                if (nameTestScorer != null) {
-                    nameTestScorer.score(new HitCollector() {
-                        public void collect(int doc, float score) {
-                            nameTestHits.set(doc);
-                        }
-                    });
-                }
-
-                for (int i = hits.nextSetBit(0); i >= 0; i = hits.nextSetBit(i + 1)) {
+                int i = contextHits.next();
+                while (i > -1) {
+                    i = contextHits.next();
+                
+                // collect all children of the context nodes
+                Hits childrenHits = new AdaptingHits();
-                // collect the doc ids of all child nodes. we reuse the existing
-                // bitset.
-                hits.clear();
-                            hits.set(docs.doc());
+                            childrenHits.set(docs.doc());
-                // filter out the child nodes that do not match the name test
-                // if there is any name test at all.
+                
-                    hits.and(nameTestHits);
-                }
-
-                // filter by index
-                if (position != LocationStepQueryNode.NONE) {
-                    for (int i = hits.nextSetBit(0); i >= 0; i = hits.nextSetBit(i + 1)) {
-                        Document node = reader.document(i);
-                        NodeId parentId = NodeId.valueOf(node.get(FieldNames.PARENT));
-                        NodeId id = NodeId.valueOf(node.get(FieldNames.UUID));
-                        try {
-                            NodeState state = (NodeState) itemMgr.getItemState(parentId);
-                            if (nameTest == null) {
-                                // only select this node if it is the child at
-                                // specified position
-                                if (position == LocationStepQueryNode.LAST) {
-                                    // only select last
-                                    List childNodes = state.getChildNodeEntries();
-                                    if (childNodes.size() == 0
-                                            || !((NodeState.ChildNodeEntry) childNodes.get(childNodes.size() - 1))
-                                                .getId().equals(id)) {
-                                        hits.flip(i);
-                                    }
-                                } else {
-                                    List childNodes = state.getChildNodeEntries();
-                                    if (position < 1
-                                            || childNodes.size() < position
-                                            || !((NodeState.ChildNodeEntry) childNodes.get(position - 1)).getId().equals(id)) {
-                                        hits.flip(i);
-                                    }
-                                }
-                            } else {
-                                // select the node when its index is equal to
-                                // specified position
-                                if (position == LocationStepQueryNode.LAST) {
-                                    // only select last
-                                    NodeState.ChildNodeEntry entry =
-                                            state.getChildNodeEntry(id);
-                                    if (entry == null) {
-                                        // no such child node, probably deleted meanwhile
-                                        hits.flip(i);
-                                    } else {
-                                        // only use the last one
-                                        QName name = entry.getName();
-                                        List childNodes = state.getChildNodeEntries(name);
-                                        if (childNodes.size() == 0
-                                                || !((NodeState.ChildNodeEntry) childNodes.get(childNodes.size() - 1))
-                                                    .getId().equals(id)) {
-                                            hits.flip(i);
-                                        }
-                                    }
-                                } else {
-                                    NodeState.ChildNodeEntry entry =
-                                            state.getChildNodeEntry(id);
-                                    if (entry == null) {
-                                        // no such child node, probably has been deleted meanwhile
-                                        hits.flip(i);
-                                    } else {
-                                        if (entry.getIndex() != position) {
-                                            hits.flip(i);
-                                        }
-                                    }
-                                }
-                            }
-                        } catch (ItemStateException e) {
-                            // ignore this node, probably has been deleted meanwhile
-                            hits.flip(i);
-                        }
-                    }
+                    hits = new HitsIntersection(childrenHits, new ScorerHits(nameTestScorer));
+                } else {
+                    hits = childrenHits;
+
+        private boolean indexIsValid(int i) throws IOException {
+            if (position != LocationStepQueryNode.NONE) {
+                Document node = reader.document(i);
+                NodeId parentId = NodeId.valueOf(node.get(FieldNames.PARENT));
+                NodeId id = NodeId.valueOf(node.get(FieldNames.UUID));
+                try {
+                    NodeState state = (NodeState) itemMgr.getItemState(parentId);
+                    if (nameTest == null) {
+                        // only select this node if it is the child at
+                        // specified position
+                        if (position == LocationStepQueryNode.LAST) {
+                            // only select last
+                            List childNodes = state.getChildNodeEntries();
+                            if (childNodes.size() == 0
+                                    || !((NodeState.ChildNodeEntry) childNodes.get(childNodes.size() - 1))
+                                        .getId().equals(id)) {
+                                return false;
+                            }
+                        } else {
+                            List childNodes = state.getChildNodeEntries();
+                            if (position < 1
+                                    || childNodes.size() < position
+                                    || !((NodeState.ChildNodeEntry) childNodes.get(position - 1)).getId().equals(id)) {
+                                return false;
+                            }
+                        }
+                    } else {
+                        // select the node when its index is equal to
+                        // specified position
+                        if (position == LocationStepQueryNode.LAST) {
+                            // only select last
+                            NodeState.ChildNodeEntry entry =
+                                    state.getChildNodeEntry(id);
+                            if (entry == null) {
+                                // no such child node, probably deleted meanwhile
+                                return false;
+                            } else {
+                                // only use the last one
+                                QName name = entry.getName();
+                                List childNodes = state.getChildNodeEntries(name);
+                                if (childNodes.size() == 0
+                                        || !((NodeState.ChildNodeEntry) childNodes.get(childNodes.size() - 1))
+                                            .getId().equals(id)) {
+                                    return false;
+                                }
+                            }
+                        } else {
+                            NodeState.ChildNodeEntry entry =
+                                    state.getChildNodeEntry(id);
+                            if (entry == null) {
+                                // no such child node, probably has been deleted meanwhile
+                                return false;
+                            } else {
+                                if (entry.getIndex() != position) {
+                                    return false;
+                                }
+                            }
+                        }
+                    }
+                } catch (ItemStateException e) {
+                    // ignore this node, probably has been deleted meanwhile
+                    return false;
+                }
+            }
+            return true;
+        }

MOV26 INS26 INS26 INS26 UPD40 INS40 INS40 INS40 MOV23 INS31 INS31 UPD43 MOV29 INS83 INS39 INS42 MOV43 INS8 INS83 INS39 INS42 INS43 INS8 UPD39 UPD42 MOV44 MOV8 UPD42 MOV21 INS19 MOV41 INS61 INS42 INS25 UPD42 INS25 INS41 UPD66 INS8 INS27 INS38 INS21 INS27 INS8 MOV27 MOV8 INS9 INS21 INS27 INS38 INS32 INS32 INS42 INS33 INS60 INS60 INS21 INS60 INS61 INS60 MOV60 MOV54 INS25 INS7 INS42 INS34 INS32 UPD42 INS42 INS42 INS42 MOV43 INS59 INS83 INS43 INS59 INS32 INS39 INS59 INS27 MOV8 INS43 INS59 MOV27 INS8 INS8 INS42 INS32 INS42 INS42 MOV42 MOV14 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS32 INS42 INS38 INS21 INS42 INS42 INS14 MOV21 INS21 INS42 INS42 INS43 MOV43 INS1 INS42 INS42 INS34 INS7 INS43 INS7 INS41 INS42 INS31 INS42 INS32 INS42 UPD42 INS14 INS42 INS42 INS9 MOV83 UPD39 MOV39 INS42 MOV44 MOV44 INS8 INS42 INS42 INS43 INS42 INS14 INS21 INS42 INS43 INS42 INS32 INS42 INS42 INS42 INS42 UPD42 INS41 INS41 INS41 INS41 INS9 INS9 INS9 INS9 INS41 INS41 INS9 INS9 DEL66 DEL65 DEL29 DEL83 DEL33 DEL59 DEL23 DEL83 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL7 DEL21 DEL42 DEL8 DEL31 DEL42 DEL42 DEL42 DEL34 DEL27 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL39 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL58 DEL42 DEL34 DEL27 DEL42 DEL42 DEL42 DEL42 DEL34 DEL27 DEL32 DEL7 DEL24 DEL42 DEL33 DEL27 DEL42 DEL7 DEL21 DEL42 DEL42 DEL83 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL1 DEL14 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL43 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL1 DEL14 DEL32 DEL21 DEL8 DEL25 DEL39 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL58 DEL42 DEL34 DEL27 DEL42 DEL42 DEL42 DEL42 DEL34 DEL27 DEL32 DEL7 DEL24 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL25 DEL8 DEL25 DEL8
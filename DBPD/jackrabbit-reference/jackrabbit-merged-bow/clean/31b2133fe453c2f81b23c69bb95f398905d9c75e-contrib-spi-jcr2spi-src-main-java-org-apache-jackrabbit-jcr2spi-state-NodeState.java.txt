work in progress

- reorder: wrong usage of OrderPatch
- reorder: missing check for 'before' being null
- reorder: affected-items in op. not consistent with modified items
- move: session.move must remember srcId 
- spi: add possibility to obtain sessionInfo for another workspace based on an existing sessionInfo.
- uriresolver: defensive check for type of ItemId

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@464431 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.name.MalformedPathException;
-     * A current element Path instance.
-     */
-    public static final Path CURRENT_PATH;
-
-    static {
-        try {
-            Path.PathBuilder builder = new Path.PathBuilder();
-            builder.addFirst(Path.CURRENT_ELEMENT);
-            CURRENT_PATH = builder.getPath();
-        } catch (MalformedPathException e) {
-            // path is always valid
-            throw new InternalError("unable to create path from '.'");
-        }
-    }
-
-    /**
-                if (id.equals(event.getParentId())) {
-                    ItemId evId = event.getItemId();
-                    ItemState newState = null;
-
-                    if (evId.denotesNode()) {
-                        QName name = event.getQPath().getNameElement().getName();
-                        int index = event.getQPath().getNameElement().getNormalizedIndex();
-                        String uuid = (((NodeId)evId).getPath() != null) ? null : ((NodeId)evId).getUUID();
-
-                        // add new childNodeEntry if it has not been added by
-                        // some earlier 'add' event
-                        // TODO: TOBEFIXED for SNSs
-                        ChildNodeEntry cne = getChildNodeEntry(name, index);
-                        if (cne == null || ((uuid == null) ? cne.getUUID() != null : !uuid.equals(cne.getUUID()))) {
-                            cne = childNodeEntries.add(name, uuid);
-                        }
-                        try {
-                            newState = cne.getNodeState();
-                        } catch (ItemStateException e) {
-                            log.error("Internal error", e);
-                        }
-                    } else {
-                        QName pName = ((PropertyId) event.getItemId()).getQName();
-                        // create a new property reference if it has not been
-                        // added by some earlier 'add' event
-                        ChildPropertyEntry re;
-                        if (hasPropertyName(pName)) {
-                            re = (ChildPropertyEntry) properties.get(pName);
-                        } else {
-                            re = PropertyReference.create(this, pName, isf, idFactory);
-                            properties.put(pName, re);
-                        }
-                        try {
-                            newState = re.getPropertyState();
-                        } catch (ItemStateException e) {
-                            log.error("Internal error", e);
-                        }
-                        // make sure this state is up to date (uuid/mixins)
-                        refresh(pName, event.getType());
-                    }
-
-                    // connect the added state from the transient layer to the
-                    // new workspaceState and make sure its data are updated.
-                    if (newState != null && changeLog != null) {
-                        for (Iterator it = changeLog.addedStates(); it.hasNext();) {
-                            ItemState added = (ItemState) it.next();
-                            if (added.hasOverlayedState()) {
-                                // already connected
-                                continue;
-                            }
-                            // TODO: TOBEFIXED. may fail (produce wrong results) for SNSs, since currently events upon 'save' are not garantied to be 'local' changes only
-                            if (added.getId().equals(evId)) {
-                                added.connect(newState);
-                                added.merge();
-                                break;
-                            }
-                        }
-                    }
-                    // and let the transiently modified session state now, that
-                    // its workspace state has been touched.
-                    setStatus(Status.MODIFIED);
-                } else {
-                    // ILLEGAL
-                    throw new IllegalArgumentException("Illegal event type " + event.getType() + " for NodeState.");
+                if (!id.equals(event.getParentId())) {
+                    // TODO: TOBEFIXED. this should never occur and indicates severe consistency issue.
+                    throw new IllegalArgumentException("Event parent (" + event.getParentId() + ") does not match this state with id: " + id);
+                ItemId evId = event.getItemId();
+                ItemState newState = null;
+
+                if (evId.denotesNode()) {
+                    QName name = event.getQPath().getNameElement().getName();
+                    int index = event.getQPath().getNameElement().getNormalizedIndex();
+                    String uuid = (((NodeId)evId).getPath() != null) ? null : ((NodeId)evId).getUUID();
+
+                    // add new childNodeEntry if it has not been added by
+                    // some earlier 'add' event
+                    // TODO: TOBEFIXED for SNSs
+                    ChildNodeEntry cne = getChildNodeEntry(name, index);
+                    if (cne == null || ((uuid == null) ? cne.getUUID() != null : !uuid.equals(cne.getUUID()))) {
+                        cne = childNodeEntries.add(name, uuid);
+                    }
+                    try {
+                        newState = cne.getNodeState();
+                    } catch (ItemStateException e) {
+                        log.error("Internal error", e);
+                    }
+                } else {
+                    QName pName = ((PropertyId) event.getItemId()).getQName();
+                    // create a new property reference if it has not been
+                    // added by some earlier 'add' event
+                    ChildPropertyEntry re;
+                    if (hasPropertyName(pName)) {
+                        re = (ChildPropertyEntry) properties.get(pName);
+                    } else {
+                        re = PropertyReference.create(this, pName, isf, idFactory);
+                        properties.put(pName, re);
+                    }
+                    try {
+                        newState = re.getPropertyState();
+                    } catch (ItemStateException e) {
+                        log.error("Internal error", e);
+                    }
+                    // make sure this state is up to date (uuid/mixins)
+                    refresh(pName, event.getType());
+                }
+
+                // connect the added state from the transient layer to the
+                // new workspaceState and make sure its data are updated.
+                if (newState != null && changeLog != null) {
+                    for (Iterator it = changeLog.addedStates(); it.hasNext();) {
+                        ItemState added = (ItemState) it.next();
+                        if (added.hasOverlayedState()) {
+                            // already connected
+                            continue;
+                        }
+                        // TODO: TOBEFIXED. may fail (produce wrong results) for SNSs, since currently events upon 'save' are not garantied to be 'local' changes only
+                        // TODO: TOBEFIXED. equals to false if added-state is referenceable.
+                        if (added.getId().equals(evId)) {
+                            added.connect(newState);
+                            added.merge();
+                            break;
+                        }
+                    }
+                }
+                // and let the transiently modified session state now, that
+                // its workspace state has been touched.
+                setStatus(Status.MODIFIED);
+                Set toRemove = new HashSet();
-                                childNodeEntries.remove(cne.getName(), cne.getIndex());
+                                toRemove.add(cne);
-                        childNodeEntries.remove(cne.getName(), cne.getIndex());
+                        toRemove.add(cne);
+                for (Iterator it = toRemove.iterator(); it.hasNext();) {
+                    ChildNodeEntry cne = (ChildNodeEntry) it.next();
+                    childNodeEntries.remove(cne.getName(), cne.getIndex());
+                }
-
+        childState.markModified();

MOV8 MOV21 MOV60 INS50 INS21 MOV32 MOV49 MOV49 INS25 MOV60 MOV60 MOV25 MOV25 MOV21 INS10 MOV49 MOV25 INS10 MOV49 MOV25 INS10 MOV49 MOV25 INS10 INS49 MOV53 INS32 INS38 INS8 INS42 INS42 MOV32 INS53 INS14 INS60 INS24 INS43 INS27 INS43 INS59 INS58 INS32 MOV8 INS42 INS45 INS32 INS45 INS42 INS42 INS42 INS14 INS43 INS59 INS42 INS42 INS60 INS42 INS42 INS43 INS42 INS42 INS32 INS43 INS59 INS42 INS8 INS42 INS42 INS42 INS42 INS11 INS21 INS43 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 MOV42 MOV42 DEL40 DEL26 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL40 DEL43 DEL42 DEL40 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL40 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL28 DEL42 DEL43 DEL45 DEL42 DEL42 DEL32 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL10 DEL10 DEL10 DEL10 DEL49 DEL50 DEL8 DEL42 DEL42 DEL32 DEL42 DEL32
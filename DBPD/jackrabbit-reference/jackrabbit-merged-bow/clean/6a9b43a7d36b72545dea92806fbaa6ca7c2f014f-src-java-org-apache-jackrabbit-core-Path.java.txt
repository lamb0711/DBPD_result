- minor path/qname adjustments

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@125923 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.util.Text;
+
-import java.util.regex.Matcher;
+import java.util.regex.Matcher;
- * The <code>Path</code> utility class provides
- * misc. methods to resolve and nornalize JCR-style item paths.
+ * The <code>Path</code> utility class provides misc. methods to resolve and
+ * nornalize JCR-style item paths. <br>
+ * Each path consistnes of path elements and is immutable. it has the following
+ * properties:<br>
+ * <code>isAbsolute()</code>:<br>
+ * A path is absolute, if the first path element denotes the root element '/'.
+ * <p>
+ * <code>isRelative()</code>:<br>
+ * A path is relative, if the first path element does not denote the root element.
+ * I.e. is always the opposite of <code>isAbsolute</code>.
+ * <p>
+ * <code>isNormalized()</code>:<br>
+ * A path is normalized, if all '.' and '..' path elements are resolved as much
+ * as possible. If the path is absolute, it is normalized if it contains
+ * no such elements. for example the path '../../a' is normalized where as
+ * '../../b/../a/.' is not. Normalized path never have '.' elements.
+ * absolte normalilzed paths have no and relative normalized paths have no or
+ * only leading '..' elements.<br>
+ * <p>
+ * <code>isCanonical()</code>:<br>
+ * A path is canonical, if its absolute and normalized.
+ * <p>
+ *
+ * the external string representation of a path has the following format:
+ *
+ * <xmp>
+ *           path ::= properpath ['/']
+ *     properpath ::= abspath | relpath
+ *        abspath ::= '/' relpath
+ *        relpath ::= [relpath '/'] pathelement
+ *    pathelement ::= name ['[' number ']']
+ *         number ::= << An integer > 0 >>
+ *
+ *           name ::= [prefix ':'] simplename
+ *         prefix ::= << Any valid XML Name >>
+ *     simplename ::= nonspacestring [[string] nonspacestring]
+ *         string ::= [string] char
+ *           char ::= nonspace | space
+ * nonspacestring ::= [nonspacestring] nonspace
+ *          space ::= << ' ' (the space character) >>
+ *       nonspace ::= << Any Unicode character except
+ *                    '/', ':', '[', ']', '*',
+ *                    '''(the single quote),
+ *                    '"'(the double quote),
+ *                    any whitespace character >>
+ * </xmp>
+     * the 'root' element. i.e. '/'
+     */
+    private static final PathElement ROOT_ELEMENT = new RootElement();
+
+    /**
+     * the 'current' element. i.e. '.'
+     */
+    private static final PathElement CURRENT_ELEMENT = new CurrentElement();
+
+    /**
+     * the 'parent' element. i.e. '..'
+     */
+    private static final PathElement PARENT_ELEMENT = new ParentElement();
+
+    /**
+     * the root path
+     */
+    public static final Path ROOT = new Path(new PathElement[]{ROOT_ELEMENT}, true);
+
+    /**
-    private static final PathElement ROOT_ELEMENT = new RootElement();
-    // .
-    private static final PathElement CURRENT_ELEMENT = new CurrentElement();
-    // ..
-    private static final PathElement PARENT_ELEMENT = new ParentElement();
-
+    /**
+     * the elements of this path
+     */
-    private int hash;
+    /**
+     * flag indicating if this path is normalized
+     */
+    private final boolean isNormalized;
+
+    /**
+     * flag indicating if this path is absolute
+     */
+    private final boolean isAbsolute;
+
+    /**
+     * the cached hashcode of this path
+     */
+    private int hash = 0;
+
+    /**
+     * the cached 'toString' of this path
+     */
+     * @param isNormalized
-    private Path(PathElement[] elements) {
+    private Path(PathElement[] elements, boolean isNormalized) {
+        if (elements==null || elements.length==0) {
+            throw new IllegalArgumentException("Empty paths are not allowed");
+        }
-        hash = 0;
+        this.isAbsolute = elements[0].denotesRoot();
+        this.isNormalized = isNormalized;
-    //------------------------------------------------------< factory methods >
+    //----------------------------------------------------< factory methods >---
+     * Creates a new <code>Path</code> from the given <code>jcrPath</code>
+     * string. If <code>normalize</code> is <code>true</code>, the returned
+     * path will be normalized (or canonicalized if absolute).
+     *
-     * @param canonicalize
+     * @param normalize
-    public static Path create(String jcrPath, NamespaceResolver resolver, boolean canonicalize)
+    public static Path create(String jcrPath, NamespaceResolver resolver,
+                              boolean normalize)
-        PathElement[] elements = parse(jcrPath, null, resolver);
-        if (canonicalize) {
-            return new Path(elements).getCanonicalPath();
-        } else {
-            return new Path(elements);
-        }
+        return normalize
+            ? parse(jcrPath, null, resolver).getNormalizedPath()
+            : parse(jcrPath, null, resolver);
-     * @param master
+     * Creates a new <code>Path</code> out of the given <code>parent</code> path
+     * and a relative path string. If <code>canonicalize</code> is
+     * <code>true</code>, the returned path will be canonicalized.
+     *
+     * @param parent
-    public static Path create(Path master, String relJCRPath, NamespaceResolver resolver, boolean canonicalize)
+    public static Path create(Path parent, String relJCRPath,
+                              NamespaceResolver resolver, boolean canonicalize)
-        if (relJCRPath.startsWith("/")) {
-            throw new MalformedPathException("'" + relJCRPath + "' is not a relative path");
-        }
-
-        PathElement[] elements = parse(relJCRPath, master.getElements(), resolver);
-        if (canonicalize) {
-            return new Path(elements).getCanonicalPath();
-        } else {
-            return new Path(elements);
-        }
+        return canonicalize
+                ? parse(relJCRPath, parent, resolver).getCanonicalPath()
+                : parse(relJCRPath, parent, resolver);
-     * @param master
+     * Creates a new <code>Path</code> out of the given <code>parent<code> path
+     * string and the given relative path string. If <code>normalize</code> is
+     * <code>true</code>, the returned path will be normalized (or
+     * canonicalized, if the parent path is absolute).
+     *
+     * @param parent
-     * @param canonicalize
+     * @param normalize
-    public static Path create(Path master, Path relPath, boolean canonicalize)
+    public static Path create(Path parent, Path relPath, boolean normalize)
-        PathBuilder pb = new PathBuilder(master.getElements());
+        PathBuilder pb = new PathBuilder(parent.getElements());
-        if (canonicalize) {
-            return pb.getPath().getCanonicalPath();
-        } else {
-            return pb.getPath();
-        }
+        return normalize
+            ? pb.getPath().getNormalizedPath()
+            : pb.getPath();
-     * @param master
+     * Creates a new <code>Path</code> out of the given <code>parent<code> path
+     * string and the give name. If <code>normalize</code> is <code>true</code>,
+     * the returned path will be normalized (or canonicalized, if the parent
+     * path is absolute).
+     *
+     * @param parent
-     * @param canonicalize
+     * @param normalize
-    public static Path create(Path master, QName name, boolean canonicalize)
+    public static Path create(Path parent, QName name, boolean normalize)
-        PathBuilder pb = new PathBuilder(master.getElements());
-        pb.addLast(name.getNamespaceURI(), name.getLocalName());
+        PathBuilder pb = new PathBuilder(parent.getElements());
+        pb.addLast(name);
-        if (canonicalize) {
-            return pb.getPath().getCanonicalPath();
-        } else {
-            return pb.getPath();
-        }
+        return normalize
+                ? pb.getPath().getNormalizedPath()
+                : pb.getPath();
-     * @param master
+     * Creates a new <code>Path</code> out of the given <code>parent<code> path
+     * string and the give name and index. If <code>normalize</code> is
+     * <code>true</code>, the returned path will be normalized
+     * (or canonicalized, if the parent path is absolute).
+     *
+     * @param parent
-     * @param canonicalize
+     * @param normalize
-    public static Path create(Path master, QName name, int index, boolean canonicalize)
+    public static Path create(Path parent, QName name, int index, boolean normalize)
-        PathBuilder pb = new PathBuilder(master.getElements());
-        pb.addLast(name.getNamespaceURI(), name.getLocalName(), index);
+        PathBuilder pb = new PathBuilder(parent.getElements());
+        pb.addLast(name, index);
-        if (canonicalize) {
-            return pb.getPath().getCanonicalPath();
-        } else {
-            return pb.getPath();
-        }
+        return normalize
+                ? pb.getPath().getNormalizedPath()
+                : pb.getPath();
-        return new Path(new PathElement[]{elem});
+        return new Path(new PathElement[]{elem}, !elem.equals(CURRENT_ELEMENT));
-        if (jcrPath == null || jcrPath.length() == 0) {
-            throw new MalformedPathException("empty path");
-        }
-        // shortcut
-        if (jcrPath.equals("/")) {
-            return;
-        }
-
-        // split path into path elements
-        String[] elems = jcrPath.split("/", -1);
-        for (int i = jcrPath.startsWith("/") ? 1 : 0; i < elems.length; i++) {
-            // validate path element
-            String elem = elems[i];
-            Matcher matcher = PATH_ELEMENT_PATTERN.matcher(elem);
-            if (!matcher.matches()) {
-                // illegal syntax for path element
-                throw new MalformedPathException("'" + jcrPath + "' is not a valid path: '" + elem + "' is not a legal path element");
-            }
-        }
+        parse(jcrPath, null, null);
-        return elements.length == 1 && elements[0].denotesRoot();
+        return isAbsolute && elements.length == 1;
-        return elements.length > 0 && elements[0].denotesRoot();
+        return isAbsolute;
-        if (!isAbsolute()) {
-            return false;
-        }
-        // check path for any "." and ".." elements
-        for (int i = 0; i < elements.length; i++) {
-            if (elements[i].equals(CURRENT_ELEMENT)
-                    || elements[i].equals(PARENT_ELEMENT)) {
-                return false;
-            }
-        }
-        return true;
+        return isAbsolute && isNormalized;
-        if (isAbsolute()) {
-            /**
-             * a normalized absolute path has to be canonical, i.e. it
-             * cannot contain any "." and ".." elements
-             */
-            return isCanonical();
-        }
-
-        // check relative path for redundant "." and ".." elements only
-        for (int i = 0; i < elements.length; i++) {
-            if (elements[i].equals(CURRENT_ELEMENT)) {
-                // "." is always redundant
-                return false;
-            }
-            if (elements[i].equals(PARENT_ELEMENT)) {
-                /**
-                 * ".." is redundant only if there's a preceeding
-                 * non-".." element
-                 */
-                if (i > 0 && !elements[i - 1].equals(PARENT_ELEMENT)) {
-                    return false;
-                }
-            }
-        }
-        return true;
+        return isNormalized;
+     * <p>
+     * If the normalized path results in an empty path (eg: 'a/..') or if an
+     * absolute path is normalized that would result in a 'negative' path
+     * (eg: /a/../../) a MalformedPathException is thrown.
+     * @throws MalformedPathException if the path cannot be normalized.
-    public Path getNormalizedPath() {
+    public Path getNormalizedPath() throws MalformedPathException {
-
+        PathElement last = null;
-
-            if (elem.equals(CURRENT_ELEMENT)) {
+            if (elem.denotesCurrent()) {
-            } else if (elem.equals(PARENT_ELEMENT)) {
-                if (queue.size() > 0 && !queue.getLast().equals(PARENT_ELEMENT)) {
-                    queue.removeLast();
-                } else {
-                    queue.add(elem);
+            } else if (elem.denotesParent() && last!=null && !last.denotesParent()) {
+                if (last.denotesRoot()) {
+                    // the first element is the root element;
+                    // ".." would refer to the parent of root
+                    throw new MalformedPathException("Path can not be canonicalized: unresolvable '..' element");
+                queue.removeLast();
+                last = queue.isEmpty() ? null : (PathElement) queue.getLast();
-                queue.add(elem);
+                queue.add(last=elem);
-        return new Path((PathElement[]) queue.toArray(new PathElement[queue.size()]));
+        if (queue.isEmpty()) {
+            throw new MalformedPathException("Path can not be normalized: would result in an empty path.");
+        }
+        return new Path((PathElement[]) queue.toArray(new PathElement[queue.size()]), true);
-
-        LinkedList queue = new LinkedList();
-        for (int i = 0; i < elements.length; i++) {
-            PathElement elem = elements[i];
-
-            if (elem.equals(CURRENT_ELEMENT)) {
-                continue;
-            } else if (elem.equals(PARENT_ELEMENT)) {
-                if (queue.size() <= 1) {
-                    // the first element is the root element;
-                    // ".." would refer to the parent of root
-                    throw new MalformedPathException("path can not be canonicalized: unresolvable '..' element");
-                }
-                queue.removeLast();
-            } else {
-                queue.add(elem);
-            }
-        }
-        return new Path((PathElement[]) queue.toArray(new PathElement[queue.size()]));
+        return getNormalizedPath();
-     * canonical, e.g. the ancestor of degree = 1 of the path "../.." would
+     * normalized, e.g. the ancestor of degree = 1 of the path "../.." would
-        return new Path(elements);
+        return new Path(elements, isNormalized);
-     * this path is an absolute or a relative path.
+     * this path is an absolute or a relative path. The depth also takes '.'
+     * and '..' elements into account.
-            if (elements[i].equals(PARENT_ELEMENT)) {
+            if (elements[i].denotesParent()) {
-            } else if (!elements[i].equals(CURRENT_ELEMENT)) {
+            } else if (!elements[i].denotesCurrent()) {
+
-        if (equals(other)) {
-            return false;
-        }
-        String[] elements = s.split("\t", -1);
+        String[] elements = Text.explode(s, '\t', true);
+        boolean isNormalized = true;
+        boolean leadingParent = true;
-            String elem = elements[i];
-            list.add(PathElement.fromString(elem));
+            PathElement elem = PathElement.fromString(elements[i]);
+            list.add(elem);
+            leadingParent &= elem.denotesParent();
+            isNormalized &= !elem.denotesCurrent() && (leadingParent || !elem.denotesParent());
-        return new Path((PathElement[]) list.toArray(new PathElement[list.size()]));
+        return new Path((PathElement[]) list.toArray(new PathElement[list.size()]), isNormalized);
-     * package private inner class used to build a path from path elements;
+     * package protected inner class used to build a path from path elements;
+
+        /**
+         * the list of path elements of the constructed path
+         */
+        /**
+         * flag indicating if the current path is normalized
+         */
+        boolean isNormalized = true;
+
+        /**
+         * flag indicating if the current path has leading parent '..' elements
+         */
+        boolean leadingParent = true;
+
+        /**
+         * Creates a new PathBuilder.
+         */
+        /**
+         * Creates a new PathBuilder and initialized it with the given path
+         * elements.
+         *
+         * @param elements
+         */
+        /**
+         * Adds the {@link Path#ROOT_ELEMENT}.
+         */
-            queue.addFirst(ROOT_ELEMENT);
+            addFirst(ROOT_ELEMENT);
+        /**
+         * Adds the given elemenets
+         * @param elements
+         */
-                queue.add(elements[i]);
+                addLast(elements[i]);
-        void addFirst(String nameSpaceURI, String localName) {
-            queue.addFirst(new PathElement(nameSpaceURI, localName));
+        /**
+         * Inserts the element at the beginning of the path to be built.
+         * @param elem
+         */
+        public void addFirst(PathElement elem) {
+            if (queue.isEmpty()) {
+                isNormalized &= !elem.denotesCurrent();
+                leadingParent = elem.denotesParent();
+            } else {
+                isNormalized &= !elem.denotesCurrent() && (!leadingParent || elem.denotesParent());
+                leadingParent |= elem.denotesParent();
+            }
+            queue.addFirst(elem);
-        void addFirst(String nameSpaceURI, String localName, int index) {
-            queue.addFirst(new PathElement(nameSpaceURI, localName, index));
-        }
-
+        /**
+         * Inserts the element at the beginning of the path to be built.
+         * @param name
+         */
-            queue.addFirst(new PathElement(name));
+            addFirst(new PathElement(name));
+        /**
+         * Inserts the element at the beginning of the path to be built.
+         * @param name
+         * @param index
+         */
-            queue.addFirst(new PathElement(name, index));
+            addFirst(new PathElement(name, index));
-        void addLast(String nameSpaceURI, String localName) {
-            queue.addLast(new PathElement(nameSpaceURI, localName));
+        /**
+         * Inserts the element at the end of the path to be built.
+         * @param elem
+         */
+        public void addLast(PathElement elem) {
+            queue.addLast(elem);
+            leadingParent &= elem.denotesParent();
+            isNormalized &= !elem.denotesCurrent() && (leadingParent || !elem.denotesParent());
-        void addLast(String nameSpaceURI, String localName, int index) {
-            queue.addLast(new PathElement(nameSpaceURI, localName, index));
-        }
-
+        /**
+         * Inserts the element at the end of the path to be built.
+         * @param name
+         */
-            queue.addLast(new PathElement(name));
+            addLast(new PathElement(name));
+        /**
+         * Inserts the element at the end of the path to be built.
+         * @param name
+         * @param index
+         */
-            queue.addLast(new PathElement(name, index));
+            addLast(new PathElement(name, index));
+        /**
+         * Assembles the built path and returns a new {@link Path}.
+         * @return
+         * @throws MalformedPathException if the internal path element queue is empty.
+         */
-            for (int i = 1; i < elements.length; i++) {
-                if (elements[i].denotesRoot()) {
-                    throw new MalformedPathException("path contains invalid root element(s)");
-                }
-            }
-            return new Path(elements);
+
+            // no need to check the path format, assuming all names correct
+            return new Path(elements, isNormalized);
-    private static PathElement[] parse(String jcrPath, PathElement[] master,
-                                       NamespaceResolver resolver)
+
+    /**
+     * parses the give string an d returns an array of path elements. if
+     * <code>master</code> is not <code>null</code>, it is prepended to the
+     * returned list. If <code>resolver</code> is <code>null</code>, this
+     * method only checks the format of the string and returns <code>null</code>.
+     *
+     * @param jcrPath
+     * @param master
+     * @param resolver
+     * @return
+     * @throws MalformedPathException
+     */
+    private static Path parse(String jcrPath, Path master, NamespaceResolver resolver)
-            return new PathElement[]{ROOT_ELEMENT};
+            return ROOT;
-        String[] elems = jcrPath.split("/", -1);
+        String[] elems = Text.explode(jcrPath, '/', true);
+        boolean isNormalized = true;
+        boolean leadingParent = true;
+            isNormalized = master.isNormalized;
-            for (int i = 0; i < master.length; i++) {
-                list.add(master[i]);
+            for (int i = 0; i < master.elements.length; i++) {
+                list.add(master.elements[i]);
+                leadingParent &= master.elements[i].denotesParent();
+                leadingParent = false;
+                if (resolver==null) {
+                    // check only
+                    continue;
+                }
+
+                    leadingParent = false;
+                    isNormalized = false;
+                    isNormalized &= leadingParent;
+                    leadingParent = false;
-        return (PathElement[]) list.toArray(new PathElement[list.size()]);
+        return resolver == null
+                ? null
+                : new Path((PathElement[]) list.toArray(new PathElement[list.size()]), isNormalized);
+

MOV26 INS26 MOV23 INS40 INS23 INS23 INS23 INS29 INS29 INS29 INS29 INS83 INS83 INS83 INS43 INS59 INS29 INS29 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS39 INS59 INS29 INS29 INS44 MOV43 MOV43 MOV43 MOV44 MOV43 MOV43 INS44 MOV44 INS8 INS8 MOV43 INS23 INS23 INS31 INS31 INS31 INS31 INS29 INS43 MOV44 UPD66 UPD66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS65 INS65 INS65 INS42 INS42 INS14 INS65 INS65 INS42 INS65 INS42 INS65 INS34 INS65 INS65 INS39 INS42 INS25 INS21 INS65 MOV65 UPD42 INS41 INS65 MOV43 INS42 INS41 INS65 MOV43 INS42 UPD42 MOV41 INS65 INS65 MOV65 MOV43 INS42 UPD42 MOV41 INS65 INS65 INS65 INS65 INS65 MOV43 INS42 UPD42 MOV41 INS21 INS41 MOV41 INS65 INS60 INS25 INS60 INS60 INS29 INS29 INS39 INS59 INS29 INS39 INS59 INS29 INS29 INS29 INS29 INS29 INS83 MOV39 MOV42 MOV44 INS8 INS29 MOV44 INS29 MOV39 MOV42 MOV44 MOV44 MOV8 INS29 INS83 MOV39 MOV42 MOV44 INS8 INS29 MOV44 INS29 MOV39 MOV42 MOV44 MOV44 MOV8 INS29 INS65 INS65 MOV65 INS65 INS65 MOV65 UPD42 MOV42 INS60 INS60 INS66 INS66 INS66 INS66 MOV43 MOV3 INS9 INS66 INS66 INS66 INS66 INS66 INS42 INS27 INS8 INS7 INS66 INS66 INS66 UPD42 INS16 INS66 INS66 INS66 UPD42 INS16 INS66 INS66 INS66 INS66 UPD42 UPD42 MOV43 INS16 INS66 INS66 INS66 INS66 UPD42 INS42 UPD42 MOV43 INS16 INS66 INS66 INS66 INS66 INS42 INS42 INS42 UPD42 INS42 MOV43 INS16 INS32 INS42 INS27 INS42 INS66 INS66 INS66 INS66 INS42 INS66 INS43 INS59 INS32 INS8 INS32 UPD66 UPD66 INS66 INS39 INS59 INS39 INS59 UPD66 INS65 INS65 INS42 INS9 INS65 INS42 INS9 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 MOV43 INS42 INS25 MOV21 INS65 MOV65 INS65 MOV65 MOV65 INS65 INS65 MOV43 INS42 MOV21 INS21 INS21 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS66 INS66 INS66 INS66 INS42 INS42 INS39 INS59 INS39 INS59 INS16 INS27 INS27 INS53 INS22 MOV32 INS22 INS42 INS42 INS32 MOV32 INS42 INS32 INS32 INS42 INS32 MOV32 MOV42 INS42 INS32 MOV32 MOV42 INS42 MOV32 MOV32 INS38 UPD42 MOV42 UPD42 MOV42 INS33 INS33 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS53 INS9 INS42 MOV43 INS42 MOV25 INS42 INS9 INS42 INS9 INS21 INS21 INS21 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS65 INS66 INS66 INS42 INS66 INS42 INS32 INS8 INS8 INS66 INS66 INS66 INS42 INS7 INS7 INS66 INS42 INS66 INS42 INS42 INS66 INS65 INS66 INS42 INS66 INS42 INS9 INS42 INS9 INS21 INS27 INS33 INS14 INS42 INS33 INS40 INS34 INS14 INS52 INS42 INS52 INS42 INS32 INS42 INS32 INS42 MOV42 MOV42 UPD42 MOV42 MOV42 MOV43 MOV32 INS42 MOV43 MOV32 INS42 MOV43 UPD42 INS32 INS14 MOV32 MOV8 INS25 UPD42 INS42 UPD42 INS13 INS9 UPD43 INS32 INS7 INS7 INS67 INS42 INS42 INS21 INS21 INS21 INS21 INS42 INS42 INS42 INS32 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS13 INS9 INS7 INS42 INS33 INS43 MOV11 INS42 INS43 INS45 INS42 UPD42 MOV42 INS33 INS42 UPD42 MOV42 INS42 INS42 INS42 UPD42 UPD42 UPD42 INS42 INS42 MOV42 UPD42 INS27 INS8 MOV43 INS45 UPD42 MOV38 MOV8 MOV42 INS32 MOV42 MOV42 INS42 INS42 INS32 INS42 INS27 INS42 INS42 INS7 INS7 INS7 INS7 INS42 INS42 INS38 INS36 INS42 INS40 UPD40 INS21 INS21 INS25 INS42 INS42 INS27 MOV38 MOV25 MOV21 MOV21 MOV32 INS42 INS42 MOV2 INS42 INS42 INS38 INS36 UPD42 MOV2 INS42 INS38 INS42 INS32 INS42 INS27 INS42 INS32 INS32 INS27 INS7 INS7 INS27 MOV8 INS32 UPD27 MOV27 INS32 INS7 UPD42 INS32 INS27 INS32 INS42 INS42 INS38 INS36 INS42 INS42 INS42 UPD42 MOV42 INS42 INS38 INS42 INS32 INS42 INS9 INS42 INS33 INS21 INS21 MOV42 UPD42 MOV42 INS42 INS33 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 MOV42 MOV42 INS42 INS16 INS7 INS42 INS42 INS42 INS38 INS42 INS42 INS32 INS27 INS32 INS40 INS2 INS42 INS7 INS7 INS21 INS21 INS32 INS33 INS11 INS42 INS42 INS32 INS42 INS42 INS38 INS32 INS42 INS42 INS40 INS42 INS42 INS9 INS42 INS9 INS7 INS7 UPD45 MOV42 UPD42 MOV42 MOV43 MOV32 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 DEL42 DEL34 DEL42 DEL43 DEL85 DEL5 DEL42 DEL59 DEL60 DEL42 DEL42 DEL14 DEL32 DEL41 DEL8 DEL42 DEL14 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL45 DEL32 DEL45 DEL42 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL14 DEL42 DEL32 DEL41 DEL8 DEL42 DEL14 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL41 DEL8 DEL8 DEL25 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL8 DEL41 DEL8 DEL25 DEL42 DEL42 DEL45 DEL32 DEL41 DEL8 DEL25 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL45 DEL34 DEL38 DEL32 DEL59 DEL60 DEL39 DEL42 DEL45 DEL32 DEL34 DEL34 DEL16 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL42 DEL42 DEL2 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL38 DEL42 DEL43 DEL45 DEL42 DEL45 DEL42 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL8 DEL24 DEL40 DEL34 DEL27 DEL42 DEL34 DEL2 DEL42 DEL32 DEL27 DEL42 DEL32 DEL38 DEL9 DEL41 DEL8 DEL25 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL42 DEL42 DEL32 DEL42 DEL42 DEL2 DEL42 DEL42 DEL32 DEL27 DEL9 DEL41 DEL8 DEL25 DEL8 DEL24 DEL9 DEL41 DEL8 DEL42 DEL32 DEL42 DEL32 DEL8 DEL25 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL42 DEL42 DEL32 DEL9 DEL41 DEL8 DEL25 DEL42 DEL42 DEL2 DEL42 DEL42 DEL32 DEL42 DEL34 DEL27 DEL42 DEL42 DEL34 DEL27 DEL2 DEL42 DEL42 DEL32 DEL38 DEL27 DEL9 DEL41 DEL8 DEL25 DEL8 DEL25 DEL8 DEL24 DEL9 DEL41 DEL8 DEL42 DEL42 DEL32 DEL34 DEL42 DEL33 DEL27 DEL32 DEL34 DEL27 DEL27 DEL42 DEL32 DEL42 DEL32 DEL27 DEL8 DEL8 DEL25 DEL8 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL42 DEL42 DEL2 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL34 DEL27 DEL45 DEL14 DEL53 DEL8 DEL25 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL25 DEL8 DEL24 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL32 DEL3 DEL32 DEL11 DEL14 DEL42 DEL42 DEL25 DEL42 DEL42 DEL32 DEL9 DEL41 DEL8 DEL25 DEL45 DEL34 DEL38 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL14 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL14 DEL32 DEL21 DEL8 DEL31 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL8 DEL31 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL14 DEL39 DEL42 DEL44 DEL31 DEL42 DEL43 DEL42 DEL44 DEL8 DEL31 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL14 DEL32 DEL21 DEL8 DEL31 DEL42 DEL42 DEL39 DEL42 DEL44 DEL31 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL42 DEL32 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL8 DEL24 DEL43 DEL85 DEL5 DEL42 DEL43 DEL85 DEL5 DEL42 DEL44 DEL42 DEL45 DEL34 DEL38 DEL42
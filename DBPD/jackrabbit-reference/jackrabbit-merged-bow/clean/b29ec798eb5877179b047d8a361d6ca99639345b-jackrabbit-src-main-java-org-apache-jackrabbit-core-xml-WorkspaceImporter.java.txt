Oops, reverting the accidental WorkspaceImporter change in revision 453165. Still reviewing patch from Nicolas.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@453169 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Iterator;
-import java.util.List;
-import java.util.Stack;
-
-import javax.jcr.AccessDeniedException;
-import javax.jcr.ImportUUIDBehavior;
-import javax.jcr.ItemExistsException;
-import javax.jcr.ItemNotFoundException;
-import javax.jcr.PathNotFoundException;
-import javax.jcr.PropertyType;
-import javax.jcr.RepositoryException;
-import javax.jcr.ValueFormatException;
-import javax.jcr.lock.LockException;
-import javax.jcr.nodetype.ConstraintViolationException;
-import javax.jcr.version.VersionException;
-import javax.jcr.version.VersionHistory;
-
+import javax.jcr.ImportUUIDBehavior;
+import javax.jcr.ItemExistsException;
+import javax.jcr.ItemNotFoundException;
+import javax.jcr.PathNotFoundException;
+import javax.jcr.PropertyType;
+import javax.jcr.RepositoryException;
+import javax.jcr.lock.LockException;
+import javax.jcr.nodetype.ConstraintViolationException;
+import javax.jcr.version.VersionException;
+import javax.jcr.version.VersionHistory;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Stack;
+
- * WorkspaceImporter. It imports the content submitted to it
- * by the Content Handler
- *
+ * <code>WorkspaceImporter</code> ...
+
+    private final WorkspaceImpl wsp;
+
-    //It is not useful anymore: we never abort: we raise an exception.
-    // I suggest to delete it. Do you see any issue with this?
-    private boolean aborted = false;
+    private boolean aborted;
-    // Unused for now. It will be used in the next iteration on JIRA
-    private boolean raw = false;
-
-     * True if we skip the tree with current node as root
-     */
-    private boolean skip = false;
-
-    /**
-     * Used to find when stopping skipping
-     */
-    private NodeInfo skipNode;
-
-    /**
-     * True if this node already exist
-     */
-    private NodeState existing = null;
-    private WorkspaceImpl wsp;
-
-    /**
-     * Creates a new <code>sWorkspaceImporter</code> instance.
+     * Creates a new <code>WorkspaceImporter</code> instance.
-     * @param wsp the workspace we want to import content to
-     * @param ntReg the NodeTypeRegistry of the repository
+     * @param wsp
+     * @param ntReg
-            WorkspaceImpl wsp,
-            NodeTypeRegistry ntReg,
-            int uuidBehavior)
-    throws PathNotFoundException, ConstraintViolationException,
-    VersionException, LockException, RepositoryException {
+                             WorkspaceImpl wsp,
+                             NodeTypeRegistry ntReg,
+                             int uuidBehavior)
+            throws PathNotFoundException, ConstraintViolationException,
+            VersionException, LockException, RepositoryException {
+
+        hierMgr = wsp.getHierarchyManager();
-        this.hierMgr = wsp.getHierarchyManager();
-        //Perform preliminary checks
+        // perform preliminary checks
+
+
+
+
-     * Performs some checks to know if the node is importable or not.
-     * If it is a serious issue, raises an exception, else return false.
-     * this subtree.
-     * <br/>
-     * Performs also if needed some remapping.
-     *
-     * @param parent the parent NodeState
-     * @param nodeInfo NodeInfo passed by the ContentHandler
-     * @param propInfo PropInfo passed by the ContentHandler
-     * @return true if the node is fine; else false
-     * @throws RepositoryException if some constraints checks are not OK
-     * @throws ItemExistsException if the item exist
-     * @throws ItemNotFoundException if some constraints checks are not OK (shouldn't happen)
-     * @throws LockException if some constraints checks are not OK
-     * @throws VersionException if some constraints checks are not OK
-     * @throws AccessDeniedException if some constraints checks are not OK
-     * @throws ConstraintViolationException if some constraints checks are not OK
-     */
-    private boolean checkNode(NodeState parent, NodeInfo nodeInfo, List propInfo)
-        throws ConstraintViolationException, AccessDeniedException, VersionException,
-        LockException, ItemNotFoundException, ItemExistsException, RepositoryException {
-        itemOps.checkAddNode(parent, nodeInfo.getName(), nodeInfo.getNodeTypeName(),
-                BatchedItemOperations.CHECK_ACCESS
-                | BatchedItemOperations.CHECK_CONSTRAINTS
-                | BatchedItemOperations.CHECK_LOCK
-                | BatchedItemOperations.CHECK_VERSIONING);
-
-        QName nodeName = nodeInfo.getName();
-        QName ntName = nodeInfo.getNodeTypeName();
-
-        if (parent.hasChildNodeEntry(nodeName)) {
-            // a node with that name already exists...
-            //No need to check for more than one, since if it
-            //is the case we can import it.
-            NodeState.ChildNodeEntry entry =
-                parent.getChildNodeEntry(nodeName, 1);
-            NodeId idExisting = entry.getId();
-            NodeState existing = (NodeState) itemOps.getItemState(idExisting);
-            NodeDef def = ntReg.getNodeDef(existing.getDefinitionId());
-            if (!def.allowsSameNameSiblings()) {
-                // existing doesn't allow same-name siblings,
-                // check for potential conflicts
-                EffectiveNodeType entExisting =
-                    itemOps.getEffectiveNodeType(existing);
-                if (!raw && def.isProtected() && entExisting.includesNodeType(ntName)) {
-                    return false;
-                }
-
-                if (def.isAutoCreated() && entExisting.includesNodeType(ntName)) {
-                    // this node has already been auto-created,
-                    // no need to create it
-                    this.existing = existing;
-                } else {
-                    throw new ItemExistsException(itemOps.safeGetJCRPath(existing.getNodeId()));
-                }
-            }
-        }
-
-        if (parent.hasPropertyName(nodeName)) {
-            /**
-             * a property with the same name already exists; if this property
-             * has been imported as well (e.g. through document view import
-             * where an element can have the same name as one of the attributes
-             * of its parent element) we have to rename the onflicting property;
-             *
-             * see http://issues.apache.org/jira/browse/JCR-61
-             */
-            PropertyId propId = new PropertyId(parent.getNodeId(), nodeName);
-            PropertyState conflicting = itemOps.getPropertyState(propId);
-            if (conflicting.getStatus() == ItemState.STATUS_NEW) {
-                // assume this property has been imported as well;
-                // rename conflicting property
-                // @todo use better reversible escaping scheme to create unique name
-                QName newName = new QName(nodeName.getNamespaceURI(), nodeName.getLocalName() + "_");
-                if (parent.hasPropertyName(newName)) {
-                    newName = new QName(newName.getNamespaceURI(), newName.getLocalName() + "_");
-                }
-                PropertyState newProp =
-                    itemOps.createPropertyState(parent, newName,
-                            conflicting.getType(), conflicting.getValues().length);
-                newProp.setValues(conflicting.getValues());
-                parent.removePropertyName(nodeName);
-                itemOps.store(parent);
-                itemOps.destroy(conflicting);
-            }
-        }
-
-        return true;
-    }
-
-    /**
-     * Create propoerties on a specific NodeState
-     * @param myNode the NodeState
-     * @param propInfos PropInfo
-     * @throws ItemNotFoundException if issue in the NodeState
-     * @throws ItemExistsException if issue in the NodeState
-     * @throws ConstraintViolationException if issue in the NodeState
-     * @throws ValueFormatException if issue in the NodeState
-     * @throws RepositoryException if issue in the NodeState
-     */
-    private void createProperties(NodeState myNode, List propInfos)
-        throws ItemNotFoundException, ItemExistsException, ConstraintViolationException,
-                                                ValueFormatException, RepositoryException {
-        // process properties
-        Iterator iter = propInfos.iterator();
-        while (iter.hasNext()) {
-            PropInfo pi = (PropInfo) iter.next();
-            pi.apply(myNode, itemOps, ntReg, refTracker);
-        }
-    }
-
-    /**
-     * Create the specific NodeState
-     * @param parent NodeState
-     * @param nodeInfo NodeInfo
-     * @return newly create NodeState
-     * @throws ConstraintViolationException if we cannot create the NodeState
-     * @throws RepositoryException if we cannot create the NodeState
-     */
-    private NodeState createNode(NodeState parent, NodeInfo nodeInfo) throws ConstraintViolationException, RepositoryException {
-
-        NodeDef def =
-            itemOps.findApplicableNodeDefinition(nodeInfo.getName(), nodeInfo.getNodeTypeName(), parent);
-
-        // potential uuid conflict
-        NodeState conflicting = null;
-        NodeState node;
-
-        try {
-            if (nodeInfo.getId() != null) {
-                conflicting = itemOps.getNodeState(nodeInfo.getId());
-            }
-        } catch (ItemNotFoundException infe) {
-            conflicting = null;
-        }
-        if (conflicting != null) {
-            // resolve uuid conflict
-            node = resolveUUIDConflict(parent, conflicting, nodeInfo);
-        }
-        else {
-            // do create new node
-            node = itemOps.createNodeState(parent, nodeInfo.getName(), nodeInfo.getNodeTypeName(),
-                                                                nodeInfo.getMixinNames(), null, def);
-        }
-        return node;
-    }
-
-    /**
-     * Resolve UUID conflict if any.
-     *
-     * @param parent NodeState
-     * @param conflicting NodeState
-     * @param nodeInfo NodeInfo
-     * @return the new conflicting NodeState
-     * @throws ItemExistsException
-     * @throws ConstraintViolationException
-     * @throws IllegalStateException
+     * @param parent
+     * @param conflicting
+     * @param nodeInfo
+     * @return
-    private NodeState resolveUUIDConflict(NodeState parent, NodeState conflicting, NodeInfo nodeInfo)
-        throws ItemExistsException, ConstraintViolationException, IllegalStateException, RepositoryException {
-        NodeState node = null;
-        switch (uuidBehavior) {
+    protected NodeState resolveUUIDConflict(NodeState parent,
+                                            NodeState conflicting,
+                                            NodeInfo nodeInfo)
+            throws RepositoryException {
-        case ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING:
-            NodeId parentId = conflicting.getParentId();
-            if (parentId == null) {
-                String msg = "root node cannot be replaced";
-                log.debug(msg);
-                throw new RepositoryException(msg);
-            }
-            // 'replace' current parent with parent of conflicting
-            try {
-                parent = itemOps.getNodeState(parentId);
-            } catch (ItemNotFoundException infe) {
-                // should never get here...
-                String msg = "internal error: failed to retrieve parent state";
-                log.error(msg, infe);
-                throw new RepositoryException(msg, infe);
-            }
-            // remove conflicting:
-            // check if conflicting can be removed
-            // (access rights, node type constraints, locking & versioning status)
-            itemOps.checkRemoveNode(conflicting,
+        NodeState node;
+        if (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {
+            // create new with new uuid:
+            // check if new node can be added (check access rights &
+            // node type constraints only, assume locking & versioning status
+            // has already been checked on ancestor)
+            itemOps.checkAddNode(parent, nodeInfo.getName(),
+                    nodeInfo.getNodeTypeName(),
-                    | BatchedItemOperations.CHECK_LOCK
-                    | BatchedItemOperations.CHECK_VERSIONING
-            // do remove conflicting (recursive)
-            itemOps.removeNodeState(conflicting);
-            // do create new node
-                    nodeInfo.getNodeTypeName(), nodeInfo.getMixinNames(),
-                    nodeInfo.getId());
-            break;
-
-        case ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING:
+                    nodeInfo.getNodeTypeName(), nodeInfo.getMixinNames(), null);
+            // remember uuid mapping
+            EffectiveNodeType ent = itemOps.getEffectiveNodeType(node);
+            if (ent.includesNodeType(QName.MIX_REFERENCEABLE)) {
+                refTracker.mappedUUID(nodeInfo.getId().getUUID(), node.getNodeId().getUUID());
+            }
+        } else if (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW) {
+            String msg = "a node with uuid " + nodeInfo.getId()
+                    + " already exists!";
+            log.debug(msg);
+            throw new ItemExistsException(msg);
+        } else if (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING) {
+            // check if new node can be added (check access rights &
+            // node type constraints only, assume locking & versioning status
+            // has already been checked on ancestor)
+            itemOps.checkAddNode(parent, nodeInfo.getName(),
+                    nodeInfo.getNodeTypeName(),
+                    BatchedItemOperations.CHECK_ACCESS
+                    | BatchedItemOperations.CHECK_CONSTRAINTS);
-            break;
-
-        case ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW:
-            String msg = "a node with uuid " + nodeInfo.getId()
-            + " already exists!";
-            log.debug(msg);
-            throw new ItemExistsException(msg);
-
-        case ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW:
-            // create new with new uuid:
-            // check if new node can be added (check access rights &
-            // node type constraints only, assume locking & versioning status
-            // has already been checked on ancestor)
-            node = itemOps.createNodeState(parent, nodeInfo.getName(),
-                    nodeInfo.getNodeTypeName(), nodeInfo.getMixinNames(), null);
-            // remember uuid mapping
-            EffectiveNodeType ent = itemOps.getEffectiveNodeType(node);
-            if (ent.includesNodeType(QName.MIX_REFERENCEABLE)) {
-                refTracker.mappedUUID(nodeInfo.getId().getUUID(), node.getNodeId().getUUID());
+        } else if (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING) {
+            NodeId parentId = conflicting.getParentId();
+            if (parentId == null) {
+                String msg = "root node cannot be replaced";
+                log.debug(msg);
+                throw new RepositoryException(msg);
-            break;
-         //No need for default case.
+            // 'replace' current parent with parent of conflicting
+            try {
+                parent = itemOps.getNodeState(parentId);
+            } catch (ItemNotFoundException infe) {
+                // should never get here...
+                String msg = "internal error: failed to retrieve parent state";
+                log.error(msg, infe);
+                throw new RepositoryException(msg, infe);
+            }
+            // remove conflicting:
+            // check if conflicting can be removed
+            // (access rights, node type constraints, locking & versioning status)
+            itemOps.checkRemoveNode(conflicting,
+                    BatchedItemOperations.CHECK_ACCESS
+                    | BatchedItemOperations.CHECK_LOCK
+                    | BatchedItemOperations.CHECK_VERSIONING
+                    | BatchedItemOperations.CHECK_CONSTRAINTS);
+            // do remove conflicting (recursive)
+            itemOps.removeNodeState(conflicting);
+            // create new with given uuid at same location as conflicting:
+            // check if new node can be added at other location
+            // (access rights, node type constraints, locking & versioning status)
+            itemOps.checkAddNode(parent, nodeInfo.getName(),
+                    nodeInfo.getNodeTypeName(),
+                    BatchedItemOperations.CHECK_ACCESS
+                    | BatchedItemOperations.CHECK_LOCK
+                    | BatchedItemOperations.CHECK_VERSIONING
+                    | BatchedItemOperations.CHECK_CONSTRAINTS);
+            // do create new node
+            node = itemOps.createNodeState(parent, nodeInfo.getName(),
+                    nodeInfo.getNodeTypeName(), nodeInfo.getMixinNames(),
+                    nodeInfo.getId());
+        } else {
+            String msg = "unknown uuidBehavior: " + uuidBehavior;
+            log.debug(msg);
+            throw new RepositoryException(msg);
-        return node;
-    }
-    /**
-     * @return true if skip mode is on.
-     */
-    protected boolean isSkipped() {
-        return skip;
+        return node;
-     * @param node NodeState to postprocess
-     * @throws RepositoryException if issue when postprocessing a node
+     * @param node
+     * @throws RepositoryException
-
-    throws RepositoryException {
+            throws RepositoryException {
+            // the import has been aborted, get outta here...
-        NodeState parent = (NodeState) parents.peek();
+        boolean succeeded = false;
+        NodeState parent;
+        try {
+            // check sanity of workspace/session first
+            wsp.sanityCheck();
-        if (raw && !checkNode(parent, nodeInfo, propInfos)) {
-            skip = true;
-        }
+            parent = (NodeState) parents.peek();
-        if (skip) {
-            return;
-        }
+            // process node
-        NodeState myNode;
-        if (existing == null) {
-            myNode = createNode(parent, nodeInfo);
+            NodeState node = null;
+            NodeId id = nodeInfo.getId();
+            QName nodeName = nodeInfo.getName();
+            QName ntName = nodeInfo.getNodeTypeName();
+            QName[] mixins = nodeInfo.getMixinNames();
+
+            if (parent == null) {
+                // parent node was skipped, skip this child node also
+                parents.push(null); // push null onto stack for skipped node
+                succeeded = true;
+                log.debug("skipping node " + nodeName);
+                return;
+            }
+            if (parent.hasChildNodeEntry(nodeName)) {
+                // a node with that name already exists...
+                NodeState.ChildNodeEntry entry =
+                        parent.getChildNodeEntry(nodeName, 1);
+                NodeId idExisting = entry.getId();
+                NodeState existing = (NodeState) itemOps.getItemState(idExisting);
+                NodeDef def = ntReg.getNodeDef(existing.getDefinitionId());
+
+                if (!def.allowsSameNameSiblings()) {
+                    // existing doesn't allow same-name siblings,
+                    // check for potential conflicts
+                    EffectiveNodeType entExisting =
+                            itemOps.getEffectiveNodeType(existing);
+                    if (def.isProtected() && entExisting.includesNodeType(ntName)) {
+                        // skip protected node
+                        parents.push(null); // push null onto stack for skipped node
+                        succeeded = true;
+                        log.debug("skipping protected node "
+                                + itemOps.safeGetJCRPath(existing.getNodeId()));
+                        return;
+                    }
+                    if (def.isAutoCreated() && entExisting.includesNodeType(ntName)) {
+                        // this node has already been auto-created,
+                        // no need to create it
+                        node = existing;
+                    } else {
+                        throw new ItemExistsException(itemOps.safeGetJCRPath(existing.getNodeId()));
+                    }
+                }
+            }
+
+            if (node == null) {
+                // there's no node with that name...
+                if (id == null) {
+                    // no potential uuid conflict, always create new node
+
+                    NodeDef def =
+                            itemOps.findApplicableNodeDefinition(nodeName, ntName, parent);
+                    if (def.isProtected()) {
+                        // skip protected node
+                        parents.push(null); // push null onto stack for skipped node
+                        succeeded = true;
+                        log.debug("skipping protected node " + nodeName);
+                        return;
+                    }
+
+                    if (parent.hasPropertyName(nodeName)) {
+                        /**
+                         * a property with the same name already exists; if this property
+                         * has been imported as well (e.g. through document view import
+                         * where an element can have the same name as one of the attributes
+                         * of its parent element) we have to rename the onflicting property;
+                         *
+                         * see http://issues.apache.org/jira/browse/JCR-61
+                         */
+                        PropertyId propId = new PropertyId(parent.getNodeId(), nodeName);
+                        PropertyState conflicting = itemOps.getPropertyState(propId);
+                        if (conflicting.getStatus() == ItemState.STATUS_NEW) {
+                            // assume this property has been imported as well;
+                            // rename conflicting property
+                            // @todo use better reversible escaping scheme to create unique name
+                            QName newName = new QName(nodeName.getNamespaceURI(), nodeName.getLocalName() + "_");
+                            if (parent.hasPropertyName(newName)) {
+                                newName = new QName(newName.getNamespaceURI(), newName.getLocalName() + "_");
+                            }
+                            PropertyState newProp =
+                                    itemOps.createPropertyState(parent, newName,
+                                            conflicting.getType(), conflicting.getValues().length);
+                            newProp.setValues(conflicting.getValues());
+                            parent.removePropertyName(nodeName);
+                            itemOps.store(parent);
+                            itemOps.destroy(conflicting);
+                        }
+                    }
+
+                    // check if new node can be added (check access rights &
+                    // node type constraints only, assume locking & versioning status
+                    // has already been checked on ancestor)
+                    itemOps.checkAddNode(parent, nodeName, ntName,
+                            BatchedItemOperations.CHECK_ACCESS
+                            | BatchedItemOperations.CHECK_CONSTRAINTS);
+                    // do create new node
+                    node = itemOps.createNodeState(parent, nodeName, ntName, mixins, null, def);
+                } else {
+                    // potential uuid conflict
+                    NodeState conflicting;
+
+                    try {
+                        conflicting = itemOps.getNodeState(id);
+                    } catch (ItemNotFoundException infe) {
+                        conflicting = null;
+                    }
+                    if (conflicting != null) {
+                        // resolve uuid conflict
+                        node = resolveUUIDConflict(parent, conflicting, nodeInfo);
+                    } else {
+                        // create new with given uuid
+
+                        NodeDef def =
+                                itemOps.findApplicableNodeDefinition(nodeName, ntName, parent);
+                        if (def.isProtected()) {
+                            // skip protected node
+                            parents.push(null); // push null onto stack for skipped node
+                            succeeded = true;
+                            log.debug("skipping protected node " + nodeName);
+                            return;
+                        }
+
+                        // check if new node can be added (check access rights &
+                        // node type constraints only, assume locking & versioning status
+                        // has already been checked on ancestor)
+                        itemOps.checkAddNode(parent, nodeName, ntName,
+                                BatchedItemOperations.CHECK_ACCESS
+                                | BatchedItemOperations.CHECK_CONSTRAINTS);
+                        // do create new node
+                        node = itemOps.createNodeState(parent, nodeName, ntName, mixins, id, def);
+                    }
+                }
+            }
+
+            // process properties
+
+            Iterator iter = propInfos.iterator();
+            while (iter.hasNext()) {
+                PropInfo pi = (PropInfo) iter.next();
+                pi.apply(node, itemOps, ntReg, refTracker);
+            }
+
+            // store affected nodes
+            itemOps.store(node);
+            itemOps.store(parent);
+
+            // push current node onto stack of parents
+            parents.push(node);
+
+            succeeded = true;
+        } finally {
+            if (!succeeded) {
+                // update operation failed, cancel all modifications
+                aborted = true;
+                itemOps.cancel();
+            }
-        else {
-            myNode = existing;
-            existing = null;
-        }
-        createProperties(myNode, propInfos);
-        parents.push(myNode);
-        //End of skip mode
-        if (skipNode != null && skipNode.equals(nodeInfo)) {
-            skip = false;
-            skipNode = null;
+        if (aborted) {
+            // the import has been aborted, get outta here...
-
-        if (aborted || skip) {
+        NodeState node = (NodeState) parents.pop();
+        if (node == null) {
+            // node was skipped, nothing to do here
-
+        boolean succeeded = false;
-            NodeState node = (NodeState) parents.pop();
+            // check sanity of workspace/session first
+            wsp.sanityCheck();
-            if (!raw) {
-                this.postProcessNode(node);
-            }
+            // post-process node (initialize properties with special semantics etc.)
+            postProcessNode(node);
+
+            // make sure node is valid according to its definition
+            itemOps.validate(node);
+
+            // we're done with that node, now store its state
-        } catch (IllegalStateException e) {
-            itemOps.cancel();
-            aborted = true;
+            succeeded = true;
+        } finally {
+            if (!succeeded) {
+                // update operation failed, cancel all modifications
+                aborted = true;
+                itemOps.cancel();
+            }
-            itemOps.cancel();
+            // the import has been aborted, get outta here...
-        wsp.sanityCheck();
-        /**
-         * adjust references that refer to uuid's which have been mapped to
-         * newly gererated uuid's on import
-         */
-        Iterator iter = refTracker.getProcessedReferences();
-        while (iter.hasNext()) {
-            PropertyState prop = (PropertyState) iter.next();
-            // being paranoid...
-            if (prop.getType() != PropertyType.REFERENCE) {
-                continue;
-            }
-            boolean modified = false;
-            InternalValue[] values = prop.getValues();
-            InternalValue[] newVals = new InternalValue[values.length];
-            for (int i = 0; i < values.length; i++) {
-                InternalValue val = values[i];
-                UUID original = (UUID) val.internalValue();
-                UUID adjusted = refTracker.getMappedUUID(original);
-                if (adjusted != null) {
-                    newVals[i] = InternalValue.create(adjusted);
-                    modified = true;
-                } else {
-                    // reference doesn't need adjusting, just copy old value
-                    newVals[i] = val;
+        boolean succeeded = false;
+        try {
+            // check sanity of workspace/session first
+            wsp.sanityCheck();
+
+            /**
+             * adjust references that refer to uuid's which have been mapped to
+             * newly gererated uuid's on import
+             */
+            Iterator iter = refTracker.getProcessedReferences();
+            while (iter.hasNext()) {
+                PropertyState prop = (PropertyState) iter.next();
+                // being paranoid...
+                if (prop.getType() != PropertyType.REFERENCE) {
+                    continue;
+                }
+                boolean modified = false;
+                InternalValue[] values = prop.getValues();
+                InternalValue[] newVals = new InternalValue[values.length];
+                for (int i = 0; i < values.length; i++) {
+                    InternalValue val = values[i];
+                    UUID original = (UUID) val.internalValue();
+                    UUID adjusted = refTracker.getMappedUUID(original);
+                    if (adjusted != null) {
+                        newVals[i] = InternalValue.create(adjusted);
+                        modified = true;
+                    } else {
+                        // reference doesn't need adjusting, just copy old value
+                        newVals[i] = val;
+                    }
+                }
+                if (modified) {
+                    prop.setValues(newVals);
+                    itemOps.store(prop);
-            if (modified) {
-                prop.setValues(newVals);
-                itemOps.store(prop);
+            refTracker.clear();
+
+            // make sure import target is valid according to its definition
+            itemOps.validate(importTarget);
+
+            // finally store the state of the import target
+            // (the parent of the imported subtree)
+            itemOps.store(importTarget);
+            succeeded = true;
+        } finally {
+            if (!succeeded) {
+                // update operation failed, cancel all modifications
+                aborted = true;
+                itemOps.cancel();
-        refTracker.clear();
-        // make sure import target is valid according to its definition
-        itemOps.validate(importTarget);
-
-        // finally store the state of the import target
-        // (the parent of the imported subtree)
-        itemOps.store(importTarget);
-
-        // finish update
-        itemOps.update();
+        if (!aborted) {
+            // finish update
+            itemOps.update();
+        }
-
-

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV23 MOV31 INS31 INS83 UPD83 UPD83 UPD39 UPD42 INS8 MOV29 MOV83 MOV39 UPD42 MOV42 MOV44 MOV43 INS8 INS8 UPD66 MOV60 INS25 MOV65 MOV43 UPD42 INS25 INS60 INS60 INS54 MOV25 MOV60 MOV25 MOV60 INS54 INS25 INS60 INS54 INS25 UPD66 INS27 INS8 INS25 INS42 INS8 INS39 INS59 MOV43 INS59 MOV8 INS8 INS27 INS39 INS8 MOV8 INS42 INS8 INS39 INS59 MOV8 INS8 INS38 INS8 INS42 INS42 INS40 MOV21 MOV21 MOV60 MOV25 INS27 INS8 INS25 INS41 INS42 INS9 UPD42 MOV42 INS42 INS21 INS21 MOV60 INS60 INS60 INS25 INS25 MOV60 INS61 INS21 INS21 INS21 INS21 INS25 INS42 INS33 UPD42 INS9 MOV21 MOV21 MOV21 MOV21 MOV21 INS41 INS42 INS9 INS21 MOV25 INS42 MOV21 INS42 INS40 MOV60 MOV21 MOV53 INS27 INS8 INS25 INS32 INS7 INS43 INS59 INS5 INS59 INS27 INS8 INS27 INS8 MOV32 INS8 INS32 INS32 INS32 INS7 INS38 INS8 INS32 MOV8 MOV21 INS7 INS38 INS42 INS40 MOV60 MOV60 MOV54 MOV21 MOV21 INS21 MOV21 INS27 INS8 INS8 INS42 INS42 INS42 MOV11 INS42 INS42 MOV32 INS43 INS85 INS42 MOV32 INS42 INS33 INS21 INS21 INS21 INS41 INS42 INS33 INS25 MOV60 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS21 INS21 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD9 UPD42 INS42 INS9 INS42 INS21 MOV32 MOV42 INS42 INS40 MOV60 MOV25 MOV54 MOV21 MOV21 INS21 MOV21 INS60 INS21 INS53 INS42 INS32 INS7 INS32 INS27 INS8 INS8 INS32 INS7 INS32 INS7 UPD42 INS27 INS32 INS43 INS59 INS32 INS14 INS42 INS42 INS33 INS42 INS9 INS42 INS42 INS27 INS42 INS33 INS60 INS25 MOV25 INS21 INS21 INS60 INS54 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS9 INS40 INS40 INS42 INS42 INS42 MOV32 MOV32 INS27 INS42 INS42 INS27 INS42 INS42 INS42 MOV43 INS42 INS45 INS42 MOV43 INS59 INS32 INS8 INS32 INS7 MOV43 INS59 INS8 MOV12 MOV27 MOV8 INS8 INS40 INS40 INS40 INS40 INS45 INS42 INS21 INS21 INS21 INS41 INS42 INS32 INS42 INS42 INS21 INS21 INS21 INS41 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS32 INS42 INS21 INS60 INS25 INS21 INS21 INS32 INS7 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS7 INS32 INS40 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS7 INS43 INS59 INS32 INS8 INS32 INS7 INS42 INS42 INS33 INS42 INS9 INS42 INS42 INS27 INS42 INS42 INS42 INS33 INS42 INS9 INS42 INS42 INS27 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS21 INS21 INS21 INS41 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS32 INS45 INS32 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS7 INS32 INS40 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS33 INS42 INS9 INS42 INS42 INS27 INS42 INS42 INS45 INS42 DEL40 DEL26 DEL40 DEL26 DEL66 DEL9 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL33 DEL59 DEL23 DEL66 DEL66 DEL52 DEL42 DEL22 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL61 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL32 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL54 DEL42 DEL42 DEL42 DEL42 DEL33 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL66 DEL65 DEL66 DEL66 DEL66 DEL66 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL40 DEL40 DEL42 DEL40 DEL49 DEL10 DEL40 DEL49 DEL10 DEL40 DEL49 DEL40 DEL49 DEL10 DEL50 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL38 DEL9 DEL41 DEL52 DEL42 DEL22 DEL9 DEL41 DEL42 DEL42 DEL42 DEL32 DEL7 DEL42 DEL52 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL38 DEL27 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL33 DEL27 DEL8 DEL42 DEL42 DEL7 DEL21 DEL42 DEL33 DEL7 DEL21 DEL8 DEL25 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL33 DEL7 DEL21 DEL41 DEL8 DEL25 DEL42 DEL42 DEL27 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL44 DEL12 DEL54 DEL8 DEL31 DEL42 DEL41
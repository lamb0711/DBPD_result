JCR-554: Index creates many folders when re-indexing
- delete unused index segments earlier
- use UUID instances instead of String representation of a UUID

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@439019 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.uuid.UUID;
+     * Flag indicating whether re-indexing is running.
+     */
+    private boolean reindexing = false;
+
+    /**
+                reindexing = true;
+                reindexing = false;
-    }
+            }
-     * @param remove Iterator of <code>Term</code>s that identify documents to
+     * @param remove Iterator of <code>UUID</code>s that identify documents to
-                String uuid = ((Term) remove.next()).text();
-                executeAndLog(new DeleteNode(transactionId, uuid));
+                executeAndLog(new DeleteNode(transactionId, (UUID) remove.next()));
-     * Deletes the first document that matches the <code>idTerm</code>.
+     * Deletes the first document that matches the <code>uuid</code>.
-     * @param idTerm document that match this term will be deleted.
+     * @param uuid document that match this <code>uuid</code> will be deleted.
-    void removeDocument(Term idTerm) throws IOException {
-        List remove = Arrays.asList(new Term[]{idTerm});
+    void removeDocument(UUID uuid) throws IOException {
+        List remove = Arrays.asList(new UUID[]{uuid});
-     * Deletes all documents that match the <code>idTerm</code>.
+     * Deletes all documents that match the <code>uuid</code>.
-     * @param idTerm documents that match this term will be deleted.
+     * @param uuid documents that match this <code>uuid</code> will be deleted.
-    synchronized int removeAllDocuments(Term idTerm) throws IOException {
+    synchronized int removeAllDocuments(UUID uuid) throws IOException {
+            Term idTerm = new Term(FieldNames.UUID, uuid.toString());
-                redoLog.append(new DeleteNode(getTransactionId(), idTerm.text()));
+                redoLog.append(new DeleteNode(getTransactionId(), uuid));
-                        redoLog.append(new DeleteNode(getTransactionId(), idTerm.text()));
+                        redoLog.append(new DeleteNode(getTransactionId(), uuid));
+     * Returns <code>true</code> if this multi index has an index segment with
+     * the given name. This method even returns <code>true</code> if an index
+     * segments has not yet been loaded / initialized but exists on disk.
+     *
+     * @param indexName the name of the index segment.
+     * @return <code>true</code> if it exists; otherwise <code>false</code>.
+     */
+    synchronized boolean hasIndex(String indexName) {
+        // check existing
+        for (Iterator it = indexes.iterator(); it.hasNext();) {
+            PersistentIndex idx = (PersistentIndex) it.next();
+            if (idx.getName().equals(indexName)) {
+                return true;
+            }
+        }
+        // check if it exists on disk
+        return new File(indexDir, indexName).exists();
+    }
+
+    /**
-            executeAndLog(new Start(Action.INTERNAL_TRANSACTION));
+            // if we are reindexing there is already an active transaction
+            if (!reindexing) {
+                executeAndLog(new Start(Action.INTERNAL_TRANSACTION));
+            }
+            // Index merger does not log an action when it creates the target
+            // index of the merge. We have to do this here.
+            executeAndLog(new CreateIndex(getTransactionId(), index.getName(), false));
+
-            executeAndLog(new Commit(getTransactionId()));
+            if (reindexing) {
+                // do some cleanup right away when reindexing
+                attemptDelete();
+            } else {
+                // only commit if we are not reindexing
+                // when reindexing the final commit is done at the very end
+                executeAndLog(new Commit(getTransactionId()));
+            }
-        if (a.getType() == Action.TYPE_COMMIT) {
+        // please note that flushing the redo log is only required on
+        // commit, but we also want to keep track of new indexes for sure.
+        // otherwise it might happen that unused index folders are orphaned
+        // after a crash.
+        if (a.getType() == Action.TYPE_COMMIT || a.getType() == Action.TYPE_ADD_INDEX) {
-        executeAndLog(new AddNode(getTransactionId(), id.getUUID().toString()));
+        executeAndLog(new AddNode(getTransactionId(), id.getUUID()));
-        private final String uuid;
+        private final UUID uuid;
-        AddNode(long transactionId, String uuid) {
+        AddNode(long transactionId, UUID uuid) {
-            this(transactionId, doc.get(FieldNames.UUID));
+            this(transactionId, UUID.fromString(doc.get(FieldNames.UUID)));
-            return new AddNode(transactionId, arguments);
+            return new AddNode(transactionId, UUID.fromString(arguments));
-                    doc = index.createDocument(NodeId.valueOf(uuid));
+                    doc = index.createDocument(new NodeId(uuid));
-            PersistentIndex idx = index.getOrCreateIndex(indexName, false);
-            index.deleteIndex(idx);
+            if (index.hasIndex(indexName)) {
+                PersistentIndex idx = index.getOrCreateIndex(indexName, false);
+                index.deleteIndex(idx);
+            }
-        private final String uuid;
+        private final UUID uuid;
-        DeleteNode(long transactionId, String uuid) {
+        DeleteNode(long transactionId, UUID uuid) {
-            return new DeleteNode(transactionId, arguments);
+            return new DeleteNode(transactionId, UUID.fromString(arguments));
-            Term idTerm = new Term(FieldNames.UUID, uuid);
+            Term idTerm = new Term(FieldNames.UUID, uuid.toString());

INS26 INS40 INS23 INS31 INS29 INS83 INS39 INS59 INS29 INS83 INS39 INS42 INS44 INS8 INS65 INS42 INS9 UPD43 UPD42 INS43 INS42 INS65 INS65 INS65 MOV43 INS42 INS24 INS41 UPD43 INS8 UPD43 INS66 UPD66 UPD66 UPD42 UPD66 UPD42 UPD66 UPD42 UPD66 INS42 INS66 INS66 INS66 INS42 INS66 INS66 INS58 INS32 INS8 INS32 INS27 MOV32 UPD42 UPD43 INS25 UPD42 UPD43 INS60 INS43 INS59 INS42 INS42 INS60 INS25 INS14 INS42 INS25 INS21 INS25 MOV27 INS27 UPD42 INS14 UPD42 INS32 INS32 MOV8 UPD42 MOV43 MOV43 INS59 INS42 INS42 INS32 INS43 INS59 INS32 INS8 INS43 INS42 INS42 INS38 INS8 INS32 INS42 INS8 INS8 INS32 INS40 MOV43 MOV32 MOV32 INS42 INS42 MOV32 INS32 INS42 INS42 INS42 INS32 INS21 INS21 UPD5 INS42 INS14 INS42 INS42 INS42 INS42 INS11 INS32 INS42 INS42 INS41 INS42 INS42 MOV21 INS42 INS14 INS21 MOV21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV43 INS32 INS7 INS7 MOV32 INS43 UPD42 MOV43 INS40 INS32 INS43 INS32 INS42 INS42 INS9 INS43 INS32 INS32 INS9 INS32 INS42 INS42 INS42 INS9 INS42 INS9 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV43 INS42 MOV11 INS42 UPD43 INS14 UPD42 INS43 INS42 INS42 INS42 DEL42 DEL59 DEL60 DEL36 DEL42 DEL42 DEL42 DEL42 DEL14 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL14 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42
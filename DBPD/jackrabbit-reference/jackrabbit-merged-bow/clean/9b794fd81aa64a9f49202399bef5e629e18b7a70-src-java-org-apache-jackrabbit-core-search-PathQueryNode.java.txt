Added SQL and XPath query implementation. The implementation is not complete yet. Only basic operations are supported.
Also added postGoals to the maven.xml to generate the parser classes for SQL XPath.

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@123135 13f79535-47bb-0310-9956-ffa450edef68

-public class PathQueryNode extends QueryNode {
+public class PathQueryNode extends NAryQueryNode {
-     * Match path exact
+     * Empty step node array.
-    public static final int TYPE_EXACT = 1;
+    private static final LocationStepQueryNode[] EMPTY = new LocationStepQueryNode[0];
-    /**
-     * Match child nodes of path
-     */
-    public static final int TYPE_CHILDREN = 2;
-
-    /**
-     * Match descendant nodes or self of path
-     */
-    public static final int TYPE_DESCENDANT_SELF = 3;
-
-    /**
-     * The base path
-     */
-    private final String path;
-
-    /**
-     * Converted path without indexes. /bla[2] -> /bla
-     */
-    private final String indexlessPath;
-
-    /**
-     * The match type for this query node
-     */
-    private final int type;
-
-    /**
-     * Flag indicating if this path query contains indexed location steps
-     */
-    private final boolean indexedName;
-
-    /**
-     * Creates a new <code>PathQueryNode</code> instance.
-     *
-     * @param parent this parent node of this query node.
-     * @param path   the base path.
-     * @param type   one of {@link #TYPE_CHILDREN}, {@link #TYPE_DESCENDANT_SELF},
-     *               {@link #TYPE_EXACT}
-     */
-    public PathQueryNode(QueryNode parent, String path, int type) {
+    public PathQueryNode(QueryNode parent) {
-        if (type < TYPE_EXACT || type > TYPE_DESCENDANT_SELF) {
-            throw new IllegalArgumentException(String.valueOf(type));
-        }
-        this.path = path;
-        this.type = type;
-        this.indexedName = (path.indexOf('[') > -1);
-        if (indexedName) {
-            // also create an indexless path
-            StringBuffer tmp = new StringBuffer(path);
-            int idx;
-            while ((idx = tmp.indexOf("[")) > -1) {
-                int end = tmp.indexOf("]", idx);
-                if (end > -1) {
-                    tmp.replace(idx, end, "");
-                } else {
-                    // should never happen
-                    // FIXME do some error logging?
-                    break;
-                }
-            }
-            this.indexlessPath = tmp.toString();
-        } else {
-            this.indexlessPath = path;
-        }
-
-     * Returns the unmodified path for this query node, as passed to the
-     * constructor.
-     *
-     * @return the unmodified path for this query node.
+     * Adds a path step to this <code>PathQueryNode</code>.
+     * @param step the step to add.
-    public String getPath() {
-        return path;
+    public void addPathStep(LocationStepQueryNode step) {
+        addOperand(step);
-     * Returns a normalized path without indexes.
-     *
-     * @return a normalized path without indexes.
+     * Returns an array of all currently set location step nodes.
+     * @return an array of all currently set location step nodes.
-    public String getIndexlessPath() {
-        return indexlessPath;
+    public LocationStepQueryNode[] getPathSteps() {
+        if (operands == null) {
+            return EMPTY;
+        } else {
+            return (LocationStepQueryNode[]) operands.toArray(new LocationStepQueryNode[operands.size()]);
+        }
-     * Returns the type of this <code>PathQueryNode</code>.
-     *
-     * @return one of {@link #TYPE_CHILDREN}, {@link #TYPE_DESCENDANT_SELF},
-     *         {@link #TYPE_EXACT}
-     */
-    public int getType() {
-        return type;
-    }
-
-    /**
-     * Returns <code>true</code> if the path contains an index. E.g. a location
-     * step in XPath has a position predicate. If the path does not contain any
-     * indexes <code>false</code> is returned.
-     *
-     * @return <code>true</code> if the path contains an indexed location step.
-     */
-    public boolean hasIndexedName() {
-        return indexedName;
-    }
-
-
-    /**
-        StringBuffer jcrql = new StringBuffer("LOCATION ");
-        jcrql.append(path);
-        if (type == TYPE_CHILDREN) {
-            jcrql.append("/*");
-        } else if (type == TYPE_DESCENDANT_SELF) {
-            jcrql.append("//");
+        StringBuffer sb = new StringBuffer("LOCATION \"");
+        LocationStepQueryNode[] steps = getPathSteps();
+        for (int i = 0; i < steps.length; i++) {
+            if (steps[i].getNameTest() == null
+                    || steps[i].getNameTest().length() > 0) {
+                sb.append('/');
+            }
+            sb.append(steps[i].toJCRQLString());
-        return jcrql.toString();
+        sb.append('"');
+        return sb.toString();
+    }
+
+
+    /**
+     * Returns a JCR SQL representation for this query node.
+     *
+     * @return a JCR SQL representation for this query node.
+     */
+    public String toJCRSQLString() {
+        // FIXME implement namespace awareness
+        StringBuffer sb = new StringBuffer("\"jcr:path\"='");
+        LocationStepQueryNode[] steps = getPathSteps();
+        for (int i = 0; i < steps.length; i++) {
+            if (steps[i].getNameTest() == null
+                    || steps[i].getNameTest().length() > 0) {
+                sb.append('/');
+            }
+            sb.append(steps[i].toJCRSQLString());
+        }
+        sb.append('\'');
+        return sb.toString();
-        // todo implement correctly.
-        return "";
+        StringBuffer sb = new StringBuffer();
+        LocationStepQueryNode[] steps = getPathSteps();
+        for (int i = 0; i < steps.length; i++) {
+            if (steps[i].getNameTest() == null
+                    || steps[i].getNameTest().length() > 0) {
+                sb.append('/');
+            }
+            sb.append(steps[i].toXPathString());
+        }
+        return sb.toString();

UPD43 INS31 INS31 INS31 INS31 INS31 INS31 UPD42 UPD83 INS5 INS83 INS42 MOV44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS5 INS42 INS8 MOV29 MOV83 MOV43 UPD42 MOV42 INS8 INS29 INS83 MOV43 INS42 INS8 MOV29 MOV83 MOV43 INS42 INS8 INS43 INS85 UPD42 INS3 MOV46 MOV65 INS65 INS43 INS42 INS21 INS65 UPD65 MOV65 INS43 INS85 INS25 MOV60 INS60 INS24 MOV21 INS41 INS65 INS65 MOV60 INS60 INS24 MOV21 INS41 MOV60 INS60 INS24 MOV41 UPD66 INS42 INS5 INS34 UPD66 INS42 INS66 UPD42 MOV42 INS32 INS66 UPD66 UPD42 MOV42 INS27 INS8 INS8 MOV43 INS5 INS59 INS58 INS27 INS37 INS8 INS32 INS32 INS66 INS66 INS43 INS5 INS59 INS58 INS27 INS37 INS8 INS32 INS32 MOV43 INS5 INS59 INS58 INS27 INS37 INS8 INS43 INS85 INS42 INS42 INS42 INS33 INS41 INS41 UPD42 INS43 INS85 INS42 INS32 INS39 INS59 INS42 INS40 INS42 MOV25 INS21 UPD42 MOV42 UPD42 MOV42 UPD13 MOV13 INS42 INS42 INS42 UPD42 INS14 INS43 INS85 INS42 INS32 INS39 INS59 INS42 INS40 INS42 INS25 MOV21 INS42 INS42 INS13 INS42 INS42 UPD42 INS43 INS85 INS42 INS32 INS39 INS59 INS42 INS40 INS42 INS25 INS21 UPD42 INS42 INS42 INS11 MOV43 INS45 UPD42 MOV42 INS42 INS42 INS34 INS32 INS43 INS45 INS42 UPD42 MOV42 UPD42 MOV42 INS34 INS27 MOV8 INS32 MOV43 INS42 INS42 INS42 INS34 INS27 MOV8 INS32 INS5 INS32 UPD27 INS21 INS42 INS42 INS32 INS42 INS27 INS27 INS42 INS42 INS32 INS27 INS27 INS42 INS42 INS32 INS43 INS85 INS42 INS42 INS3 INS32 INS33 INS32 INS34 INS32 INS2 INS42 INS32 INS33 INS32 INS34 INS2 UPD42 MOV42 INS32 INS33 INS32 INS34 INS2 INS42 INS42 INS5 INS32 INS2 INS42 INS32 INS42 UPD42 MOV42 UPD42 MOV42 INS13 INS42 INS42 INS2 UPD42 MOV42 INS32 INS42 UPD42 UPD42 INS13 INS42 INS42 INS2 INS42 INS32 INS42 UPD42 INS13 INS42 INS42 INS43 INS85 INS42 INS42 INS42 INS42 INS2 INS42 INS42 INS42 INS2 INS42 INS42 INS42 INS2 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL39 DEL34 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL29 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL83 DEL43 DEL42 DEL59 DEL23 DEL29 DEL83 DEL83 DEL43 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL42 DEL67 DEL65 DEL66 DEL42 DEL67 DEL65 DEL66 DEL42 DEL67 DEL65 DEL65 DEL29 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL45 DEL32 DEL7 DEL36 DEL34 DEL38 DEL27 DEL39 DEL42 DEL42 DEL45 DEL32 DEL59 DEL60 DEL42 DEL34 DEL38 DEL27 DEL10 DEL8 DEL25 DEL8 DEL61 DEL8 DEL8 DEL25 DEL8 DEL31 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL32 DEL14 DEL53 DEL52 DEL42 DEL22 DEL32 DEL34 DEL38 DEL27 DEL36 DEL7 DEL39 DEL42 DEL42 DEL45 DEL52 DEL42 DEL22 DEL42 DEL32 DEL7 DEL52 DEL42 DEL22 DEL42 DEL7 DEL45 DEL45 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL41 DEL8 DEL31 DEL66 DEL65 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL42 DEL41 DEL8 DEL31 DEL66 DEL65 DEL66 DEL42 DEL67 DEL65 DEL66 DEL42 DEL67 DEL65 DEL66 DEL42 DEL67 DEL65 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL83 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL27 DEL42 DEL42 DEL27 DEL42 DEL42 DEL45 DEL32 DEL21 DEL8 DEL25 DEL25 DEL8 DEL31 DEL83 DEL42 DEL45 DEL41 DEL8 DEL31
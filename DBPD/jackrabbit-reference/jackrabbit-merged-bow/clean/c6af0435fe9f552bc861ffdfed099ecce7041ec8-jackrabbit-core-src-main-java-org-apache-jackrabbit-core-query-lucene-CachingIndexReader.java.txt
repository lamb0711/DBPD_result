JCR-2647: Reduce temporary memory usage of hierarchy cache initialization

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@958577 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.lucene.document.FieldSelector;
+import org.apache.lucene.document.FieldSelector;
+     * The number of nodes that are processed in a batch when the hierarchy
+     * cache is initialized. The value is 400'000, which will limit the
+     * temporary memory usage to initialize the hierarchy cache of a segment
+     * to 64MB (-> 170B * 400k)
+     */
+    private static final int MAX_CACHE_INIT_BATCH_SIZE = 400 * 1000;
+
+    /**
-            long time = System.currentTimeMillis();
-            final Map<Object, NodeInfo> docs = new HashMap<Object, NodeInfo>();
-            // read UUIDs
-            collectTermDocs(reader, new Term(FieldNames.UUID, ""), new TermDocsCollector() {
-                public void collect(Term term, TermDocs tDocs) throws IOException {
-                    NodeId id = new NodeId(term.text());
-                    while (tDocs.next()) {
-                        int doc = tDocs.doc();
-                        // skip shareable nodes
-                        if (!shareableNodes.get(doc)) {
-                            NodeInfo info = new NodeInfo(doc, id);
-                            docs.put(doc, info);
-                        }
-                    }
-                }
-            });
-
-            // read PARENTs
-            collectTermDocs(reader, new Term(FieldNames.PARENT, "0"), new TermDocsCollector() {
-                public void collect(Term term, TermDocs tDocs) throws IOException {
-                    NodeId id = new NodeId(term.text());
-                    while (tDocs.next()) {
-                        Integer docId = tDocs.doc();
-                        NodeInfo info = docs.get(docId);
-                        if (info == null) {
-                            // shareable node, see above
-                        } else {
-                            info.parent = id;
-                            docs.remove(docId);
-                            docs.put(info.id, info);
-                        }
-                    }
-                }
-            });
-
-            if (stopRequested) {
-                return;
-            }
-
-            for (NodeInfo info : docs.values()) {
-                NodeInfo parent = docs.get(info.parent);
-                if (parent != null) {
-                    inSegmentParents[info.docId] = parent.docId;
-                } else if (info.parent != null) {
-                    foreignParents++;
-                    foreignParentDocIds.put(info.docId, DocId.create(info.parent));
-                } else if (shareableNodes.get(info.docId)) {
-                    Document doc = reader.document(info.docId, FieldSelectors.UUID_AND_PARENT);
-                    foreignParentDocIds.put(info.docId, DocId.create(doc.getValues(FieldNames.PARENT)));
-                } else {
-                    // no parent -> root node
-                    foreignParentDocIds.put(info.docId, DocId.NULL);
+            long time = System.currentTimeMillis();
+
+            // initialize in multiple passes with
+            // a fixed number of nodes at a time
+            final Term[] startUUID = new Term[]{new Term(FieldNames.UUID, "")};
+
+            for (;;) {
+                final Map<Object, NodeInfo> docs = new HashMap<Object, NodeInfo>();
+                final Map<NodeId, Integer> parents = new HashMap<NodeId, Integer>();
+
+                if (startUUID[0].text().length() != 0) {
+                    // force reading the next uuid after startUUID
+                    startUUID[0] = new Term(FieldNames.UUID, startUUID[0].text() + "_");
+                }
+                // read UUIDs
+                collectTermDocs(reader, startUUID[0], new TermDocsCollector() {
+                    public boolean collect(Term term, TermDocs tDocs) throws IOException {
+                        // remember start term for next batch
+                        startUUID[0] = term;
+                        if (docs.size() >= MAX_CACHE_INIT_BATCH_SIZE) {
+                            return false;
+                        }
+                        NodeId id = new NodeId(term.text());
+                        while (tDocs.next()) {
+                            int doc = tDocs.doc();
+                            // skip shareable nodes
+                            if (!shareableNodes.get(doc)) {
+                                NodeInfo info = new NodeInfo(doc, id);
+                                docs.put(doc, info);
+                            }
+                        }
+                        return true;
+                    }
+                });
+
+                if (docs.isEmpty()) {
+                    // no more nodes to initialize
+                    break;
+                }
+
+                // read PARENTs (full scan)
+                collectTermDocs(reader, new Term(FieldNames.PARENT, "0"), new TermDocsCollector() {
+                    public boolean collect(Term term, TermDocs tDocs) throws IOException {
+                        NodeId id = new NodeId(term.text());
+                        while (tDocs.next()) {
+                            Integer docId = tDocs.doc();
+                            NodeInfo info = docs.get(docId);
+                            if (info == null) {
+                                // shareable node, see above
+                                // or cache init is batched
+                            } else {
+                                info.parent = id;
+                                docs.remove(docId);
+                                docs.put(info.id, info);
+                                parents.put(id, null);
+                            }
+                        }
+                        return true;
+                    }
+                });
+
+                // scan UUIDs again to get document numbers for parents
+                collectTermDocs(reader, new Term(FieldNames.UUID, ""), new TermDocsCollector() {
+                    public boolean collect(Term term, TermDocs tDocs) throws IOException {
+                        NodeId id = new NodeId(term.text());
+                        while (tDocs.next()) {
+                            int doc = tDocs.doc();
+                            if (parents.containsKey(id)) {
+                                parents.put(id, doc);
+                            }
+                        }
+                        return true;
+                    }
+                });
+
+                if (stopRequested) {
+                    return;
+                }
+
+                for (NodeInfo info : docs.values()) {
+                    int parentDocId = -1;
+                    NodeInfo parent = docs.get(info.parent);
+                    if (parent != null) {
+                        parentDocId = parent.docId;
+                    } else {
+                        Integer docId = parents.get(info.parent);
+                        if (docId != null) {
+                            parentDocId = docId;
+                        }
+                    }
+                    if (parentDocId != -1) {
+                        inSegmentParents[info.docId] = parentDocId;
+                    } else if (info.parent != null) {
+                        foreignParents++;
+                        foreignParentDocIds.put(info.docId, DocId.create(info.parent));
+                    } else if (shareableNodes.get(info.docId)) {
+                        Document doc = reader.document(info.docId, FieldSelectors.UUID_AND_PARENT);
+                        foreignParentDocIds.put(info.docId, DocId.create(doc.getValues(FieldNames.PARENT)));
+                    } else {
+                        // no parent -> root node
+                        foreignParentDocIds.put(info.docId, DocId.NULL);
+                    }
+
-                            collector.collect(t, tDocs);
+                            if (!collector.collect(t, tDocs)) {
+                                // collector indicated break
+                                break;
+                            }
+         * @return false if the collector does not wish to collect more TermDocs.
-        void collect(Term term, TermDocs tDocs) throws IOException;
+        boolean collect(Term term, TermDocs tDocs) throws IOException;

MOV26 INS23 INS29 INS83 INS83 INS83 INS39 INS59 INS65 INS42 INS27 MOV60 UPD39 INS66 INS66 INS66 INS66 INS34 INS34 INS60 INS24 INS65 INS83 INS5 INS59 INS8 INS66 INS43 INS85 INS42 INS3 MOV60 INS60 INS25 MOV21 INS25 MOV21 INS21 MOV25 MOV70 INS42 INS5 INS4 INS83 INS74 INS59 INS27 INS8 INS32 INS8 INS32 INS43 INS85 INS14 INS43 INS43 INS43 INS42 INS14 INS32 INS34 INS21 INS2 INS42 INS42 INS10 INS42 INS42 MOV14 INS14 INS60 INS25 INS42 INS43 INS40 INS45 INS42 INS42 INS42 INS74 INS32 INS42 INS7 INS42 INS34 INS43 INS1 INS39 INS59 MOV27 INS8 INS8 INS27 INS42 INS43 INS43 INS43 INS2 INS42 INS2 INS14 INS42 INS31 INS42 INS38 INS21 INS60 INS25 INS42 INS38 INS42 INS42 INS42 INS42 INS34 INS42 INS34 INS43 INS40 INS27 UPD39 UPD39 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS34 INS7 INS43 INS59 INS27 INS8 INS34 INS42 INS32 INS45 INS21 INS25 INS41 INS41 INS43 INS42 INS43 INS42 INS42 INS60 INS61 INS41 INS42 INS40 INS42 INS42 INS32 INS42 INS33 INS21 INS42 INS25 INS2 INS42 INS7 INS27 INS8 INS9 INS9 INS42 INS42 INS43 INS59 INS32 INS8 INS9 INS42 INS42 INS40 INS7 INS38 INS8 INS42 INS34 INS2 INS42 INS32 INS42 INS41 INS42 INS42 INS14 INS42 INS42 INS60 INS25 INS42 INS42 MOV32 INS10 INS42 INS34 INS42 INS42 INS9 INS43 INS32 INS39 INS59 INS32 INS8 INS21 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS21 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS33 INS42 INS42 INS42 INS42 DEL40 DEL21
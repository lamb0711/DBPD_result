JCR-2579: InvalidItemStateException when attempting concurrent, non conflicting writes

The problem was caused by NodeState returning the underlying ChildNodeEntries as an unsynchronized List<> instance. I've refactored the code so that whenever a list of ChildNodeEntries is returned from NodeState, that list is independent of the internal mutable state of the NodeState instance.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@955307 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Iterator;
-        return childNodeEntries;
+        return childNodeEntries.list();
-            return childNodeEntries;
+            return childNodeEntries.list();
-            return Collections.emptyList();
-        }
-
-        ChildNodeEntries otherChildNodeEntries =
-                ((NodeState) overlayedState).childNodeEntries;
-
-        // do a lazy init
-        List<ChildNodeEntry> renamed = null;
-
-        for (Iterator<ChildNodeEntry> iter = childNodeEntries.iterator(); iter.hasNext();) {
-            ChildNodeEntry cne = iter.next();
-            ChildNodeEntry cneOther = otherChildNodeEntries.get(cne.getId());
-            if (cneOther != null && !cne.getName().equals(cneOther.getName())) {
-                // child node entry with same id but different name exists in
-                // overlayed and this state => renamed entry detected
-                if (renamed == null) {
-                    renamed = new ArrayList<ChildNodeEntry>();
-                }
-                renamed.add(cne);
-            }
-        }
-
-        if (renamed == null) {
-            return Collections.emptyList();
+            return childNodeEntries.getRenamedEntries(
+                    ((NodeState) overlayedState).childNodeEntries);
-            return renamed;
+            return Collections.emptyList();
-            ChildNodeEntry entry = (ChildNodeEntry) ours.get(i);
-            ChildNodeEntry other = (ChildNodeEntry) others.get(i);
+            ChildNodeEntry entry = ours.get(i);
+            ChildNodeEntry other = others.get(i);
-                    if (entry.getId().equals(((ChildNodeEntry) others.get(i + 1)).getId())) {
+                    if (entry.getId().equals(others.get(i + 1).getId())) {
-                            if (((ChildNodeEntry) ours.get(j)).getId().equals(other.getId())) {
+                            if (ours.get(j).getId().equals(other.getId())) {
-                    if (((ChildNodeEntry) ours.get(j)).getId().equals(entry.getId())) {
+                    if (ours.get(j).getId().equals(entry.getId())) {
-                    if (((ChildNodeEntry) others.get(j)).getId().equals(entry.getId())) {
+                    if (others.get(j).getId().equals(entry.getId())) {

INS25 INS32 MOV38 INS8 MOV8 INS42 INS42 INS41 INS32 INS32 MOV43 MOV43 INS42 INS42 INS42 INS42 INS22 MOV32 MOV32 MOV36 MOV42 MOV32 MOV32 MOV32 MOV32 MOV32 INS32 INS32 INS42 MOV32 MOV32 INS42 DEL40 DEL26 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL22 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL33 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL38 DEL27 DEL42 DEL33 DEL27 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL24 DEL42 DEL33 DEL27 DEL42 DEL41 DEL8 DEL25 DEL42 DEL43 DEL11 DEL42 DEL43 DEL11 DEL42 DEL43 DEL11 DEL36 DEL42 DEL43 DEL11 DEL36 DEL42 DEL43 DEL11 DEL36 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL11 DEL36
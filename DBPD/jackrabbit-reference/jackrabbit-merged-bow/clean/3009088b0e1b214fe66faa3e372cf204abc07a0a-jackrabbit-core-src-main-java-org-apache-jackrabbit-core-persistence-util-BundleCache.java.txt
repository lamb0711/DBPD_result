JCR-2699: Improve read/write concurrency

Make BundleCache synchronized and use the LinkedHashMap class instead of the LinkedMap from Commons Collections (LinkedHashMap supports access-ordering, which makes it better for a LRU map)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1002101 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.collections.map.LinkedMap;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
-    private LinkedMap bundles = new LinkedMap();
+    private final LinkedHashMap<NodeId, NodePropBundle> bundles;
+    @SuppressWarnings("serial")
+        this.bundles = new LinkedHashMap<NodeId, NodePropBundle>(
+                (int) maxSize / 1024, 0.75f, true /* access-ordered */) {
+            @Override
+            protected boolean removeEldestEntry(
+                    Map.Entry<NodeId, NodePropBundle> e) {
+                if (curSize > BundleCache.this.maxSize) {
+                    curSize -= e.getValue().getSize();
+                    return true;
+                } else {
+                    return false;
+                }
+            }
+        };
-    public NodePropBundle get(NodeId id) {
-        Entry entry = (Entry) bundles.remove(id);
-        if (entry != null) {
-            // at end
-            bundles.put(id, entry);
+    public synchronized NodePropBundle get(NodeId id) {
+        NodePropBundle bundle = bundles.get(id);
+        if (bundle != null) {
-        return entry == null ? null : entry.bundle;
+        return bundle;
-     * Puts a bunlde to the cache. If the new size of the cache exceeds the
-     * {@link #getMaxSize() max size} of the cache it will remove bundles from
-     * this cache until the limit is satisfied.
+     * Puts a bundle to the cache.
-    public void put(NodePropBundle bundle) {
-        Entry entry = (Entry) bundles.remove(bundle.getId());
-        if (entry == null) {
-            entry = new Entry(bundle, bundle.getSize());
-        } else {
-            curSize -= entry.size;
-            entry.bundle = bundle;
-            entry.size = bundle.getSize();
+    public synchronized void put(NodePropBundle bundle) {
+        NodePropBundle previous = bundles.get(bundle.getId());
+        if (previous != null) {
+            curSize -= previous.getSize();
-        bundles.put(bundle.getId(), entry);
-        curSize += entry.size;
-        // now limit size of cache
-        while (curSize > maxSize) {
-            entry = (Entry) bundles.remove(0);
-            curSize -= entry.size;
-        }
+        bundles.put(bundle.getId(), bundle);
+        curSize += bundle.getSize();
-    public boolean contains(NodeId id) {
+    public synchronized boolean contains(NodeId id) {
-    public NodePropBundle remove(NodeId id) {
-        Entry entry = (Entry) bundles.remove(id);
-        if (entry != null) {
-            curSize -= entry.size;
-            return entry.bundle;
-        } else {
-            return null;
+    public synchronized NodePropBundle remove(NodeId id) {
+        NodePropBundle bundle = bundles.remove(id);
+        if (bundle != null) {
+            curSize -= bundle.getSize();
+        return bundle;
-    public void clear() {
+    public synchronized void clear() {
-    /**
-     * Internal class that holds the bundles.
-     */
-    private static final class Entry {
-
-        /**
-         * the cached bundle
-         */
-        private NodePropBundle bundle;
-
-        /**
-         * the memory usage of the bundle in bytes
-         */
-        private long size;
-
-        /**
-         * Creates a new entry.
-         *
-         * @param bundle the bundle to cache
-         * @param size the size of the bundle
-         */
-        public Entry(NodePropBundle bundle, long size) {
-            this.bundle = bundle;
-            this.size = size;
-        }
-    }
-

INS26 MOV31 UPD40 INS40 INS23 MOV31 MOV29 MOV83 INS83 INS74 INS59 MOV29 INS79 UPD42 MOV44 INS83 INS83 INS39 UPD42 MOV44 INS8 INS83 INS83 INS83 INS43 INS43 INS43 INS42 INS42 INS45 MOV21 INS21 UPD65 MOV65 INS60 INS25 INS21 MOV21 INS25 INS41 UPD42 MOV42 INS42 UPD42 MOV42 INS7 UPD43 INS42 UPD66 INS43 INS59 INS27 INS8 MOV32 MOV42 UPD7 UPD43 MOV27 MOV8 INS42 INS22 INS14 UPD42 UPD42 INS32 UPD42 MOV42 INS42 MOV32 INS42 INS33 MOV21 INS42 UPD42 INS42 UPD42 UPD42 MOV32 UPD42 INS52 INS42 INS74 INS27 INS34 INS9 INS1 MOV42 UPD42 MOV42 MOV42 UPD42 UPD7 UPD7 INS43 INS43 INS43 INS11 INS34 INS31 INS42 INS32 INS42 MOV32 UPD42 MOV42 INS42 UPD42 MOV42 INS39 INS42 INS78 INS83 INS39 INS42 INS44 INS8 INS42 INS42 INS42 INS74 INS42 INS25 INS43 INS43 MOV43 INS27 INS8 INS8 INS40 INS42 MOV42 INS22 MOV21 INS41 INS41 INS52 INS42 UPD7 INS9 INS9 INS42 UPD42 INS32 INS32 UPD42 MOV42 INS42 UPD42 MOV42 DEL66 DEL42 DEL68 DEL66 DEL65 DEL66 DEL66 DEL65 DEL29 DEL39 DEL42 DEL43 DEL34 DEL32 DEL11 DEL43 DEL42 DEL43 DEL11 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL40 DEL7 DEL21 DEL40 DEL42 DEL7 DEL21 DEL8 DEL25 DEL21 DEL42 DEL40 DEL7 DEL21 DEL42 DEL27 DEL42 DEL40 DEL7 DEL21 DEL8 DEL61 DEL43 DEL42 DEL43 DEL14 DEL59 DEL23 DEL83 DEL42 DEL8 DEL31 DEL42 DEL43 DEL32 DEL11 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL33 DEL27 DEL33 DEL40 DEL16 DEL66 DEL65 DEL42 DEL42 DEL66 DEL65 DEL42 DEL52 DEL42 DEL22 DEL42 DEL40 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL42 DEL43 DEL11 DEL42 DEL42 DEL43 DEL42 DEL14 DEL42 DEL40 DEL7 DEL21 DEL40 DEL41 DEL8 DEL33 DEL41 DEL8 DEL25 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL59 DEL23 DEL55
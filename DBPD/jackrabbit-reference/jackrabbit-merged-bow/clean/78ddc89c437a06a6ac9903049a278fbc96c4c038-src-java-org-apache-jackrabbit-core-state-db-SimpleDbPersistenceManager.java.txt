- cleaned up persistence manager code in core
- improved space efficiency of simple serialization format as
  used by ObjectPersistenceManager, InMemPersistenceManager
  and SimpleDbPersistenceManager
- added configuration option to SimpleDbPersistenceManager
  whether BLOBs should be stored externally in the file system
  (default) or if they should be stored inline in the db
- prepared persistence managers for coming data model change 
  (new ItemState#modCount field)

see http://thread.gmane.org/gmane.comp.apache.jackrabbit.devel/4137

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@329224 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.fs.FileSystemPathUtil;
-import org.apache.jackrabbit.core.fs.FileSystemResource;
-import org.apache.jackrabbit.core.state.obj.BLOBStore;
-import org.apache.jackrabbit.core.state.obj.ObjectPersistenceManager;
+import org.apache.jackrabbit.core.state.util.BLOBStore;
+import org.apache.jackrabbit.core.state.util.FileSystemBLOBStore;
+import org.apache.jackrabbit.core.state.util.Serializer;
-import org.apache.jackrabbit.name.QName;
-import java.io.BufferedOutputStream;
+import java.io.BufferedReader;
-import java.io.OutputStream;
-import java.io.BufferedReader;
- * simple custom serialization format and a very basic non-normalized database
- * schema (in essence tables with one 'key' and one 'data' column).
+ * simple custom binary serialization format (see {@link Serializer}) and a
+ * very basic non-normalized database schema (in essence tables with one 'key'
+ * and one 'data' column).
+ * <li><code>externalBLOBs</code>: if <code>true</code> (the default) BINARY
+ * values (BLOBs) are stored in the local file system;
+ * if <code>false</code> BLOBs are stored in the database</li>
- *  &lt;/PersistenceManager&gt;
+ *       &lt;param name="externalBLOBs" value="false"/&gt;
+ *   &lt;/PersistenceManager&gt;
- *  &lt;/PersistenceManager&gt;
+ *       &lt;param name="externalBLOBs" value="false"/&gt;
+ *   &lt;/PersistenceManager&gt;
+ * See also {@link DerbyPersistenceManager}.
-public class SimpleDbPersistenceManager extends AbstractPersistenceManager
-        implements BLOBStore {
+public class SimpleDbPersistenceManager extends AbstractPersistenceManager {
-    /** Logger instance */
+    /**
+     * Logger instance
+     */
+    protected boolean externalBLOBs;
+
+    protected PreparedStatement nodeStateSelectExist;
+    protected PreparedStatement propertyStateSelectExist;
+    protected PreparedStatement nodeReferenceSelectExist;
-    /** file system where BLOB data is stored */
+    // shared prepared statements for BLOB management
+    // (if <code>externalBLOBs==false</code>)
+    protected PreparedStatement blobInsert;
+    protected PreparedStatement blobUpdate;
+    protected PreparedStatement blobSelect;
+    protected PreparedStatement blobSelectExist;
+    protected PreparedStatement blobDelete;
+
+    /**
+     * file system where BLOB data is stored
+     * (if <code>externalBLOBs==true</code>)
+     */
+    /**
+     * BLOBStore that manages BLOB data in the file system
+     * (if <code>externalBLOBs==true</code>)
+     */
+    protected BLOBStore blobStore;
+        externalBLOBs = true;
-    //------------------------------------------------------------< BLOBStore >
-    /**
-     * {@inheritDoc}
-     */
-    public FileSystemResource get(String blobId) throws Exception {
-        return new FileSystemResource(blobFS, blobId);
+    public boolean isExternalBLOBs() {
+        return externalBLOBs;
-    /**
-     * {@inheritDoc}
-     */
-    public String put(PropertyId id, int index, InputStream in, long size)
-            throws Exception {
-        String path = buildBlobFilePath(id.getParentUUID(), id.getName(), index);
-        OutputStream out = null;
-        FileSystemResource internalBlobFile = new FileSystemResource(blobFS, path);
-        internalBlobFile.makeParentDirs();
-        try {
-            out = new BufferedOutputStream(internalBlobFile.getOutputStream());
-            byte[] buffer = new byte[8192];
-            int read;
-            while ((read = in.read(buffer)) > 0) {
-                out.write(buffer, 0, read);
-            }
-        } finally {
-            out.close();
-        }
-        return path;
+    public void setExternalBLOBs(boolean externalBLOBs) {
+        this.externalBLOBs = externalBLOBs;
-    /**
-     * {@inheritDoc}
-     */
-    public boolean remove(String blobId) throws Exception {
-        FileSystemResource res = new FileSystemResource(blobFS, blobId);
-        if (!res.exists()) {
-            return false;
-        }
-        // delete resource and prune empty parent folders
-        res.delete(true);
-        return true;
+    public void setExternalBLOBs(String externalBLOBs) {
+        this.externalBLOBs = Boolean.valueOf(externalBLOBs).booleanValue();
-        /**
-         * store blob's in local file system in a sub directory
-         * of the workspace home directory
-         */
-        LocalFileSystem blobFS = new LocalFileSystem();
-        blobFS.setRoot(new File(context.getHomeDir(), "blobs"));
-        blobFS.init();
-        this.blobFS = blobFS;
-
+        nodeStateSelectExist =
+                con.prepareStatement("select 1 from "
+                + schemaObjectPrefix + "NODE where NODE_ID = ?");
+        propertyStateSelectExist =
+                con.prepareStatement("select 1 from "
+                + schemaObjectPrefix + "PROP where PROP_ID = ?");
+        nodeReferenceSelectExist =
+                con.prepareStatement("select 1 from "
+                + schemaObjectPrefix + "REFS where NODE_ID = ?");
+        if (externalBLOBs) {
+            /**
+             * store BLOBs in local file system in a sub directory
+             * of the workspace home directory
+             */
+            LocalFileSystem blobFS = new LocalFileSystem();
+            blobFS.setRoot(new File(context.getHomeDir(), "blobs"));
+            blobFS.init();
+            this.blobFS = blobFS;
+            blobStore = new FileSystemBLOBStore(blobFS);
+        } else {
+            /**
+             * store BLOBs in db
+             */
+            blobStore = new DbBLOBStore();
+
+            blobInsert =
+                    con.prepareStatement("insert into "
+                    + schemaObjectPrefix + "BINVAL (BINVAL_DATA, BINVAL_ID) values (?, ?)");
+            blobUpdate =
+                    con.prepareStatement("update "
+                    + schemaObjectPrefix + "BINVAL set BINVAL_DATA = ? where BINVAL_ID = ?");
+            blobSelect =
+                    con.prepareStatement("select BINVAL_DATA from "
+                    + schemaObjectPrefix + "BINVAL where BINVAL_ID = ?");
+            blobSelectExist =
+                    con.prepareStatement("select 1 from "
+                    + schemaObjectPrefix + "BINVAL where BINVAL_ID = ?");
+            blobDelete =
+                    con.prepareStatement("delete from "
+                    + schemaObjectPrefix + "BINVAL where BINVAL_ID = ?");
+        }
+
+            closeStatement(nodeStateSelectExist);
+            closeStatement(propertyStateSelectExist);
+            closeStatement(nodeReferenceSelectExist);
+            if (!externalBLOBs) {
+                closeStatement(blobInsert);
+                closeStatement(blobUpdate);
+                closeStatement(blobSelect);
+                closeStatement(blobSelectExist);
+                closeStatement(blobDelete);
+            } else {
+                // close BLOB file system
+                blobFS.close();
+                blobFS = null;
+            }
+            blobStore = null;
+
-            // close blob store
-            blobFS.close();
-            blobFS = null;
+
-            ObjectPersistenceManager.deserialize(state, in);
+            Serializer.deserialize(state, in);
-            ObjectPersistenceManager.deserialize(state, in, this);
+            Serializer.deserialize(state, in, blobStore);
-            ObjectPersistenceManager.serialize(state, out);
+            Serializer.serialize(state, out);
-            stmt.execute();
+            stmt.executeUpdate();
-            ObjectPersistenceManager.serialize(state, out, this);
+            Serializer.serialize(state, out, blobStore);
-            stmt.execute();
+            stmt.executeUpdate();
-            stmt.execute();
+            stmt.executeUpdate();
-        // delete binary values (stored as files)
+        // make sure binary values (BLOBs) are properly removed
-                        // delete blob file and prune empty parent folders
+                        // delete internal resource representation of BLOB value
+                        // also remove from BLOBStore
+                        String blobId = blobStore.createId((PropertyId) state.getId(), i);
+                        try {
+                            blobStore.remove(blobId);
+                        } catch (Exception e) {
+                            log.warn("failed to remove from BLOBStore: " + blobId, e);
+                        }
-            stmt.execute();
+            stmt.executeUpdate();
-            ObjectPersistenceManager.deserialize(refs, in);
+            Serializer.deserialize(refs, in);
-            ObjectPersistenceManager.serialize(refs, out);
+            Serializer.serialize(refs, out);
-            stmt.execute();
+            stmt.executeUpdate();
-            stmt.execute();
+            stmt.executeUpdate();
-        PreparedStatement stmt = nodeStateSelect;
+        PreparedStatement stmt = nodeStateSelectExist;
-        PreparedStatement stmt = propertyStateSelect;
+        PreparedStatement stmt = propertyStateSelectExist;
-        PreparedStatement stmt = nodeReferenceSelect;
+        PreparedStatement stmt = nodeReferenceSelectExist;
-    protected static String buildBlobFilePath(String parentUUID,
-                                              QName propName, int index) {
-        StringBuffer sb = new StringBuffer();
-        char[] chars = parentUUID.toCharArray();
-        int cnt = 0;
-        for (int i = 0; i < chars.length; i++) {
-            if (chars[i] == '-') {
-                continue;
-            }
-            //if (cnt > 0 && cnt % 4 == 0) {
-            if (cnt == 2 || cnt == 4) {
-                sb.append(FileSystem.SEPARATOR_CHAR);
-            }
-            sb.append(chars[i]);
-            cnt++;
-        }
-        sb.append(FileSystem.SEPARATOR_CHAR);
-        sb.append(FileSystemPathUtil.escapeName(propName.toString()));
-        sb.append('.');
-        sb.append(index);
-        sb.append(".bin");
-        return sb.toString();
-    }
-
+     *
-                    stmt.execute(sql);
+                    stmt.executeUpdate(sql);
+
+    //--------------------------------------------------------< inner classes >
+    class DbBLOBStore implements BLOBStore {
+        /**
+         * {@inheritDoc}
+         */
+        public String createId(PropertyId id, int index) {
+            // the blobId is a simple string concatenation of id plus index
+            StringBuffer sb = new StringBuffer();
+            sb.append(id.toString());
+            sb.append('[');
+            sb.append(index);
+            sb.append(']');
+            return sb.toString();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public synchronized InputStream get(String blobId) throws Exception {
+            PreparedStatement stmt = blobSelect;
+            try {
+                stmt.setString(1, blobId);
+                stmt.execute();
+                final ResultSet rs = stmt.getResultSet();
+                if (!rs.next()) {
+                    throw new Exception("no such BLOB: " + blobId);
+                }
+                final InputStream in = rs.getBinaryStream(1);
+
+                /**
+                 * return an InputStream wrapper in order to
+                 * close the ResultSet when the stream is closed
+                 */
+                return new InputStream() {
+                    public int read() throws IOException {
+                        return in.read();
+                    }
+
+                    public void close() throws IOException {
+                        in.close();
+                        // close ResultSet
+                        closeResultSet(rs);
+                    }
+
+                    public int available() throws IOException {
+                        return in.available();
+                    }
+
+                    public void mark(int readlimit) {
+                        in.mark(readlimit);
+                    }
+
+                    public boolean markSupported() {
+                        return in.markSupported();
+                    }
+
+                    public int read(byte b[]) throws IOException {
+                        return in.read(b);
+                    }
+
+                    public int read(byte b[], int off, int len) throws IOException {
+                        return in.read(b, off, len);
+                    }
+
+                    public void reset() throws IOException {
+                        in.reset();
+                    }
+
+                    public long skip(long n) throws IOException {
+                        return in.skip(n);
+                    }
+                };
+            } finally {
+                resetStatement(stmt);
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public synchronized void put(String blobId, InputStream in, long size)
+                throws Exception {
+            PreparedStatement stmt = blobSelectExist;
+            try {
+                stmt.setString(1, blobId);
+                stmt.execute();
+                ResultSet rs = stmt.getResultSet();
+                // a BLOB exists if the result has at least one entry
+                boolean exists = rs.next();
+                resetStatement(stmt);
+                closeResultSet(rs);
+
+                stmt = (exists) ? blobUpdate : blobInsert;
+                stmt.setBinaryStream(1, in, (int) size);
+                stmt.setString(2, blobId);
+                stmt.executeUpdate();
+            } finally {
+                resetStatement(stmt);
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public synchronized boolean remove(String blobId) throws Exception {
+            PreparedStatement stmt = blobDelete;
+            try {
+                stmt.setString(1, blobId);
+                return stmt.executeUpdate() == 1;
+            } finally {
+                resetStatement(stmt);
+            }
+        }
+    }

MOV26 MOV26 UPD40 UPD40 UPD40 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS55 INS83 INS39 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS29 INS83 MOV43 INS59 INS83 INS39 INS42 INS8 INS83 INS39 INS42 MOV44 INS8 INS83 INS39 INS42 INS44 INS8 INS42 INS43 INS31 INS31 INS31 INS31 UPD66 INS65 INS66 UPD66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS65 INS42 INS21 INS41 UPD39 UPD42 INS21 MOV43 INS42 INS21 INS21 INS21 INS21 INS25 INS54 MOV54 INS42 MOV29 INS83 MOV43 INS42 MOV44 MOV44 INS8 MOV29 INS83 INS83 INS43 INS42 MOV44 MOV43 INS8 MOV29 UPD83 MOV83 UPD83 MOV83 INS39 UPD42 MOV42 MOV44 MOV44 MOV44 MOV43 INS8 INS29 INS83 INS83 INS39 INS42 INS44 MOV43 INS8 INS42 INS42 UPD66 UPD66 INS66 INS66 INS66 INS7 INS42 INS7 INS7 INS7 INS7 INS7 INS42 INS8 INS8 INS8 MOV12 MOV8 MOV12 MOV8 INS8 MOV8 MOV60 INS21 INS21 MOV21 INS21 MOV41 UPD42 MOV42 MOV60 INS54 INS60 INS54 INS65 INS43 INS42 INS60 INS54 INS42 INS9 INS22 INS42 INS22 INS32 INS42 INS32 INS42 INS32 INS42 INS32 MOV60 MOV21 MOV21 MOV21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS25 INS21 MOV60 INS21 MOV21 MOV21 INS21 MOV21 INS21 INS21 UPD42 UPD42 UPD42 INS32 INS32 INS32 UPD43 INS8 INS8 INS43 INS59 INS8 INS8 INS65 INS42 INS43 INS59 INS8 INS8 INS52 INS42 INS52 INS42 INS32 UPD42 MOV42 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS27 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS32 INS32 INS32 INS38 INS8 INS8 INS7 INS32 INS32 INS32 INS32 INS42 INS42 MOV32 UPD42 MOV42 UPD42 MOV42 INS13 UPD42 MOV42 INS42 INS13 UPD42 UPD42 INS42 MOV21 MOV21 INS60 INS25 MOV60 INS41 MOV21 UPD42 MOV42 INS42 INS42 INS21 MOV21 MOV60 MOV60 INS21 INS21 INS21 MOV21 MOV21 MOV21 MOV21 INS42 INS42 INS42 INS21 INS41 MOV21 INS42 INS42 INS42 INS45 INS42 INS45 INS45 INS42 INS45 INS45 INS42 INS45 INS42 INS14 INS42 INS14 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS21 INS21 INS21 INS21 MOV21 MOV21 INS42 INS33 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 UPD42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 UPD42 INS83 INS43 INS59 INS38 INS8 INS83 INS43 INS14 INS32 INS43 UPD39 INS32 INS32 INS7 INS32 INS32 INS27 INS43 INS42 INS43 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS27 INS32 INS32 INS32 INS32 INS32 UPD42 UPD42 INS34 INS42 INS42 INS42 INS32 INS32 INS53 INS42 UPD42 INS32 INS43 INS1 UPD42 UPD42 INS42 INS42 INS34 INS42 INS42 UPD42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS16 UPD42 UPD42 INS34 INS42 INS11 UPD42 UPD42 INS34 INS42 INS42 INS42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 INS34 INS42 INS32 INS34 UPD42 UPD42 INS42 INS42 INS45 INS42 INS45 INS45 INS42 INS45 INS45 INS42 INS45 INS45 INS42 INS45 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS14 INS42 INS42 INS34 INS42 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 UPD42 UPD42 INS42 INS42 INS36 INS42 INS42 INS39 INS42 UPD42 MOV42 UPD42 MOV42 INS43 INS27 INS83 INS39 INS42 INS43 INS8 INS83 INS39 INS42 INS43 INS8 INS83 INS39 INS42 INS43 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS8 MOV83 UPD39 MOV39 UPD42 MOV42 INS44 INS43 INS8 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS8 INS83 INS39 INS42 INS43 INS8 INS83 INS39 INS42 INS44 INS43 INS8 INS42 INS60 INS54 UPD42 INS42 INS45 INS42 INS42 INS41 INS42 INS21 INS21 INS42 INS41 INS39 INS42 MOV21 MOV41 INS39 INS42 INS85 UPD42 MOV42 INS41 INS39 INS42 INS85 INS39 INS42 INS39 INS42 UPD42 MOV42 INS41 INS42 INS21 INS39 INS42 INS42 MOV41 MOV43 INS59 INS8 INS12 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS42 INS42 INS32 INS21 INS44 INS8 MOV42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS32 INS43 INS42 INS21 INS43 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS45 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL83 DEL43 DEL42 DEL43 DEL42 DEL42 DEL14 DEL41 DEL8 DEL31 DEL83 DEL43 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL43 DEL32 DEL14 DEL7 DEL21 DEL39 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL7 DEL36 DEL34 DEL27 DEL34 DEL32 DEL21 DEL8 DEL61 DEL8 DEL8 DEL54 DEL8 DEL31 DEL43 DEL42 DEL43 DEL42 DEL42 DEL14 DEL59 DEL60 DEL32 DEL38 DEL8 DEL25 DEL9 DEL41 DEL8 DEL31 DEL52 DEL42 DEL42 DEL42 DEL42 DEL52 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL13 DEL27 DEL18 DEL8 DEL25 DEL42 DEL34 DEL27 DEL42 DEL34 DEL27 DEL27 DEL8 DEL25 DEL8 DEL24 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL32 DEL21 DEL13 DEL32 DEL21 DEL8 DEL31 DEL42 DEL43 DEL42 DEL42 DEL14 DEL39 DEL85 DEL5 DEL39 DEL85 DEL5 DEL34 DEL3 DEL42 DEL9 DEL9 DEL39 DEL85 DEL5 DEL42 DEL34 DEL40 DEL42 DEL42 DEL2 DEL42 DEL37 DEL40 DEL45
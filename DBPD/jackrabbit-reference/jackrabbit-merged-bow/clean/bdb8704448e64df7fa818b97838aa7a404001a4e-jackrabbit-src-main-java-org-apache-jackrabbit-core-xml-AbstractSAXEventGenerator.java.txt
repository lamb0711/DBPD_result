JCR-482: Applied Julian Reschke's patch to avoid problems with concurrent namespace registrations.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@439854 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.HashMap;
+
+    
+    /**
+     * the set of namespace declarations that have already been serialized
+     */
+    protected NamespaceStack namespaces;
+        // start with an empty set of known prefixes
+        this.namespaces = new NamespaceStack(null);
-     * XML top-level element. The effect is the same as setting the
+     * XML element as required (e.g., normally just on the root
+     * element). The effect is the same as setting the
-        if (level == 0) {
-            String[] prefixes = session.getNamespacePrefixes();
-            for (int i = 0; i < prefixes.length; i++) {
-                if (prefixes[i].length() > 0
-                        && !QName.NS_XML_PREFIX.equals(prefixes[i])) {
+        String[] prefixes = session.getNamespacePrefixes();
+        NamespaceStack newNamespaces = null;
+        
+        for (int i = 0; i < prefixes.length; i++) {
+            String prefix = prefixes[i];
+            
+            if (prefix.length() > 0
+                    && !QName.NS_XML_PREFIX.equals(prefix)) {
+                String uri = session.getNamespaceURI(prefix);
+                
+                // get the matching namespace from previous declarations
+                String mappedToNs = this.namespaces.getNamespaceURI(prefix);
+            
+                if (! uri.equals(mappedToNs)) {
+                    // when not the same, add a declaration
-                            QName.NS_XMLNS_URI,
-                            prefixes[i],
-                            QName.NS_XMLNS_PREFIX + ":" + prefixes[i],
-                            "CDATA",
-                            session.getNamespaceURI(prefixes[i]));
+                        QName.NS_XMLNS_URI,
+                        prefix,
+                        QName.NS_XMLNS_PREFIX + ":" + prefix,
+                        "CDATA",
+                        uri);
+                    
+                    if (newNamespaces == null) {
+                        // replace current namespace stack when needed
+                        newNamespaces = new NamespaceStack(this.namespaces);
+                        this.namespaces = newNamespaces;
+                    }
+                    
+                    // remember the new declaration
+                    newNamespaces.setNamespacePrefix(prefix, uri);
+                
-                Node childNode = nodeIter.nextNode();
+                Node childNode = nodeIter.nextNode();
+                
+                // remember the current namespace declarations
+                NamespaceStack previousNamespaces = this.namespaces;
+                
+                
+                // restore the effective namespace declarations 
+                // (from before visiting the child node)
+                this.namespaces = previousNamespaces;
+            
+
+    
+    /**
+     * Implements a simple stack of namespace
+     * declarations.
+     */
+    
+    private static class NamespaceStack extends HashMap {
+      
+        /**
+         * Parent stack (may be <code>null</code>)
+         */
+        private final NamespaceStack parent;
+              
+        /**
+         * Instantiate a new stack
+         * @param parent parent stack (may be <code>null</code> for the initial stack)
+         */
+        public NamespaceStack(NamespaceStack parent) {
+            this.parent = parent;
+        }
+      
+        /**
+         * Obtain namespace URI for a prefix
+         * @param prefix prefix
+         * @return namespace URI (or <code>null</code> when unknown)
+         */
+        public String getNamespaceURI(String prefix) {
+          
+            String namespace = (String)super.get(prefix);
+    
+            if (namespace != null) {
+                // found in this element, return right away
+                return namespace;
+            }
+            else {
+                // ask parent, when present
+                if (this.parent == null) {
+                    return null;
+                }
+                else {
+                    return this.parent.getNamespaceURI(prefix);
+                }
+              }
+        }
+      
+        /**
+         * Add a new prefix mapping
+         * @param prefix namespace prefix
+         * @param uri namespace URI
+         */
+        public void setNamespacePrefix(String prefix, String uri) {
+            super.put(prefix, uri);
+        }
+    }

INS26 INS40 INS23 INS55 INS29 INS83 INS43 INS59 INS29 INS83 INS83 INS42 INS43 INS23 INS31 INS31 INS31 INS65 INS42 INS42 INS21 MOV60 INS60 MOV24 INS65 INS42 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS42 INS44 INS8 INS29 INS83 INS43 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS8 INS66 INS7 INS66 UPD66 INS43 INS59 INS66 INS66 INS65 INS42 INS42 INS65 INS65 INS43 INS42 INS21 INS65 INS65 INS65 INS42 INS43 INS42 INS60 INS25 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS21 INS22 INS14 INS42 INS42 INS33 INS60 INS66 INS66 INS42 INS66 INS42 INS7 INS66 INS42 INS66 INS66 INS42 INS43 INS59 INS27 INS8 INS8 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS48 INS52 INS42 INS43 INS33 INS43 INS59 INS8 INS22 INS42 INS42 INS42 INS11 INS42 INS33 INS41 INS25 INS42 INS42 INS42 INS42 INS42 INS42 MOV2 INS60 INS60 INS25 INS60 INS21 INS52 INS42 INS43 INS48 INS42 INS27 INS8 INS8 INS43 INS59 INS43 INS59 INS38 MOV8 INS43 INS59 INS7 INS42 INS42 INS42 INS22 INS33 INS41 INS41 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS21 INS25 INS21 INS42 INS42 INS22 INS22 INS42 INS52 INS42 INS33 INS32 INS42 INS42 INS42 INS22 INS42 INS42 INS42 INS42 INS42 INS32 INS27 INS8 INS32 INS52 INS42 INS52 INS42 INS22 INS42 INS42 INS52 INS42 MOV42 MOV42 MOV40 INS42 MOV27 MOV45 INS42 INS42 INS33 INS21 INS21 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS52 INS42 INS42 INS7 INS7 INS42 INS14 INS22 INS42 INS43 INS22 INS52 INS42 INS42 INS52 INS42 DEL42 DEL42 DEL2 DEL42 DEL42 DEL2 DEL42 DEL42 DEL2 DEL42 DEL42 DEL2 DEL32 DEL32 DEL21 DEL42 DEL34 DEL27 DEL8 DEL25
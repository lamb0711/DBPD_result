work in progress

- Restore: pass NodeState(s) and Path instead of NodeId(s)
- LockManager: make sure lockmanager only remembers workspace states
- LockManager: make sure operations are executed using workspace states
- LockManager: improve isLocked/getLock/checkIsLocked and respect locks that
have been accessed before.
- VersionManager: make sure operations are executed using workspace states
- VersionManager: add checkIsCheckedOut
- VersionManager: force manager to have a WorkspaceManager
- NodeReferences:
  > make interface package protected
  > clarify method naming
  > add implementation to WorkspaceItemStateFactory
  > add NodeReferences field to NodeState
  > TO_IMPROVE: references are currently always retrieve from the SPI.
- ItemStateManager + NodeReferences
  > rename interfaces methods
  > change method signature to take NodeState instead of NodeId
  > 'getReferences' returns the property states directly

- remove some JR DIFFs. 

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@432234 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.state.NodeReferences;
-    // TODO: TO-BE-FIXED. Major refactoring of caching mechanism with change to SPI ids
-        try {
-            this.service = service;
-            this.sessionInfo = sessionInfo;
+        this.service = service;
+        this.sessionInfo = sessionInfo;
-            ItemStateFactory isf = createItemStateFactory();
-            cache = new WorkspaceItemStateManager(isf, service.getIdFactory());
-            addEventListener(cache);
+        ItemStateFactory isf = createItemStateFactory();
+        cache = new WorkspaceItemStateManager(isf, service.getIdFactory());
+        addEventListener(cache);
-            nsRegistry = createNamespaceRegistry();
-            ntRegistry = createNodeTypeRegistry(nsRegistry);
-            externalChangeListener = createChangeListener();
-        } catch (ItemStateException e) {
-            throw new RepositoryException(e);
-        }
+        nsRegistry = createNamespaceRegistry();
+        ntRegistry = createNodeTypeRegistry(nsRegistry);
+        externalChangeListener = createChangeListener();
-     * @see ItemStateManager#getNodeReferences(NodeId)
+     * @see ItemStateManager#getReferingStates(NodeState)
+     * @param nodeState
-    public NodeReferences getNodeReferences(NodeId id) throws NoSuchItemStateException, ItemStateException {
+    public Collection getReferingStates(NodeState nodeState) throws ItemStateException {
-            return cache.getNodeReferences(id);
+            return cache.getReferingStates(nodeState);
-     * @see ItemStateManager#hasNodeReferences(NodeId)
+     * @see ItemStateManager#hasReferingStates(NodeState)
+     * @param nodeState
-    public boolean hasNodeReferences(NodeId id) {
+    public boolean hasReferingStates(NodeState nodeState) {
-            return cache.hasNodeReferences(id);
+            return cache.hasReferingStates(nodeState);
-    public void importXml(NodeId parentId, InputStream xmlStream, int uuidBehaviour) throws RepositoryException, LockException, ConstraintViolationException, AccessDeniedException, UnsupportedRepositoryOperationException, ItemExistsException, VersionException {
+    public void importXml(NodeState parentState, InputStream xmlStream, int uuidBehaviour) throws RepositoryException, LockException, ConstraintViolationException, AccessDeniedException, UnsupportedRepositoryOperationException, ItemExistsException, VersionException {
+        // TODO check retrieval of nodeId
+        NodeId parentId = parentState.getNodeId();
-            NodeId nId = operation.getNodeId();
-            NodeId[] versionIds = operation.getVersionIds();
-            NodeId[] vIds = new NodeId[versionIds.length];
-            for (int i = 0; i < vIds.length; i++) {
-                vIds[i] = versionIds[i];
+            NodeState nState = operation.getNodeState();
+            NodeState[] versionStates = operation.getVersionStates();
+            if (versionStates == null || versionStates.length == 0) {
+                throw new IllegalArgumentException("Restore must specify at least a singe version.");
-            if (nId == null) {
+            NodeId[] vIds = new NodeId[versionStates.length];
+            for (int i = 0; i < vIds.length; i++) {
+                vIds[i] = versionStates[i].getNodeId();
+            }
+
+            if (nState == null) {
-                events = service.restore(sessionInfo, nId, vIds[0], operation.removeExisting());
+
+                NodeId targetId;
+                Path relPath = operation.getRelativePath();
+                if (relPath != null) {
+                    targetId = getIdFactory().createNodeId(nState.getNodeId(), relPath);
+                } else {
+                    targetId = nState.getNodeId();
+                }
+                events = service.restore(sessionInfo, targetId, vIds[0], operation.removeExisting());

MOV8 UPD43 UPD42 UPD42 INS65 UPD42 UPD43 UPD42 INS65 UPD43 UPD42 INS43 UPD42 INS60 INS42 UPD42 INS42 UPD42 INS42 MOV43 INS59 INS25 UPD42 UPD42 INS42 INS32 INS43 UPD5 INS27 INS8 MOV5 UPD43 UPD43 INS42 INS42 INS42 UPD42 UPD43 UPD42 INS27 INS27 INS53 UPD42 INS60 INS60 INS25 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS33 INS40 INS34 INS14 MOV5 UPD40 MOV43 INS59 INS43 INS59 INS27 INS8 INS8 INS43 INS45 INS32 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS21 INS42 INS2 INS42 INS42 INS42 INS7 INS7 UPD42 UPD42 MOV42 MOV42 INS42 INS32 INS42 INS32 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 DEL40 DEL26 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL42 DEL43 DEL2
JCR-702: Allow database as backend for clustering
JCR-703: Add signature and major/minor version to the journal files used for clustering 


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@495239 13f79535-47bb-0310-9956-ffa450edef68

+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.InputStream;
- * A file record log is a file containing {@link FileRecord}s. Internally,
- * the first 8 bytes contain the revision this log starts with.
+ * A file record log is a file containing {@link FileRecord}s. Physically,
+ * the first 4 bytes contain a signature, followed by a major and minor version
+ * (2 bytes each). The next 8 bytes contain the revision this log starts with.
+ * After this, zero or more <code>FileRecord</code>s follow.
+     * Logger.
+     */
+    private static Logger log = LoggerFactory.getLogger(FileRecordLog.class);
+
+    /**
+     * Record log signature.
+     */
+    private static final byte[] SIGNATURE = { 'J', 'L', 'O', 'G' };
+
+    /**
+     * Known major version.
+     */
+    private static final short MAJOR_VERSION = 1;
+
+    /**
+     * Known minor version.
+     */
+    private static final short MINOR_VERSION = 0;
+
+    /**
+     * Header size. This is the size of {@link #SIGNATURE}, {@link #MAJOR_VERSION},
+     * {@link #MINOR_VERSION} and first revision (8 bytes).
+     */
+    private static final int HEADER_SIZE = 4 + 2 + 2 + 8;
+
+    /**
+                readHeader(in);
-                maxRevision = minRevision + file.length() - 8;
+                maxRevision = minRevision + file.length() - HEADER_SIZE;
-            String msg = "Seek allowed exactly once.";
+            String msg = "Stream already open: seek() only allowed once.";
-        open();
+        in = new DataInputStream(new BufferedInputStream(
+                new FileInputStream(file)));
+        skip(revision - minRevision + HEADER_SIZE);
+    }
-        long skiplen = revision - minRevision + 8;
+    /**
+     * Skip exactly <code>n</code> bytes. Throws if less bytes are skipped.
+     *
+     * @param n bytes to skip
+     * @throws IOException if an I/O error occurs, or less that <code>n</code> bytes
+     *                     were skipped.
+     */
+    private void skip(long n) throws IOException {
+        long skiplen = n;
-     * Append a record to this log.
+     * Read the file record at the current seek position.
-     * @param record record to add
+     * @return file record
-    public void append(FileRecord record) throws IOException {
+    public FileRecord read() throws IOException {
+        byte[] creator = new byte[in.readUnsignedShort()];
+        in.readFully(creator);
+        int length = in.readInt();
+        return new FileRecord(creator, length, in);
+    }
+
+    /**
+     * Append a record to this log. Returns the revision following this record.
+     *
+     * @param record record to add
+     * @return next available revision
+     * @throws IOException if an I/O error occurs
+     */
+    public long append(long revision, byte[] creator, File record) throws IOException {
+            int recordLength = (int) record.length();
-                out.writeLong(record.getRevision());
+                writeHeader(out);
+                out.writeLong(revision);
-            record.append(out);
+            out.writeShort(creator.length);
+            out.write(creator);
+            out.writeInt(recordLength);
+            append(record, out);
+            return revision + getRecordSize(creator, recordLength);
-     * Open this log.
-     *
-     * @throws IOException if an I/O error occurs
-     */
-    private void open() throws IOException {
-        in = new DataInputStream(new BufferedInputStream(
-                new FileInputStream(file)));
-    }
-
-    /**
-     * Return the underlying input stream.
-     *
-     * @return underlying input stream
-     */
-    protected DataInputStream getInputStream() {
-        if (in == null) {
-            String msg = "Input stream not open.";
-            throw new IllegalStateException(msg);
-        }
-        return in;
-    }
-
-    /**
-     *
-     * @throws IOException if an I/O error occurs
-    public void close() throws IOException {
-        if (in != null) {
+    public void close() {
+        try {
+            if (in != null) {
+                in.close();
+            }
+        } catch (IOException e) {
+            String msg = "Error while closing record log: " + e.getMessage();
+            log.warn(msg);
+        }
+    }
+
+    /**
+     * Return the size of a stored record . A stored record's size is the size of
+     * the length-prefixed creator string plus the size of the length-prefixed data.
+     *
+     * @param creator creator string
+     * @param length data length
+     * @return size of a stored record
+     */
+    public static int getRecordSize(byte[] creator, int length) {
+        return 2 + creator.length + 4 + length;
+    }
+
+    /**
+     * Read signature and major/minor version of file and verify.
+     *
+     * @param in input stream
+     * @throws IOException if an I/O error occurs or the file does
+     *                     not have a valid header.
+     */
+    private void readHeader(DataInputStream in) throws IOException {
+        byte[] signature = new byte[SIGNATURE.length];
+        in.readFully(signature);
+
+        for (int i = 0; i < SIGNATURE.length; i++) {
+            if (signature[i] != SIGNATURE[i]) {
+                String msg = "Record log '" + file.getPath() +
+                        "' has wrong signature: " + toHexString(signature);
+                throw new IOException(msg);
+            }
+        }
+
+        short major = in.readShort();
+        in.readShort(); // minor version not used yet
+
+        if (major > MAJOR_VERSION) {
+            String msg = "Record log '" + file.getPath() +
+                    "' has incompatible major version: " + major;
+            throw new IOException(msg);
+        }
+    }
+
+    /**
+     * Write signature and major/minor.
+     *
+     * @param out input stream
+     * @throws IOException if an I/O error occurs.
+     */
+    private void writeHeader(DataOutputStream out) throws IOException {
+        out.write(SIGNATURE);
+        out.writeShort(MAJOR_VERSION);
+        out.writeShort(MINOR_VERSION);
+    }
+
+    /**
+     * Append a record to this log's output stream.
+     *
+     * @param record record to append
+     * @param out where to append to
+     */
+    private static void append(File record, DataOutputStream out) throws IOException {
+        byte[] buffer = new byte[8192];
+        int len;
+
+        InputStream in = new BufferedInputStream(new FileInputStream(record));
+        try {
+            while ((len = in.read(buffer)) > 0) {
+                out.write(buffer, 0, len);
+            }
+            out.flush();
+        } finally {
+
+    /**
+     * Convert a byte array to its hexadecimal string representation.
+     */
+    private static String toHexString(byte[] b) {
+        StringBuffer buf = new StringBuffer();
+        for (int i = 0; i < b.length; i++) {
+            String s = Integer.toHexString(b[i] & 0xff).toUpperCase();
+            if (s.length() == 1) {
+                buf.append('0');
+            }
+            buf.append(s);
+        }
+        return buf.toString();
+    }

INS26 INS26 INS26 INS40 INS40 INS40 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS83 INS5 INS59 INS29 INS83 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS83 INS39 INS59 MOV29 MOV83 MOV39 INS42 MOV44 MOV43 MOV8 INS29 UPD83 UPD42 INS44 INS29 INS83 INS43 INS42 MOV43 INS8 MOV29 INS83 INS39 MOV42 INS44 INS44 MOV44 MOV43 MOV8 MOV29 INS83 INS39 INS42 INS8 UPD83 INS83 UPD39 UPD42 INS44 INS44 INS8 UPD83 INS39 UPD42 INS44 INS43 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS29 INS83 UPD83 INS42 INS44 INS44 INS43 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS8 UPD66 INS66 UPD66 INS66 INS65 INS42 INS42 INS32 INS65 INS39 INS85 INS42 INS4 INS65 INS42 INS34 INS65 INS42 INS34 INS65 INS42 INS27 INS25 INS21 INS65 INS65 INS65 INS39 INS42 INS65 INS65 MOV65 INS42 INS60 INS21 INS60 INS41 INS65 INS39 INS42 INS5 INS42 INS43 INS54 UPD65 INS65 INS65 INS5 INS42 INS39 INS42 INS41 UPD65 INS65 MOV43 INS42 INS42 INS60 INS21 INS24 INS60 INS21 INS25 INS65 INS65 INS65 INS43 INS42 INS42 INS21 INS21 INS21 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS42 INS60 INS60 INS60 INS54 INS65 INS42 INS5 INS42 INS60 INS24 INS41 INS66 INS42 INS42 INS57 INS66 INS13 INS13 INS13 INS13 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS34 INS34 INS34 INS34 MOV27 INS8 INS32 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS66 INS5 INS59 INS32 INS39 INS59 INS14 UPD66 INS66 INS39 INS85 INS42 MOV8 INS12 UPD66 INS66 UPD42 UPD66 INS42 INS66 INS66 INS39 INS85 INS27 UPD66 INS42 UPD66 INS42 INS66 INS66 INS5 INS59 INS32 INS58 INS27 INS37 INS8 INS39 INS59 INS32 INS27 INS8 INS66 INS42 INS66 INS42 INS66 INS42 INS32 INS32 INS32 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS5 INS59 INS39 INS59 INS43 INS59 INS8 INS8 INS66 INS39 INS85 INS43 INS59 INS58 INS27 INS37 INS8 INS32 INS43 INS67 INS67 INS67 INS60 INS53 INS42 MOV27 INS42 INS39 INS85 INS42 INS3 INS42 INS42 INS42 INS42 INS32 MOV43 INS42 INS42 INS42 INS60 INS21 INS21 INS21 INS41 INS44 INS8 INS34 INS40 INS34 INS42 INS39 INS85 INS42 INS3 INS42 INS42 INS42 INS39 INS59 INS42 INS40 INS42 MOV25 INS42 INS32 INS42 INS42 INS42 INS42 INS60 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS39 INS85 INS42 INS3 INS42 INS42 INS42 INS14 INS61 INS21 INS21 INS42 INS42 INS14 INS39 INS59 INS42 INS40 INS42 INS60 INS25 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS14 INS42 INS5 INS32 INS42 INS42 INS39 INS59 INS32 INS32 INS32 INS27 INS43 INS42 INS60 INS21 INS5 INS40 INS42 INS34 UPD27 INS42 INS42 INS43 INS59 INS14 INS5 INS34 INS43 INS14 INS27 INS8 INS32 INS32 INS43 INS42 INS34 INS43 INS59 INS27 INS8 INS32 INS21 INS42 INS42 INS45 INS43 INS42 INS39 INS85 INS42 INS42 INS42 INS11 INS21 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS32 INS42 MOV43 INS59 INS32 INS39 INS85 INS2 INS2 INS42 INS42 INS27 INS43 INS42 INS39 INS85 INS42 INS43 INS42 INS36 INS34 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS34 INS21 INS42 INS42 INS42 INS32 INS42 INS39 INS32 INS32 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS45 INS42 INS42 INS42 INS7 INS32 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS45 INS32 INS27 UPD43 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS27 INS42 INS42 INS13 INS42 INS42 INS42 INS45 INS32 INS45 INS32 UPD42 INS42 INS42 INS42 INS2 INS34 INS42 INS42 INS42 INS42 INS42 INS42 DEL34 DEL34 DEL42 DEL45 DEL59 DEL60 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL42 DEL32 DEL21 DEL42 DEL32 DEL31 DEL42 DEL33 DEL45 DEL42 DEL41 DEL42
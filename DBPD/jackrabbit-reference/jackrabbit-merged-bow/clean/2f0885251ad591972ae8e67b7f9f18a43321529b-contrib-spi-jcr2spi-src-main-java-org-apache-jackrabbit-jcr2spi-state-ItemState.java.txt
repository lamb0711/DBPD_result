Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.spi.IdFactory;
-import org.apache.jackrabbit.spi.Event;
-import org.apache.jackrabbit.name.Path;
-import org.apache.jackrabbit.name.MalformedPathException;
+import org.apache.jackrabbit.spi.NodeId;
+import org.apache.jackrabbit.spi.PropertyId;
+import org.apache.jackrabbit.name.Path;
+import org.apache.jackrabbit.jcr2spi.hierarchy.HierarchyEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.NodeEntry;
+import org.apache.jackrabbit.jcr2spi.hierarchy.PropertyEntry;
+import org.apache.jackrabbit.jcr2spi.nodetype.EffectiveNodeType;
+import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeRegistry;
+import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeConflictException;
-import javax.jcr.ItemNotFoundException;
-     * Flag used to distinguish workspace states from session states. The first
-     * accepts call to {@link #refresh(Event)}, while the latter
+     * Flag used to distinguish workspace states from session states. The latter
-     *  IdFactory used to build id of the states
-     */
-    final IdFactory idFactory;
-
-    /**
-    /**
-     * The parent <code>NodeState</code> or <code>null</code> if this
-     * instance represents the root node.
-     */
-    NodeState parent;
+    // TODO: find better solution..... needed to retrieve definition.
+    final NodeTypeRegistry ntReg;
-     * @param parent
-     * @param initialStatus the initial status of the item state object
+     * @param initialStatus
+     * @param isWorkspaceState
-    protected ItemState(NodeState parent, int initialStatus, ItemStateFactory isf,
-                        IdFactory idFactory, boolean isWorkspaceState) {
+    protected ItemState(int initialStatus, boolean isWorkspaceState,
+                        ItemStateFactory isf, NodeTypeRegistry ntReg) {
-        this.parent = parent;
-        this.idFactory = idFactory;
+        this.ntReg = ntReg;
-     * @param overlayedState the backing item state being overlayed
-     * @param initialStatus the initial status of the new <code>ItemState</code> instance
+     * @param overlayedState
+     * @param initialStatus
-    protected ItemState(ItemState overlayedState, NodeState parent,
-                        int initialStatus, ItemStateFactory isf, IdFactory idFactory) {
+    protected ItemState(ItemState overlayedState, int initialStatus, ItemStateFactory isf) {
-        this.parent = parent;
-        this.idFactory = idFactory;
-
+        this.ntReg = overlayedState.ntReg;
+     * The <code>HierarchyEntry</code> corresponding to this <code>ItemState</code>.
+     *
+     * @return The <code>HierarchyEntry</code> corresponding to this <code>ItemState</code>.
+     */
+    public abstract HierarchyEntry getHierarchyEntry();
+
+    /**
+     * Utility method:
-     * Returns the name of this state.
+     * Utility method:
+     * Returns the name of this state. Shortcut for calling 'getQName' on the
+     * {@link ItemState#getHierarchyEntry() hierarchy entry}.
-    public abstract QName getQName();
+    public QName getQName() {
+        return getHierarchyEntry().getQName();
+    }
-     * Returns the identifier of this item state.
+     * Utility method:
+     * Returns the identifier of this item state. Shortcut for calling 'getId'
+     * on the {@link ItemState#getHierarchyEntry() hierarchy entry}.
-     * Returns the qualified path of this item state.
+     * Utility method:
+     * Returns the qualified path of this item state. Shortcut for calling
+     * 'getPath' on the {@link ItemState#getHierarchyEntry() hierarchy entry}.
-     * @return qualified path
-     * @throws ItemNotFoundException
-     * @throws RepositoryException
+     * @return
+     * @throws RepositoryException if an error occurs
-    public Path getQPath() throws ItemNotFoundException, RepositoryException {
-        // shortcut for root state
-        if (parent == null) {
-            return Path.ROOT;
-        }
-
-        // build path otherwise
-        try {
-            Path.PathBuilder builder = new Path.PathBuilder();
-            buildPath(builder, this);
-            return builder.getPath();
-        } catch (MalformedPathException e) {
-            String msg = "Failed to build path of " + this;
-            throw new RepositoryException(msg, e);
-        }
+    public Path getQPath() throws RepositoryException {
+        return getHierarchyEntry().getPath();
-     * Adds the path element of an item id to the path currently being built.
-     * On exit, <code>builder</code> contains the path of <code>state</code>.
+     * Utility method: Shortcut for calling
+     * 'getParent().getNodeState()' on the {@link ItemState#getHierarchyEntry()
+     * hierarchy entry}.
-     * @param builder builder currently being used
-     * @param state   item to find path of
+     * @return
+     * @throws NoSuchItemStateException
+     * @throws ItemStateException
-    private void buildPath(Path.PathBuilder builder, ItemState state)
-        throws ItemNotFoundException {
-        NodeState parentState = state.getParent();
-        // shortcut for root state
-        if (parentState == null) {
-            builder.addRoot();
-            return;
-        }
-
-        // recursively build path of parent
-        buildPath(builder, parentState);
-
-        QName name = state.getQName();
-        if (state.isNode()) {
-            int index = ((NodeState)state).getIndex();
-            // add to path
-            if (index == Path.INDEX_DEFAULT) {
-                builder.addLast(name);
-            } else {
-                builder.addLast(name, index);
-            }
-        } else {
-            // property-state: add to path
-            builder.addLast(name);
-        }
-    }
-
-    /**
-     * Returns the parent <code>NodeState</code> or <code>null</code>
-     * if either this item state represents the root node or this item state is
-     * 'free floating', i.e. not attached to the repository's hierarchy.
-     *
-     * @return the parent <code>NodeState</code>
-     */
-    public NodeState getParent() {
-        return parent;
+    public NodeState getParent() throws NoSuchItemStateException, ItemStateException {
+        return getHierarchyEntry().getParent().getNodeState();
-    void setStatus(int newStatus) {
+    public void setStatus(int newStatus) {
-     * Reloads this item state recursively. If '<code>keepChanges</code>' is
-     * true, states with transient changes are left untouched. Otherwise this
-     * state gets its data reloaded from the persistent state.
-     * todo throw exception in case of error?
-     */
-    public abstract void reload(boolean keepChanges);
-
-    /**
-    abstract boolean merge(ItemState another, boolean keepChanges);
-
-    /**
-     * Invalidates this item state recursively. In contrast to {@link #refresh}
-     * this method only sets the status of this item state to {@link
-     * Status#INVALIDATED} and does not acutally update it with the persistent
-     * state in the repository.
-     */
-    public abstract void invalidate(boolean recursive);
+     public abstract boolean merge(ItemState another, boolean keepChanges);
-     * @param state
+     * @param overlayed
-    public void statusChanged(ItemState state, int previousStatus) {
+    public void statusChanged(ItemState overlayed, int previousStatus) {
-        state.checkIsWorkspaceState();
+        overlayed.checkIsWorkspaceState();
-        if (state == overlayedState) {
-            switch (state.getStatus()) {
+        if (overlayed == overlayedState) {
+            switch (overlayed.getStatus()) {
-                        synchronized (this) {
-                            if (merge(state, false) || status == Status.INVALIDATED) {
-                                // temporarily set the state to MODIFIED in order
-                                // to inform listeners.
-                                setStatus(Status.MODIFIED);
-                            }
-                        }
+                        // temporarily set the state to MODIFIED in order to inform listeners.
+                        setStatus(Status.MODIFIED);
-                    log.error("Workspace state cannot have its state changed to " + state.getStatus());
+                    log.error("Workspace state cannot have its state changed to " + overlayed.getStatus());
-    //--------------------------------------------------< Workspace - State >---
-    /**
-     * Used on 'workspace' states in order to update the state according to
-     * an external modification indicated by the given event.
-     *
-     * @param event
-     * @throws IllegalStateException if this state is a 'session' state.
-     */
-    abstract void refresh(Event event);
-
-    /**
-     * Returns the overlaying item state or <code>null</code> if that state
-     * has not been created yet or has been disconnected.
-     *
-     * @return
-     */
-    ItemState getSessionState() {
-        checkIsWorkspaceState();
-        ItemStateLifeCycleListener[] la;
-        synchronized (listeners) {
-            la = (ItemStateLifeCycleListener[]) listeners.toArray(new ItemStateLifeCycleListener[listeners.size()]);
-        }
-        for (int i = 0; i < la.length; i++) {
-            if (la[i] instanceof ItemState) {
-                return (ItemState) la[i];
-            }
-        }
-        return null;
-    }
-
-    void connect(ItemState overlayedState) {
+    private void connect(ItemState overlayedState) {
-        if (this.overlayedState != null && this.overlayedState != overlayedState) {
+        if (this.overlayedState == null) {
+            setOverLayedState(overlayedState);
+        } else if (this.overlayedState != overlayedState) {
+        } // attempt to connect state to its ol-state again -> nothing to do.
+    }
+
+    /**
+     * Replaces the overlayedState with a new instance retrieved from the
+     * persistent layer thus forcing a reload of this ItemState or in case
+     * of a NEW state, retrieves the overlayed state after the state has been
+     * persisted and connects the NEW state. Note, that in the latter case,
+     * the parent must already be connected to its overlayed state.
+     *
+     * @param keepChanges
+     * @throws NoSuchItemStateException
+     * @throws ItemStateException
+     */
+    public void reconnect(boolean keepChanges) throws NoSuchItemStateException, ItemStateException {
+        checkIsSessionState();
+        // Need to use the workspace-ISF in order not to create yet another
+        // session-state.
+        ItemStateFactory wspIsf;
+        if (overlayedState != null) {
+            wspIsf = overlayedState.isf;
+        } else {
+            wspIsf = getParent().overlayedState.isf;
+        }
+
+        ItemState overlayed;
+        if (isNode()) {
+            overlayed = wspIsf.createNodeState((NodeId) getId(), (NodeEntry) getHierarchyEntry());
+        } else {
+            overlayed = wspIsf.createPropertyState((PropertyId) getId(), (PropertyEntry) getHierarchyEntry());
+        }
+        setOverLayedState(overlayed);
+        boolean modified = merge(overlayed, keepChanges);
+        if (status == Status.NEW || status == Status.INVALIDATED) {
+            setStatus(Status.EXISTING);
+        } else if (modified) {
+            // start notification by marking ol-state modified.
+            overlayed.setStatus(Status.MODIFIED);
+        }
+    }
+
+    /**
+     *
+     * @param overlayedState
+     */
+    private void setOverLayedState(ItemState overlayedState) {
+        if (this.overlayedState != null) {
+           this.overlayedState.removeListener(this);
-     * Removes this item state. This will change the status of this property
-     * state to either {@link Status#EXISTING_REMOVED} or {@link
-     * Status#REMOVED} depending on the current status.
-     *
-     * @throws ItemStateException if an error occurs while removing this item
-     * state. e.g. this item state is not valid anymore.
-     */
-    void remove() throws ItemStateException {
-        checkIsSessionState();
-        if (!isValid()) {
-            throw new ItemStateException("Cannot remove an invalid ItemState");
-        }
-        int oldStatus = getStatus();
-        if (oldStatus == Status.NEW) {
-            setStatus(Status.REMOVED);
-        } else {
-            setStatus(Status.EXISTING_REMOVED);
-        }
-        // now inform parent
-        getParent().childStatusChanged(this, oldStatus);
-    }
-
-    /**
-     * Reverts this item state to its initial status (i.e. removing any transient
-     * modifications.
-     */
-    void revert() throws ItemStateException {
-        checkIsSessionState();
-
-        switch (getStatus()) {
-            case Status.EXISTING_MODIFIED:
-            case Status.STALE_MODIFIED:
-                // revert state from overlayed
-                merge(overlayedState, false);
-                setStatus(Status.EXISTING);
-                break;
-            case Status.EXISTING_REMOVED:
-                // revert state from overlayed
-                merge(overlayedState, false);
-                setStatus(Status.EXISTING);
-                parent.childStatusChanged(this, Status.EXISTING_REMOVED);
-                break;
-            case Status.NEW:
-                remove();
-                break;
-            case Status.STALE_DESTROYED:
-                // overlayed does not exist any more
-                // cannot call 'remove' on invalid state -> manuall remove
-                setStatus(Status.REMOVED);
-                parent.childStatusChanged(this, Status.STALE_DESTROYED);
-                break;
-            default:
-                // Cannot revert EXISTING, REMOVED, INVALIDATED, MODIFIED states.
-                // State was implicitely reverted
-                log.debug("State with status " + getStatus() + " cannot be reverted.");
-        }
-    }
-
-    /**
-     * Checks if this <code>ItemState</code> is transiently modified, new or stale
-     * modified. and adds itself to the <code>ChangeLog</code>.
-     * If this <code>ItemState</code> has children it will call
-     * {@link #collectStates(ChangeLog, boolean)} recursively.
-     *
-     * @param changeLog the <code>ChangeLog</code> collecting the transient
-     * item states present in a given tree.
-     * @param throwOnStale If the given flag is true, this methods throws
-     * StaleItemStateException if this state is stale.
-     * @throws StaleItemStateException if <code>throwOnStale</code> is true and
-     * this state is stale.
-     */
-    void collectStates(ChangeLog changeLog, boolean throwOnStale) throws StaleItemStateException {
-        checkIsSessionState();
-        if (throwOnStale && Status.isStale(getStatus())) {
-            String msg = "Cannot save changes: " + getId() + " has been modified externally.";
-            log.debug(msg);
-            throw new StaleItemStateException(msg);
-        }
-        // only interested in transient modifications or stale-modified states
-        switch (getStatus()) {
-            case Status.NEW:
-                changeLog.added(this);
-                break;
-            case Status.EXISTING_MODIFIED:
-            case Status.STALE_MODIFIED:
-                changeLog.modified(this);
-                break;
-            case Status.EXISTING_REMOVED:
-                changeLog.deleted(this);
-                break;
-            default:
-                log.debug("Collecting states: Ignored ItemState with status " + getStatus());
-        }
-    }
-
-    /**
+
+    EffectiveNodeType getEffectiveNodeType() throws RepositoryException {
+        try {
+            EffectiveNodeType ent = getNodeTypeRegistry().getEffectiveNodeType(getParent().getNodeTypeNames());
+            return ent;
+        } catch (ItemStateException e) {
+            throw new RepositoryException("Error while accessing Definition ", e);
+        } catch (NodeTypeConflictException e) {
+            throw new RepositoryException("Error while accessing Definition ", e);
+        }
+    }
+
+    NodeTypeRegistry getNodeTypeRegistry() {
+        return ntReg;
+    }

MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 MOV23 UPD40 UPD40 INS40 UPD40 INS40 INS40 INS40 UPD40 MOV44 MOV44 INS31 INS31 INS31 INS31 INS31 UPD43 MOV21 MOV21 INS29 INS83 INS83 INS43 INS42 INS8 INS8 UPD83 MOV43 UPD42 UPD43 MOV43 INS83 INS83 INS83 INS29 UPD83 MOV83 MOV39 UPD42 MOV42 MOV44 UPD43 MOV43 MOV43 INS8 MOV29 INS83 MOV39 UPD42 MOV42 MOV44 INS8 INS43 INS42 INS43 INS8 INS43 INS42 INS8 UPD42 UPD42 UPD43 UPD42 INS65 INS65 UPD42 MOV42 INS41 INS65 INS65 MOV41 INS65 INS65 INS65 UPD65 UPD42 INS41 UPD42 INS25 INS65 INS65 UPD65 MOV65 MOV65 UPD42 MOV21 MOV60 INS25 INS60 INS25 INS21 INS60 INS25 UPD43 UPD42 INS25 MOV21 MOV21 INS42 INS42 INS54 INS42 INS41 UPD66 UPD42 UPD42 UPD42 UPD66 MOV66 UPD66 MOV66 INS66 INS66 UPD66 INS65 INS66 INS32 INS66 UPD66 INS66 INS65 INS66 INS66 UPD66 MOV66 UPD66 MOV66 INS65 INS66 INS66 UPD66 MOV66 UPD66 MOV66 INS65 INS66 INS42 UPD42 INS32 UPD42 INS27 INS8 MOV25 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 INS42 UPD42 UPD42 INS43 INS27 INS8 INS8 MOV43 INS59 INS32 INS8 INS8 MOV32 INS39 INS59 MOV27 INS8 INS25 UPD42 UPD42 MOV27 INS8 INS8 INS12 INS12 INS42 UPD42 INS40 INS68 INS66 INS32 INS42 INS68 INS66 INS68 INS66 INS32 INS68 UPD66 MOV66 INS32 INS42 UPD42 UPD42 INS22 INS33 INS21 MOV27 UPD42 MOV42 UPD42 INS42 INS33 MOV21 INS21 INS42 INS42 INS21 INS21 UPD42 UPD42 INS42 INS32 INS27 MOV21 INS42 INS8 MOV21 MOV60 INS41 INS44 MOV8 INS44 INS8 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS32 MOV42 INS52 INS42 INS32 INS7 INS7 INS7 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS40 INS21 UPD43 INS42 MOV43 INS42 INS43 INS42 MOV53 UPD42 MOV42 UPD42 MOV8 INS42 INS42 UPD42 INS40 INS42 INS22 INS42 INS32 INS42 INS32 MOV32 INS22 INS42 INS52 UPD42 UPD42 INS32 INS42 INS22 INS42 INS42 INS42 INS11 INS11 UPD42 MOV42 UPD42 MOV42 INS11 INS11 UPD42 UPD42 UPD40 INS52 INS42 INS32 INS42 MOV32 INS45 UPD43 INS45 UPD42 INS32 INS42 INS43 INS32 INS43 INS32 INS43 MOV32 INS43 INS32 INS42 UPD42 UPD42 UPD42 INS42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 DEL66 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL66 DEL66 DEL65 DEL29 DEL65 DEL29 DEL43 DEL42 DEL59 DEL23 DEL66 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL66 DEL66 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL83 DEL65 DEL65 DEL42 DEL65 DEL42 DEL43 DEL42 DEL33 DEL27 DEL40 DEL41 DEL8 DEL25 DEL40 DEL43 DEL42 DEL40 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL52 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL12 DEL54 DEL8 DEL65 DEL42 DEL65 DEL66 DEL39 DEL40 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL41 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL39 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL59 DEL60 DEL42 DEL40 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL31 DEL66 DEL42 DEL67 DEL65 DEL42 DEL42 DEL67 DEL65 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL31 DEL52 DEL25 DEL8 DEL51 DEL8 DEL66 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL44 DEL31 DEL66 DEL66 DEL65 DEL65 DEL29 DEL42 DEL42 DEL32 DEL21 DEL42 DEL8 DEL51 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL42 DEL43 DEL62 DEL42 DEL42 DEL2 DEL11 DEL41 DEL8 DEL25 DEL8 DEL24 DEL33 DEL41 DEL8 DEL31 DEL27 DEL66 DEL43 DEL85 DEL5 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL32 DEL3 DEL32 DEL11 DEL9 DEL42 DEL42 DEL9 DEL32 DEL52 DEL66 DEL66 DEL66 DEL42 DEL42 DEL43 DEL69 DEL39 DEL69 DEL68 DEL65 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL66 DEL66 DEL42 DEL66 DEL66 DEL65 DEL42 DEL66 DEL66 DEL42 DEL42 DEL67 DEL65 DEL66 DEL42 DEL42 DEL67 DEL65 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL29 DEL39 DEL42 DEL32 DEL38 DEL45 DEL14 DEL53 DEL8 DEL25 DEL39 DEL42 DEL32 DEL59 DEL60 DEL42 DEL40 DEL27 DEL40 DEL32 DEL21 DEL8 DEL40 DEL32 DEL21 DEL8 DEL25 DEL21 DEL8 DEL31 DEL66 DEL66 DEL65 DEL29 DEL39 DEL42 DEL42 DEL32 DEL21 DEL32 DEL40 DEL49 DEL40 DEL49 DEL21 DEL10 DEL40 DEL49 DEL9 DEL32 DEL21 DEL42 DEL40 DEL32 DEL21 DEL42 DEL52 DEL40 DEL32 DEL21 DEL10 DEL40 DEL49 DEL42 DEL32 DEL21 DEL10 DEL40 DEL49 DEL42 DEL40 DEL32 DEL21 DEL21 DEL10 DEL49 DEL42 DEL42 DEL45 DEL42 DEL32 DEL45 DEL27 DEL32 DEL21 DEL50 DEL8 DEL31 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL32 DEL40 DEL49 DEL42 DEL42 DEL52 DEL32 DEL21 DEL10 DEL40 DEL49 DEL40 DEL49 DEL42 DEL42 DEL52 DEL32 DEL21 DEL10 DEL40 DEL49 DEL42 DEL42 DEL52 DEL32 DEL21 DEL10 DEL49 DEL42 DEL42 DEL45 DEL42 DEL32 DEL27 DEL32 DEL21 DEL50 DEL8 DEL31 DEL42 DEL52 DEL45 DEL45 DEL27 DEL42 DEL43 DEL42 DEL45 DEL52 DEL27 DEL59 DEL60 DEL42
work in progress

- Restore: pass NodeState(s) and Path instead of NodeId(s)
- LockManager: make sure lockmanager only remembers workspace states
- LockManager: make sure operations are executed using workspace states
- LockManager: improve isLocked/getLock/checkIsLocked and respect locks that
have been accessed before.
- VersionManager: make sure operations are executed using workspace states
- VersionManager: add checkIsCheckedOut
- VersionManager: force manager to have a WorkspaceManager
- NodeReferences:
  > make interface package protected
  > clarify method naming
  > add implementation to WorkspaceItemStateFactory
  > add NodeReferences field to NodeState
  > TO_IMPROVE: references are currently always retrieve from the SPI.
- ItemStateManager + NodeReferences
  > rename interfaces methods
  > change method signature to take NodeState instead of NodeId
  > 'getReferences' returns the property states directly

- remove some JR DIFFs. 

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@432234 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.state.NodeReferences;
-            if (itemStateMgr.hasNodeReferences(getNodeId())) {
-                NodeReferences refs = itemStateMgr.getNodeReferences(getNodeId());
-                // refs.getReferences() returns a list of Property states
-                Collection refStates = refs.getReferences();
+            if (itemStateMgr.hasReferingStates(getNodeState())) {
+                Collection refStates = itemStateMgr.getReferingStates(getNodeState());
-            throw new RepositoryException("Incompatible Version object :" + version);
+            throw new RepositoryException("Incompatible Version object: " + version.getPath());
-        checkIsWritable();
-        checkIsVersionable();
-        checkIsLocked();
-        restore(getNodeId(), version, removeExisting);
+        restore(this, null, version, removeExisting);
+
-            // node at 'relPath' exists -> call restore on that node
+            // node at 'relPath' exists -> call restore on the target Node
-            NodeId nId;
-                // If the would-be parent of the location relPath is actually a
-                // property, or if a node type restriction would be violated,
-                // then a ConstraintViolationException is thrown.
-                        NodeId parentId = ((NodeImpl)parent).getNodeId();
-                        nId = session.getIdFactory().createNodeId(parentId, relQPath);
+                        NodeImpl parentNode = ((NodeImpl)parent);
+                        // call the restore
+                        restore(parentNode, relQPath, version, removeExisting);
+                    // the item at parentParentPath is Property
-            restore(nId, version, removeExisting);
+     * @see Node#restoreByLabel(String, boolean)
+     */
+    public void restoreByLabel(String versionLabel, boolean removeExisting) throws VersionException, ItemExistsException, UnsupportedRepositoryOperationException, LockException, InvalidItemStateException, RepositoryException {
+        checkSupportedOption(Repository.OPTION_VERSIONING_SUPPORTED);
+        checkSessionHasPendingChanges();
+
+        // check for version-enabled and lock are performed with subsequent calls.
+        Version v = getVersionHistory().getVersionByLabel(versionLabel);
+        if (v == null) {
+            throw new VersionException("No version for label " + versionLabel + " found.");
+        }
+        restore(this, null, v, removeExisting);
+    }
+
+    /**
-     * @param nodeId
+     * @param targetNode
+     * @param relQPath
-    private void restore(NodeId nodeId, Version version, boolean removeExisting) throws PathNotFoundException, ItemExistsException, VersionException, ConstraintViolationException, UnsupportedRepositoryOperationException, LockException, InvalidItemStateException, RepositoryException {
-        if (version instanceof VersionImpl) {
-            NodeId versionId = ((NodeImpl)version).getNodeId();
-            session.getVersionManager().restore(nodeId, versionId, removeExisting);
-        } else {
-            throw new RepositoryException("Unexpected error: Failed to retrieve a valid ID for the given version " + version.getPath());
-        }
-    }
+    private void restore(NodeImpl targetNode, Path relQPath, Version version, boolean removeExisting) throws PathNotFoundException, ItemExistsException, VersionException, ConstraintViolationException, UnsupportedRepositoryOperationException, LockException, InvalidItemStateException, RepositoryException {
+        targetNode.checkIsWritable();
+        targetNode.checkIsLocked();
-    /**
-     * @see Node#restoreByLabel(String, boolean)
-     */
-    public void restoreByLabel(String versionLabel, boolean removeExisting) throws VersionException, ItemExistsException, UnsupportedRepositoryOperationException, LockException, InvalidItemStateException, RepositoryException {
-        checkSupportedOption(Repository.OPTION_VERSIONING_SUPPORTED);
-        checkSessionHasPendingChanges();
-        // check for version-enabled and lock are performed with subsequent calls.
-        Version v = getVersionHistory().getVersionByLabel(versionLabel);
-        if (v == null) {
-            throw new VersionException("No version for label " + versionLabel + " found.");
+
+        if (relQPath == null) {
+            /* restore target already exists. */
+            // target must be versionable
+            targetNode.checkIsVersionable();
+
+            VersionHistory vH = targetNode.getVersionHistory();
+            // version must be a version of the target node
+            if (!vH.isSame(version.getContainingHistory())) {
+                throw new VersionException("Version " + version + " does not correspond to the restore target.");
+            }
+            // version must not be the root version
+            if (vH.getRootVersion().isSame(version)) {
+                throw new VersionException("Attempt to restore root version.");
+            }
+        } else {
+            /* If no node exists at relPath then a VersionException is thrown if
+               the parent node is not checked out. */
+            if (!targetNode.isCheckedOut()) {
+                throw new VersionException("Parent " + targetNode.safeGetJCRPath()
+                    + " for non-existing restore target '"
+                    + LogUtil.safeGetJCRPath(relQPath, session.getNamespaceResolver())
+                    + "' must be checked out.");
+            }
+            // NOTE: check for nodetype constraint violation is left to the 'server'
-        restore(getNodeId(), v, removeExisting);
+
+        if (version instanceof VersionImpl) {
+            NodeState versionState = ((NodeImpl)version).getNodeState();
+            session.getVersionManager().restore(targetNode.getNodeState(), relQPath, versionState, removeExisting);
+        } else {
+            throw new RepositoryException("Incompatible Version object: " + version.getPath());
+        }

MOV31 INS44 INS65 UPD43 UPD42 INS43 INS42 INS21 INS21 INS25 UPD42 INS42 UPD42 INS42 INS32 INS32 INS27 INS8 INS8 INS52 INS33 INS52 INS33 INS42 INS42 INS42 INS42 INS42 INS33 INS21 INS60 INS25 INS25 INS25 INS32 INS43 INS59 INS38 INS8 INS32 INS8 INS38 INS8 UPD43 UPD42 INS42 INS42 INS42 INS42 INS32 INS32 INS53 INS32 INS42 INS42 INS53 INS32 INS53 UPD42 UPD42 INS32 INS42 UPD42 UPD42 MOV43 UPD45 INS32 INS42 INS42 INS42 INS42 INS32 INS14 INS42 INS42 INS14 INS42 INS42 INS14 UPD42 UPD42 MOV42 INS42 UPD45 UPD42 INS42 INS42 INS42 INS42 INS43 INS27 INS43 INS45 INS43 INS27 UPD42 INS42 INS45 INS42 INS45 INS42 INS42 INS45 INS32 INS45 INS32 INS45 UPD42 INS42 INS42 INS42 INS42 INS42 INS32 UPD43 INS32 INS42 INS42 UPD42 UPD42 MOV36 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 DEL40 DEL26 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL32 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL32 DEL42 DEL32 DEL32 DEL7 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32
- Workspace operations (clone, copy, importXML, etc) [work in progress...]
- typos in comments etc

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@157944 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.state.NodeReferences;
+import org.apache.jackrabbit.core.state.NodeReferencesId;
-import org.apache.jackrabbit.core.xml.ImportHandler;
-import org.apache.jackrabbit.core.version.VersionSelector;
-import org.apache.jackrabbit.core.version.VersionImpl;
+import org.apache.jackrabbit.core.version.VersionImpl;
+import org.apache.jackrabbit.core.version.VersionSelector;
+import org.apache.jackrabbit.core.xml.ImportHandler;
+import javax.jcr.PropertyType;
+import javax.jcr.ReferentialIntegrityException;
+import java.util.HashMap;
-import java.util.HashMap;
+    // flags used by private internalCopy() method
+    private static final int COPY = 0;
+    private static final int CLONE = 1;
+    private static final int CLONE_REMOVE_EXISTING = 2;
+
+    /**
+     * option for <code>{@link #checkAddNode}</code> and
+     * <code>{@link #checkRemoveNode}</code> methods:<p/>
+     * check access rights
+     */
+    public static final int CHECK_ACCESS = 1;
+    /**
+     * option for <code>{@link #checkAddNode}</code> and
+     * <code>{@link #checkRemoveNode}</code> methods:<p/>
+     * check lock status
+     */
+    public static final int CHECK_LOCK = 2;
+    /**
+     * option for <code>{@link #checkAddNode}</code> and
+     * <code>{@link #checkRemoveNode}</code> methods:<p/>
+     * check checked-out status
+     */
+    public static final int CHECK_VERSIONING = 4;
+    /**
+     * option for <code>{@link #checkAddNode}</code> and
+     * <code>{@link #checkRemoveNode}</code> methods:<p/>
+     * check constraints defined in node type
+     */
+    public static final int CHECK_CONSTRAINTS = 16;
+    /**
+     * option for <code>{@link #checkRemoveNode}</code> method:<p/>
+     * check that target node is not being referenced
+     */
+    public static final int CHECK_REFERENCES = 8;
+
-     * represented by <i>this</i> <code>Workspace</code> instance.
+     * represented by <i>this</i> <code>WorkspaceImpl</code> instance.
-     * Dumps the state of this <code>Workspace</code> instance
+     * Dumps the state of this <code>WorkspaceImpl</code> instance
-        //persistentStateMgr.dump(ps);
+        stateMgr.dump(ps);
-     * @param parentId
+     * Checks whether the given node state satisfies the constraints implied by
+     * its primary and mixin node types. The following validations/checks are
+     * performed:
+     * <ul>
+     * <li>check if its node type satisfies the 'required node types' constraint
+     * specified in its definition</li>
+     * <li>check if all 'mandatory' child items exist</li>
+     * <li>for every property: check if the property value satisfies the
+     * value constraints specified in the property's definition</li>
+     * </ul>
+     *
+     * @param nodeState node state to be validated
+     * @throws ConstraintViolationException if any of the validations fail
+     * @throws RepositoryException          if another error occurs
+     */
+    public void validate(NodeState nodeState)
+            throws ConstraintViolationException, RepositoryException {
+        // effective node type (primary type incl. mixins)
+        EffectiveNodeType ent = getEffectiveNodeType(nodeState);
+        NodeTypeRegistry ntReg = rep.getNodeTypeRegistry();
+        ChildNodeDef def = ntReg.getNodeDef(nodeState.getDefinitionId());
+
+        // check if primary type satisfies the 'required node types' constraint
+        QName[] requiredPrimaryTypes = def.getRequiredPrimaryTypes();
+        for (int i = 0; i < requiredPrimaryTypes.length; i++) {
+            if (!ent.includesNodeType(requiredPrimaryTypes[i])) {
+                String msg = hierMgr.safeGetJCRPath(nodeState.getId())
+                        + ": missing required primary type "
+                        + requiredPrimaryTypes[i];
+                log.debug(msg);
+                throw new ConstraintViolationException(msg);
+            }
+        }
+        // mandatory properties
+        PropDef[] pda = ent.getMandatoryPropDefs();
+        for (int i = 0; i < pda.length; i++) {
+            PropDef pd = pda[i];
+            if (!nodeState.hasPropertyEntry(pd.getName())) {
+                String msg = hierMgr.safeGetJCRPath(nodeState.getId())
+                        + ": mandatory property " + pd.getName()
+                        + " does not exist";
+                log.debug(msg);
+                throw new ConstraintViolationException(msg);
+            }
+        }
+        // mandatory child nodes
+        ChildNodeDef[] cnda = ent.getMandatoryNodeDefs();
+        for (int i = 0; i < cnda.length; i++) {
+            ChildNodeDef cnd = cnda[i];
+            if (!nodeState.hasChildNodeEntry(cnd.getName())) {
+                String msg = hierMgr.safeGetJCRPath(nodeState.getId())
+                        + ": mandatory child node " + cnd.getName()
+                        + " does not exist";
+                log.debug(msg);
+                throw new ConstraintViolationException(msg);
+            }
+        }
+    }
+
+    /**
+     * Checks whether the given property state satisfies the constraints
+     * implied by its definition. The following validations/checks are
+     * performed:
+     * <ul>
+     * <li>check if the type of the property values does comply with the
+     * requiredType specified in the property's definition</li>
+     * <li>check if the property values satisfy the value constraints
+     * specified in the property's definition</li>
+     * </ul>
+     *
+     * @param propState property state to be validated
+     * @throws ConstraintViolationException if any of the validations fail
+     * @throws RepositoryException          if another error occurs
+     */
+    public void validate(PropertyState propState)
+            throws ConstraintViolationException, RepositoryException {
+        NodeTypeRegistry ntReg = rep.getNodeTypeRegistry();
+        PropDef def = ntReg.getPropDef(propState.getDefinitionId());
+        InternalValue[] values = propState.getValues();
+        int type = PropertyType.UNDEFINED;
+        for (int i = 0; i < values.length; i++) {
+            if (type == PropertyType.UNDEFINED) {
+                type = values[i].getType();
+            } else if (type != values[i].getType()) {
+                throw new ConstraintViolationException(hierMgr.safeGetJCRPath(propState.getId())
+                        + ": inconsistent value types");
+            }
+            if (def.getRequiredType() != PropertyType.UNDEFINED
+                    && def.getRequiredType() != type) {
+                throw new ConstraintViolationException(hierMgr.safeGetJCRPath(propState.getId())
+                        + ": requiredType constraint is not satisfied");
+            }
+        }
+        EffectiveNodeType.checkSetPropertyValueConstraints(def, values);
+    }
+
+    /**
+     * Checks if adding if adding a child node called <code>nodeName</code> of
+     * node type <code>nodeTypeName</code> to the given parent node is allowed
+     * in the current context.
+     *
+     * @param parentState
+     * @param options      bit-wise OR'ed flags specifying the checks that should be
+     *                     performed; any combination of the following constants:
+     *                     <ul>
+     *                     <li><code>{@link #CHECK_ACCESS}</code>: make sure
+     *                     current session is granted read & write access on
+     *                     parent node</li>
+     *                     <li><code>{@link #CHECK_LOCK}</code>: make sure
+     *                     there's no foreign lock on parent node</li>
+     *                     <li><code>{@link #CHECK_VERSIONING}</code>: make sure
+     *                     parent node is checked-out</li>
+     *                     <li><code>{@link #CHECK_CONSTRAINTS}</code>:
+     *                     make sure no node type constraints would be violated</li>
+     *                     <li><code>{@link #CHECK_REFERENCES}</code></li>
+     *                     </ul>
+     * @throws VersionException
+     * @throws LockException
-    public void checkAddNode(NodeId parentId, QName nodeName, QName nodeTypeName)
+    public void checkAddNode(NodeState parentState, QName nodeName,
+                             QName nodeTypeName, int options)
-            ItemNotFoundException, ItemExistsException, RepositoryException {
+            VersionException, LockException, ItemNotFoundException,
+            ItemExistsException, RepositoryException {
-        NodeState parentState = getNodeState(parentId);
+        Path parentPath = hierMgr.getPath(parentState.getId());
-        // 1. access rights
+        // 1. locking
-        AccessManager accessMgr = session.getAccessManager();
-        if (!accessMgr.isGranted(parentId, AccessManager.READ)) {
-            throw new ItemNotFoundException(hierMgr.safeGetJCRPath(parentId));
-        }
-        if (!accessMgr.isGranted(parentId, AccessManager.WRITE)) {
-            throw new AccessDeniedException(hierMgr.safeGetJCRPath(parentId)
-                    + ": not allowed to add child node");
+        if ((options & CHECK_LOCK) == CHECK_LOCK) {
+            // make sure there's no foreign lock on parent node
+            getLockManager().checkLock(parentPath, session);
-        // 2. check node type constraints
+        // 2. versioning status
-        NodeTypeRegistry ntReg = rep.getNodeTypeRegistry();
-        ChildNodeDef parentDef = ntReg.getNodeDef(parentState.getDefinitionId());
-        if (parentDef.isProtected()) {
-            throw new ConstraintViolationException(hierMgr.safeGetJCRPath(parentId)
-                    + ": cannot add child node to protected parent node");
+        if ((options & CHECK_VERSIONING) == CHECK_VERSIONING) {
+            // make sure parent node is checked-out
+            verifyCheckedOut(parentPath);
-        EffectiveNodeType entParent = getEffectiveNodeType(parentState);
-        entParent.checkAddNodeConstraints(nodeName, nodeTypeName);
-        ChildNodeDef newNodeDef =
-                findApplicableDefinition(nodeName, nodeTypeName, parentState);
-        // 3. check for name collisions
+        // 3. access rights
-        if (parentState.hasPropertyEntry(nodeName)) {
-            // there's already a property with that name
-            throw new ItemExistsException("cannot add child node '"
-                    + nodeName.getLocalName() + "' to "
-                    + hierMgr.safeGetJCRPath(parentId)
-                    + ": colliding with same-named existing property");
-        }
-        if (parentState.hasChildNodeEntry(nodeName)) {
-            // there's already a node with that name...
-
-            // get definition of existing conflicting node
-            NodeState.ChildNodeEntry entry = parentState.getChildNodeEntry(nodeName, 1);
-            NodeState conflictingState;
-            NodeId conflictingId = new NodeId(entry.getUUID());
-            try {
-                conflictingState = (NodeState) stateMgr.getItemState(conflictingId);
-            } catch (ItemStateException ise) {
-                String msg = "internal error: failed to retrieve state of "
-                        + hierMgr.safeGetJCRPath(conflictingId);
-                log.debug(msg);
-                throw new RepositoryException(msg, ise);
+        if ((options & CHECK_ACCESS) == CHECK_ACCESS) {
+            AccessManager accessMgr = session.getAccessManager();
+            // make sure current session is granted read access on parent node
+            if (!accessMgr.isGranted(parentState.getId(), AccessManager.READ)) {
+                throw new ItemNotFoundException(hierMgr.safeGetJCRPath(parentState.getId()));
-            ChildNodeDef conflictingTargetDef =
-                    ntReg.getNodeDef(conflictingState.getDefinitionId());
-            // check same-name sibling setting of both target and existing node
-            if (!conflictingTargetDef.allowSameNameSibs()
-                    || !newNodeDef.allowSameNameSibs()) {
+            // make sure current session is granted write access on parent node
+            if (!accessMgr.isGranted(parentState.getId(), AccessManager.WRITE)) {
+                throw new AccessDeniedException(hierMgr.safeGetJCRPath(parentState.getId())
+                        + ": not allowed to add child node");
+            }
+        }
+
+        // 4. node type constraints
+
+        if ((options & CHECK_CONSTRAINTS) == CHECK_CONSTRAINTS) {
+            NodeTypeRegistry ntReg = rep.getNodeTypeRegistry();
+            ChildNodeDef parentDef = ntReg.getNodeDef(parentState.getDefinitionId());
+            // make sure parent node is not protected
+            if (parentDef.isProtected()) {
+                throw new ConstraintViolationException(hierMgr.safeGetJCRPath(parentState.getId())
+                        + ": cannot add child node to protected parent node");
+            }
+            // make sure there's an applicable definition for new child node
+            EffectiveNodeType entParent = getEffectiveNodeType(parentState);
+            entParent.checkAddNodeConstraints(nodeName, nodeTypeName);
+            ChildNodeDef newNodeDef =
+                    findApplicableDefinition(nodeName, nodeTypeName, parentState);
+
+            // check for name collisions
+            if (parentState.hasPropertyEntry(nodeName)) {
+                // there's already a property with that name
-                        + hierMgr.safeGetJCRPath(parentId)
-                        + ": colliding with same-named existing node");
+                        + hierMgr.safeGetJCRPath(parentState.getId())
+                        + ": colliding with same-named existing property");
+            }
+            if (parentState.hasChildNodeEntry(nodeName)) {
+                // there's already a node with that name...
+
+                // get definition of existing conflicting node
+                NodeState.ChildNodeEntry entry = parentState.getChildNodeEntry(nodeName, 1);
+                NodeState conflictingState;
+                NodeId conflictingId = new NodeId(entry.getUUID());
+                try {
+                    conflictingState = (NodeState) stateMgr.getItemState(conflictingId);
+                } catch (ItemStateException ise) {
+                    String msg = "internal error: failed to retrieve state of "
+                            + hierMgr.safeGetJCRPath(conflictingId);
+                    log.debug(msg);
+                    throw new RepositoryException(msg, ise);
+                }
+                ChildNodeDef conflictingTargetDef =
+                        ntReg.getNodeDef(conflictingState.getDefinitionId());
+                // check same-name sibling setting of both target and existing node
+                if (!conflictingTargetDef.allowSameNameSibs()
+                        || !newNodeDef.allowSameNameSibs()) {
+                    throw new ItemExistsException("cannot add child node '"
+                            + nodeName.getLocalName() + "' to "
+                            + hierMgr.safeGetJCRPath(parentState.getId())
+                            + ": colliding with same-named existing node");
+                }
-     * @param parentPath
-     * @param nodeName
-     * @param nodeTypeName
+     * Checks if removing the given target node is allowed in the current
+     * context.
+     *
+     * @param targetState
+     * @param options     bit-wise OR'ed flags specifying the checks that should be
+     *                    performed; any combination of the following constants:
+     *                    <ul>
+     *                    <li><code>{@link #CHECK_ACCESS}</code>: make sure
+     *                    current session is granted read access on parent
+     *                    and remove privilege on target node</li>
+     *                    <li><code>{@link #CHECK_LOCK}</code>: make sure
+     *                    there's no foreign lock on parent node</li>
+     *                    <li><code>{@link #CHECK_VERSIONING}</code>: make sure
+     *                    parent node is checked-out</li>
+     *                    <li><code>{@link #CHECK_CONSTRAINTS}</code>:
+     *                    make sure no node type constraints would be violated</li>
+     *                    <li><code>{@link #CHECK_REFERENCES}</code>:
+     *                    make sure no references exist on target node</li>
+     *                    </ul>
-     * @throws PathNotFoundException
-     * @throws ItemExistsException
-     * @throws RepositoryException
-     */
-    public void checkAddNode(Path parentPath, QName nodeName, QName nodeTypeName)
-            throws ConstraintViolationException, AccessDeniedException,
-            PathNotFoundException, ItemExistsException, RepositoryException {
-        NodeState parentState = getNodeState(parentPath);
-        checkAddNode((NodeId) parentState.getId(), nodeName, nodeTypeName);
-    }
-
-    /**
-     * @param nodeId
-     * @throws ConstraintViolationException
-     * @throws AccessDeniedException
+     * @throws VersionException
+     * @throws LockException
+     * @throws ReferentialIntegrityException
-    public void checkRemoveNode(NodeId nodeId)
+    public void checkRemoveNode(NodeState targetState, int options)
-            ItemNotFoundException, RepositoryException {
+            VersionException, LockException, ItemNotFoundException,
+            ReferentialIntegrityException, RepositoryException {
-        NodeState targetState = getNodeState(nodeId);
+        NodeId targetId = (NodeId) targetState.getId();
+        Path parentPath = hierMgr.getPath(parentId);
-        // 1. access rights
+        // 1. locking
-        AccessManager accessMgr = session.getAccessManager();
-        try {
-            if (!accessMgr.isGranted(targetState.getId(), AccessManager.READ)) {
-                throw new PathNotFoundException(hierMgr.safeGetJCRPath(nodeId));
+        if ((options & CHECK_LOCK) == CHECK_LOCK) {
+            // make sure there's no foreign lock on parent node
+            getLockManager().checkLock(parentPath, session);
+        }
+
+        // 2. versioning status
+
+        if ((options & CHECK_VERSIONING) == CHECK_VERSIONING) {
+            // make sure parent node is checked-out
+            verifyCheckedOut(parentPath);
+        }
+
+        // 3. access rights
+
+        if ((options & CHECK_ACCESS) == CHECK_ACCESS) {
+            AccessManager accessMgr = session.getAccessManager();
+            try {
+                // make sure current session is granted read access on parent node
+                if (!accessMgr.isGranted(targetId, AccessManager.READ)) {
+                    throw new PathNotFoundException(hierMgr.safeGetJCRPath(targetId));
+                }
+                // make sure current session is allowed to remove target node
+                if (!accessMgr.isGranted(targetId, AccessManager.REMOVE)) {
+                    throw new AccessDeniedException(hierMgr.safeGetJCRPath(targetId)
+                            + ": not allowed to remove node");
+                }
+            } catch (ItemNotFoundException infe) {
+                String msg = "internal error: failed to check access rights for "
+                        + hierMgr.safeGetJCRPath(targetId);
+                log.debug(msg);
+                throw new RepositoryException(msg, infe);
-            if (!accessMgr.isGranted(targetState.getId(), AccessManager.REMOVE)) {
-                throw new AccessDeniedException(hierMgr.safeGetJCRPath(parentId)
-                        + ": not allowed to remove node");
+        }
+
+        // 4. node type constraints
+
+        if ((options & CHECK_CONSTRAINTS) == CHECK_CONSTRAINTS) {
+            NodeTypeRegistry ntReg = rep.getNodeTypeRegistry();
+            ChildNodeDef parentDef = ntReg.getNodeDef(parentState.getDefinitionId());
+            if (parentDef.isProtected()) {
+                throw new ConstraintViolationException(hierMgr.safeGetJCRPath(parentId)
+                        + ": cannot remove child node of protected parent node");
-        } catch (ItemNotFoundException infe) {
-            String msg = "internal error: failed to check access rights for "
-                    + hierMgr.safeGetJCRPath(nodeId);
-            log.debug(msg);
-            throw new RepositoryException(msg, infe);
+            ChildNodeDef targetDef = ntReg.getNodeDef(targetState.getDefinitionId());
+            if (targetDef.isMandatory()) {
+                throw new ConstraintViolationException(hierMgr.safeGetJCRPath(targetId)
+                        + ": cannot remove mandatory node");
+            }
+            if (targetDef.isProtected()) {
+                throw new ConstraintViolationException(hierMgr.safeGetJCRPath(targetId)
+                        + ": cannot remove protected node");
+            }
-        // 2. check node type constraints
+        // 5. referential integrity
-        NodeTypeRegistry ntReg = rep.getNodeTypeRegistry();
-        ChildNodeDef parentDef = ntReg.getNodeDef(parentState.getDefinitionId());
-        if (parentDef.isProtected()) {
-            throw new ConstraintViolationException(hierMgr.safeGetJCRPath(parentId)
-                    + ": cannot remove child node of protected parent node");
+        if ((options & CHECK_REFERENCES) == CHECK_REFERENCES) {
+            EffectiveNodeType ent = getEffectiveNodeType(targetState);
+            if (ent.includesNodeType(MIX_REFERENCEABLE)) {
+                try {
+                    NodeReferencesId refsId = new NodeReferencesId(targetState.getUUID());
+                    NodeReferences refs = stateMgr.getNodeReferences(refsId);
+                    if (refs.hasReferences()) {
+                        throw new ReferentialIntegrityException(hierMgr.safeGetJCRPath(targetId)
+                                + ": cannot remove node with references");
+                    }
+                } catch (ItemStateException ise) {
+                    String msg = "internal error: failed to check references on "
+                            + hierMgr.safeGetJCRPath(targetId);
+                    log.error(msg, ise);
+                    throw new RepositoryException(msg, ise);
+                }
+            }
-        ChildNodeDef targetDef = ntReg.getNodeDef(targetState.getDefinitionId());
-        if (targetDef.isMandatory()) {
-            throw new ConstraintViolationException(hierMgr.safeGetJCRPath(nodeId)
-                    + ": cannot remove mandatory node");
-        }
-        if (targetDef.isProtected()) {
-            throw new ConstraintViolationException(hierMgr.safeGetJCRPath(nodeId)
-                    + ": cannot remove protected node");
-        }
-    }
-
-    /**
-     * @param nodePath
-     * @throws ConstraintViolationException
-     * @throws AccessDeniedException
-     * @throws PathNotFoundException
-     * @throws RepositoryException
-     */
-    public void checkRemoveNode(Path nodePath)
-            throws ConstraintViolationException, AccessDeniedException,
-            PathNotFoundException, RepositoryException {
-        NodeState targetState = getNodeState(nodePath);
-        checkRemoveNode((NodeId) targetState.getId());
+    /**
+     * Recursively removes the specified node state including its properties and
+     * child nodes.
+     * <p/>
+     * <b>Precondition:</b> the state manager of this workspace needs to be in
+     * edit mode.
+     *
+     * @param targetState
+     * @param parentUUID
+     * @throws RepositoryException if an error occurs
+     */
+    private void removeNodeState(NodeState targetState, String parentUUID)
+            throws RepositoryException {
+
+        // check if this node state would be orphaned after unlinking it from parent
+        ArrayList parentUUIDs = new ArrayList(targetState.getParentUUIDs());
+        parentUUIDs.remove(parentUUID);
+        boolean orphaned = parentUUIDs.isEmpty();
+
+        if (orphaned) {
+            // remove child nodes
+            // use temp array to avoid ConcurrentModificationException
+            ArrayList tmp = new ArrayList(targetState.getChildNodeEntries());
+            // remove from tail to avoid problems with same-name siblings
+            for (int i = tmp.size() - 1; i >= 0; i--) {
+                NodeState.ChildNodeEntry entry = (NodeState.ChildNodeEntry) tmp.get(i);
+                NodeId nodeId = new NodeId(entry.getUUID());
+                try {
+                    NodeState nodeState = (NodeState) stateMgr.getItemState(nodeId);
+                    // check if existing can be removed
+                    checkRemoveNode(nodeState, CHECK_ACCESS | CHECK_LOCK
+                            | CHECK_VERSIONING);
+                    // remove child node (recursive)
+                    removeNodeState(nodeState, targetState.getUUID());
+                } catch (ItemStateException ise) {
+                    String msg = "internal error: failed to retrieve state of "
+                            + nodeId;
+                    log.debug(msg);
+                    throw new RepositoryException(msg, ise);
+                }
+                // remove child node entry
+                targetState.removeChildNodeEntry(entry.getName(), entry.getIndex());
+            }
+
+            // remove properties
+            // use temp array to avoid ConcurrentModificationException
+            tmp = new ArrayList(targetState.getPropertyEntries());
+            // remove from tail to avoid problems with same-name siblings
+            for (int i = tmp.size() - 1; i >= 0; i--) {
+                NodeState.PropertyEntry entry = (NodeState.PropertyEntry) tmp.get(i);
+                PropertyId propId =
+                        new PropertyId(targetState.getUUID(), entry.getName());
+                try {
+                    PropertyState propState = (PropertyState) stateMgr.getItemState(propId);
+                    // remove property entry
+                    targetState.removePropertyEntry(propId.getName());
+                    // destroy property state
+                    stateMgr.destroy(propState);
+                } catch (ItemStateException ise) {
+                    String msg = "internal error: failed to retrieve state of "
+                            + propId;
+                    log.debug(msg);
+                    throw new RepositoryException(msg, ise);
+                }
+            }
+        }
+
+        // now actually do unlink target state from specified parent state
+        // (i.e. remove uuid of parent state from target state's parent list)
+        targetState.removeParentUUID(parentUUID);
+
+        if (orphaned) {
+            // destroy target state
+            stateMgr.destroy(targetState);
+        } else {
+            // store target state
+            stateMgr.store(targetState);
+        }
+    }
+
+    /**
+     * Recursively copies the specified node state including its properties and
+     * child nodes.
+     * <p/>
+     * <b>Precondition:</b> the state manager of <code>this</code> workspace
+     * needs to be in edit mode.
+     *
+     * @param srcState
+     * @param parentUUID
+     * @param srcStateMgr
+     * @param srcAccessMgr
+     * @param flag         one of
+     *                     <ul>
+     *                     <li><code>COPY</code></li>
+     *                     <li><code>CLONE</code></li>
+     *                     <li><code>CLONE_REMOVE_EXISTING</code></li>
+     *                     </ul>
+     * @return a deep copy of the given node state and its children
+     * @throws RepositoryException if an error occurs
+     */
-                                    boolean clone)
+                                    AccessManager srcAccessMgr,
+                                    int flag)
-            if (clone) {
-                uuid = srcState.getUUID();
-            } else {
-                /**
-                 * todo FIXME check mix:referenceable
-                 * make sure that copied reference properties are
-                 * refering to new uuid
-                 */
-                uuid = UUID.randomUUID().toString();	// create new version 4 uuid
+            NodeId id;
+            EffectiveNodeType ent = getEffectiveNodeType(srcState);
+            boolean referenceable = ent.includesNodeType(MIX_REFERENCEABLE);
+            switch (flag) {
+                case COPY:
+                    /**
+                     * todo FIXME check mix:referenceable
+                     * make sure that copied reference properties are
+                     * refering to new uuid
+                     */
+                    uuid = UUID.randomUUID().toString();    // create new version 4 uuid
+                    break;
+                case CLONE:
+                    if (!referenceable) {
+                        // non-referenceable node: always create new uuid
+                        uuid = UUID.randomUUID().toString();    // create new version 4 uuid
+                        break;
+                    }
+                    uuid = srcState.getUUID();
+                    id = new NodeId(uuid);
+                    if (stateMgr.hasItemState(id)) {
+                        // node with this uuid already exists
+                        throw new ItemExistsException(hierMgr.safeGetJCRPath(id));
+                    }
+                    break;
+                case CLONE_REMOVE_EXISTING:
+                    if (!referenceable) {
+                        // non-referenceable node: always create new uuid
+                        uuid = UUID.randomUUID().toString();    // create new version 4 uuid
+                        break;
+                    }
+                    uuid = srcState.getUUID();
+                    id = new NodeId(uuid);
+                    if (stateMgr.hasItemState(id)) {
+                        NodeState existingState = (NodeState) stateMgr.getItemState(id);
+                        // check if existing can be removed
+                        checkRemoveNode(existingState, CHECK_ACCESS | CHECK_LOCK
+                                | CHECK_VERSIONING | CHECK_CONSTRAINTS);
+                        // do remove existing
+                        removeNodeState(existingState, existingState.getParentUUID());
+                    }
+                    break;
+                default:
+                    throw new IllegalArgumentException("unknown flag");
-                NodeState srcChildState =
-                        (NodeState) srcStateMgr.getItemState(new NodeId(entry.getUUID()));
+                NodeId nodeId = new NodeId(entry.getUUID());
+                if (!srcAccessMgr.isGranted(nodeId, AccessManager.READ)) {
+                    continue;
+                }
+                NodeState srcChildState = (NodeState) srcStateMgr.getItemState(nodeId);
-                        srcStateMgr, clone);
-                // persist new child node
+                        srcStateMgr, srcAccessMgr, flag);
+                // store new child node
+                PropertyId propId = new PropertyId(srcState.getUUID(), entry.getName());
+                if (!srcAccessMgr.isGranted(propId, AccessManager.READ)) {
+                    continue;
+                }
-                        (PropertyState) srcStateMgr.getItemState(new PropertyId(srcState.getUUID(), entry.getName()));
+                        (PropertyState) srcStateMgr.getItemState(propId);
-                // persist new property
+                // store new property
+    /**
+     * Copies the specified property state.
+     * <p/>
+     * <b>Precondition:</b> the state manager of this workspace needs to be in
+     * edit mode.
+     *
+     * @param srcState
+     * @param parentUUID
+     * @param propName
+     * @return
+     * @throws RepositoryException
+     */
+    /**
+     * @param srcAbsPath
+     * @param srcWsp
+     * @param destAbsPath
+     * @param flag        one of
+     *                    <ul>
+     *                    <li><code>COPY</code></li>
+     *                    <li><code>CLONE</code></li>
+     *                    <li><code>CLONE_REMOVE_EXISTING</code></li>
+     *                    </ul>
+     * @throws ConstraintViolationException
+     * @throws AccessDeniedException
+     * @throws VersionException
+     * @throws PathNotFoundException
+     * @throws ItemExistsException
+     * @throws LockException
+     * @throws RepositoryException
+     */
-                              boolean clone)
+                              int flag)
-        // make sure destination parent node is checked-out
-        verifyCheckedOut(destParentPath);
+        // 2. check access rights, lock status, node type constraints, etc.
-        // check lock status
-        getLockManager().checkLock(destParentPath, session);
-
-        // 2. check access rights & node type constraints
-
+        checkAddNode(destParentState, destName.getName(),
+                srcState.getNodeTypeName(), CHECK_ACCESS | CHECK_LOCK
+                | CHECK_VERSIONING | CHECK_CONSTRAINTS);
+        // check read access right on source node
+        // use access manager of source workspace/session
+        AccessManager srcAccessMgr =
+                ((SessionImpl) srcWsp.getSession()).getAccessManager();
-            // check read access right on source node
-            if (!session.getAccessManager().isGranted(srcState.getId(), AccessManager.READ)) {
+            if (!srcAccessMgr.isGranted(srcState.getId(), AccessManager.READ)) {
-            String msg = "internal error: failed to check access rights for " + srcAbsPath;
+            String msg = "internal error: failed to check access rights for "
+                    + srcAbsPath;
-        // check node type constraints
-        checkAddNode(destParentPath, destName.getName(), srcState.getNodeTypeName());
-
-                    srcWsp.getItemStateManager(), clone);
+                    srcWsp.getItemStateManager(), srcAccessMgr, flag);
-            internalCopy(srcAbsPath, srcWsp, destAbsPath, true);
+            internalCopy(srcAbsPath, srcWsp, destAbsPath,
+                    removeExisting ? CLONE_REMOVE_EXISTING : CLONE);
-        internalCopy(srcAbsPath, this, destAbsPath, false);
+        internalCopy(srcAbsPath, this, destAbsPath, COPY);
-            internalCopy(srcAbsPath, srcWsp, destAbsPath, false);
+            internalCopy(srcAbsPath, srcWsp, destAbsPath, COPY);
+
-        // make sure both source & destination parent nodes are checked-out
-        verifyCheckedOut(srcParentPath);
-        verifyCheckedOut(destParentPath);
+        // 2. check if target state can be removed from old/added to new parent
-        // check locked-status
-        getLockManager().checkLock(destParentPath, session);
-
-        // 2. check node type constraints & access rights
-
-        checkRemoveNode(srcPath);
-        checkAddNode(destParentPath, destName.getName(), targetState.getNodeTypeName());
+        checkRemoveNode(targetState, CHECK_ACCESS | CHECK_LOCK
+                | CHECK_VERSIONING | CHECK_CONSTRAINTS);
+        checkAddNode(destParentState, destName.getName(),
+                targetState.getNodeTypeName(), CHECK_ACCESS | CHECK_LOCK
+                | CHECK_VERSIONING | CHECK_CONSTRAINTS);
-        for (int i=0; i<versions.length; i++) {
+        for (int i = 0; i < versions.length; i++) {
-                throw new VersionException("Unable to restore. Two ore more versions have same version history.");
+                throw new VersionException("Unable to restore. Two or more versions have same version history.");
-            while (toRestore.size()>0) {
+            while (toRestore.size() > 0) {
-                        for (int i=0; i<restored.length; i++) {
+                        for (int i = 0; i < restored.length; i++) {

MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 MOV31 INS40 INS40 INS40 INS40 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS83 INS39 INS59 MOV29 MOV83 MOV39 UPD42 MOV42 MOV44 MOV43 MOV43 INS8 INS29 INS83 INS39 INS42 INS44 MOV43 MOV43 MOV8 INS44 INS43 INS43 INS8 INS44 INS43 INS43 INS43 MOV60 UPD83 UPD42 INS44 UPD43 INS8 INS29 INS44 INS29 INS29 MOV54 INS42 INS34 INS42 INS34 INS42 INS34 INS65 INS42 INS34 INS65 INS42 INS34 INS65 INS42 INS34 INS65 INS42 INS34 INS65 INS42 INS34 INS21 INS65 UPD65 UPD65 MOV43 UPD42 INS60 INS60 INS60 INS60 INS24 INS60 INS24 INS60 INS24 INS65 INS65 INS65 INS65 INS43 INS42 INS60 INS60 INS60 INS24 INS21 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 UPD42 INS39 INS42 INS42 INS42 INS60 INS25 INS25 INS25 INS25 INS65 UPD65 MOV65 MOV65 MOV65 MOV65 MOV43 UPD42 INS39 INS42 INS42 INS42 INS42 INS60 INS25 INS25 INS25 INS25 INS25 UPD65 UPD65 UPD65 MOV43 INS42 UPD43 UPD42 UPD42 INS60 INS21 INS60 INS25 INS21 INS25 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 UPD39 UPD42 INS65 INS65 INS65 INS65 INS65 MOV65 INS65 INS65 INS65 INS65 MOV65 MOV65 INS65 MOV65 MOV65 INS65 MOV65 UPD39 UPD42 INS60 INS54 MOV54 INS21 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 UPD66 UPD66 INS32 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 UPD42 INS66 UPD42 INS66 UPD42 INS66 INS43 INS59 INS43 INS59 INS43 INS59 INS5 INS59 INS58 INS27 INS37 INS8 INS5 INS59 INS58 INS27 INS37 INS8 INS5 INS59 INS58 INS27 INS37 INS8 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS43 INS59 INS43 INS5 INS59 INS39 INS59 INS58 INS27 INS37 INS8 INS32 INS66 INS66 INS66 UPD42 INS42 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS27 INS8 INS27 INS8 INS27 INS8 INS27 MOV8 INS66 INS66 UPD42 UPD42 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS66 UPD42 UPD42 UPD42 MOV43 INS59 MOV43 INS27 INS8 INS27 INS8 INS27 INS8 INS27 INS8 INS27 INS8 INS66 INS66 INS66 INS66 INS66 UPD42 UPD42 UPD42 INS66 UPD42 INS43 INS59 INS32 INS39 INS59 INS42 INS8 INS32 INS42 INS8 INS8 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS43 INS59 INS8 MOV8 INS32 INS67 INS67 INS67 INS67 INS67 INS67 INS67 INS67 INS67 INS42 INS42 INS42 UPD42 MOV42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS43 INS85 INS42 INS32 INS39 INS59 INS42 INS40 INS42 INS25 INS43 INS85 INS42 INS32 INS39 INS59 INS42 INS40 INS42 INS60 INS25 INS43 INS85 INS42 INS32 INS39 INS59 INS42 INS40 INS42 INS60 INS25 INS42 INS42 INS32 INS42 UPD42 INS32 INS43 INS85 INS42 INS32 INS42 INS40 INS39 INS59 INS42 INS40 INS42 INS25 INS25 UPD42 MOV42 INS42 INS42 INS42 INS67 INS67 INS67 INS67 INS67 INS42 INS42 INS32 INS36 INS42 INS21 INS36 INS42 INS21 INS36 INS42 MOV60 INS25 INS25 INS36 INS42 INS67 INS67 INS67 INS67 INS67 INS42 MOV11 UPD42 INS36 INS42 INS21 INS36 INS42 INS21 INS36 INS42 MOV60 MOV54 INS36 INS42 MOV60 MOV60 MOV25 MOV60 MOV25 MOV25 INS36 INS42 INS60 INS25 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS32 INS60 INS24 INS21 INS24 INS42 INS42 INS42 INS21 INS21 INS60 INS60 INS60 INS50 UPD42 INS27 INS42 INS42 INS32 MOV21 MOV60 INS21 INS42 UPD42 MOV42 UPD42 MOV42 INS27 UPD42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 MOV42 INS42 INS42 INS42 INS34 INS38 INS8 INS42 INS42 INS42 INS42 INS34 INS43 INS59 INS38 INS8 INS42 INS42 INS42 INS42 INS34 INS43 INS59 INS38 INS8 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS34 INS27 INS8 INS25 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS27 INS32 INS27 INS32 INS27 INS38 INS8 INS38 INS8 INS27 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS27 INS32 INS27 INS32 INS27 INS27 INS27 INS43 INS59 INS32 INS8 INS43 INS32 INS42 INS42 INS43 INS59 INS58 INS27 INS37 INS8 INS7 INS58 INS27 INS37 INS8 INS32 INS32 MOV43 INS59 INS43 INS59 INS39 INS59 INS42 INS49 INS21 INS10 INS49 MOV25 MOV21 INS21 INS25 INS10 INS49 INS25 INS21 INS21 INS25 INS10 INS49 INS53 INS42 INS42 INS42 INS42 INS36 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS60 INS21 INS53 INS42 INS42 INS2 INS32 INS60 INS21 INS53 INS42 INS42 INS2 INS32 INS60 INS21 INS53 UPD42 MOV42 UPD42 MOV42 INS42 INS40 INS21 INS27 INS8 INS27 INS27 INS53 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS53 INS32 INS53 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS54 INS42 INS42 INS42 INS42 INS42 INS14 INS39 INS59 INS42 INS34 INS42 INS60 MOV60 INS54 INS21 INS42 INS14 INS39 INS59 INS42 INS34 INS42 INS60 MOV60 INS54 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS7 INS42 INS38 INS7 INS32 INS8 INS42 INS38 INS8 INS7 INS7 INS32 INS8 INS14 INS60 INS25 INS60 INS25 INS60 INS11 INS42 INS42 INS42 INS42 INS16 INS42 INS42 INS42 INS2 INS43 INS59 INS32 INS14 INS42 INS42 INS42 INS42 INS32 INS43 INS59 INS32 INS14 INS42 INS42 INS42 INS42 INS32 MOV43 INS59 INS32 INS14 INS7 INS42 INS32 INS53 INS32 INS40 INS32 INS42 INS14 INS42 INS42 INS42 MOV32 INS40 INS14 INS42 INS42 INS32 INS40 INS14 INS42 INS42 INS8 INS12 INS43 INS32 INS42 INS27 INS43 INS59 MOV43 INS8 INS12 INS32 INS43 INS32 INS42 INS27 INS43 INS59 UPD43 INS8 INS12 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS10 INS42 INS14 INS42 INS42 INS42 INS53 INS42 INS21 INS10 INS42 INS32 INS42 INS14 INS42 INS42 INS42 INS60 INS21 INS21 INS43 INS45 INS43 INS59 INS38 INS8 INS43 INS59 INS43 INS43 INS38 INS8 INS43 INS59 INS43 INS32 UPD42 MOV42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 MOV43 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS32 INS2 INS42 INS14 INS42 INS42 INS42 INS42 MOV43 INS27 INS42 INS42 MOV43 INS32 INS42 INS42 MOV43 INS27 INS43 MOV43 INS43 INS43 INS43 INS60 INS60 INS25 INS44 INS8 INS42 INS42 INS42 INS32 INS34 INS40 INS42 INS11 UPD42 MOV14 INS60 INS21 INS21 INS44 INS8 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS32 INS34 INS40 INS42 INS11 UPD42 INS42 INS14 INS60 MOV21 INS21 INS44 INS8 INS32 INS42 INS43 INS42 INS14 INS7 INS42 INS42 INS43 INS42 INS43 INS59 INS32 INS32 INS42 INS42 INS42 INS14 INS32 INS18 INS42 INS42 INS11 INS42 INS42 UPD42 MOV14 INS32 INS18 INS42 INS42 INS11 INS42 UPD42 MOV42 UPD42 MOV42 UPD45 INS32 INS45 INS2 INS32 INS45 INS32 INS45 UPD42 MOV42 INS32 INS45 INS32 INS45 UPD42 MOV42 INS2 INS42 INS42 INS42 MOV43 INS27 INS32 INS45 INS42 INS42 INS32 INS32 INS45 INS42 MOV32 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS32 INS8 INS43 INS42 INS60 INS21 INS53 INS42 INS42 INS43 INS32 MOV43 INS59 INS32 INS32 INS43 INS42 INS60 INS21 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS32 INS43 INS32 INS32 MOV43 INS59 INS32 INS43 INS42 INS60 INS21 INS53 INS42 INS42 INS42 MOV43 INS32 INS42 INS32 INS42 INS42 INS42 INS11 INS42 INS42 INS27 INS42 INS42 INS32 INS43 INS32 INS42 INS42 INS42 INS40 INS43 INS32 UPD42 INS42 INS42 INS42 INS42 INS40 INS43 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS45 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS32 INS32 MOV43 MOV43 UPD42 UPD42 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS53 INS42 INS43 INS59 INS32 INS14 INS40 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS27 INS42 INS42 INS32 UPD42 MOV42 INS43 INS59 INS32 INS14 INS40 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS11 INS42 UPD42 INS32 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS14 INS42 INS42 INS42 INS32 INS42 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 MOV32 UPD42 UPD42 INS43 INS32 INS42 INS42 INS42 INS14 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS43 INS42 INS42 MOV43 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 MOV43 INS32 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 MOV42 INS32 UPD42 INS42 INS42 INS42 INS43 INS27 INS45 INS32 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 UPD42 MOV42 INS42 INS42 INS32 INS45 INS42 INS42 INS42 INS42 INS42 INS42 DEL32 DEL42 DEL11 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL40 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL14 DEL53 DEL8 DEL25 DEL42 DEL42 DEL42 DEL40 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL43 DEL42 DEL44 DEL43 DEL42 DEL44 DEL43 DEL43 DEL31 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL11 DEL42 DEL32 DEL43 DEL8 DEL42 DEL8 DEL42 DEL42 DEL32 DEL11 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL32 DEL9 DEL9 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL54 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21
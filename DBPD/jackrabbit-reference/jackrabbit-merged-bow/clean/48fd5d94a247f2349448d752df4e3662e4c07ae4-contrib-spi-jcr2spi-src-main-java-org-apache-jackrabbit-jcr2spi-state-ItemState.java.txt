work in progress

- removeVersion missing
- LockManager/VersionManager: should not rely on observation (todo added)
- Add Operation.persisted() (Impl. still missing) in analogy to ChangeLog.persisted.
- ItemImpl.refresh behaves according to CacheBehaviour flag.
- NodeState: fix classcastexception when accessing state from propertiesInAttic
- ItemState: rename 'refresh()' to 'reload()
- ItemState: move code common to PropertyState and NodeState to ItemState
- ItemState: rename 'reset' to 'merge'
- add common interface ChildItemEntry
- SessionItemStateManager: avoid traversing twice during 'undo'

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@477095 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Set;
-            // change back tmp MODIFIED status, that is used only to have a marker
-            // to inform the overlaying state, that it needs to synchronize with
-            // its overlayed state again
+            /*
+            change back tmp MODIFIED status, that is used as marker only to
+            force the overlaying state to synchronize as well as to inform
+            other listeners about changes.
+            */
-     * Refreshes this item state recursively according to {@link
-     * javax.jcr.Item#refresh(boolean) Item.refresh(true)}. That is, changes
-     * are kept and updated to reflect the current persistent state of this
-     * item.
+     * Reloads this item state recursively. If '<code>keepChanges</code>' is
+     * true, states with transient changes are left untouched. Otherwise this
+     * state gets its data reloaded from the persistent state.
-    public abstract void refresh();
+    public abstract void reload(boolean keepChanges);
+
+    /**
+     * Merge all data from the given state into this state. If
+     * '<code>keepChanges</code>' is true, transient modifications present on
+     * this state are not touched. Otherwise this state is completely reset
+     * according to the given other state.
+     *
+     * @param another
+     * @param keepChanges
+     * @return true if this state has been modified
+     */
+    abstract boolean merge(ItemState another, boolean keepChanges);
-    public abstract void invalidate();
+    public abstract void invalidate(boolean recursive);
-                            reset();
+                            if (merge(state, false) || status == Status.INVALIDATED) {
+                                // temporarily set the state to MODIFIED in order
+                                // to inform listeners.
+                                setStatus(Status.MODIFIED);
+                            }
-                        // temporarily set the state to MODIFIED in order to
-                        // inform listeners.
-                        setStatus(Status.MODIFIED);
+                        // TODO: try to merge changes
-                    // invalidate session state as well
-                    setStatus(Status.INVALIDATED);
+                    // invalidate this session state if it is EXISTING.
+                    if (status == Status.EXISTING) {
+                        setStatus(Status.INVALIDATED);
+                    }
-     * Copy all state information from overlayed state to this state
-     */
-    abstract void reset();
-
-    /**
-     *                            state. e.g. this item state is not valid
-     *                            anymore.
+     * state. e.g. this item state is not valid anymore.
-    abstract void remove() throws ItemStateException;
+    void remove() throws ItemStateException {
+        checkIsSessionState();
+        if (!isValid()) {
+            throw new ItemStateException("Cannot remove an invalid ItemState");
+        }
+        int oldStatus = getStatus();
+        if (oldStatus == Status.NEW) {
+            setStatus(Status.REMOVED);
+        } else {
+            setStatus(Status.EXISTING_REMOVED);
+        }
+        // now inform parent
+        getParent().childStatusChanged(this, oldStatus);
+    }
-     * modifications and adds itself to the Set of <code>affectedItemStates</code>
-     * if it is reverted itself.
-     *
-     * @param affectedItemStates the set of affected item states that reverted
-     * themselfes.
+     * modifications.
-    abstract void revert(Set affectedItemStates);
+    void revert() throws ItemStateException {
+        checkIsSessionState();
+
+        switch (getStatus()) {
+            case Status.EXISTING_MODIFIED:
+            case Status.STALE_MODIFIED:
+                // revert state from overlayed
+                merge(overlayedState, false);
+                setStatus(Status.EXISTING);
+                break;
+            case Status.EXISTING_REMOVED:
+                // revert state from overlayed
+                merge(overlayedState, false);
+                setStatus(Status.EXISTING);
+                parent.childStatusChanged(this, Status.EXISTING_REMOVED);
+                break;
+            case Status.NEW:
+                remove();
+                break;
+            case Status.STALE_DESTROYED:
+                // overlayed does not exist any more
+                // cannot call 'remove' on invalid state -> manuall remove
+                setStatus(Status.REMOVED);
+                parent.childStatusChanged(this, Status.STALE_DESTROYED);
+                break;
+            default:
+                // Cannot revert EXISTING, REMOVED, INVALIDATED, MODIFIED states.
+                // State was implicitely reverted
+                log.debug("State with status " + getStatus() + " cannot be reverted.");
+        }
+    }
-     * Checks if this <code>ItemState</code> is transiently modified or new and
-     * adds itself to the <code>Set</code> of <code>transientStates</code> if
-     * that is the case. It this <code>ItemState</code> has children it will
-     * call the method {@link #collectTransientStates(Collection)} on those
-     * <code>ItemState</code>s.
+     * Checks if this <code>ItemState</code> is transiently modified, new or stale
+     * modified. and adds itself to the <code>ChangeLog</code>.
+     * If this <code>ItemState</code> has children it will call
+     * {@link #collectStates(ChangeLog, boolean)} recursively.
-     * @param transientStates the <code>Set</code> of transient <code>ItemState</code>,
+     * @param changeLog the <code>ChangeLog</code> collecting the transient
+     * item states present in a given tree.
+     * @param throwOnStale If the given flag is true, this methods throws
+     * StaleItemStateException if this state is stale.
+     * @throws StaleItemStateException if <code>throwOnStale</code> is true and
+     * this state is stale.
-    abstract void collectTransientStates(Collection transientStates);
+    void collectStates(ChangeLog changeLog, boolean throwOnStale) throws StaleItemStateException {
+        checkIsSessionState();
+        if (throwOnStale && Status.isStale(getStatus())) {
+            String msg = "Cannot save changes: " + getId() + " has been modified externally.";
+            log.debug(msg);
+            throw new StaleItemStateException(msg);
+        }
+        // only interested in transient modifications or stale-modified states
+        switch (getStatus()) {
+            case Status.NEW:
+                changeLog.added(this);
+                break;
+            case Status.EXISTING_MODIFIED:
+            case Status.STALE_MODIFIED:
+                changeLog.modified(this);
+                break;
+            case Status.EXISTING_REMOVED:
+                changeLog.deleted(this);
+                break;
+            default:
+                log.debug("Collecting states: Ignored ItemState with status " + getStatus());
+        }
+    }

MOV31 UPD42 INS44 UPD39 UPD42 INS44 INS44 INS44 INS8 INS43 INS8 UPD42 INS44 INS43 INS8 INS39 INS42 INS65 INS65 INS65 INS43 INS42 INS39 INS42 INS39 INS42 INS21 INS25 INS60 INS25 INS21 UPD42 MOV42 INS21 INS50 INS65 INS65 INS65 UPD43 UPD42 INS39 INS42 INS42 INS21 INS25 INS50 UPD66 UPD66 UPD66 UPD66 INS66 INS66 INS66 INS42 INS42 INS66 INS42 UPD66 INS32 INS38 INS8 INS39 INS59 INS27 INS8 INS8 INS32 UPD66 INS32 INS32 INS49 INS49 INS21 INS21 INS10 INS49 INS21 INS21 INS21 INS10 INS49 INS21 INS10 INS49 INS21 INS21 INS10 INS49 INS21 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 MOV65 UPD66 MOV66 INS42 UPD66 MOV66 INS66 UPD42 INS66 UPD66 INS42 INS66 INS66 UPD42 INS32 INS27 INS8 INS32 INS49 INS21 INS10 INS49 INS49 INS21 INS10 INS49 INS21 INS10 INS49 INS21 INS42 INS32 INS53 INS42 INS32 INS42 INS40 INS21 INS21 INS32 INS42 INS52 INS42 INS42 INS42 INS40 INS40 INS32 INS32 INS40 INS32 INS32 INS32 INS40 INS32 INS40 INS32 INS32 INS32 INS42 INS42 INS32 INS60 INS21 INS53 INS42 INS40 INS32 INS40 INS40 INS32 INS40 INS32 INS32 INS25 INS42 INS14 INS42 INS32 INS32 INS42 INS42 INS42 INS9 INS42 INS40 INS42 INS42 INS9 INS42 INS40 INS42 INS42 INS52 INS40 INS42 INS42 INS40 INS42 INS42 INS52 INS40 INS42 INS42 INS27 UPD42 MOV69 INS42 INS42 INS32 INS43 INS59 INS32 INS14 INS42 INS42 INS52 INS42 INS42 INS52 INS42 INS42 INS52 INS42 INS42 INS27 INS8 INS27 INS8 INS43 INS45 INS42 INS40 INS42 INS40 INS45 INS32 INS45 UPD43 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS45 INS32 INS51 INS42 INS40 MOV21 INS42 INS42 UPD42 INS45 INS32 INS45 INS42 INS42 INS52 INS8 INS42 INS25 INS27 MOV8 INS32 INS27 INS42 INS42 INS9 INS42 INS40 DEL40 DEL26 DEL40 DEL42 DEL68 DEL66 DEL65 DEL66 DEL52 DEL42 DEL32 DEL21 DEL8 DEL51 DEL66 DEL83 DEL66 DEL42 DEL66 DEL66 DEL65 DEL83 DEL43 DEL42 DEL44 DEL66 DEL65 DEL83
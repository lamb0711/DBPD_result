fixed JCR-42: Workspace.move() and Session.move() allow moves to an invalid path
minor other changes

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@153279 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.version.VersionManager;
+     * Verifies that the node at <code>nodePath</code> is checked-out; throws a
+     * <code>VersionException</code> if that's not the case.
+     * <p/>
+     * A node is considered <i>checked-out</i> if it is versionable and
+     * checked-out, or is non-versionable but its nearest versionable ancestor
+     * is checked-out, or is non-versionable and there are no versionable
+     * ancestors.
+     *
+     * @param nodePath
+     * @param hierMgr
+     * @param stateMgr
+     * @throws VersionException
+     * @throws RepositoryException
+     */
+    protected static void verifyCheckedOut(Path nodePath,
+                                           HierarchyManagerImpl hierMgr,
+                                           ItemStateManager stateMgr)
+            throws VersionException, RepositoryException {
+        // search nearest ancestor that is versionable, start with node at nodePath
+        /**
+         * FIXME should not only rely on existence of jcr:isCheckedOut property
+         * but also verify that node.isNodeType("mix:versionable")==true;
+         * this would have a negative impact on performance though...
+         */
+        NodeState nodeState = getNodeState(nodePath, hierMgr, stateMgr);
+        while (!nodeState.hasPropertyEntry(VersionManager.PROPNAME_IS_CHECKED_OUT)) {
+            if (nodePath.denotesRoot()) {
+                return;
+            }
+            nodePath = nodePath.getAncestor(1);
+            nodeState = getNodeState(nodePath, hierMgr, stateMgr);
+        }
+        PropertyId propId =
+                new PropertyId(nodeState.getUUID(), VersionManager.PROPNAME_IS_CHECKED_OUT);
+        PropertyState propState;
+        try {
+            propState = (PropertyState) stateMgr.getItemState(propId);
+        } catch (ItemStateException ise) {
+            String msg = "internal error: failed to retrieve state of "
+                    + hierMgr.safeGetJCRPath(propId);
+            log.debug(msg);
+            throw new RepositoryException(msg, ise);
+        }
+        boolean checkedOut = ((Boolean) propState.getValues()[0].internalValue()).booleanValue();
+        if (!checkedOut) {
+            throw new VersionException(hierMgr.safeGetJCRPath(nodePath) + " is checked-in");
+        }
+    }
+
+    /**
-            PathNotFoundException, ItemExistsException, RepositoryException {
+            VersionException, PathNotFoundException, ItemExistsException,
+            LockException, RepositoryException {
+        // make sure destination parent node is checked-out
+        verifyCheckedOut(destParentPath, destHierMgr, destStateMgr);
+
+        // @todo check locked-status
+
-        // @todo check ckecked-out status
-        // @todo check locked-status status
-        // @todo reimplement Workspace#copy according to new spec
-        // @todo check ckecked-out status
-        // @todo check locked-status status
-
-        // @todo reimplement Workspace#copy according to new spec
-        // @todo check ckecked-out status
-        // @todo check locked-status status
-
-        // @todo reimplement Workspace#move according to new spec
-        // @todo check ckecked-out status
-        // @todo check locked-status status
-
+            if (srcPath.isAncestorOf(destPath)) {
+                String msg = destAbsPath + ": invalid destination path (cannot be descendant of source path)";
+                log.debug(msg);
+                throw new RepositoryException(msg);
+            }
+        // make sure both source & destination parent nodes are checked-out
+        verifyCheckedOut(srcParentPath, hierMgr, stateMgr);
+        verifyCheckedOut(destParentPath, hierMgr, stateMgr);
+
+        // @todo check locked-status
+

INS26 INS40 INS31 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS43 INS8 INS43 INS43 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS60 INS61 INS60 INS60 INS54 INS60 INS25 INS42 INS42 INS21 INS21 INS21 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS38 INS8 INS43 INS59 INS43 INS59 INS8 INS12 INS39 INS59 INS38 INS8 INS32 INS32 INS32 INS42 INS42 INS32 INS32 INS25 INS21 INS21 INS42 INS42 INS14 INS42 INS42 INS21 INS44 INS8 INS42 INS32 INS42 INS53 INS42 INS42 INS42 INS42 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS32 INS8 INS7 INS7 INS43 INS32 INS40 INS7 INS43 INS42 INS60 INS21 INS53 INS36 INS42 INS14 INS32 INS8 INS42 INS42 INS41 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS11 INS42 INS43 INS59 INS32 INS14 INS11 INS43 INS27 INS42 INS42 INS42 INS60 INS21 INS53 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS43 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS43 INS32 INS42 INS32 INS45 INS43 INS59 INS32 INS14 INS42 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS2 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS32 INS34 INS42 INS45 INS42 INS42 INS42
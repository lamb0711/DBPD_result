- remove cachebehaviour flag from ChangeLog.persisted
- minor improvement

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@521356 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.config.CacheBehaviour;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+    /**
+     * Logger instance for this class.
+     */
+    private static final Logger log = LoggerFactory.getLogger(ChangeLog.class);
+
+    /**
+     * The changelog target: Root item of the tree whose changes are contained
+     * in this changelog.
+     */
-     * This implementation will call {@link ItemState#persisted(ChangeLog, CacheBehaviour)
+     * This implementation will call {@link ItemState#persisted(ChangeLog)
-     * TODO: remove parameter CacheBehaviour
-    public void persisted(CacheBehaviour cacheBehaviour) {
-        target.persisted(this, cacheBehaviour);
+    public void persisted() {
+        target.persisted(this);
+     * Adjust this ChangeLog according to the status change with the given
+     * ItemState:
-    public void removeAffected(ItemState state, int previousStatus) {
+    public void statusChanged(ItemState state, int previousStatus) {
-            case (Status.REMOVED):
-                if (previousStatus == Status.NEW) {
-                    // was new and now removed again
-                    addedStates.remove(state);
-                    deletedStates.remove(state);
-                    // remove operations performed on the removed state
-                    removeAffectedOperations(state);
-                    /* remove the add-operation as well:
-                       since the affected state of an 'ADD' operation is the parent
-                       instead of the added-state, the set of operations
-                       need to be searched for the parent state && the proper
-                       operation type.
-                       SET_MIXIN can be is a special case of adding a property */
-                    NodeEntry parentEntry = state.getHierarchyEntry().getParent();
-                    if (parentEntry != null && parentEntry.isAvailable()) {
-                        try {
-                            NodeState parent = parentEntry.getNodeState();
-                            if (parent.getStatus() != Status.REMOVED) {
-                                for (Iterator it = operations.iterator(); it.hasNext();) {
-                                    Operation op = (Operation) it.next();
-                                    if (op instanceof AddNode) {
-                                        AddNode operation = (AddNode) op;
-                                        if (operation.getParentState() == parent
-                                                && operation.getNodeName().equals(state.getQName())) {
-                                            // TODO: this will not work for name name siblings!
-                                            it.remove();
-                                            break;
-                                        }
-                                    } else if (op instanceof AddProperty) {
-                                        AddProperty operation = (AddProperty) op;
-                                        if (operation.getParentState() == parent
-                                                && operation.getPropertyName().equals(state.getQName())) {
-                                            it.remove();
-                                            break;
-                                        }
-                                    } else if (op instanceof SetMixin &&
-                                        QName.JCR_MIXINTYPES.equals(state.getQName()) &&
-                                        ((SetMixin)op).getNodeState() == parent) {
-                                        it.remove();
-                                        break;
-                                    }
-                                }
-                            }
-                        } catch (RepositoryException e) {
-                            // should never occur -> ignore
-                        }
-                    }
-                } else if (previousStatus == Status.EXISTING_REMOVED) {
-                    // was removed and is now saved
-                    deletedStates.remove(state);
-                    removeAffectedOperations(state);
-                }
-                break;
-                removeAffectedOperations(state);
+                // removeAffectedOperations(state);
-            case Status.STALE_DESTROYED:
-                // state is now stale. remove from modified
-                modifiedStates.remove(state);
-                removeAffectedOperations(state);
+            case (Status.REMOVED):
+                switch (previousStatus) {
+                    case Status.EXISTING_REMOVED:
+                        // was removed and is now saved
+                        deletedStates.remove(state);
+                        removeAffectedOperations(state);
+                        break;
+                    case Status.NEW:
+                        newStateRemoved(state);
+                        break;
+                }
+    private void newStateRemoved(ItemState state) {
+        NodeEntry parentEntry = state.getHierarchyEntry().getParent();
+        if (!parentEntry.isAvailable() || Status.isTerminal(parentEntry.getStatus())) {
+            return; // TODO: check if correct
+        }
+        // was new and now removed again
+        addedStates.remove(state);
+
+        // remove any operations performed on the removed state
+        removeAffectedOperations(state);
+
+        /* remove the add-operation as well:
+           since the affected state of an 'ADD' operation is the parent instead
+           of the added-state, the set of operations need to be searched for the
+           parent state && the proper operation type.
+           SET_MIXIN is considered as a special case of adding a property
+         */
+        NodeState parent;
+        try {
+            parent = parentEntry.getNodeState();
+        } catch (RepositoryException e) {
+            // should never occur
+            log.error("Internal error:", e);
+            return;
+        }
+        for (Iterator it = operations.iterator(); it.hasNext();) {
+            Operation op = (Operation) it.next();
+            if (op instanceof AddNode) {
+                AddNode operation = (AddNode) op;
+                if (operation.getParentState() == parent
+                        && operation.getNodeName().equals(state.getQName())) {
+                    // TODO: this will not work for name name siblings!
+                    it.remove();
+                    break;
+                }
+            } else if (op instanceof AddProperty) {
+                AddProperty operation = (AddProperty) op;
+                if (operation.getParentState() == parent
+                        && operation.getPropertyName().equals(state.getQName())) {
+                    it.remove();
+                    break;
+                }
+            } else if (op instanceof SetMixin &&
+                    QName.JCR_MIXINTYPES.equals(state.getQName()) &&
+                    ((SetMixin)op).getNodeState() == parent) {
+                it.remove();
+                break;
+            }
+        }
+    }
+

MOV26 INS26 UPD40 INS40 INS23 INS31 INS29 INS83 INS83 INS83 INS43 INS59 INS29 INS29 INS83 INS39 INS42 INS44 MOV44 INS8 UPD83 UPD42 MOV8 INS65 INS42 INS42 INS32 INS65 INS65 MOV65 INS43 INS42 INS50 MOV60 INS25 MOV21 MOV21 INS60 INS54 INS66 INS42 INS42 INS57 INS66 INS66 INS66 INS66 INS66 INS66 INS42 MOV32 MOV49 MOV50 INS10 MOV49 MOV21 INS10 MOV49 MOV21 INS10 MOV49 INS50 INS10 INS27 INS8 MOV43 INS59 INS8 INS12 INS43 INS42 INS49 MOV21 MOV21 INS10 INS49 INS21 INS10 INS38 INS32 INS41 INS42 INS21 MOV44 INS8 INS42 INS40 INS40 INS32 MOV32 INS42 INS42 INS32 INS7 INS21 INS41 INS42 INS42 INS42 INS42 INS42 MOV32 INS32 INS42 INS42 INS45 INS42 DEL42 DEL43 DEL69 DEL66 DEL42 DEL43 DEL42 DEL44 DEL42 DEL66 DEL66 DEL65 DEL29 DEL10 DEL10 DEL42 DEL40 DEL27 DEL42 DEL33 DEL27 DEL27 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL40 DEL27 DEL25 DEL8 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL42 DEL40 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL25 DEL10 DEL42 DEL42 DEL32 DEL21 DEL10 DEL40 DEL49 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL10 DEL50 DEL8
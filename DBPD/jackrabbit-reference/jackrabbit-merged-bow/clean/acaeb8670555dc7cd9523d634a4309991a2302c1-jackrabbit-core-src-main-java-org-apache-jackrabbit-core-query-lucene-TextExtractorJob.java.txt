JCR-2219: Improved background text extraction

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@799610 13f79535-47bb-0310-9956-ffa450edef68

-import EDU.oswego.cs.dl.util.concurrent.FutureResult;
-import EDU.oswego.cs.dl.util.concurrent.Callable;
-
-import org.apache.jackrabbit.util.LazyFileInputStream;
-import java.io.IOException;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.OutputStreamWriter;
-import java.io.Writer;
-import java.io.BufferedWriter;
-import java.io.InputStreamReader;
-import java.io.StringReader;
-import java.lang.reflect.InvocationTargetException;
-public class TextExtractorJob extends FutureResult implements Runnable {
-
-    /**
-     * UTF-8 encoding.
-     */
-    private static final String ENCODING_UTF8 = "UTF-8";
+public class TextExtractorJob implements Runnable {
-     * The command of the future result.
+     * The text extractor.
-    private final Runnable cmd;
+    private final TextExtractor extractor;
+
+    /**
+     * The binary stream.
+     */
+    private final InputStream stream;
-     * Set to <code>true</code> if this job timed out.
+     * The encoding of the binary content, or <code>null</code>.
-    private transient boolean timedOut = false;
+    private final String encoding;
-     * <code>true</code> if this extractor job has been flaged as discarded.
+     * The extracted text. Set when the text extraction task completes.
-    private transient boolean discarded = false;
+    private transient String text = null;
-    public TextExtractorJob(final TextExtractor extractor,
-                            final InputStream stream,
-                            final String type,
-                            final String encoding) {
+    public TextExtractorJob(
+            TextExtractor extractor,
+            InputStream stream, String type, String encoding) {
+        this.extractor = extractor;
+        this.stream = stream;
-        this.cmd = setter(new Callable() {
-            public Object call() throws Exception {
-                Reader r = extractor.extractText(stream, type, encoding);
-                if (r != null) {
-                    if (discarded) {
-                        r.close();
-                        r = null;
-                    } else if (timedOut) {
-                        // spool a temp file to save memory
-                        r = getSwappedOutReader(r);
-                    }
-                }
-                return r;
-            }
-        });
+        this.encoding = encoding;
+    }
+
+    public boolean hasExtractedText() {
+        return text != null;
-     * to the constructor of this <code>TextExtractorJob</code>. The caller of
-     * this method is responsible for closing the returned reader. Returns
+     * to the constructor of this <code>TextExtractorJob</code>. Returns
-     * @return the Reader with the extracted text. Returns <code>null</code> if
-     *         a timeout or an exception occured extracting the text.
+     * @return the extracted text, or <code>null</code> if a timeout or
+     *         an exception occurred while extracting the text
-    public Reader getReader(long timeout) {
-        Reader reader = null;
-        try {
-            reader = (Reader) timedGet(timeout);
-        } catch (InterruptedException e) {
-            // also covers TimeoutException
-            // text not extracted within timeout or interrupted
-            if (timeout > 0) {
-                log.debug("Text extraction for {} timed out (>{}ms).",
-                        type, new Long(timeout));
-                timedOut = true;
-            }
-        } catch (InvocationTargetException e) {
-            // extraction failed
-            log.warn("Exception while indexing binary property: " + e.getCause());
-            log.debug("Dump: ", e.getCause());
-        }
-        return reader;
-    }
-
-    /**
-     * Discards this extractor job. If the reader within this job is ready at
-     * the time of this call, it is closed. If the reader is not yet ready this
-     * job will be flaged as discarded and any later call to
-     * {@link #getReader(long)} will return <code>null</code>. The reader that
-     * is about to be constructed by a background thread will be closed
-     * automatically as soon as it becomes ready.
-     */
-    void discard() {
-        discarded = true;
-        Reader r = (Reader) peek();
-        if (r != null) {
+    public synchronized String getExtractedText(long timeout) {
+        if (text == null) {
-                r.close();
-            } catch (IOException e) {
-                log.warn("Exception when trying to discard extractor job: " + e);
+                wait(timeout);
+            } catch (InterruptedException e) {
+                if (text == null) {
+                    log.debug("Text extraction for {} timed out (> {}ms)",
+                            type, timeout);
+                }
+        return text;
-        // forward to command
-        cmd.run();
-    }
-
-    //----------------------------< internal >----------------------------------
-
-    /**
-     * Returns a <code>Reader</code> for <code>r</code> using a temp file.
-     *
-     * @param r the reader to swap out into a temp file.
-     * @return a reader to the temp file.
-     */
-    private Reader getSwappedOutReader(Reader r) {
-        final File temp;
-        try {
-            temp = File.createTempFile("extractor", null);
-        } catch (IOException e) {
-            // unable to create temp file
-            // return reader as is
-            return r;
-        }
-        Writer out;
-        try {
-            out = new BufferedWriter(new OutputStreamWriter(
-                            new FileOutputStream(temp), ENCODING_UTF8));
-        } catch (IOException e) {
-            // should never happend actually
-            if (!temp.delete()) {
-                temp.deleteOnExit();
-            }
-            return r;
-        }
-
-        // spool into temp file
-        InputStream in = null;
-                IOUtils.copy(r, out);
-                out.close();
+                Reader reader = extractor.extractText(stream, type, encoding);
+                this.text = IOUtils.toString(reader);
-                r.close();
+                stream.close();
-            in = new LazyFileInputStream(temp);
-
-            return new InputStreamReader(in, ENCODING_UTF8) {
-                public void close() throws IOException {
-                    super.close();
-                    // delete file
-                    if (!temp.delete()) {
-                        temp.deleteOnExit();
-                    }
-                }
-            };
-        } catch (IOException e) {
-            // do some clean up
-            IOUtils.closeQuietly(out);
-            IOUtils.closeQuietly(in);
-
-            if (!temp.delete()) {
-                temp.deleteOnExit();
-            }
-            // use empty string reader as fallback
-            return new StringReader("");
+        } catch (Throwable e) {
+            log.warn("Text extraction failed for type " + type, e);
+            this.text = "";
+        }
+        synchronized (this) {
+            notifyAll();
+

MOV23 INS31 INS31 INS31 INS43 MOV43 UPD83 INS43 INS43 MOV29 MOV83 MOV42 MOV44 MOV44 MOV44 MOV44 INS8 INS83 INS39 INS42 INS8 INS83 MOV43 UPD42 MOV29 MOV83 MOV39 MOV42 MOV8 INS42 UPD42 UPD42 INS42 UPD42 INS42 UPD42 INS33 MOV43 UPD42 UPD42 INS21 MOV21 MOV21 MOV21 MOV41 INS25 INS54 INS51 UPD66 UPD66 UPD66 UPD66 INS7 INS27 UPD66 UPD66 UPD66 INS27 INS8 UPD42 INS8 INS12 INS52 INS8 MOV22 INS42 INS22 INS42 INS22 INS42 INS42 INS33 INS42 INS33 MOV54 INS54 MOV44 INS8 MOV21 UPD42 INS52 INS42 INS52 INS42 MOV8 MOV8 UPD43 MOV21 MOV21 MOV60 UPD42 UPD42 INS32 INS32 UPD42 UPD42 INS27 UPD42 INS22 INS45 UPD42 MOV42 MOV42 UPD27 UPD42 INS22 INS42 INS42 INS45 INS42 INS52 INS42 UPD42 INS33 INS52 INS42 UPD42 INS42 UPD42 UPD45 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL42 DEL43 DEL83 DEL45 DEL42 DEL43 DEL39 DEL9 DEL39 DEL9 DEL83 DEL83 DEL83 DEL83 DEL42 DEL33 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL43 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL8 DEL25 DEL25 DEL8 DEL25 DEL8 DEL31 DEL1 DEL14 DEL32 DEL7 DEL21 DEL8 DEL31 DEL66 DEL42 DEL43 DEL42 DEL42 DEL43 DEL32 DEL11 DEL7 DEL34 DEL42 DEL43 DEL42 DEL14 DEL42 DEL9 DEL7 DEL21 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL12 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL66 DEL66 DEL66 DEL42 DEL39 DEL69 DEL68 DEL65 DEL66 DEL66 DEL66 DEL65 DEL29 DEL39 DEL42 DEL42 DEL9 DEL7 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL31 DEL42 DEL45 DEL33 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL14 DEL42 DEL14 DEL14 DEL7 DEL42 DEL42 DEL42 DEL43 DEL42 DEL14 DEL42 DEL83 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL41 DEL8 DEL12 DEL54 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8 DEL12 DEL54 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL42 DEL43 DEL42 DEL42 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL48 DEL21 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL1 DEL14 DEL41 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL38 DEL8 DEL25 DEL42 DEL43 DEL45 DEL14 DEL41 DEL8 DEL12 DEL54 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL31
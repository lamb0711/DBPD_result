work in progress

- Restore: pass NodeState(s) and Path instead of NodeId(s)
- LockManager: make sure lockmanager only remembers workspace states
- LockManager: make sure operations are executed using workspace states
- LockManager: improve isLocked/getLock/checkIsLocked and respect locks that
have been accessed before.
- VersionManager: make sure operations are executed using workspace states
- VersionManager: add checkIsCheckedOut
- VersionManager: force manager to have a WorkspaceManager
- NodeReferences:
  > make interface package protected
  > clarify method naming
  > add implementation to WorkspaceItemStateFactory
  > add NodeReferences field to NodeState
  > TO_IMPROVE: references are currently always retrieve from the SPI.
- ItemStateManager + NodeReferences
  > rename interfaces methods
  > change method signature to take NodeState instead of NodeId
  > 'getReferences' returns the property states directly

- remove some JR DIFFs. 

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@432234 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.state.UpdatableItemStateManager;
+import org.apache.jackrabbit.jcr2spi.state.ItemState;
+import org.apache.jackrabbit.jcr2spi.WorkspaceManager;
+import javax.jcr.version.VersionException;
+
+import org.apache.jackrabbit.name.Path;
-import org.apache.jackrabbit.spi.NodeId;
-    private final UpdatableItemStateManager stateManager;
+    private final WorkspaceManager workspaceManager;
-    public VersionManagerImpl(UpdatableItemStateManager stateManager) {
-        this.stateManager = stateManager;
+    public VersionManagerImpl(WorkspaceManager workspaceManager) {
+        this.workspaceManager = workspaceManager;
-        Operation ci = Checkin.create(nodeState);
-        stateManager.execute(ci);
+        NodeState wspState = getWorkspaceState(nodeState);
+        Operation ci = Checkin.create(wspState);
+        workspaceManager.execute(ci);
-        Operation co = Checkout.create(nodeState);
-        stateManager.execute(co);
+        NodeState wspState = getWorkspaceState(nodeState);
+        Operation co = Checkout.create(wspState);
+        workspaceManager.execute(co);
+        // shortcut: if state is new, its ancestor must be checkout
+        if (nodeState.getStatus() == ItemState.STATUS_NEW) {
+            return true;
+        }
+
+        NodeState wspState = getWorkspaceState(nodeState);
-            while (!nodeState.hasPropertyName(QName.JCR_ISCHECKEDOUT)) {
-                NodeState parentState = nodeState.getParent();
+            while (!wspState.hasPropertyName(QName.JCR_ISCHECKEDOUT)) {
+                NodeState parentState = wspState.getParent();
-                nodeState = parentState;
+                wspState = parentState;
-            PropertyState propState = nodeState.getPropertyState(QName.JCR_ISCHECKEDOUT);
+            PropertyState propState = wspState.getPropertyState(QName.JCR_ISCHECKEDOUT);
+    public void checkIsCheckedOut(NodeState nodeState) throws VersionException, RepositoryException {
+        if (!isCheckedOut(nodeState)) {
+            throw new VersionException(nodeState + " is checked-in");
+        }
+    }
+
-        Operation op = Remove.create(versionState);
-        stateManager.execute(op);
+        NodeState wspVersionState = getWorkspaceState(versionState);
+        Operation op = Remove.create(wspVersionState);
+        workspaceManager.execute(op);
-        Operation op = AddLabel.create(versionHistoryState, versionState, qLabel, moveLabel);
-        stateManager.execute(op);
+        NodeState wspVHState = getWorkspaceState(versionHistoryState);
+        NodeState wspVState = getWorkspaceState(versionState);
+        Operation op = AddLabel.create(wspVHState, wspVState, qLabel, moveLabel);
+        workspaceManager.execute(op);
-        Operation op = RemoveLabel.create(versionHistoryState, versionState, qLabel);
-        stateManager.execute(op);
+        NodeState wspVHState = getWorkspaceState(versionHistoryState);
+        NodeState wspVState = getWorkspaceState(versionState);
+        Operation op = RemoveLabel.create(wspVHState, wspVState, qLabel);
+        workspaceManager.execute(op);
-    public void restore(NodeId nodeId, NodeId versionId, boolean removeExisting) throws RepositoryException {
-        Operation op = Restore.create(nodeId, versionId, removeExisting);
-        stateManager.execute(op);
+    public void restore(NodeState nodeState, Path relativePath, NodeState versionState, boolean removeExisting) throws RepositoryException {
+        NodeState wspState = getWorkspaceState(nodeState);
+        NodeState wspVState = getWorkspaceState(versionState);
+        Operation op = Restore.create(wspState, relativePath, wspVState, removeExisting);
+        workspaceManager.execute(op);
-    public void restore(NodeId[] versionIds, boolean removeExisting) throws RepositoryException {
-        Operation op = Restore.create(versionIds, removeExisting);
-        stateManager.execute(op);
+    public void restore(NodeState[] versionStates, boolean removeExisting) throws RepositoryException {
+        NodeState[] wspStates = new NodeState[versionStates.length];
+        for (int i = 0; i < versionStates.length; i++) {
+            wspStates[i] = getWorkspaceState(versionStates[i]);
+        }
+
+        Operation op = Restore.create(wspStates, removeExisting);
+        workspaceManager.execute(op);
+        NodeState wspState = getWorkspaceState(nodeState);
-        Operation op = Merge.create(nodeState, workspaceName, bestEffort, mergeFailedCollector);
-        stateManager.execute(op);
+        Operation op = Merge.create(wspState, workspaceName, bestEffort, mergeFailedCollector);
+        workspaceManager.execute(op);
-        Operation op = ResolveMergeConflict.create(nodeState, versionState, done);
-        stateManager.execute(op);
+        NodeState wspState = getWorkspaceState(nodeState);
+        NodeState wspVState = getWorkspaceState(versionState);
+        Operation op = ResolveMergeConflict.create(wspState, wspVState, done);
+        workspaceManager.execute(op);
+    }
+
+    //------------------------------------------------------------< private >---
+    /**
+     * If the given <code>NodeState</code> has an overlayed state, the overlayed
+     * (workspace) state will be returned. Otherwise the given state is returned.
+     *
+     * @param nodeState
+     * @return The overlayed state or the given state, if this one does not have
+     * an overlayed state.
+     */
+    private NodeState getWorkspaceState(NodeState nodeState) {
+        if (nodeState.hasOverlayedState()) {
+            // nodestate has been obtained from  Session-ISM
+            return (NodeState) nodeState.getOverlayedState();
+        } else {
+            // nodestate has been obtained from Workspace-ISM already
+            return nodeState;
+        }

MOV26 MOV26 INS26 INS26 UPD40 INS40 INS40 UPD40 INS31 INS31 UPD43 INS83 INS39 INS42 INS44 INS43 MOV43 INS8 MOV44 MOV44 MOV43 MOV44 MOV44 MOV43 INS44 MOV43 INS43 INS29 INS83 INS43 INS42 INS44 INS8 UPD42 UPD42 UPD43 UPD42 INS60 INS60 INS25 INS60 INS43 INS42 INS42 INS25 INS60 INS60 INS60 INS60 INS60 UPD43 UPD42 INS43 INS42 UPD43 UPD42 INS60 INS60 UPD5 UPD42 INS42 INS60 INS24 INS60 INS60 INS60 INS65 INS65 INS65 INS42 INS43 INS42 INS25 UPD42 INS43 INS59 INS43 INS59 INS27 INS8 MOV43 INS59 INS42 INS38 INS8 INS43 INS59 MOV43 INS43 INS59 INS43 INS59 MOV43 INS43 INS59 INS43 INS59 MOV43 UPD42 INS42 UPD42 INS43 INS59 INS43 INS59 MOV43 UPD43 INS5 INS59 INS58 INS27 INS37 INS8 MOV43 INS43 INS59 MOV43 INS43 INS59 INS43 INS59 MOV43 INS66 INS66 INS42 INS66 INS66 INS42 INS32 INS8 INS8 UPD42 INS42 INS42 INS32 UPD42 INS42 INS42 INS32 UPD42 INS32 INS40 INS41 INS42 INS32 INS32 INS53 INS42 INS42 INS32 UPD42 INS42 INS42 INS32 INS42 INS42 INS32 UPD42 INS42 INS42 INS32 INS42 INS42 INS32 UPD42 INS42 INS42 INS32 INS42 INS42 INS32 UPD42 UPD42 INS43 INS85 INS42 INS3 INS39 INS59 INS42 INS40 INS42 INS21 UPD42 INS42 INS42 INS32 UPD42 INS42 INS42 INS32 INS42 INS42 INS32 UPD42 INS42 INS42 INS41 INS41 UPD42 INS42 INS42 UPD42 INS42 INS42 UPD42 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS14 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS42 INS5 INS40 INS42 INS34 INS7 UPD42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS11 INS42 INS43 INS27 INS43 INS85 INS2 INS32 INS43 INS32 UPD42 INS43 UPD42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS2 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 UPD42
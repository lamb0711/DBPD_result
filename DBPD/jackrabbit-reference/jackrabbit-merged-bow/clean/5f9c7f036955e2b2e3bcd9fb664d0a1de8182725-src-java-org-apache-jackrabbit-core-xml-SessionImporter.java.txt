re-implemented handling of values on import to allow import of large binary properties 

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@160072 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.IOException;
+import java.io.Reader;
-            InternalValue[] iva = pi.getValues();
+            TextValue[] tva = pi.getValues();
-            if (iva.length == 1) {
+            if (tva.length == 1) {
-            // convert InternalValue objects to Value objects using this
-            // session's namespace mappings
-            Value[] va = new Value[iva.length];
-            // check whether type conversion is required
-            if (def.getRequiredType() != PropertyType.UNDEFINED
-                    && def.getRequiredType() != type) {
-                // type doesn't match required type,
-                // type conversion required
-                // FIXME: awkward code
-                for (int i = 0; i < iva.length; i++) {
-                    // convert InternalValue to Value of required type
-                    Value v =
-                            ValueHelper.convert(iva[i].toJCRValue(nsContext),
-                                    def.getRequiredType());
-                    // convert Value to InternalValue using
+            // convert serialized values to Value objects
+            Value[] va = new Value[tva.length];
+            int targetType = def.getRequiredType();
+            if (targetType == PropertyType.UNDEFINED) {
+                if (type == PropertyType.UNDEFINED) {
+                    targetType = PropertyType.STRING;
+                } else {
+                    targetType = type;
+                }
+            }
+            for (int i = 0; i < tva.length; i++) {
+                TextValue tv = tva[i];
+
+                if (targetType == PropertyType.NAME ||
+                        targetType == PropertyType.PATH) {
+                    // NAME and PATH require special treatment because
+                    // they depend on the current namespace context
+                    // of the xml document
+
+                    // retrieve serialized value
+                    String serValue;
+                    try {
+                        serValue = tv.retrieve();
+                    } catch (IOException ioe) {
+                        String msg = "failed to retrieve serialized value";
+                        log.debug(msg, ioe);
+                        throw new RepositoryException(msg, ioe);
+                    }
+
+                    // convert serialized value to InternalValue using
-                    InternalValue ival = InternalValue.create(v, nsContext);
-                    // convert InternalValue back to Value using this
+                    InternalValue ival =
+                            InternalValue.create(serValue, targetType, nsContext);
+                    // convert InternalValue to Value using this
-                }
-            } else {
-                // no type conversion required:
-                // convert InternalValue to Value using this
-                // session's namespace mappings
-                for (int i = 0; i < iva.length; i++) {
-                    va[i] = iva[i].toJCRValue(session.getNamespaceResolver());
+                } else if (targetType == PropertyType.BINARY) {
+                    // deserialize BINARY type using Reader
+                    try {
+                        Reader reader = tv.reader();
+                        va[i] = ValueHelper.deserialize(reader, targetType, false);
+                    } catch (IOException ioe) {
+                        String msg = "failed to deserialize binary value";
+                        log.debug(msg, ioe);
+                        throw new RepositoryException(msg, ioe);
+                    }
+                } else {
+                    // all other types
+
+                    // retrieve serialized value
+                    String serValue;
+                    try {
+                        serValue = tv.retrieve();
+                    } catch (IOException ioe) {
+                        String msg = "failed to retrieve serialized value";
+                        log.debug(msg, ioe);
+                        throw new RepositoryException(msg, ioe);
+                    }
+
+                    va[i] = ValueHelper.deserialize(serValue, targetType, true);

INS26 INS26 INS40 INS40 INS60 INS25 INS24 UPD5 MOV5 INS39 INS59 INS27 INS8 MOV58 MOV27 MOV37 INS8 UPD43 UPD42 UPD40 INS42 MOV32 INS42 MOV40 INS25 UPD40 INS60 INS25 UPD42 MOV5 UPD40 INS27 INS8 INS8 UPD43 MOV43 INS59 INS27 INS8 INS25 MOV42 INS40 INS21 INS21 UPD42 UPD42 MOV42 INS2 INS27 INS27 INS60 INS54 MOV60 MOV21 INS27 INS8 INS8 INS7 INS7 UPD42 MOV42 MOV42 INS42 INS40 INS42 INS40 INS43 INS59 INS8 INS12 INS42 INS40 INS54 INS60 INS54 MOV21 INS42 INS40 INS42 INS42 INS42 INS42 INS21 INS44 INS8 INS8 INS12 INS43 INS59 INS8 INS12 INS7 INS43 INS42 INS60 INS21 INS53 UPD42 INS42 INS60 INS21 INS44 INS8 INS42 INS42 INS21 INS44 INS8 INS2 INS32 INS42 INS32 INS42 INS43 INS59 INS32 INS14 INS43 INS59 INS7 INS43 INS42 INS60 INS21 INS53 INS7 INS43 INS42 INS60 INS21 INS53 UPD42 MOV42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 INS9 INS42 INS42 INS42 INS42 INS45 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS43 INS42 INS42 INS42 UPD42 MOV42 INS32 MOV2 INS32 INS42 INS43 INS59 INS32 INS14 INS42 INS32 INS42 INS43 INS59 INS32 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 DEL2 DEL32 DEL32 DEL42 DEL42 DEL32 DEL27 DEL27 DEL27 DEL42 DEL42 DEL2 DEL42 DEL42 DEL32 DEL32 DEL32 DEL59 DEL60 DEL8 DEL24 DEL8 DEL39 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL8 DEL24 DEL8 DEL25
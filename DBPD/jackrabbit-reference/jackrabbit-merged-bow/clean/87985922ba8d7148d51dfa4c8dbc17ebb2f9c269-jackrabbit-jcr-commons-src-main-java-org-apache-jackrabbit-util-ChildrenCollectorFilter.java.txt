OAK-77 : Consolidate Utilities (WIP)

- move ItemNameMatcher to jackrabbit-jcr-commons

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1333420 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.commons.ItemNameMatcher;
-import java.util.StringTokenizer;
+    @Override
+    @Override
-     * Matches the name pattern against the specified name.
-     * <p/>
-     * The pattern may be a full name or a partial name with one or more
-     * wildcard characters ("*"), or a disjunction (using the "|" character
-     * to represent logical <i>OR</i>) of these. For example,
-     * <p/>
-     * <code>"jcr:*|foo:bar"</code>
-     * <p/>
-     * would match
-     * <p/>
-     * <code>"foo:bar"</code>, but also <code>"jcr:whatever"</code>.
-     * <p/>
-     * <pre>
-     * The EBNF for pattern is:
+     * Same as {@link ItemNameMatcher#matches(String, String)}.
-     * namePattern ::= disjunct {'|' disjunct}
-     * disjunct ::= name [':' name]
-     * name ::= '*' |
-     *          ['*'] fragment {'*' fragment}['*']
-     * fragment ::= char {char}
-     * char ::= nonspace | ' '
-     * nonspace ::= (* Any Unicode character except:
-     *               '/', ':', '[', ']', '*',
-     *               ''', '"', '|' or any whitespace
-     *               character *)
-     * </pre>
-     * Note that leading and trailing whitespace around a pattern <i>is</i> ignored.
-     *
-     * @param name the name to test the pattern with
-     * @param pattern the pattern to be matched against the name
-     * @return true if the specified name matches the pattern
-        // split pattern
-        StringTokenizer st = new StringTokenizer(pattern, OR, false);
-        while (st.hasMoreTokens()) {
-            // remove leading & trailing whitespace from token
-            String token = st.nextToken().trim();
-            if (internalMatches(name, token, 0, 0)) {
-                return true;
-            }
-        }
-        return false;
+        return ItemNameMatcher.matches(name, pattern);
-     * Matches the <code>nameGlob</code> strings in the passed array against
-     * the specified name.
-     * <p>
-     * A glob may be a full name or a partial name with one or more
-     * wildcard characters ("<code>*</code>").
-     * <p>
-     * Note that unlike in the case of the {@link #matches(String, String)}
-     * leading and trailing whitespace around a glob is <i>not</i> ignored.
+     * Same as {@link ItemNameMatcher#matches(String, String)}.
-     * @param name the name to test the pattern with
-     * @param nameGlobs an array of globbing strings
-     * @return true if the specified name matches any of the globs
-     * @see javax.jcr.Node#getNodes(String[])
+     * @see javax.jcr.Node#getNodes(String)
-        for (int i = 0; i < nameGlobs.length; i++) {
-            // use globbing string as-is, i.e. don't trim any leading/trailing
-            // whitespace
-            if (internalMatches(name, nameGlobs[i], 0, 0)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Internal helper used to recursively match the pattern
-     *
-     * @param s       The string to be tested
-     * @param pattern The pattern
-     * @param sOff    offset within <code>s</code>
-     * @param pOff    offset within <code>pattern</code>.
-     * @return true if <code>s</code> matched pattern, else false.
-     */
-    private static boolean internalMatches(String s, String pattern,
-                                           int sOff, int pOff) {
-        int pLen = pattern.length();
-        int sLen = s.length();
-
-        while (true) {
-            if (pOff >= pLen) {
-                if (sOff >= sLen) {
-                    return true;
-                } else if (s.charAt(sOff) == '[') {
-                    // check for subscript notation (e.g. "whatever[1]")
-
-                    // the entire pattern matched up to the subscript:
-                    // -> ignore the subscript
-                    return true;
-                } else {
-                    return false;
-                }
-            }
-            if (sOff >= sLen && pattern.charAt(pOff) != WILDCARD_CHAR) {
-                return false;
-            }
-
-            // check for a '*' as the next pattern char;
-            // this is handled by a recursive call for
-            // each postfix of the name.
-            if (pattern.charAt(pOff) == WILDCARD_CHAR) {
-                if (++pOff >= pLen) {
-                    return true;
-                }
-
-                while (true) {
-                    if (internalMatches(s, pattern, sOff, pOff)) {
-                        return true;
-                    }
-                    if (sOff >= sLen) {
-                        return false;
-                    }
-                    sOff++;
-                }
-            }
-
-            if (pOff < pLen && sOff < sLen) {
-                if (pattern.charAt(pOff) != s.charAt(sOff)) {
-                    return false;
-                }
-            }
-            pOff++;
-            sOff++;
-        }
+        return ItemNameMatcher.matches(name, nameGlobs);

MOV26 UPD40 INS78 INS78 INS8 INS42 INS42 INS65 INS41 INS41 UPD66 MOV66 INS65 UPD66 MOV66 INS32 UPD66 UPD66 INS32 INS68 INS42 UPD42 MOV42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 MOV42 INS42 INS42 INS42 MOV69 INS69 INS42 INS69 INS43 INS43 INS43 MOV42 INS42 INS42 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL66 DEL65 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL9 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL34 DEL34 DEL32 DEL9 DEL41 DEL8 DEL25 DEL8 DEL61 DEL9 DEL41 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL43 DEL85 DEL5 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL34 DEL34 DEL32 DEL9 DEL41 DEL8 DEL25 DEL8 DEL24 DEL9 DEL41 DEL8 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL9 DEL42 DEL42 DEL27 DEL42 DEL42 DEL27 DEL9 DEL41 DEL8 DEL42 DEL42 DEL42 DEL32 DEL13 DEL27 DEL9 DEL41 DEL8 DEL9 DEL41 DEL8 DEL25 DEL25 DEL8 DEL25 DEL42 DEL42 DEL27 DEL42 DEL42 DEL42 DEL32 DEL42 DEL27 DEL27 DEL9 DEL41 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL42 DEL27 DEL42 DEL38 DEL42 DEL27 DEL9 DEL41 DEL8 DEL25 DEL9 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL9 DEL41 DEL8 DEL25 DEL42 DEL42 DEL27 DEL9 DEL41 DEL8 DEL25 DEL42 DEL37 DEL21 DEL8 DEL61 DEL8 DEL25 DEL42 DEL42 DEL27 DEL42 DEL42 DEL27 DEL27 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL27 DEL9 DEL41 DEL8 DEL25 DEL8 DEL25 DEL42 DEL37 DEL21 DEL42 DEL37 DEL21 DEL8 DEL61 DEL8 DEL31
JCR-2874: Locked helper class improvements

Patch by Alex Parvulescu
Also fixed a few typos and whitespace issues

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1070916 13f79535-47bb-0310-9956-ffa450edef68

+import javax.jcr.lock.LockManager;
-        return with(lockable, isDeep, Long.MAX_VALUE);
+        return with(lockable, isDeep, true);
+    }
+
+    /**
+     * Executes {@link #run} while the lock on <code>lockable</code> is held.
+     * This method will block until {@link #run} is executed while holding the
+     * lock on node <code>lockable</code>.
+     *
+     * @param lockable a lockable node.
+     * @param isDeep   <code>true</code> if <code>lockable</code> will be locked
+     *                 deep.
+     * @param isSessionScoped <code>true</code> if the lock is session scoped.
+     * @return the object returned by {@link #run}.
+     * @throws IllegalArgumentException if <code>lockable</code> is not
+     *      <i>mix:lockable</i>.
+     * @throws RepositoryException  if {@link #run} throws an exception.
+     * @throws InterruptedException if this thread is interrupted while waiting
+     *                              for the lock on node <code>lockable</code>.
+     */
+    public Object with(Node lockable, boolean isDeep, boolean isSessionScoped)
+            throws RepositoryException, InterruptedException {
+        return with(lockable, isDeep, Long.MAX_VALUE, isSessionScoped);
-     * @param timeout  time in milliseconds to wait at most to aquire the lock.
+     * @param timeout  time in milliseconds to wait at most to acquire the lock.
-     *         lock on <code>lockable</code> could not be aquired within the
+     *         lock on <code>lockable</code> could not be acquired within the
+        return with(lockable, isDeep, timeout, true);
+    }
+
+    /**
+     * Executes the method {@link #run} within the scope of a lock held on
+     * <code>lockable</code>.
+     *
+     * @param lockable the node where the lock is obtained from.
+     * @param isDeep   <code>true</code> if <code>lockable</code> will be locked
+     *                 deep.
+     * @param timeout  time in milliseconds to wait at most to acquire the lock.
+     * @param isSessionScoped <code>true</code> if the lock is session scoped.
+     * @return the object returned by {@link #run} or {@link #TIMED_OUT} if the
+     *         lock on <code>lockable</code> could not be acquired within the
+     *         specified timeout.
+     * @throws IllegalArgumentException if <code>timeout</code> is negative or
+     *                                  <code>lockable</code> is not
+     *                                  <i>mix:lockable</i>.
+     * @throws RepositoryException      if {@link #run} throws an exception.
+     * @throws UnsupportedRepositoryOperationException
+     *                                  if this repository does not support
+     *                                  locking.
+     * @throws InterruptedException     if this thread is interrupted while
+     *                                  waiting for the lock on node
+     *                                  <code>lockable</code>.
+     */
+    public Object with(Node lockable, boolean isDeep, long timeout, boolean isSessionScoped)
+            throws UnsupportedRepositoryOperationException, RepositoryException, InterruptedException {
-            Lock lock = tryLock(lockable, isDeep);
+            Lock lock = tryLock(lockable, isDeep, timeout, isSessionScoped);
-            // now keep trying to aquire the lock
+            // now keep trying to acquire the lock
-                    lock = tryLock(lockable, isDeep);
+                    lock = tryLock(lockable, isDeep, timeout, isSessionScoped);
+        Node node = lock.getNode();
-            return run(lock.getNode());
+            return run(node);
-            lock.getNode().unlock();
+            node.getSession().getWorkspace().getLockManager().unlock(node.getPath());
-     * Tries to aquire a session scoped lock on <code>lockable</code>.
+     * Tries to acquire a session scoped lock on <code>lockable</code>.
+     * @param timeout  time in milliseconds to wait at most to acquire the lock.
+     * @param isSessionScoped <code>true</code> if the lock is session scoped.
-    private static Lock tryLock(Node lockable, boolean isDeep)
+    private static Lock tryLock(Node lockable, boolean isDeep, long timeout, boolean isSessionScoped)
-            return lockable.lock(isDeep, true);
+            LockManager lm = lockable.getSession().getWorkspace().getLockManager();
+            return lm.lock(lockable.getPath(), isDeep, isSessionScoped, timeout, null);

INS26 INS40 INS31 INS31 INS29 INS83 INS43 INS42 INS44 INS44 INS44 INS43 INS43 INS8 MOV29 INS83 INS43 INS42 INS44 INS44 INS44 INS43 INS43 INS43 INS8 INS29 INS44 INS44 INS44 INS65 INS65 MOV65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS39 INS42 INS39 INS42 INS42 INS42 INS41 INS65 INS42 INS43 INS42 INS39 INS42 INS39 INS42 INS42 INS42 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS39 INS42 INS60 INS65 INS65 INS39 INS42 INS39 INS42 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS42 INS66 INS42 INS66 INS66 MOV65 INS66 INS42 INS66 INS66 INS42 INS66 INS65 INS66 INS42 INS66 INS66 INS42 INS32 INS42 INS66 INS66 UPD66 INS65 UPD66 INS42 INS32 INS66 INS65 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS65 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS66 INS43 INS59 UPD66 INS42 INS66 INS42 INS66 INS9 INS67 INS67 INS67 INS42 INS42 INS42 INS40 INS42 INS67 INS42 INS42 INS42 INS42 INS9 INS67 INS67 INS67 INS67 INS42 INS42 MOV32 INS60 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS42 INS32 INS32 INS42 INS42 INS32 UPD42 INS32 INS42 INS42 INS33 INS42 INS42 MOV32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 UPD42 INS32 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 DEL40 DEL9
JCR-1138 Data store garbage collection: use IterablePersistenceManager if possible

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@604872 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.NodeId;
+import org.apache.jackrabbit.core.PropertyId;
+import org.apache.jackrabbit.core.SessionImpl;
+import org.apache.jackrabbit.core.persistence.IterablePersistenceManager;
+import org.apache.jackrabbit.core.state.ItemStateException;
+import org.apache.jackrabbit.core.state.NodeState;
+import org.apache.jackrabbit.core.state.PropertyState;
+import org.apache.jackrabbit.core.value.InternalValue;
+import org.apache.jackrabbit.spi.Name;
+import java.util.Iterator;
+import java.util.Set;
-    private final ScanEventListener callback;
+    private ScanEventListener callback;
-    private final int sleepBetweenNodes;
+    private int sleepBetweenNodes;
-    private DataStore store;
+    private final DataStore store;
-    private ArrayList listeners = new ArrayList();
+    private final ArrayList listeners = new ArrayList();
+
+    private final IterablePersistenceManager[] pmList;
+    
+    private final Session[] sessionList;
-    // TODO It may be possible to delete files early, see rememberNode()
-     * To display the progress, a callback object may be used.
+     * This method is usually not called by the application, it is called
+     * by SessionImpl.createDataStoreGarbageCollector().
-     * @param callback if set, this is called while scanning
-     * @param sleepBetweenNodes the number of milliseconds to sleep in the main scan loop (0 if the scan should run at full speed)
+     * @param list the persistence managers
-    public GarbageCollector(ScanEventListener callback, int sleepBetweenNodes) {
-        this.sleepBetweenNodes = sleepBetweenNodes;
-        this.callback = callback;
+    public GarbageCollector(SessionImpl session, IterablePersistenceManager[] list, Session[] sessionList) {
+        RepositoryImpl rep = (RepositoryImpl) session.getRepository();
+        store = rep.getDataStore();
+        this.pmList = list;
+        this.sessionList = sessionList;
+    }
+
+    /**
+     * Set the delay between scanning items.
+     * The main scan loop sleeps this many milliseconds after
+     * scanning a node. The default is 0, meaning the scan should run at full speed.
+     * 
+     * @param sleepBetweenNodes the number of milliseconds to sleep 
+     */
+    public void setSleepBetweenNodes(int millis) {
+        this.sleepBetweenNodes = millis;
+    
+    /**
+     * Set the event listener. If set, the event listener will be called 
+     * for each item that is scanned. This mechanism can be used
+     * to display the progress.
+     * 
+     * @param callback if set, this is called while scanning
+     */
+    public void setScanEventListener(ScanEventListener callback) {
+        this.callback = callback;
+    }
-    public void scan(Session session) throws RepositoryException,
-            IllegalStateException, IOException {
+    /**
+     * Scan the repository.
+     * 
+     * @throws RepositoryException
+     * @throws IllegalStateException
+     * @throws IOException
+     * @throws ItemStateException 
+     */
+    public void scan() throws RepositoryException,
+            IllegalStateException, IOException, ItemStateException {
-            RepositoryImpl rep = (RepositoryImpl) session.getRepository();
-            store = rep.getDataStore();
+        
+        if (pmList == null) {
+            for (int i = 0; i < sessionList.length; i++) {
+                scanNodes(sessionList[i]);
+            }
+        } else {
+            scanPersistenceManagers();
+        }
+    }
+    
+    private void scanNodes(Session session) throws UnsupportedRepositoryOperationException, RepositoryException, IllegalStateException, IOException {
+    
+    private void scanPersistenceManagers() throws ItemStateException, RepositoryException {
+        for (int i = 0; i < pmList.length; i++) {
+            IterablePersistenceManager pm = pmList[i];
+            Iterator it = pm.getAllNodeIds(null, 0);
+            while (it.hasNext()) {
+                NodeId id = (NodeId) it.next();
+                NodeState state = pm.load(id);
+                Set propertyNames = state.getPropertyNames();
+                for (Iterator nameIt = propertyNames.iterator(); nameIt
+                        .hasNext();) {
+                    Name name = (Name) nameIt.next();
+                    PropertyId pid = new PropertyId(id, name);
+                    PropertyState ps = pm.load(pid);
+                    if (ps.getType() == PropertyType.BINARY) {
+                        InternalValue[] values = ps.getValues();
+                        for (int j = 0; j < values.length; j++) {
+                            values[j].getBLOBFileValue().getLength();
+                        }
+                    }
+                }
+            }
+        }
+    }
+        // TODO It may be possible to delete some items early

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV31 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS23 INS31 INS31 INS31 INS31 MOV83 INS39 MOV59 INS83 INS83 INS83 MOV83 INS5 INS59 INS83 INS83 INS5 INS59 INS29 INS83 INS42 INS44 INS44 INS44 MOV8 INS29 INS83 INS39 INS42 INS44 MOV8 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS43 INS43 INS43 INS43 INS8 UPD83 UPD42 INS43 INS83 INS39 INS42 INS43 INS43 INS8 INS43 INS85 INS42 INS43 INS85 INS42 INS65 INS65 INS43 INS42 INS5 INS42 INS5 INS42 INS21 INS21 INS65 INS65 INS39 INS42 MOV21 INS65 INS65 INS65 INS65 INS65 INS42 INS42 INS42 INS42 MOV60 MOV25 INS25 INS42 INS42 INS42 INS24 INS42 INS42 INS66 INS66 INS66 INS42 INS66 INS42 INS43 INS85 INS43 INS85 INS7 INS7 INS66 INS66 INS66 INS42 INS66 UPD66 INS66 UPD66 INS66 INS42 INS42 INS42 INS42 INS66 INS8 INS27 INS8 INS8 INS58 INS27 INS37 INS8 INS42 INS42 INS22 INS42 INS22 INS42 UPD42 MOV21 MOV21 INS42 INS33 INS24 INS21 INS39 INS59 INS42 INS40 INS42 INS60 INS60 INS61 INS52 INS42 INS52 INS42 INS58 INS27 INS37 INS8 INS32 INS42 INS34 INS43 INS59 INS43 INS59 INS32 INS8 INS39 INS59 INS42 INS40 INS42 INS21 INS42 INS42 INS42 INS2 INS42 INS42 INS32 INS42 INS42 INS60 INS60 INS60 INS24 INS42 INS34 INS32 INS42 INS42 INS42 INS42 INS33 INS34 INS43 INS59 INS43 INS59 INS43 INS59 INS58 INS32 INS8 INS42 INS2 INS42 INS42 INS11 INS42 INS42 INS32 INS42 INS42 INS32 INS43 INS59 INS42 INS42 INS60 INS60 INS60 INS25 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS59 INS43 INS59 INS43 INS59 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS14 INS42 INS42 INS32 INS32 INS40 INS60 INS24 INS43 INS32 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS5 INS59 INS58 INS27 INS37 INS8 INS42 INS42 INS42 INS42 INS43 INS85 INS42 INS32 INS39 INS59 INS42 INS40 INS42 INS21 INS42 INS42 INS42 INS42 INS34 INS32 INS32 INS42 INS2 INS42 INS42 INS42 DEL83 DEL39 DEL23 DEL42 DEL66 DEL65 DEL42 DEL39 DEL42 DEL44
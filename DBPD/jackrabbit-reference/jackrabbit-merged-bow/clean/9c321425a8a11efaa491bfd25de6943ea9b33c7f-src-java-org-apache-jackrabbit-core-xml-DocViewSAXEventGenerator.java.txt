reimplemented Session.export* according to latest spec

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@151373 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.core.state.ItemStateManager;
-import org.apache.jackrabbit.core.state.NodeState;
-import org.apache.jackrabbit.core.state.PropertyState;
+import org.apache.jackrabbit.core.util.ISO9075;
+import org.apache.jackrabbit.core.util.Text;
-import org.apache.xerces.util.XMLChar; 
-import javax.jcr.InvalidSerializedDataException;
+import javax.jcr.Value;
-    protected final HierarchyManager hierMgr;
-
-     * @param nodeState      the node state which should be serialized
-     * @param nodeName       name of the node to be serialized
-     * @param noRecurse      if true, only <code>nodeState</code> and its properties will
+     * @param node           the node state which should be serialized
+     * @param noRecurse      if true, only <code>node</code> and its properties will
-     *                       <code>nodeState</code> will be serialized.
-     * @param binaryAsLink   specifies if binary properties are turned into links
-     * @param stateProvider  item state provider for retrieving child item state
-     * @param nsReg          the namespace registry to be used for namespace declarations
-     * @param accessMgr      the access manager
-     * @param hierMgr        the hierarchy manager used to resolve paths
+     *                       <code>node</code> will be serialized.
+     * @param skipBinary     flag governing whether binary properties are to be serialized.
+     * @param session        the session to be used for resolving namespace mappings
-    public DocViewSAXEventGenerator(NodeState nodeState, QName nodeName,
-                                    boolean noRecurse, boolean binaryAsLink,
-                                    ItemStateManager stateProvider,
-                                    NamespaceRegistryImpl nsReg,
-                                    AccessManagerImpl accessMgr,
-                                    HierarchyManager hierMgr,
+    public DocViewSAXEventGenerator(NodeImpl node, boolean noRecurse,
+                                    boolean skipBinary,
+                                    SessionImpl session,
-        super(nodeState, nodeName, noRecurse, binaryAsLink,
-                stateProvider, nsReg, accessMgr, contentHandler);
-        this.hierMgr = hierMgr;
+        super(node, noRecurse, skipBinary, session, contentHandler);
-     * @see AbstractSAXEventGenerator#entering(NodeState, QName, int)
+     * @see AbstractSAXEventGenerator#entering(NodeImpl, int)
-    protected void entering(NodeState state, QName name, int level)
+    protected void entering(NodeImpl node, int level)
-     * @see AbstractSAXEventGenerator#enteringProperties(NodeState, QName, int)
+     * @see AbstractSAXEventGenerator#enteringProperties(NodeImpl, int)
-    protected void enteringProperties(NodeState state, QName name, int level)
+    protected void enteringProperties(NodeImpl node, int level)
-     * @see AbstractSAXEventGenerator#leavingProperties(NodeState, QName, int)
+     * @see AbstractSAXEventGenerator#leavingProperties(NodeImpl, int)
-    protected void leavingProperties(NodeState state, QName name, int level)
+    protected void leavingProperties(NodeImpl node, int level)
+        QName name = node.getQName();
-                PropertyState propState = (PropertyState) iter.next();
-                QName propName = propState.getName();
+                PropertyImpl prop = (PropertyImpl) iter.next();
+                QName propName = prop.getQName();
-                    InternalValue val = propState.getValues()[0];
-                    char[] chars = val.toJCRValue(nsReg).getString().toCharArray();
+                    // assume jcr:xmlcharacters is single-valued
+                    char[] chars = prop.getValue().getString().toCharArray();
+            // encode node name to make sure it's a valid xml name
+            name = ISO9075.encode(name);
-                if (state.getParentUUIDs().size() == 0) {
+                if (node.isRepositoryRoot()) {
-                    elemName = NODENAME_ROOT.toJCRName(nsReg);
+                    elemName = NODENAME_ROOT.toJCRName(session.getNamespaceResolver());
-                    elemName = name.toJCRName(nsReg);
+                    elemName = name.toJCRName(session.getNamespaceResolver());
-            if (!XMLChar.isValidName(elemName)) {
-                throw new InvalidSerializedDataException("the node name is not a valid xml element name: " + elemName);
-            }
-                PropertyState propState = (PropertyState) iter.next();
-                QName propName = propState.getName();
+                PropertyImpl prop = (PropertyImpl) iter.next();
+                if (prop.getType() == PropertyType.BINARY && skipBinary) {
+                    continue;
+                }
+                QName propName = prop.getQName();
+                // encode property name to make sure it's a valid xml name
+                propName = ISO9075.encode(propName);
-                    attrName = propName.toJCRName(nsReg);
+                    attrName = propName.toJCRName(session.getNamespaceResolver());
-                if (!XMLChar.isValidName(attrName)) {
-                    throw new InvalidSerializedDataException("the property name is not a valid xml attribute name: " + attrName);
-                }
-                String attrValue;
-                int type = propState.getType();
-                // process property value (guaranteed to be single-valued and non-null)
-                InternalValue val = propState.getValues()[0];
-                if (type == PropertyType.BINARY) {
-                    if (binaryAsLink) {
-                        try {
-                            attrValue = hierMgr.getPath(new PropertyId(propState.getParentUUID(), propState.getName())).toJCRPath(nsReg);
-                        } catch (NoPrefixDeclaredException npde) {
-                            // should never get here...
-                            String msg = "internal error: encountered unregistered namespace";
-                            log.debug(msg);
-                            throw new RepositoryException(msg, npde);
-                        }
-                    } else {
+                StringBuffer attrValue = new StringBuffer();
+                // process property value(s)
+                boolean multiValued = prop.getDefinition().isMultiple();
+                Value[] vals;
+                if (multiValued) {
+                    vals = prop.getValues();
+                } else {
+                    vals = new Value[]{prop.getValue()};
+                }
+                for (int i = 0; i < vals.length; i++) {
+                    if (i > 0) {
+                        // use space as delimiter for multi-valued properties
+                        attrValue.append(" ");
+                    }
+                    Value val = vals[i];
+                    String textVal;
+                    if (prop.getType() == PropertyType.BINARY) {
-                        BLOBFileValue blob = (BLOBFileValue) val.internalValue();
-                        InputStream in = blob.getStream();
+                        InputStream in = val.getStream();
-                            in.close();
-                            writer.close();
+                            // no need to close StringWriter
+                            //writer.close();
+                        } finally {
+                            try {
+                                in.close();
+                            } catch (IOException e) {
+                                // ignore
+                            }
-                        attrValue = writer.toString();
+                        textVal = writer.toString();
+                    } else {
+                        textVal = val.getString();
-                } else {
-                    attrValue = val.toJCRValue(nsReg).getString();
+                    // enocde spaces in value
+                    textVal = Text.replace(textVal, " ", "_x0020_");
+                    attrValue.append(textVal);
-                attrs.addAttribute(propName.getNamespaceURI(), propName.getLocalName(), attrName, CDATA_TYPE, attrValue);
+                attrs.addAttribute(propName.getNamespaceURI(), propName.getLocalName(), attrName, CDATA_TYPE, attrValue.toString());
-     * @see AbstractSAXEventGenerator#leaving(NodeState, QName, int)
+     * @see AbstractSAXEventGenerator#leaving(NodeImpl, int)
-    protected void leaving(NodeState state, QName name, int level)
+    protected void leaving(NodeImpl node, int level)
+        QName name = node.getQName();
-            // (already processed in leavingProperties(NodeState, QName, int)
+            // (already processed in leavingProperties(NodeImpl, int)
-            if (state.getParentUUIDs().size() == 0) {
+            if (node.isRepositoryRoot()) {
-                elemName = NODENAME_ROOT.toJCRName(nsReg);
+                elemName = NODENAME_ROOT.toJCRName(session.getNamespaceResolver());
-                elemName = name.toJCRName(nsReg);
+                elemName = name.toJCRName(session.getNamespaceResolver());
-     * @see AbstractSAXEventGenerator#entering(PropertyState, int)
+     * @see AbstractSAXEventGenerator#entering(PropertyImpl, int)
-    protected void entering(PropertyState state, int level)
+    protected void entering(PropertyImpl prop, int level)
-        // @todo should properties declared in the 'jcr:' namespace be skipped in the document view export?
-/*
-	// skip 'system' properties (e.g. jcr:primaryType, jcr:mixinTypes, jcr:uuid)
-	if (NamespaceRegistryImpl.NS_JCR_URI.equals(state.getName().getNamespaceURI())) {
-	    return;
-	}
-*/
-        // collect property state in temporary list (will be processed in leavingProperties(NodeState, QName, int)
-        InternalValue[] values = state.getValues();
-        if (values != null && values.length > 0) {
-            if (values.length != 1) {
-                throw new InvalidSerializedDataException("unable to serialize multi-valued property in document view: " + state.getName().getLocalName());
-            }
-            if (values[0] != null) {
-                props.add(state);
-            }
-        }
+        props.add(prop);
-     * @see AbstractSAXEventGenerator#leaving(PropertyState, int)
+     * @see AbstractSAXEventGenerator#leaving(PropertyImpl, int)
-    protected void leaving(PropertyState state, int level)
+    protected void leaving(PropertyImpl prop, int level)

MOV26 MOV26 UPD40 UPD40 UPD40 MOV8 MOV44 MOV43 MOV43 INS8 MOV44 MOV43 MOV43 UPD43 UPD42 UPD42 UPD43 UPD42 UPD43 UPD42 UPD43 UPD42 UPD43 UPD42 INS60 INS25 UPD43 UPD42 INS60 UPD43 UPD42 MOV21 UPD43 UPD42 UPD42 UPD66 UPD66 UPD66 UPD42 UPD66 UPD42 UPD66 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV43 INS59 MOV32 MOV8 MOV8 UPD42 MOV43 INS59 UPD42 UPD42 MOV69 MOV69 INS42 INS32 INS21 MOV60 MOV60 MOV60 INS61 MOV21 INS42 INS32 MOV69 UPD42 MOV69 UPD43 UPD43 UPD43 UPD42 MOV42 UPD42 MOV42 INS7 INS8 MOV32 INS8 UPD43 INS42 INS42 INS32 UPD43 UPD43 UPD42 UPD42 UPD42 INS42 INS32 INS25 MOV60 INS25 MOV60 INS21 MOV60 MOV54 INS60 MOV60 INS60 INS25 INS24 MOV21 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD43 MOV43 INS42 INS42 INS42 INS32 INS8 INS8 UPD43 INS27 INS8 INS7 INS8 INS43 INS59 UPD39 INS5 INS59 INS42 INS8 INS8 INS58 INS27 INS37 MOV8 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS42 INS42 INS21 MOV21 UPD42 UPD42 INS27 INS42 INS18 INS42 INS32 MOV21 UPD42 MOV42 INS42 INS14 UPD42 INS32 INS43 INS85 UPD42 MOV42 INS21 INS21 INS39 INS59 UPD42 MOV42 UPD40 MOV40 INS42 INS25 INS60 MOV60 INS21 INS21 INS32 UPD43 UPD42 UPD42 INS7 UPD43 INS32 INS40 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS43 INS32 INS42 UPD42 MOV42 INS7 INS7 INS42 INS34 INS27 INS8 INS43 INS59 INS27 INS8 INS7 INS32 MOV42 INS42 INS32 INS32 UPD42 INS42 INS32 UPD42 UPD42 INS42 INS42 UPD42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS42 INS3 INS42 INS34 INS21 INS42 INS42 INS2 UPD42 INS32 INS40 MOV21 INS42 INS32 INS42 INS42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS32 UPD42 INS32 UPD42 INS32 UPD42 MOV42 MOV42 INS5 INS4 INS32 INS42 INS42 INS42 INS42 INS8 INS42 INS42 INS42 INS45 INS45 INS42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS43 INS85 INS32 INS42 INS42 INS45 INS54 UPD42 UPD42 INS32 UPD42 UPD42 INS42 INS42 INS42 UPD42 INS8 INS12 UPD42 MOV42 UPD42 MOV42 MOV21 INS44 INS8 INS43 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL43 DEL69 DEL42 DEL43 DEL42 DEL44 DEL69 DEL42 DEL43 DEL42 DEL44 DEL69 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL34 DEL2 DEL59 DEL60 DEL42 DEL8 DEL42 DEL42 DEL32 DEL42 DEL32 DEL34 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL8 DEL25 DEL8 DEL32 DEL42 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL32 DEL14 DEL32 DEL42 DEL42 DEL32 DEL32 DEL38 DEL43 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL43 DEL32 DEL34 DEL2 DEL59 DEL60 DEL27 DEL42 DEL32 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL38 DEL42 DEL43 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL61 DEL25 DEL8 DEL69 DEL42 DEL43 DEL42 DEL44 DEL32 DEL42 DEL32 DEL34 DEL27 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL40 DEL34 DEL27 DEL27 DEL40 DEL34 DEL27 DEL42 DEL43 DEL45 DEL42 DEL42 DEL32 DEL42 DEL32 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL34 DEL2 DEL33 DEL27 DEL8 DEL25 DEL8 DEL25 DEL8
JCR-2813: "overwriting cached entry" warnings

Use a currentlyLoading set instead of full synchronization to prevent two threads from concurrently loading the same item.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1038201 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.HashSet;
+     * Identifiers of the item states that are currently being loaded from
+     * the underlying persistence manager. Used exclusively by the
+     * {@link #getNonVirtualItemState(ItemId)} method to prevent two threads
+     * from concurrently loading the same items.
+     */
+    private final Set<ItemId> currentlyLoading = new HashSet<ItemId>();
+
+    /**
+        // First check if the item state is already in the cache
-        if (state == null) {
-            // not found in cache, load from persistent storage
-            state = loadItemState(id);
-            state.setStatus(ItemState.STATUS_EXISTING);
-            synchronized (this) {
-                // Use a double check to ensure that the cache entry is
-                // not created twice. We don't synchronize the entire
-                // method to allow the first cache retrieval to proceed
-                // even when another thread is loading a new item state.
-                ItemState cachedState = cache.retrieve(id);
-                if (cachedState == null) {
-                    // put it in cache
-                    cache.cache(state);
-                    // set parent container
-                    state.setContainer(this);
-                } else {
-                    state = cachedState;
+        if (state != null) {
+            return state;
+        }
+
+        // Wait if another thread is already loading this item state
+        synchronized (this) {
+            while (currentlyLoading.contains(id)) {
+                try {
+                    wait();
+                } catch (InterruptedException e) {
+                    throw new ItemStateException(
+                            "Interrupted while waiting for " + id, e);
+
+            state = cache.retrieve(id);
+            if (state != null) {
+                return state;
+            }
+
+            // No other thread has loaded the item state, so we'll do it
+            currentlyLoading.add(id);
-        return state;
+
+        try {
+            // Load the item state from persistent storage
+            // NOTE: This needs to happen outside a synchronized block!
+            state = loadItemState(id);
+            state.setStatus(ItemState.STATUS_EXISTING);
+            state.setContainer(this);
+
+            // put it in cache
+            cache.cache(state);
+
+            return state;
+        } finally {
+            // Notify other concurrent threads that we're done with this item
+            // NOTE: This needs to happen within the finally block!
+            synchronized (this) {
+                currentlyLoading.remove(id);
+                notifyAll();
+            }
+        }

INS26 INS40 INS23 INS29 INS83 INS83 INS74 INS59 INS65 INS43 INS43 INS42 INS14 INS25 MOV51 INS54 INS66 INS66 INS65 INS66 INS66 INS42 INS42 INS74 UPD27 MOV27 INS8 MOV8 MOV21 INS8 INS68 INS43 INS43 INS41 INS61 INS21 INS21 MOV21 MOV21 MOV41 INS51 INS42 INS69 INS42 INS42 INS42 INS32 INS8 INS7 UPD27 INS32 INS52 INS8 INS43 INS42 INS42 INS42 INS54 INS42 MOV32 UPD42 INS41 INS42 INS42 INS42 INS21 INS21 INS42 INS8 INS12 INS42 INS32 INS32 INS21 INS44 INS8 INS42 INS42 INS42 INS42 INS32 INS43 INS42 INS53 INS42 INS42 INS14 INS43 INS27 INS42 UPD42 MOV42 INS45 INS42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25
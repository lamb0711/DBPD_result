- removed @author and @version (i.e. $Revision & $Id) tags
- removed tab characters from java source code

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@47648 13f79535-47bb-0310-9956-ffa450edef68

- *
- * @author Stefan Guggisberg
- * @version $Revision: 1.20 $, $Date: 2004/08/02 16:19:48 $
-	super(overlayedState, initialStatus);
-	name = overlayedState.getName();
-	type = overlayedState.getType();
-	defId = overlayedState.getDefinitionId();
-	values = overlayedState.getValues();
+        super(overlayedState, initialStatus);
+        name = overlayedState.getName();
+        type = overlayedState.getType();
+        defId = overlayedState.getDefinitionId();
+        values = overlayedState.getValues();
-	super(parentUUID, new PropertyId(parentUUID, name), initialStatus);
-	this.name = name;
-	type = PropertyType.UNDEFINED;
-	values = new InternalValue[0];
+        super(parentUUID, new PropertyId(parentUUID, name), initialStatus);
+        this.name = name;
+        type = PropertyType.UNDEFINED;
+        values = new InternalValue[0];
-	return false;
+        return false;
-	return name;
+        return name;
-	this.type = type;
+        this.type = type;
-	return type;
+        return type;
-	return defId;
+        return defId;
-	this.defId = defId;
+        this.defId = defId;
-	this.values = values;
+        this.values = values;
-	return values;
+        return values;
-	// important: fields must be written in same order as they are
-	// read in readObject(ObjectInputStream)
-	out.writeObject(name);
-	out.writeInt(type);
-	if (values == null) {
-	    out.writeObject(null);
-	} else {
-	    String[] strings = new String[values.length];
-	    for (int i = 0; i < values.length; i++) {
-		InternalValue val = values[i];
-		try {
-		    if (type == PropertyType.BINARY) {
-			// special handling required for binary value
-			BLOBFileValue blob = (BLOBFileValue) val.internalValue();
-			InputStream in = blob.getStream();
-			// use 32k initial buffer size as binary data is
-			// probably not just a couple of bytes
-			StringWriter writer = new StringWriter(32768);
-			try {
-			    Base64.encode(in, writer);
-			} finally {
-			    in.close();
-			    writer.close();
-			}
-			strings[i] = writer.toString();
-		    } else {
-			strings[i] = val.toString();
-		    }
-		} catch (IllegalStateException ise) {
-		    throw new IOException(ise.getMessage());
-		} catch (RepositoryException re) {
-		    throw new IOException(re.getMessage());
-		}
-	    }
-	    out.writeObject(strings);
-	}
+        // important: fields must be written in same order as they are
+        // read in readObject(ObjectInputStream)
+        out.writeObject(name);
+        out.writeInt(type);
+        if (values == null) {
+            out.writeObject(null);
+        } else {
+            String[] strings = new String[values.length];
+            for (int i = 0; i < values.length; i++) {
+                InternalValue val = values[i];
+                try {
+                    if (type == PropertyType.BINARY) {
+                        // special handling required for binary value
+                        BLOBFileValue blob = (BLOBFileValue) val.internalValue();
+                        InputStream in = blob.getStream();
+                        // use 32k initial buffer size as binary data is
+                        // probably not just a couple of bytes
+                        StringWriter writer = new StringWriter(32768);
+                        try {
+                            Base64.encode(in, writer);
+                        } finally {
+                            in.close();
+                            writer.close();
+                        }
+                        strings[i] = writer.toString();
+                    } else {
+                        strings[i] = val.toString();
+                    }
+                } catch (IllegalStateException ise) {
+                    throw new IOException(ise.getMessage());
+                } catch (RepositoryException re) {
+                    throw new IOException(re.getMessage());
+                }
+            }
+            out.writeObject(strings);
+        }
-	// important: fields must be read in same order as they are
-	// written in writeObject(ObjectOutputStream)
-	name = (QName) in.readObject();
-	type = in.readInt();
-	Object obj = in.readObject();
-	if (obj == null) {
-	    values = null;
-	} else {
-	    String[] strings = (String[]) obj;
-	    values = new InternalValue[strings.length];
-	    for (int i = 0; i < strings.length; i++) {
-		String str = strings[i];
-		if (type == PropertyType.BINARY) {
-		    // special handling required for binary value
-		    ByteArrayOutputStream bos = new ByteArrayOutputStream(str.length());
-		    Base64.decode(str, bos);
-		    bos.close();
-		    values[i] = InternalValue.create(new ByteArrayInputStream(bos.toByteArray()));
-		} else {
-		    values[i] = InternalValue.valueOf(str, type);
-		}
-	    }
-	}
+        // important: fields must be read in same order as they are
+        // written in writeObject(ObjectOutputStream)
+        name = (QName) in.readObject();
+        type = in.readInt();
+        Object obj = in.readObject();
+        if (obj == null) {
+            values = null;
+        } else {
+            String[] strings = (String[]) obj;
+            values = new InternalValue[strings.length];
+            for (int i = 0; i < strings.length; i++) {
+                String str = strings[i];
+                if (type == PropertyType.BINARY) {
+                    // special handling required for binary value
+                    ByteArrayOutputStream bos = new ByteArrayOutputStream(str.length());
+                    Base64.decode(str, bos);
+                    bos.close();
+                    values[i] = InternalValue.create(new ByteArrayInputStream(bos.toByteArray()));
+                } else {
+                    values[i] = InternalValue.valueOf(str, type);
+                }
+            }
+        }

DEL66 DEL65 DEL66 DEL65
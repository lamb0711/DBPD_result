JCR-1438: Replace Config classes with factories

Reintroduced change from revision 826653:

Use generics in BeanConfig.newInstance() to avoid the need of class casts.

Use the standard java.beans classes instead of BeanMap for the configured bean properties. This allows better control over value types.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@829798 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.commons.collections.BeanMap;
+import java.beans.BeanInfo;
+import java.beans.IntrospectionException;
+import java.beans.Introspector;
+import java.beans.PropertyDescriptor;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+
-import java.util.Properties;
-import java.util.Map;
-import java.util.HashMap;
-import java.util.Collections;
-import java.io.InputStream;
-import java.io.IOException;
-
-public class BeanConfig<T> {
+public class BeanConfig {
-    public Object newInstance() throws ConfigurationException {
+    @SuppressWarnings("unchecked")
+    public <T> T newInstance(Class<T> klass) throws ConfigurationException {
-            // Instantiate the object using the default constructor
-            Object object = objectClass.newInstance();
+            if (!klass.isAssignableFrom(objectClass)) {
+                throw new ConfigurationException(
+                        "Configured class "+getClassName()
+                        + " does not implement " + klass.getName()
+                        + ". Please fix the repository configuration.");
+            }
+
+            // Instantiate the object using the default constructor
+            Object instance = objectClass.newInstance();
-            BeanMap map = new BeanMap(object);
-            for (Object key : map.keySet()) {
-                String value = properties.getProperty(key.toString());
+            List<?> names = Collections.list(properties.propertyNames());
+            BeanInfo info = Introspector.getBeanInfo(objectClass, Object.class);
+            for (PropertyDescriptor property : info.getPropertyDescriptors()) {
+                String value = properties.getProperty(property.getName());
-                    map.put(key, value);
+                    setProperty(instance, property, value);
+                    names.remove(property.getName());
-            if (validate) {
-                // Check that no invalid property names were configured
-                for (Object key : properties.keySet()) {
-                    if (!map.containsKey(key)
-                            && properties.getProperty(key.toString()) != null) {
-                        String msg =
-                            "Configured class " + object.getClass().getName()
-                            + " does not contain the property " + key
-                            + ". Please fix the repository configuration.";
-                        log.error(msg);
-                        throw new ConfigurationException(msg);
-                    }
-                }
+            // Check that no invalid property names were configured
+            if (validate && !names.isEmpty()) {
+                throw new ConfigurationException(
+                        "Configured class " + getClassName()
+                        + " does not contain the properties " + names);
-            return (T) object;
+            return (T) instance;
+        } catch (IntrospectionException e) {
+            throw new ConfigurationException(
+                    "Configured bean implementation class " + getClassName()
+                    + " can not be introspected", e);
+        }
+    }
+
+    private void setProperty(
+            Object instance, PropertyDescriptor property, String value)
+            throws ConfigurationException {
+        Method method = property.getWriteMethod();
+        if (method == null) {
+            throw new ConfigurationException(
+                    "Property " + property.getName() + " of class "
+                    + getClassName() + " can not be written"); 
+        }
+
+        Class<?>[] types = method.getParameterTypes();
+        if (types.length != 1) {
+            throw new ConfigurationException(
+                    "Property " + property.getName() + " of class "
+                    + getClassName() + " has an invalid setter");
+        }
+
+        Class<?> type = types[0];
+        try {
+            if (types[0].isAssignableFrom(String.class)
+                || types[0].isAssignableFrom(Object.class)) {
+                method.invoke(instance, value);
+            } else if (types[0].isAssignableFrom(Boolean.TYPE)
+                    || types[0].isAssignableFrom(Boolean.class)) {
+                method.invoke(instance, Boolean.valueOf(value));
+            } else if (types[0].isAssignableFrom(Integer.TYPE)
+                    || types[0].isAssignableFrom(Integer.class)) {
+                method.invoke(instance, Integer.valueOf(value));
+            } else if (types[0].isAssignableFrom(Long.TYPE)
+                    || types[0].isAssignableFrom(Long.class)) {
+                method.invoke(instance, Long.valueOf(value));
+            } else if (types[0].isAssignableFrom(Double.TYPE)
+                    || types[0].isAssignableFrom(Double.class)) {
+                method.invoke(instance, Double.valueOf(value));
+            } else {
+                throw new ConfigurationException(
+                        "The type (" + type.getName()
+                        + ") of property " + property.getName() + " of class "
+                        + getClassName() + " is not supported");
+            }
+        } catch (NumberFormatException e) {
+            throw new ConfigurationException(
+                    "Invalid number format (" + value + ") for property "
+                    + property.getName() + " of class " + getClassName(), e);
+        } catch (InvocationTargetException e) {
+            throw new ConfigurationException(
+                    "Property " + property.getName() + " of class "
+                    + getClassName() + " can not be set to \"" + value + "\"",
+                    e);
+        } catch (IllegalAccessException e) {
+            throw new ConfigurationException(
+                    "The setter of property " + property.getName()
+                    + " of class " + getClassName() + " can not be accessed",
+                    e);
+        } catch (IllegalArgumentException e) {
+            throw new ConfigurationException(
+                    "Unable to call the setter of property "
+                    + property.getName() + " of class " + getClassName(), e);

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS31 INS79 MOV73 INS43 INS44 INS83 INS39 INS42 MOV44 INS44 INS44 INS43 INS8 INS42 INS45 INS42 INS74 INS42 UPD42 INS43 INS42 MOV43 INS42 INS42 INS60 INS25 INS60 INS25 INS60 INS54 INS43 INS43 INS8 INS12 INS42 INS43 INS59 INS27 INS8 INS5 INS59 INS27 INS8 INS74 INS59 INS8 INS12 INS12 INS12 INS12 INS42 INS42 MOV60 INS25 MOV60 INS60 MOV60 INS70 INS25 MOV41 INS44 INS8 INS42 INS42 INS32 INS42 INS33 INS53 INS74 INS85 INS42 INS32 INS40 INS34 INS53 INS43 INS76 INS42 INS2 INS25 INS44 INS8 INS44 INS8 INS44 INS8 INS44 INS8 INS38 INS8 INS74 INS59 UPD43 INS44 MOV32 INS8 MOV27 INS8 INS43 INS42 MOV53 INS42 INS42 INS14 INS43 INS76 INS42 INS42 INS14 INS42 INS42 INS34 INS27 INS8 INS25 INS43 INS42 INS53 INS43 INS42 INS53 INS43 INS42 INS53 INS43 INS42 INS53 INS32 INS53 UPD42 INS43 INS76 INS42 INS32 UPD42 UPD42 INS32 INS43 INS42 UPD42 UPD42 MOV60 INS25 INS42 INS53 UPD42 INS42 INS43 INS27 INS42 INS43 INS27 INS32 INS32 INS21 INS27 INS8 INS25 INS42 INS14 INS42 INS14 INS42 INS14 INS42 INS14 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS57 INS42 MOV43 MOV27 INS8 INS14 INS43 INS27 INS42 INS42 INS45 INS32 INS45 INS32 INS45 INS42 INS45 INS32 INS45 INS32 INS45 INS2 INS42 INS57 INS2 INS42 INS57 INS32 INS32 INS32 INS21 INS27 INS8 INS25 INS43 INS27 INS42 INS43 INS27 INS42 INS43 INS27 INS42 INS43 INS27 INS42 INS43 INS27 INS42 INS42 MOV43 MOV21 INS21 UPD42 UPD42 MOV43 INS27 INS42 INS45 INS32 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS43 INS42 INS34 MOV43 INS42 INS42 INS42 INS42 INS2 INS42 INS40 INS2 INS42 INS57 INS32 INS32 INS32 INS21 INS27 INS8 INS25 INS42 INS45 INS42 INS45 INS32 INS45 INS32 INS42 INS45 INS32 INS45 INS32 INS45 INS42 INS45 INS42 INS45 INS32 INS45 INS32 INS45 INS42 INS45 INS32 INS45 INS32 INS42 INS45 INS32 INS45 INS32 INS45 INS32 MOV45 INS32 UPD45 MOV45 UPD42 MOV42 INS42 INS42 INS42 INS34 INS42 INS34 INS43 INS42 INS42 INS42 INS32 INS2 INS42 INS40 INS2 INS42 INS57 INS32 INS32 INS32 INS21 INS27 INS8 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS32 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS34 INS43 INS42 INS42 INS42 INS32 INS2 INS42 INS40 INS2 INS42 INS57 INS32 INS32 INS32 INS21 INS53 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS34 INS43 INS42 INS42 INS42 INS32 INS2 INS42 INS40 INS2 INS42 INS57 INS32 INS14 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS34 INS43 INS42 INS42 INS42 INS32 INS43 INS27 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS45 INS32 INS45 INS32 INS45 INS42 INS42 INS42 INS42 INS42 DEL42 DEL43 DEL42 DEL14 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL33 DEL27 DEL8 DEL25 DEL8 DEL70 DEL42 DEL42 DEL44 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL8 DEL25 DEL8 DEL42
JCR-2762: Optimize bundle serialization

Introduce bundle serialization version 3 that uses a fixed list of known names and namespaces to more efficiently store commonly used names. See BundleWriter.writeName() for a detailed description of the name serialization format.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1022485 13f79535-47bb-0310-9956-ffa450edef68

-        // primaryType and version
-        Name type = bundle.getNodeTypeName();
-        int index = binding.nsIndex.stringToIndex(type.getNamespaceURI());
-        out.writeByte(index >>> 16);
-        out.writeByte(index >>> 8);
-        out.writeByte(index);
-        out.writeInt(binding.nameIndex.stringToIndex(type.getLocalName()));
+        // primaryType
+        writeName(bundle.getNodeTypeName());
-            writeIndexedQName(name);
+            writeName(name);
-        writeIndexedQName(null);
+        writeName(null);
-                writeIndexedQName(pName);
+                writeName(pName);
-        writeIndexedQName(null);
+        writeName(null);
-            writeQName(entry.getName());   // name
+            writeName(entry.getName());   // name
-                        writeQName(val.getName());
+                        writeName(val.getName());
-     * Serializes a Name
+     * Serializes a name. The name encoding works as follows:
+     * <p>
+     * First; if the name is known by the {@link BundleNames} class (this
+     * includes the <code>null</code> name), then the name is serialized
+     * as a single byte using the following format.
+     * <pre>
+     * +-------------------------------+
+     * | 0 |    common name index      |
+     * +-------------------------------+
+     * </pre>
+     * <p>
+     * Second; if the name is not known, it gets serialized as a
+     * variable-length field whose first byte looks like this:
+     * <pre>
+     * +-------------------------------+
+     * | 1 | ns index  |  name length  |
+     * +-------------------------------+
+     * </pre>
+     * <p>
+     * The three-bit namespace index identifies either a known namespace
+     * in the {@link BundleNames} class (values 0 - 6) or an explicit
+     * namespace URI string that is written using
+     * {@link DataOutputStream#writeUTF(String)} right after this byte
+     * (value 7).
+     * <p>
+     * The four-bit name length field indicates the length (in UTF-8 bytes)
+     * of the local part of the name. Since zero-length local names are not
+     * allowed, the length is first decremented by one before storing in this
+     * field. The UTF-8 byte sequence is written out after this byte and the
+     * possible namespace URI string. If the length of the local name is
+     * larger than 15 (i.e. would be stored as 0x0f or more), then the value
+     * 0x0f is stored as the name length and the name string is written
+     * using {@link DataOutputStream#writeUTF(String)}.
-    private void writeQName(Name name) throws IOException {
-        out.writeInt(binding.nsIndex.stringToIndex(name.getNamespaceURI()));
-        out.writeUTF(name.getLocalName());
-    }
-
-    /**
-     * Serializes a indexed Name
-     *
-     * @param name the name
-     * @throws IOException in an I/O error occurs.
-     */
-    private void writeIndexedQName(Name name) throws IOException {
-        if (name == null) {
-            out.writeInt(-1);
+    private void writeName(Name name) throws IOException {
+        int index = BundleNames.nameToIndex(name);
+        if (index != -1) {
+            assert 0 <= index && index < 0x80;
+            out.writeByte(index);
-            out.writeInt(binding.nsIndex.stringToIndex(name.getNamespaceURI()));
-            out.writeInt(binding.nameIndex.stringToIndex(name.getLocalName()));
+            String uri = name.getNamespaceURI();
+            int ns = BundleNames.namespaceToIndex(uri) & 0x07;
+
+            String local = name.getLocalName();
+            byte[] bytes = local.getBytes("UTF-8");
+            int len = Math.min(bytes.length - 1, 0x0f);
+
+            out.writeByte(0x80 | ns << 4 | len);
+            if (ns == 0x07) {
+                out.writeUTF(uri);
+            }
+            if (len != 0x0f) {
+                out.write(bytes);
+            } else {
+                out.writeUTF(local);
+            }

INS31 MOV21 MOV21 MOV29 MOV83 MOV39 UPD42 MOV42 MOV44 MOV43 INS8 INS60 INS25 UPD66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS39 INS59 INS27 INS8 INS8 UPD42 MOV32 UPD42 UPD42 INS42 INS42 INS68 INS68 INS42 INS32 INS42 MOV38 INS6 MOV21 INS60 INS60 INS60 INS60 INS60 INS21 INS25 INS25 INS42 INS42 INS69 INS42 INS42 INS69 INS42 INS42 INS42 INS27 INS43 INS59 INS39 INS59 INS43 INS59 INS5 INS59 INS39 INS59 INS32 MOV27 MOV8 INS27 INS8 INS8 UPD42 UPD42 INS43 INS43 INS27 INS27 UPD42 MOV42 INS42 MOV32 INS42 INS27 INS42 INS42 MOV32 INS39 INS85 INS42 INS32 INS42 INS32 INS42 INS42 INS27 UPD42 INS34 INS42 INS34 MOV21 MOV21 INS42 INS42 INS34 INS42 INS42 INS34 INS32 INS34 UPD42 MOV42 UPD42 MOV42 INS45 INS42 INS42 INS27 INS34 INS27 INS42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS40 INS34 INS34 INS27 UPD42 INS42 UPD42 UPD42 MOV42 UPD42 UPD42 MOV42 UPD42 INS42 INS34 DEL42 DEL43 DEL42 DEL59 DEL60 DEL39 DEL42 DEL40 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL34 DEL27 DEL42 DEL42 DEL42 DEL34 DEL27 DEL32 DEL21 DEL42 DEL42 DEL40 DEL42 DEL42 DEL42 DEL32 DEL32 DEL32 DEL21 DEL33 DEL40 DEL32 DEL40 DEL32 DEL42 DEL43 DEL42 DEL44 DEL43 DEL42 DEL42 DEL40 DEL32 DEL32 DEL32 DEL21 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL8 DEL25 DEL8 DEL31
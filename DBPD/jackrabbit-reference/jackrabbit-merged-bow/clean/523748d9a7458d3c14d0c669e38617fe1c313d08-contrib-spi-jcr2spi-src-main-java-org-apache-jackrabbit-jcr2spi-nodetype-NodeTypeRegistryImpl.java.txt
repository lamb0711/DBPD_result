minor improvement: remove unused instance fields
minor improvement: let TransientISFactory listen to states created by the WorkspaceItemStateFactory
JCR-1004 SPI: Add RepositoryService.getQNodeTypeDefinition 
         >> modify to RepositoryService.getQNodeTypeDefinitions(QName)
         >> adjust SPI implementations
         >> change NodeTypeRegistry to load definitions upon demand.



git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@555209 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.HashMap;
-    private final ConcurrentReaderHashMap registeredNTDefs;
-
-    // definition of the root node
-    private final QNodeDefinition rootNodeDef;
+    //private final ConcurrentReaderHashMap registeredNTDefs;
+    private final NodeTypeDefinitionMap registeredNTDefs;
-    public static NodeTypeRegistryImpl create(Collection nodeTypeDefs, NodeTypeStorage storage, QNodeDefinition rootNodeDef, NamespaceRegistry nsRegistry)
-            throws RepositoryException {
-        NodeTypeRegistryImpl ntRegistry = new NodeTypeRegistryImpl(nodeTypeDefs, storage, rootNodeDef, nsRegistry);
+    public static NodeTypeRegistryImpl create(NodeTypeStorage storage, QNodeDefinition rootNodeDef, NamespaceRegistry nsRegistry) {
+        NodeTypeRegistryImpl ntRegistry = new NodeTypeRegistryImpl(storage, rootNodeDef, nsRegistry);
-    private NodeTypeRegistryImpl(Collection nodeTypeDefs, NodeTypeStorage storage, QNodeDefinition rootNodeDef, NamespaceRegistry nsRegistry)
-            throws RepositoryException {
+    private NodeTypeRegistryImpl(NodeTypeStorage storage, QNodeDefinition rootNodeDef, NamespaceRegistry nsRegistry) {
-        registeredNTDefs = new ConcurrentReaderHashMap();
+        //registeredNTDefs = new ConcurrentReaderHashMap();
+        registeredNTDefs = new NodeTypeDefinitionMap();
-        this.rootNodeDef = rootNodeDef;
-
-        try {
-            // validate & register the definitions
-            /* Note: since the client reads all nodetypes from the server, it is
-             * not able to distinguish between built-in and custom-defined
-             * nodetypes (compared to Jackrabbit-core) */
-            Map defMap = validator.validateNodeTypeDefs(nodeTypeDefs, new HashMap(registeredNTDefs));
-            internalRegister(defMap);
-        } catch (InvalidNodeTypeDefException intde) {
-            String error = "Unexpected error: Found invalid node type definition.";
-            log.debug(error);
-            throw new RepositoryException(error, intde);
-        }
-    public QName[] getRegisteredNodeTypes() {
-        return (QName[]) registeredNTDefs.keySet().toArray(new QName[registeredNTDefs.size()]);
+    public QName[] getRegisteredNodeTypes() throws RepositoryException {
+        Set qNames = registeredNTDefs.keySet();
+        return (QName[]) qNames.toArray(new QName[registeredNTDefs.size()]);
-            if (!registeredNTDefs.containsKey(ntName)) {
-                throw new NoSuchNodeTypeException(ntName.toString());
-            }
-
-            // check for node types other than those to be unregistered
-            // that depend on the given node types
-            Set dependents = getDependentNodeTypes(ntName);
+            
+            // Best effort check for node types other than those to be
+            // unregistered that depend on the given node types
+            Set dependents = registeredNTDefs.getDependentNodeTypes(ntName);
-                msg.append(ntName
-                        + " can not be removed because the following node types depend on it: ");
+                msg.append(ntName).append(" can not be removed because the following node types depend on it: ");
-            throw new NoSuchNodeTypeException(nodeTypeName.toString());
+            throw new NoSuchNodeTypeException("Nodetype " + nodeTypeName + " doesn't exist");
-
-        // store new effective node type instance
-        entCache.put(ent);
+        // store new effective node type instance if present. otherwise it
+        // will be created on demand.
+        if (ent != null) {
+            entCache.put(ent);
+        } else {
+            log.debug("Effective node type for " + ntd + " not yet built.");
+        }
-        QNodeTypeDefinition ntd = (QNodeTypeDefinition) registeredNTDefs.get(name);
-        registeredNTDefs.remove(name);
+        QNodeTypeDefinition ntd = (QNodeTypeDefinition) registeredNTDefs.remove(name);
-        // remove property & child node definitions
-        QPropertyDefinition[] pda = ntd.getPropertyDefs();
-        synchronized (propDefs) {
-            for (int i = 0; i < pda.length; i++) {
-                propDefs.remove(pda[i]);
+        if (ntd != null) {
+            // remove property & child node definitions
+            QPropertyDefinition[] pda = ntd.getPropertyDefs();
+            synchronized (propDefs) {
+                for (int i = 0; i < pda.length; i++) {
+                    propDefs.remove(pda[i]);
+                }
-        }
-        synchronized (nodeDefs) {
-            QNodeDefinition[] nda = ntd.getChildNodeDefs();
-            for (int i = 0; i < nda.length; i++) {
-                nodeDefs.remove(nda[i]);
+            synchronized (nodeDefs) {
+                QNodeDefinition[] nda = ntd.getChildNodeDefs();
+                for (int i = 0; i < nda.length; i++) {
+                    nodeDefs.remove(nda[i]);
+                }
-   /**
-     * Returns the names of those registered node types that have
-     * dependencies on the given node type.
-     *
-     * @param nodeTypeName node type name
-     * @return a set of node type <code>QName</code>s
-     * @throws NoSuchNodeTypeException
-     */
-    private Set getDependentNodeTypes(QName nodeTypeName)
-            throws NoSuchNodeTypeException {
-        if (!registeredNTDefs.containsKey(nodeTypeName)) {
-            throw new NoSuchNodeTypeException(nodeTypeName.toString());
-        }
-
-        // get names of those node types that have dependencies on the given nt
-        HashSet names = new HashSet();
-        Iterator iter = registeredNTDefs.values().iterator();
-        while (iter.hasNext()) {
-            QNodeTypeDefinition ntd = (QNodeTypeDefinition) iter.next();
-            if (ntd.getDependencies().contains(nodeTypeName)) {
-                names.add(ntd.getQName());
-            }
-        }
-        return names;
-    }
-
-        ps.println("Registered NodeTypes:");
+        ps.println("Known NodeTypes:");
-        Iterator iter = registeredNTDefs.values().iterator();
-        while (iter.hasNext()) {
-            QNodeTypeDefinition ntd = (QNodeTypeDefinition) iter.next();
-            ps.println(ntd.getQName());
-            QName[] supertypes = ntd.getSupertypes();
-            ps.println("\tSupertypes");
-            for (int i = 0; i < supertypes.length; i++) {
-                ps.println("\t\t" + supertypes[i]);
-            }
-            ps.println("\tMixin\t" + ntd.isMixin());
-            ps.println("\tOrderableChildNodes\t" + ntd.hasOrderableChildNodes());
-            ps.println("\tPrimaryItemName\t" + (ntd.getPrimaryItemName() == null ? "<null>" : ntd.getPrimaryItemName().toString()));
-            QPropertyDefinition[] pd = ntd.getPropertyDefs();
-            for (int i = 0; i < pd.length; i++) {
-                ps.print("\tPropertyDefinition");
-                ps.println(" (declared in " + pd[i].getDeclaringNodeType() + ") ");
-                ps.println("\t\tName\t\t" + (pd[i].definesResidual() ? "*" : pd[i].getQName().toString()));
-                String type = pd[i].getRequiredType() == 0 ? "null" : PropertyType.nameFromValue(pd[i].getRequiredType());
-                ps.println("\t\tRequiredType\t" + type);
-                String[] vca = pd[i].getValueConstraints();
-                StringBuffer constraints = new StringBuffer();
-                if (vca == null) {
-                    constraints.append("<null>");
-                } else {
-                    for (int n = 0; n < vca.length; n++) {
-                        if (constraints.length() > 0) {
-                            constraints.append(", ");
-                        }
-                        constraints.append(vca[n]);
-                    }
-                }
-                ps.println("\t\tValueConstraints\t" + constraints.toString());
-                QValue[] defVals = pd[i].getDefaultValues();
-                StringBuffer defaultValues = new StringBuffer();
-                if (defVals == null) {
-                    defaultValues.append("<null>");
-                } else {
-                    for (int n = 0; n < defVals.length; n++) {
-                        if (defaultValues.length() > 0) {
-                            defaultValues.append(", ");
-                        }
-                        try {
-                            defaultValues.append(defVals[n].getString());
-                        } catch (RepositoryException e) {
-                            defaultValues.append(defVals[n].toString());
-                        }
-                    }
-                }
-                ps.println("\t\tDefaultValue\t" + defaultValues.toString());
-                ps.println("\t\tAutoCreated\t" + pd[i].isAutoCreated());
-                ps.println("\t\tMandatory\t" + pd[i].isMandatory());
-                ps.println("\t\tOnVersion\t" + OnParentVersionAction.nameFromValue(pd[i].getOnParentVersion()));
-                ps.println("\t\tProtected\t" + pd[i].isProtected());
-                ps.println("\t\tMultiple\t" + pd[i].isMultiple());
-            }
-            QNodeDefinition[] nd = ntd.getChildNodeDefs();
-            for (int i = 0; i < nd.length; i++) {
-                ps.print("\tNodeDefinition");
-                ps.println(" (declared in " + nd[i].getDeclaringNodeType() + ") ");
-                ps.println("\t\tName\t\t" + (nd[i].definesResidual() ? "*" : nd[i].getQName().toString()));
-                QName[] reqPrimaryTypes = nd[i].getRequiredPrimaryTypes();
-                if (reqPrimaryTypes != null && reqPrimaryTypes.length > 0) {
-                    for (int n = 0; n < reqPrimaryTypes.length; n++) {
-                        ps.print("\t\tRequiredPrimaryType\t" + reqPrimaryTypes[n]);
-                    }
-                }
-                QName defPrimaryType = nd[i].getDefaultPrimaryType();
-                if (defPrimaryType != null) {
-                    ps.print("\n\t\tDefaultPrimaryType\t" + defPrimaryType);
-                }
-                ps.println("\n\t\tAutoCreated\t" + nd[i].isAutoCreated());
-                ps.println("\t\tMandatory\t" + nd[i].isMandatory());
-                ps.println("\t\tOnVersion\t" + OnParentVersionAction.nameFromValue(nd[i].getOnParentVersion()));
-                ps.println("\t\tProtected\t" + nd[i].isProtected());
-                ps.println("\t\tAllowsSameNameSiblings\t" + nd[i].allowsSameNameSiblings());
-            }
-        }
+        registeredNTDefs.dump(ps);
+
+    //--------------------------------------------------------< inner class >---
+    /**
+     * Inner class representing the map of <code>QNodeTypeDefinition</code>s
+     * that have been loaded yet.
+     */
+    private class NodeTypeDefinitionMap implements Map, Dumpable {
+
+        // map of node type names and node type definitions
+        private final ConcurrentReaderHashMap nodetypeDefinitions = new ConcurrentReaderHashMap();
+
+        /**
+         * Returns the names of those registered node types that have
+         * dependencies on the given node type.<p/>
+         * Note, that the returned Set may not be complete with respect
+         * to all node types registered within the repository. Instead it
+         * will only contain those node type definitions that are known so far.
+         *
+         * @param nodeTypeName node type name
+         * @return a set of node type <code>QName</code>s
+         * @throws NoSuchNodeTypeException
+         */
+        private Set getDependentNodeTypes(QName nodeTypeName) throws NoSuchNodeTypeException {
+            if (!nodetypeDefinitions.containsKey(nodeTypeName)) {
+                throw new NoSuchNodeTypeException(nodeTypeName.toString());
+            }
+            // get names of those node types that have dependencies on the
+            // node type with the given nodeTypeName.
+            HashSet names = new HashSet();
+            Iterator iter = nodetypeDefinitions.values().iterator();
+            while (iter.hasNext()) {
+                QNodeTypeDefinition ntd = (QNodeTypeDefinition) iter.next();
+                if (ntd.getDependencies().contains(nodeTypeName)) {
+                    names.add(ntd.getQName());
+                }
+            }
+            return names;
+        }
+
+        private void updateInternalMap(Iterator definitions) {
+            // since definition were retrieved from the storage, valiation
+            // can be omitted -> register without building effective-nodetype.
+            // TODO: check if correct
+            while (definitions.hasNext()) {
+                internalRegister((QNodeTypeDefinition) definitions.next(), null);
+            }
+        }
+
+        //------------------------------------------------------------< Map >---
+        public int size() {
+            return nodetypeDefinitions.size();
+        }
+
+        public void clear() {
+            throw new UnsupportedOperationException("Implementation missing");
+        }
+
+        public boolean isEmpty() {
+            return nodetypeDefinitions.isEmpty();
+        }
+
+        public boolean containsKey(Object key) {
+            if (!(key instanceof QName)) {
+                return false;
+            }
+            return get(key) != null;
+        }
+
+        public boolean containsValue(Object value) {
+            if (!(value instanceof QNodeTypeDefinition)) {
+                return false;
+            }
+            return get(((QNodeTypeDefinition)value).getQName()) != null;
+        }
+
+        public Set keySet() {
+            // to be aware of all (recently) registered nodetypes retrieve
+            // complete set from the storage again and add missing / replace
+            // existing definitions.
+            try {
+                Iterator it = storage.getAllDefinitions();
+                updateInternalMap(it);
+            } catch (RepositoryException e) {
+                log.error(e.getMessage());
+            }
+            return nodetypeDefinitions.keySet();
+        }
+
+        public Collection values() {
+            // make sure all node type definitions have been loaded.
+            keySet();
+            // and retrieve the collection containing all definitions.
+            return nodetypeDefinitions.values();
+        }
+
+        public Object put(Object key, Object value) {
+            return nodetypeDefinitions.put(key, value);
+        }
+
+        public void putAll(Map t) {
+            throw new UnsupportedOperationException("Implementation missing");
+        }
+
+        public Set entrySet() {
+            // make sure all node type definitions have been loaded.
+            keySet();
+            return nodetypeDefinitions.entrySet();
+        }
+
+        public Object get(Object key) {
+            if (!(key instanceof QName)) {
+                throw new IllegalArgumentException();
+            }
+            QNodeTypeDefinition def = (QNodeTypeDefinition) nodetypeDefinitions.get(key);
+            if (def == null) {
+                try {
+                    // node type does either not exist or hasn't been loaded yet
+                    Iterator it = storage.getDefinitions(new QName[] {(QName) key});
+                    updateInternalMap(it);
+                } catch (RepositoryException e) {
+                    log.debug(e.getMessage());
+                }
+            }
+            def = (QNodeTypeDefinition) nodetypeDefinitions.get(key);
+            return def;
+        }
+
+        public Object remove(Object key) {
+            return (QNodeTypeDefinition) nodetypeDefinitions.remove(key);
+        }
+
+        //-------------------------------------------------------< Dumpable >---
+        public void dump(PrintStream ps) {
+            Iterator iter = nodetypeDefinitions.values().iterator();
+            while (iter.hasNext()) {
+                QNodeTypeDefinition ntd = (QNodeTypeDefinition) iter.next();
+                ps.println(ntd.getQName());
+                QName[] supertypes = ntd.getSupertypes();
+                ps.println("\tSupertypes");
+                for (int i = 0; i < supertypes.length; i++) {
+                    ps.println("\t\t" + supertypes[i]);
+                }
+                ps.println("\tMixin\t" + ntd.isMixin());
+                ps.println("\tOrderableChildNodes\t" + ntd.hasOrderableChildNodes());
+                ps.println("\tPrimaryItemName\t" + (ntd.getPrimaryItemName() == null ? "<null>" : ntd.getPrimaryItemName().toString()));
+                QPropertyDefinition[] pd = ntd.getPropertyDefs();
+                for (int i = 0; i < pd.length; i++) {
+                    ps.print("\tPropertyDefinition");
+                    ps.println(" (declared in " + pd[i].getDeclaringNodeType() + ") ");
+                    ps.println("\t\tName\t\t" + (pd[i].definesResidual() ? "*" : pd[i].getQName().toString()));
+                    String type = pd[i].getRequiredType() == 0 ? "null" : PropertyType.nameFromValue(pd[i].getRequiredType());
+                    ps.println("\t\tRequiredType\t" + type);                  
+                    String[] vca = pd[i].getValueConstraints();
+                    StringBuffer constraints = new StringBuffer();
+                    if (vca == null) {
+                        constraints.append("<null>");
+                    } else {
+                        for (int n = 0; n < vca.length; n++) {
+                            if (constraints.length() > 0) {
+                                constraints.append(", ");
+                            }
+                            constraints.append(vca[n]);
+                        }
+                    }
+                    ps.println("\t\tValueConstraints\t" + constraints.toString());
+                    QValue[] defVals = pd[i].getDefaultValues();
+                    StringBuffer defaultValues = new StringBuffer();
+                    if (defVals == null) {
+                        defaultValues.append("<null>");
+                    } else {
+                        for (int n = 0; n < defVals.length; n++) {
+                            if (defaultValues.length() > 0) {
+                                defaultValues.append(", ");
+                            }
+                            try {
+                                defaultValues.append(defVals[n].getString());
+                            } catch (RepositoryException e) {
+                                defaultValues.append(defVals[n].toString());
+                            }
+                        }
+                    }
+                    ps.println("\t\tDefaultValue\t" + defaultValues.toString());
+                    ps.println("\t\tAutoCreated\t" + pd[i].isAutoCreated());
+                    ps.println("\t\tMandatory\t" + pd[i].isMandatory());
+                    ps.println("\t\tOnVersion\t" + OnParentVersionAction.nameFromValue(pd[i].getOnParentVersion()));
+                    ps.println("\t\tProtected\t" + pd[i].isProtected());
+                    ps.println("\t\tMultiple\t" + pd[i].isMultiple());
+                }
+                QNodeDefinition[] nd = ntd.getChildNodeDefs();
+                for (int i = 0; i < nd.length; i++) {
+                    ps.print("\tNodeDefinition");
+                    ps.println(" (declared in " + nd[i].getDeclaringNodeType() + ") ");
+                    ps.println("\t\tName\t\t" + (nd[i].definesResidual() ? "*" : nd[i].getQName().toString()));
+                    QName[] reqPrimaryTypes = nd[i].getRequiredPrimaryTypes();
+                    if (reqPrimaryTypes != null && reqPrimaryTypes.length > 0) {
+                        for (int n = 0; n < reqPrimaryTypes.length; n++) {
+                            ps.print("\t\tRequiredPrimaryType\t" + reqPrimaryTypes[n]);
+                        }
+                    }
+                    QName defPrimaryType = nd[i].getDefaultPrimaryType();
+                    if (defPrimaryType != null) {
+                        ps.print("\n\t\tDefaultPrimaryType\t" + defPrimaryType);
+                    }
+                    ps.println("\n\t\tAutoCreated\t" + nd[i].isAutoCreated());
+                    ps.println("\t\tMandatory\t" + nd[i].isMandatory());
+                    ps.println("\t\tOnVersion\t" + OnParentVersionAction.nameFromValue(nd[i].getOnParentVersion()));
+                    ps.println("\t\tProtected\t" + nd[i].isProtected());
+                    ps.println("\t\tAllowsSameNameSiblings\t" + nd[i].allowsSameNameSiblings());
+                }
+            }
+        }
+    }

INS31 INS55 INS43 MOV43 MOV29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS42 INS43 INS43 INS23 MOV31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 MOV31 INS42 INS21 INS60 INS25 INS25 INS43 INS42 MOV21 MOV21 INS21 MOV21 INS21 MOV21 MOV21 INS65 INS42 INS42 INS83 MOV83 MOV43 INS59 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS43 INS42 INS8 INS83 MOV43 INS42 INS8 INS83 INS43 INS42 INS44 INS44 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS43 INS42 INS8 INS83 INS43 INS42 INS44 INS8 INS83 INS43 INS42 INS44 INS8 MOV43 INS7 INS43 INS59 INS27 INS8 INS8 MOV43 INS27 INS8 INS42 INS32 INS32 INS66 INS66 INS42 MOV14 MOV43 INS42 INS61 INS41 INS53 INS41 INS43 INS42 INS25 INS41 INS43 INS42 INS25 INS41 INS42 INS54 INS41 INS21 INS41 INS42 INS43 INS42 INS43 INS42 INS41 MOV43 INS42 INS53 INS42 INS21 INS41 INS42 INS43 INS42 INS25 INS60 INS25 INS21 INS41 INS42 INS43 INS42 INS41 INS60 MOV42 INS14 INS42 INS42 MOV32 INS42 INS33 MOV21 INS21 INS42 INS33 MOV60 MOV51 MOV51 INS42 INS42 INS45 INS42 INS42 INS42 UPD66 INS66 INS66 INS66 INS32 INS8 INS32 INS14 INS32 INS42 INS38 INS8 INS27 INS42 INS38 INS8 INS27 INS8 INS12 INS32 INS32 INS32 INS42 INS42 INS32 INS14 INS32 INS32 INS42 INS38 INS8 INS43 INS59 INS27 INS8 INS7 INS42 INS42 INS11 INS43 MOV59 MOV43 UPD43 MOV43 INS42 INS32 MOV43 MOV32 INS42 INS42 INS21 INS42 INS42 INS43 INS45 INS42 INS42 INS36 INS41 INS32 INS33 INS36 INS41 INS32 INS33 INS60 INS21 INS44 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS45 INS42 INS42 INS42 INS36 INS53 INS42 INS42 INS11 INS42 INS33 INS54 INS42 INS11 INS43 INS32 INS42 UPD42 MOV43 INS27 INS42 INS42 INS27 UPD42 INS32 INS42 INS62 INS9 INS42 INS42 INS62 INS9 INS42 INS32 INS43 INS59 INS32 MOV43 INS42 INS21 INS42 INS62 INS14 INS43 INS32 INS8 INS12 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS45 INS45 INS42 INS45 UPD42 INS42 INS11 INS33 INS42 INS43 INS42 INS43 INS36 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS43 INS43 INS42 INS42 INS42 INS42 INS60 INS21 INS44 INS8 INS42 INS42 INS42 INS42 UPD42 INS32 INS42 INS45 INS43 INS32 INS42 INS42 INS11 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS43 INS59 INS32 MOV43 INS42 INS21 MOV42 MOV42 INS42 UPD42 MOV42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS3 INS42 INS42 INS32 INS5 INS4 INS42 INS42 INS43 INS85 INS11 INS42 INS43 INS42 INS42 DEL40 DEL26 DEL83 DEL43 DEL42 DEL59 DEL23 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL44 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL14 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL32 DEL14 DEL53 DEL8 DEL25 DEL42 DEL45 DEL27 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL45 DEL32 DEL21 DEL60
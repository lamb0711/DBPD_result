

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@76003 13f79535-47bb-0310-9956-ffa450edef68

-     * Listeners (soft references)
+     * Listeners (weak references)
-    protected final Map listeners = Collections.synchronizedMap(new ReferenceMap(ReferenceMap.SOFT, ReferenceMap.SOFT));
+    protected final Map listeners =
+            Collections.synchronizedMap(new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK));
-    protected void checkItemState() throws InvalidItemStateException {
-        // check status for read operation
+    /**
+     * Performs a sanity check on this item and the associated session.
+     *
+     * @throws RepositoryException if this item has been rendered invalid for some reason
+     */
+    protected void sanityCheck() throws RepositoryException {
+        // check session status
+        session.sanityCheck();
+
+        // check status of this item for read operation
-        checkItemState();
+        sanityCheck();
-    public synchronized void save()
+    public void save()
-        checkItemState();
+        sanityCheck();
-        try {
-            /**
-             * turn on temporary path caching for better performance
-             * (assuming that the paths won't change during this save() call)
-             */
-            itemStateMgr.enablePathCaching(true);
+        // synchronize on this session
+        synchronized(session) {
+            try {
+                /**
+                 * turn on temporary path caching for better performance
+                 * (assuming that the paths won't change during this save() call)
+                 */
+                itemStateMgr.enablePathCaching(true);
-            // build list of transient states that should be persisted
-            Collection dirty = getTransientStates();
-            if (dirty.size() == 0) {
-                // no transient items, nothing to do here
-                return;
-            }
+                // build list of transient states that should be persisted
+                Collection dirty = getTransientStates();
+                if (dirty.size() == 0) {
+                    // no transient items, nothing to do here
+                    return;
+                }
-            ItemState transientState;
+                ItemState transientState;
-            /**
-             * check that parent node is also included in the dirty items list
-             * if dirty node was removed or added (adding/removing a parent/child
-             * link requires that both parent and child are saved)
-             */
-            Iterator iter = dirty.iterator();
-            while (iter.hasNext()) {
-                transientState = (ItemState) iter.next();
-                if (transientState.isNode()) {
-                    NodeState nodeState = (NodeState) transientState;
-                    ArrayList dirtyParents = new ArrayList();
-                    // removed parents
-                    dirtyParents.addAll(nodeState.getRemovedParentUUIDs());
-                    // added parents
-                    dirtyParents.addAll(nodeState.getAddedParentUUIDs());
-                    Iterator parentsIter = dirtyParents.iterator();
-                    while (parentsIter.hasNext()) {
-                        NodeId id = new NodeId((String) parentsIter.next());
-                        NodeState parentState = null;
-                        try {
-                            parentState = (NodeState) itemStateMgr.getTransientItemState(id);
-                        } catch (ItemStateException ise) {
-                            // should never get here...
-                            String msg = "inconsistency: failed to retrieve transient state for " + itemMgr.safeGetJCRPath(id);
-                            log.error(msg);
-                            throw new RepositoryException(msg);
-                        }
-                        // check if parent is also going to be saved
-                        if (!dirty.contains(parentState)) {
-                            // need to save the parent too
-                            String msg = itemMgr.safeGetJCRPath(id) + " needs to be saved also.";
-                            log.error(msg);
-                            throw new RepositoryException(msg);
+                /**
+                 * check that parent node is also included in the dirty items list
+                 * if dirty node was removed or added (adding/removing a parent/child
+                 * link requires that both parent and child are saved)
+                 */
+                Iterator iter = dirty.iterator();
+                while (iter.hasNext()) {
+                    transientState = (ItemState) iter.next();
+                    if (transientState.isNode()) {
+                        NodeState nodeState = (NodeState) transientState;
+                        ArrayList dirtyParents = new ArrayList();
+                        // removed parents
+                        dirtyParents.addAll(nodeState.getRemovedParentUUIDs());
+                        // added parents
+                        dirtyParents.addAll(nodeState.getAddedParentUUIDs());
+                        Iterator parentsIter = dirtyParents.iterator();
+                        while (parentsIter.hasNext()) {
+                            NodeId id = new NodeId((String) parentsIter.next());
+                            NodeState parentState = null;
+                            try {
+                                parentState = (NodeState) itemStateMgr.getTransientItemState(id);
+                            } catch (ItemStateException ise) {
+                                // should never get here...
+                                String msg = "inconsistency: failed to retrieve transient state for " + itemMgr.safeGetJCRPath(id);
+                                log.error(msg);
+                                throw new RepositoryException(msg);
+                            }
+                            // check if parent is also going to be saved
+                            if (!dirty.contains(parentState)) {
+                                // need to save the parent too
+                                String msg = itemMgr.safeGetJCRPath(id) + " needs to be saved also.";
+                                log.error(msg);
+                                throw new RepositoryException(msg);
+                            }
-            }
-
-            /**
-             * validate access and node type constraints
-             * (this will also validate child removals)
-             */
-            validateTransientItems(dirty.iterator());
-
-            WorkspaceImpl wsp = (WorkspaceImpl) session.getWorkspace();
-
-            // list of events that are generated by saved changes
-            ObservationManagerFactory obsFactory = rep.getObservationManagerFactory(wsp.getName());
-            EventStateCollection events = obsFactory.createEventStateCollection(session,
-                    session.getItemStateManager(), session.getHierarchyManager());
-
-            /**
-             * we need to make sure that we are not interrupted while
-             * verifying/persisting node references
-             */
-            ReferenceManager refMgr = wsp.getReferenceManager();
-            synchronized (refMgr) {
-                /**
-                 * build list of transient descendents in the attic
-                 * (i.e. those marked as 'removed')
-                 */
-                Collection removed = getRemovedStates();
-                 * referential integrity checks:
-                 * make sure that a referenced node cannot be removed and
-                 * that all references are updated and persisted
+                 * validate access and node type constraints
+                 * (this will also validate child removals)
-                checkReferences(dirty.iterator(), removed.iterator(), refMgr);
+                validateTransientItems(dirty.iterator());
+
+                WorkspaceImpl wsp = (WorkspaceImpl) session.getWorkspace();
+
+                // list of events that are generated by saved changes
+                ObservationManagerFactory obsFactory = rep.getObservationManagerFactory(wsp.getName());
+                EventStateCollection events = obsFactory.createEventStateCollection(session,
+                        session.getItemStateManager(), session.getHierarchyManager());
-                 * create event states for the affected item states and
-                 * prepare them for event dispatch (this step is necessary in order
-                 * to check access rights on items that will be removed)
-                 *
-                 * todo consolidate event generating and dispatching code (ideally one method call after save has succeeded)
+                 * we need to make sure that we are not interrupted while
+                 * verifying/persisting node references
-                events.createEventStates(dirty);
-                events.createEventStates(removed);
-                events.prepare();
+                ReferenceManager refMgr = wsp.getReferenceManager();
+                synchronized (refMgr) {
+                    /**
+                     * build list of transient descendents in the attic
+                     * (i.e. those marked as 'removed')
+                     */
+                    Collection removed = getRemovedStates();
-                // definitively remove transient items marked as 'removed'
-                removeTransientItems(removed.iterator());
+                    /**
+                     * referential integrity checks:
+                     * make sure that a referenced node cannot be removed and
+                     * that all references are updated and persisted
+                     */
+                    checkReferences(dirty.iterator(), removed.iterator(), refMgr);
-                // dispose the transient states marked 'removed'
-                iter = removed.iterator();
+                    /**
+                     * create event states for the affected item states and
+                     * prepare them for event dispatch (this step is necessary in order
+                     * to check access rights on items that will be removed)
+                     *
+                     * todo consolidate event generating and dispatching code (ideally one method call after save has succeeded)
+                     */
+                    events.createEventStates(dirty);
+                    events.createEventStates(removed);
+                    events.prepare();
+
+                    // definitively remove transient items marked as 'removed'
+                    removeTransientItems(removed.iterator());
+
+                    // dispose the transient states marked 'removed'
+                    iter = removed.iterator();
+                    while (iter.hasNext()) {
+                        transientState = (ItemState) iter.next();
+                        /**
+                         * dispose the transient state, it is no longer used
+                         * this will indirectly (through stateDiscarded listener method)
+                         * permanently invalidate the wrapping Item instance
+                         */
+                        itemStateMgr.disposeTransientItemStateInAttic(transientState);
+                    }
+
+                    // initialize version histories for new nodes (might generate new transient state)
+                    if (initVersionHistories(dirty.iterator())) {
+                        /**
+                         * re-build the list of transient states because the previous call
+                         * generated new transient state
+                         */
+                        dirty = getTransientStates();
+                    }
+
+                    // persist 'new' or 'modified' transient states
+                    persistTransientItems(dirty.iterator());
+                } // synchronized(refMgr)
+
+                // now it is safe to dispose the transient states
+                iter = dirty.iterator();
-                    /**
-                     * dispose the transient state, it is no longer used
-                     * this will indirectly (through stateDiscarded listener method)
-                     * permanently invalidate the wrapping Item instance
-                     */
-                    itemStateMgr.disposeTransientItemStateInAttic(transientState);
+                    // dispose the transient state, it is no longer used
+                    itemStateMgr.disposeTransientItemState(transientState);
-                // initialize version histories for new nodes (might generate new transient state)
-                if (initVersionHistories(dirty.iterator())) {
-                    /**
-                     * re-build the list of transient states because the previous call
-                     * generated new transient state
-                     */
-                    dirty = getTransientStates();
-                }
-
-                // persist 'new' or 'modified' transient states
-                persistTransientItems(dirty.iterator());
-            } // synchronized(refMgr)
-
-            // now it is safe to dispose the transient states
-            iter = dirty.iterator();
-            while (iter.hasNext()) {
-                transientState = (ItemState) iter.next();
-                // dispose the transient state, it is no longer used
-                itemStateMgr.disposeTransientItemState(transientState);
+                // all changes are persisted, now dispatch events
+                // forward this to the session to let it decide on the right time for those
+                // events to be dispatched in case of transactional support
+                session.dispatch(events);
+            } finally {
+                // turn off temporary path caching
+                itemStateMgr.enablePathCaching(false);
-
-            // all changes are persisted, now dispatch events
-            // forward this to the session to let it decide on the right time for those
-            // events to be dispatched in case of transactional support
-            session.dispatch(events);
-        } finally {
-            // turn off temporary path caching
-            itemStateMgr.enablePathCaching(false);
-        checkItemState();
+        sanityCheck();
-        checkItemState();
+        sanityCheck();

INS29 UPD42 UPD43 INS8 INS65 INS65 UPD42 INS21 INS21 INS51 UPD66 INS66 INS42 INS66 INS32 INS32 INS42 MOV8 UPD40 UPD40 INS42 INS42 UPD42 INS42 UPD42 UPD42 DEL83 DEL42 DEL32 DEL21
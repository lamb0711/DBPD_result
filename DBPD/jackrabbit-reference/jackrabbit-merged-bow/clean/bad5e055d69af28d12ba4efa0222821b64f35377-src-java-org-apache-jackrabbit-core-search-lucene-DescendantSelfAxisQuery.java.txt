Upgraded to Lucene 1.4.3 and implemented order by in queries

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@148868 13f79535-47bb-0310-9956-ffa450edef68

-        private int nextDoc = 0;
+        private int nextDoc = -1;
-         * @see Scorer#score(org.apache.lucene.search.HitCollector, int)
+         * @see Scorer#score(org.apache.lucene.search.HitCollector)
-        public void score(HitCollector hc, int maxDoc) throws IOException {
-            if (contextUUIDs == null) {
-                contextUUIDs = new HashSet();
-                contextScorer.score(new HitCollector() {
-                    public void collect(int doc, float score) {
-                        // @todo maintain cache of doc id hierarchy
-                        hits.set(doc);
-                    }
-                }, reader.maxDoc()); // find all
-                for (int i = hits.nextSetBit(0); i >= 0; i = hits.nextSetBit(i + 1)) {
-                    contextUUIDs.add(reader.document(i).get(FieldNames.UUID));
-                }
-
-                // reuse for final hits
-                hits.clear();
-
-                subScorer.score(new HitCollector() {
-                    public void collect(int doc, float score) {
-                        subHits.set(doc);
-                    }
-                }, reader.maxDoc());
-
-                nextDoc = subHits.nextSetBit(0);
+        public void score(HitCollector hc) throws IOException {
+            while (next()) {
+                hc.collect(doc(), score());
+        }
-            while (nextDoc > -1 && nextDoc < maxDoc) {
+        public boolean next() throws IOException {
+            calculateSubHits();
+            nextDoc = subHits.nextSetBit(nextDoc + 1);
+            while (nextDoc > -1) {
-                    // match
-                    hc.collect(nextDoc, 1.0f);
+                    return true;
-                // move to next doc
+                // try next
+            }
+            return false;
+        }
+        public int doc() {
+            return nextDoc;
+        }
+
+        public float score() throws IOException {
+            return 1.0f;
+        }
+
+        public boolean skipTo(int target) throws IOException {
+            nextDoc = target - 1;
+            return next();
+        }
+
+        private void calculateSubHits() throws IOException {
+            if (contextUUIDs == null) {
+                contextUUIDs = new HashSet();
+                contextScorer.score(new HitCollector() {
+                    public void collect(int doc, float score) {
+                        // @todo maintain cache of doc id hierarchy
+                        hits.set(doc);
+                    }
+                }); // find all
+                for (int i = hits.nextSetBit(0); i >= 0; i = hits.nextSetBit(i + 1)) {
+                    contextUUIDs.add(reader.document(i).get(FieldNames.UUID));
+                }
+
+                // reuse for final hits
+                hits.clear();
+
+                subScorer.score(new HitCollector() {
+                    public void collect(int doc, float score) {
+                        subHits.set(doc);
+                    }
+                });

INS31 INS31 INS31 INS31 INS31 MOV29 INS83 INS39 INS42 MOV44 INS43 INS8 INS83 INS39 INS42 INS43 INS8 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS43 INS8 INS83 INS39 INS42 INS44 INS43 INS8 UPD83 UPD42 INS38 INS42 INS61 INS42 INS21 INS21 MOV61 INS41 INS41 INS42 INS41 INS39 INS42 INS42 INS21 INS41 INS34 INS32 INS8 INS32 INS7 MOV27 INS9 INS42 INS34 INS7 INS32 INS42 INS21 INS42 INS42 INS32 INS42 INS27 INS42 INS32 INS42 INS42 INS27 INS42 INS34 INS42 INS42 INS32 INS32 INS42 INS34 INS41 INS42 INS42 INS9 DEL34 DEL39 DEL69 DEL42 DEL42 DEL27 DEL27 DEL42 DEL42 DEL42 DEL34 DEL32 DEL21 DEL39 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL34 DEL32 DEL7 DEL21
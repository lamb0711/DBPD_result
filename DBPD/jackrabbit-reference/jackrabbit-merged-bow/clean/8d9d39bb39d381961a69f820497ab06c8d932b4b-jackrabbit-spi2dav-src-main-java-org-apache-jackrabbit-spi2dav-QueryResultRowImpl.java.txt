JCR-3198: Broken handling of outer join results over davex

Return the set of selector names as a part of the response description field along with column names.

For compatibility with earlier clients/servers this new functionality (and extensible) functionality is only enabled when the search request is made with the query language qualified with the JCR WebDAV extension namespace.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1227240 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.spi.Name;
-    private final Map<Name, NodeId> nodeIds = new HashMap<Name, NodeId>();
+    private final Map<String, NodeId> nodeIds = new HashMap<String, NodeId>();
-    private final Map<Name, Double> scores = new HashMap<Name, Double>();
+    private final Map<String, Double> scores = new HashMap<String, Double>();
-    private final Name[] selectorNames;
-
+
-        this.selectorNames = new Name[selList.size()];
-                this.selectorNames[i] = (selectorName == null) ? null : resolver.getQName(selectorName);
-                    scores.put(this.selectorNames[i], score);
+                    scores.put(selectorName, score);
-                    nodeIds.put(this.selectorNames[i], id);
+                    nodeIds.put(selectorName, id);
-    public NodeId getNodeId(Name selectorName) {
+    public NodeId getNodeId(String selectorName) {
+        if (selectorName == null && scores.size() == 1) {
+            return nodeIds.values().iterator().next();
+        }
+
-        if (id == null) {
-            if (nodeIds.size() == 1) {
-                return nodeIds.values().iterator().next();
-            } else {
-                throw new IllegalArgumentException(selectorName + " is not a valid selectorName");
-            }
+        if (id == null && !nodeIds.containsKey(selectorName)) {
+            throw new IllegalArgumentException(selectorName + " is not a valid selectorName");
-    public double getScore(Name selectorName) {
+    public double getScore(String selectorName) {
+        if (selectorName == null && scores.size() == 1) {
+            return scores.values().iterator().next();
+        }
+
-        if (score == null) {
-            if (scores.size() == 1) {
-                return scores.values().iterator().next();
-            } else {
-                throw new IllegalArgumentException(selectorName + " is not a valid selectorName");
-            }
+        if (score == null && !nodeIds.containsKey(selectorName)) {
+            throw new IllegalArgumentException(selectorName + " is not a valid selectorName");
-    Name[] getSelectorNames() {
-        return selectorNames;
-    }

UPD74 UPD74 UPD43 UPD43 UPD43 MOV25 INS25 UPD43 MOV25 UPD42 UPD74 UPD42 UPD74 UPD42 INS27 INS27 MOV8 UPD42 INS27 INS27 MOV8 UPD43 UPD43 MOV27 INS27 MOV27 INS38 INS27 MOV27 MOV27 INS38 UPD42 UPD42 MOV32 MOV34 INS32 MOV42 INS33 INS32 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL40 DEL26 DEL83 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL59 DEL23 DEL52 DEL42 DEL22 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL32 DEL3 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL2 DEL36 DEL33 DEL42 DEL42 DEL42 DEL32 DEL16 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL2 DEL52 DEL42 DEL22 DEL42 DEL2 DEL27 DEL8 DEL25 DEL8 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL41 DEL8 DEL31
work in progress

- LazyItemIterator: fixing wrong usage in ItemManagerImpl
- LazyItemIterator: removing TODOs and workaround

- ItemStateFactory: remove unused method 
  'createPropertyState(PropertyId propertyId, ItemStateManager ism)'

- TransientItemStateFactory: slightly modify methods, adding additional
  parameters that are already known upon creation of the states and must
  not be changed later on (-> removing setters on NodeState/PropertyState)

- TransientItemStateManager:
  > rename create-methods to createNew...
  > adjust parameters according to modifications in TransientISF

- NodeState:
  > set QNodeDefinition upon creation
  > modify 'moveChildNodeEntry': additing 'newDefinition' parameter
  > remove 'setParent'
  > remove 'setDefinition'
  > remove 'getDefinition(NodeTypeRegistry). since definition is set upon
    creation, there is no need for this fallback method.

- PropertyState:
  > set QPropertyDefinition upon creation
  > 'multiValued' field is therefore redundant -> remove
  > remove 'setMultiValued'
  > remove 'setDefinition'
  > remove 'getDefinition(NodeTypeRegistry). since definition is set upon
    creation, there is no need for this fallback method.

- SetPropertyValue: 'isMultiValued()' is redundant. removed and replaced
  usage with 'getPropertyState().isMultiValued()'

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@432630 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeConflictException;
-import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeRegistry;
-import org.apache.jackrabbit.jcr2spi.nodetype.EffectiveNodeType;
-     * the names of this node's mixin types
-     */
-    private QName[] mixinTypeNames = new QName[0];
-
-    /**
-    private QNodeDefinition def;
+    private QNodeDefinition definition;
+
+    /**
+     * the names of this node's mixin types
+     */
+    private QName[] mixinTypeNames = new QName[0];
+     * @param definition
-     *                      instance.
-                        QName nodeTypeName, int initialStatus, boolean isTransient,
+                        QName nodeTypeName, QNodeDefinition definition,
+                        int initialStatus, boolean isTransient,
+        this.definition = definition;
-            def = nodeState.def;
+            definition = nodeState.definition;
-     * Sets the the parent <code>NodeState</code>.
-     *
-     * @param parent the parent <code>NodeState</code> or <code>null</code>
-     * if either this node state should represent the root node or this node
-     * state should be 'free floating', i.e. detached from the repository's
-     * hierarchy.
-     */
-    private void setParent(NodeState parent) {
-        this.parent = parent;
-    }
-
-    /**
-     * Set the node type name. Needed for deserialization and should therefore
-     * not change the internal status.
-     *
-     * @param nodeTypeName node type name
-     */
-    synchronized void setNodeTypeName(QName nodeTypeName) {
-        this.nodeTypeName = nodeTypeName;
-    }
-
-    /**
-     * node state or <code>null</code> if the definition has not been
-     * set before (i.e. the corresponding item has not been accessed before).
+     * node state. Note, that the definition has been set upon creation or
+     * upon move.
-     * @see #getDefinition(NodeTypeRegistry) for the corresponding method
-     * that never returns <code>null</code>.
-        return def;
-    }
-
-    /**
-     * Returns the definition applicable to this node state. Since the definition
-     * is not defined upon state creation this state may have to retrieve
-     * the definition from the given <code>NodeTypeRegistry</code> first.
-     *
-     * @param ntRegistry
-     * @return the definition of this state
-     * @see #getDefinition()
-     */
-    public QNodeDefinition getDefinition(NodeTypeRegistry ntRegistry)
-        throws RepositoryException {
-        // make sure the state has the definition set now
-        if (def == null) {
-            NodeState parentState = getParent();
-            if (parentState == null) {
-                // special case for root state
-                def = ntRegistry.getRootNodeDef();
-            } else {
-                try {
-                    EffectiveNodeType ent = ntRegistry.getEffectiveNodeType(parentState.getNodeTypeNames());
-                    def = ent.getApplicableNodeDefinition(getName(), getNodeTypeName());
-                } catch (NodeTypeConflictException e) {
-                    String msg = "internal error: failed to build effective node type.";
-                    log.debug(msg);
-                    throw new RepositoryException(msg, e);
-                }
-            }
-        }
-        return def;
-    }
-
-    /**
-     * Sets the id of the definition applicable to this node state.
-     *
-     * @param def the definition
-     */
-    void setDefinition(QNodeDefinition def) {
-        this.def = def;
+        return definition;
-        // NOTE: List representation of 'ChildNodeEntries' is already unmodifiable
+        // NOTE: 'childNodeEntries' are already unmodifiable
-     * Renames a new <code>ChildNodeEntry</code>.
+     * Moves a <code>ChildNodeEntry</code> to a new parent. If the new parent
+     * is this <code>NodeState</code>, the child state is renamed and moved
+     * to the end of the child entries collection.
-    synchronized void moveChildNodeEntry(NodeState newParent, NodeState childState, QName newName)
+    synchronized void moveChildNodeEntry(NodeState newParent, NodeState childState, QName newName, QNodeDefinition newDefinition)
-            childState.setParent(newParent);
+            childState.parent = newParent;
+            // set definition according to new definition required by the new parent
+            childState.definition = newDefinition;

MOV23 INS44 INS44 UPD42 INS65 MOV43 INS42 INS21 MOV43 INS42 INS42 INS7 UPD66 UPD66 UPD42 UPD66 INS66 INS66 INS22 INS42 INS21 INS52 INS42 INS7 INS7 UPD42 UPD40 INS40 INS42 INS40 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL66 DEL66 DEL65 DEL42 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL42 DEL42 DEL43 DEL69 DEL68 DEL66 DEL66 DEL65 DEL66 DEL66 DEL66 DEL65 DEL42 DEL65 DEL66 DEL65 DEL42 DEL68 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL33 DEL27 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL39 DEL42 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL42 DEL42 DEL42 DEL32
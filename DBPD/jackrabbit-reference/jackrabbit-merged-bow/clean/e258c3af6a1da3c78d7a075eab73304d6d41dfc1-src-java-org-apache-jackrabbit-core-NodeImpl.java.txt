renamed jcr:frozenUUID to jcr:frozenUuid as spec'ed

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@151723 13f79535-47bb-0310-9956-ffa450edef68

+     *
-     * <code>false</code> otherwise.
+     *         <code>false</code> otherwise.
+     *
+     *
-            ConstraintViolationException, LockException,  RepositoryException {
+            ConstraintViolationException, LockException, RepositoryException {
-        if (hasProperty(ItemImpl.PROPNAME_MERGE_FAILED) && getProperty(ItemImpl.PROPNAME_MERGE_FAILED).getValues().length>0) {
+        if (hasProperty(ItemImpl.PROPNAME_MERGE_FAILED) && getProperty(ItemImpl.PROPNAME_MERGE_FAILED).getValues().length > 0) {
-/**
+
+    /**
-    // search nearest ancestor that is referenceable
-    NodeImpl m1 = this;
-    while (!m1.isRepositoryRoot() && !m1.isNodeType(NodeTypeRegistry.MIX_REFERENCEABLE)) {
-        m1 = (NodeImpl) m1.getParent();
-    }
-
-    try {
-        // get corresponding ancestor
-        NodeImpl m2 = (NodeImpl) srcSession.getNodeByUUID(m1.getUUID());
-
-        // return path of m2, if m1 == n1
-        if (m1 == this) {
-            return m2;
+        // search nearest ancestor that is referenceable
+        NodeImpl m1 = this;
+        while (!m1.isRepositoryRoot() && !m1.isNodeType(NodeTypeRegistry.MIX_REFERENCEABLE)) {
+            m1 = (NodeImpl) m1.getParent();
-        // calculate relative path from the referenceable ancestor to this node.
-        // please note, that this cannot be done
-        // iteratively in the 'while' loop above, since getName() does not
-        // return the relative path, but just the name (without path indices)
-        // n1.getPath() = /foo/bar/something[1]
-        // m1.getPath() = /foo
-        //      relpath = bar/something[1]
+        try {
+            // get corresponding ancestor
+            NodeImpl m2 = (NodeImpl) srcSession.getNodeByUUID(m1.getUUID());
-        // @todo: replace as soon as implemented
-        // Path relPath = m1.getPrimaryPath().getRelativePath(getPrimaryPath());
+            // return path of m2, if m1 == n1
+            if (m1 == this) {
+                return m2;
+            }
-        String relPath = getPath().substring(m1.getPath().length() + 1);
-        return (NodeImpl) m2.getNode(relPath);
+            // calculate relative path from the referenceable ancestor to this node.
+            // please note, that this cannot be done
+            // iteratively in the 'while' loop above, since getName() does not
+            // return the relative path, but just the name (without path indices)
+            // n1.getPath() = /foo/bar/something[1]
+            // m1.getPath() = /foo
+            //      relpath = bar/something[1]
-    } catch (ItemNotFoundException e) {
-        return null;
+            // @todo: replace as soon as implemented
+            // Path relPath = m1.getPrimaryPath().getRelativePath(getPrimaryPath());
+
+            String relPath = getPath().substring(m1.getPath().length() + 1);
+            return (NodeImpl) m2.getNode(relPath);
+
+        } catch (ItemNotFoundException e) {
+            return null;
+        }
-}
+     *
-     * @param vsel    the version selector that will select the correct version for
-     *                OPV=Version childnodes.
+     * @param vsel           the version selector that will select the correct version for
+     *                       OPV=Version childnodes.
-     *
-            if (n.getDefinition().getOnParentVersion()==OnParentVersionAction.COPY) {
+            if (n.getDefinition().getOnParentVersion() == OnParentVersionAction.COPY) {
-                if (f.getFrozenUUID()!=null) {
+                if (f.getFrozenUUID() != null) {
-                        session.move(n.getPath(), getPath()+ "/" + n.getName());
+                        session.move(n.getPath(), getPath() + "/" + n.getName());
-     *          if this node is not lockable
+     *                             if this node is not lockable

UPD66
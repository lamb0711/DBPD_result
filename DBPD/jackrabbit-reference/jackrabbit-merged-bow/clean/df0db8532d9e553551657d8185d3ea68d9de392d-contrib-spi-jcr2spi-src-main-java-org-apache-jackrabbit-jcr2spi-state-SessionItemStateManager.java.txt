- Introduce ChildPropertyEntry.isAvailable()
- Add ItemState.collectTransientStates() which traverses the ItemState hierarchy and collects the transiently modified ItemStates.
- Change various methods of NodeState to return only valid Property- and Node-States.
- Change SessionItemStateManager.getChangeLog() to use new method ItemState.collectTransientStates() and remove unused methods.
- Prepare removal of ZombieHierarchyManager :)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@433248 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.jcr2spi.ZombieHierarchyManager;
-import java.util.Collections;
+
-    /**
-     * Returns an iterator over those transient item state instances that are
-     * direct or indirect descendents of the item state with the given
-     * <code>parentId</code>. The transient item state instance with the given
-     * <code>parentId</code> itself (if there is such) will not be included.
-     * <p/>
-     * The instances are returned in depth-first tree traversal order.
-     *
-     * @param parent the common parent state of the transient item state
-     * instances to be returned.
-     * @return an iterator over descendant transient item state instances
-     */
-    private Iterator getDescendantTransientItemStates(NodeState parent) {
-        if (!transientStateMgr.hasPendingChanges()) {
-            return Collections.EMPTY_LIST.iterator();
-        }
-
-        // build ordered collection of descendant transient states
-        // sorted by decreasing relative depth
-
-        // use an array of lists to group the descendants by relative depth;
-        // the depth is used as array index
-        List[] la = new List[10];
-        try {
-            Iterator iter = transientStateMgr.getModifiedOrAddedItemStates();
-            while (iter.hasNext()) {
-                ItemState state = (ItemState) iter.next();
-                // determine relative depth: > 0 means it's a descendant
-                int depth;
-                try {
-                    depth = hierMgr.getRelativeDepth(parent, state);
-                } catch (ItemNotFoundException infe) {
-                    /**
-                     * one of the parents of the specified item has been
-                     * removed externally; as we don't know its path,
-                     * we can't determine if it is a descendant;
-                     * InvalidItemStateException should only be thrown if
-                     * a descendant is affected;
-                     * => throw InvalidItemStateException for now
-                     * todo FIXME
-                     */
-                    // unable to determine relative depth, assume that the item
-                    // (or any of its ancestors) has been removed externally
-                    String msg = state.getId()
-                            + ": the item seems to have been removed externally.";
-                    log.debug(msg);
-                    throw new InvalidItemStateException(msg);
-                }
-
-                if (depth < 1) {
-                    // not a descendant
-                    continue;
-                }
-
-                // ensure capacity
-                if (depth > la.length) {
-                    List old[] = la;
-                    la = new List[depth + 10];
-                    System.arraycopy(old, 0, la, 0, old.length);
-                }
-
-                List list = la[depth - 1];
-                if (list == null) {
-                    list = new ArrayList();
-                    la[depth - 1] = list;
-                }
-                list.add(state);
-            }
-        } catch (RepositoryException re) {
-            log.warn("inconsistent hierarchy state", re);
-        }
-        // create an iterator over the collected descendants
-        // in decreasing depth order
-        IteratorChain resultIter = new IteratorChain();
-        for (int i = la.length - 1; i >= 0; i--) {
-            List list = la[i];
-            if (list != null) {
-                resultIter.addIterator(list.iterator());
-            }
-        }
-        /**
-         * if the resulting iterator chain is empty return
-         * EMPTY_LIST.iterator() instead because older versions
-         * of IteratorChain (pre Commons Collections 3.1)
-         * would throw UnsupportedOperationException in this
-         * situation
-         */
-        if (resultIter.getIterators().isEmpty()) {
-            return Collections.EMPTY_LIST.iterator();
-        }
-        return resultIter;
-    }
-
-    /**
-     * Same as <code>{@link #getDescendantTransientItemStates(NodeState)}</code>
-     * except that item state instances in the attic are returned.
-     *
-     * @param parent the common parent of the transient item state
-     * instances to be returned.
-     * @return an iterator over descendant transient item state instances in the attic
-     */
-    private Iterator getDescendantTransientItemStatesInAttic(NodeState parent) {
-        if (!transientStateMgr.hasDeletedItemStates()) {
-            return Collections.EMPTY_LIST.iterator();
-        }
-
-        // build ordered collection of descendant transient states in attic
-        // sorted by decreasing relative depth
-
-        // use a special attic-aware hierarchy manager
-        ZombieHierarchyManager zombieHierMgr =
-                new ZombieHierarchyManager(this, transientStateMgr.getAttic(), nsResolver);
-
-        // use an array of lists to group the descendants by relative depth;
-        // the depth is used as array index
-        List[] la = new List[10];
-        try {
-            Iterator iter = transientStateMgr.getDeletedItemStates();
-            while (iter.hasNext()) {
-                ItemState state = (ItemState) iter.next();
-                // determine relative depth: > 0 means it's a descendant
-                int depth = zombieHierMgr.getRelativeDepth(parent, state);
-                if (depth < 1) {
-                    // not a descendant
-                    continue;
-                }
-
-                // ensure capacity
-                if (depth > la.length) {
-                    List old[] = la;
-                    la = new List[depth + 10];
-                    System.arraycopy(old, 0, la, 0, old.length);
-                }
-
-                List list = la[depth - 1];
-                if (list == null) {
-                    list = new ArrayList();
-                    la[depth - 1] = list;
-                }
-                list.add(state);
-            }
-        } catch (RepositoryException re) {
-            log.warn("inconsistent hierarchy state", re);
-        }
-        // create an iterator over the collected descendants
-        // in decreasing depth order
-        IteratorChain resultIter = new IteratorChain();
-        for (int i = la.length - 1; i >= 0; i--) {
-            List list = la[i];
-            if (list != null) {
-                resultIter.addIterator(list.iterator());
-            }
-        }
-        /**
-         * if the resulting iterator chain is empty return
-         * EMPTY_LIST.iterator() instead because older versions
-         * of IteratorChain (pre Commons Collections 3.1)
-         * would throw UnsupportedOperationException in this
-         * situation
-         */
-        if (resultIter.getIterators().isEmpty()) {
-            return Collections.EMPTY_LIST.iterator();
-        }
-        return resultIter;
-    }
-
-        if (itemState.getParent() == null) {
-            // root state -> get all item states
-            for (Iterator it = transientStateMgr.addedStates(); it.hasNext(); ) {
-                changeLog.added((ItemState) it.next());
-            }
-            for (Iterator it = transientStateMgr.modifiedStates(); it.hasNext(); ) {
-                changeLog.modified((ItemState) it.next());
-            }
-            for (Iterator it = transientStateMgr.deletedStates(); it.hasNext(); ) {
-                changeLog.deleted((ItemState) it.next());
-            }
-            for (Iterator it = transientStateMgr.getOperations(); it.hasNext(); ) {
-                changeLog.addOperation((Operation) it.next());
-            }
-        } else {
-            // build changelog for affected and decendant states only
-            collectTransientStates(itemState, changeLog);
-            collectRemovedStates(itemState, changeLog);
-            /**
-             * build set of item id's which are within the scope of
-             * (i.e. affected by) this save operation
-             */
-            Iterator it = new IteratorChain(changeLog.modifiedStates(), changeLog.deletedStates());
-            Set affectedStates = new HashSet();
-            while (it.hasNext()) {
-                affectedStates.add(it.next());
-            }
+        // build changelog for affected and decendant states only
+        collectTransientStates(itemState, changeLog);
-            checkIsSelfContained(affectedStates, changeLog);
-            collectOperations(affectedStates, changeLog);
+        /**
+         * build set of item id's which are within the scope of
+         * (i.e. affected by) this save operation
+         */
+        Iterator it = new IteratorChain(changeLog.modifiedStates(), changeLog.deletedStates());
+        Set affectedStates = new HashSet();
+        while (it.hasNext()) {
+            affectedStates.add(it.next());
+
+        checkIsSelfContained(affectedStates, changeLog);
+        collectOperations(affectedStates, changeLog);
+
-     * DIFF JACKRABBIT: copied and adapted from ItemImpl.getRemovedStates()
-     * <p/>
-     * Builds a list of transient descendant item states in the attic
-     * (i.e. those marked as 'removed') that are within the scope of
-     * <code>root</code>.
-     *
-     * @throws StaleItemStateException
-     */
-    private void collectRemovedStates(ItemState root, ChangeLog changeLog)
-        throws StaleItemStateException {
-        ItemState transientState;
-        if (root.isNode()) {
-            Iterator iter = getDescendantTransientItemStatesInAttic((NodeState)root);
-            while (iter.hasNext()) {
-                transientState = (ItemState) iter.next();
-                // check if stale
-                if (transientState.getStatus() == ItemState.STATUS_STALE_MODIFIED) {
-                    String msg = transientState.getId()
-                        + ": the item cannot be removed because it has been modified externally.";
-                    log.debug(msg);
-                    throw new StaleItemStateException(msg);
-                }
-                if (transientState.getStatus() == ItemState.STATUS_STALE_DESTROYED) {
-                    String msg = transientState.getId()
-                        + ": the item cannot be removed because it has already been deleted externally.";
-                    log.debug(msg);
-                    throw new StaleItemStateException(msg);
-                }
-                changeLog.deleted(transientState);
-            }
-        }
-    }
-
-    /**
-     * Builds a list of transient (i.e. new or modified) item states that are
-     * within the scope of <code>state</code>.
+     * Builds a <code>ChangeLog</code> of transient (i.e. new, modified or
+     * deleted) item states that are within the scope of <code>state</code>.
-     * @throws StaleItemStateException
-     * @throws ItemStateException
+     * @throws StaleItemStateException if a stale <code>ItemState</code> is
+     *                                 encountered while traversing the state
+     *                                 hierarchy. The <code>changeLog</code>
+     *                                 might have been populated with some
+     *                                 transient item states. A client should
+     *                                 therefore not reuse the <code>changeLog</code>
+     *                                 if such an exception is thrown.
+     * @throws ItemStateException if <code>state</code> is a new item state.
-        // list of transient states that should be persisted
-        ItemState transientState;
-
-                case ItemState.STATUS_EXISTING_MODIFIED:
-                    // add this item's state to the list
-                    changeLog.modified(state);
-                    break;
-
-
-
-
-
-                default:
-                    log.debug("unexpected state status (" + state.getStatus() + ")");
-                    // ignore
-                    break;
-        if (state.isNode()) {
-            // build list of 'new' or 'modified' descendants
-            Iterator iter = getDescendantTransientItemStates((NodeState) state);
-            while (iter.hasNext()) {
-                transientState = (ItemState) iter.next();
-                // fail-fast test: check status of transient state
-                switch (transientState.getStatus()) {
-                    case ItemState.STATUS_NEW:
-                    case ItemState.STATUS_EXISTING_MODIFIED:
-                        // add modified state to the list
-                        changeLog.modified(transientState);
-                        break;
+        // Set of transient states that should be persisted
+        Set transientStates = new HashSet();
+        state.collectTransientStates(transientStates);
-                    case ItemState.STATUS_STALE_MODIFIED:
-                        {
-                            String msg = transientState.getId() + ": the item cannot be saved because it has been modified externally.";
-                            log.debug(msg);
-                            throw new StaleItemStateException(msg);
-                        }
-
-                    case ItemState.STATUS_STALE_DESTROYED:
-                        {
-                            String msg = transientState.getId() + ": the item cannot be saved because it has been deleted externally.";
-                            log.debug(msg);
-                            throw new StaleItemStateException(msg);
-                        }
-
-                    case ItemState.STATUS_UNDEFINED:
-                        {
-                            String msg = transientState.getId() + ": the item cannot be saved; it seems to have been removed externally.";
-                            log.debug(msg);
-                            throw new StaleItemStateException(msg);
-                        }
-
-                    default:
-                        log.debug("unexpected state status (" + transientState.getStatus() + ")");
-                        // ignore
-                        break;
-                }
+        for (Iterator it = transientStates.iterator(); it.hasNext();) {
+            ItemState transientState = (ItemState) it.next();
+            // fail-fast test: check status of transient state
+            switch (transientState.getStatus()) {
+                case ItemState.STATUS_NEW:
+                    changeLog.added(transientState);
+                    break;
+                case ItemState.STATUS_EXISTING_MODIFIED:
+                    changeLog.modified(transientState);
+                    break;
+                case ItemState.STATUS_EXISTING_REMOVED:
+                    changeLog.deleted(transientState);
+                    break;
+                case ItemState.STATUS_STALE_MODIFIED:
+                    {
+                        String msg = transientState.getId() + ": the item cannot be saved because it has been modified externally.";
+                        log.debug(msg);
+                        throw new StaleItemStateException(msg);
+                    }
+                case ItemState.STATUS_STALE_DESTROYED:
+                    {
+                        String msg = transientState.getId() + ": the item cannot be saved because it has been deleted externally.";
+                        log.debug(msg);
+                        throw new StaleItemStateException(msg);
+                    }
+                case ItemState.STATUS_UNDEFINED:
+                    {
+                        String msg = transientState.getId() + ": the item cannot be saved; it seems to have been removed externally.";
+                        log.debug(msg);
+                        throw new StaleItemStateException(msg);
+                    }
+                default:
+                    log.debug("unexpected state status (" + transientState.getStatus() + ")");
+                    // ignore
+                    break;

MOV8 MOV8 MOV60 MOV41 MOV25 INS21 INS24 UPD66 UPD66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 UPD43 INS32 INS58 MOV32 MOV8 UPD42 INS42 INS14 UPD42 MOV42 UPD42 MOV42 INS42 MOV43 INS59 INS60 MOV10 MOV49 MOV10 INS43 INS42 INS32 MOV43 INS59 INS21 INS10 MOV21 INS49 INS10 UPD42 MOV42 INS42 INS42 INS42 MOV11 INS32 INS40 INS42 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL38 DEL40 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL34 DEL3 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL39 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL34 DEL27 DEL18 DEL8 DEL25 DEL42 DEL40 DEL27 DEL42 DEL43 DEL42 DEL85 DEL42 DEL59 DEL60 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL34 DEL27 DEL3 DEL7 DEL21 DEL42 DEL42 DEL42 DEL34 DEL42 DEL34 DEL40 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL27 DEL2 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL43 DEL14 DEL7 DEL21 DEL42 DEL42 DEL34 DEL27 DEL2 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL61 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL39 DEL42 DEL40 DEL34 DEL27 DEL59 DEL58 DEL42 DEL34 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL42 DEL42 DEL2 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL24 DEL42 DEL42 DEL32 DEL42 DEL32 DEL40 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL66 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL66 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL38 DEL40 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL52 DEL42 DEL42 DEL32 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL34 DEL3 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL34 DEL27 DEL18 DEL8 DEL25 DEL42 DEL40 DEL27 DEL42 DEL43 DEL42 DEL85 DEL42 DEL59 DEL60 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL34 DEL27 DEL3 DEL7 DEL21 DEL42 DEL42 DEL42 DEL34 DEL42 DEL34 DEL40 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL27 DEL2 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL43 DEL14 DEL7 DEL21 DEL42 DEL42 DEL34 DEL27 DEL2 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL61 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL39 DEL42 DEL40 DEL34 DEL27 DEL59 DEL58 DEL42 DEL34 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL42 DEL42 DEL2 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL24 DEL42 DEL42 DEL32 DEL42 DEL32 DEL40 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL33 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL21 DEL8 DEL24 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL32 DEL21 DEL8 DEL24 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL32 DEL21 DEL8 DEL24 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL32 DEL21 DEL8 DEL24 DEL8 DEL25 DEL8 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL42 DEL42 DEL32 DEL40 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL42 DEL42 DEL32 DEL40 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL8 DEL61 DEL8 DEL25 DEL8 DEL31 DEL40 DEL49 DEL42 DEL42 DEL42 DEL32 DEL21 DEL10 DEL49 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL45 DEL27 DEL32 DEL21 DEL10 DEL42 DEL42 DEL43 DEL42 DEL11 DEL32 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL32 DEL61 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL25 DEL8
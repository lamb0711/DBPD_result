JCR-178: Allow concurrent index updates and queries

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@232801 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.BitSet;
+ * <p/>
+ * Note on synchronization: This class is not entirely thread-safe. Certain
+ * concurrent access is however allowed. Read-only access on this index using
+ * {@link #getReadOnlyIndexReader()} is thread-safe. That is, multiple threads
+ * my call that method concurrently and use the returned IndexReader at the same
+ * time.<br/>
+ * Modifying threads must be synchronized externally in a way that only one
+ * thread is using the returned IndexReader and IndexWriter instances returned
+ * by {@link #getIndexReader()} and {@link #getIndexWriter()} at a time.<br/>
+ * Concurrent access by <b>one</b> modifying thread and multiple read-only
+ * threads is safe!
-    /** The currently set IndexReader of <code>null</code> if none is set */
-    private IndexReader indexReader;
+    /** The currently set IndexReader or <code>null</code> if none is set */
+    private CommittableIndexReader indexReader;
+    /** The shared IndexReader for all read-only IndexReaders */
+    private SharedIndexReader sharedReader;
+
-     * Adds a document to this index.
+     * Adds a document to this index and invalidates the shared reader.
+     *
+        invalidateSharedReader();
-     * Removes the document from this index.
+     * Removes the document from this index. This call will not invalidate
+     * the shared reader. If a subclass whishes to do so, it should overwrite
+     * this method and call {@link #invalidateSharedReader()}.
+     *
-     * Returns an <code>IndexReader</code> on this index.
+     * Returns an <code>IndexReader</code> on this index. This index reader
+     * may be used to delete documents.
+     *
-            indexReader = IndexReader.open(getDirectory());
-            if (useCachingReader()) {
-                indexReader = new CachingIndexReader(indexReader);
-            }
+            indexReader = new CommittableIndexReader(IndexReader.open(getDirectory()));
+     * Returns a read-only index reader, that can be used concurrently with
+     * other threads writing to this index. The returned index reader is
+     * read-only, that is, any attempt to delete a document from the index
+     * will throw an <code>UnsupportedOperationException</code>.
+     *
+     * @return a read-only index reader.
+     * @throws IOException if an error occurs while obtaining the index reader.
+     */
+    protected synchronized ReadOnlyIndexReader getReadOnlyIndexReader()
+            throws IOException {
+        // get current modifiable index reader
+        IndexReader modifiableReader = getIndexReader();
+        // capture snapshot of deleted documents
+        BitSet deleted = new BitSet(modifiableReader.maxDoc());
+        for (int i = 0; i < modifiableReader.maxDoc(); i++) {
+            if (modifiableReader.isDeleted(i)) {
+                deleted.set(i);
+            }
+        }
+        if (sharedReader == null) {
+            // create new shared reader
+            sharedReader = new SharedIndexReader(new CachingIndexReader(IndexReader.open(getDirectory())));
+        }
+        return new ReadOnlyIndexReader(sharedReader, deleted);
+    }
+
+
+    /**
-            if (indexReader instanceof CachingIndexReader) {
-                // only commit changes, do not close
-                log.debug("committing IndexReader.");
-                ((CachingIndexReader) indexReader).commitDeleted();
-            } else {
-                indexReader.close();
-                indexReader = null;
-            }
+            indexReader.commitDeleted();
-    void close() {
+    synchronized void close() {
+        if (sharedReader != null) {
+            try {
+                sharedReader.close();
+            } catch (IOException e) {
+                log.warn("Exception closing index reader: " + e.toString());
+            }
+        }
-     * Returns <code>true</code> if this index should use a
-     * {@link CachingIndexReader}, <code>false</code> otherwise.
-     * @return <code>true</code> if index reader should use caching.
+     * Closes the shared reader.
+     *
+     * @throws IOException if an error occurs while closing the reader.
-    protected boolean useCachingReader() {
-        return false;
+    protected synchronized void invalidateSharedReader() throws IOException {
+        // invalidate shared reader
+        if (sharedReader != null) {
+            sharedReader.close();
+            sharedReader = null;
+        }

INS26 MOV31 INS40 INS23 INS31 INS43 INS29 INS83 INS43 INS59 INS83 INS43 INS42 INS43 INS8 INS83 INS29 INS83 INS83 INS39 INS42 INS43 INS8 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS66 INS42 INS65 INS42 INS42 INS21 INS65 INS42 INS42 INS60 INS60 INS24 INS25 MOV41 MOV25 INS25 INS65 INS65 INS42 INS25 INS68 INS68 INS68 UPD66 INS66 UPD66 INS32 UPD66 INS66 INS66 INS65 INS66 UPD66 INS66 UPD66 INS66 INS66 UPD66 UPD66 INS42 INS66 MOV43 INS59 INS43 INS59 INS58 INS27 INS37 INS8 INS27 INS8 INS14 MOV27 INS27 INS8 INS66 INS42 INS66 INS27 INS8 INS42 INS42 INS42 INS42 INS68 INS42 INS32 INS42 INS42 INS14 INS39 INS59 INS42 INS32 INS42 INS25 INS42 INS33 INS21 INS43 INS42 INS42 INS42 INS33 INS54 INS42 INS33 INS21 INS21 INS42 INS42 INS43 INS32 INS42 INS34 INS42 INS42 INS32 INS8 INS7 INS42 INS8 INS12 INS32 INS7 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS42 INS14 INS42 INS21 INS44 INS8 INS42 INS42 INS42 INS33 INS43 MOV32 INS32 INS43 INS14 INS32 INS43 INS42 INS21 INS42 INS42 INS42 INS42 INS42 MOV43 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS45 INS32 INS42 INS42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL14 DEL7 DEL21 DEL8 DEL25 DEL42 DEL65 DEL9 DEL39 DEL42 DEL8 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL45 DEL32 DEL21 DEL42 DEL11 DEL36 DEL42 DEL42 DEL32 DEL21 DEL42 DEL33 DEL7 DEL21 DEL8 DEL8 DEL25
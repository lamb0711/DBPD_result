JCR-3095 : Move operation may turn AC caches stale

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1179536 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.observation.SynchronousEventListener;
+import javax.jcr.observation.EventListener;
+    private final EventListener moveListener;
+
-        observationMgr.addEventListener(this, events, systemSession.getRootNode().getPath(), true, null, ntNames, true);        
+        String rootPath = systemSession.getRootNode().getPath();
+        observationMgr.addEventListener(this, events, rootPath, true, null, ntNames, true);
+        /*
+         In addition both the collector and all subscribed listeners should be
+         informed about any kind of move events.
+         */
+        moveListener = new MoveListener();
+        observationMgr.addEventListener(moveListener, Event.NODE_MOVED, rootPath, true, null, null, true);
-            systemSession.getWorkspace().getObservationManager().removeEventListener(this);
+            ObservationManager observationMgr = systemSession.getWorkspace().getObservationManager();
+            observationMgr.removeEventListener(this);
+            observationMgr.removeEventListener(moveListener);
+
+    /**
+     * Listening to any kind of move events in the hierarchy. Since ac content
+     * is associated with individual nodes the caches need to be informed about
+     * any kind of move as well even if the target node is not access control
+     * content s.str.
+     */
+    private class MoveListener implements SynchronousEventListener {
+
+        public void onEvent(EventIterator events) {
+            // NOTE: simplified event handling as all listeners just clear
+            // the cache in case of any move event. therefore there is currently
+            // no need to process all events and using the rootID as marker.
+            while (events.hasNext()) {
+                Event event = events.nextEvent();
+                if (event.getType() == Event.NODE_MOVED) {
+                    Map<NodeId, Integer> m = Collections.singletonMap(rootID, AccessControlObserver.MOVE);
+                    AccessControlModifications<NodeId> mods = new AccessControlModifications<NodeId>(m);
+                    notifyListeners(mods);
+                    break;
+                } //else: illegal event-type: should never occur. ignore
+            }
+        }
+    }

INS26 INS26 INS40 INS40 INS23 INS55 INS83 INS83 INS43 INS59 INS29 INS83 INS42 INS43 INS31 INS42 INS42 INS60 INS21 INS21 INS65 INS42 INS83 INS39 INS42 INS44 INS8 INS43 INS59 INS7 INS32 INS66 INS66 INS66 INS66 INS43 INS42 INS61 INS42 INS42 MOV32 INS42 INS42 INS14 INS42 INS42 INS42 INS40 INS42 INS9 INS33 INS33 INS9 INS60 INS21 INS21 INS42 INS32 INS8 INS43 INS43 INS59 INS32 INS32 INS42 INS42 INS60 INS25 INS42 INS42 INS42 INS32 INS42 MOV42 MOV52 INS42 INS42 INS42 INS43 INS59 INS27 INS8 MOV32 MOV42 INS42 INS42 INS32 INS32 INS40 INS60 INS60 INS21 INS10 INS42 INS42 INS42 INS42 INS74 INS59 INS74 INS59 INS32 INS43 INS43 INS43 INS42 INS32 INS43 INS43 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS74 INS42 INS43 INS43 INS42 INS42 DEL32 DEL32 DEL21
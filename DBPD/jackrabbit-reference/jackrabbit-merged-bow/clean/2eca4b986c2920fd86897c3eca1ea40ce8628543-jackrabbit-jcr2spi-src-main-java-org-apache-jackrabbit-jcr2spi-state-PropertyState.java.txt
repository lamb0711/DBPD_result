JCR-1799 updating events swallowed (CacheBehavior.OBSERVATION)   	
JCR-1783 incomplete changelog when combining move with removal of new destination parent

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@704361 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Iterator;
-     *
+     * Value(s) and type of an existing property that has been transiently
+     * modified.
-    private TransientData transientData;
+    private PropertyData transientData;
-     *
+     * Original value(s) and type of an existing or a new property.
-    private PropertyInfo pInfo;
+    private PropertyData data;
-                            ItemDefinitionProvider definitionProvider) {
+                            ItemDefinitionProvider definitionProvider,
+                            QValue[] values, int propertyType)
+            throws ConstraintViolationException, RepositoryException {
-        this.transientData = null; // TODO: maybe type/values should be passed to constructor
-        this.pInfo = null;
+        setValues(values, propertyType);
+        this.data = new PropertyData(pInfo);
-        this.pInfo = pInfo;
-    public ItemId getId() {
+    public ItemId getId() throws RepositoryException {
-    public ItemId getWorkspaceId() {
+    public ItemId getWorkspaceId() throws RepositoryException {
-     * If <code>keepChanges</code> is true, this method does nothing and returns
-     * false. Otherwise type and values of the other property state are compared
-     * to this state. If they differ, they will be copied to this state and
-     * this method returns true.
+     * If <code>keepChanges</code> is true, this method only compares the existing
+     * values with the values from 'another' and returns true, if the underlying
+     * persistent state is different to the stored persistent values. Otherwise
+     * the transient changes will be discarded.
-        boolean modified = diff(this, (PropertyState) another);
-        this.pInfo = ((PropertyState) another).pInfo;
-        if (!keepChanges && transientData != null) {
-            modified = true;
+        // calculate if the persistent values of this state differ from the
+        // other state.
+        boolean diff = diff(data, ((PropertyState) another).data);
+        // reset the pInfo to point to the pInfo of another state.
+        this.data = ((PropertyState) another).data;
+        // if transient changes should be preserved OR if there are not
+        // transient changes, simply return diff to indicate if this state
+        // was internally changed.
+        if (keepChanges || transientData == null) {
+            return diff;
+        } else {
+            return true;
-        return modified;
-
-    /**
-     * {@inheritDoc}
-     * @see ItemState#persisted(ChangeLog)
-     */
-    void persisted(ChangeLog changeLog)
-        throws IllegalStateException {
-        for (Iterator it = changeLog.modifiedStates(); it.hasNext();) {
-            ItemState modState = (ItemState) it.next();
-            if (modState == this) {
-                /*
-                NOTE: Property can only be the changelog target, if it was
-                existing and has been modified. removal, add and implicit modification
-                of protected properties must be persisted by save on parent.
-                */
-                setStatus(Status.EXISTING);
-            }
-        }
-    }
-
-        return (transientData == null) ? pInfo.getType() : transientData.type;
+        return (transientData == null) ? data.type : transientData.type;
-        // if transientData are null the pInfo MUST be present (ev. add check)
-        return (transientData == null) ? pInfo.getValues() : transientData.values;
+        // if transientData are null the data MUST be present (ev. add check)
+        return (transientData == null) ? data.values : transientData.values;
-        if (transientData == null) {
-            transientData = new TransientData(type, values);
+        if (getStatus() == Status.NEW) {
+            if (data == null) {
+                data = new PropertyData(type, values);
+            } else {
+                data.setValues(type, values);
+            }
-            transientData.setValues(type, values);
+            if (transientData == null) {
+                transientData = new PropertyData(type, values);
+            } else {
+                transientData.setValues(type, values);
+            }
+            markModified();
-        markModified();
-    private static boolean diff(PropertyState p1, PropertyState p2) {
+    private static boolean diff(PropertyData p1, PropertyData p2) {
-        if (p1.getType() != p2.getType()) {
+        if (p1.type != p2.type) {
-        QValue[] vs1 = p1.getValues();
-        QValue[] vs2 = p2.getValues();
+        QValue[] vs1 = p1.values;
+        QValue[] vs2 = p2.values;
-     * Inner class storing transient property values an their type.
+     * Inner class storing property values an their type.
-    private class TransientData {
+    private class PropertyData {
-        private TransientData(int type, QValue[] values) throws RepositoryException {
+        private PropertyData(PropertyInfo pInfo) {
+            this.type = pInfo.getType();
+            this.values = pInfo.getValues();
+        }
+
+        private PropertyData(int type, QValue[] values) throws ConstraintViolationException, RepositoryException {
-        private void setValues(int type, QValue[] values) throws RepositoryException {
+        private void setValues(int type, QValue[] values) throws ConstraintViolationException, RepositoryException {

UPD43 UPD43 INS44 INS44 INS43 INS43 MOV21 INS43 INS43 INS8 MOV60 UPD42 INS31 INS65 UPD42 INS65 UPD42 UPD42 INS5 INS42 INS39 INS42 INS42 INS42 INS21 INS42 INS42 INS25 UPD43 UPD43 INS83 INS42 INS44 INS8 UPD42 INS43 INS43 INS66 INS66 INS66 INS43 INS85 INS32 UPD66 UPD66 UPD66 UPD66 UPD27 INS8 INS27 INS8 MOV8 UPD42 UPD42 UPD66 INS43 INS42 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS14 UPD42 INS22 INS42 UPD27 INS41 INS41 INS40 INS40 INS32 INS40 INS25 INS40 INS40 UPD42 INS40 UPD42 INS40 INS42 INS7 INS7 UPD42 INS43 INS42 INS42 MOV22 UPD42 INS36 INS42 INS42 INS9 INS42 INS27 INS8 INS8 INS22 MOV32 INS22 MOV32 INS42 UPD42 INS11 INS42 INS33 INS21 INS21 INS52 INS42 INS52 INS42 INS43 INS42 INS7 INS32 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS43 INS42 INS42 UPD43 INS42 UPD42 DEL40 DEL26 DEL52 DEL42 DEL22 DEL33 DEL7 DEL21 DEL52 DEL42 DEL22 DEL33 DEL7 DEL21 DEL42 DEL52 DEL42 DEL43 DEL42 DEL11 DEL42 DEL38 DEL42 DEL9 DEL7 DEL21 DEL42 DEL41 DEL65 DEL65 DEL42 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL29 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL52 DEL27 DEL42 DEL40 DEL32 DEL21 DEL8 DEL25 DEL8 DEL24 DEL8 DEL31 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32
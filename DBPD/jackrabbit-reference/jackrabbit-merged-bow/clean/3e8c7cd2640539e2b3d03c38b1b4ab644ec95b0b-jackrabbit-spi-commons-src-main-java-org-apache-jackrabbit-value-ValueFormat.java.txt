JCR-1152: JCR2SPI: use own ValueFactory, wrapping the SPI's QValueFactory: spi-commons: add implementations of ValueFactory wrapping QValueFactory and Value wrapping a QValue. QValueFactoryImpl: Fix conversions that weren't called before. ValueFormat: take advantage of known ValueFactory/Value implementations.


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@590140 13f79535-47bb-0310-9956-ffa450edef68

-        }
-        if (jcrValue.getType() == PropertyType.BINARY) {
+        } else if (jcrValue instanceof QValueValue) {
+            return ((QValueValue)jcrValue).getQValue();
+        } else if (jcrValue.getType() == PropertyType.BINARY) {
-        Value jcrValue;
-        int propertyType = qualifiedValue.getType();
-        switch (propertyType) {
-            case PropertyType.STRING:
-            case PropertyType.BOOLEAN:
-            case PropertyType.REFERENCE:
-                jcrValue = factory.createValue(qualifiedValue.getString(), propertyType);
-                break;
-            case PropertyType.PATH:
-                Path qPath = qualifiedValue.getPath();
-                jcrValue = factory.createValue(resolver.getJCRPath(qPath), propertyType);
-                break;
-            case PropertyType.NAME:
-                Name qName = qualifiedValue.getName();
-                jcrValue = factory.createValue(resolver.getJCRName(qName), propertyType);
-                break;
-            case PropertyType.BINARY:
-                jcrValue = factory.createValue(qualifiedValue.getStream());
-                break;
-            case PropertyType.DATE:
-                jcrValue = factory.createValue(qualifiedValue.getCalendar());
-                break;
-            case PropertyType.DOUBLE:
-              jcrValue = factory.createValue(qualifiedValue.getDouble());
-              break;
-            case PropertyType.LONG:
-                jcrValue = factory.createValue(qualifiedValue.getLong());
-                break;
-            default:
-                throw new RepositoryException("illegal internal value type");
+        if (factory instanceof ValueFactoryQImpl) {
+            return ((ValueFactoryQImpl)factory).createValue(qualifiedValue);
-        return jcrValue;
+        else {
+            Value jcrValue;
+            int propertyType = qualifiedValue.getType();
+            switch (propertyType) {
+                case PropertyType.STRING:
+                case PropertyType.BOOLEAN:
+                case PropertyType.REFERENCE:
+                    jcrValue = factory.createValue(qualifiedValue.getString(), propertyType);
+                    break;
+                case PropertyType.PATH:
+                    Path qPath = qualifiedValue.getPath();
+                    jcrValue = factory.createValue(resolver.getJCRPath(qPath), propertyType);
+                    break;
+                case PropertyType.NAME:
+                    Name qName = qualifiedValue.getName();
+                    jcrValue = factory.createValue(resolver.getJCRName(qName), propertyType);
+                    break;
+                case PropertyType.BINARY:
+                    jcrValue = factory.createValue(qualifiedValue.getStream());
+                    break;
+                case PropertyType.DATE:
+                    jcrValue = factory.createValue(qualifiedValue.getCalendar());
+                    break;
+                case PropertyType.DOUBLE:
+                  jcrValue = factory.createValue(qualifiedValue.getDouble());
+                  break;
+                case PropertyType.LONG:
+                    jcrValue = factory.createValue(qualifiedValue.getLong());
+                    break;
+                default:
+                    throw new RepositoryException("illegal internal value type");
+            }
+            return jcrValue;
+        }

INS8 INS25 INS25 MOV27 MOV8 INS25 INS62 INS8 MOV8 INS62 INS8 MOV25 INS42 INS43 INS41 INS42 INS43 INS41 INS42 INS32 INS42 INS32 INS36 INS42 INS42 INS36 INS42 INS11 INS11 INS43 INS42 INS43 INS42 INS42 INS42 DEL25
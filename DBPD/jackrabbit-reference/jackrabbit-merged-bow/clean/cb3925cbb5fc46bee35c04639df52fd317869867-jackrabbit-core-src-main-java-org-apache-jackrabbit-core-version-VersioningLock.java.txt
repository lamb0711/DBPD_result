JCR-3379 XA concurrent transactions - NullPointerException

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1360013 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.Arrays;
-
-import javax.transaction.xa.Xid;
-
-import org.apache.jackrabbit.core.TransactionContext;
-
+import static org.apache.jackrabbit.core.TransactionContext.getCurrentThreadId;
+import static org.apache.jackrabbit.core.TransactionContext.isSameThreadId;
-     * Thread concerning ReentrantWriterPreferenceReadWriteLock
-    private final ReadWriteLock rwLock =
-        new ReentrantWriterPreferenceReadWriteLock();
-
-    /**
-     * The internal Xid aware read-write lock.
-     */
-    private final ReadWriteLock xidRwLock = new XidRWLock();
+    private final ReadWriteLock rwLock = new XAAwareRWLock();
-        if (TransactionContext.getCurrentXid() == null) {
-            return new ReadLock(rwLock.readLock());
-        } else {
-            return new ReadLock(xidRwLock.readLock());
-        }
+    	return new ReadLock(rwLock.readLock());
-        if (TransactionContext.getCurrentXid() == null) {
-            return new WriteLock(rwLock);
-        } else {
-            return new WriteLock(xidRwLock);
-        }
+    	return new WriteLock(rwLock);
-     * Xid concerning ReentrantWriterPreferenceReadWriteLock
+     * XA concerning ReentrantWriterPreferenceReadWriteLock
-    private static final class XidRWLock
+    private static final class XAAwareRWLock
-        private Xid activeXid;
+    	private Object activeWriter;
-         * Check if the given Xid comes from the same globalTX
-         * @param otherXid
-         * @return true if same globalTX otherwise false
+         * {@inheritDoc}
-        boolean isSameGlobalTx(Xid otherXid) {
-            return (activeXid == otherXid) || Arrays.equals(activeXid.getGlobalTransactionId(), otherXid.getGlobalTransactionId());
-        }
-
-        /**
-         * Allow reader when there is no active Xid, or current Xid owns
-         * the write lock (reentrant).
-         */
-        @Override
-            Xid currentXid = TransactionContext.getCurrentXid();
-            return (activeXid == null && waitingWriters_ == 0) || isSameGlobalTx(currentXid);
+            Object currentId = getCurrentThreadId();
+            return (activeWriter == null && waitingWriters_ == 0) || isSameThreadId(activeWriter, currentId);
-        @Override
-            Xid currentXid = TransactionContext.getCurrentXid();
-            if (activeXid != null && isSameGlobalTx(currentXid)) { // already held; re-acquire
-                ++writeHolds_;
+        	Object currentId = getCurrentThreadId();
+            if (activeWriter != null && isSameThreadId(activeWriter, currentId)) { // already held; re-acquire
+            	++writeHolds_;
-                if (activeReaders_ == 0 || (readers_.size() == 1 && readers_.get(currentXid) != null)) {
-                    activeXid = currentXid;
-                    writeHolds_ = 1;
-                    return true;
-                } else {
-                    return false;
-                }
+            	if (activeReaders_ == 0 || (readers_.size() == 1 && readers_.get(currentId) != null)) {
+            		activeWriter = currentId;
+            		writeHolds_ = 1;
+            		return true;
+            	} else {
+            		return false;
+            	}
-                return false;
+            	return false;
-        @Override
-                return null;
+            	return null;
-                activeXid = null;
+            	activeWriter = null;
-        @Override
-        @SuppressWarnings("unchecked")
-        protected synchronized boolean startRead() {
-            Xid currentXid = TransactionContext.getCurrentXid();
-            Object c = readers_.get(currentXid);
-            if (c != null) { // already held -- just increment hold count
-                readers_.put(currentXid, (Integer) (c) + 1);
-                ++activeReaders_;
-                return true;
-            } else if (allowReader()) {
-                readers_.put(currentXid, IONE);
-                ++activeReaders_;
-                return true;
-            } else {
-                return false;
-            }
-        }
+    	@SuppressWarnings("unchecked")
+    	protected synchronized boolean startRead() {
+    		Object currentId = getCurrentThreadId();
+    	    Object c = readers_.get(currentId);
+    	    if (c != null) { // already held -- just increment hold count
+    	    	readers_.put(currentId, new Integer(((Integer)(c)).intValue()+1));
+    	    	++activeReaders_;
+    	    	return true;
+    	    } else if (allowReader()) {
+    	    	readers_.put(currentId, IONE);
+    	    	++activeReaders_;
+    	    	return true;
+    	    } else {
+    	    	return false;
+    	    }
+    	}
-        @Override
-        @SuppressWarnings("unchecked")
-        protected synchronized Signaller endRead() {
-            Xid currentXid = TransactionContext.getCurrentXid();
-            Object c = readers_.get(currentXid);
-            if (c == null) {
-                throw new IllegalStateException();
-            }
-            --activeReaders_;
-            if (c != IONE) { // more than one hold; decrement count
-                int h = (Integer) (c) -1;
-                Integer ih = (h == 1)? IONE : new Integer(h);
-                readers_.put(currentXid, ih);
-                return null;
-            } else {
-                readers_.remove(currentXid);
-
-                if (writeHolds_ > 0) { // a write lock is still held
-                    return null;
-                } else if (activeReaders_ == 0 && waitingWriters_ > 0) {
-                    return writerLock_;
-                } else  {
-                    return null;
-                }
-            }
-        }
-
+    	@SuppressWarnings("unchecked")
+    	protected synchronized Signaller endRead() {
+    		Object currentId = getCurrentThreadId();
+    	    Object c = readers_.get(currentId);
+    	    if (c == null) {
+    	    	throw new IllegalStateException();
+    	    }
+    	    --activeReaders_;
+    	    if (c != IONE) { // more than one hold; decrement count
+    	    	int h = ((Integer)(c)).intValue()-1;
+    	    	Integer ih = (h == 1)? IONE : new Integer(h);
+    	    	readers_.put(currentId, ih);
+    	    	return null;
+    	    } else {
+    	    	readers_.remove(currentId);
+    	    
+    	    	if (writeHolds_ > 0) { // a write lock is still held
+    	    		return null;
+    	    	} else if (activeReaders_ == 0 && waitingWriters_ > 0) {
+    	    		return writerLock_;
+    	    	} else  {
+    	    		return null;
+    	    	}
+    	    }
+    	}
-

UPD40 UPD40 MOV43 MOV8 MOV8 UPD42 UPD42 UPD43 UPD66 UPD43 UPD66 UPD42 UPD42 INS65 UPD42 INS65 UPD43 UPD43 UPD43 INS43 MOV43 MOV43 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 MOV21 MOV41 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 MOV21 MOV41 UPD42 UPD42 UPD42 UPD42 INS14 UPD27 MOV27 UPD42 UPD42 UPD42 INS43 UPD27 MOV27 UPD42 INS32 INS42 INS32 INS36 INS42 UPD42 UPD42 INS36 INS42 MOV11 MOV11 UPD42 DEL40 DEL26 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL42 DEL43 DEL14 DEL59 DEL23 DEL42 DEL43 DEL42 DEL42 DEL32 DEL33 DEL27 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL41 DEL8 DEL25 DEL8 DEL42 DEL42 DEL32 DEL33 DEL27 DEL42 DEL43 DEL42 DEL14 DEL41 DEL8 DEL25 DEL8 DEL66 DEL65 DEL42 DEL65 DEL66 DEL65 DEL29 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL27 DEL36 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL27 DEL41 DEL8 DEL31 DEL66 DEL66 DEL65 DEL42 DEL78 DEL42 DEL42 DEL78 DEL42 DEL42 DEL78 DEL42 DEL78 DEL42 DEL42 DEL78 DEL42 DEL43 DEL42
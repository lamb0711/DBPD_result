JCR-857: Basic support for fn:name()

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@531159 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.SearchManager;
-import org.apache.jackrabbit.name.MalformedPathException;
+import org.apache.jackrabbit.util.ISO9075;
-        switch (node.getOperation()) {
-            case QueryConstants.OPERATION_EQ_VALUE:      // =
-            case QueryConstants.OPERATION_EQ_GENERAL:
-                BooleanQuery or = new BooleanQuery();
-                for (int i = 0; i < stringValues.length; i++) {
-                    Term t = new Term(FieldNames.PROPERTIES,
-                                FieldNames.createNamedValue(field, stringValues[i]));
-                    Query q;
-                    if (transform[0] == TransformConstants.TRANSFORM_UPPER_CASE) {
-                        q = new CaseTermQuery.Upper(t);
-                    } else if (transform[0] == TransformConstants.TRANSFORM_LOWER_CASE) {
-                        q = new CaseTermQuery.Lower(t);
-                    } else {
-                        q = new TermQuery(t);
+        // support for fn:name()
+        QName propName = relPath.getNameElement().getName();
+        if (propName.getNamespaceURI().equals(SearchManager.NS_FN_URI) &&
+                propName.getLocalName().equals("name()")) {
+            if (node.getValueType() != QueryConstants.TYPE_STRING) {
+                exceptions.add(new InvalidQueryException("Name function can " +
+                        "only be used in conjunction with a string literal"));
+                return data;
+            }
+            if (node.getOperation() != QueryConstants.OPERATION_EQ_VALUE &&
+                    node.getOperation() != QueryConstants.OPERATION_EQ_GENERAL) {
+                exceptions.add(new InvalidQueryException("Name function can " +
+                        "only be used in conjunction with an equals operator"));
+                return data;
+            }
+            // check if string literal is a valid XML QName
+            if (XMLChar.isValidName(node.getStringValue())) {
+                // parse string literal as JCR QName
+                try {
+                    String translatedQName = nsMappings.translatePropertyName(
+                            ISO9075.decode(node.getStringValue()),
+                            session.getNamespaceResolver());
+                    Term t = new Term(FieldNames.LABEL, translatedQName);
+                    query = new TermQuery(t);
+                } catch (NameException e) {
+                    exceptions.add(e);
+                    return data;
+                }
+            } else {
+                // will never match -> create dummy query
+                query = new TermQuery(new Term(FieldNames.UUID, ""));
+            }
+        } else {
+            switch (node.getOperation()) {
+                case QueryConstants.OPERATION_EQ_VALUE:      // =
+                case QueryConstants.OPERATION_EQ_GENERAL:
+                    BooleanQuery or = new BooleanQuery();
+                    for (int i = 0; i < stringValues.length; i++) {
+                        Term t = new Term(FieldNames.PROPERTIES,
+                                    FieldNames.createNamedValue(field, stringValues[i]));
+                        Query q;
+                        if (transform[0] == TransformConstants.TRANSFORM_UPPER_CASE) {
+                            q = new CaseTermQuery.Upper(t);
+                        } else if (transform[0] == TransformConstants.TRANSFORM_LOWER_CASE) {
+                            q = new CaseTermQuery.Lower(t);
+                        } else {
+                            q = new TermQuery(t);
+                        }
+                        or.add(q, Occur.SHOULD);
-                    or.add(q, Occur.SHOULD);
-                }
-                query = or;
-                if (node.getOperation() == QueryConstants.OPERATION_EQ_VALUE) {
-                    query = createSingleValueConstraint(or, field);
-                }
-                break;
-            case QueryConstants.OPERATION_GE_VALUE:      // >=
-            case QueryConstants.OPERATION_GE_GENERAL:
-                or = new BooleanQuery();
-                for (int i = 0; i < stringValues.length; i++) {
-                    Term lower = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, stringValues[i]));
-                    Term upper = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, "\uFFFF"));
-                    or.add(new RangeQuery(lower, upper, true, transform[0]), Occur.SHOULD);
-                }
-                query = or;
-                if (node.getOperation() == QueryConstants.OPERATION_GE_VALUE) {
-                    query = createSingleValueConstraint(or, field);
-                }
-                break;
-            case QueryConstants.OPERATION_GT_VALUE:      // >
-            case QueryConstants.OPERATION_GT_GENERAL:
-                or = new BooleanQuery();
-                for (int i = 0; i < stringValues.length; i++) {
-                    Term lower = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, stringValues[i]));
-                    Term upper = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, "\uFFFF"));
-                    or.add(new RangeQuery(lower, upper, false, transform[0]), Occur.SHOULD);
-                }
-                query = or;
-                if (node.getOperation() == QueryConstants.OPERATION_GT_VALUE) {
-                    query = createSingleValueConstraint(or, field);
-                }
-                break;
-            case QueryConstants.OPERATION_LE_VALUE:      // <=
-            case QueryConstants.OPERATION_LE_GENERAL:      // <=
-                or = new BooleanQuery();
-                for (int i = 0; i < stringValues.length; i++) {
-                    Term lower = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, ""));
-                    Term upper = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, stringValues[i]));
-                    or.add(new RangeQuery(lower, upper, true, transform[0]), Occur.SHOULD);
-                }
-                query = or;
-                if (node.getOperation() == QueryConstants.OPERATION_LE_VALUE) {
-                    query = createSingleValueConstraint(query, field);
-                }
-                break;
-            case QueryConstants.OPERATION_LIKE:          // LIKE
-                // the like operation always has one string value.
-                // no coercing, see above
-                if (stringValues[0].equals("%")) {
+                    query = or;
+                    if (node.getOperation() == QueryConstants.OPERATION_EQ_VALUE) {
+                        query = createSingleValueConstraint(or, field);
+                    }
+                    break;
+                case QueryConstants.OPERATION_GE_VALUE:      // >=
+                case QueryConstants.OPERATION_GE_GENERAL:
+                    or = new BooleanQuery();
+                    for (int i = 0; i < stringValues.length; i++) {
+                        Term lower = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, stringValues[i]));
+                        Term upper = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, "\uFFFF"));
+                        or.add(new RangeQuery(lower, upper, true, transform[0]), Occur.SHOULD);
+                    }
+                    query = or;
+                    if (node.getOperation() == QueryConstants.OPERATION_GE_VALUE) {
+                        query = createSingleValueConstraint(or, field);
+                    }
+                    break;
+                case QueryConstants.OPERATION_GT_VALUE:      // >
+                case QueryConstants.OPERATION_GT_GENERAL:
+                    or = new BooleanQuery();
+                    for (int i = 0; i < stringValues.length; i++) {
+                        Term lower = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, stringValues[i]));
+                        Term upper = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, "\uFFFF"));
+                        or.add(new RangeQuery(lower, upper, false, transform[0]), Occur.SHOULD);
+                    }
+                    query = or;
+                    if (node.getOperation() == QueryConstants.OPERATION_GT_VALUE) {
+                        query = createSingleValueConstraint(or, field);
+                    }
+                    break;
+                case QueryConstants.OPERATION_LE_VALUE:      // <=
+                case QueryConstants.OPERATION_LE_GENERAL:      // <=
+                    or = new BooleanQuery();
+                    for (int i = 0; i < stringValues.length; i++) {
+                        Term lower = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, ""));
+                        Term upper = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, stringValues[i]));
+                        or.add(new RangeQuery(lower, upper, true, transform[0]), Occur.SHOULD);
+                    }
+                    query = or;
+                    if (node.getOperation() == QueryConstants.OPERATION_LE_VALUE) {
+                        query = createSingleValueConstraint(query, field);
+                    }
+                    break;
+                case QueryConstants.OPERATION_LIKE:          // LIKE
+                    // the like operation always has one string value.
+                    // no coercing, see above
+                    if (stringValues[0].equals("%")) {
+                        query = new MatchAllQuery(field);
+                    } else {
+                        query = new WildcardQuery(FieldNames.PROPERTIES, field, stringValues[0], transform[0]);
+                    }
+                    break;
+                case QueryConstants.OPERATION_LT_VALUE:      // <
+                case QueryConstants.OPERATION_LT_GENERAL:
+                    or = new BooleanQuery();
+                    for (int i = 0; i < stringValues.length; i++) {
+                        Term lower = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, ""));
+                        Term upper = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, stringValues[i]));
+                        or.add(new RangeQuery(lower, upper, false, transform[0]), Occur.SHOULD);
+                    }
+                    query = or;
+                    if (node.getOperation() == QueryConstants.OPERATION_LT_VALUE) {
+                        query = createSingleValueConstraint(or, field);
+                    }
+                    break;
+                case QueryConstants.OPERATION_NE_VALUE:      // !=
+                    // match nodes with property 'field' that includes svp and mvp
+                    BooleanQuery notQuery = new BooleanQuery();
+                    notQuery.add(new MatchAllQuery(field), Occur.SHOULD);
+                    // exclude all nodes where 'field' has the term in question
+                    for (int i = 0; i < stringValues.length; i++) {
+                        Term t = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, stringValues[i]));
+                        Query q;
+                        if (transform[0] == TransformConstants.TRANSFORM_UPPER_CASE) {
+                            q = new CaseTermQuery.Upper(t);
+                        } else if (transform[0] == TransformConstants.TRANSFORM_LOWER_CASE) {
+                            q = new CaseTermQuery.Lower(t);
+                        } else {
+                            q = new TermQuery(t);
+                        }
+                        notQuery.add(q, Occur.MUST_NOT);
+                    }
+                    // and exclude all nodes where 'field' is multi valued
+                    notQuery.add(new TermQuery(new Term(FieldNames.MVP, field)), Occur.MUST_NOT);
+                    query = notQuery;
+                    break;
+                case QueryConstants.OPERATION_NE_GENERAL:    // !=
+                    // that's:
+                    // all nodes with property 'field'
+                    // minus the nodes that have a single property 'field' that is
+                    //    not equal to term in question
+                    // minus the nodes that have a multi-valued property 'field' and
+                    //    all values are equal to term in question
+                    notQuery = new BooleanQuery();
+                    notQuery.add(new MatchAllQuery(field), Occur.SHOULD);
+                    for (int i = 0; i < stringValues.length; i++) {
+                        // exclude the nodes that have the term and are single valued
+                        Term t = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, stringValues[i]));
+                        Query svp = new NotQuery(new TermQuery(new Term(FieldNames.MVP, field)));
+                        BooleanQuery and = new BooleanQuery();
+                        Query q;
+                        if (transform[0] == TransformConstants.TRANSFORM_UPPER_CASE) {
+                            q = new CaseTermQuery.Upper(t);
+                        } else if (transform[0] == TransformConstants.TRANSFORM_LOWER_CASE) {
+                            q = new CaseTermQuery.Lower(t);
+                        } else {
+                            q = new TermQuery(t);
+                        }
+                        and.add(q, Occur.MUST);
+                        and.add(svp, Occur.MUST);
+                        notQuery.add(and, Occur.MUST_NOT);
+                    }
+                    // todo above also excludes multi-valued properties that contain
+                    //      multiple instances of only stringValues. e.g. text={foo, foo}
+                    query = notQuery;
+                    break;
+                case QueryConstants.OPERATION_NULL:
+                    query = new NotQuery(new MatchAllQuery(field));
+                    break;
+                case QueryConstants.OPERATION_NOT_NULL:
-                } else {
-                    query = new WildcardQuery(FieldNames.PROPERTIES, field, stringValues[0], transform[0]);
-                }
-                break;
-            case QueryConstants.OPERATION_LT_VALUE:      // <
-            case QueryConstants.OPERATION_LT_GENERAL:
-                or = new BooleanQuery();
-                for (int i = 0; i < stringValues.length; i++) {
-                    Term lower = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, ""));
-                    Term upper = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, stringValues[i]));
-                    or.add(new RangeQuery(lower, upper, false, transform[0]), Occur.SHOULD);
-                }
-                query = or;
-                if (node.getOperation() == QueryConstants.OPERATION_LT_VALUE) {
-                    query = createSingleValueConstraint(or, field);
-                }
-                break;
-            case QueryConstants.OPERATION_NE_VALUE:      // !=
-                // match nodes with property 'field' that includes svp and mvp
-                BooleanQuery notQuery = new BooleanQuery();
-                notQuery.add(new MatchAllQuery(field), Occur.SHOULD);
-                // exclude all nodes where 'field' has the term in question
-                for (int i = 0; i < stringValues.length; i++) {
-                    Term t = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, stringValues[i]));
-                    Query q;
-                    if (transform[0] == TransformConstants.TRANSFORM_UPPER_CASE) {
-                        q = new CaseTermQuery.Upper(t);
-                    } else if (transform[0] == TransformConstants.TRANSFORM_LOWER_CASE) {
-                        q = new CaseTermQuery.Lower(t);
-                    } else {
-                        q = new TermQuery(t);
-                    }
-                    notQuery.add(q, Occur.MUST_NOT);
-                }
-                // and exclude all nodes where 'field' is multi valued
-                notQuery.add(new TermQuery(new Term(FieldNames.MVP, field)), Occur.MUST_NOT);
-                query = notQuery;
-                break;
-            case QueryConstants.OPERATION_NE_GENERAL:    // !=
-                // that's:
-                // all nodes with property 'field'
-                // minus the nodes that have a single property 'field' that is
-                //    not equal to term in question
-                // minus the nodes that have a multi-valued property 'field' and
-                //    all values are equal to term in question
-                notQuery = new BooleanQuery();
-                notQuery.add(new MatchAllQuery(field), Occur.SHOULD);
-                for (int i = 0; i < stringValues.length; i++) {
-                    // exclude the nodes that have the term and are single valued
-                    Term t = new Term(FieldNames.PROPERTIES, FieldNames.createNamedValue(field, stringValues[i]));
-                    Query svp = new NotQuery(new TermQuery(new Term(FieldNames.MVP, field)));
-                    BooleanQuery and = new BooleanQuery();
-                    Query q;
-                    if (transform[0] == TransformConstants.TRANSFORM_UPPER_CASE) {
-                        q = new CaseTermQuery.Upper(t);
-                    } else if (transform[0] == TransformConstants.TRANSFORM_LOWER_CASE) {
-                        q = new CaseTermQuery.Lower(t);
-                    } else {
-                        q = new TermQuery(t);
-                    }
-                    and.add(q, Occur.MUST);
-                    and.add(svp, Occur.MUST);
-                    notQuery.add(and, Occur.MUST_NOT);
-                }
-                // todo above also excludes multi-valued properties that contain
-                //      multiple instances of only stringValues. e.g. text={foo, foo}
-                query = notQuery;
-                break;
-            case QueryConstants.OPERATION_NULL:
-                query = new NotQuery(new MatchAllQuery(field));
-                break;
-            case QueryConstants.OPERATION_NOT_NULL:
-                query = new MatchAllQuery(field);
-                break;
-            default:
-                throw new IllegalArgumentException("Unknown relation operation: "
-                        + node.getOperation());
+                    break;
+                default:
+                    throw new IllegalArgumentException("Unknown relation operation: "
+                            + node.getOperation());
+            }

MOV26 INS26 INS40 UPD40 INS60 INS25 INS43 INS59 INS27 INS8 INS8 INS42 INS42 INS32 INS32 INS32 INS25 INS25 INS25 MOV50 INS32 INS42 INS32 INS42 INS40 INS32 INS42 INS45 INS27 INS8 INS27 INS8 INS32 INS8 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS40 INS21 INS41 INS27 INS27 INS21 INS41 INS42 INS42 INS32 INS54 INS21 INS42 INS42 INS32 INS42 INS32 INS40 INS32 INS40 INS32 INS42 INS42 INS42 INS8 INS12 INS7 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS60 INS60 INS21 INS44 INS8 INS42 INS14 INS43 INS27 INS43 INS27 INS43 INS59 INS43 INS59 INS7 INS43 INS42 INS21 INS41 INS43 INS14 INS42 INS45 INS45 INS42 INS45 INS45 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS14 INS42 INS32 INS42 INS42 INS43 INS40 INS45 INS42 INS42 INS32 INS32 INS43 INS40 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42
JCR-742: Use getPath() instead of getParent() to avoid possible AccessDeniedExceptions. Added a default toString() implementation.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@515259 13f79535-47bb-0310-9956-ffa450edef68

+import javax.jcr.AccessDeniedException;
-     * Returns the ancestor of this item at the given depth from the
-     * root node.
+     * Returns the ancestor of this item at the given depth.
-     * The default implementation returns this item if the given depth
-     * equals the return value of the {@link Item#getDepth()} method.
-     * Otherwise calls the method recursively on the parent node.
+     * The default implementation handles the root node at depth zero and
+     * this item at depth equal to the depth of this item as special cases,
+     * and uses {@link javax.jcr.Session#getItem(String)} to retrieve other
+     * ancestors based on the ancestor path calculated from the path of this
+     * node as returned by {@link Item#getPath()}.
+     * @throws ItemNotFoundException if the given depth is negative or greater
+     *                               than the depth of this item
+     * @throws AccessDeniedException if access to the ancestor item is denied
-    public Item getAncestor(int depth) throws RepositoryException {
-        if (getDepth() == depth) {
+    public Item getAncestor(int depth)
+            throws ItemNotFoundException, AccessDeniedException,
+            RepositoryException {
+        if (depth < 0) {
+            throw new ItemNotFoundException(
+                    this + ": Invalid ancestor depth (" + depth + ")");
+        } else if (depth == 0) {
+            return getSession().getRootNode();
+        }
+
+        String path = getPath();
+        int slash = 0;
+        for (int i = 0; i < depth - 1; i++) {
+            slash = path.indexOf('/', slash + 1);
+            if (slash == -1) {
+                throw new ItemNotFoundException(
+                        this + ": Invalid ancestor depth (" + depth + ")");
+            }
+        }
+        slash = path.indexOf('/', slash + 1);
+        if (slash == -1) {
-        } else {
-            return getParent().getAncestor(depth);
+        }
+
+        try {
+            return getSession().getItem(path.substring(0, slash));
+        } catch (ItemNotFoundException e) {
+            throw new AccessDeniedException(
+                    this + ": Ancestor access denied (" + depth + ")");
-     * Recursively calls the method on the parent node and increments
-     * the return value to get the depth of this item. Returns zero if
-     * the parent node is not available (i.e. this is the root node).
+     * The default implementation determines the depth by counting the
+     * slashes in the path returned by {@link Item#getPath()}.
-        try {
-            return getParent().getDepth() + 1;
-        } catch (ItemNotFoundException e) {
+        String path = getPath();
+        if (path.length() == 1) {
+        } else {
+            int depth = 1;
+            int slash = path.indexOf('/', 1);
+            while (slash != -1) {
+                depth++;
+                slash = path.indexOf('/', slash + 1);
+            }
+            return depth;
+        }
+    }
+
+    //--------------------------------------------------------------< Object >
+
+    /**
+     * Returns a string representation of this item.
+     * <p>
+     * The default implementation returns the path of this item and falls
+     * back to the {@link Object#toString()} implementation if the item path
+     * can not be retrieved.
+     *
+     * @return string representation of this item
+     */
+    public String toString() {
+        try {
+            return getPath();
+        } catch (RepositoryException e) {
+            return super.toString();

INS26 INS40 INS31 INS43 INS43 INS29 INS83 INS43 INS42 INS8 INS65 INS65 INS65 INS42 INS42 INS25 INS60 INS60 INS24 INS21 INS25 INS54 INS60 INS25 INS65 INS65 INS42 INS54 UPD66 MOV66 MOV66 UPD66 MOV66 INS66 INS66 INS65 INS66 INS66 UPD66 MOV66 MOV65 UPD66 MOV66 INS42 INS66 UPD66 MOV66 INS42 INS66 INS27 INS8 INS25 INS43 INS59 INS39 INS59 INS58 INS27 INS37 INS8 INS7 INS27 MOV8 INS8 INS12 UPD66 UPD66 INS65 UPD66 INS43 INS59 INS27 MOV8 INS8 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS8 INS12 INS68 INS42 INS34 INS53 INS27 INS8 INS42 INS42 INS32 INS42 INS34 INS39 INS59 INS42 INS27 INS42 INS21 INS25 INS42 INS32 INS42 INS38 MOV41 MOV44 INS8 INS68 INS42 INS42 INS32 INS32 INS34 INS60 INS60 INS61 INS41 INS68 INS41 INS44 INS8 INS40 INS42 INS69 UPD42 INS14 INS42 INS34 INS41 UPD42 MOV42 INS42 INS34 MOV42 INS34 INS7 INS27 INS8 INS42 INS42 INS13 INS27 INS34 INS53 INS42 INS42 INS42 INS42 INS42 INS39 INS59 INS39 INS59 INS27 INS8 INS42 INS42 INS42 INS32 INS43 INS42 INS41 INS43 INS43 INS27 INS32 INS42 INS32 INS42 INS38 INS53 INS42 INS34 UPD42 INS32 INS14 INS42 INS34 INS42 INS32 INS42 INS38 INS21 INS21 INS42 INS42 INS48 INS42 INS42 INS52 INS45 INS42 INS45 INS32 INS42 INS42 INS42 INS13 INS27 INS34 INS14 UPD42 UPD42 MOV42 INS42 INS34 INS42 INS43 INS27 UPD42 MOV42 INS42 INS13 INS34 INS34 INS37 INS7 INS42 INS42 INS42 INS34 INS43 INS27 INS42 INS52 INS45 INS42 INS45 INS42 INS42 INS32 INS42 INS52 INS45 INS42 INS45 INS42 INS42 INS13 INS27 INS42 MOV34 DEL66 DEL65 DEL32 DEL27 DEL8 DEL25 DEL32 DEL42 DEL32 DEL27 DEL41 DEL8 DEL12 DEL54
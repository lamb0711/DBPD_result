re-implementing Workspace methods clone, copy, importXML [work in progress...]
plus various minor fixes and cosmetical changes



git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@158927 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.Constants;
+import org.apache.jackrabbit.core.InternalValue;
+import org.apache.jackrabbit.core.ItemId;
+import org.apache.jackrabbit.core.MalformedPathException;
+import org.apache.jackrabbit.core.NoPrefixDeclaredException;
+import org.apache.jackrabbit.core.NodeId;
+import org.apache.jackrabbit.core.Path;
+import org.apache.jackrabbit.core.PropertyId;
+import org.apache.jackrabbit.core.SessionImpl;
+import org.apache.jackrabbit.core.nodetype.EffectiveNodeType;
+import org.apache.jackrabbit.core.nodetype.NodeTypeRegistry;
+import org.apache.jackrabbit.core.nodetype.PropDef;
+import org.apache.jackrabbit.core.nodetype.PropDefId;
+import org.apache.jackrabbit.core.state.NoSuchItemStateException;
+import org.apache.jackrabbit.core.state.PropertyState;
+import org.apache.jackrabbit.core.util.ReferenceChangeTracker;
+import org.apache.jackrabbit.core.util.ValueHelper;
+import org.apache.jackrabbit.core.util.uuid.UUID;
+import javax.jcr.ItemExistsException;
+import javax.jcr.PropertyType;
+import javax.jcr.Value;
+import javax.jcr.nodetype.ConstraintViolationException;
-import java.util.HashMap;
+import java.util.Calendar;
+import java.util.Iterator;
+import java.util.Set;
-public class WorkspaceImporter implements Importer {
+public class WorkspaceImporter implements Importer, Constants {
+    private final NodeTypeRegistry ntReg;
-     * mapping <original uuid> to <new uuid> of mix:referenceable nodes
+     * helper object that keeps track of remapped uuid's and imported reference
+     * properties that might need correcting depending on the uuid mappings
-    private final HashMap uuidMap;
-    /**
-     * list of imported reference properties that might need correcting
-     */
-    private final ArrayList references;
+    private final ReferenceChangeTracker refTracker;
+    /**
+     * Creates a <code>WorkspaceImporter</code> instance.
+     *
+     * @param importTarget
+     * @param wsp
+     * @param ntReg
+     * @param uuidBehavior
+     */
+                             NodeTypeRegistry ntReg,
+        this.ntReg = ntReg;
-        uuidMap = new HashMap();
-        references = new ArrayList();
+        refTracker = new ReferenceChangeTracker();
+    /**
+     * Failsafe translation of internal <code>ItemId</code> to JCR path for
+     * use in error messages etc.
+     *
+     * @param id id to translate
+     * @return JCR path
+     */
+    private String resolveJCRPath(ItemId id) {
+        Path path;
+        try {
+            path = hierMgr.getPath(id);
+        } catch (RepositoryException re) {
+            log.error(id + ": failed to determine path to");
+            // return string representation if id as a fallback
+            return id.toString();
+        }
+        try {
+            return path.toJCRPath(((SessionImpl) wsp.getSession()).getNamespaceResolver());
+        } catch (NoPrefixDeclaredException npde) {
+            log.error("failed to convert " + path.toString() + " to JCR path.");
+            // return string representation of internal path as a fallback
+            return path.toString();
+        }
+    }
+
+        ChildNodeDef def =
+                wsp.findApplicableNodeDefinition(nodeName, nodeTypeName, parent);
+        return createNode(parent, nodeName, nodeTypeName, mixinNames, uuid, def);
+    }
+
+    protected NodeState createNode(NodeState parent,
+                                   QName nodeName,
+                                   QName nodeTypeName,
+                                   QName[] mixinNames,
+                                   String uuid,
+                                   ChildNodeDef def)
+            throws RepositoryException {
+        // check for name collisions with existing properties
+        if (parent.hasPropertyEntry(nodeName)) {
+            String msg = "there's already a property with name " + nodeName;
+            log.debug(msg);
+            throw new RepositoryException(msg);
+        }
+        // check for name collisions with existing nodes
+        if (!def.allowSameNameSibs() && parent.hasChildNodeEntry(nodeName)) {
+            NodeId id = new NodeId(parent.getChildNodeEntry(nodeName, 1).getUUID());
+            throw new ItemExistsException(resolveJCRPath(id));
+        }
+        if (uuid == null) {
+            // create new uuid
+            uuid = UUID.randomUUID().toString();    // create new version 4 uuid
+        }
+        if (nodeTypeName == null) {
+            // no primary node type specified,
+            // try default primary type from definition
+            nodeTypeName = def.getDefaultPrimaryType();
+            if (nodeTypeName == null) {
+                String msg = "an applicable node type could not be determined for "
+                        + nodeName;
+                log.debug(msg);
+                throw new ConstraintViolationException (msg);
+            }
+        }
-        node.setMixinTypeNames(new HashSet(Arrays.asList(mixinNames)));
-        ChildNodeDef nodeDef =
-                wsp.findApplicableDefinition(nodeName, nodeTypeName, parent);
-        node.setDefinitionId(new NodeDefId(nodeDef));
+        if (mixinNames != null && mixinNames.length > 0) {
+            node.setMixinTypeNames(new HashSet(Arrays.asList(mixinNames)));
+        }
+        node.setDefinitionId(new NodeDefId(def));
+        EffectiveNodeType ent = wsp.getEffectiveNodeType(node);
+        // add 'auto-create' properties defined in node type
+        PropDef[] pda = ent.getAutoCreatePropDefs();
+        for (int i = 0; i < pda.length; i++) {
+            PropDef pd = pda[i];
+            createProperty(node, pd.getName(), pd.getRequiredType(), pd);
+        }
+
+        // recursively add 'auto-create' child nodes defined in node type
+        ChildNodeDef[] nda = ent.getAutoCreateNodeDefs();
+        for (int i = 0; i < nda.length; i++) {
+            ChildNodeDef nd = nda[i];
+            createNode(node, nd.getName(), nd.getDefaultPrimaryType(),
+                    null, null, nd);
+        }
+
+    protected PropertyState createProperty(NodeState parent,
+                                           QName propName,
+                                           int type,
+                                           int numValues)
+            throws RepositoryException {
+        // find applicable definition
+        PropDef def;
+        // multi- or single-valued property?
+        if (numValues == 1) {
+            // could be single- or multi-valued (n == 1)
+            try {
+                // try single-valued
+                def = wsp.findApplicablePropertyDefinition(propName,
+                        type, false, parent);
+            } catch (ConstraintViolationException cve) {
+                // try multi-valued
+                def = wsp.findApplicablePropertyDefinition(propName,
+                        type, true, parent);
+            }
+        } else {
+            // can only be multi-valued (n == 0 || n > 1)
+            def = wsp.findApplicablePropertyDefinition(propName,
+                    type, true, parent);
+        }
+        return createProperty(parent, propName, type, def);
+    }
+
+    protected PropertyState createProperty(NodeState parent,
+                                           QName propName,
+                                           int type,
+                                           PropDef def)
+            throws RepositoryException {
+        // check for name collisions with existing child nodes
+        if (parent.hasChildNodeEntry(propName)) {
+            String msg = "there's already a child node with name " + propName;
+            log.debug(msg);
+            throw new RepositoryException(msg);
+        }
+
+        // create property
+        PropertyState prop = stateMgr.createNew(propName, parent.getUUID());
+
+        prop.setDefinitionId(new PropDefId(def));
+        if (def.getRequiredType() != PropertyType.UNDEFINED) {
+            prop.setType(def.getRequiredType());
+        } else if (type != PropertyType.UNDEFINED) {
+            prop.setType(type);
+        } else {
+            prop.setType(PropertyType.STRING);
+        }
+        prop.setMultiValued(def.isMultiple());
+
+        // compute system generated values if necessary
+        InternalValue[] genValues =
+                computeSystemGeneratedPropertyValues(parent, propName, def);
+        if (genValues != null) {
+            prop.setValues(genValues);
+        } else if (def.getDefaultValues() != null) {
+            prop.setValues(def.getDefaultValues());
+        }
+
+        // now add new property entry to parent
+        parent.addPropertyEntry(propName);
+
+        return prop;
+    }
+
+    /**
+     * Computes the values of well-known system (i.e. protected) properties.
+     * todo: duplicate code in NodeImpl: consolidate and delegate to NodeTypeInstanceHandler
+     *
+     * @param parent
+     * @param name
+     * @param def
+     * @return
+     * @throws RepositoryException
+     */
+    protected InternalValue[] computeSystemGeneratedPropertyValues(NodeState parent,
+                                                                   QName name,
+                                                                   PropDef def)
+            throws RepositoryException {
+        InternalValue[] genValues = null;
+
+        /**
+         * todo: need to come up with some callback mechanism for applying system generated values
+         * (e.g. using a NodeTypeInstanceHandler interface)
+         */
+
+        // compute system generated values
+        QName declaringNT = def.getDeclaringNodeType();
+        if (MIX_REFERENCEABLE.equals(declaringNT)) {
+            // mix:referenceable node type
+            if (JCR_UUID.equals(name)) {
+                // jcr:uuid property
+                genValues = new InternalValue[]{InternalValue.create(parent.getUUID())};
+            }
+        } else if (NT_BASE.equals(declaringNT)) {
+            // nt:base node type
+            if (JCR_PRIMARYTYPE.equals(name)) {
+                // jcr:primaryType property
+                genValues = new InternalValue[]{InternalValue.create(parent.getNodeTypeName())};
+            } else if (JCR_MIXINTYPES.equals(name)) {
+                // jcr:mixinTypes property
+                Set mixins = parent.getMixinTypeNames();
+                ArrayList values = new ArrayList(mixins.size());
+                Iterator iter = mixins.iterator();
+                while (iter.hasNext()) {
+                    values.add(InternalValue.create((QName) iter.next()));
+                }
+                genValues = (InternalValue[]) values.toArray(new InternalValue[values.size()]);
+            }
+        } else if (NT_HIERARCHYNODE.equals(declaringNT)) {
+            // nt:hierarchyNode node type
+            if (JCR_CREATED.equals(name)) {
+                // jcr:created property
+                genValues = new InternalValue[]{InternalValue.create(Calendar.getInstance())};
+            }
+        } else if (NT_RESOURCE.equals(declaringNT)) {
+            // nt:resource node type
+            if (JCR_LASTMODIFIED.equals(name)) {
+                // jcr:lastModified property
+                genValues = new InternalValue[]{InternalValue.create(Calendar.getInstance())};
+            }
+        } else if (NT_VERSION.equals(declaringNT)) {
+            // nt:version node type
+            if (JCR_CREATED.equals(name)) {
+                // jcr:created property
+                genValues = new InternalValue[]{InternalValue.create(Calendar.getInstance())};
+            }
+/*
+        // FIXME delegate to NodeTypeInstanceHandler
+        } else if (MIX_VERSIONABLE.equals(declaringNT)) {
+	    // mix:versionable node type
+	    if (JCR_VERSIONHISTORY.equals(name)) {
+		// jcr:versionHistory property
+		genValues = new InternalValue[]{InternalValue.create(new UUID(hist.getUUID()))};
+	    } else if (JCR_BASEVERSION.equals(name)) {
+		// jcr:baseVersion property
+		genValues = new InternalValue[]{InternalValue.create(new UUID(hist.getRootVersion().getUUID()))};
+	    } else if (JCR_ISCHECKEDOUT.equals(name)) {
+		// jcr:isCheckedOut property
+		genValues = new InternalValue[]{InternalValue.create(true)};
+	    } else if (JCR_PREDECESSORS.equals(name)) {
+		// jcr:predecessors property
+		genValues = new InternalValue[]{InternalValue.create(new UUID(hist.getRootVersion().getUUID()))};
+	    }
+*/
+        }
+
+        return genValues;
+    }
+
+    /**
+     * Recursively removes the specified node state including its properties and
+     * child nodes.
+     * <p/>
+     * todo duplicate code in WorkspaceImpl; consolidate in WorkspaceOperations class
+     *
+     * @param target
+     * @param parentUUID
+     * @throws RepositoryException if an error occurs
+     */
+    protected void removeNode(NodeState target, String parentUUID)
+            throws RepositoryException {
+        // check if this node state would be orphaned after unlinking it from parent
+        ArrayList parentUUIDs = new ArrayList(target.getParentUUIDs());
+        parentUUIDs.remove(parentUUID);
+        boolean orphaned = parentUUIDs.isEmpty();
+
+        if (orphaned) {
+            // remove child nodes
+            // use temp array to avoid ConcurrentModificationException
+            ArrayList tmp = new ArrayList(target.getChildNodeEntries());
+            // remove from tail to avoid problems with same-name siblings
+            for (int i = tmp.size() - 1; i >= 0; i--) {
+                NodeState.ChildNodeEntry entry = (NodeState.ChildNodeEntry) tmp.get(i);
+                NodeId nodeId = new NodeId(entry.getUUID());
+                try {
+                    NodeState node = (NodeState) stateMgr.getItemState(nodeId);
+                    // check if existing can be removed
+                    // (access rights, locking & versioning status)
+                    wsp.checkRemoveNode(node,
+                            WorkspaceImpl.CHECK_ACCESS | WorkspaceImpl.CHECK_LOCK
+                            | WorkspaceImpl.CHECK_VERSIONING);
+                    // remove child node (recursive)
+                    removeNode(node, target.getUUID());
+                } catch (ItemStateException ise) {
+                    String msg = "internal error: failed to retrieve state of "
+                            + nodeId;
+                    log.debug(msg);
+                    throw new RepositoryException(msg, ise);
+                }
+                // remove child node entry
+                target.removeChildNodeEntry(entry.getName(), entry.getIndex());
+            }
+
+            // remove properties
+            // use temp array to avoid ConcurrentModificationException
+            tmp = new ArrayList(target.getPropertyEntries());
+            // remove from tail to avoid problems with same-name siblings
+            for (int i = tmp.size() - 1; i >= 0; i--) {
+                NodeState.PropertyEntry entry = (NodeState.PropertyEntry) tmp.get(i);
+                PropertyId propId =
+                        new PropertyId(target.getUUID(), entry.getName());
+                try {
+                    PropertyState prop = (PropertyState) stateMgr.getItemState(propId);
+                    // remove property entry
+                    target.removePropertyEntry(propId.getName());
+                    // destroy property state
+                    stateMgr.destroy(prop);
+                } catch (ItemStateException ise) {
+                    String msg = "internal error: failed to retrieve state of "
+                            + propId;
+                    log.debug(msg);
+                    throw new RepositoryException(msg, ise);
+                }
+            }
+        }
+
+        // now actually do unlink target state from specified parent state
+        // (i.e. remove uuid of parent state from target state's parent list)
+        target.removeParentUUID(parentUUID);
+
+        if (orphaned) {
+            // destroy target state
+            stateMgr.destroy(target);
+        } else {
+            // store target state
+            stateMgr.store(target);
+        }
+    }
+
-        NodeState node = null;
-/*
+
+        NodeState node;
-            // create new with new uuid
+            // create new with new uuid:
+            // check if new node can be added (check access rights &
+            // node type constraints only, assume locking & versioning status
+            // has already been checked on ancestor)
+            wsp.checkAddNode(parent, nodeInfo.getName(),
+                    nodeInfo.getNodeTypeName(),
+                    WorkspaceImpl.CHECK_ACCESS
+                    | WorkspaceImpl.CHECK_CONSTRAINTS);
-            if (node.isNodeType(Constants.MIX_REFERENCEABLE)) {
-                uuidMap.put(nodeInfo.getUUID(), node.getUUID());
+            EffectiveNodeType ent = wsp.getEffectiveNodeType(node);
+            if (ent.includesNodeType(MIX_REFERENCEABLE)) {
+                refTracker.mappedUUID(nodeInfo.getUUID(), node.getUUID());
-            String msg = "a node with uuid " + nodeInfo.getUUID() + " already exists!";
+            String msg = "a node with uuid " + nodeInfo.getUUID()
+                    + " already exists!";
-            // make sure conflicting node is not importTargetNode or an ancestor thereof
-            if (importTargetNode.getPath().startsWith(conflicting.getPath())) {
-                String msg = "cannot remove ancestor node";
-                log.debug(msg);
-                throw new RepositoryException(msg);
+            // make sure conflicting node is not importTarget or an ancestor thereof
+            Path p0 = hierMgr.getPath(importTarget.getId());
+            Path p1 = hierMgr.getPath(conflicting.getId());
+            try {
+                if (p0.equals(p1) || p0.isAncestorOf(p1)) {
+                    String msg = "cannot remove ancestor node";
+                    log.debug(msg);
+                    throw new RepositoryException(msg);
+                }
+            } catch (MalformedPathException mpe) {
+                // should never get here...
+                String msg = "internal error: failed to determine degree of relationship";
+                log.error(msg, mpe);
+                throw new RepositoryException(msg, mpe);
-            // remove conflicting
-            conflicting.remove();
-            // create new with given uuid
+            // remove conflicting:
+            // check if conflicting can be removed
+            // (access rights, node type constraints, locking & versioning status)
+            wsp.checkRemoveNode(conflicting,
+                    WorkspaceImpl.CHECK_ACCESS
+                    | WorkspaceImpl.CHECK_LOCK
+                    | WorkspaceImpl.CHECK_VERSIONING
+                    | WorkspaceImpl.CHECK_CONSTRAINTS);
+            // do remove conflicting (recursive)
+            removeNode(conflicting, conflicting.getParentUUID());
+            // create new with given uuid:
+            // check if new node can be added (check access rights &
+            // node type constraints only, assume locking & versioning status
+            // has already been checked on ancestor)
+            wsp.checkAddNode(parent, nodeInfo.getName(),
+                    nodeInfo.getNodeTypeName(),
+                    WorkspaceImpl.CHECK_ACCESS
+                    | WorkspaceImpl.CHECK_CONSTRAINTS);
+            // do create new node
-            if (conflicting.getDepth() == 0) {
+            if (conflicting.getParentUUID() == null) {
-            // @todo implement IMPORT_UUID_COLLISION_REPLACE_EXISTING behavior
-            throw new RepositoryException("uuidBehavior IMPORT_UUID_COLLISION_REPLACE_EXISTING is not yet implemented");
+            // 'replace' current parent with parent of conflicting
+            NodeId parentId = new NodeId(conflicting.getParentUUID());
+            try {
+                parent = (NodeState) stateMgr.getItemState(parentId);
+            } catch (ItemStateException ise) {
+                // should never get here...
+                String msg = "internal error: failed to retrieve parent state";
+                log.error(msg, ise);
+                throw new RepositoryException(msg, ise);
+            }
+            // remove conflicting:
+            // check if conflicting can be removed
+            wsp.checkRemoveNode(conflicting,
+                    WorkspaceImpl.CHECK_ACCESS
+                    | WorkspaceImpl.CHECK_LOCK
+                    | WorkspaceImpl.CHECK_VERSIONING
+                    | WorkspaceImpl.CHECK_CONSTRAINTS);
+            // do remove conflicting (recursive)
+            removeNode(conflicting, conflicting.getParentUUID());
+            // create new with given uuid at same location as conflicting:
+            // check if new node can be added at other location
+            // (access rights, node type constraints, locking & versioning status)
+            wsp.checkAddNode(parent, nodeInfo.getName(),
+                    nodeInfo.getNodeTypeName(),
+                    WorkspaceImpl.CHECK_ACCESS
+                    | WorkspaceImpl.CHECK_LOCK
+                    | WorkspaceImpl.CHECK_VERSIONING
+                    | WorkspaceImpl.CHECK_CONSTRAINTS);
+            // do create new node
+            node = createNode(parent, nodeInfo.getName(),
+                    nodeInfo.getNodeTypeName(), nodeInfo.getMixinNames(),
+                    nodeInfo.getUUID());
-*/
+
+        NodeState parent = null;
-            NodeState parent = (NodeState) parents.peek();
+            parent = (NodeState) parents.peek();
-            NodeState node;
+            NodeState node = null;
-/*
-                ChildNodeDef nodeDef =
-                        wsp.findApplicableDefinition(nodeName, ntName, parent);
-                if (nodeDef.isProtected()) {
-                    // skip protected node
-                    parents.push(null); // push null onto stack for skipped node
-                    log.debug("skipping protected node " + nodeName);
-                    return;
+                NodeState.ChildNodeEntry entry =
+                        parent.getChildNodeEntry(nodeName, 1);
+                NodeId idExisting = new NodeId(entry.getUUID());
+                NodeState existing = (NodeState) stateMgr.getItemState(idExisting);
+                ChildNodeDef def = ntReg.getNodeDef(existing.getDefinitionId());
+
+                if (!def.allowSameNameSibs()) {
+                    // existing doesn't allow same-name siblings,
+                    // check for potential conflicts
+                    EffectiveNodeType entExisting =
+                            wsp.getEffectiveNodeType(existing);
+                    if (def.isProtected() && entExisting.includesNodeType(ntName)) {
+                        // skip protected node
+                        parents.push(null); // push null onto stack for skipped node
+                        log.debug("skipping protected node "
+                                + resolveJCRPath(existing.getId()));
+                        return;
+                    }
+                    if (def.isAutoCreate() && entExisting.includesNodeType(ntName)) {
+                        // this node has already been auto-created,
+                        // no need to create it
+                        node = existing;
+                    } else {
+                        throw new ItemExistsException(resolveJCRPath(existing.getId()));
+                    }
-                if (nodeDef.isAutoCreate() && existing.isNodeType(ntName)) {
-                    // this node has already been auto-created, no need to create it
-                    node = existing;
-                } else {
-                    throw new ItemExistsException(existing.safeGetJCRPath());
-                }
-            } else {
+            }
+
+            if (node == null) {
-                    // no potential uuid conflict, always add new node
+                    // no potential uuid conflict, always create new node:
+                    // check if new node can be added (check access rights &
+                    // node type constraints only, assume locking & versioning status
+                    // has already been checked on ancestor)
+                    wsp.checkAddNode(parent, nodeName, ntName,
+                            WorkspaceImpl.CHECK_ACCESS
+                            | WorkspaceImpl.CHECK_CONSTRAINTS);
+                    // do create new node
+
-                        conflicting = (NodeImpl) session.getNodeByUUID(uuid);
-                    } catch (ItemNotFoundException infe) {
+                        conflicting =
+                                (NodeState) stateMgr.getItemState(new NodeId(uuid));
+                    } catch (NoSuchItemStateException nsise) {
-                        // create new with given uuid
+                        // create new with given uuid:
+                        // check if new node can be added (check access rights &
+                        // node type constraints only, assume locking & versioning status
+                        // has already been checked on ancestor)
+                        wsp.checkAddNode(parent, nodeName, ntName,
+                                WorkspaceImpl.CHECK_ACCESS
+                                | WorkspaceImpl.CHECK_CONSTRAINTS);
+                        // do create new node
-            // store state
-            stateMgr.store(state);
+
+            // process properties
+
+            Iterator iter = propInfos.iterator();
+            while (iter.hasNext()) {
+                PropInfo pi = (PropInfo) iter.next();
+                QName propName = pi.getName();
+                InternalValue[] vals = pi.getValues();
+                int type = pi.getType();
+
+                PropertyState prop = null;
+
+                if (node.hasPropertyEntry(propName)) {
+                    // a property with that name already exists...
+                    PropertyId idExisting = new PropertyId(node.getUUID(), propName);
+                    PropertyState existing =
+                            (PropertyState) stateMgr.getItemState(idExisting);
+                    PropDef propDef = ntReg.getPropDef(existing.getDefinitionId());
+                    if (propDef.isProtected()) {
+                        // skip protected property
+                        log.debug("skipping protected property "
+                                + resolveJCRPath(idExisting));
+                        continue;
+                    }
+                    if (propDef.isAutoCreate() && (existing.getType() == type
+                            || type == PropertyType.UNDEFINED)
+                            && propDef.isMultiple() == existing.isMultiValued()) {
+                        // this property has already been auto-created,
+                        // no need to create it
+                        prop = existing;
+                    } else {
+                        throw new ItemExistsException(resolveJCRPath(existing.getId()));
+                    }
+                }
+                if (prop == null) {
+                    // there's no property with that name,
+                    // create new property
+                    prop = createProperty(node, propName, type, vals.length);
+                }
+
+                PropDef propDef = ntReg.getPropDef(prop.getDefinitionId());
+
+                // check multi-valued characteristic
+                if ((vals.length == 0 || vals.length > 1) && !propDef.isMultiple()) {
+                    throw new ConstraintViolationException(resolveJCRPath(prop.getId())
+                            + " is not multi-valued");
+                }
+
+                // check whether type conversion is required
+                if (propDef.getRequiredType() != PropertyType.UNDEFINED
+                        && propDef.getRequiredType() != type) {
+                    // type doesn't match required type,
+                    // type conversion required
+                    for (int i = 0; i < vals.length; i++) {
+                        // convert InternalValue to Value of required type
+                        Value v =
+                                ValueHelper.convert(vals[i].toJCRValue(nsContext),
+                                        propDef.getRequiredType());
+                        // convert Value to InternalValue using
+                        // current namespace context of xml document
+                        vals[i] = InternalValue.create(v, nsContext);
+                    }
+                }
+
+                // set values
+                prop.setValues(vals);
+
+                // make sure node is valid according to its definition
+                wsp.validate(prop);
+
+                if (prop.getType() == PropertyType.REFERENCE) {
+                    // store reference for later resolution
+                    refTracker.processedReference(prop);
+                }
+
+                // store property
+                stateMgr.store(prop);
+            }
+
+            // store affected nodes
+            stateMgr.store(node);
+            stateMgr.store(parent);
+
+            // push current node onto stack of parents
+            parents.push(node);
+
-            String msg = "internal error: failed to persist state of " + parentAbsPath;
+            String msg = "internal error: failed to store state of "
+                    + resolveJCRPath(parent.getId());
-*/
-
-/*
-
-        // process node
-
-        NodeImpl node;
-        String uuid = nodeInfo.getUUID();
-        QName nodeName = nodeInfo.getName();
-        QName ntName = nodeInfo.getNodeTypeName();
-        QName[] mixins = nodeInfo.getMixinNames();
-        if (uuid == null) {
-            // no potential uuid conflict, always add new node
-            node = createNode(parent, nodeName, ntName, mixins, null);
-        } else {
-            // potential uuid conflict
-            NodeImpl conflicting;
-            try {
-                conflicting = (NodeImpl) session.getNodeByUUID(uuid);
-            } catch (ItemNotFoundException infe) {
-                conflicting = null;
-            }
-            if (conflicting != null) {
-                // resolve uuid conflict
-                node = resolveUUIDConflict(parent, conflicting, nodeInfo);
-            } else {
-                // create new with given uuid
-                node = createNode(parent, nodeName, ntName, mixins, uuid);
-            }
-        }
-
-        // process properties
-
-        Iterator iter = propInfos.iterator();
-        while (iter.hasNext()) {
-            PropInfo pi = (PropInfo) iter.next();
-            QName propName = pi.getName();
-            Value[] vals = pi.getValues();
-            int type = pi.getType();
-            if (node.hasProperty(propName)) {
-                PropertyDef def = node.getProperty(propName).getDefinition();
-                if (def.isProtected()) {
-                    // skip protected property
-                    log.debug("skipping protected property " + propName);
-                    continue;
-                }
-            }
-            // multi- or single-valued property?
-            if (vals.length == 1) {
-                // could be single- or multi-valued (n == 1)
-                try {
-                    // try setting single-value
-                    node.setProperty(propName, vals[0]);
-                } catch (ValueFormatException vfe) {
-                    // try setting value array
-                    node.setProperty(propName, vals, type);
-                } catch (ConstraintViolationException vfe) {
-                    // try setting value array
-                    node.setProperty(propName, vals, type);
-                }
-            } else {
-                // can only be multi-valued (n == 0 || n > 1)
-                node.setProperty(propName, vals, type);
-            }
-            if (type == PropertyType.REFERENCE) {
-                // store reference for later resolution
-                references.add(node.getProperty(propName));
-            }
-        }
-
-        parents.push(node);
-*/
+            // make sure node is valid according to its definition
+            wsp.validate(node);
+
-/*
-            Iterator iter = references.iterator();
+            Iterator iter = refTracker.getProcessedReferences();
-                if (prop.getDefinition().isMultiple()) {
-                    Value[] values = prop.getValues();
-                    Value[] newVals = new Value[values.length];
-                    for (int i = 0; i < values.length; i++) {
-                        Value val = values[i];
-                        String original = val.getString();
-                        String adjusted = (String) uuidMap.get(original);
-                        if (adjusted != null) {
-                            newVals[i] = new ReferenceValue(wsp.getSession().getNodeByUUID(adjusted));
-                        } else {
-                            // reference doesn't need adjusting, just copy old value
-                            newVals[i] = val;
-                        }
-                    }
-                    prop.setValue(newVals);
-                } else {
-                    Value val = prop.getValue();
-                    String original = val.getString();
-                    String adjusted = (String) uuidMap.get(original);
+                boolean modified = false;
+                InternalValue[] values = prop.getValues();
+                InternalValue[] newVals = new InternalValue[values.length];
+                for (int i = 0; i < values.length; i++) {
+                    InternalValue val = values[i];
+                    String original = ((UUID) val.internalValue()).toString();
+                    String adjusted = refTracker.getMappedUUID(original);
-                        prop.setValue(session.getNodeByUUID(adjusted));
+                        newVals[i] = InternalValue.create(UUID.fromString(adjusted));
+                        modified = true;
+                    } else {
+                        // reference doesn't need adjusting, just copy old value
+                        newVals[i] = val;
+                if (modified) {
+                    prop.setValues(newVals);
+                    stateMgr.store(prop);
+                }
-*/
+            refTracker.clear();
+
+            // make sure import target is valid according to its definition
+            wsp.validate(importTarget);
+

MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV23 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 INS43 INS31 INS31 INS31 INS31 INS31 INS31 INS42 UPD43 INS43 INS29 INS44 MOV21 INS29 INS83 INS43 INS42 INS44 INS8 INS43 INS44 INS44 INS44 INS44 INS44 INS43 INS83 MOV43 INS42 MOV44 MOV44 MOV44 MOV44 MOV44 INS44 MOV43 INS8 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS5 INS42 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS8 UPD42 UPD42 INS42 UPD42 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS65 INS65 INS65 INS42 INS43 INS42 INS60 INS54 INS54 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS5 INS42 INS43 INS42 INS42 INS41 INS43 INS42 INS25 INS25 INS25 INS25 MOV60 INS25 MOV21 MOV21 INS60 INS60 INS24 INS60 INS24 MOV41 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS39 INS42 INS42 INS60 INS25 INS41 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS43 INS42 INS42 INS25 INS60 INS21 INS25 INS21 INS60 INS25 INS21 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS85 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS60 INS60 INS25 INS41 INS65 INS65 INS65 INS65 MOV43 INS42 INS43 INS42 INS42 INS60 INS21 INS60 INS25 INS21 INS25 MOV60 INS25 MOV41 INS60 INS66 UPD66 INS66 INS42 INS42 INS42 INS42 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS43 INS59 INS8 INS12 INS8 INS12 INS42 INS42 INS42 INS43 INS85 INS42 INS32 INS42 INS32 INS8 INS27 INS8 INS27 INS8 INS27 INS8 INS27 INS8 INS43 INS59 INS5 INS59 INS58 INS27 INS37 INS8 INS5 INS59 INS58 INS27 INS37 INS8 INS42 INS42 INS43 INS59 INS27 INS8 INS8 INS32 INS42 INS42 INS42 INS32 INS8 INS43 INS59 INS32 INS27 INS8 INS25 INS32 INS5 INS59 INS27 INS8 INS25 INS32 INS42 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS5 INS59 INS43 INS59 INS32 INS8 INS25 INS42 INS66 INS66 INS66 INS66 INS42 INS42 INS42 INS66 INS42 INS43 INS59 INS32 INS39 INS59 INS42 INS8 INS32 INS42 INS8 INS8 INS27 INS8 INS25 INS43 INS59 INS8 INS12 INS8 INS22 INS42 UPD42 INS42 INS42 INS21 INS44 INS8 INS41 INS44 INS8 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS60 INS21 INS53 INS38 INS32 INS60 INS53 INS42 INS33 INS21 INS42 INS33 INS21 INS25 INS27 INS27 MOV21 INS42 INS42 INS32 INS43 INS85 INS42 INS32 INS39 INS59 INS42 INS40 INS42 INS60 INS21 INS43 INS85 INS42 INS32 INS39 INS59 INS42 INS40 INS42 INS60 INS21 INS42 INS42 INS42 INS34 INS54 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS60 INS21 INS53 INS42 INS42 INS32 INS42 INS42 INS14 INS32 INS40 INS21 INS27 INS8 INS8 INS42 INS42 INS32 INS43 INS85 INS42 INS32 INS42 INS33 INS21 INS27 INS8 INS42 INS42 INS42 INS43 INS85 INS42 INS33 INS42 INS42 INS32 INS42 INS42 INS42 INS25 INS32 INS8 INS25 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS32 INS60 INS24 INS21 INS24 INS42 INS42 INS42 INS21 INS21 INS42 INS42 INS21 INS21 INS60 INS25 INS27 INS8 INS25 INS42 INS42 INS33 MOV21 INS21 MOV60 MOV60 MOV60 MOV60 MOV60 MOV25 INS25 INS25 INS60 INS61 INS21 INS21 INS21 INS21 INS44 INS8 INS21 INS21 MOV21 INS60 INS61 INS21 INS21 MOV21 MOV21 INS52 INS42 INS43 INS7 INS43 INS42 INS21 INS41 INS32 INS43 INS42 INS21 INS41 UPD42 INS43 INS59 INS32 INS14 INS32 INS42 INS42 INS42 INS43 INS59 INS14 INS7 INS7 INS27 INS8 INS42 INS33 INS40 INS34 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS43 INS59 INS32 INS42 INS42 INS42 INS42 INS34 INS43 INS59 INS32 INS8 INS12 INS7 INS43 INS59 INS32 INS14 INS42 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS32 INS42 INS40 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS33 INS21 INS42 INS42 INS42 INS32 INS8 INS42 INS42 INS42 INS25 INS32 INS8 INS25 INS43 INS32 INS42 INS42 INS43 INS59 INS58 INS27 INS37 INS8 INS7 INS58 INS27 INS37 INS8 INS32 INS32 INS32 INS7 INS43 INS59 INS32 INS8 INS42 INS42 INS60 INS21 INS53 INS27 INS8 INS25 INS7 INS32 INS8 INS27 INS8 INS43 INS59 INS32 INS8 INS32 INS32 INS32 INS7 INS43 INS42 INS60 INS21 INS53 INS32 INS7 INS43 INS59 INS32 INS8 INS32 INS32 INS42 INS42 INS32 INS42 INS32 INS32 INS42 INS42 INS32 INS42 INS32 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS14 INS43 INS32 INS42 INS32 INS42 INS32 INS42 INS33 INS60 INS21 INS53 INS42 INS42 INS2 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS2 INS42 INS42 INS32 INS32 INS33 INS33 INS42 INS21 INS44 INS8 INS42 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS21 INS32 INS8 INS25 INS42 INS42 INS42 INS25 INS32 INS8 INS25 INS42 INS42 INS42 INS42 INS42 INS14 INS39 INS59 INS42 INS34 INS42 INS60 INS60 INS54 INS21 INS42 INS14 INS39 INS59 INS42 INS34 INS42 INS60 INS60 INS54 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS27 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS21 INS43 INS59 INS32 INS14 INS42 INS42 INS60 INS60 INS54 INS21 INS21 INS21 INS21 INS27 INS8 INS8 INS42 MOV11 INS42 INS42 INS42 MOV60 INS60 INS60 INS60 INS25 INS42 INS33 INS25 INS42 INS42 INS32 INS42 INS42 INS60 INS60 INS60 INS60 INS60 INS25 INS25 INS60 INS25 INS25 INS21 INS21 INS25 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS43 INS59 INS32 INS14 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS32 INS42 INS42 INS60 INS25 INS60 INS60 INS60 INS24 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS36 INS42 INS42 INS42 INS27 INS42 INS42 INS45 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS43 INS59 INS32 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS43 INS42 INS21 INS42 INS42 INS42 INS42 INS9 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS32 INS7 INS42 INS42 INS42 INS21 INS32 INS8 INS32 INS8 INS42 INS42 INS42 INS25 INS32 INS8 INS43 INS32 INS42 INS27 INS43 INS59 INS43 INS59 INS8 INS12 INS32 INS43 INS32 INS42 INS27 INS43 INS59 INS43 INS59 INS8 INS12 INS42 INS42 INS42 INS42 INS40 INS40 INS42 INS42 INS32 INS32 INS32 INS33 INS42 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS43 INS59 INS43 INS59 INS8 INS12 INS32 INS32 INS32 INS7 INS42 INS42 INS25 INS60 INS54 INS21 INS21 INS21 INS21 INS60 INS21 INS53 INS43 INS43 INS59 INS43 INS59 INS43 INS59 INS38 INS8 INS27 INS8 INS8 INS42 INS42 INS43 INS59 INS43 INS59 INS5 INS59 INS39 INS59 INS43 INS59 INS32 INS8 INS27 INS8 INS43 INS59 INS27 INS8 INS27 INS8 INS32 INS32 INS27 INS8 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS43 INS59 INS27 INS8 INS39 INS59 INS5 INS59 INS5 INS59 INS58 INS27 INS37 INS8 INS42 INS8 INS42 INS45 INS11 INS45 INS32 INS45 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS32 INS42 INS7 INS42 INS42 INS42 INS3 INS7 INS42 INS42 INS42 INS60 INS60 INS60 INS61 INS21 INS42 INS42 INS42 INS21 INS32 INS8 INS42 INS42 INS42 INS25 INS42 INS42 INS42 INS32 INS34 INS40 INS42 INS11 INS42 INS42 INS14 INS60 INS21 INS21 INS44 INS8 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS32 INS34 INS40 INS42 INS11 INS42 INS42 INS14 INS60 INS21 INS21 INS44 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS45 INS32 INS45 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS25 INS44 INS8 INS42 INS42 INS42 INS27 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS32 INS27 INS42 INS32 INS27 INS8 INS43 INS59 INS8 INS12 INS32 INS32 INS32 INS7 INS43 INS59 INS32 INS14 INS40 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS11 INS42 INS42 INS32 INS32 INS60 INS25 INS25 INS42 INS33 INS21 INS21 INS60 INS54 INS25 INS42 INS42 INS11 INS42 INS42 INS32 INS43 INS85 INS42 INS32 INS42 INS32 INS42 INS42 INS33 INS42 INS42 INS42 INS60 INS60 INS60 INS25 INS25 INS42 INS33 INS21 INS42 INS42 INS32 INS36 INS38 INS53 INS27 INS27 INS24 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS40 INS21 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS11 INS32 INS40 INS18 INS42 INS9 INS43 INS85 INS42 INS32 INS43 INS85 INS42 INS3 INS39 INS59 INS42 INS40 INS42 INS60 INS60 INS60 INS25 INS21 INS21 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS34 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS32 INS5 INS4 INS42 INS3 INS43 INS59 MOV43 INS59 INS43 INS59 INS32 INS8 INS7 INS7 INS42 INS42 INS42 INS21 INS32 INS8 INS42 INS42 INS43 INS32 INS43 INS32 INS43 INS59 INS32 INS32 INS43 INS42 INS60 INS21 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS32 INS43 INS32 INS32 INS43 INS59 INS32 INS32 INS43 INS42 INS60 INS21 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS27 INS8 INS43 INS42 INS60 INS21 INS53 INS40 INS40 INS40 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS40 INS42 INS42 INS32 INS32 INS32 INS32 INS32 INS33 INS60 INS21 INS53 INS42 INS42 INS14 INS21 INS44 INS8 INS42 INS42 INS42 INS27 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS32 INS27 INS42 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS34 INS43 INS32 INS43 INS32 INS42 INS42 INS32 INS42 INS42 INS43 INS59 INS27 INS8 INS27 INS8 INS8 INS32 INS7 INS43 INS59 INS8 INS12 INS27 INS8 INS8 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS43 INS59 INS32 INS8 INS27 INS8 INS8 INS7 INS42 INS42 INS32 INS27 INS32 INS14 INS32 INS40 INS32 INS42 INS58 INS27 INS37 INS8 INS42 INS42 INS32 INS42 INS32 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS5 INS40 INS42 INS34 INS43 INS59 INS43 INS59 INS43 INS59 INS27 INS8 INS8 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS43 INS85 INS32 INS5 INS4 INS42 INS42 INS32 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS21 INS42 INS11 INS42 INS3 INS7 INS42 INS42 INS42 INS21 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS42 INS27 INS42 INS42 INS32 INS42 INS43 INS59 INS32 INS14 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS14 INS42 INS42 INS42 INS42 INS32 INS32 INS60 INS21 INS53 INS42 INS43 INS59 INS32 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS14 INS43 INS32 INS7 INS43 INS42 INS60 INS21 INS53 INS40 INS40 INS40 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS40 INS40 INS40 INS42 INS42 INS32 INS32 INS32 INS32 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS21 INS21 INS41 INS32 INS32 INS21 INS53 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS32 INS42 INS42 INS21 INS44 INS8 INS42 INS33 INS21 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS11 INS42 INS42 INS32 INS42 INS42 INS21 INS18 INS32 INS36 INS27 INS21 INS53 INS42 INS32 INS42 INS42 INS27 INS27 INS42 INS42 INS43 INS27 INS42 INS42 INS42 INS42 INS39 INS59 INS42 INS40 INS42 INS60 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS85 INS42 INS42 INS2 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS33 INS21 MOV21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS85 INS32 INS42 INS42 MOV43 INS32 INS42 INS42 INS32 INS5 INS32 INS5 INS4 INS42 INS3 INS7 INS43 INS32 INS40 INS40 INS40 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS14 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS43 INS59 INS32 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS7 INS14 INS40 INS40 INS42 INS42 INS42 INS42 INS42 INS33 INS7 INS43 INS42 INS21 INS7 INS32 INS7 INS43 INS32 INS42 INS43 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS27 INS32 INS32 INS7 INS14 INS42 INS42 INS42 INS42 INS40 INS40 INS34 INS40 INS34 INS42 INS32 INS45 INS42 INS34 INS43 INS59 INS7 INS42 INS42 INS42 INS36 INS42 INS42 INS42 INS42 INS7 INS7 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS43 INS85 INS42 INS42 INS3 INS43 INS85 INS32 INS5 INS4 INS42 INS3 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS43 INS32 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS27 INS42 INS42 INS43 INS32 INS42 INS11 INS42 INS7 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS27 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS32 INS42 INS32 INS42 INS42 INS32 INS2 INS32 INS11 INS2 INS32 UPD42 INS2 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS5 INS32 INS42 INS42 INS42 INS32 INS43 INS85 INS32 INS5 INS4 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS32 INS43 INS32 INS42 INS33 INS42 INS42 INS42 INS42 INS40 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS32 INS42 INS42 INS40 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS43 INS32 INS43 INS85 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS85 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS2 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 DEL66 DEL65 DEL29 DEL42 DEL42 DEL43 DEL14 DEL8 DEL42 DEL8 DEL8
JCR-EXT: Upgrade to 0.16.4.1

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@169294 13f79535-47bb-0310-9956-ffa450edef68

- *                 if (property.getName().equals("title")) {
- *                     return super.includeProperty(property);
- *                 } else {
- *                     return false;
- *                 }
+ *                 return property.getName().equals("title");
+    /** The JCR namespace URI. */
+    private static final String JCR_URI = "http://www.jcp.org/jcr/1.0";
+
-    private static final String XMLTEXT = "jcr:xmltext";
+    private static final Name XMLTEXT = new Name(JCR_URI, "xmltext");
-    private static final String XMLCHARACTERS = "jcr:xmlcharacters";
+    private static final Name XMLCHARACTERS = new Name(JCR_URI, "xmlcharacters");
-    public void visit(Property property) {
+    public final void visit(Property property) {
-    public void visit(Node node) throws RepositoryException {
+    public final void visit(Node node) throws RepositoryException {
-     * serialization. By default this method returns false for the special
-     * "jcr:xmlcharacters" properties and for binary properties if the
-     * skipBinary flag is set. Subclasses can extend this behaviour to
-     * implement more selective XML serialization.
-     * <p>
-     * To avoid losing the default behaviour described above, subclasses
-     * should always call super.includeProperty(property) instead of
-     * simply returning true for a property.
+     * serialization. This method returns <code>true</code> by default,
+     * but subclasses can override this method to implement more selective
+     * XML serialization.
-        return !property.getName().equals(XMLCHARACTERS)
-            && (!skipBinary || property.getType() != PropertyType.BINARY);
+        return true;
-     * serialization. This method returns true by default, but subclasses
-     * can extend this behaviour to implement selective XML serialization.
+     * serialization. This method returns <code>true</code> by default,
+     * but subclasses override this method to implement selective
+     * XML serialization.
-            Property property = node.getProperty(XMLCHARACTERS);
+            Property property =
+                node.getProperty(XMLCHARACTERS.toJCRName(node.getSession()));
-        Name qname = getQName(node);
-        String localName = escapeName(qname.getLocalPart());
+        Name name = getName(node);
+        String localName = escapeName(name.getLocalPart());
-            node.getSession().getNamespacePrefix(qname.getNamespaceURI())
+            node.getSession().getNamespacePrefix(name.getNamespaceURI())
-                qname.getNamespaceURI(), localName, prefixedName,
+                name.getNamespaceURI(), localName, prefixedName,
-                qname.getNamespaceURI(), qname.getLocalPart(), node.getName());
+                name.getNamespaceURI(), name.getLocalPart(), node.getName());
+            /*
+            return !property.getName().equals(XMLCHARACTERS)
+            && (!skipBinary || property.getType() != PropertyType.BINARY);
+            */
-                Name qname = getQName(property);
-                String value = getValue(property);
-                attributes.addAttribute(qname.getNamespaceURI(),
-                        qname.getLocalPart(), property.getName(),
-                        "CDATA", value);
+                Name name = getName(property);
+                attributes.addAttribute(
+                        name.getNamespaceURI(),
+                        escapeName(name.getLocalPart()),
+                        escapeName(name.toJCRName(property.getSession())),
+                        "CDATA", escapeValue(property));
-    private Name getQName(Item item) throws RepositoryException {
+    private Name getName(Item item) throws RepositoryException {
-        if (name.length() == 0) {
-            name = "jcr:root";
+        if (name.length() > 0) {
+            return Name.fromJCRName(item.getSession(), name);
+        } else {
+            return new Name("http://www.jcp.org/jcr/1.0", "root");
-        return Name.fromJCRName(item.getSession(), name);
+    }
+
+    /**
+     * Escapes the given character into a hex escape sequence
+     * <code>_xXXXX_</code> where <code>XXXX</code> is the (uppercase)
+     * hexadecimal representation of the given character.
+     *
+     * @param ch character to be escaped
+     * @return escape string
+     */
+    private static String escapeChar(char ch) {
+        String hex = "000" + Integer.toHexString((int) ch).toUpperCase();
+        return "_x" + hex.substring(hex.length() - 4) + "_";
-    private String escapeName(String name) {
+    private static String escapeName(String name) {
-        if (!XMLChar.isNameStart(name.charAt(0)) || name.startsWith("_x")
-                || (name.length() >= 3
-                        && "xml".equalsIgnoreCase(name.substring(0, 3)))) {
-            String hex =
-                "000" + Integer.toHexString(name.charAt(0)).toUpperCase();
-            buffer.append("_x" + hex.substring(hex.length() - 4) + "_");
+        if (!XMLChar.isNameStart(name.charAt(0))
+            || name.startsWith("_x")
+            || (name.length() >= 3
+                && "xml".equalsIgnoreCase(name.substring(0, 3)))) {
+            buffer.append(escapeChar(name.charAt(0)));
-                String hex =
-                    "000" + Integer.toHexString(name.charAt(0)).toUpperCase();
-                buffer.append("_x" + hex.substring(hex.length() - 4) + "_");
+                buffer.append(escapeChar(name.charAt(i)));
-    private String escapeValue(String value) {
+    private static String escapeValue(String value) {
-    private String getValue(Property property) throws RepositoryException {
+    private static String escapeValue(Property property)
+            throws RepositoryException {
-                        buffer.append(" ");
+                        buffer.append(' ');
-    private String encodeValue(InputStream input) throws IOException {
+    private static String encodeValue(InputStream input) throws IOException {

INS23 INS31 INS29 INS83 INS83 INS83 MOV43 INS59 INS43 INS43 INS83 INS83 UPD42 INS29 INS83 INS83 MOV43 INS42 INS44 INS8 INS83 INS83 INS83 UPD42 INS83 UPD66 INS65 INS42 INS45 INS42 INS14 INS42 INS14 INS65 INS65 INS65 INS39 INS42 INS60 INS41 INS66 INS43 INS42 INS45 INS43 INS42 INS45 UPD66 UPD66 UPD66 INS9 UPD66 INS66 UPD66 UPD27 INS8 INS66 INS66 INS66 INS42 INS66 INS66 MOV43 INS59 MOV27 INS42 INS42 UPD42 MOV41 INS41 INS42 INS27 INS21 UPD42 UPD42 UPD42 UPD42 INS14 INS45 INS32 INS32 UPD42 INS43 INS45 INS45 INS32 INS42 UPD42 MOV42 UPD42 MOV42 INS32 INS32 UPD42 INS42 INS42 INS42 INS11 INS42 MOV32 MOV42 INS42 INS32 UPD42 INS32 INS32 INS32 INS39 INS42 MOV42 MOV34 INS32 INS42 INS42 UPD42 UPD42 INS42 MOV32 INS42 INS32 UPD42 MOV42 INS42 UPD42 MOV42 INS32 UPD42 INS42 INS42 MOV32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 INS13 DEL66 DEL66 DEL66 DEL66 DEL45 DEL45 DEL66 DEL66 DEL66 DEL66 DEL66 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL38 DEL42 DEL38 DEL42 DEL42 DEL32 DEL40 DEL27 DEL27 DEL36 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL45 DEL7 DEL21 DEL42 DEL45 DEL32 DEL42 DEL32 DEL27 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL45 DEL42 DEL42 DEL32 DEL42 DEL32 DEL27 DEL59 DEL60 DEL45 DEL32 DEL34 DEL27 DEL32 DEL45 DEL27 DEL45
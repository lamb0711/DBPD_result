work in progress

- HierarchyManager: changes methods to take ItemState instead of ItemId
- HierarchyManager: remove log-utility methods (saveGetJCRPath)
- HierarchyManager: remove CachingHierachyManager. not used
- ItemManager: changes methods to take ItemState instead of ItemId
- ItemStateValidator: remove utility methods not related to validation
- new class LogUtil that provides static saveGetJCRPath methods previously
  present on HierarchyManager, ItemStateValidator
- NodeState: add method 'getPropertyEntries()'
- create interface ChildPropertyEntry
- let PropertyReference implement ChildPropertyEntry

TODO: query/NodeIteratorImpl needs to be fixed. 


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@429652 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.state.NoSuchItemStateException;
+import org.apache.jackrabbit.jcr2spi.util.LogUtil;
-import org.apache.jackrabbit.spi.ItemId;
-            ItemId id = hierMgr.getItemId(parentPath);
-            if (!id.denotesNode()) {
-                throw new PathNotFoundException(hierMgr.safeGetJCRPath(parentPath));
+            ItemState itemState = hierMgr.getItemState(parentPath);
+            if (!itemState.isNode()) {
+                throw new PathNotFoundException(LogUtil.safeGetJCRPath(parentPath, session.getNamespaceResolver()));
-            importTarget = validator.getNodeState((NodeId) id);
+            importTarget = (NodeState) itemState;
-            throw new PathNotFoundException(hierMgr.safeGetJCRPath(parentPath));
+            throw new PathNotFoundException(LogUtil.safeGetJCRPath(parentPath, session.getNamespaceResolver()));
-                       log.debug("skipping protected node " + hierMgr.safeGetJCRPath(existing.getId()));
+                       log.debug("skipping protected node " + LogUtil.safeGetJCRPath(existing, session.getNamespaceResolver(), hierMgr));
-                       throw new ItemExistsException(hierMgr.safeGetJCRPath(existing.getId()));
+                       throw new ItemExistsException(LogUtil.safeGetJCRPath(existing, session.getNamespaceResolver(), hierMgr));
-                       NodeState conflicting = validator.getNodeState(nodeInfo.getId());
+                       NodeState conflicting = (NodeState) stateMgr.getItemState(nodeInfo.getId());
-                   } catch (ItemNotFoundException infe) {
+                   } catch (NoSuchItemStateException e) {
+                   } catch (ItemStateException e) {
+                       String msg = "Internal error: failed to retrieve state of " + nodeInfo.getId().toString();
+                       log.debug(msg);
+                       throw new RepositoryException(msg, e);
-                Path p0 = hierMgr.getQPath(importTarget.getId());
-                Path p1 = hierMgr.getQPath(conflicting.getId());
+                Path p0 = hierMgr.getQPath(importTarget);
+                Path p1 = hierMgr.getQPath(conflicting);
-                    log.debug("skipping protected property " + hierMgr.safeGetJCRPath(existing.getPropertyId()));
+                    log.debug("skipping protected property " + LogUtil.safeGetJCRPath(existing, session.getNamespaceResolver(), hierMgr));
-                    throw new ItemExistsException(hierMgr.safeGetJCRPath(existing.getPropertyId()));
+                    throw new ItemExistsException(LogUtil.safeGetJCRPath(existing, session.getNamespaceResolver(), hierMgr));

MOV26 INS26 INS40 UPD40 MOV43 MOV43 UPD43 UPD42 UPD42 INS11 MOV42 MOV42 UPD42 UPD42 UPD42 UPD43 MOV43 UPD42 MOV42 UPD42 UPD42 INS32 UPD42 INS32 INS42 INS42 INS12 INS42 INS42 INS44 INS8 UPD43 UPD42 INS43 INS42 INS60 INS21 INS53 UPD42 MOV42 INS32 INS42 INS11 UPD42 INS42 INS43 INS59 INS32 INS14 UPD42 MOV42 INS32 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS43 MOV32 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS42 UPD42 MOV42 INS42 UPD42 UPD42 INS45 INS32 INS42 INS42 UPD42 MOV42 INS32 INS42 INS42 INS42 DEL42 DEL42 DEL11 DEL32 DEL32 DEL32 DEL42 DEL32 DEL42 DEL32 DEL32 DEL32
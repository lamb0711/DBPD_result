Apply and modify patch for JCR-1053. Thanks to AndrÃ© Bierwolf.
I added more unit tests on collection & proxy. 

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@566872 13f79535-47bb-0310-9956-ffa450edef68

+import javax.jcr.query.InvalidQueryException;
+import javax.jcr.query.Query;
+import javax.jcr.query.QueryResult;
+import org.apache.jackrabbit.util.ISO9075;
- * This collection mapping strategy maps a collection into several nodes based on specific node type.
+ * This collection mapping strategy maps the collection elements into subnodes based on the same node types.
+ * 
+ * There are 2 constraints in this collection converter : 
+ * 1/ this is not possible to have 2 different collections in the main object which are used the same jcr node type for their elements. 
+ * 2/ this is not possible to make a distinction between an empty collection and an null collection. 
- * If the collection element class contains an id (see the FieldDescriptor definition), this id value is used to build the collection element node.
+ * If the collection element class contains an id (see the FieldDescriptor definition), this id value is used to build the collection element node name.
+ *          
+ *          Each "collection-element" nodes have the same jcr node type
+ *          
+ *          Each collection element nodes have the same jcr node type
-         Collection collectionNodes = this.getCollectionNodes(session, parentNode, 
+         NodeIterator nodes = this.getCollectionNodes(session, parentNode, 
-         if (collectionNodes != null && elementClassDescriptor.hasIdField()) {
-            Iterator nodeIterator = collectionNodes.iterator();
+         if (nodes != null && elementClassDescriptor.hasIdField()) {
+            
-            while (nodeIterator.hasNext()) {
-                Node child = (Node) nodeIterator.next();
+            while (nodes.hasNext()) {
+                Node child = (Node) nodes.next();
-        //Class elementClass = ReflectionUtils.forName(collectionDescriptor.getElementClassName());
-        Collection nodes = this.getCollectionNodes(session, parentNode, elementClassDescriptor.getJcrType());
+
+        NodeIterator nodes = this.getCollectionNodes(session, parentNode, elementClassDescriptor.getJcrType());
-        if (nodes == null)
+        if (nodes == null || nodes.getSize() == 0)
-        
-        Iterator children = nodes.iterator();
-        while (children.hasNext()) {
-            Node itemNode = (Node) children.next();
+                
+        while (nodes.hasNext()) {
+            Node itemNode = (Node) nodes.next();
+     * 
+     * return true If the parent node doesn't contains node based on the node type associated to the collection elements
+     *  
-    	    // This collection converter returns at least a empty collection (see in doGetCollection) 
-        return false;
-    }         
-
-    private Collection getCollectionNodes(Session session, Node parentNode, String itemNodeType)
+        String elementClassName = collectionDescriptor.getElementClassName();
+        ClassDescriptor elementClassDescriptor = mapper.getClassDescriptorByClass(ReflectionUtils.forName(elementClassName));
+		QueryResult queryResult = getQuery(session, parentNode, elementClassDescriptor.getJcrType());    	
+    	return queryResult.getNodes().getSize() == 0;
+    }
+        
+    private NodeIterator getCollectionNodes(Session session, Node parentNode, String itemNodeType)
-        List collectionNodes = new ArrayList();
-
-        // TODO : review this workaround used to support version nodes
-        // Searching on the version storage has some bugs => loop on all child noded and check the property jcr:frozenPrimaryType
-        // I have to investigate in more detail what's happen exactly
-        if (!parentNode.getPath().startsWith("/jcr:system/jcr:versionStorage")) {
-            NodeIterator nodeIterator = parentNode.getNodes();
-            while (nodeIterator.hasNext()) {
-                Node child = nodeIterator.nextNode();
-
-                if (child.isNodeType(itemNodeType)) {
-                    collectionNodes.add(child);
-                }
-            }
-        }
-        else {
-            NodeIterator nodeIterator = parentNode.getNodes();
-            while (nodeIterator.hasNext()) {
-                Node child = nodeIterator.nextNode();
-
-                if (child.getProperty("jcr:frozenPrimaryType").getString().equals(itemNodeType)) {
-                    collectionNodes.add(child);
-                }
-            }
-
-        }
-
-        if (collectionNodes.size() == 0)
-        {
-        	return null; 
-        }
-        else
-        {
-            return collectionNodes;
-        }
+        List collectionNodes = null;
+        
+        QueryResult queryResult = getQuery(session, parentNode, itemNodeType);
+        return  queryResult.getNodes();
+        
-        Collection nodes = this.getCollectionNodes(session, parentNode, itemNodeType);
-        if (nodes == null) return;
-        	
-        Iterator nodeIterator = nodes.iterator();
-        while (nodeIterator.hasNext()) {
-            Node node = (Node) nodeIterator.next();
+        NodeIterator nodes = this.getCollectionNodes(session, parentNode, itemNodeType);
+        if (nodes == null || nodes.getSize()==0) return;
+        
+        while (nodes.hasNext()) {
+            Node node = (Node) nodes.next();
+    
+   
+	
+	private QueryResult getQuery(Session session, Node parentNode, String jcrNodeType) throws RepositoryException, InvalidQueryException {
+    	String jcrExpression= "";    	
+    	if (!parentNode.getPath().startsWith("/jcr:system/jcr:versionStorage")) 
+    	{
+            jcrExpression = "SELECT * FROM " + jcrNodeType + " WHERE jcr:path LIKE '" + parentNode.getPath() 
+                                       + "/%' AND NOT jcr:path LIKE '" + parentNode.getPath() + "/%/%'";
+    	}
+    	else
+    	{
+    	
+    		jcrExpression = "SELECT * FROM nt:frozenNode" + " WHERE jcr:path LIKE '" + parentNode.getPath() + "/%'" 
+    		                 + " AND NOT jcr:path LIKE '" + parentNode.getPath() + "/%/%'"
+    		                 + " AND jcr:frozenPrimaryType = '" + jcrNodeType + "'";
+
+    		                
+    	}
+        Query jcrQuery = session.getWorkspace().getQueryManager().createQuery(jcrExpression, javax.jcr.query.Query.SQL);
+        QueryResult queryResult = jcrQuery.execute();
+		return queryResult;
+	}

INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS31 INS31 MOV83 UPD43 MOV43 MOV42 INS44 INS44 MOV44 MOV43 MOV43 MOV43 INS8 INS83 INS43 INS42 MOV44 MOV44 INS44 INS43 INS43 INS8 UPD66 INS66 INS66 INS66 UPD66 INS66 INS66 INS60 INS60 INS60 MOV60 UPD42 INS43 INS42 INS43 INS42 MOV60 MOV60 INS41 INS25 UPD42 MOV42 INS43 INS42 INS42 INS42 INS60 INS25 INS60 INS60 MOV41 INS43 INS59 UPD43 INS27 INS66 INS43 INS59 INS43 INS59 UPD43 INS27 INS42 INS42 UPD43 INS32 MOV43 INS27 INS41 INS42 INS43 INS59 MOV38 MOV8 INS8 INS43 INS59 INS43 INS59 UPD42 INS42 INS42 INS32 UPD42 MOV27 INS27 UPD42 INS42 INS42 INS32 INS42 INS42 INS32 UPD42 UPD42 INS32 INS34 INS33 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 MOV27 INS27 UPD42 INS42 INS42 INS45 INS21 INS42 INS42 INS32 INS42 INS42 INS32 INS52 INS42 INS42 INS42 INS32 UPD42 INS32 INS34 MOV43 INS42 INS42 INS42 INS42 INS32 UPD42 INS32 INS42 INS42 INS42 UPD42 INS32 INS34 MOV43 INS7 INS7 MOV32 UPD42 MOV42 UPD42 MOV42 INS40 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV42 UPD42 MOV42 INS42 INS27 INS42 INS27 UPD42 MOV43 MOV43 MOV43 INS45 INS42 INS45 INS32 INS45 INS32 INS45 INS27 INS32 INS45 INS45 INS32 INS45 INS45 INS42 INS45 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS45 INS45 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV43 UPD42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL52 DEL9 DEL42 DEL43 DEL14 DEL32 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL25 DEL8 DEL61 DEL8 DEL42 DEL32 DEL59 DEL60 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL61 DEL8 DEL25 DEL32 DEL34 DEL27 DEL33 DEL41 DEL8 DEL8 DEL25 DEL8 DEL31 DEL42 DEL43 DEL41 DEL25 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL32 DEL45
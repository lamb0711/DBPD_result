JCR-2288: o.a.jackrabbit.spi.commons.conversion.NameParser should not assume that namespace URI's are registered

Accept {} and {x:y} as valid namespace URI formats in expanded names. No further namespace validity tests are needed.

As a special backwards compatibility feature, {internal} is also accepted as a valid URI prefix.

Adjusted a few corner case tests that are affected by this change.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@815745 13f79535-47bb-0310-9956-ffa450edef68

-                    try {
-                        // make sure the uri is a known namespace uri
-                        // TODO: since namespace registration does not validate
-                        //       the URI format validation is omitted here
-                        if (!checkFormat) {
-                            resolver.getPrefix(tmp);
-                        }
+                    if (tmp.length() == 0 || tmp.indexOf(':') != -1) {
+                        // The leading "{...}" part is empty or contains
+                        // a colon, so we treat it as a valid namespace URI.
+                        // More detailed validity checks (is it well formed,
+                        // registered, etc.) are not needed here.
-                    } catch (NamespaceException e) {
-                        // unknown uri -> apparently a localname starting with {
-                        // -> make sure there are no invalid characters
-                        if (tmp.indexOf(':') == -1 && tmp.indexOf('/') == -1) {
-                            state = STATE_NAME;
-                            nameStart = 0;
-                        } else {
-                            throw new IllegalNameException("Unknown uri " + tmp + ". But ':' and '/' are not allowed in a local name.");
-                        }
+                    } else if (tmp.equals("internal")) {
+                        // As a special Jackrabbit backwards compatibility
+                        // feature, support {internal} as a valid URI prefix
+                        uri = tmp;
+                        state = STATE_NAME_START;
+                    } else if (tmp.indexOf('/') == -1) {
+                        // The leading "{...}" contains neither a colon nor
+                        // a slash, so we can interpret it as a a part of a
+                        // normal local name.
+                        state = STATE_NAME;
+                        nameStart = 0;
+                    } else {
+                        throw new IllegalNameException(
+                                "The URI prefix of the name " + jcrName
+                                + " is neither a valid URI nor a valid part"
+                                + " of a local name.");

MOV25 MOV27 MOV8 MOV27 MOV8 MOV27 MOV8 MOV27 MOV8 MOV27 MOV8 MOV25 MOV27 MOV8 INS25 MOV21 MOV27 MOV8 MOV25 MOV8 MOV25 MOV60 INS25 INS27 INS8 INS25 MOV42 MOV42 MOV27 MOV25 UPD27 MOV27 MOV8 INS25 INS42 INS42 INS21 INS27 INS8 MOV42 INS27 UPD27 INS32 INS8 MOV25 INS7 INS42 INS42 INS21 INS21 MOV42 MOV42 INS32 INS34 INS42 INS42 INS45 INS21 INS21 MOV27 INS42 INS42 INS7 INS7 MOV42 MOV42 INS42 INS42 INS7 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD45 UPD42 INS45 UPD45 DEL42 DEL38 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL44 DEL12 DEL54 DEL8 DEL25
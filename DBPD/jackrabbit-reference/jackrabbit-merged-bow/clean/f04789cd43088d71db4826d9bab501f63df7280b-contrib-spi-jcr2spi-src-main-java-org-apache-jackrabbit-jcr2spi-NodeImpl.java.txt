work in progress

jcr2spi
- HierarchyManager: fixing methods with ItemId param
- HierarchyManagerImpl(s): removing unused methods
- ItemManagerImpl: replacing NodeId as cacheKey
- ItemImpl: remove ISM field

jcr2spi/xml
- ImporterImpl renamed to SessionImporter (used for s-import only)
- xml import: Use UUID String instead of creating NodeIds
- ReferenceChangeTracker: remove usage of spi NodeId

jcr2spi/state
- SessionItemStateManager: ValueFactory not needed since QPropertyDefinition returns qualified values.

jcr2spi/util
- LogUtil: add 'saveGetJCRName' utility method

jcr2spi/locking
- locking: LockManager to use NodeState instead of NodeId
- locking: removing locktoken from Session checks if Session is lock holder

jcr2spi/query
- NodeIteratorImpl: fix commented code, that allows to retrieve
  search results from IdIterator returned from QueryInfo
- minor reformatting, javadoc

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@430791 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.state.ItemStateManager;
+import org.apache.jackrabbit.jcr2spi.util.LogUtil;
-        // paranoid sanity check
+        // make sure the nodetype name is valid
-            /**
-             * todo need proper way of handling inconsistent/corrupt node type references
-             * e.g. 'flag' nodes that refer to non-registered node types
-             */
-            log.warn("Fallback to nt:unstructured due to unknown node type '" + nodeTypeName + "' of node " + safeGetJCRPath());
-            primaryTypeName = QName.NT_UNSTRUCTURED;
+            // DIFF JR: jr defines nt:unstructured as fallback.
+            // should not occur. Since nodetypes are defined by the 'server'
+            // its not possible to determine a fallback nodetype that is
+            // always available.
+            throw new IllegalArgumentException("Unknown nodetype " + LogUtil.saveGetJCRName(nodeTypeName, session.getNamespaceResolver()));
-        } catch (NoPrefixDeclaredException npde) {
+        } catch (NoPrefixDeclaredException e) {
-            String msg = "internal error: encountered unregistered namespace " + qName.getNamespaceURI();
+            String msg = "Internal error while resolving qualified name " + qName.toString();
-            throw new RepositoryException(msg, npde);
+            throw new RepositoryException(msg, e);
-            String msg = "root node doesn't have a parent";
+            String msg = "Root node doesn't have a parent.";
-                String msg = "Cannot add a node to property " + parentPath;
+                String msg = "Cannot add a node to property " + LogUtil.safeGetJCRPath(parentPath, session.getNamespaceResolver());
+                // should never occur
-            throw new ItemNotFoundException(safeGetJCRPath() + " has no child node with name " + srcChildRelPath);
+            throw new ItemNotFoundException("Node " + safeGetJCRPath() + " has no child node with name " + srcChildRelPath);
-            throw new ItemNotFoundException(safeGetJCRPath() + " has no child node with name " + destChildRelPath);
+            throw new ItemNotFoundException("Node " + safeGetJCRPath() + " has no child node with name " + destChildRelPath);
-        itemStateMgr.execute(op);
+        session.getSessionItemStateManager().execute(op);
-                // TODO: check if is correct to avoid any validation exception that way
+                // TODO: check if is correct to avoid any validation exception
-                // TODO: check if is correct to avoid any validation exception that way
+                // TODO: check if is correct to avoid any validation exception
-        /**
-         * IMPORTANT:
-         * an implementation of Node.getNodes()
-         * must not use a class derived from TraversingElementVisitor
-         * to traverse the hierarchy because this would lead to an infinite
-         * recursion!
-         */
+        // NOTE: Don't use a class derived from TraversingElementVisitor to traverse
+        // the child nodes because this would lead to an infinite recursion.
-            String msg = "failed to list the child nodes of " + safeGetJCRPath();
+            String msg = "Failed to list the child nodes of " + safeGetJCRPath();
-            String msg = "failed to list the child nodes of " + safeGetJCRPath();
+            String msg = "Failed to list the child nodes of " + safeGetJCRPath();
-            throw new ItemNotFoundException("No primary item present on Node " + getPath());
+            throw new ItemNotFoundException("No primary item present on Node " + safeGetJCRPath());
-            throw new ItemNotFoundException("Primary item " + name + " does not exist on Node " + getPath());
+            throw new ItemNotFoundException("Primary item " + name + " does not exist on Node " + safeGetJCRPath());
+        // Node is referenceable -> NodeId must contain a UUID part
+            ItemStateManager itemStateMgr = session.getItemStateManager();
-            String msg = "Unable to retrieve REFERENCE properties that refer to " + getPath();
+            String msg = "Unable to retrieve REFERENCE properties that refer to " + safeGetJCRPath();
-        itemStateMgr.execute(op);
+        session.getSessionItemStateManager().execute(op);
-                throw new ConstraintViolationException(mixinName + " can not be removed: the node is being referenced through at least one property of type REFERENCE");
+                throw new ConstraintViolationException("Mixin type " + mixinName + " can not be removed: the node is being referenced through at least one property of type REFERENCE");
-        itemStateMgr.execute(op);
+        session.getSessionItemStateManager().execute(op);
-            log.debug("Cannot add mixin '" + mixinName + "' for the following reason: " + e.getMessage());
+            log.debug("Cannot add mixin '" + mixinName + "': " + e.getMessage());
-            log.debug("Cannot add mixin '" + mixinName + "' for the following reason: " + e.getMessage());
+            log.debug("Cannot add mixin '" + mixinName + "': " + e.getMessage());
-            session.getVersionManager().checkin(getNodeId());
+            session.getVersionManager().checkin(getNodeState());
-            log.debug("Node " + getPath() + " is already checked in.");
+            // nothing to do
+            log.debug("Node " + safeGetJCRPath() + " is already checked in.");
-            session.getVersionManager().checkout(getNodeId());
+            session.getVersionManager().checkout(getNodeState());
-            log.debug("Node " + getPath() + " is already checked out.");
+            // nothing to do
+            log.debug("Node " + safeGetJCRPath() + " is already checked out.");
-            String msg = "Unable to finish merge. Node is checked-in: " + safeGetJCRPath();
+            String msg = "Unable to resolve merge conflict. Node is checked-in: " + safeGetJCRPath();
-            String msg = "Unable to finish merge. Specified version is not in jcr:mergeFailed property: " + safeGetJCRPath();
+            String msg = "Unable to resolve merge conflict. Specified version is not in jcr:mergeFailed property: " + safeGetJCRPath();
-            throw new RepositoryException("Unexpected error: Failed to retrieve a valid ID for version " + version.getPath());
+            throw new RepositoryException("Incompatible Version object :" + version);
-                        throw new RepositoryException("Unexpected error: NodeState expected.");
+                        // should not occur
+                        throw new RepositoryException("Merge failed with internal error: NodeState expected.");
-                    throw new RepositoryException("Unexpected error", e);
+                    // should not occur
+                    throw new RepositoryException(e);
-        } catch (NameException be) {
+        } catch (NameException e) {
-            String msg = "internal error: failed to determine relative path";
-            log.error(msg, be);
-            throw new RepositoryException(msg, be);
+            String msg = "Internal error: failed to determine relative path";
+            log.error(msg, e);
+            throw new RepositoryException(msg, e);
-        return session.getVersionManager().isCheckedOut(getNodeId());
+        return session.getVersionManager().isCheckedOut(getNodeState());
-            if (session.getItemManager().itemExists(parentPath)) {
+            if (itemMgr.itemExists(parentPath)) {
-                Item parent = session.getItemManager().getItem(parentPath);
+                Item parent = itemMgr.getItem(parentPath);
-        return session.getLockManager().lock(getNodeId(), this, isDeep, isSessionScoped);
+        return session.getLockManager().lock(getNodeState(), isDeep, isSessionScoped);
-        return session.getLockManager().getLock(getNodeId());
+        return session.getLockManager().getLock(getNodeState());
-        session.getLockManager().unlock(getNodeId());
+        session.getLockManager().unlock(getNodeState());
-            return (lMgr.isLocked(getNodeId()) && lMgr.getLock(getNodeId()).getNode().isSame(this));
+            return (lMgr.isLocked(getNodeState()) && lMgr.getLock(getNodeState()).getNode().isSame(this));
-        return session.getLockManager().isLocked(getNodeId());
+        return session.getLockManager().isLocked(getNodeState());
-        return session.getHierarchyManager().getQName(getNodeState());
+        NodeState parentState = getNodeState().getParent();
+        if (parentState == null) {
+            // shortcut. the given state represents the root or an orphaned node
+            return QName.ROOT;
+        }
+
+        NodeId nodeId = getNodeState().getNodeId();
+        ChildNodeEntry entry = parentState.getChildNodeEntry(nodeId);
+        if (entry == null) {
+            String msg = "Failed to retrieve qualified name of Node " + nodeId;
+            log.debug(msg);
+            throw new RepositoryException(msg);
+        }
+        return entry.getName();
-        session.getLockManager().checkLock(getNodeId());
+        session.getLockManager().checkLock(getNodeState());
-        itemStateMgr.execute(an);
+        session.getSessionItemStateManager().execute(an);
-        itemStateMgr.execute(op);
+        session.getSessionItemStateManager().execute(op);
-                log.error(mixinName + ": not a mixin node type");
+                log.error(mixin.getName() + ": not a mixin node type");
-                log.error(mixinName + ": already contained in primary node type");
+                log.error(mixin.getName() + ": already contained in primary node type");
-                log.error(mixinName + ": already contained in mixin types");
+                log.error(mixin.getName() + ": already contained in mixin types");
-        return session.getValidator().getApplicablePropertyDefinition(propertyName, type, multiValued, getNodeState());
+        ItemStateValidator validator = session.getValidator();
+        return validator.getApplicablePropertyDefinition(propertyName, type, multiValued, getNodeState());

INS26 INS26 INS40 INS40 MOV12 INS60 INS25 INS60 INS60 INS25 INS41 INS60 INS8 MOV8 INS43 INS59 INS27 INS8 INS43 INS59 INS43 INS59 INS27 INS8 INS32 INS43 INS59 INS53 INS32 INS60 INS32 INS32 MOV44 MOV44 INS21 INS32 MOV32 MOV32 INS42 INS42 INS32 INS42 INS33 INS41 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS33 INS60 INS21 MOV53 INS42 INS42 INS32 INS32 INS42 INS42 MOV32 INS42 INS14 UPD42 INS42 UPD42 MOV42 INS43 INS59 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS32 UPD42 INS53 UPD42 INS42 INS42 UPD42 MOV42 UPD42 UPD42 UPD42 INS32 UPD42 MOV42 INS40 MOV32 INS42 INS42 INS42 INS42 INS43 INS59 INS32 UPD42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS43 INS27 UPD45 INS42 INS42 INS32 MOV32 INS42 INS32 UPD42 INS14 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS27 INS42 INS42 INS42 MOV41 MOV41 INS42 UPD45 MOV45 INS32 UPD42 INS45 MOV32 INS45 MOV32 INS42 INS42 INS42 UPD42 UPD45 UPD45 UPD45 INS42 UPD45 UPD42 INS43 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS32 UPD45 UPD45 UPD45 UPD42 MOV32 UPD45 UPD45 UPD42 UPD42 MOV8 INS42 INS42 INS42 UPD42 INS32 UPD42 INS45 INS8 UPD42 MOV42 UPD42 INS32 INS32 INS32 INS42 INS42 INS42 INS32 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 UPD42 MOV43 INS45 DEL42 DEL42 DEL42 DEL45 DEL27 DEL32 DEL21 DEL42 DEL40 DEL7 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL45 DEL45 DEL42 DEL14 DEL53 DEL8 DEL42 DEL32 DEL42 DEL32 DEL52 DEL42 DEL32 DEL42 DEL32 DEL41 DEL42 DEL42 DEL42
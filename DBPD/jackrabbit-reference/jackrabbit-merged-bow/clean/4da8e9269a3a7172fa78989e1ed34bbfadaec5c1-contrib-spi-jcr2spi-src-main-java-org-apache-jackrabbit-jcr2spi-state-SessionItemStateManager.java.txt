work in progress

- operations: rename getAffectedIds to getAffectedStates
- operations: return ItemState params instead of ids whereever possible and
  let OperationVisitor deal with all kind of issues arising with SPI ids.
- AddNode/AddProperty operations: don't list state to be created as affected. Not required since operations are collected upon refresh/save, in which case a 'new' item can never be the starting point.
- transient move: let parent NodeState handle the move/renaming of child states
- transient reorder: let parent NodeState handle the reorder logic
- NodeState: remove unused methods and mark setParent private
- NodeImpl: protected getNodeId() no more used by subclasses in version package.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@431887 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.name.Path;
+                // safety... should have been checked befoe
+                case ItemState.STATUS_NEW:
+                    throw new ItemStateException("Unexpected state: cannot start undo from a new item state.");
+
-        Set affectedIds = new HashSet();
+        Set affectedStates = new HashSet();
-            affectedIds.add(((ItemState) it.next()).getId());
+            affectedStates.add(((ItemState) it.next()));
-        collectOperations(affectedIds, changeLog);
+        collectOperations(affectedStates, changeLog);
+
-            Set affectedIds = new HashSet();
+            Set affectedStates = new HashSet();
-                affectedIds.add(((ItemState) it.next()).getId());
+                affectedStates.add((ItemState) it.next());
-            checkIsSelfContained(affectedIds, changeLog);
-            collectOperations(affectedIds, changeLog);
+            checkIsSelfContained(affectedStates, changeLog);
+            collectOperations(affectedStates, changeLog);
-     * defined by the affected <code>itemIds</code>.
+     * defined by the affected <code>ItemState</code>s.
-     * @param affectedIds
+     * @param affectedStates
-    private void collectOperations(Set affectedIds, ChangeLog changeLog) {
+    private void collectOperations(Set affectedStates, ChangeLog changeLog) {
-            Iterator ids = op.getAffectedItemIds().iterator();
-            while (ids.hasNext()) {
-                ItemId id = (ItemId) ids.next();
-                if (affectedIds.contains(id)) {
+            Iterator states = op.getAffectedItemStates().iterator();
+            while (states.hasNext()) {
+                ItemState state = (ItemState) states.next();
+                if (affectedStates.contains(state)) {
-     * @param affectedIds
+     * @param affectedStates
-    private void checkIsSelfContained(Set affectedIds, ChangeLog changeLog) throws ItemStateException {
+    private void checkIsSelfContained(Set affectedStates, ChangeLog changeLog) throws ItemStateException {
-                Set dependentIDs = new HashSet();
+                Set dependentStates = new HashSet();
-                    // TODO: review usage of NodeId
-                    NodeId oldParentId = nodeState.getOverlayedState().getParent().getNodeId();
-                    NodeId newParentId = nodeState.getParent().getNodeId();
-                    if (oldParentId != null) {
-                        if (newParentId == null) {
+                    NodeState oldParentState = nodeState.getOverlayedState().getParent();
+                    NodeState newParentState = nodeState.getParent();
+                    if (oldParentState != null) {
+                        if (newParentState == null) {
-                            dependentIDs.add(oldParentId);
+                            dependentStates.add(oldParentState);
-                            if (!oldParentId.equals(newParentId)) {
+                            if (!oldParentState.equals(newParentState)) {
-                                dependentIDs.add(oldParentId);
-                                dependentIDs.add(newParentId);
+                                dependentStates.add(oldParentState);
+                                dependentStates.add(newParentState);
-                    dependentIDs.add(cne.getId());
+                    dependentStates.add(cne.getNodeState());
-                    dependentIDs.add(cne.getId());
+                    dependentStates.add(cne.getNodeState());
-                Iterator depIt = dependentIDs.iterator();
+                Iterator depIt = dependentStates.iterator();
-                    NodeId id = (NodeId) depIt.next();
-                    if (!affectedIds.contains(id)) {
+                    NodeState dependantState = (NodeState) depIt.next();
+                    if (!affectedStates.contains(dependantState)) {
-                        // TODO convert id to human-readable id
-                        String msg = id.toString() + " needs to be saved as well.";
+                        String msg = LogUtil.safeGetJCRPath(dependantState, nsResolver, hierMgr) + " needs to be saved as well.";
-        NodeState parent = getNodeState(operation.getParentId());
+        NodeState parent = operation.getParentState();
-        NodeState parent = getNodeState(operation.getParentId());
+        NodeState parent = operation.getParentState();
-        NodeState srcState = getNodeState(operation.getNodeId());
-        NodeState srcParent = getNodeState(operation.getSourceParentId());
+        NodeState srcState = operation.getNodeState();
+        NodeState srcParent = operation.getSourceParentState();
-        NodeState destParent = getNodeState(operation.getDestinationParentId());
+        NodeState destParent = operation.getDestinationParentState();
-        // TODO: TO-BE-FIXED. Move with SPI id
-        boolean renameOnly = srcParent.getNodeId().equals(destParent.getNodeId());
-        ChildNodeEntry cne = srcParent.getChildNodeEntry(srcState.getNodeId());
-        if (cne == null) {
-            String msg = "Unexpected error: Move source " + LogUtil.safeGetJCRPath(srcParent, nsResolver, hierMgr) + " does not contain a child node entry with the given id" + LogUtil.safeGetJCRPath(srcState, nsResolver, hierMgr);
-            log.error(msg);
-            throw new RepositoryException(msg);
-        }
-        QName srcName = cne.getName();
-        int srcIndex = cne.getIndex();
-        if (renameOnly) {
-            // change child node entry
-            destParent.renameChildNodeEntry(srcName, srcIndex, operation.getDestinationName());
-        } else {
-            // remove child node entry from old parent
-            srcParent.removeChildNodeEntry(srcName, srcIndex);
-            // re-parent target node
-            srcState.setParent(destParent);
-            // add child node entry to new parent
-            destParent.addChildNodeEntry(operation.getDestinationName(), srcState.getNodeId());
-        }
+        srcParent.moveChildNodeEntry(destParent, srcState, operation.getDestinationName());
-        try {
-            ItemState state = getItemState(operation.getRemoveId());
-            int options = ItemStateValidator.CHECK_LOCK
-                | ItemStateValidator.CHECK_VERSIONING
-                | ItemStateValidator.CHECK_CONSTRAINTS;
-            removeItemState(state, options);
-            // remember operation
-            transientStateMgr.addOperation(operation);
-        } catch (NoSuchItemStateException e) {
-            throw new PathNotFoundException(e);
-        } catch (ItemStateException e) {
-            throw new RepositoryException(e);
-        }
+        ItemState state = operation.getRemoveState();
+        int options = ItemStateValidator.CHECK_LOCK
+            | ItemStateValidator.CHECK_VERSIONING
+            | ItemStateValidator.CHECK_CONSTRAINTS;
+        removeItemState(state, options);
+        // remember operation
+        transientStateMgr.addOperation(operation);
-        NodeState nState = getNodeState(operation.getNodeId());
+        NodeState nState = operation.getNodeState();
-        try {
-            PropertyState pState = (PropertyState) getItemState(operation.getPropertyId());
-            setPropertyStateValue(pState, operation.getValues(), operation.getPropertyType());
-            transientStateMgr.addOperation(operation);
-        } catch (NoSuchItemStateException nsise) {
-            // TODO convert id to human-readable id
-            throw new ItemNotFoundException(operation.getPropertyId().toString());
-        } catch (ItemStateException ise) {
-            // TODO convert id to human-readable id
-            String msg = "internal error: failed to retrieve state of " + operation.getPropertyId().toString();
-            log.debug(msg);
-            throw new RepositoryException(msg, ise);
-        }
+        PropertyState pState = operation.getPropertyState();
+        setPropertyStateValue(pState, operation.getValues(), operation.getPropertyType());
+        transientStateMgr.addOperation(operation);
-        NodeState parent = getNodeState(operation.getParentId());
-
-        NodeId srcId = operation.getInsertNodeId();
-        NodeId beforeId = operation.getBeforeNodeId();
-
-        // TODO: TO-BE-FIXED. Reorder with SPI-Id -> instable ids
-        ArrayList list = new ArrayList(parent.getChildNodeEntries());
-        int srcInd = -1, destInd = -1;
-        for (int i = 0; i < list.size(); i++) {
-            ChildNodeEntry entry = (ChildNodeEntry) list.get(i);
-            if (srcInd == -1) {
-                if (entry.getId().equals(srcId)) {
-                    srcInd = i;
-                }
-            }
-            if (destInd == -1 && beforeId != null) {
-                if (entry.getId().equals(beforeId)) {
-                    destInd = i;
-                    if (srcInd != -1) {
-                        break;
-                    }
-                }
-            } else {
-                if (srcInd != -1) {
-                    break;
-                }
-            }
+        NodeState parent = operation.getParentState();
+        // modify the parent node state
+        try {
+            parent.reorderChildNodeEntries(operation.getInsertNodeId(), operation.getBeforeNodeId());
+        } catch (NoSuchItemStateException e) {
+            // invalid reorder-ids
+            throw new ItemNotFoundException(e);
-
-        // check if resulting order would be different to current order
-        if (destInd == -1) {
-            if (srcInd == list.size() - 1) {
-                // no change, we're done
-                return;
-            }
-        } else {
-            if ((destInd - srcInd) == Path.INDEX_DEFAULT) {
-                // no change, we're done
-                return;
-            }
-        }
-        // reorder list
-        if (destInd == -1) {
-            list.add(list.remove(srcInd));
-        } else {
-            if (srcInd < destInd) {
-                list.add(destInd, list.get(srcInd));
-                list.remove(srcInd);
-            } else {
-                list.add(destInd, list.remove(srcInd));
-            }
-        }
-
-        // modify the the parent node state ...
-        // TODO: do not set whole list but rather implement a proper reorder on NodeState!
-        // TODO: then remove NodeState.setChildNodeEntries()
-        parent.setChildNodeEntries(list);
-
-
-
-    /**
-     * Retrieves the state of the item with the specified id using the given
-     * item state manager.
-     * <p/>
-     * Note that access rights are <b><i>not</i></b> enforced!
-     *
-     * @param id
-     * @return
-     * @throws ItemNotFoundException
-     * @throws RepositoryException
-     */
-    private NodeState getNodeState(NodeId id) throws ItemNotFoundException, RepositoryException {
-        try {
-            return (NodeState) getItemState(id);
-        } catch (NoSuchItemStateException e) {
-            throw new ItemNotFoundException(id.toString());
-        } catch (ItemStateException e) {
-            String msg = "internal error: failed to retrieve state of " + id.toString();
-            log.debug(msg);
-            throw new RepositoryException(msg, e);
-        }
-    }

INS31 MOV8 MOV8 MOV29 MOV83 MOV39 MOV42 MOV44 MOV43 MOV43 MOV43 MOV43 MOV43 INS8 UPD42 UPD42 MOV21 MOV60 INS54 MOV21 UPD66 UPD42 UPD42 MOV43 MOV43 MOV43 INS8 MOV12 UPD42 UPD42 INS32 INS32 INS32 INS32 INS32 UPD42 UPD42 UPD42 MOV42 MOV42 MOV32 INS32 INS32 INS32 INS32 MOV21 MOV44 INS49 INS53 MOV32 MOV36 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 INS40 INS14 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV32 MOV32 MOV43 INS45 UPD43 MOV43 UPD42 INS11 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV43 MOV32 UPD43 UPD43 UPD43 UPD42 UPD43 UPD42 UPD42 UPD42 UPD42 MOV32 UPD42 UPD42 MOV32 UPD42 UPD42 UPD42 MOV42 UPD42 UPD42 UPD42 MOV43 UPD42 UPD42 UPD42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 DEL40 DEL26 DEL42 DEL42 DEL32 DEL11 DEL36 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL32 DEL42 DEL32 DEL32 DEL42 DEL32 DEL32 DEL42 DEL32 DEL32 DEL42 DEL32 DEL32 DEL42 DEL32 DEL42 DEL32 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL43 DEL42 DEL45 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL45 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL32 DEL32 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL42 DEL32 DEL32 DEL42 DEL43 DEL42 DEL32 DEL32 DEL11 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL32 DEL14 DEL53 DEL8 DEL12 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL45 DEL42 DEL42 DEL32 DEL42 DEL32 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL42 DEL32 DEL32 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL39 DEL42 DEL34 DEL38 DEL59 DEL42 DEL34 DEL38 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL34 DEL38 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL34 DEL38 DEL27 DEL42 DEL33 DEL27 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL7 DEL21 DEL42 DEL34 DEL38 DEL27 DEL10 DEL8 DEL25 DEL8 DEL25 DEL8 DEL42 DEL34 DEL38 DEL27 DEL10 DEL8 DEL25 DEL8 DEL25 DEL8 DEL24 DEL42 DEL34 DEL38 DEL27 DEL42 DEL42 DEL42 DEL32 DEL34 DEL27 DEL27 DEL41 DEL8 DEL25 DEL8 DEL42 DEL42 DEL27 DEL36 DEL40 DEL27 DEL41 DEL8 DEL25 DEL8 DEL25 DEL42 DEL34 DEL38 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL42 DEL42 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL31 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL65 DEL65 DEL42 DEL65 DEL42 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL41 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL31
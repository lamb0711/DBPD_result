Refactoring

- separate hierarchy from ItemStates
- remove ItemStateManager
- move all hierarchy related classes to a separate package ('hierarchy')
- allow loading of deep Item without loading ancestors
- consequently item definition is only built upon usage, since parent is needed.
- minor fixes with adding/removing mixin-nodetypes

Consequences for SPI interfaces:

- SPI impl must be able to deal with both proper itemID and path, since jcr2spi
  might not be aware of a uniqueID defined with a parent node.

- ItemInfo.getPath added, in order to be able to built the missing hierarchy
  entries if a deep Item identified by uniqueID (plus ev. path) is loaded

- LockInfo.getNodeId added, in order to be able to determine the lock-holding node.




git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@506927 13f79535-47bb-0310-9956-ffa450edef68

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * $Id$
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * Copyright 1997-2005 Day Management AG
+ * Barfuesserplatz 6, 4001 Basel, Switzerland
+ * All Rights Reserved.
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * This software is the confidential and proprietary information of
+ * Day Management AG, ("Confidential Information"). You shall not
+ * disclose such Confidential Information and shall use it only in
+ * accordance with the terms of the license agreement you entered into
+ * with Day.
-package org.apache.jackrabbit.jcr2spi.state;
+package org.apache.jackrabbit.jcr2spi.hierarchy;
-import org.apache.jackrabbit.jcr2spi.state.entry.ChildNodeEntry;
-import org.apache.jackrabbit.jcr2spi.state.entry.ChildNodeReference;
+import org.apache.jackrabbit.jcr2spi.state.ItemStateException;
-import java.util.List;
+import java.util.List;
- * <code>ChildNodeEntries</code> represents an insertion-ordered
- * collection of <code>ChildNodeEntry</code>s that also maintains
- * the index values of same-name siblings on insertion and removal.
+ * <code>ChildNodeEntries</code> represents an insertion-ordered collection of
+ * <code>NodeEntry</code>s that also maintains the index values of same-name
+ * siblings on insertion and removal.
-    private final NodeState nodeState;
+    private final NodeEntryImpl parent;
-     * Linked list of {@link ChildNodeEntry} instances.
+     * Linked list of {@link NodeEntry} instances.
-    private final LinkedEntries entries = new LinkedEntries();
+    private final ChildNodeEntries.LinkedEntries entries = new LinkedEntries();
-     * 
-     * @param nodeState
-     */
-    ChildNodeEntries(NodeState nodeState) {
-        this.nodeState = nodeState;
-    }
-
-    /**
-     * Create <code>ChildNodeEntries</code> for the given node state.
-     * @param nodeState
+     * @param parent
-    ChildNodeEntries(NodeState nodeState, ChildNodeEntries base) {
-        this.nodeState = nodeState;
-        for (Iterator it = base.iterator(); it.hasNext();) {
-            ChildNodeEntry baseCne = (ChildNodeEntry) it.next();
-            ChildNodeEntry cne = ChildNodeReference.create(nodeState, baseCne.getName(), baseCne.getUniqueID(), nodeState.isf, nodeState.idFactory);
-            add(cne);
-        }
+    ChildNodeEntries(NodeEntryImpl parent) {
+        this.parent = parent;
-                LinkedEntries.LinkNode n = (LinkedEntries.LinkNode) it.next();
-                ChildNodeEntry cne = n.getChildNodeEntry();
+                ChildNodeEntries.LinkedEntries.LinkNode n = (LinkedEntries.LinkNode) it.next();
+                NodeEntry cne = n.getNodeEntry();
-            ChildNodeEntry cne = ((LinkedEntries.LinkNode) o).getChildNodeEntry();
+            NodeEntry cne = ((ChildNodeEntries.LinkedEntries.LinkNode) o).getNodeEntry();
-
+    
-     * Returns the <code>ChildNodeEntry</code> for the given
-     * <code>nodeState</code>. Note, that this method does not check if the
-     * given childNodeEntry (and its attached NodeState) is still valid.
-     *
-     * @param childState the child node state for which a entry is searched.
-     * @return the <code>ChildNodeEntry</code> or <code>null</code> if there
-     * is no <code>ChildNodeEntry</code> for the given <code>NodeState</code>.
-     */
-    ChildNodeEntry get(NodeState childState) {
-        Object o = nameMap.get(childState.getQName());
-        if (o == null) {
-            // no matching child node entry
-            return null;
-        }
-        if (o instanceof List) {
-            // has same name sibling
-            for (Iterator it = ((List) o).iterator(); it.hasNext(); ) {
-                LinkedEntries.LinkNode n = (LinkedEntries.LinkNode) it.next();
-                ChildNodeEntry cne = n.getChildNodeEntry();
-                // only check available child node entries
-                try {
-                    if (cne.isAvailable() && cne.getNodeState() == childState) {
-                        return cne;
-                    }
-                } catch (ItemStateException e) {
-                    log.warn("error retrieving a child node state", e);
-                }
-            }
-        } else {
-            // single child node with this name
-            ChildNodeEntry cne = ((LinkedEntries.LinkNode) o).getChildNodeEntry();
-            try {
-                if (cne.isAvailable() && cne.getNodeState() == childState) {
-                    return cne;
-                }
-            } catch (ItemStateException e) {
-                log.warn("error retrieving a child node state", e);
-            }
-        }
-        // not found
-        return null;
-    }
-
-    /**
-     * Returns a <code>List</code> of <code>ChildNodeEntry</code>s for the
+     * Returns a <code>List</code> of <code>NodeEntry</code>s for the
-     * removed <code>ChildNodeEntry</code>s!
+     * removed <code>NodeEntry</code>s!
-                    return ((LinkedEntries.LinkNode) sns.get(index)).getChildNodeEntry();
+                    return ((LinkedEntries.LinkNode) sns.get(index)).getNodeEntry();
-                            return ((LinkedEntries.LinkNode) iter.next()).getChildNodeEntry();
+                            return ((LinkedEntries.LinkNode) iter.next()).getNodeEntry();
-            return Collections.singletonList(((LinkedEntries.LinkNode) obj).getChildNodeEntry());
+            return Collections.singletonList(((LinkedEntries.LinkNode) obj).getNodeEntry());
-     * Returns the <code>ChildNodeEntry</code> with the given
+     * Returns the <code>NodeEntry</code> with the given
-     * <code>ChildNodeEntry</code>s which are marked removed!
+     * <code>NodeEntry</code>s which are marked removed!
-     * @return the <code>ChildNodeEntry</code> or <code>null</code> if there
-     *         is no such <code>ChildNodeEntry</code>.
+     * @return the <code>NodeEntry</code> or <code>null</code> if there
+     *         is no such <code>NodeEntry</code>.
-    ChildNodeEntry get(QName nodeName, int index) {
+    NodeEntry get(QName nodeName, int index) {
-                ChildNodeEntry cne = ((LinkedEntries.LinkNode) it.next()).getChildNodeEntry();
+                NodeEntry cne = ((LinkedEntries.LinkNode) it.next()).getNodeEntry();
-                return ((LinkedEntries.LinkNode) obj).getChildNodeEntry();
+                return ((LinkedEntries.LinkNode) obj).getNodeEntry();
-    ChildNodeEntry get(QName nodeName, String uniqueID) {
+    NodeEntry get(QName nodeName, String uniqueID) {
-            ChildNodeEntry cne = (ChildNodeEntry) cneIter.next();
+            NodeEntry cne = (NodeEntry) cneIter.next();
-     * Insert a new childnode entry at the position indicated by index.
+     * Adds a <code>NodeEntry</code> to the end of the list.
-     * @param nodeName
-     * @param uniqueID
-     * @param index
-     * @return
+     * @param cne the <code>NodeEntry</code> to add.
-    ChildNodeEntry add(QName nodeName, String uniqueID, int index) {
-        ChildNodeEntry cne = ChildNodeReference.create(nodeState, nodeName, uniqueID, nodeState.isf, nodeState.idFactory);
-        add(cne, index);
-        return cne;
-    }
-
-    /**
-     * Adds a <code>childNode</code> to the end of the list.
-     *
-     * @param childState the <code>NodeState</code> to add.
-     * @return the <code>ChildNodeEntry</code> which was created for
-     *         <code>childNode</code>.
-     */
-    ChildNodeEntry add(NodeState childState) {
-        ChildNodeEntry cne = ChildNodeReference.create(childState, nodeState.isf, nodeState.idFactory);
-        add(cne);
-        return cne;
-    }
-    
-    /**
-     * Adds a <code>ChildNodeEntry</code> to the end of the list.
-     *
-     * @param cne the <code>ChildNodeEntry</code> to add.
-     */
-    private void add(ChildNodeEntry cne) {
-        QName nodeName = cne.getName();
+     void add(NodeEntry cne) {
+        QName nodeName = cne.getQName();
-     * Adds a <code>ChildNodeEntry</code>. If an entry with the given index
+     * Adds a <code>NodeEntry</code>. If an entry with the given index
-     * @param cne the <code>ChildNodeEntry</code> to add.
+     * @param cne the <code>NodeEntry</code> to add.
-    private void add(ChildNodeEntry cne, int index) {
-        QName nodeName = cne.getName();
+    void add(NodeEntry cne, int index) {
+        QName nodeName = cne.getQName();
-        // if index is 'undefined' behave just as '#add(ChildNodeEntry).
+        // if index is 'undefined' behave just as '#add(NodeEntry).
-        // add new entry (same as #add(ChildNodeEntry)
+        // add new entry (same as #add(NodeEntry)
-     * @return the removed <code>ChildNodeEntry</code> or <code>null</code>
-     *         if there is no matching <code>ChildNodeEntry</code>.
+     * @return the removed <code>NodeEntry</code> or <code>null</code>
+     *         if there is no matching <code>NodeEntry</code>.
-    ChildNodeEntry remove(QName nodeName, int index) {
+    NodeEntry remove(QName nodeName, int index) {
-            return ln.getChildNodeEntry();
+            return ln.getNodeEntry();
-        ChildNodeEntry removedEntry = ln.getChildNodeEntry();
+        NodeEntry removedEntry = ln.getNodeEntry();
-     * @param nodeState the node state whose entry is to be removed.
+     * @param childEntry the entry to be removed.
-    ChildNodeEntry remove(NodeState nodeState) {
-        ChildNodeEntry entry = null;
-        for (Iterator it = get(nodeState.getQName()).iterator(); it.hasNext(); ) {
-            ChildNodeEntry tmp = (ChildNodeEntry) it.next();
-            try {
-                if (tmp.isAvailable() && tmp.getNodeState() == nodeState) {
-                    entry = tmp;
-                    break;
-                }
-            } catch (ItemStateException e) {
-                log.warn("error accessing child node state: " + e.getMessage());
+    NodeEntry remove(NodeEntry childEntry) {
+        NodeEntry entry = null;
+        for (Iterator it = get(childEntry.getQName()).iterator(); it.hasNext(); ) {
+            NodeEntry tmp = (NodeEntry) it.next();
+            if (tmp == childEntry) {
+                entry = tmp;
+                break;
-            return remove(entry.getName(), entry.getIndex());
+            return remove(entry.getQName(), entry.getIndex());
-     * @param insertNode the node state to move.
-     * @param beforeNode the node state where <code>insertNode</code> is
+     * @param insertNode the NodeEntry to move.
+     * @param beforeNode the NodeEntry where <code>insertNode</code> is
-     * @throws NoSuchItemStateException if <code>insertNode</code> or
-     * <code>beforeNode</code> does not have a <code>ChildNodeEntry</code>
+     * @throws NoSuchElementException if <code>insertNode</code> or
+     * <code>beforeNode</code> does not have a <code>NodeEntry</code>
-    void reorder(NodeState insertNode, NodeState beforeNode) throws NoSuchItemStateException {
+    boolean reorder(NodeEntry insertNode, NodeEntry beforeNode) {
+        if (insertLN == null) {
+            return false;
+        }
+        if (beforeNode != null && beforeLN == null) {
+            return false;
+        }
+        return true;
-                QName insertName = insertLN.getChildNodeEntry().getName();
+                QName insertName = insertLN.getNodeEntry().getQName();
-                    } else if (ln.getChildNodeEntry().getName().equals(insertName)) {
+                    } else if (ln.getNodeEntry().getQName().equals(insertName)) {
-     * If the given child state got a (new) unique ID assigned or its removed,
-     * its childEntry must be adjusted.
-     *
-     * @param childState
-     */
-    void replaceEntry(NodeState childState) {
-        // NOTE: test if child-state needs to get a new entry not checked here.
-        try {
-            LinkedEntries.LinkNode ln = getLinkNode(childState);
-            ChildNodeEntry newCne = ChildNodeReference.create(childState, nodeState.isf, nodeState.idFactory);
-            entries.replaceNode(ln, newCne);
-        } catch (NoSuchItemStateException e) {
-            // should never occur.
-            log.error("Internal Error: ", e);
-        }
-    }
-
-    /**
-     * state name or due to missing availability of the <code>ChildNodeEntry</code>.
+     * state name or due to missing availability of the <code>NodeEntry</code>.
-     * @param nodeState the <code>NodeState</code> that is compared to the
-     * resolution of any <code>ChildNodeEntry</code> that matches by name.
+     * @param nodeEntry the <code>NodeEntry</code> that is compared to the
+     * resolution of any <code>NodeEntry</code> that matches by name.
-     * @throws NoSuchItemStateException if none of the <code>LinkNode</code>s
+     * @throws NoSuchElementException if none of the <code>LinkNode</code>s
-    private LinkedEntries.LinkNode getLinkNode(NodeState nodeState)
-        throws NoSuchItemStateException {
-        Object listOrLinkNode = nameMap.get(nodeState.getQName());
+    private LinkedEntries.LinkNode getLinkNode(NodeEntry nodeEntry) {
+        Object listOrLinkNode = nameMap.get(nodeEntry.getQName());
-            throw new NoSuchItemStateException(nodeState.getQName().toString());
+            return null;
-                ChildNodeEntry cne = n.getChildNodeEntry();
+                NodeEntry cne = n.getNodeEntry();
-                try {
-                    if (cne.isAvailable() && cne.getNodeState() == nodeState) {
-                        return n;
-                    }
-                } catch (ItemStateException e) {
-                    log.warn("error retrieving a child node state", e);
+                if (cne.isAvailable() && cne == nodeEntry) {
+                    return n;
-            ChildNodeEntry cne = ((LinkedEntries.LinkNode) listOrLinkNode).getChildNodeEntry();
-            try {
-                if (cne.isAvailable() && cne.getNodeState() == nodeState) {
-                    return (LinkedEntries.LinkNode) listOrLinkNode;
-                }
-            } catch (ItemStateException e) {
-                log.warn("error retrieving a child node state", e);
+            NodeEntry cne = ((LinkedEntries.LinkNode) listOrLinkNode).getNodeEntry();
+            if (cne.isAvailable() && cne == nodeEntry) {
+                return (LinkedEntries.LinkNode) listOrLinkNode;
-        throw new NoSuchItemStateException(nodeState.getQName().toString());
+        // not found
+        return null;
-        if (o instanceof ChildNodeEntry) {
+        if (o instanceof NodeEntry) {
-            return get(((ChildNodeEntry) o).getName()).contains(o);
+            return get(((NodeEntry) o).getQName()).contains(o);
-        ChildNodeEntry[] array = new ChildNodeEntry[size()];
+        NodeEntry[] array = new NodeEntry[size()];
-        if (!a.getClass().getComponentType().isAssignableFrom(ChildNodeEntry.class)) {
+        if (!a.getClass().getComponentType().isAssignableFrom(NodeEntry.class)) {
-            a = new ChildNodeEntry[size()];
+            a = new NodeEntry[size()];
-         * @return the LinkNode which refers to the added <code>ChildNodeEntry</code>.
+         * @return the LinkNode which refers to the added <code>NodeEntry</code>.
-        LinkNode add(ChildNodeEntry cne) {
-            LinkNode ln = (LinkNode) createNode(cne);
+        LinkedEntries.LinkNode add(NodeEntry cne) {
+            LinkedEntries.LinkNode ln = (LinkedEntries.LinkNode) createNode(cne);
-        void reorderNode(LinkNode insert, LinkNode before) {
+        void reorderNode(LinkedEntries.LinkNode insert, LinkedEntries.LinkNode before) {
-         * Replace the value of the given LinkNode with a new childNodeEntry
+         * Replace the value of the given LinkNode with a new NodeEntry
-        void replaceNode(LinkNode node, ChildNodeEntry value) {
+        void replaceNode(LinkedEntries.LinkNode node, NodeEntry value) {
-         * Create a new <code>LinkNode</code> for a given {@link ChildNodeEntry}
+         * Create a new <code>LinkNode</code> for a given {@link NodeEntry}
-         * @return a wrapping {@link LinkedEntries.LinkNode}.
+         * @return a wrapping {@link org.apache.jackrabbit.jcr2spi.hierarchy.ChildNodeEntries.LinkedEntries.LinkNode}.
-            return new LinkNode(value);
+            return new LinkedEntries.LinkNode(value);
-            return new LinkNode();
+            return new LinkedEntries.LinkNode();
-                private LinkNode next = ((LinkNode) header).getNextLinkNode();
+                private LinkedEntries.LinkNode next = ((LinkedEntries.LinkNode) header).getNextLinkNode();
-                    LinkNode n = next;
+                    LinkedEntries.LinkNode n = next;
-        private final class LinkNode extends AbstractLinkedList.Node {
+        private final class LinkNode extends Node {
-             * @return the wrapped <code>ChildNodeEntry</code>.
+             * @return the wrapped <code>NodeEntry</code>.
-            public ChildNodeEntry getChildNodeEntry() {
-                return (ChildNodeEntry) super.getValue();
+            public NodeEntry getNodeEntry() {
+                return (NodeEntry) super.getValue();
-            public LinkNode getNextLinkNode() {
-                return (LinkNode) super.getNextNode();
+            public LinkedEntries.LinkNode getNextLinkNode() {
+                return (LinkedEntries.LinkNode) super.getNextNode();
-}
+}

MOV26 MOV26 UPD40 UPD40 UPD43 UPD43 MOV29 UPD43 UPD43 UPD43 UPD43 UPD39 UPD66 UPD66 UPD66 UPD42 UPD42 INS40 UPD43 UPD42 UPD42 UPD42 UPD43 UPD43 UPD42 UPD42 UPD43 UPD42 UPD43 UPD43 INS25 INS25 INS41 UPD43 UPD42 MOV25 MOV41 UPD43 UPD43 UPD42 UPD42 UPD66 UPD66 INS8 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD42 MOV43 UPD66 UPD66 UPD42 MOV43 UPD66 UPD66 UPD43 UPD42 UPD66 UPD42 UPD43 UPD66 UPD66 UPD42 UPD66 UPD42 UPD42 INS27 INS8 INS27 INS8 INS9 UPD66 UPD42 UPD66 UPD66 UPD42 UPD42 MOV27 UPD5 INS40 UPD43 UPD43 UPD43 UPD43 UPD43 INS42 UPD43 UPD42 UPD43 UPD42 UPD42 INS41 UPD42 UPD42 MOV25 INS42 INS33 INS41 INS27 INS27 INS41 MOV25 UPD43 UPD43 UPD66 UPD42 MOV43 INS40 INS40 UPD66 INS40 UPD42 UPD42 INS40 UPD42 UPD43 INS32 MOV8 UPD43 UPD42 UPD42 UPD42 UPD43 INS27 INS9 INS42 INS33 INS42 INS33 INS9 UPD43 UPD42 UPD42 UPD5 MOV32 MOV11 UPD42 UPD40 UPD43 UPD43 UPD66 MOV60 UPD42 INS42 INS42 INS32 UPD42 UPD42 UPD42 INS42 INS42 UPD42 MOV25 UPD42 MOV32 UPD43 UPD43 MOV32 INS40 INS40 UPD43 UPD43 UPD43 UPD43 UPD42 MOV36 INS42 UPD43 MOV32 UPD43 UPD43 UPD42 MOV43 UPD43 UPD42 INS42 UPD42 UPD42 UPD42 UPD5 MOV32 UPD43 UPD42 INS40 INS40 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV32 INS27 UPD42 UPD43 INS40 UPD43 UPD42 UPD43 UPD42 UPD42 UPD42 MOV42 UPD42 INS42 UPD42 MOV42 UPD42 UPD43 INS40 UPD40 UPD42 UPD43 INS40 UPD42 UPD43 UPD42 INS40 UPD42 UPD42 UPD42 DEL40 DEL26 DEL42 DEL42 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL66 DEL65 DEL42 DEL65 DEL29 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL40 DEL40 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL24 DEL42 DEL42 DEL40 DEL43 DEL42 DEL40 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL40 DEL43 DEL42 DEL40 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL27 DEL27 DEL42 DEL41 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL24 DEL8 DEL42 DEL43 DEL42 DEL36 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL27 DEL27 DEL42 DEL41 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL31 DEL42 DEL42 DEL32 DEL42 DEL32 DEL41 DEL8 DEL66 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL65 DEL29 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL40 DEL40 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL40 DEL40 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL83 DEL83 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL27 DEL27 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL8 DEL12 DEL54 DEL42 DEL43 DEL66 DEL66 DEL65 DEL42 DEL65 DEL29 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL40 DEL40 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL31 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL32 DEL14 DEL53 DEL8 DEL25 DEL27 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL42 DEL42 DEL32 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL32 DEL14 DEL53 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL11 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL40 DEL42 DEL42
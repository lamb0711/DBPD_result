- Removed interface EventDispatcher. not used anymore.
- Adapted implementation of path handling in search to use regular term queries instead of a filter -> scales better.
- Changed notion of TEST_ROOT in test classes to also include the root slash.

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@51875 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.index.Term;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.TermDocs;
-import org.apache.lucene.search.*;
-
-import java.io.IOException;
+import org.apache.jackrabbit.core.Path;
+import org.apache.jackrabbit.core.NamespaceResolver;
+import org.apache.jackrabbit.core.NoPrefixDeclaredException;
- *
+ * Implements a query for a path with a match type.
-class PathQuery extends Query {
+class PathQuery extends BooleanQuery {
-    private final String path;
+    private final Path path;
+    /**
+     * The path type.
+     * The path <code>type</code> must be one of:
+     * <ul>
+     * <li>{@link org.apache.jackrabbit.core.search.PathQueryNode#TYPE_EXACT}</li>
+     * <li>{@link org.apache.jackrabbit.core.search.PathQueryNode#TYPE_CHILDREN}</li>
+     * <li>{@link org.apache.jackrabbit.core.search.PathQueryNode#TYPE_DESCENDANT_SELF}</li>
+     * </ul>
+     */
+    private final NamespaceResolver nsMappings;
+
-     * The path <code>type</code> must be one of:
-     * <ul>
-     * <li>{@link org.apache.jackrabbit.core.search.PathQueryNode#TYPE_EXACT}</li>
+     * The path <code>type</code> must be one of: <ul> <li>{@link
+     * org.apache.jackrabbit.core.search.PathQueryNode#TYPE_EXACT}</li>
-     * <li>{@link org.apache.jackrabbit.core.search.PathQueryNode#TYPE_DESCENDANT}</li>
+     * <li>{@link org.apache.jackrabbit.core.search.PathQueryNode#TYPE_DESCENDANT_SELF}</li>
-     * @param path the base path
-     * @param type the path type.
+     * @param path     the base path
+     * @param resolver namespace resolver to resolve <code>path</code>.
+     * @param type     the path type.
-    PathQuery(String path, int type) {
+    PathQuery(Path path, NamespaceResolver resolver, int type) {
-        if (type < PathQueryNode.TYPE_EXACT || type > PathQueryNode.TYPE_DESCENDANT) {
+        if (type < PathQueryNode.TYPE_EXACT || type > PathQueryNode.TYPE_DESCENDANT_SELF) {
+        this.nsMappings = resolver;
+        populateQuery();
-     * The path <code>type</code> must be one of:
-     * <ul>
-     * <li>{@link org.apache.jackrabbit.core.search.PathQueryNode#TYPE_EXACT}</li>
+     * The path <code>type</code> must be one of: <ul> <li>{@link
+     * org.apache.jackrabbit.core.search.PathQueryNode#TYPE_EXACT}</li>
-     * <li>{@link org.apache.jackrabbit.core.search.PathQueryNode#TYPE_DESCENDANT}</li>
+     * <li>{@link org.apache.jackrabbit.core.search.PathQueryNode#TYPE_DESCENDANT_SELF}</li>
-     * @param path  the base path
-     * @param type  the path type.
-     * @param index position index of the last location step.
+     * @param path     the base path
+     * @param type     the path type.
+     * @param index    position index of the last location step.
+     * @param resolver namespace resolver to resolve <code>path</code>.
-     *                                  in {@link org.apache.jackrabbit.core.search.PathQueryNode}. Or if
-     *                                  <code>index</code> &lt; 1.
+     *                                  in {@link org.apache.jackrabbit.core.search.PathQueryNode}.
+     *                                  Or if <code>index</code> &lt; 1.
-    PathQuery(String path, int type, int index) {
+    PathQuery(Path path, NamespaceResolver resolver, int type, int index) {
-        if (type < PathQueryNode.TYPE_EXACT || type > PathQueryNode.TYPE_DESCENDANT) {
+        if (type < PathQueryNode.TYPE_EXACT || type > PathQueryNode.TYPE_DESCENDANT_SELF) {
+        this.nsMappings = resolver;
+        populateQuery();
-     * Creates a new
-     *
-     * @param searcher
-     * @return
+     * Populates this <code>BooleanQuery</code> with clauses according
+     * to the path and match type.
-    protected Weight createWeight(Searcher searcher) {
-        return new PathQueryWeight(searcher);
-    }
-
-    public String toString(String field) {
-        return "";
-    }
-
-    private class PathQueryWeight implements Weight {
-
-        private final Searcher searcher;
-        private float value;
-        private float idf;
-        private float queryNorm;
-        private float queryWeight;
-
-
-        public PathQueryWeight(Searcher searcher) {
-            this.searcher = searcher;
-        }
-
-        public Query getQuery() {
-            return PathQuery.this;
-        }
-
-        public float getValue() {
-            return value;
-        }
-
-        public float sumOfSquaredWeights() throws IOException {
-            idf = searcher.getSimilarity().idf(searcher.maxDoc(), searcher.maxDoc()); // compute idf
-            queryWeight = idf * getBoost();             // compute query weight
-            return queryWeight * queryWeight;           // square it
-        }
-
-        public void normalize(float norm) {
-            this.queryNorm = norm;
-            queryWeight *= queryNorm;                   // normalize query weight
-            value = queryWeight * idf;                  // idf for document
-        }
-
-        public Scorer scorer(IndexReader reader) throws IOException {
-            return new PathQueryScorer(this, reader, searcher.getSimilarity());
-        }
-
-        public Explanation explain(IndexReader reader, int doc) throws IOException {
-            throw new UnsupportedOperationException();
-        }
-    }
-
-    private class PathQueryScorer extends Scorer {
-
-        private final Weight weight;
-
-        private final IndexReader reader;
-
-        private final float score;
-
-        protected PathQueryScorer(Weight weight,
-                                  IndexReader reader,
-                                  Similarity similarity) {
-            super(similarity);
-            this.weight = weight;
-            this.reader = reader;
-            score = similarity.tf(1) * weight.getValue();
-        }
-
-        public void score(HitCollector hc, int maxDoc) throws IOException {
-            TermDocs docs = reader.termDocs();
-            //hc.collect();
-        }
-
-        public Explanation explain(int doc) throws IOException {
-            throw new UnsupportedOperationException();
+    private void populateQuery() {
+        try {
+            if (type == PathQueryNode.TYPE_EXACT) {
+                Term t = new Term(FieldNames.PATH, path.toJCRPath(nsMappings));
+                add(new TermQuery(t), true, false);
+            } else if (type == PathQueryNode.TYPE_CHILDREN) {
+                if (path.denotesRoot()) {
+                    // get all nodes on level 1
+                    add(new TermQuery(new Term(FieldNames.LEVEL, String.valueOf(1))),
+                            true, false);
+                } else {
+                    Term t = new Term(FieldNames.ANCESTORS,
+                            path.toJCRPath(nsMappings));
+                    add(new TermQuery(t), true, false);
+                    int level = path.getAncestorCount() + 1;
+                    add(new TermQuery(new Term(FieldNames.LEVEL, String.valueOf(level))),
+                            true, false);
+                }
+            } else {
+                if (path.denotesRoot()) {
+                    // no restrictions
+                } else {
+                    String jcrPath = path.toJCRPath(nsMappings);
+                    // descendant or self
+                    Term t = new Term(FieldNames.PATH, jcrPath);
+                    // self
+                    add(new TermQuery(t), false, false);
+                    // or nodes with ancestors = self
+                    t = new Term(FieldNames.ANCESTORS, jcrPath);
+                    add(new TermQuery(t), false, false);
+                }
+            }
+        } catch (NoPrefixDeclaredException e) {
+            // will never happen, this.nsMappings dynamically adds unknown
+            // uri->prefix mappings

MOV26 INS26 INS26 INS40 UPD40 UPD40 UPD40 INS40 UPD40 UPD43 MOV23 INS31 INS65 UPD42 UPD43 INS29 UPD43 INS44 INS44 INS29 INS83 INS39 INS42 INS8 INS66 UPD42 INS65 UPD42 UPD42 INS65 UPD43 INS43 INS42 INS21 INS21 INS65 UPD43 INS43 INS42 INS21 INS21 INS65 INS54 INS66 INS66 INS66 INS66 MOV65 INS66 INS66 MOV65 INS66 INS66 INS65 INS66 INS66 UPD66 INS65 INS65 UPD66 INS42 INS66 UPD66 UPD42 INS42 INS7 INS32 UPD66 UPD66 UPD66 UPD66 INS42 INS66 UPD66 UPD66 UPD42 INS42 INS7 INS32 INS66 INS66 INS8 INS12 INS67 INS67 INS67 INS22 INS42 INS42 INS22 INS42 INS42 INS25 INS44 INS8 INS40 INS42 INS40 INS42 INS40 INS42 UPD42 UPD40 INS52 INS42 UPD42 UPD40 INS52 INS42 INS27 INS8 INS25 INS43 INS42 INS42 INS40 INS60 MOV21 INS27 INS8 INS8 UPD42 MOV42 INS43 INS59 INS32 UPD42 MOV42 INS40 INS25 INS25 UPD42 MOV42 INS42 INS14 UPD42 MOV42 INS14 INS9 INS9 INS32 INS8 INS8 INS32 INS8 INS8 INS43 INS40 INS32 INS43 INS42 INS42 INS42 INS21 INS60 INS21 INS60 INS21 INS42 INS42 INS60 INS60 INS21 MOV21 INS21 UPD42 MOV42 INS42 INS42 INS42 INS42 INS32 INS43 INS59 INS32 INS39 INS59 INS32 MOV43 INS59 INS43 INS59 INS32 INS32 INS42 INS14 INS9 INS9 UPD42 MOV42 INS42 INS14 INS42 INS14 INS9 INS9 INS42 INS27 INS42 INS14 INS9 INS9 INS42 INS32 UPD42 MOV42 INS42 INS14 INS42 INS14 INS9 INS9 INS42 INS14 INS42 INS14 INS9 INS9 INS43 INS14 UPD43 MOV43 INS40 INS32 INS43 INS42 INS32 INS34 INS43 INS14 INS42 INS42 INS42 INS43 INS40 INS42 INS43 INS42 INS43 INS40 INS42 INS43 INS42 INS42 INS43 INS40 INS32 UPD42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 INS43 INS40 INS32 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS34 UPD42 MOV42 INS42 INS42 INS42 DEL66 DEL66 DEL66 DEL66 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL7 DEL42 DEL42 DEL42 DEL34 DEL32 DEL42 DEL42 DEL32 DEL27 DEL66 DEL65 DEL42 DEL65 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL41 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL42 DEL44 DEL45 DEL41 DEL8 DEL31 DEL83 DEL42 DEL42 DEL43 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL83 DEL43 DEL42 DEL42 DEL52 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL27 DEL7 DEL21 DEL42 DEL42 DEL27 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL27 DEL7 DEL21 DEL8 DEL31 DEL83 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL52 DEL42 DEL32 DEL14 DEL41 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL14 DEL53 DEL8 DEL31 DEL55 DEL83 DEL42 DEL43 DEL83 DEL83 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL43 DEL42 DEL44 DEL42 DEL46 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL31 DEL83 DEL43 DEL42 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL14 DEL53 DEL8 DEL31 DEL55
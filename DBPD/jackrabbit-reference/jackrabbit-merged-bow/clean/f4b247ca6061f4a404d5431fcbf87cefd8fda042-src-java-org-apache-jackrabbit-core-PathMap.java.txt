Moved PathMap to core package

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@179383 13f79535-47bb-0310-9956-ffa450edef68

-package org.apache.jackrabbit.core.lock;
+package org.apache.jackrabbit.core;
-import org.apache.jackrabbit.core.Path;
-import org.apache.jackrabbit.core.QName;
-
-
-    private final Child root = new Child(null, Path.ROOT.getNameElement());
+    private final Child root = new Child(Path.ROOT.getNameElement());
-    public void put(Path path, Object obj) {
+    public Child put(Path path, Object obj) {
+        Child child = put(path);
+        child.obj = obj;
+        return child;
+    }
+
+    /**
+     * Create an empty child given by its path.
+     * @param path path to child
+     */
+    public Child put(Path path) {
-        current.obj = obj;
+        return current;
-     * Ressurrect a child previously removed, given by its new path and the
-     * child structure.
-     * @param path path to child
+     * Ressurrect a child previously removed, given by its path and the
+     * child structure. If an item at path already exists, nothing happens.
+     * @param path new path to child
-        Child current = root;
+        Path.PathElement name = path.getNameElement();
+        Child parent = root;
-        for (int i = 1; i < elements.length; i++) {
-            current = current.getChild(elements[i], true);
+        if (map(path, true) == null) {
+            for (int i = 1; i < elements.length - 1; i++) {
+                parent = parent.getChild(elements[i], true);
+            }
+            parent.setChild(name, zombie);
-
-        current.children = zombie.children;
-        current.childrenCount = zombie.childrenCount;
-        current.obj = zombie.obj;
-        private final Child parent;
+        private Child parent;
-         * Create a new instance of this class.
-         * @param parent parent of this child
+         * Create a new instance of this class with a path element.
-         * @param obj associated object
-        Child(Child parent, Path.PathElement element, Object obj) {
-            this.parent = parent;
+        Child(Path.PathElement element) {
-            this.obj = obj;
-         * @param parent parent of this child
-         * @param element path element of this child
-        Child(Child parent, Path.PathElement element) {
-            this(parent, element, null);
+        Child() {
+                        child.parent = null;
-         * Return a child matching a path element. If a child doesn not exist
+         * Return a child matching a path element. If a child does not exist
-                if (children == null) {
-                    children = new HashMap();
-                }
-                ArrayList list = (ArrayList) children.get(element.getName());
-                if (list == null) {
-                    list = new ArrayList();
-                    children.put(element.getName(), list);
-                }
-                while (list.size() < index) {
-                    list.add(null);
-                }
-                child = new Child(this, element);
-                list.add(child);
-                childrenCount++;
+                child = new Child();
+                setChild(element, child);
+         * Add a child.
+         * @param element child's path element
+         * @param child child to add
+         */
+        private void setChild(Path.PathElement element, Child child) {
+            int index = getOneBasedIndex(element) - 1;
+            if (children == null) {
+                children = new HashMap();
+            }
+            ArrayList list = (ArrayList) children.get(element.getName());
+            if (list == null) {
+                list = new ArrayList();
+                children.put(element.getName(), list);
+            }
+            while (list.size() < index) {
+                list.add(null);
+            }
+            if (list.size() == index) {
+                list.add(child);
+            } else {
+                list.set(index, child);
+            }
+
+            child.parent = this;
+            child.name = element.getName();
+            child.index = element.getIndex();
+
+            childrenCount++;
+        }
+
+        /**
+         * Return the name of this child
+         * @return name
+         */
+        public QName getName() {
+            return name;
+        }
+
+        /**
+         * Return the index of this child
+         * @return index
+         */
+        public int getIndex() {
+            return index;
+        }
+
+        /**
-         * Checks whether this child has the specified path
-         * @return path path to compare to
+         * Return the path of this element.
+         * @return path
+         * @throws MalformedPathException if building the path fails
+         */
+        public Path getPath() throws MalformedPathException {
+            if (parent == null) {
+                return Path.ROOT;
+            }
+
+            Path.PathBuilder builder = new Path.PathBuilder();
+            getPath(builder);
+            return builder.getPath();
+        }
+
+        /**
+         * Internal implementation of {@link #getPath()} that populates entries
+         * in a builder. On exit, <code>builder</code> contains the path
+         * of this element
+         */
+        private void getPath(Path.PathBuilder builder) {
+            if (parent == null) {
+                builder.addRoot();
+                return;
+            }
+            parent.getPath(builder);
+            if (index == 0 || index == 1) {
+                builder.addLast(name);
+            } else {
+                builder.addLast(name, index);
+            }
+        }
+
+        /**
+         * Checks whether this child has the specified path. Introduced to
+         * avoid catching a <code>MalformedPathException</code> for simple
+         * path comparisons.
+         * @param path path to compare to
+         * @return <code>true</code> if this child has the path
+         *         <code>path</code>, <code>false</code> otherwise
+         * @param visitor visitor to invoke
+         * @param includeEmpty if <code>true</code> invoke call back on every
+         *        child regardless, whether the associated object is empty
+         *        or not; otherwise call back on non-empty children only
+        /**
+         * Return the depth of this child. Defined to be <code>0</code> for the
+         * root node and <code>n + 1</code> for some child if the depth of its
+         * parent is <code>n</code>.
+         */
+        public int getDepth() {
+            if (parent != null) {
+                return parent.getDepth() + 1;
+            }
+            return 0;
+        }
+
+        /**
+         * Return a flag indicating whether the specified node is a
+         * child of this node.
+         * @param other node to check
+         */
+        public boolean isAncestorOf(Child other) {
+            Child parent = other.parent;
+            while (parent != null) {
+                if (parent == this) {
+                    return true;
+                }
+                parent = parent.parent;
+            }
+            return false;
+        }
+
+        /**
+         * Return the parent of this child
+         * @return parent or <code>null</code> if this is the root node
+         */
+        public Child getParent() {
+            return parent;
+        }

UPD40 INS31 MOV29 INS83 INS43 INS42 MOV44 MOV44 INS8 INS29 INS43 INS44 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS42 INS60 INS21 INS41 INS65 INS65 INS42 INS43 INS42 INS41 INS60 INS60 INS25 INS29 INS42 INS8 MOV29 INS83 INS39 UPD42 MOV42 MOV44 INS44 MOV8 INS29 INS83 INS43 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS43 INS42 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS44 MOV8 INS29 INS83 INS43 INS42 INS8 MOV43 INS59 INS7 INS42 INS66 INS42 INS66 INS42 INS42 UPD66 UPD66 UPD66 INS43 INS59 MOV43 MOV59 INS27 INS8 MOV65 INS65 MOV43 INS42 INS60 INS25 INS21 INS21 INS21 INS65 INS65 INS42 INS41 INS65 INS65 INS41 INS65 INS65 INS65 INS42 INS42 INS25 INS60 INS21 INS41 INS65 INS43 INS42 INS25 INS21 INS25 INS65 INS65 INS65 INS65 INS25 INS41 INS65 INS65 INS43 INS42 INS60 INS61 INS41 INS65 INS65 INS42 INS41 INS42 INS32 INS40 INS42 INS40 INS42 INS32 UPD42 INS32 INS33 MOV24 MOV21 UPD66 UPD66 INS8 INS66 UPD42 UPD66 UPD42 UPD66 INS39 INS59 INS27 INS8 INS8 INS7 INS7 INS7 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS27 INS8 INS43 INS59 INS32 INS32 INS66 INS65 INS66 INS66 INS66 INS40 INS27 INS8 INS32 INS27 INS8 INS8 UPD66 INS66 INS66 INS42 INS66 UPD66 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS27 INS8 INS34 INS66 INS66 INS42 INS66 INS42 INS43 INS59 INS27 INS8 INS9 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS32 INS21 INS21 INS42 INS27 INS32 INS42 MOV21 INS21 INS40 INS52 INS40 INS32 INS40 INS32 INS42 INS33 INS41 INS40 INS42 INS14 INS42 INS42 INS42 INS42 INS68 INS42 INS33 INS21 INS41 INS42 INS42 INS42 INS27 INS27 INS21 INS21 INS42 INS33 INS41 INS42 INS42 INS40 INS42 INS33 INS25 INS21 INS27 INS42 INS42 INS42 INS42 INS7 INS32 INS32 INS34 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS40 INS43 INS42 INS32 INS42 INS34 INS42 INS34 INS32 INS32 INS27 INS27 INS8 INS7 MOV40 INS34 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS34 INS42 INS52 INS41 INS42 INS40 UPD42 INS43 INS42 INS42 INS9 UPD42 INS21 INS42 INS7 INS40 INS33 DEL40 DEL26 DEL40 DEL26 DEL33 DEL39 DEL40 DEL42 DEL7 DEL21 DEL40 DEL40 DEL7 DEL42 DEL43 DEL60 DEL40 DEL40 DEL7 DEL21 DEL40 DEL40 DEL7 DEL21 DEL83 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL44 DEL31 DEL42 DEL52 DEL42 DEL14 DEL7 DEL21 DEL42 DEL42 DEL33 DEL17
JCR-569: Applied the WorkspaceImporter refactoring patch from Nicolas Toper.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@465218 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.Iterator;
+import java.util.List;
+import java.util.Stack;
+
+import javax.jcr.AccessDeniedException;
+import javax.jcr.ImportUUIDBehavior;
+import javax.jcr.ItemExistsException;
+import javax.jcr.ItemNotFoundException;
+import javax.jcr.PathNotFoundException;
+import javax.jcr.PropertyType;
+import javax.jcr.RepositoryException;
+import javax.jcr.ValueFormatException;
+import javax.jcr.lock.LockException;
+import javax.jcr.nodetype.ConstraintViolationException;
+import javax.jcr.version.VersionException;
+import javax.jcr.version.VersionHistory;
+
-import javax.jcr.ImportUUIDBehavior;
-import javax.jcr.ItemExistsException;
-import javax.jcr.ItemNotFoundException;
-import javax.jcr.PathNotFoundException;
-import javax.jcr.PropertyType;
-import javax.jcr.RepositoryException;
-import javax.jcr.lock.LockException;
-import javax.jcr.nodetype.ConstraintViolationException;
-import javax.jcr.version.VersionException;
-import javax.jcr.version.VersionHistory;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Stack;
-
- * <code>WorkspaceImporter</code> ...
+ * WorkspaceImporter. It imports the content submitted to it
+ * by the Content Handler
+ *
-
-    private final WorkspaceImpl wsp;
-
-    private boolean aborted;
+    //It is not useful anymore: we never abort: we raise an exception.
+    // I suggest to delete it. Do you see any issue with this?
+    private boolean aborted = false;
+    // Unused for now. It will be used in the next iteration on JIRA
+    private boolean raw = false;
+
-     * Creates a new <code>WorkspaceImporter</code> instance.
+     * True if we skip the tree with current node as root
+     */
+    private boolean skip = false;
+
+    /**
+     * Used to find when stopping skipping
+     */
+    private NodeInfo skipNode;
+
+    /**
+     * True if this node already exist
+     */
+    private NodeState existing = null;
+    private WorkspaceImpl wsp;
+
+    /**
+     * Creates a new <code>sWorkspaceImporter</code> instance.
-     * @param wsp
-     * @param ntReg
+     * @param wsp the workspace we want to import content to
+     * @param ntReg the NodeTypeRegistry of the repository
-                             WorkspaceImpl wsp,
-                             NodeTypeRegistry ntReg,
-                             int uuidBehavior)
-            throws PathNotFoundException, ConstraintViolationException,
-            VersionException, LockException, RepositoryException {
-
+            WorkspaceImpl wsp,
+            NodeTypeRegistry ntReg,
+            int uuidBehavior)
+    throws PathNotFoundException, ConstraintViolationException,
+    VersionException, LockException, RepositoryException {
-        hierMgr = wsp.getHierarchyManager();
-        // perform preliminary checks
+        this.hierMgr = wsp.getHierarchyManager();
+        //Perform preliminary checks
-
-
-
-
-     * @param parent
-     * @param conflicting
-     * @param nodeInfo
-     * @return
+     * Performs some checks to know if the node is importable or not.
+     * If it is a serious issue, raises an exception, else return false.
+     * this subtree.
+     * <br/>
+     * Performs also if needed some remapping.
+     *
+     * @param parent the parent NodeState
+     * @param nodeInfo NodeInfo passed by the ContentHandler
+     * @param propInfo PropInfo passed by the ContentHandler
+     * @return true if the node is fine; else false
+     * @throws RepositoryException if some constraints checks are not OK
+     * @throws ItemExistsException if the item exist
+     * @throws ItemNotFoundException if some constraints checks are not OK (shouldn't happen)
+     * @throws LockException if some constraints checks are not OK
+     * @throws VersionException if some constraints checks are not OK
+     * @throws AccessDeniedException if some constraints checks are not OK
+     * @throws ConstraintViolationException if some constraints checks are not OK
+     */
+    private boolean checkNode(NodeState parent, NodeInfo nodeInfo, List propInfo)
+        throws ConstraintViolationException, AccessDeniedException, VersionException,
+        LockException, ItemNotFoundException, ItemExistsException, RepositoryException {
+        itemOps.checkAddNode(parent, nodeInfo.getName(), nodeInfo.getNodeTypeName(),
+                BatchedItemOperations.CHECK_ACCESS
+                | BatchedItemOperations.CHECK_CONSTRAINTS
+                | BatchedItemOperations.CHECK_LOCK
+                | BatchedItemOperations.CHECK_VERSIONING);
+
+        QName nodeName = nodeInfo.getName();
+        QName ntName = nodeInfo.getNodeTypeName();
+
+        if (parent.hasChildNodeEntry(nodeName)) {
+            // a node with that name already exists...
+            //No need to check for more than one, since if it
+            //is the case we can import it.
+            NodeState.ChildNodeEntry entry =
+                parent.getChildNodeEntry(nodeName, 1);
+            NodeId idExisting = entry.getId();
+            NodeState existing = (NodeState) itemOps.getItemState(idExisting);
+            NodeDef def = ntReg.getNodeDef(existing.getDefinitionId());
+            if (!def.allowsSameNameSiblings()) {
+                // existing doesn't allow same-name siblings,
+                // check for potential conflicts
+                EffectiveNodeType entExisting =
+                    itemOps.getEffectiveNodeType(existing);
+                if (!raw && def.isProtected() && entExisting.includesNodeType(ntName)) {
+                    return false;
+                }
+
+                if (def.isAutoCreated() && entExisting.includesNodeType(ntName)) {
+                    // this node has already been auto-created,
+                    // no need to create it
+                    this.existing = existing;
+                } else {
+                    throw new ItemExistsException(itemOps.safeGetJCRPath(existing.getNodeId()));
+                }
+            }
+        }
+
+        if (parent.hasPropertyName(nodeName)) {
+            /**
+             * a property with the same name already exists; if this property
+             * has been imported as well (e.g. through document view import
+             * where an element can have the same name as one of the attributes
+             * of its parent element) we have to rename the onflicting property;
+             *
+             * see http://issues.apache.org/jira/browse/JCR-61
+             */
+            PropertyId propId = new PropertyId(parent.getNodeId(), nodeName);
+            PropertyState conflicting = itemOps.getPropertyState(propId);
+            if (conflicting.getStatus() == ItemState.STATUS_NEW) {
+                // assume this property has been imported as well;
+                // rename conflicting property
+                // @todo use better reversible escaping scheme to create unique name
+                QName newName = new QName(nodeName.getNamespaceURI(), nodeName.getLocalName() + "_");
+                if (parent.hasPropertyName(newName)) {
+                    newName = new QName(newName.getNamespaceURI(), newName.getLocalName() + "_");
+                }
+                PropertyState newProp =
+                    itemOps.createPropertyState(parent, newName,
+                            conflicting.getType(), conflicting.getValues().length);
+                newProp.setValues(conflicting.getValues());
+                parent.removePropertyName(nodeName);
+                itemOps.store(parent);
+                itemOps.destroy(conflicting);
+            }
+        }
+
+        return true;
+    }
+
+    /**
+     * Create propoerties on a specific NodeState
+     * @param myNode the NodeState
+     * @param propInfos PropInfo
+     * @throws ItemNotFoundException if issue in the NodeState
+     * @throws ItemExistsException if issue in the NodeState
+     * @throws ConstraintViolationException if issue in the NodeState
+     * @throws ValueFormatException if issue in the NodeState
+     * @throws RepositoryException if issue in the NodeState
+     */
+    private void createProperties(NodeState myNode, List propInfos)
+        throws ItemNotFoundException, ItemExistsException, ConstraintViolationException,
+                                                ValueFormatException, RepositoryException {
+        // process properties
+        Iterator iter = propInfos.iterator();
+        while (iter.hasNext()) {
+            PropInfo pi = (PropInfo) iter.next();
+            pi.apply(myNode, itemOps, ntReg, refTracker);
+        }
+    }
+
+    /**
+     * Create the specific NodeState
+     * @param parent NodeState
+     * @param nodeInfo NodeInfo
+     * @return newly create NodeState
+     * @throws ConstraintViolationException if we cannot create the NodeState
+     * @throws RepositoryException if we cannot create the NodeState
+     */
+    private NodeState createNode(NodeState parent, NodeInfo nodeInfo) throws ConstraintViolationException, RepositoryException {
+
+        NodeDef def =
+            itemOps.findApplicableNodeDefinition(nodeInfo.getName(), nodeInfo.getNodeTypeName(), parent);
+
+        // potential uuid conflict
+        NodeState conflicting = null;
+        NodeState node;
+
+        try {
+            if (nodeInfo.getId() != null) {
+                conflicting = itemOps.getNodeState(nodeInfo.getId());
+            }
+        } catch (ItemNotFoundException infe) {
+            conflicting = null;
+        }
+        if (conflicting != null) {
+            // resolve uuid conflict
+            node = resolveUUIDConflict(parent, conflicting, nodeInfo);
+        }
+        else {
+            // do create new node
+            node = itemOps.createNodeState(parent, nodeInfo.getName(), nodeInfo.getNodeTypeName(),
+                                                                nodeInfo.getMixinNames(), null, def);
+        }
+        return node;
+    }
+
+    /**
+     * Resolve UUID conflict if any.
+     *
+     * @param parent NodeState
+     * @param conflicting NodeState
+     * @param nodeInfo NodeInfo
+     * @return the new conflicting NodeState
+     * @throws ItemExistsException
+     * @throws ConstraintViolationException
+     * @throws IllegalStateException
-    protected NodeState resolveUUIDConflict(NodeState parent,
-                                            NodeState conflicting,
-                                            NodeInfo nodeInfo)
-            throws RepositoryException {
+    private NodeState resolveUUIDConflict(NodeState parent, NodeState conflicting, NodeInfo nodeInfo)
+        throws ItemExistsException, ConstraintViolationException, IllegalStateException, RepositoryException {
+        NodeState node = null;
+        switch (uuidBehavior) {
-        NodeState node;
-        if (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {
-            // create new with new uuid:
-            // check if new node can be added (check access rights &
-            // node type constraints only, assume locking & versioning status
-            // has already been checked on ancestor)
-            itemOps.checkAddNode(parent, nodeInfo.getName(),
-                    nodeInfo.getNodeTypeName(),
-                    BatchedItemOperations.CHECK_ACCESS
-                    | BatchedItemOperations.CHECK_CONSTRAINTS);
-            node = itemOps.createNodeState(parent, nodeInfo.getName(),
-                    nodeInfo.getNodeTypeName(), nodeInfo.getMixinNames(), null);
-            // remember uuid mapping
-            EffectiveNodeType ent = itemOps.getEffectiveNodeType(node);
-            if (ent.includesNodeType(QName.MIX_REFERENCEABLE)) {
-                refTracker.mappedUUID(nodeInfo.getId().getUUID(), node.getNodeId().getUUID());
+        case ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING:
+            NodeId parentId = conflicting.getParentId();
+            if (parentId == null) {
+                String msg = "root node cannot be replaced";
+                log.debug(msg);
+                throw new RepositoryException(msg);
-        } else if (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW) {
-            String msg = "a node with uuid " + nodeInfo.getId()
-                    + " already exists!";
-            log.debug(msg);
-            throw new ItemExistsException(msg);
-        } else if (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING) {
+            // 'replace' current parent with parent of conflicting
+            try {
+                parent = itemOps.getNodeState(parentId);
+            } catch (ItemNotFoundException infe) {
+                // should never get here...
+                String msg = "internal error: failed to retrieve parent state";
+                log.error(msg, infe);
+                throw new RepositoryException(msg, infe);
+            }
+            // remove conflicting:
+            // check if conflicting can be removed
+            // (access rights, node type constraints, locking & versioning status)
+            itemOps.checkRemoveNode(conflicting,
+                    BatchedItemOperations.CHECK_ACCESS
+                    | BatchedItemOperations.CHECK_LOCK
+                    | BatchedItemOperations.CHECK_VERSIONING
+                    | BatchedItemOperations.CHECK_CONSTRAINTS);
+            // do remove conflicting (recursive)
+            itemOps.removeNodeState(conflicting);
+            // do create new node
+            node = itemOps.createNodeState(parent, nodeInfo.getName(),
+                    nodeInfo.getNodeTypeName(), nodeInfo.getMixinNames(),
+                    nodeInfo.getId());
+            break;
+
+        case ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING:
+            // do create new node
+            node = itemOps.createNodeState(parent, nodeInfo.getName(),
+                    nodeInfo.getNodeTypeName(), nodeInfo.getMixinNames(),
+                    nodeInfo.getId());
+            break;
+
+        case ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW:
+            String msg = "a node with uuid " + nodeInfo.getId()
+            + " already exists!";
+            log.debug(msg);
+            throw new ItemExistsException(msg);
+
+        case ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW:
+            // create new with new uuid:
-            itemOps.checkAddNode(parent, nodeInfo.getName(),
-                    nodeInfo.getNodeTypeName(),
-                    BatchedItemOperations.CHECK_ACCESS
-                    | BatchedItemOperations.CHECK_CONSTRAINTS);
-            // do create new node
-                    nodeInfo.getNodeTypeName(), nodeInfo.getMixinNames(),
-                    nodeInfo.getId());
-        } else if (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING) {
-            NodeId parentId = conflicting.getParentId();
-            if (parentId == null) {
-                String msg = "root node cannot be replaced";
-                log.debug(msg);
-                throw new RepositoryException(msg);
+                    nodeInfo.getNodeTypeName(), nodeInfo.getMixinNames(), null);
+            // remember uuid mapping
+            EffectiveNodeType ent = itemOps.getEffectiveNodeType(node);
+            if (ent.includesNodeType(QName.MIX_REFERENCEABLE)) {
+                refTracker.mappedUUID(nodeInfo.getId().getUUID(), node.getNodeId().getUUID());
-            // 'replace' current parent with parent of conflicting
-            try {
-                parent = itemOps.getNodeState(parentId);
-            } catch (ItemNotFoundException infe) {
-                // should never get here...
-                String msg = "internal error: failed to retrieve parent state";
-                log.error(msg, infe);
-                throw new RepositoryException(msg, infe);
-            }
-            // remove conflicting:
-            // check if conflicting can be removed
-            // (access rights, node type constraints, locking & versioning status)
-            itemOps.checkRemoveNode(conflicting,
-                    BatchedItemOperations.CHECK_ACCESS
-                    | BatchedItemOperations.CHECK_LOCK
-                    | BatchedItemOperations.CHECK_VERSIONING
-                    | BatchedItemOperations.CHECK_CONSTRAINTS);
-            // do remove conflicting (recursive)
-            itemOps.removeNodeState(conflicting);
-            // create new with given uuid at same location as conflicting:
-            // check if new node can be added at other location
-            // (access rights, node type constraints, locking & versioning status)
-            itemOps.checkAddNode(parent, nodeInfo.getName(),
-                    nodeInfo.getNodeTypeName(),
-                    BatchedItemOperations.CHECK_ACCESS
-                    | BatchedItemOperations.CHECK_LOCK
-                    | BatchedItemOperations.CHECK_VERSIONING
-                    | BatchedItemOperations.CHECK_CONSTRAINTS);
-            // do create new node
-            node = itemOps.createNodeState(parent, nodeInfo.getName(),
-                    nodeInfo.getNodeTypeName(), nodeInfo.getMixinNames(),
-                    nodeInfo.getId());
-        } else {
-            String msg = "unknown uuidBehavior: " + uuidBehavior;
-            log.debug(msg);
-            throw new RepositoryException(msg);
+            break;
+         //No need for default case.
-
+     * @return true if skip mode is on.
+     */
+    protected boolean isSkipped() {
+        return skip;
+    }
+
+    /**
-     * @param node
-     * @throws RepositoryException
+     * @param node NodeState to postprocess
+     * @throws RepositoryException if issue when postprocessing a node
+
-            throws RepositoryException {
+    throws RepositoryException {
-            // the import has been aborted, get outta here...
-        boolean succeeded = false;
-        NodeState parent;
-        try {
-            // check sanity of workspace/session first
-            wsp.sanityCheck();
+        NodeState parent = (NodeState) parents.peek();
-            parent = (NodeState) parents.peek();
-
-            // process node
-
-            NodeState node = null;
-            NodeId id = nodeInfo.getId();
-            QName nodeName = nodeInfo.getName();
-            QName ntName = nodeInfo.getNodeTypeName();
-            QName[] mixins = nodeInfo.getMixinNames();
-
-            if (parent == null) {
-                // parent node was skipped, skip this child node also
-                parents.push(null); // push null onto stack for skipped node
-                succeeded = true;
-                log.debug("skipping node " + nodeName);
-                return;
-            }
-            if (parent.hasChildNodeEntry(nodeName)) {
-                // a node with that name already exists...
-                NodeState.ChildNodeEntry entry =
-                        parent.getChildNodeEntry(nodeName, 1);
-                NodeId idExisting = entry.getId();
-                NodeState existing = (NodeState) itemOps.getItemState(idExisting);
-                NodeDef def = ntReg.getNodeDef(existing.getDefinitionId());
-
-                if (!def.allowsSameNameSiblings()) {
-                    // existing doesn't allow same-name siblings,
-                    // check for potential conflicts
-                    EffectiveNodeType entExisting =
-                            itemOps.getEffectiveNodeType(existing);
-                    if (def.isProtected() && entExisting.includesNodeType(ntName)) {
-                        // skip protected node
-                        parents.push(null); // push null onto stack for skipped node
-                        succeeded = true;
-                        log.debug("skipping protected node "
-                                + itemOps.safeGetJCRPath(existing.getNodeId()));
-                        return;
-                    }
-                    if (def.isAutoCreated() && entExisting.includesNodeType(ntName)) {
-                        // this node has already been auto-created,
-                        // no need to create it
-                        node = existing;
-                    } else {
-                        throw new ItemExistsException(itemOps.safeGetJCRPath(existing.getNodeId()));
-                    }
-                }
-            }
-
-            if (node == null) {
-                // there's no node with that name...
-                if (id == null) {
-                    // no potential uuid conflict, always create new node
-
-                    NodeDef def =
-                            itemOps.findApplicableNodeDefinition(nodeName, ntName, parent);
-                    if (def.isProtected()) {
-                        // skip protected node
-                        parents.push(null); // push null onto stack for skipped node
-                        succeeded = true;
-                        log.debug("skipping protected node " + nodeName);
-                        return;
-                    }
-
-                    if (parent.hasPropertyName(nodeName)) {
-                        /**
-                         * a property with the same name already exists; if this property
-                         * has been imported as well (e.g. through document view import
-                         * where an element can have the same name as one of the attributes
-                         * of its parent element) we have to rename the onflicting property;
-                         *
-                         * see http://issues.apache.org/jira/browse/JCR-61
-                         */
-                        PropertyId propId = new PropertyId(parent.getNodeId(), nodeName);
-                        PropertyState conflicting = itemOps.getPropertyState(propId);
-                        if (conflicting.getStatus() == ItemState.STATUS_NEW) {
-                            // assume this property has been imported as well;
-                            // rename conflicting property
-                            // @todo use better reversible escaping scheme to create unique name
-                            QName newName = new QName(nodeName.getNamespaceURI(), nodeName.getLocalName() + "_");
-                            if (parent.hasPropertyName(newName)) {
-                                newName = new QName(newName.getNamespaceURI(), newName.getLocalName() + "_");
-                            }
-                            PropertyState newProp =
-                                    itemOps.createPropertyState(parent, newName,
-                                            conflicting.getType(), conflicting.getValues().length);
-                            newProp.setValues(conflicting.getValues());
-                            parent.removePropertyName(nodeName);
-                            itemOps.store(parent);
-                            itemOps.destroy(conflicting);
-                        }
-                    }
-
-                    // check if new node can be added (check access rights &
-                    // node type constraints only, assume locking & versioning status
-                    // has already been checked on ancestor)
-                    itemOps.checkAddNode(parent, nodeName, ntName,
-                            BatchedItemOperations.CHECK_ACCESS
-                            | BatchedItemOperations.CHECK_CONSTRAINTS);
-                    // do create new node
-                    node = itemOps.createNodeState(parent, nodeName, ntName, mixins, null, def);
-                } else {
-                    // potential uuid conflict
-                    NodeState conflicting;
-
-                    try {
-                        conflicting = itemOps.getNodeState(id);
-                    } catch (ItemNotFoundException infe) {
-                        conflicting = null;
-                    }
-                    if (conflicting != null) {
-                        // resolve uuid conflict
-                        node = resolveUUIDConflict(parent, conflicting, nodeInfo);
-                    } else {
-                        // create new with given uuid
-
-                        NodeDef def =
-                                itemOps.findApplicableNodeDefinition(nodeName, ntName, parent);
-                        if (def.isProtected()) {
-                            // skip protected node
-                            parents.push(null); // push null onto stack for skipped node
-                            succeeded = true;
-                            log.debug("skipping protected node " + nodeName);
-                            return;
-                        }
-
-                        // check if new node can be added (check access rights &
-                        // node type constraints only, assume locking & versioning status
-                        // has already been checked on ancestor)
-                        itemOps.checkAddNode(parent, nodeName, ntName,
-                                BatchedItemOperations.CHECK_ACCESS
-                                | BatchedItemOperations.CHECK_CONSTRAINTS);
-                        // do create new node
-                        node = itemOps.createNodeState(parent, nodeName, ntName, mixins, id, def);
-                    }
-                }
-            }
-
-            // process properties
-
-            Iterator iter = propInfos.iterator();
-            while (iter.hasNext()) {
-                PropInfo pi = (PropInfo) iter.next();
-                pi.apply(node, itemOps, ntReg, refTracker);
-            }
-
-            // store affected nodes
-            itemOps.store(node);
-            itemOps.store(parent);
-
-            // push current node onto stack of parents
-            parents.push(node);
-
-            succeeded = true;
-        } finally {
-            if (!succeeded) {
-                // update operation failed, cancel all modifications
-                aborted = true;
-                itemOps.cancel();
-            }
+        if (raw && !checkNode(parent, nodeInfo, propInfos)) {
+            skip = true;
+
+        if (skip) {
+            return;
+        }
+
+        NodeState myNode;
+        if (existing == null) {
+            myNode = createNode(parent, nodeInfo);
+        }
+        else {
+            myNode = existing;
+            existing = null;
+        }
+        createProperties(myNode, propInfos);
+        parents.push(myNode);
-        if (aborted) {
-            // the import has been aborted, get outta here...
+        //End of skip mode
+        if (skipNode != null && skipNode.equals(nodeInfo)) {
+            skip = false;
+            skipNode = null;
-        NodeState node = (NodeState) parents.pop();
-        if (node == null) {
-            // node was skipped, nothing to do here
+
+        if (aborted || skip) {
-        boolean succeeded = false;
+
-            // check sanity of workspace/session first
-            wsp.sanityCheck();
+            NodeState node = (NodeState) parents.pop();
-            // post-process node (initialize properties with special semantics etc.)
-            postProcessNode(node);
-
-            // make sure node is valid according to its definition
-            itemOps.validate(node);
-
-            // we're done with that node, now store its state
-            itemOps.store(node);
-            succeeded = true;
-        } finally {
-            if (!succeeded) {
-                // update operation failed, cancel all modifications
-                aborted = true;
-                itemOps.cancel();
+            if (!raw) {
+                this.postProcessNode(node);
+            itemOps.store(node);
+        } catch (IllegalStateException e) {
+            itemOps.cancel();
+            aborted = true;
-            // the import has been aborted, get outta here...
+            itemOps.cancel();
-        boolean succeeded = false;
-        try {
-            // check sanity of workspace/session first
-            wsp.sanityCheck();
-
-            /**
-             * adjust references that refer to uuid's which have been mapped to
-             * newly gererated uuid's on import
-             */
-            Iterator iter = refTracker.getProcessedReferences();
-            while (iter.hasNext()) {
-                PropertyState prop = (PropertyState) iter.next();
-                // being paranoid...
-                if (prop.getType() != PropertyType.REFERENCE) {
-                    continue;
-                }
-                boolean modified = false;
-                InternalValue[] values = prop.getValues();
-                InternalValue[] newVals = new InternalValue[values.length];
-                for (int i = 0; i < values.length; i++) {
-                    InternalValue val = values[i];
-                    UUID original = (UUID) val.internalValue();
-                    UUID adjusted = refTracker.getMappedUUID(original);
-                    if (adjusted != null) {
-                        newVals[i] = InternalValue.create(adjusted);
-                        modified = true;
-                    } else {
-                        // reference doesn't need adjusting, just copy old value
-                        newVals[i] = val;
-                    }
-                }
-                if (modified) {
-                    prop.setValues(newVals);
-                    itemOps.store(prop);
+        wsp.sanityCheck();
+        /**
+         * adjust references that refer to uuid's which have been mapped to
+         * newly gererated uuid's on import
+         */
+        Iterator iter = refTracker.getProcessedReferences();
+        while (iter.hasNext()) {
+            PropertyState prop = (PropertyState) iter.next();
+            // being paranoid...
+            if (prop.getType() != PropertyType.REFERENCE) {
+                continue;
+            }
+            boolean modified = false;
+            InternalValue[] values = prop.getValues();
+            InternalValue[] newVals = new InternalValue[values.length];
+            for (int i = 0; i < values.length; i++) {
+                InternalValue val = values[i];
+                UUID original = (UUID) val.internalValue();
+                UUID adjusted = refTracker.getMappedUUID(original);
+                if (adjusted != null) {
+                    newVals[i] = InternalValue.create(adjusted);
+                    modified = true;
+                } else {
+                    // reference doesn't need adjusting, just copy old value
+                    newVals[i] = val;
-            refTracker.clear();
-
-            // make sure import target is valid according to its definition
-            itemOps.validate(importTarget);
-
-            // finally store the state of the import target
-            // (the parent of the imported subtree)
-            itemOps.store(importTarget);
-            succeeded = true;
-        } finally {
-            if (!succeeded) {
-                // update operation failed, cancel all modifications
-                aborted = true;
-                itemOps.cancel();
+            if (modified) {
+                prop.setValues(newVals);
+                itemOps.store(prop);
+        refTracker.clear();
-        if (!aborted) {
-            // finish update
-            itemOps.update();
-        }
+        // make sure import target is valid according to its definition
+        itemOps.validate(importTarget);
+
+        // finally store the state of the import target
+        // (the parent of the imported subtree)
+        itemOps.store(importTarget);
+
+        // finish update
+        itemOps.update();
+
+

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 MOV23 MOV31 INS40 INS40 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS83 INS39 INS59 INS29 INS83 INS39 INS59 INS29 INS83 INS43 INS59 INS29 INS83 INS43 INS59 INS29 INS83 INS39 INS42 INS44 INS44 INS43 INS43 INS43 INS43 INS43 INS43 MOV8 INS29 INS83 MOV39 INS42 INS44 MOV44 INS43 INS43 INS43 INS43 INS43 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS43 MOV43 INS8 INS29 INS83 INS42 INS43 INS43 INS43 MOV8 INS29 INS83 INS39 INS42 INS8 MOV29 INS83 INS39 INS42 INS44 INS44 INS43 INS8 MOV29 INS83 INS39 INS42 MOV44 MOV43 INS8 MOV8 UPD66 INS66 INS9 INS42 INS9 INS65 INS42 INS9 INS65 INS42 INS42 INS65 INS42 INS42 INS33 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV21 MOV60 MOV60 MOV25 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS42 INS42 INS42 INS42 INS42 MOV60 MOV61 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS42 INS60 INS60 MOV60 INS54 INS25 INS41 INS65 MOV65 MOV65 MOV65 MOV65 INS65 INS65 INS65 MOV65 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV60 INS50 MOV41 INS65 INS41 INS43 INS42 INS43 INS42 INS42 MOV25 INS60 INS25 MOV25 INS60 INS25 MOV21 MOV21 INS25 INS25 INS54 INS25 MOV21 INS66 INS66 INS66 UPD66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 UPD42 MOV42 INS42 INS9 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS42 MOV43 INS59 MOV43 INS59 INS8 MOV12 MOV27 MOV8 INS8 INS42 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS42 INS42 INS49 MOV60 MOV25 MOV54 MOV21 MOV21 MOV21 INS10 INS49 MOV60 MOV60 MOV54 MOV21 MOV21 MOV21 INS10 INS49 MOV60 MOV21 MOV53 INS49 MOV21 MOV60 MOV25 INS10 INS66 INS42 INS66 INS66 INS42 INS42 MOV43 INS59 INS27 INS8 INS42 INS43 INS59 INS27 INS8 INS8 INS27 INS8 INS27 INS8 MOV8 INS12 INS42 INS8 INS22 INS42 MOV32 MOV42 INS42 INS33 MOV25 INS21 INS40 INS40 INS40 INS40 INS42 MOV11 INS42 INS38 INS21 INS42 INS42 INS42 INS33 MOV21 INS21 INS21 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 INS27 INS32 MOV21 INS21 INS41 INS42 INS42 INS41 MOV60 MOV21 INS44 MOV8 MOV21 MOV21 INS41 INS52 INS42 INS40 INS40 UPD42 INS27 INS7 INS32 INS7 INS7 INS7 INS7 INS42 INS33 INS42 INS42 INS42 INS7 INS8 INS43 INS42 MOV32 UPD42 INS32 INS33 INS21 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS32 INS42 INS42 INS42 INS33 UPD42 UPD9 INS42 INS33 UPD42 INS21 INS42 INS42 INS42 INS7 INS42 INS42 INS42 MOV32 MOV32 MOV32 INS33 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS38 INS41 INS42 INS32 INS42 INS52 INS42 INS42 INS42 INS9 INS42 INS42 MOV32 INS42 INS22 INS52 INS42 DEL83 DEL42 DEL83 DEL39 DEL42 DEL42 DEL42 DEL33 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL45 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL27 DEL32 DEL21 DEL41 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL33 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL41 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL42 DEL40 DEL40 DEL27 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL33 DEL42 DEL32 DEL7 DEL21 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL7 DEL21 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL85 DEL5 DEL42 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL33 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL41 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL33 DEL27 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL54 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL33 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL41 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL42 DEL40 DEL40 DEL27 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL8 DEL42 DEL38 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL40 DEL40 DEL27 DEL42 DEL41 DEL29 DEL83 DEL42 DEL42 DEL40 DEL27 DEL8 DEL42 DEL40 DEL27 DEL8 DEL42 DEL40 DEL27 DEL42 DEL40 DEL27 DEL42 DEL42 DEL42 DEL40 DEL40 DEL40 DEL40 DEL27 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL45 DEL42 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL14 DEL53 DEL8 DEL25 DEL25 DEL25 DEL25 DEL8 DEL42 DEL33 DEL27 DEL32 DEL83 DEL42 DEL39 DEL42 DEL9 DEL59 DEL60 DEL8 DEL54 DEL8 DEL31 DEL42 DEL9 DEL7 DEL42 DEL41 DEL8 DEL25 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL38 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL8 DEL54 DEL42 DEL38 DEL8 DEL25 DEL8
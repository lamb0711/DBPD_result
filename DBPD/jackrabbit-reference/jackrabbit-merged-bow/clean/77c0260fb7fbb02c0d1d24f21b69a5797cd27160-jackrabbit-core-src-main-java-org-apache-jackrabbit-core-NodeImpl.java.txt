JCR-1104 - JSR 283 support
- shareble nodes (work in progress)
- versioning operations
- regularize javadoc comments

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@645444 13f79535-47bb-0310-9956-ffa450edef68

-        return session.getHierarchyManager().getName(id);
+        HierarchyManager hierMgr = session.getHierarchyManager();
+        Name name;
+
+        if (!isShareable()) {
+            name = hierMgr.getName(id);
+        } else {
+            name = hierMgr.getName(getNodeId(), getParentId());
+        }
+        return name;
-        // (5) verify that source is shareable
-        if (!src.isShareable()) {
-            String msg = "Source node at " + src.safeGetJCRPath() + " is not shareable.";
-            log.debug(msg);
-            throw new RepositoryException(msg);
-        }
-
-        // (6) detect share cycle
-        NodeId srcId = src.getNodeId();
+        // (5) do clone operation
-        HierarchyManager hierMgr = session.getHierarchyManager();
-        if (parentId.equals(srcId) || hierMgr.isAncestor(srcId, parentId)) {
-            String msg = "This would create a share cycle.";
-            log.debug(msg);
-            throw new RepositoryException(msg);
-        }
+        src.addShare(parentId);
-        // (7) do clone operation (modify and store affected states)
-        if (!src.addShare(parentId)) {
-            String msg = "Adding a shareable node twice to the same parent is not supported.";
-            log.debug(msg);
-            throw new UnsupportedRepositoryOperationException(msg);
-        }
-
-        // (8) modify the state of 'this', i.e. the parent node
+        // (6) modify the state of 'this', i.e. the parent node
+        NodeId srcId = src.getNodeId();
-     * Add a parent to the shared set. This method does not check whether
-     * adding this parent would create a share cycle (and should therefore
-     * strictly be used internally), it does, however detect whether the given
-     * parent is already contained in the shared set.
-     *
-     * @return <code>true</code> if adding succeeded;
-     *         <code>false</code> otherwise.
+     * Add a parent to the shared set. This method checks first, whether:
+     * <ul>
+     * <li>this node is shareable</li>
+     * <li>adding this parent would create a share cycle</li>
+     * <li>whether this parent is already contained in the shared set</li>
+     * </ul>
+     * @param parentId parent to add to the shared set
+     * @throws RepositoryException if an error occurs
-    protected boolean addShare(NodeId parentId) throws RepositoryException {
-        // quickly verify whether the share is already contained before
-        // possibly changing the referenced state
-        NodeState state = (NodeState) this.state;
-        if (state.containsShare(parentId)) {
-            return false;
+    protected void addShare(NodeId parentId) throws RepositoryException {
+        // verify that we're shareable
+        if (!isShareable()) {
+            String msg = "Node at " + safeGetJCRPath() + " is not shareable.";
+            log.debug(msg);
+            throw new RepositoryException(msg);
-        // now make modifications
-        state = (NodeState) getOrCreateTransientItemState();
-        return state.addShare(parentId);
+
+        // detect share cycle
+        NodeId srcId = getNodeId();
+        HierarchyManager hierMgr = session.getHierarchyManager();
+        if (parentId.equals(srcId) || hierMgr.isAncestor(srcId, parentId)) {
+            String msg = "This would create a share cycle.";
+            log.debug(msg);
+            throw new RepositoryException(msg);
+        }
+
+        // quickly verify whether the share is already contained before creating
+        // a transient state in vain
+        NodeState state = (NodeState) this.state;
+        if (!state.containsShare(parentId)) {
+            state = (NodeState) getOrCreateTransientItemState();
+            if (state.addShare(parentId)) {
+                return;
+            }
+        }
+        String msg = "Adding a shareable node twice to the same parent is not supported.";
+        log.debug(msg);
+        throw new UnsupportedRepositoryOperationException(msg);
+                        } else if (existing.isShareable()) {
+                            // if existing node is shareable, then clone it
+                            restoredChild = clone(existing, f.getName());
-                restoredChild = addNode(f.getName(), f);
-                restoredChild.restoreFrozenState(f, vsel, restored, removeExisting);
+                if (restoredChild == null) {
+                    restoredChild = addNode(f.getName(), f);
+                    restoredChild.restoreFrozenState(f, vsel, restored, removeExisting);
+                }

MOV60 UPD39 INS8 INS60 INS60 INS25 INS41 INS21 INS65 UPD65 MOV25 INS60 MOV60 MOV25 MOV60 INS25 MOV60 MOV21 MOV53 INS43 INS59 INS43 INS59 INS38 INS8 INS8 INS42 MOV32 UPD66 INS66 UPD66 UPD66 UPD66 INS66 INS42 INS66 INS42 UPD66 INS43 INS59 INS38 MOV8 MOV25 INS42 INS42 INS32 INS42 INS42 INS32 INS21 INS21 INS42 INS42 INS32 MOV32 MOV42 MOV42 INS42 INS7 INS7 INS42 MOV32 INS42 INS32 INS42 INS32 INS25 INS42 MOV42 MOV42 INS42 INS42 INS32 INS32 UPD45 INS27 INS8 INS42 INS42 INS42 INS33 MOV21 MOV21 INS25 INS32 INS8 MOV8 INS42 INS42 INS21 INS7 INS42 INS32 INS42 INS42 INS32 INS42 INS42 DEL32 DEL32 DEL41 DEL38 DEL8 DEL25 DEL66 DEL42 DEL42 DEL9 DEL41
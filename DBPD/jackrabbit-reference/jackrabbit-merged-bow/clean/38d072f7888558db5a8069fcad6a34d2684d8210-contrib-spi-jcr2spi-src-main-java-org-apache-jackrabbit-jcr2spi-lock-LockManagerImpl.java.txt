work in progress

- Restore: pass NodeState(s) and Path instead of NodeId(s)
- LockManager: make sure lockmanager only remembers workspace states
- LockManager: make sure operations are executed using workspace states
- LockManager: improve isLocked/getLock/checkIsLocked and respect locks that
have been accessed before.
- VersionManager: make sure operations are executed using workspace states
- VersionManager: add checkIsCheckedOut
- VersionManager: force manager to have a WorkspaceManager
- NodeReferences:
  > make interface package protected
  > clarify method naming
  > add implementation to WorkspaceItemStateFactory
  > add NodeReferences field to NodeState
  > TO_IMPROVE: references are currently always retrieve from the SPI.
- ItemStateManager + NodeReferences
  > rename interfaces methods
  > change method signature to take NodeState instead of NodeId
  > 'getReferences' returns the property states directly

- remove some JR DIFFs. 

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@432234 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.state.ItemState;
+    /**
+     * WorkspaceManager used to apply and release locks as well as to retrieve
+     * Lock information for a given NodeState.
+     * NOTE: The workspace manager must not be used as ItemStateManager.
+     */
+        // NOTE: Node must be retrieved from the given NodeState and not from
+        // the overlayed workspace nodestate. See below.
-        Operation op = LockOperation.create(nodeState, isDeep, isSessionScoped);
+        NodeState wspNodeState = getWorkspaceState(nodeState);
+        Operation op = LockOperation.create(wspNodeState, isDeep, isSessionScoped);
-        Lock lock = new LockImpl(nodeState, lhNode, isSessionScoped);
+        Lock lock = new LockImpl(wspNodeState, lhNode, isSessionScoped);
-     * If the session created a lock on the node with the given id, we already
-     * know the lock. Otherwise, we look in the node state and the states of
-     * the ancestor nodes for properties indicating a lock.<br>
-     * Note, that the flag indicating session-scoped lock cannot be retrieved
-     * and the lock will always report 'false'.
-     *
-     * @see LockManager#getLock(NodeState)
-     * @param nodeState
-     */
-    public Lock getLock(NodeState nodeState) throws LockException, RepositoryException {
-        // shortcut: check if lock has been accessed before
-        if (lockMap.containsKey(nodeState)) {
-            return (Lock) lockMap.get(nodeState);
-        }
-
-        // try to retrieve parent state that holds a lock.
-        NodeState lockHoldingState = getLockHoldingState(nodeState);
-        if (lockHoldingState == null) {
-            throw new LockException("Node with id '" + nodeState.getNodeId() + "' is not locked.");
-        } else {
-            // check lockMap again with the lockholding state
-            if (lockMap.containsKey(lockHoldingState)) {
-                return (Lock) lockMap.get(lockHoldingState);
-            }
-
-            // retrieve lock holding node. note that this may fail if the session
-            // does not have permission to see this node.
-            Item lockHoldingNode = itemManager.getItem(lockHoldingState);
-            // TODO: we don;t know if lock is session scoped -> set flag to false
-            // TODO: ev. add 'isSessionScoped' to RepositoryService lock-call.
-            Lock l = new LockImpl(lockHoldingState, (Node)lockHoldingNode, false);
-            return l;
-        }
-    }
-
-    /**
+        NodeState wspNodeState = getWorkspaceState(nodeState);
-        Operation op = LockRelease.create(nodeState);
+        Operation op = LockRelease.create(wspNodeState);
-        if (lockMap.containsKey(nodeState)) {
-            LockImpl l = (LockImpl) lockMap.remove(nodeState);
+        if (lockMap.containsKey(wspNodeState)) {
+            LockImpl l = (LockImpl) lockMap.remove(wspNodeState);
+     * If the session created a lock on the node with the given state, we already
+     * know the lock. Otherwise, the node state and its ancestores are searched
+     * for properties indicating a lock.<br>
+     * Note, that the flag indicating session-scoped lock cannot be retrieved
+     * unless the current session is the lock holder.
+     *
+     * @see LockManager#getLock(NodeState)
+     * @param nodeState
+     */
+    public Lock getLock(NodeState nodeState) throws LockException, RepositoryException {
+        NodeState wspNodeState;
+        // a lock can never exist on a new state -> access parent
+        if (nodeState.getStatus() == ItemState.STATUS_NEW) {
+            wspNodeState = getWorkspaceState(nodeState.getParent());
+        } else {
+            wspNodeState = getWorkspaceState(nodeState);
+        }
+
+        LockImpl l = internalGetLock(wspNodeState);
+        // no-lock found or lock doesn't apply to this state -> throw
+        if (l == null) {
+            throw new LockException("Node with id '" + nodeState.getNodeId() + "' is not locked.");
+        }
+
+        // a lock exists either on the given node state or as deep lock inherited
+        // from any of the ancestor states.
+        return l;
+    }
+
+    /**
-        // shortcut: check if a given node holds a lock and lock has been
-        // accessed before (thus is known to the manager).
-        if (lockMap.containsKey(nodeState)) {
-            return true;
+        NodeState wspNodeState;
+        // a lock can never exist on a new state -> access parent
+        if (nodeState.getStatus() == ItemState.STATUS_NEW) {
+            wspNodeState = getWorkspaceState(nodeState.getParent());
-            // check if any lock is present (checking lock-specific properties)
-            LockInfo lInfo = getLockInfo(nodeState);
-            return lInfo != null;
+            wspNodeState = getWorkspaceState(nodeState);
+
+        LockImpl l = internalGetLock(wspNodeState);
+        return l != null;
-        LockInfo lInfo;
-        // shortcut: check if a given node holds a lock and lock has been
-        // accessed before (thus is known to the manager).
-        if (lockMap.containsKey(nodeState)) {
-            lInfo = ((LockImpl)lockMap.get(nodeState)).lockInfo;
-        } else {
-            // check if any lock is present (checking lock-specific properties)
-            lInfo = getLockInfo(nodeState);
+        // shortcut: new status indicates that a new state was already added
+        // thus, the parent state is not locked by foreign lock.
+        if (nodeState.getStatus() == ItemState.STATUS_NEW) {
+            return;
-        if (lInfo != null && lInfo.getLockToken() == null) {
+        NodeState wspNodeState = getWorkspaceState(nodeState);
+        LockImpl l = internalGetLock(wspNodeState);
+        if (l != null && l.lockInfo.getLockToken() == null) {
-        }
+        } // else: state is not locked at all || session is lock-holder
+     * If the given <code>NodeState</code> has an overlayed state, the overlayed
+     * (workspace) state will be returned. Otherwise the given state is returned.
-     * @return
-     * @throws LockException
-     * @throws RepositoryException
+     * @return The overlayed state or the given state, if this one does not have
+     * an overlayed state.
-    private LockInfo getLockInfo(NodeState nodeState) throws RepositoryException {
-        try {
-            return wspManager.getLockInfo(nodeState.getNodeId());
-        } catch (LockException e) {
-            log.debug("No lock present on node with id '" + nodeState.getNodeId() + "'", e);
-            return null;
+    private NodeState getWorkspaceState(NodeState nodeState) {
+        if (nodeState.hasOverlayedState()) {
+            // nodestate has been obtained from  Session-ISM
+            return (NodeState) nodeState.getOverlayedState();
+        } else {
+            // nodestate has been obtained from Workspace-ISM already
+            return nodeState;
-     * Search nearest ancestor that is locked. Returns <code>null</code> if no
-     * lock ancestor could be found.
+     * Search nearest ancestor that is locked. Returns <code>null</code> if neither
+     * the given state nor any of its ancestors is locked.
+     * Note, that this methods does NOT check if the given node state would
+     * be affected by the lock present on an ancestor state.
-     * @param nodeState <code>NodeState</code> from which searching starts.
-     * @return lock ancestor node or <code>null</code>.
+     * @param wspNodeState <code>NodeState</code> from which searching starts.
+     * Note, that the given state must not have an overlayed state.
+     * @return a state holding a lock or <code>null</code> if neither the
+     * given state nor any of its ancestors is locked.
-    private NodeState getLockHoldingState(NodeState nodeState) {
+    private NodeState getLockHoldingState(NodeState wspNodeState) {
-         * FIXME should not only rely on existence of jcr:lockIsDeep property
+         * TODO: should not only rely on existence of jcr:lockIsDeep property
-        while (!nodeState.hasPropertyName(QName.JCR_LOCKISDEEP)) {
-            NodeState parentState = nodeState.getParent();
+        while (!wspNodeState.hasPropertyName(QName.JCR_LOCKISDEEP)) {
+            NodeState parentState = wspNodeState.getParent();
-            nodeState = parentState;
+            wspNodeState = parentState;
-        return nodeState;
+        return wspNodeState;
+    }
+
+    /**
+     * Returns the Lock that applies to the given node state (directly or
+     * by an inherited deep lock) or <code>null</code> if the state is not
+     * locked at all.
+     *
+     * @param wspNodeState
+     * @return LockImpl that applies to the given state or <code>null</code>.
+     * @throws RepositoryException
+     */
+    private LockImpl internalGetLock(NodeState wspNodeState) throws RepositoryException {
+        // shortcut: check if a given state holds a lock, which has been
+        // accessed before (thus is known to the manager) irrespective if the
+        // current session is the lock holder or not.
+        if (lockMap.containsKey(wspNodeState)) {
+            return (LockImpl) lockMap.get(wspNodeState);
+        }
+
+        // try to retrieve a state (ev. a parent state) that holds a lock.
+        NodeState lockHoldingState = getLockHoldingState(wspNodeState);
+        if (lockHoldingState == null) {
+            // no lock
+            return null;
+        } else {
+            // check lockMap again with the lockholding state
+            if (lockMap.containsKey(lockHoldingState)) {
+                return (LockImpl) lockMap.get(lockHoldingState);
+            }
+
+            // Lock has never been access -> build the lock object
+            // retrieve lock holding node. note that this may fail if the session
+            // does not have permission to see this node.
+            Item lockHoldingNode = itemManager.getItem(lockHoldingState);
+            // TODO: we don;t know if lock is session scoped -> set flag to false
+            // TODO: ev. add 'isSessionScoped' to RepositoryService lock-call.
+            LockImpl l = new LockImpl(lockHoldingState, (Node)lockHoldingNode, false);
+
+            if (l.appliesToNodeState(wspNodeState)) {
+                return l;
+            } else {
+                // lock exists but does not apply to the workspace node state
+                // passed to this method.
+                return null;
+            }
+        }
+         * Note, that the given state must not have an overlayed state.
+            if (lockHoldingState.hasOverlayedState()) {
+                throw new IllegalArgumentException("Cannot build Lock object from a node state that has an overlayed state.");
+            }
+
+
+        /**
+         * Returns true, if the given node state is the lockholding state of
+         * this Lock object OR if this Lock is deep.
+         * Note, that in the latter case this method does not assert, that the
+         * given node state is a child state of the lockholding state.
+         *
+         * @param nodeState that must be the same or a child of the lock holding
+         * state stored within this lock object.
+         * @return true if this lock applies to the given node state.
+         */
+        private boolean appliesToNodeState(NodeState nodeState) {
+            if (lockHoldingState.equals(nodeState)) {
+                return true;
+            } else {
+                return isDeep();
+            }
+        }

INS26 MOV31 INS40 INS31 INS29 MOV29 INS83 MOV43 INS42 MOV44 MOV43 MOV43 INS8 MOV65 UPD43 UPD42 MOV44 INS44 INS29 UPD83 INS43 UPD42 INS44 INS31 INS65 INS60 INS60 INS60 INS25 INS60 INS25 MOV41 INS60 INS25 INS60 MOV41 INS25 INS60 INS60 UPD65 UPD65 UPD42 INS25 INS43 INS42 INS41 INS65 INS65 INS65 MOV65 INS42 INS43 INS42 INS29 INS83 INS39 INS42 MOV44 INS8 INS66 INS66 INS66 INS43 INS59 MOV43 INS59 UPD66 UPD66 UPD66 UPD66 INS43 INS59 INS27 INS8 INS8 MOV43 INS59 INS27 MOV8 INS43 INS59 INS27 INS8 INS8 MOV43 MOV59 INS27 INS8 INS43 INS59 MOV43 INS59 INS66 INS66 INS66 INS66 INS32 INS8 INS8 UPD66 INS66 INS66 UPD66 UPD42 INS66 UPD66 INS66 INS42 INS42 INS66 INS66 INS66 INS42 INS66 INS42 INS43 INS8 INS25 INS65 INS65 INS65 INS25 INS42 INS42 INS32 INS42 INS32 UPD42 INS42 INS42 INS32 INS40 INS21 INS21 INS42 INS32 INS42 INS33 INS42 INS42 INS32 INS40 INS21 INS21 UPD42 UPD42 INS32 INS40 INS41 INS42 INS42 INS32 INS42 INS32 MOV42 UPD42 MOV42 INS41 MOV41 UPD42 INS42 MOV41 INS25 INS66 INS32 INS8 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS66 INS32 MOV8 INS8 INS42 INS42 UPD42 UPD42 INS42 INS42 UPD42 INS43 INS42 INS42 INS7 INS7 INS42 INS42 MOV42 INS42 INS7 INS7 UPD42 UPD42 INS42 INS42 UPD42 MOV42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 INS11 UPD42 UPD42 UPD43 INS32 INS8 INS8 INS42 INS42 INS53 INS42 INS42 INS42 INS41 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS40 INS43 INS32 INS32 UPD42 UPD43 UPD42 INS42 INS42 INS42 INS41 INS41 INS14 INS32 INS43 INS42 INS32 INS42 INS42 INS42 MOV32 INS42 INS42 UPD42 MOV42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 UPD42 INS42 INS33 INS43 INS45 INS42 INS42 UPD42 INS42 INS42 UPD43 INS42 UPD42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL60 DEL8 DEL25 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL11 DEL36 DEL42 DEL22 DEL7 DEL21 DEL8 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL41 DEL8 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL32 DEL45 DEL27 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54
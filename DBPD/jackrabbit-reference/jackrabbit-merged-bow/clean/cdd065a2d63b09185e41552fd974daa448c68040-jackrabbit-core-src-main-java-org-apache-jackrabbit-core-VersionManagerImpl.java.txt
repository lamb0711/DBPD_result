JCR-890: concurrent read-only access to a session

Turn many versioning operations into SessionOperations

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@983926 13f79535-47bb-0310-9956-ffa450edef68

+import static org.apache.jackrabbit.core.ItemValidator.CHECK_HOLD;
+import static org.apache.jackrabbit.core.ItemValidator.CHECK_LOCK;
+import static org.apache.jackrabbit.core.ItemValidator.CHECK_PENDING_CHANGES;
+import static org.apache.jackrabbit.core.ItemValidator.CHECK_PENDING_CHANGES_ON_NODE;
+
+import org.apache.jackrabbit.core.session.SessionContext;
+import org.apache.jackrabbit.core.session.SessionOperation;
-     * Creates a new version manager for the given session
-     * @param session workspace sesion
+     * Component context of the current session
+     */
+    private final SessionContext sessionContext;
+
+    /**
+     * Creates a new version manager
+     *
+     * @param sessionContext component context of the current session
-    public VersionManagerImpl(SessionImpl session,
-                                 UpdatableItemStateManager stateMgr,
-                                 HierarchyManager hierMgr) {
-        super(session, stateMgr, hierMgr);
+    public VersionManagerImpl(
+            SessionContext sessionContext, UpdatableItemStateManager stateMgr,
+            HierarchyManager hierMgr) {
+        super(sessionContext.getSessionImpl(), stateMgr, hierMgr);
+        this.sessionContext = sessionContext;
-    /**
-     * {@inheritDoc}
-     */
+    private <T> T perform(SessionOperation<T> operation)
+            throws RepositoryException {
+        return sessionContext.getSessionState().perform(operation);
+    }
+
+    /** Wrapper around {@link #checkin(String, Calendar)}. */
-    public Version checkin(String absPath, Calendar created)
+    public Version checkin(final String absPath, final Calendar created)
-        NodeStateEx state = getNodeState(absPath,
-                ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD
-                | ItemValidator.CHECK_PENDING_CHANGES_ON_NODE,
-                Permission.VERSION_MNGMT);
-        NodeId baseId = checkoutCheckin(state, true, false, created);
-        return (VersionImpl) session.getNodeById(baseId);
+        return perform(new SessionOperation<Version> () {
+            public Version perform(SessionContext context)
+                    throws RepositoryException {
+                NodeStateEx state = getNodeState(
+                        absPath,
+                        CHECK_LOCK | CHECK_HOLD | CHECK_PENDING_CHANGES_ON_NODE,
+                        Permission.VERSION_MNGMT);
+                NodeId baseId = checkoutCheckin(state, true, false, created);
+                return (Version) session.getNodeById(baseId);
+            }
+        });
-    public void checkout(String absPath) throws RepositoryException {
-        NodeStateEx state = getNodeState(absPath,
-                ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD,
-                Permission.VERSION_MNGMT);
-        checkoutCheckin(state, false, true, null);
+    public void checkout(final String absPath) throws RepositoryException {
+        perform(new SessionOperation<NodeId> () {
+            public NodeId perform(SessionContext context)
+                    throws RepositoryException {
+                NodeStateEx state = getNodeState(
+                        absPath,
+                        CHECK_LOCK | CHECK_HOLD,
+                        Permission.VERSION_MNGMT);
+                return checkoutCheckin(state, false, true, null);
+            }
+        });
-    public Version checkpoint(String absPath) throws RepositoryException {
-        NodeStateEx state = getNodeState(absPath,
-                ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD | ItemValidator.CHECK_PENDING_CHANGES_ON_NODE,
-                Permission.VERSION_MNGMT);
-        NodeId baseId = checkoutCheckin(state, true, true, null);
-        return (VersionImpl) session.getNodeById(baseId);
+    public Version checkpoint(final String absPath) throws RepositoryException {
+        return perform(new SessionOperation<Version> () {
+            public Version perform(SessionContext context)
+                    throws RepositoryException {
+                NodeStateEx state = getNodeState(
+                        absPath,
+                        CHECK_LOCK | CHECK_HOLD | CHECK_PENDING_CHANGES_ON_NODE,
+                        Permission.VERSION_MNGMT);
+                NodeId baseId = checkoutCheckin(state, true, true, null);
+                return (Version) session.getNodeById(baseId);
+            }
+        });
-    /**
-     * {@inheritDoc}
-     */
+    /** Wrapper around {@link Node#isCheckedOut()}. */
-    public VersionHistory getVersionHistory(String absPath)
+    public VersionHistory getVersionHistory(final String absPath)
-        NodeStateEx state = getNodeState(absPath);
-        InternalVersionHistory vh = getVersionHistory(state);
-        return (VersionHistory) session.getNodeById(vh.getId());
+        return perform(new SessionOperation<VersionHistory> () {
+            public VersionHistory perform(SessionContext context)
+                    throws RepositoryException {
+                NodeStateEx state = getNodeState(absPath);
+                InternalVersionHistory vh = getVersionHistory(state);
+                return (VersionHistory) session.getNodeById(vh.getId());
+            }
+        });
-    public Version getBaseVersion(String absPath)
+    public Version getBaseVersion(final String absPath)
-        NodeStateEx state = getNodeState(absPath);
-        InternalVersion v = getBaseVersion(state);
-        return (Version) session.getNodeById(v.getId());
+        return perform(new SessionOperation<Version> () {
+            public Version perform(SessionContext context)
+                    throws RepositoryException {
+                NodeStateEx state = getNodeState(absPath);
+                InternalVersion v = getBaseVersion(state);
+                return (Version) session.getNodeById(v.getId());
+            }
+        });
-    /**
-     * {@inheritDoc}
-     */
+    /** Wrapper around {@link #restore(Version[], boolean)}. */
-    public void restore(Version[] versions, boolean removeExisting)
+    public void restore(final Version[] versions, final boolean removeExisting)
-        // check for pending changes
-        if (session.hasPendingChanges()) {
-            String msg = "Unable to restore version. Session has pending changes.";
-            log.error(msg);
-            throw new InvalidItemStateException(msg);
-        }
-        // add all versions to map of versions to restore
-        Map<NodeId, InternalVersion> toRestore = new HashMap<NodeId, InternalVersion>();
-        for (Version version : versions) {
-            InternalVersion v = vMgr.getVersion(((VersionImpl) version).getNodeId());
-            // check for collision
-            NodeId historyId = v.getVersionHistory().getId();
-            if (toRestore.containsKey(historyId)) {
-                String msg = "Unable to restore. Two or more versions have same version history.";
-                log.error(msg);
-                throw new VersionException(msg);
+        perform(new SessionOperation<Object> () {
+            public Object perform(SessionContext context)
+                    throws RepositoryException {
+                // check for pending changes
+                if (session.hasPendingChanges()) {
+                    throw new InvalidItemStateException(
+                            "Unable to restore version. Session has pending changes.");
+                }
+
+                // add all versions to map of versions to restore
+                Map<NodeId, InternalVersion> toRestore =
+                    new HashMap<NodeId, InternalVersion>();
+                for (Version version : versions) {
+                    InternalVersion v =
+                        vMgr.getVersion(((VersionImpl) version).getNodeId());
+                    // check for collision
+                    NodeId historyId = v.getVersionHistory().getId();
+                    if (toRestore.containsKey(historyId)) {
+                        throw new VersionException(
+                                "Unable to restore. Two or more versions have same version history.");
+                    }
+                    toRestore.put(historyId, v);
+                }
+
+                WriteOperation ops = startWriteOperation();
+                try {
+                    internalRestore(
+                            new VersionSet(toRestore, true), removeExisting);
+                    ops.save();
+                } catch (ItemStateException e) {
+                    throw new RepositoryException(e);
+                } finally {
+                    ops.close();
+                }
+
+                return this;
-            toRestore.put(historyId, v);
-        }
-        WriteOperation ops = startWriteOperation();
-        try {
-            internalRestore(new VersionSet(toRestore, true), removeExisting);
-            ops.save();
-        } catch (ItemStateException e) {
-            throw new RepositoryException(e);
-        } finally {
-            ops.close();
-        }
+        });
-    public void restore(String absPath, String versionName, boolean removeExisting)
-            throws RepositoryException {
-        NodeStateEx state = getNodeState(absPath,
-                ItemValidator.CHECK_PENDING_CHANGES | ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD,
-                Permission.NONE);
-        restore(state, session.getQName(versionName), removeExisting);
+    public void restore(
+            final String absPath, final String versionName,
+            final boolean removeExisting) throws RepositoryException {
+        perform(new SessionOperation<Object> () {
+            public Object perform(SessionContext context)
+                    throws RepositoryException {
+                NodeStateEx state = getNodeState(
+                        absPath,
+                        CHECK_PENDING_CHANGES | CHECK_LOCK | CHECK_HOLD,
+                        Permission.NONE);
+                restore(state, context.getQName(versionName), removeExisting);
+                return this;
+            }
+        });
-    public void restore(String absPath, Version version, boolean removeExisting)
+    public void restore(
+            final String absPath, final Version version, final boolean removeExisting)
-        // first check if node exists
-        if (session.nodeExists(absPath)) {
-            String msg = "VersionManager.restore(String, Version, boolean) not " +
-                    "allowed on existing nodes. " +
-                    "use VersionManager.restore(Version, boolean) instead: " + absPath;
-            log.error(msg);
-            throw new VersionException(msg);
-        } else {
-            // parent has to exist
-            Path path = session.getQPath(absPath);
-            Path parentPath = path.getAncestor(1);
-            Name name = path.getNameElement().getName();
-            NodeImpl parent = session.getItemManager().getNode(parentPath);
+        perform(new SessionOperation<Object> () {
+            public Object perform(SessionContext context)
+                    throws RepositoryException {
+                // first check if node exists
+                if (session.nodeExists(absPath)) {
+                    throw new VersionException(
+                            "VersionManager.restore(String, Version, boolean)"
+                            + " not allowed on existing nodes; use"
+                            + " VersionManager.restore(Version, boolean) instead: "
+                            + absPath);
+                } else {
+                    // parent has to exist
+                    Path path = context.getQPath(absPath);
+                    Path parentPath = path.getAncestor(1);
+                    Name name = path.getNameElement().getName();
+                    NodeImpl parent = context.getItemManager().getNode(parentPath);
-            NodeStateEx state = getNodeState(parent,
-                    ItemValidator.CHECK_PENDING_CHANGES | ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD,
-                    Permission.NONE);
+                    NodeStateEx state = getNodeState(
+                            parent,
+                            CHECK_PENDING_CHANGES | ItemValidator.CHECK_LOCK | CHECK_HOLD,
+                            Permission.NONE);
-            // check if given version is a baseline
-            InternalVersion v = getVersion(version);
-            if (v instanceof InternalBaseline) {
-                restore(state, name, (InternalBaseline) v);
-            } else {
-                restore(state, name, v, removeExisting);
+                    // check if given version is a baseline
+                    InternalVersion v = getVersion(version);
+                    if (v instanceof InternalBaseline) {
+                        restore(state, name, (InternalBaseline) v);
+                    } else {
+                        restore(state, name, v, removeExisting);
+                    }
+                }
+                return this;
-        }
+        });
-        NodeStateEx state = getNodeState(node.getPath(),
-                ItemValidator.CHECK_PENDING_CHANGES | ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD,
+        NodeStateEx state = getNodeState(
+                node.getPath(),
+                CHECK_PENDING_CHANGES | CHECK_LOCK | CHECK_HOLD,
-    public void restoreByLabel(String absPath, String versionLabel, boolean removeExisting)
-            throws RepositoryException {
-        NodeStateEx state = getNodeState(absPath,
-                ItemValidator.CHECK_PENDING_CHANGES | ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD,
-                Permission.NONE);
-        restoreByLabel(state, session.getQName(versionLabel), removeExisting);
+    public void restoreByLabel(
+            final String absPath, final String versionLabel,
+            final boolean removeExisting) throws RepositoryException {
+        perform(new SessionOperation<Object> () {
+            public Object perform(SessionContext context)
+                    throws RepositoryException {
+                NodeStateEx state = getNodeState(
+                        absPath,
+                        CHECK_PENDING_CHANGES | CHECK_LOCK | CHECK_HOLD,
+                        Permission.NONE);
+                restoreByLabel(
+                        state, context.getQName(versionLabel), removeExisting);
+                return this;
+            }
+        });
-    /**
-     * {@inheritDoc}
-     */
-    public NodeIterator merge(String absPath, String srcWorkspace,
-                              boolean bestEffort)
+    /** Wrapper around {@link #merge(String, String, boolean, boolean)}. */
+    public NodeIterator merge(
+            String absPath, String srcWorkspace, boolean bestEffort)
-    public NodeIterator merge(String absPath, String srcWorkspaceName,
-                              boolean bestEffort, boolean isShallow)
+    public NodeIterator merge(
+            final String absPath, final String srcWorkspaceName,
+            final boolean bestEffort, final boolean isShallow)
-        NodeStateEx state = getNodeState(absPath,
-                ItemValidator.CHECK_PENDING_CHANGES,
-                Permission.VERSION_MNGMT);
-        List<ItemId> failedIds = new LinkedList<ItemId>();
-        mergeOrUpdate(state, srcWorkspaceName, failedIds, bestEffort, isShallow);
-        return new LazyItemIterator(session.getItemManager(), failedIds);
+        return perform(new SessionOperation<NodeIterator> () {
+            public NodeIterator perform(SessionContext context)
+                    throws RepositoryException {
+                NodeStateEx state = getNodeState(
+                        absPath,
+                        CHECK_PENDING_CHANGES,
+                        Permission.VERSION_MNGMT);
+                List<ItemId> failedIds = new LinkedList<ItemId>();
+                mergeOrUpdate(state, srcWorkspaceName, failedIds, bestEffort, isShallow);
+                return new LazyItemIterator(session.getItemManager(), failedIds);
+            }
+        });

INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS29 INS83 INS83 INS43 INS59 INS83 INS73 INS43 INS42 INS44 INS43 INS8 INS8 INS43 INS8 INS43 INS43 INS8 MOV29 INS83 INS43 INS42 MOV44 INS43 INS8 MOV29 INS83 INS43 INS42 INS44 INS43 INS8 MOV29 INS83 INS39 INS42 INS44 INS44 INS43 INS8 MOV29 INS44 INS8 MOV29 INS83 INS39 INS42 INS44 INS44 INS44 MOV43 INS8 MOV29 INS43 INS8 INS29 MOV29 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS65 INS42 INS42 UPD43 UPD42 INS21 INS42 INS42 INS74 INS42 INS42 INS41 INS83 INS83 INS41 INS83 INS42 INS21 INS42 INS83 INS42 INS41 INS42 INS83 UPD42 INS42 INS41 INS42 INS83 MOV43 INS42 INS42 INS41 INS83 INS5 INS42 INS83 INS39 INS42 INS42 INS21 INS83 MOV43 INS42 INS83 UPD42 INS83 INS21 INS83 INS43 INS42 INS83 INS43 INS42 INS83 INS39 INS42 INS21 INS83 INS83 INS43 INS83 INS42 INS21 INS65 INS42 INS83 INS43 INS42 INS83 INS43 INS42 INS83 INS39 INS42 INS83 INS39 INS42 INS42 INS41 INS66 UPD66 UPD42 UPD66 UPD42 INS32 INS7 INS43 INS43 INS32 INS66 UPD65 INS66 INS32 INS32 INS32 INS66 UPD65 INS66 INS32 INS32 INS66 UPD65 INS66 INS43 INS85 INS32 INS32 INS42 INS42 INS32 INS42 INS32 INS66 INS65 INS66 INS42 INS42 INS32 INS42 INS42 INS22 INS42 INS42 INS42 INS32 INS42 INS42 INS68 INS42 INS14 INS42 INS14 INS42 INS14 INS68 INS42 INS14 INS42 INS14 INS68 INS42 INS42 INS14 INS42 INS14 INS42 INS14 INS42 INS14 INS68 INS42 INS14 INS52 INS42 INS42 INS42 INS42 INS69 INS69 INS74 INS1 INS74 INS1 INS74 INS1 INS42 INS42 INS74 INS1 INS74 INS1 INS42 INS69 INS69 INS74 INS1 INS74 INS1 INS74 INS1 INS74 INS1 INS42 INS69 INS69 INS69 INS69 INS74 INS1 MOV43 INS43 INS43 INS43 INS31 INS43 INS43 INS31 INS43 INS43 INS31 INS43 INS43 MOV31 INS43 INS43 MOV31 MOV5 INS39 INS43 INS43 MOV31 INS43 INS43 INS31 INS43 INS43 MOV31 INS42 INS42 INS42 INS43 INS43 INS31 MOV43 MOV43 INS39 INS39 INS43 INS43 MOV31 INS42 INS42 INS42 INS83 INS43 INS42 INS44 INS43 MOV8 INS42 INS42 INS83 INS43 INS42 INS44 MOV43 MOV8 INS42 INS42 INS83 MOV43 INS42 INS44 MOV43 MOV8 INS42 INS42 UPD42 INS42 INS42 UPD42 INS42 INS42 INS43 INS42 INS42 INS42 INS83 INS43 INS42 INS44 INS43 MOV8 INS42 INS42 INS43 INS42 INS42 INS42 INS83 INS43 INS42 INS44 INS43 MOV8 INS42 INS42 UPD42 INS42 INS43 INS42 INS42 MOV41 INS42 INS43 INS42 INS41 INS43 INS42 MOV41 UPD43 UPD42 UPD43 UPD42 INS42 INS42 INS43 UPD42 INS41 INS42 INS43 INS42 INS42 INS41 UPD42 MOV42 UPD43 UPD42 INS41 INS42 INS43 INS42 INS42 INS41 UPD43 UPD42 INS42 MOV43 INS42 MOV32 INS42 MOV43 UPD42 UPD42 UPD42 MOV42 INS52 INS42 MOV43 INS52 UPD42 INS52 INS42 MOV43 INS52 UPD42 MOV43 UPD43 UPD43 INS53 UPD42 UPD42 UPD42 INS14 MOV43 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS53 INS42 INS42 INS42 MOV43 INS27 INS42 INS42 INS42 INS14 UPD45 MOV45 UPD45 MOV45 UPD45 MOV45 MOV42 UPD42 MOV43 INS45 UPD42 INS42 INS42 DEL42 DEL40 DEL40 DEL40 DEL40 DEL40 DEL21 DEL40 DEL40 DEL40 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL14 DEL53 DEL65 DEL65 DEL29 DEL40 DEL40 DEL40 DEL39 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL14 DEL53 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL40
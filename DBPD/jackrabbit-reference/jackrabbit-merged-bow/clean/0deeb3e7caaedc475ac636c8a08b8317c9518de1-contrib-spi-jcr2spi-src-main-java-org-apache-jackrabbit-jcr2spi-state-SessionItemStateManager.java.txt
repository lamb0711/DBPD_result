- Remove AtticItemStateManager (not needed anymore)
- Remove dispose methods from TransientItemStateManager. TransientItemStateManager is a listener on all modified ItemStates and maintains its ChangeLog according to the callbacks.
- Move method SessionItemStateManager.checkIsSelfContained() to ChangeLog.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@433610 13f79535-47bb-0310-9956-ffa450edef68

-        // dispose the transient states marked 'new' or 'modified'
-        Iterator it = new IteratorChain(changeLog.addedStates(), changeLog.modifiedStates());
-        while (it.hasNext()) {
-            ItemState transientState = (ItemState) it.next();
-            // dispose the transient state, it is no longer used
-            transientStateMgr.disposeItemState(transientState);
-        }
-
-        // dispose the transient states marked 'removed'.
-        // item states in attic are removed after store, because
-        // the observation mechanism needs to build paths of removed
-        // items in update().
-        it = changeLog.deletedStates();
-        while (it.hasNext()) {
-            ItemState transientState = (ItemState) it.next();
-            // dispose the transient state, it is no longer used
-            transientStateMgr.disposeItemStateInAttic(transientState);
-        }
-
-        // TODO: check if self contained
+        // check if self contained
+        ChangeLog changeLog = new ChangeLog();
+        collectTransientStates(itemState, changeLog, false);
+        changeLog.checkIsSelfContained();
+        // now do it for real
-        ChangeLog changeLog = new ChangeLog();
-        collectTransientStates(itemState, changeLog);
+        collectTransientStates(itemState, changeLog, true);
-         * build set of item id's which are within the scope of
+         * build set of item states which are within the scope of
-        checkIsSelfContained(affectedStates, changeLog);
+        changeLog.checkIsSelfContained();
-    private void collectTransientStates(ItemState state, ChangeLog changeLog)
+    private void collectTransientStates(ItemState state, ChangeLog changeLog, boolean throwOnStale)
-                case ItemState.STATUS_STALE_MODIFIED:
-                    {
-                        String msg = LogUtil.safeGetJCRPath(state, nsResolver, hierMgr) + ": the item cannot be saved because it has been modified externally.";
-                        log.debug(msg);
-                        throw new StaleItemStateException(msg);
-                    }
-                case ItemState.STATUS_STALE_DESTROYED:
-                    {
-                        String msg = LogUtil.safeGetJCRPath(state, nsResolver, hierMgr) + ": the item cannot be saved because it has been deleted externally.";
-                        log.debug(msg);
-                        throw new StaleItemStateException(msg);
-                    }
-                case ItemState.STATUS_UNDEFINED:
-                    {
-                        String msg = LogUtil.safeGetJCRPath(state, nsResolver, hierMgr) + ": the item cannot be saved; it seems to have been removed externally.";
-                        log.debug(msg);
-                        throw new StaleItemStateException(msg);
-                    }
+            }
+            if (throwOnStale) {
+                switch (state.getStatus()) {
+                    case ItemState.STATUS_STALE_MODIFIED:
+                        {
+                            String msg = LogUtil.safeGetJCRPath(state, nsResolver, hierMgr) + ": the item cannot be saved because it has been modified externally.";
+                            log.debug(msg);
+                            throw new StaleItemStateException(msg);
+                        }
+                    case ItemState.STATUS_STALE_DESTROYED:
+                        {
+                            String msg = LogUtil.safeGetJCRPath(state, nsResolver, hierMgr) + ": the item cannot be saved because it has been deleted externally.";
+                            log.debug(msg);
+                            throw new StaleItemStateException(msg);
+                        }
+                    case ItemState.STATUS_UNDEFINED:
+                        {
+                            String msg = LogUtil.safeGetJCRPath(state, nsResolver, hierMgr) + ": the item cannot be saved; it seems to have been removed externally.";
+                            log.debug(msg);
+                            throw new StaleItemStateException(msg);
+                        }
+                }
-                    {
+                    if (throwOnStale) {
+                    } else {
+                        changeLog.modified(transientState);
-                    {
+                    if (throwOnStale) {
-                    {
+                    if (throwOnStale) {
-    /**
-     * Make sure that this save operation is totally 'self-contained'
-     * and independant; items within the scope of this update operation
-     * must not have 'external' dependencies;
-     * (e.g. moving a node requires that the target node including both
-     * old and new parents are saved)
-     *
-     * @param affectedStates
-     * @param changeLog
-     */
-    private void checkIsSelfContained(Set affectedStates, ChangeLog changeLog) throws ItemStateException {
-        Iterator it = new IteratorChain(changeLog.modifiedStates(), changeLog.deletedStates());
-        while (it.hasNext()) {
-            ItemState transientState = (ItemState) it.next();
-            if (transientState.isNode()) {
-                NodeState nodeState = (NodeState) transientState;
-                Set dependentStates = new HashSet();
-                if (nodeState.hasOverlayedState()) {
-                    NodeState oldParentState = nodeState.getOverlayedState().getParent();
-                    NodeState newParentState = nodeState.getParent();
-                    if (oldParentState != null) {
-                        if (newParentState == null) {
-                            // node has been removed, add old parent
-                            // to dependencies
-                            dependentStates.add(oldParentState);
-                        } else {
-                            if (!oldParentState.equals(newParentState)) {
-                                // node has been moved, add old and new parent
-                                // to dependencies
-                                dependentStates.add(oldParentState);
-                                dependentStates.add(newParentState);
-                            }
-                        }
-                    }
-                }
-                // removed child node entries
-                Iterator cneIt = nodeState.getRemovedChildNodeEntries().iterator();
-                while (cneIt.hasNext()) {
-                    ChildNodeEntry cne = (ChildNodeEntry) cneIt.next();
-                    dependentStates.add(cne.getNodeState());
-                }
-                // added child node entries
-                cneIt = nodeState.getAddedChildNodeEntries().iterator();
-                while (cneIt.hasNext()) {
-                    ChildNodeEntry cne = (ChildNodeEntry) cneIt.next();
-                    dependentStates.add(cne.getNodeState());
-                }
-
-                // now walk through dependencies and check whether they
-                // are within the scope of this save operation
-                Iterator depIt = dependentStates.iterator();
-                while (depIt.hasNext()) {
-                    NodeState dependantState = (NodeState) depIt.next();
-                    if (!affectedStates.contains(dependantState)) {
-                        // need to save the parent as well
-                        String msg = LogUtil.safeGetJCRPath(dependantState, nsResolver, hierMgr) + " needs to be saved as well.";
-                        log.debug(msg);
-                        throw new ItemStateException(msg);
-                    }
-                }
-            }
-        }
-    }
-
+

MOV60 INS44 INS21 INS21 INS39 INS42 INS32 INS32 INS42 INS42 INS42 INS9 INS42 INS42 INS9 UPD42 UPD42 INS50 INS25 INS32 MOV49 MOV8 INS42 INS8 INS25 INS25 INS25 INS42 INS42 MOV50 INS42 MOV8 INS8 INS42 MOV8 INS42 MOV8 INS21 INS32 INS42 INS42 INS42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL61 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL61 DEL42 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL65 DEL42 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL61 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL61 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL38 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL8 DEL61 DEL8 DEL25 DEL8 DEL61 DEL8 DEL31
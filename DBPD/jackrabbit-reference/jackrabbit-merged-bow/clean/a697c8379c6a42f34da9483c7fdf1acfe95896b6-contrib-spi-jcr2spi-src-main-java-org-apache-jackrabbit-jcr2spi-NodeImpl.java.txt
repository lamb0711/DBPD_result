work in progress

- version always protected
- versionHistory always protected
- fix Node.getReferences && reference properties
- mixinTypes are 'active' upon save only (and not before). therefore
  cleanup after removeMixin is done only after save.
  adding new states defined by a new mixin are only added after the
  node has been saved.
- nodestates identified by a uuid only were created a second time upon
  ChildNodeEntry.resolve => fix needs to be improved
- Events/ChangeLog are processed by the save-target state
- ChangeLog.persisted not used any more

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@467956 13f79535-47bb-0310-9956-ffa450edef68

-        return setProperty(name, v);
+        return setProperty(name, v, type);
-        return setProperty(name, v);
+        return setProperty(name, v, PropertyType.BINARY);
-        return setProperty(name, session.getValueFactory().createValue(value));
+        return setProperty(name, session.getValueFactory().createValue(value), PropertyType.BOOLEAN);
-        return setProperty(name, session.getValueFactory().createValue(value));
+        return setProperty(name, session.getValueFactory().createValue(value), PropertyType.DOUBLE);
-        return setProperty(name, session.getValueFactory().createValue(value));
+        return setProperty(name, session.getValueFactory().createValue(value), PropertyType.LONG);
-        return setProperty(name, v);
+        return setProperty(name, v, PropertyType.DATE);
-        // validation performed in subsequent method
-        Value v = (value == null ? null : session.getValueFactory().createValue(value));
-        return setProperty(name, v);
+        // duplicate check to make sure, writability is asserted before value
+        // validation below.
+        checkIsWritable();
+        Value v;
+        if (value == null) {
+            v = null;
+        } else {
+            PropertyImpl.checkValidReference(value, PropertyType.REFERENCE, this);
+            v = session.getValueFactory().createValue(value);
+        }
+        return setProperty(name, v, PropertyType.REFERENCE);
-        if (!isNodeType(QName.MIX_REFERENCEABLE)) {
+        String uuid = getNodeState().getUUID();
+        if (!isNodeType(QName.MIX_REFERENCEABLE) && uuid != null) {
-        return getNodeId().getUUID();
+        return uuid;
-            if (itemStateMgr.hasReferingStates(getNodeState())) {
-                Collection refStates = itemStateMgr.getReferingStates(getNodeState());
-                return new LazyItemIterator(itemMgr, refStates);
-            } else {
+            Collection refStates = itemStateMgr.getReferingStates(getNodeState());
+            if (refStates.isEmpty()) {
+            } else {
+                return new LazyItemIterator(itemMgr, refStates);
+        } catch (ConstraintViolationException e) {
+            log.debug("Cannot add mixin '" + mixinName + "': " + e.getMessage());
+            return false;
-        restore(v, removeExisting);
+        restore(this, null, v, removeExisting);
-        targetNode.checkIsWritable();
-        targetNode.checkIsLocked();
-
-
+            targetNode.checkIsWritable();
+            targetNode.checkIsLocked();
+            targetNode.checkIsLocked();
-            throw new UnsupportedRepositoryOperationException(msg);
+            throw new LockException(msg);

MOV8 INS21 INS60 INS25 INS60 INS41 MOV21 INS54 INS32 MOV43 INS59 INS27 INS8 INS8 INS43 INS59 INS27 INS42 MOV8 MOV12 INS12 INS42 INS40 INS40 INS40 INS40 INS40 INS42 MOV42 MOV42 MOV33 INS21 INS21 INS21 INS40 INS42 INS42 INS32 MOV38 INS27 MOV60 INS25 INS44 INS8 INS52 INS33 MOV21 MOV21 INS21 INS7 INS32 INS7 MOV32 MOV42 INS42 INS33 INS32 MOV8 INS8 INS43 INS42 INS21 INS41 INS32 INS42 INS33 INS42 INS42 INS42 INS40 INS52 INS42 INS32 UPD42 MOV42 INS42 INS42 MOV41 INS42 INS32 INS9 INS42 INS42 UPD43 MOV32 MOV42 MOV42 INS42 INS42 INS27 UPD42 INS45 INS42 INS45 INS32 INS42 INS42 DEL27 DEL33 DEL32 DEL16 DEL36 DEL59 DEL60 DEL32 DEL41 DEL42 DEL42 DEL32 DEL25 DEL54 DEL8
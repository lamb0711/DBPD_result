work in progress

- version always protected
- versionHistory always protected
- fix Node.getReferences && reference properties
- mixinTypes are 'active' upon save only (and not before). therefore
  cleanup after removeMixin is done only after save.
  adding new states defined by a new mixin are only added after the
  node has been saved.
- nodestates identified by a uuid only were created a second time upon
  ChildNodeEntry.resolve => fix needs to be improved
- Events/ChangeLog are processed by the save-target state
- ChangeLog.persisted not used any more

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@467956 13f79535-47bb-0310-9956-ffa450edef68

+    private ItemStateCache cache;
+
-            return createNodeState(info, parent);
+            if (parent != null) {
+                return parent.getChildNodeEntry(info.getQName(), info.getIndex()).getNodeState();
+            } else {
+                return createNodeState(info, parent);
+            }
-                childNodeEntries.add(new CNE(childInfo.getQName(), childUUID));
+                childNodeEntries.add(new CNE(childInfo.getQName(), childInfo.getIndex(), childUUID));
-            // If the uuid is not null, the state could include mix:referenceable.
-            // Therefore build a NodeReference instance and add it to the state.
-            NodeReferences nodeRefs = null;
-            if (uuid != null) {
-                PropertyId[] references = info.getReferences();
-                nodeRefs = new NodeReferencesImpl(info.getId(), references);
-            }
+            // Build node-references object even if the state is not refereceable yet.
+            PropertyId[] references = info.getReferences();
+            NodeReferences nodeRefs = new NodeReferencesImpl(state, references);
-            // copied from local-state-mgr TODO... check
-            // register as listener
-            // TODO check if needed
-            //state.addListener(this);
+            state.addListener(cache);
+            cache.created(state);
+
-            String msg = "internal error: failed to retrieve node definition.";
+            String msg = "Internal error: failed to retrieve node definition.";
-            String msg = "internal error: failed to retrieve node definition.";
+            String msg = "Internal error: failed to retrieve node definition.";
-    private PropertyState createPropertyState(PropertyInfo info,
-                                              NodeState parent)
-            throws ItemStateException {
+    private PropertyState createPropertyState(PropertyInfo info, NodeState parent)
+        throws ItemStateException {
-                def, Status.EXISTING, service.getIdFactory(), true);
+                def, Status.EXISTING, this, service.getIdFactory(), true);
+            state.addListener(cache);
+            cache.created(state);
-            // register as listener
-            // TODO check if needed
-            // state.addListener(this);
-            String msg = "internal error: failed to retrieve property definition.";
+            String msg = "internal error: failed to build property state.";
-        } catch (ConstraintViolationException e) {
-            String msg = "internal error: failed to retrieve property definition.";
-            log.debug(msg);
-            throw new ItemStateException(msg, e);
-        } catch (NoSuchNodeTypeException e) {
-            String msg = "internal error: failed to retrieve property definition.";
+        } catch (RepositoryException e) {
+            String msg = "internal error: failed to build property state.";
+    /**
+     *
+     * @param cache
+     * @see ItemStateFactory#setCache(ItemStateCache)
+     */
+    public void setCache(ItemStateCache cache) {
+        this.cache = cache;
+    }
+        private final int index;
-        private CNE(QName name, String uuid) {
+        private CNE(QName name, int index, String uuid) {
+            this.index = index;
-            throw new UnsupportedOperationException();
+            return index;
-        /**
-         * Identifier of this <code>NodeReferences</code> instance. Since the
-         * id of target state consists of a UUID and contains not relative
-         * path, the id will be stable and can be stored.
-         */
-        private NodeId nodeId;
+        private NodeState nodeState;
-         * @param nodeId
+         * @param nodeState
-        private NodeReferencesImpl(NodeId nodeId, PropertyId[] referenceIds) {
-            this.nodeId = nodeId;
+        private NodeReferencesImpl(NodeState nodeState, PropertyId[] referenceIds) {
+            this.nodeState = nodeState;
+            // shortcut
+            if (nodeState.getUUID() == null) {
+                return true;
+            }
+            // nodestate has a uuid and is potentially mix:referenceable
+            // => try to retrieve references
-                NodeInfo info = service.getNodeInfo(sessionInfo, nodeId);
+                NodeInfo info = service.getNodeInfo(sessionInfo, nodeState.getNodeId());
+            // shortcut
+            if (nodeState.getUUID() == null) {
+                return Collections.EMPTY_SET.iterator();
+            }
+            // nodestate has a uuid and is potentially mix:referenceable
+            // => try to retrieve references
-                NodeInfo info = service.getNodeInfo(sessionInfo, nodeId);
+                NodeInfo info = service.getNodeInfo(sessionInfo, nodeState.getNodeId());
-                log.error("Internal error.",e);
+                log.error("Internal error.", e);

INS23 INS31 INS83 INS43 INS59 INS29 INS83 INS39 INS42 INS44 INS8 INS23 INS42 INS42 MOV12 MOV12 INS65 INS65 INS43 INS42 INS21 INS83 INS83 INS39 INS59 INS44 UPD43 INS42 INS68 INS42 INS7 INS42 INS39 INS42 INS21 INS41 UPD42 UPD42 UPD43 UPD42 INS25 INS25 INS25 MOV60 INS21 INS21 MOV44 MOV44 INS21 INS21 MOV44 INS42 INS42 INS69 INS22 INS42 INS7 INS42 UPD42 UPD42 INS27 INS8 INS27 INS8 INS27 INS8 INS8 INS32 INS32 INS32 INS32 UPD43 INS43 INS52 INS42 INS22 INS42 UPD42 INS32 INS33 INS41 INS32 INS33 INS41 INS42 INS33 INS41 MOV41 INS14 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS52 INS42 UPD42 INS42 INS42 INS9 INS42 INS42 INS32 INS32 MOV43 INS42 INS42 UPD45 UPD45 INS52 UPD45 UPD45 INS40 INS42 INS32 INS42 INS32 INS32 INS42 INS42 INS32 INS32 INS32 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 DEL33 DEL42 DEL33 DEL27 DEL42 DEL32 DEL42 DEL14 DEL7 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL14 DEL53 DEL66 DEL66 DEL66 DEL65 DEL29
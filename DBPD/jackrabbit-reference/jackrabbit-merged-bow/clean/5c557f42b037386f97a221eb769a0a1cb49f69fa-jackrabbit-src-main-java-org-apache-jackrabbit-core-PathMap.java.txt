#JCR-284 Locking two same-name siblings and unlocking first apparently unlocks second instead.

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@349986 13f79535-47bb-0310-9956-ffa450edef68

-         * this child and no object is associated with this child, the child
-         * itself gets removed.
+         * this element and no object is associated with this element, the
+         * element itself gets removed.
+            return remove(nameIndex, true);
+        }
+
+        /**
+         * Remove a child. If <code>shift</code> is set to <code>true</code>,
+         * will shift all children having an index greater than the child
+         * removed to the left. If there are no more children left in
+         * this element and no object is associated with this element, the
+         * element itself gets removed.
+         *
+         * @param nameIndex child's path element
+         * @param shift whether to shift same name siblings having a greater
+         *              index to the left
+         * @return removed child, may be <code>null</code>
+         */
+        private Element remove(Path.PathElement nameIndex, boolean shift) {
-            if (children != null) {
-                ArrayList list = (ArrayList) children.get(nameIndex.getName());
-                if (list != null && list.size() > index) {
-                    for (int i = index + 1; i < list.size(); i++) {
-                        Element element = (Element) list.get(i);
-                        if (element != null) {
-                            element.index--;
-                        }
-                    }
-                    Element element = (Element) list.remove(index);
-                    if (element != null) {
-                        element.parent = null;
-                        childrenCount--;
-                    }
-                    if (childrenCount == 0 && obj == null) {
-                        remove();
-                    }
-                    return element;
-                }
+            if (children == null) {
+                return null;
-            return null;
+            ArrayList list = (ArrayList) children.get(nameIndex.getName());
+            if (list == null || list.size() <= index) {
+                return null;
+            }
+            Element element = (Element) list.set(index, null);
+            if (shift) {
+                for (int i = index + 1; i < list.size(); i++) {
+                    Element sibling = (Element) list.get(i);
+                    if (sibling != null) {
+                        sibling.index--;
+                    }
+                }
+                list.remove(index);
+            }
+            if (element != null) {
+                element.parent = null;
+                childrenCount--;
+            }
+            if (childrenCount == 0 && obj == null && parent != null) {
+                parent.remove(getPathElement(), shift);
+            }
+            return element;
-            if (obj == null && childrenCount == 0) {
-                remove();
+            if (obj == null && childrenCount == 0 && parent != null) {
+                parent.remove(getPathElement(), false);

INS31 MOV29 INS83 INS43 INS42 INS44 INS8 INS29 UPD83 INS44 MOV8 INS42 INS43 INS42 INS41 INS65 INS65 INS65 INS65 INS39 INS42 MOV60 INS25 INS25 INS60 MOV25 MOV25 MOV41 UPD66 UPD66 INS40 INS32 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS27 INS8 UPD27 MOV27 INS8 MOV43 INS59 INS42 INS27 INS27 INS42 INS42 INS9 INS42 INS33 INS41 UPD27 UPD27 MOV41 INS42 INS11 INS21 MOV27 INS27 MOV27 INS27 INS33 MOV43 INS32 MOV32 INS42 INS33 INS42 INS33 INS42 INS42 INS42 INS33 INS42 INS32 INS42 INS42 INS32 INS9 INS42 INS42 UPD42 UPD42 UPD40 DEL42 DEL11 DEL59 DEL60 DEL42 DEL33 DEL27 DEL25 DEL8
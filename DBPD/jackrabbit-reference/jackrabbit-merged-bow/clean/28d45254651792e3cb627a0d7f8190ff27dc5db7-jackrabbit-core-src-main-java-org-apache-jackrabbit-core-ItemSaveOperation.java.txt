JCR-890: concurrent read-only access to a session

Handle Session.logout() in a way that prevents concurrent session access.

Also move the SessionContext argument from perform() to a member variable of SessionOperation.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@957626 13f79535-47bb-0310-9956-ffa450edef68

-    public ItemSaveOperation(ItemState state) {
-        super("item save");
+    public ItemSaveOperation(SessionContext context, ItemState state) {
+        super("item save", context);
-    public void perform(SessionContext context) throws RepositoryException {
+    public void perform() throws RepositoryException {
-            dirty = getTransientStates(stateMgr);
+            dirty = getTransientStates();
-        Collection<ItemState> removed = getRemovedStates(stateMgr);
+        Collection<ItemState> removed = getRemovedStates();
-        validateTransientItems(context, dirty, removed);
+        validateTransientItems(dirty, removed);
-            removeTransientItems(stateMgr, removed);
+            removeTransientItems(removed);
-            processShareableNodes(context, dirty);
+            processShareableNodes(dirty);
-            if (initVersionHistories(context, dirty)) {
+            if (initVersionHistories(dirty)) {
-                dirty = getTransientStates(stateMgr);
+                dirty = getTransientStates();
-            persistTransientItems(context.getItemManager(), dirty);
+            persistTransientItems(dirty);
-                restoreTransientItems(context, dirty);
+                restoreTransientItems(dirty);
-    private Collection<ItemState> getTransientStates(
-            SessionItemStateManager stateMgr)
+    private Collection<ItemState> getTransientStates()
-                    : stateMgr.getDescendantTransientItemStates(state.getId())) {
+                    : context.getItemStateManager().getDescendantTransientItemStates(state.getId())) {
-    private Collection<ItemState> getRemovedStates(
-            SessionItemStateManager stateMgr)
+    private Collection<ItemState> getRemovedStates()
-                    : stateMgr.getDescendantTransientItemStatesInAttic(state.getId())) {
+                    : context.getItemStateManager().getDescendantTransientItemStatesInAttic(state.getId())) {
-            SessionContext context,
-                EffectiveNodeType ent = getEffectiveNodeType(context, nodeState);
+                EffectiveNodeType ent = getEffectiveNodeType(nodeState);
-    private void removeTransientItems(
-            SessionItemStateManager stateMgr, Iterable<ItemState> states) {
+    private void removeTransientItems(Iterable<ItemState> states) {
-            /**
-             * remove persistent state
-             *
-             * this will indirectly (through stateDestroyed listener method)
-             * permanently invalidate all Item instances wrapping it
-             */
-            stateMgr.destroy(persistentState);
+            // remove persistent state
+            // this will indirectly (through stateDestroyed listener method)
+            // permanently invalidate all Item instances wrapping it
+            context.getItemStateManager().destroy(persistentState);
-    private void processShareableNodes(
-            SessionContext context, Iterable<ItemState> states)
+    private void processShareableNodes(Iterable<ItemState> states)
-                    EffectiveNodeType ntOld = getEffectiveNodeType(context, old);
+                    EffectiveNodeType ntOld = getEffectiveNodeType(old);
-                EffectiveNodeType ntNew = getEffectiveNodeType(context, ns);
+                EffectiveNodeType ntNew = getEffectiveNodeType(ns);
-    private boolean initVersionHistories(
-            SessionContext context, Iterable<ItemState> states)
+    private boolean initVersionHistories(Iterable<ItemState> states)
-                EffectiveNodeType nt = getEffectiveNodeType(context, nodeState);
+                EffectiveNodeType nt = getEffectiveNodeType(nodeState);
-    private void persistTransientItems(
-            ItemManager itemMgr, Iterable<ItemState> states)
+    private void persistTransientItems(Iterable<ItemState> states)
+        ItemManager itemMgr = context.getItemManager();
-    private void restoreTransientItems(
-            SessionContext context, Iterable<ItemState> items) {
+    private void restoreTransientItems(Iterable<ItemState> items) {
-    private EffectiveNodeType getEffectiveNodeType(
-            SessionContext context, NodeState state)
+    private EffectiveNodeType getEffectiveNodeType(NodeState state)

MOV44 INS60 INS42 INS43 INS59 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS32 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 MOV43 MOV43 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44
JCR-651: Improve performance for queries with large result sets

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@480138 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.NodeImpl;
+import org.apache.jackrabbit.core.security.AccessManager;
+import org.apache.lucene.search.Query;
+import javax.jcr.ItemNotFoundException;
+import javax.jcr.Node;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.NoSuchElementException;
+     * The search index to execute the query.
+     */
+    private final SearchIndex index;
+
+    /**
-     * The UUIDs of the result nodes
+     * The namespace resolver of the session executing the query
-    private final NodeId[] ids;
+    protected final NamespaceResolver resolver;
-     * The scores of the result nodes
+     * The access manager of the session that executes the query.
-    private final Float[] scores;
+    private final AccessManager accessMgr;
+
+    /**
+     * The query instance which created this query result.
+     */
+    protected final QueryImpl queryImpl;
+
+    /**
+     * The lucene query to execute.
+     */
+    protected final Query query;
-    private final QName[] selectProps;
+    protected final QName[] selectProps;
-     * The namespace resolver of the session executing the query
+     * The names of properties to use for ordering the result set.
-    private final NamespaceResolver resolver;
+    protected final QName[] orderProps;
+
+    /**
+     * The order specifier for each of the order properties.
+     */
+    protected final boolean[] orderSpecs;
+
+    /**
+     * The result nodes including their score. This list is populated on a lazy
+     * basis while a client iterates through the results.
+     */
+    private final List resultNodes = new ArrayList();
+
+    /**
+     * This is the raw number of results that matched the query. This number
+     * also includes matches which will not be returned due to access
+     * restrictions. This value is set when the query is executed the first
+     * time.
+     */
+    private int numResults = -1;
+
+    /**
+     * The number of results that are invalid, either because a node does not
+     * exist anymore or because the session does not have access to the node.
+     */
+    private int invalid = 0;
-     * @param itemMgr     the item manager of the session executing the query.
-     * @param ids         the Ids of the result nodes.
-     * @param scores      the score values of the result nodes.
-     * @param selectProps the select properties of the query.
-     * @param resolver    the namespace resolver of the session executing the query.
-     * @param docOrder    if <code>true</code> the result is returned in document
-     *  order.
+     * @param index         the search index where the query is executed.
+     * @param itemMgr       the item manager of the session executing the
+     *                      query.
+     * @param resolver      the namespace resolver of the session executing the
+     *                      query.
+     * @param accessMgr     the access manager of the session executiong the
+     *                      query.
+     * @param queryImpl     the query instance which created this query result.
+     * @param query         the lucene query to execute on the index.
+     * @param selectProps   the select properties of the query.
+     * @param orderProps    the names of the order properties.
+     * @param orderSpecs    the order specs, one for each order property name.
+     * @param documentOrder if <code>true</code> the result is returned in
+     *                      document order.
-    public QueryResultImpl(ItemManager itemMgr,
-                           NodeId[] ids,
-                           Float[] scores,
-                           QName[] selectProps,
+    public QueryResultImpl(SearchIndex index,
+                           ItemManager itemMgr,
-                           boolean docOrder) {
-        this.ids = ids;
-        this.scores = scores;
+                           AccessManager accessMgr,
+                           QueryImpl queryImpl,
+                           Query query,
+                           QName[] selectProps,
+                           QName[] orderProps,
+                           boolean[] orderSpecs,
+                           boolean documentOrder) throws RepositoryException {
+        this.index = index;
-        this.selectProps = selectProps;
-        this.docOrder = docOrder;
+        this.accessMgr = accessMgr;
+        this.queryImpl = queryImpl;
+        this.query = query;
+        this.selectProps = selectProps;
+        this.orderProps = orderProps;
+        this.orderSpecs = orderSpecs;
+        this.docOrder = orderProps.length == 0 && documentOrder;
+        // if document order is requested get all results right away
+        getResults(docOrder ? Integer.MAX_VALUE : index.getResultFetchSize());
+     * Executes the query for this result and returns hits. The caller must
+     * close the query hits when he is done using it.
+     *
+     * @return hits for this query result.
+     * @throws IOException if an error occurs while executing the query.
+     */
+    protected QueryHits executeQuery() throws IOException {
+        return index.executeQuery(queryImpl, query, orderProps, orderSpecs);
+    }
+
+    //--------------------------------< internal >------------------------------
+
+    /**
+     *
-            return new DocOrderNodeIteratorImpl(itemMgr, ids, scores);
+            return new DocOrderNodeIteratorImpl(itemMgr, resultNodes);
-            return new NodeIteratorImpl(itemMgr, ids, scores);
+            return new LazyScoreNodeIterator();
+        }
+    }
+
+    /**
+     * Attempts to get <code>size</code> results and puts them into {@link
+     * #resultNodes}. If the size of {@link #resultNodes} is less than
+     * <code>size</code> then there are no more than <code>resultNodes.size()</code>
+     * results for this query.
+     *
+     * @param size the number of results to fetch for the query.
+     * @throws RepositoryException if an error occurs while executing the
+     *                             query.
+     */
+    private void getResults(int size) throws RepositoryException {
+        if (log.isDebugEnabled()) {
+            log.debug("getResults(" + size + ")");
+        }
+        if (resultNodes.size() >= size) {
+            // we already have them all
+            return;
+        }
+
+        // execute it
+        QueryHits result = null;
+        try {
+            result = executeQuery();
+
+            // set num results with the first query execution
+            if (numResults == -1) {
+                numResults = result.length();
+            }
+
+            int start = resultNodes.size() + invalid;
+            int max = Math.min(result.length(), numResults);
+            for (int i = start; i < max && resultNodes.size() < size; i++) {
+                NodeId id = NodeId.valueOf(result.doc(i).get(FieldNames.UUID));
+                // check access
+                try {
+                    if (accessMgr.isGranted(id, AccessManager.READ)) {
+                        resultNodes.add(new ScoreNode(id, result.score(i)));
+                    }
+                } catch (ItemNotFoundException e) {
+                    // has been deleted meanwhile
+                    invalid++;
+                }
+            }
+        } catch (IOException e) {
+            log.error("Exception while executing query: ", e);
+            // todo throw?
+        } finally {
+            if (result != null) {
+                try {
+                    result.close();
+                } catch (IOException e) {
+                    log.warn("Unable to close query result: " + e);
+                }
+            }
+        }
+    }
+
+    private final class LazyScoreNodeIterator implements ScoreNodeIterator {
+
+        private int position = -1;
+
+        private boolean initialized = false;
+
+        private NodeImpl next;
+
+        /**
+         * {@inheritDoc}
+         */
+        public float getScore() {
+            initialize();
+            if (!hasNext()) {
+                throw new NoSuchElementException();
+            }
+            return ((ScoreNode) resultNodes.get(position)).getScore();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public NodeImpl nextNodeImpl() {
+            initialize();
+            if (next == null) {
+                throw new NoSuchElementException();
+            }
+            NodeImpl n = next;
+            fetchNext();
+            return n;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public Node nextNode() {
+            return nextNodeImpl();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public void skip(long skipNum) {
+            initialize();
+            if (skipNum < 0) {
+                throw new IllegalArgumentException("skipNum must not be negative");
+            }
+            if ((position + invalid + skipNum) > numResults) {
+                throw new NoSuchElementException();
+            }
+            if (skipNum == 0) {
+                // do nothing
+            } else {
+                // attempt to get enough results
+                try {
+                    getResults(position + invalid + (int) skipNum);
+                    if (resultNodes.size() >= position + skipNum) {
+                        // skip within already fetched results
+                        position += skipNum - 1;
+                        fetchNext();
+                    } else {
+                        // not enough results after getResults()
+                        throw new NoSuchElementException();
+                    }
+                } catch (RepositoryException e) {
+                    throw new NoSuchElementException(e.getMessage());
+                }
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         * <p/>
+         * This value may shrink when the query result encounters non-existing
+         * nodes or the session does not have access to a node.
+         */
+        public long getSize() {
+            return numResults - invalid;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public long getPosition() {
+            initialize();
+            return position;
+        }
+
+        /**
+         * @throws UnsupportedOperationException always.
+         */
+        public void remove() {
+            throw new UnsupportedOperationException("remove");
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public boolean hasNext() {
+            initialize();
+            return next != null;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public Object next() {
+            return nextNodeImpl();
+        }
+
+        /**
+         * Initializes this iterator but only if it is not yet initialized.
+         */
+        private void initialize() {
+            if (!initialized) {
+                fetchNext();
+                initialized = true;
+            }
+        }
+
+        /**
+         * Fetches the next node to return by this iterator. If this method
+         * returns and {@link #next} is <code>null</code> then there is no next
+         * node.
+         */
+        private void fetchNext() {
+            next = null;
+            int nextPos = position + 1;
+            while (next == null && (nextPos + invalid) < numResults) {
+                if (nextPos >= resultNodes.size()) {
+                    // fetch more results
+                    try {
+                        int num;
+                        if (resultNodes.size() == 0) {
+                            num = index.getResultFetchSize();
+                        } else {
+                            num = resultNodes.size() * 2;
+                        }
+                        getResults(num);
+                    } catch (RepositoryException e) {
+                        log.warn("Exception getting more results: " + e);
+                    }
+                    // check again
+                    if (nextPos >= resultNodes.size()) {
+                        // no more valid results
+                        return;
+                    }
+                }
+                ScoreNode sn = (ScoreNode) resultNodes.get(nextPos);
+                try {
+                    next = (NodeImpl) itemMgr.getItem(sn.getNodeId());
+                } catch (RepositoryException e) {
+                    log.warn("Exception retrieving Node with UUID: "
+                            + sn.getNodeId() + ": " + e.toString());
+                    // remove score node and try next
+                    resultNodes.remove(nextPos);
+                    invalid++;
+                }
+            }
+            position++;

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV23 MOV23 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS23 INS23 INS23 INS23 INS23 MOV44 MOV44 INS31 INS31 INS55 INS29 INS83 INS83 INS43 INS59 UPD83 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS43 INS59 UPD83 UPD83 UPD5 INS29 INS83 INS83 INS5 INS59 INS43 INS29 INS83 INS39 INS59 INS29 INS83 INS39 INS59 INS44 INS44 INS44 INS44 INS43 MOV21 MOV21 INS29 INS83 INS43 INS42 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS83 INS83 INS42 INS43 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS65 INS42 INS42 INS65 INS42 INS42 INS65 INS42 INS42 INS65 INS42 INS42 UPD43 UPD42 INS65 INS39 INS85 INS42 UPD42 MOV42 UPD42 INS14 INS65 INS42 INS38 INS65 INS42 INS34 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 UPD5 UPD42 UPD5 UPD42 UPD42 INS42 INS21 INS21 INS21 INS21 INS21 INS65 INS65 INS65 INS42 INS42 INS41 INS65 INS65 INS65 INS39 INS42 INS42 INS25 INS25 INS60 INS54 INS42 INS83 INS39 INS59 INS83 INS39 INS59 INS83 INS43 INS59 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS43 INS42 INS8 INS29 INS83 INS43 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS43 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS66 INS66 INS66 INS66 UPD66 UPD42 INS66 UPD66 INS66 INS43 INS66 INS66 INS66 INS66 INS34 INS66 INS66 INS42 INS66 UPD66 INS66 UPD42 UPD66 INS66 UPD42 UPD66 INS66 INS42 INS66 INS42 INS66 UPD66 UPD42 UPD66 INS42 INS66 UPD42 UPD66 UPD66 INS42 INS42 INS42 INS42 INS43 INS39 INS7 INS7 INS7 INS7 INS32 INS66 INS66 INS66 INS42 INS66 INS32 INS66 INS65 INS66 INS65 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS32 INS8 INS27 INS8 INS43 INS59 INS8 INS12 INS8 INS42 INS38 INS42 INS9 INS42 INS42 INS65 INS21 INS25 INS41 INS65 INS42 INS21 INS25 INS60 INS21 INS41 INS65 INS42 INS41 INS65 INS39 INS42 INS21 INS25 INS25 INS25 INS65 INS41 INS65 INS21 INS41 INS65 INS53 INS65 INS21 INS41 INS65 INS42 INS41 INS65 INS25 INS65 INS21 INS60 INS61 INS21 INS42 INS42 UPD42 INS22 INS42 INS22 INS42 INS22 INS42 UPD42 INS22 INS42 INS27 INS42 INS16 INS42 INS42 INS42 INS42 INS42 INS42 INS67 INS67 INS42 INS42 INS21 INS32 INS42 INS41 INS42 INS42 INS33 INS21 INS25 INS60 INS60 INS24 INS44 INS8 INS25 INS34 INS65 INS32 INS38 INS8 INS32 INS65 INS32 INS27 INS8 INS43 INS59 INS32 INS42 INS65 INS32 INS65 INS32 INS27 INS8 INS27 INS8 INS27 INS8 INS8 INS65 INS66 INS66 INS66 INS27 INS65 INS32 INS42 INS42 INS66 INS14 INS65 INS32 INS27 INS65 INS32 INS66 INS38 INS8 INS66 INS66 INS65 INS66 INS66 INS7 INS39 INS59 INS27 INS8 INS37 UPD42 INS52 INS42 INS52 INS42 INS52 INS42 UPD42 INS52 INS42 INS27 INS42 INS42 INS40 INS32 INS42 INS42 INS32 INS42 INS42 INS7 INS27 INS8 INS39 INS59 INS39 INS59 INS58 INS27 INS37 INS8 INS43 INS42 INS21 INS27 INS8 INS42 INS32 INS53 INS36 INS42 INS42 INS42 INS33 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS53 INS36 INS42 INS53 INS42 INS34 INS54 INS42 INS42 INS42 INS43 INS45 INS42 INS42 INS33 INS42 INS42 INS21 INS21 INS67 INS42 INS33 INS42 INS27 INS27 INS27 INS25 INS60 INS54 INS42 INS40 INS34 INS42 INS42 UPD42 UPD43 INS42 INS42 INS27 INS42 INS32 INS42 INS38 INS21 INS42 INS27 INS42 INS32 INS39 INS59 INS27 INS27 INS42 INS60 INS54 INS42 INS32 INS42 INS33 INS54 INS42 INS14 INS11 INS14 INS14 INS27 INS14 INS8 INS12 INS42 INS32 INS7 INS42 INS42 INS34 INS42 INS33 INS36 INS42 INS27 INS8 INS43 INS59 INS8 INS12 UPD42 INS45 INS42 INS45 INS42 INS34 INS7 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 MOV43 INS59 INS8 INS12 INS42 INS42 INS45 INS42 INS8 INS12 INS43 INS43 INS32 INS43 INS43 INS45 INS42 INS42 INS42 INS43 INS21 INS25 INS44 INS8 INS42 INS42 INS9 INS27 INS42 INS32 INS54 INS25 INS42 INS42 INS11 INS21 INS44 INS8 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS25 INS44 INS8 INS21 INS44 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS27 INS8 INS8 INS43 INS42 INS53 INS42 INS42 INS42 INS42 INS8 INS12 INS27 INS8 INS43 INS32 INS7 INS43 INS42 INS21 INS21 INS21 INS42 INS42 INS42 INS42 INS32 INS32 INS8 INS43 INS42 INS21 INS32 INS43 INS42 INS21 INS42 INS27 INS32 INS27 INS21 INS21 INS53 INS42 INS14 INS60 INS25 INS21 INS44 INS8 INS42 INS32 INS41 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS32 INS32 INS37 INS32 INS42 INS40 INS42 INS42 INS42 INS40 INS21 INS42 INS37 INS42 INS42 INS42 INS32 INS42 INS42 INS11 INS42 INS42 INS42 INS42 INS7 INS32 INS14 INS43 INS32 INS39 INS59 INS27 INS8 INS8 INS32 INS43 INS42 INS21 INS42 INS42 INS43 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS39 INS42 INS42 INS27 INS42 INS43 INS42 INS42 INS42 INS42 INS32 INS34 INS21 INS21 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS45 INS32 INS45 INS32 INS42 INS42 INS14 INS45 INS42 INS42 INS34 INS42 INS42 INS42 INS7 INS7 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS32 INS42 INS32 INS42 INS27 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS34 INS42 INS42 DEL43 DEL85 DEL5 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42
JCR-2007 Importing strings with special characters fails

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@752458 13f79535-47bb-0310-9956-ffa450edef68

+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.FileInputStream;
-import java.io.FileReader;
+import java.io.InputStreamReader;
+import java.io.StringWriter;
-     * max size for buffering data in memory
+     * The maximum size for buffering data in memory.
+    
-     * size of increment if capacity buffer needs to be enlarged
+     * The in-memory buffer.
-    private static final int BUFFER_INCREMENT = 0x2000;
+    private StringWriter buffer;
+    
-     * in-memory buffer
+     * The number of characters written so far.
+     * If the in-memory buffer is used, this is position within buffer (size of actual data in buffer)
-    private char[] buffer;
-    /**
-     * current position within buffer (size of actual data in buffer)
-     */
-    private int bufferPos;
+    private long length;
-     * backing temporary file created when size of data exceeds
-     * MAX_BUFFER_SIZE
+     * Backing temporary file created when size of data exceeds
+     * MAX_BUFFER_SIZE.
+    
-     * writer used to write to tmpFile; writer & tmpFile are always
-     * instantiated together, i.e. they are either both null or both not null.
+     * Writer used to write to tmpFile.
+    
+    /**
+     * Whether the value is base64 encoded.
+     */
+    private boolean base64;
-        buffer = new char[0x2000];
-        bufferPos = 0;
+        buffer = new StringWriter();
+        length = 0;
-        if (buffer != null) {
-            return bufferPos;
-        } else if (tmpFile != null) {
-            // flush writer first
-            writer.flush();
-            return tmpFile.length();
-        } else {
-            throw new IOException("this instance has already been disposed");
+        return length;
+    }
+    
+    private String retrieveString() throws IOException {
+        String value = retrieve();
+        if (base64) {
+            ByteArrayOutputStream out = new ByteArrayOutputStream();
+            Base64.decode(value, out);
+            value = new String(out.toByteArray(), "UTF-8");
+        return value;
-            return new String(buffer, 0, bufferPos);
+            return buffer.toString();
-            // flush writer first
-            writer.flush();
+            // close writer first
+            writer.close();
-            StringBuffer sb = new StringBuffer((int) tmpFile.length());
+            StringBuffer sb = new StringBuffer((int) length);
-            int read;
-            Reader reader = new FileReader(tmpFile);
+            Reader reader = openReader();
+                int read;
+    
+    private Reader openReader() throws IOException {
+        return new InputStreamReader(
+                new BufferedInputStream(new FileInputStream(tmpFile)), "UTF-8");
+    }
-            return new StringReader(new String(buffer, 0, bufferPos));
+            return new StringReader(retrieve());
-            // flush writer first
-            writer.flush();
-            return new FileReader(tmpFile);
+            // close writer first
+            writer.close();
+            return openReader();
-     * @param length the number of characters to append
+     * @param len the number of characters to append
-    public void append(char[] chars, int start, int length)
+    public void append(char[] chars, int start, int len)
-            if (bufferPos + length > MAX_BUFFER_SIZE) {
+            if (this.length + len > MAX_BUFFER_SIZE) {
-                final FileOutputStream fout = new FileOutputStream(tmpFile);
-                writer = new OutputStreamWriter(fout) {
-                    public void flush() throws IOException {
-                        // flush this writer
-                        super.flush();
-                        // force synchronization with underlying file
-                        fout.getFD().sync();
-                    }
-                };
-                writer.write(buffer, 0, bufferPos);
-                writer.write(chars, start, length);
-                // reset fields
+                BufferedOutputStream fout = new BufferedOutputStream(new FileOutputStream(tmpFile));
+                writer = new OutputStreamWriter(fout, "UTF-8");
+                writer.write(buffer.toString());
+                writer.write(chars, start, len);
+                // reset the in-memory buffer
-                bufferPos = 0;
-                if (bufferPos + length > buffer.length) {
-                    // reallocate new buffer and spool old buffer contents
-                    int bufferSize =
-                            BUFFER_INCREMENT * (((bufferPos + length) / BUFFER_INCREMENT) + 1);
-                    char[] newBuffer = new char[bufferSize];
-                    System.arraycopy(buffer, 0, newBuffer, 0, bufferPos);
-                    buffer = newBuffer;
-                }
-                System.arraycopy(chars, start, buffer, bufferPos, length);
-                bufferPos += length;
+                buffer.write(chars, start, len);
-            writer.write(chars, start, length);
+            writer.write(chars, start, len);
+        length += len;
-                return ValueHelper.deserialize(retrieve(), targetType, false, ValueFactoryImpl.getInstance());
+                return ValueHelper.deserialize(retrieveString(), targetType, false, ValueFactoryImpl.getInstance());
-                    // using Reader and temporay file
+                    // using Reader and temporary file
-                        retrieve(), type, ValueFactoryImpl.getInstance()), nsContext);
+                        retrieveString(), type, ValueFactoryImpl.getInstance()), nsContext);
+    /**
+     * This class converts the text read Converts a base64 reader to an input stream.
+     */
-            bufferPos = 0;
+
+    /**
+     * Whether this value is base64 encoded
+     * 
+     * @param base64 the flag
+     */
+    public void setBase64(boolean base64) {
+        this.base64 = base64;
+    }
+

MOV26 INS26 INS26 INS26 INS26 MOV23 INS40 INS40 INS40 UPD40 INS40 INS31 INS31 INS31 INS31 INS43 MOV59 INS39 INS59 MOV43 MOV59 INS39 INS59 MOV29 MOV83 MOV39 MOV42 MOV43 INS8 INS83 INS43 INS42 INS43 INS8 INS83 INS43 INS42 MOV43 INS8 INS29 INS29 INS83 INS39 INS42 INS44 INS8 INS42 INS42 INS42 MOV41 INS42 INS42 INS60 INS25 INS41 INS42 INS41 UPD42 INS21 INS65 INS65 INS65 INS39 INS42 INS21 UPD66 UPD66 INS66 UPD66 UPD66 INS66 UPD66 UPD66 UPD42 MOV43 INS59 INS42 MOV8 INS42 INS14 UPD42 INS7 INS66 INS66 INS42 INS66 INS7 INS14 UPD42 INS42 MOV32 INS60 INS21 UPD43 MOV43 INS14 UPD45 MOV45 INS42 INS42 INS22 INS42 INS43 INS43 INS59 INS7 INS32 UPD42 INS43 INS14 INS14 INS52 INS42 INS42 INS42 INS42 INS14 UPD42 UPD42 INS42 INS42 INS42 INS14 INS42 INS42 MOV43 INS42 INS43 INS42 MOV43 INS32 INS32 INS43 MOV43 INS32 INS45 UPD42 INS32 MOV60 INS42 INS42 UPD42 INS42 INS22 UPD42 UPD43 UPD42 INS42 UPD42 MOV42 UPD42 MOV42 MOV43 INS42 INS52 INS42 UPD42 INS14 INS32 UPD42 UPD42 UPD42 UPD42 INS42 INS43 MOV14 INS45 MOV42 UPD42 MOV42 INS32 INS42 UPD42 INS42 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL39 DEL85 DEL5 DEL39 DEL42 DEL59 DEL66 DEL66 DEL39 DEL85 DEL5 DEL34 DEL3 DEL32 DEL41 DEL42 DEL33 DEL27 DEL8 DEL42 DEL33 DEL27 DEL14 DEL53 DEL8 DEL25 DEL25 DEL8 DEL31 DEL42 DEL34 DEL42 DEL14 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL14 DEL42 DEL34 DEL42 DEL14 DEL14 DEL42 DEL43 DEL42 DEL14 DEL42 DEL83 DEL83 DEL39 DEL42 DEL42 DEL48 DEL21 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL31 DEL1 DEL34 DEL42 DEL34 DEL7 DEL21 DEL42 DEL42 DEL27 DEL40 DEL27 DEL39 DEL42 DEL42 DEL42 DEL42 DEL27 DEL36 DEL42 DEL27 DEL36 DEL34 DEL27 DEL36 DEL27 DEL59 DEL60 DEL39 DEL85 DEL5 DEL42 DEL39 DEL85 DEL5 DEL42 DEL3 DEL59 DEL60 DEL42 DEL42 DEL42 DEL34 DEL42 DEL34 DEL42 DEL32 DEL21 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL7 DEL21 DEL42 DEL34 DEL7 DEL21
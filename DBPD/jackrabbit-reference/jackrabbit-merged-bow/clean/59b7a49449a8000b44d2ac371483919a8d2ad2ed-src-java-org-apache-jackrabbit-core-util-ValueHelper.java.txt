consolidated Value de-/serialization code in static methods of ValueHelper class

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@159686 13f79535-47bb-0310-9956-ffa450edef68

+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+import java.io.StringWriter;
+import java.io.Writer;
-     * @throws IllegalStateException
-            throws ValueFormatException, IllegalStateException, IllegalArgumentException {
+            throws ValueFormatException, IllegalArgumentException {
-            throws ValueFormatException, IllegalStateException, IllegalArgumentException {
+            throws ValueFormatException, IllegalStateException,
+            IllegalArgumentException {
-                            throw new ValueFormatException("failed to convert source value to PATH value", re);
+                            throw new ValueFormatException("failed to convert source value to PATH value",
+                                    re);
-                            throw new ValueFormatException("source value " + path + " does not represent a valid path", mpe);
+                            throw new ValueFormatException("source value " + path
+                                    + " does not represent a valid path", mpe);
-                    case PropertyType.PATH:	// path might be a name (relative, onle element long path)
+                    case PropertyType.PATH:	// path might be a name (relative path of length 1)
-                            throw new ValueFormatException("failed to convert source value to NAME value", re);
+                            throw new ValueFormatException("failed to convert source value to NAME value",
+                                    re);
-                            throw new ValueFormatException("source value " + name + " does not represent a valid name", ine);
+                            throw new ValueFormatException("source value "
+                                    + name
+                                    + " does not represent a valid name", ine);
-                            throw new ValueFormatException("failed to convert source value to REFERENCE value", re);
+                            throw new ValueFormatException("failed to convert source value to REFERENCE value",
+                                    re);
+
+    /**
+     * Serializes the given value to a <code>String</code>. The serialization
+     * format is the same as used by Document & System View XML, i.e.
+     * binary values will be Base64-encoded whereas for all others
+     * <code>{@link javax.jcr.Value#getString()}</code> will be used.
+     *
+     * @param value        the value to be serialized
+     * @param encodeBlanks if <code>true</code> space characters will be encoded
+     *                     as <code>"_x0020_"</code> within he output string.
+     * @return a string representation of the given value.
+     * @throws IllegalStateException if the given value is in an illegal state
+     * @throws RepositoryException   if an error occured during the serialization.
+     */
+    public static String serialize(Value value, boolean encodeBlanks)
+            throws IllegalStateException, RepositoryException {
+        StringWriter writer = new StringWriter();
+        try {
+            serialize(value, encodeBlanks, writer);
+        } catch (IOException ioe) {
+            throw new RepositoryException("failed to serialize value",
+                    ioe);
+        }
+        return writer.toString();
+    }
+
+    /**
+     * Outputs the serialized value to a <code>Writer</code>. The serialization
+     * format is the same as used by Document & System View XML, i.e.
+     * binary values will be Base64-encoded whereas for all others
+     * <code>{@link javax.jcr.Value#getString()}</code> will be used for
+     * serialization.
+     *
+     * @param value        the value to be serialized
+     * @param encodeBlanks if <code>true</code> space characters will be encoded
+     *                     as <code>"_x0020_"</code> within he output string.
+     * @param writer       writer to output the encoded data
+     * @throws IllegalStateException if the given value is in an illegal state
+     * @throws IOException           if an i/o error occured during the
+     *                               serialization
+     * @throws RepositoryException   if an error occured during the serialization.
+     */
+    public static void serialize(Value value, boolean encodeBlanks,
+                                 Writer writer)
+            throws IllegalStateException, IOException, RepositoryException {
+        if (value.getType() == PropertyType.BINARY) {
+            // binary data, base64 encoding required;
+            // the encodeBlanks flag can be ignored since base64-encoded
+            // data cannot contain space characters
+            InputStream in = value.getStream();
+            try {
+                Base64.encode(in, writer);
+                // no need to close StringWriter
+                //writer.close();
+            } finally {
+                try {
+                    in.close();
+                } catch (IOException e) {
+                    // ignore
+                }
+            }
+        } else {
+            String textVal = value.getString();
+            if (encodeBlanks) {
+                // enocde blanks in string
+                textVal = Text.replace(textVal, " ", "_x0020_");
+            }
+            writer.write(textVal);
+        }
+    }
+
+    /**
+     * Deserializes the given string to a <code>Value</code> of the given type.
+     *
+     * @param value        string to be deserialized
+     * @param type         type of value
+     * @param decodeBlanks if <code>true</code> <code>"_x0020_"</code>
+     *                     character sequences will be decoded to single space
+     *                     characters each.
+     * @return the deserialized <code>Value</code>
+     * @throws ValueFormatException if the string data is not of the required
+     *                              format
+     * @throws RepositoryException  if an error occured during the
+     *                              deserialization.
+     */
+    public static Value deserialize(String value, int type,
+                                    boolean decodeBlanks)
+            throws RepositoryException {
+        if (type == PropertyType.BINARY) {
+            // base64 encoded binary value;
+            // the encodeBlanks flag can be ignored since base64-encoded
+            // data cannot contain encoded space characters
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            try {
+                Base64.decode(value, baos);
+                // no need to close ByteArrayOutputStream
+                //baos.close();
+            } catch (IOException ioe) {
+                throw new RepositoryException("failed to decode binary value",
+                        ioe);
+            }
+            return new BinaryValue(baos.toByteArray());
+        } else {
+            if (decodeBlanks) {
+                // decode encoded blanks in value
+                value = Text.replace(value, "_x0020_", " ");
+            }
+            return convert(value, type);
+        }
+    }
+
+    /**
+     * Deserializes the string data read from the given reader to a
+     * <code>Value</code> of the given type.
+     *
+     * @param reader       reader for the string data to be deserialized
+     * @param type         type of value
+     * @param decodeBlanks if <code>true</code> <code>"_x0020_"</code>
+     *                     character sequences will be decoded to single space characters each.
+     * @return the deserialized <code>Value</code>
+     * @throws IOException          if an i/o error occured during the
+     *                              serialization
+     * @throws ValueFormatException if the string data is not of the required
+     *                              format
+     * @throws RepositoryException  if an error occured during the
+     *                              deserialization.
+     */
+    public static Value deserialize(Reader reader, int type,
+                                    boolean decodeBlanks)
+            throws IOException, ValueFormatException, RepositoryException {
+        if (type == PropertyType.BINARY) {
+            // base64 encoded binary value;
+            // the encodeBlanks flag can be ignored since base64-encoded
+            // data cannot contain encoded space characters
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            Base64.decode(reader, baos);
+            // no need to close ByteArrayOutputStream
+            //baos.close();
+            return new BinaryValue(baos.toByteArray());
+        } else {
+            char[] chunk = new char[8192];
+            int read;
+            StringBuffer buf = new StringBuffer();
+            while ((read = reader.read(chunk)) > -1) {
+                buf.append(chunk, 0, read);
+            }
+            String value = buf.toString();
+            if (decodeBlanks) {
+                // decode encoded blanks in value
+                value = Text.replace(value, "_x0020_", " ");
+            }
+            return convert(value, type);
+        }
+    }

INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS31 INS31 INS31 INS31 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS43 INS43 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS44 INS44 MOV43 INS43 INS43 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS44 INS43 INS43 INS43 INS8 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS39 INS42 INS42 INS42 INS60 INS54 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS39 INS42 INS43 INS42 INS42 INS42 INS25 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS39 INS42 INS39 INS42 INS42 INS25 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS39 INS42 INS39 INS42 INS42 INS42 INS42 INS25 INS66 INS66 INS66 INS66 INS65 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS43 INS59 INS8 INS12 INS32 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS42 INS27 INS8 INS8 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS27 INS8 INS8 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS27 INS8 INS8 INS68 INS42 INS42 INS14 INS21 INS44 INS8 INS42 INS42 INS68 INS32 INS40 INS60 INS54 INS60 INS25 INS21 INS42 INS40 INS60 INS54 INS41 INS25 INS41 INS42 INS40 INS60 INS21 INS41 INS60 INS60 INS60 INS61 INS60 INS25 INS41 INS40 INS42 INS43 INS32 INS43 INS42 INS53 INS40 INS42 INS42 INS42 INS43 INS59 INS8 INS8 INS43 INS59 INS42 INS8 INS32 INS43 INS59 INS8 INS12 INS14 INS42 INS8 INS32 INS43 INS59 INS32 INS14 INS5 INS59 INS39 INS59 INS43 INS59 INS27 INS8 INS43 INS59 INS42 INS8 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS32 INS21 INS54 INS42 INS42 INS32 INS21 INS42 INS42 INS42 INS42 INS42 INS14 INS21 INS44 INS8 INS43 INS32 INS21 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS43 INS32 INS39 INS85 INS42 INS3 INS42 INS42 INS42 INS14 INS36 INS38 INS21 INS42 INS42 INS32 INS21 INS42 INS42 INS42 INS43 INS45 INS42 INS42 INS42 INS32 INS8 INS12 INS42 INS42 INS7 INS43 INS32 INS43 INS42 INS53 INS42 INS42 INS42 INS7 INS43 INS42 INS42 INS42 INS5 INS34 INS43 INS7 INS34 INS32 INS42 INS42 INS7 INS42 INS42 INS42 INS42 INS42 INS21 INS44 INS8 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS32 INS42 INS39 INS85 INS42 INS42 INS32 INS42 INS42 INS42 INS34 INS42 INS42 INS32 INS32 INS43 INS42 INS42 INS42 INS42 INS45 INS45 INS43 INS45 INS42 INS42 INS42 INS42 INS45 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS45 INS42 INS42 INS42 INS42 DEL42 DEL65
JCR-1979: Deadlock on concurrent read & transactional write operations

Moved the virtual provider accesses outside the workspace read lock. This avoids the deadlock with a transactional write.

This change in lock scope does not endanger consistency, as all the modifiable virtual providers already have their own internal locking (as evidenced by the deadlock scenario!). In fact a global virtual provider like the version store *must* have it's own locking mechanism as it can be concurrently accessed from multiple workspaces.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@744895 13f79535-47bb-0310-9956-ffa450edef68

-
-
-            // check virtual providers
-            for (int i = 0; i < virtualProviders.length; i++) {
-                try {
-                    return virtualProviders[i].getNodeReferences(id);
-                } catch (NoSuchItemStateException e) {
-                    // ignore
-                }
-            }
+        // check virtual providers
+        for (int i = 0; i < virtualProviders.length; i++) {
+            try {
+                return virtualProviders[i].getNodeReferences(id);
+            } catch (NoSuchItemStateException e) {
+                // ignore
+            }
+        }
+
-
-
-            // check virtual providers
-            for (int i = 0; i < virtualProviders.length; i++) {
-                if (virtualProviders[i].hasNodeReferences(id)) {
-                    return true;
-                }
-            }
+
+        // check virtual providers
+        for (int i = 0; i < virtualProviders.length; i++) {
+            if (virtualProviders[i].hasNodeReferences(id)) {
+                return true;
+            }
+        }
+

MOV8 MOV8 MOV60 INS54 MOV53 MOV60 MOV54 INS54 MOV41 INS8 MOV8 INS8 MOV8 MOV54 MOV54 DEL54 DEL8 DEL54 DEL8
work in progress

- public NodeState.getChildNodeEntry/ies and
  NodeState.hasChildNodeEntry/ies must assert validity of the cnes.
- NodeState internal retrieval of child states should therefore avoid
  public methods unless only valid entries are of interest.
- ChildNodeEntries: simplify.
- SessionImporter: improve comment

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@473383 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.HashSet;
-     * TODO: cache needs to be notified when a child node entry is traversed or NodeState is created
-            for (Iterator it = parent.getChildNodeEntries(name).iterator(); it.hasNext(); ) {
+            for (Iterator it = parent.childNodeEntries.get(name).iterator(); it.hasNext(); ) {
-            ChildNodeEntry entry = getParent().getChildNodeEntry(this);
+            ChildNodeEntry entry = getParent().childNodeEntries.get(this);
-     * Return all nodetype names that apply to this <code>NodeState</code>
+     * Return all nodetype names that are defined to this <code>NodeState</code>
-     * @return
+     * @return array of NodeType names
-     * Determines if there is a <code>ChildNodeEntry</code> with the
+     * Determines if there is a valid <code>ChildNodeEntry</code> with the
-     * @param name  <code>QName</code> object specifying a node name
-     * @param index 1-based index if there are same-name child node entries
+     * @param name  <code>QName</code> object specifying a node name.
+     * @param index 1-based index if there are same-name child node entries.
-        return childNodeEntries.get(name, index) != null;
+        return isValidChildNodeEntry(childNodeEntries.get(name, index));
-     * Returns the <code>ChildNodeEntry</code> with the specified name and index
-     * or <code>null</code> if there's no matching entry.
+     * Returns the valid <code>ChildNodeEntry</code> with the specified name
+     * and index or <code>null</code> if there's no matching entry.
-     * @param nodeName <code>QName</code> object specifying a node name
-     * @param index    1-based index if there are same-name child node entries
-     * @return the <code>ChildNodeEntry</code> with the specified name and index
-     *         or <code>null</code> if there's no matching entry.
+     * @param nodeName <code>QName</code> object specifying a node name.
+     * @param index 1-based index if there are same-name child node entries.
+     * @return The <code>ChildNodeEntry</code> with the specified name and index
+     * or <code>null</code> if there's no matching entry.
-        return childNodeEntries.get(nodeName, index);
+        ChildNodeEntry cne = childNodeEntries.get(nodeName, index);
+        if (isValidChildNodeEntry(cne)) {
+            return cne;
+        } else {
+            return null;
+        }
-    public synchronized ChildNodeEntry getChildNodeEntry(NodeId nodeId) {
+    synchronized ChildNodeEntry getChildNodeEntry(NodeId nodeId) {
+        ChildNodeEntry cne;
-            return childNodeEntries.get(null, uuid);
+            cne = childNodeEntries.get(null, uuid);
-            return childNodeEntries.get(nameElement.getName(), nameElement.getIndex());
+            cne = childNodeEntries.get(nameElement.getName(), nameElement.getIndex());
-    }
-    /**
-     * Returns the <code>ChildNodeEntry</code> with the specified
-     * <code>NodeState</code> or <code>null</code> if there's no matching
-     * entry.
-     *
-     * @param nodeState the child node state.
-     * @return the <code>ChildNodeEntry</code> with the specified
-     * <code>NodeState</code> or <code>null</code> if there's no matching entry.
-     */
-    private synchronized ChildNodeEntry getChildNodeEntry(NodeState nodeState) {
-        return childNodeEntries.get(nodeState);
+        if (isValidChildNodeEntry(cne)) {
+            return cne;
+        } else {
+            return null;
+        }
-        // NOTE: 'childNodeEntries' are already unmodifiable
-        return childNodeEntries;
+        Collection entries = new ArrayList();
+        for (Iterator it = childNodeEntries.iterator(); it.hasNext();) {
+            ChildNodeEntry cne = (ChildNodeEntry) it.next();
+            if (isValidChildNodeEntry(cne)) {
+                entries.add(cne);
+            }
+        }
+        return Collections.unmodifiableCollection(entries);
-        // NOTE: SubList retrieved from 'ChildNodeEntries' is already unmodifiable
-        return childNodeEntries.get(nodeName);
+        List entries = new ArrayList();
+        for (Iterator it = childNodeEntries.get(nodeName).iterator(); it.hasNext();) {
+            ChildNodeEntry cne = (ChildNodeEntry) it.next();
+            if (isValidChildNodeEntry(cne)) {
+                entries.add(cne);
+            }
+        }
+        return Collections.unmodifiableList(entries);
-        if (entry == null) {
-            return false;
-        }
-        if (entry.isAvailable()) {
-            try {
-                return entry.getPropertyState().isValid();
-            } catch (ItemStateException e) {
-                // probably deleted in the meantime
-                return false;
-            }
-        } else {
-            // then it must be valid // TODO check if this assumption is correct.
-            return true;
-        }
+        return isValidChildPropertyEntry(entry);
-                if (propEntry.isAvailable()) {
-                    try {
-                        if (propEntry.getPropertyState().isValid()) {
-                            props.add(propEntry);
-                        }
-                    } catch (ItemStateException e) {
-                        // removed in the meantime -> ignore
-                    }
-                } else {
-                    // never been accessed before, assume valid
+                if (isValidChildPropertyEntry(propEntry)) {
-            if (entry.isAvailable()) {
-                try {
-                    if (entry.getNodeState().isValid()) {
-                        index++;
-                    }
-                } catch (ItemStateException e) {
-                    // probably removed or stale
-                }
-            } else {
-                // cne has not been resolved yet -> increase counter.
-                // TODO: check if assuption is correct
+            if (isValidChildNodeEntry(entry)) {
-                    int index = parent.getChildNodeEntry((NodeState) addedState).getIndex();
+                    int index = parent.childNodeEntries.get((NodeState)addedState).getIndex();
+                    // check for existing, valid child-node-entry
-    //---------------------------------------------------------< diff methods >
-
-    /**
-     * Returns a set of <code>QName</code>s denoting those properties that
-     * do not exist in the overlayed node state but have been added to
-     * <i>this</i> node state.
-     *
-     * @return set of <code>QName</code>s denoting the properties that have
-     *         been added.
-     */
-    public synchronized Set getAddedPropertyNames() {
-        checkIsSessionState();
-
-        if (getStatus() == Status.NEW) {
-            // state is new -> all
-            return Collections.unmodifiableSet(properties.keySet());
-        }
-
-        NodeState other = (NodeState) getWorkspaceState();
-        HashSet set = new HashSet(properties.keySet());
-        set.removeAll(other.properties.keySet());
-        return set;
-    }
-
-    /**
-     * Returns a collection of child node entries that do not exist in the
-     * overlayed node state but have been added to <i>this</i> node state.
-     *
-     * @return collection of added child node entries
-     */
-    public synchronized Collection getAddedChildNodeEntries() {
-        checkIsSessionState();
-
-        if (getStatus() == Status.NEW) {
-            // state is new -> all child nodes are new too
-            return childNodeEntries;
-        }
-
-        List added = new ArrayList();
-        for (Iterator it = childNodeEntries.iterator(); it.hasNext(); ) {
-            ChildNodeEntry cne = (ChildNodeEntry) it.next();
-            try {
-                if (cne.getNodeState().getStatus() == Status.NEW) {
-                    added.add(cne);
-                }
-            } catch (ItemStateException e) {
-                log.warn("error retrieving child node state: " + e.getMessage());
-            }
-        }
-        return added;
-    }
-
-    /**
-     * Returns a set of <code>QName</code>s denoting those properties that
-     * exist in the overlayed node state but have been removed from
-     * <i>this</i> node state.
-     *
-     * @return set of <code>QName</code>s denoting the properties that have
-     *         been removed.
-     */
-    public synchronized Set getRemovedPropertyNames() {
-        checkIsSessionState();
-
-        if (getStatus() == Status.NEW) {
-            return Collections.EMPTY_SET;
-        }
-
-        NodeState other = (NodeState) getWorkspaceState();
-        HashSet set = new HashSet(other.properties.keySet());
-        set.removeAll(properties.keySet());
-        return set;
-    }
-
-    /**
-     * Returns a collection of child node entries, that exist in the overlayed
-     * node state but have been removed from <i>this</i> node state.
-     *
-     * @return collection of removed child node entries
-     */
-    public synchronized Collection getRemovedChildNodeEntries() {
-        checkIsSessionState();
-
-        if (getStatus() == Status.NEW) {
-            return Collections.EMPTY_LIST;
-        }
-
-        List removed = new ArrayList();
-        for (Iterator it = childNodeEntries.iterator(); it.hasNext(); ) {
-            ChildNodeEntry cne = (ChildNodeEntry) it.next();
-            try {
-                if (cne.getNodeState().getStatus() == Status.EXISTING_REMOVED) {
-                    removed.add(cne);
-                }
-            } catch (ItemStateException e) {
-                log.warn("error retrieving child node state: " + e.getMessage());
-            }
-        }
-        return removed;
-    }
-
-        for (Iterator it = entries.iterator(); it.hasNext(); ) {
+        boolean hasValid = false;
+        for (Iterator it = entries.iterator(); it.hasNext() && !hasValid; ) {
-            if (cne.isAvailable()) {
-                try {
-                    if (cne.getNodeState().isValid()) {
-                        return true;
-                    }
-                } catch (ItemStateException e) {
-                    // probably removed in the meantime, check next
-                }
-            } else {
-                // then it has never been accessed and must exist
-                // TODO: check if this assumption is correct
-                return true;
-            }
+            hasValid = isValidChildNodeEntry(cne);
-        return false;
+        return hasValid;
+    }
+
+    /**
+     * Returns <code>true</code> if the given childnode entry is not
+     * <code>null</code> and resolves to a NodeState, that is valid or if the
+     * childnode entry has not been resolved up to now (assuming the corresponding
+     * nodestate is still valid).
+     *
+     * @param cne ChildNodeEntry to check.
+     * @return <code>true</code> if the given entry is valid.
+     */
+    private static boolean isValidChildNodeEntry(ChildNodeEntry cne) {
+        // shortcut.
+        if (cne == null) {
+            return false;
+        }
+        boolean isValid = false;
+        if (cne.isAvailable()) {
+            try {
+                isValid = cne.getNodeState().isValid();
+            } catch (ItemStateException e) {
+                // should not occur, if the cne is available.
+            }
+        } else {
+            // then it has never been accessed and must exist
+            // TODO: check if this assumption is correct
+            isValid = true;
+        }
+
+        return isValid;
+    }
+
+    /**
+     * Returns <code>true</code> if the given childproperty entry is not
+     * <code>null</code> and resolves to a PropertyState, that is valid or if the
+     * childproperty entry has not been resolved up to now (assuming the corresponding
+     * PropertyState is still valid).
+     *
+     * @param cpe ChildPropertyEntry to check.
+     * @return <code>true</code> if the given entry is valid.
+     */
+    private static boolean isValidChildPropertyEntry(ChildPropertyEntry cpe) {
+        if (cpe == null) {
+            return false;
+        }
+        boolean isValid = false;
+        if (cpe.isAvailable()) {
+            try {
+                isValid = cpe.getPropertyState().isValid();
+            } catch (ItemStateException e) {
+                // probably deleted in the meantime. should not occur.
+            }
+        } else {
+            // then it must be valid // TODO check if this assumption is correct.
+            isValid = true;
+        }
+        return isValid;

MOV31 INS31 INS31 INS31 MOV29 MOV83 MOV83 MOV43 MOV42 MOV44 MOV44 INS8 MOV29 MOV43 UPD42 MOV29 MOV83 MOV83 MOV43 UPD42 MOV42 MOV44 INS8 INS8 MOV8 MOV29 INS83 INS83 INS39 INS42 MOV44 INS8 UPD83 UPD83 INS39 INS42 INS44 MOV8 UPD83 UPD83 INS39 INS42 INS44 INS60 INS25 INS60 INS25 MOV60 INS24 INS41 MOV60 INS24 INS41 MOV60 MOV41 MOV60 INS25 MOV41 INS60 INS24 MOV41 INS65 INS43 INS42 INS25 INS60 INS41 INS65 INS43 INS42 MOV25 INS60 INS25 UPD66 INS66 UPD66 UPD66 UPD66 INS32 UPD66 UPD66 UPD66 UPD66 UPD66 MOV43 INS59 INS32 INS8 INS8 INS43 INS59 INS32 INS8 INS8 MOV43 MOV58 MOV32 INS8 INS32 INS58 MOV32 INS8 INS32 MOV27 MOV8 MOV8 INS39 INS59 MOV58 INS27 INS8 UPD42 UPD66 INS66 UPD66 UPD66 INS42 INS66 UPD66 UPD42 MOV42 INS27 MOV8 INS39 INS59 INS42 UPD66 INS66 UPD66 INS66 INS42 INS66 UPD66 UPD42 MOV42 INS39 INS59 INS32 INS8 INS8 UPD42 INS42 MOV32 INS42 MOV32 UPD42 MOV42 UPD42 MOV42 MOV41 MOV41 INS42 INS42 INS21 INS21 INS42 INS42 INS41 INS41 UPD42 MOV60 MOV25 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 INS43 INS59 MOV60 MOV25 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV21 INS24 MOV25 INS42 INS9 MOV32 INS38 MOV60 MOV21 INS42 INS33 INS42 INS9 INS21 UPD42 UPD42 MOV42 INS9 UPD42 MOV42 UPD42 MOV42 INS54 MOV21 UPD42 INS33 INS7 INS7 INS42 INS33 INS32 INS42 INS42 INS32 INS32 MOV58 MOV32 MOV8 INS32 INS42 INS7 INS7 INS8 MOV12 INS7 INS42 MOV32 INS42 MOV32 UPD42 MOV42 INS42 INS21 MOV32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV60 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS21 INS42 INS9 MOV21 INS42 INS9 INS22 INS42 INS32 INS32 UPD42 MOV42 UPD42 MOV42 INS7 INS7 MOV32 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 MOV32 INS42 INS32 INS32 UPD42 MOV42 INS40 UPD42 UPD42 MOV42 UPD42 MOV42 INS40 UPD42 DEL40 DEL26 DEL66 DEL42 DEL42 DEL33 DEL27 DEL41 DEL8 DEL31 DEL83 DEL41 DEL41 DEL66 DEL66 DEL66 DEL65 DEL66 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL43 DEL32 DEL40 DEL27 DEL42 DEL32 DEL32 DEL41 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL40 DEL32 DEL32 DEL21 DEL42 DEL41 DEL42 DEL32 DEL32 DEL40 DEL27 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL32 DEL41 DEL8 DEL31 DEL83 DEL83 DEL42 DEL8 DEL31 DEL83 DEL83 DEL42 DEL8 DEL31 DEL42 DEL32 DEL42 DEL42 DEL32 DEL8 DEL42 DEL43 DEL42 DEL44 DEL12 DEL54 DEL8 DEL9 DEL41 DEL8 DEL25 DEL8 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL24 DEL25 DEL8 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL8 DEL54 DEL8 DEL42 DEL37 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL45 DEL32 DEL27 DEL32 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL42 DEL32 DEL21 DEL32 DEL40 DEL27 DEL42 DEL41 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL8 DEL24 DEL8 DEL31 DEL66 DEL9 DEL41 DEL8 DEL25 DEL9 DEL41 DEL42 DEL43 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL40 DEL27 DEL40 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL43 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL40 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL41 DEL8 DEL43 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL42 DEL32 DEL21 DEL42 DEL32 DEL40 DEL27 DEL40 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL58 DEL32 DEL42 DEL32 DEL40 DEL27 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL8 DEL24 DEL83 DEL83 DEL39 DEL42 DEL24 DEL9 DEL41 DEL8 DEL31
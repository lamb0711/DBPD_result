JCR-2156: Usage of "qualified name" in JavaDoc and Comments

- spi-commons/nodetype/constraints package (omitted yesterday in order to avoid conflicts)

JCR-2153: Introduce QValueConstraint and change return type of QPropertyDefinition.getValueConstraints()

- introduce constants for the wildcards
- fixing creation of PathConstraint from /*
- fixing testcases (still used to previous internal form for path constraint)
- minor improvement to constraint tests in general



git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@786019 13f79535-47bb-0310-9956-ffa450edef68

-    private final String qualifiedDefinition;
+    private final String definition;
-    protected ValueConstraint(String qualifiedDefinition) {
-        this.qualifiedDefinition = qualifiedDefinition;
+    protected ValueConstraint(String definition) {
+        this.definition = definition;
-     * must overwrite this and return a value that has all qualified names
-     * and path elements resolved.
+     * must overwrite this and return a value that has the <code>Name</code>s
+     * or <code>Path</code> properly resolved to their JCR representation.
+     * @see NamePathResolver#getJCRName(org.apache.jackrabbit.spi.Name)
+     * @see NamePathResolver#getJCRPath(org.apache.jackrabbit.spi.Path) 
-        return qualifiedDefinition;
+        return definition;
+    //---------------------------------------------------< QValueConstraint >---
-     * By default the qualified definition is the same as the JCR definition.
-     *
-     * @return the internal definition String
-     */
+     * @see org.apache.jackrabbit.spi.QValueConstraint#getString()
+     */ 
-        return qualifiedDefinition;
+        return definition;
+    //---------------------------------------------------< java.lang.Object >---
+     * @see Object#toString()
-     * Check if the specified value matches the this constraint.
-     *
-     * @param value The value to be tested.
-     * @throws ConstraintViolationException If the specified value is
-     * <code>null</code> or does not matches the constraint.
-     * @throws RepositoryException If another error occurs.
+     * @see Object#equals(Object)
-    public abstract void check(QValue value) throws ConstraintViolationException, RepositoryException;
-
-    //---------------------------------------------------< java.lang.Object >---
-                && qualifiedDefinition.equals(((ValueConstraint) other).qualifiedDefinition);
+                && definition.equals(((ValueConstraint) other).definition);
-        return qualifiedDefinition.hashCode();
+        return definition.hashCode();
-     * Note, that the definition must be in the qualified format in case the type
-     * indicates {@link PropertyType#NAME}, {@link PropertyType#PATH} or {@link PropertyType#REFERENCE}
+     * Note, that the definition must be independant of session specific namespace
+     * mappings in case of the following constraint types:
+     * <ul><li>{@link PropertyType#NAME},</li>
+     * <li>{@link PropertyType#PATH} or</li>
+     * <li>{@link PropertyType#REFERENCE}</li>
+     * </ul>
-     * @param qualifiedDefinition internal definition string
+     * @param definition The internal definition string.
-     * @throws InvalidConstraintException if the constraint is not valid
+     * @throws InvalidConstraintException if the constraint is not valid.
+     * @see #create(int, String, NamePathResolver) for the corresponding
+     * method that allows to pass the JCR representation of a constraint
+     * definition.
-    public static ValueConstraint create(int type, String qualifiedDefinition)
+    public static ValueConstraint create(int type, String definition)
-        if (qualifiedDefinition == null) {
+        if (definition == null) {
-                return new StringConstraint(qualifiedDefinition);
-
-            case PropertyType.BOOLEAN:
-                return new BooleanConstraint(qualifiedDefinition);
-
-            case PropertyType.BINARY:
-                return new NumericConstraint(qualifiedDefinition);
-
-            case PropertyType.DATE:
-                return new DateConstraint(qualifiedDefinition);
-
-            case PropertyType.LONG:
-            case PropertyType.DOUBLE:
-            case PropertyType.DECIMAL:
-                return new NumericConstraint(qualifiedDefinition);
-
-            // qName sensitive constraints: create from qualified string
-            case PropertyType.NAME:
-                return NameConstraint.create(qualifiedDefinition);
-
-            case PropertyType.PATH:
-                return PathConstraint.create(qualifiedDefinition);
-
-            case PropertyType.REFERENCE:
-            case PropertyType.WEAKREFERENCE:
-                return ReferenceConstraint.create(qualifiedDefinition);
-
-            default:
-                throw new IllegalArgumentException("unknown/unsupported target type for constraint: "
-                        + PropertyType.nameFromValue(type));
-        }
-    }
-
-    /**
-     * Create a new <code>ValueConstraint</code> array from the String representation.
-     * Note, that the definition must be in the qualified format in case the type
-     * indicates {@link PropertyType#NAME}, {@link PropertyType#PATH} or {@link PropertyType#REFERENCE}
-     *
-     * @param type the required type
-     * @param qualifiedDefinition internal definition strings
-     * @return the array of constraints
-     * @throws InvalidConstraintException if one of the constraints is invalid
-     */
-    public static ValueConstraint[] create(int type, String[] qualifiedDefinition)
-            throws InvalidConstraintException {
-        if (qualifiedDefinition == null || qualifiedDefinition.length == 0) {
-            return ValueConstraint.EMPTY_ARRAY;
-        }
-        ValueConstraint[] ret = new ValueConstraint[qualifiedDefinition.length];
-        for (int i=0; i<ret.length; i++) {
-            ret[i] = ValueConstraint.create(type, qualifiedDefinition[i]);
-        }
-        return ret;
-    }
-
-    /**
-     * Create a new <code>ValueConstraint</code> array from the JCR representation.
-     *
-     * @param type the required type
-     * @param definition definition strings
-     * @param resolver name-path resolver
-     * @return the array of constraints
-     * @throws InvalidConstraintException if one of the constraints is invalid
-     */
-    public static ValueConstraint[] create(int type, String definition[], NamePathResolver resolver)
-            throws InvalidConstraintException {
-        if (definition == null || definition.length == 0) {
-            return ValueConstraint.EMPTY_ARRAY;
-        }
-        ValueConstraint[] ret = new ValueConstraint[definition.length];
-        for (int i=0; i<ret.length; i++) {
-            ret[i] = ValueConstraint.create(type, definition[i], resolver);
-        }
-        return ret;
-    }
-
-    /**
-     *
-     * @param type required type
-     * @param definition JCR definition
-     * @param resolver name-path resolver
-     * @return a new value constraint
-     * @throws InvalidConstraintException if the constraint is invalid
-     */
-    public static ValueConstraint create(int type, String definition,
-                                         NamePathResolver resolver)
-            throws InvalidConstraintException {
-        if (definition == null) {
-            throw new IllegalArgumentException("Illegal definition (null) for ValueConstraint.");
-        }
-        switch (type) {
-            case PropertyType.STRING:
-            case PropertyType.URI:
-                return NameConstraint.create(definition, resolver);
+                return NameConstraint.create(definition);
-                return PathConstraint.create(definition, resolver);
+                return PathConstraint.create(definition);
-                return ReferenceConstraint.create(definition, resolver);
+                return ReferenceConstraint.create(definition);
+
+            default:
+                throw new IllegalArgumentException("unknown/unsupported target type for constraint: "
+                        + PropertyType.nameFromValue(type));
+        }
+    }
+
+    /**
+     * Create a new <code>ValueConstraint</code> array from the String
+     * representation. Note, that the definition must be in the internal format
+     * in case of the following types:
+     * <ul><li>{@link PropertyType#NAME},</li>
+     * <li>{@link PropertyType#PATH} or</li>
+     * <li>{@link PropertyType#REFERENCE}</li>
+     * </ul>
+     *
+     * @param type the required type
+     * @param definition internal definition strings
+     * @return the array of constraints
+     * @throws InvalidConstraintException if one of the constraints is invalid
+     */
+    public static ValueConstraint[] create(int type, String[] definition)
+            throws InvalidConstraintException {
+        if (definition == null || definition.length == 0) {
+            return ValueConstraint.EMPTY_ARRAY;
+        }
+        ValueConstraint[] ret = new ValueConstraint[definition.length];
+        for (int i=0; i<ret.length; i++) {
+            ret[i] = ValueConstraint.create(type, definition[i]);
+        }
+        return ret;
+    }
+
+    /**
+     * Create a new <code>ValueConstraint</code> array from the specified JCR
+     * representations.
+     *
+     * @param type the required type
+     * @param jcrDefinition The definition strings as exposed through the JCR API.
+     * @param resolver name-path resolver
+     * @return the array of constraints
+     * @throws InvalidConstraintException if one of the constraints is invalid
+     */
+    public static ValueConstraint[] create(int type, String jcrDefinition[], NamePathResolver resolver)
+            throws InvalidConstraintException {
+        if (jcrDefinition == null || jcrDefinition.length == 0) {
+            return ValueConstraint.EMPTY_ARRAY;
+        }
+        ValueConstraint[] ret = new ValueConstraint[jcrDefinition.length];
+        for (int i=0; i<ret.length; i++) {
+            ret[i] = ValueConstraint.create(type, jcrDefinition[i], resolver);
+        }
+        return ret;
+    }
+
+    /**
+     *
+     * @param type required type
+     * @param jcrDefinition A JCR representation of a value constraint definition.
+     * @param resolver name-path resolver
+     * @return a new value constraint
+     * @throws InvalidConstraintException if the constraint is invalid
+     */
+    public static ValueConstraint create(int type, String jcrDefinition,
+                                         NamePathResolver resolver)
+            throws InvalidConstraintException {
+        if (jcrDefinition == null) {
+            throw new IllegalArgumentException("Illegal definition (null) for ValueConstraint.");
+        }
+        switch (type) {
+            case PropertyType.STRING:
+            case PropertyType.URI:
+                return new StringConstraint(jcrDefinition);
+
+            case PropertyType.BOOLEAN:
+                return new BooleanConstraint(jcrDefinition);
+
+            case PropertyType.BINARY:
+                return new NumericConstraint(jcrDefinition);
+
+            case PropertyType.DATE:
+                return new DateConstraint(jcrDefinition);
+
+            case PropertyType.LONG:
+            case PropertyType.DOUBLE:
+            case PropertyType.DECIMAL:
+                return new NumericConstraint(jcrDefinition);
+
+            case PropertyType.NAME:
+                return NameConstraint.create(jcrDefinition, resolver);
+
+            case PropertyType.PATH:
+                return PathConstraint.create(jcrDefinition, resolver);
+
+            case PropertyType.REFERENCE:
+            case PropertyType.WEAKREFERENCE:
+                return ReferenceConstraint.create(jcrDefinition, resolver);

MOV31 MOV31 MOV31 INS44 INS29 MOV29 MOV43 MOV44 MOV43 MOV29 MOV44 INS29 INS44 MOV44 INS29 MOV43 MOV44 MOV44 MOV43 UPD42 INS43 INS42 INS65 INS65 UPD65 INS65 INS65 INS65 MOV25 UPD42 INS65 MOV65 INS65 MOV65 MOV65 MOV65 MOV43 INS42 INS85 MOV65 INS65 MOV65 MOV65 MOV65 UPD42 UPD43 MOV42 INS25 MOV41 MOV41 INS42 UPD66 UPD66 INS68 INS68 INS66 UPD42 INS68 UPD42 INS68 INS68 UPD66 UPD66 INS66 UPD66 INS66 UPD66 INS66 INS66 INS66 UPD42 UPD66 UPD66 INS68 INS66 INS66 INS66 MOV27 MOV53 UPD66 UPD66 UPD66 INS66 UPD66 INS66 UPD66 INS66 INS66 INS66 UPD42 INS66 INS66 INS42 INS66 MOV5 INS42 INS66 MOV42 INS27 MOV8 MOV53 UPD42 INS42 INS42 INS69 INS42 INS42 INS69 INS40 INS42 INS42 INS42 INS42 INS42 INS69 UPD42 INS42 INS69 INS69 INS69 MOV33 INS42 INS33 UPD42 INS43 INS43 INS43 INS39 INS43 INS43 UPD42 UPD40 MOV5 UPD40 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 INS42 UPD42 INS42 INS40 INS40 INS42 UPD42 INS42 INS42 UPD42 INS42 UPD42 DEL66 DEL65 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL31 DEL42 DEL66 DEL65 DEL29 DEL25 DEL42 DEL42 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL42 DEL85 DEL44 DEL42
cleaning up NodeTypeRegistry and EffectiveNodeType code:
- removing NodeTypeRegistry field from EffectiveNodeType
- reviewing access modifiers
- make those methods static that don't affect the state of an instance
- etc etc

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@414843 13f79535-47bb-0310-9956-ffa450edef68

-    // node type registry
-    private final NodeTypeRegistry ntReg;
-
-    private EffectiveNodeType(NodeTypeRegistry ntReg) {
-        this.ntReg = ntReg;
+    private EffectiveNodeType() {
-     * Factory method: creates an effective node type representation of an
-     * existing (i.e. registered) node type.
-     *
-     * @param ntReg
-     * @param nodeTypeName
-     * @return
-     * @throws NodeTypeConflictException
-     * @throws NoSuchNodeTypeException
-     */
-    static EffectiveNodeType create(NodeTypeRegistry ntReg, QName nodeTypeName)
-            throws NodeTypeConflictException, NoSuchNodeTypeException {
-        return create(ntReg, ntReg.getNodeTypeDef(nodeTypeName));
-    }
-
-    /**
-     * Factory method: creates an effective node type representation of a
-     * node type definition. Whereas all referenced node types must exist
-     * (i.e. must be registered), the definition itself is not required to be
-     * registered.
-     *
-     * @param ntReg
-     * @param ntd
-     * @return
-     * @throws NodeTypeConflictException
-     * @throws NoSuchNodeTypeException
-     */
-    public static EffectiveNodeType create(NodeTypeRegistry ntReg, NodeTypeDef ntd)
-            throws NodeTypeConflictException, NoSuchNodeTypeException {
-        return create(ntReg, ntd, null, null);
-    }
-
-    /**
-     * Whereas all referenced node types must exist (i.e. must be registered),
-     * the definition itself is not required to be registered.
-     * todo check javadoc/param names
-     * @param ntReg
-     * @param ntd
-     * @param anEntCache
-     * @param aRegisteredNTDefCache
-     * @return
-     * @throws NodeTypeConflictException
-     * @throws NoSuchNodeTypeException
+     * Note that the definitions of all referenced node types must be contained
+     * in <code>ntdCache</code>.
+     *
+     * @param ntd      node type defintion
+     * @param entCache cache of already-built effective node types
+     * @param ntdCache cache of node type definitions, used to resolve dependencies
+     * @return an effective node type representation of the given node type definition.
+     * @throws NodeTypeConflictException if the node type definition is invalid,
+     *                                   e.g. due to ambiguous child definitions.
+     * @throws NoSuchNodeTypeException if a node type reference (e.g. a supertype)
+     *                                 could not be resolved.
-    static EffectiveNodeType create(NodeTypeRegistry ntReg,
-                                    NodeTypeDef ntd,
-                                    EffectiveNodeTypeCache anEntCache,
-                                    Map aRegisteredNTDefCache)
+    static EffectiveNodeType create(NodeTypeDef ntd,
+                                    EffectiveNodeTypeCache entCache,
+                                    Map ntdCache)
-        EffectiveNodeType ent = new EffectiveNodeType(ntReg);
+        EffectiveNodeType ent = new EffectiveNodeType();
-            if (anEntCache == null || aRegisteredNTDefCache == null) {
-                ent.internalMerge(ntReg.getEffectiveNodeType(supertypes), true);
-            } else {
-                ent.internalMerge(ntReg.getEffectiveNodeType(supertypes, anEntCache, aRegisteredNTDefCache), true);
-            }
+            ent.internalMerge(NodeTypeRegistry.getEffectiveNodeType(supertypes, entCache, ntdCache), true);
-    static EffectiveNodeType create(NodeTypeRegistry ntReg) {
-        return new EffectiveNodeType(ntReg);
+    static EffectiveNodeType create() {
+        return new EffectiveNodeType();
+     * Determines whether this effective node type representation includes
+     * (either through inheritance or aggregation) all of the given node types.
+     *
+     * @param nodeTypeNames array of node type names
+     * @return <code>true</code> if all of the given node types are included,
+     *         otherwise <code>false</code>
+     */
+    public boolean includesNodeTypes(QName[] nodeTypeNames) {
+        return allNodeTypes.containsAll(Arrays.asList(nodeTypeNames));
+    }
+
+    /**
-            getApplicableChildNodeDef(name, null);
+            getApplicableChildNodeDef(name, null, null);
+     * @param ntReg
-    public void checkAddNodeConstraints(QName name, QName nodeTypeName)
+    public void checkAddNodeConstraints(QName name, QName nodeTypeName,
+                                        NodeTypeRegistry ntReg)
-        NodeDef nd = getApplicableChildNodeDef(name, nodeTypeName);
+        NodeDef nd = getApplicableChildNodeDef(name, nodeTypeName, ntReg);
+     * @param ntReg
-    public NodeDef getApplicableChildNodeDef(QName name, QName nodeTypeName)
+    public NodeDef getApplicableChildNodeDef(QName name, QName nodeTypeName,
+                                             NodeTypeRegistry ntReg)
+        EffectiveNodeType entTarget;
+        if (nodeTypeName != null) {
+            entTarget = ntReg.getEffectiveNodeType(nodeTypeName);
+        } else {
+            entTarget = null;
+        }
+
-                    if (nodeTypeName != null) {
-                        try {
-                            // check node type constraints
-                            checkRequiredPrimaryType(nodeTypeName, nd.getRequiredPrimaryTypes());
-                        } catch (ConstraintViolationException cve) {
-                            // ignore and try next
+                    if (entTarget != null && nd.getRequiredPrimaryTypes() != null) {
+                        // check 'required primary types' constraint
+                        if (!entTarget.includesNodeTypes(nd.getRequiredPrimaryTypes())) {
-                        // found node definition
+                        // found named node definition
-            if (nodeTypeName != null) {
-                try {
-                    // check node type constraint
-                    checkRequiredPrimaryType(nodeTypeName, nd.getRequiredPrimaryTypes());
-                } catch (ConstraintViolationException e) {
-                    // ignore and try next
+            if (entTarget != null && nd.getRequiredPrimaryTypes() != null) {
+                // check 'required primary types' constraint
+                if (!entTarget.includesNodeTypes(nd.getRequiredPrimaryTypes())) {
-     * @param nodeTypeName
-     * @param requiredPrimaryTypes
-     * @throws ConstraintViolationException
-     * @throws NoSuchNodeTypeException
-     */
-    public void checkRequiredPrimaryType(QName nodeTypeName,
-                                         QName[] requiredPrimaryTypes)
-            throws ConstraintViolationException, NoSuchNodeTypeException {
-        if (requiredPrimaryTypes == null) {
-            // no constraint
-            return;
-        }
-        EffectiveNodeType ent;
-        try {
-            ent = ntReg.getEffectiveNodeType(nodeTypeName);
-        } catch (RepositoryException re) {
-            String msg = "failed to check node type constraint";
-            log.debug(msg);
-            throw new ConstraintViolationException(msg, re);
-        }
-        for (int i = 0; i < requiredPrimaryTypes.length; i++) {
-            if (!ent.includesNodeType(requiredPrimaryTypes[i])) {
-                throw new ConstraintViolationException("node type constraint not satisfied: " + requiredPrimaryTypes[i]);
-            }
-        }
-    }
-
-    /**
-        EffectiveNodeType clone = new EffectiveNodeType(ntReg);
+        EffectiveNodeType clone = new EffectiveNodeType();

MOV31 UPD83 INS39 INS42 MOV44 MOV44 MOV44 UPD42 UPD42 MOV25 UPD42 MOV65 MOV65 INS60 INS25 UPD66 UPD66 INS66 UPD42 INS66 UPD42 INS66 INS66 INS66 INS66 INS66 INS66 MOV43 MOV27 UPD66 UPD66 UPD42 INS66 INS66 INS66 MOV43 INS59 MOV27 INS8 INS8 MOV43 UPD42 UPD42 INS42 INS21 INS21 MOV43 UPD42 UPD42 UPD42 INS42 INS7 INS7 INS27 MOV8 MOV43 INS33 INS42 MOV32 INS42 INS33 INS27 INS27 INS25 INS41 UPD42 UPD42 UPD42 UPD42 MOV42 MOV33 INS32 INS33 INS38 MOV8 INS42 MOV42 MOV42 MOV32 INS18 INS27 UPD42 UPD42 INS27 INS27 INS25 INS42 INS33 INS32 INS33 INS38 MOV8 INS42 INS42 INS32 INS42 INS42 MOV32 INS42 INS42 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL65 DEL65 DEL42 DEL65 DEL42 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL33 DEL33 DEL32 DEL41 DEL8 DEL31 DEL66 DEL42 DEL42 DEL33 DEL27 DEL42 DEL33 DEL27 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL9 DEL32 DEL21 DEL8 DEL8 DEL25 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL44 DEL12 DEL54 DEL21 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL12 DEL54 DEL8 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL33 DEL27 DEL41 DEL8 DEL25 DEL42 DEL59 DEL60 DEL42 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL42 DEL42 DEL2 DEL32 DEL38 DEL42 DEL43 DEL45 DEL42 DEL42 DEL2 DEL27 DEL14 DEL53 DEL8 DEL25 DEL8 DEL24 DEL8 DEL31 DEL42
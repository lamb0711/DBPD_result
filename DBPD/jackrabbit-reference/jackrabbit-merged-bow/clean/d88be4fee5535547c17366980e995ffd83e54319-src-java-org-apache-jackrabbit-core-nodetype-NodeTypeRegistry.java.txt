more work on value constraints

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@109359 13f79535-47bb-0310-9956-ffa450edef68

-            String reason = name + " already exists";
-            log.error(reason);
-            throw new InvalidNodeTypeDefException(reason);
+            String msg = name + " already exists";
+            log.error(msg);
+            throw new InvalidNodeTypeDefException(msg);
-            String reason = "no name specified";
-            log.error(reason);
-            throw new InvalidNodeTypeDefException(reason);
+            String msg = "no name specified";
+            log.error(msg);
+            throw new InvalidNodeTypeDefException(msg);
-            String reason = name + " already exists";
-            log.error(reason);
-            throw new InvalidNodeTypeDefException(reason);
+            String msg = name + " already exists";
+            log.error(msg);
+            throw new InvalidNodeTypeDefException(msg);
-                // simple check for infinite recursion
-                // (won't trap recursion on a deeper inheritance level)
+                /**
+                 * simple check for infinite recursion
+                 * (won't trap recursion on a deeper inheritance level)
+                 */
-                    String reason = "invalid supertype: " + supertypes[i] + " (infinite recursion))";
-                    log.error(reason);
-                    throw new InvalidNodeTypeDefException(reason);
+                    String msg = "invalid supertype: " + supertypes[i] + " (infinite recursion))";
+                    log.error(msg);
+                    throw new InvalidNodeTypeDefException(msg);
-                    String reason = "invalid supertype: " + supertypes[i];
-                    log.error(reason);
-                    throw new InvalidNodeTypeDefException(reason);
+                    String msg = "invalid supertype: " + supertypes[i];
+                    log.error(msg);
+                    throw new InvalidNodeTypeDefException(msg);
-            // check for circularity in inheritance chain ('a' extends 'b' extends 'a'):
+            /**
+             * check for circularity in inheritance chain
+             * ('a' extends 'b' extends 'a')
+             */
-         * note that infinite recursion through inheritance is automatically being checked
-         * by the following call to getEffectiveNodeType
-         * as it's impossible to register an node type definition which references a
-         * supertype that isn't registered yet...
+         * note that infinite recursion through inheritance is automatically
+         * being checked by the following call to getEffectiveNodeType()
+         * as it's impossible to register an node type definition which
+         * references a supertype that isn't registered yet...
-        // build effective (i.e. merged and resolved) node type from supertypes
-        // and check for conflicts
+        /**
+         * build effective (i.e. merged and resolved) node type from supertypes
+         * and check for conflicts
+         */
-                    String reason = "all primary node types except nt:base itself must be (directly or indirectly) derived from nt:base";
-                    log.error(reason);
-                    throw new InvalidNodeTypeDefException(reason);
+                    String msg = "all primary node types except nt:base itself must be (directly or indirectly) derived from nt:base";
+                    log.error(msg);
+                    throw new InvalidNodeTypeDefException(msg);
-                String reason = "failed to validate supertypes";
-                log.error(reason, ntce);
-                throw new InvalidNodeTypeDefException(reason, ntce);
+                String msg = "failed to validate supertypes";
+                log.error(msg, ntce);
+                throw new InvalidNodeTypeDefException(msg, ntce);
-                String reason = "failed to validate supertypes";
-                log.error(reason, nsnte);
-                throw new InvalidNodeTypeDefException(reason, nsnte);
+                String msg = "failed to validate supertypes";
+                log.error(msg, nsnte);
+                throw new InvalidNodeTypeDefException(msg, nsnte);
-                String reason = "all primary node types except nt:base itself must be (directly or indirectly) derived from nt:base";
-                log.error(reason);
-                throw new InvalidNodeTypeDefException(reason);
+                String msg = "all primary node types except nt:base itself must be (directly or indirectly) derived from nt:base";
+                log.error(msg);
+                throw new InvalidNodeTypeDefException(msg);
-                    String reason = "primary item must specify a name";
-                    log.error(reason);
-                    throw new InvalidNodeTypeDefException(reason);
+                    String msg = "primary item must specify a name";
+                    log.error(msg);
+                    throw new InvalidNodeTypeDefException(msg);
-                    String reason = "more than one primary item specified";
-                    log.error(reason);
-                    throw new InvalidNodeTypeDefException(reason);
+                    String msg = "more than one primary item specified";
+                    log.error(msg);
+                    throw new InvalidNodeTypeDefException(msg);
-                String reason = "auto-created properties must specify a name";
-                log.error(reason);
-                throw new InvalidNodeTypeDefException(reason);
+                String msg = "auto-created properties must specify a name";
+                log.error(msg);
+                throw new InvalidNodeTypeDefException(msg);
-                            String reason = "type of default value(s) is not consistent with required property type";
-                            log.error(reason);
-                            throw new InvalidNodeTypeDefException(reason);
+                            String msg = "type of default value(s) is not consistent with required property type";
+                            log.error(msg);
+                            throw new InvalidNodeTypeDefException(msg);
-            if (constraints != null && constraints.length != 0
-                    && defVals != null && defVals.length != 0) {
-                for (int j = 0; j < constraints.length; j++) {
-                    for (int k = 0; k < defVals.length; k++) {
-                        try {
-                            constraints[j].check(defVals[k]);
-                        } catch (ConstraintViolationException cve) {
+            if (constraints != null && constraints.length > 0) {
+                if (defVals != null && defVals.length > 0) {
+                    // check value constraints on every value
+                    for (int j = 0; j < defVals.length; j++) {
+                        // constraints are OR-ed together
+                        boolean satisfied = false;
+                        ConstraintViolationException cve = null;
+                        for (int k = 0; k < constraints.length; k++) {
+                            try {
+                                constraints[k].check(defVals[j]);
+                                // at least one constraint is satisfied
+                                satisfied = true;
+                                break;
+                            } catch (ConstraintViolationException e) {
+                                cve = e;
+                                continue;
+                            }
+                        }
+                        if (!satisfied) {
+                            // report last exception we encountered
-                                    + " does not satisfy value constraint "
-                                    + constraints[j].getDefinition();
+                                    + " does not satisfy value constraint";
+
+                /**
+                 * ReferenceConstraint:
+                 * the specified node type must be registered, with one notable
+                 * exception: the node type just being registered
+                 */
+                if (pd.getRequiredType() == PropertyType.REFERENCE) {
+                    for (int j = 0; j < constraints.length; j++) {
+                        ReferenceConstraint rc = (ReferenceConstraint) constraints[j];
+                        QName ntName = rc.getNodeTypeName();
+                        if (!name.equals(ntName) && !registeredNTDefs.containsKey(ntName)) {
+                            String msg = "invalid REFERENCE value constraint '"
+                                    + ntName + "' (unknown node type) in property definition "
+                                    + (pd.definesResidual() ? "*" : pd.getName().toString());
+                            log.error(msg);
+                            throw new InvalidNodeTypeDefException(msg);
+                        }
+                    }
+                }
-                // the default primary type must be registered with one notable
-                // exception: the node type just being registered
+                /**
+                 * the default primary type must be registered, with one notable
+                 * exception: the node type just being registered
+                 */
-                    String msg = "Invalid default primary type: " + dpt + " in childnode definition " + cnd.getName();
+                    String msg = "invalid default primary type '" + dpt
+                            + "' in childnode definition " + cnd.getName();
-                // build effective (i.e. merged and resolved) node type from
-                // default primary type and check for conflicts
+                /**
+                 * build effective (i.e. merged and resolved) node type from
+                 * default primary type and check for conflicts
+                 */
-                        // the default primary type is identical with the node type
-                        // just being registered; we have to instantiate it
-                        // 'manually'
+                        /**
+                         * the default primary type is identical with the node
+                         * type just being registered; we have to instantiate it
+                         * 'manually'
+                         */
-                        // check for circularity through default primary types of
-                        // auto-created child nodes (node type 'a' defines
-                        // auto-created child node with default primary type 'a')
+                        /**
+                         * check for circularity through default primary types
+                         * of auto-created child nodes (node type 'a' defines
+                         * auto-created child node with default primary type 'a')
+                         */
-                    // check if this node type specifies itself as required primary type
+                    /**
+                     * check if this node type specifies itself as required
+                     * primary type
+                     */
-                    // the required primary type must be registered with one notable
-                    // exception: the node type just being registered
+                    /**
+                     * the required primary type must be registered, with one
+                     * notable exception: the node type just being registered
+                     */
-                    // check if default primary type satisfies the required primary type constraint
+                    /**
+                     * check if default primary type satisfies the required
+                     * primary type constraint
+                     */
-                    // build effective (i.e. merged and resolved) node type from
-                    // required primary type constraint and check for conflicts
+                    /**
+                     * build effective (i.e. merged and resolved) node type from
+                     * required primary type constraint and check for conflicts
+                     */
-                            // the required primary type is identical with the node type
-                            // just being registered; we have to instantiate it
-                            // 'manually'
+                            /**
+                             * the required primary type is identical with the
+                             * node type just being registered; we have to
+                             * instantiate it 'manually'
+                             */
-                String reason = "unknown supertype: " + nt;
-                log.error(reason, nsnte);
-                throw new InvalidNodeTypeDefException(reason, nsnte);
+                String msg = "unknown supertype: " + nt;
+                log.error(msg, nsnte);
+                throw new InvalidNodeTypeDefException(msg, nsnte);
-                String reason = definingNT + " defines invalid default node type for child node " + nodeDefs[i].getName();
-                log.error(reason, nsnte);
-                throw new InvalidNodeTypeDefException(reason, nsnte);
+                String msg = definingNT + " defines invalid default node type for child node " + nodeDefs[i].getName();
+                log.error(msg, nsnte);
+                throw new InvalidNodeTypeDefException(msg, nsnte);
-         * todo build set of node types that have dependencies on the specified
+         * collect names of node types that have dependencies on the given
+        HashSet dependentNTs = new HashSet();
+        // only custom node types can have dependencies on a custom node type
+        Iterator iter = customNTDefs.all().iterator();
+        while (iter.hasNext()) {
+            NodeTypeDef ntd = (NodeTypeDef) iter.next();
+            if (ntd.getDependencies().contains(name)) {
+                dependentNTs.add(ntd.getName());
+            }
+        }
-         * todo check if this node type (or any node type that has dependencies
+         * todo
+         * check if the given node type (or any node type that has dependencies

INS60 INS60 INS61 INS43 INS59 INS43 INS59 INS32 INS8 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS60 INS25 MOV27 INS43 INS32 INS42 INS43 INS59 INS32 INS8 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD27 INS25 INS25 INS42 INS42 INS42 INS42 INS42 INS11 INS32 INS42 INS42 INS21 INS27 MOV8 INS27 INS8 INS43 INS32 INS42 INS42 INS32 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV27 INS27 INS32 INS40 MOV24 INS42 INS42 INS42 INS42 INS42 INS32 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS40 INS34 MOV58 MOV37 INS42 INS42 INS58 INS37 INS8 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS60 INS60 INS24 INS25 INS39 INS59 INS42 INS60 INS60 INS25 INS39 INS59 INS43 INS59 MOV58 INS27 MOV37 INS8 INS38 MOV8 INS42 INS34 INS43 INS59 INS43 INS59 INS27 INS8 UPD45 UPD45 INS42 INS9 INS42 INS42 INS33 INS42 INS40 MOV54 INS42 INS42 INS42 INS11 INS42 INS42 INS32 INS38 INS38 INS60 INS21 INS53 INS43 MOV2 INS42 INS42 INS32 INS32 INS43 INS59 INS32 INS14 UPD42 UPD42 UPD42 INS21 INS10 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS7 UPD42 INS21 INS18 UPD45 INS45 INS42 INS45 INS36 INS42 INS2 INS42 INS9 INS7 INS16 INS42 INS42 UPD42 INS42 INS42 INS32 INS45 INS32 INS42 INS42 INS32 INS42 INS42 INS42 DEL27 DEL40 DEL34 DEL27 DEL27 DEL42 DEL42 DEL2 DEL42 DEL32
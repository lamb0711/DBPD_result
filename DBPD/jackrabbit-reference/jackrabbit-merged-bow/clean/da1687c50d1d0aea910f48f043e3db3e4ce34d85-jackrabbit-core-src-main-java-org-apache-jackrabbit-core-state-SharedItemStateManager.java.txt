JCR-2272: Errors during concurrent session import of nodes with same UUIDs

Merge changes back to trunk.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1176546 13f79535-47bb-0310-9956-ffa450edef68

-     * Update event channel.
+     * Update event channel. By default this is a dummy channel that simply
+     * ignores all events (so we don't need to check for null all the time),
+     * but in clustered environments the
+     * {@link #setEventChannel(UpdateEventChannel)} method should be called
+     * during initialization to connect this SISM instance with the cluster.
-    private UpdateEventChannel eventChannel;
+    private UpdateEventChannel eventChannel = new DummyUpdateEventChannel();
-            /* let listener know about change */
-            if (eventChannel != null) {
-                eventChannel.updateCreated(this);
-            }
+            // let listener know about change
+            eventChannel.updateCreated(this);
-                if (writeLock == null && eventChannel != null) {
+                if (writeLock == null) {
+                    if (state.isNode() && state.getStatus() != ItemState.STATUS_NEW) {
+                        // another node with same id had been created
+                        // in the meantime, probably caused by mid-air collision
+                        // of concurrent versioning operations (JCR-2272)
+                        String msg = state.getId()
+                                + " has been created externally  (status "
+                                + state.getStatus() + ")";
+                        log.debug(msg);
+                        throw new StaleItemStateException(msg);
+                    }
-                /* let listener know about change */
-                if (eventChannel != null) {
-                    eventChannel.updatePrepared(this);
-                }
+                // let listener know about change
+                eventChannel.updatePrepared(this);
-
-                /* let listener know about finished operation */
-                if (eventChannel != null) {
-                    String path = events.getSession().getUserID() + "@" + events.getCommonPath();
-                    eventChannel.updateCommitted(this, path);
-                }
+                // Let listener know about finished operation. This needs
+                // to happen in the finally block so that the cluster lock
+                // always gets released, even if a post-store() exception
+                // is thrown from the code above. See also JCR-2272.
+                String path = events.getSession().getUserID()
+                        + "@" + events.getCommonPath();
+                eventChannel.updateCommitted(this, path);
+
-                /* let listener know about canceled operation */
-                if (eventChannel != null) {
-                    eventChannel.updateCancelled(this);
-                }
+                // let listener know about canceled operation
+                eventChannel.updateCancelled(this);

INS14 UPD66 INS66 INS66 INS65 INS66 INS66 INS43 MOV21 INS68 INS42 MOV8 INS42 INS69 MOV21 MOV25 MOV21 INS43 MOV27 INS8 INS42 INS25 MOV21 MOV21 INS27 INS8 INS32 INS27 INS60 INS21 INS53 INS42 INS42 INS32 INS40 INS43 INS59 INS32 INS14 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS43 INS42 INS32 INS45 INS32 INS45 INS42 INS42 INS42 INS42 INS42 DEL42 DEL33 DEL27 DEL8 DEL25 DEL42 DEL33 DEL27 DEL27 DEL8 DEL42 DEL33 DEL27 DEL8 DEL25 DEL42 DEL33 DEL27 DEL25 DEL8 DEL42 DEL33 DEL27 DEL8 DEL25
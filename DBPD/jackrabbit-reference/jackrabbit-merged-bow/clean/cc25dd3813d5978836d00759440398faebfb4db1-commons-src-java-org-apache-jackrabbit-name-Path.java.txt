JCR-157: Reorganize Jackrabbit into 'core' 'api' and 'commons'

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@209089 13f79535-47bb-0310-9956-ffa450edef68

-package org.apache.jackrabbit.core;
+package org.apache.jackrabbit.name;
-import org.apache.jackrabbit.core.util.Text;
+import org.apache.jackrabbit.Constants;
+import org.apache.jackrabbit.util.Text;
- * nornalize JCR-style item paths. <br>
- * Each path consistnes of path elements and is immutable. it has the following
- * properties:<br>
- * <code>absolute()</code>:<br>
- * A path is absolute, if the first path element denotes the root element '/'.
+ * nornalize JCR-style item paths.
- * <code>isRelative()</code>:<br>
- * A path is relative, if the first path element does not denote the root element.
- * I.e. is always the opposite of <code>absolute</code>.
+ * Each path consistnes of path elements and is immutable. It has the following
+ * properties:
- * <code>normalized()</code>:<br>
- * A path is normalized, if all '.' and '..' path elements are resolved as much
- * as possible. If the path is absolute, it is normalized if it contains
- * no such elements. for example the path '../../a' is normalized where as
- * '../../b/../a/.' is not. Normalized path never have '.' elements.
- * absolte normalilzed paths have no and relative normalized paths have no or
- * only leading '..' elements.<br>
+ * <code>isAbsolute()</code>:<br>
+ * A path is absolute if the first path element denotes the root element '/'.
+ * <p/>
+ * <code>isNormalized()</code>:<br>
+ * A path is normalized if all '.' and '..' path elements are resolved as much
+ * as possible. If the path is absolute it is normalized if it contains
+ * no such elements. For example the path '../../a' is normalized where as
+ * '../../b/../a/.' is not. Normalized paths never have '.' elements.
+ * Absolute normalized paths have no and relative normalized paths have no or
+ * only leading '..' elements.
- * A path is canonical, if its absolute and normalized.
+ * A path is canonical if its absolute and normalized.
+ *
+ * <h2>String representations</h2>
- * <p/>
- * the external string representation of a path has the following format:
- * <p/>
- * <xmp>
- * path ::= properpath ['/']
- * properpath ::= abspath | relpath
- * abspath ::= '/' relpath
- * relpath ::= [relpath '/'] pathelement
- * pathelement ::= name ['[' number ']']
- * number ::= << An integer > 0 >>
- * <p/>
- * name ::= [prefix ':'] simplename
- * prefix ::= << Any valid XML Name >>
- * simplename ::= nonspacestring [[string] nonspacestring]
- * string ::= [string] char
- * char ::= nonspace | space
- * nonspacestring ::= [nonspacestring] nonspace
- * space ::= << ' ' (the space character) >>
- * nonspace ::= << Any Unicode character except
- * '/', ':', '[', ']', '*',
- * '''(the single quote),
- * '"'(the double quote),
- * any whitespace character >>
- * </xmp>
+ * The JCR path format is specified by JSR 170 as follows:
+ * <pre>
+ *  path ::= properpath ['/']
+ *  properpath ::= abspath | relpath
+ *  abspath ::= '/' relpath
+ *  relpath ::= pathelement | relpath '/' pathelement
+ *  pathelement ::= name | name '[' number ']' | '..' | '.'
+ *  number ::= (* An integer > 0 *)
+ *  name ::= simplename | prefixedname
+ *  simplename ::= onecharsimplename |
+ *                 twocharsimplename |
+ *                 threeormorecharname
+ *  prefixedname ::= prefix ':' localname
+ *  localname ::= onecharlocalname |
+ *                twocharlocalname |
+ *                threeormorecharname
+ *  onecharsimplename ::= (* Any Unicode character except:
+ *                     '.', '/', ':', '[', ']', '*',
+ *                     ''', '"', '|' or any whitespace
+ *                     character *)
+ *  twocharsimplename ::= '.' onecharsimplename |
+ *                        onecharsimplename '.' |
+ *                        onecharsimplename onecharsimplename
+ *  onecharlocalname ::= nonspace
+ *  twocharlocalname ::= nonspace nonspace
+ *  threeormorecharname ::= nonspace string nonspace
+ *  prefix ::= (* Any valid XML Name *)
+ *  string ::= char | string char
+ *  char ::= nonspace | ' '
+ *  nonspace ::= (* Any Unicode character except:
+ *                  '/', ':', '[', ']', '*',
+ *                  ''', '"', '|' or any whitespace
+ *                  character *)
+ * </pre>
-     * string and the give name and index. If <code>normalize</code> is
+     * and the give name and index. If <code>normalize</code> is
-    public static Path create(Path parent, QName name, int index, boolean normalize)
+    public static Path create(Path parent, QName name, int index,
+                              boolean normalize)
-     * @throws PathNotFoundException    if there is no ancestor of the specified
+     * @throws javax.jcr.PathNotFoundException    if there is no ancestor of the specified
-     * @see java.lang.Object#hashCode()
+     * @see Object#hashCode()
-     * package private inner class used to build a path from path elements;
-     * this class does not validate the format of the path elements!
+     * Internal helper class used to build a path from pre-parsed path elements.
+     * <p/>
+     * <strong>Warning!</strong> This class does neither validate the format of
+     * the path elements nor does it validate the format of the entire path!
+     * This class should therefore only be used in special situations. The
+     * regular way of creating/building a <code>Path</code> object is by calling
+     * any of the overloaded <code>Path.create()</code> factory methods.
-    static final class PathBuilder implements Cloneable {
+    public static final class PathBuilder implements Cloneable {
-        PathBuilder() {
+        public PathBuilder() {
-        PathBuilder(PathElement[] elements) {
+        public PathBuilder(PathElement[] elements) {
-        void addRoot() {
+        public void addRoot() {
-        void addAll(PathElement[] elements) {
+        public void addAll(PathElement[] elements) {
-        void addFirst(QName name) {
+        public void addFirst(QName name) {
-        void addFirst(QName name, int index) {
+        public void addFirst(QName name, int index) {
-        void addLast(QName name) {
+        public void addLast(QName name) {
-        void addLast(QName name, int index) {
+        public void addLast(QName name, int index) {
-         * @return
+         * @return a new {@link Path}
-        Path getPath() throws MalformedPathException {
+        public Path getPath() throws MalformedPathException {
-    public static class RootElement extends PathElement {
+    public static final class RootElement extends PathElement {
-        public String toJCRName(NamespaceResolver resolver) throws NoPrefixDeclaredException {
+        public String toJCRName(NamespaceResolver resolver)
+                throws NoPrefixDeclaredException {
-    public static class CurrentElement extends PathElement {
+    public static final class CurrentElement extends PathElement {
-        public String toJCRName(NamespaceResolver resolver) throws NoPrefixDeclaredException {
+        public String toJCRName(NamespaceResolver resolver)
+                throws NoPrefixDeclaredException {
-    public static class ParentElement extends PathElement {
+    public static final class ParentElement extends PathElement {
-        public String toJCRName(NamespaceResolver resolver) throws NoPrefixDeclaredException {
+        public String toJCRName(NamespaceResolver resolver)
+                throws NoPrefixDeclaredException {

INS26 UPD40 INS40 UPD40 INS83 INS83 INS83 INS83 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 INS66 UPD66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 UPD66 INS66 INS66 UPD66 UPD66 UPD66 INS66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 INS83 INS83 INS83 INS83 INS83 INS83 INS83 INS83 INS83 UPD66 INS40 UPD66 INS66 INS66 UPD66 INS66 INS66 INS66 INS42 INS66 INS65 INS42 DEL66 DEL66 DEL66 DEL66 DEL66 DEL42 DEL40
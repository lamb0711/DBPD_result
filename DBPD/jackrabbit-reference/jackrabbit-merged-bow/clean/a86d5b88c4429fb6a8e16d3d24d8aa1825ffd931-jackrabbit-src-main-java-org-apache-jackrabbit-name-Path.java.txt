- improve Path and QName classes
- improve PathElement handling 
- add convenience methods to NameFormat


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@424258 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.util.Text;
-
- *
+ * <p/>
+
+    /**
+     * Creates a new <code>Path</code> from the given path elements.
+     *
+     * @param elements the path elements that will form the path
+     * @return a new <code>Path</code>
+     */
+    public static Path create(PathElement[] elements) {
+        PathElement[] tmp = new PathElement[elements.length];
+        boolean isNormalized = true;
+        boolean leadingParent = true;
+        for (int i = 0; i < elements.length; i++) {
+            PathElement elem = tmp[i] = elements[i];
+            if (elem.denotesCurrent() || elem.denotesParent()) {
+                leadingParent &= elem.denotesParent();
+                isNormalized &= !elem.denotesCurrent() && (leadingParent || !elem.denotesParent());
+            }
+        }
+        return new Path(tmp, isNormalized);
+    }
+
+    /**
+     * Creates a new <code>Path</code> from the given path elements but does
+     * not check if the path is normalized or not.
+     * <p/>
+     * Please note that this method should only be called, if the normalized
+     * state is known. Further is the element array not duplicated. Basically
+     * this method should only be called from {@link PathFormat}.
+     *
+     * @param elements     the path elements that will form the path
+     * @param isNormalized flag
+     * @return a new <code>Path</code>
+     */
+    protected static Path create(PathElement[] elements, boolean isNormalized) {
+        return new Path(elements, isNormalized);
+    }
+
-        Path path = PathFormat.parse(jcrPath, resolver);
-        if (normalize) {
-            return path.getNormalizedPath();
-        } else {
-            return path;
-        }
+        return normalize
+                ? PathFormat.parse(null, jcrPath, resolver).getNormalizedPath()
+                : PathFormat.parse(null, jcrPath, resolver);
-        Path path = PathFormat.parse(parent, relJCRPath, resolver);
-        if (canonicalize) {
-            return path.getCanonicalPath();
-        } else {
-            return path;
-        }
+        return canonicalize
+                ? PathFormat.parse(parent, relJCRPath, resolver).getCanonicalPath()
+                : PathFormat.parse(parent, relJCRPath, resolver);
-
-
-        Path path = pb.getPath();
-        if (normalize) {
-            return path.getNormalizedPath();
-        } else {
-            return path;
-        }
+        return normalize
+                ? pb.getPath().getNormalizedPath()
+                : pb.getPath();
-     * @param parent the parent path
-     * @param name the name of the new path element.
+     * @param parent    the parent path
+     * @param name      the name of the new path element.
-
-        Path path = pb.getPath();
-        if (normalize) {
-            return path.getNormalizedPath();
-        } else {
-            return path;
-        }
+        return normalize
+                ? pb.getPath().getNormalizedPath()
+                : pb.getPath();
-     * @param parent the paren tpath.
-     * @param name the name of the new path element.
-     * @param index the index of the new path element.
+     * @param parent    the paren tpath.
+     * @param name      the name of the new path element.
+     * @param index     the index of the new path element.
-
-        Path path = pb.getPath();
-        if (normalize) {
-            return path.getNormalizedPath();
-        } else {
-            return path;
-        }
+        return normalize
+                ? pb.getPath().getNormalizedPath()
+                : pb.getPath();
-        if (index < INDEX_UNDEFINED) {
+        PathElement elem = createPathElement(name, index);
+        return new Path(new PathElement[]{elem}, !elem.denotesCurrent());
+    }
+
+    /**
+     * Create a PathElement from the given QName and index.
+     *
+     * @param qName
+     * @param index
+     * @return new path element
+     * @throws IllegalArgumentException if the index is less than {@link Path#INDEX_UNDEFINED}.
+     */
+    public static PathElement createPathElement(QName qName, int index) {
+        if (index < Path.INDEX_UNDEFINED) {
-        PathElement elem;
-        if (index < INDEX_DEFAULT) {
-            elem = new PathElement(name);
+        if (index < Path.INDEX_DEFAULT) {
+            return PathElement.create(qName);
-            elem = new PathElement(name, index);
+            return PathElement.create(qName, index);
-        return new Path(new PathElement[]{elem}, !elem.equals(CURRENT_ELEMENT));
+
+
-        PathElement last = null;
+        PathElement last = PARENT_ELEMENT;
-            if (elem.denotesCurrent()) {
-                continue;
-            } else if (elem.denotesParent() && last != null && !last.denotesParent()) {
+            if (elem.denotesParent() && !last.denotesParent()) {
-                if (queue.isEmpty()) {
-                    last = null;
-                } else {
-                    last = (PathElement) queue.getLast();
-                }
-            } else {
-                last = elem;
-                queue.add(elem);
+                last = queue.isEmpty() ? PARENT_ELEMENT : (PathElement) queue.getLast();
+            } else if (!elem.denotesCurrent()) {
+                queue.add(last = elem);
-        for (int i = 0; i < p0.getElements().length && i < p1.getElements().length; i++) {
+        for (int i = 0; i < p0.getElements().length && i < p1.getElements().length; i++)
+        {
-     * @throws javax.jcr.PathNotFoundException    if there is no ancestor of the specified
+     * @throws PathNotFoundException
+     *                                  if there is no ancestor of the specified
-     * element at index <code>i</code>.
+     *                                        element at index <code>i</code>.
+
-        String[] elements = Text.explode(s, '\t', true);
+        final char delim = '\t';
+        int lastPos = 0;
+        int pos = s.indexOf(delim);
-        for (int i = 0; i < elements.length; i++) {
-            PathElement elem = PathElement.fromString(elements[i]);
+        while (lastPos >= 0) {
+            PathElement elem;
+            if (pos >= 0) {
+                elem = PathElement.fromString(s.substring(lastPos, pos));
+                lastPos = pos + 1;
+                pos = s.indexOf(delim, lastPos);
+            } else {
+                elem = PathElement.fromString(s.substring(lastPos));
+                lastPos = -1;
+            }
+
-            addFirst(new PathElement(name));
+            addFirst(PathElement.create(name));
-            addFirst(new PathElement(name, index));
+            addFirst(PathElement.create(name, index));
-            addLast(new PathElement(name));
+            addLast(PathElement.create(name));
-            addLast(new PathElement(name, index));
+            addLast(PathElement.create(name, index));
-        public Object clone() {
+        /**
+         * {@inheritDoc}
+         */
+        public Object clone() throws CloneNotSupportedException {
+            super.clone();
-    public static final class RootElement extends PathElement {
-        // use a literal that is an illegal name character to avoid collisions
-        static final String LITERAL = "*";
-
-        private RootElement() {
-            super(QName.ROOT);
-        }
-
-        /**
-         * Returns true.
-         * @return true
-         * @see PathElement#denotesRoot()
-         */
-        public boolean denotesRoot() {
-            return true;
-        }
-
-        /**
-         * Returns false.
-         * @return false
-         * @see PathElement#denotesCurrent()
-         */
-        public boolean denotesCurrent() {
-            return false;
-        }
-
-        /**
-         * Returns false.
-         * @return false
-         * @see PathElement#denotesParent()
-         */
-        public boolean denotesParent() {
-            return false;
-        }
-
-        /**
-         * Returns false.
-         * @return false
-         * @see PathElement#denotesName()
-         */
-        public boolean denotesName() {
-            return false;
-        }
-
-        /**
-         * @return {@link #LITERAL}
-         * @see Object#toString()
-         */
-        public String toString() {
-            return LITERAL;
-        }
-    }
-
-    public static final class CurrentElement extends PathElement {
-        static final String LITERAL = ".";
-
-        private CurrentElement() {
-            super(QName.NS_DEFAULT_URI, LITERAL);
-        }
-
-        /**
-         * Returns false.
-         * @return false
-         * @see PathElement#denotesRoot()
-         */
-        public boolean denotesRoot() {
-            return false;
-        }
-
-        /**
-         * Returns true.
-         * @return true
-         */
-        public boolean denotesCurrent() {
-            return true;
-        }
-
-        /**
-         * Returns false.
-         * @return false
-         * @see PathElement#denotesParent()
-         */
-        public boolean denotesParent() {
-            return false;
-        }
-
-        /**
-         * Returns false.
-         * @return false
-         * @see PathElement#denotesName()
-         */
-        public boolean denotesName() {
-            return false;
-        }
-
-        /**
-         * Returns the JCR name of this path element.
-         *
-         * @param resolver
-         * @return {@link #LITERAL}
-         */
-        public String toJCRName(NamespaceResolver resolver) {
-            return LITERAL;
-        }
-
-
-        /**
-         * @return {@link #LITERAL}
-         * @see Object#toString()
-         */
-        public String toString() {
-            return LITERAL;
-        }
-    }
-
-    private static final class ParentElement extends PathElement {
-        static final String LITERAL = "..";
-
-        private ParentElement() {
-            super(QName.NS_DEFAULT_URI, LITERAL);
-        }
-
-        /**
-         * Returns false.
-         * @return false
-         * @see PathElement#denotesRoot()
-         */
-        public boolean denotesRoot() {
-            return false;
-        }
-
-        /**
-         * Returns false.
-         * @return false
-         * @see PathElement#denotesCurrent()
-         */
-        public boolean denotesCurrent() {
-            return false;
-        }
-
-        /**
-         * Returns true.
-         * @return true
-         * @see PathElement#denotesParent()
-         */
-        public boolean denotesParent() {
-            return true;
-        }
-
-        /**
-         * Returns false.
-         * @return false
-         * @see PathElement#denotesName()
-         */
-        public boolean denotesName() {
-            return false;
-        }
-
-        /**
-         * Returns the JCR name of this path element.
-         *
-         * @param resolver
-         * @return {@link #LITERAL}
-         */
-        public String toJCRName(NamespaceResolver resolver) {
-            return LITERAL;
-        }
-
-        /**
-         * @return {@link #LITERAL}
-         * @see Object#toString()
-         */
-        public String toString() {
-            return LITERAL;
-        }
-    }
+    //---------------------------------------------------------< Path Elements >
-     * Once created, a PathElement object is immutable.
+     * Once created, a NameElement object is immutable.
-    public static class PathElement {
+    public abstract static class PathElement {
-        /**
-         * Creates a path element with the given qualified name.
-         * The created path element does not contain an explicit index.
-         *
-         * @param namespaceURI namespace URI
-         * @param localName    local name
-         */
-        private PathElement(String namespaceURI, String localName) {
-            this(new QName(namespaceURI, localName));
-        }
-
-        /**
-         * Creates a path element with the given qualified name and index.
-         *
-         * @param namespaceURI namespace URI
-         * @param localName    local name
-         * @param index        index
-         */
-        private PathElement(String namespaceURI, String localName, int index) {
-            this(new QName(namespaceURI, localName), index);
-        }
-
-        /**
-         * Creates a path element with the given qualified name.
-         * The created path element does not contain an explicit index.
-         *
-         * @param name qualified name
-         * @throws IllegalArgumentException if the name is <code>null</code>
-         */
-        private PathElement(QName name) throws IllegalArgumentException {
-            if (name == null) {
-                throw new IllegalArgumentException("name must not be null");
-            }
-            this.name = name;
-            this.index = INDEX_UNDEFINED;
-        }
-         * @throws IllegalArgumentException if the name is <code>null</code>
-        private PathElement(QName name, int index) throws IllegalArgumentException {
-            if (name == null) {
-                throw new IllegalArgumentException("name must not be null");
-            }
-            if (index < INDEX_DEFAULT) {
-                throw new IllegalArgumentException("index is 1-based");
-            }
+        private PathElement(QName name, int index) {
+         * Creates a new path element with the given qualified name and index.
+         * If the name is equals to the name of a special element, like the
+         * {@link PARENT_ELEMENT},{@link CURRENT_ELEMENT} or the
+         * {@link ROOT_ELEMENT}, then it's instance is returned.
+         * <p/>
+         * the private constructor must never be called but from these 2 methods.
+         *
+         * @param name the name of the element
+         * @return a path element
+         * @throws IllegalArgumentException if the name is <code>null</code>
+         */
+        public static PathElement create(QName name) {
+            if (name == null) {
+                throw new IllegalArgumentException("name must not be null");
+            } else if (name.equals(PARENT_ELEMENT.getName())) {
+                return PARENT_ELEMENT;
+            } else if (name.equals(CURRENT_ELEMENT.getName())) {
+                return CURRENT_ELEMENT;
+            } else if (name.equals(ROOT_ELEMENT.getName())) {
+                return ROOT_ELEMENT;
+            } else {
+                return new NameElement(name, INDEX_UNDEFINED);
+            }
+        }
+
+        /**
+         * Creates a new path element with the given qualified name and index.
+         * If the name is equals to the name of a special element, like the
+         * {@link PARENT_ELEMENT},{@link CURRENT_ELEMENT} or the
+         * {@link ROOT_ELEMENT}, then it's instance is returned.
+         * <p/>
+         * the private constructor must never be called but from these 2 methods.
+         *
+         * @param name  the name of the element
+         * @param index the 1-based index.
+         * @return a path element
+         * @throws IllegalArgumentException if the name is <code>null</code> or
+         *                                  if the given index is less than 1.
+         */
+        public static PathElement create(QName name, int index) {
+            if (index < INDEX_DEFAULT) {
+                throw new IllegalArgumentException("index is 1-based.");
+            } else if (name == null) {
+                throw new IllegalArgumentException("name must not be null");
+            } else if (name.equals(PARENT_ELEMENT.getName())) {
+                return PARENT_ELEMENT;
+            } else if (name.equals(CURRENT_ELEMENT.getName())) {
+                return CURRENT_ELEMENT;
+            } else if (name.equals(ROOT_ELEMENT.getName())) {
+                return ROOT_ELEMENT;
+            } else {
+                return new NameElement(name, index);
+            }
+        }
+
+        /**
-         * Returns <code>true</code> if this element denotes the <i>root</i> element,
-         * otherwise returns <code>false</code>.
-         *
-         * @return <code>true</code> if this element denotes the <i>root</i>
-         *         element; otherwise <code>false</code>
-         */
-        public boolean denotesRoot() {
-            return equals(ROOT_ELEMENT);
-        }
-
-        /**
-         * Returns <code>true</code> if this element denotes the <i>parent</i>
-         * ('..') element, otherwise returns <code>false</code>.
-         *
-         * @return <code>true</code> if this element denotes the <i>parent</i>
-         *         element; otherwise <code>false</code>
-         */
-        public boolean denotesParent() {
-            return equals(PARENT_ELEMENT);
-        }
-
-        /**
-         * Returns <code>true</code> if this element denotes the <i>current</i>
-         * ('.') element, otherwise returns <code>false</code>.
-         *
-         * @return <code>true</code> if this element denotes the <i>current</i>
-         *         element; otherwise <code>false</code>
-         */
-        public boolean denotesCurrent() {
-            return equals(CURRENT_ELEMENT);
-        }
-
-        /**
-         * Returns <code>true</code> if this element represents a regular name
-         * (i.e. neither root, '.' nor '..'), otherwise returns <code>false</code>.
-         *
-         * @return <code>true</code> if this element represents a regular name;
-         *         otherwise <code>false</code>
-         */
-        public boolean denotesName() {
-            return !denotesRoot() && !denotesParent() && !denotesCurrent();
-        }
-
-        /**
-                return new PathElement(name.getNamespaceURI(), name.getLocalName());
+                return new NameElement(name, INDEX_UNDEFINED);
-                return new PathElement(name.getNamespaceURI(), name.getLocalName(), index);
+                return new NameElement(name, index);
+
+        /**
+         * Returns <code>true</code> if this element denotes the <i>root</i> element,
+         * otherwise returns <code>false</code>.
+         *
+         * @return <code>true</code> if this element denotes the <i>root</i>
+         *         element; otherwise <code>false</code>
+         */
+        abstract public boolean denotesRoot();
+
+        /**
+         * Returns <code>true</code> if this element denotes the <i>parent</i>
+         * ('..') element, otherwise returns <code>false</code>.
+         *
+         * @return <code>true</code> if this element denotes the <i>parent</i>
+         *         element; otherwise <code>false</code>
+         */
+        abstract public boolean denotesParent();
+
+        /**
+         * Returns <code>true</code> if this element denotes the <i>current</i>
+         * ('.') element, otherwise returns <code>false</code>.
+         *
+         * @return <code>true</code> if this element denotes the <i>current</i>
+         *         element; otherwise <code>false</code>
+         */
+        abstract public boolean denotesCurrent();
+
+        /**
+         * Returns <code>true</code> if this element represents a regular name
+         * (i.e. neither root, '.' nor '..'), otherwise returns <code>false</code>.
+         *
+         * @return <code>true</code> if this element represents a regular name;
+         *         otherwise <code>false</code>
+         */
+        abstract public boolean denotesName();
+
+    }
+
+    public static final class RootElement extends PathElement {
+        // use a literal that is an illegal name character to avoid collisions
+        static final String LITERAL = "*";
+
+        private RootElement() {
+            super(QName.ROOT, Path.INDEX_UNDEFINED);
+        }
+
+        /**
+         * Returns false.
+         *
+         * @return false
+         * @see PathElement#denotesName()
+         */
+        public boolean denotesName() {
+            return false;
+        }
+
+        /**
+         * Returns true.
+         *
+         * @return true
+         * @see PathElement#denotesRoot()
+         */
+        public boolean denotesRoot() {
+            return true;
+        }
+
+        /**
+         * Returns false.
+         *
+         * @return false
+         * @see PathElement#denotesParent()
+         */
+        public boolean denotesParent() {
+            return false;
+        }
+
+        /**
+         * Returns false.
+         *
+         * @return false
+         * @see PathElement#denotesCurrent()
+         */
+        public boolean denotesCurrent() {
+            return false;
+        }
+
+        /**
+         * Returns the JCR name of this path element.
+         *
+         * @param resolver
+         * @return ""
+         */
+        public String toJCRName(NamespaceResolver resolver) {
+            return "";
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public void toJCRName(NamespaceResolver resolver, StringBuffer buf) {
+            // append empty string, i.e. nothing.
+        }
+
+        /**
+         * @return {@link #LITERAL}
+         * @see Object#toString()
+         */
+        public String toString() {
+            return LITERAL;
+        }
+    }
+
+
+    public static final class CurrentElement extends PathElement {
+        static final String LITERAL = ".";
+
+        private CurrentElement() {
+            super(new QName(QName.NS_DEFAULT_URI, LITERAL), Path.INDEX_UNDEFINED);
+        }
+
+        /**
+         * Returns false.
+         *
+         * @return false
+         * @see PathElement#denotesName()
+         */
+        public boolean denotesName() {
+            return false;
+        }
+
+        /**
+         * Returns false.
+         *
+         * @return false
+         * @see PathElement#denotesRoot()
+         */
+        public boolean denotesRoot() {
+            return false;
+        }
+
+        /**
+         * Returns false.
+         *
+         * @return false
+         * @see PathElement#denotesParent()
+         */
+        public boolean denotesParent() {
+            return false;
+        }
+
+        /**
+         * Returns true.
+         *
+         * @return true
+         * @see PathElement#denotesCurrent()
+         */
+        public boolean denotesCurrent() {
+            return true;
+        }
+
+        /**
+         * Returns the JCR name of this path element.
+         *
+         * @param resolver
+         * @return {@link #LITERAL}
+         */
+        public String toJCRName(NamespaceResolver resolver) {
+            return LITERAL;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public void toJCRName(NamespaceResolver resolver, StringBuffer buf) {
+            buf.append(LITERAL);
+        }
+
+        /**
+         * @return {@link #LITERAL}
+         * @see Object#toString()
+         */
+        public String toString() {
+            return LITERAL;
+        }
+    }
+
+    public static final class ParentElement extends PathElement {
+        static final String LITERAL = "..";
+
+        private ParentElement() {
+            super(new QName(QName.NS_DEFAULT_URI, LITERAL), Path.INDEX_UNDEFINED);
+        }
+
+        /**
+         * Returns false.
+         *
+         * @return false
+         * @see PathElement#denotesName()
+         */
+        public boolean denotesName() {
+            return false;
+        }
+
+        /**
+         * Returns false.
+         *
+         * @return false
+         * @see PathElement#denotesRoot()
+         */
+        public boolean denotesRoot() {
+            return false;
+        }
+
+        /**
+         * Returns true.
+         *
+         * @return true
+         * @see PathElement#denotesParent()
+         */
+        public boolean denotesParent() {
+            return true;
+        }
+
+        /**
+         * Returns false.
+         *
+         * @return false
+         * @see PathElement#denotesCurrent()
+         */
+        public boolean denotesCurrent() {
+            return false;
+        }
+
+        /**
+         * Returns the JCR name of this path element.
+         *
+         * @param resolver
+         * @return {@link #LITERAL}
+         */
+        public String toJCRName(NamespaceResolver resolver) {
+            return LITERAL;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public void toJCRName(NamespaceResolver resolver, StringBuffer buf) {
+            buf.append(LITERAL);
+        }
+
+        /**
+         * @return {@link #LITERAL}
+         * @see Object#toString()
+         */
+        public String toString() {
+            return LITERAL;
+        }
+    }
+
+    public static final class NameElement extends PathElement {
+
+        private NameElement(QName name, int index) {
+            super(name, index);
+        }
+
+        /**
+         * Returns true.
+         *
+         * @return true
+         * @see PathElement#denotesName()
+         */
+        public boolean denotesName() {
+            return true;
+        }
+
+        /**
+         * Returns false.
+         *
+         * @return false
+         * @see PathElement#denotesRoot()
+         */
+        public boolean denotesRoot() {
+            return false;
+        }
+
+        /**
+         * Returns false.
+         *
+         * @return false
+         * @see PathElement#denotesParent()
+         */
+        public boolean denotesParent() {
+            return false;
+        }
+
+        /**
+         * Returns false.
+         *
+         * @return false
+         * @see PathElement#denotesCurrent()
+         */
+        public boolean denotesCurrent() {
+            return false;
+        }

MOV55 INS31 INS31 INS31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 INS55 INS29 INS83 INS83 MOV43 INS42 INS44 INS8 INS29 INS83 INS83 MOV43 INS42 INS44 INS44 INS8 INS29 INS83 INS83 MOV43 INS42 INS44 INS44 INS8 MOV8 INS83 INS31 INS31 INS31 INS31 UPD83 INS31 INS83 INS83 INS83 INS42 MOV43 INS31 INS31 INS31 INS31 INS31 INS66 INS65 INS65 INS65 INS5 INS42 INS60 INS60 INS60 INS24 INS41 INS65 INS65 INS65 INS65 INS5 INS42 INS39 INS42 INS41 INS41 INS41 INS41 INS41 INS41 INS60 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS39 INS42 MOV25 INS25 MOV25 MOV60 INS60 INS24 MOV25 MOV41 INS60 INS60 INS60 INS61 INS29 INS43 UPD83 INS83 INS43 INS42 INS8 MOV29 UPD83 MOV83 INS83 MOV43 UPD42 MOV42 MOV44 MOV44 INS8 INS83 INS83 INS83 INS83 INS29 INS83 MOV43 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS8 INS83 INS42 MOV44 INS44 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS66 INS42 INS66 INS66 MOV43 INS85 INS5 INS59 INS39 INS59 INS39 INS59 MOV58 MOV27 MOV37 INS8 INS14 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS42 INS66 INS42 INS66 INS66 MOV43 INS85 INS14 INS16 INS16 INS16 UPD66 UPD66 INS16 UPD66 UPD66 UPD66 INS16 MOV43 INS59 INS66 INS42 INS42 INS66 INS42 INS66 INS65 INS66 INS42 INS27 INS8 INS8 MOV43 INS59 MOV58 MOV27 MOV37 MOV8 MOV32 MOV8 INS42 UPD66 INS83 INS39 INS59 INS39 INS59 INS39 INS59 INS27 INS8 INS65 INS42 INS21 UPD66 UPD65 MOV65 INS42 UPD43 UPD42 INS25 INS65 UPD65 UPD43 UPD42 INS25 INS65 INS65 INS65 INS43 INS42 INS41 INS65 INS43 INS42 INS43 INS42 INS65 INS65 INS43 INS42 INS43 INS42 INS21 INS65 INS43 INS42 INS43 INS42 INS21 INS39 INS42 INS46 INS65 INS65 INS65 INS41 INS65 INS65 INS65 INS41 INS65 INS65 INS65 INS41 INS65 INS65 INS65 INS41 MOV43 INS85 INS42 INS3 INS42 INS9 INS42 INS9 MOV60 INS25 MOV43 INS42 INS42 INS42 MOV43 INS42 INS42 INS42 INS32 INS32 INS42 INS32 MOV32 INS42 INS32 MOV32 INS42 INS32 MOV32 INS42 INS32 MOV32 INS42 INS32 INS67 INS40 INS42 INS40 INS41 INS41 INS42 INS42 MOV60 INS25 MOV42 UPD42 MOV53 INS42 INS13 INS42 INS34 INS42 INS32 INS42 INS34 MOV60 INS25 MOV21 MOV21 MOV21 INS65 INS48 UPD66 UPD66 INS65 INS66 INS65 INS66 INS65 INS66 INS66 INS66 UPD42 UPD66 UPD66 UPD42 MOV27 MOV8 INS25 UPD66 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS66 INS66 UPD42 UPD66 UPD42 UPD66 INS66 UPD42 INS66 UPD66 UPD42 MOV27 MOV8 INS25 INS40 INS66 INS42 INS66 INS42 INS45 INS65 INS42 INS42 INS14 INS40 INS68 INS65 INS42 INS42 INS32 INS14 INS40 INS65 INS42 INS42 INS32 INS42 INS42 INS66 INS66 INS68 INS9 INS66 INS66 INS68 INS9 INS66 INS66 INS68 INS9 INS66 INS66 INS68 INS9 INS5 INS40 INS27 INS8 INS32 INS42 INS42 UPD42 MOV42 INS33 UPD42 MOV42 INS42 INS32 INS42 INS32 MOV42 INS42 INS42 INS32 INS42 INS32 MOV42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 MOV27 MOV8 INS25 INS42 INS42 INS42 INS27 INS8 INS8 INS32 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS8 INS25 INS42 INS42 INS42 MOV27 MOV8 INS25 MOV43 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV43 INS85 INS7 INS32 INS32 INS21 INS21 MOV42 MOV42 INS33 MOV42 MOV42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV42 MOV42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV38 MOV25 MOV21 INS38 MOV8 INS42 INS34 INS21 INS21 INS21 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS41 INS32 INS8 INS25 INS32 INS8 INS25 INS42 INS2 MOV2 INS42 INS42 INS42 INS42 INS7 INS7 INS32 INS7 INS7 INS7 INS7 INS7 INS42 INS42 INS42 INS42 INS42 INS32 INS41 INS32 INS8 INS8 UPD45 INS42 INS42 INS32 INS41 INS32 INS8 INS25 INS43 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS32 INS42 INS27 INS16 INS42 INS42 INS32 MOV42 UPD42 MOV42 INS42 INS32 INS42 INS27 INS42 INS32 INS42 INS32 INS42 INS38 INS42 INS42 INS42 INS42 INS42 INS32 INS41 INS41 INS42 INS42 INS42 INS42 INS42 INS32 INS41 INS32 INS8 INS8 INS42 INS42 INS42 INS42 INS38 INS36 MOV32 INS42 MOV11 INS42 INS42 MOV7 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS34 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS32 INS41 INS41 INS32 INS27 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 UPD43 MOV43 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS38 UPD42 INS43 INS42 INS42 INS32 INS42 INS42 INS42 DEL40 DEL26 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL32 DEL41 DEL8 DEL42 DEL41 DEL8 DEL25 DEL42 DEL59 DEL60 DEL42 DEL32 DEL41 DEL8 DEL42 DEL41 DEL8 DEL25 DEL42 DEL59 DEL60 DEL42 DEL32 DEL41 DEL8 DEL42 DEL41 DEL8 DEL25 DEL42 DEL59 DEL60 DEL42 DEL32 DEL41 DEL8 DEL42 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL41 DEL8 DEL42 DEL41 DEL8 DEL25 DEL42 DEL42 DEL27 DEL42 DEL42 DEL14 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL14 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL33 DEL27 DEL33 DEL7 DEL25 DEL18 DEL27 DEL21 DEL42 DEL32 DEL21 DEL8 DEL25 DEL25 DEL42 DEL33 DEL59 DEL60 DEL24 DEL8 DEL40 DEL42 DEL43 DEL85 DEL5 DEL42 DEL13 DEL9 DEL32 DEL59 DEL60 DEL8 DEL24 DEL42 DEL14 DEL42 DEL42 DEL14 DEL42 DEL14 DEL42 DEL42 DEL14 DEL42 DEL44 DEL42 DEL42 DEL14 DEL42 DEL17 DEL8 DEL31 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL25 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL42 DEL43 DEL25 DEL25 DEL42 DEL42 DEL42 DEL43 DEL42 DEL44 DEL14 DEL17 DEL8 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL41 DEL8 DEL42 DEL42 DEL32 DEL41 DEL8 DEL42 DEL42 DEL32 DEL41 DEL8 DEL42 DEL32 DEL38 DEL42 DEL32 DEL38 DEL42 DEL32 DEL38 DEL27 DEL41 DEL8 DEL40 DEL42 DEL40 DEL42
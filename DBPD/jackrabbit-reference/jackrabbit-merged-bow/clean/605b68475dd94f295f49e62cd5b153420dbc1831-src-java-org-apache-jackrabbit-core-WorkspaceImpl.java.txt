Workspace.clone(...,removeExisting=true) & Workspace.importXML(..., IMPORT_UUID_COLLISION_REMOVE_EXISTING) potentially leaves repository in inconsistent state

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@160781 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.List;
-     * Checks if removing the given target node is allowed in the current
-     * context.
+     * Checks if removing the given target node entirely (i.e. unlinking from
+     * all its parents) is allowed in the current context.
+        List parentUUIDs = targetState.getParentUUIDs();
+        Iterator iter = parentUUIDs.iterator();
+        while (iter.hasNext()) {
+            NodeId parentId = new NodeId((String) iter.next());
+            checkRemoveNode(targetState, parentId, options);
+        }
+    }
+
+    /**
+     * Checks if removing the given target node from the specifed parent
+     * is allowed in the current context.
+     *
+     * @param targetState
+     * @param parentId
+     * @param options     bit-wise OR'ed flags specifying the checks that should be
+     *                    performed; any combination of the following constants:
+     *                    <ul>
+     *                    <li><code>{@link #CHECK_ACCESS}</code>: make sure
+     *                    current session is granted read access on parent
+     *                    and remove privilege on target node</li>
+     *                    <li><code>{@link #CHECK_LOCK}</code>: make sure
+     *                    there's no foreign lock on parent node</li>
+     *                    <li><code>{@link #CHECK_VERSIONING}</code>: make sure
+     *                    parent node is checked-out</li>
+     *                    <li><code>{@link #CHECK_CONSTRAINTS}</code>:
+     *                    make sure no node type constraints would be violated</li>
+     *                    <li><code>{@link #CHECK_REFERENCES}</code>:
+     *                    make sure no references exist on target node</li>
+     *                    </ul>
+     * @throws ConstraintViolationException
+     * @throws AccessDeniedException
+     * @throws VersionException
+     * @throws LockException
+     * @throws ItemNotFoundException
+     * @throws ReferentialIntegrityException
+     * @throws RepositoryException
+     */
+    public void checkRemoveNode(NodeState targetState, NodeId parentId,
+                                int options)
+            throws ConstraintViolationException, AccessDeniedException,
+            VersionException, LockException, ItemNotFoundException,
+            ReferentialIntegrityException, RepositoryException {
-        NodeId parentId = new NodeId(targetState.getParentUUID());
-     * Recursively removes the specified node state including its properties and
-     * child nodes.
+     * Unlinks the specified node state from all its parents and recursively
+     * removes it including its properties and child nodes.
+     * <p/>
+     * <b>Precondition:</b> the state manager of this workspace needs to be in
+     * edit mode.
+     * todo duplicate code in WorkspaceImporter; consolidate in WorkspaceOperations class
+     *
+     * @param targetState
+     * @throws RepositoryException if an error occurs
+     */
+    private void removeNodeState(NodeState targetState)
+            throws RepositoryException {
+
+        // copy list to avoid ConcurrentModificationException
+        ArrayList parentUUIDs = new ArrayList(targetState.getParentUUIDs());
+        Iterator iter = parentUUIDs.iterator();
+        while (iter.hasNext()) {
+            String parentUUID = (String) iter.next();
+            NodeId parentId = new NodeId(parentUUID);
+
+            // unlink node state from this parent
+            unlinkNodeState(targetState, parentUUID);
+
+            // remove child node entries
+            NodeState parent = getNodeState(parentId);
+            // use temp array to avoid ConcurrentModificationException
+            ArrayList tmp =
+                    new ArrayList(parent.getChildNodeEntries(targetState.getUUID()));
+            // remove from tail to avoid problems with same-name siblings
+            for (int i = tmp.size() - 1; i >= 0; i--) {
+                NodeState.ChildNodeEntry entry = (NodeState.ChildNodeEntry) tmp.get(i);
+                parent.removeChildNodeEntry(entry.getName(), entry.getIndex());
+            }
+            // store parent
+            stateMgr.store(parent);
+        }
+    }
+
+    /**
+     * Unlinks the given node state from the specified parent i.e. removes
+     * <code>parentUUID</code> from its list of parents. If as a result
+     * the given node state would be orphaned it will be recursively removed
+     * including its properties and child nodes.
+     * <p/>
+     * Note that the child node entry refering to <code>targetState</code> is
+     * <b><i>not</i></b> automatically removed from <code>targetState</code>'s
+     * parent denoted by <code>parentUUID</code>.
-    private void removeNodeState(NodeState targetState, String parentUUID)
+    private void unlinkNodeState(NodeState targetState, String parentUUID)
-                    // check if existing can be removed
-                    checkRemoveNode(nodeState, CHECK_ACCESS | CHECK_LOCK
-                            | CHECK_VERSIONING);
-                    // remove child node (recursive)
-                    removeNodeState(nodeState, targetState.getUUID());
+                    // check if child node can be removed
+                    // (access rights, locking & versioning status)
+                    checkRemoveNode(nodeState, (NodeId) targetState.getId(),
+                            CHECK_ACCESS | CHECK_LOCK | CHECK_VERSIONING);
+                    // unlink child node (recursive)
+                    unlinkNodeState(nodeState, targetState.getUUID());
-                    PropertyState propState = (PropertyState) stateMgr.getItemState(propId);
+                    PropertyState propState =
+                            (PropertyState) stateMgr.getItemState(propId);
+                        // make sure existing node is not the parent
+                        // or an ancestor thereof
+                        NodeId newParentId = new NodeId(parentUUID);
+                        Path p0 = hierMgr.getPath(newParentId);
+                        Path p1 = hierMgr.getPath(id);
+                        try {
+                            if (p1.equals(p0) || p1.isAncestorOf(p0)) {
+                                String msg = "cannot remove ancestor node";
+                                log.debug(msg);
+                                throw new RepositoryException(msg);
+                            }
+                        } catch (MalformedPathException mpe) {
+                            // should never get here...
+                            String msg = "internal error: failed to determine degree of relationship";
+                            log.error(msg, mpe);
+                            throw new RepositoryException(msg, mpe);
+                        }
+
+
-                        removeNodeState(existingState, existingState.getParentUUID());
+                        removeNodeState(existingState);
-        checkRemoveNode(targetState, CHECK_ACCESS | CHECK_LOCK
-                | CHECK_VERSIONING | CHECK_CONSTRAINTS);
+        checkRemoveNode(targetState, (NodeId) srcParentState.getId(),
+                CHECK_ACCESS | CHECK_LOCK | CHECK_VERSIONING | CHECK_CONSTRAINTS);

INS26 INS40 INS31 INS31 MOV29 INS83 INS39 INS42 INS44 INS44 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS8 INS29 INS44 INS29 INS83 INS39 INS42 INS44 INS43 INS8 UPD42 INS43 INS42 INS39 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS60 INS60 INS61 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS65 INS65 INS65 INS43 INS42 INS42 INS60 INS60 INS61 UPD66 UPD66 INS42 INS43 INS59 INS43 INS59 INS32 INS8 INS66 INS66 INS42 INS42 INS42 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS66 INS42 INS43 INS59 INS43 INS59 INS32 INS8 UPD66 INS66 INS66 UPD66 INS66 INS66 INS66 INS66 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS60 INS21 INS67 INS67 INS67 INS67 INS67 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS60 INS60 INS21 INS60 INS60 INS24 INS21 INS11 INS42 INS42 INS42 INS42 MOV43 INS59 INS32 INS42 INS42 INS42 INS42 INS42 INS43 INS32 INS42 INS42 INS43 INS59 INS43 INS59 INS32 INS43 INS59 INS43 INS59 INS58 INS27 INS37 INS8 INS32 INS43 INS32 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS14 INS39 INS59 INS42 INS34 INS42 INS60 INS21 INS42 INS42 INS42 INS8 INS42 INS42 INS42 MOV43 INS11 INS43 INS32 INS43 INS42 INS42 INS42 INS43 MOV32 INS42 INS27 INS43 INS59 INS32 MOV60 INS60 INS60 INS60 INS54 MOV21 INS21 INS43 INS32 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS32 INS34 INS40 INS42 INS11 INS42 INS42 INS32 INS32 INS43 INS59 INS43 INS59 INS43 INS59 INS8 INS12 INS32 INS42 INS42 INS42 INS42 INS42 INS43 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS32 INS25 INS44 INS8 INS42 INS42 INS40 INS42 INS42 INS42 INS11 INS42 INS42 INS32 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS8 INS43 INS42 INS60 MOV21 INS53 INS43 INS32 INS42 INS42 INS42 INS32 INS32 INS60 INS21 INS53 INS42 INS43 INS59 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS14 INS42 INS42 INS45 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 INS43 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS43 INS42 INS42 INS42 DEL42 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL32 DEL8
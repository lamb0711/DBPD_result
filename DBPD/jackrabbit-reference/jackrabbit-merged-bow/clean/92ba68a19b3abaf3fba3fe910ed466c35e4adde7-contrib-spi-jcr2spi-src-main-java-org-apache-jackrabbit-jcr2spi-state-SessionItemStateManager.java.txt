- Remove TransientItemStateListener
- Create property states and child node states on NodeState

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@430020 13f79535-47bb-0310-9956-ffa450edef68

-            // notify uncovering of transient state
-            transientState.notifyStateUncovering();
-            switch (transientState.getStatus()) {
-                case ItemState.STATUS_STALE_MODIFIED:
-                case ItemState.STATUS_STALE_DESTROYED:
-                case ItemState.STATUS_EXISTING_MODIFIED:
-                    transientState.notifyStateUncovering();
-            }
-        NodeState srcState = create(getNodeState(operation.getNodeId()));
-        NodeState srcParent = create(getNodeState(operation.getSourceParentId()));
+        NodeState srcState = getNodeState(operation.getNodeId());
+        NodeState srcParent = getNodeState(operation.getSourceParentId());
-        NodeState destParent = create(getNodeState(operation.getDestinationParentId()));
+        NodeState destParent = getNodeState(operation.getDestinationParentId());
-        // store states
-        store(srcState);
-        if (renameOnly) {
-            store(srcParent);
-        } else {
-            store(srcParent);
-            store(destParent);
-        }
-
-        NodeState nState = create(getNodeState(operation.getNodeId()));
+        NodeState nState = getNodeState(operation.getNodeId());
-            } else {
-                // alternative: make sure changes on nodeState are reflected in state manager.
-                store(nState);
-        // make sure the parent state is modifiable
-        NodeState parent = create(getNodeState(operation.getParentId()));
+        NodeState parent = getNodeState(operation.getParentId());
+        // TODO: do not set whole list but rather implement a proper reorder on NodeState!
+        // TODO: then remove NodeState.setChildNodeEntries()
-        // ... and mark it as modified on the stateMgr.
-        store(parent);
-        // assert transient parent state
-        NodeState parentState = create(parent);
-        PropertyState propState = createNew(propertyName, parentState);
+        PropertyState propState = transientStateMgr.createPropertyState(parent, propertyName);
-
-        // now add new property entry to parent
-        parentState.addPropertyName(propertyName);
-        // store parent
-        store(parentState);
-        // store property
-        store(propState);
-        // assert parent state is transient
-        NodeState parentState = create(parent);
-        // ev. create new id
-        NodeId newId = (uuid == null) ? idFactory.createNodeId(UUID.randomUUID().toString()) : idFactory.createNodeId(uuid);
-        NodeState nodeState = createNew(newId, nodeTypeName, parentState);
+        NodeState nodeState = transientStateMgr.createNodeState(nodeName, uuid, nodeTypeName, parent);
-        // now add new child node entry to parent
-        parentState.addChildNodeEntry(nodeName, newId);
-
-
-        // store node
-        store(nodeState);
-        // store parent
-        store(parentState);
-            // assert parent is transient state
-            NodeState parent = create(itemState.getParent());
+            NodeState parent = itemState.getParent();
-            // store parent
-            // DIFF JR: only store parent if removal is successful... check if correct.
-            store(parent);
-        NodeState modifiableTarget = create(target);
+        // TODO: implement this functionality in NodeState. i.e. target.remove()
-        parent.removeChildNodeEntry(modifiableTarget.getNodeId());
+        parent.removeChildNodeEntry(target.getNodeId());
-        recursiveRemoveNodeState(modifiableTarget);
+        recursiveRemoveNodeState(target);
-        PropertyState modifiableTarget = create(target);
+        // TODO: implement this functionality in PropertyState. i.e. target.remove()
-        parent.removePropertyName(modifiableTarget.getQName());
+        parent.removePropertyName(target.getQName());
-        destroy(modifiableTarget);
+        destroy(target);
-        // make sure the state is modifiable
-        PropertyState propertyState = create(propState);
-
-        QValue[] oldValues = propertyState.getValues();
+        QValue[] oldValues = propState.getValues();
-        propertyState.setValues(iva);
-        propertyState.setType(valueType);
-
-        // store property
-        store(propertyState);
-    }
-
-    /**
-     * Creates a {@link NodeState} instance representing new,
-     * i.e. not yet existing state. Call {@link #store}
-     * on the returned object to make it persistent.
-     *
-     * @param id           the id of the node
-     * @param nodeTypeName qualified node type name
-     * @param parent     parent node's id
-     * @return a node state
-     * @throws IllegalStateException if the manager is not in edit mode.
-     */
-    private NodeState createNew(NodeId id, QName nodeTypeName, NodeState parent)
-            throws IllegalStateException {
-        // DIFF JACKRABBIT: return workspaceItemStateMgr.createNew(id, nodeTypeName, parentId);
-        return transientStateMgr.createNodeState(id, nodeTypeName, parent);
-    }
-
-    /**
-     * Creates a modifiable {@link NodeState} instances representing an existing
-     * <code>state</code>. Call {@link #store(ItemState)} on the returned
-     * object to make it persistent.
-     * <p/>
-     * If <code>state</code> is a transient state, it is immediately returned.
-     * Otherwise, after a transient state has been created that overlays
-     * <code>state</code> {@link TransientItemStateListener} registered on
-     * <code>state</code> are notified about the overlay via the the callback
-     * {@link TransientItemStateListener#stateOverlaid(ItemState)}.
-     *
-     * @param state the node as retrieved with {@link #getItemState(ItemId)}
-     * @return a modifiable {@link NodeState}.
-     */
-    private NodeState create(NodeState state) {
-        if (state.isTransient()) {
-            // already transient state
-            return state;
-        }
-        NodeState transientState = transientStateMgr.createNodeState(state);
-        state.notifyStateOverlaid(transientState);
-        return transientState;
-    }
-
-    /**
-     * Creates a {@link PropertyState} instance representing new,
-     * i.e. not yet existing state. Call {@link #store}
-     * on the returned object to make it persistent.
-     *
-     * @param propName   qualified property name
-     * @param parent   parent node state
-     * @return a property state
-     */
-    private PropertyState createNew(QName propName, NodeState parent) {
-        // DIFF JACKRABBIT: return workspaceItemStateMgr.createNew(propName, parentId);
-        return transientStateMgr.createPropertyState(parent, propName);
-    }
-
-    /**
-     * Creates a modifiable {@link PropertyState} instances representing an existing
-     * <code>state</code>. Call {@link #store(ItemState)} on the returned
-     * object to make it persistent.
-     * <p/>
-     * If <code>state</code> is a transient state, it is immediately returned.
-     * Otherwise, after a transient state has been created that overlays
-     * <code>state</code> {@link TransientItemStateListener} registered on
-     * <code>state</code> are notified about the overlay via the the callback
-     * {@link TransientItemStateListener#stateOverlaid(ItemState)}.
-     *
-     * @param state the node as retrieved with {@link #getItemState(ItemId)}
-     * @return a modifiable {@link PropertyState}.
-     */
-    private PropertyState create(PropertyState state) {
-        if (state.isTransient()) {
-            // already transient state
-            return state;
-        }
-        PropertyState transientState = transientStateMgr.createPropertyState(state);
-        state.notifyStateOverlaid(transientState);
-        return transientState;
-    }
-
-    /**
-     * Store the given item state, which may be a new one previously created by
-     * calling <code>createNew</code> or a modified existing state.
-     *
-     * @param state item state that should be stored
-     */
-    private void store(ItemState state) throws IllegalStateException {
-        // DIFF JACKRABBIT: workspaceItemStateMgr.store(state);
-        if (state.getStatus() == ItemState.STATUS_EXISTING_MODIFIED) {
-            transientStateMgr.modified(state);
-        } else if (state.getStatus() == ItemState.STATUS_NEW) {
-            transientStateMgr.added(state);
-        } else {
-            // todo throw InvalidItemStateException?
-            throw new IllegalStateException("invalid state: " + state.getStatus());
-        }
+        propState.setValues(iva);
+        propState.setType(valueType);

MOV43 MOV32 MOV32 MOV32 MOV32 MOV32 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL40 DEL49 DEL40 DEL49 DEL40 DEL49 DEL42 DEL42 DEL32 DEL21 DEL50 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL33 DEL27 DEL36 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL42 DEL42 DEL42 DEL32 DEL16 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL66 DEL42 DEL65 DEL66 DEL66 DEL42 DEL67 DEL65 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL66 DEL42 DEL65 DEL66 DEL66 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL42 DEL65 DEL66 DEL66 DEL42 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL66 DEL65 DEL42 DEL66 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL65 DEL66 DEL42 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL66 DEL42 DEL65 DEL66 DEL66 DEL42 DEL67 DEL65 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL66 DEL42 DEL65 DEL66 DEL66 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL42 DEL65 DEL66 DEL66 DEL42 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL66 DEL65 DEL42 DEL66 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL65 DEL66 DEL42 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL32 DEL40 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL40 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL45 DEL42 DEL42 DEL32 DEL27 DEL14 DEL53 DEL8 DEL25 DEL25 DEL8 DEL31
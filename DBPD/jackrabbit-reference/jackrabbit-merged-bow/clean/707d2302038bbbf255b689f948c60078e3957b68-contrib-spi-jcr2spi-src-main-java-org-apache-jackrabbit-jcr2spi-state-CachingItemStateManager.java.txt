Remove PathMap from CachingItemStateManager and use linked ItemState hierarchy instead.
Add secondary LRUMap to CachingItemStateManager which keeps a fixed amount of hard references to most recently used ItemStates. Still nedds some improvements. See todo in NodeState.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@428714 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.util.PathMap;
-import org.apache.jackrabbit.name.MalformedPathException;
-import org.apache.jackrabbit.spi.PropertyId;
+import org.apache.commons.collections.map.ReferenceMap;
+import org.apache.commons.collections.map.LRUMap;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
-import java.util.HashMap;
+     * The logger instance for this class.
+     */
+    private static Logger log = LoggerFactory.getLogger(CachingItemStateManager.class);
+
+    /**
-    private final Map uuid2PathElement;
+    private final Map uuid2NodeState;
-     * Maps a path to an {@link ItemState}.
+     * Map of recently used <code>ItemState</code>.
-    private final PathMap path2State;
+    private final Map recentlyUsed;
+
+    /**
+     * The root node of the workspace.
+     */
+    private final NodeState root;
-    public CachingItemStateManager(ItemStateFactory isf, IdFactory idFactory) {
+    /**
+     * Creates a new <code>CachingItemStateManager</code>.
+     *
+     * @param isf       the item state factory to create item state instances.
+     * @param idFactory the id factory.
+     * @throws NoSuchItemStateException if the root node cannot be obtained.
+     * @throws ItemStateException       if any other error occurs while
+     *                                  obtaining the root node.
+     */
+    public CachingItemStateManager(ItemStateFactory isf, IdFactory idFactory)
+            throws ItemStateException, NoSuchItemStateException {
-        this.uuid2PathElement = new HashMap(); // TODO: must use weak references
-        path2State = new PathMap();      // TODO: must use weak references
+        this.uuid2NodeState = new ReferenceMap(ReferenceMap.HARD, ReferenceMap.WEAK);
+        this.recentlyUsed = new LRUMap(1000); // TODO: make configurable
+        // initialize root
+        root = isf.createNodeState(idFactory.createNodeId((String) null, Path.ROOT), this);
-        return (ItemState) getPathElement(id).get();
+        return resolve(id);
-            getPathElement(id);
+            resolve(id);
-                    PathMap.Element elem = lookup(itemId);
-                    if (elem != null) {
+                    state = lookup(itemId);
+                    if (state != null) {
-                        state = (ItemState) elem.get();
-                        if (itemId.denotesNode()) {
-                            elem.set(null);
-                        } else {
-                            elem.remove();
-                        }
-                        if (state != null) {
-                            state.discard();
-                        }
+                        recentlyUsed.remove(state);
+                        state.discard();
-                    elem = lookup(parentId);
-                    if (elem != null) {
+                    parent = (NodeState) lookup(parentId);
+                    if (parent != null) {
-                        parent = (NodeState) elem.get();
-                        if (parent != null) {
-                            parent.discard();
-                            elem.set(null);
-                        }
+                        recentlyUsed.remove(parent);
+                        parent.discard();
-                    elem = lookup(itemId);
-                    if (elem != null) {
-                        state = (ItemState) elem.get();
+                    state = lookup(itemId);
+                    if (state != null) {
-                                uuid2PathElement.remove(itemId.getUUID());
+                                uuid2NodeState.remove(itemId.getUUID());
-
-                        elem.remove();
-
-                        if (state != null) {
-                            state.notifyStateDestroyed();
-                        }
+                        recentlyUsed.remove(state);
+                        state.notifyStateDestroyed();
-                    elem = lookup(parentId);
-                    if (elem != null && elem.get() != null) {
-                        parent = (NodeState) elem.get();
+                    state = lookup(parentId);
+                    if (state != null) {
+                        parent = (NodeState) state;
+                            recentlyUsed.remove(parent);
-                            elem.set(null);
-                    elem = lookup(itemId);
+                    state = lookup(itemId);
-                    if (elem != null) {
-                        state = (ItemState) elem.get();
+                    if (state != null) {
+                        recentlyUsed.remove(state);
-                        elem.remove();
-     * Returns the PathMap.Element which holds the ItemState with
-     * <code>id</code>. The returned <code>PathMap.Element</code> is guaranteed
-     * to reference an <code>ItemState</code> calling {@link
-     * PathMap.Element#get()};
+     * Called whenever an item state is accessed. Calling this method will update
+     * the LRU map which keeps track of most recently used item states.
-     * @param id the id of the item state.
-     * @return the PathElement.Element.
-     * @throws NoSuchItemStateException if there is no ItemState with this id.
-     * @throws ItemStateException       if another error occurs.
+     * @param state the touched state.
-    private PathMap.Element getPathElement(ItemId id)
-            throws NoSuchItemStateException, ItemStateException {
-        String uuid = id.getUUID();
-        Path relPath = id.getRelativePath();
-        PathMap.Element elem = null;
-
-        // first get PathElement of uuid part
-        if (uuid != null) {
-            elem = (PathMap.Element) uuid2PathElement.get(uuid);
-            if (elem == null || elem.get() == null) {
-                // state identified by the uuid is not yet cached -> get from ISM
-                NodeId refId = (relPath == null) ? (NodeId) id : idFactory.createNodeId(uuid);
-                NodeState state = isf.createNodeState(refId, this);
-
-                // put this state to cache
-                // but first we have to make sure that the parent of this state
-                // is already cached
-
-                if (state.getParentId() == null) {
-                    // shortcut for the root node
-                    elem = path2State.map(Path.ROOT, true);
-                    elem.set(state);
-                    uuid2PathElement.put(uuid, elem);
-                    return elem;
-                } else {
-                    // get element of parent this will force loading of
-                    // parent into cache if needed
-                    PathMap.Element parentElement = getPathElement(state.getParentId());
-                    // create path element if necessary
-                    if (elem == null) {
-                        Path.PathElement[] elements = new Path.PathElement[]{
-                            getNameElement((NodeState) parentElement.get(), state)};
-                        Path p = null;
-                        try {
-                            p = new Path.PathBuilder(elements).getPath();
-                        } catch (MalformedPathException e) {
-                            // elements is never empty
-                        }
-                        elem = parentElement.getDescendant(p, false);
-                    }
-                    elem.set(state);
-                    // now put current state to cache
-                    uuid2PathElement.put(uuid, elem);
-                }
-            }
-        }
-
-        // at this point we are guaranteed to have an element
-        // now resolve relative path part of id if there is one
-        if (relPath != null) {
-            PathMap.Element tmp = elem.getDescendant(relPath, true);
-            if (tmp == null || tmp.get() == null) {
-                // not yet cached, load from isf
-                ItemState state;
-                if (id.denotesNode()) {
-                    state = isf.createNodeState((NodeId) id, this);
-                } else {
-                    state = isf.createPropertyState((PropertyId) id, this);
-                }
-                // put to cache
-                if (tmp == null) {
-                    tmp = elem.getDescendant(relPath, false);
-                }
-                tmp.set(state);
-            }
-            elem = tmp;
-        }
-        return elem;
+    private void touch(ItemState state) {
+        recentlyUsed.put(state, state);
-     * Looks up the <code>Element</code> with id but does not try to load the
+     * Resolves the id into an <code>ItemState</code>.
+     *
+     * @param id the id of the <code>ItemState</code> to resolve.
+     * @return the <code>ItemState</code>.
+     * @throws NoSuchItemStateException if there is no <code>ItemState</code>
+     *                                  with <code>id</code>
+     * @throws ItemStateException       if any other error occurs.
+     */
+    private ItemState resolve(ItemId id) throws NoSuchItemStateException, ItemStateException {
+        String uuid = id.getUUID();
+        Path relPath = id.getRelativePath();
+
+        NodeState nodeState = null;
+        // resolve uuid part
+        if (uuid != null) {
+            nodeState = (NodeState) uuid2NodeState.get(uuid);
+            if (nodeState == null) {
+                // state identified by the uuid is not yet cached -> get from ISM
+                NodeId refId = (relPath == null) ? (NodeId) id : idFactory.createNodeId(uuid);
+                nodeState = isf.createNodeState(refId, this);
+                uuid2NodeState.put(uuid, nodeState);
+            }
+        }
+
+        ItemState s = nodeState;
+        if (relPath != null) {
+            s = PathResolver.resolve(nodeState, relPath);
+        }
+        touch(s);
+        return s;
+    }
+
+    /**
+     * Looks up the <code>ItemState</code> with id but does not try to load the
-     * @return the cached <code>Element</code> or <code>null</code> if it is not
+     * @return the cached <code>ItemState</code> or <code>null</code> if it is not
-    private PathMap.Element lookup(ItemId id) {
-        PathMap.Element elem;
+    private ItemState lookup(ItemId id) {
+        ItemState state;
-            elem = (PathMap.Element) uuid2PathElement.get(id.getUUID());
-            if (elem == null) {
+            state = (ItemState) uuid2NodeState.get(id.getUUID());
+            if (state == null) {
-            elem = path2State.map(Path.ROOT, false);
+            state = root;
-            elem = elem.getDescendant(id.getRelativePath(), true);
-        }
-
-        return elem;
-    }
-
-    /**
-     * Returns the name of <code>state</code> starting from
-     * <code>parent</code>. This method only works for a direct parent of
-     * <code>state</code>.
-     *
-     * @param parent the parent of <code>state</code>.
-     * @param state the state.
-     * @return the name element for <code>state</code> starting from
-     * <code>parent</code>
-     * @throws ItemStateException if an error occurs
-     */
-    private static Path.PathElement getNameElement(NodeState parent, ItemState state)
-            throws ItemStateException {
-        if (state.isNode()) {
-            ChildNodeEntry entry = parent.getChildNodeEntry((NodeId) state.getId());
-            if (entry == null) {
-                throw new ItemStateException("No child node entry " +
-                        state.getId() + " found in " + parent.getId());
-            } else {
-                return Path.create(entry.getName(), entry.getIndex()).getNameElement();
+            try {
+                state = PathResolver.lookup(state, id.getRelativePath());
+            } catch (ItemStateException e) {
+                log.warn("exception while looking up state with id: " + id);
+                return null;
-        } else {
-            return state.getId().getRelativePath().getNameElement();
+
+        return state;

MOV26 MOV26 MOV26 MOV26 MOV23 MOV31 UPD40 UPD40 UPD40 UPD40 INS23 INS23 INS31 INS31 UPD83 UPD43 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS83 MOV43 INS59 MOV29 UPD83 MOV83 INS42 MOV44 MOV44 MOV43 INS43 INS8 INS29 INS83 INS39 INS42 MOV44 INS8 MOV43 UPD42 MOV44 MOV43 MOV43 MOV43 UPD42 INS42 INS32 UPD42 INS65 UPD42 MOV42 INS42 INS65 INS42 UPD65 INS42 MOV21 MOV21 MOV21 MOV21 MOV21 INS65 INS65 MOV21 UPD65 UPD65 MOV60 MOV60 INS60 INS25 INS60 INS25 INS21 INS41 MOV60 UPD66 INS42 INS42 INS57 INS66 INS66 UPD66 UPD42 UPD66 INS42 UPD66 UPD66 UPD66 INS66 INS32 INS66 INS66 INS42 INS66 UPD66 UPD42 UPD66 UPD66 INS42 UPD66 UPD66 UPD66 MOV43 INS59 MOV27 INS8 MOV43 INS59 MOV27 INS8 INS32 INS42 UPD66 UPD66 INS8 UPD42 INS43 INS22 INS14 INS22 INS14 UPD42 UPD42 MOV42 MOV42 UPD42 UPD42 INS42 INS42 INS33 INS21 INS25 INS42 INS42 INS21 UPD42 MOV42 UPD42 MOV42 INS54 INS42 INS52 INS42 INS43 INS40 INS40 INS52 INS42 UPD43 MOV43 INS34 INS32 INS21 MOV25 MOV25 INS7 MOV27 MOV8 INS7 MOV8 INS12 INS42 INS42 INS42 INS42 MOV11 INS40 UPD42 MOV7 MOV21 MOV27 INS27 MOV21 INS42 INS11 UPD42 MOV60 INS21 INS21 INS42 INS32 UPD42 UPD42 INS42 INS42 INS44 INS8 UPD43 INS33 MOV32 INS21 UPD42 INS11 UPD42 MOV21 UPD42 UPD42 MOV42 MOV33 UPD42 UPD42 MOV43 MOV32 INS7 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV43 MOV43 INS42 INS21 INS41 UPD42 INS32 MOV43 MOV32 MOV21 UPD42 UPD42 INS42 INS42 MOV32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS32 INS33 INS42 INS42 INS42 UPD42 INS42 UPD42 UPD42 INS42 UPD42 INS42 UPD42 UPD42 INS42 INS42 INS42 INS27 INS42 INS45 INS42 UPD42 INS42 UPD42 UPD42 DEL66 DEL42 DEL65 DEL42 DEL66 DEL66 DEL40 DEL42 DEL68 DEL65 DEL66 DEL42 DEL42 DEL42 DEL40 DEL9 DEL32 DEL40 DEL42 DEL42 DEL14 DEL42 DEL32 DEL42 DEL83 DEL42 DEL52 DEL42 DEL22 DEL43 DEL14 DEL7 DEL21 DEL42 DEL42 DEL43 DEL14 DEL7 DEL21 DEL8 DEL31 DEL32 DEL42 DEL32 DEL11 DEL42 DEL42 DEL32 DEL11 DEL40 DEL43 DEL42 DEL59 DEL60 DEL42 DEL33 DEL27 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL33 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL33 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL8 DEL25 DEL27 DEL42 DEL42 DEL32 DEL33 DEL27 DEL27 DEL42 DEL42 DEL32 DEL33 DEL42 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL40 DEL43 DEL42 DEL40 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL40 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL33 DEL27 DEL27 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL8 DEL40 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL40 DEL43 DEL85 DEL5 DEL42 DEL40 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL11 DEL42 DEL32 DEL4 DEL3 DEL59 DEL60 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL40 DEL43 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL33 DEL27 DEL27 DEL42 DEL42 DEL32 DEL8 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL52 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL66 DEL66 DEL42 DEL83 DEL40 DEL43 DEL42 DEL44 DEL45 DEL32 DEL45 DEL32 DEL27 DEL14 DEL53 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL43 DEL11 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL32 DEL32 DEL32 DEL41 DEL8 DEL25 DEL8 DEL32 DEL42 DEL32 DEL42 DEL32 DEL41 DEL8 DEL25 DEL40 DEL43 DEL40 DEL43 DEL42 DEL59 DEL60 DEL40 DEL43 DEL42 DEL42 DEL42 DEL40 DEL9 DEL32 DEL9
JCR-3000 SQL2 Join with OR clause still has some issues

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1143477 13f79535-47bb-0310-9956-ffa450edef68

-    
+
-    private static final Logger log = LoggerFactory.getLogger(QueryEngine.class);
+    private static final Logger log = LoggerFactory
+            .getLogger(QueryEngine.class);
-        
+
-                throw new RuntimeException(
-                        "Unable to compare rows " + a + " and " + b, e);
+                throw new RuntimeException("Unable to compare rows " + a
+                        + " and " + b, e);
-        if (log.isDebugEnabled()) {
-            time = System.currentTimeMillis() - time;
-            log.debug("SQL2 QUERY execute took " + time + " ms.");
-        }
+        log.debug("SQL2 QUERY execute took {} ms.", System.currentTimeMillis()
+                - time);
-            if (log.isDebugEnabled()) {
-                log.debug(genString(printIndentation)
-                        + "SQL2 RIGHT OUTER JOIN transformed to LEFT OUTER JOIN.");
-            }
+            log.debug(
+                    "{} SQL2 RIGHT OUTER JOIN transformed to LEFT OUTER JOIN.",
+                    genString(printIndentation));
-        long timeJoinLeftSide = System.currentTimeMillis();
+        boolean isOuterJoin = JCR_JOIN_TYPE_LEFT_OUTER.equalsIgnoreCase(join
+                .getJoinType());
+        QueryResult result = execute(merger, csInfo, isOuterJoin,
+                printIndentation);
+
+        long sort = System.currentTimeMillis();
+        QueryResult sortedResult = sort(result, orderings, evaluator, offset,
+                limit);
+        log.debug(" {} SQL2 SORT took {} ms.", genString(printIndentation),
+                System.currentTimeMillis() - sort);
+        return sortedResult;
+    }
+
+    protected QueryResult execute(JoinMerger merger,
+            ConstraintSplitInfo csInfo, boolean isOuterJoin,
+            int printIndentation) throws RepositoryException {
+
+        long timeJoinLeftSide = System.currentTimeMillis();
+
+        if (csInfo.isMultiple()) {
+            log.debug("{} SQL2 JOIN execute: there are multiple inner splits.",
+                    genString(printIndentation));
+
+            // first branch
+            long bTime = System.currentTimeMillis();
+            QueryResult branch1 = execute(merger,
+                    csInfo.getLeftInnerConstraints(), isOuterJoin,
+                    printIndentation + printIndentStep);
+            Set<Row> allRows = new TreeSet<Row>(new RowPathComparator(
+                    Arrays.asList(merger.getSelectorNames())));
+            RowIterator ri1 = branch1.getRows();
+            while (ri1.hasNext()) {
+                Row r = ri1.nextRow();
+                allRows.add(r);
+            }
+            log.debug("{} SQL2 JOIN executed first branch, took {} ms.",
+                    genString(printIndentation), System.currentTimeMillis()
+                            - bTime);
+
+            // second branch
+            bTime = System.currentTimeMillis();
+            QueryResult branch2 = execute(merger,
+                    csInfo.getRightInnerConstraints(), isOuterJoin,
+                    printIndentation + printIndentStep);
+            RowIterator ri2 = branch2.getRows();
+            while (ri2.hasNext()) {
+                Row r = ri2.nextRow();
+                allRows.add(r);
+            }
+            log.debug("{} SQL2 JOIN executed second branch, took {} ms.",
+                    genString(printIndentation), System.currentTimeMillis()
+                            - bTime);
+            return new SimpleQueryResult(merger.getColumnNames(),
+                    merger.getSelectorNames(), new RowIteratorAdapter(allRows));
+        }
+        
-        // So, in the case of an OUTER JOIN we'll run 2 queries, one with 'ON'
+        // So, in the case of an OUTER JOIN we'll run 2 queries, one with
+        // 'ON'
-        // - excludingOuterJoinRowsSet: the 'ON' + 'WHERE' condition dataset, or
+        // - excludingOuterJoinRowsSet: the 'ON' + 'WHERE' condition
+        // dataset, or
-        boolean isOuterJoin = JCR_JOIN_TYPE_LEFT_OUTER.equalsIgnoreCase(join
-                .getJoinType());
-
-        Set<Row> rightRows = buildRightRowsJoin(csInfo, rightConstraints, isOuterJoin,
-                rightCo, printIndentation + printIndentStep);
+        Set<Row> rightRows = buildRightRowsJoin(csInfo, rightConstraints,
+                isOuterJoin, rightCo, printIndentation + printIndentStep);
-
-        long timeMergeAndSort = System.currentTimeMillis();
-
-        QueryResult result = merger.merge(new RowIteratorAdapter(leftRows),
+        return merger.merge(new RowIteratorAdapter(leftRows),
-        QueryResult sortedResult = sort(result, orderings, evaluator, offset,
-                limit);
-        if (log.isDebugEnabled()) {
-            timeMergeAndSort = System.currentTimeMillis() - timeMergeAndSort;
-            log.debug(genString(printIndentation)
-                    + "SQL2 JOIN MERGE and SORT took " + timeMergeAndSort
-                    + " ms.");
-        }
-        return sortedResult;
+
-            if (csi.getLeftInnerConstraints().isHasLeftConstraints()) {
-                leftRows.addAll(buildLeftRowsJoin(
-                        csi.getLeftInnerConstraints(), comparator,
-                        printIndentation + printIndentStep));
-            }
-            if (csi.getRightInnerConstraints().isHasLeftConstraints()) {
-                leftRows.addAll(buildLeftRowsJoin(
-                        csi.getRightInnerConstraints(), comparator,
-                        printIndentation + printIndentStep));
-            }
+            leftRows.addAll(buildLeftRowsJoin(csi.getLeftInnerConstraints(),
+                    comparator, printIndentation + printIndentStep));
+            leftRows.addAll(buildLeftRowsJoin(csi.getRightInnerConstraints(),
+                    comparator, printIndentation + printIndentStep));
-        
+
-                rightRows.addAll(buildRightRowsJoin(
-                        csi.getLeftInnerConstraints(), rightConstraints,
-                        ignoreWhereConstraints, comparator, printIndentation
-                                + printIndentStep));
-                rightRows.addAll(buildRightRowsJoin(
-                        csi.getRightInnerConstraints(), rightConstraints,
-                        ignoreWhereConstraints, comparator, printIndentation
-                                + printIndentStep));
+            rightRows.addAll(buildRightRowsJoin(csi.getLeftInnerConstraints(),
+                    rightConstraints, ignoreWhereConstraints, comparator,
+                    printIndentation + printIndentStep));
+            rightRows.addAll(buildRightRowsJoin(csi.getRightInnerConstraints(),
+                    rightConstraints, ignoreWhereConstraints, comparator,
+                    printIndentation + printIndentStep));
-                        + time + " ms. selector: " + selector
-                        + ", columns: " + Arrays.toString(columnNames)
-                        + ", constraint: " + constraint);
+                        + time + " ms. selector: " + selector + ", columns: "
+                        + Arrays.toString(columnNames) + ", constraint: "
+                        + constraint);
-    private Map<String, PropertyValue> getColumnMap(
-            Column[] columns, Map<String, NodeType> selectors)
-            throws RepositoryException {
-        Map<String, PropertyValue> map =
-            new LinkedHashMap<String, PropertyValue>();
+    private Map<String, PropertyValue> getColumnMap(Column[] columns,
+            Map<String, NodeType> selectors) throws RepositoryException {
+        Map<String, PropertyValue> map = new LinkedHashMap<String, PropertyValue>();
-                    map.put(name, qomFactory.propertyValue(
-                            columns[i].getSelectorName(),
-                            columns[i].getPropertyName()));
+                    map.put(name,
+                            qomFactory.propertyValue(
+                                    columns[i].getSelectorName(),
+                                    columns[i].getPropertyName()));
-                map.putAll(getColumnMap(
-                        selector.getKey(), selector.getValue()));
+                map.putAll(getColumnMap(selector.getKey(), selector.getValue()));
-    private Map<String, PropertyValue> getColumnMap(
-            String selector, NodeType type) throws RepositoryException {
-        Map<String, PropertyValue> map =
-            new LinkedHashMap<String, PropertyValue>();
+    private Map<String, PropertyValue> getColumnMap(String selector,
+            NodeType type) throws RepositoryException {
+        Map<String, PropertyValue> map = new LinkedHashMap<String, PropertyValue>();
-            return Collections.singletonMap(
-                    selector.getSelectorName(), getNodeType(selector));
+            return Collections.singletonMap(selector.getSelectorName(),
+                    getNodeType(selector));
-     * Sorts the given query results according to the given QOM orderings.
-     * If one or more orderings have been specified, this method will iterate
+     * Sorts the given query results according to the given QOM orderings. If
+     * one or more orderings have been specified, this method will iterate
-     *
-     * @param result original query results
-     * @param orderings QOM orderings
-     * @param offset result offset
-     * @param limit result limit
+     * 
+     * @param result
+     *            original query results
+     * @param orderings
+     *            QOM orderings
+     * @param offset
+     *            result offset
+     * @param limit
+     *            result limit
-     * @throws RepositoryException if the results can not be sorted
+     * @throws RepositoryException
+     *             if the results can not be sorted
-        if ((orderings != null && orderings.length > 0)
-                || offset != 0 || limit >= 0) {
+        if ((orderings != null && orderings.length > 0) || offset != 0
+                || limit >= 0) {
-            return new SimpleQueryResult(
-                    result.getColumnNames(), result.getSelectorNames(),
-                    new RowIteratorAdapter(rows));
+            return new SimpleQueryResult(result.getColumnNames(),
+                    result.getSelectorNames(), new RowIteratorAdapter(rows));

INS31 INS83 INS43 INS42 MOV44 MOV44 MOV44 MOV44 MOV44 MOV44 INS44 INS43 INS8 INS44 INS44 INS44 MOV60 MOV21 INS42 INS39 INS42 INS42 MOV25 MOV60 MOV60 MOV60 MOV21 MOV60 INS60 INS60 MOV60 INS21 MOV41 INS43 INS42 INS43 INS42 INS39 INS42 INS25 INS41 INS32 INS43 INS59 INS39 INS59 INS32 INS42 INS42 INS32 INS8 MOV32 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS42 INS42 INS45 MOV27 MOV21 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS45 MOV32 INS27 INS42 INS42 INS21 MOV60 INS60 INS60 INS60 INS61 MOV21 INS21 INS60 INS60 INS61 MOV21 INS41 MOV21 MOV21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS43 INS59 INS74 INS59 INS43 INS59 INS32 INS8 INS7 MOV43 INS59 INS43 INS59 INS32 INS8 INS32 INS14 INS45 INS32 INS42 INS42 INS42 INS42 INS45 INS32 INS42 INS32 INS42 INS42 INS32 INS43 INS43 INS42 INS14 INS42 INS42 INS32 INS42 INS42 MOV60 INS21 INS45 INS32 INS27 INS42 MOV32 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS60 INS21 INS42 INS42 INS45 MOV32 MOV27 INS43 INS32 INS32 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS27 INS42 INS42 INS74 INS14 INS42 INS42 INS43 INS32 MOV42 MOV42 INS32 INS42 INS42 INS42 INS32 INS42 INS27 INS42 INS42 INS43 INS59 INS32 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS32 INS42 UPD42 INS32 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 DEL42 DEL7 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL45 DEL27 DEL32 DEL21 DEL8 DEL25 DEL45 DEL27 DEL42 DEL42 DEL32 DEL8 DEL25 DEL42 DEL45 DEL42 DEL45 DEL27 DEL42 DEL7 DEL32 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL32 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL32 DEL8 DEL25
JCR-1590 JSR 283: Locking

- getSecondsRemaining is negative if lock is expired or released
- getLockToken always returns null if lock is sessionscoped

JCR-2004 Update SPI locking to match JCR 2.0

- extend spi/LockInfo.java
- add JCR 2.0 variant of RepositoryService#lock that takes timeoutHint and ownerHint
- adjust jcr2spi
- adjust spi implementation(s)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@753244 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.jcr2spi.NodeImpl;
+import org.apache.jackrabbit.spi.commons.conversion.PathResolver;
+import java.util.Date;
-public class LockManagerImpl implements LockManager, SessionListener {
+public class LockManagerImpl implements LockManager, org.apache.jackrabbit.api.jsr283.lock.LockManager, SessionListener {
+    private static final long TIMEOUT_EXPIRED = -1;
+    private static final long TIMEOUT_INFINITE = Long.MAX_VALUE;
+
+    private final PathResolver resolver;
-                           CacheBehaviour cacheBehaviour) {
+                           CacheBehaviour cacheBehaviour, PathResolver pathResolver) {
+        this.resolver = pathResolver;
+    //--------------------------------------------------------< LockManager >---
+    /**
+     * @see org.apache.jackrabbit.api.jsr283.lock.LockManager#getLock(String)
+     */
+    public org.apache.jackrabbit.api.jsr283.lock.Lock getLock(String absPath) throws LockException, RepositoryException {
+        Node n = itemManager.getNode(resolver.getQPath(absPath));
+        return (org.apache.jackrabbit.api.jsr283.lock.Lock) n.getLock();
+    }
+
+    /**
+     * @see org.apache.jackrabbit.api.jsr283.lock.LockManager#isLocked(String)
+     */
+    public boolean isLocked(String absPath) throws RepositoryException {
+        Node n = itemManager.getNode(resolver.getQPath(absPath));
+        return n.isLocked();
+    }
+
+    /**
+     * @see org.apache.jackrabbit.api.jsr283.lock.LockManager#holdsLock(String)
+     */
+    public boolean holdsLock(String absPath) throws RepositoryException {
+        Node n = itemManager.getNode(resolver.getQPath(absPath));
+        return n.holdsLock();
+    }
+
+    /**
+     * @see org.apache.jackrabbit.api.jsr283.lock.LockManager#lock(String, boolean, boolean, long, String)
+     */
+    public org.apache.jackrabbit.api.jsr283.lock.Lock lock(String absPath, boolean isDeep, boolean isSessionScoped, long timeoutHint, String ownerInfo) throws RepositoryException {
+        Node n = itemManager.getNode(resolver.getQPath(absPath));
+        return (org.apache.jackrabbit.api.jsr283.lock.Lock) ((NodeImpl) n).lock(isDeep, isSessionScoped, timeoutHint, ownerInfo);
+    }
+
+    /**
+     * @see org.apache.jackrabbit.api.jsr283.lock.LockManager#unlock(String) 
+     */
+    public void unlock(String absPath) throws LockException, RepositoryException {
+        Node n = itemManager.getNode(resolver.getQPath(absPath));
+        n.unlock();
+    }
+
+    //---------------------< org.apache.jackrabbit.jcr2spi.lock.LockManager >---
+        return lock(nodeState, isDeep, isSessionScoped, Long.MAX_VALUE, null);
+    }
+
+    /**
+     * @see LockManager#lock(NodeState,boolean,boolean,long,String)
+     */
+    public Lock lock(NodeState nodeState, boolean isDeep, boolean isSessionScoped, long timeoutHint, String ownerHint) throws RepositoryException {
-        LockOperation op = LockOperation.create(nodeState, isDeep, isSessionScoped);
+        LockOperation op = LockOperation.create(nodeState, isDeep, isSessionScoped, timeoutHint, ownerHint);
-        if (l != null && l.getLockToken() == null) {
+        if (l != null && !l.isLockOwningSession()) {
+    //--------< LockManager, org.apache.jackrabbit.jcr2spi.lock.LockManager >---
-            if (l.isSessionScoped() && l.getLockToken() != null) {
+            if (l.isSessionScoped() && l.isLockOwningSession()) {
-                lockHoldingState = ((NodeEntry) lockedEntry).getNodeState();
+                lockHoldingState = lockedEntry.getNodeState();
-            // need correct information about lock status -> retrieve lockInfo
+            // need precise information about lock status -> retrieve lockInfo
-                lock.lockState.lockInfo = lState.lockInfo;
+                lock.lockState.setLockInfo(lState.lockInfo);
+        private long expiration = TIMEOUT_INFINITE;
-            this.lockInfo = lockInfo;
+            setLockInfo(lockInfo);
+        private void setLockInfo(LockInfo lockInfo) {
+            this.lockInfo = lockInfo;
+            long seconds = lockInfo.getSecondsRemaining();
+            if (seconds <= TIMEOUT_EXPIRED) {
+                expiration = TIMEOUT_EXPIRED;
+                isLive = false;
+            } else if (seconds < TIMEOUT_INFINITE) {
+                // calculate timeout
+                expiration = new Date().getTime()/1000 + lockInfo.getSecondsRemaining();
+            } else {
+                expiration = TIMEOUT_INFINITE;
+            }
+        }
+
+        /**
+         * @return <code>true</code> if the lock is still alive.
+         */
+        private boolean isLive() {
+            if (isLive) {
+                isLive = getSecondsRemaining() > 0;
+            }
+            return isLive;
+        }
+
+        /**
+         * @return the number of seconds until the lock's timeout is reached,
+         * {@link Long#MAX_VALUE} if timeout is infinite or undefined and
+         * a negative value if timeout has already been reached or the lock
+         * has been otherwise released.
+         */
+        private long getSecondsRemaining() {
+            if (!isLive) {
+                return TIMEOUT_EXPIRED;
+            } else if (expiration == TIMEOUT_INFINITE) {
+                return expiration;
+            } else {
+                long seconds = expiration - new Date().getTime()/1000;
+                if (seconds <= 0) {
+                    isLive = false;
+                    return TIMEOUT_EXPIRED;
+                } else {
+                    return seconds;
+                }
+            }
+        }
+
-            if (isLive) {
-                isLive = false;
+            if (isLive()) {
+                isLive = false;
-            if (!isLive) {
+            if (!isLive()) {
-    private class LockImpl implements Lock, LockTokenListener {
+    private class LockImpl implements org.apache.jackrabbit.api.jsr283.lock.Lock, LockTokenListener {
-            } else if (isHoldBySession()) {
+            } else if (lockState.lockInfo.isLockOwner()) {
+            // shortcut for jsr 283 session scoped locks: they never expose
+            // the lock token to the API users.
+            if (isSessionScoped()) {
+                return null;
+            }
+
-            return lockState.isLive;
+            return lockState.isLive();
-            if (getLockToken() == null) {
+            if (!isLockOwningSession()) {
+        /**
+         * @see org.apache.jackrabbit.api.jsr283.lock.Lock#getSecondsRemaining()
+         */
+        public long getSecondsRemaining() throws RepositoryException {
+            updateLockInfo();
+            return lockState.getSecondsRemaining();
+        }
+
+        /**
+         * @see org.apache.jackrabbit.api.jsr283.lock.Lock#isLockOwningSession()
+         */
+        public boolean isLockOwningSession(){
+            return lockState.lockInfo.isLockOwner();
+        }
+
-            if (getLockToken() == null) {
-                // could be that this affects this lock and session became
+            if (!isSessionScoped() && !isLockOwningSession()) {
+                // unless this lock is session-scoped (token is never transfered)
+                // and the session isn't the owner yet (token already present),
+                // it could be that this affects this lock and session became
-            // for this lock.
+            // for this lock. this will never be true for session-scoped locks
+            // that are not exposed (thus cannot be removed).
-        /**
-         * @return true if this lock is hold by this session. false otherwise.
-         */
-        private boolean isHoldBySession() {
-            return lockState.lockInfo.getLockToken() != null;
-        }

INS26 INS26 INS26 INS40 INS40 INS40 INS43 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 MOV31 INS40 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS43 INS59 INS44 INS29 INS83 INS43 INS42 INS44 INS43 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS43 INS43 INS8 MOV29 INS83 MOV43 INS42 INS44 INS44 INS44 MOV43 INS43 INS8 INS29 INS44 INS44 INS23 INS31 INS31 INS31 INS43 INS31 INS42 INS38 INS42 INS40 INS42 INS42 INS43 INS42 INS21 INS65 INS40 INS43 INS42 INS42 INS42 INS60 INS41 INS65 INS43 INS42 INS42 INS60 INS41 INS65 INS43 INS42 INS42 INS60 INS41 INS65 INS40 INS43 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS43 INS42 INS42 INS60 INS41 INS65 INS43 INS42 INS42 INS42 INS60 INS21 INS43 INS42 INS39 INS42 INS39 INS42 INS42 INS41 INS65 INS39 INS42 INS43 INS42 INS83 INS39 INS59 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS40 INS29 INS83 INS39 INS42 INS43 INS8 UPD83 UPD42 INS34 INS42 INS7 INS68 INS42 INS43 INS59 INS11 INS68 INS42 INS43 INS59 INS32 INS68 INS42 INS43 INS59 INS32 INS68 INS42 INS42 INS43 INS59 INS11 INS68 INS66 INS42 INS43 INS59 INS32 INS42 INS32 INS68 INS42 INS42 INS42 INS21 INS43 INS42 MOV21 INS60 INS25 INS65 INS25 INS41 INS65 INS25 INS25 INS65 INS42 INS21 INS41 UPD65 INS22 INS42 INS40 INS42 INS69 INS42 INS42 INS32 INS43 INS32 INS40 INS42 INS69 INS42 INS42 INS32 INS42 INS42 INS40 INS42 INS69 INS42 INS42 INS32 INS42 INS42 INS40 INS42 INS69 INS69 INS69 INS69 INS69 INS42 INS42 INS32 INS43 INS32 INS40 INS42 INS69 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS33 INS42 INS42 INS69 INS69 INS69 INS69 INS69 INS38 INS32 INS42 INS39 INS59 INS27 INS8 INS25 INS66 INS42 INS8 INS42 INS66 INS65 INS66 INS66 INS66 MOV38 INS8 INS25 INS32 MOV21 INS38 INS32 INS8 INS32 INS38 INS68 INS32 INS32 INS68 INS32 UPD27 INS52 INS42 INS43 INS42 INS42 INS32 INS40 INS42 INS42 INS43 INS42 INS42 INS32 INS43 INS42 INS42 INS32 INS43 INS39 INS39 INS39 INS43 INS42 INS42 INS32 INS40 INS36 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS32 INS43 INS39 INS39 INS39 INS43 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS21 INS21 INS27 INS8 INS8 INS21 INS67 INS41 INS27 INS8 INS8 INS42 INS32 INS42 INS41 INS42 INS42 INS32 INS40 INS42 INS42 INS42 INS42 INS40 INS42 MOV40 UPD42 MOV42 INS38 INS38 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS42 INS42 INS42 INS42 MOV42 UPD42 MOV42 MOV32 INS42 INS42 INS7 INS7 INS42 INS42 INS21 INS21 INS7 INS42 INS42 INS42 INS42 INS42 INS41 INS60 INS25 INS42 INS40 UPD42 INS33 UPD42 MOV42 INS32 INS32 INS43 INS42 UPD42 INS32 INS42 INS42 INS42 INS9 INS7 INS7 INS42 INS27 INS42 INS39 INS59 INS27 INS8 INS8 INS42 UPD42 MOV42 INS42 INS40 INS42 INS40 INS42 INS27 INS42 INS42 INS32 INS34 INS42 INS27 INS42 INS34 INS21 INS41 INS41 INS42 INS27 INS32 INS42 INS42 INS27 INS7 INS42 INS42 INS32 INS34 INS42 INS42 INS32 INS34 INS42 INS9 INS14 INS42 INS14 INS42 INS43 INS43 INS42 INS42 DEL32 DEL33 DEL27 DEL33 DEL27 DEL42 DEL43 DEL42 DEL11 DEL36 DEL40 DEL40 DEL7 DEL42 DEL40 DEL32 DEL33 DEL27 DEL66 DEL32 DEL33 DEL27 DEL32 DEL33
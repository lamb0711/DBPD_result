JCR-3528 Node type selection for CanAddChildNodeCallWithNodeTypeTest#testResidualAndLegalType is not optimal

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1452698 13f79535-47bb-0310-9956-ffa450edef68

+
+import java.util.ArrayList;
+import java.util.List;
+     * Locate all non-protected child node def declared by a non-abstract node type
+     * parsing all node types
+     *
+     * @param session                  the session to access the node types
+     * @param regardDefaultPrimaryType if true, the default primary type of the
+     *                                 returned <code>NodeDef</code> is
+     *                                 according to param <code>defaultPrimaryType</code>.
+     *                                 If false, the returned <code>NodeDef</code>
+     *                                 might have a default primary type or
+     *                                 not.
+     * @param defaultPrimaryType       if <code>regardDefaultPrimaryType</code>
+     *                                 is true: if true, the returned
+     *                                 <code>NodeDef</code> has a default
+     *                                 primary type, else not
+     * @param residual                 if true, the returned <code>NodeDef</code>
+     *                                 is of the residual name "*", else not
+     * @return
+     * @throws RepositoryException
+     */
+    public static List<NodeDefinition> locateAllChildNodeDef(Session session,
+                                                    boolean regardDefaultPrimaryType,
+                                                    boolean defaultPrimaryType,
+                                                    boolean residual)
+            throws RepositoryException {
+        List<NodeDefinition> nodeTypes = new ArrayList<NodeDefinition>();
+
+        NodeTypeManager manager = session.getWorkspace().getNodeTypeManager();
+        NodeTypeIterator types = manager.getAllNodeTypes();
+
+        boolean skip = false;
+
+        while (types.hasNext()) {
+            NodeType type = types.nextNodeType();
+
+            // node types with more than one residual child node definition
+            // will cause trouble in test cases. the implementation
+            // might pick another definition than the definition returned by
+            // this method, when a child node is set.
+            NodeDefinition[] childDefs = type.getChildNodeDefinitions();
+            int residuals = 0;
+            for (int i = 0; i < childDefs.length; i++) {
+                if (childDefs[i].getName().equals("*")) {
+                    residuals++;
+                }
+            }
+            if (residuals > 1) {
+                // more than one residual, not suitable for tests
+                continue;
+            }
+
+            NodeDefinition nodeDefs[] = type.getDeclaredChildNodeDefinitions();
+
+            for (int i = 0; i < nodeDefs.length; i++) {
+                NodeDefinition nodeDef = nodeDefs[i];
+
+                if (nodeDef.getDeclaringNodeType().isAbstract()) {
+                    continue;
+                }
+
+                if (nodeDef.isProtected()) {
+                    continue;
+                }
+
+                if (nodeDef.getRequiredPrimaryTypes().length > 1) {
+                    // behaviour of implementations that support multiple multiple inheritance
+                    // of primary node types is not specified
+                    continue;
+                }
+
+                if (regardDefaultPrimaryType) {
+
+                    if (defaultPrimaryType && nodeDef.getDefaultPrimaryType() == null) {
+                        continue;
+                    }
+
+                    if (!defaultPrimaryType && nodeDef.getDefaultPrimaryType() != null) {
+                        continue;
+                    }
+                }
+
+                if (residual && !nodeDef.getName().equals("*")) {
+                    continue;
+                }
+
+                if (!residual) {
+                    // if another child node def is a residual definition
+                    // skip the current node type
+                    NodeDefinition nodeDefsAll[] = type.getChildNodeDefinitions();
+                    for (int j = 0; j < nodeDefsAll.length; j++) {
+                        if (nodeDefsAll[j].getName().equals("*")) {
+                            skip = true;
+                            break;
+                        }
+                    }
+                    if (skip) {
+                        // break the loop of the current child not defs
+                        skip = false;
+                        break;
+                    }
+                }
+
+                nodeTypes.add(nodeDef);
+            }
+        }
+        return nodeTypes;
+    }
+
+    /**

INS26 INS26 INS40 INS40 INS31 INS29 INS83 INS83 INS74 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS43 INS43 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS42 INS60 INS60 INS60 INS60 INS61 INS41 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS42 INS74 INS59 INS43 INS59 INS43 INS59 INS39 INS59 INS32 INS8 INS42 INS43 INS43 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS9 INS42 INS42 INS60 INS60 INS60 INS24 INS25 INS60 INS24 INS42 INS42 INS74 INS32 INS42 INS42 INS42 INS43 INS59 INS5 INS59 INS39 INS59 INS58 INS27 INS37 INS8 INS27 INS8 INS43 INS59 INS58 INS27 INS37 INS8 INS43 INS43 INS42 INS42 INS42 INS42 INS32 INS43 INS85 INS42 INS32 INS42 INS34 INS39 INS59 INS42 INS40 INS42 INS25 INS42 INS34 INS18 INS42 INS42 INS85 INS32 INS39 INS59 INS42 INS40 INS42 INS60 INS25 INS25 INS25 INS25 INS25 INS25 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS32 INS8 INS42 INS42 INS42 INS34 INS43 INS59 INS32 INS8 INS32 INS8 INS27 INS8 INS42 INS8 INS27 INS8 INS38 INS8 INS32 INS32 INS42 INS45 INS21 INS42 INS42 INS2 INS32 INS42 INS18 INS42 INS42 INS18 INS22 INS34 INS18 INS25 INS25 INS42 INS38 INS18 INS42 INS60 INS24 INS25 INS42 INS42 INS42 INS2 INS42 INS37 INS42 INS42 INS42 INS42 INS32 INS42 INS27 INS8 INS27 INS8 INS32 INS43 INS59 INS58 INS27 INS37 INS8 INS42 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS18 INS38 INS27 INS18 INS32 INS42 INS45 INS42 INS42 INS85 INS32 INS39 INS59 INS42 INS40 INS42 INS25 INS21 INS10 INS32 INS33 INS42 INS32 INS33 INS42 INS42 INS42 INS42 INS42 INS34 INS32 INS8 INS7 INS42 INS42 INS42 INS42 INS32 INS42 INS45 INS21 INS10 INS42 INS9 INS2 INS42 INS7 INS42 INS42 INS42 INS9
- Create a factory method in ChildNodeReference, which creates a UUIDReference or a PathElementReference based on the availability of a UUID in the child NodeState.
- Introduce a propertiesInAttic in NodeState, which contains properties that are marked removed in the transient space and have been overlayed with a new property with the same name.
- Reviewed NodeState.moveChildNodeEntry()
- Removed unused NodeStateListener.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@432506 13f79535-47bb-0310-9956-ffa450edef68

-import org.apache.jackrabbit.util.WeakIdentityCollection;
+     * Map of properties which are deleted and have been re-created as transient
+     * property with the same name.
+     */
+    private HashMap propertiesInAttic = new HashMap();
+
+    /**
-     * Listeners (weak references)
-     */
-    private final transient Collection listeners = new WeakIdentityCollection(3);
-
-    /**
-            parent = nodeState.parent; // TODO: parent from wrong ism layer
+            //parent = nodeState.parent; // TODO: parent from wrong ism layer
+            propertiesInAttic.clear();
-        ChildNodeEntry entry = childNodeEntries.add(nodeName, uuid);
-        notifyNodeAdded(entry);
-        return entry;
+        return childNodeEntries.add(nodeName, uuid);
-        ChildNodeEntry cne;
-        if (uuid != null) {
-            cne = new UUIDReference(child, isf);
-        } else {
-            cne = new PathElementReference(child, isf, idFactory);
-        }
+        ChildNodeEntry cne = ChildNodeReference.create(child, isf, idFactory);
+     * Renames this node to <code>newName</code>.
+     *
+     * @param newName the new name for this node state.
+     * @throws IllegalStateException if this is the root node.
+     */
+    private synchronized void rename(QName newName) {
+        if (parent == null) {
+            throw new IllegalStateException("root node cannot be renamed");
+        }
+        name = newName;
+    }
+
+    /**
-                // already removed
+                // remove invalid property state from properties map
+                it.remove();
+        // move all properties from attic back to properties map
+        properties.putAll(propertiesInAttic);
+        propertiesInAttic.clear();
+
-        if (properties.containsKey(propertyName)) {
-            throw new ItemExistsException(propertyName.toString());
+        // check for an existing property
+        PropertyReference ref = (PropertyReference) properties.get(propertyName);
+        if (ref != null) {
+            PropertyState existingState = null;
+            try {
+                existingState = ref.getPropertyState();
+            } catch (ItemStateException e) {
+                // probably does not exist anymore, remove from properties map
+                properties.remove(propertyName);
+            }
+            if (existingState != null) {
+                if (existingState.getStatus() == STATUS_EXISTING_REMOVED) {
+                    // move to attic
+                    propertiesInAttic.put(propertyName, ref);
+                } else {
+                    throw new ItemExistsException(propertyName.toString());
+                }
+            }
+     * Reorders the child node <code>insertNode</code> before the child node
+     * <code>beforeNode</code>.
-     * @param insertNode
-     * @param beforeNode
+     * @param insertNode the child node to reorder.
+     * @param beforeNode the child node where to insert the node before. If
+     *                   <code>null</code> the child node <code>insertNode</code>
+     *                   is moved to the end of the child node entries.
+     * @throws NoSuchItemStateException if <code>insertNode</code> or
+     *                                  <code>beforeNode</code> is not a child
+     *                                  node of this <code>NodeState</code>.
+        // mark this state as modified
+        markModified();
-    // TODO: review. move with SPI Ids
-        // rename only
-            if (newParent == this) {
-                ChildNodeEntry newEntry = childNodeEntries.add(name, childState.getUUID());
-                notifyNodeAdded(newEntry);
-                notifyNodeRemoved(oldEntry);
-            } else {
-                notifyNodeRemoved(oldEntry);
-                // re-parent target node
-                childState.setParent(newParent);
-                // add child node entry to new parent
-                newParent.addChildNodeEntry(newName, childState.getUUID());
-            }
+            childState.rename(newName);
+            // re-parent target node
+            childState.setParent(newParent);
+            // add child node entry to new parent
+            newParent.childNodeEntries.add(childState);
-    //---------------------------------------------------< Listener support >---
-    /**
-     * {@inheritDoc}
-     * <p/>
-     * If the listener passed is at the same time a <code>NodeStateListener</code>
-     * we add it to our list of specialized listeners.
-     */
-    public void addListener(ItemStateListener listener) {
-        if (listener instanceof NodeStateListener) {
-            synchronized (listeners) {
-                if (listeners.contains(listener)) {
-                    log.debug("listener already registered: " + listener);
-                    // no need to add to call ItemState.addListener()
-                    return;
-                } else {
-                    listeners.add(listener);
-                }
-            }
-        }
-        super.addListener(listener);
-    }
-
-    /**
-     * {@inheritDoc}
-     * <p/>
-     * If the listener passed is at the same time a <code>NodeStateListener</code>
-     * we remove it from our list of specialized listeners.
-     */
-    public void removeListener(ItemStateListener listener) {
-        if (listener instanceof NodeStateListener) {
-            synchronized (listeners) {
-                listeners.remove(listener);
-            }
-        }
-        super.removeListener(listener);
-    }
-
-    //----------------------------------------------< Listener notification >---
-    /**
-     * Notify the listeners that a child node entry has been added
-     */
-    private void notifyNodeAdded(ChildNodeEntry added) {
-        synchronized (listeners) {
-            Iterator iter = listeners.iterator();
-            while (iter.hasNext()) {
-                NodeStateListener l = (NodeStateListener) iter.next();
-                if (l != null) {
-                    l.nodeAdded(this, added.getName(), added.getIndex(), added.getId());
-                }
-            }
-        }
-    }
-
-    /**
-     * Notify the listeners that the child node entries have been replaced
-     */
-    private void notifyNodesReplaced() {
-        synchronized (listeners) {
-            Iterator iter = listeners.iterator();
-            while (iter.hasNext()) {
-                NodeStateListener l = (NodeStateListener) iter.next();
-                if (l != null) {
-                    l.nodesReplaced(this);
-                }
-            }
-        }
-    }
-
-    /**
-     * Notify the listeners that a child node entry has been removed
-     */
-    private void notifyNodeRemoved(ChildNodeEntry removed) {
-        synchronized (listeners) {
-            Iterator iter = listeners.iterator();
-            while (iter.hasNext()) {
-                NodeStateListener l = (NodeStateListener) iter.next();
-                if (l != null) {
-                    l.nodeRemoved(this, removed.getName(),
-                            removed.getIndex(), removed.getId());
-                }
-            }
-        }
-    }
-
+         * Adds a <code>childNode</code> to the end of the list.
+         *
+         * @param childNode the <code>NodeState</code> to add.
+         * @return the <code>ChildNodeEntry</code> which was created for
+         *         <code>childNode</code>.
+         */
+        ChildNodeEntry add(NodeState childNode) {
+            ChildNodeEntry cne = ChildNodeReference.create(childNode, isf, idFactory);
+            add(cne);
+            return cne;
+        }
+
+        /**

MOV23 INS31 UPD43 INS29 MOV83 UPD83 MOV83 MOV39 UPD42 MOV42 INS44 INS8 INS31 UPD42 UPD42 INS60 MOV65 INS65 INS65 INS43 INS42 MOV25 MOV21 INS21 INS21 INS60 INS25 INS65 INS65 INS21 INS29 MOV43 INS42 INS44 INS8 UPD66 INS66 UPD43 MOV21 MOV32 MOV43 INS59 UPD66 INS42 UPD66 MOV66 INS42 UPD66 MOV66 UPD42 MOV42 UPD27 INS7 INS32 INS32 INS43 INS59 INS27 INS8 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS66 INS32 INS65 INS65 INS65 INS43 INS42 INS60 INS21 INS41 UPD42 MOV42 INS32 UPD42 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS33 INS60 INS54 INS25 INS42 INS21 MOV21 MOV21 INS66 INS42 INS66 INS66 INS66 INS42 MOV43 INS59 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS14 INS43 INS32 INS43 INS59 INS8 INS12 INS27 INS8 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS43 INS45 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS21 INS44 INS8 INS42 INS33 MOV25 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS40 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS7 INS43 INS42 INS21 INS27 INS8 INS42 INS42 INS42 INS32 INS42 INS32 INS32 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 MOV42 INS42 DEL40 DEL26 DEL83 DEL83 DEL34 DEL42 DEL40 DEL7 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL43 DEL42 DEL42 DEL14 DEL7 DEL21 DEL8 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL14 DEL7 DEL21 DEL8 DEL25 DEL65 DEL66 DEL66 DEL42 DEL42 DEL52 DEL32 DEL21 DEL42 DEL42 DEL52 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL52 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL41 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL51 DEL8 DEL25 DEL42 DEL42 DEL48 DEL21 DEL8 DEL31 DEL65 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL51 DEL8 DEL25 DEL42 DEL42 DEL48 DEL21 DEL8 DEL31 DEL65 DEL29 DEL39 DEL42 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL52 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL61 DEL8 DEL51 DEL8 DEL31 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL8 DEL61 DEL8 DEL51 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL33 DEL27 DEL8 DEL25 DEL8 DEL61 DEL8 DEL51 DEL8 DEL31
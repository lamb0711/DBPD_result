JCR-1483: Move common node type functionality to jackrabbit-spi-commons
- moved common functionality from NodeTypeImpl (core and jcr2spi) to AbstractNodeType (spi-commons)

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@816568 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.QNodeTypeDefinition;
+import org.apache.jackrabbit.spi.Name;
+import org.apache.jackrabbit.spi.QNodeDefinition;
+import org.apache.jackrabbit.spi.QPropertyDefinition;
+import org.apache.jackrabbit.spi.commons.conversion.NamePathResolver;
+import org.apache.jackrabbit.spi.commons.conversion.NameException;
+import javax.jcr.nodetype.NoSuchNodeTypeException;
+import javax.jcr.nodetype.NodeDefinition;
+import javax.jcr.nodetype.PropertyDefinition;
+import javax.jcr.NamespaceException;
+
-    private final AbstractNodeTypeManager ntMgr;
+    protected final AbstractNodeTypeManager ntMgr;
+
+    protected final QNodeTypeDefinition ntd;
+
+    protected final NamePathResolver resolver;
-     * @param ntMgr
+     * @param ntd      the underlying node type definition.
+     * @param ntMgr    the node type manager.
+     * @param resolver the name/path resolver of the session that created this
+     *                 node type instance.
-    public AbstractNodeType(AbstractNodeTypeManager ntMgr) {
+    public AbstractNodeType(QNodeTypeDefinition ntd,
+                            AbstractNodeTypeManager ntMgr,
+                            NamePathResolver resolver) {
+        this.ntd = ntd;
+        this.resolver = resolver;
+    }
+
+    /**
+     * Returns the node type definition.
+     *
+     * @return the internal node type definition.
+     */
+    public QNodeTypeDefinition getDefinition() {
+        return ntd;
+
+    /**
+     * {@inheritDoc}
+     */
+    public String getName() {
+        try {
+            return resolver.getJCRName(ntd.getName());
+        } catch (NamespaceException e) {
+            // should never get here
+            log.error("encountered unregistered namespace in node type name", e);
+            return ntd.getName().toString();
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean isAbstract() {
+        return ntd.isAbstract();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean isMixin() {
+        return ntd.isMixin();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean isQueryable() {
+        return ntd.isQueryable();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public String[] getDeclaredSupertypeNames() {
+        Name[] ntNames = ntd.getSupertypes();
+        String[] supertypes = new String[ntNames.length];
+        for (int i = 0; i < ntNames.length; i++) {
+            try {
+                supertypes[i] = resolver.getJCRName(ntNames[i]);
+            } catch (NamespaceException e) {
+                // should never get here
+                log.error("encountered unregistered namespace in node type name", e);
+                supertypes[i] = ntNames[i].toString();
+            }
+        }
+        return supertypes;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public NodeType[] getDeclaredSupertypes() {
+        Name[] ntNames = ntd.getSupertypes();
+        NodeType[] supertypes = new NodeType[ntNames.length];
+        for (int i = 0; i < ntNames.length; i++) {
+            try {
+                supertypes[i] = ntMgr.getNodeType(ntNames[i]);
+            } catch (NoSuchNodeTypeException e) {
+                // should never get here
+                log.error("undefined supertype", e);
+                return new NodeType[0];
+            }
+        }
+        return supertypes;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public NodeDefinition[] getDeclaredChildNodeDefinitions() {
+        QNodeDefinition[] cnda = ntd.getChildNodeDefs();
+        NodeDefinition[] nodeDefs = new NodeDefinition[cnda.length];
+        for (int i = 0; i < cnda.length; i++) {
+            nodeDefs[i] = ntMgr.getNodeDefinition(cnda[i]);
+        }
+        return nodeDefs;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public String getPrimaryItemName() {
+        // TODO JCR-1947: JSR 283: Node Type Attribute Subtyping Rules
+        try {
+            Name piName = ntd.getPrimaryItemName();
+            if (piName != null) {
+                return resolver.getJCRName(piName);
+            } else {
+                return null;
+            }
+        } catch (NamespaceException e) {
+            // should never get here
+            log.error("encountered unregistered namespace in name of primary item", e);
+            return ntd.getName().toString();
+        }
+    }
+
+    /**
+     * @see javax.jcr.nodetype.NodeTypeDefinition#getDeclaredPropertyDefinitions()
+     */
+    public PropertyDefinition[] getDeclaredPropertyDefinitions() {
+        QPropertyDefinition[] pda = ntd.getPropertyDefs();
+        PropertyDefinition[] propDefs = new PropertyDefinition[pda.length];
+        for (int i = 0; i < pda.length; i++) {
+            propDefs[i] = ntMgr.getPropertyDefinition(pda[i]);
+        }
+        return propDefs;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean isNodeType(String nodeTypeName) {
+        Name ntName;
+        try {
+            ntName = resolver.getQName(nodeTypeName);
+        } catch (NamespaceException e) {
+            log.warn("invalid node type name: " + nodeTypeName, e);
+            return false;
+        } catch (NameException e) {
+            log.warn("invalid node type name: " + nodeTypeName, e);
+            return false;
+        }
+        return isNodeType(ntName);
+    }
+
+    /**
+     * Test if this nodetype equals or is directly or indirectly derived from
+     * the node type with the specified <code>nodeTypeName</code>, without
+     * checking of a node type of that name really exists.
+     *
+     * @param nodeTypeName A node type name.
+     * @return true if this node type represents the type with the given
+     * <code>nodeTypeName</code> or if it is directly or indirectly derived
+     * from it; otherwise <code>false</code>. If no node type exists with the
+     * specified name this method will also return <code>false</code>.
+     */
+    public abstract boolean isNodeType(Name nodeTypeName);
+
+

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 UPD83 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS44 INS44 INS29 INS83 INS43 INS42 INS8 INS29 INS83 INS43 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS5 INS42 INS8 INS29 INS83 INS5 INS42 INS8 INS29 INS83 INS5 INS42 INS8 INS29 INS83 INS43 INS42 INS8 INS29 INS83 INS5 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS42 INS42 INS42 INS42 INS65 INS65 INS43 INS42 INS43 INS42 INS21 INS21 INS65 INS65 INS42 INS41 INS65 INS42 INS54 INS65 INS41 INS65 INS41 INS65 INS41 INS65 INS43 INS85 INS60 INS60 INS24 INS41 INS65 INS43 INS85 INS60 INS60 INS24 INS41 INS65 INS43 INS85 INS60 INS60 INS24 INS41 INS65 INS42 INS54 INS65 INS43 INS85 INS60 INS60 INS24 INS41 INS65 INS43 INS42 INS60 INS54 INS41 INS65 INS65 INS65 INS43 INS42 INS42 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS7 INS7 INS66 INS66 INS42 INS65 INS8 INS12 INS65 INS32 INS65 INS32 INS65 INS32 INS65 INS42 INS5 INS59 INS5 INS59 INS58 INS27 INS37 INS8 INS42 INS65 INS42 INS5 INS59 INS5 INS59 INS58 INS27 INS37 INS8 INS42 INS65 INS42 INS5 INS59 INS5 INS59 INS58 INS27 INS37 INS8 INS42 INS65 INS8 INS12 INS68 INS42 INS5 INS59 INS5 INS59 INS58 INS27 INS37 INS8 INS42 INS65 INS42 INS43 INS59 INS8 INS12 INS12 INS32 INS66 INS66 INS66 INS42 INS66 INS66 INS66 INS66 INS66 INS42 INS22 INS42 INS22 INS42 INS41 INS44 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS85 INS42 INS32 INS43 INS85 INS42 INS3 INS39 INS59 INS42 INS40 INS42 INS54 INS43 INS85 INS42 INS32 INS43 INS85 INS42 INS3 INS39 INS59 INS42 INS40 INS42 INS54 INS43 INS85 INS42 INS32 INS43 INS85 INS42 INS3 INS39 INS59 INS42 INS40 INS42 INS21 INS60 INS25 INS44 INS8 INS40 INS42 INS43 INS85 INS42 INS32 INS43 INS85 INS42 INS3 INS39 INS59 INS42 INS40 INS42 INS21 INS42 INS42 INS21 INS44 INS8 INS44 INS8 INS42 INS42 INS52 INS42 INS52 INS42 INS32 INS43 INS42 INS21 INS41 INS42 INS42 INS42 INS42 INS5 INS40 INS42 INS34 INS8 INS12 INS42 INS42 INS42 INS42 INS5 INS40 INS42 INS34 INS8 INS12 INS42 INS42 INS42 INS42 INS5 INS40 INS42 INS34 INS7 INS43 INS59 INS27 INS8 INS8 INS43 INS42 INS21 INS41 INS42 INS42 INS42 INS42 INS5 INS40 INS42 INS34 INS7 INS7 INS43 INS42 INS21 INS41 INS43 INS42 INS21 INS41 INS42 INS42 INS32 INS42 INS32 INS32 INS43 INS85 INS21 INS44 INS8 INS43 INS85 INS21 INS44 INS8 INS43 INS85 INS2 INS32 INS42 INS42 INS32 INS42 INS33 INS41 INS41 INS42 INS32 INS32 INS43 INS85 INS2 INS32 INS42 INS32 INS42 INS32 INS9 INS42 INS32 INS9 INS42 INS42 INS42 INS42 INS45 INS42 INS32 INS42 INS42 INS7 INS43 INS42 INS21 INS21 INS42 INS7 INS43 INS42 INS21 INS41 INS42 INS42 INS42 INS42 INS42 INS2 INS42 INS42 INS32 INS33 INS42 INS42 INS45 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS2 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS2 INS32 INS42 INS32 INS7 INS2 INS32 INS42 INS32 INS3 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS2 INS42 INS42 INS45 INS42 INS2 INS32 INS42 INS42 INS42 INS42 INS2 INS42 INS42 INS45 INS42 INS5 INS34 INS42 INS42 INS42 INS42 INS2 INS42 INS42 INS42 INS43 INS85 INS42 INS42 INS42
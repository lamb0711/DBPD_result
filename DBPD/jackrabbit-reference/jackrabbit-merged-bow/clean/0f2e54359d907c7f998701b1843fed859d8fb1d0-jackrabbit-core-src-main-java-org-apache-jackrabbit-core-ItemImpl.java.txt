JCR-1588 - JSR 283: Access Control (work in progress)
JCR-1590 - JSR 283: Locking
JCR-1915 - Node.setPrimaryNodeType should only redefine child-definitions that are not covered by the new effective nt
JCR-1875 - Failing Node.unlock() might leave inconsistent transient state
JCR-538 - Failing Node.checkin() or Node.checkout() might leave inconsistent transient state

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@732693 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.core.state.ChildNodeEntry;
-import org.apache.jackrabbit.core.state.ChildNodeEntry;
-                                "Item cannot be saved because it has been"
+                                "Item cannot be saved because it has been "
-                                "Item cannot be saved because it has been"
+                                "Item cannot be saved because it has been "
-                                "Item cannot be saved; it seems to have been"
+                                "Item cannot be saved; it seems to have been "
-         * - if it is 'modified' check the WRITE permission
+         * - if it is 'modified' or 'new' check the corresponding write permission.
-
-
-            if (itemState.getStatus() != ItemState.STATUS_NEW) {
-                /* transient item is not 'new', therefore it has to be 'modified'
-                   detect the effective set of modification:
-                   - child additions -> add_node perm on the child
-                   - property additions, modifications or removals -> set_property permission
+            ItemDefinition def;
+            if (itemState.isNode()) {
+                def = ntMgr.getNodeDefinition(((NodeState) itemState).getDefinitionId());
+            } else {
+                def = ntMgr.getPropertyDefinition(((PropertyState) itemState).getDefinitionId());
+            }
+            /* check permissions for non-protected items. protected items are
+               only added through API methods which need to assert that
+               permissions are not violated.
+             */
+            if (!def.isProtected()) {
+                /* detect the effective set of modification:
+                   - new added node -> add_node perm on the child
+                   - new property added -> set_property permission
+                   - property modified -> set_property permission
+                   - modified nodes can be ignored for changes only included
+                     child-item addition or removal or changes of protected
+                     properties such as mixin-types which are covered separately
-                // check WRITE permission
-                    // modified node state -> check possible modifications
-                    NodeState nState = (NodeState) itemState;
-                    for (Iterator it = nState.getAddedChildNodeEntries().iterator();
-                         it.hasNext() && isGranted;) {
-                        Name nodeName = ((ChildNodeEntry) it.next()).getName();
-                        isGranted = accessMgr.isGranted(path, nodeName, Permission.ADD_NODE);
-                    }
-                    for (Iterator it = nState.getAddedPropertyNames().iterator();
-                         it.hasNext() && isGranted;) {
-                        Name propName = (Name) it.next();
-                        isGranted = accessMgr.isGranted(path, propName, Permission.SET_PROPERTY);
-                    }
+                    if (itemState.getStatus() == ItemState.STATUS_NEW) {
+                        isGranted = accessMgr.isGranted(path, Permission.ADD_NODE);
+                    } // else: modified node (see comment above)
+                    // modified or new property: set_property permission
-                    String msg = itemMgr.safeGetJCRPath(path) + ": not allowed to modify item";
+                    String msg = itemMgr.safeGetJCRPath(path) + ": not allowed to add or modify item";
-                NodeDefinition def = ntMgr.getNodeDefinition(nodeState.getDefinitionId());
+                NodeDefinition nodeDef = (NodeDefinition) def;
-                    NodeType[] nta = def.getRequiredPrimaryTypes();
+                    NodeType[] nta = nodeDef.getRequiredPrimaryTypes();
-                PropertyDefinitionImpl def =
-                        ntMgr.getPropertyDefinition(propState.getDefinitionId());
+                PropertyDefinitionImpl propDef = (PropertyDefinitionImpl) def;
-                    String[] constraints = def.getValueConstraints();
+                    String[] constraints = propDef.getValueConstraints();
-                                    def.unwrap(), values);
+                                    propDef.unwrap(), values);
-                                && def.getRequiredType() == PropertyType.REFERENCE) {
+                                && propDef.getRequiredType() == PropertyType.REFERENCE) {
-            Path path = stateMgr.getAtticAwareHierarchyMgr().getPath(itemState.getId());
-            // check REMOVE permission
-            int permission = (itemState.isNode()) ? Permission.REMOVE_NODE : Permission.REMOVE_PROPERTY;
-            if (!accessMgr.isGranted(path, permission)) {
-                String msg = itemMgr.safeGetJCRPath(path)
-                        + ": not allowed to remove item";
-                log.debug(msg);
-                throw new AccessDeniedException(msg);
+            ItemDefinition def;
+            if (itemState.isNode()) {
+                def = ntMgr.getNodeDefinition(((NodeState) itemState).getDefinitionId());
+            } else {
+                def = ntMgr.getPropertyDefinition(((PropertyState) itemState).getDefinitionId());
+            }
+            if (!def.isProtected()) {
+                Path path = stateMgr.getAtticAwareHierarchyMgr().getPath(itemState.getId());
+                // check REMOVE permission
+                int permission = (itemState.isNode()) ? Permission.REMOVE_NODE : Permission.REMOVE_PROPERTY;
+                if (!accessMgr.isGranted(path, permission)) {
+                    String msg = itemMgr.safeGetJCRPath(path)
+                            + ": not allowed to remove item";
+                    log.debug(msg);
+                    throw new AccessDeniedException(msg);
+                }
-                        ChildNodeEntry cne =
-                                (ChildNodeEntry) cneIt.next();
+                        ChildNodeEntry cne = (ChildNodeEntry) cneIt.next();
-                        ChildNodeEntry cne =
-                                (ChildNodeEntry) cneIt.next();
+                        ChildNodeEntry cne = (ChildNodeEntry) cneIt.next();

MOV26 INS8 INS60 INS25 MOV60 INS60 INS25 INS25 INS43 INS59 INS32 INS8 INS8 INS38 INS43 INS59 INS32 INS8 INS8 INS38 MOV8 INS42 INS42 INS42 INS42 INS21 INS21 INS32 INS42 INS42 INS42 INS42 INS21 INS21 INS32 INS7 INS7 INS42 INS42 INS43 INS59 INS43 INS59 INS7 INS7 INS42 INS42 INS42 INS32 INS42 INS32 INS25 INS42 INS42 INS11 INS42 INS42 INS11 INS42 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 UPD27 MOV27 INS8 MOV43 INS42 MOV43 INS42 INS42 INS42 INS32 INS42 INS42 INS32 UPD45 UPD45 UPD45 INS36 INS42 INS36 INS42 MOV21 INS36 INS42 INS36 INS42 MOV11 INS11 UPD45 UPD42 UPD42 INS11 INS11 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS42 UPD42 UPD42 DEL42 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL27 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL36 DEL42 DEL32 DEL59 DEL60 DEL8 DEL24 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL27 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL40 DEL32 DEL7 DEL21 DEL8 DEL24 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59
JCR-688: Extracted the generational cache to a separate class

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@494560 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-
- * <p>
- * The cache consists of three parts: a long term cache and two generations
- * of recent cache entries. The two generations are used to collect recent new
- * entries, and those entries that are used within two successive generations
- * get promoted to the long term cache. The entries within the long term cache
- * are discarded only when the size of the cache exceeds the given maximum
- * cache size.
-     * Default maximum cache size.
-     */
-    private static final int DEFAULT_CACHE_SIZE = 1000;
-
-    /**
-     * Divisor used to determine the default generation age from the
-     * maximum cache size.
-     */
-    private static final int DEFAULT_SIZE_AGE_RATIO = 10;
-
-    /**
-     * Maximum size of the name cache.
+     * Generational cache.
-    private final int maxSize;
+    private final GenerationalCache cache;
-     * Maximum age of a cache generation.
-     */
-    private final int maxAge;
-
-    /**
-     * Long term name cache. Read only.
-     */
-    private Map cache = new HashMap();
-
-    /**
-     * Old cache generation. Read only.
-     */
-    private Map old = new HashMap();
-
-    /**
-     * Young cache generation. Write only.
-     */
-    private Map young = new HashMap();
-
-    /**
-     * Age of the young cache generation.
-     */
-    private int age = 0;
-
-    /**
-     * Creates a caching name resolver.
+     * Creates a caching decorator for the given name resolver. The given
+     * generational cache is used for caching.
-     * @param maxSize maximum size of the long term cache
-     * @param maxAge maximum age of a cache generation
+     * @param cache generational cache
-    public CachingNameResolver(NameResolver resolver, int maxSize, int maxAge) {
+    public CachingNameResolver(NameResolver resolver, GenerationalCache cache) {
-        this.maxSize = maxSize;
-        this.maxAge = maxAge;
+        this.cache = cache;
-     * Creates a caching name resolver using the default generation age for
-     * the given cache size.
+     * Creates a caching decorator for the given name resolver.
-     * @param resolver decorated name resolver
-     * @param maxSize maximum size of the long term cache
-     */
-    public CachingNameResolver(NameResolver resolver, int maxSize) {
-        this(resolver, maxSize, maxSize / DEFAULT_SIZE_AGE_RATIO);
-    }
-
-    /**
-     * Creates a caching name resolver using the default size and
-     * generation age.
-     *
-     * @param resolver decorated name resolver
+     * @param resolver name resolver
-        this(resolver, DEFAULT_CACHE_SIZE);
-    }
-
-    /**
-     * Caches the given key-value pair and increases the age of the current
-     * cache generation. When the maximum age of a generation is reached,
-     * the following steps are taken:
-     * <ol>
-     *   <li>The union of the two cache generations is calculated</li>
-     *   <li>The union is added to the long term name cache</li>
-     *   <li>If the cache size exceeds the maximum, only the union is kept</li>
-     *   <li>A new cache generation is started</li>
-     * </ol>
-     *
-     * @param key key of the cache entry
-     * @param value value of the cache entry
-     */
-    private synchronized void cache(Object key, Object value) {
-        young.put(key, value);
-
-        if (++age == maxAge) {
-            Map union = new HashMap();
-            Iterator iterator = old.entrySet().iterator();
-            while (iterator.hasNext()) {
-                Map.Entry entry = (Map.Entry) iterator.next();
-                if (young.containsKey(entry.getKey())) {
-                    union.put(entry.getKey(), entry.getValue());
-                }
-            }
-
-            if (!union.isEmpty()) {
-                if (cache.size() + union.size() <= maxSize) {
-                    union.putAll(cache);
-                }
-                cache = union;
-            }
-
-            old = young;
-            young = new HashMap();
-            age = 0;
-        }
+        this(resolver, new GenerationalCache());
-            qname = (QName) old.get(name);
-            if (qname == null) {
-                qname = resolver.getQName(name);
-            }
-            cache(name, qname);
+            qname = resolver.getQName(name);
+            cache.put(name, qname);
-     * Returns the prefixed JCR name for the given qualified name.
-     * If the name is in the default namespace, then the local name
-     * is returned without a prefix. Otherwise the name is first looked
-     * up form the generational cache and the call gets delegated to the
-     * decorated name resolver only if the cache misses.
+     * Returns the prefixed JCR name for the given qualified name. The name
+     * is first looked up form the generational cache and the call gets
+     * delegated to the decorated name resolver only if the cache misses.
-            name = (String) old.get(qname);
-            if (name == null) {
-                name = resolver.getJCRName(qname);
-            }
-            cache(qname, name);
+            name = resolver.getJCRName(qname);
+            cache.put(qname, name);

INS23 MOV29 MOV83 MOV83 UPD43 MOV43 MOV59 INS44 UPD42 INS65 INS43 UPD42 MOV42 MOV25 MOV25 UPD66 UPD66 MOV66 UPD66 MOV66 UPD42 UPD66 INS42 UPD66 UPD66 INS14 UPD66 UPD66 UPD66 UPD42 INS43 INS21 INS21 UPD42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL42 DEL43 DEL14 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL39 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL23 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL65 DEL42 DEL65 DEL39 DEL42 DEL44 DEL39 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL66 DEL42 DEL66 DEL65 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL27 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL17 DEL8 DEL31 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL38 DEL42 DEL27 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL40 DEL43 DEL42 DEL40 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL61 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL42 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL7 DEL21 DEL42 DEL42 DEL43 DEL14 DEL7 DEL21 DEL42 DEL34 DEL7 DEL21 DEL8 DEL25 DEL8 DEL31 DEL42 DEL33 DEL27 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL66 DEL66 DEL42 DEL33 DEL27 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25
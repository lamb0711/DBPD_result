some minor cleanups and javadoc improvements

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@428023 13f79535-47bb-0310-9956-ffa450edef68

-                    throw new MalformedPathException("Path can not be canonicalized: unresolvable '..' element");
+                    throw new MalformedPathException(
+                            "Path can not be canonicalized: unresolvable '..' element");
-                last = queue.isEmpty() ? PARENT_ELEMENT : (PathElement) queue.getLast();
+                if (queue.isEmpty()) {
+                    last = PARENT_ELEMENT;
+                } else {
+                    last = (PathElement) queue.getLast();
+                }
-                queue.add(last = elem);
+                last = elem;
+                queue.add(last);
-
-        /**
-         * {@inheritDoc}
-         */
-        public Object clone() throws CloneNotSupportedException {
-            super.clone();
-            PathBuilder clone = new PathBuilder();
-            clone.queue.addAll(queue);
-            return clone;
-        }
-    //---------------------------------------------------------< Path Elements >
-
+    //---------------------------------------------< PathElement & subclasses >
-     * Once created, a NameElement object is immutable.
+     * Once created, a PathElement object is immutable.
-
-         * Creates a path element with the given qualified name and index.
+         * Private constructor for creating a path element with the given
+         * qualified name and index. Instead of using this constructor directly
+         * the factory methods {@link #create(QName)} and {@link #create(QName, int)}
+         * should be used.
-         * Creates a new path element with the given qualified name and index.
-         * If the name is equals to the name of a special element, like the
-         * {@link #PARENT_ELEMENT},{@link #CURRENT_ELEMENT} or the
-         * {@link #ROOT_ELEMENT}, then it's instance is returned.
+         * Creates a path element with the given qualified name.
+         * The created path element does not contain an explicit index.
-         * the private constructor must never be called but from these 2 methods.
+         * If the specified name denotes a <i>special</i> path element (either
+         * {@link Path#PARENT_ELEMENT}, {@link Path#CURRENT_ELEMENT} or
+         * {@link Path#ROOT_ELEMENT}) then the associated constant is returned.
-         * Creates a new path element with the given qualified name and index.
-         * If the name is equals to the name of a special element, like the
-         * {@link #PARENT_ELEMENT},{@link #CURRENT_ELEMENT} or the
-         * {@link #ROOT_ELEMENT}, then it's instance is returned.
+         * Same as {@link #create(QName)} except that an explicit index can be
+         * specified.
-         * the private constructor must never be called but from these 2 methods.
+         * Note that an IllegalArgumentException will be thrown if the specified
+         * name denotes a <i>special</i> path element (either
+         * {@link Path#PARENT_ELEMENT}, {@link Path#CURRENT_ELEMENT} or
+         * {@link Path#ROOT_ELEMENT}) since an explicit index is not allowed
+         * in this context.
-         * @throws IllegalArgumentException if the name is <code>null</code> or
-         *                                  if the given index is less than 1.
+         * @throws IllegalArgumentException if the name is <code>null</code>,
+         *                                  if the given index is less than 1
+         *                                  or if name denoting a special path
+         *                                  element and an index greater than 1
+         *                                  have been specified.
-            } else if (name.equals(PARENT_ELEMENT.getName())) {
-                return PARENT_ELEMENT;
-            } else if (name.equals(CURRENT_ELEMENT.getName())) {
-                return CURRENT_ELEMENT;
-            } else if (name.equals(ROOT_ELEMENT.getName())) {
-                return ROOT_ELEMENT;
+            } else if (name.equals(PARENT_ELEMENT.getName())
+                    || name.equals(CURRENT_ELEMENT.getName())
+                    || name.equals(ROOT_ELEMENT.getName())) {
+                throw new IllegalArgumentException(
+                        "special path elements (root, '.' and '..') can not have an explicit index");
-         * Returns the JCR name of this path element.
-         *
-         * @param resolver
-         * @return ""
+         * {@inheritDoc}
+         * <p/>
+         * Returns <code>""</code>
+         * @return <code>""</code>
-         * Returns the JCR name of this path element.
-         *
-         * @param resolver
-         * @return {@link #LITERAL}
+         * {@inheritDoc}
+         * <p/>
+         * Returns <code>"."</code>
+         * @return <code>"."</code>
-         * Returns the JCR name of this path element.
-         *
-         * @param resolver
-         * @return {@link #LITERAL}
+         * {@inheritDoc}
+         * <p/>
+         * Returns <code>".."</code>
+         * @return <code>".."</code>

UPD66 MOV25 UPD66 INS66 INS66 INS65 INS66 INS65 INS66 UPD66 INS66 INS66 UPD66 UPD66 UPD66 UPD66 INS66 INS65 INS66 INS66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 INS66 INS66 MOV27 MOV8 INS65 INS66 UPD66 UPD66 INS65 INS66 UPD66 UPD66 INS65 INS66 UPD66 UPD66 INS68 INS68 INS68 MOV27 MOV8 INS25 INS42 INS69 INS42 INS69 INS69 INS42 INS42 INS42 INS42 INS69 INS42 INS42 INS42 INS27 MOV32 INS8 INS8 INS21 INS43 INS43 INS39 INS43 MOV32 MOV32 MOV32 INS53 INS21 MOV21 MOV7 INS32 INS42 INS42 INS42 INS14 INS7 INS42 INS42 INS42 INS43 INS45 INS42 INS42 MOV11 INS42 DEL42 DEL16 DEL42 DEL42 DEL32 DEL65 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL48 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL40 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL42 DEL41 DEL8 DEL42 DEL41 DEL8 DEL42 DEL41 DEL25 DEL25 DEL42 DEL65 DEL42 DEL65 DEL42 DEL67 DEL65 DEL42 DEL65 DEL42 DEL67 DEL65
work in progress

- event processing upon saving transient modifications
- extend ItemState.refresh: add Event and ev. ChangeLog as param
- EventImpl: parentId missing
- remove ItemStateListener
- all state changes are covered by ItemStateLifeCycleListener.statusChanged(ItemState, int)


git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@453514 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.jackrabbit.spi.Event;
-public abstract class ItemState implements ItemStateListener {
+public abstract class ItemState implements ItemStateLifeCycleListener {
-     * a new state was deleted and is now 'removed'
+     * a state is permanently modified either by saving transient changes or
+     * by wsp operations or be external modification
+     * TODO: improve. status only temporarily used to indicate to a SessionISM-state to pull changes
-    public static final int STATUS_REMOVED = 7;
+    public static final int STATUS_MODIFIED = 7;
+
+    /**
+     * a new state was deleted and is now 'removed'
+     * or an existing item has been removed by a workspace operation or
+     * by an external modification.
+     */
+    public static final int STATUS_REMOVED = 8;
-     * Copy state information from another state into this state
-     * 
-     * @param state source state information
+     * Copy state information from overlayed state to this state
-    abstract void copyFrom(ItemState state);
-
-    /**
-     * Pull state information from overlayed state.
-     */
-    void pull() {
-        if (overlayedState != null) {
-            copyFrom(overlayedState);
-        }
-    }
-
-    /**
-     * Push state information into overlayed state.
-     */
-    void push() {
-        if (overlayedState != null) {
-            overlayedState.copyFrom(this);
-        }
-    }
+    protected abstract void pull();
-    /**
-     * Reconnect this state to the overlayed state that it has been
-     * disconnected from earlier.
-     */
-    protected void reconnect() {
-        if (this.overlayedState == null) {
-            throw new IllegalStateException("Item state cannot be reconnected because there's no underlying state to reconnect to: " + this);
-        }
-        this.overlayedState.addListener(this);
-    }
-    /**
-     * Disconnect this state from the underlying overlayed state.
-     */
-    protected void disconnect() {
-        if (overlayedState != null) {
-            // de-register listener on overlayed state...
-            overlayedState.removeListener(this);
-            overlayedState = null;
-        }
-    }
-
-    /**
-     * Refreshes this item state
-     */
-    protected void refresh() {
-        // TODO: how is this done? where is the new state retrieved from???
-        // TODO: pass in as argument?
-    }
-
-    /**
-     * Notify the listeners that the persistent state this object is
-     * representing has been created.
-     */
-    protected void notifyStateCreated() {
-        // copy listeners to array to avoid ConcurrentModificationException
-        ItemStateListener[] la;
-        synchronized (listeners) {
-            la = (ItemStateListener[]) listeners.toArray(new ItemStateListener[listeners.size()]);
-        }
-        for (int i = 0; i < la.length; i++) {
-            if (la[i] != null) {
-                la[i].stateCreated(this);
-            }
-        }
-    }
-
-    /**
-     * Notify the listeners that the persistent state this object is
-     * representing has been updated.
-     */
-    protected void notifyStateUpdated() {
-        // copy listeners to array to avoid ConcurrentModificationException
-        ItemStateListener[] la;
-        synchronized (listeners) {
-            la = (ItemStateListener[]) listeners.toArray(new ItemStateListener[listeners.size()]);
-        }
-        for (int i = 0; i < la.length; i++) {
-            if (la[i] != null) {
-                la[i].stateModified(this);
-            }
-        }
-    }
-
-    /**
-     * Notify the listeners that the persistent state this object is
-     * representing has been destroyed.
-     */
-    protected void notifyStateDestroyed() {
-        // copy listeners to array to avoid ConcurrentModificationException
-        ItemStateListener[] la;
-        synchronized (listeners) {
-            la = (ItemStateListener[]) listeners.toArray(new ItemStateListener[listeners.size()]);
-        }
-        for (int i = 0; i < la.length; i++) {
-            if (la[i] != null) {
-                la[i].stateDestroyed(this);
-            }
-        }
-    }
+    protected abstract void refresh(Event event, ChangeLog changeLog);
-        ItemStateListener[] la;
+        ItemStateLifeCycleListener[] la;
-            la = (ItemStateListener[]) listeners.toArray(new ItemStateListener[listeners.size()]);
+            la = (ItemStateLifeCycleListener[]) listeners.toArray(new ItemStateLifeCycleListener[listeners.size()]);
+        // only transient states can be marked-modified
+        if (getStatus() != STATUS_NEW && overlayedState == null) {
+            throw new IllegalStateException("persisted cannot be called on workspace state");
+        }
+
-                // should actually get here because item should check before
-                // it modifies an item state. do nothing because item state
-                // is stale anyway.
-                break;
+                // should actually not get here because item should check before
+                // it modifies an item state.
+                throw new IllegalStateException("Cannot mark stale state modified.");
+
-
+            case STATUS_MODIFIED:
-     * Add an <code>ItemStateListener</code>
+     * Add an <code>ItemStateLifeCycleListener</code>
-    public void addListener(ItemStateListener listener) {
+    public void addListener(ItemStateLifeCycleListener listener) {
-     * Remove an <code>ItemStateListener</code>
+     * Remove an <code>ItemStateLifeCycleListener</code>
-    public void removeListener(ItemStateListener listener) {
+    public void removeListener(ItemStateLifeCycleListener listener) {
-    //--------------------------------------------------< ItemStateListener >---
+    //-----------------------------------------< ItemStateLifeCycleListener >---
-     * {@inheritDoc}
+     *
+     * @param state
+     * @param previousStatus
-    public void stateCreated(ItemState created) {
-        // underlying state has been permanently created
-        pull();
-        setStatus(STATUS_EXISTING);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void stateDestroyed(ItemState destroyed) {
-        // underlying state has been permanently destroyed
-        if (isTransient()) {
-            setStatus(STATUS_STALE_DESTROYED);
-        } else {
-            setStatus(STATUS_REMOVED);
-            notifyStateDestroyed();
+    public void statusChanged(ItemState state, int previousStatus) {
+        // workspace-states never are listening to another state
+        if (getStatus() != STATUS_NEW && overlayedState == null) {
+            throw new IllegalStateException("statusChanged cannot be called on workspace state");
-    }
-    /**
-     * {@inheritDoc}
-     */
-    public void stateModified(ItemState modified) {
-        // underlying state has been modified
-        if (isTransient()) {
-            setStatus(STATUS_STALE_MODIFIED);
-        } else {
-            synchronized (this) {
-                // this instance represents existing state, update it
-                pull();
-                notifyStateUpdated();
-            }
+        switch (state.getStatus()) {
+            case STATUS_EXISTING:
+                // nothing to do
+                break;
+            case STATUS_MODIFIED:
+                if (previousStatus == STATUS_EXISTING) {
+                    // change back
+                    state.status = STATUS_EXISTING;
+                    // underlying state has been modified
+                    if (isTransient()) {
+                        setStatus(STATUS_STALE_MODIFIED);
+                    } else {
+                        synchronized (this) {
+                            // this instance represents existing state, update it
+                            pull();
+                            setStatus(STATUS_EXISTING);
+                        }
+                    }
+                } else {
+                    // ILLEGAL
+                    throw new IllegalArgumentException();
+                }
+                break;
+            case STATUS_REMOVED:
+                if (isTransient()) {
+                    setStatus(STATUS_STALE_DESTROYED);
+                } else {
+                    setStatus(STATUS_REMOVED);
+                }
+                break;
+            case STATUS_STALE_MODIFIED:
+            case STATUS_STALE_DESTROYED:
+            case STATUS_EXISTING_REMOVED:
+            case STATUS_EXISTING_MODIFIED:
+            case STATUS_NEW:
+                log.error("Workspace state cannot have its state changed to " + state.getStatus());
+                break;

INS26 MOV31 INS40 UPD43 INS23 INS31 UPD42 INS29 INS83 INS83 INS83 INS39 INS59 INS83 UPD42 INS83 UPD42 INS44 INS44 MOV29 UPD83 MOV83 MOV39 UPD42 MOV42 MOV44 INS44 INS8 UPD42 INS65 INS42 INS34 INS43 INS42 INS43 INS42 INS25 UPD43 UPD43 UPD65 INS65 INS39 INS42 INS25 INS50 UPD66 INS66 INS66 UPD66 MOV66 INS66 UPD66 MOV66 UPD66 INS42 INS42 UPD5 MOV59 INS27 MOV8 INS53 INS49 UPD66 UPD42 UPD66 UPD42 INS42 INS42 INS27 INS8 INS32 INS49 INS10 INS49 INS25 INS10 INS49 MOV25 INS10 INS49 INS49 INS49 INS49 INS49 INS21 INS10 UPD43 INS27 INS27 INS14 INS42 INS27 INS27 INS53 INS42 UPD42 MOV42 INS42 INS42 UPD27 MOV27 INS8 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS32 UPD42 INS32 INS42 INS42 INS33 INS43 INS45 INS32 INS42 INS42 MOV33 INS14 INS42 INS42 MOV21 MOV25 INS53 INS42 UPD42 MOV42 INS27 INS42 INS45 INS42 INS42 INS43 INS45 MOV32 MOV8 INS14 INS45 INS32 UPD5 UPD42 MOV42 INS40 UPD42 INS51 INS43 UPD42 MOV42 INS42 UPD43 INS52 MOV8 UPD42 MOV42 UPD42 UPD5 MOV32 UPD43 UPD42 DEL65 DEL42 DEL65 DEL29 DEL83 DEL39 DEL42 DEL31 DEL66 DEL65 DEL29 DEL39 DEL42 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL66 DEL65 DEL29 DEL39 DEL42 DEL42 DEL33 DEL27 DEL42 DEL42 DEL52 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL66 DEL52 DEL42 DEL22 DEL33 DEL27 DEL25 DEL52 DEL42 DEL22 DEL42 DEL52 DEL32 DEL21 DEL8 DEL66 DEL65 DEL29 DEL42 DEL33 DEL27 DEL42 DEL42 DEL52 DEL32 DEL21 DEL42 DEL33 DEL7 DEL21 DEL8 DEL25 DEL8 DEL8 DEL31 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL85 DEL5 DEL60 DEL42 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL43 DEL85 DEL5 DEL3 DEL32 DEL11 DEL7 DEL21 DEL8 DEL51 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL27 DEL42 DEL42 DEL2 DEL42 DEL52 DEL32 DEL21 DEL8 DEL25 DEL8 DEL24 DEL8 DEL31 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL43 DEL85 DEL5 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL32 DEL3 DEL32 DEL11 DEL7 DEL21 DEL8 DEL51 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL42 DEL52 DEL32 DEL21 DEL8 DEL25 DEL8 DEL24 DEL8 DEL31 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL59 DEL60 DEL42 DEL8 DEL51 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL8 DEL24 DEL8 DEL31 DEL42 DEL59 DEL42 DEL42 DEL32 DEL45 DEL52 DEL27 DEL10 DEL66 DEL42 DEL42 DEL2 DEL33 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL32 DEL3 DEL32 DEL11 DEL42 DEL42 DEL2 DEL33 DEL27 DEL42 DEL42 DEL2 DEL42 DEL52 DEL32 DEL21 DEL42 DEL32 DEL21 DEL65 DEL65 DEL29 DEL83 DEL39 DEL42 DEL43 DEL42 DEL44 DEL31 DEL65 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL8 DEL31 DEL65 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL52 DEL32 DEL21 DEL32 DEL21 DEL8 DEL51 DEL8 DEL25 DEL8 DEL31
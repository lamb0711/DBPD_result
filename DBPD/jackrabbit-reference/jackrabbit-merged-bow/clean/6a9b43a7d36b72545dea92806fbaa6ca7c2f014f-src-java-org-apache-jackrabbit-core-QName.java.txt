- minor path/qname adjustments

git-svn-id: https://svn.apache.org/repos/asf/incubator/jackrabbit/trunk@125923 13f79535-47bb-0310-9956-ffa450edef68

-import java.util.regex.Matcher;
+import java.util.regex.Matcher;
+ * <p>
+ * The external string representation is specified as follows:
+ * <xmp>
+ *           name ::= [prefix ':'] simplename
+ *         prefix ::= << Any valid XML Name >>
+ *     simplename ::= nonspacestring [[string] nonspacestring]
+ *         string ::= [string] char
+ *           char ::= nonspace | space
+ * nonspacestring ::= [nonspacestring] nonspace
+ *          space ::= << ' ' (the space character) >>
+ *       nonspace ::= << Any Unicode character except
+ *                    '/', ':', '[', ']', '*',
+ *                    '''(the single quote),
+ *                    '"'(the double quote),
+ *                    any whitespace character >>
+ * </xmp>
+ *
+
-        if (rawName == null || rawName.length() == 0) {
-            throw new IllegalNameException("empty name");
+        if (resolver==null) {
+            throw new NullPointerException("resolver must not be null");
-
-        String prefix = null;
-        String localName = null;
-
-        Matcher matcher = NAME_PATTERN.matcher(rawName);
-        if (matcher.matches()) {
-            // check for prefix (group 1)
-            if (matcher.group(1) != null) {
-                // prefix specified
-                // group 2 is namespace prefix excl. delimiter (colon)
-                prefix = matcher.group(2);
-            } else {
-                // no prefix specified
-                prefix = "";
-            }
-
-            // group 3 is localName
-            localName = matcher.group(3);
-        } else {
-            // illegal syntax for name
-            throw new IllegalNameException("'" + rawName + "' is not a valid name");
-        }
-
-        String uri;
-        try {
-            uri = resolver.getURI(prefix);
-        } catch (NamespaceException nse) {
-            throw new UnknownPrefixException(prefix);
-        }
-
-        return new QName(uri, localName);
+        return internalFromJCRName(rawName, resolver);
-        if (jcrName == null || jcrName.length() == 0) {
+        try {
+            internalFromJCRName(jcrName, null);
+        } catch (UnknownPrefixException e) {
+            // ignore, will never happen
+        }
+    }
+
+    /**
+     * Parses the <code>jcrName</code>, resolves the prefix using the namespace
+     * resolver and returns a new QName instance. this method is also used
+     * internally just to check the format of the given string by passing a
+     * <code>null</code> value as <code>resolver</code>
+     *
+     * @param rawName the jcr name to parse
+     * @param resolver the namespace resolver or <code>null</code>
+     * @return a new resolved QName
+     * @throws IllegalNameException
+     * @throws UnknownPrefixException
+     */
+    public static QName internalFromJCRName(String rawName, NamespaceResolver resolver)
+            throws IllegalNameException, UnknownPrefixException {
+
+        if (rawName == null || rawName.length() == 0) {
-        Matcher matcher = NAME_PATTERN.matcher(jcrName);
-        if (!matcher.matches()) {
+        String prefix = null;
+        String localName = null;
+
+        Matcher matcher = NAME_PATTERN.matcher(rawName);
+        if (matcher.matches()) {
+            // check for prefix (group 1)
+            if (matcher.group(1) != null) {
+                // prefix specified
+                // group 2 is namespace prefix excl. delimiter (colon)
+                prefix = matcher.group(2);
+            } else {
+                // no prefix specified
+                prefix = "";
+            }
+
+            // group 3 is localName
+            localName = matcher.group(3);
+        } else {
-            throw new IllegalNameException("'" + jcrName + "' is not a valid name");
+            throw new IllegalNameException("'" + rawName + "' is not a valid name");
+        }
+
+        if (resolver==null) {
+            return null;
+        } else {
+            String uri;
+            try {
+                uri = resolver.getURI(prefix);
+            } catch (NamespaceException nse) {
+                throw new UnknownPrefixException(prefix);
+            }
+
+            return new QName(uri, localName);
+
-            return namespaceURI.equals(other.namespaceURI)
-                    && localName.equals(other.localName);
+            return localName.equals(other.localName)
+                    && namespaceURI.equals(other.namespaceURI);
+

MOV26 MOV31 INS31 INS31 MOV29 MOV83 MOV83 INS43 INS42 INS44 INS44 MOV43 INS43 INS8 MOV29 INS83 INS83 INS39 INS42 MOV44 MOV43 INS8 INS29 UPD42 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS43 INS42 INS43 INS42 INS42 MOV25 INS41 INS54 INS65 INS65 INS65 INS65 INS65 INS65 INS25 INS42 INS42 INS27 INS32 INS8 INS12 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS27 INS8 INS8 UPD42 MOV42 MOV33 INS42 INS42 UPD42 MOV42 INS21 INS44 INS8 INS42 INS33 INS41 MOV60 MOV54 MOV41 INS32 INS43 INS42 INS33 MOV32 INS43 UPD45 UPD42 MOV42 UPD42 MOV42 INS33 UPD42 MOV42 INS42 DEL27 DEL42 DEL42 DEL32 DEL34 DEL27 DEL27 DEL39 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL32 DEL38 DEL43 DEL45 DEL42 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL8 DEL31
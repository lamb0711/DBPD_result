work in progress

- version always protected
- versionHistory always protected
- fix Node.getReferences && reference properties
- mixinTypes are 'active' upon save only (and not before). therefore
  cleanup after removeMixin is done only after save.
  adding new states defined by a new mixin are only added after the
  node has been saved.
- nodestates identified by a uuid only were created a second time upon
  ChildNodeEntry.resolve => fix needs to be improved
- Events/ChangeLog are processed by the save-target state
- ChangeLog.persisted not used any more

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@467956 13f79535-47bb-0310-9956-ffa450edef68

+import org.apache.commons.collections.iterators.IteratorChain;
-import org.apache.jackrabbit.spi.PropertyId;
-    private QName[] mixinTypeNames = new QName[0];
+    private QName[] mixinTypeNames = QName.EMPTY_ARRAY;
-     * The <code>ItemStateFactory</code> which is used to create new
-     * <code>ItemState</code> instances.
-     */
-    private final ItemStateFactory isf;
-
-    /**
-        super(parent, initialStatus, idFactory, isWorkspaceState);
+        super(parent, initialStatus, isf, idFactory, isWorkspaceState);
-        this.isf = isf;
+        assertAvailability();
-        super(overlayedState, parent, initialStatus, idFactory);
-        this.isf = isf;
-        reset();
+        super(overlayedState, parent, initialStatus, isf, idFactory);
+        if (overlayedState != null) {
+            synchronized (overlayedState) {
+                NodeState wspState = (NodeState) overlayedState;
+                name = wspState.name;
+                uuid = wspState.uuid;
+                nodeTypeName = wspState.nodeTypeName;
+                definition = wspState.definition;
+
+                init(wspState.getMixinTypeNames(), wspState.getChildNodeEntries(), wspState.getPropertyNames(), wspState.getNodeReferences());
+            }
+        }
+        assertAvailability();
+    /**
+     *
+     * @param mixinTypeNames
+     * @param childEntries
+     * @param propertyNames
+     * @param references
+     */
-            properties.put(propName, PropertyReference.create(this, propName, isf, idFactory));
+            addPropertyEntry(PropertyReference.create(this, propName, isf, idFactory));
-            childNodeEntries.add(cne.getName(), cne.getUUID());
+            childNodeEntries.add(cne.getName(), cne.getUUID(), cne.getIndex());
+    private void assertAvailability() {
+        // TODO: improve this.
+        if (uuid != null) {
+            // make sure this state is connected to its childNode-entry
+            ChildNodeEntry cne = parent.childNodeEntries.get(uuid);
+            if (!cne.isAvailable()) {
+                try {
+                    cne.getNodeState();
+                } catch (ItemStateException e) {
+                    // ignore
+                }
+            }
+        }
+    }
+
+        NodeState parent = getParent();
-    public final String getUUID() {
+    public String getUUID() {
+     * Modify the uuid of this state and make sure, that the parent state
+     * contains a proper childNodeEntry for this state. If the given uuid is
+     * not different from the uuid of this state, the method returns silently
+     * without changing neither the parent nor this state.
+     *
+     * @param uuid
+     */
+    private void setUUID(String uuid) {
+        String oldUUID = this.uuid;
+        boolean mod = (oldUUID == null) ? uuid != null : !oldUUID.equals(uuid);
+        if (mod) {
+            this.uuid = uuid;
+            if (getParent() != null) {
+                getParent().childNodeEntries.replaceEntry(this);
+            }
+        }
+    }
+
+    /**
-        if (getStatus() == Status.NEW) {
-            return null;
-        } else {
-            return references;
-        }
+        return references;
+     *
+     * @param propEntry
+     */
+    private void addPropertyEntry(ChildPropertyEntry propEntry) {
+        QName propName = propEntry.getName();
+        properties.put(propName, propEntry);
+        try {
+            if (isWorkspaceState() && isUuidOrMixin(propName)) {
+                if (QName.JCR_UUID.equals(propName) && uuid == null) {
+                    PropertyState ps = propEntry.getPropertyState();
+                    setUUID(ps.getValue().getString());
+                } else if (QName.JCR_MIXINTYPES.equals(propName) && (mixinTypeNames == null || mixinTypeNames.length == 0)) {
+                    PropertyState ps = propEntry.getPropertyState();
+                    mixinTypeNames = getMixinNames(ps);
+                }
+            }
+        } catch (ItemStateException e) {
+            log.error("Internal Error", e);
+        } catch (RepositoryException e) {
+            log.error("Internal Error", e);
+        }
+    }
+
+    /**
+     *
+     * @param propName
+     */
+    private void removePropertyEntry(QName propName) {
+        if (properties.remove(propName) != null) {
+            if (isWorkspaceState()) {
+                if (QName.JCR_UUID.equals(propName)) {
+                    setUUID(null);
+                } else if (QName.JCR_MIXINTYPES.equals(propName)) {
+                    mixinTypeNames = QName.EMPTY_ARRAY;
+                }
+            }
+        }
+    }
+
+    /**
-     * @param changeLog
-     * @see ItemState#refresh(Event, ChangeLog)
+     * @see ItemState#refresh(Event)
-    synchronized void refresh(Event event, ChangeLog changeLog) {
+    synchronized void refresh(Event event) {
+        QName name = event.getQPath().getNameElement().getName();
+                int index = event.getQPath().getNameElement().getNormalizedIndex();
+                NodeId evId = (NodeId) event.getItemId();
+                String uuid = (evId.getPath() != null) ? null : evId.getUUID();
+
+                // add new childNodeEntry if it has not been added by
+                // some earlier 'add' event
+                // TODO: TOBEFIXED for SNSs
+                ChildNodeEntry cne = childNodeEntries.get(name, index);
+                if (cne == null || ((uuid == null) ? cne.getUUID() != null : !uuid.equals(cne.getUUID()))) {
+                    cne = childNodeEntries.add(name, uuid, index);
+                }
+                // and let the transiently modified session state now, that
+                // its workspace state has been touched.
+                setStatus(Status.MODIFIED);
+                break;
+
-                if (!id.equals(event.getParentId())) {
-                    // TODO: TOBEFIXED. this should never occur and indicates severe consistency issue.
-                    throw new IllegalArgumentException("Event parent (" + event.getParentId() + ") does not match this state with id: " + id);
-                }
-                ItemId evId = event.getItemId();
-                ItemState newState = null;
-
-                if (evId.denotesNode()) {
-                    QName name = event.getQPath().getNameElement().getName();
-                    int index = event.getQPath().getNameElement().getNormalizedIndex();
-                    String uuid = (((NodeId)evId).getPath() != null) ? null : ((NodeId)evId).getUUID();
-
-                    // add new childNodeEntry if it has not been added by
-                    // some earlier 'add' event
-                    // TODO: TOBEFIXED for SNSs
-                    ChildNodeEntry cne = getChildNodeEntry(name, index);
-                    if (cne == null || ((uuid == null) ? cne.getUUID() != null : !uuid.equals(cne.getUUID()))) {
-                        cne = childNodeEntries.add(name, uuid);
-                    }
-                    try {
-                        newState = cne.getNodeState();
-                    } catch (ItemStateException e) {
-                        log.error("Internal error", e);
-                    }
-                } else {
-                    QName pName = ((PropertyId) event.getItemId()).getQName();
-                    // create a new property reference if it has not been
-                    // added by some earlier 'add' event
-                    ChildPropertyEntry re;
-                    if (hasPropertyName(pName)) {
-                        re = (ChildPropertyEntry) properties.get(pName);
-                    } else {
-                        re = PropertyReference.create(this, pName, isf, idFactory);
-                        properties.put(pName, re);
-                    }
-                    try {
-                        newState = re.getPropertyState();
-                    } catch (ItemStateException e) {
-                        log.error("Internal error", e);
-                    }
-                    // make sure this state is up to date (uuid/mixins)
-                    refresh(pName, event.getType());
-                }
-
-                // connect the added state from the transient layer to the
-                // new workspaceState and make sure its data are updated.
-                if (newState != null && changeLog != null) {
-                    for (Iterator it = changeLog.addedStates(); it.hasNext();) {
-                        ItemState added = (ItemState) it.next();
-                        if (added.hasOverlayedState()) {
-                            // already connected
-                            continue;
-                        }
-                        // TODO: TOBEFIXED. may fail (produce wrong results) for SNSs, since currently events upon 'save' are not garantied to be 'local' changes only
-                        // TODO: TOBEFIXED. equals to false if added-state is referenceable.
-                        if (added.getId().equals(evId)) {
-                            added.connect(newState);
-                            added.merge();
-                            break;
-                        }
-                    }
+                // create a new property reference if it has not been
+                // added by some earlier 'add' event
+                if (!hasPropertyName(name)) {
+                    ChildPropertyEntry re = PropertyReference.create(this, name, isf, idFactory);
+                    addPropertyEntry(re);
-                    QName qName = event.getQPath().getNameElement().getName();
-                    int index = event.getQPath().getNameElement().getNormalizedIndex();
-                    childNodeEntries.remove(qName, index);
+                    index = event.getQPath().getNameElement().getNormalizedIndex();
+                    childNodeEntries.remove(name, index);
-                if (id.equals(event.getParentId())) {
-                    QName pName = ((PropertyId) event.getItemId()).getQName();
-                    properties.remove(pName);
-                    // make sure this state is up to date (uuid/mixins)
-                    refresh(pName, event.getType());
-                    setStatus(Status.MODIFIED);
-                } else {
-                    // ILLEGAL
-                    throw new IllegalArgumentException("Illegal event type " + event.getType() + " for NodeState.");
-                }
+                removePropertyEntry(name);
+                setStatus(Status.MODIFIED);
-                if (id.equals(event.getParentId())) {
-                    QName pName = ((PropertyId) event.getItemId()).getQName();
-                    if (refresh(pName, event.getType())) {
-                        setStatus(Status.MODIFIED);
+                if (QName.JCR_UUID.equals(name) || QName.JCR_MIXINTYPES.equals(name)) {
+                    try {
+                        PropertyState ps = getPropertyState(name);
+                        adjustNodeState(this, new PropertyState[] {ps});
+                    } catch (ItemStateException e) {
+                        // should never occur.
+                        log.error("Internal error while updating node state.", e);
-                } else {
-                    // ILLEGAL
-                    throw new IllegalArgumentException("Illegal event type " + event.getType() + " for NodeState.");
+    //----------------------------------------------------< Session - State >---
-     * Returns true, if the uuid or the mixin types of this state have been
-     * modified.
-     *
-     * @param propertyName
-     * @param eventType
-     * @return
+     * {@inheritDoc}
+     * @see ItemState#refresh(Collection,ChangeLog)
-    private boolean refresh(QName propertyName, int eventType) {
-        if (QName.JCR_UUID.equals(propertyName)) {
-            // TODO: to be fixed.
-        } else if (QName.JCR_MIXINTYPES.equals(propertyName)) {
-            if (eventType == Event.PROPERTY_REMOVED) {
-                mixinTypeNames = QName.EMPTY_ARRAY;
-            } else { // added or changed
-                try {
-                    PropertyState ps = getPropertyState(propertyName);
-                    QValue[] values = ps.getValues();
-                    QName[] newMixins = new QName[values.length];
-                    for (int i = 0; i < values.length; i++) {
-                        newMixins[i] = QName.valueOf(values[i].getString());
-                    }
-                    mixinTypeNames = newMixins;
-                } catch (ItemStateException e) {
-                    // should never occur.
-                    log.error("Internal error while updating mixin types.", e);
-                } catch (RepositoryException e) {
-                    // should never occur.
-                    log.error("Internal error while updating mixin types.", e);
+    void refresh(Collection events, ChangeLog changeLog) throws IllegalStateException {
+
+        // remember parent states that have need to adjust their uuid/mixintypes
+        // or that got a new child entry added or existing entries removed.
+        HashMap modParents = new HashMap();
+
+        // process deleted states from the changelog
+        for (Iterator it = changeLog.deletedStates(); it.hasNext();) {
+            ItemState state = (ItemState) it.next();
+            state.setStatus(Status.REMOVED);
+            state.overlayedState.setStatus(Status.REMOVED);
+
+            // adjust parent states unless the parent is removed as well
+            NodeState parent = state.getParent();
+            if (!changeLog.deletedStates.contains(parent)) {
+                NodeState overlayedParent = (NodeState) parent.overlayedState;
+                if (state.isNode()) {
+                    overlayedParent.childNodeEntries.remove((NodeState)state.overlayedState);
+                } else {
+                    overlayedParent.removePropertyEntry(state.overlayedState.getQName());
+                modifiedParent(parent, state, modParents);
-            return true;
+            // don't remove processed state from changelog, but from event list
+            // state on changelog is used for check if parent is deleted as well.
+            removeEvent(events, state);
-        return false;
+
+        // process added states from the changelog. since the changlog maintains
+        // LinkedHashSet for its entries, the iterator will not return a added
+        // entry before its NEW parent.
+        for (Iterator it = changeLog.addedStates(); it.hasNext();) {
+            ItemState addedState = (ItemState) it.next();
+            NodeState parent = addedState.getParent();
+            // TODO: only retrieve overlayed state, if necessary
+            try {
+                // adjust parent child-entries
+                NodeState overlayedParent = (NodeState) parent.overlayedState;
+                QName addedName = addedState.getQName();
+                if (addedState.isNode()) {
+                    int index = parent.getChildNodeEntry((NodeState) addedState).getIndex();
+                    ChildNodeEntry cne;
+                    if (overlayedParent.hasChildNodeEntry(addedName, index)) {
+                        cne = overlayedParent.getChildNodeEntry(addedName, index);
+                    } else {
+                        cne = overlayedParent.childNodeEntries.add(addedState.getQName(), null, index);
+                    }
+                    NodeState overlayed = cne.getNodeState();
+                    if (overlayed.getUUID() != null) {
+                        overlayedParent.childNodeEntries.replaceEntry(overlayed);
+                    }
+                    addedState.connect(overlayed);
+                } else {
+                    ChildPropertyEntry pe;
+                    if (overlayedParent.hasPropertyName(addedName)) {
+                        pe = (ChildPropertyEntry) overlayedParent.properties.get(addedName);
+                    } else {
+                        pe = PropertyReference.create(overlayedParent, addedName, overlayedParent.isf,  overlayedParent.idFactory);
+                        overlayedParent.addPropertyEntry(pe);
+                    }
+                    addedState.connect(pe.getPropertyState());
+                }
+
+                // make sure the new state gets updated (e.g. uuid created by server)
+                addedState.reset();
+                // and mark the added-state existing
+                addedState.setStatus(Status.EXISTING);
+                // if parent is modified -> remember for final status reset
+                if (parent.getStatus() == Status.EXISTING_MODIFIED) {
+                    modifiedParent(parent, addedState, modParents);
+                }
+
+                it.remove();
+                removeEvent(events, addedState);
+            } catch (ItemStateException e) {
+                log.error("Internal error.", e);
+            }
+        }
+
+        for (Iterator it = changeLog.modifiedStates(); it.hasNext();) {
+            ItemState modState = (ItemState) it.next();
+            if (modState.isNode()) {
+                continue;
+            }
+            // push changes down to overlayed state
+            int type = ((PropertyState) modState).getType();
+            QValue[] values = ((PropertyState) modState).getValues();
+            ((PropertyState) modState.overlayedState).init(type, values);
+
+            modState.setStatus(Status.EXISTING);
+            // if property state defines a modified jcr:mixinTypes
+            // the parent is listed as modified state and needs to be
+            // processed at the end.
+            if (isUuidOrMixin(modState.getQName())) {
+                modifiedParent(this, modState, modParents);
+            }
+            // remove the processed event from the set
+            it.remove();
+            removeEvent(events, modState);
+        }
+
+        /* process all parent states that need their uuid or mixin-types being
+           adjusted because that property has been added or modified */
+        for (Iterator it = modParents.keySet().iterator(); it.hasNext();) {
+            NodeState parent = (NodeState) it.next();
+            List l = (List) modParents.get(parent);
+            adjustNodeState(parent, (PropertyState[]) l.toArray(new PropertyState[l.size()]));
+        }
+
+        /* finally check if all entries in the changelog have been processed
+           and eventually force a reload in order not to have any states with
+           wrong transient status floating around. */
+        Iterator[] its = new Iterator[] {changeLog.addedStates(), changeLog.deletedStates(), changeLog.modifiedStates()};
+        IteratorChain chain = new IteratorChain(its);
+        while (chain.hasNext()) {
+            ItemState state = (ItemState) chain.next();
+            if (!(state.getStatus() == Status.EXISTING || state.getStatus() == Status.REMOVED)) {
+                // error: state has not been processed
+                // TODO: discard state and force reload of all data
+            }
+        }
-    //----------------------------------------------------< Session - State >---
-                uuid = wspState.uuid;
-                nodeTypeName = wspState.nodeTypeName;
-                definition = wspState.definition;
-
-                init(wspState.getMixinTypeNames(), wspState.getChildNodeEntries(), wspState.getPropertyNames(), wspState.getNodeReferences());
-            }
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     * @see ItemState#merge()
-     */
-    synchronized void merge() {
-        checkIsSessionState();
-
-        if (overlayedState != null) {
-            synchronized (overlayedState) {
-                NodeState wspState = (NodeState) overlayedState;
-                name = wspState.name;
-                uuid = wspState.uuid;
+                setUUID(wspState.uuid);
-                references = wspState.getNodeReferences();
-                // search for removed properties
-                Collection wspProps = wspState.getPropertyNames();
+                // remove all entries in the attic
+                propertiesInAttic.clear();
+
+                // merge prop-names
+                Collection wspPropNames = wspState.getPropertyNames();
+                for (Iterator it = wspPropNames.iterator(); it.hasNext();) {
+                    QName propName = (QName) it.next();
+                    if (!hasPropertyName(propName)) {
+                        addPropertyEntry(PropertyReference.create(this, propName, isf, idFactory));
+                    }
+                }
-                    ChildPropertyEntry pe = (ChildPropertyEntry) properties.get((QName) it.next());
-                    if (pe.isAvailable()) {
-                        try {
-                            PropertyState ps = getPropertyState(pe.getName());
-                            if (ps.getStatus() == Status.REMOVED || ps.getStatus() == Status.STALE_DESTROYED) {
-                                it.remove();
-                            }
-                        } catch (ItemStateException e) {
-                            log.error("Internal error while merging item node states.", e);
-                        }
-                    } else if (!wspProps.contains(pe.getName())) {
-                        // not available and not present in wsp-layer any more.
+                    // remove all prop-entries in the session state that are
+                    // not present in the wsp-state.
+                    if (!wspPropNames.contains(it.next())) {
-                // add missing property entries
-                for (Iterator it = wspProps.iterator(); it.hasNext();) {
-                    QName propName = (QName) it.next();
-                    if (!hasPropertyName(propName)) {
-                        properties.put(propName, PropertyReference.create(this, propName, isf, idFactory));
-                    } // else property is already listed
-                }
-                Collection wspEntries = wspState.getChildNodeEntries();
-                // remove child entries, that are 'REMOVED' in the wsp layer
-                Set toRemove = new HashSet();
+                // merge child node entries
+                for (Iterator it = wspState.getChildNodeEntries().iterator(); it.hasNext();) {
+                    ChildNodeEntry cne = (ChildNodeEntry) it.next();
+                    int index = cne.getIndex();
+                    if (!childNodeEntries.contains(cne.getName(), index, cne.getUUID())) {
+                        childNodeEntries.add(cne.getName(), cne.getUUID(), index);
+                    }
+                }
+                List toRemove = new ArrayList();
-                    if (cne.isAvailable()) {
-                        try {
-                            NodeState ns = cne.getNodeState();
-                            if (ns.getStatus() == Status.REMOVED) {
-                                toRemove.add(cne);
-                            }
-                        } catch (ItemStateException e) {
-                            // should not occur
-                            log.error("Internal error while merging item node states.", e);
-                        }
-                    } else if (wspState.getChildNodeEntries(cne.getName()).isEmpty()) {
+                    if (!wspState.childNodeEntries.contains(cne.getName(), cne.getIndex(), cne.getUUID())) {
-                    } // TODO: clean up same-named siblings
+                    }
-
-                // add missing child entries
-                for (Iterator it = wspEntries.iterator(); it.hasNext();) {
-                    ChildNodeEntry wspEntry = (ChildNodeEntry) it.next();
-                    List namedEntries = getChildNodeEntries(wspEntry.getName());
-                    if (namedEntries.isEmpty()) {
-                        // simple case: no cne with the given name
-                        childNodeEntries.add(wspEntry.getName(), wspEntry.getUUID());
-                    } else {
-                        List wspCnes = wspState.getChildNodeEntries(wspEntry.getName());
-                        // TODO: compare sn-siblings an add missing ones
-                    }
-                }
+                // set the node references
+                references = wspState.references;
-        parent.childNodeStateRemoved(this);
+        getParent().childNodeStateRemoved(this);
-                parent.childNodeStateRemoved(this);
+                getParent().childNodeStateRemoved(this);
-                parent.childNodeStateRemoved(this);
+                getParent().childNodeStateRemoved(this);
-                parent.childNodeStateRemoved(this);
+                getParent().childNodeStateRemoved(this);
-     * @see ItemState#collectTransientStates(Set)
+     * @see ItemState#collectTransientStates(Collection)
-    void collectTransientStates(Set transientStates) {
+    void collectTransientStates(Collection transientStates) {
-     * Sets the names of this node's mixin types.
-     *
-     * @param mixinTypeNames set of names of mixin types
-     */
-    synchronized void setMixinTypeNames(QName[] mixinTypeNames) {
-        checkIsSessionState();
-
-        if (mixinTypeNames != null) {
-            this.mixinTypeNames = mixinTypeNames;
-        } else {
-            this.mixinTypeNames = new QName[0];
-        }
-        markModified();
-    }
-
-    /**
-     * @param uuid  the uuid of the child node state or <code>null</code> if
-     *              <code>child</code> cannot be identified with a uuid.
-    synchronized void addChildNodeState(NodeState child, String uuid) {
+    synchronized void addChildNodeState(NodeState child) {
-
+
-                properties.remove(propertyName);
+                removePropertyEntry(propertyName);
-        properties.put(propertyName, PropertyReference.create(propState, isf, idFactory));
+        addPropertyEntry(PropertyReference.create(propState, isf, idFactory));
-            properties.remove(propState.getQName());
+            removePropertyEntry(propState.getQName());
-
-
-        if (parent == null) {
+        if (getParent() == null) {
+    /**
+     *
+     * @param ps
+     * @return
+     * @throws RepositoryException
+     */
+    private static QName[] getMixinNames(PropertyState ps) throws RepositoryException {
+        assert QName.JCR_MIXINTYPES.equals(ps.getQName());
+
+        QValue[] values = ps.getValues();
+        QName[] newMixins = new QName[values.length];
+        for (int i = 0; i < values.length; i++) {
+            newMixins[i] = QName.valueOf(values[i].getString());
+        }
+        return newMixins;
+    }
+
+    private static boolean isUuidOrMixin(QName propName) {
+        return QName.JCR_UUID.equals(propName) || QName.JCR_MIXINTYPES.equals(propName);
+    }
+
+    private static void modifiedParent(NodeState parent, ItemState child, Map modParents) {
+        List l;
+        if (modParents.containsKey(parent)) {
+            l = (List) modParents.get(parent);
+        } else {
+            l = new ArrayList(2);
+            modParents.put(parent, l);
+        }
+        if (child != null && !child.isNode() && isUuidOrMixin(child.getQName())) {
+            l.add(child);
+        }
+    }
+
+    /**
+     *
+     * @param parent
+     * @param props
+     */
+    private static void adjustNodeState(NodeState parent, PropertyState[] props) {
+        NodeState overlayed = (parent.isWorkspaceState()) ? parent : (NodeState) parent.overlayedState;
+        NodeState sState = (parent.isWorkspaceState()) ? (NodeState) overlayed.getSessionState() : parent;
+
+        if (overlayed != null) {
+            for (int i = 0; i < props.length; i++) {
+                try {
+                    if (QName.JCR_UUID.equals(props[i].getQName())) {
+                        String uuid = (props[i].getStatus() == Status.REMOVED) ? null : props[i].getValue().getString();
+                        sState.setUUID(uuid);
+                        overlayed.setUUID(uuid);
+                    } else if (QName.JCR_MIXINTYPES.equals(props[i].getQName())) {
+                        QName[] mixins = (props[i].getStatus() == Status.REMOVED) ? QName.EMPTY_ARRAY : getMixinNames(props[i]);
+
+                        sState.mixinTypeNames = mixins;
+                        overlayed.mixinTypeNames = mixins;
+                    } // else: ignore.
+                } catch (RepositoryException e) {
+                    // should never occur.
+                    log.error("Internal error while updating node state.", e);
+                }
+            }
+
+            // make sure all other modifications on the overlayed state are
+            // reflected on the session-state.
+            sState.reset();
+            // make sure, the session-state gets its status reset to Existing.
+            if (sState.getStatus() == Status.EXISTING_MODIFIED) {
+                sState.setStatus(Status.EXISTING);
+            }
+        } else {
+            // should never occur.
+            log.warn("Error while adjusting nodestate: Overlayed state is missing.");
+        }
+    }
+         *
+         * @param name
+         * @param index
+         * @param uuid
+         * @return
+         */
+        private boolean contains(QName name, int index, String uuid) {
+            if (!nameMap.containsKey(name)) {
+                // no matching child node entry
+                return false;
+            }
+            Object o = nameMap.get(name);
+            if (o instanceof List) {
+                // SNS
+                for (Iterator it = ((List) o).iterator(); it.hasNext(); ) {
+                    LinkedEntries.LinkNode n = (LinkedEntries.LinkNode) it.next();
+                    ChildNodeEntry cne = n.getChildNodeEntry();
+                    if (uuid == null) {
+                        if (cne.getIndex() == index) {
+                            return true;
+                        }
+                    } else if (uuid.equals(cne.getUUID())) {
+                        return true;
+                    }
+                }
+                // no matching entry found
+                return false;
+            } else {
+                // single child node with this name
+                ChildNodeEntry cne = ((LinkedEntries.LinkNode) o).getChildNodeEntry();
+                if (uuid == null) {
+                    return cne.getUUID() == null;
+                } else {
+                    return uuid.equals(cne.getUUID());
+                }
+            }
+        }
+
+        /**
+         * 
+         * @param uuid
+         * @return
+         */
+        private ChildNodeEntry get(String uuid) {
+            for (Iterator it = entries.iterator(); it.hasNext();) {
+                LinkedEntries.LinkNode ln = (LinkedEntries.LinkNode) it.next();
+                ChildNodeEntry cne = ln.getChildNodeEntry();
+                if (cne.getUUID() == uuid) {
+                    return cne;
+                }
+            }
+            return null;
+        }
+
+        /**
-                        if (cne.isAvailable() && cne.getNodeState() == nodeState) {
+                        if (cne.getNodeState() == nodeState) {
-                    if (cne.isAvailable() && cne.getNodeState() == nodeState) {
+                    if (cne.getNodeState() == nodeState) {
-                return Collections.singletonList(
-                        ((LinkedEntries.LinkNode) obj).getChildNodeEntry());
+                return Collections.singletonList(((LinkedEntries.LinkNode) obj).getChildNodeEntry());
-            List siblings = null;
-            Object obj = nameMap.get(nodeName);
-            if (obj != null) {
-                if (obj instanceof List) {
-                    // map entry is a list of siblings
-                    siblings = (List) obj;
-                } else {
-                    // map entry is a single child node entry,
-                    // convert to siblings list
-                    siblings = new ArrayList();
-                    siblings.add(obj);
-                    nameMap.put(nodeName, siblings);
-                }
-            }
+            ChildNodeEntry cne = ChildNodeReference.create(NodeState.this, nodeName, uuid, isf, idFactory);
+            add(cne);
+            return cne;
+        }
-            ChildNodeEntry entry = ChildNodeReference.create(NodeState.this, nodeName, uuid, isf, idFactory);
-            LinkedEntries.LinkNode ln = entries.add(entry);
+        /**
+         * Insert a new childnode entry at the position indicated by index.
+         * @param nodeName
+         * @param uuid
+         * @param index
+         * @return
+         */
+        ChildNodeEntry add(QName nodeName, String uuid, int index) {
+            ChildNodeEntry cne = add(nodeName, uuid);
+            // TODO: in case of SNS, move new cne to the right position.
+            return cne;
+        }
-            if (siblings != null) {
-                siblings.add(ln);
-            } else {
-                nameMap.put(nodeName, ln);
-            }
-
-            return entry;
+        /**
+         * Adds a <code>childNode</code> to the end of the list.
+         *
+         * @param childState the <code>NodeState</code> to add.
+         * @return the <code>ChildNodeEntry</code> which was created for
+         *         <code>childNode</code>.
+         */
+        ChildNodeEntry add(NodeState childState) {
+            ChildNodeEntry cne = ChildNodeReference.create(childState, isf, idFactory);
+            add(cne);
+            return cne;
-         * Adds a <code>childNode</code> to the end of the list.
-         *
-         * @param childNode the <code>NodeState</code> to add.
-         * @return the <code>ChildNodeEntry</code> which was created for
-         *         <code>childNode</code>.
-         */
-        ChildNodeEntry add(NodeState childNode) {
-            ChildNodeEntry cne = ChildNodeReference.create(childNode, isf, idFactory);
-            add(cne);
-            return cne;
-        }
-
-        /**
-         *                   reordered to.
+         * reordered to.
-         *                                  <code>beforeNode</code> does not
-         *                                  have a <code>ChildNodeEntry</code>
-         *                                  in this <code>ChildNodeEntries</code>.
+         * <code>beforeNode</code> does not have a <code>ChildNodeEntry</code>
+         * in this <code>ChildNodeEntries</code>.
+         * If the given child state got a (new) uuid assigned or its removed,
+         * its childEntry must be adjusted.
+         *
+         * @param childState
+         */
+        private void replaceEntry(NodeState childState) {
+            // NOTE: test if child-state needs to get a new entry not checked here.
+            try {
+                Object replaceObj = nameMap.get(childState.getQName());
+                LinkedEntries.LinkNode ln = getLinkNode(replaceObj, childState);
+                ChildNodeEntry newCne = ChildNodeReference.create(childState, isf, idFactory);
+                entries.replaceNode(ln, newCne);
+            } catch (NoSuchItemStateException e) {
+                log.error("Internal error.", e);
+            }
+        }
+
+        /**
+         * Replace the value of the given LinkNode with a new childNodeEntry
+         * value.
+         *
+         * @param node
+         * @param value
+         */
+        void replaceNode(LinkNode node, ChildNodeEntry value) {
+            updateNode(node, value);
+        }
+
+        /**

MOV26 MOV31 MOV31 MOV31 UPD40 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS8 MOV8 INS29 UPD83 MOV83 MOV39 UPD42 MOV42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 MOV29 INS83 INS39 INS42 MOV44 INS8 INS29 INS39 INS42 INS44 MOV44 INS43 INS8 MOV29 UPD42 INS83 MOV5 INS42 INS44 INS43 MOV8 INS83 INS83 INS39 INS42 MOV44 INS8 INS83 UPD83 UPD42 INS44 INS44 INS44 INS8 INS83 UPD83 UPD42 INS44 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS40 MOV25 INS21 INS65 INS65 INS65 INS65 INS25 INS60 MOV65 INS65 INS43 INS42 INS60 INS60 INS25 INS65 MOV43 INS42 INS60 INS21 INS54 INS65 MOV43 INS42 INS25 MOV21 MOV60 MOV60 INS50 MOV65 INS65 MOV43 INS42 INS42 INS60 INS24 INS24 INS24 INS24 INS60 INS60 INS61 UPD43 UPD65 UPD65 INS43 INS42 INS42 INS6 INS41 UPD42 INS41 INS43 INS42 INS43 INS42 INS43 INS42 INS60 INS25 INS25 UPD65 INS43 INS42 UPD5 UPD42 INS60 INS60 INS25 INS29 INS83 INS39 INS42 INS44 INS44 MOV44 INS8 INS29 INS83 INS43 INS42 INS44 INS8 MOV29 MOV43 INS42 MOV44 MOV44 INS8 INS29 INS43 INS42 INS44 INS44 INS44 INS8 MOV29 MOV43 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS39 INS42 INS44 INS44 INS8 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 MOV32 MOV32 INS27 INS8 INS43 INS59 UPD66 UPD66 INS66 INS66 INS42 UPD42 MOV42 INS43 INS59 INS39 INS59 INS42 INS8 INS42 MOV43 INS59 INS32 INS8 INS12 INS12 INS42 INS27 INS8 MOV32 MOV49 MOV60 INS60 INS60 INS60 MOV25 MOV21 INS10 MOV49 INS25 MOV21 INS10 MOV49 MOV25 INS10 MOV49 INS21 MOV21 INS10 MOV49 INS25 INS10 INS49 MOV53 INS68 INS43 INS59 INS58 INS32 INS8 MOV58 MOV32 INS8 INS58 INS32 INS8 INS58 MOV32 INS8 INS5 INS59 INS43 INS59 INS32 INS8 UPD42 UPD42 INS42 INS42 INS32 INS42 INS27 INS42 UPD42 MOV42 UPD42 MOV42 MOV43 INS59 INS32 INS8 INS8 INS27 INS8 INS42 UPD42 INS42 UPD43 INS43 INS59 INS43 INS59 MOV27 INS8 INS8 INS65 INS65 INS65 INS65 INS43 INS42 INS39 INS42 INS25 MOV60 MOV25 INS65 INS65 INS42 INS43 INS42 INS24 MOV41 INS25 MOV60 MOV21 MOV41 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS39 INS42 MOV60 INS41 INS43 INS42 INS60 MOV21 INS41 INS65 INS65 INS43 INS42 INS54 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS21 INS42 INS42 INS42 INS33 INS60 INS25 INS42 INS42 INS32 INS42 UPD42 MOV42 INS22 INS42 INS16 INS21 INS25 INS42 INS32 INS42 INS42 INS42 INS42 INS25 MOV44 INS8 MOV44 INS8 INS32 INS33 INS25 MOV43 INS59 MOV43 MOV59 MOV43 MOV59 INS38 INS8 INS32 INS27 INS8 INS42 INS42 INS69 MOV69 INS42 INS42 INS14 INS43 INS59 INS42 INS42 MOV60 INS21 INS21 INS60 INS25 INS21 INS60 INS60 INS54 MOV43 INS59 UPD42 MOV42 UPD42 MOV42 INS60 INS25 INS60 MOV60 MOV21 INS21 INS25 INS21 INS21 MOV43 INS59 MOV60 INS60 INS21 INS43 INS85 INS42 INS3 INS42 INS42 INS14 UPD42 MOV42 UPD42 MOV42 MOV60 MOV25 INS32 UPD42 INS32 INS40 INS42 INS32 MOV32 INS32 INS42 INS42 INS42 INS42 MOV21 MOV21 INS21 INS27 INS32 INS21 UPD42 INS42 INS42 INS16 INS42 INS42 INS16 UPD42 INS24 INS21 INS25 INS21 INS42 INS42 INS42 INS42 INS38 INS8 INS8 INS42 UPD42 MOV42 INS58 INS32 INS8 INS62 INS8 MOV8 INS66 INS42 INS42 INS42 INS42 INS42 INS43 INS42 UPD42 INS42 INS43 INS59 INS42 UPD66 INS66 INS66 INS42 INS42 INS8 INS12 INS66 INS66 INS42 INS42 INS42 INS42 INS32 MOV43 INS59 INS38 INS8 INS42 INS52 INS42 INS36 INS27 INS38 INS7 INS27 INS8 UPD42 MOV42 UPD42 MOV42 INS27 INS8 INS21 INS21 INS42 INS42 INS42 INS32 INS8 INS42 MOV11 INS32 INS60 INS21 INS21 INS42 INS42 INS32 INS32 MOV54 INS43 INS43 INS42 INS42 INS32 INS32 INS32 INS43 INS59 INS38 INS8 INS32 MOV43 INS59 INS43 INS59 INS8 INS12 INS42 INS32 INS43 INS59 INS32 MOV8 INS39 INS59 INS5 INS32 INS32 INS8 INS32 INS32 INS42 INS32 MOV43 MOV43 INS59 INS32 INS42 INS5 INS4 INS43 INS42 UPD43 INS38 UPD42 MOV42 INS32 INS32 INS32 UPD43 INS42 UPD42 MOV42 UPD42 MOV42 INS40 UPD42 UPD42 INS40 INS42 INS42 INS32 INS27 INS38 INS42 MOV32 INS32 INS36 INS42 INS11 INS36 INS11 INS42 INS58 INS27 INS37 INS8 INS32 INS27 INS8 INS32 INS32 INS41 UPD42 MOV41 MOV60 INS25 INS43 INS59 INS42 UPD42 MOV42 INS60 INS60 INS25 INS42 INS43 INS24 INS60 UPD42 INS42 UPD42 INS42 INS42 INS32 UPD42 INS60 INS60 MOV60 INS21 INS44 INS8 INS42 INS42 INS42 MOV21 INS21 INS21 MOV21 UPD42 INS32 INS42 INS32 MOV32 INS54 INS27 INS42 INS33 INS32 INS22 INS42 INS32 INS33 INS21 INS32 INS32 INS25 INS32 INS32 INS42 INS25 MOV32 UPD42 INS42 INS42 INS42 MOV43 INS59 INS32 INS7 INS40 INS42 INS42 INS40 INS42 INS42 INS8 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS40 INS40 INS42 INS40 INS42 INS42 INS32 INS32 INS60 INS25 INS21 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS32 INS60 INS60 INS25 INS21 INS21 INS25 INS21 MOV21 MOV44 INS8 INS42 UPD42 MOV42 INS42 INS42 INS11 INS42 INS42 INS42 INS32 INS43 INS85 UPD42 INS36 UPD42 UPD42 INS42 UPD42 MOV42 INS42 INS40 INS42 INS32 INS21 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS32 INS42 UPD42 INS42 INS11 INS42 INS42 INS11 INS43 INS85 INS32 INS32 INS32 INS42 UPD42 UPD42 INS11 INS36 INS24 INS24 INS60 INS24 INS21 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 INS11 UPD42 INS14 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS33 INS32 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS43 INS40 INS32 MOV43 INS32 INS39 INS59 INS42 INS40 INS42 INS54 INS42 INS42 INS32 INS40 INS21 INS42 INS42 INS45 INS42 INS42 INS42 INS9 UPD42 INS8 INS27 INS8 INS8 INS42 INS42 INS32 MOV43 INS59 MOV43 INS59 INS27 MOV8 INS42 INS58 INS32 MOV8 INS43 INS59 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS43 INS32 INS43 INS42 INS21 INS7 INS7 MOV32 INS42 INS42 INS40 INS42 INS42 MOV8 MOV12 INS42 INS33 INS42 INS42 INS42 INS52 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS8 INS25 INS42 UPD42 MOV42 INS45 UPD42 MOV42 INS42 INS42 INS45 INS42 INS32 INS8 INS25 INS42 INS42 INS32 INS42 INS42 INS42 MOV32 UPD42 INS60 INS21 MOV44 INS42 INS42 INS40 INS42 INS42 INS43 INS59 INS32 INS8 INS8 INS32 UPD43 MOV43 MOV32 INS42 INS42 INS43 INS59 MOV43 INS59 INS32 INS8 INS8 INS32 INS32 INS27 INS8 INS32 MOV21 INS43 INS32 INS36 INS42 UPD42 MOV42 UPD42 INS11 INS42 UPD42 MOV42 INS32 INS42 INS42 INS43 MOV43 INS32 INS5 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD43 MOV43 MOV32 INS27 INS32 INS32 MOV58 MOV32 INS8 INS58 INS32 INS8 MOV43 INS59 MOV58 MOV32 MOV8 INS7 MOV43 INS32 INS43 INS34 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS34 INS8 INS12 INS42 INS42 INS32 MOV60 MOV60 INS25 INS42 INS33 INS41 INS41 INS42 INS42 INS42 MOV11 INS42 INS32 INS32 INS42 INS43 INS59 INS42 INS42 INS60 INS60 INS42 INS42 INS32 INS42 INS42 INS32 INS40 INS42 INS32 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 MOV42 MOV40 INS42 MOV40 INS42 MOV40 UPD42 MOV42 INS32 INS22 INS42 INS52 MOV32 INS27 INS60 INS21 INS27 INS8 INS40 INS42 INS42 INS21 INS32 MOV8 INS42 INS42 INS42 INS52 INS42 INS42 INS42 UPD42 INS43 INS59 INS32 INS42 INS42 INS11 INS42 INS42 INS21 INS21 INS42 INS42 INS42 INS42 UPD42 UPD42 UPD42 INS42 INS42 INS11 INS42 INS32 INS42 INS42 INS60 MOV60 INS25 MOV60 INS25 MOV21 INS60 INS25 MOV21 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS40 INS32 INS40 INS21 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS11 INS43 INS40 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS85 INS42 INS42 INS3 UPD42 UPD42 UPD42 INS27 INS27 INS42 INS40 UPD42 MOV42 UPD42 MOV42 UPD42 INS43 MOV25 INS43 MOV59 INS42 UPD42 MOV42 MOV60 INS60 INS25 INS42 INS42 MOV14 INS42 INS40 INS42 INS42 INS42 INS42 INS25 INS44 INS8 INS42 INS42 INS40 INS27 INS8 INS25 INS27 INS32 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS59 INS43 INS59 INS36 INS42 MOV27 INS8 MOV42 UPD42 MOV42 INS32 INS42 INS42 INS42 UPD42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS32 INS42 INS40 UPD42 UPD42 UPD42 MOV42 INS33 UPD43 MOV43 MOV59 INS32 INS32 INS36 INS60 INS21 INS32 INS40 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS52 INS3 INS43 INS40 INS32 INS32 INS43 INS40 INS42 MOV42 INS39 INS59 MOV43 MOV32 MOV8 INS8 INS43 INS27 INS8 MOV43 INS59 INS32 INS8 INS8 INS42 INS42 INS32 UPD42 INS42 INS45 UPD42 MOV43 INS42 UPD43 INS42 INS42 UPD42 MOV42 INS5 INS32 INS32 INS40 INS32 INS40 INS42 INS38 MOV8 UPD42 MOV42 UPD42 INS32 INS39 INS59 MOV38 INS8 INS43 INS38 MOV8 UPD42 INS32 MOV8 INS25 INS43 INS42 MOV21 INS42 INS33 INS25 INS32 INS8 INS32 INS33 INS42 INS42 INS32 INS40 INS36 INS42 INS40 INS42 INS11 INS42 INS42 INS32 INS11 INS41 INS42 UPD42 MOV42 INS42 INS42 UPD42 UPD42 INS42 INS32 INS40 INS42 INS42 INS27 INS43 MOV59 INS7 INS42 INS33 INS42 INS42 INS5 INS4 UPD45 INS42 INS40 INS42 INS11 INS42 INS42 INS32 INS42 INS42 INS32 UPD42 INS42 UPD42 UPD42 INS42 MOV21 INS42 UPD42 INS32 INS33 INS21 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS21 MOV21 INS21 UPD42 UPD42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 INS43 INS85 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 INS32 MOV32 INS42 INS42 INS32 INS21 INS42 UPD42 INS11 INS32 INS40 INS42 INS32 INS60 INS21 INS32 MOV8 INS42 INS27 INS8 INS42 INS42 INS32 INS41 INS42 INS42 INS42 INS42 INS11 INS43 INS32 INS42 INS42 MOV27 MOV8 INS43 INS42 INS42 UPD42 UPD42 INS32 INS42 INS27 INS27 INS42 INS42 INS32 INS42 INS32 MOV43 INS85 INS42 INS43 INS40 INS40 INS42 INS32 INS42 INS42 INS42 INS32 INS7 INS32 UPD42 UPD42 INS42 UPD42 MOV42 UPD42 MOV42 INS32 UPD42 MOV42 INS42 UPD42 MOV32 INS42 INS32 INS43 INS32 INS40 UPD42 MOV42 MOV32 MOV32 INS32 INS2 INS42 INS43 INS59 INS32 INS32 INS40 INS42 INS32 INS60 INS21 UPD42 INS42 INS45 INS42 INS32 INS42 MOV41 INS42 INS42 INS9 INS43 INS42 INS40 INS42 INS42 INS40 INS42 INS42 INS42 INS33 INS40 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS11 UPD42 INS32 UPD42 INS40 INS42 INS42 INS42 INS11 UPD42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 MOV42 MOV42 INS32 MOV32 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS16 INS42 INS42 INS42 INS42 INS42 INS42 INS2 INS42 MOV5 INS59 INS7 INS42 INS42 INS42 INS43 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS40 UPD42 INS32 INS33 UPD42 MOV43 INS32 UPD42 UPD42 INS42 INS42 INS40 INS40 MOV42 UPD42 MOV42 UPD42 UPD42 INS36 INS33 INS32 INS42 INS42 INS42 INS16 INS40 INS42 INS40 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS40 INS42 INS42 INS27 INS32 INS42 INS36 INS40 INS32 INS32 INS40 INS2 INS42 INS27 INS42 INS2 INS2 INS42 INS42 INS42 INS32 INS40 INS42 INS42 INS42 INS42 INS2 INS42 INS42 INS42 DEL34 DEL3 DEL29 DEL83 DEL83 DEL43 DEL59 DEL23 DEL52 DEL42 DEL22 DEL42 DEL7 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL42 DEL7 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL83 DEL42 DEL32 DEL40 DEL27 DEL8 DEL25 DEL8 DEL42 DEL33 DEL42 DEL65 DEL42 DEL36 DEL42 DEL11 DEL36 DEL42 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL32 DEL11 DEL52 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL32 DEL32 DEL42 DEL42 DEL32 DEL32 DEL38 DEL42 DEL43 DEL45 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL60 DEL60 DEL32 DEL60 DEL60 DEL8 DEL42 DEL11 DEL36 DEL32 DEL59 DEL60 DEL8 DEL25 DEL8 DEL54 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL33 DEL27 DEL27 DEL32 DEL25 DEL32 DEL32 DEL10 DEL8 DEL25 DEL8 DEL24 DEL8 DEL25 DEL10 DEL10 DEL42 DEL32 DEL32 DEL32 DEL32 DEL21 DEL8 DEL43 DEL45 DEL32 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL10 DEL42 DEL42 DEL32 DEL32 DEL8 DEL42 DEL43 DEL45 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL10 DEL49 DEL50 DEL8 DEL31 DEL42 DEL42 DEL68 DEL65 DEL29 DEL42 DEL40 DEL7 DEL42 DEL32 DEL7 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL8 DEL43 DEL42 DEL44 DEL42 DEL45 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL25 DEL25 DEL8 DEL24 DEL42 DEL42 DEL42 DEL32 DEL40 DEL27 DEL42 DEL32 DEL40 DEL27 DEL27 DEL32 DEL21 DEL8 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL8 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL32 DEL40 DEL27 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL45 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL32 DEL25 DEL25 DEL8 DEL24 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL24 DEL42 DEL66 DEL66 DEL65 DEL42 DEL42 DEL42 DEL42 DEL42 DEL66 DEL66 DEL65 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL7 DEL21 DEL39 DEL42 DEL39 DEL42 DEL44 DEL40 DEL42 DEL42 DEL32 DEL8 DEL40 DEL42 DEL42 DEL32 DEL42 DEL40 DEL27 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL25 DEL25 DEL8 DEL42 DEL32 DEL21 DEL8 DEL66 DEL66 DEL52 DEL42 DEL22 DEL42 DEL7 DEL52 DEL42 DEL22 DEL34 DEL3 DEL32 DEL21 DEL25 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL42 DEL42 DEL33 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL62 DEL42 DEL42 DEL11 DEL7 DEL21 DEL8 DEL42 DEL7 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL33 DEL27 DEL8 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL42 DEL42 DEL44 DEL8 DEL31 DEL66
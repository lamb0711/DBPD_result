JCR-2855: Writers blocked forever when waiting on update operations

Automatically clear a downgraded activeWriterId when the last reader lock is released.

Also add generics.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@1066059 13f79535-47bb-0310-9956-ffa450edef68

+import java.util.concurrent.atomic.AtomicInteger;
+     * Number of current readers.
+     */
+    private final AtomicInteger readerCount = new AtomicInteger(0);
+
+    /**
-    private List waitingReaders = Collections.synchronizedList(new LinkedList());
+    private List<Sync> waitingReaders =
+        Collections.synchronizedList(new LinkedList<Sync>());
-    private List waitingWriters = new LinkedList();
+    private List<Sync> waitingWriters = new LinkedList<Sync>();
+            readerCount.incrementAndGet();
+                    readerCount.incrementAndGet();
+            readerCount.incrementAndGet();
+                if (readerCount.decrementAndGet() == 0 && activeWriter == null) {
+                    activeWriterId = null;
+                }
-        Iterator it = waitingReaders.iterator();
+        Iterator<Sync> it = waitingReaders.iterator();
-            ((Sync) it.next()).release();
+            it.next().release();
-            Iterator it = waitingWriters.iterator();
+            Iterator<Sync> it = waitingWriters.iterator();
-                ((Sync) it.next()).release();
+                it.next().release();
-        private final Map[] slots = new Map[0x10];
+        @SuppressWarnings("unchecked")
+        private final Map<ItemId, Integer>[] slots = new Map[0x10];
-                slots[i] = new HashMap();
+                slots[i] = new HashMap<ItemId, Integer>();
-            Map locks = slots[slotIndex(id)];
+            Map<ItemId, Integer> locks = slots[slotIndex(id)];
-            Map locks = slots[slotIndex(id)];
+            Map<ItemId, Integer> locks = slots[slotIndex(id)];
-                Map locks = slots[i];
-                if (!locks.isEmpty()) {
-                    Iterator it = locks.keySet().iterator();
-                    while (it.hasNext()) {
-                        ItemId id = (ItemId) it.next();
-                        if (FineGrainedISMLocking.hasDependency(changes, id)) {
-                            return true;
-                        }
+                Map<ItemId, Integer> locks = slots[i];
+                for (ItemId id : locks.keySet()) {
+                    if (FineGrainedISMLocking.hasDependency(changes, id)) {
+                        return true;

INS26 MOV31 INS40 INS23 INS29 INS83 INS83 INS43 INS59 INS74 INS74 MOV8 MOV29 UPD42 MOV8 MOV29 UPD42 INS8 INS65 INS42 INS42 INS14 MOV43 INS43 MOV43 INS43 MOV14 INS25 INS24 MOV60 INS51 INS79 UPD5 INS66 INS43 INS34 INS42 MOV14 INS42 INS74 MOV32 MOV8 INS8 INS21 INS74 INS42 MOV8 INS42 INS45 INS74 INS60 MOV60 INS42 INS74 MOV43 INS43 INS21 MOV60 MOV60 MOV21 MOV54 MOV21 INS32 MOV43 MOV43 MOV25 INS60 MOV43 INS43 INS43 INS74 MOV59 INS74 MOV43 INS43 INS42 INS32 INS42 INS42 INS25 INS74 MOV59 INS42 INS42 INS42 MOV43 INS43 INS43 MOV43 MOV43 INS43 INS70 INS42 INS42 INS42 INS27 INS8 MOV32 MOV43 MOV43 INS42 INS42 MOV42 INS42 INS74 INS44 MOV32 MOV8 MOV8 INS27 INS27 INS21 MOV43 MOV43 INS43 INS43 INS42 INS21 INS32 INS34 INS42 INS33 INS7 MOV32 INS74 INS42 UPD42 MOV42 INS32 INS42 INS42 INS42 INS33 MOV43 INS43 INS43 INS42 INS42 INS42 INS42 DEL25 DEL24 DEL8 DEL60 DEL11 DEL36 DEL42 DEL51 DEL8 DEL11 DEL36 DEL60 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL32 DEL38 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL8 DEL25
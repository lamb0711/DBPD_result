work in progress

- operations: rename getAffectedIds to getAffectedStates
- operations: return ItemState params instead of ids whereever possible and
  let OperationVisitor deal with all kind of issues arising with SPI ids.
- AddNode/AddProperty operations: don't list state to be created as affected. Not required since operations are collected upon refresh/save, in which case a 'new' item can never be the starting point.
- transient move: let parent NodeState handle the move/renaming of child states
- transient reorder: let parent NodeState handle the reorder logic
- NodeState: remove unused methods and mark setParent private
- NodeImpl: protected getNodeId() no more used by subclasses in version package.

git-svn-id: https://svn.apache.org/repos/asf/jackrabbit/trunk@431887 13f79535-47bb-0310-9956-ffa450edef68

-                     QName nodeTypeName, int initialStatus, boolean isTransient,
-                     ItemStateFactory isf, IdFactory idFactory) {
+                        QName nodeTypeName, int initialStatus, boolean isTransient,
+                        ItemStateFactory isf, IdFactory idFactory) {
-                     int initialStatus, boolean isTransient,
-                     ItemStateFactory isf, IdFactory idFactory) {
+                        int initialStatus, boolean isTransient,
+                        ItemStateFactory isf, IdFactory idFactory) {
-    // TODO: change to private and only let new parent node state set the parent.
-    void setParent(NodeState parent) {
+    private void setParent(NodeState parent) {
-     * @see #removeChildNodeEntry
-     * @see #removeChildNodeEntry
-     * @see #removeChildNodeEntry
-    synchronized ChildNodeEntry addChildNodeEntry(QName nodeName,
-                                                  NodeId id) {
+    synchronized ChildNodeEntry addChildNodeEntry(QName nodeName, NodeId id) {
-     * Renames a new <code>ChildNodeEntry</code>.
-     *
-     * @param oldName <code>QName</code> object specifying the entry's old name
-     * @param index 1-based index if there are same-name child node entries
-     * @param newName <code>QName</code> object specifying the entry's new name
-     * @return <code>true</code> if the entry was sucessfully renamed;
-     *         otherwise <code>false</code>
-     */
-    synchronized boolean renameChildNodeEntry(QName oldName, int index,
-                                                     QName newName) {
-        ChildNodeEntry oldEntry = childNodeEntries.remove(oldName, index);
-        if (oldEntry != null) {
-            ChildNodeEntry newEntry = childNodeEntries.add(newName, oldEntry.getId());
-            notifyNodeAdded(newEntry);
-            notifyNodeRemoved(oldEntry);
-            return true;
-        }
-        return false;
-    }
-
-    /**
-     * Removes a <code>ChildNodeEntry</code>.
-     *
-     * @param nodeName <code>ChildNodeEntry</code> object specifying a node name
-     * @param index    1-based index if there are same-name child node entries
-     * @return <code>true</code> if the specified child node entry was found
-     *         in the list of child node entries and could be removed.
-     */
-    synchronized boolean removeChildNodeEntry(QName nodeName, int index) {
-        ChildNodeEntry entry = childNodeEntries.remove(nodeName, index);
-        if (entry != null) {
-            notifyNodeRemoved(entry);
-        }
-        return entry != null;
-    }
-
-    /**
-     * Removes a <code>ChildNodeEntry</code>.
-     *
-     * @param id the id of the entry to be removed
-     * @return <code>true</code> if the specified child node entry was found
-     *         in the list of child node entries and could be removed.
-     */
-    synchronized boolean removeChildNodeEntry(NodeId id) {
-        ChildNodeEntry entry = childNodeEntries.remove(id);
-        if (entry != null) {
-            notifyNodeRemoved(entry);
-        }
-        return entry != null;
-    }
-
-    /**
-     * Removes all <code>ChildNodeEntry</code>s.
-     */
-    synchronized void removeAllChildNodeEntries() {
-        childNodeEntries.removeAll();
-    }
-
-    /**
-    synchronized void childNodeStateRemoved(NodeState nodeState) {
+    private synchronized void childNodeStateRemoved(NodeState nodeState) {
-     * Sets the list of <code>ChildNodeEntry</code> objects denoting the
-     * child nodes of this node.
-     */
-    synchronized void setChildNodeEntries(List nodeEntries) {
-        // re-create child node entries
-        childNodeEntries.clear(); // TODO: any mre cleanup work to do? try some kind of merging?
-        for (Iterator it = nodeEntries.iterator(); it.hasNext(); ) {
-            ChildNodeEntry cne = (ChildNodeEntry) it.next();
-            childNodeEntries.add(cne.getName(), cne.getId());
-        }
-        notifyNodesReplaced();
-    }
-
-    /**
-
-     * @see #removePropertyName
-     * @see #removePropertyName
-     * Removes a property name entry.
-     *
-     * @param propName <code>QName</code> object specifying the property name
-     * @return <code>true</code> if the specified property name was found
-     *         in the list of property name entries and could be removed.
-     */
-    synchronized boolean removePropertyName(QName propName) {
-        return properties.remove(propName) != null;
-    }
-
-    /**
-    /**
-     * Removes all property name entries.
-     */
-    synchronized void removeAllPropertyNames() {
-        properties.clear();
-    }
-
-    /**
-     * Sets the set of <code>QName</code> objects denoting the
-     * properties of this node.
-     */
-    synchronized void setPropertyNames(Set propNames) {
-        removeAllPropertyNames();
-        for (Iterator it = propNames.iterator(); it.hasNext(); ) {
-            addPropertyName((QName) it.next());
-        }
-    }
-
-    /**
+    /*
+     *
+     * @param insertNodeId
+     * @param beforeNodeId
+     */
+    synchronized void reorderChildNodeEntries(NodeId insertNodeId, NodeId beforeNodeId)
+        throws NoSuchItemStateException {
+        // validate existance of child node entries even if this has been
+        // checked within NodeImpl.
+        if (childNodeEntries.get(insertNodeId) == null) {
+            throw new NoSuchItemStateException("No such child node entry: " + insertNodeId);
+        }
+        if (beforeNodeId != null && childNodeEntries.get(insertNodeId) == null) {
+            throw new NoSuchItemStateException("No such child node entry: " + beforeNodeId);
+        }
+
+        // TODO: check again. Reorder with SPI-Id
+        ArrayList nodeEntries = new ArrayList(childNodeEntries);
+        int srcInd = -1, destInd = -1;
+        for (int i = 0; i < nodeEntries.size(); i++) {
+            ChildNodeEntry entry = (ChildNodeEntry) nodeEntries.get(i);
+            if (srcInd == -1) {
+                if (entry.getId().equals(insertNodeId)) {
+                    srcInd = i;
+                }
+            }
+            if (destInd == -1 && beforeNodeId != null) {
+                if (entry.getId().equals(beforeNodeId)) {
+                    destInd = i;
+                    if (srcInd != -1) {
+                        break;
+                    }
+                }
+            } else {
+                if (srcInd != -1) {
+                    break;
+                }
+            }
+        }
+
+        // check if resulting order would be different to current order
+        if (destInd == -1) {
+            if (srcInd == nodeEntries.size() - 1) {
+                // no change, we're done
+                return;
+            }
+        } else {
+            if ((destInd - srcInd) == Path.INDEX_DEFAULT) {
+                // no change, we're done
+                return;
+            }
+        }
+        // reorder list
+        if (destInd == -1) {
+            nodeEntries.add(nodeEntries.remove(srcInd));
+        } else {
+            if (srcInd < destInd) {
+                nodeEntries.add(destInd, nodeEntries.get(srcInd));
+                nodeEntries.remove(srcInd);
+            } else {
+                nodeEntries.add(destInd, nodeEntries.remove(srcInd));
+            }
+        }
+
+        // re-create child node entries
+        childNodeEntries.clear(); // TODO: any mre cleanup work to do? try some kind of merging?
+        for (Iterator it = nodeEntries.iterator(); it.hasNext(); ) {
+            ChildNodeEntry cne = (ChildNodeEntry) it.next();
+            childNodeEntries.add(cne.getName(), cne.getId());
+        }
+        // TODO: correct?
+        notifyNodesReplaced();
+    }
+
+    /**
+     * Renames a new <code>ChildNodeEntry</code>.
+     *
+     * @param newParent
+     * @param childState
+     * @param newName
+     * @param newName <code>QName</code> object specifying the entry's new name
+     * @throws RepositoryException if the given child state is not a child
+     * of this node state.
+     */
+    // TODO: review. move with SPI Ids
+    synchronized void moveChildNodeEntry(NodeState newParent, NodeState childState, QName newName)
+        throws RepositoryException {
+        NodeId childId = childState.getNodeId();
+        // rename only
+        ChildNodeEntry oldEntry = childNodeEntries.remove(childId);
+        if (oldEntry != null) {
+            if (newParent == this) {
+                ChildNodeEntry newEntry = childNodeEntries.add(name, oldEntry.getId());
+                notifyNodeAdded(newEntry);
+                notifyNodeRemoved(oldEntry);
+            } else {
+                notifyNodeRemoved(oldEntry);
+                // re-parent target node
+                childState.setParent(newParent);
+                // add child node entry to new parent
+                newParent.addChildNodeEntry(newName, childId);
+            }
+        } else {
+            throw new RepositoryException("Unexpected error: Child state to be renamed does not exist.");
+        }
+    }
+    
+    /**
-    protected void notifyNodeAdded(ChildNodeEntry added) {
+    private void notifyNodeAdded(ChildNodeEntry added) {
-    protected void notifyNodesReplaced() {
+    private void notifyNodesReplaced() {
-    protected void notifyNodeRemoved(ChildNodeEntry removed) {
+    private void notifyNodeRemoved(ChildNodeEntry removed) {

MOV31 INS31 INS83 INS83 MOV29 MOV83 UPD39 MOV39 UPD42 MOV42 MOV44 MOV44 INS43 INS8 UPD42 INS44 MOV44 INS43 INS8 UPD83 UPD83 UPD83 UPD43 UPD42 INS43 INS42 INS42 INS25 INS25 INS60 INS60 INS24 INS25 INS25 MOV21 MOV24 MOV21 MOV65 INS65 INS65 INS65 MOV65 UPD65 UPD43 UPD42 INS43 INS42 UPD42 MOV42 INS60 INS60 INS25 UPD42 UPD42 UPD42 INS42 INS27 INS8 INS27 INS8 INS43 INS59 INS39 INS59 INS59 INS58 INS27 INS37 INS8 INS27 MOV8 INS8 INS27 INS8 INS8 INS42 INS42 INS42 INS42 UPD66 UPD66 UPD42 INS42 INS43 INS59 MOV43 INS59 MOV27 MOV8 INS8 INS32 INS33 INS53 INS27 INS27 INS53 INS42 INS42 INS14 INS42 INS38 INS42 INS38 INS39 INS59 INS42 INS32 INS42 MOV60 MOV25 INS25 INS42 INS38 INS25 INS25 INS42 INS38 MOV21 INS25 INS42 UPD42 MOV42 MOV32 INS42 INS32 INS53 INS42 INS42 INS42 INS14 INS42 INS33 INS32 INS33 INS14 INS43 INS42 INS34 INS34 INS42 INS34 INS42 INS42 MOV43 UPD27 INS27 INS8 INS8 INS34 INS27 INS8 INS27 INS8 INS34 INS32 INS27 INS8 INS8 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 INS27 INS8 INS14 INS43 INS27 INS42 INS42 INS42 INS43 INS27 INS42 INS11 UPD42 INS38 INS25 INS27 INS27 INS25 INS25 INS42 INS27 INS41 INS36 INS40 INS41 INS42 INS42 INS32 INS42 INS42 INS21 INS21 MOV21 INS42 INS52 INS21 INS21 INS21 INS43 INS45 INS42 INS45 INS42 UPD42 MOV42 INS45 INS42 MOV43 INS32 INS34 INS32 INS8 INS42 INS38 UPD42 MOV42 MOV33 INS32 INS8 MOV27 INS8 INS32 INS34 INS27 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS32 INS32 INS32 INS32 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS32 UPD42 MOV42 INS42 INS21 INS34 INS32 INS42 INS42 INS21 INS25 UPD42 INS38 INS10 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS32 UPD42 MOV42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS7 INS42 INS42 INS7 INS27 INS8 INS34 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS38 INS10 INS34 DEL42 DEL67 DEL65 DEL42 DEL67 DEL65 DEL42 DEL67 DEL65 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL27 DEL41 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL25 DEL33 DEL27 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL8 DEL31 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL8 DEL31 DEL42 DEL67 DEL65 DEL42 DEL67 DEL65 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL32 DEL33 DEL27 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL29 DEL66 DEL66 DEL66 DEL66 DEL65 DEL39 DEL42 DEL42 DEL32 DEL33 DEL32 DEL21 DEL33 DEL32 DEL21 DEL32 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL9 DEL41 DEL9 DEL41 DEL42 DEL32 DEL21 DEL43 DEL59 DEL58 DEL32 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL32 DEL21 DEL8 DEL24 DEL8
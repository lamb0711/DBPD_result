Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This class contains utility methods for JSON (http://www.json.org/) which is 
- * used by classes used for the Command Line Interface (CLI).
+ * This class contains utility methods for JSON (http://www.json.org/) which is used by classes used
+ * for the Command Line Interface (CLI).
-   * Converts given JSON String in to a Map. 
-   * Refer http://www.json.org/ to construct a JSON format.
+   * Converts given JSON String in to a Map. Refer http://www.json.org/ to construct a JSON format.
-   * @param jsonString
-   *          jsonString to be converted in to a Map.
+   * @param jsonString jsonString to be converted in to a Map.
-   * @throws IllegalArgumentException
-   *           if the specified JSON string can not be converted in to a Map
+   * @throws IllegalArgumentException if the specified JSON string can not be converted in to a Map
-      
+
-      
+
-      throw new IllegalArgumentException("Could not convert jsonString : '"+jsonString+"' to map.");
+      throw new IllegalArgumentException(
+          "Could not convert jsonString : '" + jsonString + "' to map.");
-  
+
-   * Converts given Map in to a JSON string representing a Map. 
-   * Refer http://www.json.org/ for more.
+   * Converts given Map in to a JSON string representing a Map. Refer http://www.json.org/ for more.
-  
+
-   * Converts given Object in to a JSON string representing an Object. 
-   * Refer http://www.json.org/ for more.
+   * Converts given Object in to a JSON string representing an Object. Refer http://www.json.org/
+   * for more.
-  public static String objectToJson(Object object) {    
+  public static String objectToJson(Object object) {
-  }  
+  }
-   * Converts given Object in to a JSON string representing an Object. 
-   * If object contains an attribute which itself is another object
-   * it will be displayed as className if its json representation
-   * exceeds the length
+   * Converts given Object in to a JSON string representing an Object. If object contains an
+   * attribute which itself is another object it will be displayed as className if its json
+   * representation exceeds the length
-    return objectToJsonNestedChkCDep(object, length, false);    
+    return objectToJsonNestedChkCDep(object, length, false);
-  
-  public static String objectToJsonNestedChkCDep(Object object, int length) {    
-   return objectToJsonNestedChkCDep(object, length, true);
+
+  public static String objectToJsonNestedChkCDep(Object object, int length) {
+    return objectToJsonNestedChkCDep(object, length, true);
-  
-  private static String objectToJsonNestedChkCDep(Object object, int length, boolean checkCyclicDep) {    
-    GfJsonObject jsonObject = new GfJsonObject(object,checkCyclicDep);
+
+  private static String objectToJsonNestedChkCDep(Object object, int length,
+      boolean checkCyclicDep) {
+    GfJsonObject jsonObject = new GfJsonObject(object, checkCyclicDep);
-    while(iterator.hasNext()){
+    while (iterator.hasNext()) {
-      if(value!=null && !isPrimitiveOrWrapper(value.getClass())){
+      if (value != null && !isPrimitiveOrWrapper(value.getClass())) {
-        try{
-        if(stringified.length()>length){          
-          jsonObject.put(key,jsonified.getType());
-        }else{
-          jsonObject.put(key, stringified);
-        }
-        }catch (GfJsonException e) {          
-          e.printStackTrace();          
+        try {
+          if (stringified.length() > length) {
+            jsonObject.put(key, jsonified.getType());
+          } else {
+            jsonObject.put(key, stringified);
+          }
+        } catch (GfJsonException e) {
+          e.printStackTrace();
-    }    
+    }
-  
+
-   * Converts given JSON String in to a Object. 
-   * Refer http://www.json.org/ to construct a JSON format.
+   * Converts given JSON String in to a Object. Refer http://www.json.org/ to construct a JSON
+   * format.
-   * @param jsonString
-   *          jsonString to be converted in to a Map.
+   * @param jsonString jsonString to be converted in to a Map.
-   * @throws IllegalArgumentException
-   *           if the specified JSON string can not be converted in to an Object
+   * @throws IllegalArgumentException if the specified JSON string can not be converted in to an
+   *         Object
-    try {      
+    try {
-      
+
-      
+
-        Method method = methodsMap.get("set"+capitalize(key));
+        Method method = methodsMap.get("set" + capitalize(key));
-            
+
-            else if (isArray(parameterType)){
-              value = toArray(value,parameterType);
-            }
-            else if (isList(parameterType)) {
+            else if (isArray(parameterType)) {
+              value = toArray(value, parameterType);
+            } else if (isList(parameterType)) {
-            method.invoke(objectFromJson, new Object[] { value });
+            method.invoke(objectFromJson, new Object[] {value});
-          
+
-      
+
-        throw new IllegalArgumentException("Not enough setter methods for fields in given JSON String : "+jsonString+" in class : "+klass);
+        throw new IllegalArgumentException(
+            "Not enough setter methods for fields in given JSON String : " + jsonString
+                + " in class : " + klass);
-      
+
-      throw new IllegalArgumentException("Couldn't convert JSON to Object of type "+klass, e);
+      throw new IllegalArgumentException("Couldn't convert JSON to Object of type " + klass, e);
-      throw new IllegalArgumentException("Couldn't convert JSON to Object of type "+klass, e);
+      throw new IllegalArgumentException("Couldn't convert JSON to Object of type " + klass, e);
-      throw new IllegalArgumentException("Couldn't convert JSON to Object of type "+klass, e);
+      throw new IllegalArgumentException("Couldn't convert JSON to Object of type " + klass, e);
-      throw new IllegalArgumentException("Couldn't convert JSON to Object of type "+klass, e);
+      throw new IllegalArgumentException("Couldn't convert JSON to Object of type " + klass, e);
-      throw new IllegalArgumentException("Couldn't convert JSON to Object of type "+klass, e);
+      throw new IllegalArgumentException("Couldn't convert JSON to Object of type " + klass, e);
-  }  
-  
-  private static Object toArray(Object value, Class<?> parameterType)
-      throws GfJsonException {
+  }
+
+  private static Object toArray(Object value, Class<?> parameterType) throws GfJsonException {
-      if(value instanceof JSONArray){
+      if (value instanceof JSONArray) {
-          Object jArray = Array.newInstance(arrayComponentType,
-              jsonArray.length());
+          Object jArray = Array.newInstance(arrayComponentType, jsonArray.length());
-      }else {
-        throw new GfJsonException(
-        "Expected JSONArray for array type");
+      } else {
+        throw new GfJsonException("Expected JSONArray for array type");
-  
+
+   * 
-   * @param parameterType 
+   * @param parameterType
-   * @throws GfJsonException 
+   * @throws GfJsonException
-  @SuppressWarnings({ "rawtypes", "unchecked" })
-  private static Object toSet(Object value, Class<?> parameterType)
-      throws GfJsonException {
+  @SuppressWarnings({"rawtypes", "unchecked"})
+  private static Object toSet(Object value, Class<?> parameterType) throws GfJsonException {
-  private static Object toMap(Object value, Class<?> parameterType)
-      throws GfJsonException {
+  private static Object toMap(Object value, Class<?> parameterType) throws GfJsonException {
-            "Expected JSONObject for Map. Retrieved type is "
-                + value.getClass());
+            "Expected JSONObject for Map. Retrieved type is " + value.getClass());
-      List list = new ArrayList();      
+      List list = new ArrayList();
-        if(isPrimitiveOrWrapper(element.getClass())){
+        if (isPrimitiveOrWrapper(element.getClass())) {
-        }
-        else throw new GfJsonException("Only primitive types are supported in set type for input commands");        
+        } else
+          throw new GfJsonException(
+              "Only primitive types are supported in set type for input commands");
-      
+
-      
+
-      
-      while(keys.hasNext()) {
+
+      while (keys.hasNext()) {
-        arr[i++] = jsonToObject((String)jsonObject.get(key).toString(), klass);
+        arr[i++] = jsonToObject((String) jsonObject.get(key).toString(), klass);
-      
+
-    
+
-  
+
-    
+
-  
+
-    return parameterType.isArray();    
+    return parameterType.isArray();
-  
-  public static boolean isList(Class<?> klass){
-    return klass.isAssignableFrom(List.class);      
+
+  public static boolean isList(Class<?> klass) {
+    return klass.isAssignableFrom(List.class);
-  
-  public static boolean isSet(Class<?> klass){
-    return klass.isAssignableFrom(Set.class);      
+
+  public static boolean isSet(Class<?> klass) {
+    return klass.isAssignableFrom(Set.class);
-  
-  public static boolean isMap(Class<?> klass){
-    return klass.isAssignableFrom(Map.class);      
-  }  
-  
+
+  public static boolean isMap(Class<?> klass) {
+    return klass.isAssignableFrom(Map.class);
+  }
+
-    return klass.isAssignableFrom(Byte.class)
-        || klass.isAssignableFrom(byte.class)
-        || klass.isAssignableFrom(Short.class)
-        || klass.isAssignableFrom(short.class)
-        || klass.isAssignableFrom(Integer.class)
-        || klass.isAssignableFrom(int.class)
-        || klass.isAssignableFrom(Long.class)
-        || klass.isAssignableFrom(long.class)
-        || klass.isAssignableFrom(Float.class)
-        || klass.isAssignableFrom(float.class)
-        || klass.isAssignableFrom(Double.class)
-        || klass.isAssignableFrom(double.class)
-        || klass.isAssignableFrom(Boolean.class)
-        || klass.isAssignableFrom(boolean.class)
-        || klass.isAssignableFrom(String.class)
-        || klass.isAssignableFrom(Character.class)
+    return klass.isAssignableFrom(Byte.class) || klass.isAssignableFrom(byte.class)
+        || klass.isAssignableFrom(Short.class) || klass.isAssignableFrom(short.class)
+        || klass.isAssignableFrom(Integer.class) || klass.isAssignableFrom(int.class)
+        || klass.isAssignableFrom(Long.class) || klass.isAssignableFrom(long.class)
+        || klass.isAssignableFrom(Float.class) || klass.isAssignableFrom(float.class)
+        || klass.isAssignableFrom(Double.class) || klass.isAssignableFrom(double.class)
+        || klass.isAssignableFrom(Boolean.class) || klass.isAssignableFrom(boolean.class)
+        || klass.isAssignableFrom(String.class) || klass.isAssignableFrom(Character.class)
-  
-  public static Object getPrimitiveOrWrapperValue(Class<?> klass, Object value) throws IllegalArgumentException {
+
+  public static Object getPrimitiveOrWrapperValue(Class<?> klass, Object value)
+      throws IllegalArgumentException {
-        else if (str.length() > 1 || str.length()==0) {
+        else if (str.length() > 1 || str.length() == 0) {
-        else if (str.length() > 1 || str.length()==0) {
+        else if (str.length() > 1 || str.length() == 0) {
-    }else {
+    } else {
-    return value;    
+    return value;
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-        CliJsonSerializable cliJsonSerializable = CliJsonSerializableFactory.getCliJsonSerializable(jsId);
+        CliJsonSerializable cliJsonSerializable =
+            CliJsonSerializableFactory.getCliJsonSerializable(jsId);
-  
+
-        CliJsonSerializable cliJsonSerializable = CliJsonSerializableFactory.getCliJsonSerializable(jsId);
+        CliJsonSerializable cliJsonSerializable =
+            CliJsonSerializableFactory.getCliJsonSerializable(jsId);
-  
-  
+
+
-    
-    String str = "{\"org.apache.geode.management.internal.cli.JsonUtil$Employee\":{\"id\":1234,\"name\":\"Foo BAR\",\"department\":{\"id\":456,\"name\":\"support\"}}}";
+
+    String str =
+        "{\"org.apache.geode.management.internal.cli.JsonUtil$Employee\":{\"id\":1234,\"name\":\"Foo BAR\",\"department\":{\"id\":456,\"name\":\"support\"}}}";
-    
+
-  
+
-    
+
+
+
+
+
+
+
-      return "Employee [id=" + id + ", name=" + name + ", department="
-          + department + "]";
+      return "Employee [id=" + id + ", name=" + name + ", department=" + department + "]";
-  
+
-    
+
+
+
+
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 DEL66 DEL66 DEL66 DEL66 DEL66
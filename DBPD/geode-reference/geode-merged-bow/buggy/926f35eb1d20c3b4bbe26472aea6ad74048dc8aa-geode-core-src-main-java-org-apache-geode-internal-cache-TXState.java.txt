Feature/geode 5624 Use a single thread to ensure beforeCompletion and afterCompletion are executed by the same thread. (#2388)





+import java.util.concurrent.Executor;
+import org.apache.geode.CancelCriterion;
+  /**
+   * for client/server JTA transactions we need to have a single thread handle both beforeCompletion
+   * and afterCompletion so that beforeCompletion can obtain locks for the afterCompletion step.
+   * This is that thread
+   */
+  private final SingleThreadJTAExecutor singleThreadJTAExecutor;
+
+    this(proxy, onBehalfOfRemoteStub, new SingleThreadJTAExecutor());
+  }
+
+  public TXState(TXStateProxy proxy, boolean onBehalfOfRemoteStub,
+      SingleThreadJTAExecutor singleThreadJTAExecutor) {
-
+    this.singleThreadJTAExecutor = singleThreadJTAExecutor;
-       * If there is a TransactionWriter plugged in, we need to to give it an opportunity to abort
+       * If there is a TransactionWriter plugged in, we need to to give it an opportunity to cleanup
+    if (singleThreadJTAExecutor.shouldDoCleanup()) {
+      singleThreadJTAExecutor.cleanup(getCancelCriterion());
+    } else {
+      doCleanup();
+    }
+  }
+
+  void doCleanup() {
+
+    proxy.getTxMgr().setTXState(null);
+
-    doBeforeCompletion();
+    singleThreadJTAExecutor.executeBeforeCompletion(this,
+        getExecutor(), getCancelCriterion());
-  private void doBeforeCompletion() {
+  private Executor getExecutor() {
+    return getCache().getDistributionManager().getWaitingThreadPool();
+  }
+
+  private CancelCriterion getCancelCriterion() {
+    return getCache().getCancelCriterion();
+  }
+
+  void doBeforeCompletion() {
+
-       * If there is a TransactionWriter plugged in, we need to to give it an opportunity to abort
+       * If there is a TransactionWriter plugged in, we need to to give it an opportunity to cleanup
-    this.proxy.getTxMgr().setTXState(null);
-    // For commit, beforeCompletion should be called. Otherwise
+    proxy.getTxMgr().setTXState(null);
+    // if there was a beforeCompletion call then there will be a thread
+    // sitting in the waiting pool to execute afterCompletion. Otherwise
-    if (wasBeforeCompletionCalled()) {
-      doAfterCompletion(status);
+    if (beforeCompletionCalled) {
+      singleThreadJTAExecutor.executeAfterCompletion(getCancelCriterion(), status);
-  private void doAfterCompletion(int status) {
+  void doAfterCompletion(int status) {

INS26 INS26 INS40 INS40 INS23 INS31 INS31 INS31 INS31 INS29 INS83 INS83 INS43 INS59 INS83 INS42 INS44 INS44 INS8 INS44 INS83 INS39 INS42 INS8 UPD42 INS83 INS43 INS42 INS8 INS83 INS43 INS42 INS8 INS65 INS42 INS42 INS43 INS42 INS39 INS42 INS17 INS43 INS42 INS21 INS25 INS21 INS42 INS41 INS42 INS41 INS66 INS66 INS66 INS42 INS42 INS42 INS14 INS42 INS7 INS32 INS8 INS8 INS32 INS32 INS32 INS42 INS43 INS22 INS42 INS42 INS42 INS21 INS21 INS32 INS42 INS33 INS42 UPD42 INS52 INS32 INS32 INS32 INS42 INS32 INS42 INS42 INS52 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 UPD42 INS32 INS42 INS42 DEL83 DEL83 DEL52 DEL42 DEL22 DEL42 DEL32 DEL83
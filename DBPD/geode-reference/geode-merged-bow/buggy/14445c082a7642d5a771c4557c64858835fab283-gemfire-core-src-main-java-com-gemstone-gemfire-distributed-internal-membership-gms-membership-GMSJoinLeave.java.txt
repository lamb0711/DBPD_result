GEODE-77: improvements in handling loss of coordinator

1) Locator join-timeout has been bumped from 17 sec to 24.  This allows it to join in spite of the loss of the current coordinator and several backup coordinators.

2) Join responses are now sent after "prepare for view" messages so that other members have some knowledge of the new members before they are allowed into the system.  If the coordinator dies before completing preparation the new coordinator will find this prepared view and now adds its new members to its own membership view.

3) We no longer clear the collection of already-tried potential-coordinators when a new view is processed during startup.  Since join-requests have already been sent to these addresses there is no point in trying them again.

4) The coordinator now periodically sends out the current view to members and to crashed members of the last view using unreliable messaging.  This helps get rid of rogue processes & is similar to what we did with the view-sync JGroups protocol in GemFire.  I new method for unreliable message transmission to Messenger for this purpose.  This keeps JGroups UNICAST3 protocol from recreating a retransmission table entry for the old, crashed, members who would reject the old sequence numbers generated by the new table entry and never dispatch the messages.

5) Removal requests are now processed in the ViewCreator after all other requests have been processed.  This prevents a member from being kicked out when we've already received a shutdown message from that member.

6) Several new unit tests

+import java.util.TimerTask;
+  /** interval for broadcasting the current view to members in case they didn't get it the first time */
+  private static final long VIEW_BROADCAST_INTERVAL = Long.getLong("gemfire.view-broadcast-interval", 60000);
+
+  /** the established request collection jitter.  This can be overridden for testing with delayViewCreationForTest */
+  long requestCollectionInterval = MEMBER_REQUEST_COLLECTION_INTERVAL;
+
-            if (System.currentTimeMillis() > giveupTime) {
-              break;
-            }
+            if (System.currentTimeMillis() > giveupTime) {
+              break;
+            }
-          } else if (System.currentTimeMillis() > giveupTime) {
+          } else if (now > giveupTime) {
+      searchState.cleanup();
-    logger.info("Attempting to join the distributed system through coordinator " + coord + " using address " + this.localAddress);
-    JoinRequestMessage req = new JoinRequestMessage(coord, this.localAddress, services.getAuthenticator().getCredentials(coord));
-    // add server socket port in the join request
-    if (services.getHealthMonitor().getSocketInfo().get(localAddress) != null) {
-      req.setSocketPort(services.getHealthMonitor().getSocketInfo().get(localAddress).getPort());
+    if (state.alreadyTried.contains(coord)) {
+      logger.info("Probably coordinator is still {} - waiting for a join-response");
+    } else {
+      logger.info("Attempting to join the distributed system through coordinator " + coord + " using address " + this.localAddress);
+      JoinRequestMessage req = new JoinRequestMessage(coord, this.localAddress, services.getAuthenticator().getCredentials(coord));
+      // add server socket port in the join request
+      if (services.getHealthMonitor().getSocketInfo().get(localAddress) != null) {
+        req.setSocketPort(services.getHealthMonitor().getSocketInfo().get(localAddress).getPort());
+      }
+      services.getMessenger().send(req);
-    services.getMessenger().send(req);
-        recordViewRequest(incomingRequest);
-        this.viewProcessor.processRemoveRequest(mbr);
-        this.prepareProcessor.processRemoveRequest(mbr);
+        // suspect processing tends to get carried away sometimes during
+        // shutdown (especially shutdownAll), so we check for a scheduled shutdown
+        // message
+        if (!getPendingRequestIDs(LEAVE_REQUEST_MESSAGE).contains(mbr)) {
+          recordViewRequest(incomingRequest);
+          this.viewProcessor.processRemoveRequest(mbr);
+          this.prepareProcessor.processRemoveRequest(mbr);
+        }
+  /**
+   * Test hook for delaying the creation of new views.
+   * This should be invoked before this member becomes coordinator
+   * and creates its ViewCreator thread.
+   * @param millis
+   */
+  public void delayViewCreationForTest(int millis) {
+    requestCollectionInterval = millis;
+  }
+  
+        startViewBroadcaster();
+        startViewBroadcaster();
-  boolean prepareView(NetView view, Collection<InternalDistributedMember> newMembers, List<DistributionMessage> requests) {
+  boolean prepareView(NetView view, List<InternalDistributedMember> newMembers, List<DistributionMessage> requests) {
-  void sendView(NetView view, Collection<InternalDistributedMember> newMembers, List<DistributionMessage> requests) {
+  void sendView(NetView view, List<InternalDistributedMember> newMembers, List<DistributionMessage> requests) {
-  boolean sendView(NetView view, Collection<InternalDistributedMember> newMembers, boolean preparing, ViewReplyProcessor rp,
+  boolean sendView(NetView view, List<InternalDistributedMember> newMembers, boolean preparing, ViewReplyProcessor rp,
+      // send join responses after other members at least have
+      // a prepared view announcing the new member
+      if (!(isNetworkPartition(view) && quorumRequired)) {
+        List<Integer> newPorts = new ArrayList<Integer>(view.size());
+        addPorts(view, requests, newPorts);
+        sendJoinResponses(newMembers, view, portsForMembers);
+      }
+
-    int connectTimeout = (int)services.getConfig().getMemberTimeout();
+    int connectTimeout = (int)services.getConfig().getMemberTimeout() * 2;
-            if (response.getSenderId() != null && response.getSenderId().getVmViewId() >= 0) {
+            if (!state.hasContactedAJoinedLocator &&
+                response.getSenderId() != null && response.getSenderId().getVmViewId() >= 0) {
-                // if the view has changed it is possible that a member
-                // that we already tried to join with will become coordinator
-                state.alreadyTried.clear();
+  
+  private void startViewBroadcaster() {
+    services.getTimer().schedule(new ViewBroadcaster(), VIEW_BROADCAST_INTERVAL, VIEW_BROADCAST_INTERVAL);
+  }
+  /**
+   * ViewBroadcaster periodically sends the current view to all
+   * current and departed members.  This ensures that a member that
+   * missed the view will eventually see it and act on it.
+   */
+  class ViewBroadcaster extends TimerTask {
+
+    @Override
+    public void run() {
+      if (!isCoordinator || isStopping) {
+        cancel();
+      } else {
+        sendCurrentView();
+      }
+    }
+    
+    void sendCurrentView() {
+      NetView v = currentView;
+      if (v != null) {
+        InstallViewMessage msg = new InstallViewMessage(v, services.getAuthenticator().getCredentials(localAddress));
+        Collection<InternalDistributedMember> recips = new ArrayList<>(v.size() + v.getCrashedMembers().size());
+        recips.addAll(v.getMembers());
+        recips.addAll(v.getCrashedMembers());
+        List<Integer> ports = new ArrayList<>(v.size());
+        for (InternalDistributedMember mbr: v.getMembers()) {
+          InetSocketAddress addr = services.getHealthMonitor().getSocketInfo().get(mbr);
+          int port = addr==null? -1 : addr.getPort();
+          ports.add(Integer.valueOf(port));
+        }
+        msg.setPortsForMembers(ports);
+        msg.setRecipients(recips);
+        services.getMessenger().send(msg);
+      }
+    }
+    
+  }
+
-          prepareAndSendView(initialView, Collections.<InternalDistributedMember> emptyList(), initialLeaving, initialRemovals, null);
+          prepareAndSendView(initialView, Collections.<InternalDistributedMember>emptyList(), initialLeaving,
+              initialRemovals, Collections.<DistributionMessage>emptyList());
-      long okayToCreateView = System.currentTimeMillis() + MEMBER_REQUEST_COLLECTION_INTERVAL;
+      long okayToCreateView = System.currentTimeMillis() + requestCollectionInterval;
-                okayToCreateView = System.currentTimeMillis() + MEMBER_REQUEST_COLLECTION_INTERVAL;
+                okayToCreateView = System.currentTimeMillis() + requestCollectionInterval;
-                okayToCreateView = System.currentTimeMillis() + MEMBER_REQUEST_COLLECTION_INTERVAL;
+                okayToCreateView = System.currentTimeMillis() + requestCollectionInterval;
-          mbr = ((RemoveMemberMessage) msg).getMemberID();
-          if (oldMembers.contains(mbr) && !leaveReqs.contains(mbr) && !removalReqs.contains(mbr)) {
-            removalReqs.add(mbr);
-            removalReasons.add(((RemoveMemberMessage) msg).getReason());
-          } else {
-            sendRemoveMessages(Collections.<InternalDistributedMember> singletonList(mbr),
-                Collections.<String> singletonList(((RemoveMemberMessage) msg).getReason()), currentView);
-          }
+          // process these after gathring all leave-requests so that
+          // we don't kick out a member that's shutting down
+      for (DistributionMessage msg : requests) {
+        switch (msg.getDSFID()) {
+        case REMOVE_MEMBER_REQUEST:
+          InternalDistributedMember mbr = ((RemoveMemberMessage) msg).getMemberID();
+          if (!leaveReqs.contains(mbr)) {
+            if (oldMembers.contains(mbr) && !removalReqs.contains(mbr)) {
+              removalReqs.add(mbr);
+              removalReasons.add(((RemoveMemberMessage) msg).getReason());
+            } else {
+              sendRemoveMessages(Collections.<InternalDistributedMember> singletonList(mbr),
+                  Collections.<String> singletonList(((RemoveMemberMessage) msg).getReason()), currentView);
+            }
+          }
+          break;
+        default:
+          break;
+        }
+      }
+
-      // we want to always check for quorum loss but don't act on it
-      // unless network-partition-detection is enabled
-      if (!(isNetworkPartition(newView) && quorumRequired)) {
-        // add socket ports of all members to join response
-        List<Integer> portsForMembers = new ArrayList<Integer>(newView.size());
-        addPorts(newView, requests, portsForMembers);
-        sendJoinResponses(joinReqs, newView, portsForMembers);
-      }
-
+
+        NetView conflictingView = prepareProcessor.getConflictingView();
+
-        NetView conflictingView = prepareProcessor.getConflictingView();
+          List<InternalDistributedMember> newMembers = prepareProcessor.getConflictingView().getNewMembers();
+          if (!newMembers.isEmpty()) {
+            logger.info("adding these new members from a conflicting view to the new view: {}", newMembers);
+            for (InternalDistributedMember mbr: newMembers) {
+              InetSocketAddress addr = services.getHealthMonitor().getSocketInfo().get(mbr);
+              // TODO: re-factor health monitor ports to be in the NetView so we don't need
+              // to create a fake JoinRequestMessage here
+              int port = addr==null? -1 : addr.getPort();
+              JoinRequestMessage msg = new JoinRequestMessage(localAddress, mbr, null);
+              msg.setSocketPort(port);
+              requests.add(msg);
+              newView.add(mbr);
+              joinReqs.add(mbr);
+            }
+          }
-
+  
+  

INS26 INS40 INS23 INS23 INS31 INS31 INS55 INS29 INS83 INS83 INS83 INS39 INS59 INS29 INS39 INS59 INS29 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS8 INS29 INS42 INS43 INS31 INS31 INS65 INS42 INS32 INS65 INS42 INS42 INS25 INS65 INS65 INS39 INS42 INS21 UPD74 UPD74 INS74 INS21 INS65 INS42 INS78 INS83 INS39 INS42 INS8 INS39 INS42 INS8 INS66 INS42 INS42 INS45 INS34 INS66 INS32 INS8 INS8 INS66 INS66 INS66 INS42 INS7 UPD43 UPD43 INS43 INS43 INS32 INS66 INS66 INS66 INS42 INS25 INS60 INS25 INS70 INS21 INS40 INS42 INS42 INS21 MOV21 MOV60 MOV25 MOV21 INS42 INS42 UPD42 UPD42 INS42 INS42 INS25 INS27 INS32 INS42 INS14 INS42 INS42 INS27 INS8 INS8 INS43 INS59 INS27 INS8 INS44 INS42 INS8 MOV60 INS32 INS32 INS8 INS38 INS8 MOV11 INS34 INS42 INS42 INS43 INS38 INS42 INS21 INS21 INS42 INS42 INS42 INS42 INS33 INS60 INS60 INS21 INS21 INS60 INS70 INS21 INS21 INS21 MOV27 INS43 INS42 INS50 INS42 INS42 INS42 INS42 INS45 INS25 INS21 INS21 INS36 INS60 INS21 INS21 INS42 INS42 INS32 INS32 INS43 INS59 MOV74 INS59 INS32 INS32 INS74 INS59 INS44 INS32 INS8 INS32 INS32 INS32 UPD42 INS42 INS32 INS49 INS60 MOV25 INS10 INS49 INS10 INS8 INS38 MOV8 INS32 INS32 INS27 MOV74 INS59 INS32 INS32 INS42 INS42 INS42 INS42 INS14 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS32 INS43 INS43 INS42 INS14 INS43 INS42 INS42 INS42 INS60 INS60 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS43 INS59 MOV38 INS8 MOV21 MOV21 MOV21 INS60 INS25 INS32 INS42 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS32 INS74 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS74 INS32 INS42 INS43 INS59 INS39 INS59 INS32 INS42 INS42 UPD42 MOV42 INS42 MOV32 INS25 INS74 INS59 INS38 INS8 MOV25 INS32 INS42 INS42 INS42 INS42 MOV74 INS32 INS42 INS32 INS42 INS42 INS43 INS32 INS32 INS43 INS42 INS42 INS42 INS42 INS32 INS42 INS16 INS42 INS42 INS32 INS32 MOV27 MOV8 MOV8 INS43 INS43 INS42 INS32 INS32 INS21 INS70 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS27 INS38 INS32 INS42 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS44 INS42 INS8 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS33 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS43 INS42 INS60 INS60 INS60 INS21 INS21 INS21 INS21 INS27 INS42 INS42 INS42 INS43 INS59 INS39 INS59 INS43 INS59 INS32 INS32 INS32 INS32 INS38 MOV27 INS42 INS42 INS32 INS42 INS16 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS32 INS42 INS42 INS27 INS38 INS32 INS43 INS42 INS42 INS33 MOV27 INS32 INS42 INS42 INS33 INS34 INS42 INS42 INS42 UPD42 UPD42 INS42 INS42 DEL42 DEL42 DEL32 DEL40 DEL42 DEL32 DEL21 DEL33 DEL42 DEL7 DEL21 DEL42 DEL42 DEL32 DEL42 DEL27 DEL36 DEL38 DEL42 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public class InitialImageOperation  {
+public class InitialImageOperation {
-  
+
-  
+
-    Integer.getInteger("GetInitialImage.chunkSize", 500 * 1024).intValue();
-  
+      Integer.getInteger("GetInitialImage.chunkSize", 500 * 1024).intValue();
+
-      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "GetInitialImage.CHUNK_PERMITS", 16).intValue();
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "GetInitialImage.CHUNK_PERMITS", 16)
+          .intValue();
-  public static int MAXIMUM_UNFINISHED_OPERATIONS =
-      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "GetInitialImage.MAXIMUM_UNFINISHED_OPERATIONS", 10000).intValue();
+  public static int MAXIMUM_UNFINISHED_OPERATIONS = Integer.getInteger(
+      DistributionConfig.GEMFIRE_PREFIX + "GetInitialImage.MAXIMUM_UNFINISHED_OPERATIONS", 10000)
+      .intValue();
-      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "GetInitialImage.MAX_PARALLEL_GIIS", 5).intValue();
-  
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "GetInitialImage.MAX_PARALLEL_GIIS", 5)
+          .intValue();
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  private final static ThreadLocal inhibitStateFlush = new ThreadLocal(){
+  private final static ThreadLocal inhibitStateFlush = new ThreadLocal() {
-      protected Object initialValue() {
-        return Boolean.valueOf(false);
-      }
-    };
-  
-  
+    protected Object initialValue() {
+      return Boolean.valueOf(false);
+    }
+  };
+
+
-  
+
-    NO_GII,
-    GOTIMAGE_BY_FULLGII,
-    GOTIMAGE_BY_DELTAGII; 
-    
+    NO_GII, GOTIMAGE_BY_FULLGII, GOTIMAGE_BY_DELTAGII;
+
-      return (giiStatus == GIIStatus.GOTIMAGE_BY_FULLGII || giiStatus == GIIStatus.GOTIMAGE_BY_DELTAGII);
+      return (giiStatus == GIIStatus.GOTIMAGE_BY_FULLGII
+          || giiStatus == GIIStatus.GOTIMAGE_BY_DELTAGII);
-    
+
-  
+
-  
+
-   * @param targetReinitialized true if candidate should wait until initialized
-   *        before responding
+   * @param targetReinitialized true if candidate should wait until initialized before responding
-  GIIStatus getFromOne(
-      Set recipientSet,
-      boolean targetReinitialized,
-      CacheDistributionAdvisor.InitialImageAdvice advice,
-      boolean recoveredFromDisk, RegionVersionVector recoveredRVV)
-      throws org.apache.geode.cache.TimeoutException
-  {
+  GIIStatus getFromOne(Set recipientSet, boolean targetReinitialized,
+      CacheDistributionAdvisor.InitialImageAdvice advice, boolean recoveredFromDisk,
+      RegionVersionVector recoveredRVV) throws org.apache.geode.cache.TimeoutException {
-    
+
-       * TODO (ashetkar): recipientSet may contain more than one member. Ensure
-       * only the gii-source member is vMotioned. The test hook may need to be
-       * placed at another point.
+       * TODO (ashetkar): recipientSet may contain more than one member. Ensure only the gii-source
+       * member is vMotioned. The test hook may need to be placed at another point.
-        InternalDistributedMember primary = sender.getSenderAdvisor()
-            .advisePrimaryGatewaySender();
+        InternalDistributedMember primary = sender.getSenderAdvisor().advisePrimaryGatewaySender();
-    
+
-      
-      InternalDistributedMember recipient = (InternalDistributedMember)itr.next();
-      
-      // In case of HARegion, before getting the region snapshot(image) get the filters 
+
+      InternalDistributedMember recipient = (InternalDistributedMember) itr.next();
+
+      // In case of HARegion, before getting the region snapshot(image) get the filters
-      // As part of bug fix 39014, while creating the secondary HARegion/Queue, the 
-      // filters registered by the client is applied first and then the HARegion 
+      // As part of bug fix 39014, while creating the secondary HARegion/Queue, the
+      // filters registered by the client is applied first and then the HARegion
-      if (region instanceof HARegion){
+      if (region instanceof HARegion) {
-//          HARegion r = (HARegion)region;
-//          if (!r.isPrimaryQueue()) {
-            if (!this.requestFilterInfo(recipient)) {
-              if (isDebugEnabled) {
-                logger.debug("Failed to receive interest and CQ information from {}", recipient);
-              }
+          // HARegion r = (HARegion)region;
+          // if (!r.isPrimaryQueue()) {
+          if (!this.requestFilterInfo(recipient)) {
+            if (isDebugEnabled) {
+              logger.debug("Failed to receive interest and CQ information from {}", recipient);
-//          }
-        } catch (Exception ex){
+          }
+          // }
+        } catch (Exception ex) {
-              logger.info("Failed while getting interest and CQ information from {}", recipient, ex);
+              logger.info("Failed while getting interest and CQ information from {}", recipient,
+                  ex);
-      
+
-      if(persistenceAdvisor != null) {
+      if (persistenceAdvisor != null) {
-        } catch(ReplyException e) {
+        } catch (ReplyException e) {
-      final DistributionManager dm = (DistributionManager)this.region.getDistributionManager();
+      final DistributionManager dm = (DistributionManager) this.region.getDistributionManager();
-      if (this.region.concurrencyChecksEnabled && recipient.getVersionObject().compareTo(Version.GFE_80) >= 0) {
-        if (internalBeforeRequestRVV != null && internalBeforeRequestRVV.getRegionName().equals(this.region.getName())) {
+      if (this.region.concurrencyChecksEnabled
+          && recipient.getVersionObject().compareTo(Version.GFE_80) >= 0) {
+        if (internalBeforeRequestRVV != null
+            && internalBeforeRequestRVV.getRegionName().equals(this.region.getName())) {
-        //Request the RVV from the provider and discover any operations on this 
-        //member that have not been performed on the provider.
+        // Request the RVV from the provider and discover any operations on this
+        // member that have not been performed on the provider.
-        //It is important that this happens *before* the state flush. An operation
-        //maybe unfinished because a member crashed during distribution, or because
-        //it is in flight right now. If it is in flight right now, we need to make
-        //sure the provider receives the latest value for the operation before the
-        //GII really starts.
+        // It is important that this happens *before* the state flush. An operation
+        // maybe unfinished because a member crashed during distribution, or because
+        // it is in flight right now. If it is in flight right now, we need to make
+        // sure the provider receives the latest value for the operation before the
+        // GII really starts.
-        if (internalAfterCalculatedUnfinishedOps != null && internalAfterCalculatedUnfinishedOps.getRegionName().equals(this.region.getName())) {
+        if (internalAfterCalculatedUnfinishedOps != null
+            && internalAfterCalculatedUnfinishedOps.getRegionName().equals(this.region.getName())) {
-      Boolean inhibitFlush = (Boolean)inhibitStateFlush.get();
+      Boolean inhibitFlush = (Boolean) inhibitStateFlush.get();
-          Collection<BucketRegion> userPRBuckets = ((BucketRegionQueue)(this.region))
-              .getCorrespondingUserPRBuckets();
+          Collection<BucketRegion> userPRBuckets =
+              ((BucketRegionQueue) (this.region)).getCorrespondingUserPRBuckets();
-      
+
-              logger.debug("Region {} recovered without EndGII flag, do full GII", this.region.getFullPath());
+              logger.debug("Region {} recovered without EndGII flag, do full GII",
+                  this.region.getFullPath());
-              logger.debug("Region {} has {} unfinished operations, which exceeded threshold {}, do full GII instead",
-                  this.region.getFullPath(), keysOfUnfinishedOps.size(), MAXIMUM_UNFINISHED_OPERATIONS);
+              logger.debug(
+                  "Region {} has {} unfinished operations, which exceeded threshold {}, do full GII instead",
+                  this.region.getFullPath(), keysOfUnfinishedOps.size(),
+                  MAXIMUM_UNFINISHED_OPERATIONS);
-                logger.debug("Region {}: after filled versions of unfinished keys, recovered rvv is still newer than remote rvv:{}. recovered rvv is {}. Do full GII",
-                  this.region.getFullPath(), remote_rvv, recoveredRVV);
+                logger.debug(
+                    "Region {}: after filled versions of unfinished keys, recovered rvv is still newer than remote rvv:{}. recovered rvv is {}. Do full GII",
+                    this.region.getFullPath(), remote_rvv, recoveredRVV);
-                logger.debug("Region {} recovered with EndGII flag, rvv is {}. recovered rvv is {}. Do delta GII",
+                logger.debug(
+                    "Region {} recovered with EndGII flag, rvv is {}. recovered rvv is {}. Do delta GII",
-          if (internalBeforeSavedReceivedRVV != null && internalBeforeSavedReceivedRVV.getRegionName().equals(this.region.getName())) {
+          if (internalBeforeSavedReceivedRVV != null
+              && internalBeforeSavedReceivedRVV.getRegionName().equals(this.region.getName())) {
-          if (internalAfterSavedReceivedRVV != null && internalAfterSavedReceivedRVV.getRegionName().equals(this.region.getName())) {
+          if (internalAfterSavedReceivedRVV != null
+              && internalAfterSavedReceivedRVV.getRegionName().equals(this.region.getName())) {
-      ImageProcessor processor = new ImageProcessor(this.region.getSystem(),
-                                                    recipient);
+      ImageProcessor processor = new ImageProcessor(this.region.getSystem(), recipient);
-        if (region.isUsedForPartitionedRegionBucket() &&
-            region.getDistributionConfig().getAckSevereAlertThreshold() > 0) {
+        if (region.isUsedForPartitionedRegionBucket()
+            && region.getDistributionConfig().getAckSevereAlertThreshold() > 0) {
-      
+
-            new Object[] { this.region.getName(), recipient }));
+            new Object[] {this.region.getName(), recipient}));
-        if (internalAfterSentRequestImage != null && internalAfterSentRequestImage.getRegionName().equals(this.region.getName())) {
+        if (internalAfterSentRequestImage != null
+            && internalAfterSentRequestImage.getRegionName().equals(this.region.getName())) {
-          
+
-          if (this.region.getDataPolicy().withPersistence() && keysOfUnfinishedOps != null && !keysOfUnfinishedOps.isEmpty()) {
+          if (this.region.getDataPolicy().withPersistence() && keysOfUnfinishedOps != null
+              && !keysOfUnfinishedOps.isEmpty()) {
-            for (Object key:keysOfUnfinishedOps) {
+            for (Object key : keysOfUnfinishedOps) {
-              DiskEntry de = (DiskEntry)re;
+              DiskEntry de = (DiskEntry) re;
-          
+
-            throw (org.apache.geode.cache.TimeoutException)cause;
+            throw (org.apache.geode.cache.TimeoutException) cause;
-          if(!region.isDestroyed()) {
+          if (!region.isDestroyed()) {
-          
+
-          
-          //Make sure we have applied the tombstone GC as seen on the GII
-          //source
-          if(this.gcVersions != null) {
-            region.getGemFireCache().getTombstoneService().gcTombstones(region, this.gcVersions, false);
+
+          // Make sure we have applied the tombstone GC as seen on the GII
+          // source
+          if (this.gcVersions != null) {
+            region.getGemFireCache().getTombstoneService().gcTombstones(region, this.gcVersions,
+                false);
-          
+
-                region.getDistributionManager().getDistributionManagerId(), region.getPersistentID());
+                region.getDistributionManager().getDistributionManagerId(),
+                region.getPersistentID());
-            logger.info("{} is done getting image from {}. isDeltaGII is {}", this.region.getName(), recipient, this.isDeltaGII);
+            logger.info("{} is done getting image from {}. isDeltaGII is {}", this.region.getName(),
+                recipient, this.isDeltaGII);
-                    LocalizedStrings.InitialImageOperation_REGION_0_INITIALIZED_PERSISTENT_REGION_WITH_ID_1_FROM_2,
-                    new Object[] {this.region.getName(),
-                        this.region.getPersistentID(), recipient}));
+                LocalizedStrings.InitialImageOperation_REGION_0_INITIALIZED_PERSISTENT_REGION_WITH_ID_1_FROM_2,
+                new Object[] {this.region.getName(), this.region.getPersistentID(), recipient}));
-    
+
-  
+
-   * synchronize with another member (delta GII from it).  If lostMember is not
-   * null, then only changes that it made to the image provider will be sent
-   * back.  Otherwise all changes made to the image provider will be compared
-   * with those made to this cache and a full delta will be sent.
+   * synchronize with another member (delta GII from it). If lostMember is not null, then only
+   * changes that it made to the image provider will be sent back. Otherwise all changes made to the
+   * image provider will be compared with those made to this cache and a full delta will be sent.
-  public void synchronizeWith(InternalDistributedMember target,
-      VersionSource lostMemberVersionID, InternalDistributedMember lostMember) {
-    final DistributionManager dm = (DistributionManager)this.region.getDistributionManager();
+  public void synchronizeWith(InternalDistributedMember target, VersionSource lostMemberVersionID,
+      InternalDistributedMember lostMember) {
+    final DistributionManager dm = (DistributionManager) this.region.getDistributionManager();
-    if (lostMemberVersionID != null)  {
+    if (lostMemberVersionID != null) {
-    ImageProcessor processor = new ImageProcessor(this.region.getSystem(),
-                                                  target);
+    ImageProcessor processor = new ImageProcessor(this.region.getSystem(), target);
-      if (region.isUsedForPartitionedRegionBucket() &&
-          region.getDistributionConfig().getAckSevereAlertThreshold() > 0) {
+      if (region.isUsedForPartitionedRegionBucket()
+          && region.getDistributionConfig().getAckSevereAlertThreshold() > 0) {
-    
-      logger.info("Region {} is requesting synchronization with {} for {}", this.region.getName(), target, lostMember);
+
+      logger.info("Region {} is requesting synchronization with {} for {}", this.region.getName(),
+          target, lostMember);
-          throw (org.apache.geode.cache.TimeoutException)cause;
+          throw (org.apache.geode.cache.TimeoutException) cause;
-        if(!region.isDestroyed()) {
+        if (!region.isDestroyed()) {
-          RegionVersionHolder holder = this.region.getVersionVector().getHolderForMember(lostMemberVersionID);
-          if (this.rcvd_holderToSync != null && this.rcvd_holderToSync.isNewerThanOrCanFillExceptionsFor(holder)) {
-            logger.info("synchronizeWith detected mismatch region version holder for lost member {}. Old is {}, new is {}",
+          RegionVersionHolder holder =
+              this.region.getVersionVector().getHolderForMember(lostMemberVersionID);
+          if (this.rcvd_holderToSync != null
+              && this.rcvd_holderToSync.isNewerThanOrCanFillExceptionsFor(holder)) {
+            logger.info(
+                "synchronizeWith detected mismatch region version holder for lost member {}. Old is {}, new is {}",
-            this.region.getVersionVector().initializeVersionHolder(lostMemberVersionID, this.rcvd_holderToSync);
+            this.region.getVersionVector().initializeVersionHolder(lostMemberVersionID,
+                this.rcvd_holderToSync);
-            logger.debug("{} received no synchronization data from {} which could mean that we are already synchronized", this.region.getName(), target);
+            logger.debug(
+                "{} received no synchronization data from {} which could mean that we are already synchronized",
+                this.region.getName(), target);
-    
+
-    // that the image provider didn't see.  This can happen if the
+    // that the image provider didn't see. This can happen if the
-            rvv.recordVersion(tag.getMemberID(),  tag.getRegionVersion());
+            rvv.recordVersion(tag.getMemberID(), tag.getRegionVersion());
-          // member(s)  These will either be DistributedMember IDs or DiskStore IDs
+          // member(s) These will either be DistributedMember IDs or DiskStore IDs
-          Set recipients =  this.region.getCacheDistributionAdvisor().adviseReplicates();
-          for (Iterator it=recipients.iterator(); it.hasNext(); ) {
-            InternalDistributedMember mbr = (InternalDistributedMember)it.next();
+          Set recipients = this.region.getCacheDistributionAdvisor().adviseReplicates();
+          for (Iterator it = recipients.iterator(); it.hasNext();) {
+            InternalDistributedMember mbr = (InternalDistributedMember) it.next();
-              logger.debug("Local versions were found that the image provider has not seen for {}", needsSync);
+              logger.debug("Local versions were found that the image provider has not seen for {}",
+                  needsSync);
-  
+
-    if (internalBeforeGetInitialImage != null && internalBeforeGetInitialImage.getRegionName().equals(region.getName())) {
+    if (internalBeforeGetInitialImage != null
+        && internalBeforeGetInitialImage.getRegionName().equals(region.getName())) {
-  
-  
+
+
+   * 
-  private boolean requestFilterInfo(InternalDistributedMember recipient){
+  private boolean requestFilterInfo(InternalDistributedMember recipient) {
-    RequestFilterInfoMessage filterInfoMsg = new RequestFilterInfoMessage();      
+    RequestFilterInfoMessage filterInfoMsg = new RequestFilterInfoMessage();
-    FilterInfoProcessor processor = new FilterInfoProcessor(this.region.getSystem(),
-        recipient);    
+    FilterInfoProcessor processor = new FilterInfoProcessor(this.region.getSystem(), recipient);
-        throw (org.apache.geode.cache.TimeoutException)cause;
+        throw (org.apache.geode.cache.TimeoutException) cause;
-      if(!region.isDestroyed()) {
+      if (!region.isDestroyed()) {
-  
-  
-  /** Called from separate thread when reply is processed.
-   *  @param entries entries to add to the region
-   *  @return false if should abort (region was destroyed or cache was closed)
+
+
+  /**
+   * Called from separate thread when reply is processed.
+   * 
+   * @param entries entries to add to the region
+   * @return false if should abort (region was destroyed or cache was closed)
-  boolean processChunk(List entries, InternalDistributedMember sender,
-      Version remoteVersion) throws IOException, ClassNotFoundException {
+  boolean processChunk(List entries, InternalDistributedMember sender, Version remoteVersion)
+      throws IOException, ClassNotFoundException {
-    
+
-    //Asif : Can the image state be null here. Don't think so
-    //Assert.assertTrue(imgState != null, "processChunk :ImageState should not have been null ");
-    //Asif: Set the Htree Reference in Thread Local before the iteration begins so as
-    //to detect a clear operation occurring while the put operation is in progress
-    //It is Ok to set it every time the loop is executed, because a clear can happen
-    //only once during GII life cycle & so it does not matter if the HTree ref changes after the clear
-    //whenever a conflict is detected in DiskRegion it is Ok to abort the operation
+    // Asif : Can the image state be null here. Don't think so
+    // Assert.assertTrue(imgState != null, "processChunk :ImageState should not have been null ");
+    // Asif: Set the Htree Reference in Thread Local before the iteration begins so as
+    // to detect a clear operation occurring while the put operation is in progress
+    // It is Ok to set it every time the loop is executed, because a clear can happen
+    // only once during GII life cycle & so it does not matter if the HTree ref changes after the
+    // clear
+    // whenever a conflict is detected in DiskRegion it is Ok to abort the operation
-        if (internalDuringApplyDelta != null && !internalDuringApplyDelta.isRunning && internalDuringApplyDelta.getRegionName().equals(this.region.getName())) {
+        if (internalDuringApplyDelta != null && !internalDuringApplyDelta.isRunning
+            && internalDuringApplyDelta.getRegionName().equals(this.region.getName())) {
-                logger.debug("processChunk: Sleeping for {} ms for rgn {}", slow, this.region.getFullPath());
+                logger.debug("processChunk: Sleeping for {} ms for rgn {}", slow,
+                    this.region.getFullPath());
-            }
-            catch (InterruptedException e) {
+            } catch (InterruptedException e) {
-            }
-            finally {
+            } finally {
-        }
-        catch (CancelException e) {
+        } catch (CancelException e) {
-        Entry entry = (Entry)entries.get(i);
+        Entry entry = (Entry) entries.get(i);
-        final long lastModified = entry.getLastModified(this.region
-            .getDistributionManager());
+        final long lastModified = entry.getLastModified(this.region.getDistributionManager());
-            tmpBytes = (byte[])tmpValue;
+            tmpBytes = (byte[]) tmpValue;
-        
+
-                  tmpValue = entry.isLocalInvalid()
-                    ? Token.LOCAL_INVALID
-                    : Token.INVALID;
+                  tmpValue = entry.isLocalInvalid() ? Token.LOCAL_INVALID : Token.INVALID;
-                
-                //Compare the version stamps, and if they are equal
-                //we can skip adding the entry we receive as part of GII.
+
+                // Compare the version stamps, and if they are equal
+                // we can skip adding the entry we receive as part of GII.
-                //If the received entry and what we have in the cache
-                //actually are equal, keep don't put the received
-                //entry into the cache (this avoids writing a record to disk)
-                if(entriesEqual) {
+                // If the received entry and what we have in the cache
+                // actually are equal, keep don't put the received
+                // entry into the cache (this avoids writing a record to disk)
+                if (entriesEqual) {
-                  tmpValue = CachedDeserializableFactory.create((byte[])tmpValue);
+                  tmpValue = CachedDeserializableFactory.create((byte[]) tmpValue);
-                    this.entries.initialImagePut(entry.key, lastModified, tmpValue,
-                        wasRecovered, true, tag, sender, this.isSynchronizing);
+                    this.entries.initialImagePut(entry.key, lastModified, tmpValue, wasRecovered,
+                        true, tag, sender, this.isSynchronizing);
-                }
-                catch (RegionDestroyedException e) {
+                } catch (RegionDestroyedException e) {
-                }
-                catch (CancelException e) {
+                } catch (CancelException e) {
-            //fix for 41814, java level deadlock
+            // fix for 41814, java level deadlock
-            keys.add(String.valueOf(entry.key) + ",v="+tag);
+            keys.add(String.valueOf(entry.key) + ",v=" + tag);
-            tmpValue = entry.isLocalInvalid()
-              ? Token.LOCAL_INVALID
-              : Token.INVALID;
+            tmpValue = entry.isLocalInvalid() ? Token.LOCAL_INVALID : Token.INVALID;
-            tmpValue = CachedDeserializableFactory.create((byte[])tmpValue);
+            tmpValue = CachedDeserializableFactory.create((byte[]) tmpValue);
-              logger.trace("processChunk:initialImagePut:key={},lastModified={},tmpValue={},wasRecovered={},tag={}",
+              logger.trace(
+                  "processChunk:initialImagePut:key={},lastModified={},tmpValue={},wasRecovered={},tag={}",
-            this.entries.initialImagePut(entry.key, lastModified, tmpValue,
-                wasRecovered, false, tag, sender, this.isSynchronizing);
-          }
-          catch (RegionDestroyedException e) {
+            this.entries.initialImagePut(entry.key, lastModified, tmpValue, wasRecovered, false,
+                tag, sender, this.isSynchronizing);
+          } catch (RegionDestroyedException e) {
-          }
-          catch (CancelException e) {
+          } catch (CancelException e) {
-      if (internalBeforeCleanExpiredTombstones != null && internalBeforeCleanExpiredTombstones.getRegionName().equals(this.region.getName())) {
+      if (internalBeforeCleanExpiredTombstones != null
+          && internalBeforeCleanExpiredTombstones.getRegionName().equals(this.region.getName())) {
-      if (internalAfterSavedRVVEnd != null && internalAfterSavedRVVEnd.getRegionName().equals(this.region.getName())) {
+      if (internalAfterSavedRVVEnd != null
+          && internalAfterSavedRVVEnd.getRegionName().equals(this.region.getName())) {
-    }
-    finally {
+    } finally {
-                
-  protected RegionVersionVector getRVVFromProvider(final DistributionManager dm, InternalDistributedMember recipient,
-      boolean targetReinitialized) {
+
+  protected RegionVersionVector getRVVFromProvider(final DistributionManager dm,
+      InternalDistributedMember recipient, boolean targetReinitialized) {
-    // RequestRVVMessage is to send rvv of gii provider for both persistent and non-persistent region
+    // RequestRVVMessage is to send rvv of gii provider for both persistent and non-persistent
+    // region
-    RequestRVVProcessor rvv_processor = new RequestRVVProcessor(this.region.getSystem(),
-        recipient);    
+    RequestRVVProcessor rvv_processor = new RequestRVVProcessor(this.region.getSystem(), recipient);
-    if (internalAfterRequestRVV != null && internalAfterRequestRVV.getRegionName().equals(this.region.getName())) {
+    if (internalAfterRequestRVV != null
+        && internalAfterRequestRVV.getRegionName().equals(this.region.getName())) {
-        throw (org.apache.geode.cache.TimeoutException)cause;
+        throw (org.apache.geode.cache.TimeoutException) cause;
-      if(!region.isDestroyed()) {
+      if (!region.isDestroyed()) {
-  /** 
-   * Compare the received RVV with local RVV and return a set of keys 
-   * for unfinished operations. 
+  /**
+   * Compare the received RVV with local RVV and return a set of keys for unfinished operations.
+   * 
-   *  @return set for keys of unfinished operations.
+   * @return set for keys of unfinished operations.
-    if (this.region.getDataPolicy().withPersistence() && localRVV.isNewerThanOrCanFillExceptionsFor(remoteRVV)) {
-      // only search for unfinished keys when localRVV has something newer 
+    if (this.region.getDataPolicy().withPersistence()
+        && localRVV.isNewerThanOrCanFillExceptionsFor(remoteRVV)) {
+      // only search for unfinished keys when localRVV has something newer
-        RegionEntry mapEntry = (RegionEntry)it.next();
+        RegionEntry mapEntry = (RegionEntry) it.next();
-          
-          if (count<10) {
+
+          if (count < 10) {
-              logger.trace(LogMarker.GII, "Region:{} found unfinished operation key={},member={},region version={}",
-                  region.getFullPath(), mapEntry.getKey(), stamp.getMemberID(), stamp.getRegionVersion());
+              logger.trace(LogMarker.GII,
+                  "Region:{} found unfinished operation key={},member={},region version={}",
+                  region.getFullPath(), mapEntry.getKey(), stamp.getMemberID(),
+                  stamp.getRegionVersion());
-          logger.trace(LogMarker.GII, "Region:{} found {} unfinished operations", region.getFullPath(), keys.size());
+          logger.trace(LogMarker.GII, "Region:{} found {} unfinished operations",
+              region.getFullPath(), keys.size());
-  
+
-    // the provider's was when the GII began.  This ensures that a
+    // the provider's was when the GII began. This ensures that a
-      logger.trace(LogMarker.GII, "Applying received version vector {} to {}", rvv.fullToString(), region.getName());
+      logger.trace(LogMarker.GII, "Applying received version vector {} to {}", rvv.fullToString(),
+          region.getName());
-    //TODO - RVV - Our current RVV might reflect some operations 
-    //that are concurrent updates. We want to keep those updates. However
-    //it might also reflect things that we recovered from disk that we are going
-    //to remove. We'll need to remove those from the RVV somehow.
+    // TODO - RVV - Our current RVV might reflect some operations
+    // that are concurrent updates. We want to keep those updates. However
+    // it might also reflect things that we recovered from disk that we are going
+    // to remove. We'll need to remove those from the RVV somehow.
-    if(region.getDataPolicy().withPersistence()) {
+    if (region.getDataPolicy().withPersistence()) {
-      logger.trace(LogMarker.GII, "version vector is now {}", region.getVersionVector().fullToString());
+      logger.trace(LogMarker.GII, "version vector is now {}",
+          region.getVersionVector().fullToString());
-  
+
-   * This is the processor that handles {@link ImageReplyMessage}s that
-   * arrive
+   * This is the processor that handles {@link ImageReplyMessage}s that arrive
-  class ImageProcessor extends ReplyProcessor21  {
+  class ImageProcessor extends ReplyProcessor21 {
-     * true if this image has been rendered moot, esp. by a region destroy,
-     * a clear, or a shutdown
+     * true if this image has been rendered moot, esp. by a region destroy, a clear, or a shutdown
-    
+
-    
+
-     * Keys are the senders (@link {@link InternalDistributedMember}), and
-     * values are instances of {@link Status}.
+     * Keys are the senders (@link {@link InternalDistributedMember}), and values are instances of
+     * {@link Status}.
-    
+
-    
+
-    /** 
-     * process the memberid:threadid -> sequence# information transmitted 
-     * along with an initial image from another cache 
-     */ 
-    void processRegionStateMessage(RegionStateMessage msg) { 
-      if (msg.eventState != null) { 
-        logger.debug("Applying event state to region {} from {}", region.getName(), msg.getSender()); 
-        region.recordEventState(msg.getSender(), msg.eventState); 
+    /**
+     * process the memberid:threadid -> sequence# information transmitted along with an initial
+     * image from another cache
+     */
+    void processRegionStateMessage(RegionStateMessage msg) {
+      if (msg.eventState != null) {
+        logger.debug("Applying event state to region {} from {}", region.getName(),
+            msg.getSender());
+        region.recordEventState(msg.getSender(), msg.eventState);
-      if (msg.versionVector != null && msg.getSender().getVersionObject().compareTo(Version.GFE_80) < 0 && region.getConcurrencyChecksEnabled()) {
+      if (msg.versionVector != null
+          && msg.getSender().getVersionObject().compareTo(Version.GFE_80) < 0
+          && region.getConcurrencyChecksEnabled()) {
-        if (internalBeforeSavedReceivedRVV != null && internalBeforeSavedReceivedRVV.getRegionName().equals(region.getName())) {
+        if (internalBeforeSavedReceivedRVV != null
+            && internalBeforeSavedReceivedRVV.getRegionName().equals(region.getName())) {
-        if (internalAfterSavedReceivedRVV != null && internalAfterSavedReceivedRVV.getRegionName().equals(region.getName())) {
+        if (internalAfterSavedReceivedRVV != null
+            && internalAfterSavedReceivedRVV.getRegionName().equals(region.getName())) {
-    } 
+    }
-    class Status  {
+    class Status {
-      
+
-       * This is not set until the last chunk is received, so while it is
-       * zero we know we are not done.
+       * This is not set until the last chunk is received, so while it is zero we know we are not
+       * done.
-      
+
-      
+
-          logger.debug("InitialImage Message Tracking Status: Processor id: {}; Sender: {}; Messages Processed: {}; NumInSeries:{}",
-              getProcessorId(), m.getSender(), arrayToString(this.msgsProcessed), arrayToString(this.numInSeries));
+          logger.debug(
+              "InitialImage Message Tracking Status: Processor id: {}; Sender: {}; Messages Processed: {}; NumInSeries:{}",
+              getProcessorId(), m.getSender(), arrayToString(this.msgsProcessed),
+              arrayToString(this.numInSeries));
-        return(this.allChunksReceived);
+        return (this.allChunksReceived);
-    
-    
+
+
-                          InternalDistributedMember member) {
+        InternalDistributedMember member) {
-    public ImageProcessor(InternalDistributedSystem system,
-                          Set members) {
-      super(system, members); 
+    public ImageProcessor(InternalDistributedSystem system, Set members) {
+      super(system, members);
-    
+
-    protected boolean processTimeout(){
-      //if chunk recieved then no need to process timeout
+    protected boolean processTimeout() {
+      // if chunk recieved then no need to process timeout
-    
+
-     * @see org.apache.geode.distributed.internal.ReplyProcessor21#process(org.apache.geode.distributed.internal.DistributionMessage)
+     * 
+     * @see
+     * org.apache.geode.distributed.internal.ReplyProcessor21#process(org.apache.geode.distributed.
+     * internal.DistributionMessage)
-    @Override  
+    @Override
-        // ignore messages from members not in the wait list
+      // ignore messages from members not in the wait list
-          processRegionStateMessage((RegionStateMessage)msg);
+          processRegionStateMessage((RegionStateMessage) msg);
-          ImageReplyMessage m = (ImageReplyMessage)msg;
-          
+          ImageReplyMessage m = (ImageReplyMessage) msg;
+
-              if (internalAfterReceivedImageReply != null && internalAfterReceivedImageReply.getRegionName().equals(region.getName())) {
+              if (internalAfterReceivedImageReply != null
+                  && internalAfterReceivedImageReply.getRegionName().equals(region.getName())) {
-                isAborted = !processChunk(m.entries, m.getSender(),
-                    m.remoteVersion);
+                isAborted = !processChunk(m.entries, m.getSender(), m.remoteVersion);
-                }else {
+                } else {
-              
+
-                  logger.debug("processChunk is aborted for region {}, rvv is {}. Do full gii next time.",
-                      InitialImageOperation.this.region.getFullPath(), InitialImageOperation.this.region.getVersionVector());
+                  logger.debug(
+                      "processChunk is aborted for region {}, rvv is {}. Do full gii next time.",
+                      InitialImageOperation.this.region.getFullPath(),
+                      InitialImageOperation.this.region.getVersionVector());
-            }
-            catch( DiskAccessException dae) { 
+            } catch (DiskAccessException dae) {
-            }
-            catch (Throwable t) {
+            } catch (Throwable t) {
-              // catch VirtualMachineError (see above).  However, there is
+              // catch VirtualMachineError (see above). However, there is
-          }
-          else {
+          } else {
-          
-          if(m.gcVersions != null) {
+
+          if (m.gcVersions != null) {
-      }
-      finally {
+      } finally {
-        checkIfDone(); // check to see if decrementing msgsBeingProcessed requires signaling to proceed
+        checkIfDone(); // check to see if decrementing msgsBeingProcessed requires signaling to
+                       // proceed
-    }  
+    }
-     * Contract of {@link ReplyProcessor21#stillWaiting()} is that it must
-     * never return true after having returned false.
+     * Contract of {@link ReplyProcessor21#stillWaiting()} is that it must never return true after
+     * having returned false.
-    
-    /** Overridden to wait for messages being currently processed:
-     *  This situation can come about if a member departs while we
-     *  are still processing data from that member
+
+    /**
+     * Overridden to wait for messages being currently processed: This situation can come about if a
+     * member departs while we are still processing data from that member
-    @Override  
+    @Override
-      }
-      else {
+      } else {
-    
-        
-    @Override  
+
+
+    @Override
-      //bug 37189  These strings are a work-around for an escaped reference
-      //in ReplyProcessor21 constructor
+      // bug 37189 These strings are a work-around for an escaped reference
+      // in ReplyProcessor21 constructor
-    		  : String.valueOf(this.msgsBeingProcessed.get());
+          : String.valueOf(this.msgsBeingProcessed.get());
-    		  : InitialImageOperation.this.region.getFullPath();
+          : InitialImageOperation.this.region.getFullPath();
-//      String membersToStr = (this.members == null) ? "nullRef" : membersToString();
-    	
-      return "<" + this.getClass().getName() + " " + this.getProcessorId() +
-        " waiting for " + numMembersStr + " replies" + 
-        (exception == null ? "" : (" exception: " + exception)) +
-        " from " + membersToString() 
-        + "; waiting for " + msgsBeingProcessedStr +
-            " messages in-flight; " 
-        + "region=" + regionStr 
-        + "; abort=" + this.abort + ">";
-    }    
-    
+      // String membersToStr = (this.members == null) ? "nullRef" : membersToString();
+
+      return "<" + this.getClass().getName() + " " + this.getProcessorId() + " waiting for "
+          + numMembersStr + " replies" + (exception == null ? "" : (" exception: " + exception))
+          + " from " + membersToString() + "; waiting for " + msgsBeingProcessedStr
+          + " messages in-flight; " + "region=" + regionStr + "; abort=" + this.abort + ">";
+    }
+
-        status = (Status)this.statusMap.get(sender);
+        status = (Status) this.statusMap.get(sender);
-      
+
-        
+
-  
+
-  
+
-    
+
-    int initLevel = targetReinitialized ? LocalRegion.AFTER_INITIAL_IMAGE
-        : LocalRegion.ANY_INIT;
+    int initLevel = targetReinitialized ? LocalRegion.AFTER_INITIAL_IMAGE : LocalRegion.ANY_INIT;
-      //GemFireCache cache = (GemFireCache)CacheFactory.getInstance(system);
+      // GemFireCache cache = (GemFireCache)CacheFactory.getInstance(system);
-        logger.debug("RequestImageMessage: attempting to get region reference for {}, initLevel={}", regionPath, initLevel);
+        logger.debug("RequestImageMessage: attempting to get region reference for {}, initLevel={}",
+            regionPath, initLevel);
-      if (lclRgn != null && !lclRgn.isUsedForPartitionedRegionBucket()
-          && targetReinitialized && !lclRgn.reinitialized_new()) {
+      if (lclRgn != null && !lclRgn.isUsedForPartitionedRegionBucket() && targetReinitialized
+          && !lclRgn.reinitialized_new()) {
-          logger.debug("GII message process: Found region, but wasn't reinitialized, so assuming region destroyed and recreated");
+          logger.debug(
+              "GII message process: Found region, but wasn't reinitialized, so assuming region destroyed and recreated");
-    }
-    finally {
+    } finally {
-        logger.debug("{}, nothing to do", (lclRgn == null ? "region not found" : "region not initialized yet"));
+        logger.debug("{}, nothing to do",
+            (lclRgn == null ? "region not found" : "region not initialized yet"));
-    
+
-  public static final class RequestImageMessage 
-    extends DistributionMessage implements MessageWithReply {
+  public static final class RequestImageMessage extends DistributionMessage
+      implements MessageWithReply {
-     * a version vector is transmitted with the request if we are merely
-     * synchronizing with an existing region, or providing missed updates
-     * for a recreated region
+     * a version vector is transmitted with the request if we are merely synchronizing with an
+     * existing region, or providing missed updates for a recreated region
-    
+
-     * if a version vector is transmitted, this will be sent along with it
-     * to tell the image provider that only changes made by this ID should
-     * be sent back
+     * if a version vector is transmitted, this will be sent along with it to tell the image
+     * provider that only changes made by this ID should be sent back
-    
+
-     * Name of the region we want
-     * This field is public for test code.
+     * Name of the region we want This field is public for test code.
-    
+
-    
+
-    
+
-    
+
-     * If true, recipient should wait until fully initialized before
-     * returning data.
+     * If true, recipient should wait until fully initialized before returning data.
-        
+
-     * whether severe alert processing should be performed in the reply processor
-     * for this message
+     * whether severe alert processing should be performed in the reply processor for this message
-    
+
-    @Override  
+    @Override
-    @Override  
+    @Override
-      return this.targetReinitialized ? DistributionManager.WAITING_POOL_EXECUTOR :
-                                DistributionManager.HIGH_PRIORITY_EXECUTOR;
+      return this.targetReinitialized ? DistributionManager.WAITING_POOL_EXECUTOR
+          : DistributionManager.HIGH_PRIORITY_EXECUTOR;
-    
+
-          logger.debug("Region {}'s local RVVGC is not dominated by remote RVV={}, do full GII", rgn.getFullPath(), requesterRVV);
+          logger.debug("Region {}'s local RVVGC is not dominated by remote RVV={}, do full GII",
+              rgn.getFullPath(), requesterRVV);
-        
-    @Override  
+
+    @Override
-      
+
-      if (lclAbortTest) abortTest = false;
-            
+      if (lclAbortTest)
+        abortTest = false;
+
-        final DistributedRegion rgn = (DistributedRegion)getGIIRegion(dm, this.regionPath, this.targetReinitialized);
+        final DistributedRegion rgn =
+            (DistributedRegion) getGIIRegion(dm, this.regionPath, this.targetReinitialized);
-         
+
-        if (internalAfterReceivedRequestImage != null && internalAfterReceivedRequestImage.getRegionName().equals(rgn.getName())) {
+        if (internalAfterReceivedRequestImage != null
+            && internalAfterReceivedRequestImage.getRegionName().equals(rgn.getName())) {
-              logger.trace(LogMarker.GII, "ignoring synchronization request as this region has no version vector");
+              logger.trace(LogMarker.GII,
+                  "ignoring synchronization request as this region has no version vector");
-            logger.debug("checking version vector against region's ({})", rgn.getVersionVector().fullToString());
+            logger.debug("checking version vector against region's ({})",
+                rgn.getVersionVector().fullToString());
-          // specific versions that the sender is missing.  The current check
+          // specific versions that the sender is missing. The current check
-          if ( !rgn.getVersionVector().isNewerThanOrCanFillExceptionsFor(this.versionVector) ) {
+          if (!rgn.getVersionVector().isNewerThanOrCanFillExceptionsFor(this.versionVector)) {
-            // no need to send any data.  This is a synchronization request and this region's
+            // no need to send any data. This is a synchronization request and this region's
-                logger.trace(LogMarker.GII, "version vector reports that I have nothing that the requester hasn't already seen");
+                logger.trace(LogMarker.GII,
+                    "version vector reports that I have nothing that the requester hasn't already seen");
-              logger.trace(LogMarker.GII, "version vector reports that I have updates the requester hasn't seen, remote rvv is {}", this.versionVector);
+              logger.trace(LogMarker.GII,
+                  "version vector reports that I have updates the requester hasn't seen, remote rvv is {}",
+                  this.versionVector);
-        
+
-          logger.trace(LogMarker.GII, "RequestImageMessage: Starting chunkEntries for {}", rgn.getFullPath());
+          logger.trace(LogMarker.GII, "RequestImageMessage: Starting chunkEntries for {}",
+              rgn.getFullPath());
-        
-        final InitialImageFlowControl flowControl = InitialImageFlowControl.register(dm, getSender());
-        
+
+        final InitialImageFlowControl flowControl =
+            InitialImageFlowControl.register(dm, getSender());
+
-          ((HARegion)rgn).startServingGIIRequest();
+          ((HARegion) rgn).startServingGIIRequest();
-            // wait for the lost member to be gone from this VM's membership and all ops applied to the cache
+            // wait for the lost member to be gone from this VM's membership and all ops applied to
+            // the cache
-              RegionVersionHolder rvh = rgn.getVersionVector().getHolderForMember(this.lostMemberVersionID);
+              RegionVersionHolder rvh =
+                  rgn.getVersionVector().getHolderForMember(this.lostMemberVersionID);
-                RegionVersionHolder holderOfRequest = this.versionVector.getHolderForMember(this.lostMemberVersionID);
+                RegionVersionHolder holderOfRequest =
+                    this.versionVector.getHolderForMember(this.lostMemberVersionID);
-                  logger.trace(LogMarker.GII, "synchronizeWith detected mismatch region version holder for lost member {}. Old is {}, new is {}",
+                  logger.trace(LogMarker.GII,
+                      "synchronizeWith detected mismatch region version holder for lost member {}. Old is {}, new is {}",
-                logger.trace(LogMarker.GII, "timed out waiting for the departure of {} before processing delta GII request", this.lostMemberID);
+                logger.trace(LogMarker.GII,
+                    "timed out waiting for the departure of {} before processing delta GII request",
+                    this.lostMemberID);
-            if (rgn instanceof HARegion) { 
-            //long eventXferStart = System.currentTimeMillis();
-              Map<? extends DataSerializable, ? extends DataSerializable> eventState = rgn.getEventState(); 
-              if (eventState != null && eventState.size() > 0) {
-                RegionStateMessage.send(dm, getSender(), this.processorId, eventState, true);
-              }
-            } else if (getSender().getVersionObject().compareTo(Version.GFE_80) < 0) {
-              // older versions of the product expect a RegionStateMessage at this point
-              if (rgn.concurrencyChecksEnabled && this.versionVector == null && !recoveringForLostMember) {
-                RegionVersionVector rvv = rgn.getVersionVector().getCloneForTransmission();
-                RegionStateMessage.send(dm, getSender(), this.processorId, rvv, false);
-              }
+          if (rgn instanceof HARegion) {
+            // long eventXferStart = System.currentTimeMillis();
+            Map<? extends DataSerializable, ? extends DataSerializable> eventState =
+                rgn.getEventState();
+            if (eventState != null && eventState.size() > 0) {
+              RegionStateMessage.send(dm, getSender(), this.processorId, eventState, true);
-            if (this.checkTombstoneVersions && this.versionVector != null && rgn.concurrencyChecksEnabled) {
-              synchronized(rgn.getCache().getTombstoneService().getBlockGCLock()) {
+          } else if (getSender().getVersionObject().compareTo(Version.GFE_80) < 0) {
+            // older versions of the product expect a RegionStateMessage at this point
+            if (rgn.concurrencyChecksEnabled && this.versionVector == null
+                && !recoveringForLostMember) {
+              RegionVersionVector rvv = rgn.getVersionVector().getCloneForTransmission();
+              RegionStateMessage.send(dm, getSender(), this.processorId, rvv, false);
+            }
+          }
+          if (this.checkTombstoneVersions && this.versionVector != null
+              && rgn.concurrencyChecksEnabled) {
+            synchronized (rgn.getCache().getTombstoneService().getBlockGCLock()) {
-              }
-            final RegionVersionHolder holderToSend = holderToSync;
-            boolean finished = chunkEntries(rgn, CHUNK_SIZE_IN_BYTES, !keysOnly, versionVector,
-                (HashSet)this.unfinishedKeys, flowControl, new ObjectIntProcedure() {
-              int msgNum = 0;
+          }
+          final RegionVersionHolder holderToSend = holderToSync;
+          boolean finished = chunkEntries(rgn, CHUNK_SIZE_IN_BYTES, !keysOnly, versionVector,
+              (HashSet) this.unfinishedKeys, flowControl, new ObjectIntProcedure() {
+                int msgNum = 0;
-              boolean last = false;
-              /**
-               * @param entList ArrayList of entries
-               * @param b positive if last chunk
-               * @return true to continue to next chunk
-               */
-              public boolean executeWith(Object entList, int b) {
-                if (rgn.getCache().isClosed()) {
-                  return false;
-                }
-                
-                if (this.last) {
-                  throw new InternalGemFireError(LocalizedStrings.InitialImageOperation_ALREADY_PROCESSED_LAST_CHUNK.toLocalizedString());
-                }
+                boolean last = false;
-                List entries = (List)entList;
-                this.last = b > 0 && !lclAbortTest; // if abortTest, then never send last flag set to true
-                try {
-                  boolean abort = rgn.isDestroyed();
-                  if (!abort) {
-                    int fid = flowControl.getId();
-                    Map<VersionSource, Long> gcVersions = null;
-                    if(this.last && rgn.getVersionVector() != null) {
-                      gcVersions = rgn.getVersionVector().getMemberToGCVersion();
-                    }
-                    replyWithData(dm, entries, seriesNum, msgNum++, numSeries, this.last, fid, versionVector!=null, holderToSend, gcVersions);
+                /**
+                 * @param entList ArrayList of entries
+                 * @param b positive if last chunk
+                 * @return true to continue to next chunk
+                 */
+                public boolean executeWith(Object entList, int b) {
+                  if (rgn.getCache().isClosed()) {
+                    return false;
-                  return !abort;
+
+                  if (this.last) {
+                    throw new InternalGemFireError(
+                        LocalizedStrings.InitialImageOperation_ALREADY_PROCESSED_LAST_CHUNK
+                            .toLocalizedString());
+                  }
+
+                  List entries = (List) entList;
+                  this.last = b > 0 && !lclAbortTest; // if abortTest, then never send last flag set
+                                                      // to true
+                  try {
+                    boolean abort = rgn.isDestroyed();
+                    if (!abort) {
+                      int fid = flowControl.getId();
+                      Map<VersionSource, Long> gcVersions = null;
+                      if (this.last && rgn.getVersionVector() != null) {
+                        gcVersions = rgn.getVersionVector().getMemberToGCVersion();
+                      }
+                      replyWithData(dm, entries, seriesNum, msgNum++, numSeries, this.last, fid,
+                          versionVector != null, holderToSend, gcVersions);
+                    }
+                    return !abort;
+                  } catch (CancelException e) {
+                    return false;
+                  }
-                catch (CancelException e) {
-                  return false;
-                }
-              }
-            });
+              });
-            if (isGiiDebugEnabled) {
-              logger.trace(LogMarker.GII, "RequestImageMessage: ended chunkEntries for {}; finished = {}", rgn.getFullPath(), finished);
-            }
+          if (isGiiDebugEnabled) {
+            logger.trace(LogMarker.GII,
+                "RequestImageMessage: ended chunkEntries for {}; finished = {}", rgn.getFullPath(),
+                finished);
+          }
-            // Call to chunkEntries above will have sent at least one
-            // reply with last==true for the last message. (unless doing abortTest or
-            // region is destroyed or cache closed)
-            if (finished && !lclAbortTest) {
-              sendFailureMessage = false;
-              return; // sent msg with last indicated
-            }
+          // Call to chunkEntries above will have sent at least one
+          // reply with last==true for the last message. (unless doing abortTest or
+          // region is destroyed or cache closed)
+          if (finished && !lclAbortTest) {
+            sendFailureMessage = false;
+            return; // sent msg with last indicated
+          }
-            ((HARegion)rgn).endServingGIIRequest();
+            ((HARegion) rgn).endServingGIIRequest();
-        
+
-        Assert.assertTrue(lclAbortTest, this + 
-            ": Did not finish sending image, but region, cache, and DS are alive.");
+        Assert.assertTrue(lclAbortTest,
+            this + ": Did not finish sending image, but region, cache, and DS are alive.");
-      }
-      catch (RegionDestroyedException e) {
-//        thr = e; Don't marshal an exception here; just return null
+      } catch (RegionDestroyedException e) {
+        // thr = e; Don't marshal an exception here; just return null
-      }
-      catch (IllegalStateException e) {
-//      thr = e; Don't marshal an exception here; just return null
+      } catch (IllegalStateException e) {
+        // thr = e; Don't marshal an exception here; just return null
-      }
-      catch (CancelException e) {
-//      thr = e; Don't marshal an exception here; just return null
+      } catch (CancelException e) {
+        // thr = e; Don't marshal an exception here; just return null
-      }
-      catch (VirtualMachineError err) {
+      } catch (VirtualMachineError err) {
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-      }
-      catch (Throwable t) {
+      } catch (Throwable t) {
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-      }
-      finally {
+      } finally {
-          ImageReplyMessage.send(getSender(), processorId, rex, dm, 
-              null, 0, 0, 1, true, 0, false, null, null);
+          ImageReplyMessage.send(getSender(), processorId, rex, dm, null, 0, 0, 1, true, 0, false,
+              null, null);
-        
-        if (internalAfterSentImageReply != null && regionPath.endsWith(internalAfterSentImageReply.getRegionName())) {
+
+        if (internalAfterSentImageReply != null
+            && regionPath.endsWith(internalAfterSentImageReply.getRegionName())) {
-     * Serialize the entries into byte[] chunks, calling proc for each one. proc
-     * args: the byte[] chunk and an int indicating whether it is the last chunk
-     * (positive means last chunk, zero otherwise). The return value of proc
-     * indicates whether to continue to the next chunk (true) or abort (false).
+     * Serialize the entries into byte[] chunks, calling proc for each one. proc args: the byte[]
+     * chunk and an int indicating whether it is the last chunk (positive means last chunk, zero
+     * otherwise). The return value of proc indicates whether to continue to the next chunk (true)
+     * or abort (false).
+     * 
-     * @param flowControl 
+     * @param flowControl
-    protected boolean chunkEntries(DistributedRegion rgn, int chunkSizeInBytes, boolean includeValues,
-        RegionVersionVector versionVector, HashSet unfinishedKeys, InitialImageFlowControl flowControl, ObjectIntProcedure proc) throws IOException
-    {
+    protected boolean chunkEntries(DistributedRegion rgn, int chunkSizeInBytes,
+        boolean includeValues, RegionVersionVector versionVector, HashSet unfinishedKeys,
+        InitialImageFlowControl flowControl, ObjectIntProcedure proc) throws IOException {
-      int MAX_ENTRIES_PER_CHUNK = chunkSizeInBytes/100;
+      int MAX_ENTRIES_PER_CHUNK = chunkSizeInBytes / 100;
-      chunkEntries = new InitialImageVersionedEntryList(rgn.concurrencyChecksEnabled, MAX_ENTRIES_PER_CHUNK);
+      chunkEntries =
+          new InitialImageVersionedEntryList(rgn.concurrencyChecksEnabled, MAX_ENTRIES_PER_CHUNK);
-      if( dr!=null ){
+      if (dr != null) {
-      if (internalDuringPackingImage != null && this.regionPath.endsWith(internalDuringPackingImage.getRegionName())) {
+      if (internalDuringPackingImage != null
+          && this.regionPath.endsWith(internalDuringPackingImage.getRegionName())) {
-      
+
-        
-          while (chunkEntries.size() < MAX_ENTRIES_PER_CHUNK
-              && currentChunkSize < chunkSizeInBytes
+
+          while (chunkEntries.size() < MAX_ENTRIES_PER_CHUNK && currentChunkSize < chunkSizeInBytes
-            RegionEntry mapEntry = (RegionEntry)it.next();
-            Object key = mapEntry.getKey();        
+            RegionEntry mapEntry = (RegionEntry) it.next();
+            Object key = mapEntry.getKey();
-                if (((Conflatable)v).getEventId() == null) {
+                if (((Conflatable) v).getEventId() == null) {
-                  synchronized(mapEntry) { // bug #46042 must sync to make sure the tag goes with the value
+                  synchronized (mapEntry) { // bug #46042 must sync to make sure the tag goes with
+                                            // the value
-                    if (id == null) { id = myId; }
+                    if (id == null) {
+                      id = myId;
+                    }
-                    if ((unfinishedKeys == null || !unfinishedKeys.contains(key)) && versionVector != null) {
+                    if ((unfinishedKeys == null || !unfinishedKeys.contains(key))
+                        && versionVector != null) {
-              }
-              catch(DiskAccessException dae) {
+              } catch (DiskAccessException dae) {
-              if(!fillRes) {
+              if (!fillRes) {
-            }
-            else {
+            } else {
-              entry.setLastModified(rgn.getDistributionManager(), mapEntry
-                  .getLastModified());
+              entry.setLastModified(rgn.getDistributionManager(), mapEntry.getLastModified());
-          RegionVersionVector vv = rgn.getVersionVector(); 
+          RegionVersionVector vv = rgn.getVersionVector();
-      }
-      finally {
-        if( dr!=null ){
+      } finally {
+        if (dr != null) {
-    private void replyNoData(DistributionManager dm, boolean isDeltaGII, Map<VersionSource, Long> gcVersions) {
-      ImageReplyMessage.send(getSender(), this.processorId, null, dm, null, 0, 0, 1, true,0, isDeltaGII, null, gcVersions);
+    private void replyNoData(DistributionManager dm, boolean isDeltaGII,
+        Map<VersionSource, Long> gcVersions) {
+      ImageReplyMessage.send(getSender(), this.processorId, null, dm, null, 0, 0, 1, true, 0,
+          isDeltaGII, null, gcVersions);
-    protected void replyWithData(DistributionManager dm, List entries,
-                               int seriesNum, int msgNum, int numSeries, boolean lastInSeries,
-                               int flowControlId, boolean isDeltaGII, 
-                               RegionVersionHolder holderToSend, Map<VersionSource, Long> gcVersions) {
-      ImageReplyMessage.send(getSender(), this.processorId, null, dm, entries,
-                             seriesNum, msgNum, numSeries, lastInSeries,flowControlId, isDeltaGII, holderToSend, gcVersions);
-    }  
-    
+    protected void replyWithData(DistributionManager dm, List entries, int seriesNum, int msgNum,
+        int numSeries, boolean lastInSeries, int flowControlId, boolean isDeltaGII,
+        RegionVersionHolder holderToSend, Map<VersionSource, Long> gcVersions) {
+      ImageReplyMessage.send(getSender(), this.processorId, null, dm, entries, seriesNum, msgNum,
+          numSeries, lastInSeries, flowControlId, isDeltaGII, holderToSend, gcVersions);
+    }
+
-          logger.debug("abortTest: Disconnecting from distributed system and sending null chunk to abort");
+          logger.debug(
+              "abortTest: Disconnecting from distributed system and sending null chunk to abort");
-        ThreadGroup group = LoggingThreadGroup.createThreadGroup(
-            "InitialImageOperation abortTest Threads", logger);
-        Thread disconnectThread = 
-            new Thread(group, "InitialImageOperation abortTest Thread") {
-          @Override  
+        ThreadGroup group =
+            LoggingThreadGroup.createThreadGroup("InitialImageOperation abortTest Threads", logger);
+        Thread disconnectThread = new Thread(group, "InitialImageOperation abortTest Thread") {
+          @Override
-    
+
-    @Override  
+    @Override
-      this.lostMemberVersionID = (VersionSource)DataSerializer.readObject(in);
-      this.versionVector = (RegionVersionVector)DataSerializer.readObject(in);
-      this.lostMemberID = (InternalDistributedMember)DataSerializer.readObject(in);
-      this.unfinishedKeys = (Set)DataSerializer.readObject(in);
+      this.lostMemberVersionID = (VersionSource) DataSerializer.readObject(in);
+      this.versionVector = (RegionVersionVector) DataSerializer.readObject(in);
+      this.lostMemberID = (InternalDistributedMember) DataSerializer.readObject(in);
+      this.unfinishedKeys = (Set) DataSerializer.readObject(in);
-    
-    @Override  
+
+    @Override
-    
+
-    
-    @Override  
+
+    @Override
-      String cname = getClass().getName().substring(
-          getClass().getPackage().getName().length() + 1);
+      String cname = getClass().getName().substring(getClass().getPackage().getName().length() + 1);
-    @Override  
+    @Override
-  class FilterInfoProcessor extends ReplyProcessor21  {
+  class FilterInfoProcessor extends ReplyProcessor21 {
-    
+
-                          InternalDistributedMember member) {
+        InternalDistributedMember member) {
-    public FilterInfoProcessor(InternalDistributedSystem system,
-                          Set members) {
-      super(system, members); 
+    public FilterInfoProcessor(InternalDistributedSystem system, Set members) {
+      super(system, members);
-        
-    @Override  
+
+    @Override
-        if ( !(msg instanceof FilterInfoMessage) ) {
+        if (!(msg instanceof FilterInfoMessage)) {
-        FilterInfoMessage m = (FilterInfoMessage)msg;
+        FilterInfoMessage m = (FilterInfoMessage) msg;
-        
+
-              CacheClientProxy proxy = ((HAContainerWrapper)ccn.getHaContainer()).getProxy(
-                  region.getName());      
+              CacheClientProxy proxy =
+                  ((HAContainerWrapper) ccn.getHaContainer()).getProxy(region.getName());
-        
+
-        
+
-        
+
-    }       
-            
-    @Override  
+    }
+
+    @Override
-      String cname = getClass().getName().substring(
-          getClass().getPackage().getName().length() + 1);
-      return "<" + cname + " " + this.getProcessorId() + 
-      " replies" + (exception == null ? "" : (" exception: " + exception)) +
-        " from " + membersToString() + ">";
-    }            
- 
-    @Override      
+      String cname = getClass().getName().substring(getClass().getPackage().getName().length() + 1);
+      return "<" + cname + " " + this.getProcessorId() + " replies"
+          + (exception == null ? "" : (" exception: " + exception)) + " from " + membersToString()
+          + ">";
+    }
+
+    @Override
-  
+
-  public static final class RequestFilterInfoMessage 
-    extends DistributionMessage implements MessageWithReply {
+  public static final class RequestFilterInfoMessage extends DistributionMessage
+      implements MessageWithReply {
-    
+
-            
-    @Override  
+
+    @Override
-        
-    @Override  
+
+    @Override
-    
-    @Override  
+
+    @Override
-      Throwable thr = null;           
+      Throwable thr = null;
-        Assert.assertTrue(this.regionPath != null, "Region path is null.");        
+        Assert.assertTrue(this.regionPath != null, "Region path is null.");
-        
+
-            logger.debug("{}; Failed to process filter info request. Region not yet initialized.", this);
+            logger.debug("{}; Failed to process filter info request. Region not yet initialized.",
+                this);
-        
-        final DistributedRegion rgn = (DistributedRegion)lclRgn;
-        FilterInfoMessage.send(dm, getSender(), this.processorId, rgn, null);         
+
+        final DistributedRegion rgn = (DistributedRegion) lclRgn;
+        FilterInfoMessage.send(dm, getSender(), this.processorId, rgn, null);
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-          
-          if (rex == null){
+
+          if (rex == null) {
-        
+
-    @Override  
+    @Override
-    
-    @Override  
+
+    @Override
-    @Override  
+    @Override
-      String cname = getClass().getName().substring(
-          getClass().getPackage().getName().length() + 1);
+      String cname = getClass().getName().substring(getClass().getPackage().getName().length() + 1);
-  class RequestRVVProcessor extends ReplyProcessor21  {
-//    Set keysOfUnfinishedOps;
+  class RequestRVVProcessor extends ReplyProcessor21 {
+    // Set keysOfUnfinishedOps;
+
-                          InternalDistributedMember member) {
+        InternalDistributedMember member) {
-    public RequestRVVProcessor(InternalDistributedSystem system,
-                          Set members) {
-      super(system, members); 
+    public RequestRVVProcessor(InternalDistributedSystem system, Set members) {
+      super(system, members);
-        
-    @Override  
+
+    @Override
-      
-      ReplyMessage reply = (ReplyMessage)msg;
+
+      ReplyMessage reply = (ReplyMessage) msg;
-            logger.trace(LogMarker.GII, "Did not received RVVReply from {}. Remote member might be down.", Arrays.toString(getMembers()));
+            logger.trace(LogMarker.GII,
+                "Did not received RVVReply from {}. Remote member might be down.",
+                Arrays.toString(getMembers()));
-        if (reply.getException()!=null) {
+        if (reply.getException() != null) {
-            logger.trace(LogMarker.GII, "Failed to get RVV from {} due to {}", reply.getSender(), reply.getException());
+            logger.trace(LogMarker.GII, "Failed to get RVV from {} due to {}", reply.getSender(),
+                reply.getException());
-          RVVReplyMessage rvv_reply = (RVVReplyMessage)reply;
+          RVVReplyMessage rvv_reply = (RVVReplyMessage) reply;
-            logger.trace(LogMarker.GII, "{} did not send back rvv. Maybe it's non-persistent proxy region or remote region {} not found or not initialized. Nothing to do.",
-              reply.getSender(), region.getFullPath());
+            logger.trace(LogMarker.GII,
+                "{} did not send back rvv. Maybe it's non-persistent proxy region or remote region {} not found or not initialized. Nothing to do.",
+                reply.getSender(), region.getFullPath());
-    }       
-            
-    @Override  
+    }
+
+    @Override
-      String cname = getClass().getName().substring(
-          getClass().getPackage().getName().length() + 1);
+      String cname = getClass().getName().substring(getClass().getPackage().getName().length() + 1);
-    }            
- 
-    @Override      
+    }
+
+    @Override
-  
-  /** 
-   * RVVReplyMessage transmits the GII provider's RVV to requester 
-   *  
-   */ 
-  public static class RVVReplyMessage extends ReplyMessage { 
-     
-    @Override   
-    public boolean getInlineProcess() { 
-      return false; 
-    } 
- 
-    RegionVersionVector versionVector; 
-     
-    public RVVReplyMessage() { 
-    } 
- 
-    private RVVReplyMessage(InternalDistributedMember mbr, int processorId, RegionVersionVector rvv) { 
-      setRecipient(mbr); 
-      setProcessorId(processorId); 
+
+  /**
+   * RVVReplyMessage transmits the GII provider's RVV to requester
+   * 
+   */
+  public static class RVVReplyMessage extends ReplyMessage {
+
+    @Override
+    public boolean getInlineProcess() {
+      return false;
+    }
+
+    RegionVersionVector versionVector;
+
+    public RVVReplyMessage() {}
+
+    private RVVReplyMessage(InternalDistributedMember mbr, int processorId,
+        RegionVersionVector rvv) {
+      setRecipient(mbr);
+      setProcessorId(processorId);
-    } 
-     
-    public static void send(DM dm, InternalDistributedMember dest, int processorId, 
+    }
+
+    public static void send(DM dm, InternalDistributedMember dest, int processorId,
-      RVVReplyMessage msg = new RVVReplyMessage(dest, processorId, rvv); 
+      RVVReplyMessage msg = new RVVReplyMessage(dest, processorId, rvv);
-      dm.putOutgoing(msg); 
+      dm.putOutgoing(msg);
-     
-    @Override   
-    public void toData(DataOutput dop) throws IOException { 
+
+    @Override
+    public void toData(DataOutput dop) throws IOException {
-    } 
+    }
-    @Override   
-    public String toString() { 
-      String descr = super.toString(); 
+    @Override
+    public String toString() {
+      String descr = super.toString();
-        descr += "; versionVector=" + (RegionVersionVector.DEBUG? versionVector.fullToString() : versionVector);
+        descr += "; versionVector="
+            + (RegionVersionVector.DEBUG ? versionVector.fullToString() : versionVector);
-      return descr; 
-    } 
-     
-    @Override   
-    public void fromData(DataInput dip) throws IOException, ClassNotFoundException { 
+      return descr;
+    }
+
+    @Override
+    public void fromData(DataInput dip) throws IOException, ClassNotFoundException {
-    } 
-     
-    /* (non-Javadoc) 
-     * @see org.apache.geode.internal.DataSerializableFixedID#getDSFID() 
-     */ 
-    @Override   
-    public int getDSFID() { 
-      return RVV_REPLY_MESSAGE; 
-    } 
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.geode.internal.DataSerializableFixedID#getDSFID()
+     */
+    @Override
+    public int getDSFID() {
+      return RVV_REPLY_MESSAGE;
+    }
-  public static final class RequestRVVMessage 
-    extends DistributionMessage implements MessageWithReply {
+  public static final class RequestRVVMessage extends DistributionMessage
+      implements MessageWithReply {
-    
+
-    
+
-     * If true, recipient should wait until fully initialized before
-     * returning data.
+     * If true, recipient should wait until fully initialized before returning data.
-    @Override  
+    @Override
-        
-    @Override  
+
+    @Override
-      return this.targetReinitialized ? DistributionManager.WAITING_POOL_EXECUTOR :
-                                DistributionManager.HIGH_PRIORITY_EXECUTOR;
+      return this.targetReinitialized ? DistributionManager.WAITING_POOL_EXECUTOR
+          : DistributionManager.HIGH_PRIORITY_EXECUTOR;
-    
-    @Override  
+
+    @Override
-      Throwable thr = null;            
+      Throwable thr = null;
-        Assert.assertTrue(this.regionPath != null, "Region path is null.");        
-        final DistributedRegion rgn = (DistributedRegion)getGIIRegion(dm, this.regionPath, this.targetReinitialized);
+        Assert.assertTrue(this.regionPath != null, "Region path is null.");
+        final DistributedRegion rgn =
+            (DistributedRegion) getGIIRegion(dm, this.regionPath, this.targetReinitialized);
-      }
-      catch (RegionDestroyedException e) {
+      } catch (RegionDestroyedException e) {
-      }
-      catch (CancelException e) {
+      } catch (CancelException e) {
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-          
+
-        
+
-    @Override  
+    @Override
-    
-    @Override  
+
+    @Override
-    @Override  
+    @Override
-      String cname = getClass().getName().substring(
-          getClass().getPackage().getName().length() + 1);
+      String cname = getClass().getName().substring(getClass().getPackage().getName().length() + 1);
-  public static final class RequestSyncMessage 
-    extends HighPriorityDistributionMessage {
+  public static final class RequestSyncMessage extends HighPriorityDistributionMessage {
-    
+
-     * IDs that destroyed the region or crashed during GII that the GII
-     * recipient got events from that weren't sent to this member
+     * IDs that destroyed the region or crashed during GII that the GII recipient got events from
+     * that weren't sent to this member
-    
-    
-    @Override  
+
+
+    @Override
-        Assert.assertTrue(this.regionPath != null, "Region path is null.");        
-        final DistributedRegion rgn = (DistributedRegion)getGIIRegion(dm, this.regionPath, false);
+        Assert.assertTrue(this.regionPath != null, "Region path is null.");
+        final DistributedRegion rgn = (DistributedRegion) getGIIRegion(dm, this.regionPath, false);
-          for (VersionSource lostSource: this.lostVersionSources) {
+          for (VersionSource lostSource : this.lostVersionSources) {
-              mbr = (InternalDistributedMember)lostSource;
+              mbr = (InternalDistributedMember) lostSource;
-      }
-      catch (RegionDestroyedException e) {
+      } catch (RegionDestroyedException e) {
-      }
-      catch (CancelException e) {
+      } catch (CancelException e) {
-        
+
-    @Override  
+    @Override
-      for (VersionSource id: this.lostVersionSources) {
+      for (VersionSource id : this.lostVersionSources) {
-    @Override  
+    @Override
-      for (int i=0; i<len; i++) {
-        this.lostVersionSources[i] =
-            (persistentIDs? DiskStoreID.readEssentialData(in)
-                          : InternalDistributedMember.readEssentialData(in));
+      for (int i = 0; i < len; i++) {
+        this.lostVersionSources[i] = (persistentIDs ? DiskStoreID.readEssentialData(in)
+            : InternalDistributedMember.readEssentialData(in));
-    
-    @Override  
+
+    @Override
-      String cname = getClass().getName().substring(
-          getClass().getPackage().getName().length() + 1);
+      String cname = getClass().getName().substring(getClass().getPackage().getName().length() + 1);
-    
+
-    
-    /** the series this message belongs to  (0-based) */
+
+    /** the series this message belongs to (0-based) */
-    
+
-    
+
-    
+
-    
+
-     * A map of the final GC versions. This sent with the last GII chunk
-     * to ensure that the GII recipient's GC version matches that of the sender.
+     * A map of the final GC versions. This sent with the last GII chunk to ensure that the GII
+     * recipient's GC version matches that of the sender.
-     * @param entries the data to send back, if null then all the following
-     * parameters are ignored and any future replies from this member will
-     * be ignored, and the streaming of chunks is considered aborted by the
-     * receiver.
+     * @param entries the data to send back, if null then all the following parameters are ignored
+     *        and any future replies from this member will be ignored, and the streaming of chunks
+     *        is considered aborted by the receiver.
-    public static void send(InternalDistributedMember recipient, int processorId, 
-                            ReplyException exception,
-                            DistributionManager dm,
-                            List entries,
-                            int seriesNum, int msgNum, int numSeries, boolean lastInSeries,
-                            int flowControlId, boolean isDeltaGII, RegionVersionHolder holderToSend, 
-                            Map<VersionSource, Long> gcVersions) {
+    public static void send(InternalDistributedMember recipient, int processorId,
+        ReplyException exception, DistributionManager dm, List entries, int seriesNum, int msgNum,
+        int numSeries, boolean lastInSeries, int flowControlId, boolean isDeltaGII,
+        RegionVersionHolder holderToSend, Map<VersionSource, Long> gcVersions) {
-    }        
-    
-    
-    
-    
+    }
+
+
+
-      //We have to do this here, rather than in the reply processor code,
-      //because the reply processor may be null.
+      // We have to do this here, rather than in the reply processor code,
+      // because the reply processor may be null.
-        //TODO we probably should send an abort message to the sender
-        //if we have aborted, but at the very least we need to keep
-        //the permits going.
+        // TODO we probably should send an abort message to the sender
+        // if we have aborted, but at the very least we need to keep
+        // the permits going.
-    @Override  
+    @Override
-    @Override  
+    @Override
-        this.entries = (List)listData;
+        this.entries = (List) listData;
-      this.remoteVersion = InternalDataSerializer
-                        .getVersionForDataStreamOrNull(in);
+      this.remoteVersion = InternalDataSerializer.getVersionForDataStreamOrNull(in);
-      
+
-      if(gcVersionsLength >= 0) {
+      if (gcVersionsLength >= 0) {
-      for(int i =0; i < gcVersionsLength; i++) {
+      for (int i = 0; i < gcVersionsLength; i++) {
-        DataSerializer.writeArrayList(list, out); 
+        DataSerializer.writeArrayList(list, out);
-        DataSerializer.writeArrayList((ArrayList)this.entries, out);
+        DataSerializer.writeArrayList((ArrayList) this.entries, out);
-      if(gcVersions != null) {
-        for(Map.Entry<VersionSource, Long> entry : gcVersions.entrySet()) {
+      if (gcVersions != null) {
+        for (Map.Entry<VersionSource, Long> entry : gcVersions.entrySet()) {
-    
-    @Override  
+
+    @Override
-      String cname = getClass().getName().substring(
-          getClass().getPackage().getName().length() + 1);
+      String cname = getClass().getName().substring(getClass().getPackage().getName().length() + 1);
-      }
-      else {
+      } else {
-    
+
-  
+
-   * Represents a key/value pair returned from a peer as part of an
-   * {@link InitialImageOperation}
+   * Represents a key/value pair returned from a peer as part of an {@link InitialImageOperation}
-     * key for this entry.  Null if "end of chunk" marker entry
+     * key for this entry. Null if "end of chunk" marker entry
-    
+
-     * value of this entry.  Null when invalid or local invalid
+     * value of this entry. Null when invalid or local invalid
-    
+
-     * Defaults to invalid, not serialized, not local invalid.
-     * The "invalid" flag is not used.  When invalid, localInvalid is false
-     * and the values is null.
+     * Defaults to invalid, not serialized, not local invalid. The "invalid" flag is not used. When
+     * invalid, localInvalid is false and the values is null.
-     * if the region has versioning enabled, we need to transfer the version
-     * with the entry
+     * if the region has versioning enabled, we need to transfer the version with the entry
-    
+
-    
+
-    public void fromData(DataInput in) throws IOException,
-        ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      
+
-        RuntimeException ex2 = new IllegalArgumentException(LocalizedStrings.InitialImageOperation_COULD_NOT_CALCULATE_SIZE_OF_OBJECT.toLocalizedString());
+        RuntimeException ex2 = new IllegalArgumentException(
+            LocalizedStrings.InitialImageOperation_COULD_NOT_CALCULATE_SIZE_OF_OBJECT
+                .toLocalizedString());
-    @Override  
+
+    @Override
-  public static class InitialImageVersionedEntryList extends ArrayList<Entry> implements DataSerializableFixedID, Externalizable {
+  public static class InitialImageVersionedEntryList extends ArrayList<Entry>
+      implements DataSerializableFixedID, Externalizable {
-     * if the region has versioning enabled, we need to transfer the version
-     * with the entry
+     * if the region has versioning enabled, we need to transfer the version with the entry
-     * InitialImageOperation.Entry list 
-     *  
+     * InitialImageOperation.Entry list
+     * 
-    //List<Entry> entries;
+    // List<Entry> entries;
-      if (this.isRegionVersioned && versionTag != null) { 
+      if (this.isRegionVersioned && versionTag != null) {
-      // Add entry without version tag in top-level ArrayList. 
+      // Add entry without version tag in top-level ArrayList.
+
-    
+
-     * replace null membership IDs in version tags with the given member ID.
-     * VersionTags received from a server may have null IDs because they were
-     * operations  performed by that server.  We transmit them as nulls to cut
-     * costs, but have to do the swap on the receiving end (in the client)
+     * replace null membership IDs in version tags with the given member ID. VersionTags received
+     * from a server may have null IDs because they were operations performed by that server. We
+     * transmit them as nulls to cut costs, but have to do the swap on the receiving end (in the
+     * client)
+     * 
-      for (VersionTag versionTag: versionTags) {
+      for (VersionTag versionTag : versionTags) {
-       logger.trace(LogMarker.GII_VERSIONED_ENTRY, "serializing {} with flags 0x{}", this, Integer.toHexString(flags));
+        logger.trace(LogMarker.GII_VERSIONED_ENTRY, "serializing {} with flags 0x{}", this,
+            Integer.toHexString(flags));
-      
+
-        for (int i=0; i < super.size(); i++) {
+        for (int i = 0; i < super.size(); i++) {
-        for (VersionTag tag: this.versionTags) {
+        for (VersionTag tag : this.versionTags) {
-    
+
-      final boolean isGiiVersionEntryDebugEnabled = logger.isTraceEnabled(LogMarker.GII_VERSIONED_ENTRY);
-      
+      final boolean isGiiVersionEntryDebugEnabled =
+          logger.isTraceEnabled(LogMarker.GII_VERSIONED_ENTRY);
+
-      boolean persistent= (flags & 0x20) == 0x20;
-      
+      boolean persistent = (flags & 0x20) == 0x20;
+
-            "deserializing a InitialImageVersionedObjectList with flags 0x{}", Integer.toHexString(flags));
+            "deserializing a InitialImageVersionedObjectList with flags 0x{}",
+            Integer.toHexString(flags));
-        int size = (int)InternalDataSerializer.readUnsignedVL(in);
+        int size = (int) InternalDataSerializer.readUnsignedVL(in);
-        for (int i=0; i<size; i++) {
+        for (int i = 0; i < size; i++) {
-        int size = (int)InternalDataSerializer.readUnsignedVL(in);
+        int size = (int) InternalDataSerializer.readUnsignedVL(in);
-        for (int i=0; i<size; i++) {
+        for (int i = 0; i < size; i++) {
-          case FLAG_NULL_TAG:
-            this.versionTags.add(null);
-            break;
-          case FLAG_FULL_TAG:
-            this.versionTags.add(VersionTag.create(persistent, in));
-            break;
-          case FLAG_TAG_WITH_NEW_ID:
-            VersionTag tag = VersionTag.create(persistent, in);
-            ids.add(tag.getMemberID());
-            this.versionTags.add(tag);
-            break;
-          case FLAG_TAG_WITH_NUMBER_ID:
-            tag = VersionTag.create(persistent, in);
-            int idNumber = (int)InternalDataSerializer.readUnsignedVL(in);
-            tag.setMemberID(ids.get(idNumber));
-            this.versionTags.add(tag);
-            break;
+            case FLAG_NULL_TAG:
+              this.versionTags.add(null);
+              break;
+            case FLAG_FULL_TAG:
+              this.versionTags.add(VersionTag.create(persistent, in));
+              break;
+            case FLAG_TAG_WITH_NEW_ID:
+              VersionTag tag = VersionTag.create(persistent, in);
+              ids.add(tag.getMemberID());
+              this.versionTags.add(tag);
+              break;
+            case FLAG_TAG_WITH_NUMBER_ID:
+              tag = VersionTag.create(persistent, in);
+              int idNumber = (int) InternalDataSerializer.readUnsignedVL(in);
+              tag.setMemberID(ids.get(idNumber));
+              this.versionTags.add(tag);
+              break;
-    public void readExternal(ObjectInput in) throws IOException,
-        ClassNotFoundException {
+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
-    }    
+    }
-  /** 
-   * EventStateMessage transmits the cache's memberId:threadId sequence# 
-   * information so that a cache receiving an initial image will know what 
-   * events that image represents. 
-   *  
-   */ 
-  public static class RegionStateMessage extends ReplyMessage { 
-     
-    // event state is processed in-line to ensure it is applied before 
-    // the initial image state is received 
-    @Override   
-    public boolean getInlineProcess() { 
-      return true; 
-    } 
- 
+  /**
+   * EventStateMessage transmits the cache's memberId:threadId sequence# information so that a cache
+   * receiving an initial image will know what events that image represents.
+   * 
+   */
+  public static class RegionStateMessage extends ReplyMessage {
+
+    // event state is processed in-line to ensure it is applied before
+    // the initial image state is received
+    @Override
+    public boolean getInlineProcess() {
+      return true;
+    }
+
-    RegionVersionVector versionVector; 
-     
-    public RegionStateMessage() { 
-    } 
- 
-    private RegionStateMessage(InternalDistributedMember mbr, int processorId, Map eventState, boolean isHARegion) { 
-      setRecipient(mbr); 
-      setProcessorId(processorId); 
+    RegionVersionVector versionVector;
+
+    public RegionStateMessage() {}
+
+    private RegionStateMessage(InternalDistributedMember mbr, int processorId, Map eventState,
+        boolean isHARegion) {
+      setRecipient(mbr);
+      setProcessorId(processorId);
-    } 
-     
-    private RegionStateMessage(InternalDistributedMember mbr, int processorId, RegionVersionVector rvv, boolean isHARegion) { 
-      setRecipient(mbr); 
-      setProcessorId(processorId); 
+    }
+
+    private RegionStateMessage(InternalDistributedMember mbr, int processorId,
+        RegionVersionVector rvv, boolean isHARegion) {
+      setRecipient(mbr);
+      setProcessorId(processorId);
-    } 
-     
-    public static void send(DM dm, InternalDistributedMember dest, int processorId, 
-        Map<? extends DataSerializable, ? extends DataSerializable> eventState, boolean isHARegion) { 
-      RegionStateMessage msg = new RegionStateMessage(dest, processorId, eventState, isHARegion); 
-      dm.putOutgoing(msg); 
-    } 
-     
-    public static void send(DM dm, InternalDistributedMember dest, int processorId, 
-        RegionVersionVector rvv, boolean isHARegion) { 
-      RegionStateMessage msg = new RegionStateMessage(dest, processorId, rvv, isHARegion); 
-      dm.putOutgoing(msg); 
-    } 
-     
-    @Override   
-    public void toData(DataOutput dop) throws IOException { 
+    }
+
+    public static void send(DM dm, InternalDistributedMember dest, int processorId,
+        Map<? extends DataSerializable, ? extends DataSerializable> eventState,
+        boolean isHARegion) {
+      RegionStateMessage msg = new RegionStateMessage(dest, processorId, eventState, isHARegion);
+      dm.putOutgoing(msg);
+    }
+
+    public static void send(DM dm, InternalDistributedMember dest, int processorId,
+        RegionVersionVector rvv, boolean isHARegion) {
+      RegionStateMessage msg = new RegionStateMessage(dest, processorId, rvv, isHARegion);
+      dm.putOutgoing(msg);
+    }
+
+    @Override
+    public void toData(DataOutput dop) throws IOException {
-    } 
-     
+    }
-    @Override   
-    public String toString() { 
-      String descr = super.toString(); 
-      if (eventState != null) { 
-        descr += "; eventCount=" + eventState.size(); 
+
+    @Override
+    public String toString() {
+      String descr = super.toString();
+      if (eventState != null) {
+        descr += "; eventCount=" + eventState.size();
-        descr += "; versionVector=" + (RegionVersionVector.DEBUG? versionVector.fullToString() : versionVector);
+        descr += "; versionVector="
+            + (RegionVersionVector.DEBUG ? versionVector.fullToString() : versionVector);
-      return descr; 
-    } 
-     
-    @Override   
-    public void fromData(DataInput dip) throws IOException, ClassNotFoundException { 
+      return descr;
+    }
+
+    @Override
+    public void fromData(DataInput dip) throws IOException, ClassNotFoundException {
-    } 
-     
-    /* (non-Javadoc) 
-     * @see org.apache.geode.internal.DataSerializableFixedID#getDSFID() 
-     */ 
-    @Override   
-    public int getDSFID() { 
-      return REGION_STATE_MESSAGE; 
-    } 
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.geode.internal.DataSerializableFixedID#getDSFID()
+     */
+    @Override
+    public int getDSFID() {
+      return REGION_STATE_MESSAGE;
+    }
-  
-  /** 
-   * This Message is sent as response to RequestFilterInfo. 
-   * The filters registered by the client owning the HARegion is sent 
-   * as part of this message.
-   */ 
-  public static class FilterInfoMessage extends ReplyMessage { 
-    
+
+  /**
+   * This Message is sent as response to RequestFilterInfo. The filters registered by the client
+   * owning the HARegion is sent as part of this message.
+   */
+  public static class FilterInfoMessage extends ReplyMessage {
+
-    
+
-    
+
-    
+
-    
+
-    
+
-    private final InterestMaps interestMaps[] = new InterestMaps[] {
-        new InterestMaps(), new InterestMaps() };
+    private final InterestMaps interestMaps[] =
+        new InterestMaps[] {new InterestMaps(), new InterestMaps()};
-    
+
-    
+
-        
-    
-    @Override   
-    public boolean getInlineProcess() { 
-      return false; 
-    } 
-    
-    public FilterInfoMessage() { 
-    } 
- 
-    private FilterInfoMessage(InternalDistributedMember mbr, int processorId, LocalRegion haRegion) { 
-      setRecipient(mbr); 
+
+
+    @Override
+    public boolean getInlineProcess() {
+      return false;
+    }
+
+    public FilterInfoMessage() {}
+
+    private FilterInfoMessage(InternalDistributedMember mbr, int processorId,
+        LocalRegion haRegion) {
+      setRecipient(mbr);
-    } 
- 
+    }
+
-      LocalRegion haReg = this.haRegion; 
-       
+      LocalRegion haReg = this.haRegion;
+
-      ClientProxyMembershipID clientID = ((HAContainerWrapper)ccn.getHaContainer()).getProxyID(haReg.getName());
+      ClientProxyMembershipID clientID =
+          ((HAContainerWrapper) ccn.getHaContainer()).getProxyID(haReg.getName());
-      
+
-      
+
-        LocalRegion r = (LocalRegion)cache.getRegion(rName);
+        LocalRegion r = (LocalRegion) cache.getRegion(rName);
-        
+
-        
+
-        
+
-      
+
-            for(ServerCQ cq : cqsList) {
+            for (ServerCQ cq : cqsList) {
-    
+
-        // Check if interested in all keys.          
+        // Check if interested in all keys.
-        
+
-        
+
-    
+
+     * 
-          logger.info("Found null cache client notifier. Failed to register Filters during HARegion GII. Region :{}", region.getName());
+          logger.info(
+              "Found null cache client notifier. Failed to register Filters during HARegion GII. Region :{}",
+              region.getName());
-        proxy = ((HAContainerWrapper)ccn.getHaContainer()).getProxy(
-            region.getName());      
+        proxy = ((HAContainerWrapper) ccn.getHaContainer()).getProxy(region.getName());
-        logger.info("Unable to obtain the client proxy. Failed to register Filters during HARegion GII. Region :{}, {}",
+        logger.info(
+            "Unable to obtain the client proxy. Failed to register Filters during HARegion GII. Region :{}, {}",
-      
+
-        logger.info("Found null client proxy. Failed to register Filters during HARegion GII. Region :{}, HaContainer :{}", region.getName(), ccn.getHaContainer());
+        logger.info(
+            "Found null client proxy. Failed to register Filters during HARegion GII. Region :{}, HaContainer :{}",
+            region.getName(), ccn.getHaContainer());
-      
+
-          CqService cqService = ((DefaultQueryService)(region.getCache().getQueryService()))
-          .getCqService();
+          CqService cqService =
+              ((DefaultQueryService) (region.getCache().getQueryService())).getCqService();
-          for(Map.Entry<String, ServerCQ> e : this.cqs.entrySet()){
+          for (Map.Entry<String, ServerCQ> e : this.cqs.entrySet()) {
-              // found. 
-              cqService.executeCq(e.getKey(), cq.getQueryString(), 
-                  ((CqStateImpl)cq.getState()).getState(), proxy.getProxyID(), 
-                  ccn, cq.isDurable(), true, -1, this.emptyRegionMap);
+              // found.
+              cqService.executeCq(e.getKey(), cq.getQueryString(),
+                  ((CqStateImpl) cq.getState()).getState(), proxy.getProxyID(), ccn, cq.isDurable(),
+                  true, -1, this.emptyRegionMap);
-              logger.info("Failed to register CQ during HARegion GII. CQ: {} {}", e.getKey(), ex.getMessage(), ex);
+              logger.info("Failed to register CQ during HARegion GII. CQ: {} {}", e.getKey(),
+                  ex.getMessage(), ex);
-        } catch (Exception ex){
-          logger.info("Failed to get CqService for CQ registration during HARegion GII. {}", ex.getMessage(), ex);
+        } catch (Exception ex) {
+          logger.info("Failed to get CqService for CQ registration during HARegion GII. {}",
+              ex.getMessage(), ex);
-    
+
-      
-      int mapIndex = durable? DURABLE : NON_DURABLE;
-      
+
+      int mapIndex = durable ? DURABLE : NON_DURABLE;
+
-      } catch (Exception ex){
-        logger.info("Failed to register interest of type keys during HARegion GII. {}", ex.getMessage(), ex);
+      } catch (Exception ex) {
+        logger.info("Failed to register interest of type keys during HARegion GII. {}",
+            ex.getMessage(), ex);
-      
+
-        registerInterestKeys(this.interestMaps[mapIndex].allKeysInv, true, region, ccn, proxy, durable,
-            false, InterestType.REGULAR_EXPRESSION, regionsWithInterest);
-      } catch (Exception ex){
-        logger.info("Failed to register interest of type keys during HARegion GII. {}", ex.getMessage(), ex);
+        registerInterestKeys(this.interestMaps[mapIndex].allKeysInv, true, region, ccn, proxy,
+            durable, false, InterestType.REGULAR_EXPRESSION, regionsWithInterest);
+      } catch (Exception ex) {
+        logger.info("Failed to register interest of type keys during HARegion GII. {}",
+            ex.getMessage(), ex);
-      
+
-        registerInterestKeys(this.interestMaps[mapIndex].keysOfInterest, false, region, ccn, proxy, durable,
-            false, InterestType.KEY, regionsWithInterest);
-      } catch (Exception ex){
-        logger.info("Failed to register interest of type keys during HARegion GII. {}", ex.getMessage(), ex);
+        registerInterestKeys(this.interestMaps[mapIndex].keysOfInterest, false, region, ccn, proxy,
+            durable, false, InterestType.KEY, regionsWithInterest);
+      } catch (Exception ex) {
+        logger.info("Failed to register interest of type keys during HARegion GII. {}",
+            ex.getMessage(), ex);
-        registerInterestKeys(this.interestMaps[mapIndex].keysOfInterestInv, false, region, ccn, proxy, durable,
-            true, InterestType.KEY, regionsWithInterest);      
-      } catch (Exception ex){
-        logger.info("Failed to register interest of type keys for invalidates during HARegion GII. {}", ex.getMessage(), ex);
+        registerInterestKeys(this.interestMaps[mapIndex].keysOfInterestInv, false, region, ccn,
+            proxy, durable, true, InterestType.KEY, regionsWithInterest);
+      } catch (Exception ex) {
+        logger.info(
+            "Failed to register interest of type keys for invalidates during HARegion GII. {}",
+            ex.getMessage(), ex);
-        registerInterestKeys(this.interestMaps[mapIndex].patternsOfInterest, false, region, ccn, proxy, durable,
-            false, InterestType.REGULAR_EXPRESSION, regionsWithInterest);
-      } catch (Exception ex){
-        logger.info("Failed to register interest of type expression during HARegion GII. {}", ex.getMessage(), ex);
+        registerInterestKeys(this.interestMaps[mapIndex].patternsOfInterest, false, region, ccn,
+            proxy, durable, false, InterestType.REGULAR_EXPRESSION, regionsWithInterest);
+      } catch (Exception ex) {
+        logger.info("Failed to register interest of type expression during HARegion GII. {}",
+            ex.getMessage(), ex);
-        registerInterestKeys(this.interestMaps[mapIndex].patternsOfInterestInv, false, region, ccn, proxy, durable,
-            true, InterestType.REGULAR_EXPRESSION, regionsWithInterest);
-      } catch (Exception ex){
-        logger.info("Failed to register interest of type expression for invalidates during HARegion GII. {}", ex.getMessage(), ex);
+        registerInterestKeys(this.interestMaps[mapIndex].patternsOfInterestInv, false, region, ccn,
+            proxy, durable, true, InterestType.REGULAR_EXPRESSION, regionsWithInterest);
+      } catch (Exception ex) {
+        logger.info(
+            "Failed to register interest of type expression for invalidates during HARegion GII. {}",
+            ex.getMessage(), ex);
-        registerInterestKeys(this.interestMaps[mapIndex].filtersOfInterest, false, region, ccn, proxy, durable,
-            false, InterestType.FILTER_CLASS, regionsWithInterest);
-      } catch (Exception ex){
-        logger.info("Failed to register interest of type filter during HARegion GII. {}", ex.getMessage(), ex);
+        registerInterestKeys(this.interestMaps[mapIndex].filtersOfInterest, false, region, ccn,
+            proxy, durable, false, InterestType.FILTER_CLASS, regionsWithInterest);
+      } catch (Exception ex) {
+        logger.info("Failed to register interest of type filter during HARegion GII. {}",
+            ex.getMessage(), ex);
-      try {      
-        registerInterestKeys(this.interestMaps[mapIndex].filtersOfInterestInv, false, region, ccn, proxy, durable,
-            true, InterestType.FILTER_CLASS, regionsWithInterest);
-      } catch (Exception ex){
-        logger.info("Failed to register interest of type filter for invalidates during HARegion GII. {}", ex.getMessage(), ex);
+      try {
+        registerInterestKeys(this.interestMaps[mapIndex].filtersOfInterestInv, false, region, ccn,
+            proxy, durable, true, InterestType.FILTER_CLASS, regionsWithInterest);
+      } catch (Exception ex) {
+        logger.info(
+            "Failed to register interest of type filter for invalidates during HARegion GII. {}",
+            ex.getMessage(), ex);
-      
+
-       * now that interest is in place we need to flush operations to the
-       * image provider
+       * now that interest is in place we need to flush operations to the image provider
-      for (String regionName: regionsWithInterest) {
+      for (String regionName : regionsWithInterest) {
-    private void registerInterestKeys(Map regionKeys, boolean allKey, 
-        LocalRegion region, CacheClientNotifier ccn, CacheClientProxy proxy,
-        boolean isDurable,
-        boolean updatesAsInvalidates, int interestType, Set<String>regionsWithInterest) throws IOException {
-      
+    private void registerInterestKeys(Map regionKeys, boolean allKey, LocalRegion region,
+        CacheClientNotifier ccn, CacheClientProxy proxy, boolean isDurable,
+        boolean updatesAsInvalidates, int interestType, Set<String> regionsWithInterest)
+        throws IOException {
+
-     
+
-          Map.Entry e = (Map.Entry)iter.next();
-          String regionName = (String)e.getKey();     
+          Map.Entry e = (Map.Entry) iter.next();
+          String regionName = (String) e.getKey();
-              ccn.registerClientInterest(regionName, e.getValue(), 
-                proxy.getProxyID(), interestType, isDurable, updatesAsInvalidates, 
-                manageEmptyRegions, 0, false);       
+              ccn.registerClientInterest(regionName, e.getValue(), proxy.getProxyID(), interestType,
+                  isDurable, updatesAsInvalidates, manageEmptyRegions, 0, false);
-                ccn.registerClientInterest(regionName, (String) i.next(), 
-                    proxy.getProxyID(), interestType, isDurable, updatesAsInvalidates, 
-                    manageEmptyRegions, 0, false);       
+                ccn.registerClientInterest(regionName, (String) i.next(), proxy.getProxyID(),
+                    interestType, isDurable, updatesAsInvalidates, manageEmptyRegions, 0, false);
-              ccn.registerClientInterest(regionName,  new ArrayList((Set)e.getValue()), 
-                proxy.getProxyID(), isDurable, updatesAsInvalidates, 
-                manageEmptyRegions, interestType, false);
+              ccn.registerClientInterest(regionName, new ArrayList((Set) e.getValue()),
+                  proxy.getProxyID(), isDurable, updatesAsInvalidates, manageEmptyRegions,
+                  interestType, false);
-    public static void send(DM dm, InternalDistributedMember dest, int processorId, 
-        LocalRegion rgn, ReplyException ex) { 
+    public static void send(DM dm, InternalDistributedMember dest, int processorId, LocalRegion rgn,
+        ReplyException ex) {
-      dm.putOutgoing(msg); 
-    } 
-     
-    @Override   
-    public String toString() { 
-      String descr = super.toString(); 
-      descr +=
-        "; NON_DURABLE allKeys=" + (this.interestMaps[NON_DURABLE].allKeys != null?this.interestMaps[NON_DURABLE].allKeys.size():0) + 
-        "; allKeysInv=" + (this.interestMaps[NON_DURABLE].allKeysInv != null?this.interestMaps[NON_DURABLE].allKeysInv.size():0) +
-        "; keysOfInterest=" + (this.interestMaps[NON_DURABLE].keysOfInterest != null?this.interestMaps[NON_DURABLE].keysOfInterest.size():0) + 
-        "; keysOfInterestInv=" + (this.interestMaps[NON_DURABLE].keysOfInterestInv != null?this.interestMaps[NON_DURABLE].keysOfInterestInv.size():0) + 
-        "; patternsOfInterest=" + (this.interestMaps[NON_DURABLE].patternsOfInterest != null?this.interestMaps[NON_DURABLE].patternsOfInterest.size():0) + 
-        "; patternsOfInterestInv=" + (this.interestMaps[NON_DURABLE].patternsOfInterestInv != null?this.interestMaps[NON_DURABLE].patternsOfInterestInv.size():0) + 
-        "; filtersOfInterest=" + (this.interestMaps[NON_DURABLE].filtersOfInterest != null?this.interestMaps[NON_DURABLE].filtersOfInterest.size():0) + 
-        "; filtersOfInterestInv=" + (this.interestMaps[NON_DURABLE].filtersOfInterestInv != null?this.interestMaps[NON_DURABLE].filtersOfInterestInv.size():0);
-      descr +=
-        "; DURABLE allKeys=" + (this.interestMaps[DURABLE].allKeys != null?this.interestMaps[DURABLE].allKeys.size():0) + 
-        "; allKeysInv=" + (this.interestMaps[DURABLE].allKeysInv != null?this.interestMaps[DURABLE].allKeysInv.size():0) +
-        "; keysOfInterest=" + (this.interestMaps[DURABLE].keysOfInterest != null?this.interestMaps[DURABLE].keysOfInterest.size():0) + 
-        "; keysOfInterestInv=" + (this.interestMaps[DURABLE].keysOfInterestInv != null?this.interestMaps[DURABLE].keysOfInterestInv.size():0) + 
-        "; patternsOfInterest=" + (this.interestMaps[DURABLE].patternsOfInterest != null?this.interestMaps[DURABLE].patternsOfInterest.size():0) + 
-        "; patternsOfInterestInv=" + (this.interestMaps[DURABLE].patternsOfInterestInv != null?this.interestMaps[DURABLE].patternsOfInterestInv.size():0) + 
-        "; filtersOfInterest=" + (this.interestMaps[DURABLE].filtersOfInterest != null?this.interestMaps[DURABLE].filtersOfInterest.size():0) + 
-        "; filtersOfInterestInv=" + (this.interestMaps[DURABLE].filtersOfInterestInv != null?this.interestMaps[DURABLE].filtersOfInterestInv.size():0);
-      descr +=
-        "; cqs=" + (this.cqs != null?this.cqs.size():0); 
-      return descr; 
-    } 
+      dm.putOutgoing(msg);
+    }
+
+    @Override
+    public String toString() {
+      String descr = super.toString();
+      descr += "; NON_DURABLE allKeys="
+          + (this.interestMaps[NON_DURABLE].allKeys != null
+              ? this.interestMaps[NON_DURABLE].allKeys.size() : 0)
+          + "; allKeysInv="
+          + (this.interestMaps[NON_DURABLE].allKeysInv != null
+              ? this.interestMaps[NON_DURABLE].allKeysInv.size() : 0)
+          + "; keysOfInterest="
+          + (this.interestMaps[NON_DURABLE].keysOfInterest != null
+              ? this.interestMaps[NON_DURABLE].keysOfInterest.size() : 0)
+          + "; keysOfInterestInv="
+          + (this.interestMaps[NON_DURABLE].keysOfInterestInv != null
+              ? this.interestMaps[NON_DURABLE].keysOfInterestInv.size() : 0)
+          + "; patternsOfInterest="
+          + (this.interestMaps[NON_DURABLE].patternsOfInterest != null
+              ? this.interestMaps[NON_DURABLE].patternsOfInterest.size() : 0)
+          + "; patternsOfInterestInv="
+          + (this.interestMaps[NON_DURABLE].patternsOfInterestInv != null
+              ? this.interestMaps[NON_DURABLE].patternsOfInterestInv.size() : 0)
+          + "; filtersOfInterest="
+          + (this.interestMaps[NON_DURABLE].filtersOfInterest != null
+              ? this.interestMaps[NON_DURABLE].filtersOfInterest.size() : 0)
+          + "; filtersOfInterestInv=" + (this.interestMaps[NON_DURABLE].filtersOfInterestInv != null
+              ? this.interestMaps[NON_DURABLE].filtersOfInterestInv.size() : 0);
+      descr += "; DURABLE allKeys="
+          + (this.interestMaps[DURABLE].allKeys != null ? this.interestMaps[DURABLE].allKeys.size()
+              : 0)
+          + "; allKeysInv="
+          + (this.interestMaps[DURABLE].allKeysInv != null
+              ? this.interestMaps[DURABLE].allKeysInv.size() : 0)
+          + "; keysOfInterest="
+          + (this.interestMaps[DURABLE].keysOfInterest != null
+              ? this.interestMaps[DURABLE].keysOfInterest.size() : 0)
+          + "; keysOfInterestInv="
+          + (this.interestMaps[DURABLE].keysOfInterestInv != null
+              ? this.interestMaps[DURABLE].keysOfInterestInv.size() : 0)
+          + "; patternsOfInterest="
+          + (this.interestMaps[DURABLE].patternsOfInterest != null
+              ? this.interestMaps[DURABLE].patternsOfInterest.size() : 0)
+          + "; patternsOfInterestInv="
+          + (this.interestMaps[DURABLE].patternsOfInterestInv != null
+              ? this.interestMaps[DURABLE].patternsOfInterestInv.size() : 0)
+          + "; filtersOfInterest="
+          + (this.interestMaps[DURABLE].filtersOfInterest != null
+              ? this.interestMaps[DURABLE].filtersOfInterest.size() : 0)
+          + "; filtersOfInterestInv=" + (this.interestMaps[DURABLE].filtersOfInterestInv != null
+              ? this.interestMaps[DURABLE].filtersOfInterestInv.size() : 0);
+      descr += "; cqs=" + (this.cqs != null ? this.cqs.size() : 0);
+      return descr;
+    }
-      if (this.interestMaps[NON_DURABLE].keysOfInterest != null || this.interestMaps[NON_DURABLE].keysOfInterestInv != null || 
-          this.interestMaps[NON_DURABLE].patternsOfInterest != null || this.interestMaps[NON_DURABLE].patternsOfInterestInv != null || 
-          this.interestMaps[NON_DURABLE].filtersOfInterest != null || this.interestMaps[NON_DURABLE].filtersOfInterestInv != null || 
-          this.interestMaps[DURABLE].patternsOfInterest != null || this.interestMaps[DURABLE].patternsOfInterestInv != null || 
-          this.interestMaps[DURABLE].filtersOfInterest != null || this.interestMaps[DURABLE].filtersOfInterestInv != null ||
-          this.cqs != null) {
+      if (this.interestMaps[NON_DURABLE].keysOfInterest != null
+          || this.interestMaps[NON_DURABLE].keysOfInterestInv != null
+          || this.interestMaps[NON_DURABLE].patternsOfInterest != null
+          || this.interestMaps[NON_DURABLE].patternsOfInterestInv != null
+          || this.interestMaps[NON_DURABLE].filtersOfInterest != null
+          || this.interestMaps[NON_DURABLE].filtersOfInterestInv != null
+          || this.interestMaps[DURABLE].patternsOfInterest != null
+          || this.interestMaps[DURABLE].patternsOfInterestInv != null
+          || this.interestMaps[DURABLE].filtersOfInterest != null
+          || this.interestMaps[DURABLE].filtersOfInterestInv != null || this.cqs != null) {
-      } 
-      return true; 
-    } 
+      }
+      return true;
+    }
-    @Override   
-    public void toData(DataOutput dop) throws IOException { 
-      super.toData(dop); 
-      //DataSerializer.writeString(this.haRegion.getName(), dop);
-      DataSerializer.writeHashMap((HashMap)this.emptyRegionMap, dop);
+    @Override
+    public void toData(DataOutput dop) throws IOException {
+      super.toData(dop);
+      // DataSerializer.writeString(this.haRegion.getName(), dop);
+      DataSerializer.writeHashMap((HashMap) this.emptyRegionMap, dop);
-      DataSerializer.writeHashMap((HashMap)this.interestMaps[NON_DURABLE].allKeys, dop);
-      DataSerializer.writeHashMap((HashMap)this.interestMaps[NON_DURABLE].allKeysInv, dop);
-      DataSerializer.writeHashMap((HashMap)this.interestMaps[NON_DURABLE].keysOfInterest, dop);
-      DataSerializer.writeHashMap((HashMap)this.interestMaps[NON_DURABLE].keysOfInterestInv, dop);
-      DataSerializer.writeHashMap((HashMap)this.interestMaps[NON_DURABLE].patternsOfInterest, dop);
-      DataSerializer.writeHashMap((HashMap)this.interestMaps[NON_DURABLE].patternsOfInterestInv, dop);
-      DataSerializer.writeHashMap((HashMap)this.interestMaps[NON_DURABLE].filtersOfInterest, dop);
-      DataSerializer.writeHashMap((HashMap)this.interestMaps[NON_DURABLE].filtersOfInterestInv, dop);
+      DataSerializer.writeHashMap((HashMap) this.interestMaps[NON_DURABLE].allKeys, dop);
+      DataSerializer.writeHashMap((HashMap) this.interestMaps[NON_DURABLE].allKeysInv, dop);
+      DataSerializer.writeHashMap((HashMap) this.interestMaps[NON_DURABLE].keysOfInterest, dop);
+      DataSerializer.writeHashMap((HashMap) this.interestMaps[NON_DURABLE].keysOfInterestInv, dop);
+      DataSerializer.writeHashMap((HashMap) this.interestMaps[NON_DURABLE].patternsOfInterest, dop);
+      DataSerializer.writeHashMap((HashMap) this.interestMaps[NON_DURABLE].patternsOfInterestInv,
+          dop);
+      DataSerializer.writeHashMap((HashMap) this.interestMaps[NON_DURABLE].filtersOfInterest, dop);
+      DataSerializer.writeHashMap((HashMap) this.interestMaps[NON_DURABLE].filtersOfInterestInv,
+          dop);
-      DataSerializer.writeHashMap((HashMap)this.interestMaps[DURABLE].allKeys, dop);
-      DataSerializer.writeHashMap((HashMap)this.interestMaps[DURABLE].allKeysInv, dop);
-      DataSerializer.writeHashMap((HashMap)this.interestMaps[DURABLE].keysOfInterest, dop);
-      DataSerializer.writeHashMap((HashMap)this.interestMaps[DURABLE].keysOfInterestInv, dop);
-      DataSerializer.writeHashMap((HashMap)this.interestMaps[DURABLE].patternsOfInterest, dop);
-      DataSerializer.writeHashMap((HashMap)this.interestMaps[DURABLE].patternsOfInterestInv, dop);
-      DataSerializer.writeHashMap((HashMap)this.interestMaps[DURABLE].filtersOfInterest, dop);
-      DataSerializer.writeHashMap((HashMap)this.interestMaps[DURABLE].filtersOfInterestInv, dop);
-      
+      DataSerializer.writeHashMap((HashMap) this.interestMaps[DURABLE].allKeys, dop);
+      DataSerializer.writeHashMap((HashMap) this.interestMaps[DURABLE].allKeysInv, dop);
+      DataSerializer.writeHashMap((HashMap) this.interestMaps[DURABLE].keysOfInterest, dop);
+      DataSerializer.writeHashMap((HashMap) this.interestMaps[DURABLE].keysOfInterestInv, dop);
+      DataSerializer.writeHashMap((HashMap) this.interestMaps[DURABLE].patternsOfInterest, dop);
+      DataSerializer.writeHashMap((HashMap) this.interestMaps[DURABLE].patternsOfInterestInv, dop);
+      DataSerializer.writeHashMap((HashMap) this.interestMaps[DURABLE].filtersOfInterest, dop);
+      DataSerializer.writeHashMap((HashMap) this.interestMaps[DURABLE].filtersOfInterestInv, dop);
+
-      DataSerializer.writeHashMap((HashMap)this.cqs, dop);
-    } 
-          
-    @Override   
-    public void fromData(DataInput dip) throws IOException, ClassNotFoundException { 
-      super.fromData(dip); 
-      //String regionName = DataSerializer.readString(dip);
+      DataSerializer.writeHashMap((HashMap) this.cqs, dop);
+    }
+
+    @Override
+    public void fromData(DataInput dip) throws IOException, ClassNotFoundException {
+      super.fromData(dip);
+      // String regionName = DataSerializer.readString(dip);
-      this.interestMaps[NON_DURABLE].keysOfInterestInv = DataSerializer.readHashMap(dip); 
+      this.interestMaps[NON_DURABLE].keysOfInterestInv = DataSerializer.readHashMap(dip);
-      this.interestMaps[NON_DURABLE].filtersOfInterestInv = DataSerializer.readHashMap(dip);  
+      this.interestMaps[NON_DURABLE].filtersOfInterestInv = DataSerializer.readHashMap(dip);
-      this.interestMaps[DURABLE].keysOfInterestInv = DataSerializer.readHashMap(dip); 
+      this.interestMaps[DURABLE].keysOfInterestInv = DataSerializer.readHashMap(dip);
-      this.interestMaps[DURABLE].filtersOfInterestInv = DataSerializer.readHashMap(dip);  
+      this.interestMaps[DURABLE].filtersOfInterestInv = DataSerializer.readHashMap(dip);
-    } 
-          
-    /* (non-Javadoc) 
-     * @see org.apache.geode.internal.DataSerializableFixedID#getDSFID() 
-     */ 
-    @Override   
-    public int getDSFID() { 
-      return FILTER_INFO_MESSAGE; 
-    } 
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.geode.internal.DataSerializableFixedID#getDSFID()
+     */
+    @Override
+    public int getDSFID() {
+      return FILTER_INFO_MESSAGE;
+    }
+
-    
+
-    
+
-      return type+":"+region_name+":"+isRunning;
+      return type + ":" + region_name + ":" + isRunning;
-    
+
-    
+
-    
+
-  public static final boolean TRACE_GII = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "GetInitialImage.TRACE_GII");
-  public static boolean FORCE_FULL_GII = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "GetInitialImage.FORCE_FULL_GII");
+  public static final boolean TRACE_GII =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "GetInitialImage.TRACE_GII");
+  public static boolean FORCE_FULL_GII =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "GetInitialImage.FORCE_FULL_GII");
-  
+
-  
-  // internal test hooks at provider 
+
+  // internal test hooks at provider
-    BeforeGetInitialImage,
-    BeforeRequestRVV,
-    AfterRequestRVV,
-    AfterCalculatedUnfinishedOps,
-    BeforeSavedReceivedRVV,
-    AfterSavedReceivedRVV,
-    AfterSentRequestImage,
-    
-    AfterReceivedRequestImage,
-    DuringPackingImage,
-    AfterSentImageReply,
-    
-    AfterReceivedImageReply,
-    DuringApplyDelta,
-    BeforeCleanExpiredTombstones,
-    AfterSavedRVVEnd
+    BeforeGetInitialImage, BeforeRequestRVV, AfterRequestRVV, AfterCalculatedUnfinishedOps, BeforeSavedReceivedRVV, AfterSavedReceivedRVV, AfterSentRequestImage,
+
+    AfterReceivedRequestImage, DuringPackingImage, AfterSentImageReply,
+
+    AfterReceivedImageReply, DuringApplyDelta, BeforeCleanExpiredTombstones, AfterSavedRVVEnd
-  
+
-    case BeforeGetInitialImage: // 0
-      return internalBeforeGetInitialImage;
-    case BeforeRequestRVV: // 1
-      return internalBeforeRequestRVV;
-    case AfterRequestRVV: // 2
-      return internalAfterRequestRVV;
-    case AfterCalculatedUnfinishedOps: // 3
-      return internalAfterCalculatedUnfinishedOps;
-    case BeforeSavedReceivedRVV: // 4
-      return internalBeforeSavedReceivedRVV;
-    case AfterSavedReceivedRVV: // 5
-      return internalAfterSavedReceivedRVV;
-    case AfterSentRequestImage: // 6
-      return internalAfterSentRequestImage;
+      case BeforeGetInitialImage: // 0
+        return internalBeforeGetInitialImage;
+      case BeforeRequestRVV: // 1
+        return internalBeforeRequestRVV;
+      case AfterRequestRVV: // 2
+        return internalAfterRequestRVV;
+      case AfterCalculatedUnfinishedOps: // 3
+        return internalAfterCalculatedUnfinishedOps;
+      case BeforeSavedReceivedRVV: // 4
+        return internalBeforeSavedReceivedRVV;
+      case AfterSavedReceivedRVV: // 5
+        return internalAfterSavedReceivedRVV;
+      case AfterSentRequestImage: // 6
+        return internalAfterSentRequestImage;
-    case AfterReceivedRequestImage: // 7
-      return internalAfterReceivedRequestImage;
-    case DuringPackingImage: // 8
-      return internalDuringPackingImage;
-    case AfterSentImageReply: // 9
-      return internalAfterSentImageReply;
+      case AfterReceivedRequestImage: // 7
+        return internalAfterReceivedRequestImage;
+      case DuringPackingImage: // 8
+        return internalDuringPackingImage;
+      case AfterSentImageReply: // 9
+        return internalAfterSentImageReply;
-    case AfterReceivedImageReply: // 10
-      return internalAfterReceivedImageReply;
-    case DuringApplyDelta: // 11
-      return internalDuringApplyDelta;
-    case BeforeCleanExpiredTombstones: // 12
-      return internalBeforeCleanExpiredTombstones;
-    case AfterSavedRVVEnd: // 13
-      return internalAfterSavedRVVEnd;
-    default:
-      throw new RuntimeException("Illegal test hook type");
+      case AfterReceivedImageReply: // 10
+        return internalAfterReceivedImageReply;
+      case DuringApplyDelta: // 11
+        return internalDuringApplyDelta;
+      case BeforeCleanExpiredTombstones: // 12
+        return internalBeforeCleanExpiredTombstones;
+      case AfterSavedRVVEnd: // 13
+        return internalAfterSavedRVVEnd;
+      default:
+        throw new RuntimeException("Illegal test hook type");
-    case BeforeGetInitialImage: // 0
-      assert internalBeforeGetInitialImage == null;
-      internalBeforeGetInitialImage = callback;
-      break;
-    case BeforeRequestRVV: // 1
-      assert internalBeforeRequestRVV == null;
-      internalBeforeRequestRVV = callback;
-      break;
-    case AfterRequestRVV: // 2
-      assert internalAfterRequestRVV == null;
-      internalAfterRequestRVV = callback;
-      break;
-    case AfterCalculatedUnfinishedOps: // 3
-      assert internalAfterCalculatedUnfinishedOps == null;
-      internalAfterCalculatedUnfinishedOps = callback;
-      break;
-    case BeforeSavedReceivedRVV: // 4
-      assert internalBeforeSavedReceivedRVV == null;
-      internalBeforeSavedReceivedRVV = callback;
-      break;
-    case AfterSavedReceivedRVV: // 5
-      internalAfterSavedReceivedRVV = callback;
-      break;
-    case AfterSentRequestImage: // 6
-      internalAfterSentRequestImage = callback;
-      break;
+      case BeforeGetInitialImage: // 0
+        assert internalBeforeGetInitialImage == null;
+        internalBeforeGetInitialImage = callback;
+        break;
+      case BeforeRequestRVV: // 1
+        assert internalBeforeRequestRVV == null;
+        internalBeforeRequestRVV = callback;
+        break;
+      case AfterRequestRVV: // 2
+        assert internalAfterRequestRVV == null;
+        internalAfterRequestRVV = callback;
+        break;
+      case AfterCalculatedUnfinishedOps: // 3
+        assert internalAfterCalculatedUnfinishedOps == null;
+        internalAfterCalculatedUnfinishedOps = callback;
+        break;
+      case BeforeSavedReceivedRVV: // 4
+        assert internalBeforeSavedReceivedRVV == null;
+        internalBeforeSavedReceivedRVV = callback;
+        break;
+      case AfterSavedReceivedRVV: // 5
+        internalAfterSavedReceivedRVV = callback;
+        break;
+      case AfterSentRequestImage: // 6
+        internalAfterSentRequestImage = callback;
+        break;
-    case AfterReceivedRequestImage: // 7
-      assert internalAfterReceivedRequestImage == null;
-      internalAfterReceivedRequestImage = callback;
-      break;
-    case DuringPackingImage: // 8
-      assert internalDuringPackingImage == null;
-      internalDuringPackingImage = callback;
-      break;
-    case AfterSentImageReply: // 9
-      assert internalAfterSentImageReply == null;
-      internalAfterSentImageReply = callback;
-      break;
+      case AfterReceivedRequestImage: // 7
+        assert internalAfterReceivedRequestImage == null;
+        internalAfterReceivedRequestImage = callback;
+        break;
+      case DuringPackingImage: // 8
+        assert internalDuringPackingImage == null;
+        internalDuringPackingImage = callback;
+        break;
+      case AfterSentImageReply: // 9
+        assert internalAfterSentImageReply == null;
+        internalAfterSentImageReply = callback;
+        break;
-    case AfterReceivedImageReply: // 10
-      assert internalAfterReceivedImageReply == null;
-      internalAfterReceivedImageReply = callback;
-      break;
-    case DuringApplyDelta: // 11
-      assert internalDuringApplyDelta == null;
-      internalDuringApplyDelta = callback;
-      break;
-    case BeforeCleanExpiredTombstones: // 12
-      assert internalBeforeCleanExpiredTombstones == null;
-      internalBeforeCleanExpiredTombstones = callback;
-      break;
-    case AfterSavedRVVEnd: // 13
-      assert internalAfterSavedRVVEnd == null;
-      internalAfterSavedRVVEnd = callback;
-      break;
-    default:
-      throw new RuntimeException("Illegal test hook type");
+      case AfterReceivedImageReply: // 10
+        assert internalAfterReceivedImageReply == null;
+        internalAfterReceivedImageReply = callback;
+        break;
+      case DuringApplyDelta: // 11
+        assert internalDuringApplyDelta == null;
+        internalDuringApplyDelta = callback;
+        break;
+      case BeforeCleanExpiredTombstones: // 12
+        assert internalBeforeCleanExpiredTombstones == null;
+        internalBeforeCleanExpiredTombstones = callback;
+        break;
+      case AfterSavedRVVEnd: // 13
+        assert internalAfterSavedRVVEnd == null;
+        internalAfterSavedRVVEnd = callback;
+        break;
+      default:
+        throw new RuntimeException("Illegal test hook type");
-    case BeforeGetInitialImage: // 0
-      if (internalBeforeGetInitialImage != null) {
-        internalBeforeGetInitialImage.reset();
-        if (setNull) {
-          internalBeforeGetInitialImage = null;
+      case BeforeGetInitialImage: // 0
+        if (internalBeforeGetInitialImage != null) {
+          internalBeforeGetInitialImage.reset();
+          if (setNull) {
+            internalBeforeGetInitialImage = null;
+          }
-      }
-      break;
-    case BeforeRequestRVV: // 1
-      if (internalBeforeRequestRVV != null) {
-        internalBeforeRequestRVV.reset();
-        if (setNull) {
-          internalBeforeRequestRVV = null;
+        break;
+      case BeforeRequestRVV: // 1
+        if (internalBeforeRequestRVV != null) {
+          internalBeforeRequestRVV.reset();
+          if (setNull) {
+            internalBeforeRequestRVV = null;
+          }
-      }
-      break;
-    case AfterRequestRVV: // 2
-      if (internalAfterRequestRVV != null) {
-        internalAfterRequestRVV.reset();
-        if (setNull) {
-          internalAfterRequestRVV = null;
+        break;
+      case AfterRequestRVV: // 2
+        if (internalAfterRequestRVV != null) {
+          internalAfterRequestRVV.reset();
+          if (setNull) {
+            internalAfterRequestRVV = null;
+          }
-      }
-      break;
-    case AfterCalculatedUnfinishedOps: // 3
-      if (internalAfterCalculatedUnfinishedOps != null) {
-        internalAfterCalculatedUnfinishedOps.reset();
-        if (setNull) {
-          internalAfterCalculatedUnfinishedOps = null;
+        break;
+      case AfterCalculatedUnfinishedOps: // 3
+        if (internalAfterCalculatedUnfinishedOps != null) {
+          internalAfterCalculatedUnfinishedOps.reset();
+          if (setNull) {
+            internalAfterCalculatedUnfinishedOps = null;
+          }
-      }
-      break;
-    case BeforeSavedReceivedRVV: // 4
-      if (internalBeforeSavedReceivedRVV != null) {
-        internalBeforeSavedReceivedRVV.reset();
-        if (setNull) {
-          internalBeforeSavedReceivedRVV = null;
+        break;
+      case BeforeSavedReceivedRVV: // 4
+        if (internalBeforeSavedReceivedRVV != null) {
+          internalBeforeSavedReceivedRVV.reset();
+          if (setNull) {
+            internalBeforeSavedReceivedRVV = null;
+          }
-      }
-      break;
-    case AfterSavedReceivedRVV: // 5
-      if (internalAfterSavedReceivedRVV != null) {
-        internalAfterSavedReceivedRVV.reset();
-        if (setNull) {
-          internalAfterSavedReceivedRVV = null;
+        break;
+      case AfterSavedReceivedRVV: // 5
+        if (internalAfterSavedReceivedRVV != null) {
+          internalAfterSavedReceivedRVV.reset();
+          if (setNull) {
+            internalAfterSavedReceivedRVV = null;
+          }
-      }
-      break;
-    case AfterSentRequestImage: // 6
-      if (internalAfterSentRequestImage != null) {
-        internalAfterSentRequestImage.reset();
-        if (setNull) {
-          internalAfterSentRequestImage = null;
+        break;
+      case AfterSentRequestImage: // 6
+        if (internalAfterSentRequestImage != null) {
+          internalAfterSentRequestImage.reset();
+          if (setNull) {
+            internalAfterSentRequestImage = null;
+          }
-      }
-      break;
+        break;
-    case AfterReceivedRequestImage: // 7
-      if (internalAfterReceivedRequestImage != null) {
-        internalAfterReceivedRequestImage.reset();
-        if (setNull) {
-          internalAfterReceivedRequestImage = null;
+      case AfterReceivedRequestImage: // 7
+        if (internalAfterReceivedRequestImage != null) {
+          internalAfterReceivedRequestImage.reset();
+          if (setNull) {
+            internalAfterReceivedRequestImage = null;
+          }
-      }
-      break;
-    case DuringPackingImage: // 8
-      if (internalDuringPackingImage != null) {
-        internalDuringPackingImage.reset();
-        if (setNull) {
-          internalDuringPackingImage = null;
+        break;
+      case DuringPackingImage: // 8
+        if (internalDuringPackingImage != null) {
+          internalDuringPackingImage.reset();
+          if (setNull) {
+            internalDuringPackingImage = null;
+          }
-      }
-      break;
-    case AfterSentImageReply: // 9
-      if (internalAfterSentImageReply != null) {
-        internalAfterSentImageReply.reset();
-        if (setNull) {
-          internalAfterSentImageReply = null;
+        break;
+      case AfterSentImageReply: // 9
+        if (internalAfterSentImageReply != null) {
+          internalAfterSentImageReply.reset();
+          if (setNull) {
+            internalAfterSentImageReply = null;
+          }
-      }
-      break;
+        break;
-    case AfterReceivedImageReply: // 10
-      if (internalAfterReceivedImageReply != null) {
-        internalAfterReceivedImageReply.reset();
-        if (setNull) {
-          internalAfterReceivedImageReply = null;
+      case AfterReceivedImageReply: // 10
+        if (internalAfterReceivedImageReply != null) {
+          internalAfterReceivedImageReply.reset();
+          if (setNull) {
+            internalAfterReceivedImageReply = null;
+          }
-      }
-      break;
-    case DuringApplyDelta: // 11
-      if (internalDuringApplyDelta != null) {
-        internalDuringApplyDelta.reset();
-        if (setNull) {
-          internalDuringApplyDelta = null;
+        break;
+      case DuringApplyDelta: // 11
+        if (internalDuringApplyDelta != null) {
+          internalDuringApplyDelta.reset();
+          if (setNull) {
+            internalDuringApplyDelta = null;
+          }
-      }
-      break;
-    case BeforeCleanExpiredTombstones: // 12
-      if (internalBeforeCleanExpiredTombstones != null) {
-        internalBeforeCleanExpiredTombstones.reset();
-        if (setNull) {
-          internalBeforeCleanExpiredTombstones = null;
+        break;
+      case BeforeCleanExpiredTombstones: // 12
+        if (internalBeforeCleanExpiredTombstones != null) {
+          internalBeforeCleanExpiredTombstones.reset();
+          if (setNull) {
+            internalBeforeCleanExpiredTombstones = null;
+          }
-      }
-      break;
-    case AfterSavedRVVEnd: // 13
-      if (internalAfterSavedRVVEnd != null) {
-        internalAfterSavedRVVEnd.reset();
-        if (setNull) {
-          internalAfterSavedRVVEnd = null;
+        break;
+      case AfterSavedRVVEnd: // 13
+        if (internalAfterSavedRVVEnd != null) {
+          internalAfterSavedRVVEnd.reset();
+          if (setNull) {
+            internalAfterSavedRVVEnd = null;
+          }
-      }
-      break;
-    default:
-      throw new RuntimeException("Illegal test hook type");
+        break;
+      default:
+        throw new RuntimeException("Illegal test hook type");

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
GEODE-1994: Overhaul of internal.lang.StringUtils to extend and heavily use commons.lang.StringUtils

*   geode.internal.lang.StringUtils has been deprecated.  In the interim, it has been heavily refactored and extends commons.lang.StringUtils.
*
*   Renamed:
*   --  EMPTY_STRING -> EMPTY (inherited)
*   --  toUpperCase  -> upperCase (inherited)
*   --  toLowerCase  -> lowerCase (inherited)
*   --  padEnding    -> rightPad (inherited)
*
*   Removed:
*   --  EMPTY_STRING_ARRAY; usage replaced with commons.lang.ArrayUtils.EMPTY_STRING_ARRAY
*   --  SPACES
*   --  UTF_8; rare usage replaced with raw string
*   --  concat; usage replaced with commons.lang.join, refactoring as necessary.
*   --  getLettersOnly
*   --  getSpaces
*   --  truncate
*   --  valueOf; usage refactored to use defaultString
*
*   Refactored
*   --  defaultIfBlank: previously relied on varargs and could return null.  Usage refactored to allow inheritance from commons.
*   --  defaultString(s, EMPTY) refactored to use standard signature defaultString(s) for consistency throughout codebase.
*   --  isBlank: usage refactored to resolve discrepancies with commons.lang.isBlank, which is now inherited.
*   --  isEmpty: usage refactored to resolve discrepancies with commons.lang.isEmpty, which is now inherited.
*
*   Code Cleanup:
*   --  Many uses of !isBlank -> isNotBlank
*   --  Changes suggested by Inspections on most touched files.
*   --     Explicit <T> -> <> when type is inferable
*   --     while loops operating on iterators converted to for each loops
*   --     for loops operating on array indices converted to for each loops
*   --  Various string typos corrected.
*   --  isEmpty(s.trim()) -> isBlank(s)
*   --  s.trim().isEmpty() -> isEmpty(s)
*   --  Removed some instances of 'dead' code
*   --  Optimized imports in every touched file
*
*   Qualitative Changes:
*   --  The following functions now throw an error when called with a null string input:
*   --  *  LocatorLauncher.Builder.setMemberName
*   --  *  ServerLauncher.Builder.setMemberName
*   --  *  ServerLauncher.Builder.setHostnameForClients
*   --  (Unit tests added to capture these changes)
*
*   Notes:
*   --  StringUtils.wraps may be inherited from Apache Commons when the dependency is updated.
*   --  AbstractLauncher.getMember has the documented behavior of returning null when both MemberName and ID are blank.  Is this the best behavior for this method?

* this closes #521

+import org.apache.geode.cache.EntryDestroyedException;
+import org.apache.geode.cache.query.NameNotFoundException;
+import org.apache.geode.cache.query.QueryInvocationTargetException;
+import org.apache.geode.cache.query.QueryService;
+import org.apache.geode.cache.query.types.ObjectType;
+import org.apache.geode.internal.cache.Token;
+import org.apache.geode.internal.i18n.LocalizedStrings;
+import org.apache.geode.pdx.JSONFormatter;
+import org.apache.geode.pdx.PdxInstance;
+import org.apache.geode.pdx.PdxSerializationException;
+import org.apache.geode.pdx.internal.FieldNotFoundInPdxVersion;
+import org.apache.geode.pdx.internal.PdxInstanceImpl;
+
-import org.apache.geode.cache.EntryDestroyedException;
-import org.apache.geode.cache.query.NameNotFoundException;
-import org.apache.geode.cache.query.QueryInvocationTargetException;
-import org.apache.geode.cache.query.QueryService;
-import org.apache.geode.cache.query.types.ObjectType;
-import org.apache.geode.internal.cache.Token;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.pdx.PdxInstance;
-import org.apache.geode.pdx.PdxSerializationException;
-import org.apache.geode.pdx.internal.FieldNotFoundInPdxVersion;
-import org.apache.geode.pdx.internal.PdxInstanceImpl;
-import org.apache.geode.pdx.JSONFormatter;
-
-  /* this method is not yet used. Here to support Update statements */
-  // returns either null or UNDEFINED
-  /*
-   * public Object write(Object target, Object newValue) throws PathEvaluationException { if (target
-   * == null) return QueryService.UNDEFINED;
-   * 
-   * 
-   * Class targetType = target.getClass(); Class argType = newValue == null ? null :
-   * newValue.getClass(); Member m = getWriteMember(targetType, argType); if (m == null) throw new
-   * PathEvaluationException(LocalizedStrings.AttributeDescriptor_NO_UPDATE_PATH_MAPPING_FOUND_FOR_0
-   * .toLocalizedString(_name)); try { if (m instanceof Method) { try { ((Method)m).invoke(target,
-   * new Object[] { newValue }); return null; } catch (InvocationTargetException e) { throw new
-   * PathEvaluationException(e.getTargetException()); } } else { ((Field)m).set(target, newValue);
-   * return null; } } catch (IllegalAccessException e) { throw new PathEvaluationException(e)); }
-   * 
-   * }
-   */
-
-
-  /*
-   * Not yet used, Here to support Update statements private Member getWriteMember(Class targetType,
-   * Class argType) { // mapping: public field (same name), method (setAttribute(val)), // method
-   * attribute(val) Member m; m = getWriteField(targetType, argType); if (m != null) return m;
-   * return getWriteMethod(targetType, argType); }
-   */
-
-
-  /*
-   * not yet used private Field getWriteField(Class targetType, Class argType) { try { return
-   * targetType.getField(_name); } catch (NoSuchFieldException e) { return null; } }
-   */
-
-  /*
-   * not yet used private Method getWriteMethod(Class targetType, Class argType) { Method m; String
-   * beanMethod = "set" + _name.substring(0,1).toUpperCase() + _name.substring(1); m =
-   * getWriteMethod(targetType, argType, beanMethod); if (m != null) return m; return
-   * getWriteMethod(targetType, argType, _name); }
-   */
-  /*
-   * not yet used private Method getWriteMethod(Class targetType, Class argType, String methodName)
-   * { try { // @todo look up maximally specific method based on argType return
-   * targetType.getMethod(methodName, new Class[] { argType }); } catch (NoSuchMethodException e) {
-   * return null; } }
-   */

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26
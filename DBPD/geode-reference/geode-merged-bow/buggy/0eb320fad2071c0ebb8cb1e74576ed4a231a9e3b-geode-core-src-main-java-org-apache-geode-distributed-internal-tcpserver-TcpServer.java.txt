GEODE-3406: Address PR feedback

* Rename ExecutionContext -> MessageExecutionContext
* Properly close socket when processing ProtoBuf request in TcpServer
* GetAvailableServersRequestHandler guards against `null` servers
* minor style changes

Signed-off-by: Alexander Murmann <amurmann@pivotal.io>

-import org.apache.geode.CancelException;
-import org.apache.geode.DataSerializer;
-import org.apache.geode.SystemFailure;
-import org.apache.geode.distributed.internal.ClusterConfigurationService;
-import org.apache.geode.distributed.internal.DistributionConfig;
-import org.apache.geode.distributed.internal.DistributionConfigImpl;
-import org.apache.geode.distributed.internal.DistributionStats;
-import org.apache.geode.distributed.internal.InternalDistributedSystem;
-import org.apache.geode.distributed.internal.InternalLocator;
-import org.apache.geode.distributed.internal.PoolStatHelper;
-import org.apache.geode.distributed.internal.PooledExecutorWithDMStats;
-import org.apache.geode.internal.DSFIDFactory;
-import org.apache.geode.internal.GemFireVersion;
-import org.apache.geode.internal.Version;
-import org.apache.geode.internal.VersionedDataInputStream;
-import org.apache.geode.internal.VersionedDataOutputStream;
-import org.apache.geode.internal.cache.InternalCache;
-import org.apache.geode.internal.cache.tier.Acceptor;
-import org.apache.geode.internal.cache.tier.sockets.AcceptorImpl;
-import org.apache.geode.internal.cache.tier.sockets.ClientProtocolMessageHandlerLoader;
-import org.apache.geode.internal.cache.tier.sockets.ClientProtocolMessageHandler;
-import org.apache.geode.internal.cache.tier.sockets.ExecutionContext;
-import org.apache.geode.internal.cache.tier.sockets.HandShake;
-import org.apache.geode.internal.logging.LogService;
-import org.apache.geode.internal.net.SocketCreator;
-import org.apache.geode.internal.net.SocketCreatorFactory;
-import org.apache.geode.internal.security.SecurableCommunicationChannel;
-import org.apache.logging.log4j.Logger;
-
+
+import org.apache.logging.log4j.Logger;
+
+import org.apache.geode.CancelException;
+import org.apache.geode.DataSerializer;
+import org.apache.geode.SystemFailure;
+import org.apache.geode.distributed.internal.ClusterConfigurationService;
+import org.apache.geode.distributed.internal.DistributionConfig;
+import org.apache.geode.distributed.internal.DistributionConfigImpl;
+import org.apache.geode.distributed.internal.DistributionStats;
+import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.distributed.internal.InternalLocator;
+import org.apache.geode.distributed.internal.PoolStatHelper;
+import org.apache.geode.distributed.internal.PooledExecutorWithDMStats;
+import org.apache.geode.internal.DSFIDFactory;
+import org.apache.geode.internal.GemFireVersion;
+import org.apache.geode.internal.Version;
+import org.apache.geode.internal.VersionedDataInputStream;
+import org.apache.geode.internal.VersionedDataOutputStream;
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.internal.cache.tier.Acceptor;
+import org.apache.geode.internal.cache.tier.sockets.ClientProtocolMessageHandler;
+import org.apache.geode.internal.cache.tier.sockets.HandShake;
+import org.apache.geode.internal.cache.tier.sockets.MessageExecutionContext;
+import org.apache.geode.internal.logging.LogService;
+import org.apache.geode.internal.net.SocketCreator;
+import org.apache.geode.internal.net.SocketCreatorFactory;
+import org.apache.geode.internal.security.SecurableCommunicationChannel;
+
+  /**
+   * For the new client-server protocol, which ignores the usual handshake mechanism.
+   */
+  public static final byte PROTOBUF_CLIENT_SERVER_PROTOCOL = (byte) 110;
+
-  private InternalLocator internalLocator;
+  private final InternalLocator internalLocator;
+  private ClientProtocolMessageHandler messageHandler;
+
-      ThreadGroup threadGroup, String threadName, InternalLocator internalLocator) {
+      ThreadGroup threadGroup, String threadName, InternalLocator internalLocator,
+      ClientProtocolMessageHandler messageHandler) {
+    this.messageHandler = messageHandler;
-          if (input.readUnsignedByte() == AcceptorImpl.PROTOBUF_CLIENT_SERVER_PROTOCOL
+          if (input.readUnsignedByte() == PROTOBUF_CLIENT_SERVER_PROTOCOL
-            ClientProtocolMessageHandler messageHandler = ClientProtocolMessageHandlerLoader.load();
-                new ExecutionContext(internalLocator));
+                new MessageExecutionContext(internalLocator));
+          }
+        } else {
+          if (gossipVersion <= getCurrentGossipVersion()
+              && GOSSIP_TO_GEMFIRE_VERSION_MAP.containsKey(gossipVersion)) {
+            // Create a versioned stream to remember sender's GemFire version
+            versionOrdinal = (short) GOSSIP_TO_GEMFIRE_VERSION_MAP.get(gossipVersion);
+          } else {
+            // Close the socket. We can not accept requests from a newer version
+            rejectUnknownProtocolConnection(socket, gossipVersion);
-        }
-        if (gossipVersion <= getCurrentGossipVersion()
-            && GOSSIP_TO_GEMFIRE_VERSION_MAP.containsKey(gossipVersion)) {
-          // Create a versioned stream to remember sender's GemFire version
-          versionOrdinal = (short) GOSSIP_TO_GEMFIRE_VERSION_MAP.get(gossipVersion);
-        } else {
-          // Close the socket. We can not accept requests from a newer version
-          rejectUnknownProtocolConnection(socket, gossipVersion);
-          return;
-        }
-        if (Version.GFE_71.compareTo(versionOrdinal) <= 0) {
-          // Recent versions of TcpClient will send the version ordinal
-          versionOrdinal = input.readShort();
-        }
-
-        if (log.isDebugEnabled() && versionOrdinal != Version.CURRENT_ORDINAL) {
-          log.debug("Locator reading request from " + socket.getInetAddress() + " with version "
-              + Version.fromOrdinal(versionOrdinal, false));
-        }
-        input = new VersionedDataInputStream(input, Version.fromOrdinal(versionOrdinal, false));
-        request = DataSerializer.readObject(input);
-        if (log.isDebugEnabled()) {
-          log.debug("Locator received request " + request + " from " + socket.getInetAddress());
-        }
-        if (request instanceof ShutdownRequest) {
-          shuttingDown = true;
-          // Don't call shutdown from within the worker thread, see java bug #6576792.
-          // Closing the socket will cause our acceptor thread to shutdown the executor
-          this.serverSocketPortAtClose = srv_sock.getLocalPort();
-          srv_sock.close();
-          response = new ShutdownResponse();
-        } else if (request instanceof InfoRequest) {
-          response = handleInfoRequest(request);
-        } else if (request instanceof VersionRequest) {
-          response = handleVersionRequest(request);
-        } else {
-          response = handler.processRequest(request);
-        }
-
-        handler.endRequest(request, startTime);
-
-        startTime = DistributionStats.getStatTime();
-        if (response != null) {
-          DataOutputStream output = new DataOutputStream(socket.getOutputStream());
-          if (versionOrdinal != Version.CURRENT_ORDINAL) {
-            output =
-                new VersionedDataOutputStream(output, Version.fromOrdinal(versionOrdinal, false));
+          if (Version.GFE_71.compareTo(versionOrdinal) <= 0) {
+            // Recent versions of TcpClient will send the version ordinal
+            versionOrdinal = input.readShort();
-          DataSerializer.writeObject(response, output);
-          output.flush();
+
+          if (log.isDebugEnabled() && versionOrdinal != Version.CURRENT_ORDINAL) {
+            log.debug("Locator reading request from " + socket.getInetAddress() + " with version "
+                + Version.fromOrdinal(versionOrdinal, false));
+          }
+          input = new VersionedDataInputStream(input, Version.fromOrdinal(versionOrdinal, false));
+          request = DataSerializer.readObject(input);
+          if (log.isDebugEnabled()) {
+            log.debug("Locator received request " + request + " from " + socket.getInetAddress());
+          }
+          if (request instanceof ShutdownRequest) {
+            shuttingDown = true;
+            // Don't call shutdown from within the worker thread, see java bug #6576792.
+            // Closing the socket will cause our acceptor thread to shutdown the executor
+            this.serverSocketPortAtClose = srv_sock.getLocalPort();
+            srv_sock.close();
+            response = new ShutdownResponse();
+          } else if (request instanceof InfoRequest) {
+            response = handleInfoRequest(request);
+          } else if (request instanceof VersionRequest) {
+            response = handleVersionRequest(request);
+          } else {
+            response = handler.processRequest(request);
+          }
+
+          handler.endRequest(request, startTime);
+
+          startTime = DistributionStats.getStatTime();
+          if (response != null) {
+            DataOutputStream output = new DataOutputStream(socket.getOutputStream());
+            if (versionOrdinal != Version.CURRENT_ORDINAL) {
+              output =
+                  new VersionedDataOutputStream(output, Version.fromOrdinal(versionOrdinal, false));
+            }
+            DataSerializer.writeObject(response, output);
+            output.flush();
+          }
+
+          handler.endResponse(request, startTime);
-
-        handler.endResponse(request, startTime);
-

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 UPD40 INS23 INS23 INS29 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS43 INS59 INS44 INS65 INS42 INS11 INS42 INS42 MOV43 INS42 INS21 INS66 INS39 INS34 INS7 INS22 INS42 INS52 INS42 INS8 MOV25 MOV25 MOV25 MOV21 MOV21 MOV25 MOV25 MOV21 MOV21 MOV25 MOV21 INS42 UPD43 UPD42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL41
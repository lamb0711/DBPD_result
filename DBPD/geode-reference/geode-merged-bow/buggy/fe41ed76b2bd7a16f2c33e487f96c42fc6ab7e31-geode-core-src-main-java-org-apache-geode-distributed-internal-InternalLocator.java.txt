GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

-import org.apache.geode.cache.Cache;
+import org.apache.geode.internal.cache.InternalCache;
-import org.apache.geode.management.internal.JmxManagerLocatorResponse;
- * Provides the implementation of a distribution <code>Locator</code> as well as internal-only
+ * Provides the implementation of a distribution {@code Locator} as well as internal-only
- * services can be started independently <code> locator = createLocator()
- * locator.startPeerLocation(); locator.startDistributeSystem();
+ * services can be started independently {@code  locator = createLocator();
+ * locator.startPeerLocation(); locator.startDistributeSystem();}
-
-   * How long (in milliseconds) a member that we haven't heard from in a while should live before we
-   * call it dead?
-   */
-  private static final long EXPIRY_MS = 60000; // one minute
-
-  private static final int SHARED_CONFIG_STATUS_TIMEOUT = 10000; // 10 seconds
-
-  /**
-  ///////////////////// Instance Fields //////////////////////
-
-  private Cache myCache;
+  private InternalCache myCache;
-  private LocatorMembershipListener locatorListener;
+  private final LocatorMembershipListener locatorListener;
-  public boolean isSharedConfigurationEnabled() {
+  boolean isSharedConfigurationEnabled() {
-  public boolean loadFromSharedConfigDir() {
+  private boolean loadFromSharedConfigDir() {
-    if (this.sharedConfig != null) {
-      return this.sharedConfig.getStatus() == SharedConfigurationStatus.RUNNING;
-    } else {
-      return false;
-    }
+    return this.sharedConfig != null
+        && this.sharedConfig.getStatus() == SharedConfigurationStatus.RUNNING;
-  ////////////////////// Static Methods /////////////////////
-
+   *
+   * GuardedBy must synchronize on locatorLock
-  private static InternalLocator locator; // must synchronize on locatorLock
+  private static InternalLocator locator;
+
+  // TODO: getLocator() overrides static method of a superclass
+  // TODO: hasLocator() overrides static method of a superclass
-  private static boolean removeLocator(InternalLocator l) {
-    if (l == null) {
+  // TODO: return value of removeLocator is never used
+  private static boolean removeLocator(InternalLocator locator) {
+    if (locator == null) {
-        if (l.equals(locator)) {
-          locator = null;
+        if (locator.equals(InternalLocator.locator)) {
+          InternalLocator.locator = null;
-      String hostnameForClients, java.util.Properties distributedSystemProperties,
-      boolean startDistributedSystem) throws IOException {
+      String hostnameForClients, Properties distributedSystemProperties,
+      boolean startDistributedSystem) {
-      InternalLocator l =
+      InternalLocator locator =
-      locator = l;
-      return l;
+      InternalLocator.locator = locator;
+      return locator;
-  private static void setLocator(InternalLocator l) {
+  private static void setLocator(InternalLocator locator) {
-      if (locator != null && locator != l) {
+      if (InternalLocator.locator != null && InternalLocator.locator != locator) {
-      locator = l;
+      InternalLocator.locator = locator;
-
-   * @throws IOException
-
-   *
-   * @throws IOException
-    InternalLocator slocator = null;
+    InternalLocator newLocator = null;
-      slocator = createLocator(port, logFile, stateFile, logger, securityLogger, bindAddress,
+      newLocator = createLocator(port, logFile, stateFile, logger, securityLogger, bindAddress,
-        slocator.startPeerLocation(startDistributedSystem);
+        newLocator.startPeerLocation(startDistributedSystem);
-            slocator.startDistributedSystem(); // TODO:GEODE-1243: throws Exception if TcpServer
-                                               // still has zero for its locator port
+            // TODO:GEODE-1243: throws Exception if TcpServer still has zero for its locator port
+            newLocator.startDistributedSystem();
-            slocator.stop();
+            newLocator.stop();
-          final InternalDistributedSystem ids = (InternalDistributedSystem) slocator.myDs;
+          final InternalDistributedSystem ids = newLocator.myDs;
-                getLocatorStrings(), slocator.isSharedConfigurationEnabled());
+                getLocatorStrings(), newLocator.isSharedConfigurationEnabled());
-      } catch (LocatorCancelException e) {
-        slocator.stop();
+      } catch (final LocatorCancelException ignored) {
+        newLocator.stop();
-
-          slocator.startServerLocation(sys);
+          newLocator.startServerLocation(sys);
-          slocator.stop();
+          newLocator.stop();
-      slocator.endStartLocator(null);
+      newLocator.endStartLocator(null);
-      return slocator;
+      return newLocator;
-        removeLocator(slocator);
+        removeLocator(newLocator);
-    InternalDistributedSystem ids = (InternalDistributedSystem) internalLocator.myDs;
+    InternalDistributedSystem ids = internalLocator.myDs;
-  /////////////////////// Constructors //////////////////////
-
-   * Creates a new <code>Locator</code> with the given port, log file, logger, and bind address.
+   * Creates a new {@code Locator} with the given port, log file, logger, and bind address.
-      InetAddress bindAddress, String hostnameForClients,
-      java.util.Properties distributedSystemProperties, DistributionConfigImpl cfg,
-      boolean startDistributedSystem) {
+      InetAddress bindAddress, String hostnameForClients, Properties distributedSystemProperties,
+      DistributionConfigImpl cfg, boolean startDistributedSystem) {
+
+    // TODO: the following three assignments are already done in superclass
+
-    env = new Properties();
+    this.env = new Properties();
-      env.setProperty(BIND_ADDRESS, bindAddress.getHostAddress());
+      this.env.setProperty(BIND_ADDRESS, bindAddress.getHostAddress());
-      env.putAll(distributedSystemProperties);
+      this.env.putAll(distributedSystemProperties);
-    env.setProperty(CACHE_XML_FILE, "");
+    this.env.setProperty(CACHE_XML_FILE, "");
-      this.config = new DistributionConfigImpl(env);
+      this.config = new DistributionConfigImpl(this.env);
-      this.config.unsafeSetLogFile(this.logFile); // LOG: this is(was) a hack for when logFile and
-                                                  // config don't match -- if config specifies a
-                                                  // different log-file things will break!
+      // LOG: this is(was) a hack for when logFile and config don't match -- if config specifies a
+      // different log-file things will break!
+      this.config.unsafeSetLogFile(this.logFile);
-      ((LogWriterLogger) logWriter).setLogWriterLevel(this.config.getSecurityLogLevel());
+      logWriter.setLogWriterLevel(this.config.getSecurityLogLevel());
-    if (locatorListener != null) {
+    if (this.locatorListener != null) {
-      // in the
-      // case where we're starting with port = 0.
-      this.locatorListener.setConfig(this.getConfig());
+      // in the case where we're starting with port = 0.
+      this.locatorListener.setConfig(getConfig());
-    stats = new LocatorStats();
+    this.stats = new LocatorStats();
-
-    server = new TcpServer(port, this.bindAddress, null, this.config, this.handler,
+    this.server = new TcpServer(port, this.bindAddress, null, this.config, this.handler,
-
-    server.start();
+    this.server.start();
-    return config;
+    return this.config;
-   * 
+   * <p>
+   * TODO: parameter withDS is never used
+   *
-   * @throws IOException
-  public void startPeerLocation(boolean withDS) throws IOException {
+  void startPeerLocation(boolean withDS) throws IOException {
-      locatorsAreCoordinators = (prop != null && prop.length() > 0);
+      locatorsAreCoordinators = prop != null && !prop.isEmpty();
-    this.locatorImpl =
-        MemberFactory.newLocatorHandler(this.bindAddress, this.stateFile, locatorsProp,
-            locatorsAreCoordinators, networkPartitionDetectionEnabled, stats, securityUDPDHAlgo);
+    this.locatorImpl = MemberFactory.newLocatorHandler(this.bindAddress, this.stateFile,
+        locatorsProp, locatorsAreCoordinators, networkPartitionDetectionEnabled, this.stats,
+        securityUDPDHAlgo);
-    peerLocator = true;
-    if (!server.isAlive()) {
+    this.peerLocator = true;
+    if (!this.server.isAlive()) {
+   * <p>
+   * TODO: parameters peerLocator and serverLocator and b1 are never used
+  @Deprecated
-
-        if (locator.sharedConfig == null) {
+        if (this.locator.sharedConfig == null) {
-          locator.sharedConfig = new ClusterConfigurationService(locator.myCache);
+          this.locator.sharedConfig = new ClusterConfigurationService(locator.myCache);
-        locator.sharedConfig.initSharedConfiguration(locator.loadFromSharedConfigDir());
-        locator.installSharedConfigDistribution();
+        this.locator.sharedConfig.initSharedConfiguration(this.locator.loadFromSharedConfigDir());
+        this.locator.installSharedConfigDistribution();
-      } catch (CancelException e) {
+      } catch (CancelException | LockServiceDestroyedException e) {
-      } catch (LockServiceDestroyedException e) {
-        if (logger.isDebugEnabled()) {
-          logger.debug("Cluster configuration start up was cancelled", e);
-        }
-      } catch (Throwable e) {
+      } catch (Exception e) {
-   * @throws UnknownHostException
-  public void startDistributedSystem() throws UnknownHostException {
+  private void startDistributedSystem() throws UnknownHostException {
-      String thisLocator;
-      {
-        StringBuilder sb = new StringBuilder(100);
-        if (bindAddress != null) {
-          sb.append(bindAddress.getHostAddress());
-        } else {
-          sb.append(SocketCreator.getLocalHost().getHostAddress());
-        }
-        sb.append('[').append(getPort()).append(']');
-        thisLocator = sb.toString();
+
+      StringBuilder sb = new StringBuilder(100);
+      if (this.bindAddress != null) {
+        sb.append(this.bindAddress.getHostAddress());
+      } else {
+        sb.append(SocketCreator.getLocalHost().getHostAddress());
+      sb.append('[').append(getPort()).append(']');
+      String thisLocator = sb.toString();
-      if (peerLocator) {
+      if (this.peerLocator) {
-        if (locatorsProp != null && locatorsProp.trim().length() > 0) {
+        if (locatorsProp != null && !locatorsProp.trim().isEmpty()) {
-            locatorsProp = locatorsProp + "," + thisLocator;
+            locatorsProp = locatorsProp + ',' + thisLocator;
-
-      myDs = (InternalDistributedSystem) DistributedSystem.connect(connectEnv);
+      this.myDs = (InternalDistributedSystem) DistributedSystem.connect(connectEnv);
-      if (peerLocator) {
-        this.locatorImpl.setMembershipManager(myDs.getDM().getMembershipManager());
+      if (this.peerLocator) {
+        this.locatorImpl.setMembershipManager(this.myDs.getDM().getMembershipManager());
-      myDs.addDisconnectListener(new DisconnectListener() {
+      this.myDs.addDisconnectListener(new DisconnectListener() {
-      ((InternalDistributedSystem) myDs).setDependentLocator(this);
+      myDs.setDependentLocator(this);
-
-
-    GemFireCacheImpl gfc = GemFireCacheImpl.getInstance();
-    if (gfc == null) {
+    InternalCache internalCache = GemFireCacheImpl.getInstance();
+    if (internalCache == null) {
-      this.myCache = new CacheFactory(ds.getProperties()).create();
-      gfc = (GemFireCacheImpl) this.myCache;
+      this.myCache = (InternalCache) new CacheFactory(ds.getProperties()).create();
+      internalCache = this.myCache;
-    startJmxManagerLocationService(gfc);
+    startJmxManagerLocationService(internalCache);
-    startSharedConfigurationService(gfc);
+    startSharedConfigurationService(internalCache);
-   * @throws UnknownHostException
-  public void endStartLocator(InternalDistributedSystem distributedSystem)
-      throws UnknownHostException {
-    env = null;
+  void endStartLocator(InternalDistributedSystem distributedSystem) throws UnknownHostException {
+    this.env = null;
-      this.locatorDiscoverer.discover(getPort(), config, locatorListener, hostnameForClients);
+      this.locatorDiscoverer.discover(getPort(), this.config, this.locatorListener,
+          this.hostnameForClients);
-  public void startServerLocation(InternalDistributedSystem distributedSystem) throws IOException {
+  void startServerLocation(InternalDistributedSystem distributedSystem) throws IOException {
-    ServerLocator sl = new ServerLocator(getPort(), this.bindAddress, this.hostnameForClients,
-        this.logFile, this.productUseLog, getConfig().getName(), distributedSystem, stats);
-    this.handler.addHandler(LocatorListRequest.class, sl);
-    this.handler.addHandler(ClientConnectionRequest.class, sl);
-    this.handler.addHandler(QueueConnectionRequest.class, sl);
-    this.handler.addHandler(ClientReplacementRequest.class, sl);
-    this.handler.addHandler(GetAllServersRequest.class, sl);
-    this.handler.addHandler(LocatorStatusRequest.class, sl);
-    this.serverLocator = sl;
-    if (!server.isAlive()) {
+    ServerLocator serverLocator =
+        new ServerLocator(getPort(), this.bindAddress, this.hostnameForClients, this.logFile,
+            this.productUseLog, getConfig().getName(), distributedSystem, this.stats);
+    this.handler.addHandler(LocatorListRequest.class, serverLocator);
+    this.handler.addHandler(ClientConnectionRequest.class, serverLocator);
+    this.handler.addHandler(QueueConnectionRequest.class, serverLocator);
+    this.handler.addHandler(ClientReplacementRequest.class, serverLocator);
+    this.handler.addHandler(GetAllServersRequest.class, serverLocator);
+    this.handler.addHandler(LocatorStatusRequest.class, serverLocator);
+    this.serverLocator = serverLocator;
+    if (!this.server.isAlive()) {
-    // SocketCreatorFactory.close();
-  }
-
-  /**
-   * Was this locator stopped during forced-disconnect processing but should reconnect?
-   */
-  public boolean getStoppedForReconnect() {
-    return this.stoppedForReconnect;
-          } catch (InterruptedException e) {
+          } catch (InterruptedException ignored) {
-    if (stoppedForReconnect) {
+    if (this.stoppedForReconnect) {
-
-    productUseLog.close();
-    if (myDs != null) {
-      ((InternalDistributedSystem) myDs).setDependentLocator(null);
+    this.productUseLog.close();
+    if (this.myDs != null) {
+      this.myDs.setDependentLocator(null);
-        logger.info("Could not close locator's cache because: {}", ex);
+        logger.info("Could not close locator's cache because: {}", ex.getMessage(), ex);
-    if (stats != null) {
-      stats.close();
+    if (this.stats != null) {
+      this.stats.close();
-    if (myDs != null && !this.forcedDisconnect) {
-      if (myDs.isConnected()) {
+    if (this.myDs != null && !this.forcedDisconnect) {
+      if (this.myDs.isConnected()) {
-        myDs.disconnect();
+        this.myDs.disconnect();
-        Thread rs = this.restartThread;
-        if (rs != null) {
+        Thread restartThread = this.restartThread;
+        if (restartThread != null) {
-          rs.join();
+          restartThread.join();
+    // TODO: non-atomic operation on volatile field restartThread
+      @Override
-  public boolean attemptReconnect() throws InterruptedException, IOException {
+  private boolean attemptReconnect() throws InterruptedException, IOException {
-      // LogWriter log = new ManagerLogWriter(LogWriterImpl.FINE_LEVEL, System.out);
-        // log.fine("reconnecting locator: starting location services");
-    logger.info("restart thread exiting.  Service was " + (restarted ? "" : "not ") + "restarted");
+    logger.info("restart thread exiting.  Service was {}restarted", restarted ? "" : "not ");
-
-  private void restartWithDS(InternalDistributedSystem newSystem, GemFireCacheImpl newCache)
+  private void restartWithDS(InternalDistributedSystem newSystem, InternalCache newCache)
-      ((InternalDistributedSystem) myDs).setDependentLocator(this);
+      this.myDs.setDependentLocator(this);
-      endStartLocator((InternalDistributedSystem) myDs);
+      endStartLocator(this.myDs);
-
-  // implementation of abstract method in Locator
-    return myDs;
+    return this.myDs;
-    return peerLocator;
+    return this.peerLocator;
+  @Override
-    if (server != null) {
-      return server.getPort();
+    if (this.server != null) {
+      return this.server.getPort();
-  /******
-   *
-   *
-   */
-    public SharedConfigurationStatusResponse call() throws Exception {
-      SharedConfigurationStatusResponse response;
-
+    @Override
+    public SharedConfigurationStatusResponse call() throws InterruptedException {
+      // TODO: this for-loop is probably not necessary as the if to break is always true
+      SharedConfigurationStatusResponse response;
-
-    ExecutorService es =
-        ((GemFireCacheImpl) myCache).getDistributionManager().getWaitingThreadPool();
+    ExecutorService es = this.myCache.getDistributionManager().getWaitingThreadPool();
-    SharedConfigurationStatusResponse response = null;
+    SharedConfigurationStatusResponse response;
-
-    private volatile HashMap<Class, TcpHandler> handlerMapping = new HashMap<Class, TcpHandler>();
-    private volatile HashSet<TcpHandler> allHandlers = new HashSet<TcpHandler>();
+    private volatile HashMap<Class, TcpHandler> handlerMapping = new HashMap<>();
+    private volatile HashSet<TcpHandler> allHandlers = new HashSet<>();
-    // private final List<LocatorJoinMessage> locatorJoinMessages;
-    private Object locatorJoinObject = new Object();
-    private InternalLocator internalLocator;
+    private final InternalLocator internalLocator;
-    public PrimaryHandler(InternalLocator locator, LocatorMembershipListener listener) {
+    PrimaryHandler(InternalLocator locator, LocatorMembershipListener listener) {
-      internalLocator = locator;
-      // this.locatorJoinMessages = new ArrayList<LocatorJoinMessage>();
+      this.internalLocator = locator;
+    @Override
-        this.locatorListener.setPort(internalLocator.getPort());
+        this.locatorListener.setPort(this.internalLocator.getPort());
-      for (Iterator itr = allHandlers.iterator(); itr.hasNext();) {
-        TcpHandler handler = (TcpHandler) itr.next();
+      for (TcpHandler handler : this.allHandlers) {
+    @Override
+    @Override
-          handler = (TcpHandler) handlerMapping.get(PeerLocatorRequest.class);
+          handler = this.handlerMapping.get(PeerLocatorRequest.class);
-          handler = (TcpHandler) handlerMapping.get(request.getClass());
+          handler = this.handlerMapping.get(request.getClass());
-          if (locatorListener != null) {
-            return locatorListener.handleRequest(request);
+          if (this.locatorListener != null) {
+            return this.locatorListener.handleRequest(request);
-              int locatorWaitTime = internalLocator.getConfig().getLocatorWaitTime();
+              int locatorWaitTime = this.internalLocator.getConfig().getLocatorWaitTime();
-                locatorWaitTime = 30; // always retry some number of times
+                // always retry some number of times
+                locatorWaitTime = 30;
-              hasWaitedForHandlerInitialization = true;
-              giveup = System.currentTimeMillis() + (locatorWaitTime * 1000);
+              this.hasWaitedForHandlerInitialization = true;
+              giveup = System.currentTimeMillis() + locatorWaitTime * 1000;
-              } catch (InterruptedException e) {
+              } catch (InterruptedException ignored) {
-      return hasWaitedForHandlerInitialization;
+      return this.hasWaitedForHandlerInitialization;
-    private JmxManagerLocatorResponse findJmxManager(JmxManagerLocatorRequest request) {
-      JmxManagerLocatorResponse result = null;
-      // NYI
-      return result;
-    }
-
+    @Override
-        for (Iterator itr = allHandlers.iterator(); itr.hasNext();) {
-          TcpHandler handler = (TcpHandler) itr.next();
+        for (TcpHandler handler : this.allHandlers) {
-    public synchronized boolean isHandled(Class clazz) {
+    synchronized boolean isHandled(Class clazz) {
-      HashMap tmpHandlerMapping = new HashMap(handlerMapping);
-      HashSet tmpAllHandlers = new HashSet(allHandlers);
+      HashMap<Class, TcpHandler> tmpHandlerMapping = new HashMap<>(this.handlerMapping);
+      HashSet<TcpHandler> tmpAllHandlers = new HashSet<>(this.allHandlers);
-      if (tmpAllHandlers.add(handler) && tcpServer != null) {
-        handler.init(tcpServer);
+      if (tmpAllHandlers.add(handler) && this.tcpServer != null) {
+        handler.init(this.tcpServer);
-      handlerMapping = tmpHandlerMapping;
-      allHandlers = tmpAllHandlers;
+      this.handlerMapping = tmpHandlerMapping;
+      this.allHandlers = tmpAllHandlers;
+    @Override
-      TcpHandler handler = (TcpHandler) handlerMapping.get(request.getClass());
+      TcpHandler handler = this.handlerMapping.get(request.getClass());
+    @Override
-      TcpHandler handler = (TcpHandler) handlerMapping.get(request.getClass());
+      TcpHandler handler = this.handlerMapping.get(request.getClass());
+  @Override
-      stats.hookupStats(sys, SocketCreator.getLocalHost().getCanonicalHostName() + "-"
-          + server.getBindAddress().toString());
-    } catch (UnknownHostException uhe) {
-      uhe.printStackTrace();
+      this.stats.hookupStats(sys,
+          SocketCreator.getLocalHost().getCanonicalHostName() + '-' + this.server.getBindAddress());
+    } catch (UnknownHostException e) {
+      logger.warn(e);
-    Collection<String> locatorStrings = null;
+    Collection<String> locatorStrings;
-    } catch (UnknownHostException e) {
+    } catch (UnknownHostException ignored) {
-
+    @Override
+    @Override
-  public void startSharedConfigurationService(GemFireCacheImpl gfc) {
-
+  private void startSharedConfigurationService(InternalCache internalCache) {
-      ExecutorService es = gfc.getDistributionManager().getThreadPool();
+      ExecutorService es = internalCache.getDistributionManager().getThreadPool();
-  public void startJmxManagerLocationService(GemFireCacheImpl gfc) {
-    if (gfc.getJmxManagerAdvisor() != null) {
+  public void startJmxManagerLocationService(InternalCache internalCache) {
+    if (internalCache.getJmxManagerAdvisor() != null) {
-        this.handler.addHandler(JmxManagerLocatorRequest.class, new JmxManagerLocator(gfc));
+        this.handler.addHandler(JmxManagerLocatorRequest.class,
+            new JmxManagerLocator(internalCache));
-  /***
+  /**
-  public void installSharedConfigDistribution() {
+  private void installSharedConfigDistribution() {
-  public void installSharedConfigHandler() {
+  private void installSharedConfigHandler() {
-    return (handler.isHandled(messageClass));
+    return this.handler.isHandled(messageClass);

MOV26 UPD40 INS23 UPD43 MOV83 MOV83 MOV43 MOV59 UPD83 MOV8 INS78 UPD83 UPD83 INS78 INS31 INS78 UPD83 UPD83 UPD83 UPD66 INS65 INS66 UPD66 INS65 UPD42 UPD42 UPD43 UPD42 UPD43 INS42 UPD43 INS42 INS78 UPD43 MOV60 MOV59 MOV59 INS83 INS78 INS78 INS78 INS78 MOV83 MOV39 MOV42 MOV8 INS78 INS78 INS42 INS78 INS78 UPD43 UPD42 UPD43 UPD42 INS66 INS66 MOV66 INS27 INS66 INS42 INS66 INS65 UPD66 INS42 INS22 INS66 INS66 INS66 INS66 UPD43 MOV22 UPD42 INS22 INS22 INS42 UPD42 UPD42 UPD42 INS42 INS70 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS32 MOV27 MOV27 UPD42 UPD42 INS40 INS66 INS22 INS22 INS22 INS22 INS22 INS22 INS52 INS42 INS22 MOV60 MOV25 MOV21 INS60 UPD42 UPD42 UPD42 UPD42 UPD42 INS22 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS22 INS22 INS22 INS45 MOV16 INS52 INS42 INS52 INS42 INS22 INS74 INS74 INS44 INS22 INS8 INS22 INS8 MOV74 INS59 MOV74 INS59 MOV44 MOV44 INS22 MOV42 MOV42 UPD42 UPD42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS52 INS42 INS22 MOV43 INS59 INS22 INS22 INS52 INS42 INS22 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS52 INS42 MOV43 MOV43 INS22 INS43 INS42 INS52 INS42 MOV21 INS52 INS42 INS70 INS42 INS14 INS42 INS14 INS22 INS22 MOV32 MOV32 UPD42 UPD42 INS52 INS42 UPD42 INS40 INS40 UPD42 UPD42 INS22 INS22 INS42 INS27 INS52 INS42 INS52 INS42 INS84 UPD43 INS22 INS42 MOV32 INS52 INS42 INS22 INS52 INS42 INS22 INS42 INS11 INS42 MOV22 INS22 INS22 INS22 INS52 INS42 INS52 INS42 INS22 INS22 INS52 INS42 INS22 INS22 INS22 INS22 INS22 INS52 INS42 MOV42 INS44 INS22 INS8 INS74 INS22 INS74 INS22 INS22 INS52 INS42 INS52 INS42 INS22 INS22 INS22 INS40 INS40 INS83 UPD42 INS52 INS42 INS52 INS42 INS22 MOV27 INS38 INS22 INS22 INS22 MOV43 MOV43 UPD42 INS52 INS42 UPD27 MOV27 INS52 INS42 INS52 INS42 INS43 MOV32 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS78 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS43 INS42 INS52 INS42 MOV21 MOV43 INS52 INS42 MOV43 INS52 INS42 INS52 INS42 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS13 INS32 UPD42 INS42 UPD42 UPD42 INS40 UPD42 UPD42 INS52 INS42 INS32 INS22 INS42 INS22 INS42 INS22 INS52 INS42 MOV27 INS38 INS42 INS22 UPD42 UPD42 INS42 INS22 MOV42 INS52 INS42 INS22 MOV42 UPD42 UPD42 MOV42 UPD42 MOV42 INS52 INS42 INS22 INS52 INS42 INS52 INS42 INS22 MOV32 INS32 INS42 INS52 INS42 INS52 INS42 MOV32 MOV32 INS22 INS52 INS42 UPD42 INS40 INS40 UPD42 INS22 INS42 INS52 INS42 UPD42 INS22 MOV42 INS42 UPD42 INS22 INS22 INS52 INS42 UPD42 INS52 INS42 INS52 INS42 UPD42 INS52 INS42 INS52 INS42 INS22 UPD42 INS52 INS42 UPD42 UPD42 INS13 INS22 INS52 INS42 MOV27 UPD42 INS22 INS52 INS42 DEL40 DEL26 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL23 DEL83 DEL9 DEL41 DEL8 DEL25 DEL8 DEL42 DEL42 DEL40 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL65 DEL42 DEL65 DEL42 DEL43 DEL40 DEL11 DEL42 DEL43 DEL40 DEL11 DEL40 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL52 DEL42 DEL42 DEL42 DEL42 DEL42 DEL65 DEL83 DEL32 DEL34 DEL27 DEL27 DEL36 DEL42 DEL42 DEL42 DEL40 DEL40 DEL40 DEL42 DEL42 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL12 DEL42 DEL65 DEL42 DEL42 DEL42 DEL59 DEL60 DEL42 DEL7 DEL21 DEL8 DEL42 DEL34 DEL27 DEL45 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL42 DEL43 DEL11 DEL42 DEL65 DEL83 DEL42 DEL42 DEL42 DEL42 DEL83 DEL42 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL41 DEL8 DEL31 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL42 DEL42 DEL42 DEL42 DEL45 DEL36 DEL45 DEL27 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL43 DEL42 DEL11 DEL42 DEL42 DEL42 DEL42 DEL29 DEL42 DEL43 DEL42 DEL11 DEL36 DEL33 DEL42 DEL42 DEL14 DEL59 DEL42 DEL42 DEL14 DEL59 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL23 DEL83 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL8 DEL24 DEL42 DEL42 DEL43 DEL11 DEL42 DEL42 DEL43 DEL11 DEL42 DEL42 DEL42 DEL42 DEL36 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL8 DEL24 DEL8 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL41 DEL8 DEL31 DEL31 DEL83 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL11 DEL42 DEL42 DEL43 DEL11 DEL42 DEL45 DEL42 DEL32 DEL42 DEL32 DEL33 DEL42 DEL32 DEL36
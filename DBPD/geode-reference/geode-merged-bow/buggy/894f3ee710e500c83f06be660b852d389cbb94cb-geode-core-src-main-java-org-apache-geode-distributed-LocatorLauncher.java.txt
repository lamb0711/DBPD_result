GEODE-3413: overhaul launcher and process classes and tests

This is primarily an overall of all ServerLauncher and LocatorLauncher
tests and org.apache.geode.internal.process tests. The main classes in
org.apachage.geode.internal.process package are also cleaned up.

In addition, several bugs involving these classes and tests are fixed.

Here is the complete list of tickets that are resolved in this overhaul:

* GEODE-1229: LocatorLauncherRemoteJUnitTest.testStartOverwritesStalePidFile
* GEODE-2791: LocatorLauncherAssemblyIntegrationTest.testLocatorStopsWhenJmxPortIsNonZero fails intermittently with AssertionError
* GEODE-1308: CI failure: LocatorLauncherTest.testSetBindAddressToNonLocalHost
* GEODE-1309: CI failure: ServerLauncherTest.testSetServerBindAddressToNonLocalHost
* GEODE-3193: locator pid file is removed even if there was a problem while shutting down
* GEODE-3413: Overhaul launcher tests and process tests
* GEODE-3414: Cleanup org.apache.geode.internal.process package

Note I moved all useful tests from LocatorLauncherAssemblyIntegrationTest
into the other launcher tests in geode-core.

-
+import static org.apache.commons.lang.StringUtils.defaultIfBlank;
+import static org.apache.commons.lang.StringUtils.isBlank;
+import static org.apache.commons.lang.StringUtils.isNotBlank;
+import static org.apache.commons.lang.StringUtils.lowerCase;
+import static org.apache.geode.internal.lang.ObjectUtils.defaultIfNull;
+import static org.apache.geode.internal.lang.StringUtils.wrap;
+import static org.apache.geode.internal.lang.SystemUtils.CURRENT_DIRECTORY;
+import static org.apache.geode.internal.util.IOUtils.tryGetCanonicalPathElseGetAbsolutePath;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.lang.management.ManagementFactory;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.TreeMap;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.logging.Level;
+
+import javax.management.MalformedObjectNameException;
+import javax.management.ObjectName;
+
+import joptsimple.OptionException;
+import joptsimple.OptionParser;
+import joptsimple.OptionSet;
-import org.apache.geode.internal.lang.StringUtils;
-import org.apache.geode.internal.lang.SystemUtils;
-import org.apache.geode.internal.util.IOUtils;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.lang.management.ManagementFactory;
-import java.net.ConnectException;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-import java.util.TreeMap;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.logging.Level;
-import javax.management.MalformedObjectNameException;
-import javax.management.ObjectName;
-import joptsimple.OptionException;
-import joptsimple.OptionParser;
-import joptsimple.OptionSet;
-
+    helpMap.put("delete-pid-file-on-stop",
+        "Specifies that this Locator's PID file should be deleted on stop.  The default is to not delete this Locator's PID file until JVM exit if --delete-pid-file-on-stop is not specified.");
+  private final boolean deletePidFileOnStop;
-    } catch (AttachAPINotFoundException e) {
-      System.err.println(e.getMessage());
+    } catch (AttachAPINotFoundException handled) {
+      System.err.println(handled.getMessage());
-    setDebug(Boolean.TRUE.equals(builder.getDebug()));
-    this.force = Boolean.TRUE.equals(builder.getForce());
+    setDebug(Boolean.TRUE.equals(builder.getDebug()));
+    this.deletePidFileOnStop = Boolean.TRUE.equals(builder.getDeletePidFileOnStop());
+    this.force = Boolean.TRUE.equals(builder.getForce());
-    } catch (UnknownHostException ignore) {
-      // TODO determine a better value for the host on which the Locator is running to return
-      // here...
+    } catch (UnknownHostException handled) {
-      // localhost
-      // could be found
+      // localhost could be found
+  @Override
-    return StringUtils.defaultIfBlank(getMemberName(), DEFAULT_LOCATOR_LOG_NAME)
+    return defaultIfBlank(getMemberName(), DEFAULT_LOCATOR_LOG_NAME)
-   * @see AbstractLauncher#getMemberName()
+  @Override
-    return StringUtils.defaultIfBlank(this.memberName, super.getMemberName());
+    return defaultIfBlank(this.memberName, super.getMemberName());
-    return ObjectUtils.defaultIfNull(getPort(), getDefaultLocatorPort()).toString();
+    return defaultIfNull(getPort(), getDefaultLocatorPort()).toString();
+  @Override
-      info(StringUtils.wrap(helpMap.get(command.getName()), 80, ""));
+      info(wrap(helpMap.get(command.getName()), 80, ""));
-      info(StringUtils.wrap("> java ... " + getClass().getName() + " " + usageMap.get(command), 80,
-          "\t\t"));
+      info(wrap("> java ... " + getClass().getName() + " " + usageMap.get(command), 80, "\t\t"));
-        info(StringUtils.wrap("--" + option + ": " + helpMap.get(option) + "\n", 80, "\t"));
+        info(wrap("--" + option + ": " + helpMap.get(option) + "\n", 80, "\t"));
-    info(StringUtils.wrap(helpMap.get("launcher"), 80, "\t"));
+    info(wrap(helpMap.get("launcher"), 80, "\t"));
+  @Override
-        // TODO : remove the extra param for loadFromSharedConfigDir
-      } catch (Error e) {
-        failOnStart(e);
-        throw e;
-      } catch (RuntimeException e) {
+      } catch (Error | RuntimeException e) {
-      this.process.stop();
+      this.process.stop(this.deletePidFileOnStop);
-    } catch (InterruptedException e) {
+    } catch (InterruptedException handled) {
-      t = e;
-      debug(e);
-    } catch (RuntimeException e) {
-      t = e;
-      throw e;
+      t = handled;
+      debug(handled);
-      } catch (Exception ignore) {
-        try {
-          synchronized (this) {
-            timeUnit.timedWait(this, interval);
-          }
-        } catch (InterruptedException ignoreInterrupt) {
-          // NOTE just go and send another status request to the Locator...
-        }
+      } catch (Exception handled) {
+        timedWait(interval, timeUnit);
+  private void timedWait(final long interval, final TimeUnit timeUnit) {
+    try {
+      synchronized (this) {
+        timeUnit.timedWait(this, interval);
+      }
+    } catch (InterruptedException handled) {
+      // NOTE just go and send another status request to the Locator...
+    }
+  }
+
-    } catch (ConnectionFailedException e) {
+    } catch (ConnectionFailedException handled) {
-      return createNoResponseState(e, "Failed to connect to locator with process id " + getPid());
-    } catch (IOException e) {
-      // failed to open or read file or dir
-      return createNoResponseState(e,
+      return createNoResponseState(handled,
+          "Failed to connect to locator with process id " + getPid());
+    } catch (IOException | MBeanInvocationFailedException | UnableToControlProcessException
+        | TimeoutException handled) {
+      return createNoResponseState(handled,
-    } catch (MBeanInvocationFailedException e) {
-      // MBean either doesn't exist or method or attribute don't exist
-      return createNoResponseState(e,
-          "Failed to communicate with locator with process id " + getPid());
-    } catch (UnableToControlProcessException e) {
-      return createNoResponseState(e,
-          "Failed to communicate with locator with process id " + getPid());
-    } catch (InterruptedException e) {
+    } catch (InterruptedException handled) {
-      return createNoResponseState(e,
+      return createNoResponseState(handled,
-    } catch (TimeoutException e) {
-      return createNoResponseState(e,
-          "Failed to communicate with locator with process id " + getPid());
-    } catch (Exception e) {
-      return createNoResponseState(e, "Failed to connect to locator " + getId());
+    } catch (Exception handled) {
+      return createNoResponseState(handled, "Failed to connect to locator " + getId());
-              new File(getWorkingDirectory()), ProcessType.LOCATOR.getPidFileName(),
-              READ_PID_FILE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
+              new File(getWorkingDirectory()), ProcessType.LOCATOR.getPidFileName());
-    } catch (ConnectionFailedException e) {
+    } catch (ConnectionFailedException handled) {
-      return createNoResponseState(e, "Failed to connect to locator with process id " + parsedPid);
-    } catch (FileNotFoundException e) {
+      return createNoResponseState(handled,
+          "Failed to connect to locator with process id " + parsedPid);
+    } catch (FileNotFoundException handled) {
-      return createNoResponseState(e, "Failed to find process file "
+      return createNoResponseState(handled, "Failed to find process file "
-    } catch (IOException e) {
-      // failed to open or read file or dir
-      return createNoResponseState(e,
-          "Failed to communicate with locator with process id " + parsedPid);
-    } catch (MBeanInvocationFailedException e) {
-      // MBean either doesn't exist or method or attribute don't exist
-      return createNoResponseState(e,
+    } catch (IOException | MBeanInvocationFailedException | UnableToControlProcessException
+        | TimeoutException handled) {
+      return createNoResponseState(handled,
-    } catch (UnableToControlProcessException e) {
-      return createNoResponseState(e,
-          "Failed to communicate with locator with process id " + parsedPid);
-    } catch (InterruptedException e) {
+    } catch (InterruptedException handled) {
-      return createNoResponseState(e,
+      return createNoResponseState(handled,
-    } catch (TimeoutException e) {
-      return createNoResponseState(e,
-          "Failed to communicate with locator with process id " + parsedPid);
-      this.process.stop();
+      this.process.stop(this.deletePidFileOnStop);
-    } catch (ConnectionFailedException e) {
+    } catch (ConnectionFailedException handled) {
-      return createNoResponseState(e, "Failed to connect to locator with process id " + getPid());
-    } catch (IOException e) {
-      // failed to open or read file or dir
-      return createNoResponseState(e,
-          "Failed to communicate with locator with process id " + getPid());
-    } catch (MBeanInvocationFailedException e) {
-      // MBean either doesn't exist or method or attribute don't exist
-      return createNoResponseState(e,
-          "Failed to communicate with locator with process id " + getPid());
-    } catch (UnableToControlProcessException e) {
-      return createNoResponseState(e,
+      return createNoResponseState(handled,
+          "Failed to connect to locator with process id " + getPid());
+    } catch (IOException | MBeanInvocationFailedException
+        | UnableToControlProcessException handled) {
+      return createNoResponseState(handled,
-              new File(getWorkingDirectory()), ProcessType.LOCATOR.getPidFileName(),
-              READ_PID_FILE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
+              new File(getWorkingDirectory()), ProcessType.LOCATOR.getPidFileName());
-    } catch (ConnectionFailedException e) {
+    } catch (ConnectionFailedException handled) {
-      return createNoResponseState(e, "Failed to connect to locator with process id " + parsedPid);
-    } catch (FileNotFoundException e) {
+      return createNoResponseState(handled,
+          "Failed to connect to locator with process id " + parsedPid);
+    } catch (FileNotFoundException handled) {
-      return createNoResponseState(e, "Failed to find process file "
+      return createNoResponseState(handled, "Failed to find process file "
-    } catch (IOException e) {
-      // failed to open or read file or dir
-      return createNoResponseState(e,
+    } catch (IOException | MBeanInvocationFailedException
+        | UnableToControlProcessException handled) {
+      return createNoResponseState(handled,
-    } catch (InterruptedException e) {
+    } catch (InterruptedException handled) {
-      return createNoResponseState(e,
+      return createNoResponseState(handled,
-    } catch (MBeanInvocationFailedException e) {
-      // MBean either doesn't exist or method or attribute don't exist
-      return createNoResponseState(e,
-          "Failed to communicate with locator with process id " + parsedPid);
-    } catch (PidUnavailableException e) {
+    } catch (PidUnavailableException handled) {
-      return createNoResponseState(e, "Failed to find usable process id within file "
+      return createNoResponseState(handled, "Failed to find usable process id within file "
-    } catch (TimeoutException e) {
-      return createNoResponseState(e, "Timed out trying to find usable process id within file "
-          + ProcessType.LOCATOR.getPidFileName() + " in " + getWorkingDirectory());
-    } catch (UnableToControlProcessException e) {
-      return createNoResponseState(e,
-          "Failed to communicate with locator with process id " + parsedPid);
+    } catch (TimeoutException handled) {
+      return createNoResponseState(handled,
+          "Timed out trying to find usable process id within file "
+              + ProcessType.LOCATOR.getPidFileName() + " in " + getWorkingDirectory());
-    // info(errorMessage);
-  private Properties getOverriddenDefaults() {
+  private Properties getOverriddenDefaults() throws IOException {
-        getLogFileName());
+        getLogFile().getCanonicalPath());
-    public File getWorkingDirectory() {
+    public File getDirectory() {
-      } catch (MalformedObjectNameException e) {
-        return null;
-      } catch (NullPointerException e) {
+      } catch (MalformedObjectNameException | NullPointerException handled) {
+    private Boolean deletePidFileOnStop;
+      parser.accepts("delete-pid-file-on-stop");
+        setDeletePidFileOnStop(options.has("delete-pid-file-on-stop"));
-      for (String arg : args) {
-        final Command command = Command.valueOfName(arg);
-        if (command != null) {
-          setCommand(command);
-          break;
+      if (args != null) {
+        for (String arg : args) {
+          final Command command = Command.valueOfName(arg);
+          if (command != null) {
+            setCommand(command);
+            break;
+          }
-    protected void parseMemberName(final String[] args) {
-      for (String arg : args) {
-        if (!(arg.startsWith(OPTION_PREFIX) || Command.isCommand(arg))) {
-          setMemberName(arg);
-          break;
+    protected void parseMemberName(final String... args) {
+      if (args != null) {
+        for (String arg : args) {
+          if (!(arg.startsWith(OPTION_PREFIX) || Command.isCommand(arg))) {
+            setMemberName(arg);
+            break;
+          }
-      return ObjectUtils.defaultIfNull(this.command, DEFAULT_COMMAND);
+      return defaultIfNull(this.command, DEFAULT_COMMAND);
-     * @see #getHelp()
+     * @see #getDebug()
+     * Determines whether the Geode Locator should delete the pid file when its service stops or
+     * when the JVM exits.
+     *
+     * @return a boolean value indicating if the pid file should be deleted when this service stops
+     *         or when the JVM exits.
+     * @see #setDeletePidFileOnStop(Boolean)
+     */
+    public Boolean getDeletePidFileOnStop() {
+      return this.deletePidFileOnStop;
+    }
+
+    /**
+     * Sets whether the Geode Locator should delete the pid file when its service stops or when the
+     * JVM exits.
+     *
+     * @param deletePidFileOnStop a boolean value indicating if the pid file should be deleted when
+     *        this service stops or when the JVM exits.
+     * @return this Builder instance.
+     * @see #getDeletePidFileOnStop()
+     */
+    public Builder setDeletePidFileOnStop(final Boolean deletePidFileOnStop) {
+      this.deletePidFileOnStop = deletePidFileOnStop;
+      return this;
+    }
+
+    /**
-     * @see org.apache.geode.internal.process.LocalProcessLauncher
-      return ObjectUtils.defaultIfNull(this.force, DEFAULT_FORCE);
+      return defaultIfNull(this.force, DEFAULT_FORCE);
-     * @see org.apache.geode.internal.process.LocalProcessLauncher
-      if (StringUtils.isBlank(bindAddress)) {
+      if (isBlank(bindAddress)) {
-      if (StringUtils.isBlank(hostnameForClients)) {
+      if (isBlank(hostnameForClients)) {
-      if (StringUtils.isBlank(memberName)) {
+      if (isBlank(memberName)) {
-      return ObjectUtils.defaultIfNull(port, getDefaultLocatorPort());
+      return defaultIfNull(port, getDefaultLocatorPort());
-      return StringUtils.isNotBlank(this.workingDirectory);
+      return isNotBlank(this.workingDirectory);
-      return IOUtils.tryGetCanonicalPathElseGetAbsolutePath(
-          new File(StringUtils.defaultIfBlank(this.workingDirectory, DEFAULT_WORKING_DIRECTORY)));
+      return tryGetCanonicalPathElseGetAbsolutePath(
+          new File(defaultIfBlank(this.workingDirectory, DEFAULT_WORKING_DIRECTORY)));
-      if (!new File(StringUtils.defaultIfBlank(workingDirectory, DEFAULT_WORKING_DIRECTORY))
-          .isDirectory()) {
+      if (!new File(defaultIfBlank(workingDirectory, DEFAULT_WORKING_DIRECTORY)).isDirectory()) {
-      if (Command.START.equals(getCommand())) {
-        if (StringUtils.isBlank(getMemberName())
+      if (Command.START == getCommand()) {
+        if (isBlank(getMemberName())
-        if (!SystemUtils.CURRENT_DIRECTORY.equals(getWorkingDirectory())) {
+        if (!CURRENT_DIRECTORY.equals(getWorkingDirectory())) {
-      if (Command.STATUS.equals(getCommand())) {
+      if (Command.STATUS == getCommand()) {
-      if (Command.STOP.equals(getCommand())) {
+      if (Command.STOP == getCommand()) {
-      assert !StringUtils
-          .isBlank(name) : "The name of the locator launcher command must be specified!";
+      assert isNotBlank(name) : "The name of the locator launcher command must be specified!";
-      return getOptions().contains(StringUtils.lowerCase(option));
+      return getOptions().contains(lowerCase(option));
-      return UNSPECIFIED.equals(this);
+      return UNSPECIFIED == this;
-          if (StringUtils.isBlank(bindAddress.getHostAddress())) {
+          if (isBlank(bindAddress.getHostAddress())) {
-          final String logFileCanonicalPath =
-              IOUtils.tryGetCanonicalPathElseGetAbsolutePath(logFile);
-          if (StringUtils.isNotBlank(logFileCanonicalPath)) { // this is probably not need but a
-                                                              // safe
+          final String logFileCanonicalPath = tryGetCanonicalPathElseGetAbsolutePath(logFile);
+          if (isNotBlank(logFileCanonicalPath)) { // this is probably not need but a
+                                                  // safe
-        if (StringUtils.isNotBlank(portAsString)) {
+        if (isNotBlank(portAsString)) {

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 UPD40 UPD40 UPD40 UPD40 INS23 INS31 INS83 INS83 INS39 INS59 MOV21 MOV21 INS78 INS78 INS78 INS78 INS83 INS39 INS42 INS44 INS44 MOV8 INS43 INS23 INS31 INS31 INS21 INS42 INS21 INS42 INS42 INS42 INS42 INS83 INS39 INS42 INS83 INS43 INS42 INS42 UPD42 INS83 INS43 INS59 INS8 INS8 INS29 INS83 INS43 INS42 INS8 INS29 INS83 INS43 INS42 INS44 INS8 INS32 INS7 INS42 INS42 INS42 INS21 INS25 INS43 INS25 INS65 INS65 INS65 INS42 INS41 INS65 INS65 INS65 INS65 INS42 INS83 INS43 INS42 INS21 INS41 INS42 INS42 INS45 INS45 INS22 INS32 INS32 INS32 INS27 MOV8 MOV42 INS27 MOV8 INS66 INS66 INS66 INS66 INS68 INS22 INS66 INS66 INS42 INS66 INS66 INS66 INS68 INS42 INS7 INS52 INS27 INS27 INS27 INS32 INS27 UPD42 INS52 INS42 INS40 INS42 INS32 UPD42 UPD42 UPD42 UPD42 INS84 INS42 UPD42 UPD42 UPD42 UPD42 INS84 INS42 UPD42 UPD42 INS84 INS42 UPD42 UPD42 INS84 INS42 UPD42 UPD42 UPD42 MOV32 INS42 INS42 INS42 INS45 INS21 INS42 INS33 INS42 INS33 UPD42 INS42 INS69 INS52 INS42 INS42 INS22 INS42 INS40 MOV32 INS40 MOV32 INS40 MOV32 UPD42 MOV42 MOV42 INS42 INS52 INS42 INS42 INS22 INS8 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 INS22 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 UPD42 INS84 INS42 INS32 INS43 INS52 INS42 INS84 INS52 INS42 UPD42 UPD42 UPD42 INS21 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS52 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV43 MOV43 INS42 INS32 INS42 UPD42 MOV43 MOV43 INS32 INS42 INS42 INS45 INS42 INS42 INS42 INS42 DEL42 DEL42 DEL42 DEL68 DEL65 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL44 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL7 DEL21 DEL42 DEL53 DEL8 DEL12 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL40 DEL42 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL40 DEL42 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL42 DEL44 DEL33 DEL41 DEL8 DEL12 DEL43 DEL85 DEL5 DEL42 DEL40 DEL65 DEL42 DEL40 DEL65 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL40 DEL42 DEL32 DEL42 DEL40 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL42 DEL32 DEL38 DEL42 DEL42 DEL42 DEL52 DEL32 DEL42 DEL42 DEL42 DEL42
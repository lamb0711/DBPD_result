GEODE-5279: RegionExistsException coming from JMX Manager (#2026)


Co-authored-by: Ivan Godwin <igodwin@pivotal.io>

+import java.util.concurrent.atomic.AtomicReference;
+import org.apache.geode.annotations.TestingOnly;
+  private AtomicReference<Exception> latestException = new AtomicReference<>(null);
+
-    executeTask(new Runnable() {
-      @Override
-      public void run() {
+    executeTask(() -> {
+      try {
+      } catch (Exception e) {
+        logger.warn("Error federating new member {}: {}", member.getId(), e.getMessage());
+        latestException.set(e);
-      Region<String, Object> proxyMonitoringRegion;
-      Region<NotificationKey, Notification> proxyNotificationRegion;
-      try {
+      synchronized (member) {
+        Region<String, Object> proxyMonitoringRegion;
+        Region<NotificationKey, Notification> proxyNotificationRegion;
+        String appender = MBeanJMXAdapter.getUniqueIDForMember(member);
+        String monitoringRegionName = ManagementConstants.MONITORING_REGION + "_" + appender;
+        String notificationRegionName = ManagementConstants.NOTIFICATION_REGION + "_" + appender;
-        // GII wont start at all if its interrupted
-        if (!Thread.currentThread().isInterrupted()) {
-
-          // as the regions will be internal regions
-          InternalRegionArguments internalArgs = new InternalRegionArguments();
-          internalArgs.setIsUsedForMetaRegion(true);
-
-          // Create anonymous stats holder for Management Regions
-          final HasCachePerfStats monitoringRegionStats = new HasCachePerfStats() {
-            public CachePerfStats getCachePerfStats() {
-              return new CachePerfStats(cache.getDistributedSystem(), "managementRegionStats");
-            }
-          };
-
-          internalArgs.setCachePerfStatsHolder(monitoringRegionStats);
-
-          // Monitoring region for member is created
-          AttributesFactory<String, Object> monitorAttrFactory = new AttributesFactory<>();
-          monitorAttrFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
-          monitorAttrFactory.setDataPolicy(DataPolicy.REPLICATE);
-          monitorAttrFactory.setConcurrencyChecksEnabled(false);
-          ManagementCacheListener mgmtCacheListener = new ManagementCacheListener(proxyFactory);
-          monitorAttrFactory.addCacheListener(mgmtCacheListener);
-
-          RegionAttributes<String, Object> monitoringRegionAttrs = monitorAttrFactory.create();
-
-          // Notification region for member is created
-          AttributesFactory<NotificationKey, Notification> notifAttrFactory =
-              new AttributesFactory<>();
-          notifAttrFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
-          notifAttrFactory.setDataPolicy(DataPolicy.REPLICATE);
-          notifAttrFactory.setConcurrencyChecksEnabled(false);
-
-          // Fix for issue #49638, evict the internal region _notificationRegion
-          notifAttrFactory.setEvictionAttributes(EvictionAttributes.createLRUEntryAttributes(
-              ManagementConstants.NOTIF_REGION_MAX_ENTRIES, EvictionAction.LOCAL_DESTROY));
-
-          NotificationCacheListener notifListener = new NotificationCacheListener(proxyFactory);
-          notifAttrFactory.addCacheListener(notifListener);
-
-          RegionAttributes<NotificationKey, Notification> notifRegionAttrs =
-              notifAttrFactory.create();
-
-          boolean proxyMonitoringRegionCreated = false;
-          boolean proxyNotifRegionCreated = false;
-
-          String appender = MBeanJMXAdapter.getUniqueIDForMember(member);
-
-          try {
-            if (!running) {
-              return null;
-            }
-            proxyMonitoringRegion =
-                cache.createVMRegion(ManagementConstants.MONITORING_REGION + "_" + appender,
-                    monitoringRegionAttrs, internalArgs);
-            proxyMonitoringRegionCreated = true;
-
-          } catch (TimeoutException | RegionExistsException | IOException
-              | ClassNotFoundException e) {
-            if (logger.isDebugEnabled()) {
-              logger.debug("Error During Internal Region creation {}", e.getMessage(), e);
-            }
-            throw new ManagementException(e);
-          }
-
-          try {
-            if (!running) {
-              return null;
-            }
-            proxyNotificationRegion =
-                cache.createVMRegion(ManagementConstants.NOTIFICATION_REGION + "_" + appender,
-                    notifRegionAttrs, internalArgs);
-            proxyNotifRegionCreated = true;
-          } catch (TimeoutException | RegionExistsException | IOException
-              | ClassNotFoundException e) {
-            if (logger.isDebugEnabled()) {
-              logger.debug("Error During Internal Region creation {}", e.getMessage(), e);
-            }
-            throw new ManagementException(e);
-          } finally {
-            if (!proxyNotifRegionCreated && proxyMonitoringRegionCreated) {
-              // Destroy the proxy region if proxy notification
-              // region is not created
-              proxyMonitoringRegion.localDestroyRegion();
-            }
-          }
-
-          if (logger.isDebugEnabled()) {
-            logger.debug("Management Region created with Name : {}",
-                proxyMonitoringRegion.getName());
-            logger.debug("Notification Region created with Name : {}",
-                proxyNotificationRegion.getName());
-          }
-
-          // Only the exception case would have destroyed the proxy
-          // regions. We can safely proceed here.
-          repo.putEntryInMonitoringRegionMap(member, proxyMonitoringRegion);
-          repo.putEntryInNotifRegionMap(member, proxyNotificationRegion);
-          try {
-            if (!running) {
-              return null;
-            }
-            proxyFactory.createAllProxies(member, proxyMonitoringRegion);
-
-            mgmtCacheListener.markReady();
-            notifListener.markReady();
-          } catch (Exception e) {
-            if (logger.isDebugEnabled()) {
-              logger.debug("Error During GII Proxy creation {}", e.getMessage(), e);
-            }
-
-            throw new ManagementException(e);
-          }
+        if (cache.getRegion(monitoringRegionName) != null
+            && cache.getRegion(notificationRegionName) != null) {
+          return member;
-      } catch (Exception e) {
-        throw new ManagementException(e);
+        try {
+
+          // GII wont start at all if its interrupted
+          if (!Thread.currentThread().isInterrupted()) {
+
+            // as the regions will be internal regions
+            InternalRegionArguments internalArgs = new InternalRegionArguments();
+            internalArgs.setIsUsedForMetaRegion(true);
+
+            // Create anonymous stats holder for Management Regions
+            final HasCachePerfStats monitoringRegionStats = new HasCachePerfStats() {
+              public CachePerfStats getCachePerfStats() {
+                return new CachePerfStats(cache.getDistributedSystem(), "managementRegionStats");
+              }
+            };
+
+            internalArgs.setCachePerfStatsHolder(monitoringRegionStats);
+
+            // Monitoring region for member is created
+            AttributesFactory<String, Object> monitorAttrFactory = new AttributesFactory<>();
+            monitorAttrFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
+            monitorAttrFactory.setDataPolicy(DataPolicy.REPLICATE);
+            monitorAttrFactory.setConcurrencyChecksEnabled(false);
+            ManagementCacheListener mgmtCacheListener = new ManagementCacheListener(proxyFactory);
+            monitorAttrFactory.addCacheListener(mgmtCacheListener);
+
+            RegionAttributes<String, Object> monitoringRegionAttrs = monitorAttrFactory.create();
+
+            // Notification region for member is created
+            AttributesFactory<NotificationKey, Notification> notifAttrFactory =
+                new AttributesFactory<>();
+            notifAttrFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
+            notifAttrFactory.setDataPolicy(DataPolicy.REPLICATE);
+            notifAttrFactory.setConcurrencyChecksEnabled(false);
+
+            // Fix for issue #49638, evict the internal region _notificationRegion
+            notifAttrFactory.setEvictionAttributes(EvictionAttributes.createLRUEntryAttributes(
+                ManagementConstants.NOTIF_REGION_MAX_ENTRIES, EvictionAction.LOCAL_DESTROY));
+
+            NotificationCacheListener notifListener = new NotificationCacheListener(proxyFactory);
+            notifAttrFactory.addCacheListener(notifListener);
+
+            RegionAttributes<NotificationKey, Notification> notifRegionAttrs =
+                notifAttrFactory.create();
+
+            boolean proxyMonitoringRegionCreated = false;
+            boolean proxyNotifRegionCreated = false;
+
+            try {
+              if (!running) {
+                return null;
+              }
+              proxyMonitoringRegion =
+                  cache.createVMRegion(monitoringRegionName, monitoringRegionAttrs, internalArgs);
+              proxyMonitoringRegionCreated = true;
+
+            } catch (TimeoutException | RegionExistsException | IOException
+                | ClassNotFoundException e) {
+              if (logger.isDebugEnabled()) {
+                logger.debug("Error During Internal Region creation {}", e.getMessage(), e);
+              }
+              throw new ManagementException(e);
+            }
+
+            try {
+              if (!running) {
+                return null;
+              }
+              proxyNotificationRegion =
+                  cache.createVMRegion(notificationRegionName, notifRegionAttrs, internalArgs);
+              proxyNotifRegionCreated = true;
+            } catch (TimeoutException | RegionExistsException | IOException
+                | ClassNotFoundException e) {
+              if (logger.isDebugEnabled()) {
+                logger.debug("Error During Internal Region creation {}", e.getMessage(), e);
+              }
+              throw new ManagementException(e);
+            } finally {
+              if (!proxyNotifRegionCreated && proxyMonitoringRegionCreated) {
+                // Destroy the proxy region if proxy notification
+                // region is not created
+                proxyMonitoringRegion.localDestroyRegion();
+              }
+            }
+
+            if (logger.isDebugEnabled()) {
+              logger.debug("Management Region created with Name : {}",
+                  proxyMonitoringRegion.getName());
+              logger.debug("Notification Region created with Name : {}",
+                  proxyNotificationRegion.getName());
+            }
+
+            // Only the exception case would have destroyed the proxy
+            // regions. We can safely proceed here.
+            repo.putEntryInMonitoringRegionMap(member, proxyMonitoringRegion);
+            repo.putEntryInNotifRegionMap(member, proxyNotificationRegion);
+            try {
+              if (!running) {
+                return null;
+              }
+              proxyFactory.createAllProxies(member, proxyMonitoringRegion);
+
+              mgmtCacheListener.markReady();
+              notifListener.markReady();
+            } catch (Exception e) {
+              if (logger.isDebugEnabled()) {
+                logger.debug("Error During GII Proxy creation {}", e.getMessage(), e);
+              }
+
+              throw new ManagementException(e);
+            }
+          }
+
+        } catch (Exception e) {
+          throw new ManagementException(e);
+        }
+
+        // Before completing task intimate all listening ProxyListener which might send
+        // notifications.
+        service.memberJoined((InternalDistributedMember) member);
+
+        // Send manager info to the added member
+        messenger.sendManagerInfo(member);
+
+        return member;
-
-      // Before completing task intimate all listening ProxyListener which might send notifications.
-      service.memberJoined((InternalDistributedMember) member);
-
-      // Send manager info to the added member
-      messenger.sendManagerInfo(member);
-
-      return member;
+  @TestingOnly
+  public void setMessenger(MemberMessenger messenger) {
+    this.messenger = messenger;
+  }
+
+  @TestingOnly
+  public synchronized Exception getAndResetLatestException() {
+    return latestException.getAndSet(null);
+  }

INS26 INS26 INS40 INS40 INS23 INS31 INS31 INS83 INS74 INS59 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS83 INS43 INS42 INS8 INS43 INS43 INS42 INS14 INS8 INS42 INS43 INS42 INS21 INS42 INS42 INS41 INS42 INS42 INS74 INS33 INS51 INS42 INS7 INS32 INS43 INS86 INS42 MOV8 INS22 INS42 INS42 INS42 INS33 INS42 INS8 MOV60 INS60 INS60 INS25 INS52 INS42 INS54 INS43 INS59 INS43 INS59 INS27 INS8 MOV8 INS12 INS42 INS42 MOV27 INS42 INS42 MOV27 INS27 INS27 INS41 INS44 INS8 INS32 INS33 INS32 INS33 INS42 INS43 INS42 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS32 INS32 INS42 INS42 INS45 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL43 DEL42 DEL78 DEL83 DEL39 DEL42 DEL31 DEL1 DEL14
GEODE-831: unit test FreeListManager

* moved state from SimpleMemoryAllocatorImpl to FreeListManager
* refactored and cleaned up release/free code
* Removed ChunkType and ChunkFactory. They were no longer used by GemFire and complicated the code
* removed BATCH_SIZE; it was an expirement that was not longer used
* combined Chunk and GemFireChunk to the new ObjectChunk class

+   * A chunk that stores a Java object.
+   * Currently the object stored in this chunk
+   * is always an entry value of a Region.
-  public abstract class Chunk extends OffHeapCachedDeserializable implements Comparable<Chunk>, MemoryBlock {
+  public class ObjectChunk extends OffHeapCachedDeserializable implements Comparable<ObjectChunk>, MemoryBlock {
-     * The next three bits are used to encode the SRC_TYPE enum.
+     * The next three bits are unused.
-    final static int SRC_TYPE_MASK = 0x38000000;
-    final static int SRC_TYPE_SHIFT = 16/*refCount*/+8/*dataSize*/+3/*magicSize*/;
+    // UNUSED 0x38000000
-    // The 8 bits reserved for SRC_TYPE are basically no longer used.
-    // So we could free up these 8 bits for some other use or we could
-    // keep them for future extensions.
-    // If we ever want to allocate other "types" into a chunk of off-heap
-    // memory then the SRC_TYPE would be the way to go.
-    // For example we may want to allocate the memory for the off-heap
-    // RegionEntry in off-heap memory without it being of type GFE.
-    // When it is of type GFE then it either needs to be the bytes
-    // of a byte array or it needs to be a serialized java object.
-    // For the RegionEntry we may want all the primitive fields of
-    // the entry at certain offsets in the off-heap memory so we could
-    // access them directly in native byte format (i.e. no serialization).
-    // Note that for every SRC_TYPE we should have a ChunkType subclass.
-    public final static int SRC_TYPE_UNUSED0 = 0 << SRC_TYPE_SHIFT;
-    public final static int SRC_TYPE_UNUSED1 = 1 << SRC_TYPE_SHIFT;
-    public final static int SRC_TYPE_UNUSED2 = 2 << SRC_TYPE_SHIFT;
-    public final static int SRC_TYPE_UNUSED3 = 3 << SRC_TYPE_SHIFT;
-    public final static int SRC_TYPE_GFE = 4 << SRC_TYPE_SHIFT;
-    public final static int SRC_TYPE_UNUSED5 = 5 << SRC_TYPE_SHIFT;
-    public final static int SRC_TYPE_UNUSED6 = 6 << SRC_TYPE_SHIFT;
-    public final static int SRC_TYPE_UNUSED7 = 7 << SRC_TYPE_SHIFT;
-    
-    protected Chunk(long memoryAddress, int chunkSize, ChunkType chunkType) {
+    protected ObjectChunk(long memoryAddress, int chunkSize) {
-      UnsafeMemoryChunk.writeAbsoluteIntVolatile(getMemoryAddress()+REF_COUNT_OFFSET, MAGIC_NUMBER|chunkType.getSrcType());
+      UnsafeMemoryChunk.writeAbsoluteIntVolatile(getMemoryAddress()+REF_COUNT_OFFSET, MAGIC_NUMBER);
-    public void readyForAllocation(ChunkType chunkType) {
-      if (!UnsafeMemoryChunk.writeAbsoluteIntVolatile(getMemoryAddress()+REF_COUNT_OFFSET, 0, MAGIC_NUMBER|chunkType.getSrcType())) {
+    public void readyForAllocation() {
+      if (!UnsafeMemoryChunk.writeAbsoluteIntVolatile(getMemoryAddress()+REF_COUNT_OFFSET, 0, MAGIC_NUMBER)) {
-    protected Chunk() {
+    protected ObjectChunk() {
-    protected Chunk(long memoryAddress) {
+    protected ObjectChunk(long memoryAddress) {
-    protected Chunk(Chunk chunk) {
+    protected ObjectChunk(ObjectChunk chunk) {
-      release(this.memoryAddress, true);
+      release(this.memoryAddress);
-    public int compareTo(Chunk o) {
+    public int compareTo(ObjectChunk o) {
-      if (o instanceof Chunk) {
-        return getMemoryAddress() == ((Chunk) o).getMemoryAddress();
+      if (o instanceof ObjectChunk) {
+        return getMemoryAddress() == ((ObjectChunk) o).getMemoryAddress();
-    @Override
-    public ChunkType getChunkType() {
-      return SimpleMemoryAllocatorImpl.getAllocator().getChunkFactory().getChunkTypeForAddress(getMemoryAddress());
-    }
-    public static int getSrcTypeOrdinal(long memAddr) {
-      return getSrcType(memAddr) >> SRC_TYPE_SHIFT;
-    }
-    public static int getSrcType(long memAddr) {
-      return getSrcTypeFromRawBits(UnsafeMemoryChunk.readAbsoluteInt(memAddr+REF_COUNT_OFFSET));
-    }
-    public static int getSrcTypeFromRawBits(int rawBits) {
-      return rawBits & SRC_TYPE_MASK;
-    }
-    public static int getSrcTypeOrdinalFromRawBits(int rawBits) {
-      return getSrcTypeFromRawBits(rawBits) >> SRC_TYPE_SHIFT;
-    }
-     * @param baseAddress the starting address for a {@link Chunk}.
+     * @param baseAddress the starting address for a {@link ObjectChunk}.
-      assert SimpleMemoryAllocatorImpl.TINY_MULTIPLE == 8;
+      assert FreeListManager.TINY_MULTIPLE == 8;
-      for(int i = 0;i < size;i += SimpleMemoryAllocatorImpl.TINY_MULTIPLE) {
+      for(int i = 0;i < size;i += FreeListManager.TINY_MULTIPLE) {
-    public static void release(final long memAddr, boolean issueOnReturnCallback) {
+    public static void release(final long memAddr) {
+      release(memAddr, null);
+    }
+    static void release(final long memAddr, FreeListManager freeListManager) {
-        /*
-        if(issueOnReturnCallback) {
-         final GemFireCacheImpl.StaticSystemCallbacks sysCb =
-              GemFireCacheImpl.FactoryStatics.systemCallbacks;
-          if(sysCb != null ) {
-            ChunkType ct = SimpleMemoryAllocatorImpl.getAllocator().getChunkFactory().getChunkTypeForRawBits(rawBits);
-            int dataSizeDelta = computeDataSizeDelta(rawBits);
-            sysCb.beforeReturningOffHeapMemoryToAllocator(memAddr, ct, dataSizeDelta);
-          }
-        }
-        */
-       
-        if (ReferenceCountHelper.trackReferenceCounts()) {
+       if (ReferenceCountHelper.trackReferenceCounts()) {
-        
-        // Use fill pattern for free list data integrity check.
-        if(SimpleMemoryAllocatorImpl.getAllocator().validateMemoryWithFill) {
-          fill(memAddr);
+        if (freeListManager == null) {
+          freeListManager = SimpleMemoryAllocatorImpl.getAllocator().getFreeListManager();
-        
-        SimpleMemoryAllocatorImpl.getAllocator().freeChunk(memAddr);
+        freeListManager.free(memAddr);
-    private static int computeDataSizeDelta(int rawBits) {
-      int dataSizeDelta = rawBits;
-      dataSizeDelta &= DATA_SIZE_DELTA_MASK;
-      dataSizeDelta >>= DATA_SIZE_SHIFT;
-      return dataSizeDelta;
-    }
-    
-    public Chunk slice(int position, int limit) {
-      throw new UnsupportedOperationException();
+    public ObjectChunk slice(int position, int limit) {
+      return new ObjectChunkSlice(this, position, limit);

MOV31 UPD42 UPD74 UPD43 UPD42 UPD42 UPD42 UPD42 UPD39 UPD42 UPD43 INS66 INS66 INS66 UPD42 UPD43 UPD43 INS83 INS21 INS43 INS42 UPD42 INS41 UPD66 UPD42 UPD42 INS32 INS42 INS14 UPD27 INS42 UPD43 UPD42 UPD40 UPD40 UPD42 MOV42 INS42 INS33 UPD43 MOV43 INS52 INS42 INS42 MOV42 MOV27 INS42 UPD42 INS27 UPD42 MOV42 INS42 INS33 UPD42 MOV42 UPD42 INS7 INS42 INS32 UPD43 MOV32 UPD42 MOV42 UPD42 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL34 DEL34 DEL34 DEL27 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL42 DEL27 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL42 DEL27 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL42 DEL27 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL42 DEL27 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL42 DEL27 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL42 DEL27 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL42 DEL27 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL42 DEL27 DEL59 DEL23 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL27 DEL9 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL41 DEL8 DEL31 DEL83 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL27 DEL41 DEL8 DEL31 DEL83 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL27 DEL41 DEL8 DEL31 DEL83 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL27 DEL41 DEL8 DEL31 DEL42 DEL42 DEL42 DEL42 DEL27 DEL32 DEL32 DEL41 DEL83 DEL39 DEL42 DEL42 DEL22 DEL42 DEL32 DEL42 DEL32 DEL83 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL39 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL7 DEL21 DEL42 DEL42 DEL7 DEL21 DEL42 DEL41 DEL8 DEL31 DEL14 DEL53
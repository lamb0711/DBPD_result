Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * QueryMonitor class, monitors the query execution time. 
- * Instantiated based on the system property MAX_QUERY_EXECUTION_TIME. At most 
- * there will be one query monitor-thread that cancels the long running queries.
+ * QueryMonitor class, monitors the query execution time. Instantiated based on the system property
+ * MAX_QUERY_EXECUTION_TIME. At most there will be one query monitor-thread that cancels the long
+ * running queries.
- * The queries to be monitored is added into the ordered queue, ordered based
- * on its start/arrival time. The first one in the Queue is the older query 
- * that will be canceled first.
+ * The queries to be monitored is added into the ordered queue, ordered based on its start/arrival
+ * time. The first one in the Queue is the older query that will be canceled first.
- * The QueryMonitor cancels a query-execution thread if its taking more than
- * the max time. 
+ * The QueryMonitor cancels a query-execution thread if its taking more than the max time.
-   * Holds the query execution status for the thread executing the query.
-   * FALSE if the query is not canceled due to max query execution timeout.
-   * TRUE it the query is canceled due to max query execution timeout timeout.
+   * Holds the query execution status for the thread executing the query. FALSE if the query is not
+   * canceled due to max query execution timeout. TRUE it the query is canceled due to max query
+   * execution timeout timeout.
-  private static ThreadLocal<AtomicBoolean> queryExecutionStatus = new ThreadLocal<AtomicBoolean>() {
-    @Override 
-    protected AtomicBoolean initialValue() {
-      return new AtomicBoolean(Boolean.FALSE);
-    }    
-  };
-  
+  private static ThreadLocal<AtomicBoolean> queryExecutionStatus =
+      new ThreadLocal<AtomicBoolean>() {
+        @Override
+        protected AtomicBoolean initialValue() {
+          return new AtomicBoolean(Boolean.FALSE);
+        }
+      };
+
-  
-  //Variables for cancelling queries due to low memory
+
+  // Variables for cancelling queries due to low memory
-  
+
+   * 
-      String reason = LocalizedStrings.QueryMonitor_LOW_MEMORY_CANCELED_QUERY.toLocalizedString(LOW_MEMORY_USED_BYTES);
+      String reason = LocalizedStrings.QueryMonitor_LOW_MEMORY_CANCELED_QUERY
+          .toLocalizedString(LOW_MEMORY_USED_BYTES);
-    synchronized (queryThreads){
+    synchronized (queryThreads) {
-      logger.debug("Adding thread to QueryMonitor. QueryMonitor size is:{}, Thread (id): {} query: {} thread is : {}", 
+      logger.debug(
+          "Adding thread to QueryMonitor. QueryMonitor size is:{}, Thread (id): {} query: {} thread is : {}",
-    if (GemFireCacheImpl.getInstance() != null && GemFireCacheImpl.getInstance().TEST_MAX_QUERY_EXECUTION_TIME > 0) {
-      if (this.queryMonitorTasks == null){
+    if (GemFireCacheImpl.getInstance() != null
+        && GemFireCacheImpl.getInstance().TEST_MAX_QUERY_EXECUTION_TIME > 0) {
+      if (this.queryMonitorTasks == null) {
-    }    
+    }
-  
+
-   * Stops monitoring the query.
-   * Removes the passed thread from QueryMonitor queue.
+   * Stops monitoring the query. Removes the passed thread from QueryMonitor queue.
+   * 
-    DefaultQuery q = (DefaultQuery)query;
+    DefaultQuery q = (DefaultQuery) query;
-    
-    synchronized(queryCompleted) {
+
+    synchronized (queryCompleted) {
-      if (GemFireCacheImpl.getInstance() != null && GemFireCacheImpl.getInstance().TEST_MAX_QUERY_EXECUTION_TIME > 0){
+      if (GemFireCacheImpl.getInstance() != null
+          && GemFireCacheImpl.getInstance().TEST_MAX_QUERY_EXECUTION_TIME > 0) {
-        QueryThreadTask queryTask = (QueryThreadTask)queryThreads.peek();
+        QueryThreadTask queryTask = (QueryThreadTask) queryThreads.peek();
-        
+
-          if ((currentTime - queryTask.StartTime) > maxTimeSet){
+          if ((currentTime - queryTask.StartTime) > maxTimeSet) {
-            testException = new QueryExecutionTimeoutException("The QueryMonitor thread may be sleeping longer than" +
-                " the set sleep time. This will happen as the sleep is based on OS thread scheduling," +
-            " verify the time spent by the executor thread.");
+            testException = new QueryExecutionTimeoutException(
+                "The QueryMonitor thread may be sleeping longer than"
+                    + " the set sleep time. This will happen as the sleep is based on OS thread scheduling,"
+                    + " verify the time spent by the executor thread.");
-    
+
-      logger.debug("Removed thread from QueryMonitor. QueryMonitor size is:{}, Thread ID is: {}  thread is : {}", 
+      logger.debug(
+          "Removed thread from QueryMonitor. QueryMonitor size is:{}, Thread ID is: {}  thread is : {}",
-    
-    if (testException != null){
+
+    if (testException != null) {
-   * This method is called to check if the query execution is canceled.
-   * The QueryMonitor cancels the query execution if it takes more than 
-   * the max query execution time set or in low memory situations where
-   * critical heap percentage has been set on the resource manager
-   *  
-   * The max query execution time is set using the system property 
-   * gemfire.Cache.MAX_QUERY_EXECUTION_TIME 
-   */  
-  public static void isQueryExecutionCanceled(){    
-    if (queryExecutionStatus.get() != null && queryExecutionStatus.get().get()){
+   * This method is called to check if the query execution is canceled. The QueryMonitor cancels the
+   * query execution if it takes more than the max query execution time set or in low memory
+   * situations where critical heap percentage has been set on the resource manager
+   * 
+   * The max query execution time is set using the system property
+   * gemfire.Cache.MAX_QUERY_EXECUTION_TIME
+   */
+  public static void isQueryExecutionCanceled() {
+    if (queryExecutionStatus.get() != null && queryExecutionStatus.get().get()) {
- 
+
-  public void stopMonitoring(){
-    //synchronized in the rare case where query monitor was created but not yet run
-    synchronized(stopped) {
+  public void stopMonitoring() {
+    // synchronized in the rare case where query monitor was created but not yet run
+    synchronized (stopped) {
-   * Starts monitoring the query.
-   * If query runs longer than the set MAX_QUERY_EXECUTION_TIME, interrupts the
-   * thread executing the query.
+   * Starts monitoring the query. If query runs longer than the set MAX_QUERY_EXECUTION_TIME,
+   * interrupts the thread executing the query.
-  public void run(){
-    //if the query monitor is stopped before run has been called, we should not run
+  public void run() {
+    // if the query monitor is stopped before run has been called, we should not run
-      while(true){
-        // Get the first query task from the queue. This query will have the shortest 
+      while (true) {
+        // Get the first query task from the queue. This query will have the shortest
-        queryTask = (QueryThreadTask)queryThreads.peek();
-        if (queryTask == null){
-          // Empty queue. 
-          synchronized (this.queryThreads){
+        queryTask = (QueryThreadTask) queryThreads.peek();
+        if (queryTask == null) {
+          // Empty queue.
+          synchronized (this.queryThreads) {
-        // Check if the sleepTime is greater than the remaining query execution time. 
-        if ((currentTime - queryTask.StartTime) < this.maxQueryExecutionTime){
+        // Check if the sleepTime is greater than the remaining query execution time.
+        if ((currentTime - queryTask.StartTime) < this.maxQueryExecutionTime) {
-          // Its been noted that the sleep is not guaranteed to wait for the specified 
+          // Its been noted that the sleep is not guaranteed to wait for the specified
-          // behavior, hence thread may sleep for longer than the specified time. 
+          // behavior, hence thread may sleep for longer than the specified time.
-        // Query execution has taken more than the max time, Set queryExecutionStatus flag 
+        // Query execution has taken more than the max time, Set queryExecutionStatus flag
-        boolean[] queryCompleted = ((DefaultQuery)queryTask.query).getQueryCompletedForMonitoring();
-        synchronized(queryCompleted) {
+        boolean[] queryCompleted =
+            ((DefaultQuery) queryTask.query).getQueryCompletedForMonitoring();
+        synchronized (queryCompleted) {
-            ((DefaultQuery)queryTask.query).setCanceled(true, new QueryExecutionTimeoutException(LocalizedStrings.QueryMonitor_LONG_RUNNING_QUERY_CANCELED.toLocalizedString(
-                GemFireCacheImpl.MAX_QUERY_EXECUTION_TIME)));
+            ((DefaultQuery) queryTask.query).setCanceled(true,
+                new QueryExecutionTimeoutException(
+                    LocalizedStrings.QueryMonitor_LONG_RUNNING_QUERY_CANCELED
+                        .toLocalizedString(GemFireCacheImpl.MAX_QUERY_EXECUTION_TIME)));
-        
-        logger.info(LocalizedMessage.create(LocalizedStrings.GemFireCache_LONG_RUNNING_QUERY_EXECUTION_CANCELED, 
+
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.GemFireCache_LONG_RUNNING_QUERY_EXECUTION_CANCELED,
-        if (logger.isDebugEnabled()){
+        if (logger.isDebugEnabled()) {
-      if (logger.isDebugEnabled()){
+      if (logger.isDebugEnabled()) {
-  
-  //Assumes LOW_MEMORY will only be set if query monitor is enabled
+
+  // Assumes LOW_MEMORY will only be set if query monitor is enabled
-  
+
-  
+
-    if (GemFireCacheImpl.getInstance() != null && !GemFireCacheImpl.getInstance().isQueryMonitorDisabledForLowMemory()) {
+    if (GemFireCacheImpl.getInstance() != null
+        && !GemFireCacheImpl.getInstance().isQueryMonitorDisabledForLowMemory()) {
-  
+
-      if (!queryCompleted[0]) { //cancel if query is not completed
-        String reason = LocalizedStrings.QueryMonitor_LOW_MEMORY_CANCELED_QUERY.toLocalizedString(memoryThreshold);
-        ((DefaultQuery) queryTask.query).setCanceled(true, new QueryExecutionLowMemoryException(reason));
+      if (!queryCompleted[0]) { // cancel if query is not completed
+        String reason = LocalizedStrings.QueryMonitor_LOW_MEMORY_CANCELED_QUERY
+            .toLocalizedString(memoryThreshold);
+        ((DefaultQuery) queryTask.query).setCanceled(true,
+            new QueryExecutionLowMemoryException(reason));
-  
+
-    
-    
-    QueryThreadTask(Thread queryThread, Query query, AtomicBoolean queryExecutionStatus){
+
+
+    QueryThreadTask(Thread queryThread, Query query, AtomicBoolean queryExecutionStatus) {
-    
+
-     * The query task in the queue is identified by the thread.
-     * To remove the task in the queue using the thread reference.
+     * The query task in the queue is identified by the thread. To remove the task in the queue
+     * using the thread reference.
-    public boolean equals(Object other){
+    public boolean equals(Object other) {
-      QueryThreadTask o = (QueryThreadTask)other;
+      QueryThreadTask o = (QueryThreadTask) other;
-    public String toString(){
-      return new StringBuffer()
-      .append("QueryThreadTask[StartTime:").append(this.StartTime)
-      .append(", queryThread:").append(this.queryThread)
-      .append(", threadId:").append(this.queryThread.getId())
-      .append(", query:").append(this.query.getQueryString())
-      .append(", queryExecutionStatus:").append(this.queryExecutionStatus)
-      .append("]").toString();
+    public String toString() {
+      return new StringBuffer().append("QueryThreadTask[StartTime:").append(this.StartTime)
+          .append(", queryThread:").append(this.queryThread).append(", threadId:")
+          .append(this.queryThread.getId()).append(", query:").append(this.query.getQueryString())
+          .append(", queryExecutionStatus:").append(this.queryExecutionStatus).append("]")
+          .toString();
-    
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
+
-  
+
-  
+
-   * Deserialization policy: do not deserialize (for byte array, null or cases
-   * where the value should stay serialized)
+   * Deserialization policy: do not deserialize (for byte array, null or cases where the value
+   * should stay serialized)
-  public static final byte DESERIALIZATION_POLICY_NONE = (byte)0;
+  public static final byte DESERIALIZATION_POLICY_NONE = (byte) 0;
-  public static final byte DESERIALIZATION_POLICY_LAZY = (byte)2;
-  
+  public static final byte DESERIALIZATION_POLICY_LAZY = (byte) 2;
+
-   * @param deserializationPolicy must be one of the following: DESERIALIZATION_POLICY_NONE, DESERIALIZATION_POLICY_LAZY.
+   * @param deserializationPolicy must be one of the following: DESERIALIZATION_POLICY_NONE,
+   *        DESERIALIZATION_POLICY_LAZY.
-  public static void writeValue(final byte deserializationPolicy, final Object vObj, final byte[] vBytes, final DataOutput out) throws IOException {
+  public static void writeValue(final byte deserializationPolicy, final Object vObj,
+      final byte[] vBytes, final DataOutput out) throws IOException {
-    }    
+    }
+
-    if (!oldValueIsSerialized) return DESERIALIZATION_POLICY_NONE;
+    if (!oldValueIsSerialized)
+      return DESERIALIZATION_POLICY_NONE;
-          DistributionMessage.getNumBits(DESERIALIZATION_POLICY_LAZY);
+      DistributionMessage.getNumBits(DESERIALIZATION_POLICY_LAZY);
-          (short) (1 << DESERIALIZATION_POLICY_NUMBITS);
-  public static final short DESERIALIZATION_POLICY_MASK =
-          (short) (DESERIALIZATION_POLICY_END - 1);
+      (short) (1 << DESERIALIZATION_POLICY_NUMBITS);
+  public static final short DESERIALIZATION_POLICY_MASK = (short) (DESERIALIZATION_POLICY_END - 1);
-    case DESERIALIZATION_POLICY_NONE:
-      return "NONE";
-    case DESERIALIZATION_POLICY_LAZY:
-      return "LAZY";
-    default:
-      throw new AssertionError("unknown deserialization policy");
+      case DESERIALIZATION_POLICY_NONE:
+        return "NONE";
+      case DESERIALIZATION_POLICY_LAZY:
+        return "LAZY";
+      default:
+        throw new AssertionError("unknown deserialization policy");
-    this.event = (InternalCacheEvent)event;
+    this.event = (InternalCacheEvent) event;
-   * Return true if this operation needs to check for reliable delivery. Return
-   * false if not. Currently the only case it doesn't need to be is a
-   * DestroyRegionOperation doing a "local" destroy.
+   * Return true if this operation needs to check for reliable delivery. Return false if not.
+   * Currently the only case it doesn't need to be is a DestroyRegionOperation doing a "local"
+   * destroy.
-    // thread-owned reader thread.  See bug #49565.  Also see Connection#processNIOBuffer
-//    int dominoCount = org.apache.geode.internal.tcp.Connection.getDominoCount();
-//    return dominoCount < 2;
+    // thread-owned reader thread. See bug #49565. Also see Connection#processNIOBuffer
+    // int dominoCount = org.apache.geode.internal.tcp.Connection.getDominoCount();
+    // return dominoCount < 2;
-   * returns true if multicast can be used for this operation. The default is
-   * true.
+   * returns true if multicast can be used for this operation. The default is true.
-   * returns true if adjunct messaging (piggybacking) is allowed for this
-   * operation. Region-oriented operations typically do not allow adjunct
-   * messaging, while Entry-oriented operations do. The default implementation
-   * returns true.
+   * returns true if adjunct messaging (piggybacking) is allowed for this operation. Region-oriented
+   * operations typically do not allow adjunct messaging, while Entry-oriented operations do. The
+   * default implementation returns true.
-   * returns true if this operation supports propagation of delta values instead
-   * of full changes
+   * returns true if this operation supports propagation of delta values instead of full changes
-   * Distribute a cache operation to other members of the distributed system.
-   * This method determines who the recipients are and handles careful delivery
-   * of the operation to those members.
+   * Distribute a cache operation to other members of the distributed system. This method determines
+   * who the recipients are and handles careful delivery of the operation to those members.
-    boolean reliableOp = isOperationReliable()
-        && region.requiresReliabilityCheck();
-    
+    boolean reliableOp = isOperationReliable() && region.requiresReliabilityCheck();
+
-      try { Thread.sleep(SLOW_DISTRIBUTION_MS); }
-      catch (InterruptedException e) { Thread.currentThread().interrupt(); }
+      try {
+        Thread.sleep(SLOW_DISTRIBUTION_MS);
+      } catch (InterruptedException e) {
+        Thread.currentThread().interrupt();
+      }
-    
+
-      logger.trace(LogMarker.STATE_FLUSH_OP, "dispatching operation in view version {}", viewVersion);
+      logger.trace(LogMarker.STATE_FLUSH_OP, "dispatching operation in view version {}",
+          viewVersion);
-      if(region.getDataPolicy().withPersistence()) {
+      if (region.getDataPolicy().withPersistence()) {
-        twoMessages = ((BucketRegion)region).getBucketAdvisor().adviseRequiresTwoMessages();
+        twoMessages = ((BucketRegion) region).getBucketAdvisor().adviseRequiresTwoMessages();
-      if (this.supportsAdjunctMessaging()
-          && region.isUsedForPartitionedRegionBucket()) {
-        BucketRegion br = (BucketRegion)region;
-        adjunctRecipients = getAdjunctReceivers(br, recipients,
-            twoMessages, filterRouting);
+      if (this.supportsAdjunctMessaging() && region.isUsedForPartitionedRegionBucket()) {
+        BucketRegion br = (BucketRegion) region;
+        adjunctRecipients = getAdjunctReceivers(br, recipients, twoMessages, filterRouting);
-      
-      EntryEventImpl entryEvent = event.getOperation().isEntry()? getEvent() : null;
+
+      EntryEventImpl entryEvent = event.getOperation().isEntry() ? getEvent() : null;
-        }
-        else {
-          needsOldValueInCacheOp = region.getCacheDistributionAdvisor().adviseRequiresOldValueInCacheOp();
+        } else {
+          needsOldValueInCacheOp =
+              region.getCacheDistributionAdvisor().adviseRequiresOldValueInCacheOp();
-      Set<InternalDistributedMember> cachelessNodesWithNoCacheServer = new HashSet<InternalDistributedMember>();
-      if (region.getDistributionConfig().getDeltaPropagation()
-          && this.supportsDeltaPropagation()) {
+      Set<InternalDistributedMember> cachelessNodesWithNoCacheServer =
+          new HashSet<InternalDistributedMember>();
+      if (region.getDistributionConfig().getDeltaPropagation() && this.supportsDeltaPropagation()) {
-        adviseCacheServers = region.getCacheDistributionAdvisor()
-            .adviseCacheServers();
+        adviseCacheServers = region.getCacheDistributionAdvisor().adviseCacheServers();
-      if (recipients.isEmpty() && adjunctRecipients.isEmpty()
-          && needsOldValueInCacheOp.isEmpty() && cachelessNodes.isEmpty()) {
+      if (recipients.isEmpty() && adjunctRecipients.isEmpty() && needsOldValueInCacheOp.isEmpty()
+          && cachelessNodes.isEmpty()) {
-        /** compute local client routing before waiting for an ack only for a bucket*/
+        /** compute local client routing before waiting for an ack only for a bucket */
-            && region.getSystem().getConfig().getMcastPort() != 0
-            && this.supportsMulticast();
-        ;
+            && region.getSystem().getConfig().getMcastPort() != 0 && this.supportsMulticast();;
-        // don't send to the sender of a remote-operation-message.  Those messages send
-        // their own response.  fixes bug #45973
+        // don't send to the sender of a remote-operation-message. Those messages send
+        // their own response. fixes bug #45973
-            useMulticast = false; // bug #45106: can't mcast or the sender of the one-hop op will get it
+            useMulticast = false; // bug #45106: can't mcast or the sender of the one-hop op will
+                                  // get it
-        
+
-          logger.debug("recipients for {}: {} with adjunct messages to: {}", this, recipients, adjunctRecipients);
+          logger.debug("recipients for {}: {} with adjunct messages to: {}", this, recipients,
+              adjunctRecipients);
-        
+
-          if (recipients.size() > 0 && adjunctRecipients.size() == 0
-                     && cachelessNodes.isEmpty()) { // the common case
+          if (recipients.size() > 0 && adjunctRecipients.size() == 0 && cachelessNodes.isEmpty()) { // the
+                                                                                                    // common
+                                                                                                    // case
-          } else if (!cachelessNodes.isEmpty()){
+          } else if (!cachelessNodes.isEmpty()) {
-            if ( (LOSS_SIMULATION_GENERATOR.nextInt(100) * 1.0 / 100.0) < LOSS_SIMULATION_RATIO ) {
+            if ((LOSS_SIMULATION_GENERATOR.nextInt(100) * 1.0 / 100.0) < LOSS_SIMULATION_RATIO) {
-                logger.debug("loss simulation is inhibiting message transmission to {}", recipients);
+                logger.debug("loss simulation is inhibiting message transmission to {}",
+                    recipients);
-            this.processor = new ReliableCacheReplyProcessor(
-                region.getSystem(), waitForMembers, this.departedMembers);
+            this.processor = new ReliableCacheReplyProcessor(region.getSystem(), waitForMembers,
+                this.departedMembers);
-            this.processor = new CacheOperationReplyProcessor(region
-                .getSystem(), waitForMembers);
+            this.processor = new CacheOperationReplyProcessor(region.getSystem(), waitForMembers);
-          if (r.isUsedForPartitionedRegionBucket()
-              && event.getOperation().isEntry()) {
-            PartitionMessage pm = ((EntryEventImpl)event).getPartitionMessage();
-            if (pm != null
-                && pm.getSender() != null
-                && !pm.getSender().equals(
-                    r.getDistributionManager().getDistributionManagerId())) {
+          if (r.isUsedForPartitionedRegionBucket() && event.getOperation().isEntry()) {
+            PartitionMessage pm = ((EntryEventImpl) event).getPartitionMessage();
+            if (pm != null && pm.getSender() != null
+                && !pm.getSender().equals(r.getDistributionManager().getDistributionManagerId())) {
-          if (!isPutAll && !isRemoveAll && filterRouting != null && filterRouting.hasMemberWithFilterInfo()) {
+          if (!isPutAll && !isRemoveAll && filterRouting != null
+              && filterRouting.hasMemberWithFilterInfo()) {
-              logger.debug("Setting filter information for message to {}",filterRouting);
+              logger.debug("Setting filter information for message to {}", filterRouting);
-          throw region.cache
-              .getCacheClosedException(
-                  LocalizedStrings.DistributedCacheOperation_THE_CACHE_HAS_BEEN_CLOSED
-                      .toLocalizedString(), null);
+          throw region.cache.getCacheClosedException(
+              LocalizedStrings.DistributedCacheOperation_THE_CACHE_HAS_BEEN_CLOSED
+                  .toLocalizedString(),
+              null);
-          msg.appendOldValueToMessage((EntryEventImpl)this.event);
+          msg.appendOldValueToMessage((EntryEventImpl) this.event);
-            }
-            else {
+            } else {
-            ((UpdateMessage)msg).setSendDeltaWithFullValue(false);
+            ((UpdateMessage) msg).setSendDeltaWithFullValue(false);
-          logger.debug("Failed sending ({}) to {} while processing event:{}", msg,  failures, event);
+          logger.debug("Failed sending ({}) to {} while processing event:{}", msg, failures, event);
-        Set<InternalDistributedMember> adjunctRecipientsWithNoCacheServer = new HashSet<InternalDistributedMember>();
+        Set<InternalDistributedMember> adjunctRecipientsWithNoCacheServer =
+            new HashSet<InternalDistributedMember>();
-          
+
-          adviseCacheServers = ((BucketRegion)region).getPartitionedRegion()
+          adviseCacheServers = ((BucketRegion) region).getPartitionedRegion()
-            ((BucketRegion)region).performPutAllAdjunctMessaging(
-                (DistributedPutAllOperation)this, recipients,
-                adjunctRecipients, filterRouting, this.processor);
+            ((BucketRegion) region).performPutAllAdjunctMessaging((DistributedPutAllOperation) this,
+                recipients, adjunctRecipients, filterRouting, this.processor);
-            ((BucketRegion)region).performRemoveAllAdjunctMessaging(
-                (DistributedRemoveAllOperation)this, recipients,
-                adjunctRecipients, filterRouting, this.processor);
+            ((BucketRegion) region).performRemoveAllAdjunctMessaging(
+                (DistributedRemoveAllOperation) this, recipients, adjunctRecipients, filterRouting,
+                this.processor);
-            boolean calculateDelta = adjunctRecipientsWithNoCacheServer.size() < adjunctRecipients
-                .size();
+            boolean calculateDelta =
+                adjunctRecipientsWithNoCacheServer.size() < adjunctRecipients.size();
-              ((BucketRegion)region).performAdjunctMessaging(getEvent(),
-                  recipients, adjunctRecipients, filterRouting, this.processor,
-                  calculateDelta, true);
+              ((BucketRegion) region).performAdjunctMessaging(getEvent(), recipients,
+                  adjunctRecipients, filterRouting, this.processor, calculateDelta, true);
-              ((BucketRegion)region).performAdjunctMessaging(getEvent(),
-                  recipients, adjunctRecipientsWithNoCacheServer,
-                  filterRouting, this.processor, calculateDelta, false);
+              ((BucketRegion) region).performAdjunctMessaging(getEvent(), recipients,
+                  adjunctRecipientsWithNoCacheServer, filterRouting, this.processor, calculateDelta,
+                  false);
-        /** compute local client routing before waiting for an ack only for a bucket*/
+        /** compute local client routing before waiting for an ack only for a bucket */
-      logger.info(LocalizedMessage.create(LocalizedStrings.DistributedCacheOperation_EXCEPTION_OCCURRED_WHILE_PROCESSING__0, this), e);
+      logger.info(LocalizedMessage.create(
+          LocalizedStrings.DistributedCacheOperation_EXCEPTION_OCCURRED_WHILE_PROCESSING__0, this),
+          e);
-          logger.trace(LogMarker.STATE_FLUSH_OP, "done dispatching operation in view version {}", viewVersion);
+          logger.trace(LogMarker.STATE_FLUSH_OP, "done dispatching operation in view version {}",
+              viewVersion);
-   * Cleanup destroyed events in CQ result cache for remote CQs.
-   * While maintaining the CQ results key caching. the destroy event
-   * keys are marked as destroyed instead of removing them, this is
-   * to take care, arrival of duplicate events. The key marked as
-   * destroyed are  removed after the event is placed in clients 
-   * HAQueue or distributed to the peers.
+   * Cleanup destroyed events in CQ result cache for remote CQs. While maintaining the CQ results
+   * key caching. the destroy event keys are marked as destroyed instead of removing them, this is
+   * to take care, arrival of duplicate events. The key marked as destroyed are removed after the
+   * event is placed in clients HAQueue or distributed to the peers.
-   * This is similar to CacheClientNotifier.removeDestroyTokensFromCqResultKeys()
-   * where the destroyed events for local CQs are handled.
+   * This is similar to CacheClientNotifier.removeDestroyTokensFromCqResultKeys() where the
+   * destroyed events for local CQs are handled.
-      CacheProfile cf = (CacheProfile) ((BucketRegion)getRegion()).getPartitionedRegion()
+      CacheProfile cf = (CacheProfile) ((BucketRegion) getRegion()).getPartitionedRegion()
-      if (cf == null || cf.filterProfile == null || cf.filterProfile.isLocalProfile() 
+      if (cf == null || cf.filterProfile == null || cf.filterProfile.isLocalProfile()
-        ServerCQ cq = (ServerCQ)value;
+        ServerCQ cq = (ServerCQ) value;
-        for (Map.Entry<Long, Integer> e: filterInfo.getCQs().entrySet()) {
+        for (Map.Entry<Long, Integer> e : filterInfo.getCQs().entrySet()) {
-          if (cq.getFilterID() == cqID && (e.getValue().equals(Integer.valueOf(
-              MessageType.LOCAL_DESTROY)))) {
-            cq.removeFromCqResultKeys(((EntryEventImpl)event).getKey(), true);
+          if (cq.getFilterID() == cqID
+              && (e.getValue().equals(Integer.valueOf(MessageType.LOCAL_DESTROY)))) {
+            cq.removeFromCqResultKeys(((EntryEventImpl) event).getKey(), true);
-   * @param br
-   *          the PR bucket
-   * @param cacheOpReceivers
-   *          the receivers of the CacheOperationMessage for this op
-   * @param twoMessages
-   *          PR members that are creating the bucket and need both cache op
-   *          and adjunct messages
-   * @param routing
-   *          client routing information
+   * @param br the PR bucket
+   * @param cacheOpReceivers the receivers of the CacheOperationMessage for this op
+   * @param twoMessages PR members that are creating the bucket and need both cache op and adjunct
+   *        messages
+   * @param routing client routing information
-  Set getAdjunctReceivers(BucketRegion br, Set cacheOpReceivers,
-      Set twoMessages, FilterRoutingInfo routing) {
-    return br.getAdjunctReceivers(this.getEvent(), cacheOpReceivers,
-        twoMessages, routing);
+  Set getAdjunctReceivers(BucketRegion br, Set cacheOpReceivers, Set twoMessages,
+      FilterRoutingInfo routing) {
+    return br.getAdjunctReceivers(this.getEvent(), cacheOpReceivers, twoMessages, routing);
-  protected void initProcessor(CacheOperationReplyProcessor p,
-      CacheOperationMessage msg) {
+  protected void initProcessor(CacheOperationReplyProcessor p, CacheOperationMessage msg) {
-  protected final void waitForAckIfNeeded(CacheOperationMessage msg, Map<InternalDistributedMember, PersistentMemberID> persistentIds) {
+  protected final void waitForAckIfNeeded(CacheOperationMessage msg,
+      Map<InternalDistributedMember, PersistentMemberID> persistentIds) {
-          logger.fatal(LocalizedMessage.create(LocalizedStrings.DistributedCacheOperation_WAITFORACKIFNEEDED_EXCEPTION), e);
+          logger.fatal(LocalizedMessage
+              .create(LocalizedStrings.DistributedCacheOperation_WAITFORACKIFNEEDED_EXCEPTION), e);
-  private void handleClosedMembers(
-      Set<InternalDistributedMember> closedMembers, Map<InternalDistributedMember, PersistentMemberID> persistentIds) {
-    if(persistentIds == null) {
+  private void handleClosedMembers(Set<InternalDistributedMember> closedMembers,
+      Map<InternalDistributedMember, PersistentMemberID> persistentIds) {
+    if (persistentIds == null) {
-    
-    for(InternalDistributedMember member: closedMembers) {
+
+    for (InternalDistributedMember member : closedMembers) {
-      if(persistentId != null) {
-        //Fix for bug 42142 - In order for recovery to work, 
-        //we must either
+      if (persistentId != null) {
+        // Fix for bug 42142 - In order for recovery to work,
+        // we must either
-        //or
+        // or
-        
-        //if we have started to shutdown, we don't want to mark the peer
-        //as offline, or we will think we have newer data when in fact we don't
+
+        // if we have started to shutdown, we don't want to mark the peer
+        // as offline, or we will think we have newer data when in fact we don't
-        
-        //Otherwise, mark the peer as offline, because it didn't complete
-        //the operation.
+
+        // Otherwise, mark the peer as offline, because it didn't complete
+        // the operation.
-    return (DistributedRegion)this.event.getRegion();
+    return (DistributedRegion) this.event.getRegion();
-    return (EntryEventImpl)this.event;
+    return (EntryEventImpl) this.event;
-    CacheDistributionAdvisor advisor = getRegion()
-        .getCacheDistributionAdvisor();
+    CacheDistributionAdvisor advisor = getRegion().getCacheDistributionAdvisor();
-//    if (region.isUsedForPartitionedRegionBucket()) {
-      advisor = ((BucketRegion)region).getPartitionedRegion()
-          .getCacheDistributionAdvisor();
-//    } else {
-//      advisor = ((DistributedRegion)region).getCacheDistributionAdvisor();
-//    }
+    // if (region.isUsedForPartitionedRegionBucket()) {
+    advisor = ((BucketRegion) region).getPartitionedRegion().getCacheDistributionAdvisor();
+    // } else {
+    // advisor = ((DistributedRegion)region).getCacheDistributionAdvisor();
+    // }
-      
+
-      msg.callbackArg = ((RegionEventImpl)this.event).getRawCallbackArgument();
+      msg.callbackArg = ((RegionEventImpl) this.event).getRawCallbackArgument();
-    
+
-    String cname = getClass().getName().substring(
-        getClass().getPackage().getName().length() + 1);
+    String cname = getClass().getName().substring(getClass().getPackage().getName().length() + 1);
-   * Add an internal callback which is run before the CacheOperationMessage is
-   * distributed with dm.putOutgoing.
+   * Add an internal callback which is run before the CacheOperationMessage is distributed with
+   * dm.putOutgoing.
-  public static abstract class CacheOperationMessage extends
-      SerialDistributionMessage implements MessageWithReply,
-      DirectReplyMessage, ReliableDistributionData, OldValueImporter {
+  public static abstract class CacheOperationMessage extends SerialDistributionMessage
+      implements MessageWithReply, DirectReplyMessage, ReliableDistributionData, OldValueImporter {
-    protected final static short OLD_VALUE_MASK =
-            DistributionMessage.UNRESERVED_FLAGS_START;
+    protected final static short OLD_VALUE_MASK = DistributionMessage.UNRESERVED_FLAGS_START;
-    protected final static short UNRESERVED_FLAGS_START =
-            (PERSISTENT_TAG_MASK << 1);
+    protected final static short UNRESERVED_FLAGS_START = (PERSISTENT_TAG_MASK << 1);
-    
+
-    
+
-    
+
-    
+
-    
+
+     * 
-      // notification that a reply has been received.  Most messages
+      // notification that a reply has been received. Most messages
-     * Add the cache event's old value to this message.  We must propagate
-     * the old value when the receiver is doing GII and has listeners (CQs)
-     * that require the old value.
+     * Add the cache event's old value to this message. We must propagate the old value when the
+     * receiver is doing GII and has listeners (CQs) that require the old value.
+     * 
-        @Unretained Object val = event.getRawOldValue();
-        if (val == null ||
-            val == Token.NOT_AVAILABLE ||
-            val == Token.REMOVED_PHASE1 ||
-            val == Token.REMOVED_PHASE2 ||
-            val == Token.DESTROYED ||
-            val == Token.TOMBSTONE) {
+        @Unretained
+        Object val = event.getRawOldValue();
+        if (val == null || val == Token.NOT_AVAILABLE || val == Token.REMOVED_PHASE1
+            || val == Token.REMOVED_PHASE2 || val == Token.DESTROYED || val == Token.TOMBSTONE) {
-    
+
-     * Insert this message's oldValue into the given event.  This fixes
-     * bug 38382 by propagating old values with Entry level
-     * CacheOperationMessages during initial image transfer
+     * Insert this message's oldValue into the given event. This fixes bug 38382 by propagating old
+     * values with Entry level CacheOperationMessages during initial image transfer
+     * 
-      if (cqService.isRunning()/* || event.getOperation().guaranteesOldValue()*/) {
+      if (cqService.isRunning()/* || event.getOperation().guaranteesOldValue() */) {
-            event.setSerializedOldValue((byte[])this.oldValue);
-          }
-          else {
+            event.setSerializedOldValue((byte[]) this.oldValue);
+          } else {
-     * Sets a flag in the message indicating that this message contains delta
-     * bytes.
+     * Sets a flag in the message indicating that this message contains delta bytes.
-    
+
-      GemFireCacheImpl gfc = (GemFireCacheImpl)CacheFactory.getInstance(dm.getSystem());
+      GemFireCacheImpl gfc = (GemFireCacheImpl) CacheFactory.getInstance(dm.getSystem());
-      
+
-      int oldLevel = LocalRegion.setThreadInitLevelRequirement(
-                                  LocalRegion.BEFORE_INITIAL_IMAGE); 
+      int oldLevel = LocalRegion.setThreadInitLevelRequirement(LocalRegion.BEFORE_INITIAL_IMAGE);
-        //Could this cause a deadlock, because this can block a P2P reader
-        //thread which might be needed to read the create region reply??
-        //DAN - I don't think this does anything because process called
-        //LocalRegion.setThreadInitLevelRequirement
+        // Could this cause a deadlock, because this can block a P2P reader
+        // thread which might be needed to read the create region reply??
+        // DAN - I don't think this does anything because process called
+        // LocalRegion.setThreadInitLevelRequirement
-        DistributedRegion rgn = (DistributedRegion)lclRgn;
+        DistributedRegion rgn = (DistributedRegion) lclRgn;
-        @Released InternalCacheEvent event = createEvent(rgn);
+        @Released
+        InternalCacheEvent event = createEvent(rgn);
-        boolean isEntry = event.getOperation().isEntry();
+          boolean isEntry = event.getOperation().isEntry();
-        if (isEntry && this.possibleDuplicate) {
-          ((EntryEventImpl)event).setPossibleDuplicate(true);
-          // If the state of the initial image yet to be received is unknown,
-          // we must not apply the event. It may already be reflected in the
-          // initial image state and, in fact, have been modified by subsequent
-          // events. This code path could be modified to pass the event to
-          // listeners and bridges, but it should not apply the change to the
-          // region
-          if (!rgn.isEventTrackerInitialized()
-              && (rgn.getDataPolicy().withReplication() || rgn.getDataPolicy()
-                  .withPreloaded())) {
-            if (logger.isDebugEnabled()) {
-              logger.trace(LogMarker.DM_BRIDGE_SERVER, "Ignoring possible duplicate event");
+          if (isEntry && this.possibleDuplicate) {
+            ((EntryEventImpl) event).setPossibleDuplicate(true);
+            // If the state of the initial image yet to be received is unknown,
+            // we must not apply the event. It may already be reflected in the
+            // initial image state and, in fact, have been modified by subsequent
+            // events. This code path could be modified to pass the event to
+            // listeners and bridges, but it should not apply the change to the
+            // region
+            if (!rgn.isEventTrackerInitialized()
+                && (rgn.getDataPolicy().withReplication() || rgn.getDataPolicy().withPreloaded())) {
+              if (logger.isDebugEnabled()) {
+                logger.trace(LogMarker.DM_BRIDGE_SERVER, "Ignoring possible duplicate event");
+              }
+              return;
-            return;
-        }
-        
-        sendReply = operateOnRegion(event, dm) && sendReply;
+
+          sendReply = operateOnRegion(event, dm) && sendReply;
-          logger.debug("{} Region destroyed: nothing to do",this);
+          logger.debug("{} Region destroyed: nothing to do", this);
-        if(!lclRgn.isDestroyed()) {
+        if (!lclRgn.isDestroyed()) {
-          logger.error(LocalizedMessage.create(LocalizedStrings.DistributedCacheOperation_EXCEPTION_OCCURRED_WHILE_PROCESSING__0, this), thr);
+          logger.error(LocalizedMessage.create(
+              LocalizedStrings.DistributedCacheOperation_EXCEPTION_OCCURRED_WHILE_PROCESSING__0,
+              this), thr);
-    public void sendReply(InternalDistributedMember recipient, int pId,
-        ReplyException rex, ReplySender dm) {
-      if (pId == 0 && (dm instanceof DM) && !this.directAck) {//Fix for #41871
-        // distributed-no-ack message.  Don't respond 
+    public void sendReply(InternalDistributedMember recipient, int pId, ReplyException rex,
+        ReplySender dm) {
+      if (pId == 0 && (dm instanceof DM) && !this.directAck) {// Fix for #41871
+        // distributed-no-ack message. Don't respond
-        ReplyMessage.send(recipient, pId, exception, dm, !this.appliedOperation, this.closed, false, isInternal());
+        ReplyMessage.send(recipient, pId, exception, dm, !this.appliedOperation, this.closed, false,
+            isInternal());
-    
+
-     * Ensure that a version tag has been recorded in the region's version vector.
-     * This makes note that the event has been received and processed but probably
-     * didn't affect the cache's state or it would have been recorded earlier.
+     * Ensure that a version tag has been recorded in the region's version vector. This makes note
+     * that the event has been received and processed but probably didn't affect the cache's state
+     * or it would have been recorded earlier.
-              logger.trace("recording version tag in RVV in basicProcess since it wasn't done earlier");
+              logger.trace(
+                  "recording version tag in RVV in basicProcess since it wasn't done earlier");
-    
+
-     * When an event is discarded because of an attempt to overwrite a more
-     * recent change we still need to deliver that event to clients.  Clients
-     * can then perform their own concurrency checks on the event.
+     * When an event is discarded because of an attempt to overwrite a more recent change we still
+     * need to deliver that event to clients. Clients can then perform their own concurrency checks
+     * on the event.
-    protected abstract boolean operateOnRegion(CacheEvent event,
-        DistributionManager dm) throws EntryNotFoundException;
+    protected abstract boolean operateOnRegion(CacheEvent event, DistributionManager dm)
+        throws EntryNotFoundException;
-    public void fromData(DataInput in) throws IOException,
-            ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-          vBytes = (byte[])this.oldValue;
+          vBytes = (byte[]) this.oldValue;
-        InternalDataSerializer.invokeToData(this.versionTag,out);
+        InternalDataSerializer.invokeToData(this.versionTag, out);
-    protected void setFlags(short bits, DataInput in) throws IOException,
-            ClassNotFoundException {
+    protected void setFlags(short bits, DataInput in) throws IOException, ClassNotFoundException {
-      QueuedOperation qOp = new QueuedOperation(getOperation(), null, null,
-          null, noDeserialize, this.callbackArg);
+      QueuedOperation qOp =
+          new QueuedOperation(getOperation(), null, null, null, noDeserialize, this.callbackArg);
-      int oldLevel = LocalRegion.setThreadInitLevelRequirement(LocalRegion.ANY_INIT); 
+      int oldLevel = LocalRegion.setThreadInitLevelRequirement(LocalRegion.ANY_INIT);
-  static private class ReliableCacheReplyProcessor extends
-      CacheOperationReplyProcessor {
+  static private class ReliableCacheReplyProcessor extends CacheOperationReplyProcessor {
-    public ReliableCacheReplyProcessor(InternalDistributedSystem system,
-        Collection initMembers, Set departedMembers) {
+    public ReliableCacheReplyProcessor(InternalDistributedSystem system, Collection initMembers,
+        Set departedMembers) {
-    protected synchronized void processException(DistributionMessage dmsg,
-        ReplyException ex) {
+    protected synchronized void processException(DistributionMessage dmsg, ReplyException ex) {
-      if (cause instanceof CancelException
-          || cause instanceof RegionDestroyedException) {
+      if (cause instanceof CancelException || cause instanceof RegionDestroyedException) {
-      if (dmsg instanceof ReplyMessage && ((ReplyMessage)dmsg).getIgnored()) {
+      if (dmsg instanceof ReplyMessage && ((ReplyMessage) dmsg).getIgnored()) {
-    
-    public CopyOnWriteHashSet<InternalDistributedMember> closedMembers = new CopyOnWriteHashSet<InternalDistributedMember>();
-    
-    public CacheOperationReplyProcessor(InternalDistributedSystem system,
-        Collection initMembers) {
+
+    public CopyOnWriteHashSet<InternalDistributedMember> closedMembers =
+        new CopyOnWriteHashSet<InternalDistributedMember>();
+
+    public CacheOperationReplyProcessor(InternalDistributedSystem system, Collection initMembers) {
-        ReplyMessage replyMessage =(ReplyMessage)dmsg;
+        ReplyMessage replyMessage = (ReplyMessage) dmsg;
-        if(replyMessage.getClosed()) {
+        if (replyMessage.getClosed()) {
-    }   
-    
+    }
+

UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
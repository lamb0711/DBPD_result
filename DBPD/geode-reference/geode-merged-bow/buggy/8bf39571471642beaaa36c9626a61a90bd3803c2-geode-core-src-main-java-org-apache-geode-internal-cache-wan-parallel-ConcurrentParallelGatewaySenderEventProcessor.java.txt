Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * a set of shadowPR or buckets.
- * Once the buckets/shadowPRs are assigned to a processor it should not change to avoid any event 
- * ordering issue. 
+ * a set of shadowPR or buckets. Once the buckets/shadowPRs are assigned to a processor it should
+ * not change to avoid any event ordering issue.
- * The {@link ParallelGatewaySenderQueue} should be shared among all the {@link ParallelGatewaySenderEventProcessor}s.
+ * The {@link ParallelGatewaySenderQueue} should be shared among all the
+ * {@link ParallelGatewaySenderEventProcessor}s.
-public class ConcurrentParallelGatewaySenderEventProcessor extends AbstractGatewaySenderEventProcessor {
+public class ConcurrentParallelGatewaySenderEventProcessor
+    extends AbstractGatewaySenderEventProcessor {
-  
+
-  //private final List<ConcurrentParallelGatewaySenderQueue> concurrentParallelQueues;
+  // private final List<ConcurrentParallelGatewaySenderQueue> concurrentParallelQueues;
-  
+
-    super(LoggingThreadGroup.createThreadGroup("Event Processor for GatewaySender_"
-        + sender.getId()),
+    super(
+        LoggingThreadGroup.createThreadGroup("Event Processor for GatewaySender_" + sender.getId()),
-   // initializeMessageQueue(sender.getId());
-    logger.info("ConcurrentParallelGatewaySenderEventProcessor: dispatcher threads {}", sender.getDispatcherThreads());
-    
-    nDispatcher= sender.getDispatcherThreads();
+    // initializeMessageQueue(sender.getId());
+    logger.info("ConcurrentParallelGatewaySenderEventProcessor: dispatcher threads {}",
+        sender.getDispatcherThreads());
+
+    nDispatcher = sender.getDispatcherThreads();
-     * We have to divide the buckets/shadowPRs here.
-     * So that the individual processors can start with a set of events to deal with
-     * In case of shadowPR getting created it will have to attach itself to one of the 
-     * processors when they are created.
+     * We have to divide the buckets/shadowPRs here. So that the individual processors can start
+     * with a set of events to deal with In case of shadowPR getting created it will have to attach
+     * itself to one of the processors when they are created.
-    // for each of the shadowPR: 
-    // each of the processor gets : 0 .. totalNumBuckets/totalDispatcherThreads and last processor gets the remaining
+    // for each of the shadowPR:
+    // each of the processor gets : 0 .. totalNumBuckets/totalDispatcherThreads and last processor
+    // gets the remaining
-    for (LocalRegion pr : ((GemFireCacheImpl)((AbstractGatewaySender)sender)
-        .getCache()).getApplicationRegions()) {
+    for (LocalRegion pr : ((GemFireCacheImpl) ((AbstractGatewaySender) sender).getCache())
+        .getApplicationRegions()) {
-    
+
-    
-//    this.queue = parallelQueue;
+
+    // this.queue = parallelQueue;
-  
+
-      processors[i] = new ParallelGatewaySenderEventProcessor(sender,
-          targetRs, i, sender.getDispatcherThreads());
+      processors[i] = new ParallelGatewaySenderEventProcessor(sender, targetRs, i,
+          sender.getDispatcherThreads());
-   /* Set<Region> targetRs = new HashSet<Region>();
-    for (LocalRegion pr : ((GemFireCacheImpl)((ParallelGatewaySenderImpl)sender)
-        .getCache()).getApplicationRegions()) {
-      if (pr.getAllGatewaySenderIds().contains(id)) {
-        targetRs.add(pr);
-      }
-    }
-*/
-  //  this.parallelQueue = new ParallelGatewaySenderQueue(this.sender, targetRs);
-    /*if (sender.getIsHDFSQueue())
-      this.parallelQueue = new HDFSParallelGatewaySenderQueue(this.sender,
-          targetRs);
-    else
-      this.parallelQueue = new ParallelGatewaySenderQueue(this.sender, targetRs);*/
+    /*
+     * Set<Region> targetRs = new HashSet<Region>(); for (LocalRegion pr :
+     * ((GemFireCacheImpl)((ParallelGatewaySenderImpl)sender) .getCache()).getApplicationRegions())
+     * { if (pr.getAllGatewaySenderIds().contains(id)) { targetRs.add(pr); } }
+     */
+    // this.parallelQueue = new ParallelGatewaySenderQueue(this.sender, targetRs);
+    /*
+     * if (sender.getIsHDFSQueue()) this.parallelQueue = new
+     * HDFSParallelGatewaySenderQueue(this.sender, targetRs); else this.parallelQueue = new
+     * ParallelGatewaySenderQueue(this.sender, targetRs);
+     */
-  
+
-  public void enqueueEvent(EnumListenerEvent operation, EntryEvent event,
-      Object substituteValue) throws IOException, CacheException {
+  public void enqueueEvent(EnumListenerEvent operation, EntryEvent event, Object substituteValue)
+      throws IOException, CacheException {
-    //int bucketId = PartitionedRegionHelper.getHashKey((EntryOperation)event);
-    int bucketId = ((EntryEventImpl)event).getEventId().getBucketID();
-    if( bucketId < 0) {
-    	return;
+    // int bucketId = PartitionedRegionHelper.getHashKey((EntryOperation)event);
+    int bucketId = ((EntryEventImpl) event).getEventId().getBucketID();
+    if (bucketId < 0) {
+      return;
-    
-   /* if (getSender().beforeEnqueue(gatewayQueueEvent)) {
-      long start = getSender().getStatistics().startTime();
-      try {
-        this.parallelQueue.put(gatewayQueueEvent);
-      }
-      catch (InterruptedException e) {
-        e.printStackTrace();
-      } finally {
-      if (gatewayQueueEvent != null) {
-        gatewayQueueEvent.release();
-      }
-      getSender().getStatistics().endPut(start);
-    }
-    else {
-      getSender().getStatistics().incEventsFiltered();
-    }*/
+
+    /*
+     * if (getSender().beforeEnqueue(gatewayQueueEvent)) { long start =
+     * getSender().getStatistics().startTime(); try { this.parallelQueue.put(gatewayQueueEvent); }
+     * catch (InterruptedException e) { e.printStackTrace(); } finally { if (gatewayQueueEvent !=
+     * null) { gatewayQueueEvent.release(); } getSender().getStatistics().endPut(start); } else {
+     * getSender().getStatistics().incEventsFiltered(); }
+     */
-  
+
-    
-    for(int i = 0; i < this.processors.length; i++){
+
+    for (int i = 0; i < this.processors.length; i++) {
-    
+
-        if(isDebugEnabled) {
+        if (isDebugEnabled) {
-        }  
+        }
-  
+
-        while (parallelProcessor.getException() == null
-            && parallelProcessor.isStopped()) {
+        while (parallelProcessor.getException() == null && parallelProcessor.isStopped()) {
-                  .toLocalizedString(new Object[] { this.getId(),
-                      ex.getMessage() }), ex.getCause());
+                  .toLocalizedString(new Object[] {this.getId(), ex.getMessage()}),
+              ex.getCause());
-  
+
-      for(Future<Boolean> f: futures) {
+      for (Future<Boolean> f : futures) {
-            logger.debug("ConcurrentParallelGatewaySenderEventProcessor: {} stopped dispatching: {}",
+            logger.debug(
+                "ConcurrentParallelGatewaySenderEventProcessor: {} stopped dispatching: {}",
-          logger.warn(LocalizedMessage.create(LocalizedStrings.GatewaySender_0_CAUGHT_EXCEPTION_WHILE_STOPPING_1, sender), e.getCause());
+          logger.warn(
+              LocalizedMessage.create(
+                  LocalizedStrings.GatewaySender_0_CAUGHT_EXCEPTION_WHILE_STOPPING_1, sender),
+              e.getCause());
-    
+
-  
+
-  
+
-  public void pauseDispatching(){
+  public void pauseDispatching() {
-  
+
-  	for (ParallelGatewaySenderEventProcessor parallelProcessor : this.processors) {
+    for (ParallelGatewaySenderEventProcessor parallelProcessor : this.processors) {
-   // super.waitForDispatcherToPause();
+    // super.waitForDispatcherToPause();
-  
+
-  
+
-    List<ParallelGatewaySenderEventProcessor> l = new LinkedList<ParallelGatewaySenderEventProcessor>();
+    List<ParallelGatewaySenderEventProcessor> l =
+        new LinkedList<ParallelGatewaySenderEventProcessor>();
-/*
-  public List<ConcurrentParallelGatewaySenderQueue> getConcurrentParallelQueues() {
-    return concurrentParallelQueues;
-  }*/
-     
+  /*
+   * public List<ConcurrentParallelGatewaySenderQueue> getConcurrentParallelQueues() { return
+   * concurrentParallelQueues; }
+   */
+
- /* public Set<PartitionedRegion> getRegions() {
-   return ((ParallelGatewaySenderQueue)(processors[0].getQueue())).getRegions();
-  }
- 
-  public int localSize() {
-    return ((ParallelGatewaySenderQueue)(processors[0].getQueue())).localSize();
-  }*/
- 
+  /*
+   * public Set<PartitionedRegion> getRegions() { return
+   * ((ParallelGatewaySenderQueue)(processors[0].getQueue())).getRegions(); }
+   * 
+   * public int localSize() { return
+   * ((ParallelGatewaySenderQueue)(processors[0].getQueue())).localSize(); }
+   */
+
-    return this.processors[0].getDispatcher();//Suranjan is that fine??
+    return this.processors[0].getDispatcher();// Suranjan is that fine??
-    
+

UPD66 UPD66 UPD66 DEL66
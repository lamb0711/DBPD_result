GEODE-77: improvements in handling loss of coordinator

1) Locator join-timeout has been bumped from 17 sec to 24.  This allows it to join in spite of the loss of the current coordinator and several backup coordinators.

2) Join responses are now sent after "prepare for view" messages so that other members have some knowledge of the new members before they are allowed into the system.  If the coordinator dies before completing preparation the new coordinator will find this prepared view and now adds its new members to its own membership view.

3) We no longer clear the collection of already-tried potential-coordinators when a new view is processed during startup.  Since join-requests have already been sent to these addresses there is no point in trying them again.

4) The coordinator now periodically sends out the current view to members and to crashed members of the last view using unreliable messaging.  This helps get rid of rogue processes & is similar to what we did with the view-sync JGroups protocol in GemFire.  I new method for unreliable message transmission to Messenger for this purpose.  This keeps JGroups UNICAST3 protocol from recreating a retransmission table entry for the old, crashed, members who would reject the old sequence numbers generated by the new table entry and never dispatch the messages.

5) Removal requests are now processed in the ViewCreator after all other requests have been processed.  This prevents a member from being kicked out when we've already received a shutdown message from that member.

6) Several new unit tests

-  private View jgView;
-  
-  private boolean playingDead;
-
+  private byte[] serializedNetMember;
+  
-    this.jgView = jgv;
-    playingDead = true;
-    playingDead = false;
-  public Set<InternalDistributedMember> send(DistributionMessage msg) {
+  public Set<InternalDistributedMember> sendUnreliably(DistributionMessage msg) {
+    return send(msg, false);
+  }
+  @Override
+  public Set<InternalDistributedMember> send(DistributionMessage msg) {
+    return send(msg, true);
+  }
+    
+  public Set<InternalDistributedMember> send(DistributionMessage msg, boolean reliably) {
+      
+        if (!reliably) {
+          jmsg.setFlag(Message.Flag.NO_RELIABILITY);
+        }
+            if (!reliably) {
+              jmsg.setFlag(Message.Flag.NO_RELIABILITY);
+            }

MOV23 MOV31 INS31 INS31 INS31 INS5 MOV78 INS83 INS39 INS42 INS8 MOV78 MOV83 MOV39 UPD42 MOV42 INS8 INS78 INS83 INS74 INS42 INS44 MOV8 MOV78 INS74 INS42 INS44 INS44 INS39 INS85 UPD42 INS42 INS43 INS43 INS43 INS42 INS41 INS43 INS43 INS43 INS42 INS41 INS39 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS9 INS42 INS42 INS9 INS25 INS38 INS8 INS42 INS21 INS25 INS32 INS38 INS8 INS42 INS42 INS40 INS42 INS21 INS32 INS42 INS42 INS40 DEL42 DEL43 DEL83 DEL39 DEL42 DEL59 DEL23 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL31 DEL42 DEL9 DEL7 DEL21 DEL39 DEL42 DEL42 DEL9 DEL7 DEL21
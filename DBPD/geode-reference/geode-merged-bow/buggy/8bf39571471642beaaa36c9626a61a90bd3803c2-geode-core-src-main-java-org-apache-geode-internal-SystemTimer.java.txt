Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Instances of this class are like {@link Timer}, but are associated
- * with a "swarm", which can be cancelled as a group with 
- * {@link #cancelSwarm(Object)}.
+ * Instances of this class are like {@link Timer}, but are associated with a "swarm", which can be
+ * cancelled as a group with {@link #cancelSwarm(Object)}.
- * TODO -- with Java 1.5, this will be a template type so that the swarm's
- * class can be specified.
+ *      TODO -- with Java 1.5, this will be a template type so that the swarm's class can be
+ *      specified.
-  
-  final static private boolean isIBM = "IBM Corporation".equals(System.getProperty("java.vm.vendor"));
+
+  final static private boolean isIBM =
+      "IBM Corporation".equals(System.getProperty("java.vm.vendor"));
-//  private static final boolean DEBUG = true;
+  // private static final boolean DEBUG = true;
-  
+
-  
+
-  
+
-//    sb.append("; timer = " + timer);
+    // sb.append("; timer = " + timer);
-  
+
-  
+
-   * Add the given timer is in the given swarm.  Used only by constructors.
+   * Add the given timer is in the given swarm. Used only by constructors.
-      swarmSet = (ArrayList)allSwarms.get(swarm);
+      swarmSet = (ArrayList) allSwarms.get(swarm);
-    
+
-  
+
-  
+
-   * Interval, in milliseconds, to sweep all swarms, measured from when
-   * the last sweep finished
+   * Interval, in milliseconds, to sweep all swarms, measured from when the last sweep finished
-  
+
-   * Manually garbage collect {@link #allSwarms}, if it hasn't happened
-   * in a while.
+   * Manually garbage collect {@link #allSwarms}, if it hasn't happened in a while.
-        Map.Entry entry = (Map.Entry)it.next();
-        ArrayList swarm = (ArrayList)entry.getValue();
+        Map.Entry entry = (Map.Entry) it.next();
+        ArrayList swarm = (ArrayList) entry.getValue();
-            WeakReference wr = (WeakReference)it2.next();
-            SystemTimer st = (SystemTimer)wr.get();
+            WeakReference wr = (WeakReference) it2.next();
+            SystemTimer st = (SystemTimer) wr.get();
-           it.remove(); 
-           if (isDebugEnabled) {
-             logger.trace("SystemTimer#sweepAllSwarms: removed unused swarm {}", entry.getKey());
-           }
+            it.remove();
+            if (isDebugEnabled) {
+              logger.trace("SystemTimer#sweepAllSwarms: removed unused swarm {}", entry.getKey());
+            }
-    
-    // Collect time at END of sweep.  It means an extra call to the system
+
+    // Collect time at END of sweep. It means an extra call to the system
-  
+
+   * 
-      ArrayList swarmSet = (ArrayList)allSwarms.get(t.swarm);
+      ArrayList swarmSet = (ArrayList) allSwarms.get(t.swarm);
-      
+
-          WeakReference ref = (WeakReference)it.next();
-          SystemTimer t2 = (SystemTimer)ref.get();
-          if (t2 == null) { 
+          WeakReference ref = (WeakReference) it.next();
+          SystemTimer t2 = (SystemTimer) ref.get();
+          if (t2 == null) {
-        
-        // While we're here, if the swarm has gone to zero size, 
+
+        // While we're here, if the swarm has gone to zero size,
-    
+
-  
+
+   * 
-      swarmSet = (ArrayList)allSwarms.get(swarm);
+      swarmSet = (ArrayList) allSwarms.get(swarm);
-    
+
-        WeakReference wr = (WeakReference)it.next();
-        SystemTimer st = (SystemTimer)wr.get();
-//        it.remove();  Not necessary, we're emptying the list...
+        WeakReference wr = (WeakReference) it.next();
+        SystemTimer st = (SystemTimer) wr.get();
+        // it.remove(); Not necessary, we're emptying the list...
-    
+
-  
-  // This creates a non-daemon timer thread.  We don't EVER do this...
-//  /**
-//   * @see Timer#Timer()
-//   * 
-//   * @param swarm the swarm this timer belongs to
-//   */
-//  public SystemTimer(DistributedSystem swarm) {
-//    this.timer = new Timer();
-//    this.swarm = swarm;
-//    addToSwarm(swarm, this);
-//  }
+
+  // This creates a non-daemon timer thread. We don't EVER do this...
+  // /**
+  // * @see Timer#Timer()
+  // *
+  // * @param swarm the swarm this timer belongs to
+  // */
+  // public SystemTimer(DistributedSystem swarm) {
+  // this.timer = new Timer();
+  // this.swarm = swarm;
+  // addToSwarm(swarm, this);
+  // }
-   * @param isDaemon whether the timer is a daemon.  Must be true for GemFire use.
+   * @param isDaemon whether the timer is a daemon. Must be true for GemFire use.
-    Assert.assertTrue(swarm instanceof InternalDistributedSystem, 
+    Assert.assertTrue(swarm instanceof InternalDistributedSystem,
-   * @param isDaemon whether the timer is a daemon.  Must be true for GemFire use.
+   * @param isDaemon whether the timer is a daemon. Must be true for GemFire use.
-    Assert.assertTrue(swarm instanceof InternalDistributedSystem, 
+    Assert.assertTrue(swarm instanceof InternalDistributedSystem,
-  
+
-      logger.trace("SystemTimer#schedule (long): {}: expect task {} to fire around {}", this, task, sdf.format(tilt));
+      logger.trace("SystemTimer#schedule (long): {}: expect task {} to fire around {}", this, task,
+          sdf.format(tilt));
-      logger.trace("SystemTimer#schedule (Date): {}: expect task {} to fire around {}", this, task, sdf.format(time));
+      logger.trace("SystemTimer#schedule (Date): {}: expect task {} to fire around {}", this, task,
+          sdf.format(time));
-//  /**
-//   * @see Timer#schedule(TimerTask, long, long)
-//   */
-//  public void schedule(SystemTimerTask task, long delay, long period) {
-//    // TODO add debug statement
-//    checkCancelled();
-//    timer.schedule(task, delay, period);
-//  }
+  // /**
+  // * @see Timer#schedule(TimerTask, long, long)
+  // */
+  // public void schedule(SystemTimerTask task, long delay, long period) {
+  // // TODO add debug statement
+  // checkCancelled();
+  // timer.schedule(task, delay, period);
+  // }
-//  /**
-//   * @see Timer#schedule(TimerTask, Date, long) 
-//   */
-//  public void schedule(SystemTimerTask task, Date firstTime, long period) {
-//    // TODO add debug statement
-//    checkCancelled();
-//    timer.schedule(task, firstTime, period);
-//  }
+  // /**
+  // * @see Timer#schedule(TimerTask, Date, long)
+  // */
+  // public void schedule(SystemTimerTask task, Date firstTime, long period) {
+  // // TODO add debug statement
+  // checkCancelled();
+  // timer.schedule(task, firstTime, period);
+  // }
-//  /**
-//   * @see Timer#scheduleAtFixedRate(TimerTask, Date, long)
-//   */
-//  public void scheduleAtFixedRate(SystemTimerTask task, Date firstTime,
-//                                  long period) {
-//    // TODO add debug statement
-//    checkCancelled();
-//    timer.scheduleAtFixedRate(task, firstTime, period);
-//  }
+  // /**
+  // * @see Timer#scheduleAtFixedRate(TimerTask, Date, long)
+  // */
+  // public void scheduleAtFixedRate(SystemTimerTask task, Date firstTime,
+  // long period) {
+  // // TODO add debug statement
+  // checkCancelled();
+  // timer.scheduleAtFixedRate(task, firstTime, period);
+  // }
-    
+
-    
+
-     * Does debug logging, catches critical errors, then delegates to
-     * {@link #run2()}
+     * Does debug logging, catches critical errors, then delegates to {@link #run2()}
-      }
-      catch (CancelException ignore) {
+      } catch (CancelException ignore) {
-      } 
-      catch (VirtualMachineError e) {
+      } catch (VirtualMachineError e) {
-      }
-      catch (Throwable t) {
+      } catch (Throwable t) {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.SystemTimer_TIMER_TASK_0_ENCOUNTERED_EXCEPTION, this), t);
+        logger.warn(LocalizedMessage
+            .create(LocalizedStrings.SystemTimer_TIMER_TASK_0_ENCOUNTERED_EXCEPTION, this), t);

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66
GEODE-831: unit test FreeListManager

* moved state from SimpleMemoryAllocatorImpl to FreeListManager
* refactored and cleaned up release/free code
* Removed ChunkType and ChunkFactory. They were no longer used by GemFire and complicated the code
* removed BATCH_SIZE; it was an expirement that was not longer used
* combined Chunk and GemFireChunk to the new ObjectChunk class

-public final class SimpleMemoryAllocatorImpl implements MemoryAllocator {
+public class SimpleMemoryAllocatorImpl implements MemoryAllocator {
-  /**
-   * How many extra allocations to do for each actual slab allocation.
-   * Is this really a good idea?
-   */
-  public static final int BATCH_SIZE = Integer.getInteger("gemfire.OFF_HEAP_BATCH_ALLOCATION_SIZE", 1);
-  /**
-   * Every allocated chunk smaller than TINY_MULTIPLE*TINY_FREE_LIST_COUNT will allocate a chunk of memory that is a multiple of this value.
-   * Sizes are always rounded up to the next multiple of this constant
-   * so internal fragmentation will be limited to TINY_MULTIPLE-1 bytes per allocation
-   * and on average will be TINY_MULTIPLE/2 given a random distribution of size requests.
-   * This does not account for the additional internal fragmentation caused by the off-heap header
-   * which currently is always 8 bytes.
-   */
-  public final static int TINY_MULTIPLE = Integer.getInteger("gemfire.OFF_HEAP_ALIGNMENT", 8);
-  /**
-   * Number of free lists to keep for tiny allocations.
-   */
-  public final static int TINY_FREE_LIST_COUNT = Integer.getInteger("gemfire.OFF_HEAP_FREE_LIST_COUNT", 16384);
-  public final static int MAX_TINY = TINY_MULTIPLE*TINY_FREE_LIST_COUNT;
-  /**
-   * How many unused bytes are allowed in a huge memory allocation.
-   */
-  public final static int HUGE_MULTIPLE = 256;
+  private volatile OffHeapMemoryStats stats;
-  volatile OffHeapMemoryStats stats;
+  private volatile OutOfOffHeapMemoryListener ooohml;
-  volatile OutOfOffHeapMemoryListener ooohml;
-  
-  /** The MemoryChunks that this allocator is managing by allocating smaller chunks of them.
-   * The contents of this array never change.
-   */
-  private final UnsafeMemoryChunk[] slabs;
-  private final long totalSlabSize;
-  private final int largestSlab;
-  
+  OutOfOffHeapMemoryListener getOutOfOffHeapMemoryListener() {
+    return this.ooohml;
+  }
+
-  final ChunkFactory chunkFactory;
-        null, TINY_MULTIPLE, BATCH_SIZE, TINY_FREE_LIST_COUNT, HUGE_MULTIPLE, 
-        new UnsafeMemoryChunk.Factory() {
+        null, new AddressableMemoryChunkFactory() {
-      public UnsafeMemoryChunk create(int size) {
+      public AddressableMemoryChunk create(int size) {
-      UnsafeMemoryChunk[] slabs, int tinyMultiple, int batchSize, int tinyFreeListCount, int hugeMultiple,
-      UnsafeMemoryChunk.Factory memChunkFactory) {
+      AddressableMemoryChunk[] slabs, AddressableMemoryChunkFactory memChunkFactory) {
-        lw.config("Reusing " + result.getTotalMemory() + " bytes of off-heap memory. The maximum size of a single off-heap object is " + result.largestSlab + " bytes.");
+        lw.config("Reusing " + result.getTotalMemory() + " bytes of off-heap memory. The maximum size of a single off-heap object is " + result.freeList.getLargestSlabSize() + " bytes.");
-      result = new SimpleMemoryAllocatorImpl(ooohml, stats, slabs, tinyMultiple, batchSize, tinyFreeListCount, hugeMultiple);
+      result = new SimpleMemoryAllocatorImpl(ooohml, stats, slabs);
-  // for unit tests
-  static SimpleMemoryAllocatorImpl create(OutOfOffHeapMemoryListener ooohml, OffHeapMemoryStats stats, LogWriter lw, 
-      int slabCount, long offHeapMemorySize, long maxSlabSize, UnsafeMemoryChunk.Factory memChunkFactory) {
+  static SimpleMemoryAllocatorImpl createForUnitTest(OutOfOffHeapMemoryListener ooohml, OffHeapMemoryStats stats, LogWriter lw, 
+      int slabCount, long offHeapMemorySize, long maxSlabSize, AddressableMemoryChunkFactory memChunkFactory) {
-        null, TINY_MULTIPLE, BATCH_SIZE, TINY_FREE_LIST_COUNT, HUGE_MULTIPLE, memChunkFactory);
+        null, memChunkFactory);
-  // for unit tests
-  public static SimpleMemoryAllocatorImpl create(OutOfOffHeapMemoryListener oooml, OffHeapMemoryStats stats, UnsafeMemoryChunk[] slabs) {
-    return create(oooml, stats, slabs, TINY_MULTIPLE, BATCH_SIZE, TINY_FREE_LIST_COUNT, HUGE_MULTIPLE);
-  }
-  // for unit tests
-  static SimpleMemoryAllocatorImpl create(OutOfOffHeapMemoryListener oooml, OffHeapMemoryStats stats, UnsafeMemoryChunk[] slabs,
-      int tinyMultiple, int batchSize, int tinyFreeListCount, int hugeMultiple) {
+  public static SimpleMemoryAllocatorImpl createForUnitTest(OutOfOffHeapMemoryListener oooml, OffHeapMemoryStats stats, AddressableMemoryChunk[] slabs) {
-    return create(oooml, stats, null, slabCount, offHeapMemorySize, maxSlabSize, slabs, tinyMultiple, batchSize, tinyFreeListCount, hugeMultiple, null);
+    return create(oooml, stats, null, slabCount, offHeapMemorySize, maxSlabSize, slabs, null);
-  private void reuse(OutOfOffHeapMemoryListener oooml, LogWriter lw, OffHeapMemoryStats newStats, long offHeapMemorySize, UnsafeMemoryChunk[] slabs) {
+  private void reuse(OutOfOffHeapMemoryListener oooml, LogWriter lw, OffHeapMemoryStats newStats, long offHeapMemorySize, AddressableMemoryChunk[] slabs) {
-    if (slabs != null) {
-      // this will only happen in unit tests
-      if (slabs != this.slabs) {
-        // If the unit test gave us a different array
-        // of slabs then something is wrong because we
-        // are trying to reuse the old already allocated
-        // array which means that the new one will never
-        // be used. Note that this code does not bother
-        // comparing the contents of the arrays.
-        throw new IllegalStateException("attempted to reuse existing off-heap memory even though new off-heap memory was allocated");
-      }
+    if (!this.freeList.okToReuse(slabs)) {
+      throw new IllegalStateException("attempted to reuse existing off-heap memory even though new off-heap memory was allocated");
-  private SimpleMemoryAllocatorImpl(final OutOfOffHeapMemoryListener oooml, final OffHeapMemoryStats stats, final UnsafeMemoryChunk[] slabs,
-      int tinyMultiple, int batchSize, int tinyFreeListCount, int hugeMultiple) {
+  private SimpleMemoryAllocatorImpl(final OutOfOffHeapMemoryListener oooml, final OffHeapMemoryStats stats, final AddressableMemoryChunk[] slabs) {
-    if (tinyMultiple <= 0 || (tinyMultiple & 3) != 0) {
-      throw new IllegalStateException("gemfire.OFF_HEAP_ALIGNMENT must be a multiple of 8.");
-    }
-    if (tinyMultiple > 256) {
-      // this restriction exists because of the dataSize field in the object header.
-      throw new IllegalStateException("gemfire.OFF_HEAP_ALIGNMENT must be <= 256 and a multiple of 8.");
-    }
-    if (batchSize <= 0) {
-      throw new IllegalStateException("gemfire.OFF_HEAP_BATCH_ALLOCATION_SIZE must be >= 1.");
-    }
-    if (tinyFreeListCount <= 0) {
-      throw new IllegalStateException("gemfire.OFF_HEAP_FREE_LIST_COUNT must be >= 1.");
-    }
-    if (hugeMultiple > 256 || hugeMultiple < 0) {
-      // this restriction exists because of the dataSize field in the object header.
-      throw new IllegalStateException("HUGE_MULTIPLE must be >= 0 and <= 256 but it was " + hugeMultiple);
-    }
-    this.slabs = slabs;
-    this.chunkFactory = new GemFireChunkFactory();
-    
+
-    largestSlab = slabs[0].getSize();
-    this.stats.setLargestFragment(largestSlab);
-    long total = 0;
-    for (int i=0; i < slabs.length; i++) {
-      //debugLog("slab"+i + " @" + Long.toHexString(slabs[i].getMemoryAddress()), false);
-      //UnsafeMemoryChunk.clearAbsolute(slabs[i].getMemoryAddress(), slabs[i].getSize()); // HACK to see what this does to bug 47883
-      total += slabs[i].getSize();
-    }
-    totalSlabSize = total;
-    this.stats.incMaxMemory(this.totalSlabSize);
-    this.stats.incFreeMemory(this.totalSlabSize);
+    this.stats.setLargestFragment(slabs[0].getSize());
-    this.freeList = new FreeListManager(this);
+    this.freeList = new FreeListManager(this, slabs);
+
+    this.stats.incMaxMemory(this.freeList.getTotalMemory());
+    this.stats.incFreeMemory(this.freeList.getTotalMemory());
-  public List<Chunk> getLostChunks() {
-    List<Chunk> liveChunks = this.freeList.getLiveChunks();
-    List<Chunk> regionChunks = getRegionLiveChunks();
-    Set<Chunk> liveChunksSet = new HashSet<>(liveChunks);
-    Set<Chunk> regionChunksSet = new HashSet<>(regionChunks);
+  public List<ObjectChunk> getLostChunks() {
+    List<ObjectChunk> liveChunks = this.freeList.getLiveChunks();
+    List<ObjectChunk> regionChunks = getRegionLiveChunks();
+    Set<ObjectChunk> liveChunksSet = new HashSet<>(liveChunks);
+    Set<ObjectChunk> regionChunksSet = new HashSet<>(regionChunks);
-    return new ArrayList<Chunk>(liveChunksSet);
+    return new ArrayList<ObjectChunk>(liveChunksSet);
-  private List<Chunk> getRegionLiveChunks() {
-    ArrayList<Chunk> result = new ArrayList<Chunk>();
+  private List<ObjectChunk> getRegionLiveChunks() {
+    ArrayList<ObjectChunk> result = new ArrayList<ObjectChunk>();
-  private void getRegionLiveChunks(Region<?,?> r, List<Chunk> result) {
+  private void getRegionLiveChunks(Region<?,?> r, List<ObjectChunk> result) {
-  private void basicGetRegionLiveChunks(LocalRegion r, List<Chunk> result) {
+  private void basicGetRegionLiveChunks(LocalRegion r, List<ObjectChunk> result) {
-        if (value instanceof Chunk) {
-          result.add((Chunk) value);
+        if (value instanceof ObjectChunk) {
+          result.add((ObjectChunk) value);
-  @Override
-  public MemoryChunk allocate(int size, ChunkType chunkType) {
-    //System.out.println("allocating " + size);
-    Chunk result = this.freeList.allocate(size, chunkType);
-    //("allocated off heap object of size " + size + " @" + Long.toHexString(result.getMemoryAddress()), true);
+  private ObjectChunk allocateChunk(int size) {
+    ObjectChunk result = this.freeList.allocate(size);
+    int resultSize = result.getSize();
+    stats.incObjects(1);
+    stats.incUsedMemory(resultSize);
+    stats.incFreeMemory(-resultSize);
+    notifyListeners();
+  @Override
+  public MemoryChunk allocate(int size) {
+    //System.out.println("allocating " + size);
+    ObjectChunk result = allocateChunk(size);
+    //("allocated off heap object of size " + size + " @" + Long.toHexString(result.getMemoryAddress()), true);
+    return result;
+  }
+  
-  public StoredObject allocateAndInitialize(byte[] v, boolean isSerialized, boolean isCompressed, ChunkType chunkType) {
+  public StoredObject allocateAndInitialize(byte[] v, boolean isSerialized, boolean isCompressed) {
-    if (chunkType == null) {
-      chunkType = GemFireChunk.TYPE;
-    }
-
-    Chunk result = this.freeList.allocate(v.length, chunkType);
+    ObjectChunk result = allocateChunk(v.length);
-    if (ReferenceCountHelper.trackReferenceCounts()) {
-      ReferenceCountHelper.refCountChanged(result.getMemoryAddress(), false, 1);
-    }
-    assert result.getChunkType() == chunkType: "chunkType=" + chunkType + " getChunkType()=" + result.getChunkType();
-    return totalSlabSize;
+    return this.freeList.getTotalMemory();
-      freeSlabs(this.slabs);
+      this.freeList.freeSlabs();
-  private static void freeSlabs(final UnsafeMemoryChunk[] slabs) {
-    //debugLog("called freeSlabs", false);
-    for (int i=0; i < slabs.length; i++) {
-      slabs[i].release();
-    }
-  }
-  
-  void freeChunk(long addr) {
-    this.freeList.free(addr);
-  }
-  
-  protected UnsafeMemoryChunk[] getSlabs() {
-    return this.slabs;
+  FreeListManager getFreeListManager() {
+    return this.freeList;
-    for (int i=0; i < this.slabs.length; i++) {
-      UnsafeMemoryChunk slab = this.slabs[i];
-      long slabAddr = slab.getMemoryAddress();
-      if (addr >= slabAddr) {
-        if (addr < slabAddr + slab.getSize()) {
-          return i;
-        }
-      }
-    }
-    throw new IllegalStateException("could not find a slab for addr " + addr);
+    return this.freeList.findSlab(addr);
-  public ChunkFactory getChunkFactory() {
-    return this.chunkFactory;
-  }
-
-        for (int i=0; i < ma.slabs.length; i++) {
-          long startAddr = ma.slabs[i].getMemoryAddress();
-          long endAddr = startAddr + ma.slabs[i].getSize();
-          sb.append("[").append(Long.toString(startAddr, 16)).append("..").append(Long.toString(endAddr, 16)).append("] ");
-        }
-      }
+        ma.freeList.getSlabDescriptions(sb);
+     }
-        for (int i=0; i < ma.slabs.length; i++) {
-          if (ma.slabs[i].getMemoryAddress() <= addr && addr < (ma.slabs[i].getMemoryAddress() + ma.slabs[i].getSize())) {
-            // validate addr + size is within the same slab
-            if (size != -1) { // skip this check if size is -1
-              if (!(ma.slabs[i].getMemoryAddress() <= (addr+size-1) && (addr+size-1) < (ma.slabs[i].getMemoryAddress() + ma.slabs[i].getSize()))) {
-                throw new IllegalStateException(" address 0x" + Long.toString(addr+size-1, 16) + " does not address the original slab memory");
-              }
-            }
-            return;
-          }
+        if (!ma.freeList.validateAddressAndSizeWithinSlab(addr, size)) {
+          throw new IllegalStateException(" address 0x" + Long.toString(addr, 16) + " does not address the original slab memory");
-        throw new IllegalStateException(" address 0x" + Long.toString(addr, 16) + " does not address the original slab memory");
-    List<Chunk> liveChunks = this.freeList.getLiveChunks();
-    List<Chunk> regionChunks = getRegionLiveChunks();
+    List<ObjectChunk> liveChunks = this.freeList.getLiveChunks();
+    List<ObjectChunk> regionChunks = getRegionLiveChunks();
-    for (Chunk chunk: liveChunks) {
+    for (ObjectChunk chunk: liveChunks) {
-
-  /*
-   * Set this to "true" to perform data integrity checks on allocated and reused Chunks.  This may clobber 
-   * performance so turn on only when necessary.
-   */
-  final boolean validateMemoryWithFill = Boolean.getBoolean("gemfire.validateOffHeapWithFill");

MOV31 MOV31 INS31 INS83 INS83 INS43 INS42 INS8 UPD42 INS83 UPD42 UPD83 INS42 MOV44 MOV44 INS74 UPD74 MOV74 INS43 INS42 INS43 UPD42 MOV8 INS8 UPD42 MOV42 INS41 UPD5 UPD43 UPD43 UPD5 UPD5 MOV25 INS83 UPD5 MOV25 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 INS21 INS21 MOV43 INS43 UPD43 UPD74 MOV74 UPD74 MOV74 UPD42 MOV42 UPD42 INS60 INS60 INS21 MOV25 INS41 INS60 INS60 UPD42 MOV42 INS41 MOV41 INS22 UPD43 INS42 INS42 UPD43 UPD43 INS38 UPD43 INS32 INS32 INS32 INS42 INS74 INS74 INS74 UPD74 MOV74 INS14 UPD42 UPD74 UPD43 UPD43 INS43 INS59 INS39 INS59 INS32 INS32 INS42 UPD43 MOV43 INS59 UPD43 MOV43 INS59 INS32 MOV22 MOV32 MOV8 UPD74 MOV74 UPD74 MOV74 INS52 INS42 UPD42 UPD42 UPD42 INS32 UPD42 MOV22 INS42 MOV32 INS22 MOV22 UPD42 MOV42 INS32 MOV22 UPD42 MOV42 INS32 MOV43 INS43 MOV43 INS43 MOV43 INS43 UPD43 INS74 INS42 UPD43 MOV14 UPD42 UPD42 UPD42 MOV42 INS42 INS32 UPD42 MOV42 INS32 INS42 INS42 INS34 INS42 UPD42 INS42 INS42 INS38 INS42 UPD42 MOV42 INS32 UPD42 MOV42 INS32 INS22 INS42 UPD42 UPD42 MOV60 UPD43 UPD43 UPD43 UPD43 INS22 INS42 INS42 INS52 INS42 INS42 INS22 UPD42 MOV42 INS22 UPD42 MOV42 INS42 INS42 INS42 UPD42 MOV43 INS43 UPD42 UPD74 MOV22 UPD42 MOV42 UPD42 MOV42 INS42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS40 INS52 INS42 MOV32 INS8 MOV27 UPD42 UPD42 UPD42 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS42 UPD43 UPD42 MOV21 INS21 UPD43 UPD42 INS32 UPD42 UPD43 INS40 UPD42 MOV42 MOV42 INS32 MOV53 UPD42 INS40 UPD42 MOV42 INS42 INS42 INS32 UPD43 INS40 INS42 UPD42 DEL83 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL45 DEL34 DEL32 DEL59 DEL23 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL45 DEL34 DEL32 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL45 DEL34 DEL32 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL27 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL43 DEL85 DEL5 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL42 DEL42 DEL42 DEL42 DEL40 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL40 DEL40 DEL42 DEL42 DEL42 DEL42 DEL40 DEL42 DEL42 DEL42 DEL42 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL42 DEL52 DEL42 DEL22 DEL27 DEL42 DEL33 DEL27 DEL8 DEL25 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL7 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL42 DEL43 DEL74 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL74 DEL14 DEL42 DEL43 DEL74 DEL42 DEL83 DEL43 DEL85 DEL5 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL34 DEL27 DEL42 DEL34 DEL27 DEL36 DEL34 DEL27 DEL27 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL42 DEL34 DEL27 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL42 DEL34 DEL27 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL42 DEL34 DEL27 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL42 DEL34 DEL27 DEL42 DEL34 DEL27 DEL27 DEL42 DEL43 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL43 DEL14 DEL7 DEL21 DEL32 DEL21 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL42 DEL2 DEL32 DEL7 DEL21 DEL8 DEL24 DEL42 DEL42 DEL7 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL44 DEL59 DEL60 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL9 DEL34 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL44 DEL42 DEL33 DEL27 DEL42 DEL40 DEL7 DEL21 DEL8 DEL25 DEL59 DEL60 DEL42 DEL32 DEL42 DEL27 DEL45 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL6 DEL42 DEL42 DEL42 DEL42 DEL52 DEL42 DEL22 DEL32 DEL83 DEL83 DEL39 DEL42 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL44 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL42 DEL32 DEL21 DEL8 DEL24 DEL8 DEL31 DEL39 DEL42 DEL39 DEL42 DEL44 DEL31 DEL83 DEL43 DEL85 DEL5 DEL42 DEL42 DEL32 DEL21 DEL52 DEL42 DEL22 DEL41 DEL8 DEL40 DEL42 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL52 DEL42 DEL22 DEL42 DEL22 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL2 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL27 DEL27 DEL8 DEL25 DEL8 DEL25 DEL8 DEL24 DEL42 DEL43 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL83 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL39 DEL42 DEL40 DEL42 DEL2 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL40 DEL42 DEL2 DEL32 DEL27 DEL59 DEL60 DEL42 DEL45 DEL32 DEL42 DEL42 DEL42 DEL42 DEL34 DEL32 DEL32 DEL42 DEL45 DEL32 DEL42 DEL42 DEL42 DEL42 DEL34 DEL32 DEL32 DEL42 DEL45 DEL32 DEL21 DEL8 DEL24 DEL8 DEL42 DEL34 DEL38 DEL27 DEL40 DEL42 DEL2 DEL32 DEL42 DEL42 DEL27 DEL34 DEL27 DEL36 DEL27 DEL42 DEL42 DEL27 DEL34 DEL27 DEL36 DEL40 DEL42 DEL2 DEL42 DEL32 DEL40 DEL42 DEL2 DEL42 DEL32 DEL27 DEL36 DEL27 DEL27 DEL36 DEL42 DEL43 DEL45 DEL42 DEL42 DEL42 DEL42 DEL27 DEL34 DEL27 DEL34 DEL32 DEL45 DEL27 DEL14 DEL53 DEL41 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL40 DEL42 DEL2 DEL42 DEL32 DEL42 DEL27 DEL42 DEL40 DEL42 DEL2 DEL42 DEL32 DEL40 DEL42 DEL2 DEL42 DEL32 DEL27 DEL36 DEL27 DEL27 DEL25 DEL8 DEL24 DEL8 DEL25 DEL8 DEL42 DEL43 DEL74 DEL83 DEL39 DEL42 DEL42 DEL42 DEL45 DEL32 DEL59 DEL23
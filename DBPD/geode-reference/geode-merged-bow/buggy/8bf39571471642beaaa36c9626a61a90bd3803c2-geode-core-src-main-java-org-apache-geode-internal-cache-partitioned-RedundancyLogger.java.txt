Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Consolidates logging during the recovery of ProxyRegionBuckets that are not hosted by this member.  This logger
- * is meant to run in its own thread and utilizes the PRHARedundancyProvider's count down latch in order to determine
- * when it is finished.
+ * Consolidates logging during the recovery of ProxyRegionBuckets that are not hosted by this
+ * member. This logger is meant to run in its own thread and utilizes the PRHARedundancyProvider's
+ * count down latch in order to determine when it is finished.
-  
+
-  private volatile boolean membershipChanged = true; 
-  
+  private volatile boolean membershipChanged = true;
+
-  
+
-  
+
+   * 
-    List<PartitionedRegion> colocatedRegions = ColocationHelper.getColocatedChildRegions(baseRegion);
+    List<PartitionedRegion> colocatedRegions =
+        ColocationHelper.getColocatedChildRegions(baseRegion);
-    if(baseRegion.getDataPolicy().withPersistence()) {
+    if (baseRegion.getDataPolicy().withPersistence()) {
-    for(PartitionedRegion region : colocatedRegions) {
-      if(region.getDataPolicy().withPersistence()) {
+    for (PartitionedRegion region : colocatedRegions) {
+      if (region.getDataPolicy().withPersistence()) {
-    
+
-    
-    
+
+
-  public void memberOnline(InternalDistributedMember member,
-      PersistentMemberID persistentID) {
+  public void memberOnline(InternalDistributedMember member, PersistentMemberID persistentID) {
-  public void memberOffline(InternalDistributedMember member,
-      PersistentMemberID persistentID) {
+  public void memberOffline(InternalDistributedMember member, PersistentMemberID persistentID) {
-  
+
-    for(RegionStatus region : regions) {
+    for (RegionStatus region : regions) {
-  
+
-    for(RegionStatus region : regions) {
+    for (RegionStatus region : regions) {
-  
-  
+
+
-   * Writes a consolidated log entry every SLEEP_PERIOD that summarizes which buckets are still waiting on persistent members
-   * for the region.
+   * Writes a consolidated log entry every SLEEP_PERIOD that summarizes which buckets are still
+   * waiting on persistent members for the region.
-    try{      
+    try {
-      while(this.allBucketsRecoveredFromDisk.getCount() > 0) {
+      while (this.allBucketsRecoveredFromDisk.getCount() > 0) {
-        Thread.sleep(sleepMillis);          
+        Thread.sleep(sleepMillis);
-        if(this.membershipChanged) {
+        if (this.membershipChanged) {
-          for(RegionStatus region : regions) {
+          for (RegionStatus region : regions) {
-      
+
-    } finally {        
+    } finally {
-       * Our job is done.  Stop listening to the bucket advisors.
+       * Our job is done. Stop listening to the bucket advisors.
-      for(RegionStatus region : regions) {
-        if(!region.loggedDoneMessage) {
+      for (RegionStatus region : regions) {
+        if (!region.loggedDoneMessage) {
-  
+
-   * Keeps track of logging a message for a single partitioned region
-   * and logging a separate message when the waiting is done for the same region
+   * Keeps track of logging a message for a single partitioned region and logging a separate message
+   * when the waiting is done for the same region
-    
+
-    
+
-    
+
-    
+
-      for(ProxyBucketRegion proxyBucket : this.bucketRegions) {
+      for (ProxyBucketRegion proxyBucket : this.bucketRegions) {
-      for(ProxyBucketRegion proxyBucket : this.bucketRegions) {
+      for (ProxyBucketRegion proxyBucket : this.bucketRegions) {
-     * Creates a temporary (and somewhat fake) PersistentMemberID for this member if 
-     * there is no DiskStore available for our region (which can happen in some
-     * colocated scenarios).
+     * Creates a temporary (and somewhat fake) PersistentMemberID for this member if there is no
+     * DiskStore available for our region (which can happen in some colocated scenarios).
-      
+
-       * A non-persistent colocated region will not have a disk store so check the leader 
-       * region if this region does not have one.
+       * A non-persistent colocated region will not have a disk store so check the leader region if
+       * this region does not have one.
-      if(region.getAttributes().getDataPolicy().withPersistence()) {
+      if (region.getAttributes().getDataPolicy().withPersistence()) {
-      } else if(ColocationHelper.getLeaderRegion(region).getAttributes().getDataPolicy().withPersistence()) {
+      } else if (ColocationHelper.getLeaderRegion(region).getAttributes().getDataPolicy()
+          .withPersistence()) {
-      
+
-       * We have a DiskStore?  Great!  Simply have it 
-       * generate the id.
+       * We have a DiskStore? Great! Simply have it generate the id.
-      if(null != diskStore) {
+      if (null != diskStore) {
-       * Bummer.  No DiskStore.  Put together a fake one (for logging only).
+       * Bummer. No DiskStore. Put together a fake one (for logging only).
-        String diskDir = System.getProperty("user.dir");      
+        String diskDir = System.getProperty("user.dir");
-        return (new PersistentMemberID(null, localHost, diskDir, name, redundancyProvider.prRegion.getCache().cacheTimeMillis(), (short) 0));    
+        return (new PersistentMemberID(null, localHost, diskDir, name,
+            redundancyProvider.prRegion.getCache().cacheTimeMillis(), (short) 0));
-    
+
-     * @param offlineOnly true if only the members which are not currently try running should be returned,
-     * false to return all members that this member is waiting for, including members which are running
-     * but not fully initialized.
+     * 
+     * @param offlineOnly true if only the members which are not currently try running should be
+     *        returned, false to return all members that this member is waiting for, including
+     *        members which are running but not fully initialized.
-      Map<PersistentMemberID, Set<Integer>> waitingForMembers = new HashMap<PersistentMemberID, Set<Integer>>();
-      
-      
-      for(ProxyBucketRegion proxyBucket : this.bucketRegions) {
+      Map<PersistentMemberID, Set<Integer>> waitingForMembers =
+          new HashMap<PersistentMemberID, Set<Integer>>();
+
+
+      for (ProxyBucketRegion proxyBucket : this.bucketRegions) {
-        
-        //Get the set of missing members from the persistence advisor
+
+        // Get the set of missing members from the persistence advisor
-        if(offlineOnly) {
+        if (offlineOnly) {
-        
-        if(missingMembers != null) {
-          for(PersistentMemberID missingMember : missingMembers) {
+
+        if (missingMembers != null) {
+          for (PersistentMemberID missingMember : missingMembers) {
-            if(buckets == null) {
+            if (buckets == null) {
-      
+
-      this.loggedDoneMessage = true;          
-      StartupStatus.startup(LocalizedStrings.CreatePersistentRegionProcessor_DONE_WAITING_FOR_BUCKET_MEMBERS, new Object[] {this.region, TransformUtils.persistentMemberIdToLogEntryTransformer.transform(this.thisMember)});
+      this.loggedDoneMessage = true;
+      StartupStatus.startup(
+          LocalizedStrings.CreatePersistentRegionProcessor_DONE_WAITING_FOR_BUCKET_MEMBERS,
+          new Object[] {this.region,
+              TransformUtils.persistentMemberIdToLogEntryTransformer.transform(this.thisMember)});
-    
+
-      Map<PersistentMemberID, Set<Integer>> allMembersToWaitFor= getMembersToWaitFor(false);
-      
-      boolean thereAreBucketsToBeRecovered = (RedundancyLogger.this.allBucketsRecoveredFromDisk.getCount() > 0);
-      
+      Map<PersistentMemberID, Set<Integer>> allMembersToWaitFor = getMembersToWaitFor(false);
+
+      boolean thereAreBucketsToBeRecovered =
+          (RedundancyLogger.this.allBucketsRecoveredFromDisk.getCount() > 0);
+
-      if(thereAreBucketsToBeRecovered && !offlineMembers.isEmpty()) {
+      if (thereAreBucketsToBeRecovered && !offlineMembers.isEmpty()) {
-        
-        TransformUtils.transform(offlineMembers.entrySet(), membersToWaitForLogEntries, TransformUtils.persistentMemberEntryToLogEntryTransformer);
-        
+
+        TransformUtils.transform(offlineMembers.entrySet(), membersToWaitForLogEntries,
+            TransformUtils.persistentMemberEntryToLogEntryTransformer);
+
-        
-        StartupStatus
-        	.startup(LocalizedStrings.CreatePersistentRegionProcessor_WAITING_FOR_OFFLINE_BUCKET_MEMBERS, 
-        		new Object[] {this.region, missingBuckets, TransformUtils.persistentMemberIdToLogEntryTransformer.transform(this.thisMember),
+
+        StartupStatus.startup(
+            LocalizedStrings.CreatePersistentRegionProcessor_WAITING_FOR_OFFLINE_BUCKET_MEMBERS,
+            new Object[] {this.region, missingBuckets,
+                TransformUtils.persistentMemberIdToLogEntryTransformer.transform(this.thisMember),
-      } 
+      }
-      else if(thereAreBucketsToBeRecovered && !allMembersToWaitFor.isEmpty()){
+      else if (thereAreBucketsToBeRecovered && !allMembersToWaitFor.isEmpty()) {
-        
-        Set<Integer> missingBuckets = getAllWaitingBuckets(allMembersToWaitFor);
-        TransformUtils.transform(allMembersToWaitFor.entrySet(), membersToWaitForLogEntries, TransformUtils.persistentMemberEntryToLogEntryTransformer);
-        StartupStatus
-        	.startup(LocalizedStrings.CreatePersistentRegionProcessor_WAITING_FOR_ONLINE_BUCKET_MEMBERS, 
-        		new Object[] {this.region, missingBuckets, TransformUtils.persistentMemberIdToLogEntryTransformer.transform(this.thisMember),
-        		membersToWaitForLogEntries});
+        Set<Integer> missingBuckets = getAllWaitingBuckets(allMembersToWaitFor);
+        TransformUtils.transform(allMembersToWaitFor.entrySet(), membersToWaitForLogEntries,
+            TransformUtils.persistentMemberEntryToLogEntryTransformer);
+
+        StartupStatus.startup(
+            LocalizedStrings.CreatePersistentRegionProcessor_WAITING_FOR_ONLINE_BUCKET_MEMBERS,
+            new Object[] {this.region, missingBuckets,
+                TransformUtils.persistentMemberIdToLogEntryTransformer.transform(this.thisMember),
+                membersToWaitForLogEntries});
-       * No online? Then log that we are done. 
+       * No online? Then log that we are done.
-      else if(!this.loggedDoneMessage) {
+      else if (!this.loggedDoneMessage) {
-    
+
-      for(Set<Integer> missingPerMember : offlineMembers.values()) {
+      for (Set<Integer> missingPerMember : offlineMembers.values()) {

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66
GEODE-5420: Protect events in HAContainer from premature modification

- Updated putInProgress boolean in HAWrapper to a counter to prevent prematurely setting ClientUpdateMessage to null when events are temporarily queued during a GII or message dispatcher initialization
- decAndRemoveFromHAContainer only removes when putInProgress counter and ref count are 0
- Refactored putEventInHARegion/putConditionallyInHAContainer to prevent overwriting an existing entry in the HAContainer.  Also reduces simplifies the code and reduces duplicated logic.
- Wrote missing basic HARegionQueue unit/integration tests, and an integration test to capture setting the ClientUpdateMessage property on HAEventWrapper to null prematurely
- Added new event tracing messages at debug logging level to help track similar issues in the future

Co-authored-by: Ryan McMahon <rmcmahon@pivotal.io>
Co-authored-by: Lynn Hughes-Godfrey <lhughesgodfrey@pivotal.io>

+        HAEventWrapper haContainerKey = null;
+
-          // bug #43609 - prevent loss of the message while in the queue
-          putEntryConditionallyIntoHAContainer((HAEventWrapper) object);
+          HAEventWrapper wrapper = (HAEventWrapper) object;
+          wrapper.incrementPutInProgressCounter();
+          if (logger.isDebugEnabled()) {
+            logger
+                .debug("Incremented PutInProgressCounter during GII queueing. Event ID hash code: "
+                    + wrapper.hashCode() + "; System ID hash code: "
+                    + System.identityHashCode(wrapper)
+                    + "; Wrapper details: " + wrapper);
+          }
+
-                // if there is no wrapped message look for it in the HA container map
-                ClientUpdateMessageImpl haContainerMessage =
-                    (ClientUpdateMessageImpl) haContainer.get(value);
-                if (haContainerMessage != null) {
-                  ((HAEventWrapper) value).setClientUpdateMessage(haContainerMessage);
-                } else {
-                  if (isDebugEnabled) {
-                    logger.debug(
-                        "{} ATTENTION: found gii queued event with null event message.  Please see bug #44852: {}",
-                        this.regionName, value);
-                  }
-                  continue;
+                if (isDebugEnabled) {
+                  logger.debug(
+                      "{} ATTENTION: found gii queued event with null event message.  Please see bug #44852: {}",
+                      this.regionName, value);
+                continue;
+
+
+            // The HAEventWrapper putInProgressCounter must be decremented because it was
+            // incremented when it was queued in giiQueue.
-              decAndRemoveFromHAContainer((HAEventWrapper) value);
+              ((HAEventWrapper) value).decrementPutInProgressCounter();
+      if (logger.isDebugEnabled()) {
+        logger.debug("Adding position " + position + " to available IDs. Region: " + regionName);
+      }
+
-   *        where expiry is aborted if this function returns false
+   *        where
+   *        expiry is aborted if this function returns false
+    if (logger.isDebugEnabled()) {
+      logger.debug("Removing position " + position + " from available IDs. Region: " + regionName);
+    }
+
+    if (logger.isDebugEnabled()) {
+      logger.debug("Removing position " + position + " from available IDs and region. Region: "
+          + this.regionName);
+    }
+
-    if (Thread.interrupted())
+    if (Thread.interrupted()) {
+    }
+
+
+
+      // It is possible for the object to be null if a queue removal
+      // occurred between getting the next available ID and getting the object
+      // from the region. If this happens, on the next iteration of this loop we will
+      // get a different available ID to process
-        // peeked a object, so add the correponding counter to thread-context
-        if (object != null) { // Is it possible for object to be null...when?
+        if (object != null) {
-            if ((HAEventWrapper) haContainer.getKey(entryHaEventWrapper) != null) {
+            if (entryHaEventWrapper == (HAEventWrapper) haContainer.getKey(entryHaEventWrapper)) {
+              if (logger.isDebugEnabled()) {
+                logger.debug("GII Update of Event ID hash code: " + entryHaEventWrapper.hashCode()
+                    + "; System ID hash code: " + System.identityHashCode(entryHaEventWrapper)
+                    + "; Wrapper details: " + entryHaEventWrapper);
+              }
-            inputHaEventWrapper.setIsRefFromHAContainer(true);
+            if (logger.isDebugEnabled()) {
+              logger.debug("GII Add of Event ID hash code: " + inputHaEventWrapper.hashCode()
+                  + "; System ID hash code: " + System.identityHashCode(inputHaEventWrapper)
+                  + "; Wrapper details: " + entryHaEventWrapper);
+            }
+      Conflatable eventInHARegion = null;
+
+
-          owningQueue.putEventInHARegion(event, position);
+          eventInHARegion = owningQueue.putEventInHARegion(event, position);
-          if (owningQueue.shouldBeConflated(event)) {
+          if (owningQueue.shouldBeConflated(eventInHARegion)) {
-            oldPosition = owningQueue.addToConflationMap(event, position);
+            oldPosition = owningQueue.addToConflationMap(eventInHARegion, position);
-        owningQueue.entryEnqueued(event);
+        owningQueue.entryEnqueued(eventInHARegion);
-            owningQueue.decAndRemoveFromHAContainer((HAEventWrapper) conflatable);
+            owningQueue.decAndRemoveFromHAContainer((HAEventWrapper) conflatable,
+                "Remove Old Conflated Entry");
-              owningQueue.decAndRemoveFromHAContainer((HAEventWrapper) event);
+
+              owningQueue.decAndRemoveFromHAContainer((HAEventWrapper) event,
+                  "Queue Removal Message");
-            owningQueue.decAndRemoveFromHAContainer((HAEventWrapper) wrapper);
+            owningQueue.decAndRemoveFromHAContainer((HAEventWrapper) wrapper, "Message Dispatcher");
-  protected void putEventInHARegion(Conflatable event, Long position) {
+  protected Conflatable putEventInHARegion(Conflatable event, Long position) {
+      HAEventWrapper haContainerKey = null;
+
-        if (inputHaEventWrapper.getIsRefFromHAContainer()) {
-          putEntryConditionallyIntoHAContainer(inputHaEventWrapper);
-        } else {
-          // This means that the haEventWrapper reference we have is not
-          // authentic, i.e. it doesn't refer to the HAEventWrapper instance
-          // in the haContainer, but to the one outside it.
-          HAEventWrapper haContainerKey = null;
-          do {
-            ClientUpdateMessageImpl haContainerEntry =
-                (ClientUpdateMessageImpl) ((HAContainerWrapper) this.haContainer)
-                    .putIfAbsent(inputHaEventWrapper, inputHaEventWrapper.getClientUpdateMessage());
-            if (haContainerEntry != null) {
-              haContainerKey = (HAEventWrapper) ((HAContainerWrapper) this.haContainer)
-                  .getKey(inputHaEventWrapper);
-              if (haContainerKey == null) {
-                continue;
-              }
-              synchronized (haContainerKey) {
-                // assert the entry is still present
-                if (((HAContainerWrapper) this.haContainer).getKey(haContainerKey) != null) {
-                  haContainerKey.incAndGetReferenceCount();
-                  addClientCQsAndInterestList(haContainerEntry, inputHaEventWrapper,
-                      this.haContainer, this.regionName);
-                  inputHaEventWrapper = haContainerKey;
-                } else {
-                  haContainerKey = null;
-                }
-              }
-            } else {
-              synchronized (inputHaEventWrapper) {
-                inputHaEventWrapper.incAndGetReferenceCount();
-                inputHaEventWrapper.setHAContainer(this.haContainer);
-                if (!inputHaEventWrapper.getPutInProgress()) {
-                  // This means that this is a GII'ed event. Hence we must
-                  // explicitly set 'clientUpdateMessage' to null.
-                  inputHaEventWrapper.setClientUpdateMessage(null);
-                }
-                inputHaEventWrapper.setIsRefFromHAContainer(true);
-              }
-              break;
-            }
-          } while (haContainerKey == null);
-        }
+        haContainerKey = putEntryConditionallyIntoHAContainer(inputHaEventWrapper);
+      } else {
+        haContainerKey = inputHaEventWrapper;
-      // Put the reference to the HAEventWrapper instance into the
-      // HA queue.
+
-        logger.debug("adding inputHaEventWrapper to HARegion at " + position + ":"
-            + inputHaEventWrapper + " for " + this.regionName);
+        logger.debug("adding haContainerKey to HARegion at " + position + ":"
+            + haContainerKey + " for " + this.regionName);
-      this.region.put(position, inputHaEventWrapper);
+      this.region.put(position, haContainerKey);
+
+      return haContainerKey;
+
+      return event;
-    // if (haEventWrapper.getPutInProgress()) {
-    // ((HAEventWrapper)entry.getKey()).setPutInProgress(true);
-    // }
-    if (clientMsg.isClientInterestedInUpdates(proxyID)) {
-      msg.addClientInterestList(proxyID, true);
-    } else if (clientMsg.isClientInterestedInInvalidates(proxyID)) {
-      msg.addClientInterestList(proxyID, false);
+    if (clientMsg != null) {
+      if (clientMsg.isClientInterestedInUpdates(proxyID)) {
+        msg.addClientInterestList(proxyID, true);
+      } else if (clientMsg.isClientInterestedInInvalidates(proxyID)) {
+        msg.addClientInterestList(proxyID, false);
+      }
-   * @param haEventWrapper An instance of {@code HAEventWrapper}
+   * @param inputHaEventWrapper An instance of {@code HAEventWrapper}
-  protected void putEntryConditionallyIntoHAContainer(HAEventWrapper haEventWrapper) {
-    if (haEventWrapper.incAndGetReferenceCount() == 1) {
-      // if (logger.isDebugEnabled()) {
-      // logger.fine("Putting event in haContainer: " + haEventWrapper);
-      // }
-      haEventWrapper.setHAContainer(HARegionQueue.this.haContainer);
-      this.haContainer.put(haEventWrapper, haEventWrapper.getClientUpdateMessage());
+  protected HAEventWrapper putEntryConditionallyIntoHAContainer(
+      HAEventWrapper inputHaEventWrapper) {
+    HAEventWrapper haContainerKey = null;
+
+    while (haContainerKey == null) {
+      ClientUpdateMessageImpl haContainerEntry =
+          (ClientUpdateMessageImpl) ((HAContainerWrapper) this.haContainer)
+              .putIfAbsent(inputHaEventWrapper, inputHaEventWrapper.getClientUpdateMessage());
+
+      if (haContainerEntry != null) {
+        haContainerKey = (HAEventWrapper) ((HAContainerWrapper) this.haContainer)
+            .getKey(inputHaEventWrapper);
+
+        // Key was already removed from the container, so continue
+        if (haContainerKey == null) {
+          continue;
+        }
+
+        synchronized (haContainerKey) {
+          // assert the entry is still present and we still have the same reference
+          if (haContainerKey == ((HAContainerWrapper) this.haContainer).getKey(haContainerKey)) {
+            haContainerKey.incAndGetReferenceCount();
+
+            addClientCQsAndInterestList(haContainerEntry, inputHaEventWrapper,
+                this.haContainer, this.regionName);
+
+            if (logger.isDebugEnabled()) {
+              logger.debug("Putting updated event in haContainer with Event ID hash code: "
+                  + haContainerKey.hashCode() + "; System ID hash code: "
+                  + System.identityHashCode(haContainerKey)
+                  + "; Wrapper details: " + haContainerKey);
+            }
+          } else {
+            haContainerKey = null;
+          }
+        }
+      } else {
+        synchronized (inputHaEventWrapper) {
+          inputHaEventWrapper.incAndGetReferenceCount();
+          inputHaEventWrapper.setHAContainer(this.haContainer);
+
+          if (!inputHaEventWrapper.getPutInProgress()) {
+            // This means that this is a GII'ed event. Hence we must
+            // explicitly set 'clientUpdateMessage' to null.
+            inputHaEventWrapper.setClientUpdateMessage(null);
+          }
+
+          if (logger.isDebugEnabled()) {
+            logger.debug("Putting new event in haContainer with Event ID hash code: "
+                + inputHaEventWrapper.hashCode()
+                + "; System ID hash code: " + System.identityHashCode(inputHaEventWrapper)
+                + "; Wrapper details: " + inputHaEventWrapper);
+          }
+        }
+
+        haContainerKey = inputHaEventWrapper;
+      }
+
+    return haContainerKey;
+
-                  HARegionQueue.this.decAndRemoveFromHAContainer((HAEventWrapper) conflatable);
+                  HARegionQueue.this
+                      .decAndRemoveFromHAContainer((HAEventWrapper) conflatable, "Destroy");
-        });
+        }, "HA Region Cleanup for " + regionName);
-        decAndRemoveFromHAContainer(wrapper);
+        decAndRemoveFromHAContainer(wrapper, "GetAndRemoveFromHAContainer");
-   * IMPORTANT: <br>
-   * The wrapper passed here must be the authentic wrapper, i.e. it must be the one referred by the
-   * HARegion underlying this queue. <br>
-   * Decrements wrapper's reference count by one. If the decremented ref count is zero and put is
-   * not in progress, removes the entry from the haContainer.
+   * Decrements reference count for the wrapper in the container by one. If the decremented ref
+   * count is zero and put is not in progress, removes the entry from the haContainer.
-    if (wrapper.decAndGetReferenceCount() == 0L && !wrapper.getPutInProgress()) {
-      synchronized (wrapper) {
-        if (wrapper.getReferenceCount() == 0L) {
+    decAndRemoveFromHAContainer(wrapper, "");
+  }
+
+  public void decAndRemoveFromHAContainer(HAEventWrapper wrapper, String caller) {
+    boolean decAndRemovePerformed = false;
+
+    while (!decAndRemovePerformed) {
+      HAEventWrapper haContainerKey =
+          (HAEventWrapper) ((HAContainerWrapper) haContainer).getKey(wrapper);
+
+      if (haContainerKey == null) {
+        break;
+      }
+
+      synchronized (haContainerKey) {
+        if (haContainerKey == (HAEventWrapper) ((HAContainerWrapper) haContainer).getKey(wrapper)) {
-            logger.debug("Removing event from {}: {}", this.region.getFullPath(),
-                wrapper.getEventId());
+            logger.debug(caller + " decremented Event ID hash code: " + haContainerKey.hashCode()
+                + "; System ID hash code: " + System.identityHashCode(haContainerKey)
+                + "; Wrapper details: " + haContainerKey);
-          HARegionQueue.this.haContainer.remove(wrapper);
+          if (haContainerKey.decAndGetReferenceCount() == 0L) {
+            HARegionQueue.this.haContainer.remove(haContainerKey);
+            if (logger.isDebugEnabled()) {
+              logger.debug(
+                  caller + " removed Event ID hash code: " + haContainerKey.hashCode()
+                      + "; System ID hash code: "
+                      + System.identityHashCode(haContainerKey)
+                      + "; Wrapper details: " + haContainerKey);
+            }
+          }
+          decAndRemovePerformed = true;

MOV31 MOV31 INS31 INS31 MOV8 MOV29 INS43 INS42 MOV44 MOV44 INS29 INS43 INS42 INS44 MOV8 MOV29 MOV83 MOV39 MOV42 MOV44 INS8 INS83 INS39 INS42 INS44 INS44 INS8 MOV21 MOV60 INS54 INS25 INS25 UPD42 MOV42 INS25 MOV65 INS65 MOV65 INS42 INS43 INS42 INS61 INS41 INS21 INS43 INS42 INS43 INS42 INS60 INS61 MOV8 MOV12 MOV12 MOV8 INS66 UPD66 INS32 INS8 INS32 INS8 INS8 INS60 MOV62 INS8 MOV8 INS27 INS8 INS42 INS66 MOV65 INS42 MOV27 MOV8 INS42 UPD66 UPD66 INS32 INS42 INS42 INS39 INS59 INS38 INS8 MOV21 MOV25 MOV25 INS25 INS42 INS42 INS21 INS42 INS42 INS21 MOV53 INS43 INS59 MOV60 INS60 INS25 INS25 MOV21 INS41 INS41 INS42 INS33 MOV25 INS42 INS42 INS45 INS42 INS9 INS42 INS60 INS25 INS51 MOV27 MOV8 INS32 INS8 INS32 INS32 INS42 INS42 INS33 INS43 INS59 MOV32 MOV8 INS8 MOV32 INS8 INS42 INS42 INS43 INS59 INS27 INS8 INS42 INS8 INS60 INS25 MOV25 MOV60 MOV60 MOV60 INS61 INS25 INS42 INS42 INS21 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS42 INS33 MOV21 MOV21 UPD42 INS21 INS42 INS42 INS11 INS42 INS33 INS10 MOV25 INS43 INS59 MOV62 INS8 INS9 MOV8 MOV42 MOV8 INS32 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS22 UPD42 INS7 INS7 INS7 INS43 INS32 INS27 INS8 INS42 INS42 INS33 INS60 INS21 MOV25 MOV60 MOV54 MOV21 INS54 INS42 INS42 INS27 INS52 INS42 INS7 INS42 MOV32 INS42 INS42 INS42 UPD42 INS27 INS25 INS42 INS42 INS45 INS42 INS36 INS42 INS42 INS42 INS11 INS25 MOV25 INS21 MOV43 INS59 INS32 INS32 MOV8 MOV12 MOV12 INS45 INS42 INS45 INS42 INS42 MOV32 UPD42 INS45 INS42 INS45 INS42 INS45 MOV22 UPD27 INS32 INS8 INS27 INS11 INS43 INS32 MOV32 INS8 MOV25 INS7 INS42 MOV11 INS42 INS42 INS42 INS42 MOV25 MOV21 INS25 INS25 INS42 INS25 INS42 INS42 MOV21 INS45 INS42 INS43 INS42 INS42 INS36 INS42 INS42 INS21 INS42 INS9 MOV62 MOV62 MOV8 UPD27 INS32 INS8 INS45 INS45 INS32 INS8 INS42 INS11 INS32 UPD42 UPD42 INS32 UPD42 INS42 INS27 INS42 INS42 INS25 INS42 INS42 MOV21 UPD42 INS42 INS42 MOV21 INS42 INS42 INS27 INS43 INS42 INS42 INS42 INS27 UPD42 INS42 INS42 INS45 INS32 INS45 INS32 INS45 INS42 MOV27 INS32 INS8 INS45 INS32 INS45 INS32 INS45 INS32 INS45 INS42 INS42 INS42 INS45 INS32 INS45 INS32 INS45 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS21 INS42 INS42 INS27 INS42 INS42 INS27 MOV42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS27 INS32 INS45 INS32 INS45 INS32 INS45 INS42 INS45 INS32 INS45 INS32 INS45 INS42 INS42 INS45 INS32 INS45 INS32 INS45 INS42 INS42 INS42 INS27 MOV42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS45 INS32 INS45 INS32 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS45 DEL9 DEL61 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL25 DEL42 DEL42 DEL11 DEL32 DEL8 DEL25 DEL54 DEL54 DEL8 DEL33 DEL9 DEL42 DEL66 DEL65 DEL29 DEL39 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL52 DEL42 DEL22 DEL32 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL34 DEL27 DEL8 DEL33 DEL42 DEL42 DEL7 DEL9 DEL10 DEL19 DEL39 DEL42 DEL42 DEL42 DEL32 DEL25 DEL8 DEL25 DEL42 DEL42 DEL45 DEL42 DEL45 DEL42 DEL45 DEL27 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL66 DEL66 DEL66 DEL45 DEL52 DEL42 DEL22 DEL32 DEL32 DEL42 DEL42 DEL32 DEL34 DEL27 DEL32 DEL38 DEL27 DEL42 DEL8 DEL51 DEL8 DEL8 DEL31
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
+
-  private static final BigInteger dhP = new BigInteger(
-    "13528702063991073999718992897071702177131142188276542919088770094024269"
-      +  "73079899070080419278066109785292538223079165925365098181867673946"
-      +  "34756714063947534092593553024224277712367371302394452615862654308"
-      +  "11180902979719649450105660478776364198726078338308557022096810447"
-      +  "3500348898008043285865193451061481841186553");
+  private static final BigInteger dhP =
+      new BigInteger("13528702063991073999718992897071702177131142188276542919088770094024269"
+          + "73079899070080419278066109785292538223079165925365098181867673946"
+          + "34756714063947534092593553024224277712367371302394452615862654308"
+          + "11180902979719649450105660478776364198726078338308557022096810447"
+          + "3500348898008043285865193451061481841186553");
-  private static final BigInteger dhG = new BigInteger(
-    "13058345680719715096166513407513969537624553636623932169016704425008150"
-      +  "56576152779768716554354314319087014857769741104157332735258102835"
-      +  "93126577393912282416840649805564834470583437473176415335737232689"
-      +  "81480201869671811010996732593655666464627559582258861254878896534"
-      +  "1273697569202082715873518528062345259949959");
+  private static final BigInteger dhG =
+      new BigInteger("13058345680719715096166513407513969537624553636623932169016704425008150"
+          + "56576152779768716554354314319087014857769741104157332735258102835"
+          + "93126577393912282416840649805564834470583437473176415335737232689"
+          + "81480201869671811010996732593655666464627559582258861254878896534"
+          + "1273697569202082715873518528062345259949959");
-  private  PrivateKey dhPrivateKey = null;
+  private PrivateKey dhPrivateKey = null;
-  private  PublicKey dhPublicKey = null;
+  private PublicKey dhPublicKey = null;
-  private  String dhSKAlgo = null;
+  private String dhSKAlgo = null;
-  
+
-  public static final int numberOfPeerEncryptorCopies = Integer.getInteger("GMSEncrypt.MAX_ENCRYPTORS", Math.max(Runtime.getRuntime().availableProcessors()*4, 16)).intValue();
+  public static final int numberOfPeerEncryptorCopies =
+      Integer.getInteger("GMSEncrypt.MAX_ENCRYPTORS",
+          Math.max(Runtime.getRuntime().availableProcessors() * 4, 16)).intValue();
-  
+
-  private Map<InternalDistributedMemberWrapper, byte[]> memberToPeerEncryptor = new ConcurrentHashMap<>();
+  private Map<InternalDistributedMemberWrapper, byte[]> memberToPeerEncryptor =
+      new ConcurrentHashMap<>();
-  
+
-    if(this.clusterEncryptor == null) {
+    if (this.clusterEncryptor == null) {
-      
+
-  
+
-  private  byte[] getRegisteredPublicKey(InternalDistributedMember mbr) {
+  private byte[] getRegisteredPublicKey(InternalDistributedMember mbr) {
-  
+
-  
-  public GMSEncrypt(Services services, InternalDistributedMember mbr) throws  Exception {
+
+  public GMSEncrypt(Services services, InternalDistributedMember mbr) throws Exception {
-  
+
-    copyOfPeerEncryptors = new  ConcurrentHashMap[numberOfPeerEncryptorCopies];
+    copyOfPeerEncryptors = new ConcurrentHashMap[numberOfPeerEncryptorCopies];
-  
+
-  
+
-    return encryptor.decryptBytes(data);    
+    return encryptor.decryptBytes(data);
-  
+
-  
+
-      //createPeerEncryptor(mbr, publickey);
+      // createPeerEncryptor(mbr, publickey);
-        //remove all the existing keys..
-        for(Map m : copyOfPeerEncryptors) {
-          if(m != null)
+        // remove all the existing keys..
+        for (Map m : copyOfPeerEncryptors) {
+          if (m != null)
-    }catch(Exception e) {
-      throw new RuntimeException("Unable to create peer encryptor " +  mbr, e);
+    } catch (Exception e) {
+      throw new RuntimeException("Unable to create peer encryptor " + mbr, e);
-      
+
-  }  
-  
+  }
+
-          byte[] pk = (byte[])memberToPeerEncryptor.get(new InternalDistributedMemberWrapper(member));
+          byte[] pk =
+              (byte[]) memberToPeerEncryptor.get(new InternalDistributedMemberWrapper(member));
-          result = createPeerEncryptor(member, pk != null ? pk : (byte[]) view.getPublicKey(member));
+          result =
+              createPeerEncryptor(member, pk != null ? pk : (byte[]) view.getPublicKey(member));
-    
-    if(m == null) {
+
+    if (m == null) {
-        if(m == null) {
+        if (m == null) {
-          copyOfPeerEncryptors[h] = m;          
+          copyOfPeerEncryptors[h] = m;
-  
+
-    
-    if(c == null) {
+
+    if (c == null) {
-        if(c == null) {
+        if (c == null) {
-          copyOfClusterEncryptors[h] = c;          
+          copyOfClusterEncryptors[h] = c;
-  
-  private PeerEncryptor createPeerEncryptor(InternalDistributedMember member, byte[] peerKeyBytes) throws Exception {
-    PeerEncryptor result = new PeerEncryptor(peerKeyBytes);    
+
+  private PeerEncryptor createPeerEncryptor(InternalDistributedMember member, byte[] peerKeyBytes)
+      throws Exception {
+    PeerEncryptor result = new PeerEncryptor(peerKeyBytes);
-    }
-    else {
+    } else {
-    }
-    else if (algoStr.equalsIgnoreCase("Blowfish")) {
+    } else if (algoStr.equalsIgnoreCase("Blowfish")) {
-    }
-    else if (algoStr.equalsIgnoreCase("AES")) {
-      keysize = (algoKeySize != 192 && algoKeySize != 256) ? 16
-        : algoKeySize / 8;
+    } else if (algoStr.equalsIgnoreCase("AES")) {
+      keysize = (algoKeySize != 192 && algoKeySize != 256) ? 16 : algoKeySize / 8;
-    }
-    else {
+    } else {
-    }
-    else if (algoStr.equalsIgnoreCase("Blowfish")) {
+    } else if (algoStr.equalsIgnoreCase("Blowfish")) {
-    }
-    else if (algoStr.equalsIgnoreCase("AES")) {
+    } else if (algoStr.equalsIgnoreCase("AES")) {
-  static public byte[] decryptBytes(byte[] data, Cipher decrypt)
-    throws Exception{
+  static public byte[] decryptBytes(byte[] data, Cipher decrypt) throws Exception {
-    }catch(Exception ex) {
+    } catch (Exception ex) {
-    
+
-    private Cipher getEncryptCipher(String dhSKAlgo)
-      throws Exception{
+    private Cipher getEncryptCipher(String dhSKAlgo) throws Exception {
-        if(encrypt == null) {
+        if (encrypt == null) {
-      }catch(Exception ex) {
+      } catch (Exception ex) {
-    }    
+    }
-    private Cipher getDecryptCipher( String dhSKAlgo, PublicKey publicKey)
-      throws Exception{
-      if(decrypt == null) {
+    private Cipher getDecryptCipher(String dhSKAlgo, PublicKey publicKey) throws Exception {
+      if (decrypt == null) {
-  //this needs to synchronize as it uses private key of that member
-  protected static synchronized Cipher getEncryptCipher(String dhSKAlgo, PrivateKey privateKey, PublicKey peerPublicKey) throws Exception {
+  // this needs to synchronize as it uses private key of that member
+  protected static synchronized Cipher getEncryptCipher(String dhSKAlgo, PrivateKey privateKey,
+      PublicKey peerPublicKey) throws Exception {
-    
+
-    }
-    else {
+    } else {
-  
+
-  //this needs to synchronize as it uses private key of that member
-  protected static synchronized Cipher getDecryptCipher(String dhSKAlgo, PrivateKey privateKey, PublicKey publicKey) throws Exception {
+  // this needs to synchronize as it uses private key of that member
+  protected static synchronized Cipher getDecryptCipher(String dhSKAlgo, PrivateKey privateKey,
+      PublicKey publicKey) throws Exception {
-    
+
-  
+
-  protected static byte[] generateSecret(String dhSKAlgo, PrivateKey privateKey, PublicKey otherPublicKey) throws Exception {
+
+  protected static byte[] generateSecret(String dhSKAlgo, PrivateKey privateKey,
+      PublicKey otherPublicKey) throws Exception {
-    
+
-      SecretKey sKey = ka.generateSecret(dhSKAlgo);      
+      SecretKey sKey = ka.generateSecret(dhSKAlgo);
-  
+
-    //PublicKey pubKey = keyFact.generatePublic(x509KeySpec);
+    // PublicKey pubKey = keyFact.generatePublic(x509KeySpec);
-  protected static void initEncryptCipher(KeyAgreement ka, List<PublicKey> publicKeys) throws Exception{
+  protected static void initEncryptCipher(KeyAgreement ka, List<PublicKey> publicKeys)
+      throws Exception {
-    while(itr.hasNext()) {
-       ka.doPhase(itr.next(), !itr.hasNext());
+    while (itr.hasNext()) {
+      ka.doPhase(itr.next(), !itr.hasNext());
+
-  protected class ClusterEncryptor{
+  protected class ClusterEncryptor {
-      GMSEncrypt mine = new GMSEncrypt(other.services);      
-      this.secretBytes = GMSEncrypt.generateSecret(mine.dhSKAlgo, mine.dhPrivateKey, other.dhPublicKey);
+      GMSEncrypt mine = new GMSEncrypt(other.services);
+      this.secretBytes =
+          GMSEncrypt.generateSecret(mine.dhSKAlgo, mine.dhPrivateKey, other.dhPublicKey);
-    
+
-    
+
-    private Cipher getEncryptCipher(String dhSKAlgo)
-      throws Exception{
+    private Cipher getEncryptCipher(String dhSKAlgo) throws Exception {
-        if(encrypt == null) {
+        if (encrypt == null) {
-      }catch(Exception ex) {
+      } catch (Exception ex) {
-    private Cipher getDecryptCipher( String dhSKAlgo)
-      throws Exception{
-      if(decrypt == null) {
+    private Cipher getDecryptCipher(String dhSKAlgo) throws Exception {
+      if (decrypt == null) {


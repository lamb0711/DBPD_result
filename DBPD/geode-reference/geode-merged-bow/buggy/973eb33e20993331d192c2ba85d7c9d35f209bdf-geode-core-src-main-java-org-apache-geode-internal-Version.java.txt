GEODE-2915 Messages rejected due to unknown "vmkind"

The fix for GEODE_2875 has exacerbated this problem, which we used to only
see in cases where disable-tcp=true or when multicast was enabled.

The problem is that JGroupsMessenger is not sending the "vmkind" of the
sender in message headers.  This part of the header comes from
GMSMember.writeEssentialData().  I've changed it here to include the
vmKind if the recipient isn't using geode 1.0, which doesn't expect
the version byte.

-  public static final int HIGHEST_VERSION = 55;
+  public static final int HIGHEST_VERSION = 60;
-      new Version("GEODE", "1.1.0", (byte) 9, (byte) 0, (byte) 1, (byte) 0, GEODE_110_ORDINAL);
+      new Version("GEODE", "1.1.0", (byte) 1, (byte) 1, (byte) 0, (byte) 0, GEODE_110_ORDINAL);
-  private static final byte GFE_91_ORDINAL = 55;
+  private static final byte GEODE_111_ORDINAL = 55;
-  public static final Version GFE_91 =
-      new Version("GFE", "9.1", (byte) 9, (byte) 1, (byte) 0, (byte) 0, GFE_91_ORDINAL);
+  public static final Version GEODE_111 =
+      new Version("GEODE", "1.1.1", (byte) 1, (byte) 1, (byte) 1, (byte) 0, GEODE_111_ORDINAL);
+
+  private static final byte GEODE_120_ORDINAL = 60;
+
+  public static final Version GEODE_120 =
+      new Version("GEODE", "1.2.0", (byte) 1, (byte) 2, (byte) 0, (byte) 0, GEODE_120_ORDINAL);
-  public static final Version CURRENT = GFE_91;
+  public static final Version CURRENT = GEODE_120;
-      // [bruce] old implementation used ordinals for comparison, but this requires
-      // ordinals to be in increasing order, which may not always be possible
-      // // byte min/max can't overflow int, so use (a-b)
-      // final int thisOrdinal = this.ordinal;
-      // final int otherOrdinal = o.ordinal;
-      // return (thisOrdinal - otherOrdinal);
-      // [bruce] new implementation uses major/minor/patch/build
-      if (this.majorVersion > other.majorVersion) {
-        return 1;
-      } else if (other.majorVersion > this.majorVersion) {
-        return -1;
-      }
-      if (this.minorVersion > other.minorVersion) {
-        return 1;
-      } else if (other.minorVersion > this.minorVersion) {
-        return -1;
-      }
-      if (this.release > other.release) {
-        return 1;
-      } else if (other.release > this.release) {
-        return -1;
-      }
-      if (this.patch > other.patch) {
-        return 1;
-      } else if (other.patch > this.patch) {
-        return -1;
-      }
-      return 0;
+      // byte min/max can't overflow int, so use (a-b)
+      final int thisOrdinal = this.ordinal;
+      final int otherOrdinal = other.ordinal;
+      return (thisOrdinal - otherOrdinal);

INS23 INS23 INS31 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS83 INS43 INS59 MOV29 MOV78 INS83 INS39 INS42 MOV44 INS8 UPD34 UPD42 UPD42 INS42 INS34 INS42 INS42 INS14 UPD42 MOV25 INS11 MOV11 UPD45 UPD45 MOV11 UPD42 INS43 INS45 INS45 INS11 INS11 MOV11 INS11 INS42 MOV27 INS8 MOV8 UPD34 INS39 INS34 UPD34 INS42 INS39 INS34 INS39 INS34 INS39 INS34 INS60 INS60 INS41 INS83 INS39 INS59 INS83 INS39 INS59 INS36 INS42 INS22 INS42 INS40 INS27 MOV52 UPD42 MOV42 INS42 INS42 DEL22 DEL40 DEL27 DEL34 DEL41 DEL8 DEL40 DEL52 DEL42 DEL22 DEL27 DEL34 DEL38 DEL41 DEL8 DEL25 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL40 DEL27 DEL34 DEL41 DEL8 DEL40 DEL52 DEL42 DEL22 DEL27 DEL34 DEL38 DEL41 DEL8 DEL25 DEL25 DEL52 DEL42 DEL22 DEL40 DEL27 DEL34 DEL41 DEL8 DEL40 DEL52 DEL42 DEL22 DEL27 DEL34 DEL38 DEL41 DEL8 DEL25 DEL25 DEL52 DEL42 DEL22 DEL40 DEL27 DEL34 DEL41 DEL8 DEL40 DEL52 DEL42 DEL22 DEL27 DEL34 DEL38 DEL41 DEL8 DEL25 DEL25 DEL34 DEL41 DEL8 DEL25 DEL8 DEL31
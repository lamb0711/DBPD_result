GEODE-6322: refactor createRegionCommand to use RegionConfig only (#3156)

* get rid of usages of xxxArgs and RegionConfigFactory
* the resulting cluster configuration xml for region does not have excessive default values

+import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.Optional;
-import javax.management.ObjectName;
-
+import joptsimple.internal.Strings;
-import org.apache.commons.lang3.exception.ExceptionUtils;
+import org.apache.commons.lang3.builder.EqualsBuilder;
-import org.apache.geode.cache.RegionAttributes;
+import org.apache.geode.cache.configuration.ClassNameType;
+import org.apache.geode.cache.configuration.DeclarableType;
+import org.apache.geode.cache.configuration.RegionAttributesType;
-import org.apache.geode.cache.execute.ResultCollector;
+import org.apache.geode.internal.config.JAXBService;
-import org.apache.geode.management.RegionAttributesData;
-import org.apache.geode.management.RegionMXBean;
-import org.apache.geode.management.internal.cli.CliUtil;
-import org.apache.geode.management.internal.cli.LogWrapper;
-import org.apache.geode.management.internal.cli.domain.PartitionArgs;
-import org.apache.geode.management.internal.cli.domain.RegionConfigFactory;
-import org.apache.geode.management.internal.cli.functions.RegionAttributesWrapper;
+  private static final String[] PARTITION_ATTRIBUTES = new String[] {
+      CliStrings.CREATE_REGION__COLOCATEDWITH,
+      CliStrings.CREATE_REGION__LOCALMAXMEMORY,
+      CliStrings.CREATE_REGION__RECOVERYDELAY,
+      CliStrings.CREATE_REGION__REDUNDANTCOPIES,
+      CliStrings.CREATE_REGION__STARTUPRECOVERYDDELAY,
+      CliStrings.CREATE_REGION__TOTALMAXMEMORY,
+      CliStrings.CREATE_REGION__TOTALNUMBUCKETS,
+      CliStrings.CREATE_REGION__PARTITION_RESOLVER
+  };
+
+    RegionConfig regionConfig = new RegionConfig();
+
+    // get the initial set of attributes either from shortcut or from the template region
+    InternalConfigurationPersistenceService persistenceService =
+        getConfigurationPersistenceService();
+    if (regionShortcut != null) {
+      regionConfig.setType(regionShortcut.name());
+    }
+    // get the attributes from the template region
+    else {
+      List<RegionConfig> templateRegionConfigs = new ArrayList<>();
+      // get the potential template region config from the cluster configuration
+      if (persistenceService != null) {
+        templateRegionConfigs = persistenceService.getGroups().stream()
+            .flatMap(g -> persistenceService.getCacheConfig(g, true).getRegions().stream())
+            .filter(c -> c.getName().equals(templateRegion.substring(1)))
+            .collect(Collectors.toList());
+      }
+      // as a last resort, go the member that hosts this region to retrieve the template's region
+      // xml
+      else {
+        // we would need to execute a function to the member hosting the template region to get the
+        // region xml. cluster configuration isn't always enabled, so we cannot guarantee that we
+        // can
+        // get the template region configuration from the cluster configuration.
+        Set<DistributedMember> regionAssociatedMembers = findMembersForRegion(templateRegion);
+
+        if (!regionAssociatedMembers.isEmpty()) {
+          List<CliFunctionResult> regionXmlResults = executeAndGetFunctionResult(
+              FetchRegionAttributesFunction.INSTANCE, templateRegion, regionAssociatedMembers);
+
+          JAXBService jaxbService = new JAXBService(CacheConfig.class);
+          templateRegionConfigs = regionXmlResults.stream().filter(CliFunctionResult::isSuccessful)
+              .map(CliFunctionResult::getResultObject).map(String.class::cast)
+              .map(s -> jaxbService.unMarshall(s, RegionConfig.class))
+              .collect(Collectors.toList());
+        }
+      }
+
+      if (templateRegionConfigs.isEmpty()) {
+        return ResultModel.createError("Template region " + templateRegion + " does not exist.");
+      }
+      if (templateRegionConfigs.size() == 1) {
+        regionConfig = templateRegionConfigs.get(0);
+      }
+      // found more than one configuration with this name. fail ff they have different attributes.
+      else {
+        RegionConfig first = templateRegionConfigs.get(0);
+        for (int i = 1; i < templateRegionConfigs.size(); i++) {
+          if (!EqualsBuilder.reflectionEquals(first, templateRegionConfigs.get(i), false, null,
+              true)) {
+            return ResultModel.createError("Multiple types of template region " + templateRegion
+                + " exist. Can not resolve template region attributes.");
+          }
+        }
+        regionConfig = first;
+      }
+    }
+
+    regionConfig.setName(regionPathData.getName());
+
+    // set partition attributes
+    RegionAttributesType regionAttributes = regionConfig.getRegionAttributes();
+    RegionAttributesType.PartitionAttributes delta =
+        RegionAttributesType.PartitionAttributes.generate(partitionResolver, null, prLocalMaxMemory,
+            prRecoveryDelay, prRedundantCopies, prStartupRecoveryDelay, prTotalMaxMemory,
+            prTotalNumBuckets, prColocatedWith);
+
+    RegionAttributesType.PartitionAttributes partitionAttributes =
+        RegionAttributesType.PartitionAttributes.combine(
+            regionAttributes.getPartitionAttributes(), delta);
+    regionAttributes.setPartitionAttributes(partitionAttributes);
+
-    PartitionArgs partitionArgs =
-        new PartitionArgs(prColocatedWith, prLocalMaxMemory, prRecoveryDelay,
-            prRedundantCopies, prStartupRecoveryDelay, prTotalMaxMemory, prTotalNumBuckets,
-            partitionResolver);
-    if (regionShortcut != null && !regionShortcut.name().startsWith("PARTITION")
-        && !partitionArgs.isEmpty()) {
-      return ResultModel.createError(CliStrings.format(
-          CliStrings.CREATE_REGION__MSG__OPTION_0_CAN_BE_USED_ONLY_FOR_PARTITIONEDREGION,
-          partitionArgs.getUserSpecifiedPartitionAttributes()) + " "
-          + CliStrings.format(CliStrings.CREATE_REGION__MSG__0_IS_NOT_A_PARITIONEDREGION,
-              regionPath));
+    if (!regionAttributes.getDataPolicy().isPartition() && partitionAttributes != null) {
+      return ResultModel.createError(
+          String.format("Parameters %s can be used only for creating a Partitioned Region",
+              Strings.join(PARTITION_ATTRIBUTES, ", ")));
-    // validate gateway senders
+    // validate and set gateway senders
+      regionAttributes.setGatewaySenderIds(StringUtils.join(gatewaySenderIds, ","));
-    // validate if template region exists, if provided
-    if (templateRegion != null && !regionExists(templateRegion)) {
-      return ResultModel.createError(CliStrings.format(
-          CliStrings.CREATE_REGION__MSG__SPECIFY_VALID_REGION_PATH_FOR_0_REGIONPATH_1_NOT_FOUND,
-          CliStrings.CREATE_REGION__USEATTRIBUTESFROM, templateRegion));
-    }
-
-    // get predefined attributes for a template region
-    RegionAttributesWrapper<?, ?> wrappedTemplateAttributes = null;
-    if (templateRegion != null) {
-      wrappedTemplateAttributes = getRegionAttributes(cache, templateRegion);
-      if (wrappedTemplateAttributes == null) {
-        return ResultModel.createError(CliStrings.format(
-            CliStrings.CREATE_REGION__MSG__COULD_NOT_RETRIEVE_REGION_ATTRS_FOR_PATH_0_VERIFY_REGION_EXISTS,
-            templateRegion));
+    // validating and set diskstore
+    if (diskStore != null) {
+      if (!regionAttributes.getDataPolicy().isPersistent()) {
+        String subMessage =
+            "Only regions with persistence or overflow to disk can specify DiskStore";
+        String message = subMessage + ". "
+            + CliStrings.format(
+                CliStrings.CREATE_REGION__MSG__USE_ATTRIBUTES_FROM_REGION_0_IS_NOT_WITH_PERSISTENCE,
+                new Object[] {templateRegion});
+        return ResultModel.createError(message);
-      if (wrappedTemplateAttributes.getRegionAttributes().getPartitionAttributes() == null
-          && !partitionArgs.isEmpty()) {
+      if (!diskStoreExists(diskStore)) {
-            CliStrings.CREATE_REGION__MSG__OPTION_0_CAN_BE_USED_ONLY_FOR_PARTITIONEDREGION,
-            partitionArgs.getUserSpecifiedPartitionAttributes()) + " "
-            + CliStrings.format(CliStrings.CREATE_REGION__MSG__0_IS_NOT_A_PARITIONEDREGION,
-                templateRegion));
+            CliStrings.CREATE_REGION__MSG__SPECIFY_VALID_DISKSTORE_UNKNOWN_DISKSTORE_0,
+            new Object[] {diskStore}));
-    }
-
-    RegionAttributes<?, ?> regionAttributes;
-    if (wrappedTemplateAttributes != null) {
-      regionAttributes = wrappedTemplateAttributes.getRegionAttributes();
-    } else {
-      regionAttributes = cache.getRegionAttributes(regionShortcut.toString());
-    }
-
-    // validating diskstore with other attributes
-    if (diskStore != null && !regionAttributes.getDataPolicy().withPersistence()) {
-      String subMessage = "Only regions with persistence or overflow to disk can specify DiskStore";
-      String message = subMessage + ". "
-          + CliStrings.format(
-              CliStrings.CREATE_REGION__MSG__USE_ATTRIBUTES_FROM_REGION_0_IS_NOT_WITH_PERSISTENCE,
-              new Object[] {templateRegion});
-
-      return ResultModel.createError(message);
-    }
-
-    if (diskStore != null && !diskStoreExists(diskStore)) {
-      return ResultModel.createError(CliStrings.format(
-          CliStrings.CREATE_REGION__MSG__SPECIFY_VALID_DISKSTORE_UNKNOWN_DISKSTORE_0,
-          new Object[] {diskStore}));
+      regionAttributes.setDiskStoreName(diskStore);
-    if (isAttributePersistent(regionAttributes)) {
+    if (regionAttributes.getDataPolicy().isPersistent()) {
-
-    Set<ClassName<CacheListener>> cacheListeners = new HashSet<>();
-      Arrays.stream(cacheListener).forEach(c -> cacheListeners.add(c));
-    } else if (wrappedTemplateAttributes != null
-        && wrappedTemplateAttributes.getCacheListenerClasses() != null) {
-      cacheListeners.addAll(wrappedTemplateAttributes.getCacheListenerClasses());
+      // clean the old tempalte region's cache listener
+      regionAttributes.getCacheListeners().clear();
+      Arrays.stream(cacheListener)
+          .map(cl -> new DeclarableType(cl.getClassName(), cl.getInitProperties()))
+          .forEach(regionAttributes.getCacheListeners()::add);
-    ClassName<CacheLoader> cacheLoaderClassNameToPersist = null;
-      cacheLoaderClassNameToPersist = cacheLoader;
-    } else if (wrappedTemplateAttributes != null
-        && wrappedTemplateAttributes.getCacheLoaderClass() != null) {
-      cacheLoaderClassNameToPersist = wrappedTemplateAttributes.getCacheLoaderClass();
+      regionAttributes.setCacheLoader(
+          new DeclarableType(cacheLoader.getClassName(), cacheLoader.getInitProperties()));
-    ClassName<CacheWriter> cacheWriterClassNameToPersist = null;
-      cacheWriterClassNameToPersist = cacheWriter;
-    } else if (wrappedTemplateAttributes != null
-        && wrappedTemplateAttributes.getCacheWriterClass() != null) {
-      cacheWriterClassNameToPersist = wrappedTemplateAttributes.getCacheWriterClass();
+      regionAttributes.setCacheWriter(
+          new DeclarableType(cacheWriter.getClassName(), cacheWriter.getInitProperties()));
-    String compressorClassNameToPersist = null;
-      compressorClassNameToPersist = compressor;
-    } else if (wrappedTemplateAttributes != null
-        && wrappedTemplateAttributes.getCompressorClass() != null) {
-      compressorClassNameToPersist = wrappedTemplateAttributes.getCompressorClass();
+      regionAttributes.setCompressor(new ClassNameType(compressor));
-    String keyConstraintToPersist = null;
-      keyConstraintToPersist = keyConstraint;
-    } else if (wrappedTemplateAttributes != null
-        && wrappedTemplateAttributes.getKeyConstraintClass() != null) {
-      keyConstraintToPersist = wrappedTemplateAttributes.getKeyConstraintClass();
+      regionAttributes.setKeyConstraint(keyConstraint);
-    String valueConstraintToPersist = null;
-      valueConstraintToPersist = valueConstraint;
-    } else if (wrappedTemplateAttributes != null
-        && wrappedTemplateAttributes.getValueConstraintClass() != null) {
-      valueConstraintToPersist = wrappedTemplateAttributes.getValueConstraintClass();
+      regionAttributes.setValueConstraint(valueConstraint);
-    Set<String> asyncEventQueueIdSet = Optional.ofNullable(asyncEventQueueIds)
-        .map(a -> Arrays.stream(a).collect(Collectors.toSet()))
-        .orElse(null);
-    Set<String> gatewaySenderIdSet = Optional.ofNullable(gatewaySenderIds)
-        .map(a -> Arrays.stream(a).collect(Collectors.toSet()))
-        .orElse(null);
+    if (asyncEventQueueIds != null) {
+      regionAttributes.setAsyncEventQueueIds(Strings.join(asyncEventQueueIds, ","));
+    }
-    RegionConfig config = (new RegionConfigFactory()).generate(regionPath, keyConstraintToPersist,
-        valueConstraintToPersist, statisticsEnabled, entryExpirationIdleTime,
-        entryExpirationIdleTimeAction, entryExpirationTTL, entryExpirationTTLAction,
-        entryIdleTimeCustomExpiry,
-        entryTTLCustomExpiry, regionExpirationIdleTime, regionExpirationIdleTimeAction,
-        regionExpirationTTL, regionExpirationTTLAction, evictionAction, evictionMaxMemory,
-        evictionEntryCount, evictionObjectSizer, diskStore, diskSynchronous, enableAsyncConflation,
-        enableSubscriptionConflation, cacheListeners, cacheLoaderClassNameToPersist,
-        cacheWriterClassNameToPersist,
-        asyncEventQueueIdSet, gatewaySenderIdSet, concurrencyChecksEnabled, cloningEnabled,
-        mcastEnabled,
-        concurrencyLevel, partitionArgs, compressorClassNameToPersist, offHeap, regionAttributes);
+    if (offHeap != null) {
+      regionAttributes.setOffHeap(offHeap);
+    }
+    if (concurrencyLevel != null) {
+      regionAttributes.setConcurrencyLevel(concurrencyLevel.toString());
+    }
+    if (enableAsyncConflation != null) {
+      regionAttributes.setEnableAsyncConflation(enableAsyncConflation);
+    }
+    if (cloningEnabled != null) {
+      regionAttributes.setCloningEnabled(cloningEnabled);
+    }
+    if (concurrencyChecksEnabled != null) {
+      regionAttributes.setConcurrencyChecksEnabled(concurrencyChecksEnabled);
+    }
+    if (mcastEnabled != null) {
+      regionAttributes.setMulticastEnabled(mcastEnabled);
+    }
+    if (statisticsEnabled != null) {
+      regionAttributes.setStatisticsEnabled(statisticsEnabled);
+    }
+    if (enableSubscriptionConflation != null) {
+      regionAttributes.setEnableSubscriptionConflation(enableSubscriptionConflation);
+    }
+    if (diskSynchronous != null) {
+      regionAttributes.setDiskSynchronous(diskSynchronous);
+    }
+
+    regionAttributes.updateEntryIdleTime(entryExpirationIdleTime, entryExpirationIdleTimeAction,
+        entryIdleTimeCustomExpiry);
+    regionAttributes.updateEntryTimeToLive(entryExpirationTTL, entryExpirationTTLAction,
+        entryTTLCustomExpiry);
+    regionAttributes.updateRegionIdleTime(regionExpirationIdleTime, regionExpirationIdleTimeAction,
+        null);
+    regionAttributes.updateRegionTimeToLive(regionExpirationTTL, regionExpirationTTLAction, null);
+
+    // unlike expiration attributes, if any single eviction attributes is set, we will replace
+    // the template eviction attributes with this new eviction attributes. we do not combine
+    // the old and new.
+    RegionAttributesType.EvictionAttributes evictionAttributes =
+        RegionAttributesType.EvictionAttributes
+            .generate(evictionAction, evictionMaxMemory, evictionEntryCount, evictionObjectSizer);
+    if (evictionAttributes != null) {
+      regionAttributes.setEvictionAttributes(evictionAttributes);
+    }
-        new CreateRegionFunctionArgs(regionPath, config, ifNotExists);
+        new CreateRegionFunctionArgs(regionPath, regionConfig, ifNotExists);
-      config.getCustomRegionElements().addAll(extensions);
+      regionConfig.getCustomRegionElements().addAll(extensions);
-      resultModel.setConfigObject(new CreateRegionResult(config, regionPath));
+      resultModel.setConfigObject(new CreateRegionResult(regionConfig, regionPath));
-  RegionAttributesWrapper getRegionAttributes(InternalCache cache, String regionPath) {
-    if (!isClusterWideSameConfig(cache, regionPath)) {
-      throw new IllegalStateException(CliStrings.format(
-          CliStrings.CREATE_REGION__MSG__USE_ATTRIBUTES_FORM_REGIONS_EXISTS_BUT_DIFFERENT_SCOPE_OR_DATAPOLICY_USE_DESCRIBE_REGION_FOR_0,
-          regionPath));
-    }
-    RegionAttributesWrapper attributes = null;
-
-    // First check whether the region exists on a this manager, if yes then no
-    // need to use FetchRegionAttributesFunction to fetch RegionAttributes
-    try {
-      attributes = FetchRegionAttributesFunction.getRegionAttributes(cache, regionPath);
-    } catch (IllegalArgumentException e) {
-      /* region doesn't exist on the manager */
-    }
-
-    if (attributes == null) {
-      // find first member which has the region
-      Set<DistributedMember> regionAssociatedMembers = findMembersForRegion(regionPath);
-      if (regionAssociatedMembers != null && !regionAssociatedMembers.isEmpty()) {
-        DistributedMember distributedMember = regionAssociatedMembers.iterator().next();
-        ResultCollector<?, ?> resultCollector =
-            executeFunction(FetchRegionAttributesFunction.INSTANCE, regionPath, distributedMember);
-        List<?> resultsList = (List<?>) resultCollector.getResult();
-
-        if (resultsList != null && !resultsList.isEmpty()) {
-          for (Object object : resultsList) {
-            if (object instanceof IllegalArgumentException) {
-              throw (IllegalArgumentException) object;
-            } else if (object instanceof Throwable) {
-              Throwable th = (Throwable) object;
-              LogWrapper.getInstance(getCache()).info(ExceptionUtils.getStackTrace((th)));
-              throw new IllegalArgumentException(CliStrings.format(
-                  CliStrings.CREATE_REGION__MSG__COULD_NOT_RETRIEVE_REGION_ATTRS_FOR_PATH_0_REASON_1,
-                  regionPath, th.getMessage()));
-            } else { // has to be RegionAttributes
-              @SuppressWarnings("unchecked") // to avoid warning :(
-              RegionAttributesWrapper regAttr = ((RegionAttributesWrapper) object);
-              if (attributes == null) {
-                attributes = regAttr;
-                break;
-              } // attributes null check
-            } // not IllegalArgumentException or other throwable
-          } // iterate over list - there should be only one result in the list
-        } // result list is not null or empty
-      } // regionAssociatedMembers is not-empty
-    } // attributes are null because do not exist on local member
-
-    return attributes;
-  }
-
-    // either C is local, or E is local or E and C are both non-proxy regions. this is to make
-    // sure local, replicate or partition regions have unique names across the entire cluster
-    if (regionShortcut.isLocal() || existingDataPolicy.equals("NORMAL") || !regionShortcut.isProxy()
-        && (regionBean.getMemberCount() > regionBean.getEmptyNodes())) {
+    // fail if either C is local, or E is local or E and C are both non-proxy regions. this is to
+    // make sure local, replicate or partition regions have unique names across the entire cluster
+    boolean existingRegionIsNotProxy = regionBean.getMemberCount() > regionBean.getEmptyNodes();
+    boolean toBeCreatedIsNotProxy = !regionShortcut.isProxy();
+    if (regionShortcut.isLocal() || existingDataPolicy.equals("NORMAL") || (toBeCreatedIsNotProxy
+        && existingRegionIsNotProxy)) {
-  private boolean isClusterWideSameConfig(InternalCache cache, String regionPath) {
-    ManagementService managementService = getManagementService();
-
-    DistributedSystemMXBean dsMXBean = managementService.getDistributedSystemMXBean();
-
-    Set<DistributedMember> allMembers = getAllNormalMembers();
-
-    RegionAttributesData regionAttributesToValidateAgainst = null;
-    for (DistributedMember distributedMember : allMembers) {
-      ObjectName regionObjectName;
-      try {
-        regionObjectName = dsMXBean
-            .fetchRegionObjectName(CliUtil.getMemberNameOrId(distributedMember), regionPath);
-        RegionMXBean regionMBean =
-            managementService.getMBeanInstance(regionObjectName, RegionMXBean.class);
-        RegionAttributesData regionAttributes = regionMBean.listRegionAttributes();
-
-        if (regionAttributesToValidateAgainst == null) {
-          regionAttributesToValidateAgainst = regionAttributes;
-        } else if (!(regionAttributesToValidateAgainst.getScope()
-            .equals(regionAttributes.getScope())
-            || regionAttributesToValidateAgainst.getDataPolicy()
-                .equals(regionAttributes.getDataPolicy()))) {
-          return false;
-        }
-      } catch (Exception e) {
-        // ignore
-      }
-    }
-
-    return true;
-  }
-
-  private boolean isAttributePersistent(RegionAttributes attributes) {
-    return attributes != null && attributes.getDataPolicy() != null
-        && attributes.getDataPolicy().toString().contains("PERSISTENT");
-  }
-
-

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 INS23 INS83 INS83 INS83 INS5 INS59 MOV60 MOV43 INS85 INS42 INS3 INS60 INS60 INS25 INS21 INS60 INS60 INS21 INS25 INS25 INS25 INS25 INS25 INS25 INS25 INS25 INS25 INS25 INS25 INS25 INS25 INS25 INS25 INS25 INS25 INS25 INS21 INS21 INS21 INS21 INS60 INS25 INS60 INS60 INS5 INS4 UPD43 MOV43 INS59 INS43 INS59 MOV27 INS8 INS8 INS32 INS43 INS43 INS59 INS43 INS59 INS32 MOV27 MOV27 INS8 MOV27 INS8 INS32 MOV27 INS8 MOV27 MOV8 MOV27 INS8 MOV27 INS8 MOV27 MOV8 MOV27 MOV8 INS27 MOV8 INS27 MOV8 INS27 MOV8 INS27 MOV8 INS27 MOV8 INS27 INS8 INS27 INS8 INS27 INS8 INS27 INS8 INS27 INS8 INS32 INS32 INS32 INS32 INS43 INS59 INS27 INS8 MOV43 INS39 INS59 INS39 INS59 MOV43 INS85 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD42 UPD42 MOV42 INS14 UPD42 MOV42 INS42 INS32 INS21 INS60 INS25 MOV25 MOV25 INS42 INS42 INS32 UPD42 MOV42 INS32 INS40 INS42 INS32 INS40 INS42 INS32 INS42 INS42 INS42 INS41 INS21 MOV25 MOV25 INS21 MOV32 INS42 MOV21 INS21 INS21 INS21 INS42 MOV33 INS42 INS33 UPD42 MOV42 MOV33 INS42 INS33 UPD42 MOV42 MOV33 INS42 INS33 INS21 INS42 INS33 INS21 INS42 INS33 INS21 INS42 INS33 INS21 INS42 INS33 INS21 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS33 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS33 INS40 INS42 INS32 INS42 INS33 INS21 INS42 MOV27 INS42 MOV38 INS36 INS43 INS42 MOV32 MOV32 INS74 INS59 INS27 INS8 INS8 INS32 INS27 INS8 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS33 INS42 INS42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS40 UPD42 MOV42 INS32 UPD42 MOV42 UPD42 INS32 INS32 INS38 MOV38 INS32 UPD42 MOV42 UPD42 MOV42 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS40 UPD42 MOV42 MOV42 MOV42 MOV42 MOV42 INS32 MOV43 UPD42 INS27 INS42 INS42 UPD42 MOV43 INS43 INS42 INS14 INS42 INS33 INS21 INS60 INS25 INS42 INS42 INS32 INS34 INS21 INS60 INS24 INS21 UPD42 MOV42 UPD42 MOV42 UPD42 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS42 INS90 INS42 INS42 INS14 INS42 INS42 INS14 UPD42 MOV42 INS42 INS14 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS74 INS7 MOV74 INS59 MOV38 INS8 UPD42 MOV42 UPD42 MOV42 INS7 MOV43 INS59 INS58 INS27 INS37 INS8 INS7 INS42 UPD42 MOV42 INS45 INS32 INS42 INS42 INS42 INS45 INS32 INS42 UPD42 UPD42 MOV32 INS42 INS86 INS32 INS42 INS43 INS32 INS32 INS43 INS32 INS32 INS43 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS45 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS43 INS42 INS32 INS42 INS32 INS60 MOV60 MOV21 INS27 INS42 INS32 INS42 INS32 INS39 INS59 INS42 INS32 INS42 INS25 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS45 INS42 INS42 INS59 INS14 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 UPD42 MOV42 INS74 INS59 INS43 INS45 INS42 INS45 UPD42 MOV42 UPD42 MOV42 INS34 UPD42 MOV42 INS42 INS34 INS42 INS34 INS42 INS42 INS38 INS8 INS42 INS43 INS32 INS32 INS32 INS42 INS86 UPD42 MOV42 INS42 MOV43 INS43 INS42 INS32 UPD42 MOV42 UPD42 INS14 UPD42 INS32 INS32 INS41 UPD42 MOV42 INS42 INS42 INS42 INS42 INS32 INS42 INS86 MOV59 INS32 INS42 UPD42 MOV42 UPD40 MOV40 MOV42 INS42 INS43 INS57 INS32 INS42 INS32 INS42 UPD42 MOV42 UPD42 MOV42 MOV32 INS9 INS33 INS9 INS32 INS32 INS42 INS59 INS32 INS32 INS42 MOV32 INS42 INS43 INS32 INS42 INS86 INS42 INS42 UPD42 UPD42 INS42 UPD42 MOV42 UPD42 MOV42 INS27 INS42 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS34 INS42 INS32 INS42 INS90 INS59 INS32 INS45 INS42 INS45 INS32 UPD42 MOV42 INS32 INS42 INS90 INS57 INS42 INS42 INS42 INS42 INS42 INS57 UPD42 MOV42 UPD42 MOV42 INS42 INS9 INS32 INS42 INS90 INS42 INS42 MOV43 INS43 INS42 INS42 INS42 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL45 DEL43 DEL76 DEL76 DEL74 DEL33 DEL42 DEL42 DEL42 DEL32 DEL42 DEL33 DEL27 DEL42 DEL42 DEL40 DEL42 DEL32 DEL32 DEL42 DEL32 DEL33 DEL27 DEL32 DEL38 DEL27 DEL42 DEL40 DEL32 DEL45 DEL40 DEL42 DEL32 DEL27 DEL32 DEL41 DEL43 DEL76 DEL76 DEL74 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL14 DEL59 DEL60 DEL38 DEL27 DEL32 DEL38 DEL27 DEL40 DEL32 DEL45 DEL42 DEL40 DEL42 DEL32 DEL27 DEL32 DEL41 DEL8 DEL25 DEL27 DEL42 DEL33 DEL27 DEL38 DEL27 DEL42 DEL42 DEL42 DEL40 DEL32 DEL32 DEL41 DEL8 DEL25 DEL42 DEL33 DEL27 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL32 DEL32 DEL7 DEL21 DEL8 DEL25 DEL32 DEL42 DEL42 DEL42 DEL32 DEL7 DEL42 DEL32 DEL7 DEL42 DEL42 DEL7 DEL42 DEL32 DEL7 DEL42 DEL42 DEL7 DEL42 DEL32 DEL7 DEL42 DEL42 DEL7 DEL42 DEL32 DEL7 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL32 DEL86 DEL32 DEL21 DEL8 DEL42 DEL33 DEL27 DEL32 DEL33 DEL27 DEL27 DEL8 DEL25 DEL25 DEL42 DEL43 DEL43 DEL74 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL7 DEL21 DEL8 DEL42 DEL33 DEL27 DEL32 DEL33 DEL27 DEL27 DEL25 DEL25 DEL42 DEL43 DEL43 DEL74 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL7 DEL21 DEL8 DEL42 DEL33 DEL27 DEL42 DEL32 DEL33 DEL27 DEL27 DEL25 DEL25 DEL42 DEL33 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL27 DEL27 DEL25 DEL25 DEL42 DEL33 DEL59 DEL60 DEL27 DEL42 DEL42 DEL32 DEL33 DEL27 DEL27 DEL25 DEL25 DEL42 DEL33 DEL59 DEL60 DEL27 DEL42 DEL42 DEL32 DEL33 DEL27 DEL27 DEL25 DEL25 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL32 DEL42 DEL42 DEL59 DEL32 DEL42 DEL32 DEL32 DEL86 DEL32 DEL42 DEL33 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL32 DEL42 DEL42 DEL59 DEL32 DEL32 DEL32 DEL86 DEL32 DEL33 DEL32 DEL59 DEL60 DEL42 DEL42 DEL43 DEL14 DEL36 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL38 DEL42 DEL43 DEL42 DEL42 DEL40 DEL42 DEL32 DEL14 DEL53 DEL8 DEL25 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL76 DEL76 DEL74 DEL42 DEL42 DEL40 DEL42 DEL42 DEL32 DEL59 DEL60 DEL76 DEL74 DEL42 DEL76 DEL74 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL38 DEL27 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL11 DEL53 DEL8 DEL42 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL42 DEL42 DEL36 DEL32 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL40 DEL42 DEL42 DEL42 DEL32 DEL32 DEL14 DEL53 DEL8 DEL42 DEL45 DEL79 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL7 DEL21 DEL10 DEL8 DEL25 DEL8 DEL25 DEL25 DEL8 DEL70 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL36 DEL27 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL7 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL57 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL7 DEL21 DEL8 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL27 DEL36 DEL38 DEL9 DEL41 DEL8 DEL25 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL8 DEL70 DEL9 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL33 DEL27 DEL27 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL45 DEL32 DEL27 DEL41 DEL8 DEL31
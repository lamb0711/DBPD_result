[GEODE-2324] keep private variables private.

* Update AcceptorImplDUnit test,
* Refactor AcceptorImpl.close into multiple methods.
* Remove a commented-out method.

-import org.apache.geode.internal.cache.tier.sockets.command.AcceptorImplObserver;
-  private volatile boolean shutdown = false;
+  private volatile boolean shutdownStarted = false;
-  // Assumed non-null. Do not set this to null.
-  private static AcceptorImplObserver acceptorImplObserver_do_not_access_directly =
-      new AcceptorImplObserver() {
-        @Override
-        public void beforeClose(AcceptorImpl acceptorImpl) {}
-
-        @Override
-        public void normalCloseTermination(AcceptorImpl acceptorImpl) {}
-
-        @Override
-        public void afterClose(AcceptorImpl acceptorImpl) {}
-      };
-
-  private static AcceptorImplObserver getAcceptorImplObserver() {
-    synchronized (AcceptorImpl.class) {
-      return acceptorImplObserver_do_not_access_directly;
-    }
-  }
-
-  public static void setObserver_TESTONLY(AcceptorImplObserver observer) {
-    synchronized (AcceptorImpl.class) {
-      if (observer != null) {
-        acceptorImplObserver_do_not_access_directly = observer;
-      }
-    }
-  }
-
-    return !this.shutdown;
+    return !this.shutdownStarted;
-    AcceptorImplObserver acceptorImplObserver = getAcceptorImplObserver();
-        acceptorImplObserver.beforeClose(this);
-        this.shutdown = true;
+        this.shutdownStarted = true;
-          // Well, we tried. Continue shutting down.
+
-        if (isSelector()) {
-          this.hsTimer.cancel();
-          if (this.tmpSel != null) {
-            try {
-              this.tmpSel.close();
-            } catch (IOException ignore) {
-            }
-          }
-          try {
-            wakeupSelector();
-            this.selector.close();
-          } catch (IOException ignore) {
-          }
-          if (this.selectorThread != null) {
-            this.selectorThread.interrupt();
-          }
-          this.commBufferQueue.clear();
-        }
+        shutdownSelectorIfIsSelector();
-        this.pool.shutdown();
-
-        try {
-          if (!this.pool.awaitTermination(PoolImpl.SHUTDOWN_TIMEOUT, TimeUnit.MILLISECONDS)) {
-            logger.warn(LocalizedMessage.create(
-                LocalizedStrings.PoolImpl_TIMEOUT_WAITING_FOR_BACKGROUND_TASKS_TO_COMPLETE));
-            this.pool.shutdownNow();
-          }
-        } catch (InterruptedException ignore) {
-          Thread.currentThread().interrupt();
-          this.pool.shutdownNow();
-        }
-        this.hsPool.shutdownNow();
+        shutdownPools();
-        GemFireCacheImpl myCache = (GemFireCacheImpl) cache;
-        if (!myCache.forcedDisconnect()) {
-          Set<PartitionedRegion> prs = myCache.getPartitionedRegions();
-          for (PartitionedRegion pr : prs) {
-            Map<Integer, BucketAdvisor.BucketProfile> profiles =
-                new HashMap<Integer, BucketAdvisor.BucketProfile>();
-            // get all local real bucket advisors
-            Map<Integer, BucketAdvisor> advisors = pr.getRegionAdvisor().getAllBucketAdvisors();
-            for (Map.Entry<Integer, BucketAdvisor> entry : advisors.entrySet()) {
-              BucketAdvisor advisor = entry.getValue();
-              BucketProfile bp = (BucketProfile) advisor.createProfile();
-              advisor.updateServerBucketProfile(bp);
-              profiles.put(entry.getKey(), bp);
-            }
-            Set receipients = new HashSet();
-            receipients = pr.getRegionAdvisor().adviseAllPRNodes();
-            // send it to all in one messgae
-            ReplyProcessor21 reply = AllBucketProfilesUpdateMessage.send(receipients,
-                pr.getDistributionManager(), pr.getPRId(), profiles, true);
-            if (reply != null) {
-              reply.waitForRepliesUninterruptibly();
-            }
-
-            if (logger.isDebugEnabled()) {
-              logger.debug("sending messages to all peers for removing this server..");
-            }
-          }
-        }
-        acceptorImplObserver.normalCloseTermination(this);
+        notifyCacheMembersOfClose();
-    } finally {
-      acceptorImplObserver.afterClose(this);
+  private void notifyCacheMembersOfClose() {
+    GemFireCacheImpl myCache = (GemFireCacheImpl) cache;
+    if (!myCache.forcedDisconnect()) {
+      for (PartitionedRegion pr : myCache.getPartitionedRegions()) {
+        Map<Integer, BucketAdvisor.BucketProfile> profiles = new HashMap<>();
+        // get all local real bucket advisors
+        Map<Integer, BucketAdvisor> advisors = pr.getRegionAdvisor().getAllBucketAdvisors();
+        for (Map.Entry<Integer, BucketAdvisor> entry : advisors.entrySet()) {
+          BucketAdvisor advisor = entry.getValue();
+          BucketProfile bp = (BucketProfile) advisor.createProfile();
+          advisor.updateServerBucketProfile(bp);
+          profiles.put(entry.getKey(), bp);
+        }
+
+        Set recipients = pr.getRegionAdvisor().adviseAllPRNodes();
+        // send it to all in one message
+        ReplyProcessor21 reply = AllBucketProfilesUpdateMessage.send(recipients,
+            pr.getDistributionManager(), pr.getPRId(), profiles, true);
+        if (reply != null) {
+          reply.waitForRepliesUninterruptibly();
+        }
+
+        if (logger.isDebugEnabled()) {
+          logger.debug("sending messages to all peers for removing this server..");
+        }
+      }
+    }
+  }
+
+  private void shutdownSelectorIfIsSelector() {
+    if (isSelector()) {
+      this.hsTimer.cancel();
+      if (this.tmpSel != null) {
+        try {
+          this.tmpSel.close();
+        } catch (IOException ignore) {
+        }
+      }
+      try {
+        wakeupSelector();
+        this.selector.close();
+      } catch (IOException ignore) {
+      }
+      if (this.selectorThread != null) {
+        this.selectorThread.interrupt();
+      }
+      this.commBufferQueue.clear();
+    }
+  }
+
+  private void shutdownPools() {
+    this.pool.shutdown();
+    try {
+      if (!this.pool.awaitTermination(PoolImpl.SHUTDOWN_TIMEOUT, TimeUnit.MILLISECONDS)) {
+        logger.warn(LocalizedMessage
+            .create(LocalizedStrings.PoolImpl_TIMEOUT_WAITING_FOR_BACKGROUND_TASKS_TO_COMPLETE));
+        this.pool.shutdownNow();
+      }
+    } catch (InterruptedException ignore) {
+      Thread.currentThread().interrupt();
+      this.pool.shutdownNow();
+    }
+    this.hsPool.shutdownNow();
+  }
+
+  public boolean isShutdownProperly() {
+    return !isRunning() && (selectorThread == null || !selectorThread.isAlive())
+        && (pool == null || pool.isShutdown()) && (hsPool == null || hsPool.isShutdown())
+        && (selector == null || !selector.isOpen());
+  }
-  // protected InetAddress getBindAddress() {
-  // return this.bindAddress;
-  // }
-
-  // /**
-  // * Calculates the bind address based on gemfire.properties.
-  // * Returns null if no bind address is configured.
-  // * @since GemFire 5.7
-  // */
-  // public static InetAddress calcBindAddress(Cache cache) throws IOException {
-  // InternalDistributedSystem system = (InternalDistributedSystem)cache
-  // .getDistributedSystem();
-  // DistributionConfig config = system.getConfig();
-  // InetAddress address = null;
-
-  // // Get the server-bind-address. If it is not null, use it.
-  // // If it is null, get the bind-address. If it is not null, use it.
-  // // Otherwise set default.
-  // String serverBindAddress = config.getServerBindAddress();
-  // if (serverBindAddress != null && serverBindAddress.length() > 0) {
-  // address = InetAddress.getByName(serverBindAddress);
-  // } else {
-  // String bindAddress = config.getBindAddress();
-  // if (bindAddress != null && bindAddress.length() > 0) {
-  // address = InetAddress.getByName(bindAddress);
-  // }
-  // }
-  // return address;
-  // }

INS31 INS31 INS31 INS31 INS31 MOV78 INS83 INS39 INS42 INS8 MOV78 MOV83 MOV39 UPD42 MOV42 INS8 UPD83 INS42 MOV8 UPD83 MOV83 MOV39 INS42 MOV8 UPD83 MOV83 MOV39 UPD42 MOV42 MOV8 UPD83 MOV83 INS39 INS42 INS8 UPD42 INS41 INS54 MOV25 MOV21 MOV54 MOV21 INS41 INS38 INS8 MOV12 INS27 INS22 INS51 INS38 INS36 INS36 INS36 INS36 INS52 INS42 INS42 INS8 MOV32 INS32 INS27 INS27 INS27 INS27 MOV25 INS21 MOV21 MOV25 MOV54 MOV21 INS21 MOV21 MOV21 MOV21 INS21 MOV21 INS21 INS42 INS27 INS38 INS27 INS32 INS27 INS32 INS27 INS38 INS7 INS32 INS32 INS32 MOV43 INS42 INS33 INS32 INS42 INS33 INS42 INS42 UPD42 MOV42 MOV33 INS42 INS42 INS42 INS33 INS32 INS22 INS9 INS42 INS42 INS42 UPD42 MOV32 INS42 INS42 INS42 INS42 INS52 INS42 UPD74 UPD42 DEL40 DEL26 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL78 DEL42 DEL43 DEL42 DEL44 DEL8 DEL31 DEL42 DEL78 DEL42 DEL42 DEL43 DEL42 DEL44 DEL31 DEL42 DEL78 DEL42 DEL43 DEL42 DEL44 DEL31 DEL1 DEL14 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL57 DEL42 DEL41 DEL8 DEL51 DEL8 DEL31 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL57 DEL27 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL8 DEL51 DEL8 DEL31 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL38 DEL41 DEL8 DEL31 DEL42 DEL42 DEL52 DEL32 DEL21 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL42 DEL43 DEL74 DEL42 DEL59 DEL60 DEL42 DEL42 DEL43 DEL40 DEL43 DEL42 DEL43 DEL42 DEL43 DEL14 DEL42 DEL7 DEL21 DEL42 DEL42 DEL52 DEL32 DEL21 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL51 DEL8 DEL42 DEL42 DEL52 DEL32 DEL21 DEL8 DEL54 DEL8
GEODE-6772: create index will use region to determine the group inforâ€¦ (#3590)



+import static org.apache.geode.management.internal.cli.remote.CommandExecutor.RUN_ON_MEMBER_CHANGE_NOT_PERSISTED;
+import static org.apache.geode.management.internal.cli.remote.CommandExecutor.SERVICE_NOT_RUNNING_CHANGE_NOT_PERSISTED;
+
+import java.util.Arrays;
+import java.util.HashSet;
+import joptsimple.internal.Strings;
-import org.apache.geode.cache.configuration.CacheConfig;
+import org.apache.geode.distributed.internal.InternalConfigurationPersistenceService;
+import org.apache.geode.management.api.ClusterManagementService;
-import org.apache.geode.management.cli.SingleGfshCommand;
+import org.apache.geode.management.cli.GfshCommand;
+import org.apache.geode.management.configuration.RuntimeRegionConfig;
+import org.apache.geode.management.internal.cli.result.model.InfoResultModel;
-import org.apache.geode.management.internal.exceptions.EntityNotFoundException;
-public class CreateIndexCommand extends SingleGfshCommand {
+public class CreateIndexCommand extends GfshCommand {
-          help = CliStrings.CREATE_INDEX__GROUP__HELP) final String[] groups) {
+          help = CliStrings.CREATE_INDEX__GROUP__HELP) String[] groups) {
-    final Set<DistributedMember> targetMembers = findMembers(groups, memberNameOrID);
+    // first find out what groups this region belongs to when using cluster configuration
+    InternalConfigurationPersistenceService ccService = getConfigurationPersistenceService();
+    ClusterManagementService cms = getClusterManagementService();
+    final Set<DistributedMember> targetMembers;
+    ResultModel resultModel = new ResultModel();
+    InfoResultModel info = resultModel.addInfo();
+    String regionName = null;
+    // if cluster management service is enabled and user did not specify a member id, then
+    // we will find the applicable members based on the what group this region is on
+    if (ccService != null && memberNameOrID == null) {
+      regionName = getValidRegionName(regionPath, cms);
+      RuntimeRegionConfig config = getRuntimeRegionConfig(cms, regionName);
+      if (config == null) {
+        return ResultModel.createError("Region " + regionName + " does not exist.");
+      }
+      String[] calculatedGroups = config.getGroups().toArray(new String[0]);
+      if (groups != null && !containsExactlyInAnyOrder(groups, calculatedGroups)) {
+        info.addLine("--groups=" + Strings.join(groups, ",") + " is ignored.");
+      }
+      groups = calculatedGroups;
+      targetMembers = findMembers(groups, null);
+    }
+    // otherwise use the group/members specified in the option to find the applicable members.
+    else {
+      targetMembers = findMembers(groups, memberNameOrID);
+    }
-    ResultModel result = ResultModel.createMemberStatusResult(functionResults);
-    result.setConfigObject(index);
-    return result;
+    resultModel.addTableAndSetStatus("createIndex", functionResults, true, false);
+
+    if (!resultModel.isSuccessful()) {
+      return resultModel;
+    }
+
+    // update the cluster configuration. Can't use SingleGfshCommand to do the update since in some
+    // cases
+    // groups information is inferred by the region, and the --group option might have the wrong
+    // group
+    // information.
+    if (ccService == null) {
+      info.addLine(SERVICE_NOT_RUNNING_CHANGE_NOT_PERSISTED);
+      return resultModel;
+    }
+    if (memberNameOrID != null) {
+      info.addLine(RUN_ON_MEMBER_CHANGE_NOT_PERSISTED);
+      return resultModel;
+    }
+
+    final InfoResultModel groupStatus = resultModel.addInfo("groupStatus");
+    String finalRegionName = regionName;
+    // at this point, groups should be the regionConfig's groups
+    if (groups.length == 0) {
+      groups = new String[] {"cluster"};
+    }
+    for (String group : groups) {
+      ccService.updateCacheConfig(group, cacheConfig -> {
+        RegionConfig regionConfig = cacheConfig.findRegionConfiguration(finalRegionName);
+        regionConfig.getIndexes().add(index);
+        groupStatus
+            .addLine("Cluster configuration for group '" + group + "' is updated.");
+        return cacheConfig;
+      });
+    }
+    return resultModel;
-  String getValidRegionName(String regionPath, CacheConfig cacheConfig) {
+  private static boolean containsExactlyInAnyOrder(String[] a, String[] b) {
+    return new HashSet(Arrays.asList(a)).equals(new HashSet(Arrays.asList(b)));
+  }
+
+  // find a valid regionName when regionPath passed in is in the form of
+  // "/region1.fieldName.fieldName x"
+  // this also handles the possibility when regionName has "." in it, like "/A.B". It's stripping
+  // . part one by one and check if the remaining part is a valid region name or not. If we
+  // could not find a region with any part of the name, (like, couldn't find A.B or A), then A is
+  // returned.
+  String getValidRegionName(String regionPath, ClusterManagementService cms) {
-    String[] regionPathTokens = regionPath.trim().split(" ");
-    regionPath = regionPathTokens[0];
+    String regionName = regionPath.trim().split(" ")[0];
-    while (regionPath.contains(".") && cacheConfig.findRegionConfiguration(regionPath) == null) {
-      regionPath = regionPath.substring(0, regionPath.lastIndexOf("."));
+    while (regionName.contains(".")) {
+      RuntimeRegionConfig region = getRuntimeRegionConfig(cms, regionName);
+      if (region != null) {
+        break;
+      }
+      // otherwise, strip one more . part off the regionName
+      else {
+        regionName = regionName.substring(0, regionName.lastIndexOf("."));
+      }
-    return regionPath;
+    return regionName;
-  @Override
-  public boolean updateConfigForGroup(String group, CacheConfig config, Object element) {
-    RegionConfig.Index index = (RegionConfig.Index) element;
-    String regionPath = getValidRegionName(index.getFromClause(), config);
-
-    RegionConfig regionConfig = config.findRegionConfiguration(regionPath);
-    if (regionConfig == null) {
-      throw new EntityNotFoundException("Region " + index.getFromClause() + " not found.");
+  RuntimeRegionConfig getRuntimeRegionConfig(ClusterManagementService cms,
+      String regionName) {
+    RegionConfig regionConfig = new RegionConfig();
+    regionConfig.setName(regionName);
+    List<RuntimeRegionConfig> list = cms.list(regionConfig).getResult(RuntimeRegionConfig.class);
+    if (list.isEmpty()) {
+      return null;
+    } else {
+      return list.get(0);
-    regionConfig.getIndexes().add(index);
-    return true;
+
+

MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 UPD40 INS40 UPD40 UPD43 INS31 UPD42 INS83 INS83 INS39 INS42 INS44 INS44 INS8 INS43 INS43 INS42 INS60 INS60 INS60 INS60 INS60 INS25 INS21 INS25 INS25 INS25 INS60 INS60 INS25 INS70 INS5 INS42 INS5 INS42 INS41 INS42 UPD43 UPD42 UPD42 MOV42 UPD43 UPD42 UPD43 UPD42 INS21 INS60 INS25 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS27 INS8 INS8 INS32 INS38 INS8 INS27 INS8 INS27 INS8 INS83 INS43 INS59 MOV43 INS59 INS27 INS8 MOV44 INS42 INS8 UPD42 INS43 INS85 INS43 INS85 INS32 UPD42 MOV43 INS32 INS8 UPD42 UPD42 UPD42 UPD43 INS32 INS74 INS59 INS32 INS8 INS8 INS42 INS42 INS32 INS42 INS42 INS32 INS42 UPD42 MOV42 INS14 INS42 INS42 INS32 INS42 INS42 INS33 INS27 INS27 INS21 INS60 INS25 INS60 INS25 INS21 INS21 INS21 UPD42 MOV42 UPD42 MOV42 INS45 MOV42 INS9 INS9 INS32 INS41 INS42 INS33 INS21 INS41 INS42 INS33 INS21 INS41 INS42 INS42 INS32 INS42 INS42 INS40 INS34 INS21 MOV21 INS42 INS42 INS14 INS42 INS14 UPD42 INS2 UPD42 MOV42 MOV42 MOV45 INS60 INS25 INS42 UPD42 INS14 INS42 UPD42 MOV42 UPD42 MOV42 INS43 INS43 UPD42 MOV42 INS32 UPD42 MOV42 UPD42 MOV42 INS41 INS41 INS42 INS42 MOV43 INS42 INS42 INS42 INS33 INS42 INS33 INS7 INS43 INS59 INS27 INS8 INS5 INS59 INS27 INS8 INS7 INS7 INS7 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS45 INS7 INS42 INS43 INS32 INS43 INS32 MOV32 INS34 INS43 INS59 INS27 INS8 INS8 INS43 INS42 UPD42 MOV42 INS32 INS42 INS57 INS33 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS33 INS41 INS43 INS85 INS42 INS32 INS27 INS38 INS21 INS42 INS42 INS42 INS32 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS3 INS42 INS42 INS42 INS86 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 MOV33 INS10 MOV21 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS43 UPD42 MOV42 UPD42 MOV42 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS3 INS42 INS33 INS32 INS32 INS42 INS42 INS33 INS5 INS4 INS59 INS8 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS27 INS42 INS42 MOV5 INS34 INS42 INS42 INS42 INS42 INS42 INS27 INS43 INS85 INS45 INS42 INS60 MOV21 INS21 INS41 UPD42 INS45 INS42 INS45 INS45 INS32 INS45 INS42 MOV43 INS59 INS32 INS42 UPD42 INS42 INS42 INS42 INS45 INS42 INS42 INS32 INS42 INS42 INS27 UPD42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS45 INS42 INS45 DEL83 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL34 DEL2 DEL7 DEL21 DEL32 DEL32 DEL27 DEL27 DEL8 DEL42 DEL78 DEL83 DEL39 DEL42 DEL40 DEL40 DEL43 DEL42 DEL11 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL43 DEL45 DEL32 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL9 DEL41
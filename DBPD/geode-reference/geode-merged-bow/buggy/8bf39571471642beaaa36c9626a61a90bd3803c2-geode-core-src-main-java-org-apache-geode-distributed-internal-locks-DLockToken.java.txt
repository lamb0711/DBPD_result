Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * A DistributedLockService contains a collection of DLockToken
- * instances, one for each name in that DistributedLockService for which
- * a lock has ever been requested.  The token identifies whether that
- * name is currently locked, and which distribution manager and thread owns 
- * the lock.
+ * A DistributedLockService contains a collection of DLockToken instances, one for each name in that
+ * DistributedLockService for which a lock has ever been requested. The token identifies whether
+ * that name is currently locked, and which distribution manager and thread owns the lock.
-  
-  // -------------------------------------------------------------------------
-  //   Instance variables
-  // -------------------------------------------------------------------------
-  
-   /** 
-    * Lock name for this lock. Logically final but set by fromData.
-    */
-   private final Object name;
-   
-   /** 
-    * DistributionManager using this lock token. Reference is used to identify
-    * local member identity and to {@link DLockService#getLockTimeStamp(DM)}.
-    */
-   private final DM dm;
-   
-   /** 
-    * The reply processor id is used to identify the distinct lease which a
-    * thread has used to lease this lock.
-    */
-   private int leaseId = -1;
-   /**
-    * The absolute time at which the current lease on this lock will expire.  
-    * -1 represents a lease which will not expire until explicitly released.
-    */
-   private long leaseExpireTime = -1;
-   
-   /** 
-    * Remotable identity of thread currently leasing this lock.
-    */
-   private RemoteThread lesseeThread = null;
-   
-   /** 
-    * Counter that indicates number of times this lock has been re-entered
-    * for the current lease.
-    */
-   private int recursion;
-   
-  /** 
+  // -------------------------------------------------------------------------
+  // Instance variables
+  // -------------------------------------------------------------------------
+
+  /**
+   * Lock name for this lock. Logically final but set by fromData.
+   */
+  private final Object name;
+
+  /**
+   * DistributionManager using this lock token. Reference is used to identify local member identity
+   * and to {@link DLockService#getLockTimeStamp(DM)}.
+   */
+  private final DM dm;
+
+  /**
+   * The reply processor id is used to identify the distinct lease which a thread has used to lease
+   * this lock.
+   */
+  private int leaseId = -1;
+
+  /**
+   * The absolute time at which the current lease on this lock will expire. -1 represents a lease
+   * which will not expire until explicitly released.
+   */
+  private long leaseExpireTime = -1;
+
+  /**
+   * Remotable identity of thread currently leasing this lock.
+   */
+  private RemoteThread lesseeThread = null;
+
+  /**
+   * Counter that indicates number of times this lock has been re-entered for the current lease.
+   */
+  private int recursion;
+
+  /**
-   * {@link org.apache.geode.distributed.LeaseExpiredException}.
-   * Keys are threads that have had their lease expire on this lock,
-   * but may not yet have noticed.  Would use weak set if available.
-   * Entry is removed upon throwing LeaseExpiredException. Protected by
-   * synchronization on this lock token.
+   * {@link org.apache.geode.distributed.LeaseExpiredException}. Keys are threads that have had
+   * their lease expire on this lock, but may not yet have noticed. Would use weak set if available.
+   * Entry is removed upon throwing LeaseExpiredException. Protected by synchronization on this lock
+   * token.
-  
-  /** 
+
+  /**
-  
-  /** 
+
+  /**
-  
-  /** 
+
+  /**
-  
+
-  
+
-  //   Constructors
+  // Constructors
-  
+
-  //   Public accessors
+  // Public accessors
-  
+
-   * Returns the lock re-entry recursion of the current lease or -1 if there is
-   * no current lease. Caller must synchronize on this lock token. 
+   * Returns the lock re-entry recursion of the current lease or -1 if there is no current lease.
+   * Caller must synchronize on this lock token.
-   * Public because {@link 
-   * org.apache.geode.internal.admin.remote.RemoteDLockInfo} is a caller.
+   * Public because {@link org.apache.geode.internal.admin.remote.RemoteDLockInfo} is a caller.
-  
+
-   * Returns the name of the actual local thread leasing this lock or null
-   * if there is no lease. Caller must synchronize on this lock token. 
+   * Returns the name of the actual local thread leasing this lock or null if there is no lease.
+   * Caller must synchronize on this lock token.
-   * Public because {@link 
-   * org.apache.geode.internal.admin.remote.RemoteDLockInfo} is a caller.
+   * Public because {@link org.apache.geode.internal.admin.remote.RemoteDLockInfo} is a caller.
-  
+
-   * Returns the actual local thread leasing this lock or null
-   * if there is no lease.
+   * Returns the actual local thread leasing this lock or null if there is no lease.
-  
+
-   * Returns the absolute time at which the current lease will expire or -1
-   * if there is no lease. Caller must synchronize on this lock token.
+   * Returns the absolute time at which the current lease will expire or -1 if there is no lease.
+   * Caller must synchronize on this lock token.
-   * Public because {@link 
-   * org.apache.geode.internal.admin.remote.RemoteDLockInfo} is a caller.
+   * Public because {@link org.apache.geode.internal.admin.remote.RemoteDLockInfo} is a caller.
-  
+
-  
+
-  //   Package accessors
+  // Package accessors
-  
+
-   * Returns the identifying name of this lock. Caller must synchronize on
-   * this lock token if instance was deserialized.
+   * Returns the identifying name of this lock. Caller must synchronize on this lock token if
+   * instance was deserialized.
-  
+
-   * Returns the lease id currently used to hold a lease on this lock or -1
-   * if no thread currently holds this lock. Caller must synchronize on this
-   * token.
+   * Returns the lease id currently used to hold a lease on this lock or -1 if no thread currently
+   * holds this lock. Caller must synchronize on this token.
-  
+
-   * Returns the remotable identity of the thread currently leasing this 
-   * lock or null if no thread currently holds this lock. Caller must 
-   * synchronize on this lock token.
+   * Returns the remotable identity of the thread currently leasing this lock or null if no thread
+   * currently holds this lock. Caller must synchronize on this lock token.
-  
+
-   * Increment usage count for this lock token. Caller must synchronize on 
-   * this lock token.
+   * Increment usage count for this lock token. Caller must synchronize on this lock token.
-  
+
-   * Decrement usage count for this lock token. Caller must synchronize on 
-   * this lock token.
+   * Decrement usage count for this lock token. Caller must synchronize on this lock token.
-  
+
-   * Returns true if the usage count for this lock token is greater than zero.
-   * Caller must synchronize on this lock token.
+   * Returns true if the usage count for this lock token is greater than zero. Caller must
+   * synchronize on this lock token.
-  
+
-  //   Package operations
+  // Package operations
-    //checkDestroyed();
+    // checkDestroyed();
-   * Returns the current time in absolute milliseconds for use calculating
-   * lease expiration times.
+   * Returns the current time in absolute milliseconds for use calculating lease expiration times.
-    if (this.dm == null) return -1;
+    if (this.dm == null)
+      return -1;
-  
+
-   * Throws LeaseExpiredException if the calling thread's lease on this lock
-   * previously expired. The expired lease will no longer be tracked after
-   * throwing LeaseExpiredException. Caller must synchronize on this lock 
-   * token.
+   * Throws LeaseExpiredException if the calling thread's lease on this lock previously expired. The
+   * expired lease will no longer be tracked after throwing LeaseExpiredException. Caller must
+   * synchronize on this lock token.
-  void throwIfCurrentThreadHadExpiredLease() 
-  throws LeaseExpiredException {
+  void throwIfCurrentThreadHadExpiredLease() throws LeaseExpiredException {
-      throw new LeaseExpiredException(LocalizedStrings.DLockToken_THIS_THREADS_LEASE_EXPIRED_FOR_THIS_LOCK.toLocalizedString());
+      throw new LeaseExpiredException(
+          LocalizedStrings.DLockToken_THIS_THREADS_LEASE_EXPIRED_FOR_THIS_LOCK.toLocalizedString());
-  
+
-   * Checks the current lease for expiration and returns true if it has
-   * been marked as expired. Caller must synchronize on this lock token.
+   * Checks the current lease for expiration and returns true if it has been marked as expired.
+   * Caller must synchronize on this lock token.
-    
+
-    if (this.leaseId > -1 &&
-        this.leaseExpireTime < Long.MAX_VALUE) {
-    
+    if (this.leaseId > -1 && this.leaseExpireTime < Long.MAX_VALUE) {
+
-          logger.trace(LogMarker.DLS, "[checkForExpiration] Expiring token at {}: {}", currentTime, this);
+          logger.trace(LogMarker.DLS, "[checkForExpiration] Expiring token at {}: {}", currentTime,
+              this);
-    
+
-  }  
+  }
-   * Grants new lease to calling thread for this lock token. Synchronizes
-   * on this lock token.
+   * Grants new lease to calling thread for this lock token. Synchronizes on this lock token.
-  synchronized boolean grantLock(long newLeaseExpireTime, 
-                                 int newLeaseId, 
-                                 int newRecursion,
-                                 RemoteThread remoteThread) {
-    
+  synchronized boolean grantLock(long newLeaseExpireTime, int newLeaseId, int newRecursion,
+      RemoteThread remoteThread) {
+
-    Assert.assertTrue(newLeaseId > -1, 
-        "Invalid attempt to grant lock with leaseId " + newLeaseId);
-    
+    Assert.assertTrue(newLeaseId > -1, "Invalid attempt to grant lock with leaseId " + newLeaseId);
+
-    
+
-    
+
-    
+
-   * Returns true if there's currently a lease on this lock token. 
-   * Synchronizes on this lock token.
+   * Returns true if there's currently a lease on this lock token. Synchronizes on this lock token.
-  
+
-   * Returns true if lease on this lock token is held by calling thread or
-   * the specified remote thread. Caller must synchronize on this lock token.
+   * Returns true if lease on this lock token is held by calling thread or the specified remote
+   * thread. Caller must synchronize on this lock token.
-    }
-    else {
-      return this.lesseeThread != null  && remoteThread != null &&
-             this.lesseeThread.equals(remoteThread);
+    } else {
+      return this.lesseeThread != null && remoteThread != null
+          && this.lesseeThread.equals(remoteThread);
-  
+
-   * Returns true if lease on this lock token is held by calling thread. 
-   * Caller must synchronize on this lock token.
+   * Returns true if lease on this lock token is held by calling thread. Caller must synchronize on
+   * this lock token.
-  
+
-   * Returns true if this lock token should be ignored for grantor recovery.
-   * Caller must synchronize on this lock token.
+   * Returns true if this lock token should be ignored for grantor recovery. Caller must synchronize
+   * on this lock token.
-  
+
-   * Sets whether or not this lock token should be ignored for grantor recovery.
-   * Caller must synchronize on this lock token.
+   * Sets whether or not this lock token should be ignored for grantor recovery. Caller must
+   * synchronize on this lock token.
-  
-  /** 
-   * Releases the current lease on this lock token. Synchronizes on this lock
-   * token.
+
+  /**
+   * Releases the current lease on this lock token. Synchronizes on this lock token.
-  synchronized boolean releaseLock(int leaseIdToRelease, 
-                                   RemoteThread remoteThread) {
+  synchronized boolean releaseLock(int leaseIdToRelease, RemoteThread remoteThread) {
-  
-  /** 
-   * Releases the current lease on this lock token. Synchronizes on this lock
-   * token.
+
+  /**
+   * Releases the current lease on this lock token. Synchronizes on this lock token.
-  synchronized boolean releaseLock(int leaseIdToRelease, 
-                                   RemoteThread remoteThread,
-                                   boolean decRecursion) {
-    
-    if (leaseIdToRelease == -1) return false;
+  synchronized boolean releaseLock(int leaseIdToRelease, RemoteThread remoteThread,
+      boolean decRecursion) {
+
+    if (leaseIdToRelease == -1)
+      return false;
-    
+
-    if (!isLeaseHeld(leaseIdToRelease) || 
-        !isLeaseHeldByCurrentOrRemoteThread(remoteThread)) {
+    if (!isLeaseHeld(leaseIdToRelease) || !isLeaseHeldByCurrentOrRemoteThread(remoteThread)) {
-    
+
-    
+
-  
+
-   * Nulls out current lease and decrements usage count. Caller must be
-   * synchronized on this lock token.
+   * Nulls out current lease and decrements usage count. Caller must be synchronized on this lock
+   * token.
-    
+
-    
+
-  
+
-  //   Private implementation methods
+  // Private implementation methods
-  
+
-   * Returns true if lease is held using specified lease id. Caller must 
-   * synchronize on this lock token.
+   * Returns true if lease is held using specified lease id. Caller must synchronize on this lock
+   * token.
-  
+
-   * Increments or decrements usage count by the specified amount. Caller 
-   * must synchronize on this lock token.
+   * Increments or decrements usage count by the specified amount. Caller must synchronize on this
+   * lock token.
-      Assert.assertTrue(this.usageCount-amount >= 0, amount +
-          " cannot be subtracted from usageCount " + this.usageCount);
+      Assert.assertTrue(this.usageCount - amount >= 0,
+          amount + " cannot be subtracted from usageCount " + this.usageCount);
-  
+
-   * Increments or decrements recursion by the specified amount. Caller must
-   * synchronize on this lock token.
+   * Increments or decrements recursion by the specified amount. Caller must synchronize on this
+   * lock token.
-      Assert.assertTrue(this.recursion-amount >= 0, amount +
-          " cannot be subtracted from recursion " + this.recursion);
+      Assert.assertTrue(this.recursion - amount >= 0,
+          amount + " cannot be subtracted from recursion " + this.recursion);
-  
+
-   * Throws IllegalStateException if this lock token has been destroyed. 
-   * Caller must synchronize on this lock token.
+   * Throws IllegalStateException if this lock token has been destroyed. Caller must synchronize on
+   * this lock token.
-      IllegalStateException e = new IllegalStateException(LocalizedStrings.DLockToken_ATTEMPTING_TO_USE_DESTROYED_TOKEN_0.toLocalizedString(this));
+      IllegalStateException e = new IllegalStateException(
+          LocalizedStrings.DLockToken_ATTEMPTING_TO_USE_DESTROYED_TOKEN_0.toLocalizedString(this));
-  
+
-   * Record the token's owning thread as having lost its lease, so it can 
-   * throw an exception later if it tries to unlock. A weak reference to the 
-   * thread is used. Caller must synchronize on this lock token.
+   * Record the token's owning thread as having lost its lease, so it can throw an exception later
+   * if it tries to unlock. A weak reference to the thread is used. Caller must synchronize on this
+   * lock token.
-  //   java.lang.Object methods
+  // java.lang.Object methods
-  
+
-      return "DLockToken" + "@" + Integer.toHexString(hashCode()) + 
-             ", name: " + this.name + 
-             ", thread: <" + getThreadName() + ">" +
-             ", recursion: " + this.recursion +
-             ", leaseExpireTime: " + this.leaseExpireTime +
-             ", leaseId: " + this.leaseId +
-             ", ignoreForRecovery: " + this.ignoreForRecovery +
-             ", lesseeThread: " + this.lesseeThread +
-             ", usageCount: " + this.usageCount +
-             ", currentTime: " + getCurrentTime();
+      return "DLockToken" + "@" + Integer.toHexString(hashCode()) + ", name: " + this.name
+          + ", thread: <" + getThreadName() + ">" + ", recursion: " + this.recursion
+          + ", leaseExpireTime: " + this.leaseExpireTime + ", leaseId: " + this.leaseId
+          + ", ignoreForRecovery: " + this.ignoreForRecovery + ", lesseeThread: "
+          + this.lesseeThread + ", usageCount: " + this.usageCount + ", currentTime: "
+          + getCurrentTime();

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
Revert "GEODE-7938: added keys query param to GET, PUT, and DELETE /{region} endpoints (#4901)"

This reverts commit 6263f1f9a4782433d013c6b759bda8c84216b595.

-import java.net.URI;
-import org.apache.geode.rest.internal.web.controllers.support.UpdateOp;
-  @ApiOperation(value = "create entry", notes = "Create (put-if-absent) data in region."
-      + " The key is not decoded so if the key contains special characters use PUT /{region}?keys=EncodedKey&op=CREATE.")
+  @ApiOperation(value = "create entry", notes = "Create (put-if-absent) data in region")
+
+    logger.debug(
+        "Posting (creating/putIfAbsent) JSON document ({}) to Region ({}) with Key ({})...", json,
+        region, key);
+
-    return create(region, key, json, false);
-  }
-
-  private ResponseEntity<?> create(String region, String key, String json,
-      boolean keyInQueryParam) {
-    logger.debug("Create JSON document ({}) in Region ({}) with Key ({})...", json, region, key);
-
-    if (keyInQueryParam) {
-      headers.setLocation(toUriWithKeys(new String[] {encode(key)}, region));
-    } else {
-      headers.setLocation(toUri(region, key));
-    }
+    headers.setLocation(toUri(region, key));
-   * For the given region either gets all the region's data (with an optional limit),
-   * or gets the region's data for the given keys (optionally ignoring missing keys).
+   * Read all or fixed number of data in a given Region
-   * @param encodedKeys an optional comma separated list of encoded keys to read
-   * @param ignoreMissingKey if true and reading more than one key then if a key is missing ignore
-   *        it
-  @ApiOperation(value = "read all data for region or the specified keys",
-      notes = "If reading all data for region then the limit parameter can be used to give the maximum number of values to return."
-          + " If reading specific keys then the ignoreMissingKey parameter can be used to not fail if a key is missing.")
+  @ApiOperation(value = "read all data for region",
+      notes = "Read all data for region. Use limit param to get fixed or limited number of entries.")
+  @PreAuthorize("@securityService.authorize('DATA', 'READ', #region)")
-          defaultValue = DEFAULT_GETALL_RESULT_LIMIT) final String limit,
-      @RequestParam(value = "keys", required = false) final String[] encodedKeys,
-      @RequestParam(value = "ignoreMissingKey", required = false) final String ignoreMissingKey) {
-    region = decode(region);
-    if (encodedKeys == null || encodedKeys.length == 0) {
-      return getAllRegionData(region, limit);
-    } else {
-      String[] decodedKeys = decode(encodedKeys);
-      return getRegionKeys(region, ignoreMissingKey, decodedKeys, true);
-    }
-  }
-
-  private ResponseEntity<?> getAllRegionData(String region, String limit) {
-    securityService.authorize("DATA", "READ", region);
+          defaultValue = DEFAULT_GETALL_RESULT_LIMIT) final String limit) {
+
+    region = decode(region);
+
-      keyList = StringUtils.collectionToCommaDelimitedString(keys);
+      keyList = StringUtils.collectionToDelimitedString(keys, ",");
-        keyList = StringUtils.collectionToCommaDelimitedString(keys.subList(0, maxLimit));
+        keyList = StringUtils.collectionToDelimitedString(keys.subList(0, maxLimit), ",");
-    headers.set(HttpHeaders.CONTENT_LOCATION, toUri(region, keyList).toASCIIString());
+    headers.set("Content-Location", toUri(region, keyList).toASCIIString());
-  @RequestMapping(method = RequestMethod.GET, value = "/{region}/{keys}",
+  @RequestMapping(method = RequestMethod.GET, value = "/{region}/**",
-      notes = "Read data for specific set of keys in a region. Deprecated in favor of /{region}?keys=.")
+      notes = "Read data for specific set of keys in a region. The keys, ** in the endpoint, are a comma separated list.")
-  public ResponseEntity<?> readKeys(@PathVariable("region") String region,
-      @PathVariable("keys") final String[] keys,
-      @RequestParam(value = "ignoreMissingKey", required = false) final String ignoreMissingKey) {
-    region = decode(region);
-    return getRegionKeys(region, ignoreMissingKey, keys, false);
-  }
-
-  private ResponseEntity<?> getRegionKeys(String region, String ignoreMissingKey, String[] keys,
-      boolean keysInQueryParam) {
-    logger.debug("Reading data for keys ({}) in Region ({})", ArrayUtils.toString(keys), region);
+  public ResponseEntity<?> read(@PathVariable("region") String region,
+      @RequestParam(value = "ignoreMissingKey", required = false) final String ignoreMissingKey,
+      HttpServletRequest request) {
+    String[] keys = parseKeys(request, region);
+    logger.debug("Reading data for keys ({}) in Region ({})", ArrayUtils.toString(keys), region);
+
+    region = decode(region);
+
-      URI uri;
-      if (keysInQueryParam) {
-        String[] encodedKeys = encode(keys);
-        String encodedRegion = encode(region);
-        uri = this.toUriWithKeys(encodedKeys, encodedRegion);
-      } else {
-        uri = toUri(region, keys[0]);
-      }
-      headers.set(HttpHeaders.CONTENT_LOCATION, uri.toASCIIString());
+      headers.set("Content-Location", toUri(region, keys[0]).toASCIIString());
-      final Map<Object, Object> valueObjs = getValues(region, keys);
-      // valueObjs will have as its keys all of "keys".
-      // valueObjs will have a null value if the key did not exist.
-      // So if ignoreMissingKey is false we can use "null" values to detect the missing keys.
-        List<String> unknownKeys = new ArrayList<>();
-        // use "keys" to iterate so that we get the original key ordering from user.
-        for (String key : keys) {
-          if (valueObjs.get(key) == null) {
-            unknownKeys.add(key);
-          }
-        }
-        if (!unknownKeys.isEmpty()) {
-          String unknownKeysAsStr = StringUtils.collectionToCommaDelimitedString(unknownKeys);
-          String errorString = String.format("Requested keys (%1$s) not exist in region (%2$s)",
-              unknownKeysAsStr, region);
-          return new ResponseEntity<>(convertErrorAsJson(errorString), headers,
+        List<String> unknownKeys = checkForMultipleKeysExist(region, keys);
+        if (unknownKeys.size() > 0) {
+          String unknownKeysAsStr = StringUtils.collectionToDelimitedString(unknownKeys, ",");
+          String erroString = String.format("Requested keys (%1$s) not exist in region (%2$s)",
+              StringUtils.collectionToDelimitedString(unknownKeys, ","), region);
+          return new ResponseEntity<>(convertErrorAsJson(erroString), headers,
-      // The dev rest api was already released with null values being returned
-      // for non-existent keys.
-      // Order the keys in the result after the array of keys given to this method.
-      // Previous code returned them in random order which made the result harder to test and use.
+      final Map<Object, Object> valueObjs = getValues(region, keys);
-      URI uri;
-      if (keysInQueryParam) {
-        String[] encodedKeys = encode(keys);
-        String encodedRegion = encode(region);
-        uri = this.toUriWithKeys(encodedKeys, encodedRegion);
-      } else {
-        String keyList = StringUtils.arrayToCommaDelimitedString(keys);
-        uri = toUri(region, keyList);
-      }
+      // Do we need to remove null values from Map..?
+      // To Remove null value entries from map.
+      // valueObjs.values().removeAll(Collections.singleton(null));
-      headers.set(HttpHeaders.CONTENT_LOCATION, uri.toASCIIString());
+      // currently we are not removing keys having value null from the result.
+      String keyList = StringUtils.collectionToDelimitedString(valueObjs.keySet(), ",");
+      headers.set("Content-Location", toUri(region, keyList).toASCIIString());
-      // add the values in the same order as the original keys
-      // the code used to use valueObj.values() which used "hash" ordering.
-      for (String key : keys) {
-        data.add(valueObjs.get(key));
-      }
+      data.add(valueObjs.values());
-   * @param keys comma separated list of keys
-  @RequestMapping(method = RequestMethod.PUT, value = "/{region}/{keys}",
+  @RequestMapping(method = RequestMethod.PUT, value = "/{region}/**",
-          + " Deprecated in favor of /{region}?keys=."
+          + " The keys, ** in the endpoint, are a comma separated list."
-  @PreAuthorize("@securityService.authorize('WRITE', #region, #keys)")
-      @PathVariable("keys") String[] keys,
+    String[] keys = parseKeys(request, region);
+    securityService.authorize("WRITE", region, keys);
-    if (!validOp(opValue)) {
-      String errorMessage = String.format(
-          "The op parameter (%1$s) is not valid. Valid values are PUT, REPLACE, or CAS.",
-          opValue);
-      return new ResponseEntity<>(convertErrorAsJson(errorMessage), HttpStatus.BAD_REQUEST);
-    }
-      updateMultipleKeys(region, keys, json);
-      HttpHeaders headers = new HttpHeaders();
-      headers.setLocation(toUri(region, StringUtils.arrayToCommaDelimitedString(keys)));
-      return new ResponseEntity<>(headers, HttpStatus.OK);
+      return updateMultipleKeys(region, keys, json);
-      Object existingValue = updateSingleKey(region, keys[0], json, opValue);
-      final HttpHeaders headers = new HttpHeaders();
-      headers.setLocation(toUri(region, keys[0]));
-      return new ResponseEntity<>(existingValue, headers,
-          (existingValue == null ? HttpStatus.OK : HttpStatus.CONFLICT));
-    }
-  }
-
-  private boolean validOp(String opValue) {
-    try {
-      UpdateOp.valueOf(opValue.toUpperCase());
-      return true;
-    } catch (IllegalArgumentException ex) {
-      return false;
-    }
-  }
-
-  /**
-   * Update data for a key or set of keys
-   *
-   * @param encodedRegion gemfire data region
-   * @param encodedKeys comma separated list of keys
-   * @param opValue type of update (put, replace, cas etc)
-   * @param json new data for the key(s)
-   * @return JSON document
-   */
-  @RequestMapping(method = RequestMethod.PUT, value = "/{region}",
-      consumes = {APPLICATION_JSON_UTF8_VALUE}, produces = {
-          APPLICATION_JSON_UTF8_VALUE})
-  @ApiOperation(value = "update data for key(s)",
-      notes = "Update or insert (put) data for keys in a region."
-          + " The keys are a comma separated list."
-          + " If multiple keys are given then put (create or update) the data for each key."
-          + " The op parameter is ignored if more than one key is given."
-          + " If op=PUT, the default, create or update data for the given key."
-          + " If op=CREATE, create data for the given key if and only if the key does not exit in the region."
-          + " If op=REPLACE, update (replace) data for the given key if and only if the key exists in the region."
-          + " If op=CAS, update (compare-and-set) value having key with a new value if and only if the \"@old\" value sent matches the current value for the key in the region.")
-  @ApiResponses({@ApiResponse(code = 200, message = "OK."),
-      @ApiResponse(code = 201, message = "For op=CREATE on success."),
-      @ApiResponse(code = 400, message = "Bad Request."),
-      @ApiResponse(code = 401, message = "Invalid Username or Password."),
-      @ApiResponse(code = 403, message = "Insufficient privileges for operation."),
-      @ApiResponse(code = 404,
-          message = "Region does not exist or if key is not mapped to some value for REPLACE or CAS."),
-      @ApiResponse(code = 409,
-          message = "For op=CREATE, key already exist in region. For op=CAS, @old value does not match to the current value in region."),
-      @ApiResponse(code = 500, message = "GemFire throws an error or exception.")})
-  public ResponseEntity<?> updateKeys(@PathVariable("region") final String encodedRegion,
-      @RequestParam(value = "keys") final String[] encodedKeys,
-      @RequestParam(value = "op", defaultValue = "PUT") final String opValue,
-      @RequestBody final String json) {
-
-    String decodedRegion = decode(encodedRegion);
-    String[] decodedKeys = decode(encodedKeys);
-    if (!validOp(opValue) && !opValue.equalsIgnoreCase("CREATE")) {
-      String errorMessage = String.format(
-          "The op parameter (%1$s) is not valid. Valid values are PUT, CREATE, REPLACE, or CAS.",
-          opValue);
-      return new ResponseEntity<>(convertErrorAsJson(errorMessage), HttpStatus.BAD_REQUEST);
-    }
-
-    if (decodedKeys.length > 1) {
-      // putAll case
-      logger.debug("updating keys ({}) for region ({}) op={}", decodedKeys, decodedRegion, opValue);
-      securityService.authorize("WRITE", decodedRegion, decodedKeys);
-      updateMultipleKeys(decodedRegion, decodedKeys, json);
-      HttpHeaders headers = new HttpHeaders();
-      headers.setLocation(toUriWithKeys(encodedKeys, encodedRegion));
-      return new ResponseEntity<>(headers, HttpStatus.OK);
-    } else if (opValue.equalsIgnoreCase("CREATE")) {
-      securityService.authorize("DATA", "WRITE", decodedRegion);
-      return create(decodedRegion, decodedKeys[0], json, true);
-    } else {
-      // put case
-      logger.debug("updating keys ({}) for region ({}) op={}", decodedKeys, decodedRegion, opValue);
-      securityService.authorize("WRITE", decodedRegion, decodedKeys);
-      Object existingValue = updateSingleKey(decodedRegion, decodedKeys[0], json, opValue);
-      final HttpHeaders headers = new HttpHeaders();
-      headers.setLocation(toUriWithKeys(encodedKeys, encodedRegion));
-      return new ResponseEntity<>(existingValue, headers,
-          (existingValue == null ? HttpStatus.OK : HttpStatus.CONFLICT));
+      return updateSingleKey(region, keys[0], json, opValue);

INS8 MOV29 MOV77 INS77 MOV79 INS79 INS83 INS42 MOV44 MOV44 MOV29 MOV77 INS77 MOV79 INS83 INS42 MOV44 MOV44 MOV21 MOV21 INS21 MOV21 MOV60 MOV60 MOV25 MOV60 MOV21 MOV25 INS42 INS80 INS80 INS42 INS45 MOV21 INS42 MOV80 INS80 INS43 INS42 INS60 MOV21 MOV60 MOV21 INS25 INS45 INS32 UPD66 INS42 INS45 INS42 INS45 UPD45 INS42 INS45 INS42 MOV5 INS59 MOV60 UPD45 MOV5 MOV27 INS8 MOV8 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS42 INS32 MOV21 MOV60 MOV21 UPD45 UPD42 UPD42 UPD42 MOV42 INS45 MOV42 MOV42 MOV41 INS42 INS42 INS42 INS32 MOV43 UPD42 UPD42 UPD42 MOV32 MOV32 INS42 INS42 INS45 INS32 INS60 INS45 UPD42 MOV42 MOV42 UPD42 INS45 MOV32 INS42 MOV74 INS59 INS27 UPD42 INS32 INS45 INS32 UPD42 MOV42 MOV42 INS32 INS32 INS34 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 INS45 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 MOV43 MOV43 UPD42 UPD42 INS45 INS32 UPD42 INS42 INS42 UPD42 MOV42 INS45 DEL40 DEL26 DEL40 DEL26 DEL45 DEL45 DEL27 DEL9 DEL32 DEL41 DEL8 DEL83 DEL42 DEL43 DEL76 DEL74 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL32 DEL4 DEL3 DEL42 DEL32 DEL32 DEL21 DEL8 DEL8 DEL25 DEL8 DEL31 DEL42 DEL42 DEL45 DEL80 DEL42 DEL45 DEL45 DEL27 DEL80 DEL77 DEL83 DEL42 DEL43 DEL76 DEL74 DEL42 DEL42 DEL42 DEL45 DEL80 DEL42 DEL9 DEL80 DEL77 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL44 DEL42 DEL42 DEL45 DEL80 DEL42 DEL9 DEL80 DEL77 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL33 DEL27 DEL40 DEL34 DEL27 DEL27 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL41 DEL8 DEL25 DEL8 DEL31 DEL66 DEL42 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL45 DEL42 DEL32 DEL21 DEL40 DEL42 DEL42 DEL45 DEL80 DEL77 DEL83 DEL42 DEL43 DEL76 DEL74 DEL42 DEL42 DEL45 DEL79 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL41 DEL8 DEL31 DEL83 DEL42 DEL42 DEL44 DEL42 DEL44 DEL42 DEL44 DEL39 DEL42 DEL42 DEL7 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL52 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL8 DEL25 DEL42 DEL42 DEL40 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL33 DEL27 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL32 DEL38 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL52 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL40 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL8 DEL70 DEL42 DEL66 DEL65 DEL42 DEL45 DEL79 DEL42 DEL45 DEL79 DEL42 DEL43 DEL85 DEL5 DEL42 DEL44 DEL42 DEL43 DEL45 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL43 DEL74 DEL42 DEL40 DEL14 DEL42 DEL43 DEL42 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL34 DEL2 DEL32 DEL32 DEL21 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL33 DEL27 DEL40 DEL40 DEL16 DEL36 DEL14 DEL42 DEL42 DEL32 DEL38 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL40 DEL14 DEL41 DEL8 DEL25 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL8 DEL25 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL9 DEL41 DEL8 DEL42 DEL43 DEL42 DEL44 DEL9 DEL41 DEL8 DEL12 DEL54 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL42 DEL42 DEL40 DEL80 DEL42 DEL45 DEL80 DEL42 DEL42 DEL4 DEL80 DEL42 DEL42 DEL4 DEL80 DEL77 DEL42 DEL42 DEL45 DEL80 DEL42 DEL45 DEL45 DEL45 DEL45 DEL45 DEL45 DEL45 DEL45 DEL27 DEL80 DEL77 DEL42 DEL42 DEL42 DEL34 DEL80 DEL42 DEL45 DEL80 DEL77 DEL42 DEL42 DEL34 DEL80 DEL42 DEL45 DEL80 DEL77 DEL42 DEL42 DEL34 DEL80 DEL42 DEL45 DEL80 DEL77 DEL42 DEL42 DEL34 DEL80 DEL42 DEL45 DEL80 DEL77 DEL42 DEL42 DEL34 DEL80 DEL42 DEL45 DEL80 DEL77 DEL42 DEL42 DEL34 DEL80 DEL42 DEL45 DEL80 DEL77 DEL42 DEL42 DEL34 DEL80 DEL42 DEL45 DEL80 DEL77 DEL42 DEL42 DEL34 DEL80 DEL42 DEL45 DEL80 DEL77 DEL4 DEL79 DEL83 DEL42 DEL43 DEL76 DEL74 DEL42 DEL42 DEL45 DEL79 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL80 DEL77 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL44 DEL42 DEL42 DEL45 DEL80 DEL42 DEL45 DEL80 DEL77 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL45 DEL32 DEL38 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL45 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL40 DEL14 DEL41 DEL8 DEL25 DEL40 DEL34 DEL27 DEL42 DEL42 DEL45 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL43 DEL74 DEL42 DEL40 DEL14 DEL41 DEL8 DEL42 DEL42 DEL45 DEL32 DEL42 DEL42 DEL45 DEL45 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL34 DEL2 DEL42 DEL9 DEL32 DEL41 DEL8 DEL42 DEL42 DEL45 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL34 DEL2 DEL42 DEL42 DEL32 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL33 DEL27 DEL40 DEL40 DEL16 DEL36 DEL14 DEL41 DEL8 DEL25 DEL25 DEL8 DEL31
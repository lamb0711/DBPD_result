GEODE-6918: Cleanup PRHARedundancyProvider

* Reorder constants and fields
* Move inner-classes to bottom of outer-class
* Extract DataStoreBuckets
* Encapuslate fields behind accessors
* Remove unused fields, contants and methods
* Reduce scope where possible
* Fix misc IDE warnings
* Remove bug system numbers
* Remove todos, useless comments/javadocs
* Fix typos
* Improve comments
* Delete commented out code

Co-authored-by: Michael Oleske <moleske@pivotal.io>
Co-authored-by: Mark Hanson <mhanson@pivotal.io>

-
+import static java.lang.System.lineSeparator;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.apache.geode.distributed.internal.DistributionConfig.GEMFIRE_PREFIX;
+
-import org.apache.geode.annotations.internal.MutableForTesting;
-import org.apache.geode.distributed.internal.DistributionConfig;
+import org.apache.geode.internal.cache.partitioned.DataStoreBuckets;
-import org.apache.geode.internal.cache.persistence.PersistentStateListener;
- * following to the PartitionedRegion: <br>
- * (1) Redundancy Management at the time of bucket creation.</br>
- * <br>
- * (2) Redundancy management at the new node arrival.</br>
- * <br>
- * (3) Redundancy management when the node leaves the partitioned region distributed system
- * gracefully. i.e. Cache.close()</br>
- * <br>
- * (4) Redundancy management at random node failure.</br>
+ * following to the PartitionedRegion:
+ * <pre>
+ * (1) Redundancy Management at the time of bucket creation.
+ * (2) Redundancy management at the new node arrival.
+ * (3) Redundancy management when the node leaves the partitioned region distributed system
+ * gracefully. i.e. Cache.close()
+ * (4) Redundancy management at random node failure.
+ * </pre>
+  public static final String TIMEOUT_MSG =
+      "If your system has sufficient space, perhaps it is under membership or region creation stress?";
+
+  /**
+   * Signature string indicating that not enough stores are available.
+   */
+  public static final String INSUFFICIENT_STORES_MSG =
+      "Advise you to start enough data store nodes";
+
-      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "DISABLE_CREATE_BUCKET_RANDOMNESS");
+      Boolean.getBoolean(GEMFIRE_PREFIX + "DISABLE_CREATE_BUCKET_RANDOMNESS");
-  public static class ArrayListWithClearState<T> extends ArrayList<T> {
-    private static final long serialVersionUID = 1L;
-    private boolean wasCleared = false;
+  private static final String DATASTORE_DISCOVERY_TIMEOUT_PROPERTY_NAME =
+      GEMFIRE_PREFIX + "partitionedRegionDatastoreDiscoveryTimeout";
-    public boolean wasCleared() {
-      return this.wasCleared;
-    }
+  /**
+   * Signature string indicating that there are enough stores available.
+   */
+  private static final String SUFFICIENT_STORES_MSG = "Found a member to host a bucket.";
-    @Override
-    public void clear() {
-      super.clear();
-      this.wasCleared = true;
-    }
-  }
+  /**
+   * string indicating the attempt to allocate a bucket
+   */
+  private static final String ALLOCATE_ENOUGH_MEMBERS_TO_HOST_BUCKET =
+      "allocate enough members to host a new bucket";
-  public static final String DATASTORE_DISCOVERY_TIMEOUT_PROPERTY_NAME =
-      DistributionConfig.GEMFIRE_PREFIX + "partitionedRegionDatastoreDiscoveryTimeout";
+  private static final long INSUFFICIENT_LOGGING_THROTTLE_TIME = TimeUnit.SECONDS.toNanos(
+      Integer.getInteger(GEMFIRE_PREFIX + "InsufficientLoggingThrottleTime", 2));
+
+  private static final ThreadLocal<Boolean> forceLocalPrimaries = new ThreadLocal<>();
+
-  static volatile Long DATASTORE_DISCOVERY_TIMEOUT_MILLISECONDS =
+  private static final Long DATASTORE_DISCOVERY_TIMEOUT_MILLISECONDS =
-  public final PartitionedRegion prRegion;
+
-  private final AtomicBoolean firstInsufficentStoresLogged = new AtomicBoolean(false);
+  private final AtomicBoolean firstInsufficientStoresLogged = new AtomicBoolean(false);
+
+  private final PartitionedRegion prRegion;
-  protected final OneTaskOnlyExecutor recoveryExecutor;
-  private volatile ScheduledFuture<?> recoveryFuture;
+  private final OneTaskOnlyExecutor recoveryExecutor;
+
-  private boolean shutdown = false;
+
+  private volatile ScheduledFuture<?> recoveryFuture;
-  private volatile PersistentBucketRecoverer persistentBucketRecoverer = null;
+  private volatile PersistentBucketRecoverer persistentBucketRecoverer;
+
+  private boolean shutdown;
-    this.prRegion = region;
+    prRegion = region;
-        new OneTaskOnlyExecutor.ConflatedTaskListener() {
-          @Override
-          public void taskDropped() {
-            InternalResourceManager.getResourceObserver().recoveryConflated(region);
-          }
-        }, getThreadMonitorObj());
+        () -> InternalResourceManager.getResourceObserver().recoveryConflated(region),
+        getThreadMonitorObj());
-  public static String regionStatus(PartitionedRegion prRegion, Set allStores,
-      Collection alreadyUsed, boolean forLog) {
-    StringBuffer sb = new StringBuffer();
-    sb.append("Partitioned Region name = " + prRegion.getFullPath());
-    final char newLine;
+  private static String regionStatus(PartitionedRegion prRegion,
+      Collection<InternalDistributedMember> allStores,
+      Collection<InternalDistributedMember> alreadyUsed, boolean forLog) {
+    StringBuilder sb = new StringBuilder();
+    sb.append("Partitioned Region name = ").append(prRegion.getFullPath());
+    final String newLine;
-      newLine = ' ';
+      newLine = " ";
-      newLine = '\n';
+      newLine = lineSeparator();
-      sb.append(newLine + spaces + "Redundancy level set to " + prRegion.getRedundantCopies());
-      sb.append(newLine + ". Number of available data stores: " + allStores.size());
-      sb.append(newLine + spaces + ". Number successfully allocated = " + alreadyUsed.size());
-      sb.append(newLine + ". Data stores: " + PartitionedRegionHelper.printCollection(allStores));
-      sb.append(newLine + ". Data stores successfully allocated: "
-          + PartitionedRegionHelper.printCollection(alreadyUsed));
-      sb.append(newLine + ". Equivalent members: " + PartitionedRegionHelper
-          .printCollection(prRegion.getDistributionManager().getMembersInThisZone()));
+      sb.append(newLine).append(spaces).append("Redundancy level set to ")
+          .append(prRegion.getRedundantCopies());
+      sb.append(newLine).append(". Number of available data stores: ").append(allStores.size());
+      sb.append(newLine).append(spaces).append(". Number successfully allocated = ")
+          .append(alreadyUsed.size());
+      sb.append(newLine).append(". Data stores: ")
+          .append(PartitionedRegionHelper.printCollection(allStores));
+      sb.append(newLine).append(". Data stores successfully allocated: ")
+          .append(PartitionedRegionHelper.printCollection(alreadyUsed));
+      sb.append(newLine).append(". Equivalent members: ").append(PartitionedRegionHelper
+          .printCollection(prRegion
+              .getDistributionManager()
+              .getMembersInThisZone()));
-  public static final String TIMEOUT_MSG =
-      "If your system has sufficient space, perhaps it is under membership or region creation stress?";
-
-  public static void timedOut(PartitionedRegion prRegion, Set allStores, Collection alreadyUsed,
+  public static void timedOut(PartitionedRegion prRegion, Set<InternalDistributedMember> allStores,
+      Collection<InternalDistributedMember> alreadyUsed,
-            new Object[] {opString,
-                regionStatus(prRegion, allStores, alreadyUsed, true), Long.valueOf(timeOut)})
+            opString,
+            regionStatus(prRegion, allStores, alreadyUsed, true), timeOut)
+  public PartitionedRegion getPartitionedRegion() {
+    return prRegion;
+  }
+
-        this.prRegion.getRegionAdvisor().adviseDataStore(true);
-    PartitionedRegionDataStore myDS = this.prRegion.getDataStore();
+        prRegion.getRegionAdvisor().adviseDataStore(true);
+    PartitionedRegionDataStore myDS = prRegion.getDataStore();
-      allStores.add(this.prRegion.getDistributionManager().getId());
+      allStores.add(prRegion.getDistributionManager().getId());
-        this.prRegion.getRegionAdvisor().adviseFixedPartitionDataStores(partitionName);
+        prRegion.getRegionAdvisor().adviseFixedPartitionDataStores(partitionName);
-    List<FixedPartitionAttributesImpl> FPAs = this.prRegion.getFixedPartitionAttributesImpl();
+    List<FixedPartitionAttributesImpl> FPAs = prRegion.getFixedPartitionAttributesImpl();
-          members.add((InternalDistributedMember) this.prRegion.getMyId());
+          members.add(prRegion.getMyId());
-   * Signature string indicating that not enough stores are available.
-   */
-  public static final String INSUFFICIENT_STORES_MSG =
-      "Advise you to start enough data store nodes";
-
-  /**
-   * Signature string indicating that there are enough stores available.
-   */
-  public static final String SUFFICIENT_STORES_MSG =
-      "Found a member to host a bucket.";
-
-  /**
-   * string indicating the attempt to allocate a bucket
-   */
-  private static final String ALLOCATE_ENOUGH_MEMBERS_TO_HOST_BUCKET =
-      "allocate enough members to host a new bucket";
-
-
-  /**
-  private void insufficientStores(Set allStores, Collection alreadyUsed, boolean onlyLog) {
-    final String regionStat = regionStatus(this.prRegion, allStores, alreadyUsed, onlyLog);
-    final char newLine;
+  private void insufficientStores(Set<InternalDistributedMember> allStores,
+      Collection<InternalDistributedMember> alreadyUsed, boolean onlyLog) {
+    final String regionStat = regionStatus(prRegion, allStores, alreadyUsed, onlyLog);
+    final String newLine;
-      newLine = ' ';
+      newLine = " ";
-      newLine = '\n';
+      newLine = lineSeparator();
-        PRHARedundancyProvider.INSUFFICIENT_STORES_MSG, newLine + regionStat + newLine};
+        INSUFFICIENT_STORES_MSG, newLine + regionStat + newLine};
-      final Set<InternalDistributedMember> excludedMembers,
+      final Collection<InternalDistributedMember> excludedMembers,
-    HashSet<InternalDistributedMember> candidateMembers =
-        new HashSet<InternalDistributedMember>(allStores);
+    Set<InternalDistributedMember> candidateMembers = new HashSet<>(allStores);
-    if (candidateMembers.size() == 0) {
-      this.prRegion.checkReadiness(); // fix for bug #37207
+    if (candidateMembers.isEmpty()) {
+      prRegion.checkReadiness();
-        return null; // fail, let caller signal error
+        // fail, let caller signal error
+        return null;
-      candidateMembers = new HashSet<InternalDistributedMember>(allStores);
+      candidateMembers = new HashSet<>(allStores);
-    InternalDistributedMember candidate = null;
-    if (candidateMembers.size() == 0) { // no options
+    if (candidateMembers.isEmpty()) {
+      // no options
-      return null; // failure
-    } // no options
-    else {
-      // In case of FPR, candidateMembers is the set of members on which
-      // required fixed partition is defined.
-      if (this.prRegion.isFixedPartitionedRegion()) {
-        candidate = candidateMembers.iterator().next();
+      // failure
+      return null;
+    }
+
+    // In case of FPR, candidateMembers is the set of members on which
+    // required fixed partition is defined.
+    InternalDistributedMember candidate;
+    if (prRegion.isFixedPartitionedRegion()) {
+      candidate = candidateMembers.iterator().next();
+    } else {
+      String prName = prRegion.getAttributes().getPartitionAttributes().getColocatedWith();
+      if (prName != null) {
+        candidate = getColocatedDataStore(candidateMembers, alreadyUsed, bucketId, prName);
-        String prName = this.prRegion.getAttributes().getPartitionAttributes().getColocatedWith();
-        if (prName != null) {
-          candidate = getColocatedDataStore(candidateMembers, alreadyUsed, bucketId, prName);
-        } else {
-          final ArrayList<InternalDistributedMember> orderedCandidates =
-              new ArrayList<InternalDistributedMember>(candidateMembers);
-          candidate = getPreferredDataStore(orderedCandidates, alreadyUsed);
-        }
+        final Collection<InternalDistributedMember> orderedCandidates =
+            new ArrayList<>(candidateMembers);
+        candidate = getPreferredDataStore(orderedCandidates, alreadyUsed);
-    if (!this.prRegion.isShadowPR()
-        && !ColocationHelper.checkMembersColocation(this.prRegion, candidate)) {
+    if (!prRegion.isShadowPR()
+        && !ColocationHelper.checkMembersColocation(prRegion, candidate)) {
-    if (!(candidate.equals(this.prRegion.getMyId()))) { // myself
-      PartitionProfile pp = this.prRegion.getRegionAdvisor().getPartitionProfile(candidate);
+    if (!candidate.equals(prRegion.getMyId())) {
+      PartitionProfile pp = prRegion.getRegionAdvisor().getPartitionProfile(candidate);
-              this.prRegion.getFullPath(), candidate);
+              prRegion.getFullPath(), candidate);
-    } // myself
+    }
-      return candidate; // success!
+      // success!
+      return candidate;
-          this.prRegion.getFullPath(), candidate, this.prRegion.bucketStringForLogs(bucketId),
+          prRegion.getFullPath(), candidate, prRegion.bucketStringForLogs(bucketId),
-    candidate = null; // failure
-  public static final long INSUFFICIENT_LOGGING_THROTTLE_TIME = TimeUnit.SECONDS.toNanos(
-      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "InsufficientLoggingThrottleTime", 2)
-          .intValue());
-  @MutableForTesting
-  public static volatile boolean TEST_MODE = false;
-  // since 6.6, please use the distributed system property enforce-unique-host instead.
-  // public static final boolean ENFORCE_UNIQUE_HOST_STORAGE_ALLOCATION =
-  // DistributionConfig.DEFAULT_ENFORCE_UNIQUE_HOST;
-
-  public InternalDistributedMember createBucketOnDataStore(int bucketId, int size, long startTime,
+  InternalDistributedMember createBucketOnDataStore(int bucketId, int size,
-    Set<InternalDistributedMember> attempted = new HashSet<InternalDistributedMember>();
-    InternalDistributedMember ret;
-    if (this.prRegion.isFixedPartitionedRegion()) {
+    if (prRegion.isFixedPartitionedRegion()) {
-          this.prRegion.getRegionAdvisor().adviseFixedPrimaryPartitionDataStore(bucketId);
+          prRegion.getRegionAdvisor().adviseFixedPrimaryPartitionDataStore(bucketId);
+    InternalDistributedMember ret;
+    Collection<InternalDistributedMember> attempted = new HashSet<>();
-      this.prRegion.checkReadiness();
+      prRegion.checkReadiness();
-          this.prRegion.getRegionAdvisor().adviseInitializedDataStore();
-      InternalDistributedMember target = null;
+          prRegion.getRegionAdvisor().adviseInitializedDataStore();
+      InternalDistributedMember target = null;
-              this.prRegion.bucketStringForLogs(bucketId));
+              prRegion.bucketStringForLogs(bucketId));
-            CreateBucketMessage.send(target, this.prRegion, bucketId, size);
+            CreateBucketMessage.send(target, prRegion, bucketId, size);
-    } while ((ret = this.prRegion.getNodeForBucketWrite(bucketId, snoozer)) == null);
+    } while ((ret = prRegion.getNodeForBucketWrite(bucketId, snoozer)) == null);
-   * picture of bucket distribution in the face of concurrency. See bug 37275.
-   * </p>
+   * picture of bucket distribution in the face of concurrency.
+   * <p>
-   * @param startTime a time stamp prior to calling the method, used to update bucket creation stats
-      final int newBucketSize, final long startTime, final boolean finishIncompleteCreation,
-      String partitionName) throws PartitionedRegionStorageException, PartitionedRegionException,
+      final int newBucketSize, final boolean finishIncompleteCreation, String partitionName)
+      throws PartitionedRegionStorageException, PartitionedRegionException,
-      if (this.prRegion.getCache().isCacheAtShutdownAll()) {
+      if (prRegion.getCache().isCacheAtShutdownAll()) {
-            this.prRegion.bucketStringForLogs(bucketId));
+            prRegion.bucketStringForLogs(bucketId));
-      Collection<InternalDistributedMember> acceptedMembers =
-          new ArrayList<InternalDistributedMember>(); // ArrayList<DataBucketStores>
-      Set<InternalDistributedMember> excludedMembers = new HashSet<InternalDistributedMember>();
-      ArrayListWithClearState<InternalDistributedMember> failedMembers =
-          new ArrayListWithClearState<InternalDistributedMember>();
-        this.prRegion.checkReadiness();
+        prRegion.checkReadiness();
-        Bucket toCreate = this.prRegion.getRegionAdvisor().getBucket(bucketId);
+        Bucket toCreate = prRegion.getRegionAdvisor().getBucket(bucketId);
-          bucketPrimary = this.prRegion.getBucketPrimary(bucketId);
+          bucketPrimary = prRegion.getBucketPrimary(bucketId);
-        boolean loggedInsufficentStores = false; // track if insufficient data stores have been
-        for (;;) {
-          this.prRegion.checkReadiness();
-          if (this.prRegion.getCache().isCacheAtShutdownAll()) {
+        ArrayListWithClearState<InternalDistributedMember> failedMembers =
+            new ArrayListWithClearState<>();
+        Set<InternalDistributedMember> excludedMembers = new HashSet<>();
+        Collection<InternalDistributedMember> acceptedMembers = new ArrayList<>();
+        for (boolean loggedInsufficientStores = false;;) {
+          prRegion.checkReadiness();
+          if (prRegion.getCache().isCacheAtShutdownAll()) {
-          // this.prRegion.getCache().getLogger().config(
-          // "DEBUG createBucketAtomically: "
-          // + " bucketId=" + this.prRegion.getBucketName(bucketId) +
-          // " accepted: " + acceptedMembers +
-          // " failed: " + failedMembers);
-            timedOut(this.prRegion, getAllStores(partitionName), acceptedMembers,
+            timedOut(prRegion, getAllStores(partitionName), acceptedMembers,
-            // NOTREACHED
-          // Always go back to the advisor, see if any fresh data stores are
-          // present.
+          // Always go back to the advisor, see if any fresh data stores are present.
-          loggedInsufficentStores = checkSufficientStores(allStores, loggedInsufficentStores);
+          loggedInsufficientStores = checkSufficientStores(allStores, loggedInsufficientStores);
-            if (this.prRegion.getDistributionManager().enforceUniqueZone()) {
-              // enforceUniqueZone property has no effect for a loner. Fix for defect #47181
-              if (!(this.prRegion.getDistributionManager() instanceof LonerDistributionManager)) {
+            if (prRegion.getDistributionManager().enforceUniqueZone()) {
+              // enforceUniqueZone property has no effect for a loner
+              if (!(prRegion.getDistributionManager() instanceof LonerDistributionManager)) {
-          // [sumedh] set the primary as the candidate in the first iteration if
-          // the candidate has accepted
+          // set the primary as the candidate in the first iteration if the candidate has accepted
-          final int potentialCandidateCount = (allStores.size()
-              - (excludedMembers.size() + acceptedMembers.size() + failedMembers.size()));
+          final int potentialCandidateCount = allStores.size()
+              - (excludedMembers.size() + acceptedMembers.size() + failedMembers.size());
-              acceptedMembers.size() > this.prRegion.getRedundantCopies();
-          final boolean bucketNotCreated = acceptedMembers.size() == 0;
+              acceptedMembers.size() > prRegion.getRedundantCopies();
+          final boolean bucketNotCreated = acceptedMembers.isEmpty();
-          // Fix for bug 39283
-            // The rest of the members will be allowed to
-            // volunteer for primary.
+            // The rest of the members will be allowed to volunteer for primary.
-                - (acceptedMembers.contains(this.prRegion.getMyId()) ? 1 : 0);
+                - (acceptedMembers.contains(prRegion.getMyId()) ? 1 : 0);
-              this.prRegion.getCancelCriterion().checkCancelInProgress(e);
+              prRegion.getCancelCriterion().checkCancelInProgress(e);
-          } // almost done
-        } // for
-      } catch (CancelException e) {
-        // Fix for 43544 - We don't need to elect a primary
-        // if the cache was closed. The other members will
-        // take care of it. This ensures we don't compromise
-        // redundancy.
-        needToElectPrimary = false;
-        throw e;
-      } catch (RegionDestroyedException e) {
-        // Fix for 43544 - We don't need to elect a primary
-        // if the region was destroyed. The other members will
-        // take care of it. This ensures we don't compromise
-        // redundancy.
+          }
+        }
+      } catch (CancelException | RegionDestroyedException e) {
+        // We don't need to elect a primary if the cache was closed. The other members will
+        // take care of it. This ensures we don't compromise redundancy.
-        // If we're finishing an incomplete bucket creation, don't blast out
-        // another message to peers to do so.
-        // TODO - should we ignore a PartitionRegionStorageException, rather
-        // than reattempting on other nodes?
-                || (prRegion.getCancelCriterion().isCancelInProgress())) {
+                || prRegion.getCancelCriterion().isCancelInProgress()) {
-    } // synchronized(this)
+    }
-    acceptedMembers = new HashSet<InternalDistributedMember>(acceptedMembers);
-
-    // TODO prpersist - we need to factor out a method that just chooses
-    // the primary. But this will do the trick for the moment.
+    acceptedMembers = new HashSet<>(acceptedMembers);
-        targetPrimary = this.prRegion.getMyId();
+        targetPrimary = prRegion.getMyId();
-            this.prRegion.getRegionAdvisor().adviseFixedPrimaryPartitionDataStore(bucketId);
+            prRegion.getRegionAdvisor().adviseFixedPrimaryPartitionDataStore(bucketId);
-      // [sumedh] we need to select the same primary as chosen earlier (e.g.
+      // we need to select the same primary as chosen earlier (e.g.
-      // InternalDistributedMember targetPrimary = getPreferredDataStore(
-      // acceptedMembers, Collections.<InternalDistributedMember> emptySet());
-          getPreferredDataStore(acceptedMembers, Collections.<InternalDistributedMember>emptySet());
+          getPreferredDataStore(acceptedMembers, Collections.emptySet());
-    EndBucketCreationMessage.send(acceptedMembers, targetPrimary, this.prRegion, bucketId);
-
-    // Observer for testing purpose
-    final EndBucketCreationObserver observer = testEndObserverInstance;
-    if (observer != null) {
-      observer.afterEndBucketCreationMessageSend(this.prRegion, bucketId);
-    }
+    EndBucketCreationMessage.send(acceptedMembers, targetPrimary, prRegion, bucketId);
-
-    if (observer != null) {
-      observer.afterEndBucketCreation(this.prRegion, bucketId);
-    }
-    List<FixedPartitionAttributesImpl> FPAs = this.prRegion.getFixedPartitionAttributesImpl();
+    List<FixedPartitionAttributesImpl> FPAs = prRegion.getFixedPartitionAttributesImpl();
-  @MutableForTesting
-  private static volatile EndBucketCreationObserver testEndObserverInstance;
-
-  // Observer for testing purpose
-  public static void setTestEndBucketCreationObserver(EndBucketCreationObserver observer) {
-    testEndObserverInstance = observer;
-  }
-
-  /**
-   * Test observer to help reproduce #42429.
-   */
-  public interface EndBucketCreationObserver {
-
-    void afterEndBucketCreationMessageSend(PartitionedRegion pr, int bucketId);
-
-    void afterEndBucketCreation(PartitionedRegion pr, int bucketId);
-  }
-
-
-    // Don't elect ourselves as primary or tell others to persist our ID if this member
-    // has been destroyed.
+    // Don't elect ourselves as primary or tell others to persist our ID
+    // if this member has been destroyed.
-          this.prRegion.getFullPath(), bucketId, newPrimary);
+          prRegion.getFullPath(), bucketId, newPrimary);
-    // This fixes an issue with 41336, where multiple threads were calling endBucketCreation
-    // on the persistent advisor and marking a bucket as initialized twice.
-      // may not have. So now we wait for the chosen member to become
-      // primary.
+      // may not have. So now we wait for the chosen member to become primary.
-        // If we're the choosen primary, volunteer for primary now
+        // If we're the chosen primary, volunteer for primary now
-        // If the bucket has had a primary, that means the
-        // chosen bucket was primary for a while. Go ahead and
-        // clear the primary elector field.
+        // If the bucket has had a primary, that means the chosen bucket was primary for a while.
+        // Go ahead and clear the primary elector field.
-   *
-      final Set<InternalDistributedMember> allStores) {
-    HashSet<InternalDistributedMember> allMembersOnSystem =
-        new HashSet<InternalDistributedMember>();
-    DistributionManager dm = this.prRegion.getDistributionManager();
+      final Collection<InternalDistributedMember> allStores) {
+
+    DistributionManager dm = prRegion.getDistributionManager();
-    // TODO Dan - I'm not sure this retain all is necessary, but there may have been a reason we
-    // were
-    // passing this set in before.
-    Set currentStores = getAllStores(partitionName);
+    Set<InternalDistributedMember> currentStores = getAllStores(partitionName);
-        insufficientStores(currentStores, Collections.EMPTY_LIST, true);
+        insufficientStores(currentStores, Collections.emptyList(), true);
-      insufficientStores(currentStores, Collections.EMPTY_LIST, false);
+      insufficientStores(currentStores, Collections.emptyList(), false);
-    if (this.firstInsufficentStoresLogged.compareAndSet(false, true)
+    if (firstInsufficientStoresLogged.compareAndSet(false, true)
-    } else {
-      return false;
+    return false;
-      long millis = DATASTORE_DISCOVERY_TIMEOUT_MILLISECONDS.longValue();
-      if (millis > 0) { // only positive values allowed
+      long millis = DATASTORE_DISCOVERY_TIMEOUT_MILLISECONDS;
+      // only positive values allowed
+      if (millis > 0) {
-    return this.prRegion.getRetryTimeout();
+    return prRegion.getRetryTimeout();
-   * @param loggedInsufficentStores indicates whether a warning has been logged
+   * @param loggedInsufficientStores indicates whether a warning has been logged
-  private boolean checkSufficientStores(final Set allStores,
-      final boolean loggedInsufficentStores) {
+  private boolean checkSufficientStores(final Set<InternalDistributedMember> allStores,
+      final boolean loggedInsufficientStores) {
-    if (!loggedInsufficentStores) {
-      if (allStores.size() == 0) {
-        insufficientStores(allStores, Collections.EMPTY_LIST, true);
+    if (!loggedInsufficientStores) {
+      if (allStores.isEmpty()) {
+        insufficientStores(allStores, Collections.emptyList(), true);
-      if (allStores.size() > 0) {
+      if (!allStores.isEmpty()) {
-        final Object[] logArgs =
-            new Object[] {SUFFICIENT_STORES_MSG, prRegion.getFullPath()};
-        if (TEST_MODE) {
-          logger.fatal(logStr, logArgs);
-        } else {
-          logger.info(logStr, logArgs);
-        }
+        logger.info(logStr, SUFFICIENT_STORES_MSG, prRegion.getFullPath());
-      } else {
-        // Already logged warning, there are no datastores
-        insufficientStores(allStores, Collections.EMPTY_LIST, false);
-        // UNREACHABLE
+      // Already logged warning, there are no datastores
+      insufficientStores(allStores, Collections.emptyList(), false);
-    return loggedInsufficentStores;
+    return loggedInsufficientStores;
-    Set dataStores = this.prRegion.getRegionAdvisor().adviseDataStore();
-    BucketBackupMessage.send(dataStores, this.prRegion, buck);
+    Set<InternalDistributedMember> dataStores = prRegion.getRegionAdvisor().adviseDataStore();
+    BucketBackupMessage.send(dataStores, prRegion, buck);
-    final long startTime = PartitionedRegionStats.startTime();
-    if (this.prRegion.isFixedPartitionedRegion()) {
+    if (prRegion.isFixedPartitionedRegion()) {
-          PartitionedRegionHelper.getFixedPartitionAttributesForBucket(this.prRegion, bucketId);
+          PartitionedRegionHelper.getFixedPartitionAttributesForBucket(prRegion, bucketId);
-    createBucketAtomically(bucketId, 0, startTime, true, partitionName);
+    createBucketAtomically(bucketId, 0, true, partitionName);
-
-          this.prRegion.bucketStringForLogs(bucketId), targetNMember);
+          prRegion.bucketStringForLogs(bucketId), targetNMember);
-    if (!(targetNMember.equals(this.prRegion.getMyId()))) {
-      // final StoppableReentrantReadWriteLock.StoppableReadLock isClosingReadLock;
-      PartitionProfile pp = this.prRegion.getRegionAdvisor().getPartitionProfile(targetNMember);
-      if (pp != null) {
-        // isClosingReadLock = pp.getIsClosingReadLock(
-        // this.prRegion.getCancelCriterion());
-      } else {
+    if (!targetNMember.equals(prRegion.getMyId())) {
+      PartitionProfile pp = prRegion.getRegionAdvisor().getPartitionProfile(targetNMember);
+      if (pp == null) {
-            ManageBackupBucketMessage.send(targetNMember, this.prRegion, bucketId, isRebalance,
+            ManageBackupBucketMessage.send(targetNMember, prRegion, bucketId, isRebalance,
-                this.prRegion.bucketStringForLogs(bucketId), targetNMember);
+                prRegion.bucketStringForLogs(bucketId), targetNMember);
-        } else {
-          if (logger.isDebugEnabled()) {
-            logger.debug(
-                "createBackupBucketOnMember: Bucket creation failed for bucketId={} on member = {}",
-                this.prRegion.bucketStringForLogs(bucketId), targetNMember);
-          }
-
-          return false;
+        if (logger.isDebugEnabled()) {
+          logger.debug(
+              "createBackupBucketOnMember: Bucket creation failed for bucketId={} on member = {}",
+              prRegion.bucketStringForLogs(bucketId), targetNMember);
+        }
+
+        return false;
-          // no log needed see bug 37569
+          // no log needed
-            || (e.getCause() != null && (e.getCause() instanceof CancelException))) {
+            || e.getCause() != null && e.getCause() instanceof CancelException) {
-          logger.warn("Exception creating partition on " +
-              targetNMember,
-              e);
+          logger.warn("Exception creating partition on {}", targetNMember, e);
-    } else {
-      final PartitionedRegionDataStore prDS = this.prRegion.getDataStore();
-      boolean bucketManaged = prDS != null && prDS.grabBucket(bucketId, moveSource, forceCreation,
-          replaceOfflineData, isRebalance, null, false).equals(CreateBucketResult.CREATED);
-      if (!bucketManaged) {
-        if (logger.isDebugEnabled()) {
-          logger.debug(
-              "createBackupBucketOnMember: Local data store refused to accommodate the data for bucketId={} prDS={}",
-              this.prRegion.bucketStringForLogs(bucketId), prDS);
-        }
-      }
-      return bucketManaged;
-  }
-
-  private static final ThreadLocal forceLocalPrimaries = new ThreadLocal();
-
-  public static void setForceLocalPrimaries(boolean v) {
-    forceLocalPrimaries.set(Boolean.valueOf(v));
+    final PartitionedRegionDataStore prDS = prRegion.getDataStore();
+    boolean bucketManaged = prDS != null && prDS.grabBucket(bucketId, moveSource, forceCreation,
+        replaceOfflineData, isRebalance, null, false).equals(CreateBucketResult.CREATED);
+    if (!bucketManaged) {
+      if (logger.isDebugEnabled()) {
+        logger.debug(
+            "createBackupBucketOnMember: Local data store refused to accommodate the data for bucketId={} prDS={}",
+            prRegion.bucketStringForLogs(bucketId), prDS);
+      }
+    }
+    return bucketManaged;
-    Boolean v = (Boolean) forceLocalPrimaries.get();
+    Boolean v = forceLocalPrimaries.get();
-      result = v.booleanValue();
+      result = v;
-  public ManageBucketRsp createBucketOnMember(final int bucketId,
+  private ManageBucketRsp createBucketOnMember(final int bucketId,
-          this.prRegion.bucketStringForLogs(bucketId), targetNMember,
-          (forceCreation ? " forced" : ""));
+          prRegion.bucketStringForLogs(bucketId), targetNMember,
+          forceCreation ? " forced" : "");
-    if (!(targetNMember.equals(this.prRegion.getMyId()))) {
-      // final StoppableReentrantReadWriteLock.StoppableReadLock isClosingReadLock;
-      PartitionProfile pp = this.prRegion.getRegionAdvisor().getPartitionProfile(targetNMember);
-      if (pp != null) {
-        // isClosingReadLock = pp.getIsClosingReadLock(
-        // this.prRegion.getCancelCriterion());
-      } else {
+    if (!targetNMember.equals(prRegion.getMyId())) {
+      PartitionProfile pp = prRegion.getRegionAdvisor().getPartitionProfile(targetNMember);
+      if (pp == null) {
-        // isClosingReadLock.lock(); // Grab the read lock, preventing any region closures
-        // on this remote Node until this bucket is fully published, forcing the closing
-        // Node to recognize any pre-natal buckets.
-        NodeResponse response = ManageBucketMessage.send(targetNMember, this.prRegion, bucketId,
+        NodeResponse response = ManageBucketMessage.send(targetNMember, prRegion, bucketId,
-                this.prRegion.bucketStringForLogs(bucketId), targetNMember);
+                prRegion.bucketStringForLogs(bucketId), targetNMember);
-          // lockList.add(isClosingReadLock);
-        } else {
-          if (logger.isDebugEnabled()) {
-            logger.debug(
-                "createBucketOnMember: Bucket creation failed for bucketId={} on member = {}",
-                this.prRegion.bucketStringForLogs(bucketId), targetNMember);
-          }
-
-          // isClosingReadLock.unlock();
-          return response.rejectedDueToInitialization() ? ManageBucketRsp.NO_INITIALIZING
-              : ManageBucketRsp.NO;
+        if (logger.isDebugEnabled()) {
+          logger.debug(
+              "createBucketOnMember: Bucket creation failed for bucketId={} on member = {}",
+              prRegion.bucketStringForLogs(bucketId), targetNMember);
+        }
+
+        return response.rejectedDueToInitialization() ? ManageBucketRsp.NO_INITIALIZING
+            : ManageBucketRsp.NO;
-            || (e.getCause() != null && (e.getCause() instanceof CancelException))) {
+            || e.getCause() != null && e.getCause() instanceof CancelException) {
-        } else if (e instanceof ForceReattemptException) {
-          // no log needed see bug 37569
+        }
+        if (e instanceof ForceReattemptException) {
+          // no log needed
-        // isClosingReadLock.unlock();
-    } else {
-      final PartitionedRegionDataStore prDS = this.prRegion.getDataStore();
-      boolean bucketManaged = prDS != null && prDS.handleManageBucketRequest(bucketId,
-          newBucketSize, this.prRegion.getMyId(), forceCreation);
-      if (!bucketManaged) {
-        if (logger.isDebugEnabled()) {
-          logger.debug(
-              "createBucketOnMember: Local data store not able to accommodate the data for bucketId={}",
-              this.prRegion.bucketStringForLogs(bucketId));
-        }
-      }
-      return ManageBucketRsp.valueOf(bucketManaged);
+    final PartitionedRegionDataStore prDS = prRegion.getDataStore();
+    boolean bucketManaged = prDS != null && prDS.handleManageBucketRequest(bucketId,
+        newBucketSize, prRegion.getMyId(), forceCreation);
+    if (!bucketManaged) {
+      if (logger.isDebugEnabled()) {
+        logger.debug(
+            "createBucketOnMember: Local data store not able to accommodate the data for bucketId={}",
+            prRegion.bucketStringForLogs(bucketId));
+      }
+    }
+    return ManageBucketRsp.valueOf(bucketManaged);
-    Assert.assertTrue(prName != null); // precondition1
-    PartitionedRegion colocatedRegion = ColocationHelper.getColocatedRegion(this.prRegion);
-    Region prRoot = PartitionedRegionHelper.getPRRoot(prRegion.getCache());
+    Assert.assertTrue(prName != null);
+    PartitionedRegion colocatedRegion = ColocationHelper.getColocatedRegion(prRegion);
+    Region<?, ?> prRoot = PartitionedRegionHelper.getPRRoot(prRegion.getCache());
-      throw new IllegalStateException("Cannot create buckets, as colocated regions are not "
-          + "configured to be at the same nodes.");
+      throw new IllegalStateException(
+          "Cannot create buckets, as colocated regions are not configured to be at the same nodes.");
-    Set bucketOwnersSet = advisor.getBucketOwners(bucketId);
+    Set<InternalDistributedMember> bucketOwnersSet = advisor.getBucketOwners(bucketId);
-    ArrayList members = new ArrayList(bucketOwnersSet);
+    Collection<InternalDistributedMember> members = new ArrayList<>(bucketOwnersSet);
-    /* has a primary already been chosen? */
-    final boolean forPrimary = alreadyUsed.size() == 0;
+    // has a primary already been chosen?
+    final boolean forPrimary = alreadyUsed.isEmpty();
-      PartitionedRegionDataStore myDS = this.prRegion.getDataStore();
+      PartitionedRegionDataStore myDS = prRegion.getDataStore();
-        return this.prRegion.getMyId();
+        return prRegion.getMyId();
-    ArrayList<DataStoreBuckets> stores = this.prRegion.getRegionAdvisor()
-        .adviseFilteredDataStores(new HashSet<InternalDistributedMember>(candidates));
+    ArrayList<DataStoreBuckets> stores = prRegion.getRegionAdvisor()
+        .adviseFilteredDataStores(new HashSet<>(candidates));
-    final DistributionManager dm = this.prRegion.getDistributionManager();
-    // Add ourself as a candidate, if appropriate
+    final DistributionManager dm = prRegion.getDistributionManager();
+    // Add local member as a candidate, if appropriate
-    PartitionedRegionDataStore myDS = this.prRegion.getDataStore();
+    PartitionedRegionDataStore myDS = prRegion.getDataStore();
-      int localMaxMemory = this.prRegion.getLocalMaxMemory();
+      int localMaxMemory = prRegion.getLocalMaxMemory();
-    final HashSet<InternalDistributedMember> existingHosts =
-        new HashSet<InternalDistributedMember>();
-    Iterator<InternalDistributedMember> it = alreadyUsed.iterator();
-    while (it.hasNext()) {
-      InternalDistributedMember mem = it.next();
+    final Set<InternalDistributedMember> existingHosts = new HashSet<>();
+    for (InternalDistributedMember mem : alreadyUsed) {
-    Comparator<DataStoreBuckets> comparator = new Comparator<DataStoreBuckets>() {
-      @Override
-      public int compare(DataStoreBuckets d1, DataStoreBuckets d2) {
-        boolean host1Used = existingHosts.contains(d1.memberId);
-        boolean host2Used = existingHosts.contains(d2.memberId);
+    Comparator<DataStoreBuckets> comparator = (d1, d2) -> {
+      boolean host1Used = existingHosts.contains(d1.memberId());
+      boolean host2Used = existingHosts.contains(d2.memberId());
-        if (!host1Used && host2Used) {
-          return -1; // host1 preferred
-        }
-        if (host1Used && !host2Used) {
-          return 1; // host2 preferred
-        }
-
-        // Six eggs, half a dozen. Look for least loaded.
-        float metric1, metric2;
-        if (forPrimary) {
-          metric1 = d1.numPrimaries / (float) d1.localMaxMemoryMB;
-          metric2 = d2.numPrimaries / (float) d2.localMaxMemoryMB;
-        } else {
-          metric1 = d1.numBuckets / (float) d1.localMaxMemoryMB;
-          metric2 = d2.numBuckets / (float) d2.localMaxMemoryMB;
-        }
-        int result = Float.compare(metric1, metric2);
-        if (result == 0) {
-          // if they have the same load, choose the member with the
-          // higher localMaxMemory
-          result = d2.localMaxMemoryMB - d1.localMaxMemoryMB;
-        }
-        return result;
+      if (!host1Used && host2Used) {
+        // host1 preferred
+        return -1;
+      if (host1Used && !host2Used) {
+        // host2 preferred
+        return 1;
+      }
+
+      // Look for least loaded
+      float metric1;
+      float metric2;
+      if (forPrimary) {
+        metric1 = d1.numPrimaries() / (float) d1.localMaxMemoryMB();
+        metric2 = d2.numPrimaries() / (float) d2.localMaxMemoryMB();
+      } else {
+        metric1 = d1.numBuckets() / (float) d1.localMaxMemoryMB();
+        metric2 = d2.numBuckets() / (float) d2.localMaxMemoryMB();
+      }
+      int result = Float.compare(metric1, metric2);
+      if (result == 0) {
+        // if they have the same load, choose the member with the higher localMaxMemory
+        result = d2.localMaxMemoryMB() - d1.localMaxMemoryMB();
+      }
+      return result;
-    Collections.sort(stores, comparator);
+    stores.sort(comparator);
-    ArrayList<DataStoreBuckets> bestStores = new ArrayList<DataStoreBuckets>();
+    List<DataStoreBuckets> bestStores = new ArrayList<>();
-    final boolean allStoresInUse = alreadyUsed.contains(bestDataStore.memberId);
+    final boolean allStoresInUse = alreadyUsed.contains(bestDataStore.memberId());
-    // Collect all of the other hosts in this sorted list that are as good
-    // as the very first one.
+    // Collect all of the other hosts in this sorted list that are as good as the very first one.
-      if (!allStoresInUse && alreadyUsed.contains(aDataStore.memberId)) {
+      if (!allStoresInUse && alreadyUsed.contains(aDataStore.memberId())) {
-    return aDataStore.memberId;
+    return aDataStore.memberId();
-  public void startRedundancyRecovery() {
+  void startRedundancyRecovery() {
+   * <p>
-  private String fancyFormatBucketAllocation(String prefix, List dataStores, Set existingStores) {
-    StringBuffer logStr = new StringBuffer();
+  private String fancyFormatBucketAllocation(String prefix, Iterable<DataStoreBuckets> dataStores,
+      Collection<InternalDistributedMember> existingStores) {
+    StringBuilder logStr = new StringBuilder();
-    logStr.append("Bucket Allocation for prId=" + this.prRegion.getPRId() + ":\n");
-    for (Iterator i = dataStores.iterator(); i.hasNext();) {
-      DataStoreBuckets dsb = (DataStoreBuckets) i.next();
-      logStr.append(dsb.memberId).append(": ");
-      if (existingStores.contains(dsb.memberId)) {
+    logStr.append("Bucket Allocation for prId=").append(prRegion.getPRId()).append(":").append(
+        lineSeparator());
+    for (Object dataStore : dataStores) {
+      DataStoreBuckets dsb = (DataStoreBuckets) dataStore;
+      logStr.append(dsb.memberId()).append(": ");
+      if (existingStores.contains(dsb.memberId())) {
-      logStr.append(Integer.toString(dsb.numPrimaries));
+      logStr.append(dsb.numPrimaries());
-      logStr.append(Integer.toString(dsb.numBuckets - dsb.numPrimaries));
-      // for (int j = 0; j < dsb.numPrimaries; j++) {
-      // logStr.append('#');
-      // }
-      // int nonPrimary = dsb.numBuckets - dsb.numPrimaries;
-      // for (int j = 0; j < nonPrimary; j++) {
-      // logStr.append('*');
-      // }
-      logStr.append('\n');
+      logStr.append(dsb.numBuckets() - dsb.numPrimaries());
+
+      logStr.append(lineSeparator());
-  public static class DataStoreBuckets {
-    public final InternalDistributedMember memberId;
-    public final int numBuckets;
-    public final int numPrimaries;
-    private final int localMaxMemoryMB;
-
-    public DataStoreBuckets(InternalDistributedMember mem, int buckets, int primaryBuckets,
-        int localMaxMemory) {
-      this.memberId = mem;
-      this.numBuckets = buckets;
-      this.numPrimaries = primaryBuckets;
-      this.localMaxMemoryMB = localMaxMemory;
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-      if ((obj == null) || !(obj instanceof DataStoreBuckets)) {
-        return false;
-      }
-      DataStoreBuckets other = (DataStoreBuckets) obj;
-      return this.numBuckets == other.numBuckets && this.memberId.equals(other.memberId);
-    }
-
-    @Override
-    public int hashCode() {
-      return this.memberId.hashCode();
-    }
-
-    @Override
-    public String toString() {
-      return "DataStoreBuckets memberId=" + this.memberId + "; numBuckets=" + this.numBuckets
-          + "; numPrimaries=" + this.numPrimaries;
-    }
-  }
-
-  void verifyBucketNodes(Collection<InternalDistributedMember> members, String partitionName) {
+  private void verifyBucketNodes(Collection<InternalDistributedMember> members,
+      String partitionName) {
-    // boolean debugAnyRemoved = false;
-          // debugAnyRemoved = true;
-    } // for
+    }
-  public void scheduleRedundancyRecovery(Object failedMemId) {
-
-    final boolean isStartup = failedMemId == null ? true : false;
-    final InternalCache cache = this.prRegion.getCache();
-    final int redundantCopies = PRHARedundancyProvider.this.prRegion.getRedundantCopies();
+  private void scheduleRedundancyRecovery(Object failedMemberId) {
+    // note: isStartup is true even when not starting
+    final boolean isStartup = failedMemberId == null;
-      delay = this.prRegion.getPartitionAttributes().getStartupRecoveryDelay();
+      delay = prRegion.getPartitionAttributes().getStartupRecoveryDelay();
-          .getBoolean(DistributionConfig.GEMFIRE_PREFIX + "DISABLE_MOVE_PRIMARIES_ON_STARTUP");
+          .getBoolean(GEMFIRE_PREFIX + "DISABLE_MOVE_PRIMARIES_ON_STARTUP");
-      delay = this.prRegion.getPartitionAttributes().getRecoveryDelay();
+      delay = prRegion.getPartitionAttributes().getRecoveryDelay();
-    if (!PRHARedundancyProvider.this.prRegion.isDataStore()) {
+    if (!prRegion.isDataStore()) {
-              PRHARedundancyProvider.this.prRegion.isFixedPartitionedRegion();
+              prRegion.isFixedPartitionedRegion();
-
-          // Fix for 43582 - always replace offline data for fixed partitioned
-          // regions - this guarantees we create the buckets we are supposed to
-          // create on this node.
+          // always replace offline data for fixed partitioned regions -
+          // this guarantees we create the buckets we are supposed to create on this node.
-              PRHARedundancyProvider.this.prRegion, false, director, replaceOfflineData, false);
+              prRegion, false, director, replaceOfflineData, false);
-          long start = PRHARedundancyProvider.this.prRegion.getPrStats().startRecovery();
+          long start = prRegion.getPrStats().startRecovery();
-          PRHARedundancyProvider.this.prRegion.getPrStats().endRecovery(start);
-          PRHARedundancyProvider.this.recoveryFuture = null;
+          prRegion.getPrStats().endRecovery(start);
+          recoveryFuture = null;
-          logger.error("Unexpected exception during bucket recovery",
-              e);
+          logger.error("Unexpected exception during bucket recovery", e);
-    synchronized (this.shutdownLock) { // possible fix for bug 41094
-      if (!this.shutdown) {
+    synchronized (shutdownLock) {
+      if (!shutdown) {
-              logger.debug(this.prRegion + " scheduling redundancy recovery in {} ms", delay);
+              logger.debug(prRegion + " scheduling redundancy recovery in {} ms", delay);
-                  failedMemId, delay);
+                  failedMemberId, delay);
-          recoveryFuture = this.recoveryExecutor.schedule(task, delay, TimeUnit.MILLISECONDS);
+          recoveryFuture = recoveryExecutor.schedule(task, delay, MILLISECONDS);
-    int numBuckets = this.prRegion.getPartitionAttributes().getTotalNumBuckets();
-    int targetRedundancy = this.prRegion.getPartitionAttributes().getRedundantCopies();
+    int numBuckets = prRegion.getPartitionAttributes().getTotalNumBuckets();
+    int targetRedundancy = prRegion.getPartitionAttributes().getRedundantCopies();
-      int redundancy = this.prRegion.getRegionAdvisor().getBucketRedundancy(i);
+      int redundancy = prRegion.getRegionAdvisor().getBucketRedundancy(i);
-  public boolean recoverPersistentBuckets() {
-
-    /**
+  boolean recoverPersistentBuckets() {
+    /*
-    PartitionedRegion leaderRegion = ColocationHelper.getLeaderRegion(this.prRegion);
+    PartitionedRegion leaderRegion = ColocationHelper.getLeaderRegion(prRegion);
-    // TODO prpersist - It would make sense to hold the lock here in some cases
-    // to prevent confusing members that are trying to rebalance. BUT, these persistent regions
-    // need to wait for other members to recover during initialization.
-    // RecoveryLock lock = leaderRegion.getRecoveryLock();
-    // lock.lock();
-    // try {
-    Set<InternalDistributedMember> peers = this.prRegion.getRegionAdvisor().adviseGeneric();
+    Set<InternalDistributedMember> peers = prRegion.getRegionAdvisor().adviseGeneric();
-    // TODO prpersist - Ok, this is super lame. We need to make sure here that we don't run into
-    // this race condition
+    // We need to make sure here that we don't run into this race condition:
-    MembershipFlushRequest.send(peers, this.prRegion.getDistributionManager(),
-        this.prRegion.getFullPath());
+    MembershipFlushRequest.send(peers, prRegion.getDistributionManager(),
+        prRegion.getFullPath());
-
-    ArrayList<ProxyBucketRegion> bucketsNotHostedLocally =
-        new ArrayList<ProxyBucketRegion>(proxyBucketArray.length);
-    ArrayList<ProxyBucketRegion> bucketsHostedLocally =
-        new ArrayList<ProxyBucketRegion>(proxyBucketArray.length);
+    List<ProxyBucketRegion> bucketsNotHostedLocally = new ArrayList<>(proxyBucketArray.length);
+    List<ProxyBucketRegion> bucketsHostedLocally = new ArrayList<>(proxyBucketArray.length);
-            // Fix for 44551 - make sure that we always count down
-            // this latch, even if the region was destroyed.
+            // make sure that we always count down this latch, even if the region was destroyed.
-      // Partial fix for 44045, try to recover the local
-      // buckets before the proxy buckets. This will allow us
-      // to detect any ConflictingDataException before the proxy
-      // buckets update their membership view.
+      // try to recover the local buckets before the proxy buckets. This will allow us to detect any
+      // ConflictingDataException before the proxy buckets update their membership view.
-    // } finally {
-    // lock.unlock();
-    // }
-  protected PartitionedRegion getPersistentLeader() {
-    PartitionedRegion leader = ColocationHelper.getLeaderRegion(this.prRegion);
-
+  private PartitionedRegion getPersistentLeader() {
+    PartitionedRegion leader = ColocationHelper.getLeaderRegion(prRegion);
-  public void scheduleCreateMissingBuckets() {
-    if (this.prRegion.getColocatedWith() != null
-        && ColocationHelper.isColocationComplete(this.prRegion)) {
+  void scheduleCreateMissingBuckets() {
+    if (prRegion.getColocatedWith() != null
+        && ColocationHelper.isColocationComplete(prRegion)) {
-          this.prRegion.getGemFireCache().getInternalResourceManager();
+          prRegion.getGemFireCache().getInternalResourceManager();
-    synchronized (this.shutdownLock) { // possible fix for bug 41094
-      this.shutdown = true;
+    synchronized (shutdownLock) {
+      shutdown = true;
-        recoveryFuture.cancel(false/* mayInterruptIfRunning */);
-        this.recoveryExecutor.purge();
+        recoveryFuture.cancel(false);
+        recoveryExecutor.purge();
-
-    final PartitionedRegion pr = this.prRegion;
+    final PartitionedRegion pr = prRegion;
-    // int size = datastores.size() + (ds == null ? 0 : 1);
-
-    Set<InternalPartitionDetails> memberDetails = new TreeSet<InternalPartitionDetails>();
+    Set<InternalPartitionDetails> memberDetails = new TreeSet<>();
-
-
-    InternalPRInfo details = new PartitionRegionInfoImpl(pr.getFullPath(), configuredBucketCount,
+    return new PartitionRegionInfoImpl(pr.getFullPath(), configuredBucketCount,
-
-    return details;
-      if (this.prRegion.getDataPolicy().withPersistence()) {
+      if (prRegion.getDataPolicy().withPersistence()) {
-
-    final PartitionedRegion pr = this.prRegion;
+    final PartitionedRegion pr = prRegion;
-    InternalPartitionDetails localDetails = null;
-
-    InternalDistributedMember localMember = (InternalDistributedMember) pr.getMyId();
+    InternalDistributedMember localMember = pr.getMyId();
-    for (Iterator<Map.Entry<Integer, Integer>> iter = bucketSizeMap.entrySet().iterator(); iter
-        .hasNext();) {
-      Map.Entry<Integer, Integer> me = iter.next();
-      int bid = me.getKey().intValue();
+    for (Map.Entry<Integer, Integer> me : bucketSizeMap.entrySet()) {
+      int bid = me.getKey();
+    InternalPartitionDetails localDetails;
-
-          new PartitionMemberInfoImpl(localMember, pr.getLocalMaxMemory() * (1024L * 1024L), size,
+          new PartitionMemberInfoImpl(localMember, pr.getLocalMaxMemory() * 1024L * 1024L, size,
-          new PartitionMemberInfoImpl(localMember, pr.getLocalMaxMemory() * (1024L * 1024L), size,
+          new PartitionMemberInfoImpl(localMember, pr.getLocalMaxMemory() * 1024L * 1024L, size,
-  protected void waitForPersistentBucketRecoveryOrClose() {
+  private void waitForPersistentBucketRecoveryOrClose() {
-          PartitionedRegionHelper.DEFAULT_WAIT_PER_RETRY_ITERATION, TimeUnit.MILLISECONDS);
+          PartitionedRegionHelper.DEFAULT_WAIT_PER_RETRY_ITERATION, MILLISECONDS);
-        ColocationHelper.getColocatedChildRegions(this.prRegion);
+        ColocationHelper.getColocatedChildRegions(prRegion);
-  protected void waitForPersistentBucketRecovery() {
+  void waitForPersistentBucketRecovery() {
-  public boolean isPersistentRecoveryComplete() {
-    if (!ColocationHelper.checkMembersColocation(this.prRegion, this.prRegion.getMyId())) {
+  boolean isPersistentRecoveryComplete() {
+    if (!ColocationHelper.checkMembersColocation(prRegion, prRegion.getMyId())) {
-        ColocationHelper.getAllColocationRegions(this.prRegion);
+        ColocationHelper.getAllColocationRegions(prRegion);
-  private static class ManageBucketRsp {
-    @Immutable
-    static final ManageBucketRsp NO = new ManageBucketRsp("NO");
-    @Immutable
-    static final ManageBucketRsp YES = new ManageBucketRsp("YES");
-    @Immutable
-    static final ManageBucketRsp NO_INITIALIZING = new ManageBucketRsp("NO_INITIALIZING");
-    @Immutable
-    public static final ManageBucketRsp CLOSED = new ManageBucketRsp("CLOSED");
-
-    private final String name;
-
-    private ManageBucketRsp(String name) {
-      this.name = name;
+  private ThreadsMonitoring getThreadMonitorObj() {
+    DistributionManager distributionManager = prRegion.getDistributionManager();
+    if (distributionManager != null) {
+      return distributionManager.getThreadMonitoring();
-
-    boolean isRejection() {
-      return this == NO || this == NO_INITIALIZING || this == CLOSED;
-    }
-
-    boolean isAcceptance() {
-      return this == YES;
-    }
-
-    boolean isInitializing() {
-      return this == NO_INITIALIZING;
-    }
-
-    @Override
-    public String toString() {
-      return "ManageBucketRsp(" + this.name + ")";
-    }
-
-    /** return YES if the argument is true, NO if not */
-    static ManageBucketRsp valueOf(boolean managed) {
-      return managed ? YES : NO;
-    }
-  }
-
-  private static class BucketMembershipObserverResults {
-    final boolean problematicDeparture;
-    final InternalDistributedMember primary;
-
-    BucketMembershipObserverResults(boolean re, InternalDistributedMember p) {
-      problematicDeparture = re;
-      primary = p;
-    }
-
-    @Override
-    public String toString() {
-      return "pDepart:" + problematicDeparture + " primary:" + primary;
-    }
+    return null;
-   *
-    final Bucket bucketToMonitor;
-    final AtomicInteger arrivals = new AtomicInteger(0);
-    final AtomicBoolean departures = new AtomicBoolean(false);
+    private final Bucket bucketToMonitor;
+    private final AtomicInteger arrivals = new AtomicInteger(0);
+    private final AtomicBoolean departures = new AtomicBoolean(false);
-    public BucketMembershipObserver(Bucket b) {
-      this.bucketToMonitor = b;
+    private BucketMembershipObserver(Bucket b) {
+      bucketToMonitor = b;
-    public BucketMembershipObserver beginMonitoring() {
-      int profilesPresent = this.bucketToMonitor.getBucketAdvisor()
+    private BucketMembershipObserver beginMonitoring() {
+      int profilesPresent = bucketToMonitor.getBucketAdvisor()
-    public void stopMonitoring() {
-      this.bucketToMonitor.getBucketAdvisor().removeMembershipListener(this);
+    private void stopMonitoring() {
+      bucketToMonitor.getBucketAdvisor().removeMembershipListener(this);
-        logger.debug("Observer for bucket {} member joined {}", this.bucketToMonitor, id);
+        logger.debug("Observer for bucket {} member joined {}", bucketToMonitor, id);
-        // TODO manipulate failedNodes and verifiedNodeList directly
-        notify();
+        notifyAll();
-    public void memberSuspect(DistributionManager distributionManager, InternalDistributedMember id,
-        InternalDistributedMember whoSuspected, String reason) {}
-
-    @Override
-        logger.debug("Observer for bucket {} member departed {}", this.bucketToMonitor, id);
+        logger.debug("Observer for bucket {} member departed {}", bucketToMonitor, id);
-        // TODO manipulate failedNodes and verifiedNodeList directly
-        notify();
+        notifyAll();
-    public BucketMembershipObserverResults waitForOwnersGetPrimary(final int expectedCount,
+    private BucketMembershipObserverResults waitForOwnersGetPrimary(final int expectedCount,
-        for (;;) {
-          this.bucketToMonitor.getCancelCriterion().checkCancelInProgress(null);
+        while (true) {
+          bucketToMonitor.getCancelCriterion().checkCancelInProgress(null);
-            // reselect = true; // need to pick new victims
+            // need to pick new victims
-                prRegion.bucketStringForLogs(this.bucketToMonitor.getId()));
+                prRegion.bucketStringForLogs(bucketToMonitor.getId()));
-                new Object[] {Integer.valueOf(creationWaitMillis), prRegion.getFullPath(),
+                new Object[] {creationWaitMillis, prRegion.getFullPath(),
-        } // for (;;)
-      } // synchronized
+        }
+      }
-      InternalDistributedMember primmy = bucketToMonitor.getBucketAdvisor().getPrimary();
-      if (primmy == null) {
+      InternalDistributedMember primary = bucketToMonitor.getBucketAdvisor().getPrimary();
+      if (primary == null) {
-      } else {
-        return new BucketMembershipObserverResults(false, primmy);
+      return new BucketMembershipObserverResults(false, primary);
-
-    @Override
-    public void quorumLost(DistributionManager distributionManager,
-        Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {}
-   *
-  protected class PRMembershipListener implements MembershipListener {
+  private class PRMembershipListener implements MembershipListener {
-        DistributedMember dmem = prRegion.getSystem().getDistributedMember();
+        DistributedMember member = prRegion.getSystem().getDistributedMember();
-              "MembershipListener invoked on DistributedMember = {} for failed memberId = {}", dmem,
+              "MembershipListener invoked on DistributedMember = {} for failed memberId = {}",
+              member,
-        if (!prRegion.isCacheClosing() && !prRegion.isDestroyed() && !dmem.equals(id)) {
-
+        if (!prRegion.isCacheClosing() && !prRegion.isDestroyed() && !member.equals(id)) {
-          if (!PRHARedundancyProvider.this.prRegion.isFixedPartitionedRegion()) {
-            postRecoveryTask = new Runnable() {
-              @Override
-              public void run() {
-                // After the metadata has been cleaned, recover redundancy.
-                scheduleRedundancyRecovery(id);
-              }
+          if (!prRegion.isFixedPartitionedRegion()) {
+            postRecoveryTask = () -> {
+              // After the metadata has been cleaned, recover redundancy.
+              scheduleRedundancyRecovery(id);
+  }
-    @Override
-    public void memberSuspect(DistributionManager distributionManager, InternalDistributedMember id,
-        InternalDistributedMember whoSuspected, String reason) {}
+  private static class ManageBucketRsp {
+    @Immutable
+    private static final ManageBucketRsp NO = new ManageBucketRsp("NO");
+    @Immutable
+    private static final ManageBucketRsp YES = new ManageBucketRsp("YES");
+    @Immutable
+    private static final ManageBucketRsp NO_INITIALIZING = new ManageBucketRsp("NO_INITIALIZING");
+    @Immutable
+    private static final ManageBucketRsp CLOSED = new ManageBucketRsp("CLOSED");
-    @Override
-    public void memberJoined(DistributionManager distributionManager,
-        InternalDistributedMember id) {
-      // no action required
+    private final String name;
+
+    private ManageBucketRsp(String name) {
+      this.name = name;
+    }
+
+    private boolean isAcceptance() {
+      return this == YES;
-    public void quorumLost(DistributionManager distributionManager,
-        Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {}
-  }
+    public String toString() {
+      return "ManageBucketRsp(" + name + ")";
+    }
-  /**
-   * This class extends MembershipListener to start redundancy recovery when a persistent member is
-   * revoked
-   *
-   */
-  protected class PRPersistenceListener extends PersistentStateListener.PersistentStateAdapter {
-
-    // TODO prpersist It seems like this might trigger recovery too often. For example, a rebalance
-    // can end up removing a bucket, which would trigger recovery here. We really need to only
-    // trigger this thing when a PR region is destroyed. And isn't that code already in there?
-    @Override
-    public void memberRemoved(PersistentMemberID persistentID, boolean revoked) {
-      if (!revoked) {
-        return;
-      }
-
-      DistributedMember dmem = prRegion.getSystem().getDistributedMember();
-      if (logger.isDebugEnabled()) {
-        logger.debug(
-            "Persistent Membership Listener invoked on DistributedMember = {} for removed memberId = {}",
-            dmem, persistentID);
-      }
-
-      if (!prRegion.isCacheClosing() && !prRegion.isDestroyed()
-          && !prRegion.isFixedPartitionedRegion()) {
-        scheduleRedundancyRecovery(persistentID);
-      }
+    /** return YES if the argument is true, NO if not */
+    private static ManageBucketRsp valueOf(boolean managed) {
+      return managed ? YES : NO;
-  private ThreadsMonitoring getThreadMonitorObj() {
-    DistributionManager distributionManager = this.prRegion.getDistributionManager();
-    if (distributionManager != null) {
-      return distributionManager.getThreadMonitoring();
-    } else {
-      return null;
+  private static class BucketMembershipObserverResults {
+    private final boolean problematicDeparture;
+    final InternalDistributedMember primary;
+
+    BucketMembershipObserverResults(boolean re, InternalDistributedMember p) {
+      problematicDeparture = re;
+      primary = p;
+    }
+
+    @Override
+    public String toString() {
+      return "pDepart:" + problematicDeparture + " primary:" + primary;
+    }
+  }
+
+  private static class ArrayListWithClearState<T> extends ArrayList<T> {
+    private static final long serialVersionUID = 1L;
+    private volatile boolean wasCleared;
+
+    private boolean wasCleared() {
+      return wasCleared;
+    }
+
+    @Override
+    public void clear() {
+      super.clear();
+      wasCleared = true;

MOV26 MOV26 MOV26 INS26 MOV23 MOV23 MOV23 MOV23 MOV23 MOV23 MOV23 MOV23 MOV31 MOV23 MOV55 MOV55 MOV31 UPD40 INS40 UPD40 UPD40 INS55 UPD83 UPD83 UPD83 INS74 INS83 UPD83 UPD83 UPD83 UPD83 UPD83 MOV43 INS42 MOV60 MOV60 INS44 MOV44 UPD83 INS83 UPD83 MOV44 UPD83 MOV60 UPD83 UPD83 UPD83 MOV83 MOV83 INS42 MOV73 MOV74 MOV23 MOV23 MOV31 MOV31 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV43 MOV43 UPD42 UPD42 MOV21 INS74 INS74 INS74 INS74 INS41 INS74 INS74 INS74 INS60 MOV25 INS83 INS74 INS42 INS41 UPD42 INS25 MOV60 MOV60 MOV25 MOV41 INS60 INS60 INS25 MOV41 INS60 INS70 MOV60 INS74 INS74 INS21 INS70 UPD42 INS70 MOV8 MOV41 INS83 INS83 INS83 UPD83 UPD83 UPD83 UPD83 INS83 INS83 INS83 UPD83 INS83 INS83 INS83 UPD83 UPD39 UPD83 UPD42 MOV78 INS42 INS8 INS42 MOV32 INS74 INS7 INS43 INS43 INS43 INS43 UPD43 INS32 MOV43 INS43 INS43 INS43 INS43 INS42 INS43 INS43 INS43 INS43 MOV43 INS43 INS43 MOV74 INS59 INS32 INS32 MOV43 INS59 INS74 MOV60 UPD66 UPD66 INS43 INS43 INS74 INS9 UPD42 UPD42 MOV74 MOV32 MOV38 MOV8 MOV43 MOV38 MOV43 INS83 MOV43 INS59 INS39 INS59 MOV38 INS8 INS74 MOV74 INS74 INS59 MOV43 MOV74 MOV44 INS42 MOV8 MOV74 INS74 INS32 INS66 INS43 MOV43 INS43 INS43 UPD43 INS32 MOV44 INS42 INS8 INS42 MOV43 INS74 UPD74 MOV43 INS42 MOV43 MOV14 MOV43 MOV43 INS44 MOV32 MOV8 MOV41 UPD42 MOV21 MOV21 INS42 MOV43 INS42 INS42 INS14 UPD42 MOV42 INS42 MOV42 INS42 UPD42 INS32 INS42 INS32 MOV42 INS42 MOV42 INS42 MOV42 INS42 MOV42 INS42 INS42 INS42 UPD43 MOV43 MOV43 INS42 INS14 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 INS42 INS42 INS32 INS42 INS43 INS43 INS42 INS42 INS42 INS43 INS43 INS42 UPD42 INS25 MOV21 INS42 INS42 INS32 MOV32 INS32 INS42 INS32 INS42 INS27 INS25 MOV43 INS76 INS76 INS43 INS43 INS42 INS14 INS32 MOV14 INS86 UPD42 MOV43 MOV43 UPD42 INS42 INS42 INS42 UPD42 MOV42 INS42 UPD42 INS32 INS42 INS32 UPD42 MOV60 MOV21 MOV25 MOV21 MOV21 MOV21 MOV21 INS27 MOV43 MOV43 MOV43 MOV43 INS42 INS42 MOV32 MOV74 INS42 MOV21 MOV60 MOV32 MOV32 INS42 INS7 INS42 MOV43 MOV32 INS86 MOV32 UPD43 MOV42 MOV42 INS45 INS42 INS42 INS32 INS32 INS32 INS32 INS32 INS42 INS42 INS42 UPD42 MOV42 UPD74 MOV74 MOV42 MOV42 MOV42 MOV32 INS42 INS42 UPD74 MOV74 UPD74 INS42 INS42 MOV42 INS42 INS42 INS32 INS38 MOV8 MOV42 MOV42 MOV32 MOV43 UPD27 MOV8 INS42 MOV32 MOV42 MOV42 MOV32 MOV43 UPD27 INS42 INS42 MOV27 INS32 MOV32 INS8 INS42 INS42 INS42 INS74 INS42 MOV42 UPD42 MOV42 MOV43 INS14 INS42 INS42 UPD74 MOV42 INS59 INS59 INS8 INS74 INS32 UPD43 INS32 INS42 INS45 UPD42 MOV42 MOV43 UPD42 MOV42 MOV33 INS42 INS42 INS42 INS42 UPD74 UPD74 MOV74 INS42 INS42 UPD74 INS42 INS42 INS42 INS42 INS42 INS61 UPD42 UPD42 UPD42 INS42 INS42 INS9 MOV32 UPD42 INS45 INS32 INS32 INS42 MOV32 INS32 INS42 MOV32 INS32 INS42 MOV32 INS32 INS42 MOV32 INS32 INS42 MOV32 INS32 INS42 MOV32 INS42 MOV32 MOV42 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS42 INS42 MOV32 INS42 MOV60 MOV60 INS32 INS42 MOV42 UPD42 MOV42 MOV41 INS32 INS21 INS32 INS42 INS42 INS25 MOV25 MOV41 INS42 MOV16 INS42 INS25 MOV25 MOV41 INS42 INS42 INS42 INS42 INS32 INS42 INS21 INS45 MOV43 INS42 UPD74 MOV74 INS42 INS42 INS42 MOV60 MOV60 MOV25 MOV25 MOV60 INS60 MOV25 MOV60 MOV25 MOV41 MOV43 INS42 INS42 UPD42 INS32 INS42 INS32 INS32 INS27 INS32 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS42 INS9 MOV8 MOV32 INS42 INS32 INS42 INS45 INS32 INS42 INS45 INS32 INS42 INS45 INS32 INS42 INS45 INS32 INS42 INS45 INS32 INS42 INS45 INS42 UPD74 INS74 INS59 INS42 INS42 INS42 MOV74 INS58 MOV60 INS84 INS42 INS42 INS42 MOV42 UPD42 MOV42 INS32 INS42 INS42 INS42 INS42 MOV32 MOV8 MOV32 INS42 MOV32 MOV8 MOV32 MOV25 MOV25 INS42 INS42 INS32 INS42 INS42 INS39 MOV59 INS32 MOV42 MOV42 INS45 INS42 MOV42 MOV43 INS42 INS32 INS42 INS42 UPD42 UPD42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 UPD42 UPD42 INS32 INS42 INS42 MOV42 MOV42 INS42 INS32 INS42 INS42 MOV42 MOV42 INS42 MOV42 MOV42 INS42 MOV42 MOV42 INS42 INS42 UPD43 MOV43 MOV43 INS42 INS14 INS42 INS42 INS42 INS42 UPD42 INS14 INS39 INS59 MOV43 MOV43 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS42 MOV41 MOV25 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV34 MOV34 MOV34 MOV34 INS42 MOV32 MOV38 MOV42 MOV42 INS42 MOV42 MOV42 INS42 INS42 UPD42 UPD74 MOV74 MOV42 INS42 INS42 INS74 UPD74 UPD74 INS42 INS9 INS42 INS42 INS42 INS42 INS42 MOV42 MOV42 INS42 MOV32 INS8 INS42 INS42 MOV32 MOV27 MOV41 INS42 INS42 INS42 INS32 INS32 INS42 UPD42 UPD42 MOV32 INS32 INS42 INS43 INS42 UPD42 MOV27 UPD42 UPD27 UPD42 INS32 INS42 MOV27 INS21 MOV62 INS42 INS42 INS42 INS42 INS42 MOV42 INS42 MOV42 INS42 INS42 INS42 INS42 INS42 UPD42 INS32 INS42 UPD42 MOV42 INS42 MOV62 INS32 INS42 INS32 INS32 INS32 INS32 INS32 INS32 INS42 INS42 INS86 INS42 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 MOV8 INS42 MOV32 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 DEL66 DEL40 DEL83 DEL83 DEL42 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL8 DEL31 DEL55 DEL40 DEL40 DEL42 DEL32 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL33 DEL42 DEL78 DEL83 DEL83 DEL9 DEL52 DEL42 DEL22 DEL42 DEL40 DEL43 DEL42 DEL78 DEL83 DEL39 DEL42 DEL8 DEL31 DEL1 DEL14 DEL14 DEL7 DEL21 DEL43 DEL43 DEL45 DEL27 DEL32 DEL39 DEL13 DEL13 DEL42 DEL42 DEL45 DEL27 DEL32 DEL42 DEL45 DEL27 DEL32 DEL42 DEL42 DEL45 DEL27 DEL32 DEL42 DEL45 DEL27 DEL32 DEL42 DEL45 DEL27 DEL32 DEL42 DEL45 DEL27 DEL43 DEL43 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL4 DEL3 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL52 DEL42 DEL22 DEL32 DEL11 DEL43 DEL43 DEL52 DEL42 DEL22 DEL39 DEL13 DEL13 DEL40 DEL42 DEL43 DEL42 DEL74 DEL14 DEL59 DEL32 DEL34 DEL27 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL32 DEL34 DEL27 DEL8 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL74 DEL14 DEL59 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL32 DEL36 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL32 DEL52 DEL42 DEL22 DEL42 DEL33 DEL7 DEL21 DEL83 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL66 DEL65 DEL83 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL39 DEL9 DEL42 DEL43 DEL42 DEL43 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL36 DEL34 DEL52 DEL42 DEL22 DEL32 DEL27 DEL42 DEL42 DEL32 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL44 DEL42 DEL9 DEL7 DEL21 DEL42 DEL53 DEL8 DEL12 DEL36 DEL42 DEL43 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL52 DEL42 DEL22 DEL83 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL8 DEL25 DEL52 DEL42 DEL22 DEL42 DEL78 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL42 DEL39 DEL42 DEL42 DEL44 DEL39 DEL42 DEL44 DEL31 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL31 DEL55 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL52 DEL42 DEL22 DEL43 DEL40 DEL40 DEL52 DEL42 DEL22 DEL9 DEL41 DEL8 DEL42 DEL42 DEL32 DEL52 DEL42 DEL22 DEL83 DEL42 DEL43 DEL42 DEL44 DEL32 DEL34 DEL27 DEL40 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL4 DEL3 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL40 DEL32 DEL34 DEL27 DEL8 DEL25 DEL42 DEL43 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL32 DEL36 DEL52 DEL42 DEL22 DEL8 DEL9 DEL41 DEL8 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL8 DEL25 DEL36 DEL36 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL8 DEL25 DEL83 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL31 DEL11 DEL42 DEL42 DEL32 DEL52 DEL42 DEL22 DEL36 DEL52 DEL42 DEL22 DEL32 DEL36 DEL52 DEL42 DEL22 DEL8 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL8 DEL25 DEL36 DEL36 DEL42 DEL42 DEL45 DEL42 DEL27 DEL42 DEL32 DEL21 DEL8 DEL83 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL42 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL32 DEL27 DEL59 DEL60 DEL42 DEL42 DEL45 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL52 DEL42 DEL22 DEL45 DEL45 DEL27 DEL43 DEL32 DEL34 DEL27 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL42 DEL43 DEL42 DEL43 DEL74 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL44 DEL42 DEL44 DEL8 DEL31 DEL1 DEL14 DEL42 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL40 DEL40 DEL40 DEL83 DEL43 DEL42 DEL43 DEL42 DEL42 DEL32 DEL40 DEL40 DEL40 DEL40 DEL40 DEL27 DEL32 DEL13 DEL45 DEL52 DEL42 DEL22 DEL32 DEL45 DEL27 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL8 DEL24 DEL42 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL42 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL42 DEL45 DEL52 DEL42 DEL22 DEL45 DEL52 DEL42 DEL22 DEL45 DEL52 DEL42 DEL22 DEL27 DEL41 DEL8 DEL31 DEL55 DEL27 DEL9 DEL9 DEL16 DEL83 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL59 DEL60 DEL83 DEL39 DEL42 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL59 DEL60 DEL52 DEL42 DEL22 DEL40 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL40 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL52 DEL42 DEL22 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL11 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL32 DEL33 DEL42 DEL43 DEL40 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL27 DEL36 DEL27 DEL36 DEL42 DEL42 DEL40 DEL52 DEL42 DEL22 DEL83 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL8 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL44 DEL8 DEL31 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL32 DEL24 DEL8 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL44 DEL42 DEL43 DEL74 DEL42 DEL44 DEL8 DEL31 DEL42 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL78 DEL83 DEL39 DEL42 DEL31 DEL1 DEL14 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL44 DEL42 DEL43 DEL74 DEL42 DEL44 DEL8 DEL31 DEL39 DEL42 DEL52 DEL42 DEL27 DEL52 DEL42 DEL27 DEL27 DEL52 DEL42 DEL27 DEL27 DEL41 DEL8 DEL31 DEL39 DEL42 DEL52 DEL42 DEL27 DEL41 DEL8 DEL31 DEL52 DEL42 DEL22 DEL42 DEL78 DEL42 DEL33 DEL27 DEL36 DEL42 DEL62 DEL36 DEL38 DEL27 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL52 DEL42 DEL22 DEL40 DEL27 DEL52 DEL42 DEL22 DEL42 DEL40 DEL32 DEL27 DEL42 DEL78 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL38 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL8 DEL25 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL32 DEL38 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL40 DEL43 DEL55
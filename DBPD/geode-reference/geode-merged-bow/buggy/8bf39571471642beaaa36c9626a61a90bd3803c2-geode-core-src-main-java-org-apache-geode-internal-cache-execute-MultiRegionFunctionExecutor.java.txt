Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  private MultiRegionFunctionExecutor(Set<Region> regions, Set filter2,
-      Object args, MemberMappedArgument memberMappedArg,
-      ServerToClientFunctionResultSender resultSender) {
+  private MultiRegionFunctionExecutor(Set<Region> regions, Set filter2, Object args,
+      MemberMappedArgument memberMappedArg, ServerToClientFunctionResultSender resultSender) {
-    }
-    else if (memberMappedArg != null) {
+    } else if (memberMappedArg != null) {
-  private MultiRegionFunctionExecutor(MultiRegionFunctionExecutor executor,
-      ResultCollector rs) {
+  private MultiRegionFunctionExecutor(MultiRegionFunctionExecutor executor, ResultCollector rs) {
-  public MultiRegionFunctionExecutor(MultiRegionFunctionExecutor executor,
-      Object args) {
+  public MultiRegionFunctionExecutor(MultiRegionFunctionExecutor executor, Object args) {
-  
-  public MultiRegionFunctionExecutor(MultiRegionFunctionExecutor executor,
-      boolean isReExecute) {
+
+  public MultiRegionFunctionExecutor(MultiRegionFunctionExecutor executor, boolean isReExecute) {
-  
-  public InternalExecution withMemberMappedArgument(
-      MemberMappedArgument argument) {
+
+  public InternalExecution withMemberMappedArgument(MemberMappedArgument argument) {
-  
+
-    }
-    else {
+    } else {
-    InternalDistributedSystem ds = InternalDistributedSystem
-        .getConnectedInstance();
+    InternalDistributedSystem ds = InternalDistributedSystem.getConnectedInstance();
-          LocalizedStrings.ExecuteFunction_DS_NOT_CREATED_OR_NOT_READY
-              .toLocalizedString());
+          LocalizedStrings.ExecuteFunction_DS_NOT_CREATED_OR_NOT_READY.toLocalizedString());
-    final Map<InternalDistributedMember, Set<String>> memberToRegionMap = calculateMemberToRegionMap();
-    final Set<InternalDistributedMember> dest = new HashSet<InternalDistributedMember>(
-        memberToRegionMap.keySet());
+    final Map<InternalDistributedMember, Set<String>> memberToRegionMap =
+        calculateMemberToRegionMap();
+    final Set<InternalDistributedMember> dest =
+        new HashSet<InternalDistributedMember>(memberToRegionMap.keySet());
-      Set<InternalDistributedMember> hcm = cache.getResourceAdvisor()
-          .adviseCritialMembers();
+      Set<InternalDistributedMember> hcm = cache.getResourceAdvisor().adviseCritialMembers();
-              .toLocalizedString(new Object[] { function.getId(), sm }), sm);
+              .toLocalizedString(new Object[] {function.getId(), sm}),
+          sm);
-    final LocalResultCollector<?, ?> localResultCollector = getLocalResultCollector(
-        function, resultCollector);
+    final LocalResultCollector<?, ?> localResultCollector =
+        getLocalResultCollector(function, resultCollector);
-    final MemberFunctionResultSender resultSender = new MemberFunctionResultSender(
-        dm, localResultCollector, function, localOnly, remoteOnly, null);
+    final MemberFunctionResultSender resultSender = new MemberFunctionResultSender(dm,
+        localResultCollector, function, localOnly, remoteOnly, null);
-      final FunctionContextImpl context = new MultiRegionFunctionContextImpl(
-          function.getId(), getArgumentsForMember(localVM.getId()),
-          resultSender, regions, this.isReExecute);
+      final FunctionContextImpl context = new MultiRegionFunctionContextImpl(function.getId(),
+          getArgumentsForMember(localVM.getId()), resultSender, regions, this.isReExecute);
-      HashMap<InternalDistributedMember, Object> memberArgs = new HashMap<InternalDistributedMember, Object>();
+      HashMap<InternalDistributedMember, Object> memberArgs =
+          new HashMap<InternalDistributedMember, Object>();
-      MultiRegionFunctionResultWaiter waiter = new MultiRegionFunctionResultWaiter(
-          ds, localResultCollector, function, dest, memberArgs, resultSender,
-          memberToRegionMap);
+      MultiRegionFunctionResultWaiter waiter = new MultiRegionFunctionResultWaiter(ds,
+          localResultCollector, function, dest, memberArgs, resultSender, memberToRegionMap);
-      ResultCollector reply = waiter
-          .getFunctionResultFrom(dest, function, this);
+      ResultCollector reply = waiter.getFunctionResultFrom(dest, function, this);
-    Map<InternalDistributedMember, Set<String>> memberToRegions = new HashMap<InternalDistributedMember, Set<String>>();
+    Map<InternalDistributedMember, Set<String>> memberToRegions =
+        new HashMap<InternalDistributedMember, Set<String>>();
-        PartitionedRegion pr = (PartitionedRegion)region;
-        Set<InternalDistributedMember> prMembers = pr.getRegionAdvisor()
-            .advisePrimaryOwners();
+        PartitionedRegion pr = (PartitionedRegion) region;
+        Set<InternalDistributedMember> prMembers = pr.getRegionAdvisor().advisePrimaryOwners();
-          GemFireCacheImpl cache = (GemFireCacheImpl)region.getCache();
+          GemFireCacheImpl cache = (GemFireCacheImpl) region.getCache();
-      }
-      else if (region instanceof DistributedRegion) {
+      } else if (region instanceof DistributedRegion) {
-          DistributedRegion dr = (DistributedRegion)region;
-          Set<InternalDistributedMember> replicates = dr
-              .getCacheDistributionAdvisor().adviseInitializedReplicates();
+          DistributedRegion dr = (DistributedRegion) region;
+          Set<InternalDistributedMember> replicates =
+              dr.getCacheDistributionAdvisor().adviseInitializedReplicates();
-            InternalDistributedMember member = (InternalDistributedMember)(replicates
+            InternalDistributedMember member = (InternalDistributedMember) (replicates
-        }
-        else if (dp.withReplication()) {
-          GemFireCacheImpl cache = (GemFireCacheImpl)region.getCache();
+        } else if (dp.withReplication()) {
+          GemFireCacheImpl cache = (GemFireCacheImpl) region.getCache();
-      }
-      else if (region instanceof LocalRegion) {
-        GemFireCacheImpl cache = (GemFireCacheImpl)region.getCache();
+      } else if (region instanceof LocalRegion) {
+        GemFireCacheImpl cache = (GemFireCacheImpl) region.getCache();
-  
+
+
-      cache = (GemFireCacheImpl)r.getCache();
+      cache = (GemFireCacheImpl) r.getCache();
-        throw new TransactionException(LocalizedStrings.PartitionedRegion_TX_FUNCTION_ON_MORE_THAN_ONE_NODE
-            .toLocalizedString());
+        throw new TransactionException(
+            LocalizedStrings.PartitionedRegion_TX_FUNCTION_ON_MORE_THAN_ONE_NODE
+                .toLocalizedString());
-        DistributedMember funcTarget = (DistributedMember)targetMembers.iterator().next();
+        DistributedMember funcTarget = (DistributedMember) targetMembers.iterator().next();
-          throw new TransactionDataNotColocatedException(LocalizedStrings.PartitionedRegion_TX_FUNCTION_EXECUTION_NOT_COLOCATED_0_1
-              .toLocalizedString(new Object[] {target,funcTarget}));
+          throw new TransactionDataNotColocatedException(
+              LocalizedStrings.PartitionedRegion_TX_FUNCTION_EXECUTION_NOT_COLOCATED_0_1
+                  .toLocalizedString(new Object[] {target, funcTarget}));
-    if (function.optimizeForWrite() && cache.getResourceManager().getHeapMonitor().
-        containsHeapCriticalMembers(targetMembers) &&
-        !MemoryThresholds.isLowMemoryExceptionDisabled()) {
-      Set<InternalDistributedMember> hcm  = cache.getResourceAdvisor().adviseCritialMembers();
+    if (function.optimizeForWrite()
+        && cache.getResourceManager().getHeapMonitor().containsHeapCriticalMembers(targetMembers)
+        && !MemoryThresholds.isLowMemoryExceptionDisabled()) {
+      Set<InternalDistributedMember> hcm = cache.getResourceAdvisor().adviseCritialMembers();
-      throw new LowMemoryException(LocalizedStrings.ResourceManager_LOW_MEMORY_FOR_0_FUNCEXEC_MEMBERS_1.toLocalizedString(
-          new Object[] {function.getId(), sm}), sm);
+      throw new LowMemoryException(
+          LocalizedStrings.ResourceManager_LOW_MEMORY_FOR_0_FUNCEXEC_MEMBERS_1
+              .toLocalizedString(new Object[] {function.getId(), sm}),
+          sm);


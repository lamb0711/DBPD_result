GEODE-1400: An inflight transaction op could arrive later than a client failover operation

 * Handle inflight p2p transaction message received
   later than failover message.
 * Add unit tests.
 * Move hasTxAlreadyFinished method to TXManagerImpl.

-public final class TXManagerImpl implements CacheTransactionManager,
+public class TXManagerImpl implements CacheTransactionManager,
-    TXStateProxy val;
-    val = this.hostedTXStates.get(key);
+    TXStateProxy val = getOrSetHostedTXState(key, msg);
+
+    if (val != null) {
+      boolean success = getLock(val, key);
+      while (!success) {
+        val = getOrSetHostedTXState(key, msg);
+        if (val != null) {
+          success = getLock(val, key);
+        } else {
+          break;
+        }
+      }
+    }
+
+    setTXState(val);
+    return val;
+  }
+
+  TXStateProxy getOrSetHostedTXState(TXId key, TransactionMessage msg) {
+    TXStateProxy val = this.hostedTXStates.get(key);
-    if (val != null) {
-      if (!val.getLock().isHeldByCurrentThread()) {
-        val.getLock().lock();
+    return val;
+  }
+
+  boolean getLock(TXStateProxy val, TXId key) {
+    if (!val.getLock().isHeldByCurrentThread()) {
+      val.getLock().lock();
+      synchronized (this.hostedTXStates) {
+        TXStateProxy curVal = this.hostedTXStates.get(key);
+        // Inflight op could be received later than TXFailover operation.
+        if (curVal == null) {
+          if (!isHostedTxRecentlyCompleted(key)) {
+            this.hostedTXStates.put(key, val);
+            // Failover op removed the val
+            // It is possible that the same operation can be executed
+            // twice by two threads, but data is consistent.
+          }
+        } else {
+          if (val != curVal) {
+            //Failover op replaced with a new TXStateProxyImpl
+            //Use the new one instead.
+            val.getLock().unlock();
+            return false;
+          }
+        }
-
-    setTXState(val);
-    return val;
+    return true;
+  }
+  
+  public boolean hasTxAlreadyFinished(TXStateProxy tx, TXId txid) {
+    if (tx == null) {
+      return false;
+    }
+    if (isHostedTxRecentlyCompleted(txid)) {
+      //Should only happen when handling a later arrival of transactional op from proxy,
+      //while the transaction has failed over and already committed or rolled back.
+      //Just send back reply as a success op.
+      //The client connection should be lost from proxy, or
+      //the proxy is closed for failover to occur.
+      logger.info("TxId {} has already finished." , txid);
+      return true;
+    }
+    return false;

INS42 INS31 INS31 INS31 MOV29 INS83 INS43 INS42 INS44 MOV43 INS8 UPD42 INS44 INS39 INS42 INS44 INS44 INS8 INS83 INS39 INS42 INS44 INS44 INS8 INS42 INS43 INS42 MOV25 MOV60 INS60 INS25 MOV21 INS41 INS43 INS42 INS43 INS42 INS43 INS42 INS25 INS41 INS43 INS42 INS43 INS42 INS25 INS25 INS41 INS42 MOV43 INS59 INS27 INS8 INS42 INS42 INS43 INS42 INS42 MOV38 INS8 INS9 INS42 INS42 INS27 INS8 INS32 INS8 INS9 INS42 INS32 INS42 INS33 INS60 INS61 INS42 MOV32 MOV21 INS51 INS42 INS33 INS41 INS42 INS42 INS21 INS41 INS42 INS42 INS42 INS39 INS59 INS38 INS8 INS22 INS8 INS9 INS32 INS9 INS42 INS32 INS42 INS21 INS25 INS52 INS42 INS60 INS25 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS7 MOV27 INS8 INS8 INS43 INS59 INS27 INS8 INS8 INS42 INS32 INS21 INS10 INS42 INS42 INS32 INS42 INS33 INS25 INS25 INS42 INS42 INS42 INS7 INS22 INS42 INS42 INS38 INS8 INS27 INS8 INS42 INS32 INS52 INS42 INS32 INS21 INS42 INS42 INS21 INS41 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS9 INS22 INS42 INS42 INS42 INS32 INS42 INS52 INS42 INS42 INS42 DEL83 DEL42 DEL83 DEL42 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25
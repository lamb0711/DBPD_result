GEODE-4372: clean up RemoteOperationMessage classes (#1338)


* throw RemoteOperationException instead of ForceReattemptException when cache is closing. All ForceReattemptException throwing by RemoteOperationMessage has been removed.

* now uses SERIAL_EXECUTOR for all RemoteOperationMessages.
Previously most of these messages where processed in the partitioned message
thread pool even though most all of these messages where not partitioned.
It is possible that RemotePutAll and RemoteRemoveAll will have some trouble
being SERIAL_EXECUTOR.

* added comments for all RemoteOperationMessages describing what
they are used for

* Improved RemoteOperationMessageTest

* added a BucketTXRegionStub to calculate bucket region size on a stub.

* removed GemFireCacheImpl.getInstance call

* added RemoteOperationResponse unit test

* renamed handleAsUnexpected to handleCause

* renamed waitForCacheException to waitForRemoteResponse

* moved RemoteOperation classes to tx package


-package org.apache.geode.internal.cache;
+package org.apache.geode.internal.cache.tx;
-import java.util.Set;
-import org.apache.geode.cache.CacheException;
-import org.apache.geode.cache.LowMemoryException;
-import org.apache.geode.internal.cache.partitioned.PutMessage;
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.RemoteOperationException;
+import org.apache.geode.internal.cache.TXManagerImpl;
+import org.apache.geode.internal.cache.TXStateProxy;
+import org.apache.geode.internal.cache.TransactionMessage;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
- * The base PartitionedRegion message type upon which other messages should be based.
+ * The base message type upon which other messages that need to be sent to a remote member that is
+ * hosting a transaction should be based. Note that, currently, some of these message are not used
+ * by transactions. This is a misuse of these messages and needs to be corrected.
-  /** default exception to ensure a false-positive response is never returned */
-  static final ForceReattemptException UNHANDLED_EXCEPTION =
-      (ForceReattemptException) new ForceReattemptException(
-          LocalizedStrings.PartitionMessage_UNKNOWN_EXCEPTION.toLocalizedString())
-              .fillInStackTrace();
-
+    this(regionPath, processor);
+  }
+
+  private RemoteOperationMessage(String regionPath, ReplyProcessor21 processor) {
-    setIfTransactionDistributed();
-  }
-
-  public RemoteOperationMessage(Set recipients, String regionPath, ReplyProcessor21 processor) {
-    setRecipients(recipients);
-    this.regionPath = regionPath;
-    this.processorId = processor == null ? 0 : processor.getProcessorId();
-    if (processor != null && isSevereAlertCompatible()) {
-      processor.enableSevereAlertProcessing();
-    }
-    this.txUniqId = TXManagerImpl.getCurrentTXUniqueId();
-    TXStateProxy txState = TXManagerImpl.getCurrentTXState();
-    if (txState != null && txState.isMemberIdForwardingRequired()) {
-      this.txMemberId = txState.getOriginatingMember();
-    }
-    setIfTransactionDistributed();
-  }
-
-  /**
-   * Copy constructor that initializes the fields declared in this class
-   */
-  public RemoteOperationMessage(RemoteOperationMessage other) {
-    this.regionPath = other.regionPath;
-    this.processorId = other.processorId;
-    this.txUniqId = other.getTXUniqId();
-    this.txMemberId = other.getTXMemberId();
-    this.isTransactionDistributed = other.isTransactionDistributed;
+    setIfTransactionDistributed(processor);
-    return ClusterDistributionManager.PARTITIONED_REGION_EXECUTOR;
+    return ClusterDistributionManager.SERIAL_EXECUTOR;
-  public boolean checkCacheClosing(ClusterDistributionManager dm) {
-    InternalCache cache = dm.getCache();
+  public boolean checkCacheClosing(InternalCache cache) {
-   * @throws PartitionedRegionException if the region does not exist (typically, if it has been
-   *         destroyed)
+   * @throws RegionDestroyedException if the region does not exist
-      if (checkCacheClosing(dm) || checkDSClosing(dm)) {
+      if (checkCacheClosing(cache) || checkDSClosing(dm)) {
+        String message = "Remote cache is closed: " + dm.getId();
-          thr = new CacheClosedException(LocalizedStrings.PartitionMessage_REMOTE_CACHE_IS_CLOSED_0
-              .toLocalizedString(dm.getId()));
+          thr = new CacheClosedException(message);
-          thr = cache
-              .getCacheClosedException(LocalizedStrings.PartitionMessage_REMOTE_CACHE_IS_CLOSED_0
-                  .toLocalizedString(dm.getId()));
+          thr = cache.getCacheClosedException(message);
-        // if the distributed system is disconnecting, don't send a reply saying
-        // the partitioned region can't be found (bug 36585)
-      thr = UNHANDLED_EXCEPTION;
-
-      thr = null;
-
-    } catch (RemoteOperationException fre) {
-      thr = fre;
+    } catch (RegionDestroyedException | RemoteOperationException ex) {
+      thr = ex;
-    } catch (RegionDestroyedException rde) {
-      // [bruce] RDE does not always mean that the sender's region is also
-      // destroyed, so we must send back an exception. If the sender's
-      // region is also destroyed, who cares if we send it an exception
-      // if (pr != null && pr.isClosed) {
-      thr = new ForceReattemptException(LocalizedStrings.PartitionMessage_REGION_IS_DESTROYED_IN_0
-          .toLocalizedString(dm.getDistributionManagerId()), rde);
-      // }
+      thr = new RemoteOperationException("VirtualMachineError", err);
-      SystemFailure.checkFailure();
-      // log the exception at fine level if there is no reply to the message
-      thr = null;
+      if (sendReply) {
+        thr = new RemoteOperationException("system failure", SystemFailure.getFailure());
+      }
+      checkForSystemFailure();
-          thr = new ForceReattemptException(
-              LocalizedStrings.PartitionMessage_DISTRIBUTED_SYSTEM_IS_DISCONNECTING
-                  .toLocalizedString());
+          thr = new RemoteOperationException("cache is closing");
+  protected void checkForSystemFailure() {
+    SystemFailure.checkFailure();
+  }
+
-    return (LocalRegion) internalCache.getRegionByPathForProcessing(this.regionPath);
+    return (LocalRegion) internalCache.getRegionByPathForProcessing(getRegionPath());
-   *
-   * @param pr the Partitioned Region for the message whose statistics are incremented
-   * @param startTime the start time of the operation in nanoseconds
-   * @see PutMessage#sendReply
-      ReplyException ex, LocalRegion pr, long startTime) {
-    // if (pr != null && startTime > 0) {
-    // pr.getPrStats().endRemoteOperationMessagesProcessing(startTime);
-    // }
-
-    ReplyMessage.send(member, procId, ex, getReplySender(dm), pr != null && pr.isInternalRegion());
+      ReplyException ex, LocalRegion r, long startTime) {
+    ReplyMessage.send(member, procId, ex, getReplySender(dm), r != null && r.isInternalRegion());
-
-  /**
-   * return a new reply processor for this class, for use in relaying a response. This <b>must</b>
-   * be an instance method so subclasses can override it properly.
-   */
-  RemoteOperationResponse createReplyProcessor(PartitionedRegion r, Set recipients) {
-    return new RemoteOperationResponse(r.getSystem(), recipients);
-  }
-
-
-   * @see #waitForCacheException()
+   * @see #waitForRemoteResponse()
-    /**
-     * The exception thrown when the recipient does not reply
-     */
-    volatile ForceReattemptException prce;
+
+    private volatile RemoteOperationException memberDepartedException;
-    volatile boolean responseReceived;
+    private volatile boolean responseReceived;
-    boolean responseRequired;
+    private boolean responseRequired;
-    public RemoteOperationResponse(InternalDistributedSystem dm, Collection initMembers) {
-      this(dm, initMembers, true);
-    }
-
-    public RemoteOperationResponse(InternalDistributedSystem dm, Collection initMembers,
+    public RemoteOperationResponse(InternalDistributedSystem dm, Collection<?> initMembers,
-          this.prce = new ForceReattemptException(
-              LocalizedStrings.PartitionMessage_PARTITIONRESPONSE_GOT_MEMBERDEPARTED_EVENT_FOR_0_CRASHED_1
-                  .toLocalizedString(id, crashed));
+          this.memberDepartedException = new RemoteOperationException(
+              "memberDeparted event for <" + id + "> crashed = " + crashed);
-        Exception e = new Exception(
-            LocalizedStrings.PartitionMessage_MEMBERDEPARTED_GOT_NULL_MEMBERID.toLocalizedString());
-        logger.info(LocalizedMessage.create(
-            LocalizedStrings.PartitionMessage_MEMBERDEPARTED_GOT_NULL_MEMBERID_CRASHED_0, crashed),
-            e);
+        Exception e = new Exception("memberDeparted got null memberId");
+        logger.info("memberDeparted got null memberId crashed=" + crashed, e);
+    public RemoteOperationException getMemberDepartedException() {
+      return this.memberDepartedException;
+    }
+
-     * @throws CacheException if the recipient threw a cache exception during message processing
+     * @throws RemoteOperationException if the member we waited for a response from departed
+     * @throws RemoteOperationException if a response was required and not received
+     * @throws RemoteOperationException if the ReplyException was caused by a
+     *         RemoteOperationException
+     * @throws RemoteOperationException if the remote side's cache was closed
-    public void waitForCacheException()
-        throws CacheException, RemoteOperationException, PrimaryBucketException {
+    public void waitForRemoteResponse() throws RemoteOperationException {
-        if (this.prce != null || (this.responseRequired && !this.responseReceived)) {
-          throw new RemoteOperationException(
-              LocalizedStrings.PartitionMessage_ATTEMPT_FAILED.toLocalizedString(), this.prce);
+        RemoteOperationException ex = getMemberDepartedException();
+        if (ex != null) {
+          throw ex;
+        }
+        if (this.responseRequired && !this.responseReceived) {
+          throw new RemoteOperationException("response required but not received");
-        if (t instanceof CacheException) {
-          throw (CacheException) t;
-        } else if (t instanceof RemoteOperationException) {
-          RemoteOperationException ft = (RemoteOperationException) t;
-          // See FetchEntriesMessage, which can marshal a ForceReattempt
-          // across to the sender
-          RemoteOperationException fre = new RemoteOperationException(
-              LocalizedStrings.PartitionMessage_PEER_REQUESTS_REATTEMPT.toLocalizedString(), t);
-          if (ft.hasHash()) {
-            fre.setHash(ft.getHash());
-          }
-          throw fre;
-        } else if (t instanceof PrimaryBucketException) {
-          // See FetchEntryMessage, GetMessage, InvalidateMessage,
-          // PutMessage
-          // which can marshal a ForceReattemptacross to the sender
-          throw new PrimaryBucketException(
-              LocalizedStrings.PartitionMessage_PEER_FAILED_PRIMARY_TEST.toLocalizedString(), t);
-        } else if (t instanceof RegionDestroyedException) {
-          throw (RegionDestroyedException) t;
+        if (t instanceof RemoteOperationException) {
+          // no need to create a local RemoteOperationException to wrap the one from the reply
+          throw (RemoteOperationException) t;
-                "RemoteOperationResponse got CacheClosedException from {}, throwing ForceReattemptException",
+                "RemoteOperationResponse got CacheClosedException from {}, throwing RemoteOperationException",
-          throw new RemoteOperationException(
-              LocalizedStrings.PartitionMessage_PARTITIONRESPONSE_GOT_REMOTE_CACHECLOSEDEXCEPTION
-                  .toLocalizedString(),
-              t);
-        } else if (t instanceof LowMemoryException) {
-          if (logger.isDebugEnabled()) {
-            logger.debug("RemoteOperationResponse re-throwing remote LowMemoryException from {}",
-                e.getSender(), t);
-          }
-          throw (LowMemoryException) t;
+          throw new RemoteOperationException("remote cache was closed", t);
-        e.handleAsUnexpected();
+        e.handleCause();
-  public void setTransactionDistributed(boolean isDistTx) {
-    this.isTransactionDistributed = isDistTx;
-  }
-
-  /*
-   * For Distributed Tx
-   */
-  private void setIfTransactionDistributed() {
-    InternalCache cache = GemFireCacheImpl.getInstance();
-    if (cache != null) {
-      if (cache.getTxManager() != null) {
-        this.isTransactionDistributed = cache.getTxManager().isDistributed();
+  private void setIfTransactionDistributed(ReplyProcessor21 processor) {
+    if (processor != null) {
+      DistributionManager distributionManager = processor.getDistributionManager();
+      if (distributionManager != null) {
+        InternalCache cache = distributionManager.getCache();
+        if (cache != null && cache.getTxManager() != null) {
+          this.isTransactionDistributed = cache.getTxManager().isDistributed();
+        }

MOV26 MOV26 MOV26 MOV26 INS26 MOV31 MOV31 UPD40 UPD40 UPD40 UPD40 UPD40 INS40 UPD40 UPD83 MOV21 MOV78 INS39 UPD42 UPD83 UPD39 UPD42 INS31 INS44 INS8 UPD66 INS66 INS66 INS17 INS41 MOV43 INS42 MOV21 MOV43 UPD42 INS83 UPD43 INS83 INS83 MOV44 INS83 INS43 INS42 INS8 UPD42 INS43 INS42 INS25 INS42 INS42 INS40 UPD42 UPD66 UPD42 UPD42 INS74 INS42 INS41 INS65 INS65 INS65 INS42 INS27 MOV8 UPD42 UPD42 MOV43 UPD42 MOV43 INS76 INS22 INS42 INS66 INS42 INS66 UPD42 UPD66 INS66 INS42 INS66 INS8 INS12 INS42 INS33 INS84 INS42 INS21 INS25 INS21 INS32 INS52 INS42 MOV21 MOV60 MOV25 INS25 MOV44 INS8 INS43 INS27 INS60 MOV43 INS43 INS7 INS42 INS8 INS32 INS42 UPD42 UPD42 MOV43 INS27 MOV27 MOV8 MOV60 MOV25 MOV21 INS42 UPD42 INS42 INS33 INS60 UPD42 INS43 INS59 INS42 UPD42 INS42 INS14 MOV21 INS42 INS27 UPD42 INS32 INS42 INS33 INS53 MOV62 UPD42 UPD42 MOV43 INS59 INS27 INS42 INS42 INS27 INS43 INS45 INS42 MOV43 INS45 INS45 INS42 UPD42 MOV42 INS42 UPD42 INS42 INS32 MOV27 MOV27 INS45 MOV32 INS42 INS14 MOV43 INS45 MOV11 INS42 INS42 MOV43 INS45 INS32 UPD42 MOV43 INS27 INS42 UPD42 MOV42 INS42 INS42 INS45 INS42 INS45 INS42 MOV43 INS45 MOV43 INS45 UPD45 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL43 DEL40 DEL42 DEL32 DEL14 DEL42 DEL32 DEL11 DEL59 DEL23 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL33 DEL27 DEL34 DEL42 DEL42 DEL32 DEL16 DEL7 DEL21 DEL42 DEL33 DEL27 DEL42 DEL32 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL27 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL44 DEL42 DEL32 DEL21 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL40 DEL7 DEL21 DEL52 DEL42 DEL22 DEL40 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL52 DEL42 DEL22 DEL40 DEL7 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL66 DEL40 DEL42 DEL32 DEL40 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL7 DEL21 DEL42 DEL33 DEL7 DEL21 DEL42 DEL42 DEL44 DEL42 DEL42 DEL43 DEL40 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL14 DEL7 DEL21 DEL8 DEL12 DEL33 DEL42 DEL43 DEL40 DEL42 DEL32 DEL40 DEL41 DEL52 DEL42 DEL22 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL42 DEL67 DEL65 DEL66 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL14 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL9 DEL17 DEL8 DEL31 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL40 DEL42 DEL42 DEL42 DEL32 DEL40 DEL42 DEL32 DEL42 DEL42 DEL40 DEL42 DEL32 DEL42 DEL43 DEL42 DEL43 DEL40 DEL32 DEL42 DEL14 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL43 DEL40 DEL42 DEL32 DEL42 DEL42 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL11 DEL40 DEL42 DEL32 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL11 DEL53 DEL8 DEL25 DEL52 DEL42 DEL22 DEL33 DEL27 DEL36 DEL27 DEL40 DEL42 DEL32 DEL52 DEL42 DEL22 DEL14 DEL53 DEL8 DEL25 DEL8 DEL42 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL11 DEL53 DEL8 DEL42 DEL59 DEL60 DEL42 DEL53 DEL8 DEL42 DEL42 DEL43 DEL62 DEL25 DEL25 DEL25 DEL8 DEL12 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31
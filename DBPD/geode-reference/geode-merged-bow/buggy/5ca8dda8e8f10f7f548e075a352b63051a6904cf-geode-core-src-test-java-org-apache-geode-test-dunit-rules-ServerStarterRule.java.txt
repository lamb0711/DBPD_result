GEODE-2267: Enhance server/locator startup rules

* be able to return the rule itself so that we can start the server/locator at rule declaration time.
* rearrange the class structure
* do not delete the workingDir if the rule is created with a workingDir (then it's up for the caller to delete it)

-import org.apache.commons.io.FileUtils;
-import org.junit.rules.ExternalResource;
-import java.io.Serializable;
-import java.nio.file.Files;
+import java.io.IOException;
-public class ServerStarterRule extends ExternalResource implements Serializable {
+public class ServerStarterRule extends MemberStarterRule implements Server {
-  public Cache cache;
-  public CacheServer server;
-
-  private File workingDir;
-  private String oldUserDir;
+  private transient Cache cache;
+  private transient CacheServer server;
-   * Default constructor, if used, the rule won't start the server for you, you will need to
-   * manually start it. The rule will handle stop the server for you.
+   * Default constructor, if used, the rule will create a temporary folder as the server's working
+   * dir, and will delete it when the test is done.
+  /**
+   * if constructed this way, the rule won't be deleting the workingDir after the test is done. It's
+   * up to the caller's responsibility to delete it.
+   * 
+   * @param workingDir: the working dir this server should be writing the artifacts to.
+   */
-  public void before() throws Exception {
-    oldUserDir = System.getProperty("user.dir");
-    if (workingDir == null) {
-      workingDir = Files.createTempDirectory("server").toAbsolutePath().toFile();
-    }
-    System.setProperty("user.dir", workingDir.toString());
+  public Cache getCache() {
+    return cache;
-  public Server startServer() throws Exception {
+  public CacheServer getServer() {
+    return server;
+  }
+
+  @Override
+  void stopMember() {
+    // make sure this cache is the one currently open. A server cache can be recreated due to
+    // importing a new set of cluster configuration.
+    cache = GemFireCacheImpl.getInstance();
+    if (cache != null) {
+      cache.close();
+      cache = null;
+    }
+    if (server != null) {
+      server.stop();
+      server = null;
+    }
+  }
+
+  public ServerStarterRule startServer() {
-  public Server startServer(int locatorPort) throws Exception {
+  public ServerStarterRule startServer(int locatorPort) {
-  public Server startServer(int locatorPort, boolean pdxPersistent) throws Exception {
+  public ServerStarterRule startServer(int locatorPort, boolean pdxPersistent) {
-  public Server startServer(Properties properties) throws Exception {
+  public ServerStarterRule startServer(Properties properties) {
-  public Server startServer(Properties properties, int locatorPort) throws Exception {
+  public ServerStarterRule startServer(Properties properties, int locatorPort) {
-  public Server startServer(Properties properties, int locatorPort, boolean pdxPersistent)
-      throws Exception {
+  public ServerStarterRule startServer(Properties properties, int locatorPort,
+      boolean pdxPersistent) {
-    String name = properties.getProperty(NAME);
+    name = properties.getProperty(NAME);
-      int jmxPort = Integer.parseInt(properties.getProperty(JMX_MANAGER_PORT));
+      jmxPort = Integer.parseInt(properties.getProperty(JMX_MANAGER_PORT));
-    server.start();
-    return new Server(server.getPort(), workingDir, name);
-  }
-
-  @Override
-  public void after() {
-    // make sure this cache is the one currently open. A server cache can be recreated due to
-    // importing a new set of cluster configuration.
-    cache = GemFireCacheImpl.getInstance();
-    if (cache != null) {
-      cache.close();
-      cache = null;
+    try {
+      server.start();
+    } catch (IOException e) {
+      throw new RuntimeException("unable to start server", e);
-    if (server != null) {
-      server.stop();
-      server = null;
-    }
-    FileUtils.deleteQuietly(workingDir);
-    if (oldUserDir == null) {
-      System.clearProperty("user.dir");
-    } else {
-      System.setProperty("user.dir", oldUserDir);
-    }
+    memberPort = server.getPort();
+    return this;

MOV31 UPD40 INS43 MOV43 INS31 INS31 UPD42 MOV42 UPD83 INS83 UPD83 INS83 INS29 MOV83 UPD43 MOV43 INS42 INS8 INS83 INS43 INS42 INS8 UPD42 UPD43 UPD43 UPD43 UPD43 UPD43 INS43 INS42 INS65 INS65 UPD42 INS41 INS42 INS41 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS21 INS54 INS21 INS41 UPD66 UPD66 INS66 INS66 INS66 INS42 INS42 INS7 INS8 INS12 INS7 INS52 INS42 MOV32 INS21 MOV21 INS44 INS8 INS42 MOV32 INS7 INS43 INS42 INS53 INS42 MOV32 UPD42 MOV42 INS14 UPD43 MOV43 INS45 UPD42 MOV42 UPD42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL42 DEL43 DEL42 DEL43 DEL83 DEL43 DEL42 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL33 DEL27 DEL42 DEL42 DEL45 DEL32 DEL21 DEL8 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL25 DEL39 DEL42 DEL42 DEL42 DEL42 DEL45 DEL32 DEL7 DEL21 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL45 DEL32 DEL42 DEL32 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL31 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL43 DEL43 DEL42 DEL59 DEL60 DEL39 DEL42 DEL59 DEL60 DEL42 DEL14 DEL41
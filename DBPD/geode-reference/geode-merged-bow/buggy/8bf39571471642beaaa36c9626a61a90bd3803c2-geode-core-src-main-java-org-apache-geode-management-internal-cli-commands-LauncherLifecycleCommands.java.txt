Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * The LauncherLifecycleCommands class encapsulates all GemFire launcher commands for GemFire tools (like starting
- * GemFire Monitor (GFMon) and Visual Statistics Display (VSD)) as well external tools (like jconsole).
+ * The LauncherLifecycleCommands class encapsulates all GemFire launcher commands for GemFire tools
+ * (like starting GemFire Monitor (GFMon) and Visual Statistics Display (VSD)) as well external
+ * tools (like jconsole).
+ * 
-  protected static final AtomicReference<Boolean> ATTACH_API_AVAILABLE = new AtomicReference<>(null);
+  protected static final AtomicReference<Boolean> ATTACH_API_AVAILABLE =
+      new AtomicReference<>(null);
-  protected static final String ATTACH_API_CLASS_NAME = "com.sun.tools.attach.AttachNotSupportedException";
+  protected static final String ATTACH_API_CLASS_NAME =
+      "com.sun.tools.attach.AttachNotSupportedException";
-  protected static final String GEMFIRE_JAR_PATHNAME = IOUtils.appendToPath(GEMFIRE_HOME, "lib", GemFireVersion.getGemFireJarFileName());
+  protected static final String GEMFIRE_JAR_PATHNAME =
+      IOUtils.appendToPath(GEMFIRE_HOME, "lib", GemFireVersion.getGemFireJarFileName());
-  @CliMetaData(shellOnly = true, relatedTopic = { CliStrings.TOPIC_GEODE_LOCATOR, CliStrings.TOPIC_GEODE_LIFECYCLE })
+  @CliMetaData(shellOnly = true,
+      relatedTopic = {CliStrings.TOPIC_GEODE_LOCATOR, CliStrings.TOPIC_GEODE_LIFECYCLE})
-      @CliOption(key = CliStrings.START_LOCATOR__MEMBER_NAME,
-          mandatory = true,
+      @CliOption(key = CliStrings.START_LOCATOR__MEMBER_NAME, mandatory = true,
-          help = CliStrings.START_LOCATOR__MEMBER_NAME__HELP)
-      final String memberName,
+          help = CliStrings.START_LOCATOR__MEMBER_NAME__HELP) final String memberName,
-          help = CliStrings.START_LOCATOR__BIND_ADDRESS__HELP)
-      final String bindAddress,
+          help = CliStrings.START_LOCATOR__BIND_ADDRESS__HELP) final String bindAddress,
-          help = CliStrings.START_LOCATOR__CLASSPATH__HELP)
-      final String classpath,
-      @CliOption(key = CliStrings.START_LOCATOR__FORCE,
-          unspecifiedDefaultValue = "false",
+          help = CliStrings.START_LOCATOR__CLASSPATH__HELP) final String classpath,
+      @CliOption(key = CliStrings.START_LOCATOR__FORCE, unspecifiedDefaultValue = "false",
-          help = CliStrings.START_LOCATOR__FORCE__HELP)
-      final Boolean force,
-      @CliOption(key = CliStrings.START_LOCATOR__GROUP,
-          optionContext = ConverterHint.MEMBERGROUP,
+          help = CliStrings.START_LOCATOR__FORCE__HELP) final Boolean force,
+      @CliOption(key = CliStrings.START_LOCATOR__GROUP, optionContext = ConverterHint.MEMBERGROUP,
-          help = CliStrings.START_LOCATOR__GROUP__HELP)
-      final String group,
+          help = CliStrings.START_LOCATOR__GROUP__HELP) final String group,
-          help = CliStrings.START_LOCATOR__HOSTNAME_FOR_CLIENTS__HELP)
-      final String hostnameForClients,
+          help = CliStrings.START_LOCATOR__HOSTNAME_FOR_CLIENTS__HELP) final String hostnameForClients,
-          specifiedDefaultValue = "true",
-          unspecifiedDefaultValue = "false",
-          help = CliStrings.START_LOCATOR__INCLUDE_SYSTEM_CLASSPATH__HELP)
-      final Boolean includeSystemClasspath,
+          specifiedDefaultValue = "true", unspecifiedDefaultValue = "false",
+          help = CliStrings.START_LOCATOR__INCLUDE_SYSTEM_CLASSPATH__HELP) final Boolean includeSystemClasspath,
-          help = CliStrings.START_LOCATOR__LOCATORS__HELP)
-      final String locators,
-      @CliOption(key = CliStrings.START_LOCATOR__LOG_LEVEL,
-          optionContext = ConverterHint.LOG_LEVEL,
+          help = CliStrings.START_LOCATOR__LOCATORS__HELP) final String locators,
+      @CliOption(key = CliStrings.START_LOCATOR__LOG_LEVEL, optionContext = ConverterHint.LOG_LEVEL,
-          help = CliStrings.START_LOCATOR__LOG_LEVEL__HELP)
-      final String logLevel,
+          help = CliStrings.START_LOCATOR__LOG_LEVEL__HELP) final String logLevel,
-          help = CliStrings.START_LOCATOR__MCAST_ADDRESS__HELP)
-      final String mcastBindAddress,
+          help = CliStrings.START_LOCATOR__MCAST_ADDRESS__HELP) final String mcastBindAddress,
-          help = CliStrings.START_LOCATOR__MCAST_PORT__HELP)
-      final Integer mcastPort,
+          help = CliStrings.START_LOCATOR__MCAST_PORT__HELP) final Integer mcastPort,
-          help = CliStrings.START_LOCATOR__PORT__HELP)
-      final Integer port,
-      @CliOption(key = CliStrings.START_LOCATOR__DIR,
-          optionContext = ConverterHint.DIR_PATHSTRING,
+          help = CliStrings.START_LOCATOR__PORT__HELP) final Integer port,
+      @CliOption(key = CliStrings.START_LOCATOR__DIR, optionContext = ConverterHint.DIR_PATHSTRING,
-          help = CliStrings.START_LOCATOR__DIR__HELP)
-          String workingDirectory,
+          help = CliStrings.START_LOCATOR__DIR__HELP) String workingDirectory,
-          help = CliStrings.START_LOCATOR__PROPERTIES__HELP)
-          String gemfirePropertiesPathname,
+          help = CliStrings.START_LOCATOR__PROPERTIES__HELP) String gemfirePropertiesPathname,
-          help = CliStrings.START_LOCATOR__SECURITY_PROPERTIES__HELP)
-          String gemfireSecurityPropertiesPathname,
+          help = CliStrings.START_LOCATOR__SECURITY_PROPERTIES__HELP) String gemfireSecurityPropertiesPathname,
-          help = CliStrings.START_LOCATOR__INITIALHEAP__HELP)
-      final String initialHeap,
+          help = CliStrings.START_LOCATOR__INITIALHEAP__HELP) final String initialHeap,
-          help = CliStrings.START_LOCATOR__MAXHEAP__HELP)
-      final String maxHeap,
-      @CliOption(key = CliStrings.START_LOCATOR__J,
-          optionContext = ConverterHint.STRING_LIST,
+          help = CliStrings.START_LOCATOR__MAXHEAP__HELP) final String maxHeap,
+      @CliOption(key = CliStrings.START_LOCATOR__J, optionContext = ConverterHint.STRING_LIST,
-          help = CliStrings.START_LOCATOR__J__HELP)
-      @CliMetaData(valueSeparator = ",")
-      final String[] jvmArgsOpts,
-      @CliOption(key = CliStrings.START_LOCATOR__CONNECT,
-          unspecifiedDefaultValue = "true",
+          help = CliStrings.START_LOCATOR__J__HELP) @CliMetaData(
+              valueSeparator = ",") final String[] jvmArgsOpts,
+      @CliOption(key = CliStrings.START_LOCATOR__CONNECT, unspecifiedDefaultValue = "true",
-          help = CliStrings.START_LOCATOR__CONNECT__HELP)
-      final boolean connect,
+          help = CliStrings.START_LOCATOR__CONNECT__HELP) final boolean connect,
-          unspecifiedDefaultValue = "true",
-          specifiedDefaultValue = "true",
-          help = CliStrings.START_LOCATOR__ENABLE__SHARED__CONFIGURATION__HELP)
-      final boolean enableSharedConfiguration,
+          unspecifiedDefaultValue = "true", specifiedDefaultValue = "true",
+          help = CliStrings.START_LOCATOR__ENABLE__SHARED__CONFIGURATION__HELP) final boolean enableSharedConfiguration,
-          help = CliStrings.START_LOCATOR__LOAD__SHARED_CONFIGURATION__FROM__FILESYSTEM__HELP)
-      final boolean loadSharedConfigurationFromDirectory,
-      @CliOption(key = CliStrings.START_LOCATOR__CLUSTER__CONFIG__DIR,
-          unspecifiedDefaultValue = "",
-          help = CliStrings.START_LOCATOR__CLUSTER__CONFIG__DIR__HELP)
-      final String clusterConfigDir
-  ) {
+          help = CliStrings.START_LOCATOR__LOAD__SHARED_CONFIGURATION__FROM__FILESYSTEM__HELP) final boolean loadSharedConfigurationFromDirectory,
+      @CliOption(key = CliStrings.START_LOCATOR__CLUSTER__CONFIG__DIR, unspecifiedDefaultValue = "",
+          help = CliStrings.START_LOCATOR__CLUSTER__CONFIG__DIR__HELP) final String clusterConfigDir) {
-          throw new IllegalStateException(CliStrings.format(CliStrings.START_LOCATOR__MSG__COULD_NOT_CREATE_DIRECTORY_0_VERIFY_PERMISSIONS,
+          throw new IllegalStateException(CliStrings.format(
+              CliStrings.START_LOCATOR__MSG__COULD_NOT_CREATE_DIRECTORY_0_VERIFY_PERMISSIONS,
-      if (!StringUtils.isBlank(gemfirePropertiesPathname) && !IOUtils.isExistingPathname(gemfirePropertiesPathname)) {
-        return ResultBuilder.createUserErrorResult(CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE,
-            StringUtils.EMPTY_STRING, gemfirePropertiesPathname));
+      if (!StringUtils.isBlank(gemfirePropertiesPathname)
+          && !IOUtils.isExistingPathname(gemfirePropertiesPathname)) {
+        return ResultBuilder.createUserErrorResult(
+            CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE,
+                StringUtils.EMPTY_STRING, gemfirePropertiesPathname));
-      gemfireSecurityPropertiesPathname = CliUtil.resolvePathname(gemfireSecurityPropertiesPathname);
+      gemfireSecurityPropertiesPathname =
+          CliUtil.resolvePathname(gemfireSecurityPropertiesPathname);
-      if (!StringUtils.isBlank(gemfireSecurityPropertiesPathname) && !IOUtils.isExistingPathname(gemfireSecurityPropertiesPathname)) {
-        return ResultBuilder.createUserErrorResult(CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE,
-            "Security ", gemfireSecurityPropertiesPathname));
+      if (!StringUtils.isBlank(gemfireSecurityPropertiesPathname)
+          && !IOUtils.isExistingPathname(gemfireSecurityPropertiesPathname)) {
+        return ResultBuilder.createUserErrorResult(
+            CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE, "Security ",
+                gemfireSecurityPropertiesPathname));
-      gemfireProperties.setProperty(LOCATORS, StringUtils.valueOf(locators, StringUtils.EMPTY_STRING));
-      gemfireProperties.setProperty(LOG_LEVEL, StringUtils.valueOf(logLevel, StringUtils.EMPTY_STRING));
-      gemfireProperties.setProperty(MCAST_ADDRESS, StringUtils.valueOf(mcastBindAddress, StringUtils.EMPTY_STRING));
-      gemfireProperties.setProperty(MCAST_PORT, StringUtils.valueOf(mcastPort, StringUtils.EMPTY_STRING));
-      gemfireProperties.setProperty(ENABLE_CLUSTER_CONFIGURATION, StringUtils.valueOf(enableSharedConfiguration, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(LOCATORS,
+          StringUtils.valueOf(locators, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(LOG_LEVEL,
+          StringUtils.valueOf(logLevel, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(MCAST_ADDRESS,
+          StringUtils.valueOf(mcastBindAddress, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(MCAST_PORT,
+          StringUtils.valueOf(mcastPort, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(ENABLE_CLUSTER_CONFIGURATION,
+          StringUtils.valueOf(enableSharedConfiguration, StringUtils.EMPTY_STRING));
-      gemfireProperties.setProperty(CLUSTER_CONFIGURATION_DIR, StringUtils.valueOf(clusterConfigDir, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(CLUSTER_CONFIGURATION_DIR,
+          StringUtils.valueOf(clusterConfigDir, StringUtils.EMPTY_STRING));
-      // read the OSProcess enable redirect system property here -- TODO: replace with new GFSH argument
-      final boolean redirectOutput = Boolean.getBoolean(OSProcess.ENABLE_OUTPUT_REDIRECTION_PROPERTY);
-      LocatorLauncher locatorLauncher = new LocatorLauncher.Builder()
-          .setBindAddress(bindAddress)
-          .setForce(force)
-          .setHostnameForClients(hostnameForClients)
-          .setMemberName(memberName)
-          .setPort(port)
-          .setRedirectOutput(redirectOutput)
-          .setWorkingDirectory(workingDirectory)
-          .build();
+      // read the OSProcess enable redirect system property here -- TODO: replace with new GFSH
+      // argument
+      final boolean redirectOutput =
+          Boolean.getBoolean(OSProcess.ENABLE_OUTPUT_REDIRECTION_PROPERTY);
+      LocatorLauncher locatorLauncher =
+          new LocatorLauncher.Builder().setBindAddress(bindAddress).setForce(force)
+              .setHostnameForClients(hostnameForClients).setMemberName(memberName).setPort(port)
+              .setRedirectOutput(redirectOutput).setWorkingDirectory(workingDirectory).build();
-      String[] locatorCommandLine = createStartLocatorCommandLine(locatorLauncher, gemfirePropertiesPathname,
-          gemfireSecurityPropertiesPathname, gemfireProperties, classpath, includeSystemClasspath, jvmArgsOpts, initialHeap, maxHeap);
+      String[] locatorCommandLine = createStartLocatorCommandLine(locatorLauncher,
+          gemfirePropertiesPathname, gemfireSecurityPropertiesPathname, gemfireProperties,
+          classpath, includeSystemClasspath, jvmArgsOpts, initialHeap, maxHeap);
-      //getGfsh().logInfo(StringUtils.concat(locatorCommandLine, " "), null);
+      // getGfsh().logInfo(StringUtils.concat(locatorCommandLine, " "), null);
-          .directory(new File(locatorLauncher.getWorkingDirectory()))
-          .start();
+          .directory(new File(locatorLauncher.getWorkingDirectory())).start();
-      final ReadingMode readingMode = SystemUtils.isWindows() ? ReadingMode.NON_BLOCKING : ReadingMode.BLOCKING;
+      final ReadingMode readingMode =
+          SystemUtils.isWindows() ? ReadingMode.NON_BLOCKING : ReadingMode.BLOCKING;
-          .inputStream(locatorProcess.getErrorStream())
-          .inputListener(inputListener)
-          .readingMode(readingMode)
-          .continueReadingMillis(2 * 1000)
-          .build()
-          .start();
+          .inputStream(locatorProcess.getErrorStream()).inputListener(inputListener)
+          .readingMode(readingMode).continueReadingMillis(2 * 1000).build().start();
-      final boolean registeredLocatorSignalListener = getGfsh().getSignalHandler().registerListener(locatorSignalListener);
+      final boolean registeredLocatorSignalListener =
+          getGfsh().getSignalHandler().registerListener(locatorSignalListener);
-            IOUtils.tryGetCanonicalPathElseGetAbsolutePath(new File(locatorLauncher.getWorkingDirectory()))), null);
+            IOUtils.tryGetCanonicalPathElseGetAbsolutePath(
+                new File(locatorLauncher.getWorkingDirectory()))),
+            null);
-            //Gfsh.println(message);
+            // Gfsh.println(message);
-            return ResultBuilder.createShellClientErrorResult(String.format(
-                CliStrings.START_LOCATOR__PROCESS_TERMINATED_ABNORMALLY_ERROR_MESSAGE,
-                exitValue, locatorLauncher.getWorkingDirectory(), message.toString()));
+            return ResultBuilder.createShellClientErrorResult(
+                String.format(CliStrings.START_LOCATOR__PROCESS_TERMINATED_ABNORMALLY_ERROR_MESSAGE,
+                    exitValue, locatorLauncher.getWorkingDirectory(), message.toString()));
-            // the IllegalThreadStateException is expected; it means the Locator's process has not terminated,
+            // the IllegalThreadStateException is expected; it means the Locator's process has not
+            // terminated,
-            locatorState = (ProcessUtils.isAttachApiAvailable() ? locatorStatus(locatorPidFile, oldPid, memberName)
+            locatorState = (ProcessUtils.isAttachApiAvailable()
+                ? locatorStatus(locatorPidFile, oldPid, memberName)
-                && !(StringUtils.isBlank(currentLocatorStatusMessage)
-                || currentLocatorStatusMessage.equalsIgnoreCase(previousLocatorStatusMessage))) {
+                && !(StringUtils.isBlank(currentLocatorStatusMessage) || currentLocatorStatusMessage
+                    .equalsIgnoreCase(previousLocatorStatusMessage))) {
-        }
-        while (!(registeredLocatorSignalListener && locatorSignalListener.isSignaled())
+        } while (!(registeredLocatorSignalListener && locatorSignalListener.isSignaled())
-        stderrReader.stopAsync(PROCESS_STREAM_READER_ASYNC_STOP_TIMEOUT_MILLIS); // stop will close ErrorStream
+        stderrReader.stopAsync(PROCESS_STREAM_READER_ASYNC_STOP_TIMEOUT_MILLIS); // stop will close
+                                                                                 // ErrorStream
-      final boolean asyncStart = (registeredLocatorSignalListener && locatorSignalListener.isSignaled()
-          && isStartingNotRespondingOrNull(locatorState));
+      final boolean asyncStart = (registeredLocatorSignalListener
+          && locatorSignalListener.isSignaled() && isStartingNotRespondingOrNull(locatorState));
-        infoResultData.addLine(String.format(CliStrings.ASYNC_PROCESS_LAUNCH_MESSAGE, LOCATOR_TERM_NAME));
+        infoResultData
+            .addLine(String.format(CliStrings.ASYNC_PROCESS_LAUNCH_MESSAGE, LOCATOR_TERM_NAME));
-        if (bindAddr != null){
+        if (bindAddr != null) {
-          locatorHostName = StringUtils.defaultIfBlank(locatorLauncher.getHostnameForClients(), getLocalHost());
+          locatorHostName =
+              StringUtils.defaultIfBlank(locatorLauncher.getHostnameForClients(), getLocalHost());
-          doAutoConnect(locatorHostName, locatorPort, gemfirePropertiesPathname, gemfireSecurityPropertiesPathname,
-              infoResultData);
+          doAutoConnect(locatorHostName, locatorPort, gemfirePropertiesPathname,
+              gemfireSecurityPropertiesPathname, infoResultData);
-          infoResultData.addLine(getSharedConfigurationStatusFromLocator(locatorHostName, locatorPort));
+          infoResultData
+              .addLine(getSharedConfigurationStatusFromLocator(locatorHostName, locatorPort));
-      if (message != null && message.matches(LocalizedStrings.Launcher_Builder_UNKNOWN_HOST_ERROR_MESSAGE.toLocalizedString(".+"))) {
-        message = CliStrings.format(CliStrings.LAUNCHERLIFECYCLECOMMANDS__MSG__FAILED_TO_START_0_REASON_1, LOCATOR_TERM_NAME, message);
+      if (message != null && message.matches(
+          LocalizedStrings.Launcher_Builder_UNKNOWN_HOST_ERROR_MESSAGE.toLocalizedString(".+"))) {
+        message =
+            CliStrings.format(CliStrings.LAUNCHERLIFECYCLECOMMANDS__MSG__FAILED_TO_START_0_REASON_1,
+                LOCATOR_TERM_NAME, message);
-      final String gemfirePropertiesPathname,
-      final String gemfireSecurityPropertiesPathname,
-      final Properties gemfireProperties,
-      final String userClasspath,
-      final Boolean includeSystemClasspath,
-      final String[] jvmArgsOpts,
-      final String initialHeap,
-      final String maxHeap)
-      throws MalformedObjectNameException {
+      final String gemfirePropertiesPathname, final String gemfireSecurityPropertiesPathname,
+      final Properties gemfireProperties, final String userClasspath,
+      final Boolean includeSystemClasspath, final String[] jvmArgsOpts, final String initialHeap,
+      final String maxHeap) throws MalformedObjectNameException {
-    commandLine.add(getLocatorClasspath(Boolean.TRUE.equals(includeSystemClasspath), userClasspath));
+    commandLine
+        .add(getLocatorClasspath(Boolean.TRUE.equals(includeSystemClasspath), userClasspath));
-    commandLine.add("-D".concat(AbstractLauncher.SIGNAL_HANDLER_REGISTRATION_SYSTEM_PROPERTY.concat("=true")));
+    commandLine.add(
+        "-D".concat(AbstractLauncher.SIGNAL_HANDLER_REGISTRATION_SYSTEM_PROPERTY.concat("=true")));
-    commandLine.add("-Dsun.rmi.dgc.server.gcInterval".concat("=").concat(Long.toString(Long.MAX_VALUE - 1)));
+    commandLine.add(
+        "-Dsun.rmi.dgc.server.gcInterval".concat("=").concat(Long.toString(Long.MAX_VALUE - 1)));
-  // TODO should we connect implicitly when in non-interactive, headless mode (e.g. gfsh -e "start locator ...")?
-  // With execute option (-e), there could be multiple commands which might presume that a prior "start locator"
+  // TODO should we connect implicitly when in non-interactive, headless mode (e.g. gfsh -e "start
+  // locator ...")?
+  // With execute option (-e), there could be multiple commands which might presume that a prior
+  // "start locator"
-  private boolean doAutoConnect(final String locatorHostname,
-      final int locatorPort,
-      final String gemfirePropertiesPathname,
-      final String gemfireSecurityPropertiesPathname,
+  private boolean doAutoConnect(final String locatorHostname, final int locatorPort,
+      final String gemfirePropertiesPathname, final String gemfireSecurityPropertiesPathname,
-    Map<String, String> configurationProperties = loadConfigurationProperties(gemfireSecurityPropertiesPathname,
-        loadConfigurationProperties(gemfirePropertiesPathname));
+    Map<String, String> configurationProperties = loadConfigurationProperties(
+        gemfireSecurityPropertiesPathname, loadConfigurationProperties(gemfirePropertiesPathname));
-        ConnectToLocatorResult connectToLocatorResult = ShellCommands.connectToLocator(locatorHostname, locatorPort,
-            ShellCommands.getConnectLocatorTimeoutInMS() / 4, locatorConfigurationProperties);
+        ConnectToLocatorResult connectToLocatorResult =
+            ShellCommands.connectToLocator(locatorHostname, locatorPort,
+                ShellCommands.getConnectLocatorTimeoutInMS() / 4, locatorConfigurationProperties);
-        getGfsh().setOperationInvoker(new JmxOperationInvoker(memberEndpoint.getHost(), memberEndpoint.getPort(),
-            null, null, configurationProperties, null));
+        getGfsh().setOperationInvoker(new JmxOperationInvoker(memberEndpoint.getHost(),
+            memberEndpoint.getPort(), null, null, configurationProperties, null));
-        String shellAndLogMessage = CliStrings.format(CliStrings.CONNECT__MSG__SUCCESS, "JMX Manager " + memberEndpoint.toString(false));
+        String shellAndLogMessage = CliStrings.format(CliStrings.CONNECT__MSG__SUCCESS,
+            "JMX Manager " + memberEndpoint.toString(false));
-      }
-      catch (AuthenticationFailedException ignore) {
+      } catch (AuthenticationFailedException ignore) {
-      }
-      catch (SSLException ignore) {
+      } catch (SSLException ignore) {
-          // try to connect again without SSL since the SSL handshake failed implying a plain text connection...
+          // try to connect again without SSL since the SSL handshake failed implying a plain text
+          // connection...
-      doOnConnectionFailure(locatorHostname, locatorPort, jmxManagerAuthEnabled, jmxManagerSslEnabled, infoResultData);
+      doOnConnectionFailure(locatorHostname, locatorPort, jmxManagerAuthEnabled,
+          jmxManagerSslEnabled, infoResultData);
-  private void doOnConnectionFailure(final String locatorHostName,
-      final int locatorPort,
-      final boolean jmxManagerAuthEnabled,
-      final boolean jmxManagerSslEnabled,
+  private void doOnConnectionFailure(final String locatorHostName, final int locatorPort,
+      final boolean jmxManagerAuthEnabled, final boolean jmxManagerSslEnabled,
-        new CommandStringBuilder(CliStrings.CONNECT).addOption(CliStrings.CONNECT__LOCATOR,
-            locatorHostName + "[" + locatorPort + "]").toString()));
+        new CommandStringBuilder(CliStrings.CONNECT)
+            .addOption(CliStrings.CONNECT__LOCATOR, locatorHostName + "[" + locatorPort + "]")
+            .toString()));
-      message.append(jmxManagerAuthEnabled ? " and " : StringUtils.EMPTY_STRING).append("SSL configuration");
+      message.append(jmxManagerAuthEnabled ? " and " : StringUtils.EMPTY_STRING)
+          .append("SSL configuration");
-  private Map<String, String> loadConfigurationProperties(final String configurationPropertiesPathname) {
+  private Map<String, String> loadConfigurationProperties(
+      final String configurationPropertiesPathname) {
-  private Map<String, String> loadConfigurationProperties(final String configurationPropertiesPathname,
-      Map<String, String> configurationProperties) {
-    configurationProperties = (configurationProperties != null ? configurationProperties
-        : new HashMap<String, String>());
+  private Map<String, String> loadConfigurationProperties(
+      final String configurationPropertiesPathname, Map<String, String> configurationProperties) {
+    configurationProperties =
+        (configurationProperties != null ? configurationProperties : new HashMap<String, String>());
-        configurationProperties.putAll(ShellCommands.loadPropertiesFromURL(
-            new File(configurationPropertiesPathname).toURI().toURL()));
+        configurationProperties.putAll(ShellCommands
+            .loadPropertiesFromURL(new File(configurationPropertiesPathname).toURI().toURL()));
-        LogWrapper.getInstance().warning(String.format(
-            "Failed to load GemFire configuration properties from pathname (%1$s)!",
-            configurationPropertiesPathname), ignore);
+        LogWrapper.getInstance()
+            .warning(String.format(
+                "Failed to load GemFire configuration properties from pathname (%1$s)!",
+                configurationPropertiesPathname), ignore);
-  private String getSharedConfigurationStatusFromLocatorState(LocatorState locatorState) throws ClassNotFoundException, IOException {
-    return getSharedConfigurationStatusFromLocator(locatorState.getHost(), Integer.parseInt(locatorState.getPort()));
+  private String getSharedConfigurationStatusFromLocatorState(LocatorState locatorState)
+      throws ClassNotFoundException, IOException {
+    return getSharedConfigurationStatusFromLocator(locatorState.getHost(),
+        Integer.parseInt(locatorState.getPort()));
-  private String getSharedConfigurationStatusFromLocator(String locatorHostName, int locatorPort) throws ClassNotFoundException, IOException {
+  private String getSharedConfigurationStatusFromLocator(String locatorHostName, int locatorPort)
+      throws ClassNotFoundException, IOException {
-      SharedConfigurationStatusResponse statusResponse = (SharedConfigurationStatusResponse)
-          client.requestToServer(networkAddress, locatorPort, new SharedConfigurationStatusRequest(), 10000, true);
+      SharedConfigurationStatusResponse statusResponse =
+          (SharedConfigurationStatusResponse) client.requestToServer(networkAddress, locatorPort,
+              new SharedConfigurationStatusRequest(), 10000, true);
-        if (statusResponse.getStatus().equals(SharedConfigurationStatus.STARTED) || statusResponse.getStatus().equals(SharedConfigurationStatus.NOT_STARTED)) {
-          statusResponse = (SharedConfigurationStatusResponse)
-              client.requestToServer(networkAddress, locatorPort, new SharedConfigurationStatusRequest(), 10000, true);
+        if (statusResponse.getStatus().equals(SharedConfigurationStatus.STARTED)
+            || statusResponse.getStatus().equals(SharedConfigurationStatus.NOT_STARTED)) {
+          statusResponse =
+              (SharedConfigurationStatusResponse) client.requestToServer(networkAddress,
+                  locatorPort, new SharedConfigurationStatusRequest(), 10000, true);
-            //Swallow the exception
+            // Swallow the exception
-      case RUNNING:
-        buffer.append("\nCluster configuration service is up and running.");
-        break;
-      case STOPPED:
-        buffer.append("\nCluster configuration service failed to start , please check the log file for errors.");
-        break;
-      case WAITING:
-        buffer.append("\nCluster configuration service is waiting for other locators with newer shared configuration data.");
-        Set<PersistentMemberPattern> pmpSet = statusResponse.getOtherLocatorInformation();
-        if (!pmpSet.isEmpty()) {
-          buffer.append("\nThis locator might have stale cluster configuration data.");
-          buffer.append("\nFollowing locators contain potentially newer cluster configuration data");
+        case RUNNING:
+          buffer.append("\nCluster configuration service is up and running.");
+          break;
+        case STOPPED:
+          buffer.append(
+              "\nCluster configuration service failed to start , please check the log file for errors.");
+          break;
+        case WAITING:
+          buffer.append(
+              "\nCluster configuration service is waiting for other locators with newer shared configuration data.");
+          Set<PersistentMemberPattern> pmpSet = statusResponse.getOtherLocatorInformation();
+          if (!pmpSet.isEmpty()) {
+            buffer.append("\nThis locator might have stale cluster configuration data.");
+            buffer.append(
+                "\nFollowing locators contain potentially newer cluster configuration data");
-          for (PersistentMemberPattern pmp : pmpSet) {
-            buffer.append("\nHost : ").append(pmp.getHost());
-            buffer.append("\nDirectory : ").append(pmp.getDirectory());
+            for (PersistentMemberPattern pmp : pmpSet) {
+              buffer.append("\nHost : ").append(pmp.getHost());
+              buffer.append("\nDirectory : ").append(pmp.getDirectory());
+            }
+          } else {
+            buffer.append("\nPlease check the log file for errors");
-        } else {
-          buffer.append("\nPlease check the log file for errors");
-        }
-        break;
-      case UNDETERMINED:
-        buffer.append("\nUnable to determine the status of shared configuration service, please check the log file");
-        break;
-      case NOT_STARTED:
-        buffer.append("\nCluster configuration service has not been started yet");
-        break;
-      case STARTED:
-        buffer.append("\nCluster configuration service has been started, but its not running yet");
-        break;
+          break;
+        case UNDETERMINED:
+          buffer.append(
+              "\nUnable to determine the status of shared configuration service, please check the log file");
+          break;
+        case NOT_STARTED:
+          buffer.append("\nCluster configuration service has not been started yet");
+          break;
+        case STARTED:
+          buffer
+              .append("\nCluster configuration service has been started, but its not running yet");
+          break;
-      // NOTE this ClassCastException occurs if the a plain text TCP/IP connection is used to connect to a Locator
+      // NOTE this ClassCastException occurs if the a plain text TCP/IP connection is used to
+      // connect to a Locator
-      getGfsh().logToFile(String.format("Failed to get the status of the Shared Configuration Service running on Locator (%1$s[%2$d])!",
+      getGfsh().logToFile(String.format(
+          "Failed to get the status of the Shared Configuration Service running on Locator (%1$s[%2$d])!",
-  @CliMetaData(shellOnly = true, relatedTopic = { CliStrings.TOPIC_GEODE_LOCATOR, CliStrings.TOPIC_GEODE_LIFECYCLE })
-  public Result statusLocator(@CliOption(key = CliStrings.STATUS_LOCATOR__MEMBER,
-      optionContext = ConverterHint.LOCATOR_MEMBER_IDNAME,
-      unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-      help = CliStrings.STATUS_LOCATOR__MEMBER__HELP)
-  final String member,
+  @CliMetaData(shellOnly = true,
+      relatedTopic = {CliStrings.TOPIC_GEODE_LOCATOR, CliStrings.TOPIC_GEODE_LIFECYCLE})
+  public Result statusLocator(
+      @CliOption(key = CliStrings.STATUS_LOCATOR__MEMBER,
+          optionContext = ConverterHint.LOCATOR_MEMBER_IDNAME,
+          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
+          help = CliStrings.STATUS_LOCATOR__MEMBER__HELP) final String member,
-          help = CliStrings.STATUS_LOCATOR__HOST__HELP)
-      final String locatorHost,
+          help = CliStrings.STATUS_LOCATOR__HOST__HELP) final String locatorHost,
-          help = CliStrings.STATUS_LOCATOR__PORT__HELP)
-      final Integer locatorPort,
+          help = CliStrings.STATUS_LOCATOR__PORT__HELP) final Integer locatorPort,
-          help = CliStrings.STATUS_LOCATOR__PID__HELP)
-      final Integer pid,
-      @CliOption(key = CliStrings.STATUS_LOCATOR__DIR,
-          optionContext = ConverterHint.DIR_PATHSTRING,
+          help = CliStrings.STATUS_LOCATOR__PID__HELP) final Integer pid,
+      @CliOption(key = CliStrings.STATUS_LOCATOR__DIR, optionContext = ConverterHint.DIR_PATHSTRING,
-          help = CliStrings.STATUS_LOCATOR__DIR__HELP)
-      final String workingDirectory) {
+          help = CliStrings.STATUS_LOCATOR__DIR__HELP) final String workingDirectory) {
-        final LocatorLauncher locatorLauncher = new LocatorLauncher.Builder()
-            .setCommand(LocatorLauncher.Command.STATUS)
-            .setBindAddress(locatorHost)
-            .setDebug(isDebugging())
-            .setPid(pid)
-            .setPort(locatorPort)
-            .setWorkingDirectory(workingDirectory)
-            .build();
+        final LocatorLauncher locatorLauncher =
+            new LocatorLauncher.Builder().setCommand(LocatorLauncher.Command.STATUS)
+                .setBindAddress(locatorHost).setDebug(isDebugging()).setPid(pid)
+                .setPort(locatorPort).setWorkingDirectory(workingDirectory).build();
-      return ResultBuilder.createShellClientErrorResult(String.format(CliStrings.STATUS_LOCATOR__GENERAL_ERROR_MESSAGE,
-          getLocatorId(locatorHost, locatorPort), StringUtils.defaultIfBlank(workingDirectory, SystemUtils.CURRENT_DIRECTORY),
+      return ResultBuilder.createShellClientErrorResult(String.format(
+          CliStrings.STATUS_LOCATOR__GENERAL_ERROR_MESSAGE, getLocatorId(locatorHost, locatorPort),
+          StringUtils.defaultIfBlank(workingDirectory, SystemUtils.CURRENT_DIRECTORY),
-  @CliMetaData(shellOnly = true, relatedTopic = { CliStrings.TOPIC_GEODE_LOCATOR, CliStrings.TOPIC_GEODE_LIFECYCLE })
-  public Result stopLocator(@CliOption(key = CliStrings.STOP_LOCATOR__MEMBER,
-      optionContext = ConverterHint.LOCATOR_MEMBER_IDNAME,
-      unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-      help = CliStrings.STOP_LOCATOR__MEMBER__HELP)
-  final String member,
+  @CliMetaData(shellOnly = true,
+      relatedTopic = {CliStrings.TOPIC_GEODE_LOCATOR, CliStrings.TOPIC_GEODE_LIFECYCLE})
+  public Result stopLocator(
+      @CliOption(key = CliStrings.STOP_LOCATOR__MEMBER,
+          optionContext = ConverterHint.LOCATOR_MEMBER_IDNAME,
+          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
+          help = CliStrings.STOP_LOCATOR__MEMBER__HELP) final String member,
-          help = CliStrings.STOP_LOCATOR__PID__HELP)
-      final Integer pid,
-      @CliOption(key = CliStrings.STOP_LOCATOR__DIR,
-          optionContext = ConverterHint.DIR_PATHSTRING,
+          help = CliStrings.STOP_LOCATOR__PID__HELP) final Integer pid,
+      @CliOption(key = CliStrings.STOP_LOCATOR__DIR, optionContext = ConverterHint.DIR_PATHSTRING,
-          help = CliStrings.STOP_LOCATOR__DIR__HELP)
-      final String workingDirectory) {
+          help = CliStrings.STOP_LOCATOR__DIR__HELP) final String workingDirectory) {
-              throw new IllegalStateException(CliStrings.format(CliStrings.STOP_LOCATOR__NOT_LOCATOR_ERROR_MESSAGE, member));
+              throw new IllegalStateException(
+                  CliStrings.format(CliStrings.STOP_LOCATOR__NOT_LOCATOR_ERROR_MESSAGE, member));
-              throw new IllegalStateException(CliStrings.format(CliStrings.STOP_LOCATOR__LOCATOR_IS_CACHE_SERVER_ERROR_MESSAGE, member));
+              throw new IllegalStateException(CliStrings
+                  .format(CliStrings.STOP_LOCATOR__LOCATOR_IS_CACHE_SERVER_ERROR_MESSAGE, member));
-        final LocatorLauncher locatorLauncher = new LocatorLauncher.Builder()
-            .setCommand(LocatorLauncher.Command.STOP)
-            .setDebug(isDebugging())
-            .setPid(pid)
-            .setWorkingDirectory(workingDirectory)
-            .build();
+        final LocatorLauncher locatorLauncher =
+            new LocatorLauncher.Builder().setCommand(LocatorLauncher.Command.STOP)
+                .setDebug(isDebugging()).setPid(pid).setWorkingDirectory(workingDirectory).build();
-        getGfsh().logInfo(String.format(CliStrings.STOP_LOCATOR__STOPPING_LOCATOR_MESSAGE,
-            locatorState.getWorkingDirectory(), locatorState.getServiceLocation(), locatorState.getMemberName(),
-            locatorState.getPid(), locatorState.getLogFile()), null);
+        getGfsh().logInfo(
+            String.format(CliStrings.STOP_LOCATOR__STOPPING_LOCATOR_MESSAGE,
+                locatorState.getWorkingDirectory(), locatorState.getServiceLocation(),
+                locatorState.getMemberName(), locatorState.getPid(), locatorState.getLogFile()),
+            null);
-      return ResultBuilder.createShellClientErrorResult(String.format(CliStrings.STOP_LOCATOR__GENERAL_ERROR_MESSAGE,
-          toString(t, getGfsh().getDebug())));
+      return ResultBuilder.createShellClientErrorResult(String.format(
+          CliStrings.STOP_LOCATOR__GENERAL_ERROR_MESSAGE, toString(t, getGfsh().getDebug())));
-  // TODO re-evaluate whether a MalformedObjectNameException should be thrown here; just because we were not able to find
-  // the "current" Locators in order to conveniently add the new member to the GemFire cluster does not mean we should
+  // TODO re-evaluate whether a MalformedObjectNameException should be thrown here; just because we
+  // were not able to find
+  // the "current" Locators in order to conveniently add the new member to the GemFire cluster does
+  // not mean we should
-  protected void addCurrentLocators(final List<String> commandLine, final Properties gemfireProperties) throws MalformedObjectNameException {
+  protected void addCurrentLocators(final List<String> commandLine,
+      final Properties gemfireProperties) throws MalformedObjectNameException {
-  protected Result createStatusLocatorResult(final LocatorState state) throws NumberFormatException, IOException, ClassNotFoundException {
+  protected Result createStatusLocatorResult(final LocatorState state)
+      throws NumberFormatException, IOException, ClassNotFoundException {
-  protected void addGemFirePropertyFile(final List<String> commandLine, final String gemfirePropertiesPathname) {
+  protected void addGemFirePropertyFile(final List<String> commandLine,
+      final String gemfirePropertiesPathname) {
-  protected void addGemFireSecurityPropertyFile(final List<String> commandLine, final String gemfireSecurityPropertiesPathname) {
+  protected void addGemFireSecurityPropertyFile(final List<String> commandLine,
+      final String gemfireSecurityPropertiesPathname) {
-  protected void addGemFireSystemProperties(final List<String> commandLine, final Properties gemfireProperties) {
+  protected void addGemFireSystemProperties(final List<String> commandLine,
+      final Properties gemfireProperties) {
-        commandLine.add("-D" + DistributionConfig.GEMFIRE_PREFIX + "" + propertyName + "=" + propertyValue);
+        commandLine.add(
+            "-D" + DistributionConfig.GEMFIRE_PREFIX + "" + propertyName + "=" + propertyValue);
-  protected void addJvmArgumentsAndOptions(final List<String> commandLine, final String[] jvmArgsOpts) {
+  protected void addJvmArgumentsAndOptions(final List<String> commandLine,
+      final String[] jvmArgsOpts) {
-      // NOTE IBM states the following IBM J9 JVM command-line option/switch has side-effects on "performance",
+      // NOTE IBM states the following IBM J9 JVM command-line option/switch has side-effects on
+      // "performance",
-      // NOTE the following Oracle JRockit JVM documentation was referenced to identify the appropriate JVM option to
+      // NOTE the following Oracle JRockit JVM documentation was referenced to identify the
+      // appropriate JVM option to
-      //commandLine.add("-XX:MinHeapFreeRatio=" + MINIMUM_HEAP_FREE_RATIO);
+      // commandLine.add("-XX:MinHeapFreeRatio=" + MINIMUM_HEAP_FREE_RATIO);
-  protected LocatorState locatorStatus(final File locatorPidFile, final int oldPid, final String memberName) {
+  protected LocatorState locatorStatus(final File locatorPidFile, final int oldPid,
+      final String memberName) {
-    LocatorState locatorState = new LocatorLauncher.Builder().setWorkingDirectory(workingDirectory).build().status();
+    LocatorState locatorState =
+        new LocatorLauncher.Builder().setWorkingDirectory(workingDirectory).build().status();
-  protected ServerState serverStatus(final File serverPidFile, final int oldPid, final String memberName) {
+  protected ServerState serverStatus(final File serverPidFile, final int oldPid,
+      final String memberName) {
-      ServerState serverState = new ServerLauncher.Builder().setPid(newPid).setDisableDefaultServer(true)
-          .build().status();
+      ServerState serverState = new ServerLauncher.Builder().setPid(newPid)
+          .setDisableDefaultServer(true).build().status();
-  protected String getLocatorClasspath(final boolean includeSystemClasspath, final String userClasspath) {
-    return toClasspath(includeSystemClasspath, new String[] { CORE_DEPENDENCIES_JAR_PATHNAME }, userClasspath);
+  protected String getLocatorClasspath(final boolean includeSystemClasspath,
+      final String userClasspath) {
+    return toClasspath(includeSystemClasspath, new String[] {CORE_DEPENDENCIES_JAR_PATHNAME},
+        userClasspath);
-    return toClasspath(includeSystemClasspath, jarFilePathnames.toArray(new String[jarFilePathnames.size()]),
-        userClasspath);
+    return toClasspath(includeSystemClasspath,
+        jarFilePathnames.toArray(new String[jarFilePathnames.size()]), userClasspath);
-  String toClasspath(final boolean includeSystemClasspath, String[] jarFilePathnames, String... userClasspaths) {
+  String toClasspath(final boolean includeSystemClasspath, String[] jarFilePathnames,
+      String... userClasspaths) {
-    // Then, include user-specified classes on CLASSPATH to enable the user to override GemFire JAR dependencies
-    // with application-specific versions; this logic/block corresponds to classes/jar-files specified with the
-    // --classpath option to the 'start locator' and 'start server commands'; also this will override any
-    // System CLASSPATH environment variable setting, which is consistent with the Java platform behavior...
+    // Then, include user-specified classes on CLASSPATH to enable the user to override GemFire JAR
+    // dependencies
+    // with application-specific versions; this logic/block corresponds to classes/jar-files
+    // specified with the
+    // --classpath option to the 'start locator' and 'start server commands'; also this will
+    // override any
+    // System CLASSPATH environment variable setting, which is consistent with the Java platform
+    // behavior...
-    jarFilePathnames = (jarFilePathnames != null ? jarFilePathnames : StringUtils.EMPTY_STRING_ARRAY);
+    jarFilePathnames =
+        (jarFilePathnames != null ? jarFilePathnames : StringUtils.EMPTY_STRING_ARRAY);
-    final String locatorPort = StringUtils.valueOf(port, String.valueOf(DistributionLocator.DEFAULT_LOCATOR_PORT));
+    final String locatorPort =
+        StringUtils.valueOf(port, String.valueOf(DistributionLocator.DEFAULT_LOCATOR_PORT));
-   * Gets a proxy to the DistributedSystemMXBean from the GemFire Manager's MBeanServer, or null if unable to find
-   * the DistributedSystemMXBean.
+   * Gets a proxy to the DistributedSystemMXBean from the GemFire Manager's MBeanServer, or null if
+   * unable to find the DistributedSystemMXBean.
-   * @return a proxy to the DistributedSystemMXBean from the GemFire Manager's MBeanServer, or null if unable to find
-   * the DistributedSystemMXBean.
+   * @return a proxy to the DistributedSystemMXBean from the GemFire Manager's MBeanServer, or null
+   *         if unable to find the DistributedSystemMXBean.
-  protected DistributedSystemMXBean getDistributedSystemMXBean() throws IOException, MalformedObjectNameException {
-    assertState(isConnectedAndReady(), "Gfsh must be connected in order to get proxy to a GemFire DistributedSystemMXBean.");
+  protected DistributedSystemMXBean getDistributedSystemMXBean()
+      throws IOException, MalformedObjectNameException {
+    assertState(isConnectedAndReady(),
+        "Gfsh must be connected in order to get proxy to a GemFire DistributedSystemMXBean.");
-   * Gets a proxy to the MemberMXBean for the GemFire member specified by member name or ID from the GemFire Manager's
-   * MBeanServer.
+   * Gets a proxy to the MemberMXBean for the GemFire member specified by member name or ID from the
+   * GemFire Manager's MBeanServer.
-   * @return a proxy to the MemberMXBean having the specified GemFire member's name or ID from the GemFire Manager's
-   * MBeanServer, or null if no GemFire member could be found with the specified member name or ID.
+   * @return a proxy to the MemberMXBean having the specified GemFire member's name or ID from the
+   *         GemFire Manager's MBeanServer, or null if no GemFire member could be found with the
+   *         specified member name or ID.
-  protected MemberMXBean getMemberMXBean(final String serviceName, final String member) throws IOException {
-    assertState(isConnectedAndReady(), "Gfsh must be connected in order to get proxy to a GemFire Member MBean.");
+  protected MemberMXBean getMemberMXBean(final String serviceName, final String member)
+      throws IOException {
+    assertState(isConnectedAndReady(),
+        "Gfsh must be connected in order to get proxy to a GemFire Member MBean.");
-      // NOTE throws a MalformedObjectNameException, however, this should not happen since the ObjectName is constructed
+      // NOTE throws a MalformedObjectNameException, however, this should not happen since the
+      // ObjectName is constructed
-      final QueryExp query = Query.or(
-          Query.eq(Query.attr("Name"), Query.value(member)),
-          Query.eq(Query.attr("Id"), Query.value(member))
-      );
+      final QueryExp query = Query.or(Query.eq(Query.attr("Name"), Query.value(member)),
+          Query.eq(Query.attr("Id"), Query.value(member)));
-      final Set<ObjectName> memberObjectNames = getGfsh().getOperationInvoker().queryNames(objectName, query);
+      final Set<ObjectName> memberObjectNames =
+          getGfsh().getOperationInvoker().queryNames(objectName, query);
-        memberBean = getGfsh().getOperationInvoker().getMBeanProxy(memberObjectNames.iterator().next(), MemberMXBean.class);
+        memberBean = getGfsh().getOperationInvoker()
+            .getMBeanProxy(memberObjectNames.iterator().next(), MemberMXBean.class);
-    // note: this will use JNA if available or Attach if available or return false if neither is available
+    // note: this will use JNA if available or Attach if available or return false if neither is
+    // available
-  @CliMetaData(shellOnly = true, relatedTopic = { CliStrings.TOPIC_GEODE_SERVER, CliStrings.TOPIC_GEODE_LIFECYCLE })
-  public Result startServer(@CliOption(key = CliStrings.START_SERVER__ASSIGN_BUCKETS,
-      unspecifiedDefaultValue = "false",
-      specifiedDefaultValue = "true",
-      help = CliStrings.START_SERVER__ASSIGN_BUCKETS__HELP)
-  final Boolean assignBuckets,
+  @CliMetaData(shellOnly = true,
+      relatedTopic = {CliStrings.TOPIC_GEODE_SERVER, CliStrings.TOPIC_GEODE_LIFECYCLE})
+  public Result startServer(
+      @CliOption(key = CliStrings.START_SERVER__ASSIGN_BUCKETS, unspecifiedDefaultValue = "false",
+          specifiedDefaultValue = "true",
+          help = CliStrings.START_SERVER__ASSIGN_BUCKETS__HELP) final Boolean assignBuckets,
-          help = CliStrings.START_SERVER__BIND_ADDRESS__HELP)
-      final String bindAddress,
+          help = CliStrings.START_SERVER__BIND_ADDRESS__HELP) final String bindAddress,
-          help = CliStrings.START_SERVER__CACHE_XML_FILE__HELP)
-          String cacheXmlPathname,
+          help = CliStrings.START_SERVER__CACHE_XML_FILE__HELP) String cacheXmlPathname,
-                                      /*optionContext = ConverterHint.FILE_PATHSTRING, // there's an issue with TAB here*/
+          /* optionContext = ConverterHint.FILE_PATHSTRING, // there's an issue with TAB here */
-          help = CliStrings.START_SERVER__CLASSPATH__HELP)
-      final String classpath,
+          help = CliStrings.START_SERVER__CLASSPATH__HELP) final String classpath,
-          help = CliStrings.START_SERVER__CRITICAL__HEAP__HELP)
-      final Float criticalHeapPercentage,
+          help = CliStrings.START_SERVER__CRITICAL__HEAP__HELP) final Float criticalHeapPercentage,
-          help = CliStrings.START_SERVER__CRITICAL_OFF_HEAP__HELP)
-      final Float criticalOffHeapPercentage,
-      @CliOption(key = CliStrings.START_SERVER__DIR,
-          optionContext = ConverterHint.DIR_PATHSTRING,
+          help = CliStrings.START_SERVER__CRITICAL_OFF_HEAP__HELP) final Float criticalOffHeapPercentage,
+      @CliOption(key = CliStrings.START_SERVER__DIR, optionContext = ConverterHint.DIR_PATHSTRING,
-          help = CliStrings.START_SERVER__DIR__HELP)
-          String workingDirectory,
+          help = CliStrings.START_SERVER__DIR__HELP) String workingDirectory,
-          unspecifiedDefaultValue = "false",
-          specifiedDefaultValue = "true",
-          help = CliStrings.START_SERVER__DISABLE_DEFAULT_SERVER__HELP)
-      final Boolean disableDefaultServer,
+          unspecifiedDefaultValue = "false", specifiedDefaultValue = "true",
+          help = CliStrings.START_SERVER__DISABLE_DEFAULT_SERVER__HELP) final Boolean disableDefaultServer,
-          unspecifiedDefaultValue = "false",
-          specifiedDefaultValue = "true",
-          help = CliStrings.START_SERVER__DISABLE_EXIT_WHEN_OUT_OF_MEMORY_HELP)
-      final Boolean disableExitWhenOutOfMemory,
+          unspecifiedDefaultValue = "false", specifiedDefaultValue = "true",
+          help = CliStrings.START_SERVER__DISABLE_EXIT_WHEN_OUT_OF_MEMORY_HELP) final Boolean disableExitWhenOutOfMemory,
-          help = CliStrings.START_SERVER__ENABLE_TIME_STATISTICS__HELP)
-      final Boolean enableTimeStatistics,
+          help = CliStrings.START_SERVER__ENABLE_TIME_STATISTICS__HELP) final Boolean enableTimeStatistics,
-          help = CliStrings.START_SERVER__EVICTION__HEAP__PERCENTAGE__HELP)
-      final Float evictionHeapPercentage,
+          help = CliStrings.START_SERVER__EVICTION__HEAP__PERCENTAGE__HELP) final Float evictionHeapPercentage,
-          help = CliStrings.START_SERVER__EVICTION_OFF_HEAP_PERCENTAGE__HELP)
-      final Float evictionOffHeapPercentage,
-      @CliOption(key = CliStrings.START_SERVER__FORCE,
-          unspecifiedDefaultValue = "false",
+          help = CliStrings.START_SERVER__EVICTION_OFF_HEAP_PERCENTAGE__HELP) final Float evictionOffHeapPercentage,
+      @CliOption(key = CliStrings.START_SERVER__FORCE, unspecifiedDefaultValue = "false",
-          help = CliStrings.START_SERVER__FORCE__HELP)
-      final Boolean force,
-      @CliOption(key = CliStrings.START_SERVER__GROUP,
-          optionContext = ConverterHint.MEMBERGROUP,
+          help = CliStrings.START_SERVER__FORCE__HELP) final Boolean force,
+      @CliOption(key = CliStrings.START_SERVER__GROUP, optionContext = ConverterHint.MEMBERGROUP,
-          help = CliStrings.START_SERVER__GROUP__HELP)
-      final String group,
+          help = CliStrings.START_SERVER__GROUP__HELP) final String group,
-          help = CliStrings.START_SERVER__HOSTNAME__FOR__CLIENTS__HELP)
-      final String hostNameForClients,
+          help = CliStrings.START_SERVER__HOSTNAME__FOR__CLIENTS__HELP) final String hostNameForClients,
-          specifiedDefaultValue = "true",
-          unspecifiedDefaultValue = "false",
-          help = CliStrings.START_SERVER__INCLUDE_SYSTEM_CLASSPATH__HELP)
-      final Boolean includeSystemClasspath,
+          specifiedDefaultValue = "true", unspecifiedDefaultValue = "false",
+          help = CliStrings.START_SERVER__INCLUDE_SYSTEM_CLASSPATH__HELP) final Boolean includeSystemClasspath,
-          help = CliStrings.START_SERVER__INITIAL_HEAP__HELP)
-      final String initialHeap,
-      @CliOption(key = CliStrings.START_SERVER__J,
-          optionContext = ConverterHint.STRING_LIST,
+          help = CliStrings.START_SERVER__INITIAL_HEAP__HELP) final String initialHeap,
+      @CliOption(key = CliStrings.START_SERVER__J, optionContext = ConverterHint.STRING_LIST,
-          help = CliStrings.START_SERVER__J__HELP)
-      @CliMetaData(valueSeparator = ",")
-      final String[] jvmArgsOpts,
+          help = CliStrings.START_SERVER__J__HELP) @CliMetaData(
+              valueSeparator = ",") final String[] jvmArgsOpts,
-          help = CliStrings.START_SERVER__LOCATORS__HELP)
-      final String locators,
+          help = CliStrings.START_SERVER__LOCATORS__HELP) final String locators,
-          help = CliStrings.START_SERVER__LOCATOR_WAIT_TIME_HELP)
-      final Integer locatorWaitTime,
+          help = CliStrings.START_SERVER__LOCATOR_WAIT_TIME_HELP) final Integer locatorWaitTime,
-          help = CliStrings.START_SERVER__LOCK_MEMORY__HELP)
-      final Boolean lockMemory,
-      @CliOption(key = CliStrings.START_SERVER__LOG_LEVEL,
-          optionContext = ConverterHint.LOG_LEVEL,
+          help = CliStrings.START_SERVER__LOCK_MEMORY__HELP) final Boolean lockMemory,
+      @CliOption(key = CliStrings.START_SERVER__LOG_LEVEL, optionContext = ConverterHint.LOG_LEVEL,
-          help = CliStrings.START_SERVER__LOG_LEVEL__HELP)
-      final String logLevel,
+          help = CliStrings.START_SERVER__LOG_LEVEL__HELP) final String logLevel,
-          help = CliStrings.START_SERVER__MAX__CONNECTIONS__HELP)
-      final Integer maxConnections,
+          help = CliStrings.START_SERVER__MAX__CONNECTIONS__HELP) final Integer maxConnections,
-          help = CliStrings.START_SERVER__MAXHEAP__HELP)
-      final String maxHeap,
+          help = CliStrings.START_SERVER__MAXHEAP__HELP) final String maxHeap,
-          help = CliStrings.START_SERVER__MAX__MESSAGE__COUNT__HELP)
-      final Integer maxMessageCount,
+          help = CliStrings.START_SERVER__MAX__MESSAGE__COUNT__HELP) final Integer maxMessageCount,
-          help = CliStrings.START_SERVER__MAX__THREADS__HELP)
-      final Integer maxThreads,
+          help = CliStrings.START_SERVER__MAX__THREADS__HELP) final Integer maxThreads,
-          help = CliStrings.START_SERVER__MCAST_ADDRESS__HELP)
-      final String mcastBindAddress,
+          help = CliStrings.START_SERVER__MCAST_ADDRESS__HELP) final String mcastBindAddress,
-          help = CliStrings.START_SERVER__MCAST_PORT__HELP)
-      final Integer mcastPort,
+          help = CliStrings.START_SERVER__MCAST_PORT__HELP) final Integer mcastPort,
-          help = CliStrings.START_SERVER__MEMCACHED_PORT__HELP)
-      final Integer memcachedPort,
+          help = CliStrings.START_SERVER__MEMCACHED_PORT__HELP) final Integer memcachedPort,
-          help = CliStrings.START_SERVER__MEMCACHED_PROTOCOL__HELP)
-      final String memcachedProtocol,
+          help = CliStrings.START_SERVER__MEMCACHED_PROTOCOL__HELP) final String memcachedProtocol,
-          help = CliStrings.START_SERVER__MEMCACHED_BIND_ADDRESS__HELP)
-      final String memcachedBindAddress,
+          help = CliStrings.START_SERVER__MEMCACHED_BIND_ADDRESS__HELP) final String memcachedBindAddress,
-          help = CliStrings.START_SERVER__REDIS_PORT__HELP)
-      final Integer redisPort,
+          help = CliStrings.START_SERVER__REDIS_PORT__HELP) final Integer redisPort,
-          help = CliStrings.START_SERVER__REDIS_BIND_ADDRESS__HELP)
-      final String redisBindAddress,
+          help = CliStrings.START_SERVER__REDIS_BIND_ADDRESS__HELP) final String redisBindAddress,
-          help = CliStrings.START_SERVER__REDIS_PASSWORD__HELP)
-      final String redisPassword,
+          help = CliStrings.START_SERVER__REDIS_PASSWORD__HELP) final String redisPassword,
-          help = CliStrings.START_SERVER__MESSAGE__TIME__TO__LIVE__HELP)
-      final Integer messageTimeToLive,
-      @CliOption(key = CliStrings.START_SERVER__NAME,
-          mandatory = true,
+          help = CliStrings.START_SERVER__MESSAGE__TIME__TO__LIVE__HELP) final Integer messageTimeToLive,
+      @CliOption(key = CliStrings.START_SERVER__NAME, mandatory = true,
-          help = CliStrings.START_SERVER__NAME__HELP)
-      final String memberName,
+          help = CliStrings.START_SERVER__NAME__HELP) final String memberName,
-          help = CliStrings.START_SERVER__OFF_HEAP_MEMORY_SIZE__HELP)
-      final String offHeapMemorySize,
+          help = CliStrings.START_SERVER__OFF_HEAP_MEMORY_SIZE__HELP) final String offHeapMemorySize,
-          help = CliStrings.START_SERVER__PROPERTIES__HELP)
-          String gemfirePropertiesPathname,
-      @CliOption(key = CliStrings.START_SERVER__REBALANCE,
-          unspecifiedDefaultValue = "false",
+          help = CliStrings.START_SERVER__PROPERTIES__HELP) String gemfirePropertiesPathname,
+      @CliOption(key = CliStrings.START_SERVER__REBALANCE, unspecifiedDefaultValue = "false",
-          help = CliStrings.START_SERVER__REBALANCE__HELP)
-      final Boolean rebalance,
+          help = CliStrings.START_SERVER__REBALANCE__HELP) final Boolean rebalance,
-          help = CliStrings.START_SERVER__SECURITY_PROPERTIES__HELP)
-          String gemfireSecurityPropertiesPathname,
+          help = CliStrings.START_SERVER__SECURITY_PROPERTIES__HELP) String gemfireSecurityPropertiesPathname,
-          help = CliStrings.START_SERVER__SERVER_BIND_ADDRESS__HELP)
-      final String serverBindAddress,
+          help = CliStrings.START_SERVER__SERVER_BIND_ADDRESS__HELP) final String serverBindAddress,
-          help = CliStrings.START_SERVER__SERVER_PORT__HELP)
-      final Integer serverPort,
+          help = CliStrings.START_SERVER__SERVER_PORT__HELP) final Integer serverPort,
-          help = CliStrings.START_SERVER__SOCKET__BUFFER__SIZE__HELP)
-      final Integer socketBufferSize,
+          help = CliStrings.START_SERVER__SOCKET__BUFFER__SIZE__HELP) final Integer socketBufferSize,
-          help = CliStrings.START_SERVER__SPRING_XML_LOCATION_HELP)
-      final String springXmlLocation,
+          help = CliStrings.START_SERVER__SPRING_XML_LOCATION_HELP) final String springXmlLocation,
-          help = CliStrings.START_SERVER__STATISTIC_ARCHIVE_FILE__HELP)
-      final String statisticsArchivePathname,
+          help = CliStrings.START_SERVER__STATISTIC_ARCHIVE_FILE__HELP) final String statisticsArchivePathname,
-          unspecifiedDefaultValue = "true",
+          unspecifiedDefaultValue = "true", specifiedDefaultValue = "true",
+          help = CliStrings.START_SERVER__USE_CLUSTER_CONFIGURATION__HELP) final Boolean requestSharedConfiguration,
+      @CliOption(key = CliStrings.START_SERVER__REST_API, unspecifiedDefaultValue = "false",
-          help = CliStrings.START_SERVER__USE_CLUSTER_CONFIGURATION__HELP)
-      final Boolean requestSharedConfiguration,
-          @CliOption(key = CliStrings.START_SERVER__REST_API,
-          unspecifiedDefaultValue = "false",
-          specifiedDefaultValue = "true",
-          help = CliStrings.START_SERVER__REST_API__HELP)
-      final Boolean startRestApi,
-          @CliOption(key = CliStrings.START_SERVER__HTTP_SERVICE_PORT,
-            unspecifiedDefaultValue = ("" + CacheServer.HTTP_DEFAULT_PORT),
-            help = CliStrings.START_SERVER__HTTP_SERVICE_PORT__HELP)
-      final String httpServicePort,
-          @CliOption(key = CliStrings.START_SERVER__HTTP_SERVICE_BIND_ADDRESS,
-           unspecifiedDefaultValue = CacheServer.HTTP_SERVICE_DEFAULT_BIND_ADDRESS,
-           help = CliStrings.START_SERVER__HTTP_SERVICE_BIND_ADDRESS__HELP)
-      final String httpServiceBindAddress,
-          @CliOption(key = CliStrings.START_SERVER__USERNAME,
-           unspecifiedDefaultValue = "",
-           help = CliStrings.START_SERVER__USERNAME__HELP)
-      final String userName,
-          @CliOption(key = START_SERVER__PASSWORD,
-           unspecifiedDefaultValue = "",
-           help = CliStrings.START_SERVER__PASSWORD__HELP)
-      String passwordToUse)
+          help = CliStrings.START_SERVER__REST_API__HELP) final Boolean startRestApi,
+      @CliOption(key = CliStrings.START_SERVER__HTTP_SERVICE_PORT,
+          unspecifiedDefaultValue = ("" + CacheServer.HTTP_DEFAULT_PORT),
+          help = CliStrings.START_SERVER__HTTP_SERVICE_PORT__HELP) final String httpServicePort,
+      @CliOption(key = CliStrings.START_SERVER__HTTP_SERVICE_BIND_ADDRESS,
+          unspecifiedDefaultValue = CacheServer.HTTP_SERVICE_DEFAULT_BIND_ADDRESS,
+          help = CliStrings.START_SERVER__HTTP_SERVICE_BIND_ADDRESS__HELP) final String httpServiceBindAddress,
+      @CliOption(key = CliStrings.START_SERVER__USERNAME, unspecifiedDefaultValue = "",
+          help = CliStrings.START_SERVER__USERNAME__HELP) final String userName,
+      @CliOption(key = START_SERVER__PASSWORD, unspecifiedDefaultValue = "",
+          help = CliStrings.START_SERVER__PASSWORD__HELP) String passwordToUse)
-          return ResultBuilder.createConnectionErrorResult(CliStrings.START_SERVER__MSG__PASSWORD_MUST_BE_SPECIFIED);
+          return ResultBuilder.createConnectionErrorResult(
+              CliStrings.START_SERVER__MSG__PASSWORD_MUST_BE_SPECIFIED);
-          throw new IllegalStateException(CliStrings.format(CliStrings.START_SERVER__MSG__COULD_NOT_CREATE_DIRECTORY_0_VERIFY_PERMISSIONS,
+          throw new IllegalStateException(CliStrings.format(
+              CliStrings.START_SERVER__MSG__COULD_NOT_CREATE_DIRECTORY_0_VERIFY_PERMISSIONS,
-        return ResultBuilder.createUserErrorResult(CliStrings.format(CliStrings.CACHE_XML_NOT_FOUND_MESSAGE, cacheXmlPathname));
+        return ResultBuilder.createUserErrorResult(
+            CliStrings.format(CliStrings.CACHE_XML_NOT_FOUND_MESSAGE, cacheXmlPathname));
-      if (!StringUtils.isBlank(gemfirePropertiesPathname) && !IOUtils.isExistingPathname(gemfirePropertiesPathname)) {
-        return ResultBuilder.createUserErrorResult(CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE,
-            StringUtils.EMPTY_STRING, gemfirePropertiesPathname));
+      if (!StringUtils.isBlank(gemfirePropertiesPathname)
+          && !IOUtils.isExistingPathname(gemfirePropertiesPathname)) {
+        return ResultBuilder.createUserErrorResult(
+            CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE,
+                StringUtils.EMPTY_STRING, gemfirePropertiesPathname));
-      gemfireSecurityPropertiesPathname = CliUtil.resolvePathname(gemfireSecurityPropertiesPathname);
+      gemfireSecurityPropertiesPathname =
+          CliUtil.resolvePathname(gemfireSecurityPropertiesPathname);
-      if (!StringUtils.isBlank(gemfireSecurityPropertiesPathname) && !IOUtils.isExistingPathname(gemfireSecurityPropertiesPathname)) {
-        return ResultBuilder.createUserErrorResult(CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE,
-            "Security ", gemfireSecurityPropertiesPathname));
+      if (!StringUtils.isBlank(gemfireSecurityPropertiesPathname)
+          && !IOUtils.isExistingPathname(gemfireSecurityPropertiesPathname)) {
+        return ResultBuilder.createUserErrorResult(
+            CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE, "Security ",
+                gemfireSecurityPropertiesPathname));
-      gemfireProperties.setProperty(BIND_ADDRESS, StringUtils.valueOf(bindAddress, StringUtils.EMPTY_STRING));
-      gemfireProperties.setProperty(CACHE_XML_FILE, StringUtils.valueOf(cacheXmlPathname, StringUtils.EMPTY_STRING));
-      gemfireProperties.setProperty(ENABLE_TIME_STATISTICS, StringUtils.valueOf(enableTimeStatistics, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(BIND_ADDRESS,
+          StringUtils.valueOf(bindAddress, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(CACHE_XML_FILE,
+          StringUtils.valueOf(cacheXmlPathname, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(ENABLE_TIME_STATISTICS,
+          StringUtils.valueOf(enableTimeStatistics, StringUtils.EMPTY_STRING));
-      gemfireProperties.setProperty(LOCATORS, StringUtils.valueOf(locators, StringUtils.EMPTY_STRING));
-      gemfireProperties.setProperty(LOCATOR_WAIT_TIME, StringUtils.valueOf(locatorWaitTime, StringUtils.EMPTY_STRING));
-      gemfireProperties.setProperty(LOG_LEVEL, StringUtils.valueOf(logLevel, StringUtils.EMPTY_STRING));
-      gemfireProperties.setProperty(MCAST_ADDRESS, StringUtils.valueOf(mcastBindAddress, StringUtils.EMPTY_STRING));
-      gemfireProperties.setProperty(MCAST_PORT, StringUtils.valueOf(mcastPort, StringUtils.EMPTY_STRING));
-      gemfireProperties.setProperty(MEMCACHED_PORT, StringUtils.valueOf(memcachedPort, StringUtils.EMPTY_STRING));
-      gemfireProperties.setProperty(MEMCACHED_PROTOCOL, StringUtils.valueOf(memcachedProtocol, StringUtils.EMPTY_STRING));
-      gemfireProperties.setProperty(MEMCACHED_BIND_ADDRESS, StringUtils.valueOf(memcachedBindAddress, StringUtils.EMPTY_STRING));
-      gemfireProperties.setProperty(REDIS_PORT, StringUtils.valueOf(redisPort, StringUtils.EMPTY_STRING));
-      gemfireProperties.setProperty(REDIS_BIND_ADDRESS, StringUtils.valueOf(redisBindAddress, StringUtils.EMPTY_STRING));
-      gemfireProperties.setProperty(REDIS_PASSWORD, StringUtils.valueOf(redisPassword, StringUtils.EMPTY_STRING));
-      gemfireProperties.setProperty(STATISTIC_ARCHIVE_FILE, StringUtils.valueOf(statisticsArchivePathname, StringUtils.EMPTY_STRING));
-      gemfireProperties.setProperty(USE_CLUSTER_CONFIGURATION, StringUtils.valueOf(requestSharedConfiguration, Boolean.TRUE.toString()));
-      gemfireProperties.setProperty(LOCK_MEMORY, StringUtils.valueOf(lockMemory, StringUtils.EMPTY_STRING));
-      gemfireProperties.setProperty(OFF_HEAP_MEMORY_SIZE, StringUtils.valueOf(offHeapMemorySize, StringUtils.EMPTY_STRING));
-      gemfireProperties.setProperty(START_DEV_REST_API, StringUtils.valueOf(startRestApi, StringUtils.EMPTY_STRING));
-      gemfireProperties.setProperty(HTTP_SERVICE_PORT,  StringUtils.valueOf(httpServicePort, StringUtils.EMPTY_STRING));
-      gemfireProperties.setProperty(HTTP_SERVICE_BIND_ADDRESS,  StringUtils.valueOf(httpServiceBindAddress, StringUtils.EMPTY_STRING));
-      // if username is specified in the command line, it will overwrite what's set in the properties file
-      if(!StringUtils.isBlank(userName)){
+      gemfireProperties.setProperty(LOCATORS,
+          StringUtils.valueOf(locators, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(LOCATOR_WAIT_TIME,
+          StringUtils.valueOf(locatorWaitTime, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(LOG_LEVEL,
+          StringUtils.valueOf(logLevel, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(MCAST_ADDRESS,
+          StringUtils.valueOf(mcastBindAddress, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(MCAST_PORT,
+          StringUtils.valueOf(mcastPort, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(MEMCACHED_PORT,
+          StringUtils.valueOf(memcachedPort, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(MEMCACHED_PROTOCOL,
+          StringUtils.valueOf(memcachedProtocol, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(MEMCACHED_BIND_ADDRESS,
+          StringUtils.valueOf(memcachedBindAddress, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(REDIS_PORT,
+          StringUtils.valueOf(redisPort, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(REDIS_BIND_ADDRESS,
+          StringUtils.valueOf(redisBindAddress, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(REDIS_PASSWORD,
+          StringUtils.valueOf(redisPassword, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(STATISTIC_ARCHIVE_FILE,
+          StringUtils.valueOf(statisticsArchivePathname, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(USE_CLUSTER_CONFIGURATION,
+          StringUtils.valueOf(requestSharedConfiguration, Boolean.TRUE.toString()));
+      gemfireProperties.setProperty(LOCK_MEMORY,
+          StringUtils.valueOf(lockMemory, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(OFF_HEAP_MEMORY_SIZE,
+          StringUtils.valueOf(offHeapMemorySize, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(START_DEV_REST_API,
+          StringUtils.valueOf(startRestApi, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(HTTP_SERVICE_PORT,
+          StringUtils.valueOf(httpServicePort, StringUtils.EMPTY_STRING));
+      gemfireProperties.setProperty(HTTP_SERVICE_BIND_ADDRESS,
+          StringUtils.valueOf(httpServiceBindAddress, StringUtils.EMPTY_STRING));
+      // if username is specified in the command line, it will overwrite what's set in the
+      // properties file
+      if (!StringUtils.isBlank(userName)) {
-      // read the OSProcess enable redirect system property here -- TODO: replace with new GFSH argument
-      final boolean redirectOutput = Boolean.getBoolean(OSProcess.ENABLE_OUTPUT_REDIRECTION_PROPERTY);
+      // read the OSProcess enable redirect system property here -- TODO: replace with new GFSH
+      // argument
+      final boolean redirectOutput =
+          Boolean.getBoolean(OSProcess.ENABLE_OUTPUT_REDIRECTION_PROPERTY);
-      ServerLauncher serverLauncher = new ServerLauncher.Builder()
-          .setAssignBuckets(assignBuckets)
-          .setDisableDefaultServer(disableDefaultServer)
-          .setForce(force)
-          .setMemberName(memberName)
-          .setRebalance(rebalance)
-          .setRedirectOutput(redirectOutput)
-          .setServerBindAddress(serverBindAddress)
-          .setServerPort(serverPort)
-          .setSpringXmlLocation(springXmlLocation)
-          .setWorkingDirectory(workingDirectory)
+      ServerLauncher serverLauncher = new ServerLauncher.Builder().setAssignBuckets(assignBuckets)
+          .setDisableDefaultServer(disableDefaultServer).setForce(force).setMemberName(memberName)
+          .setRebalance(rebalance).setRedirectOutput(redirectOutput)
+          .setServerBindAddress(serverBindAddress).setServerPort(serverPort)
+          .setSpringXmlLocation(springXmlLocation).setWorkingDirectory(workingDirectory)
-          .setEvictionOffHeapPercentage(evictionOffHeapPercentage)
-          .setMaxConnections(maxConnections)
-          .setMaxMessageCount(maxMessageCount)
-          .setMaxThreads(maxThreads)
-          .setMessageTimeToLive(messageTimeToLive)
-          .setSocketBufferSize(socketBufferSize)
-          .setHostNameForClients(hostNameForClients)
-          .build();
+          .setEvictionOffHeapPercentage(evictionOffHeapPercentage).setMaxConnections(maxConnections)
+          .setMaxMessageCount(maxMessageCount).setMaxThreads(maxThreads)
+          .setMessageTimeToLive(messageTimeToLive).setSocketBufferSize(socketBufferSize)
+          .setHostNameForClients(hostNameForClients).build();
-      String[] serverCommandLine = createStartServerCommandLine(serverLauncher, gemfirePropertiesPathname,
-          gemfireSecurityPropertiesPathname, gemfireProperties, classpath, includeSystemClasspath, jvmArgsOpts,
-          disableExitWhenOutOfMemory, initialHeap, maxHeap);
+      String[] serverCommandLine = createStartServerCommandLine(serverLauncher,
+          gemfirePropertiesPathname, gemfireSecurityPropertiesPathname, gemfireProperties,
+          classpath, includeSystemClasspath, jvmArgsOpts, disableExitWhenOutOfMemory, initialHeap,
+          maxHeap);
-          .directory(new File(serverLauncher.getWorkingDirectory()))
-          .start();
+          .directory(new File(serverLauncher.getWorkingDirectory())).start();
-      final ReadingMode readingMode = SystemUtils.isWindows() ? ReadingMode.NON_BLOCKING : ReadingMode.BLOCKING;
+      final ReadingMode readingMode =
+          SystemUtils.isWindows() ? ReadingMode.NON_BLOCKING : ReadingMode.BLOCKING;
-          .inputStream(serverProcess.getErrorStream())
-          .inputListener(inputListener)
-          .readingMode(readingMode)
-          .continueReadingMillis(2 * 1000)
-          .build()
-          .start();
+          .inputStream(serverProcess.getErrorStream()).inputListener(inputListener)
+          .readingMode(readingMode).continueReadingMillis(2 * 1000).build().start();
-      final boolean registeredServerSignalListener = getGfsh().getSignalHandler().registerListener(serverSignalListener);
+      final boolean registeredServerSignalListener =
+          getGfsh().getSignalHandler().registerListener(serverSignalListener);
-            IOUtils.tryGetCanonicalPathElseGetAbsolutePath(new File(serverLauncher.getWorkingDirectory()))), null);
+            IOUtils.tryGetCanonicalPathElseGetAbsolutePath(
+                new File(serverLauncher.getWorkingDirectory()))),
+            null);
-            //Gfsh.println(message);
+            // Gfsh.println(message);
-            return ResultBuilder.createShellClientErrorResult(String.format(
-                CliStrings.START_SERVER__PROCESS_TERMINATED_ABNORMALLY_ERROR_MESSAGE,
-                exitValue, serverLauncher.getWorkingDirectory(), message.toString()));
+            return ResultBuilder.createShellClientErrorResult(
+                String.format(CliStrings.START_SERVER__PROCESS_TERMINATED_ABNORMALLY_ERROR_MESSAGE,
+                    exitValue, serverLauncher.getWorkingDirectory(), message.toString()));
-            // the IllegalThreadStateException is expected; it means the Server's process has not terminated,
+            // the IllegalThreadStateException is expected; it means the Server's process has not
+            // terminated,
-            serverState = (ProcessUtils.isAttachApiAvailable() ? serverStatus(serverPidFile, oldPid, memberName)
+            serverState = (ProcessUtils.isAttachApiAvailable()
+                ? serverStatus(serverPidFile, oldPid, memberName)
-                || currentServerStatusMessage.equalsIgnoreCase(previousServerStatusMessage))) {
+                    || currentServerStatusMessage.equalsIgnoreCase(previousServerStatusMessage))) {
-        }
-        while (!(registeredServerSignalListener && serverSignalListener.isSignaled())
+        } while (!(registeredServerSignalListener && serverSignalListener.isSignaled())
-        stderrReader.stopAsync(PROCESS_STREAM_READER_ASYNC_STOP_TIMEOUT_MILLIS); // stop will close ErrorStream
+        stderrReader.stopAsync(PROCESS_STREAM_READER_ASYNC_STOP_TIMEOUT_MILLIS); // stop will close
+                                                                                 // ErrorStream
-      if (message != null && message.matches(LocalizedStrings.Launcher_Builder_UNKNOWN_HOST_ERROR_MESSAGE.toLocalizedString(".+"))) {
-        message = CliStrings.format(CliStrings.LAUNCHERLIFECYCLECOMMANDS__MSG__FAILED_TO_START_0_REASON_1, SERVER_TERM_NAME, message);
+      if (message != null && message.matches(
+          LocalizedStrings.Launcher_Builder_UNKNOWN_HOST_ERROR_MESSAGE.toLocalizedString(".+"))) {
+        message =
+            CliStrings.format(CliStrings.LAUNCHERLIFECYCLECOMMANDS__MSG__FAILED_TO_START_0_REASON_1,
+                SERVER_TERM_NAME, message);
-      return ResultBuilder.createShellClientErrorResult(String.format(CliStrings.START_SERVER__GENERAL_ERROR_MESSAGE,
-          toString(t, getGfsh().getDebug())));
+      return ResultBuilder.createShellClientErrorResult(String.format(
+          CliStrings.START_SERVER__GENERAL_ERROR_MESSAGE, toString(t, getGfsh().getDebug())));
-      final String gemfirePropertiesPathname,
-      final String gemfireSecurityPropertiesPathname,
-      final Properties gemfireProperties,
-      final String userClasspath,
-      final Boolean includeSystemClasspath,
-      final String[] jvmArgsOpts,
-      final Boolean disableExitWhenOutOfMemory,
-      final String initialHeap,
-      final String maxHeap)
+      final String gemfirePropertiesPathname, final String gemfireSecurityPropertiesPathname,
+      final Properties gemfireProperties, final String userClasspath,
+      final Boolean includeSystemClasspath, final String[] jvmArgsOpts,
+      final Boolean disableExitWhenOutOfMemory, final String initialHeap, final String maxHeap)
-    commandLine.add(getServerClasspath(Boolean.TRUE.equals(includeSystemClasspath),
-        userClasspath));
+    commandLine.add(getServerClasspath(Boolean.TRUE.equals(includeSystemClasspath), userClasspath));
-    // NOTE asserting not equal to true rather than equal to false handles the null case and ensures the user
+    // NOTE asserting not equal to true rather than equal to false handles the null case and ensures
+    // the user
-    commandLine.add("-D".concat(AbstractLauncher.SIGNAL_HANDLER_REGISTRATION_SYSTEM_PROPERTY.concat("=true")));
+    commandLine.add(
+        "-D".concat(AbstractLauncher.SIGNAL_HANDLER_REGISTRATION_SYSTEM_PROPERTY.concat("=true")));
-    commandLine.add("-Dsun.rmi.dgc.server.gcInterval".concat("=").concat(Long.toString(Long.MAX_VALUE - 1)));
+    commandLine.add(
+        "-Dsun.rmi.dgc.server.gcInterval".concat("=").concat(Long.toString(Long.MAX_VALUE - 1)));
-      commandLine.add("--server-bind-address=" + launcher.getServerBindAddress().getCanonicalHostName());
+      commandLine
+          .add("--server-bind-address=" + launcher.getServerBindAddress().getCanonicalHostName());
-      commandLine.add("--" + CliStrings.START_SERVER__CRITICAL__HEAP__PERCENTAGE + "=" + launcher.getCriticalHeapPercentage());
+      commandLine.add("--" + CliStrings.START_SERVER__CRITICAL__HEAP__PERCENTAGE + "="
+          + launcher.getCriticalHeapPercentage());
-      commandLine.add("--" + CliStrings.START_SERVER__EVICTION__HEAP__PERCENTAGE + "=" + launcher.getEvictionHeapPercentage());
+      commandLine.add("--" + CliStrings.START_SERVER__EVICTION__HEAP__PERCENTAGE + "="
+          + launcher.getEvictionHeapPercentage());
-      commandLine.add("--" + CliStrings.START_SERVER__CRITICAL_OFF_HEAP_PERCENTAGE + "=" + launcher.getCriticalOffHeapPercentage());
+      commandLine.add("--" + CliStrings.START_SERVER__CRITICAL_OFF_HEAP_PERCENTAGE + "="
+          + launcher.getCriticalOffHeapPercentage());
-      commandLine.add("--" + CliStrings.START_SERVER__EVICTION_OFF_HEAP_PERCENTAGE + "=" + launcher.getEvictionOffHeapPercentage());
+      commandLine.add("--" + CliStrings.START_SERVER__EVICTION_OFF_HEAP_PERCENTAGE + "="
+          + launcher.getEvictionOffHeapPercentage());
-      commandLine.add("--" + CliStrings.START_SERVER__MAX__CONNECTIONS + "=" + launcher.getMaxConnections());
+      commandLine.add(
+          "--" + CliStrings.START_SERVER__MAX__CONNECTIONS + "=" + launcher.getMaxConnections());
-      commandLine.add("--" + CliStrings.START_SERVER__MAX__MESSAGE__COUNT + "=" + launcher.getMaxMessageCount());
+      commandLine.add("--" + CliStrings.START_SERVER__MAX__MESSAGE__COUNT + "="
+          + launcher.getMaxMessageCount());
-      commandLine.add("--" + CliStrings.START_SERVER__MAX__THREADS + "=" + launcher.getMaxThreads());
+      commandLine
+          .add("--" + CliStrings.START_SERVER__MAX__THREADS + "=" + launcher.getMaxThreads());
-      commandLine.add("--" + CliStrings.START_SERVER__MESSAGE__TIME__TO__LIVE + "=" + launcher.getMessageTimeToLive());
+      commandLine.add("--" + CliStrings.START_SERVER__MESSAGE__TIME__TO__LIVE + "="
+          + launcher.getMessageTimeToLive());
-      commandLine.add("--" + CliStrings.START_SERVER__SOCKET__BUFFER__SIZE + "=" + launcher.getSocketBufferSize());
+      commandLine.add("--" + CliStrings.START_SERVER__SOCKET__BUFFER__SIZE + "="
+          + launcher.getSocketBufferSize());
-      commandLine.add("--" + CliStrings.START_SERVER__HOSTNAME__FOR__CLIENTS + "=" + launcher.getHostNameForClients());
+      commandLine.add("--" + CliStrings.START_SERVER__HOSTNAME__FOR__CLIENTS + "="
+          + launcher.getHostNameForClients());
-  @CliMetaData(shellOnly = true, relatedTopic = { CliStrings.TOPIC_GEODE_SERVER, CliStrings.TOPIC_GEODE_LIFECYCLE })
-  public Result statusServer(@CliOption(key = CliStrings.STATUS_SERVER__MEMBER,
-      optionContext = ConverterHint.MEMBERIDNAME,
-      unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-      help = CliStrings.STATUS_SERVER__MEMBER__HELP)
-  final String member,
+  @CliMetaData(shellOnly = true,
+      relatedTopic = {CliStrings.TOPIC_GEODE_SERVER, CliStrings.TOPIC_GEODE_LIFECYCLE})
+  public Result statusServer(
+      @CliOption(key = CliStrings.STATUS_SERVER__MEMBER, optionContext = ConverterHint.MEMBERIDNAME,
+          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
+          help = CliStrings.STATUS_SERVER__MEMBER__HELP) final String member,
-          help = CliStrings.STATUS_SERVER__PID__HELP)
-      final Integer pid,
-      @CliOption(key = CliStrings.STATUS_SERVER__DIR,
-          optionContext = ConverterHint.DIR_PATHSTRING,
+          help = CliStrings.STATUS_SERVER__PID__HELP) final Integer pid,
+      @CliOption(key = CliStrings.STATUS_SERVER__DIR, optionContext = ConverterHint.DIR_PATHSTRING,
-          help = CliStrings.STATUS_SERVER__DIR__HELP)
-      final String workingDirectory) {
+          help = CliStrings.STATUS_SERVER__DIR__HELP) final String workingDirectory) {
-            return ResultBuilder.createInfoResult(ServerState.fromJson(serverProxy.status()).toString());
+            return ResultBuilder
+                .createInfoResult(ServerState.fromJson(serverProxy.status()).toString());
-          return ResultBuilder.createUserErrorResult(CliStrings.format(
-              CliStrings.STATUS_SERVICE__GFSH_NOT_CONNECTED_ERROR_MESSAGE, "Cache Server"));
+          return ResultBuilder.createUserErrorResult(CliStrings
+              .format(CliStrings.STATUS_SERVICE__GFSH_NOT_CONNECTED_ERROR_MESSAGE, "Cache Server"));
-            .setCommand(ServerLauncher.Command.STATUS)
-            .setDebug(isDebugging())
-            // NOTE since we do not know whether the "CacheServer" was enabled or not on the GemFire server when it was started,
-            // set the disableDefaultServer property in the ServerLauncher.Builder to default status to the MemberMBean
+            .setCommand(ServerLauncher.Command.STATUS).setDebug(isDebugging())
+            // NOTE since we do not know whether the "CacheServer" was enabled or not on the GemFire
+            // server when it was started,
+            // set the disableDefaultServer property in the ServerLauncher.Builder to default status
+            // to the MemberMBean
-            .setDisableDefaultServer(true)
-            .setMemberName(member)
-            .setPid(pid)
-            .setWorkingDirectory(workingDirectory)
-            .build();
+            .setDisableDefaultServer(true).setMemberName(member).setPid(pid)
+            .setWorkingDirectory(workingDirectory).build();
-      return ResultBuilder.createShellClientErrorResult(String.format(CliStrings.STATUS_SERVER__GENERAL_ERROR_MESSAGE,
-          toString(t, getGfsh().getDebug())));
+      return ResultBuilder.createShellClientErrorResult(String.format(
+          CliStrings.STATUS_SERVER__GENERAL_ERROR_MESSAGE, toString(t, getGfsh().getDebug())));
-  @CliMetaData(shellOnly = true, relatedTopic = { CliStrings.TOPIC_GEODE_SERVER, CliStrings.TOPIC_GEODE_LIFECYCLE })
-  public Result stopServer(@CliOption(key = CliStrings.STOP_SERVER__MEMBER,
-      optionContext = ConverterHint.MEMBERIDNAME,
-      unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-      help = CliStrings.STOP_SERVER__MEMBER__HELP)
-  final String member,
+  @CliMetaData(shellOnly = true,
+      relatedTopic = {CliStrings.TOPIC_GEODE_SERVER, CliStrings.TOPIC_GEODE_LIFECYCLE})
+  public Result stopServer(
+      @CliOption(key = CliStrings.STOP_SERVER__MEMBER, optionContext = ConverterHint.MEMBERIDNAME,
+          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
+          help = CliStrings.STOP_SERVER__MEMBER__HELP) final String member,
-          help = CliStrings.STOP_SERVER__PID__HELP)
-      final Integer pid,
-      @CliOption(key = CliStrings.STOP_SERVER__DIR,
-          optionContext = ConverterHint.DIR_PATHSTRING,
+          help = CliStrings.STOP_SERVER__PID__HELP) final Integer pid,
+      @CliOption(key = CliStrings.STOP_SERVER__DIR, optionContext = ConverterHint.DIR_PATHSTRING,
-          help = CliStrings.STOP_SERVER__DIR__HELP)
-      final String workingDirectory) {
+          help = CliStrings.STOP_SERVER__DIR__HELP) final String workingDirectory) {
-              throw new IllegalStateException(CliStrings.format(CliStrings.STOP_SERVER__MEMBER_IS_NOT_SERVER_ERROR_MESSAGE, member));
+              throw new IllegalStateException(CliStrings
+                  .format(CliStrings.STOP_SERVER__MEMBER_IS_NOT_SERVER_ERROR_MESSAGE, member));
-            return ResultBuilder.createUserErrorResult(CliStrings.format(
-                CliStrings.STOP_SERVER__NO_SERVER_FOUND_FOR_MEMBER_ERROR_MESSAGE, member));
+            return ResultBuilder.createUserErrorResult(CliStrings
+                .format(CliStrings.STOP_SERVER__NO_SERVER_FOUND_FOR_MEMBER_ERROR_MESSAGE, member));
-          return ResultBuilder.createUserErrorResult(CliStrings.format(
-              CliStrings.STOP_SERVICE__GFSH_NOT_CONNECTED_ERROR_MESSAGE, "Cache Server"));
+          return ResultBuilder.createUserErrorResult(CliStrings
+              .format(CliStrings.STOP_SERVICE__GFSH_NOT_CONNECTED_ERROR_MESSAGE, "Cache Server"));
-            .setCommand(ServerLauncher.Command.STOP)
-            .setDebug(isDebugging())
-            .setMemberName(member)
-            .setPid(pid)
-            .setWorkingDirectory(workingDirectory)
-            .build();
+            .setCommand(ServerLauncher.Command.STOP).setDebug(isDebugging()).setMemberName(member)
+            .setPid(pid).setWorkingDirectory(workingDirectory).build();
-        getGfsh().logInfo(String.format(CliStrings.STOP_SERVER__STOPPING_SERVER_MESSAGE,
-            serverState.getWorkingDirectory(), serverState.getServiceLocation(), serverState.getMemberName(),
-            serverState.getPid(), serverState.getLogFile()), null);
+        getGfsh().logInfo(
+            String.format(CliStrings.STOP_SERVER__STOPPING_SERVER_MESSAGE,
+                serverState.getWorkingDirectory(), serverState.getServiceLocation(),
+                serverState.getMemberName(), serverState.getPid(), serverState.getLogFile()),
+            null);
-      return ResultBuilder.createShellClientErrorResult(String.format(CliStrings.STOP_SERVER__GENERAL_ERROR_MESSAGE,
-          toString(t, getGfsh().getDebug())));
+      return ResultBuilder.createShellClientErrorResult(String.format(
+          CliStrings.STOP_SERVER__GENERAL_ERROR_MESSAGE, toString(t, getGfsh().getDebug())));
-  //@CliCommand(value=CliStrings.START_MANAGER, help=CliStrings.START_MANAGER__HELP)
-  //@CliMetaData(shellOnly=true, relatedTopic = {CliStrings.TOPIC_GEODE_MANAGER, CliStrings.TOPIC_GEODE_JMX, CliStrings.TOPIC_GEODE_LIFECYCLE})
-  public Result startManager(@CliOption(key = CliStrings.START_MANAGER__MEMBERNAME,
-      unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-      help = CliStrings.START_MANAGER__MEMBERNAME__HELP)
-      String memberName,
+  // @CliCommand(value=CliStrings.START_MANAGER, help=CliStrings.START_MANAGER__HELP)
+  // @CliMetaData(shellOnly=true, relatedTopic = {CliStrings.TOPIC_GEODE_MANAGER,
+  // CliStrings.TOPIC_GEODE_JMX, CliStrings.TOPIC_GEODE_LIFECYCLE})
+  public Result startManager(
+      @CliOption(key = CliStrings.START_MANAGER__MEMBERNAME,
+          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
+          help = CliStrings.START_MANAGER__MEMBERNAME__HELP) String memberName,
-          help = CliStrings.START_MANAGER__DIR__HELP)
-          String dir,
-      @CliOption(key = CliStrings.START_MANAGER__PORT,
-          unspecifiedDefaultValue = "1099",
-          help = CliStrings.START_MANAGER__PORT__HELP)
-          int cacheServerPort,
+          help = CliStrings.START_MANAGER__DIR__HELP) String dir,
+      @CliOption(key = CliStrings.START_MANAGER__PORT, unspecifiedDefaultValue = "1099",
+          help = CliStrings.START_MANAGER__PORT__HELP) int cacheServerPort,
-          help = CliStrings.START_MANAGER__BIND_ADDRESS__HELP)
-          String cacheServerHost,
+          help = CliStrings.START_MANAGER__BIND_ADDRESS__HELP) String cacheServerHost,
-          help = CliStrings.START_MANAGER__CLASSPATH__HELP)
-          String classpath,
+          help = CliStrings.START_MANAGER__CLASSPATH__HELP) String classpath,
-          help = CliStrings.START_MANAGER__MAXHEAP__HELP)
-          String maxHeap,
+          help = CliStrings.START_MANAGER__MAXHEAP__HELP) String maxHeap,
-          help = CliStrings.START_MANAGER__INITIALHEAP__HELP)
-          String initialHeap,
+          help = CliStrings.START_MANAGER__INITIALHEAP__HELP) String initialHeap,
-          help = CliStrings.START_MANAGER__J__HELP)
-          Map<String, String> systepProps,
+          help = CliStrings.START_MANAGER__J__HELP) Map<String, String> systepProps,
-          help = CliStrings.START_MANAGER__GEODEPROPS__HELP)
-          Map<String, String> gemfireProps) {
+          help = CliStrings.START_MANAGER__GEODEPROPS__HELP) Map<String, String> gemfireProps) {
-  @CliMetaData(shellOnly = true, relatedTopic = { CliStrings.TOPIC_GEODE_MANAGER, CliStrings.TOPIC_GEODE_JMX, CliStrings.TOPIC_GEODE_M_AND_M })
-  public Result startJConsole(@CliOption(key = CliStrings.START_JCONSOLE__INTERVAL,
-      unspecifiedDefaultValue = "4",
-      help = CliStrings.START_JCONSOLE__INTERVAL__HELP)
-  final int interval,
-      @CliOption(key = CliStrings.START_JCONSOLE__NOTILE,
-          specifiedDefaultValue = "true",
+  @CliMetaData(shellOnly = true, relatedTopic = {CliStrings.TOPIC_GEODE_MANAGER,
+      CliStrings.TOPIC_GEODE_JMX, CliStrings.TOPIC_GEODE_M_AND_M})
+  public Result startJConsole(
+      @CliOption(key = CliStrings.START_JCONSOLE__INTERVAL, unspecifiedDefaultValue = "4",
+          help = CliStrings.START_JCONSOLE__INTERVAL__HELP) final int interval,
+      @CliOption(key = CliStrings.START_JCONSOLE__NOTILE, specifiedDefaultValue = "true",
-          help = CliStrings.START_JCONSOLE__NOTILE__HELP)
-      final boolean notile,
+          help = CliStrings.START_JCONSOLE__NOTILE__HELP) final boolean notile,
-          help = CliStrings.START_JCONSOLE__PLUGINPATH__HELP)
-      final String pluginpath,
-      @CliOption(key = CliStrings.START_JCONSOLE__VERSION,
-          specifiedDefaultValue = "true",
+          help = CliStrings.START_JCONSOLE__PLUGINPATH__HELP) final String pluginpath,
+      @CliOption(key = CliStrings.START_JCONSOLE__VERSION, specifiedDefaultValue = "true",
-          help = CliStrings.START_JCONSOLE__VERSION__HELP)
-      final boolean version,
-      @CliOption(key = CliStrings.START_JCONSOLE__J,
-          optionContext = ConverterHint.STRING_LIST,
+          help = CliStrings.START_JCONSOLE__VERSION__HELP) final boolean version,
+      @CliOption(key = CliStrings.START_JCONSOLE__J, optionContext = ConverterHint.STRING_LIST,
-          help = CliStrings.START_JCONSOLE__J__HELP)
-      @CliMetaData(valueSeparator = ",")
-      final List<String> jvmArgs) {
+          help = CliStrings.START_JCONSOLE__J__HELP) @CliMetaData(
+              valueSeparator = ",") final List<String> jvmArgs) {
-      String[] jconsoleCommandLine = createJConsoleCommandLine(null, interval, notile, pluginpath, version, jvmArgs);
+      String[] jconsoleCommandLine =
+          createJConsoleCommandLine(null, interval, notile, pluginpath, version, jvmArgs);
-        getGfsh().printAsInfo(String.format("JConsole command-line ($1%s)", Arrays.toString(jconsoleCommandLine)));
+        getGfsh().printAsInfo(
+            String.format("JConsole command-line ($1%s)", Arrays.toString(jconsoleCommandLine)));
-        BufferedReader reader = new BufferedReader(new InputStreamReader(jconsoleProcess.getErrorStream()));
+        BufferedReader reader =
+            new BufferedReader(new InputStreamReader(jconsoleProcess.getErrorStream()));
-      return ResultBuilder.createShellClientErrorResult(CliStrings.START_JCONSOLE__IO_EXCEPTION_MESSAGE);
+      return ResultBuilder
+          .createShellClientErrorResult(CliStrings.START_JCONSOLE__IO_EXCEPTION_MESSAGE);
-      return ResultBuilder.createShellClientErrorResult(String.format(CliStrings.START_JCONSOLE__CATCH_ALL_ERROR_MESSAGE,
-          toString(t, false)));
+      return ResultBuilder.createShellClientErrorResult(
+          String.format(CliStrings.START_JCONSOLE__CATCH_ALL_ERROR_MESSAGE, toString(t, false)));
-  protected String[] createJConsoleCommandLine(final String member,
-      final int interval,
-      final boolean notile,
-      final String pluginpath,
-      final boolean version,
+  protected String[] createJConsoleCommandLine(final String member, final int interval,
+      final boolean notile, final String pluginpath, final boolean version,
-  protected String getJdkToolPathname(final String jdkToolExecutableName, final GemFireException throwable) {
+  protected String getJdkToolPathname(final String jdkToolExecutableName,
+      final GemFireException throwable) {
-    pathnames.push(IOUtils.appendToPath(System.getenv("JAVA_HOME"), "..", "bin", jdkToolExecutableName));
+    pathnames
+        .push(IOUtils.appendToPath(System.getenv("JAVA_HOME"), "..", "bin", jdkToolExecutableName));
-  protected String getJdkToolPathname(final Stack<String> pathnames, final GemFireException throwable) {
+  protected String getJdkToolPathname(final Stack<String> pathnames,
+      final GemFireException throwable) {
-      // assume 'java.home' JVM System property refers to the JDK installation directory.  note, however, that the
+      // assume 'java.home' JVM System property refers to the JDK installation directory. note,
+      // however, that the
-        ConnectionEndpoint connectionEndpoint = converter.convertFromText(member, ConnectionEndpoint.class, null);
+        ConnectionEndpoint connectionEndpoint =
+            converter.convertFromText(member, ConnectionEndpoint.class, null);
-        return StringUtils.concat("service:jmx:rmi://", connectionEndpoint.getHost(), ":", connectionEndpoint.getPort(),
-            "/jndi/rmi://", connectionEndpoint.getHost(), ":", connectionEndpoint.getPort(), "/jmxrmi");
+        return StringUtils.concat("service:jmx:rmi://", connectionEndpoint.getHost(), ":",
+            connectionEndpoint.getPort(), "/jndi/rmi://", connectionEndpoint.getHost(), ":",
+            connectionEndpoint.getPort(), "/jmxrmi");
-        throw new IllegalArgumentException(CliStrings.START_JCONSOLE__CONNECT_BY_MEMBER_NAME_ID_ERROR_MESSAGE);
+        throw new IllegalArgumentException(
+            CliStrings.START_JCONSOLE__CONNECT_BY_MEMBER_NAME_ID_ERROR_MESSAGE);
-      if (isConnectedAndReady() && (getGfsh().getOperationInvoker() instanceof JmxOperationInvoker)) {
-        JmxOperationInvoker jmxOperationInvoker = (JmxOperationInvoker) getGfsh().getOperationInvoker();
+      if (isConnectedAndReady()
+          && (getGfsh().getOperationInvoker() instanceof JmxOperationInvoker)) {
+        JmxOperationInvoker jmxOperationInvoker =
+            (JmxOperationInvoker) getGfsh().getOperationInvoker();
-  @CliMetaData(shellOnly = true, relatedTopic = { CliStrings.TOPIC_GEODE_MANAGER, CliStrings.TOPIC_GEODE_JMX, CliStrings.TOPIC_GEODE_M_AND_M })
-  public Result startJVisualVM(@CliOption(key = CliStrings.START_JCONSOLE__J,
-      optionContext = ConverterHint.STRING_LIST,
-      unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-      help = CliStrings.START_JCONSOLE__J__HELP)
-  @CliMetaData(valueSeparator = ",")
-  final List<String> jvmArgs) {
+  @CliMetaData(shellOnly = true, relatedTopic = {CliStrings.TOPIC_GEODE_MANAGER,
+      CliStrings.TOPIC_GEODE_JMX, CliStrings.TOPIC_GEODE_M_AND_M})
+  public Result startJVisualVM(
+      @CliOption(key = CliStrings.START_JCONSOLE__J, optionContext = ConverterHint.STRING_LIST,
+          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
+          help = CliStrings.START_JCONSOLE__J__HELP) @CliMetaData(
+              valueSeparator = ",") final List<String> jvmArgs) {
-        getGfsh().printAsInfo(String.format("JVisualVM command-line (%1$s)", Arrays.toString(jvisualvmCommandLine)));
+        getGfsh().printAsInfo(
+            String.format("JVisualVM command-line (%1$s)", Arrays.toString(jvisualvmCommandLine)));
-      return ResultBuilder.createShellClientErrorResult(String.format(CliStrings.START_JVISUALVM__ERROR_MESSAGE,
-          toString(t, false)));
+      return ResultBuilder.createShellClientErrorResult(
+          String.format(CliStrings.START_JVISUALVM__ERROR_MESSAGE, toString(t, false)));
-        return IOUtils.verifyPathnameExists("/System/Library/Java/Support/VisualVM.bundle/Contents/Home/bin/jvisualvm");
+        return IOUtils.verifyPathnameExists(
+            "/System/Library/Java/Support/VisualVM.bundle/Contents/Home/bin/jvisualvm");
-          throw new VisualVmNotFoundException(CliStrings.START_JVISUALVM__EXPECTED_JDK_VERSION_ERROR_MESSAGE);
+          throw new VisualVmNotFoundException(
+              CliStrings.START_JVISUALVM__EXPECTED_JDK_VERSION_ERROR_MESSAGE);
-  @CliMetaData(shellOnly = true, relatedTopic = { CliStrings.TOPIC_GEODE_MANAGER, CliStrings.TOPIC_GEODE_JMX, CliStrings.TOPIC_GEODE_M_AND_M })
+  @CliMetaData(shellOnly = true, relatedTopic = {CliStrings.TOPIC_GEODE_MANAGER,
+      CliStrings.TOPIC_GEODE_JMX, CliStrings.TOPIC_GEODE_M_AND_M})
-      help = CliStrings.START_PULSE__URL__HELP)
-  final String url) {
+      help = CliStrings.START_PULSE__URL__HELP) final String url) {
-          String pulseURL = (String) operationInvoker.getAttribute(managerObjectName.toString(), "PulseURL");
+          String pulseURL =
+              (String) operationInvoker.getAttribute(managerObjectName.toString(), "PulseURL");
-            return ResultBuilder.createInfoResult(CliStrings.START_PULSE__RUN + " with URL: " + pulseURL);
+            return ResultBuilder
+                .createInfoResult(CliStrings.START_PULSE__RUN + " with URL: " + pulseURL);
-            String pulseMessage = (String) operationInvoker.getAttribute(managerObjectName.toString(), "StatusMessage");
-            return (!StringUtils.isBlank(pulseMessage) ? ResultBuilder.createGemFireErrorResult(pulseMessage)
+            String pulseMessage = (String) operationInvoker
+                .getAttribute(managerObjectName.toString(), "StatusMessage");
+            return (!StringUtils.isBlank(pulseMessage)
+                ? ResultBuilder.createGemFireErrorResult(pulseMessage)
-          return ResultBuilder.createUserErrorResult(CliStrings.format(CliStrings.GFSH_MUST_BE_CONNECTED_FOR_LAUNCHING_0,
-              "GemFire Pulse"));
+          return ResultBuilder.createUserErrorResult(CliStrings
+              .format(CliStrings.GFSH_MUST_BE_CONNECTED_FOR_LAUNCHING_0, "GemFire Pulse"));
-      return ResultBuilder.createShellClientErrorResult(String.format(CliStrings.START_PULSE__ERROR,
-          toString(t, false)));
+      return ResultBuilder.createShellClientErrorResult(
+          String.format(CliStrings.START_PULSE__ERROR, toString(t, false)));
-    assertState(Desktop.isDesktopSupported(), String.format(CliStrings.DESKSTOP_APP_RUN_ERROR_MESSAGE,
-        System.getProperty("os.name")));
+    assertState(Desktop.isDesktopSupported(),
+        String.format(CliStrings.DESKSTOP_APP_RUN_ERROR_MESSAGE, System.getProperty("os.name")));
-    String resourceName = classpathResourceLocation.substring(classpathResourceLocation.lastIndexOf(File.separator) + 1);
+    String resourceName = classpathResourceLocation
+        .substring(classpathResourceLocation.lastIndexOf(File.separator) + 1);
-        for (String line = resourceReader.readLine(); line != null; line = resourceReader.readLine()) {
+        for (String line = resourceReader.readLine(); line != null; line =
+            resourceReader.readLine()) {
-  @CliMetaData(shellOnly = true, relatedTopic = { CliStrings.TOPIC_GEODE_M_AND_M, CliStrings.TOPIC_GEODE_STATISTICS })
-  public Result startVsd(@CliOption(key = CliStrings.START_VSD__FILE, help = CliStrings.START_VSD__FILE__HELP)
-  final String[] statisticsArchiveFilePathnames) {
+  @CliMetaData(shellOnly = true,
+      relatedTopic = {CliStrings.TOPIC_GEODE_M_AND_M, CliStrings.TOPIC_GEODE_STATISTICS})
+  public Result startVsd(@CliOption(key = CliStrings.START_VSD__FILE,
+      help = CliStrings.START_VSD__FILE__HELP) final String[] statisticsArchiveFilePathnames) {
-      assertState(IOUtils.isExistingPathname(getPathToVsd()), String.format(CliStrings.START_VSD__NOT_FOUND_ERROR_MESSAGE,
-          gemfireHome));
+      assertState(IOUtils.isExistingPathname(getPathToVsd()),
+          String.format(CliStrings.START_VSD__NOT_FOUND_ERROR_MESSAGE, gemfireHome));
-        getGfsh().printAsInfo(String.format("GemFire VSD command-line (%1$s)", Arrays.toString(vsdCommandLine)));
+        getGfsh().printAsInfo(
+            String.format("GemFire VSD command-line (%1$s)", Arrays.toString(vsdCommandLine)));
-      return ResultBuilder.createShellClientErrorResult(String.format(CliStrings.START_VSD__ERROR_MESSAGE,
-          toString(t, false)));
+      return ResultBuilder.createShellClientErrorResult(
+          String.format(CliStrings.START_VSD__ERROR_MESSAGE, toString(t, false)));
-  protected String[] createdVsdCommandLine(final String[] statisticsArchiveFilePathnames) throws FileNotFoundException {
+  protected String[] createdVsdCommandLine(final String[] statisticsArchiveFilePathnames)
+      throws FileNotFoundException {
-    String vsdPathname = IOUtils.appendToPath(System.getenv("GEMFIRE"), "tools", "vsd", "bin", "vsd");
+    String vsdPathname =
+        IOUtils.appendToPath(System.getenv("GEMFIRE"), "tools", "vsd", "bin", "vsd");
-  protected Set<String> processStatisticsArchiveFiles(final String[] statisticsArchiveFilePathnames) throws FileNotFoundException {
+  protected Set<String> processStatisticsArchiveFiles(final String[] statisticsArchiveFilePathnames)
+      throws FileNotFoundException {
-              throw new IllegalArgumentException("A Statistics Archive File must end with a .gfs file extension.");
+              throw new IllegalArgumentException(
+                  "A Statistics Archive File must end with a .gfs file extension.");
-  protected void processStatisticsArchiveFiles(final File path, final Set<String> statisticsArchiveFiles) {
+  protected void processStatisticsArchiveFiles(final File path,
+      final Set<String> statisticsArchiveFiles) {
-  //@CliCommand(value=CliStrings.START_DATABROWSER, help=CliStrings.START_DATABROWSER__HELP)
-  @CliMetaData(shellOnly = true, relatedTopic = { CliStrings.TOPIC_GEODE_M_AND_M })
+  // @CliCommand(value=CliStrings.START_DATABROWSER, help=CliStrings.START_DATABROWSER__HELP)
+  @CliMetaData(shellOnly = true, relatedTopic = {CliStrings.TOPIC_GEODE_M_AND_M})
-      if (isConnectedAndReady() && (getGfsh().getOperationInvoker() instanceof JmxOperationInvoker)) {
+      if (isConnectedAndReady()
+          && (getGfsh().getOperationInvoker() instanceof JmxOperationInvoker)) {
-        assertState(IOUtils.isExistingPathname(dataBrowserPath), String.format(
-            CliStrings.START_DATABROWSER__NOT_FOUND_ERROR_MESSAGE, gemfireHome));
+        assertState(IOUtils.isExistingPathname(dataBrowserPath),
+            String.format(CliStrings.START_DATABROWSER__NOT_FOUND_ERROR_MESSAGE, gemfireHome));
-        JmxOperationInvoker operationInvoker = (JmxOperationInvoker) getGfsh().getOperationInvoker();
+        JmxOperationInvoker operationInvoker =
+            (JmxOperationInvoker) getGfsh().getOperationInvoker();
-          getGfsh().printAsInfo(String.format("GemFire DataBrowser command-line (%1$s)", dataBrowserCommandLine));
+          getGfsh().printAsInfo(
+              String.format("GemFire DataBrowser command-line (%1$s)", dataBrowserCommandLine));
-        String dataBrowserProcessOutput = waitAndCaptureProcessStandardOutputStream(dataBrowserProcess);
+        String dataBrowserProcessOutput =
+            waitAndCaptureProcessStandardOutputStream(dataBrowserProcess);
-        return ResultBuilder.createUserErrorResult(CliStrings.format(CliStrings.GFSH_MUST_BE_CONNECTED_VIA_JMX_FOR_LAUNCHING_0,
-            "GemFire DataBrowser"));
+        return ResultBuilder.createUserErrorResult(CliStrings.format(
+            CliStrings.GFSH_MUST_BE_CONNECTED_VIA_JMX_FOR_LAUNCHING_0, "GemFire DataBrowser"));
-    String dataBrowserPathName = IOUtils.appendToPath(GEMFIRE_HOME, "tools", "DataBrowser", "bin", "databrowser");
+    String dataBrowserPathName =
+        IOUtils.appendToPath(GEMFIRE_HOME, "tools", "DataBrowser", "bin", "databrowser");
-    return waitAndCaptureProcessStandardOutputStream(process, DEFAULT_PROCESS_OUTPUT_WAIT_TIME_MILLISECONDS);
+    return waitAndCaptureProcessStandardOutputStream(process,
+        DEFAULT_PROCESS_OUTPUT_WAIT_TIME_MILLISECONDS);
-  protected String waitAndCaptureProcessStandardOutputStream(final Process process, final long waitTimeMilliseconds) {
+  protected String waitAndCaptureProcessStandardOutputStream(final Process process,
+      final long waitTimeMilliseconds) {
-    return waitAndCaptureProcessStandardErrorStream(process, DEFAULT_PROCESS_OUTPUT_WAIT_TIME_MILLISECONDS);
+    return waitAndCaptureProcessStandardErrorStream(process,
+        DEFAULT_PROCESS_OUTPUT_WAIT_TIME_MILLISECONDS);
-  protected String waitAndCaptureProcessStandardErrorStream(final Process process, final long waitTimeMilliseconds) {
+  protected String waitAndCaptureProcessStandardErrorStream(final Process process,
+      final long waitTimeMilliseconds) {
-  private String waitAndCaptureProcessStream(final Process process, final InputStream processInputStream, long waitTimeMilliseconds) {
+  private String waitAndCaptureProcessStream(final Process process,
+      final InputStream processInputStream, long waitTimeMilliseconds) {
-        .inputStream(processInputStream)
-        .inputListener(inputListener)
-        .build();
+        .inputStream(processInputStream).inputListener(inputListener).build();
-  @CliAvailabilityIndicator({ CliStrings.START_LOCATOR, CliStrings.STOP_LOCATOR, CliStrings.STATUS_LOCATOR,
-      CliStrings.START_SERVER, CliStrings.STOP_SERVER, CliStrings.STATUS_SERVER,
-      CliStrings.START_MANAGER, CliStrings.START_PULSE, CliStrings.START_VSD, CliStrings.START_DATABROWSER })
+  @CliAvailabilityIndicator({CliStrings.START_LOCATOR, CliStrings.STOP_LOCATOR,
+      CliStrings.STATUS_LOCATOR, CliStrings.START_SERVER, CliStrings.STOP_SERVER,
+      CliStrings.STATUS_SERVER, CliStrings.START_MANAGER, CliStrings.START_PULSE,
+      CliStrings.START_VSD, CliStrings.START_DATABROWSER})
-      //System.err.printf("Gfsh LauncherSignalListener Received Signal '%1$s' (%2$d)...%n",
-      //  event.getSignal().getName(), event.getSignal().getNumber());
+      // System.err.printf("Gfsh LauncherSignalListener Received Signal '%1$s' (%2$d)...%n",
+      // event.getSignal().getName(), event.getSignal().getNumber());
-  protected static class StatisticsArchiveFileAndDirectoryFilter extends StatisticsArchiveFileFilter {
+  protected static class StatisticsArchiveFileAndDirectoryFilter
+      extends StatisticsArchiveFileFilter {
-    protected static final StatisticsArchiveFileAndDirectoryFilter INSTANCE = new StatisticsArchiveFileAndDirectoryFilter();
+    protected static final StatisticsArchiveFileAndDirectoryFilter INSTANCE =
+        new StatisticsArchiveFileAndDirectoryFilter();

UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66
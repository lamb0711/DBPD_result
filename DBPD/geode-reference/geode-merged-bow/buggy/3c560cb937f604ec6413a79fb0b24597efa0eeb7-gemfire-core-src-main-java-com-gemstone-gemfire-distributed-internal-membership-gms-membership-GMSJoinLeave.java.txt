enabling multicast communications and fixing a locator auto-restart problem.
This disables the use of multicast for discovery and all tests that were
doing that have been changed to use locators.

+import static com.gemstone.gemfire.distributed.internal.DistributionManager.LOCATOR_DM_TYPE;
+import static com.gemstone.gemfire.internal.DataSerializableFixedID.INSTALL_VIEW_MESSAGE;
+import static com.gemstone.gemfire.internal.DataSerializableFixedID.JOIN_REQUEST;
+import static com.gemstone.gemfire.internal.DataSerializableFixedID.JOIN_RESPONSE;
+import static com.gemstone.gemfire.internal.DataSerializableFixedID.LEAVE_REQUEST_MESSAGE;
+import static com.gemstone.gemfire.internal.DataSerializableFixedID.REMOVE_MEMBER_MESSAGE;
+import static com.gemstone.gemfire.internal.DataSerializableFixedID.VIEW_ACK_MESSAGE;
+
-import com.gemstone.gemfire.distributed.internal.membership.gms.Services;
+import com.gemstone.gemfire.distributed.internal.membership.gms.Services;
-import com.gemstone.gemfire.internal.logging.LoggingThreadGroup;
-  private static final int JOIN_RETRY_SLEEP = Integer.getInteger("gemfire.join-retry-sleep", 3000);
+  private static final int JOIN_RETRY_SLEEP = Integer.getInteger("gemfire.join-retry-sleep", 1000);
-  private boolean isConnected;
+  /** have I connected to the distributed system? */
+  private boolean isJoined;
+  /** a synch object that guards view installation */
-  private ViewReplyProcessor viewResponses = new ViewReplyProcessor(false);
+  /** collects responses to new views */
+  private ViewReplyProcessor viewProcessor = new ViewReplyProcessor(false);
-  private ViewReplyProcessor prepareResponses = new ViewReplyProcessor(true);
+  /** collects responses to view preparation messages */
+  private ViewReplyProcessor prepareProcessor = new ViewReplyProcessor(true);
+  /** whether quorum checks can cause a forced-disconnect */
+  /** timeout in receiving view acknowledgement */
+  /** am I shutting down? */
+
+    if (this.localAddress.getVmKind() == LOCATOR_DM_TYPE
+        && Boolean.getBoolean("gemfire.first-member")) {
+      becomeCoordinator();
+      return true;
+    }
+
-    return this.isConnected;
+    return this.isJoined;
-    try {
-      services.getMessenger().send(req);
-    } catch (IOException e) {
-      throw new SystemConnectException("Exception caught while trying to join", e);
-    }
+
+    services.getMessenger().send(req);
+    
+  
-      try {
-        services.getMessenger().send(m);
-      } catch (IOException e) {
-        //ignore - the attempt has been logged and the member can't join
-      }
+      services.getMessenger().send(m);
-        try {
-          services.getMessenger().send(m);
-        } catch (IOException e2) {
-          logger.info("unable to send join response " + rejection + " to " + incomingRequest.getMemberID(), e2);
-        }
+        services.getMessenger().send(m);
-      logger.debug("JoinLeave: this member is becoming the membership coordinator with address {}", localAddress);
+      logger.info("This member is becoming the membership coordinator with address {}", localAddress);
-        isConnected = true;
+        isJoined = true;
-              Collections.EMPTY_LIST);
+              Collections.<InternalDistributedMember>emptyList());
-        sendView(newView);
+        sendView(newView, Collections.<InternalDistributedMember>emptyList());
-      try {
-        services.getMessenger().send(response);
-      } catch (IOException e) {
-        logger.info("unable to send join response to {}", mbr);
-      }
+      services.getMessenger().send(response);
-      try {
-        services.getMessenger().send(response);
-      } catch (IOException e) {
-        logger.info("unable to send remove message to {}", mbr);
-      }
+      services.getMessenger().send(response);
-  boolean prepareView(NetView view) {
-    return sendView(view, true, this.prepareResponses);
+  boolean prepareView(NetView view, Collection<InternalDistributedMember> newMembers) {
+    return sendView(view, newMembers, true, this.prepareProcessor);
-  void sendView(NetView view) {
-    sendView(view, false, this.viewResponses);
+  void sendView(NetView view, Collection<InternalDistributedMember> newMembers) {
+    sendView(view, newMembers, false, this.viewProcessor);
-  boolean sendView(NetView view, boolean preparing, ViewReplyProcessor rp) {
+  boolean sendView(NetView view, Collection<InternalDistributedMember> newMembers, boolean preparing, ViewReplyProcessor rp) {
+    recips.removeAll(newMembers); // new members get the view in a JoinResponseMessage
+    recips.remove(this.localAddress); // no need to send it to ourselves
+    installView(view);
+    if (recips.isEmpty()) {
+      return true;
+    }
-    logger.info("View Creator " + (preparing? "preparing" : "sending") + " new view " + view);
-    try {
-      services.getMessenger().send(msg);
-    }
-    catch (IOException e) {
-      logger.warn("Unsuccessful in installing new membership view", e);
-      return false;
-    }
+
+    logger.info((preparing? "preparing" : "sending") + " new view " + view);
+    services.getMessenger().send(msg);
-        try {
-          services.getMessenger().send(new ViewAckMessage(m.getSender(), this.preparedView));
-        } catch (IOException e) {
-          logger.info("unable to send view response to " + m.getSender(), e);
-        }
+        services.getMessenger().send(new ViewAckMessage(m.getSender(), this.preparedView));
-      try {
-        services.getMessenger().send(new ViewAckMessage(m.getSender(), m.getView().getViewId(), m.isPreparing()));
-      } catch (IOException e) {
-        logger.info("unable to send view response to " + m.getSender(), e);
-      }
+      services.getMessenger().send(new ViewAckMessage(m.getSender(), m.getView().getViewId(), m.isPreparing()));
-      this.prepareResponses.processViewResponse(m.getViewId(), m.getSender(), m.getAlternateView());
+      this.prepareProcessor.processViewResponse(m.getViewId(), m.getSender(), m.getAlternateView());
-      this.viewResponses.processViewResponse(m.getViewId(), m.getSender(), m.getAlternateView());
+      this.viewProcessor.processViewResponse(m.getViewId(), m.getSender(), m.getAlternateView());
-    if (locators == null) {
-      DistributionConfig dconfig = services.getConfig().getDistributionConfig();
-      String bindAddr = dconfig.getBindAddress();
-      locators = GMSUtil.parseLocators(dconfig.getLocators(), bindAddr);
-    }
-
-            GMSMember mbr = (GMSMember)this.localAddress.getNetMember();
-            services.getConfig().setNetworkPartitionDetectionEnabled(response.isNetworkPartitionDetectionEnabled());
-            if (response.isUsePreferredCoordinators()
-                && localAddress.getVmKind() != DistributionManager.LOCATOR_DM_TYPE) {
-              mbr.setPreferredForCoordinator(false);
+            if (response.isFromView()) {
+              GMSMember mbr = (GMSMember)this.localAddress.getNetMember();
+              services.getConfig().setNetworkPartitionDetectionEnabled(response.isNetworkPartitionDetectionEnabled());
+              if (response.isUsePreferredCoordinators()
+                  && localAddress.getVmKind() != DistributionManager.LOCATOR_DM_TYPE) {
+                mbr.setPreferredForCoordinator(false);
+              }
-        // get rid of outdated requests
+        // get rid of outdated requests.  It's possible some requests are
+        // newer than the view just processed - the senders will have to
+        // resend these
-    isConnected = false;
+    isJoined = false;
-            try {
-              services.getMessenger().send(m);
-              try { Thread.sleep(LEAVE_MESSAGE_SLEEP_TIME); }
-              catch (InterruptedException e) { Thread.currentThread().interrupt(); }
-            } catch (IOException e) {
-              logger.info("JoinLeave: unable to notify remaining members shutdown due to i/o exception", e);
-            }
+            services.getMessenger().send(m);
+            try { Thread.sleep(LEAVE_MESSAGE_SLEEP_TIME); }
+            catch (InterruptedException e) { Thread.currentThread().interrupt(); }
-            try {
-              services.getMessenger().send(m);
-            } catch (IOException e) {
-              logger.info("JoinLeave: unable to notify membership coordinator of shutdown due to i/o exception", e);
-            }
+            services.getMessenger().send(m);
-      try {
-        services.getMessenger().send(msg);
-      } catch (IOException e) {
-        logger.info("JoinLeave was unable to remove member " + m + " due to an i/o exception");
-      }
+      services.getMessenger().send(msg);
+    services.getMessenger().addHandler(JoinRequestMessage.class, this);
+    services.getMessenger().addHandler(JoinResponseMessage.class, this);
+    DistributionConfig dconfig = services.getConfig().getDistributionConfig();
+    String bindAddr = dconfig.getBindAddress();
+    locators = GMSUtil.parseLocators(dconfig.getLocators(), bindAddr);
-    if (m instanceof JoinRequestMessage) {
+    switch (m.getDSFID()) {
+    case JOIN_REQUEST:
-    } else if (m instanceof JoinResponseMessage) {
+      break;
+    case JOIN_RESPONSE:
-    } else if (m instanceof InstallViewMessage) {
+      break;
+    case INSTALL_VIEW_MESSAGE:
-    } else if (m instanceof ViewAckMessage) {
+      break;
+    case VIEW_ACK_MESSAGE:
-    } else if (m instanceof LeaveRequestMessage) {
+      break;
+    case LEAVE_REQUEST_MESSAGE:
-    } else if (m instanceof RemoveMemberMessage) {
+      break;
+    case REMOVE_MEMBER_MESSAGE:
-    } else {
+      break;
+    default:
+      this.conflictingView = null;
+
-        waitingFor.remove(sender);
-        if (waitingFor.isEmpty()) {
-          synchronized(waitingFor) {
+        synchronized(waitingFor) {
+          waitingFor.remove(sender);
+          if (waitingFor.isEmpty()) {
+            logger.debug("All view responses received - notifying waiting thread");
+
-      
+            logger.debug("Interrupted while waiting for view resonses");
+
-          prepared = prepareView(newView);
+          prepared = prepareView(newView, joinReqs);
-            Set<InternalDistributedMember> unresponsive = prepareResponses.getUnresponsiveMembers();
+            Set<InternalDistributedMember> unresponsive = prepareProcessor.getUnresponsiveMembers();
-            List<InternalDistributedMember> failures = new ArrayList<InternalDistributedMember>(currentView.getCrashedMembers().size() + unresponsive.size());
-            failures.addAll(unresponsive);
-            
-            NetView conflictingView = prepareResponses.getConflictingView();
-            if (conflictingView != null
-                && !conflictingView.getCreator().equals(localAddress)
-                && conflictingView.getViewId() > newView.getViewId()
-                && (lastConflictingView == null || conflictingView.getViewId() > lastConflictingView.getViewId())) {
-              lastConflictingView = conflictingView;
-              failures.addAll(conflictingView.getCrashedMembers());
-            }
-  
-            failures.removeAll(removalReqs);
-            if (failures.size() > 0) {
-              // abort the current view and try again
-              removalReqs.addAll(failures);
-              newView = new NetView(localAddress, newView.getViewId()+1, newView.getMembers(), leaveReqs,
-                  removalReqs);
+            if (!unresponsive.isEmpty()) {
+              List<InternalDistributedMember> failures = new ArrayList<InternalDistributedMember>(currentView.getCrashedMembers().size() + unresponsive.size());
+              failures.addAll(unresponsive);
+
+              NetView conflictingView = prepareProcessor.getConflictingView();
+              if (conflictingView != null
+                  && !conflictingView.getCreator().equals(localAddress)
+                  && conflictingView.getViewId() > newView.getViewId()
+                  && (lastConflictingView == null || conflictingView.getViewId() > lastConflictingView.getViewId())) {
+                lastConflictingView = conflictingView;
+                failures.addAll(conflictingView.getCrashedMembers());
+              }
+
+              failures.removeAll(removalReqs);
+              if (failures.size() > 0) {
+                // abort the current view and try again
+                removalReqs.addAll(failures);
+                newView = new NetView(localAddress, newView.getViewId()+1, newView.getMembers(), leaveReqs,
+                    removalReqs);
+              }
-      sendView(newView);
+      sendView(newView, joinReqs);
-              return null;
+              return fmbr;
-            return fmbr;
+            return null;

MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 UPD40 INS40 INS40 INS40 INS40 INS29 INS29 INS29 INS29 INS29 INS29 INS29 MOV8 MOV8 INS44 INS44 INS44 MOV8 MOV8 MOV8 INS65 UPD42 INS65 INS65 UPD42 INS65 UPD42 INS65 INS65 INS65 INS25 MOV21 INS70 MOV60 INS70 INS74 INS42 INS74 INS42 INS74 INS42 INS21 MOV21 INS21 INS25 MOV21 INS25 MOV8 INS51 MOV60 INS25 INS21 INS21 MOV60 MOV60 MOV21 INS50 UPD34 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS27 INS8 MOV44 INS42 MOV8 MOV44 INS42 MOV8 INS43 INS43 INS43 INS43 INS43 INS43 INS32 INS32 INS32 INS8 MOV32 MOV8 INS42 MOV8 MOV27 MOV8 INS32 INS32 INS32 INS49 MOV21 INS10 INS49 MOV21 INS10 INS49 MOV21 INS10 INS49 MOV21 INS10 INS49 MOV21 INS10 INS49 MOV21 INS10 INS49 MOV53 INS21 INS27 INS32 INS21 INS41 UPD42 MOV21 MOV60 MOV60 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS22 INS42 INS42 INS42 INS42 MOV41 UPD42 MOV60 MOV21 MOV60 INS32 INS42 INS57 INS52 INS32 INS42 INS57 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS32 INS42 INS42 INS42 INS45 INS32 INS9 MOV8 UPD42 UPD42 INS52 INS42 UPD9 MOV8 MOV27 INS42 INS42 INS43 INS42 INS42 INS43 INS22 INS33 INS51 INS42 INS22 INS42 INS42 MOV60 MOV21 UPD42 UPD45 INS42 INS42 INS52 INS42 INS42 INS8 INS52 INS42 UPD42 UPD42 MOV27 MOV21 MOV25 UPD42 INS32 INS25 MOV8 INS42 INS43 INS42 MOV22 MOV8 INS8 INS21 INS25 INS42 INS25 MOV21 MOV21 MOV60 MOV21 MOV60 MOV21 MOV21 MOV60 MOV21 INS32 INS21 INS42 INS38 INS8 INS32 INS32 INS8 MOV32 INS42 INS42 INS45 INS32 INS32 MOV60 MOV21 MOV60 MOV25 MOV21 MOV25 MOV41 INS42 INS43 INS42 INS42 INS42 MOV60 MOV21 MOV25 MOV32 MOV42 UPD42 INS42 INS42 INS45 UPD42 INS42 INS42 INS42 MOV41 UPD42 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL45 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL40 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL42 DEL70 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL42 DEL70 DEL8 DEL45 DEL42 DEL45 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL25 DEL8 DEL42 DEL33 DEL27 DEL8 DEL25 DEL45 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL25 DEL42 DEL51 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL45 DEL27 DEL32 DEL21 DEL8 DEL12 DEL54 DEL25 DEL8 DEL42 DEL42 DEL43 DEL62 DEL8 DEL42 DEL42 DEL43 DEL62 DEL8 DEL42 DEL42 DEL43 DEL62 DEL8 DEL42 DEL42 DEL43 DEL62 DEL8 DEL42 DEL42 DEL43 DEL62 DEL8 DEL42 DEL42 DEL43 DEL62 DEL8 DEL8 DEL25 DEL25 DEL25 DEL25 DEL25 DEL25 DEL42 DEL51 DEL8
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Class <code>CacheClientNotifier</code> works on the server and manages
- * client socket connections to clients requesting notification of updates and
- * notifies them when updates occur.
+ * Class <code>CacheClientNotifier</code> works on the server and manages client socket connections
+ * to clients requesting notification of updates and notifies them when updates occur.
-  
+
-  
+
-   * Factory method to construct a CacheClientNotifier
-   * <code>CacheClientNotifier</code> instance.
+   * Factory method to construct a CacheClientNotifier <code>CacheClientNotifier</code> instance.
-   * @param cache
-   *          The GemFire <code>Cache</code>
-   * @param acceptorStats        
+   * @param cache The GemFire <code>Cache</code>
+   * @param acceptorStats
-   * @param messageTimeToLive 
-   * @param listener 
-   * @param overflowAttributesList 
+   * @param messageTimeToLive
+   * @param listener
+   * @param overflowAttributesList
-      CacheServerStats acceptorStats,
-      int maximumMessageCount, int messageTimeToLive,
-      ConnectionListener listener, List overflowAttributesList, boolean isGatewayReceiver)
-  {
+      CacheServerStats acceptorStats, int maximumMessageCount, int messageTimeToLive,
+      ConnectionListener listener, List overflowAttributesList, boolean isGatewayReceiver) {
-      ccnSingleton = new CacheClientNotifier(cache, acceptorStats, maximumMessageCount, 
+      ccnSingleton = new CacheClientNotifier(cache, acceptorStats, maximumMessageCount,
-    
+
-//    else {
-//      ccnSingleton.acceptorStats = acceptorStats;
-//      ccnSingleton.maximumMessageCount = maximumMessageCount;
-//      ccnSingleton.messageTimeToLive = messageTimeToLive;
-//      ccnSingleton._connectionListener = listener;
-//      ccnSingleton.setCache((GemFireCache)cache);
-//    }
+    // else {
+    // ccnSingleton.acceptorStats = acceptorStats;
+    // ccnSingleton.maximumMessageCount = maximumMessageCount;
+    // ccnSingleton.messageTimeToLive = messageTimeToLive;
+    // ccnSingleton._connectionListener = listener;
+    // ccnSingleton.setCache((GemFireCache)cache);
+    // }
-  
-  public static CacheClientNotifier getInstance(){
+
+  public static CacheClientNotifier getInstance() {
-  
+
-   * @param dos
-   *                the <code>DataOutputStream</code> to use for writing the
-   *                message
-   * @param type
-   *                a byte representing the message type
-   * @param p_msg
-   *                the message to be written; can be null
+   * @param dos the <code>DataOutputStream</code> to use for writing the message
+   * @param type a byte representing the message type
+   * @param p_msg the message to be written; can be null
-   *                
+   * 
-  private void writeMessage(DataOutputStream dos, byte type, String p_msg, Version clientVersion )
+  private void writeMessage(DataOutputStream dos, byte type, String p_msg, Version clientVersion)
-    writeMessage(dos, type, p_msg, clientVersion, (byte)0x00, 0);
+    writeMessage(dos, type, p_msg, clientVersion, (byte) 0x00, 0);
-  private void writeMessage(DataOutputStream dos, byte type, String p_msg,
-      Version clientVersion, byte epType, int qSize) throws IOException {
+  private void writeMessage(DataOutputStream dos, byte type, String p_msg, Version clientVersion,
+      byte epType, int qSize) throws IOException {
-    if (clientVersion != null
-        && clientVersion.compareTo(Version.GFE_61) >= 0) {
+    if (clientVersion != null && clientVersion.compareTo(Version.GFE_61) >= 0) {
-          instantiatorAttributes.add(instantiator.getClass().toString()
-              .substring(6));
-          instantiatorAttributes.add(instantiator.getInstantiatedClass()
-              .toString().substring(6));
+          instantiatorAttributes.add(instantiator.getClass().toString().substring(6));
+          instantiatorAttributes.add(instantiator.getInstantiatedClass().toString().substring(6));
-      DataSerializer[] dataSerializers = InternalDataSerializer
-          .getSerializers();
-      HashMap<Integer, ArrayList<String>> dsToSupportedClasses = new HashMap<Integer, ArrayList<String>>();
+      DataSerializer[] dataSerializers = InternalDataSerializer.getSerializers();
+      HashMap<Integer, ArrayList<String>> dsToSupportedClasses =
+          new HashMap<Integer, ArrayList<String>>();
-          dataSerializersMap.put(dataSerializer.getId(), dataSerializer
-              .getClass().toString().substring(6));
+          dataSerializersMap.put(dataSerializer.getId(),
+              dataSerializer.getClass().toString().substring(6));
-   * @param dos
-   *                the <code>DataOutputStream</code> to use for writing the
-   *                message
-   * @param type
-   *                a byte representing the exception type
-   * @param ex
-   *                the exception to be written; should not be null
+   * @param dos the <code>DataOutputStream</code> to use for writing the message
+   * @param type a byte representing the exception type
+   * @param ex the exception to be written; should not be null
-  //  /**
-  //   * Factory method to return the singleton <code>CacheClientNotifier</code>
-  //   * instance.
-  //   * @return the singleton <code>CacheClientNotifier</code> instance
-  //   */
-  //  public static CacheClientNotifier getInstance()
-  //  {
-  //    return _instance;
-  //  }
+  // /**
+  // * Factory method to return the singleton <code>CacheClientNotifier</code>
+  // * instance.
+  // * @return the singleton <code>CacheClientNotifier</code> instance
+  // */
+  // public static CacheClientNotifier getInstance()
+  // {
+  // return _instance;
+  // }
-  //  /**
-  //   * Shuts down the singleton <code>CacheClientNotifier</code> instance.
-  //   */
-  //  public static void shutdownInstance()
-  //  {
-  //    if (_instance == null) return;
-  //    _instance.shutdown();
-  //    _instance = null;
-  //  }
+  // /**
+  // * Shuts down the singleton <code>CacheClientNotifier</code> instance.
+  // */
+  // public static void shutdownInstance()
+  // {
+  // if (_instance == null) return;
+  // _instance.shutdown();
+  // _instance = null;
+  // }
-   * Registers a new client updater that wants to receive updates with this
-   * server.
+   * Registers a new client updater that wants to receive updates with this server.
-   * @param socket
-   *          The socket over which the server communicates with the client.
+   * @param socket The socket over which the server communicates with the client.
-      boolean notifyBySubscription)
-      throws IOException
-  {
+      boolean notifyBySubscription) throws IOException {
-    }
-    catch (UnsupportedVersionException e) {
+    } catch (UnsupportedVersionException e) {
-      logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientNotifier_CACHECLIENTNOTIFIER_CAUGHT_EXCEPTION_ATTEMPTING_TO_CLIENT), uve);
+      logger.warn(
+          LocalizedMessage.create(
+              LocalizedStrings.CacheClientNotifier_CACHECLIENTNOTIFIER_CAUGHT_EXCEPTION_ATTEMPTING_TO_CLIENT),
+          uve);
-      registerGFEClient(dis, dos, socket, isPrimary, startTime, clientVersion,
-            acceptorId, notifyBySubscription);
+      registerGFEClient(dis, dos, socket, isPrimary, startTime, clientVersion, acceptorId,
+          notifyBySubscription);
-        Exception e = new UnsupportedVersionException(clientVersionOrdinal);
-        throw new IOException(e.toString());
+      Exception e = new UnsupportedVersionException(clientVersionOrdinal);
+      throw new IOException(e.toString());
-  protected void registerGFEClient(DataInputStream dis, DataOutputStream dos,
-      Socket socket, boolean isPrimary, long startTime, Version clientVersion,
-      long acceptorId, boolean notifyBySubscription) throws IOException {    
- // Read the ports and throw them away. We no longer need them
+  protected void registerGFEClient(DataInputStream dis, DataOutputStream dos, Socket socket,
+      boolean isPrimary, long startTime, Version clientVersion, long acceptorId,
+      boolean notifyBySubscription) throws IOException {
+    // Read the ports and throw them away. We no longer need them
-        writeException(dos, HandShake.REPLY_INVALID, new Exception(
-            "This client is blacklisted by server"), clientVersion);
+        writeException(dos, HandShake.REPLY_INVALID,
+            new Exception("This client is blacklisted by server"), clientVersion);
-      String authenticator = sysProps
-          .getProperty(SECURITY_CLIENT_AUTHENTICATOR);
-      //TODO;hitesh for conflation
+      String authenticator = sysProps.getProperty(SECURITY_CLIENT_AUTHENTICATOR);
+      // TODO;hitesh for conflation
-        byte[] overrides = HandShake.extractOverrides(new byte[] { (byte) dis.read() });
-        
+        byte[] overrides = HandShake.extractOverrides(new byte[] {(byte) dis.read()});
+
-      proxy = registerClient(socket, proxyID, proxy, isPrimary, clientConflation,
-        clientVersion, acceptorId, notifyBySubscription);
-      
-      //TODO:hitesh
+      proxy = registerClient(socket, proxyID, proxy, isPrimary, clientConflation, clientVersion,
+          acceptorId, notifyBySubscription);
+
+      // TODO:hitesh
-      if (credentials != null && proxy!=null) {
+      if (credentials != null && proxy != null) {
-          securityLogWriter.fine("CacheClientNotifier: verifying credentials for proxyID: " + proxyID);
+          securityLogWriter
+              .fine("CacheClientNotifier: verifying credentials for proxyID: " + proxyID);
-        Object subject = HandShake.verifyCredentials(authenticator,
-            credentials, system.getSecurityProperties(), this.logWriter,
-            this.securityLogWriter, member);
-        if(subject instanceof Principal){
+        Object subject = HandShake.verifyCredentials(authenticator, credentials,
+            system.getSecurityProperties(), this.logWriter, this.securityLogWriter, member);
+        if (subject instanceof Principal) {
-            securityLogWriter.fine("CacheClientNotifier: successfully verified credentials for proxyID: " + proxyID + " having principal: " + principal.getName());
+            securityLogWriter
+                .fine("CacheClientNotifier: successfully verified credentials for proxyID: "
+                    + proxyID + " having principal: " + principal.getName());
-          String postAuthzFactoryName = sysProps
-              .getProperty(SECURITY_CLIENT_ACCESSOR_PP);
+          String postAuthzFactoryName = sysProps.getProperty(SECURITY_CLIENT_ACCESSOR_PP);
-              securityLogWriter.warning(LocalizedStrings.CacheClientNotifier_CACHECLIENTNOTIFIER_POST_PROCESS_AUTHORIZATION_CALLBACK_ENABLED_BUT_AUTHENTICATION_CALLBACK_0_RETURNED_WITH_NULL_CREDENTIALS_FOR_PROXYID_1, new Object[] {
-                SECURITY_CLIENT_AUTHENTICATOR, proxyID
-              });
+              securityLogWriter.warning(
+                  LocalizedStrings.CacheClientNotifier_CACHECLIENTNOTIFIER_POST_PROCESS_AUTHORIZATION_CALLBACK_ENABLED_BUT_AUTHENTICATION_CALLBACK_0_RETURNED_WITH_NULL_CREDENTIALS_FOR_PROXYID_1,
+                  new Object[] {SECURITY_CLIENT_AUTHENTICATOR, proxyID});
-        }
-        else if(subject instanceof Subject){
-          proxy.setSubject((Subject)subject);
+        } else if (subject instanceof Subject) {
+          proxy.setSubject((Subject) subject);
-    }
-    catch (ClassNotFoundException e) {
-      throw new IOException(LocalizedStrings.CacheClientNotifier_CLIENTPROXYMEMBERSHIPID_OBJECT_COULD_NOT_BE_CREATED_EXCEPTION_OCCURRED_WAS_0.toLocalizedString(e));
-    }
-    catch (AuthenticationRequiredException ex) {
-      securityLogWriter.warning(LocalizedStrings.CacheClientNotifier_AN_EXCEPTION_WAS_THROWN_FOR_CLIENT_0_1, new Object[] {proxyID, ex});
+    } catch (ClassNotFoundException e) {
+      throw new IOException(
+          LocalizedStrings.CacheClientNotifier_CLIENTPROXYMEMBERSHIPID_OBJECT_COULD_NOT_BE_CREATED_EXCEPTION_OCCURRED_WAS_0
+              .toLocalizedString(e));
+    } catch (AuthenticationRequiredException ex) {
+      securityLogWriter.warning(
+          LocalizedStrings.CacheClientNotifier_AN_EXCEPTION_WAS_THROWN_FOR_CLIENT_0_1,
+          new Object[] {proxyID, ex});
-    }
-    catch (AuthenticationFailedException ex) {
-      securityLogWriter.warning(LocalizedStrings.CacheClientNotifier_AN_EXCEPTION_WAS_THROWN_FOR_CLIENT_0_1, new Object[] {proxyID, ex});
+    } catch (AuthenticationFailedException ex) {
+      securityLogWriter.warning(
+          LocalizedStrings.CacheClientNotifier_AN_EXCEPTION_WAS_THROWN_FOR_CLIENT_0_1,
+          new Object[] {proxyID, ex});
-    }
-    catch (CacheException e) {
-      logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientNotifier_0_REGISTERCLIENT_EXCEPTION_ENCOUNTERED_IN_REGISTRATION_1, new Object[] {this, e}), e);
-      IOException io = new IOException(LocalizedStrings.CacheClientNotifier_EXCEPTION_OCCURRED_WHILE_TRYING_TO_REGISTER_INTEREST_DUE_TO_0.toLocalizedString(e.getMessage()));
+    } catch (CacheException e) {
+      logger.warn(LocalizedMessage.create(
+          LocalizedStrings.CacheClientNotifier_0_REGISTERCLIENT_EXCEPTION_ENCOUNTERED_IN_REGISTRATION_1,
+          new Object[] {this, e}), e);
+      IOException io = new IOException(
+          LocalizedStrings.CacheClientNotifier_EXCEPTION_OCCURRED_WHILE_TRYING_TO_REGISTER_INTEREST_DUE_TO_0
+              .toLocalizedString(e.getMessage()));
-    }
-    catch (Exception ex) {
-      logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientNotifier_AN_EXCEPTION_WAS_THROWN_FOR_CLIENT_0_1, new Object[] {proxyID, ""}), ex);
+    } catch (Exception ex) {
+      logger.warn(LocalizedMessage.create(
+          LocalizedStrings.CacheClientNotifier_AN_EXCEPTION_WAS_THROWN_FOR_CLIENT_0_1,
+          new Object[] {proxyID, ""}), ex);
-   * @param socket
-   *                The socket over which the server communicates with the
-   *                client.
-   * @param proxyId
-   *                The distributed member id of the client being registered
-   * @param proxy
-   *                The <code>CacheClientProxy</code> of the given
-   *                <code>proxyId</code>
+   * @param socket The socket over which the server communicates with the client.
+   * @param proxyId The distributed member id of the client being registered
+   * @param proxy The <code>CacheClientProxy</code> of the given <code>proxyId</code>
-  private CacheClientProxy registerClient(Socket socket,
-      ClientProxyMembershipID proxyId, CacheClientProxy proxy,
-      boolean isPrimary, byte clientConflation, Version clientVersion,
+  private CacheClientProxy registerClient(Socket socket, ClientProxyMembershipID proxyId,
+      CacheClientProxy proxy, boolean isPrimary, byte clientConflation, Version clientVersion,
-      logger.debug("CacheClientNotifier: Initialized server-to-client socket with send buffer size: {} bytes and receive buffer size: {} bytes", socket.getSendBufferSize(), socket.getReceiveBufferSize());
+      logger.debug(
+          "CacheClientNotifier: Initialized server-to-client socket with send buffer size: {} bytes and receive buffer size: {} bytes",
+          socket.getSendBufferSize(), socket.getReceiveBufferSize());
-        logger.debug("CacheClientNotifier: Attempting to register durable client: {}", proxyId.getDurableId());
+        logger.debug("CacheClientNotifier: Attempting to register durable client: {}",
+            proxyId.getDurableId());
-          logger.debug("CacheClientNotifier: No proxy exists for durable client with id {}. It must be created.", proxyId.getDurableId());
+          logger.debug(
+              "CacheClientNotifier: No proxy exists for durable client with id {}. It must be created.",
+              proxyId.getDurableId());
-        l_proxy = new CacheClientProxy(this, socket, proxyId,
-            isPrimary, clientConflation, clientVersion, acceptorId, notifyBySubscription);
+        l_proxy = new CacheClientProxy(this, socket, proxyId, isPrimary, clientConflation,
+            clientVersion, acceptorId, notifyBySubscription);
-          if (l_proxy.lockDrain()) { 
+          if (l_proxy.lockDrain()) {
-                logger.debug("CacheClientNotifier: A proxy exists for durable client with id {}. This proxy will be reinitialized: {}", proxyId.getDurableId(), l_proxy);
+                logger.debug(
+                    "CacheClientNotifier: A proxy exists for durable client with id {}. This proxy will be reinitialized: {}",
+                    proxyId.getDurableId(), l_proxy);
-              l_proxy.reinitialize(socket, proxyId, this.getCache(), isPrimary,
-                  clientConflation, clientVersion);
+              l_proxy.reinitialize(socket, proxyId, this.getCache(), isPrimary, clientConflation,
+                  clientVersion);
-            }
-            finally {
+            } finally {
-          }
-          else {
-            unsuccessfulMsg = LocalizedStrings.CacheClientNotifier_COULD_NOT_CONNECT_DUE_TO_CQ_BEING_DRAINED.toLocalizedString();
+          } else {
+            unsuccessfulMsg =
+                LocalizedStrings.CacheClientNotifier_COULD_NOT_CONNECT_DUE_TO_CQ_BEING_DRAINED
+                    .toLocalizedString();
-          unsuccessfulMsg = LocalizedStrings.CacheClientNotifier_CACHECLIENTNOTIFIER_THE_REQUESTED_DURABLE_CLIENT_HAS_THE_SAME_IDENTIFIER__0__AS_AN_EXISTING_DURABLE_CLIENT__1__DUPLICATE_DURABLE_CLIENTS_ARE_NOT_ALLOWED.toLocalizedString(new Object[] {proxyId.getDurableId(), proxy});
+          unsuccessfulMsg =
+              LocalizedStrings.CacheClientNotifier_CACHECLIENTNOTIFIER_THE_REQUESTED_DURABLE_CLIENT_HAS_THE_SAME_IDENTIFIER__0__AS_AN_EXISTING_DURABLE_CLIENT__1__DUPLICATE_DURABLE_CLIENTS_ARE_NOT_ALLOWED
+                  .toLocalizedString(new Object[] {proxyId.getDurableId(), proxy});
-            logger.debug("CacheClientNotifier: A proxy exists for this non-durable client. It must be closed.");
+            logger.debug(
+                "CacheClientNotifier: A proxy exists for this non-durable client. It must be closed.");
-          }
-          else {
+          } else {
-        l_proxy = new CacheClientProxy(this, socket, proxyId,
-            isPrimary, clientConflation, clientVersion, acceptorId, notifyBySubscription);
+        l_proxy = new CacheClientProxy(this, socket, proxyId, isPrimary, clientConflation,
+            clientVersion, acceptorId, notifyBySubscription);
-    if (!successful){
+    if (!successful) {
-      unsuccessfulMsg = LocalizedStrings.CacheClientNotifier_CACHECLIENTNOTIFIER_A_PREVIOUS_CONNECTION_ATTEMPT_FROM_THIS_CLIENT_IS_STILL_BEING_PROCESSED__0.toLocalizedString(new Object[] {proxyId});      
+      unsuccessfulMsg =
+          LocalizedStrings.CacheClientNotifier_CACHECLIENTNOTIFIER_A_PREVIOUS_CONNECTION_ATTEMPT_FROM_THIS_CLIENT_IS_STILL_BEING_PROCESSED__0
+              .toLocalizedString(new Object[] {proxyId});
-    
+
-      DataOutputStream dos = new DataOutputStream(new BufferedOutputStream(
-          socket.getOutputStream()));
+      DataOutputStream dos =
+          new DataOutputStream(new BufferedOutputStream(socket.getOutputStream()));
-    }
-    catch (IOException ioe) {// remove the added proxy if we get IOException.
+    } catch (IOException ioe) {// remove the added proxy if we get IOException.
-    
+
-    
+
-    if (!clientIsDurable && l_proxy != null &&
-        responseByte == Acceptor.SUCCESSFUL_SERVER_TO_CLIENT) {
+    if (!clientIsDurable && l_proxy != null
+        && responseByte == Acceptor.SUCCESSFUL_SERVER_TO_CLIENT) {
-      logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientNotifier_CACHECLIENTNOTIFIER_UNSUCCESSFULLY_REGISTERED_CLIENT_WITH_IDENTIFIER__0, proxyId));
+      logger.warn(LocalizedMessage.create(
+          LocalizedStrings.CacheClientNotifier_CACHECLIENTNOTIFIER_UNSUCCESSFULLY_REGISTERED_CLIENT_WITH_IDENTIFIER__0,
+          proxyId));
-    if (!this.isProxyInInitializationMode(l_proxy)){
+    if (!this.isProxyInInitializationMode(l_proxy)) {
-      try {              
-        // Add client proxy to initialization list.  This has to be done before
+      try {
+        // Add client proxy to initialization list. This has to be done before
-          logger.debug("Found RegionExistsException while initializing proxy. Region name: {}", name);
+          logger.debug("Found RegionExistsException while initializing proxy. Region name: {}",
+              name);
-  
+
-   * Makes Primary to this CacheClientProxy and start the dispatcher of the
-   * CacheClientProxy
+   * Makes Primary to this CacheClientProxy and start the dispatcher of the CacheClientProxy
-   * @param isClientReady Whether the marker has already been processed. This
-   * value helps determine whether to start the dispatcher.
+   * @param isClientReady Whether the marker has already been processed. This value helps determine
+   *        whether to start the dispatcher.
-  public void makePrimary(ClientProxyMembershipID proxyId, boolean isClientReady)
-  {
+  public void makePrimary(ClientProxyMembershipID proxyId, boolean isClientReady) {
-      
-      /* If the client represented by this proxy has:
-       * - already processed the marker message (meaning the client is failing
-       * over to this server as its primary) <or>
-       * - is not durable (meaning the marker message is being processed
-       * automatically
-       *
-       * Then, start or resume the dispatcher. Otherwise, let the clientReady
-       * message start the dispatcher.
-       * See CacheClientProxy.startOrResumeMessageDispatcher
-      if (!proxy._messageDispatcher.isAlive()) {
-        proxy._messageDispatcher._messageQueue.setPrimary(true);
-        proxy._messageDispatcher.start();
-      }
-      */
+      /*
+       * If the client represented by this proxy has: - already processed the marker message
+       * (meaning the client is failing over to this server as its primary) <or> - is not durable
+       * (meaning the marker message is being processed automatically
+       *
+       * Then, start or resume the dispatcher. Otherwise, let the clientReady message start the
+       * dispatcher. See CacheClientProxy.startOrResumeMessageDispatcher if
+       * (!proxy._messageDispatcher.isAlive()) {
+       * 
+       * proxy._messageDispatcher._messageQueue.setPrimary(true); proxy._messageDispatcher.start();
+       * }
+       */
-  public boolean processDispatchedMessage(ClientProxyMembershipID proxyId, EventID eid)
-  {
+  public boolean processDispatchedMessage(ClientProxyMembershipID proxyId, EventID eid) {
-      harq.addDispatchedMessage(new ThreadIdentifier(eid.getMembershipID(),
-                                                     eid.getThreadID()),
-                                eid.getSequenceID());
+      harq.addDispatchedMessage(new ThreadIdentifier(eid.getMembershipID(), eid.getThreadID()),
+          eid.getSequenceID());
-   * @param membershipID
-   *          Uniquely identifies the client pool
+   * @param membershipID Uniquely identifies the client pool
-  public void setKeepAlive(ClientProxyMembershipID membershipID, boolean keepAlive)
-  {
+  public void setKeepAlive(ClientProxyMembershipID membershipID, boolean keepAlive) {
-//         // If so, remove the port from the client's remote ports
-//         proxy.removePort(clientPort);
-        // Set the keepalive flag
+      // // If so, remove the port from the client's remote ports
+      // proxy.removePort(clientPort);
+      // Set the keepalive flag
-   * @param memberId
-   *          Uniquely identifies the client
+   * @param memberId Uniquely identifies the client
-  public void unregisterClient(ClientProxyMembershipID memberId, boolean normalShutdown)
-  {
+  public void unregisterClient(ClientProxyMembershipID memberId, boolean normalShutdown) {
-  public void readyForEvents(ClientProxyMembershipID proxyId)
-  {
+  public void readyForEvents(ClientProxyMembershipID proxyId) {
-      //@todo log a message
+      // @todo log a message
-  private ClientUpdateMessageImpl constructClientMessage(InternalCacheEvent event){
+  private ClientUpdateMessageImpl constructClientMessage(InternalCacheEvent event) {
-    
+
-      logger.fatal(LocalizedMessage.create(LocalizedStrings.CacheClientNotifier_CANNOT_NOTIFY_CLIENTS_TO_PERFORM_OPERATION_0_ON_EVENT_1, new Object[] { operation, event}), e); 
+      logger.fatal(LocalizedMessage.create(
+          LocalizedStrings.CacheClientNotifier_CANNOT_NOTIFY_CLIENTS_TO_PERFORM_OPERATION_0_ON_EVENT_1,
+          new Object[] {operation, event}), e);
-  
+
-   * notify interested clients of the given cache event.  The
-   * event should have routing information in it that determines
-   * which clients will receive the event.
+   * notify interested clients of the given cache event. The event should have routing information
+   * in it that determines which clients will receive the event.
-    
+
-  
+
-   * notify interested clients of the given cache event using the
-   * given update message.  The
-   * event should have routing information in it that determines
-   * which clients will receive the event.
+   * notify interested clients of the given cache event using the given update message. The event
+   * should have routing information in it that determines which clients will receive the event.
-      
+
-  
-  private void singletonNotifyClients(InternalCacheEvent event, ClientUpdateMessage cmsg){
+
+  private void singletonNotifyClients(InternalCacheEvent event, ClientUpdateMessage cmsg) {
-    
-    FilterInfo filterInfo = event.getLocalFilterInfo();
-    
-//    if (_logger.fineEnabled()) {
-//      _logger.fine("Client dispatcher processing event " + event);
-//    }
-    FilterProfile regionProfile = ((LocalRegion)event.getRegion()).getFilterProfile();
+    FilterInfo filterInfo = event.getLocalFilterInfo();
+
+    // if (_logger.fineEnabled()) {
+    // _logger.fine("Client dispatcher processing event " + event);
+    // }
+
+    FilterProfile regionProfile = ((LocalRegion) event.getRegion()).getFilterProfile();
-    if ((filterInfo == null ||
-         (filterInfo.getCQs() == null &&
-          filterInfo.getInterestedClients() == null && 
-          filterInfo.getInterestedClientsInv() == null))) {
+    if ((filterInfo == null
+        || (filterInfo.getCQs() == null && filterInfo.getInterestedClients() == null
+            && filterInfo.getInterestedClientsInv() == null))) {
-    
+
-        
+
-      clientMessage = (ClientUpdateMessageImpl)cmsg;
+      clientMessage = (ClientUpdateMessageImpl) cmsg;
-    if (clientMessage == null){
+    if (clientMessage == null) {
-        
+
-    
+
-      for (Map.Entry<Long, Integer> e: filterInfo.getCQs().entrySet()) { 
+      for (Map.Entry<Long, Integer> e : filterInfo.getCQs().entrySet()) {
-        if (cqName == null){
+        if (cqName == null) {
-        if (cq != null){
+        if (cq != null) {
-      Set<Object>rawIDs = regionProfile.getRealClientIDs(filterInfo.getInterestedClientsInv());
+      Set<Object> rawIDs = regionProfile.getRealClientIDs(filterInfo.getInterestedClientsInv());
-      Set<Object>rawIDs = regionProfile.getRealClientIDs(filterInfo.getInterestedClients());
+      Set<Object> rawIDs = regionProfile.getRealClientIDs(filterInfo.getInterestedClients());
-    
+
-        CacheClientProxy ccp = getClientProxy((ClientProxyMembershipID)id, true);
+        CacheClientProxy ccp = getClientProxy((ClientProxyMembershipID) id, true);
-    
+
-    
+
-    // destroyed are  removed after the event is placed in clients HAQueue.
-    if (filterInfo.filterProcessedLocally){
+    // destroyed are removed after the event is placed in clients HAQueue.
+    if (filterInfo.filterProcessedLocally) {
-  
-  
-  private void removeDestroyTokensFromCqResultKeys(InternalCacheEvent event, FilterInfo filterInfo){    
-    FilterProfile regionProfile = ((LocalRegion)event.getRegion()).getFilterProfile();
+
+
+  private void removeDestroyTokensFromCqResultKeys(InternalCacheEvent event,
+      FilterInfo filterInfo) {
+    FilterProfile regionProfile = ((LocalRegion) event.getRegion()).getFilterProfile();
-      EntryEventImpl entryEvent = (EntryEventImpl)event;
-      for (Map.Entry<Long, Integer> e: filterInfo.getCQs().entrySet()) { 
+      EntryEventImpl entryEvent = (EntryEventImpl) event;
+      for (Map.Entry<Long, Integer> e : filterInfo.getCQs().entrySet()) {
-          if (cq != null
-              && e.getValue().equals(Integer.valueOf(MessageType.LOCAL_DESTROY))) {
+          if (cq != null && e.getValue().equals(Integer.valueOf(MessageType.LOCAL_DESTROY))) {
-  
-  
+
+
-   * delivers the given message to all proxies for routing.  The message should
-   * already have client interest established, or override the isClientInterested
-   * method to implement its own routing
+   * delivers the given message to all proxies for routing. The message should already have client
+   * interest established, or override the isClientInterested method to implement its own routing
+   * 
-      instance.singletonRouteClientMessage(clientMessage, instance._clientProxies.keySet()); // ok to use keySet here because all we do is call getClientProxy with these keys
+      instance.singletonRouteClientMessage(clientMessage, instance._clientProxies.keySet()); // ok
+                                                                                             // to
+                                                                                             // use
+                                                                                             // keySet
+                                                                                             // here
+                                                                                             // because
+                                                                                             // all
+                                                                                             // we
+                                                                                             // do
+                                                                                             // is
+                                                                                             // call
+                                                                                             // getClientProxy
+                                                                                             // with
+                                                                                             // these
+                                                                                             // keys
-  
+
-  public static void routeSingleClientMessage(ClientUpdateMessage clientMessage, ClientProxyMembershipID clientProxyMembershipId) {
+  public static void routeSingleClientMessage(ClientUpdateMessage clientMessage,
+      ClientProxyMembershipID clientProxyMembershipId) {
-      instance.singletonRouteClientMessage(clientMessage, Collections.singleton(clientProxyMembershipId));
+      instance.singletonRouteClientMessage(clientMessage,
+          Collections.singleton(clientProxyMembershipId));
-  } 
-  
+  }
+
-    this._cache.getCancelCriterion().checkCancelInProgress(null); // bug #43942 - client notified but no p2p distribution
-    
+    this._cache.getCancelCriterion().checkCancelInProgress(null); // bug #43942 - client notified
+                                                                  // but no p2p distribution
+
-    for(ClientProxyMembershipID clientId: filterClients ) {
+    for (ClientProxyMembershipID clientId : filterClients) {
-  
+
-   * processes the given collection of durable and non-durable client identifiers,
-   * returning a collection of non-durable identifiers of clients connected to this VM
+   * processes the given collection of durable and non-durable client identifiers, returning a
+   * collection of non-durable identifiers of clients connected to this VM
-   * processes the given collection of durable and non-durable client identifiers,
-   * returning a collection of non-durable identifiers of clients connected to this VM.
-   * This version can check for proxies in initialization as well as fully initialized
-   * proxies.
+   * processes the given collection of durable and non-durable client identifiers, returning a
+   * collection of non-durable identifiers of clients connected to this VM. This version can check
+   * for proxies in initialization as well as fully initialized proxies.
-    for (Object id: mixedDurableAndNonDurableIDs) {
+    for (Object id : mixedDurableAndNonDurableIDs) {
-        CacheClientProxy clientProxy = getClientProxy((String)id, true);
+        CacheClientProxy clientProxy = getClientProxy((String) id, true);
-        CacheClientProxy proxy = getClientProxy((ClientProxyMembershipID)id, true);
+        CacheClientProxy proxy = getClientProxy((ClientProxyMembershipID) id, true);
-//this._logger.info(LocalizedStrings.DEBUG, "BRUCE: found match for " + id + ": " + proxy.getProxyID());
+          // this._logger.info(LocalizedStrings.DEBUG, "BRUCE: found match for " + id + ": " +
+          // proxy.getProxyID());
-//this._logger.info(LocalizedStrings.DEBUG, "BRUCE: did not find match for " + id);
+          // this._logger.info(LocalizedStrings.DEBUG, "BRUCE: did not find match for " + id);
-          //result.add((ClientProxyMembershipID)id);
+          // result.add((ClientProxyMembershipID)id);
-  
-  private void blackListSlowReciever(CacheClientProxy clientProxy){
+
+  private void blackListSlowReciever(CacheClientProxy clientProxy) {
-      logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientNotifier_CLIENT_0_IS_A_SLOW_RECEIVER, new Object[] { proxy.getProxyID() }));
+      logger.warn(
+          LocalizedMessage.create(LocalizedStrings.CacheClientNotifier_CLIENT_0_IS_A_SLOW_RECEIVER,
+              new Object[] {proxy.getProxyID()}));
-      InternalDistributedSystem ids = (InternalDistributedSystem)this.getCache()
-          .getDistributedSystem();
+      InternalDistributedSystem ids =
+          (InternalDistributedSystem) this.getCache().getDistributedSystem();
-          CacheDistributionAdvisor advisor = ((DistributedRegion)proxy
-              .getHARegionQueue().getRegion()).getCacheDistributionAdvisor();
+          CacheDistributionAdvisor advisor =
+              ((DistributedRegion) proxy.getHARegionQueue().getRegion())
+                  .getCacheDistributionAdvisor();
-          ClientBlacklistProcessor.sendBlacklistedClient(proxy.getProxyID(),
-              dm, members);
+          ClientBlacklistProcessor.sendBlacklistedClient(proxy.getProxyID(), dm, members);
-   * Initializes a <code>ClientUpdateMessage</code> from an operation and
-   * event
+   * Initializes a <code>ClientUpdateMessage</code> from an operation and event
-   * @param operation
-   *          The operation that occurred (e.g. AFTER_CREATE)
-   * @param event
-   *          The event containing the data to be updated
+   * @param operation The operation that occurred (e.g. AFTER_CREATE)
+   * @param event The event containing the data to be updated
-  private ClientUpdateMessageImpl initializeMessage(EnumListenerEvent operation,
-      CacheEvent event) throws Exception
-  {
+  private ClientUpdateMessageImpl initializeMessage(EnumListenerEvent operation, CacheEvent event)
+      throws Exception {
-      throw new Exception(LocalizedStrings.CacheClientNotifier_THE_CACHE_CLIENT_NOTIFIER_DOES_NOT_SUPPORT_OPERATIONS_OF_TYPE_0.toLocalizedString(operation));
+      throw new Exception(
+          LocalizedStrings.CacheClientNotifier_THE_CACHE_CLIENT_NOTIFIER_DOES_NOT_SUPPORT_OPERATIONS_OF_TYPE_0
+              .toLocalizedString(operation));
-//    String regionName = event.getRegion().getFullPath();
+    // String regionName = event.getRegion().getFullPath();
-      EntryEventImpl entryEvent = (EntryEventImpl)event;
+      EntryEventImpl entryEvent = (EntryEventImpl) event;
-    }
-    else {
-      RegionEventImpl regionEvent = (RegionEventImpl)event;
+    } else {
+      RegionEventImpl regionEvent = (RegionEventImpl) event;
-        ClientRegionEventImpl bridgeEvent = (ClientRegionEventImpl)event;
+        ClientRegionEventImpl bridgeEvent = (ClientRegionEventImpl) event;
-    ClientUpdateMessageImpl clientUpdateMsg = new ClientUpdateMessageImpl(operation,
-        (LocalRegion)event.getRegion(), keyOfInterest, null, delta, (byte) 0x01,
-        callbackArgument, membershipID, eventIdentifier, versionTag);
-    
+    ClientUpdateMessageImpl clientUpdateMsg =
+        new ClientUpdateMessageImpl(operation, (LocalRegion) event.getRegion(), keyOfInterest, null,
+            delta, (byte) 0x01, callbackArgument, membershipID, eventIdentifier, versionTag);
+
-      EntryEventImpl entryEvent = (EntryEventImpl)event;
+      EntryEventImpl entryEvent = (EntryEventImpl) event;
-   * Returns whether the <code>CacheClientNotifier</code> supports the input
-   * operation.
+   * Returns whether the <code>CacheClientNotifier</code> supports the input operation.
-   * @param operation
-   *          The operation that occurred (e.g. AFTER_CREATE)
-   * @return whether the <code>CacheClientNotifier</code> supports the input
-   *         operation
+   * @param operation The operation that occurred (e.g. AFTER_CREATE)
+   * @return whether the <code>CacheClientNotifier</code> supports the input operation
-  protected boolean supportsOperation(EnumListenerEvent operation)
-  {
+  protected boolean supportsOperation(EnumListenerEvent operation) {
-  //  /**
-  //   * Queues the <code>ClientUpdateMessage</code> to be distributed
-  //   * to interested clients. This method is not being used currently.
-  //   * @param clientMessage The <code>ClientUpdateMessage</code> to be queued
-  //   */
-  //  protected void notifyClients(final ClientUpdateMessage clientMessage)
-  //  {
-  //    if (USE_SYNCHRONOUS_NOTIFICATION)
-  //    {
-  //      // Execute the method in the same thread as the caller
-  //      deliver(clientMessage);
-  //    }
-  //    else {
-  //      // Obtain an Executor and use it to execute the method in its own thread
-  //      try
-  //      {
-  //        getExecutor().execute(new Runnable()
-  //          {
-  //            public void run()
-  //            {
-  //              deliver(clientMessage);
-  //            }
-  //          }
-  //        );
-  //      } catch (InterruptedException e)
-  //      {
-  //        _logger.warning("CacheClientNotifier: notifyClients interrupted", e);
-  //        Thread.currentThread().interrupt();
-  //      }
-  //    }
-  //  }
+  // /**
+  // * Queues the <code>ClientUpdateMessage</code> to be distributed
+  // * to interested clients. This method is not being used currently.
+  // * @param clientMessage The <code>ClientUpdateMessage</code> to be queued
+  // */
+  // protected void notifyClients(final ClientUpdateMessage clientMessage)
+  // {
+  // if (USE_SYNCHRONOUS_NOTIFICATION)
+  // {
+  // // Execute the method in the same thread as the caller
+  // deliver(clientMessage);
+  // }
+  // else {
+  // // Obtain an Executor and use it to execute the method in its own thread
+  // try
+  // {
+  // getExecutor().execute(new Runnable()
+  // {
+  // public void run()
+  // {
+  // deliver(clientMessage);
+  // }
+  // }
+  // );
+  // } catch (InterruptedException e)
+  // {
+  // _logger.warning("CacheClientNotifier: notifyClients interrupted", e);
+  // Thread.currentThread().interrupt();
+  // }
+  // }
+  // }
-//   /**
-//    * Updates the information this <code>CacheClientNotifier</code> maintains
-//    * for a given edge client. It is invoked when a edge client re-connects to
-//    * the server.
-//    *
-//    * @param clientHost
-//    *          The host on which the client runs (i.e. the host the
-//    *          CacheClientNotifier uses to communicate with the
-//    *          CacheClientUpdater) This is used with the clientPort to uniquely
-//    *          identify the client
-//    * @param clientPort
-//    *          The port through which the server communicates with the client
-//    *          (i.e. the port the CacheClientNotifier uses to communicate with
-//    *          the CacheClientUpdater) This is used with the clientHost to
-//    *          uniquely identify the client
-//    * @param remotePort
-//    *          The port through which the client communicates with the server
-//    *          (i.e. the new port the ConnectionImpl uses to communicate with the
-//    *          ServerConnection)
-//    * @param membershipID
-//    *          Uniquely idenifies the client
-//    */
-//   public void registerClientPort(String clientHost, int clientPort,
-//       int remotePort, ClientProxyMembershipID membershipID)
-//   {
-//     if (_logger.fineEnabled())
-//       _logger.fine("CacheClientNotifier: Registering client port: "
-//           + clientHost + ":" + clientPort + " with remote port " + remotePort
-//           + " and ID " + membershipID);
-//     for (Iterator i = getClientProxies().iterator(); i.hasNext();) {
-//       CacheClientProxy proxy = (CacheClientProxy)i.next();
-//       if (_logger.finerEnabled())
-//         _logger.finer("CacheClientNotifier: Potential client: " + proxy);
-//       //if (proxy.representsCacheClientUpdater(clientHost, clientPort))
-//       if (proxy.isMember(membershipID)) {
-//         if (_logger.finerEnabled())
-//           _logger
-//               .finer("CacheClientNotifier: Updating remotePorts since host and port are a match");
-//         proxy.addPort(remotePort);
-//       }
-//       else {
-//         if (_logger.finerEnabled())
-//           _logger.finer("CacheClientNotifier: Host and port "
-//               + proxy.getRemoteHostAddress() + ":" + proxy.getRemotePort()
-//               + " do not match " + clientHost + ":" + clientPort);
-//       }
-//     }
-//   }
+  // /**
+  // * Updates the information this <code>CacheClientNotifier</code> maintains
+  // * for a given edge client. It is invoked when a edge client re-connects to
+  // * the server.
+  // *
+  // * @param clientHost
+  // * The host on which the client runs (i.e. the host the
+  // * CacheClientNotifier uses to communicate with the
+  // * CacheClientUpdater) This is used with the clientPort to uniquely
+  // * identify the client
+  // * @param clientPort
+  // * The port through which the server communicates with the client
+  // * (i.e. the port the CacheClientNotifier uses to communicate with
+  // * the CacheClientUpdater) This is used with the clientHost to
+  // * uniquely identify the client
+  // * @param remotePort
+  // * The port through which the client communicates with the server
+  // * (i.e. the new port the ConnectionImpl uses to communicate with the
+  // * ServerConnection)
+  // * @param membershipID
+  // * Uniquely idenifies the client
+  // */
+  // public void registerClientPort(String clientHost, int clientPort,
+  // int remotePort, ClientProxyMembershipID membershipID)
+  // {
+  // if (_logger.fineEnabled())
+  // _logger.fine("CacheClientNotifier: Registering client port: "
+  // + clientHost + ":" + clientPort + " with remote port " + remotePort
+  // + " and ID " + membershipID);
+  // for (Iterator i = getClientProxies().iterator(); i.hasNext();) {
+  // CacheClientProxy proxy = (CacheClientProxy)i.next();
+  // if (_logger.finerEnabled())
+  // _logger.finer("CacheClientNotifier: Potential client: " + proxy);
+  // //if (proxy.representsCacheClientUpdater(clientHost, clientPort))
+  // if (proxy.isMember(membershipID)) {
+  // if (_logger.finerEnabled())
+  // _logger
+  // .finer("CacheClientNotifier: Updating remotePorts since host and port are a match");
+  // proxy.addPort(remotePort);
+  // }
+  // else {
+  // if (_logger.finerEnabled())
+  // _logger.finer("CacheClientNotifier: Host and port "
+  // + proxy.getRemoteHostAddress() + ":" + proxy.getRemotePort()
+  // + " do not match " + clientHost + ":" + clientPort);
+  // }
+  // }
+  // }
-   * @param regionName
-   *          The name of the region of interest
-   * @param keyOfInterest
-   *          The name of the key of interest
+   * @param regionName The name of the region of interest
+   * @param keyOfInterest The name of the key of interest
-      boolean sendUpdatesAsInvalidates,
-      boolean manageEmptyRegions, int regionDataPolicy,
-      boolean flushState) throws IOException, RegionDestroyedException
-  {
+      boolean sendUpdatesAsInvalidates, boolean manageEmptyRegions, int regionDataPolicy,
+      boolean flushState) throws IOException, RegionDestroyedException {
-    
+
-      logger.debug("CacheClientNotifier: Client {} registering interest in: {} -> {} (an instance of {})", proxy, regionName, keyOfInterest, keyOfInterest.getClass().getName());
+      logger.debug(
+          "CacheClientNotifier: Client {} registering interest in: {} -> {} (an instance of {})",
+          proxy, regionName, keyOfInterest, keyOfInterest.getClass().getName());
-    
-    if(proxy == null){
+
+    if (proxy == null) {
-      throw new IOException(LocalizedStrings.CacheClientNotifier_CACHECLIENTPROXY_FOR_THIS_CLIENT_IS_NO_LONGER_ON_THE_SERVER_SO_REGISTERINTEREST_OPERATION_IS_UNSUCCESSFUL.toLocalizedString());
+      throw new IOException(
+          LocalizedStrings.CacheClientNotifier_CACHECLIENTPROXY_FOR_THIS_CLIENT_IS_NO_LONGER_ON_THE_SERVER_SO_REGISTERINTEREST_OPERATION_IS_UNSUCCESSFUL
+              .toLocalizedString());
-    
+
-      proxy.registerClientInterest(regionName, keyOfInterest, interestType,
-          isDurable, sendUpdatesAsInvalidates, flushState);
-      
+      proxy.registerClientInterest(regionName, keyOfInterest, interestType, isDurable,
+          sendUpdatesAsInvalidates, flushState);
+
-        updateMapOfEmptyRegions(proxy.getRegionsWithEmptyDataPolicy(),
-          regionName, regionDataPolicy);
+        updateMapOfEmptyRegions(proxy.getRegionsWithEmptyDataPolicy(), regionName,
+            regionDataPolicy);
-      
-      done = true;      
-    }
-    finally {
+
+      done = true;
+    } finally {
-        proxy.unregisterClientInterest(regionName, keyOfInterest, interestType,
-            false);
+        proxy.unregisterClientInterest(regionName, keyOfInterest, interestType, false);
-  protected void addFilterRegisteredClients(String regionName,
-      ClientProxyMembershipID membershipID) throws RegionNotFoundException {
-    // Update Regions book keeping.
-    LocalRegion region = (LocalRegion)this._cache.getRegion(regionName);
-    if (region == null) {
-      //throw new AssertionError("Could not find region named '" + regionName + "'");
-      // @todo: see bug 36805
-      // fix for bug 37979
-      if (_logger.fineEnabled()) {
-        _logger
-          .fine("CacheClientNotifier: Client " + membershipID
-                + " :Throwing RegionDestroyedException as region: " + regionName + " is not present.");
-      }
-      throw new RegionDestroyedException("registerInterest failed", regionName);
-    }
-    else {
-      region.getFilterProfile().addFilterRegisteredClients(this, membershipID);
-    }
-  }
-  */
-  
+   * protected void addFilterRegisteredClients(String regionName, ClientProxyMembershipID
+   * membershipID) throws RegionNotFoundException { // Update Regions book keeping. LocalRegion
+   * region = (LocalRegion)this._cache.getRegion(regionName); if (region == null) { //throw new
+   * AssertionError("Could not find region named '" + regionName + "'"); // @todo: see bug 36805 //
+   * fix for bug 37979 if (_logger.fineEnabled()) { _logger .fine("CacheClientNotifier: Client " +
+   * membershipID + " :Throwing RegionDestroyedException as region: " + regionName +
+   * " is not present."); } throw new RegionDestroyedException("registerInterest failed",
+   * regionName); } else { region.getFilterProfile().addFilterRegisteredClients(this, membershipID);
+   * } }
+   */
+
-  public void updateMapOfEmptyRegions(Map regionsWithEmptyDataPolicy,
-      String regionName, int regionDataPolicy) {
+  public void updateMapOfEmptyRegions(Map regionsWithEmptyDataPolicy, String regionName,
+      int regionDataPolicy) {
-   * @param regionName
-   *          The name of the region of interest
-   * @param keyOfInterest
-   *          The name of the key of interest
-   * @param isClosing
-   *          Whether the caller is closing
-   * @param membershipID
-   *          The <code>ClientProxyMembershipID</code> of the client no longer
-   *          interested in this <code>Region</code> and key
+   * @param regionName The name of the region of interest
+   * @param keyOfInterest The name of the key of interest
+   * @param isClosing Whether the caller is closing
+   * @param membershipID The <code>ClientProxyMembershipID</code> of the client no longer interested
+   *        in this <code>Region</code> and key
-  public void unregisterClientInterest(String regionName, Object keyOfInterest,
-      int interestType, boolean isClosing, ClientProxyMembershipID membershipID, boolean keepalive)
-  {
+  public void unregisterClientInterest(String regionName, Object keyOfInterest, int interestType,
+      boolean isClosing, ClientProxyMembershipID membershipID, boolean keepalive) {
-      logger.debug("CacheClientNotifier: Client {} unregistering interest in: {} -> {} (an instance of {})", membershipID, regionName, keyOfInterest, keyOfInterest.getClass().getName());
+      logger.debug(
+          "CacheClientNotifier: Client {} unregistering interest in: {} -> {} (an instance of {})",
+          membershipID, regionName, keyOfInterest, keyOfInterest.getClass().getName());
-    if(proxy != null) {
+    if (proxy != null) {
-   * @param regionName
-   *          The name of the region of interest
-   * @param keysOfInterest
-   *          The list of keys of interest
-   * @param membershipID
-   *          The <code>ClientProxyMembershipID</code> of the client no longer
-   *          interested in this <code>Region</code> and key
+   * @param regionName The name of the region of interest
+   * @param keysOfInterest The list of keys of interest
+   * @param membershipID The <code>ClientProxyMembershipID</code> of the client no longer interested
+   *        in this <code>Region</code> and key
-      ClientProxyMembershipID membershipID, boolean isDurable,
-      boolean sendUpdatesAsInvalidates,
-      boolean manageEmptyRegions, int regionDataPolicy, boolean flushState) throws IOException, RegionDestroyedException
-  {
+      ClientProxyMembershipID membershipID, boolean isDurable, boolean sendUpdatesAsInvalidates,
+      boolean manageEmptyRegions, int regionDataPolicy, boolean flushState)
+      throws IOException, RegionDestroyedException {
-      logger.debug("CacheClientNotifier: Client {} registering interest in: {} -> {}", proxy, regionName, keysOfInterest);
+      logger.debug("CacheClientNotifier: Client {} registering interest in: {} -> {}", proxy,
+          regionName, keysOfInterest);
-    if(proxy == null){
-      throw new IOException(LocalizedStrings.CacheClientNotifier_CACHECLIENTPROXY_FOR_THIS_CLIENT_IS_NO_LONGER_ON_THE_SERVER_SO_REGISTERINTEREST_OPERATION_IS_UNSUCCESSFUL.toLocalizedString());
+    if (proxy == null) {
+      throw new IOException(
+          LocalizedStrings.CacheClientNotifier_CACHECLIENTPROXY_FOR_THIS_CLIENT_IS_NO_LONGER_ON_THE_SERVER_SO_REGISTERINTEREST_OPERATION_IS_UNSUCCESSFUL
+              .toLocalizedString());
-    
+
-    
+
-      updateMapOfEmptyRegions(proxy.getRegionsWithEmptyDataPolicy(), regionName,
-          regionDataPolicy);
-    }    
+      updateMapOfEmptyRegions(proxy.getRegionsWithEmptyDataPolicy(), regionName, regionDataPolicy);
+    }
-  
+
-   * @param regionName
-   *          The name of the region of interest
-   * @param keysOfInterest
-   *          The list of keys of interest
-   * @param isClosing
-   *          Whether the caller is closing
-   * @param membershipID
-   *          The <code>ClientProxyMembershipID</code> of the client no longer
-   *          interested in this <code>Region</code> and key
+   * @param regionName The name of the region of interest
+   * @param keysOfInterest The list of keys of interest
+   * @param isClosing Whether the caller is closing
+   * @param membershipID The <code>ClientProxyMembershipID</code> of the client no longer interested
+   *        in this <code>Region</code> and key
-  public void unregisterClientInterest(String regionName, List keysOfInterest,
-      boolean isClosing, ClientProxyMembershipID membershipID, boolean keepalive)
-  {
+  public void unregisterClientInterest(String regionName, List keysOfInterest, boolean isClosing,
+      ClientProxyMembershipID membershipID, boolean keepalive) {
-      logger.debug("CacheClientNotifier: Client {} unregistering interest in: {} -> {}", membershipID, regionName, keysOfInterest);
+      logger.debug("CacheClientNotifier: Client {} unregistering interest in: {} -> {}",
+          membershipID, regionName, keysOfInterest);
-   * If the conflatable is an instance of HAEventWrapper, and if the
-   * corresponding entry is present in the haContainer, set the
-   * reference to the clientUpdateMessage to null and putInProgress flag to
-   * false. Also, if the ref count is zero, then remove the entry from the
-   * haContainer.
+   * If the conflatable is an instance of HAEventWrapper, and if the corresponding entry is present
+   * in the haContainer, set the reference to the clientUpdateMessage to null and putInProgress flag
+   * to false. Also, if the ref count is zero, then remove the entry from the haContainer.
-      HAEventWrapper wrapper = (HAEventWrapper)conflatable;
+      HAEventWrapper wrapper = (HAEventWrapper) conflatable;
-        wrapper = (HAEventWrapper)haContainer.getKey(wrapper);
+        wrapper = (HAEventWrapper) haContainer.getKey(wrapper);
-        //else {
-          // This is a replay-of-event case.
-        //}
-      }
-      else {
+        // else {
+        // This is a replay-of-event case.
+        // }
+      } else {
-  public CacheClientProxy getClientProxy(ClientProxyMembershipID membershipID)
-  {
-    return (CacheClientProxy)this._clientProxies.get(membershipID);
+  public CacheClientProxy getClientProxy(ClientProxyMembershipID membershipID) {
+    return (CacheClientProxy) this._clientProxies.get(membershipID);
-   * Returns the CacheClientProxy associated to the membershipID. This
-   * looks at both proxies that are initialized and those that are still
-   * in initialization mode.
+   * Returns the CacheClientProxy associated to the membershipID. This looks at both proxies that
+   * are initialized and those that are still in initialization mode.
-      boolean proxyInInitMode)
-  {
-    CacheClientProxy proxy = getClientProxy(membershipID); 
+      boolean proxyInInitMode) {
+    CacheClientProxy proxy = getClientProxy(membershipID);
-      proxy = (CacheClientProxy)this._initClientProxies.get(membershipID);
+      proxy = (CacheClientProxy) this._initClientProxies.get(membershipID);
-  
+
-   * Returns the <code>CacheClientProxy</code> associated to the
-   * durableClientId
+   * Returns the <code>CacheClientProxy</code> associated to the durableClientId
-   * @return the <code>CacheClientProxy</code> associated to the
-   *         durableClientId
+   * @return the <code>CacheClientProxy</code> associated to the durableClientId
-  
+
-   * Returns the <code>CacheClientProxy</code> associated to the
-   * durableClientId.  This version of the method can check for initializing
-   * proxies as well as fully initialized proxies.
+   * Returns the <code>CacheClientProxy</code> associated to the durableClientId. This version of
+   * the method can check for initializing proxies as well as fully initialized proxies.
-   * @return the <code>CacheClientProxy</code> associated to the
-   *         durableClientId
+   * @return the <code>CacheClientProxy</code> associated to the durableClientId
-  public CacheClientProxy getClientProxy(String durableClientId, boolean proxyInInitMode)  {
+  public CacheClientProxy getClientProxy(String durableClientId, boolean proxyInInitMode) {
-    
+
-      CacheClientProxy clientProxy = (CacheClientProxy)i.next();
+      CacheClientProxy clientProxy = (CacheClientProxy) i.next();
-          logger.debug("CacheClientNotifier: {} represents the durable client {}", proxy, durableClientId);
+          logger.debug("CacheClientNotifier: {} represents the durable client {}", proxy,
+              durableClientId);
-        CacheClientProxy clientProxy = (CacheClientProxy)i.next();
+        CacheClientProxy clientProxy = (CacheClientProxy) i.next();
-            logger.debug("CacheClientNotifier: initializing client {} represents the durable client {}", proxy, durableClientId);
+            logger.debug(
+                "CacheClientNotifier: initializing client {} represents the durable client {}",
+                proxy, durableClientId);
-   * Returns the <code>CacheClientProxySameDS</code> associated to the
-   * membershipID   *
-   * @return the <code>CacheClientProxy</code> associated to the same
-   * distributed system
+   * Returns the <code>CacheClientProxySameDS</code> associated to the membershipID *
+   * 
+   * @return the <code>CacheClientProxy</code> associated to the same distributed system
-      logger.debug("{}::getClientProxySameDS(), Determining client for host {}", this, membershipID);
-      logger.debug("{}::getClientProxySameDS(), Number of proxies in the Cache Clinet Notifier: {}", this, getClientProxies().size());
-/*      _logger.fine(this + "::getClientProxySameDS(), Proxies in the Cache Clinet Notifier: "
-          + getClientProxies());*/
+      logger.debug("{}::getClientProxySameDS(), Determining client for host {}", this,
+          membershipID);
+      logger.debug("{}::getClientProxySameDS(), Number of proxies in the Cache Clinet Notifier: {}",
+          this, getClientProxies().size());
+      /*
+       * _logger.fine(this + "::getClientProxySameDS(), Proxies in the Cache Clinet Notifier: " +
+       * getClientProxies());
+       */
-      CacheClientProxy clientProxy  = (CacheClientProxy) i.next();
+      CacheClientProxy clientProxy = (CacheClientProxy) i.next();
-        proxy = clientProxy ;
+        proxy = clientProxy;
-          logger.debug("CacheClientNotifier: {} represents the client running on host {}", proxy, membershipID);
+          logger.debug("CacheClientNotifier: {} represents the client running on host {}", proxy,
+              membershipID);
-   * It will remove the clients connected to the passed acceptorId.
-   * If its the only server, shuts down this instance. 
+   * It will remove the clients connected to the passed acceptorId. If its the only server, shuts
+   * down this instance.
-      logger.debug("At cache server shutdown time, the number of cache servers in the cache is {}", this.getCache().getCacheServers().size());
+      logger.debug("At cache server shutdown time, the number of cache servers in the cache is {}",
+          this.getCache().getCacheServers().size());
-    
+
-      CacheClientProxy proxy = (CacheClientProxy)it.next();
-      if (proxy.getAcceptorId() != acceptorId){
+      CacheClientProxy proxy = (CacheClientProxy) it.next();
+      if (proxy.getAcceptorId() != acceptorId) {
-      }
-      catch (Exception ignore) {
+      } catch (Exception ignore) {
-    if (noActiveServer() && ccnSingleton != null){
+    if (noActiveServer() && ccnSingleton != null) {
-      
+
-    } 
+    }
-  private boolean noActiveServer(){
-    for (CacheServer server: this.getCache().getCacheServers()){
-      if (server.isRunning()){
+  private boolean noActiveServer() {
+    for (CacheServer server : this.getCache().getCacheServers()) {
+      if (server.isRunning()) {
-  
+
-   * Adds a new <code>CacheClientProxy</code> to the list of known client
-   * proxies
+   * Adds a new <code>CacheClientProxy</code> to the list of known client proxies
-   * @param proxy
-   *          The <code>CacheClientProxy</code> to add
+   * @param proxy The <code>CacheClientProxy</code> to add
-  protected void addClientProxy(CacheClientProxy proxy) throws IOException
-  {
-//    this._logger.info(LocalizedStrings.DEBUG, "adding client proxy " + proxy);
+  protected void addClientProxy(CacheClientProxy proxy) throws IOException {
+    // this._logger.info(LocalizedStrings.DEBUG, "adding client proxy " + proxy);
-      /* 
-       * #41788 - If the client connection init starts while cache/member is 
-       * shutting down, ClientHealthMonitor.getInstance() might return null.
+      /*
+       * #41788 - If the client connection init starts while cache/member is shutting down,
+       * ClientHealthMonitor.getInstance() might return null.
-  protected void addClientInitProxy(CacheClientProxy proxy) throws IOException
-  {
+  protected void addClientInitProxy(CacheClientProxy proxy) throws IOException {
-  protected void removeClientInitProxy(CacheClientProxy proxy) throws IOException
-  {
+  protected void removeClientInitProxy(CacheClientProxy proxy) throws IOException {
-  
-  protected boolean isProxyInInitializationMode(CacheClientProxy proxy) throws IOException
-  {
+
+  protected boolean isProxyInInitializationMode(CacheClientProxy proxy) throws IOException {
-  
-  
+
+
-   * Returns (possibly stale) set of memberIds for all clients being actively
-   * notified by this server.
+   * Returns (possibly stale) set of memberIds for all clients being actively notified by this
+   * server.
-  public Set getActiveClients()
-  {
+  public Set getActiveClients() {
-      CacheClientProxy proxy = (CacheClientProxy)iter.next();
+      CacheClientProxy proxy = (CacheClientProxy) iter.next();
+   * 
-  public Map getAllClients()
-  {
+  public Map getAllClients() {
-      CacheClientProxy proxy = (CacheClientProxy)iter.next();
+      CacheClientProxy proxy = (CacheClientProxy) iter.next();
-   * @param durableId -
-   *                id for the durable-client
+   * @param durableId - id for the durable-client
-  public boolean hasDurableClient(String durableId)
-  {
+  public boolean hasDurableClient(String durableId) {
-      CacheClientProxy proxy = (CacheClientProxy)iter.next();
+      CacheClientProxy proxy = (CacheClientProxy) iter.next();
-   * @param durableId -
-   *                id for the durable-client
+   * @param durableId - id for the durable-client
-  public boolean hasPrimaryForDurableClient(String durableId)
-  {
+  public boolean hasPrimaryForDurableClient(String durableId) {
-      CacheClientProxy proxy = (CacheClientProxy)iter.next();
+      CacheClientProxy proxy = (CacheClientProxy) iter.next();
-        }
-        else {
+        } else {
-   * Returns (possibly stale) map of queue sizes for all clients notified
-   * by this server.
+   * Returns (possibly stale) map of queue sizes for all clients notified by this server.
-  public Map getClientQueueSizes()
-  {
-    Map/*<ClientProxyMembershipID,Integer>*/ queueSizes = new HashMap();
+  public Map getClientQueueSizes() {
+    Map/* <ClientProxyMembershipID,Integer> */ queueSizes = new HashMap();
-      CacheClientProxy proxy = (CacheClientProxy)iter.next();
+      CacheClientProxy proxy = (CacheClientProxy) iter.next();
-  
+
-  
-  //closes the cq and drains the queue
-  public boolean closeClientCq(String durableClientId, String clientCQName) 
-  throws CqException {
+
+  // closes the cq and drains the queue
+  public boolean closeClientCq(String durableClientId, String clientCQName) throws CqException {
-  
+
-   * Removes an existing <code>CacheClientProxy</code> from the list of known
-   * client proxies
+   * Removes an existing <code>CacheClientProxy</code> from the list of known client proxies
-   * @param proxy
-   *          The <code>CacheClientProxy</code> to remove
+   * @param proxy The <code>CacheClientProxy</code> to remove
-  protected void removeClientProxy(CacheClientProxy proxy)
-  {
-//    this._logger.info(LocalizedStrings.DEBUG, "removing client proxy " + proxy, new Exception("stack trace"));
+  protected void removeClientProxy(CacheClientProxy proxy) {
+    // this._logger.info(LocalizedStrings.DEBUG, "removing client proxy " + proxy, new
+    // Exception("stack trace"));
-    ((GemFireCacheImpl)this.getCache()).cleanupForClient(this, client);
+    ((GemFireCacheImpl) this.getCache()).cleanupForClient(this, client);
-        chm.numOfClientsPerVersion
-            .decrementAndGet(proxy.getVersion().ordinal());
+        chm.numOfClientsPerVersion.decrementAndGet(proxy.getVersion().ordinal());
-    
+
-   * Returns an unmodifiable Collection of known 
-   * <code>CacheClientProxy</code> instances.
-   * The collection is not static so its contents may change.
+   * Returns an unmodifiable Collection of known <code>CacheClientProxy</code> instances. The
+   * collection is not static so its contents may change.
-  //  /**
-  //   * Returns the <code>Executor</code> that delivers messages to the
-  //   * <code>CacheClientProxy</code> instances.
-  //   * @return the <code>Executor</code> that delivers messages to the
-  //   * <code>CacheClientProxy</code> instances
-  //   */
-  //  protected Executor getExecutor()
-  //  {
-  //    return _executor;
-  //  }
+  // /**
+  // * Returns the <code>Executor</code> that delivers messages to the
+  // * <code>CacheClientProxy</code> instances.
+  // * @return the <code>Executor</code> that delivers messages to the
+  // * <code>CacheClientProxy</code> instances
+  // */
+  // protected Executor getExecutor()
+  // {
+  // return _executor;
+  // }
-        logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientNotifier_UNABLE_TO_CLOSE_CQS_FOR_THE_CLIENT__0, proxy.getProxyID()));
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.CacheClientNotifier_UNABLE_TO_CLOSE_CQS_FOR_THE_CLIENT__0,
+            proxy.getProxyID()));
-  
+
-  public boolean closeDurableClientProxy(String durableClientId) 
-  throws CacheException {
+  public boolean closeDurableClientProxy(String durableClientId) throws CacheException {
-    //we can probably remove the isPaused check
+    // we can probably remove the isPaused check
-    }
-    else {
+    } else {
-      throw new CacheException("Cannot close a running durable client : " + durableClientId){};
+      throw new CacheException("Cannot close a running durable client : " + durableClientId) {};
-  
+
-   * @param deadProxies
-   *          The list of <code>CacheClientProxy</code> instances to close
+   * @param deadProxies The list of <code>CacheClientProxy</code> instances to close
-      CacheClientProxy proxy = (CacheClientProxy)i.next();
+      CacheClientProxy proxy = (CacheClientProxy) i.next();
-      }
-      catch (CancelException e) {
+      } catch (CancelException e) {
+      } catch (Exception e) {
-      catch (Exception e) {
-      }
-      
+
-        logger.info(LocalizedMessage.create(LocalizedStrings.CacheClientNotifier_CACHECLIENTNOTIFIER_KEEPING_PROXY_FOR_DURABLE_CLIENT_NAMED_0_FOR_1_SECONDS_2, new Object[] {proxy.getDurableId(), Integer.valueOf(proxy.getDurableTimeout()), proxy}));
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.CacheClientNotifier_CACHECLIENTNOTIFIER_KEEPING_PROXY_FOR_DURABLE_CLIENT_NAMED_0_FOR_1_SECONDS_2,
+            new Object[] {proxy.getDurableId(), Integer.valueOf(proxy.getDurableTimeout()),
+                proxy}));
-  
+
-   * @param listener
-   *                The <code>InterestRegistrationListener</code> to register
+   * @param listener The <code>InterestRegistrationListener</code> to register
-  public void registerInterestRegistrationListener(
-      InterestRegistrationListener listener) {
+  public void registerInterestRegistrationListener(InterestRegistrationListener listener) {
-   * Unregisters an existing <code>InterestRegistrationListener</code> from
-   * the set of <code>InterestRegistrationListener</code>s.
+   * Unregisters an existing <code>InterestRegistrationListener</code> from the set of
+   * <code>InterestRegistrationListener</code>s.
-   * @param listener
-   *                The <code>InterestRegistrationListener</code> to
-   *                unregister
+   * @param listener The <code>InterestRegistrationListener</code> to unregister
-  public void unregisterInterestRegistrationListener(
-      InterestRegistrationListener listener) {
+  public void unregisterInterestRegistrationListener(InterestRegistrationListener listener) {
-   * Returns a read-only collection of <code>InterestRegistrationListener</code>s
-   * registered with this notifier.
+   * Returns a read-only collection of <code>InterestRegistrationListener</code>s registered with
+   * this notifier.
-   * @return a read-only collection of <code>InterestRegistrationListener</code>s
-   *         registered with this notifier
+   * @return a read-only collection of <code>InterestRegistrationListener</code>s registered with
+   *         this notifier
-  protected void notifyInterestRegistrationListeners(
-      InterestRegistrationEvent event) {
-    for (Iterator i = this.writableInterestRegistrationListeners.iterator(); i
-        .hasNext();) {
-      InterestRegistrationListener listener = (InterestRegistrationListener)i
-          .next();
+  protected void notifyInterestRegistrationListeners(InterestRegistrationEvent event) {
+    for (Iterator i = this.writableInterestRegistrationListeners.iterator(); i.hasNext();) {
+      InterestRegistrationListener listener = (InterestRegistrationListener) i.next();
-      }
-      else {
+      } else {
-  public CacheClientNotifierStats getStats()
-  {
+  public CacheClientNotifierStats getStats() {
-    LocalRegion region = (LocalRegion)event.getRegion();
+    LocalRegion region = (LocalRegion) event.getRegion();
-   * @param cache
-   *          The GemFire <code>Cache</code>
+   * @param cache The GemFire <code>Cache</code>
-   * @param listener a listener which should receive notifications
-   *          abouts queues being added or removed.
+   * @param listener a listener which should receive notifications abouts queues being added or
+   *        removed.
-  private CacheClientNotifier(Cache cache, CacheServerStats acceptorStats, 
-      int maximumMessageCount, int messageTimeToLive, 
-      ConnectionListener listener, List overflowAttributesList, boolean isGatewayReceiver) {
+  private CacheClientNotifier(Cache cache, CacheServerStats acceptorStats, int maximumMessageCount,
+      int messageTimeToLive, ConnectionListener listener, List overflowAttributesList,
+      boolean isGatewayReceiver) {
-    this.setCache((GemFireCacheImpl)cache);
+    this.setCache((GemFireCacheImpl) cache);
-    this.socketCloser = new SocketCloser(1, 50); // we only need one thread per client and wait 50ms for close
+    this.socketCloser = new SocketCloser(1, 50); // we only need one thread per client and wait 50ms
+                                                 // for close
-    this.logWriter = (InternalLogWriter)cache.getLogger();
+    this.logWriter = (InternalLogWriter) cache.getLogger();
-    this.securityLogWriter = (InternalLogWriter)cache.getSecurityLogger();
+    this.securityLogWriter = (InternalLogWriter) cache.getSecurityLogger();
-    StatisticsFactory factory ;
-    if(isGatewayReceiver){
+    StatisticsFactory factory;
+    if (isGatewayReceiver) {
-    }else{
-      factory = this.getCache().getDistributedSystem(); 
+    } else {
+      factory = this.getCache().getDistributedSystem();
-      this.logFrequency = Long.valueOf(System
-          .getProperty(MAX_QUEUE_LOG_FREQUENCY));
+      this.logFrequency = Long.valueOf(System.getProperty(MAX_QUEUE_LOG_FREQUENCY));
-    
-    eventEnqueueWaitTime = Integer.getInteger(EVENT_ENQUEUE_WAIT_TIME_NAME,
-        DEFAULT_EVENT_ENQUEUE_WAIT_TIME);
+
+    eventEnqueueWaitTime =
+        Integer.getInteger(EVENT_ENQUEUE_WAIT_TIME_NAME, DEFAULT_EVENT_ENQUEUE_WAIT_TIME);
-    
+
-   * this message is used to send interest registration to another server.
-   * Since interest registration performs a state-flush operation this
-   * message must not transmitted on an ordered socket
+   * this message is used to send interest registration to another server. Since interest
+   * registration performs a state-flush operation this message must not transmitted on an ordered
+   * socket
-  public static class ServerInterestRegistrationMessage extends HighPriorityDistributionMessage 
-  implements MessageWithReply {
+  public static class ServerInterestRegistrationMessage extends HighPriorityDistributionMessage
+      implements MessageWithReply {
-    
+
-    
-    public ServerInterestRegistrationMessage() { }
-    
-    static void sendInterestChange(DM dm,
-        ClientProxyMembershipID clientID,
+
+    public ServerInterestRegistrationMessage() {}
+
+    static void sendInterestChange(DM dm, ClientProxyMembershipID clientID,
-      ServerInterestRegistrationMessage smsg = new ServerInterestRegistrationMessage(
-          clientID, msg);
+      ServerInterestRegistrationMessage smsg = new ServerInterestRegistrationMessage(clientID, msg);
-  
-  
-    /* (non-Javadoc)
-     * @see org.apache.geode.distributed.internal.DistributionMessage#process(org.apache.geode.distributed.internal.DistributionManager)
+
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.geode.distributed.internal.DistributionMessage#process(org.apache.geode.
+     * distributed.internal.DistributionManager)
-          CacheClientProxy proxy = ccn.getClientProxy(clientId); 
-          // If this VM contains a proxy for the requested proxy id, forward the 
-          // message on to the proxy for processing 
-          if (proxy != null) { 
-            proxy.processInterestMessage(this.clientMessage); 
+          CacheClientProxy proxy = ccn.getClientProxy(clientId);
+          // If this VM contains a proxy for the requested proxy id, forward the
+          // message on to the proxy for processing
+          if (proxy != null) {
+            proxy.processInterestMessage(this.clientMessage);
-    /* (non-Javadoc)
+    /*
+     * (non-Javadoc)
+     * 
-    
+
-    
+
-    
+
-  
-  //   * Initializes the <code>QueuedExecutor</code> and
+
+  // * Initializes the <code>QueuedExecutor</code> and
-  //   * used to deliver messages to <code>CacheClientProxy</code> instances.
-  //   * @param logger The GemFire <code>LogWriterI18n</code>
-  //   */
-  //  private void initializeExecutors(LogWriterI18n logger)
-  //  {
-  //    // Create the thread groups
-  //    final ThreadGroup loggerGroup = LoggingThreadGroup.createThreadGroup("Cache
+  // * used to deliver messages to <code>CacheClientProxy</code> instances.
+  // * @param logger The GemFire <code>LogWriterI18n</code>
+  // */
+  // private void initializeExecutors(LogWriterI18n logger)
+  // {
+  // // Create the thread groups
+  // final ThreadGroup loggerGroup = LoggingThreadGroup.createThreadGroup("Cache
-  //    final ThreadGroup notifierGroup =
-  //      new ThreadGroup("Cache Client Notifier Group")
-  //      {
-  //        public void uncaughtException(Thread t, Throwable e)
-  //        {
-  //          Thread.dumpStack();
-  //          loggerGroup.uncaughtException(t, e);
-  //          //CacheClientNotifier.exceptionInThreads = true;
-  //        }
-  //      };
+  // final ThreadGroup notifierGroup =
+  // new ThreadGroup("Cache Client Notifier Group")
+  // {
+  // public void uncaughtException(Thread t, Throwable e)
+  // {
+  // Thread.dumpStack();
+  // loggerGroup.uncaughtException(t, e);
+  // //CacheClientNotifier.exceptionInThreads = true;
+  // }
+  // };
-  //    // Originally set ThreadGroup to be a daemon, but it was causing the
+  // // Originally set ThreadGroup to be a daemon, but it was causing the
-  //    // exception after five minutes of non-activity (the keep alive time of the
-  //    // threads in the PooledExecutor.
+  // // exception after five minutes of non-activity (the keep alive time of the
+  // // threads in the PooledExecutor.
-  //    // java.lang.IllegalThreadStateException
-  //    // at java.lang.ThreadGroup.add(Unknown Source)
-  //    // at java.lang.Thread.init(Unknown Source)
-  //    // at java.lang.Thread.<init>(Unknown Source)
-  //    // at
+  // // java.lang.IllegalThreadStateException
+  // // at java.lang.ThreadGroup.add(Unknown Source)
+  // // at java.lang.Thread.init(Unknown Source)
+  // // at java.lang.Thread.<init>(Unknown Source)
+  // // at
-  //    // at
+  // // at
-  //    // at
+  // // at
-  //    // at
+  // // at
-  //    // at
+  // // at
-  //    //notifierGroup.setDaemon(true);
+  // //notifierGroup.setDaemon(true);
-  //    if (USE_QUEUED_EXECUTOR)
-  //      createQueuedExecutor(notifierGroup);
-  //    else
-  //      createPooledExecutor(notifierGroup);
-  //  }
+  // if (USE_QUEUED_EXECUTOR)
+  // createQueuedExecutor(notifierGroup);
+  // else
+  // createPooledExecutor(notifierGroup);
+  // }
-  //  /**
-  //   * Creates the <code>QueuedExecutor</code> used to deliver messages
-  //   * to <code>CacheClientProxy</code> instances
-  //   * @param notifierGroup The <code>ThreadGroup</code> to which the
-  //   * <code>QueuedExecutor</code>'s <code>Threads</code> belong
-  //   */
-  //  protected void createQueuedExecutor(final ThreadGroup notifierGroup)
-  //  {
-  //    QueuedExecutor queuedExecutor = new QueuedExecutor(new LinkedQueue());
-  //    queuedExecutor.setThreadFactory(new ThreadFactory()
-  //      {
-  //        public Thread newThread(Runnable command)
-  //        {
-  //          Thread thread = new Thread(notifierGroup, command, "Queued Cache Client
+  // /**
+  // * Creates the <code>QueuedExecutor</code> used to deliver messages
+  // * to <code>CacheClientProxy</code> instances
+  // * @param notifierGroup The <code>ThreadGroup</code> to which the
+  // * <code>QueuedExecutor</code>'s <code>Threads</code> belong
+  // */
+  // protected void createQueuedExecutor(final ThreadGroup notifierGroup)
+  // {
+  // QueuedExecutor queuedExecutor = new QueuedExecutor(new LinkedQueue());
+  // queuedExecutor.setThreadFactory(new ThreadFactory()
+  // {
+  // public Thread newThread(Runnable command)
+  // {
+  // Thread thread = new Thread(notifierGroup, command, "Queued Cache Client
-  //          thread.setDaemon(true);
-  //          return thread;
-  //        }
-  //      });
-  //    _executor = queuedExecutor;
-  //  }
+  // thread.setDaemon(true);
+  // return thread;
+  // }
+  // });
+  // _executor = queuedExecutor;
+  // }
-  //  /**
-  //   * Creates the <code>PooledExecutor</code> used to deliver messages
-  //   * to <code>CacheClientProxy</code> instances
-  //   * @param notifierGroup The <code>ThreadGroup</code> to which the
-  //   * <code>PooledExecutor</code>'s <code>Threads</code> belong
-  //   */
+  // /**
+  // * Creates the <code>PooledExecutor</code> used to deliver messages
+  // * to <code>CacheClientProxy</code> instances
+  // * @param notifierGroup The <code>ThreadGroup</code> to which the
+  // * <code>PooledExecutor</code>'s <code>Threads</code> belong
+  // */
-  //  {
-  //    PooledExecutor pooledExecutor = new PooledExecutor(new
+  // {
+  // PooledExecutor pooledExecutor = new PooledExecutor(new
-  //    pooledExecutor.setMinimumPoolSize(10);
-  //    pooledExecutor.setKeepAliveTime(1000 * 60 * 5);
-  //    pooledExecutor.setThreadFactory(new ThreadFactory()
-  //      {
-  //      public Thread newThread(Runnable command)
-  //      {
-  //        Thread thread = new Thread(notifierGroup, command, "Pooled Cache Client
+  // pooledExecutor.setMinimumPoolSize(10);
+  // pooledExecutor.setKeepAliveTime(1000 * 60 * 5);
+  // pooledExecutor.setThreadFactory(new ThreadFactory()
+  // {
+  // public Thread newThread(Runnable command)
+  // {
+  // Thread thread = new Thread(notifierGroup, command, "Pooled Cache Client
-  //        thread.setDaemon(true);
-  //        return thread;
-  //      }
-  //    });
-  //    pooledExecutor.createThreads(5);
-  //    _executor = pooledExecutor;
-  //  }
+  // thread.setDaemon(true);
+  // return thread;
+  // }
+  // });
+  // pooledExecutor.createThreads(5);
+  // _executor = pooledExecutor;
+  // }
-  protected void deliverInterestChange(ClientProxyMembershipID proxyID, 
-    ClientInterestMessageImpl message) { 
-    DM dm = ((InternalDistributedSystem)this.getCache()
-        .getDistributedSystem()).getDistributionManager();
+  protected void deliverInterestChange(ClientProxyMembershipID proxyID,
+      ClientInterestMessageImpl message) {
+    DM dm = ((InternalDistributedSystem) this.getCache().getDistributedSystem())
+        .getDistributionManager();
-  } 
- 
+  }
+
-  
+
-  
-  public void addCompiledQuery(DefaultQuery query){
-    if (this.compiledQueries.putIfAbsent(query.getQueryString(), query) == null){
+
+  public void addCompiledQuery(DefaultQuery query) {
+    if (this.compiledQueries.putIfAbsent(query.getQueryString(), query) == null) {
-      if (logger.isDebugEnabled()){
-        logger.debug("Added compiled query into ccn.compliedQueries list. Query: {}. Total compiled queries: {}", query.getQueryString(), this._statistics.getCompiledQueryCount());
+      if (logger.isDebugEnabled()) {
+        logger.debug(
+            "Added compiled query into ccn.compliedQueries list. Query: {}. Total compiled queries: {}",
+            query.getQueryString(), this._statistics.getCompiledQueryCount());
-      startCompiledQueryCleanupThread();    
-    }        
+      startCompiledQueryCleanupThread();
+    }
-  
-  public Query getCompiledQuery(String queryString){
+
+  public Query getCompiledQuery(String queryString) {
-  private void clearCompiledQueries(){
-    if (this.compiledQueries.size() > 0){
+  private void clearCompiledQueries() {
+    if (this.compiledQueries.size() > 0) {
-      if (logger.isDebugEnabled()){
-        logger.debug("Removed all compiled queries from ccn.compliedQueries list. Total compiled queries: {}", this._statistics.getCompiledQueryCount());
-      } 
+      if (logger.isDebugEnabled()) {
+        logger.debug(
+            "Removed all compiled queries from ccn.compliedQueries list. Total compiled queries: {}",
+            this._statistics.getCompiledQueryCount());
+      }
-   * This starts the cleanup thread that periodically 
-   * (DefaultQuery.TEST_COMPILED_QUERY_CLEAR_TIME) checks for the 
-   * compiled queries that are not used and removes them.
+   * This starts the cleanup thread that periodically (DefaultQuery.TEST_COMPILED_QUERY_CLEAR_TIME)
+   * checks for the compiled queries that are not used and removes them.
-    if (isCompiledQueryCleanupThreadStarted){
-      return;  
+    if (isCompiledQueryCleanupThreadStarted) {
+      return;
-    
-    SystemTimer.SystemTimerTask task = new SystemTimer.SystemTimerTask() {   
+
+    SystemTimer.SystemTimerTask task = new SystemTimer.SystemTimerTask() {
-        for (Map.Entry<String, DefaultQuery> e : compiledQueries.entrySet()){
+        for (Map.Entry<String, DefaultQuery> e : compiledQueries.entrySet()) {
-          // Check if the query last used flag. 
-          // If its true set it to false. If its false it means it is not used 
-          // from the its last checked. 
+          // Check if the query last used flag.
+          // If its true set it to false. If its false it means it is not used
+          // from the its last checked.
-              if (isDebugEnabled){
-                logger.debug("Removed compiled query from ccn.compliedQueries list. Query: " + q.getQueryString() + ". Total compiled queries are : " + _statistics.getCompiledQueryCount());
+              if (isDebugEnabled) {
+                logger.debug("Removed compiled query from ccn.compliedQueries list. Query: "
+                    + q.getQueryString() + ". Total compiled queries are : "
+                    + _statistics.getCompiledQueryCount());
-    
+
-        long period = DefaultQuery.TEST_COMPILED_QUERY_CLEAR_TIME > 0 ? 
-            DefaultQuery.TEST_COMPILED_QUERY_CLEAR_TIME:DefaultQuery.COMPILED_QUERY_CLEAR_TIME;
+        long period = DefaultQuery.TEST_COMPILED_QUERY_CLEAR_TIME > 0
+            ? DefaultQuery.TEST_COMPILED_QUERY_CLEAR_TIME : DefaultQuery.COMPILED_QUERY_CLEAR_TIME;
-  
+
-      
+
-        
+
-        
+
-    CacheClientNotifier.this._cache.getCCPTimer()
-        .scheduleAtFixedRate(this.clientPingTask, CLIENT_PING_TASK_PERIOD,
-            CLIENT_PING_TASK_PERIOD);
+    CacheClientNotifier.this._cache.getCCPTimer().scheduleAtFixedRate(this.clientPingTask,
+        CLIENT_PING_TASK_PERIOD, CLIENT_PING_TASK_PERIOD);
-  //  /**
-  //   * Whether to synchonously deliver messages to proxies.
-  //   * This is currently hard-coded to true to ensure ordering.
-  //   */
-  //  protected static final boolean USE_SYNCHRONOUS_NOTIFICATION =
-  //    true;
-  //    Boolean.getBoolean("CacheClientNotifier.USE_SYNCHRONOUS_NOTIFICATION");
+  // /**
+  // * Whether to synchonously deliver messages to proxies.
+  // * This is currently hard-coded to true to ensure ordering.
+  // */
+  // protected static final boolean USE_SYNCHRONOUS_NOTIFICATION =
+  // true;
+  // Boolean.getBoolean("CacheClientNotifier.USE_SYNCHRONOUS_NOTIFICATION");
-  //  /**
-  //   * Whether to use the <code>QueuedExecutor</code> (or the
-  //   * <code>PooledExecutor</code>) to deliver messages to proxies.
-  //   * Currently, delivery is synchronous. No <code>Executor</code> is
-  //   * used.
-  //   */
-  //  protected static final boolean USE_QUEUED_EXECUTOR =
-  //    Boolean.getBoolean("CacheClientNotifier.USE_QUEUED_EXECUTOR");
+  // /**
+  // * Whether to use the <code>QueuedExecutor</code> (or the
+  // * <code>PooledExecutor</code>) to deliver messages to proxies.
+  // * Currently, delivery is synchronous. No <code>Executor</code> is
+  // * used.
+  // */
+  // protected static final boolean USE_QUEUED_EXECUTOR =
+  // Boolean.getBoolean("CacheClientNotifier.USE_QUEUED_EXECUTOR");
-   * The map of known <code>CacheClientProxy</code> instances.
-   * Maps ClientProxyMembershipID to CacheClientProxy.
-   * Note that the keys in this map are not updated when a durable client reconnects.
-   * To make sure you get the updated ClientProxyMembershipID use this map to
-   * lookup the CacheClientProxy and then call getProxyID on it.
+   * The map of known <code>CacheClientProxy</code> instances. Maps ClientProxyMembershipID to
+   * CacheClientProxy. Note that the keys in this map are not updated when a durable client
+   * reconnects. To make sure you get the updated ClientProxyMembershipID use this map to lookup the
+   * CacheClientProxy and then call getProxyID on it.
-  private final ConcurrentMap/*<ClientProxyMembershipID, CacheClientProxy>*/ _clientProxies
-    = new ConcurrentHashMap();
+  private final ConcurrentMap/* <ClientProxyMembershipID, CacheClientProxy> */ _clientProxies =
+      new ConcurrentHashMap();
-   * The map of <code>CacheClientProxy</code> instances which are getting 
-   * initialized.
-   * Maps ClientProxyMembershipID to CacheClientProxy.
+   * The map of <code>CacheClientProxy</code> instances which are getting initialized. Maps
+   * ClientProxyMembershipID to CacheClientProxy.
-  private final ConcurrentMap/*<ClientProxyMembershipID, CacheClientProxy>*/ _initClientProxies
-    = new ConcurrentHashMap();
+  private final ConcurrentMap/* <ClientProxyMembershipID, CacheClientProxy> */ _initClientProxies =
+      new ConcurrentHashMap();
-  private final HashSet<ClientProxyMembershipID> timedOutDurableClientProxies 
-    = new HashSet<ClientProxyMembershipID>();
+  private final HashSet<ClientProxyMembershipID> timedOutDurableClientProxies =
+      new HashSet<ClientProxyMembershipID>();
-   * The GemFire <code>Cache</code>.  Note that since this is a singleton class
-   * you should not use a direct reference to _cache in CacheClientNotifier code.
-   * Instead, you should always use <code>getCache()</code>
+   * The GemFire <code>Cache</code>. Note that since this is a singleton class you should not use a
+   * direct reference to _cache in CacheClientNotifier code. Instead, you should always use
+   * <code>getCache()</code>
-  
+
-   * the time (in seconds) after which a message in the client queue will
-   * expire.
+   * the time (in seconds) after which a message in the client queue will expire.
-   * A listener which receives notifications
-   * about queues that are added or removed
+   * A listener which receives notifications about queues that are added or removed
-   * haContainer can hold either the name of the client-messages-region
-   * (in case of eviction policies "mem" or "entry") or an instance of HashMap
-   * (in case of eviction policy "none"). In both the cases, it'll store
-   * HAEventWrapper as its key and ClientUpdateMessage as its value.
+   * haContainer can hold either the name of the client-messages-region (in case of eviction
+   * policies "mem" or "entry") or an instance of HashMap (in case of eviction policy "none"). In
+   * both the cases, it'll store HAEventWrapper as its key and ClientUpdateMessage as its value.
-  //   /**
-  //    * The singleton <code>CacheClientNotifier</code> instance
-  //    */
+  // /**
+  // * The singleton <code>CacheClientNotifier</code> instance
+  // */
-   * The size of the server-to-client communication socket buffers. This can be
-   * modified using the BridgeServer.SOCKET_BUFFER_SIZE system property.
+   * The size of the server-to-client communication socket buffers. This can be modified using the
+   * BridgeServer.SOCKET_BUFFER_SIZE system property.
-  static final private int socketBufferSize = Integer.getInteger(
-      "BridgeServer.SOCKET_BUFFER_SIZE", 32768).intValue();
+  static final private int socketBufferSize =
+      Integer.getInteger("BridgeServer.SOCKET_BUFFER_SIZE", 32768).intValue();
-  
-  /** 
-   * The <code>InterestRegistrationListener</code> instances registered in 
-   * this VM. This is used when modifying the set of listeners. 
-   */ 
-  private final Set writableInterestRegistrationListeners = new CopyOnWriteArraySet();
- 
-  /** 
-   * The <code>InterestRegistrationListener</code> instances registered in 
-   * this VM. This is used to provide a read-only <code>Set</code> of 
-   * listeners. 
-   */ 
-  private final Set readableInterestRegistrationListeners = Collections 
-      .unmodifiableSet(writableInterestRegistrationListeners); 
-  
+
-   * System property name for indicating how much frequently the "Queue full"
-   * message should be logged.
+   * The <code>InterestRegistrationListener</code> instances registered in this VM. This is used
+   * when modifying the set of listeners.
-  public static final String MAX_QUEUE_LOG_FREQUENCY = DistributionConfig.GEMFIRE_PREFIX + "logFrequency.clientQueueReachedMaxLimit";
+  private final Set writableInterestRegistrationListeners = new CopyOnWriteArraySet();
+
+  /**
+   * The <code>InterestRegistrationListener</code> instances registered in this VM. This is used to
+   * provide a read-only <code>Set</code> of listeners.
+   */
+  private final Set readableInterestRegistrationListeners =
+      Collections.unmodifiableSet(writableInterestRegistrationListeners);
+
+  /**
+   * System property name for indicating how much frequently the "Queue full" message should be
+   * logged.
+   */
+  public static final String MAX_QUEUE_LOG_FREQUENCY =
+      DistributionConfig.GEMFIRE_PREFIX + "logFrequency.clientQueueReachedMaxLimit";
-  public static final String EVENT_ENQUEUE_WAIT_TIME_NAME = DistributionConfig.GEMFIRE_PREFIX + "subscription.EVENT_ENQUEUE_WAIT_TIME";
+  public static final String EVENT_ENQUEUE_WAIT_TIME_NAME =
+      DistributionConfig.GEMFIRE_PREFIX + "subscription.EVENT_ENQUEUE_WAIT_TIME";
-   * System property value denoting the time in milliseconds. Any thread putting
-   * an event into a subscription queue, which is full, will wait this much time
-   * for the queue to make space. It'll then enque the event possibly causing
-   * the queue to grow beyond its capacity/max-size. See #51400.
+   * System property value denoting the time in milliseconds. Any thread putting an event into a
+   * subscription queue, which is full, will wait this much time for the queue to make space. It'll
+   * then enque the event possibly causing the queue to grow beyond its capacity/max-size. See
+   * #51400.
-  private final ConcurrentHashMap<String, DefaultQuery> compiledQueries = new ConcurrentHashMap<String, DefaultQuery>();
-  
+  private final ConcurrentHashMap<String, DefaultQuery> compiledQueries =
+      new ConcurrentHashMap<String, DefaultQuery>();
+
-  
+
-  
+
-  
+
-        && !HARegionQueue.HA_EVICTION_POLICY_NONE.equals(overflowAttributesList
-            .get(0))) {
-      haContainer = new HAContainerRegion(_cache.getRegion(Region.SEPARATOR
-          + CacheServerImpl.clientMessagesRegion((GemFireCacheImpl)_cache,
-              (String)overflowAttributesList.get(0),
-              ((Integer)overflowAttributesList.get(1)).intValue(),
-              ((Integer)overflowAttributesList.get(2)).intValue(),
-              (String)overflowAttributesList.get(3),
-              (Boolean)overflowAttributesList.get(4))));
-    }
-    else {
+        && !HARegionQueue.HA_EVICTION_POLICY_NONE.equals(overflowAttributesList.get(0))) {
+      haContainer = new HAContainerRegion(_cache.getRegion(
+          Region.SEPARATOR + CacheServerImpl.clientMessagesRegion((GemFireCacheImpl) _cache,
+              (String) overflowAttributesList.get(0),
+              ((Integer) overflowAttributesList.get(1)).intValue(),
+              ((Integer) overflowAttributesList.get(2)).intValue(),
+              (String) overflowAttributesList.get(3), (Boolean) overflowAttributesList.get(4))));
+    } else {
-    new ScheduledThreadPoolExecutor(1).schedule(
-        new ExpireBlackListTask(proxyID), 120, TimeUnit.SECONDS);
+    new ScheduledThreadPoolExecutor(1).schedule(new ExpireBlackListTask(proxyID), 120,
+        TimeUnit.SECONDS);

UPD66 UPD66 MOV65 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
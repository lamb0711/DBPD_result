GEODE-124: Add Auto-Rebalance trigger logic

* Add size threshold configuration
* Add logic to trigger rebalance if size to move is above threshold

-   * Use this configuration to provide out-of-balance audit. If the audit finds
-   * the system to be out-of-balance, it will trigger re-balancing. Any valid
-   * cron string is accepted. The first value represent second.
+   * Use this configuration to manage out-of-balance audit frequency. If the
+   * auditor finds the system to be out-of-balance, it will trigger
+   * re-balancing. Any valid cron string is accepted. The sub-expressions
+   * represent the following:
+   * <OL>
+   * <LI>Seconds
+   * <LI>Minutes
+   * <LI>Hours
+   * <LI>Day-of-Month
+   * <LI>Month
+   * <LI>Day-of-Week
+   * <LI>Year (optional field)
+   * 
-   * For. e.g. {@code 0 0 * * * *} for auditing the system every hour
+   * For. e.g. {@code 0 0 * * * ?} for auditing the system every hour
+   * Use this configuration to manage re-balance threshold. Rebalance operation
+   * will be triggered if the total number of bytes rebalance operation may move
+   * is more than this threshold, percentage of the total data size.
+   * <P>
+   * Default {@value AutoBalancer#DEFAULT_SIZE_THRESHOLD_PERCENT}
+   */
+  public static final String SIZE_THRESHOLD_PERCENT = "size-threshold-percent";
+
+  /**
+   * Default value of {@link AutoBalancer#SIZE_THRESHOLD_PERCENT}. If 10% of
+   * data is misplaced, its a good time to redistribute buckets
+   */
+  public static final int DEFAULT_SIZE_THRESHOLD_PERCENT = 10;
+
+  /**
-    if (props != null) {
-      String schedule = props.getProperty(SCHEDULE);
+    auditor.init(props);
-      auditor.init(props);
-      scheduler.init(schedule);
+    String schedule = null;
+    if (props != null) {
+      schedule = props.getProperty(SCHEDULE);
+    scheduler.init(schedule);
+    private int sizeThreshold = DEFAULT_SIZE_THRESHOLD_PERCENT;
+
+
+      if (props != null) {
+        if (props.getProperty(SIZE_THRESHOLD_PERCENT) != null) {
+          sizeThreshold = Integer.valueOf(props.getProperty(SIZE_THRESHOLD_PERCENT));
+          if (sizeThreshold <= 0 || sizeThreshold >= 100) {
+            throw new GemFireConfigException(SIZE_THRESHOLD_PERCENT + " should be integer, 1 to 99");
+          }
+        }
+      }
+
+        result = needsRebalancing();
+        if (!result) {
+          if (logger.isDebugEnabled()) {
+            logger.debug("Rebalancing is not needed");
+          }
+          return;
+        }
+
+
+    /**
+     * By default auto-balancer will avoid rebalancing, because a user can
+     * always trigger rebalance manually. So in case of error or inconsistent
+     * data, return false. Return true if
+     * <OL>
+     * <LI>total transfer size is above threshold percent of total data size at
+     * cluster level
+     * <LI>If some smaller capacity nodes are heavily loaded while bigger
+     * capacity nodes are balanced. In such a scenario transfer size based
+     * trigger may not cause rebalance.
+     */
+    boolean needsRebalancing() {
+      // test cluster level status
+      long transferSize = cacheFacade.getTotalTransferSize();
+      long totalSize = cacheFacade.getTotalDataSize();
+
+      if (totalSize > 0) {
+        int transferPercent = (int) ((100.0 * transferSize) / totalSize);
+        if (transferPercent >= sizeThreshold) {
+          return true;
+        }
+      }
+
+      // TODO test member level skew
+
+      return false;
+    }
+
+    public int getSizeThreshold() {
+      return sizeThreshold;
+    }
+    public long getTotalDataSize() {
+      // TODO Auto-generated method stub
+      return getTotalTransferSize();
+    }
+
+    @Override
+    public long getTotalTransferSize() {
+      try {
+        RebalanceOperation operation = getCache().getResourceManager().createRebalanceFactory().simulate();
+        RebalanceResults result = operation.getResults();
+        if (logger.isDebugEnabled()) {
+          logger.debug("Rebalance estimate: RebalanceResultsImpl [TotalBucketCreateBytes="
+              + result.getTotalBucketCreateBytes() + ", TotalBucketCreatesCompleted="
+              + result.getTotalBucketCreatesCompleted() + ", TotalBucketTransferBytes="
+              + result.getTotalBucketTransferBytes() + ", TotalBucketTransfersCompleted="
+              + result.getTotalBucketTransfersCompleted() + ", TotalPrimaryTransfersCompleted="
+              + result.getTotalPrimaryTransfersCompleted() + "]");
+        }
+        return result.getTotalBucketTransferBytes();
+      } catch (CancellationException e) {
+        logger.info("Error while trying to estimate rebalance cost ", e);
+      } catch (InterruptedException e) {
+        logger.info("Error while trying to estimate rebalance cost ", e);
+      }
+      return 0;
+    }
+
+    @Override
-      RebalanceOperation operation = getCache().getResourceManager().createRebalanceFactory().simulate();
+        RebalanceOperation operation = getCache().getResourceManager().createRebalanceFactory().start();
-        logger.info(result.getTotalBucketTransfersCompleted() + " " + result.getTotalBucketTransferBytes());
+        logger.info("Rebalance result: RebalanceResultsImpl [TotalBucketCreateBytes="
+            + result.getTotalBucketCreateBytes() + ", TotalBucketCreatesCompleted="
+            + result.getTotalBucketCreatesCompleted() + ", TotalBucketTransferBytes="
+            + result.getTotalBucketTransferBytes() + ", TotalBucketTransfersCompleted="
+            + result.getTotalBucketTransfersCompleted() + ", TotalPrimaryTransfersCompleted="
+            + result.getTotalPrimaryTransfersCompleted() + "]");
-        // TODO Auto-generated catch block
-        e.printStackTrace();
+        logger.info("Error rebalancing the cluster", e);
-        // TODO Auto-generated catch block
-        e.printStackTrace();
+        logger.info("Error rebalancing the cluster", e);
-    private GemFireCacheImpl getCache() {
+    GemFireCacheImpl getCache() {
+
+    long getTotalDataSize();
+
+    long getTotalTransferSize();

INS23 INS23 MOV31 INS29 INS83 INS83 INS83 INS43 INS59 INS29 INS83 INS83 INS83 INS39 INS59 MOV8 MOV60 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS65 INS42 INS42 INS45 INS65 INS42 INS34 MOV25 INS25 INS83 INS39 INS59 INS8 INS29 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS8 UPD39 UPD42 INS78 INS83 INS39 INS42 INS8 INS39 INS42 INS39 INS42 UPD66 UPD66 UPD66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS66 MOV27 INS8 INS42 INS42 MOV25 INS25 INS65 INS60 INS60 INS25 INS41 INS41 INS42 INS41 INS41 INS42 INS54 UPD66 INS67 INS67 INS33 INS21 INS27 INS8 INS8 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS39 INS59 INS39 INS59 INS27 INS8 INS9 INS42 INS32 INS8 INS34 INS8 INS12 INS12 INS42 INS42 INS42 INS42 INS7 INS42 INS33 INS25 INS21 INS25 MOV21 INS42 INS32 INS42 INS32 INS42 INS34 INS60 INS25 INS42 MOV60 MOV60 INS25 INS41 INS60 INS60 INS21 INS44 INS8 INS44 INS8 INS42 MOV32 INS27 INS8 INS7 INS38 INS8 INS42 INS42 INS42 INS42 INS39 INS59 INS27 INS8 INS32 INS8 INS32 INS43 INS59 INS43 INS59 INS32 INS43 INS42 INS21 INS43 INS42 INS21 INS32 INS33 INS21 INS25 INS42 INS32 INS42 INS25 INS41 INS42 INS11 INS42 INS42 INS41 INS42 INS42 MOV21 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS27 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS7 INS27 INS8 INS42 INS32 INS8 INS39 INS36 INS9 UPD42 INS42 INS45 UPD42 UPD42 INS42 INS45 UPD42 INS32 INS42 INS42 INS42 INS45 INS32 INS45 INS32 INS45 INS32 INS45 INS32 INS45 INS32 INS45 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS42 INS42 INS32 INS27 INS27 INS53 INS42 INS42 INS21 INS27 UPD42 MOV32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS34 INS42 INS34 INS14 INS32 INS36 INS42 INS45 INS32 INS45 INS32 INS45 INS45 INS45 INS32 UPD45 INS32 INS42 INS42 INS42 INS42 INS43 INS27 INS42 INS42 INS45 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS34 INS42 DEL25 DEL8 DEL8 DEL8 DEL8 DEL83
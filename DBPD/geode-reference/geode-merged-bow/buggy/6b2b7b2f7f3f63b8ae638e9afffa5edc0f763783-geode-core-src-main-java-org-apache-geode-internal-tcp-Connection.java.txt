GEODE-2684 Connection & ConnectionTable cleanup

removed dead code and indirect access of TcpConduit through the
connection table.

-  // We no longer support early ack
-  // public final static int EARLY_ACK_BIT = 0x10;
-  final ConnectionTable owner;
+  private final ConnectionTable owner;
+
+  private final TCPConduit conduit;
-  /**
-   * Returns the depth of unshared reader threads from this thread to the original
-   * non-reader-thread. E.g., ServerConnection -> reader(domino=1) -> reader(domino=2) ->
-   * reader(domino=3)
-   */
-  public static int getDominoCount() {
-    return dominoCount.get().intValue();
-  }
-
-  private final static void makeReaderThread(boolean v) {
+  private static void makeReaderThread(boolean v) {
-      P2P_CONNECT_TIMEOUT = 6 * this.owner.owner.getDM().getConfig().getMemberTimeout();
+      P2P_CONNECT_TIMEOUT = 6 * this.conduit.getDM().getConfig().getMemberTimeout();
-  /** the position of the next message's content */
-  // int nioMessageStart;
-
-  // byte nioMessageVersion;
+
+
-  private ReplySender replySender;
-
+    this.conduit = t.getConduit();
-    bytes[MSG_HEADER_ID_OFFSET] = (byte) ((MsgIdGenerator.NO_MSG_ID / 0x100) & 0xff);
+    bytes[MSG_HEADER_ID_OFFSET] = (byte) ((MsgIdGenerator.NO_MSG_ID >> 8) & 0xff);
+      assert my_okHandshakeBuf != null;
-        try {
-          // this.writerThread = Thread.currentThread();
-          this.output.write(my_okHandshakeBytes, 0, my_okHandshakeBytes.length);
-          this.output.flush();
-        } finally {
-          // this.writerThread = null;
-        }
+        assert my_okHandshakeBytes != null;
+        this.output.write(my_okHandshakeBytes, 0, my_okHandshakeBytes.length);
+        this.output.flush();
-   * @param beingSick
+   * @param beingSick test hook to simulate sickness in communications & membership
-    // connectHandshake.reset();
-    /**
+    /*
-    // this.output = new BufferedOutputStream(getSocket().getOutputStream(),
-    // owner.getConduit().bufferSize);
-    lenbytes[MSG_HEADER_ID_OFFSET] = (byte) ((MsgIdGenerator.NO_MSG_ID / 0x100) & 0xff);
+    lenbytes[MSG_HEADER_ID_OFFSET] = (byte) ((MsgIdGenerator.NO_MSG_ID >> 8) & 0xff);
-      try {
-        // this.writerThread = Thread.currentThread();
-        this.output.write(lenbytes, 0, lenbytes.length);
-        this.output.write(msg, 0, msg.length);
-        this.output.flush();
-      } finally {
-        // this.writerThread = null;
-      }
+      this.output.write(lenbytes, 0, lenbytes.length);
+      this.output.write(msg, 0, msg.length);
+      this.output.flush();
-          conn = new Connection(mgr, t, preserveOrder, remoteAddr, sharedResource);
+          conn = new Connection(t, preserveOrder, remoteAddr, sharedResource);
-    MembershipManager mgr = this.owner.owner.getMembershipManager();
+    MembershipManager mgr = this.conduit.getMembershipManager();
-  private Connection(MembershipManager mgr, ConnectionTable t, boolean preserveOrder,
-      DistributedMember remoteID, boolean sharedResource)
-      throws IOException, DistributedSystemDisconnectedException {
+  private Connection(ConnectionTable t, boolean preserveOrder, DistributedMember remoteID,
+      boolean sharedResource) throws IOException, DistributedSystemDisconnectedException {
+    this.conduit = t.getConduit();
-        /**
+        /*
-        int connectTime = getP2PConnectTimeout();;
+        int connectTime = getP2PConnectTimeout();
-        } catch (CancelledKeyException e) {
+        } catch (CancelledKeyException | ClosedSelectorException e) {
-        } catch (ClosedSelectorException e) {
-          // bug #44808: for some reason JRockit NIO thorws this runtime exception
-          // instead of an IOException on timeouts
-          ConnectException c = new ConnectException(
-              LocalizedStrings.Connection_ATTEMPT_TO_CONNECT_TIMED_OUT_AFTER_0_MILLISECONDS
-                  .toLocalizedString(new Object[] {connectTime}));
-          c.initCause(e);
-          throw c;
-        // socket = new Socket(remoteAddr.getInetAddress(), remoteAddr.getPort());
-  protected static final int BATCH_BUFFER_SIZE =
+  private static final int BATCH_BUFFER_SIZE =
-  protected static final int BATCH_FLUSH_MS =
-      Integer.getInteger("p2p.batchFlushTime", 50).intValue();
-  protected Object batchLock;
-  protected ByteBuffer fillBatchBuffer;
-  protected ByteBuffer sendBatchBuffer;
+  private static final int BATCH_FLUSH_MS = Integer.getInteger("p2p.batchFlushTime", 50).intValue();
+  private Object batchLock;
+  private ByteBuffer fillBatchBuffer;
+  private ByteBuffer sendBatchBuffer;
-                } catch (IOException ex) {
-                  logger.fatal(LocalizedMessage.create(
-                      LocalizedStrings.Connection_EXCEPTION_FLUSHING_BATCH_SEND_BUFFER_0, ex));
-                  readerShuttingDown = true;
-                  requestClose(LocalizedStrings.Connection_EXCEPTION_FLUSHING_BATCH_SEND_BUFFER_0
-                      .toLocalizedString(ex));
-                } catch (ConnectionException ex) {
+                } catch (IOException | ConnectionException ex) {
-  /**
-   * Used to close a connection that has not yet been registered with the distribution manager.
-   */
-  void closePartialConnect(String reason) {
-    close(reason, false, false, false, false);
-  }
-
-      if (this.owner.owner.config.getEnableNetworkPartitionDetection()
-          || this.owner.owner.getMemberId().getVmKind() == DistributionManager.ADMIN_ONLY_DM_TYPE
-          || this.owner.owner.getMemberId().getVmKind() == DistributionManager.LOCATOR_DM_TYPE) {
+      if (this.conduit.config.getEnableNetworkPartitionDetection()
+          || this.conduit.getMemberId().getVmKind() == DistributionManager.ADMIN_ONLY_DM_TYPE
+          || this.conduit.getMemberId().getVmKind() == DistributionManager.LOCATOR_DM_TYPE) {
+            // noinspection ConstantConditions
-          this.owner.owner.stats.incThreadOwnedReceivers(-1L, dominoCount.get());
+          this.conduit.stats.incThreadOwnedReceivers(-1L, dominoCount.get());
-    StringBuffer sb = new StringBuffer(64);
+    StringBuilder sb = new StringBuilder(64);
-    return (msg.indexOf("forcibly closed") >= 0) || (msg.indexOf("reset by peer") >= 0)
-        || (msg.indexOf("connection reset") >= 0);
+    return (msg.contains("forcibly closed")) || (msg.contains("reset by peer"))
+        || (msg.contains("connection reset"));
-              this.owner.owner.getCancelCriterion(), v);
+              this.conduit.getCancelCriterion(), v);
-        short msgId = (short) ((lenbytes[MSG_HEADER_ID_OFFSET] & 0xff * 0x100)
+        short msgId = (short) (((lenbytes[MSG_HEADER_ID_OFFSET] & 0xff) << 8)
-                this.owner.owner.stats.incThreadOwnedReceivers(1L, dominoNumber);
+                this.conduit.stats.incThreadOwnedReceivers(1L, dominoNumber);
-        // try { Thread.sleep(10); }
-        // catch (InterruptedException ie) {
-        // Thread.currentThread().interrupt();
-        // }
-
-      originalState = this.connectionState;;
+      originalState = this.connectionState;
-            try {
-              // this.writerThread = Thread.currentThread();
-              this.output.write(bytesToWrite);
-              this.output.flush();
-            } finally {
-              // this.writerThread = null;
-            }
+            this.output.write(bytesToWrite);
+            this.output.flush();
-  // private String socketInfo() {
-  // return (" socket: " + getSocket().getLocalAddress() + ":" + getSocket().getLocalPort() + " -> "
-  // +
-  // getSocket().getInetAddress() + ":" + getSocket().getPort() + " connection = " +
-  // System.identityHashCode(this));
-  //
-  // }
-
-  private final boolean addToQueue(ByteBuffer buffer, DistributionMessage msg, boolean force)
+  private boolean addToQueue(ByteBuffer buffer, DistributionMessage msg, boolean force)
-  private final boolean handleBlockedWrite(ByteBuffer buffer, DistributionMessage msg)
+  private boolean handleBlockedWrite(ByteBuffer buffer, DistributionMessage msg)
-  private final ByteBuffer takeFromOutgoingQueue() throws InterruptedException {
+  private ByteBuffer takeFromOutgoingQueue() throws InterruptedException {
-  private final boolean useSyncWrites(boolean forceAsync) {
+  private boolean useSyncWrites(boolean forceAsync) {
-  private final void writeAsync(SocketChannel channel, ByteBuffer buffer, boolean forceAsync,
+  private void writeAsync(SocketChannel channel, ByteBuffer buffer, boolean forceAsync,
-                  boolean interrupted = Thread.interrupted();;
+                  boolean interrupted = Thread.interrupted();
-  protected Object stateLock = new Object();
+  private final Object stateLock = new Object();
-  protected byte connectionState = STATE_IDLE;
+  private byte connectionState = STATE_IDLE;
-  protected static final String[] STATE_NAMES =
-      new String[] {"idle", "sending", "post_sending", "reading_ack", "received_ack", "reading"};
-  private static int ACK_SIZE = 1;
-  private static byte ACK_BYTE = 37;
-
-                  this.owner.owner.stats.incThreadOwnedReceivers(1L, dominoNumber);
+                  this.conduit.stats.incThreadOwnedReceivers(1L, dominoNumber);
+  protected TCPConduit getConduit() {
+    return this.conduit;
+  }
+
-  private final boolean useNIO() {
+  private boolean useNIO() {
-        if (os.indexOf("Windows") != -1) {
+        if (os.contains("Windows")) {

MOV23 MOV31 INS83 INS83 UPD43 UPD83 UPD83 UPD83 UPD83 UPD83 MOV8 UPD83 INS83 UPD83 INS83 INS43 INS42 UPD42 UPD42 INS21 INS21 MOV25 MOV25 MOV60 MOV60 MOV51 MOV21 INS54 UPD42 MOV42 INS41 INS7 MOV8 INS66 MOV8 INS7 UPD43 MOV8 MOV8 INS22 INS22 INS32 INS6 INS51 INS22 INS32 UPD42 MOV25 INS52 INS42 INS52 INS42 INS42 INS42 INS27 INS42 MOV8 INS22 INS52 INS42 INS42 INS42 UPD43 INS32 INS32 INS32 MOV32 MOV8 INS42 INS33 INS6 MOV52 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV45 MOV42 UPD42 MOV42 MOV45 MOV42 UPD42 MOV42 MOV45 INS25 INS21 MOV21 INS27 MOV32 MOV8 MOV8 MOV37 MOV7 INS32 UPD27 INS42 INS33 UPD27 MOV60 INS51 MOV42 UPD42 MOV42 MOV45 UPD34 UPD34 INS84 MOV22 INS22 INS42 MOV8 INS22 MOV43 MOV43 UPD42 INS22 MOV52 UPD42 MOV42 MOV52 UPD42 MOV42 MOV52 UPD42 MOV42 MOV22 INS36 UPD42 INS22 INS27 MOV52 UPD42 MOV42 MOV36 INS34 MOV34 INS84 MOV43 MOV43 MOV22 UPD42 MOV22 UPD42 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL41 DEL8 DEL31 DEL83 DEL22 DEL42 DEL22 DEL8 DEL54 DEL42 DEL51 DEL8 DEL8 DEL54 DEL8 DEL42 DEL22 DEL42 DEL22 DEL42 DEL43 DEL42 DEL44 DEL20 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL43 DEL40 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL4 DEL3 DEL32 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL40 DEL42 DEL32 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL42 DEL40 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL12 DEL42 DEL22 DEL22 DEL42 DEL22 DEL22 DEL42 DEL22 DEL42 DEL22 DEL32 DEL34 DEL27 DEL32 DEL34 DEL27 DEL32 DEL34 DEL27 DEL22 DEL42 DEL22 DEL34 DEL27 DEL42 DEL22 DEL20 DEL8 DEL54 DEL42 DEL51 DEL25 DEL54 DEL8 DEL83 DEL83 DEL83 DEL83 DEL83 DEL20 DEL83 DEL83 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL45 DEL45 DEL45 DEL45 DEL45 DEL45 DEL4 DEL3 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL42 DEL22 DEL66 DEL65 DEL29 DEL39 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL9 DEL9 DEL9 DEL9 DEL32 DEL21 DEL83 DEL32 DEL34 DEL38 DEL27
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-/** <p>ConnectionTable holds all of the Connection objects in a conduit.
-    Connections represent a pipe between two endpoints represented
-    by generic DistributedMembers.</p>
-
-    @since GemFire 2.1
-*/
+/**
+ * <p>
+ * ConnectionTable holds all of the Connection objects in a conduit. Connections represent a pipe
+ * between two endpoints represented by generic DistributedMembers.
+ * </p>
+ * 
+ * @since GemFire 2.1
+ */
-    Note: We no longer use InputMultiplexer
-    If InputMux is reinstated then the manager needs to be
-    initialized and all lines that have a NOMUX preface should be uncommented
-
-*/
-public class ConnectionTable  {
+ * Note: We no longer use InputMultiplexer If InputMux is reinstated then the manager needs to be
+ * initialized and all lines that have a NOMUX preface should be uncommented
+ * 
+ */
+public class ConnectionTable {
-  
+
-  //static java.util.Random random = new java.util.Random();
+  // static java.util.Random random = new java.util.Random();
-   * Used for messages whose order must be preserved
-   * Only connections used for sending messages,
-   * and receiving acks, will be put in this map.
+   * Used for messages whose order must be preserved Only connections used for sending messages, and
+   * receiving acks, will be put in this map.
-  
+
-   * ordered connections local to this thread.  Note that accesses to
-   * the resulting map must be synchronized because of static cleanup.
+   * ordered connections local to this thread. Note that accesses to the resulting map must be
+   * synchronized because of static cleanup.
-  
+
-  
+
-  
+
-   * Used to find connections owned by threads.
-   * The key is the same one used in threadOrderedConnMap.
-   * The value is an ArrayList since we can have any number of connections
+   * Used to find connections owned by threads. The key is the same one used in
+   * threadOrderedConnMap. The value is an ArrayList since we can have any number of connections
-  
+
-   * Used for all non-ordered messages.
-   * Only connections used for sending messages,
-   * and receiving acks, will be put in this map.
+   * Used for all non-ordered messages. Only connections used for sending messages, and receiving
+   * acks, will be put in this map.
-   * Used for all accepted connections. These connections are read only;
-   * we never send messages, except for acks; only receive.
+   * Used for all accepted connections. These connections are read only; we never send messages,
+   * except for acks; only receive.
-  //private final TCPConduit owner;
-  
+  // private final TCPConduit owner;
+
-  /** Number of seconds to wait before timing out an unused p2p reader thread. Default is 120 (2 minutes). */
-  private final static long READER_POOL_KEEP_ALIVE_TIME = Long.getLong("p2p.READER_POOL_KEEP_ALIVE_TIME", 120).longValue();
-  
+  /**
+   * Number of seconds to wait before timing out an unused p2p reader thread. Default is 120 (2
+   * minutes).
+   */
+  private final static long READER_POOL_KEEP_ALIVE_TIME =
+      Long.getLong("p2p.READER_POOL_KEEP_ALIVE_TIME", 120).longValue();
+
-  
+
-  
+
-  
+
-   * Cause calling thread to share communication
-   * resources with other threads.
+   * Cause calling thread to share communication resources with other threads.
+
-   * Cause calling thread to acquire exclusive access to
-   * communication resources.
-   * Exclusive access may not be available in which
-   * case this call is ignored.
+   * Cause calling thread to acquire exclusive access to communication resources. Exclusive access
+   * may not be available in which case this call is ignored.
+
-    
-//    Boolean b = getThreadOwnsResourcesRegistration();
-//    if (b == null) {
-//      // thread does not have a preference so return default
-//      return !this.owner.shareSockets;
-//      return false;
-//    } else {
-//      return b.booleanValue();
-//    }
+
+    // Boolean b = getThreadOwnsResourcesRegistration();
+    // if (b == null) {
+    // // thread does not have a preference so return default
+    // return !this.owner.shareSockets;
+    // return false;
+    // } else {
+    // return b.booleanValue();
+    // }
-  
+
-    return (Boolean)threadWantsOwnResources.get();
+    return (Boolean) threadWantsOwnResources.get();
-  
-//  public static void setThreadOwnsResourcesRegistration(
-//      Boolean newValue) {
-//    threadWantsOwnResources.set(newValue);
-//  }
+
+  // public static void setThreadOwnsResourcesRegistration(
+  // Boolean newValue) {
+  // threadWantsOwnResources.set(newValue);
+  // }
-  //private int lowWater;
-  //private int highWater;
+  // private int lowWater;
+  // private int highWater;
-//   private static boolean TRACK_SERVER_CONNECTIONS =
-//       System.getProperty("p2p.bidirectional", "true").equals("true");
+  // private static boolean TRACK_SERVER_CONNECTIONS =
+  // System.getProperty("p2p.bidirectional", "true").equals("true");
-    this.idleConnTimer = (this.owner.idleConnectionTimeout != 0) 
-        ? new SystemTimer(c.getDM().getSystem(), true)
-        : null;
+    this.idleConnTimer = (this.owner.idleConnectionTimeout != 0)
+        ? new SystemTimer(c.getDM().getSystem(), true) : null;
-  /*  NOMUX: if (TCPConduit.useNIO) {
-      inputMuxManager = new InputMuxManager(this);
-      inputMuxManager.start(c.logger);
-    }*/
+    /*
+     * NOMUX: if (TCPConduit.useNIO) { inputMuxManager = new InputMuxManager(this);
+     * inputMuxManager.start(c.logger); }
+     */
-  
-  private Executor createThreadPoolForIO(boolean conserveSockets) { 
-    Executor executor = null; 
-    final ThreadGroup connectionRWGroup = LoggingThreadGroup.createThreadGroup("P2P Reader Threads", logger);
-    if (conserveSockets) { 
-      executor = new Executor() { 
-        @Override 
-        public void execute(Runnable command) { 
-          Thread th = new Thread(connectionRWGroup, command); 
-          th.setDaemon(true); 
-          th.start(); 
-        } 
-      }; 
-    } 
-    else { 
-      BlockingQueue synchronousQueue = new SynchronousQueue(); 
-      ThreadFactory tf = new ThreadFactory() { 
-        public Thread newThread(final Runnable command) { 
-          Thread thread = new Thread(connectionRWGroup, command); 
-          thread.setDaemon(true); 
-          return thread; 
-        } 
-      }; 
-      executor = new ThreadPoolExecutor(1, Integer.MAX_VALUE, READER_POOL_KEEP_ALIVE_TIME, 
-          TimeUnit.SECONDS, synchronousQueue, tf); 
-    } 
-    return executor; 
-  } 
+
+  private Executor createThreadPoolForIO(boolean conserveSockets) {
+    Executor executor = null;
+    final ThreadGroup connectionRWGroup =
+        LoggingThreadGroup.createThreadGroup("P2P Reader Threads", logger);
+    if (conserveSockets) {
+      executor = new Executor() {
+        @Override
+        public void execute(Runnable command) {
+          Thread th = new Thread(connectionRWGroup, command);
+          th.setDaemon(true);
+          th.start();
+        }
+      };
+    } else {
+      BlockingQueue synchronousQueue = new SynchronousQueue();
+      ThreadFactory tf = new ThreadFactory() {
+        public Thread newThread(final Runnable command) {
+          Thread thread = new Thread(connectionRWGroup, command);
+          thread.setDaemon(true);
+          return thread;
+        }
+      };
+      executor = new ThreadPoolExecutor(1, Integer.MAX_VALUE, READER_POOL_KEEP_ALIVE_TIME,
+          TimeUnit.SECONDS, synchronousQueue, tf);
+    }
+    return executor;
+  }
-//   protected void connected() {
-//   /*  NOMUX: if (TCPConduit.useNIO) {
-//       inputMuxManager.connected();
-//     }*/
-//   }
+  // protected void connected() {
+  // /* NOMUX: if (TCPConduit.useNIO) {
+  // inputMuxManager.connected();
+  // }*/
+  // }
-  protected void acceptConnection(Socket sock) throws IOException, 
-      ConnectionException {
+  protected void acceptConnection(Socket sock) throws IOException, ConnectionException {
-//    boolean exceptionLogged = false;
+    // boolean exceptionLogged = false;
-      
+
-    
-    //Stub id = conn.getRemoteId();
+
+    // Stub id = conn.getRemoteId();
-          closeCon(LocalizedStrings.ConnectionTable_CONNECTION_TABLE_NO_LONGER_IN_USE.toLocalizedString(), conn);
+          closeCon(LocalizedStrings.ConnectionTable_CONNECTION_TABLE_NO_LONGER_IN_USE
+              .toLocalizedString(), conn);
-        logger.debug("Accepted {} myAddr={} theirAddr={}", conn, getConduit().getLocalAddress(), conn.remoteAddr);
+        logger.debug("Accepted {} myAddr={} theirAddr={}", conn, getConduit().getLocalAddress(),
+            conn.remoteAddr);
-   // cleanupHighWater();
+    // cleanupHighWater();
-//   /** returns the connection associated with the given key, or null if
-//       no such connection exists */
-//   protected Connection basicGet(Serializable id) {
-//     synchronized (this.orderedConnectionMap) {
-//       return (Connection) this.orderedConnectionMap.get(id);
-//     }
-//   }
+  // /** returns the connection associated with the given key, or null if
+  // no such connection exists */
+  // protected Connection basicGet(Serializable id) {
+  // synchronized (this.orderedConnectionMap) {
+  // return (Connection) this.orderedConnectionMap.get(id);
+  // }
+  // }
-//   protected Connection get(Serializable id) throws java.io.IOException {
-//     return get(id, false);
-//   }
+  // protected Connection get(Serializable id) throws java.io.IOException {
+  // return get(id, false);
+  // }
-      boolean preserveOrder,
-      Map m, PendingConnection pc, long startTime, long ackThreshold, long ackSAThreshold)
-      throws IOException, DistributedSystemDisconnectedException
-  {
+      boolean preserveOrder, Map m, PendingConnection pc, long startTime, long ackThreshold,
+      long ackSAThreshold) throws IOException, DistributedSystemDisconnectedException {
-      con = Connection.createSender(owner.getMembershipManager(), this, preserveOrder,
-                                    id,
-                                    sharedResource,
-                                    startTime, ackThreshold, ackSAThreshold);
+      con = Connection.createSender(owner.getMembershipManager(), this, preserveOrder, id,
+          sharedResource, startTime, ackThreshold, ackSAThreshold);
-    }
-    finally {
+    } finally {
-      }
-      else if (e == null) {
+      } else if (e == null) {
-        con.requestClose(LocalizedStrings.ConnectionTable_PENDING_CONNECTION_CANCELLED.toLocalizedString());
+        con.requestClose(
+            LocalizedStrings.ConnectionTable_PENDING_CONNECTION_CANCELLED.toLocalizedString());
-      }
-      else {
+      } else {
-          Connection newCon = (Connection)e;
+          Connection newCon = (Connection) e;
-              con.requestClose(LocalizedStrings.ConnectionTable_PENDING_CONNECTION_CLOSED.toLocalizedString());
+              con.requestClose(
+                  LocalizedStrings.ConnectionTable_PENDING_CONNECTION_CLOSED.toLocalizedString());
-          }
-          else {
+          } else {
-              con.requestClose(LocalizedStrings.ConnectionTable_SOMEONE_ELSE_CREATED_THE_CONNECTION.toLocalizedString());
+              con.requestClose(LocalizedStrings.ConnectionTable_SOMEONE_ELSE_CREATED_THE_CONNECTION
+                  .toLocalizedString());
-      logger.debug("handleNewPendingConnection {} myAddr={} theirAddr={}", con, getConduit().getLocalAddress(), con.remoteAddr);
+      logger.debug("handleNewPendingConnection {} myAddr={} theirAddr={}", con,
+          getConduit().getLocalAddress(), con.remoteAddr);
-   * unordered or conserve-sockets
-   * note that unordered connections are currently always shared
+   * unordered or conserve-sockets note that unordered connections are currently always shared
-  private Connection getUnorderedOrConserveSockets(DistributedMember id, 
-      boolean threadOwnsResources, boolean preserveOrder,
-      long startTime, long ackTimeout, long ackSATimeout)
-    throws IOException, DistributedSystemDisconnectedException
-    {
+  private Connection getUnorderedOrConserveSockets(DistributedMember id,
+      boolean threadOwnsResources, boolean preserveOrder, long startTime, long ackTimeout,
+      long ackSATimeout) throws IOException, DistributedSystemDisconnectedException {
-    
-    final Map m = preserveOrder ? this.orderedConnectionMap 
-        : this.unorderedConnectionMap;
+
+    final Map m = preserveOrder ? this.orderedConnectionMap : this.unorderedConnectionMap;
-    
+
-        Connection existingCon = (Connection)mEntry;
+        Connection existingCon = (Connection) mEntry;
-    
+
-                                          startTime, ackTimeout, ackSATimeout);
+          startTime, ackTimeout, ackSATimeout);
-    } else {  // we have existing connection
+    } else { // we have existing connection
-        
-        result = ((PendingConnection)mEntry).waitForConnect(
-            this.owner.getMembershipManager(), startTime,
-            ackTimeout, ackSATimeout);
+
+        result = ((PendingConnection) mEntry).waitForConnect(this.owner.getMembershipManager(),
+            startTime, ackTimeout, ackSATimeout);
-            logger.debug("getUnorderedOrConserveSockets {} myAddr={} theirAddr={}",
-                result, getConduit().getLocalAddress(), result.remoteAddr);
+            logger.debug("getUnorderedOrConserveSockets {} myAddr={} theirAddr={}", result,
+                getConduit().getLocalAddress(), result.remoteAddr);
-        result = (Connection)mEntry;
+        result = (Connection) mEntry;
-      
+
-    }
+  }
-  Connection getOrderedAndOwned(DistributedMember id, long startTime, long ackTimeout, long ackSATimeout) 
-      throws IOException, DistributedSystemDisconnectedException  {
+  Connection getOrderedAndOwned(DistributedMember id, long startTime, long ackTimeout,
+      long ackSATimeout) throws IOException, DistributedSystemDisconnectedException {
-    
+
-    Map m = (Map)this.threadOrderedConnMap.get();
+    Map m = (Map) this.threadOrderedConnMap.get();
-      // First time for this thread.  Create thread local
+      // First time for this thread. Create thread local
-          throw new DistributedSystemDisconnectedException(LocalizedStrings.ConnectionTable_CONNECTION_TABLE_IS_CLOSED.toLocalizedString());
+          throw new DistributedSystemDisconnectedException(
+              LocalizedStrings.ConnectionTable_CONNECTION_TABLE_IS_CLOSED.toLocalizedString());
-        for (Iterator it=this.threadConnMaps.iterator(); it.hasNext();) {
-          Reference r = (Reference)it.next();
+        for (Iterator it = this.threadConnMaps.iterator(); it.hasNext();) {
+          Reference r = (Reference) it.next();
-        result = (Connection)m.get(id);
+        result = (Connection) m.get(id);
-    
+
-    result = Connection.createSender(owner.getMembershipManager(), 
-        this, true /* preserveOrder */, id,
-        false /* shared */,
-        startTime, ackTimeout, ackSATimeout);
+    result = Connection.createSender(owner.getMembershipManager(), this, true /* preserveOrder */,
+        id, false /* shared */, startTime, ackTimeout, ackSATimeout);
-    this.owner.stats.incSenders(false/*shared*/, true /* preserveOrder */);
-    
+    this.owner.stats.incSenders(false/* shared */, true /* preserveOrder */);
+
-    
+
-      closeCon(LocalizedStrings.ConnectionTable_CONNECTION_TABLE_BEING_DESTROYED.toLocalizedString(), result);
+      closeCon(
+          LocalizedStrings.ConnectionTable_CONNECTION_TABLE_BEING_DESTROYED.toLocalizedString(),
+          result);
-    
-    ArrayList al = (ArrayList)this.threadConnectionMap.get(id);
+
+    ArrayList al = (ArrayList) this.threadConnectionMap.get(id);
-      // First connection for this DistributedMember.  Make sure list for this
+      // First connection for this DistributedMember. Make sure list for this
-      
+
-        al = (ArrayList)o;
+        al = (ArrayList) o;
-    
+
-    
+
-    
+
-  
+
-        synchronized(this) {
+        synchronized (this) {
-            this.getIdleConnTimer().scheduleAtFixedRate(task, 
-              this.owner.idleConnectionTimeout, this.owner.idleConnectionTimeout);
+            this.getIdleConnTimer().scheduleAtFixedRate(task, this.owner.idleConnectionTimeout,
+                this.owner.idleConnectionTimeout);
-      }
-      catch (IllegalStateException e) {
+      } catch (IllegalStateException e) {
-          LocalizedStrings.ConnectionTable_THE_DISTRIBUTED_SYSTEM_IS_SHUTTING_DOWN.toLocalizedString(),
-          cause);
+            LocalizedStrings.ConnectionTable_THE_DISTRIBUTED_SYSTEM_IS_SHUTTING_DOWN
+                .toLocalizedString(),
+            cause);
-  
+
+   * 
-  protected Connection get(DistributedMember id, boolean preserveOrder,
-      long startTime, long ackTimeout, long ackSATimeout) 
-      throws java.io.IOException, DistributedSystemDisconnectedException
-  {
+  protected Connection get(DistributedMember id, boolean preserveOrder, long startTime,
+      long ackTimeout, long ackSATimeout)
+      throws java.io.IOException, DistributedSystemDisconnectedException {
-      throw new DistributedSystemDisconnectedException(LocalizedStrings.ConnectionTable_CONNECTION_TABLE_IS_CLOSED.toLocalizedString());
+      throw new DistributedSystemDisconnectedException(
+          LocalizedStrings.ConnectionTable_CONNECTION_TABLE_IS_CLOSED.toLocalizedString());
-      result = getUnorderedOrConserveSockets(id, threadOwnsResources, preserveOrder, startTime, ackTimeout, ackSATimeout);
+      result = getUnorderedOrConserveSockets(id, threadOwnsResources, preserveOrder, startTime,
+          ackTimeout, ackSATimeout);
-  
+
-      logger.fatal(LocalizedMessage.create(LocalizedStrings.ConnectionTable_OUT_OF_FILE_DESCRIPTORS_USING_SHARED_CONNECTION));
+      logger.fatal(LocalizedMessage.create(
+          LocalizedStrings.ConnectionTable_OUT_OF_FILE_DESCRIPTORS_USING_SHARED_CONNECTION));
-      ((Connection)c).closePartialConnect(reason, beingSick); // fix for bug 31666
+      ((Connection) c).closePartialConnect(reason, beingSick); // fix for bug 31666
-      ((PendingConnection)c).notifyWaiters(null);
+      ((PendingConnection) c).notifyWaiters(null);
-   * returns the idle connection timer, or null if the connection table is closed.
-   * guarded by a sync on the connection table
+   * returns the idle connection timer, or null if the connection table is closed. guarded by a sync
+   * on the connection table
-    return this.idleConnTimer;    
+    return this.idleConnTimer;
-  
+
-   /* NOMUX if (inputMuxManager != null) {
-      inputMuxManager.stop();
-    }*/
+    /*
+     * NOMUX if (inputMuxManager != null) { inputMuxManager.stop(); }
+     */
-      for (Iterator it=this.orderedConnectionMap.values().iterator(); it.hasNext(); ) {
-        closeCon(LocalizedStrings.ConnectionTable_CONNECTION_TABLE_BEING_DESTROYED.toLocalizedString(), it.next());
+      for (Iterator it = this.orderedConnectionMap.values().iterator(); it.hasNext();) {
+        closeCon(
+            LocalizedStrings.ConnectionTable_CONNECTION_TABLE_BEING_DESTROYED.toLocalizedString(),
+            it.next());
-      for (Iterator it=this.unorderedConnectionMap.values().iterator(); it.hasNext(); ) {
-        closeCon(LocalizedStrings.ConnectionTable_CONNECTION_TABLE_BEING_DESTROYED.toLocalizedString(), it.next());
+      for (Iterator it = this.unorderedConnectionMap.values().iterator(); it.hasNext();) {
+        closeCon(
+            LocalizedStrings.ConnectionTable_CONNECTION_TABLE_BEING_DESTROYED.toLocalizedString(),
+            it.next());
-        for (Iterator it=this.threadConnMaps.iterator(); it.hasNext();) {
-          Reference r = (Reference)it.next();
-          Map m = (Map)r.get();
+        for (Iterator it = this.threadConnMaps.iterator(); it.hasNext();) {
+          Reference r = (Reference) it.next();
+          Map m = (Map) r.get();
-              for (Iterator mit=m.values().iterator(); mit.hasNext(); ) {
-                closeCon(LocalizedStrings.ConnectionTable_CONNECTION_TABLE_BEING_DESTROYED.toLocalizedString(), mit.next());
+              for (Iterator mit = m.values().iterator(); mit.hasNext();) {
+                closeCon(LocalizedStrings.ConnectionTable_CONNECTION_TABLE_BEING_DESTROYED
+                    .toLocalizedString(), mit.next());
-          ((ExecutorService)localExec).shutdown();
+          ((ExecutorService) localExec).shutdown();
-    
-    Map m = (Map)this.threadOrderedConnMap.get();
-    if(m != null)
-    {
+
+    Map m = (Map) this.threadOrderedConnMap.get();
+    if (m != null) {
-      }        
+      }
-  public void executeCommand(Runnable runnable) { 
+  public void executeCommand(Runnable runnable) {
-  
+
-   * Close all receiving threads.  This is used during shutdown and is also
-   * used by a test hook that makes us deaf to incoming messages.
+   * Close all receiving threads. This is used during shutdown and is also used by a test hook that
+   * makes us deaf to incoming messages.
+   * 
-      for (Iterator it=this.receivers.iterator(); it.hasNext();) {
-        Connection con = (Connection)it.next();
+      for (Iterator it = this.receivers.iterator(); it.hasNext();) {
+        Connection con = (Connection) it.next();
-          closeCon(LocalizedStrings.ConnectionTable_CONNECTION_TABLE_BEING_DESTROYED.toLocalizedString(), con, beingSick);
+          closeCon(
+              LocalizedStrings.ConnectionTable_CONNECTION_TABLE_BEING_DESTROYED.toLocalizedString(),
+              con, beingSick);
-      synchronized(connectingSockets) {
-        for (Iterator it = connectingSockets.entrySet().iterator(); it.hasNext(); ) {
-          Map.Entry entry = (Map.Entry)it.next();
-//          ConnectingSocketInfo info = (ConnectingSocketInfo)entry.getValue();
+      synchronized (connectingSockets) {
+        for (Iterator it = connectingSockets.entrySet().iterator(); it.hasNext();) {
+          Map.Entry entry = (Map.Entry) it.next();
+          // ConnectingSocketInfo info = (ConnectingSocketInfo)entry.getValue();
-            ((Socket)entry.getKey()).close();
+            ((Socket) entry.getKey()).close();
-  
-  
+
+
-   * Return true if our owner already knows that this endpoint is departing 
+   * Return true if our owner already knows that this endpoint is departing
-  
+
-  protected void removeEndpoint(DistributedMember memberID, String reason, boolean notifyDisconnect) {
+  protected void removeEndpoint(DistributedMember memberID, String reason,
+      boolean notifyDisconnect) {
-        ArrayList al = (ArrayList)cm.get(memberID);
+        ArrayList al = (ArrayList) cm.get(memberID);
-          ArrayList al = (ArrayList)cm.remove(memberID);
+          ArrayList al = (ArrayList) cm.remove(memberID);
-              for (Iterator it=al.iterator(); it.hasNext();) {
+              for (Iterator it = al.iterator(); it.hasNext();) {
-      synchronized(connectingSockets) {
-        for (Iterator it=connectingSockets.entrySet().iterator(); it.hasNext(); ) {
-          Map.Entry entry = (Map.Entry)it.next();
-          ConnectingSocketInfo info = (ConnectingSocketInfo)entry.getValue();
-          if (info.peerAddress.equals(((InternalDistributedMember)memberID).getInetAddress())) {
+      synchronized (connectingSockets) {
+        for (Iterator it = connectingSockets.entrySet().iterator(); it.hasNext();) {
+          Map.Entry entry = (Map.Entry) it.next();
+          ConnectingSocketInfo info = (ConnectingSocketInfo) entry.getValue();
+          if (info.peerAddress.equals(((InternalDistributedMember) memberID).getInetAddress())) {
-      for (Iterator it=toRemove.iterator(); it.hasNext(); ) {
-        Socket sock = (Socket)it.next();
+      for (Iterator it = toRemove.iterator(); it.hasNext();) {
+        Socket sock = (Socket) it.next();
-        }
-        catch (IOException e) {
+        } catch (IOException e) {
-            logger.debug("caught exception while trying to close connecting socket for {}", memberID, e);
+            logger.debug("caught exception while trying to close connecting socket for {}",
+                memberID, e);
-        for (Iterator it=receivers.iterator(); it.hasNext();) {
-          Connection con = (Connection)it.next();
+        for (Iterator it = receivers.iterator(); it.hasNext();) {
+          Connection con = (Connection) it.next();
-      for (Iterator it=toRemove.iterator(); it.hasNext(); ) {
-        Connection con = (Connection)it.next();
+      for (Iterator it = toRemove.iterator(); it.hasNext();) {
+        Connection con = (Connection) it.next();
-          throw new DistributedSystemDisconnectedException("Shutdown in progress", owner.getDM().getMembershipManager().getShutdownCause());
+          throw new DistributedSystemDisconnectedException("Shutdown in progress",
+              owner.getDM().getMembershipManager().getShutdownCause());
-      
+
-  
+
-  
+
-      for (Iterator it=receivers.iterator(); it.hasNext();) {
-        Connection con = (Connection)it.next();
+      for (Iterator it = receivers.iterator(); it.hasNext();) {
+        Connection con = (Connection) it.next();
-  
-  private static void removeFromThreadConMap(ConcurrentMap cm, DistributedMember stub, Connection c) {
+
+  private static void removeFromThreadConMap(ConcurrentMap cm, DistributedMember stub,
+      Connection c) {
-      ArrayList al = (ArrayList)cm.get(stub);
+      ArrayList al = (ArrayList) cm.get(stub);
+
-    /*if (this.closed) {
-      return;
-    }*/
+    /*
+     * if (this.closed) { return; }
+     */
-    Map m = (Map)this.threadOrderedConnMap.get();
+    Map m = (Map) this.threadOrderedConnMap.get();
-  void removeSharedConnection(String reason, DistributedMember stub, boolean ordered, Connection c) {
+
+  void removeSharedConnection(String reason, DistributedMember stub, boolean ordered,
+      Connection c) {
-  
+
-   * Clears lastInstance.  Does not yet close underlying sockets, but
-   * probably not strictly necessary.
+   * Clears lastInstance. Does not yet close underlying sockets, but probably not strictly
+   * necessary.
-  
+
-     synchronized (m) {
-       Iterator it = m.entrySet().iterator();
-       while (it.hasNext()) {
-         Map.Entry me = (Map.Entry)it.next();
-         DistributedMember stub = (DistributedMember)me.getKey();
-         Connection c = (Connection)me.getValue();
-         removeFromThreadConMap(this.threadConnectionMap, stub, c);
-         it.remove();
-         closeCon(LocalizedStrings.ConnectionTable_THREAD_FINALIZATION.toLocalizedString(), c);
-       } // while
-     } // synchronized m
+      synchronized (m) {
+        Iterator it = m.entrySet().iterator();
+        while (it.hasNext()) {
+          Map.Entry me = (Map.Entry) it.next();
+          DistributedMember stub = (DistributedMember) me.getKey();
+          Connection c = (Connection) me.getValue();
+          removeFromThreadConMap(this.threadConnectionMap, stub, c);
+          it.remove();
+          closeCon(LocalizedStrings.ConnectionTable_THREAD_FINALIZATION.toLocalizedString(), c);
+        } // while
+      } // synchronized m
-//    lastInstance = null; 
+    // lastInstance = null;
-   * records the current outgoing message count on all thread-owned
-   * ordered connections.  This does not synchronize or stop new connections
-   * from being formed or new messages from being sent
+   * records the current outgoing message count on all thread-owned ordered connections. This does
+   * not synchronize or stop new connections from being formed or new messages from being sent
+   * 
-  protected void getThreadOwnedOrderedConnectionState(DistributedMember member,
-      Map result) {
+  protected void getThreadOwnedOrderedConnectionState(DistributedMember member, Map result) {
-      ArrayList al = (ArrayList)cm.get(member);
+      ArrayList al = (ArrayList) cm.get(member);
-        synchronized(al) {
+        synchronized (al) {
-  
-        for (Iterator it=al.iterator(); it.hasNext(); ) {
-          Connection conn = (Connection)it.next();
-          if (!conn.isSharedResource() && conn.getOriginatedHere() 
-              && conn.getPreserveOrder()) {
+
+        for (Iterator it = al.iterator(); it.hasNext();) {
+          Connection conn = (Connection) it.next();
+          if (!conn.isSharedResource() && conn.getOriginatedHere() && conn.getPreserveOrder()) {
-  
+
-   * wait for the given incoming connections to receive at least the associated
-   * number of messages
+   * wait for the given incoming connections to receive at least the associated number of messages
-    if (Thread.interrupted()) throw new InterruptedException(); // wisest to do this before the synchronize below
+    if (Thread.interrupted())
+      throw new InterruptedException(); // wisest to do this before the synchronize below
-    synchronized(receivers) {
+    synchronized (receivers) {
-    for (Iterator it=r.iterator(); it.hasNext();) {
-      Connection con = (Connection)it.next();
+    for (Iterator it = r.iterator(); it.hasNext();) {
+      Connection con = (Connection) it.next();
-        Long state = (Long)connectionStates.remove(Long.valueOf(con.getUniqueId()));
+        Long state = (Long) connectionStates.remove(Long.valueOf(con.getUniqueId()));
-              logger.debug("Waiting for connection {}/{} currently={} need={}", 
+              logger.debug("Waiting for connection {}/{} currently={} need={}",
-        for (Iterator it=connectionStates.entrySet().iterator();
-            it.hasNext(); ) {
-          Map.Entry entry = (Map.Entry)it.next();
-          sb.append(entry.getKey())
-              .append('(')
-              .append(entry.getValue())
-              .append(')');
+        for (Iterator it = connectionStates.entrySet().iterator(); it.hasNext();) {
+          Map.Entry entry = (Map.Entry) it.next();
+          sb.append(entry.getKey()).append('(').append(entry.getValue()).append(')');
-//  public boolean isShuttingDown() {
-//    return this.owner.isShuttingDown();
-//  }
+  // public boolean isShuttingDown() {
+  // return this.owner.isShuttingDown();
+  // }
-  //protected void cleanupHighWater() {
-  //  cleanup(highWater);
-  //}
+  // protected void cleanupHighWater() {
+  // cleanup(highWater);
+  // }
-  //protected void cleanupLowWater() {
- //   cleanup(lowWater);
-  //}
+  // protected void cleanupLowWater() {
+  // cleanup(lowWater);
+  // }
-  //private void cleanup(int maxConnections) {
-  /*  if (maxConnections == 0 || maxConnections >= connections.size()) {
-      return;
-    }
-    while (connections.size() > maxConnections) {
-      Connection oldest = null;
-      synchronized(connections) {
-        for (Iterator iter = connections.values().iterator(); iter.hasNext(); ) {
-          Connection c = (Connection)iter.next();
-          if (oldest == null || c.getTimeStamp() < oldest.getTimeStamp()) {
-            oldest = c;
-          }
-        }
-      }
-      // sanity check - don't close anything fresher than 10 seconds or
-      // we'll start thrashing
-      if (oldest.getTimeStamp() > (System.currentTimeMillis() - 10000)) {
-        if (owner.lowWaterConnectionCount > 0) {
-          owner.lowWaterConnectionCount += 10;
-        }
-        if (owner.highWaterConnectionCount > 0) {
-          owner.highWaterConnectionCount += 10;
-        }
-          new Object[] {
-            owner.lowWaterConnectionCount,
-            owner.highWaterConnectionCount
-          });
-        break;
-      }
-      if (oldest != null) {
-        oldest.close();
-      }
-    }*/
-  //}
+  // private void cleanup(int maxConnections) {
+  /*
+   * if (maxConnections == 0 || maxConnections >= connections.size()) { return; } while
+   * (connections.size() > maxConnections) { Connection oldest = null; synchronized(connections) {
+   * for (Iterator iter = connections.values().iterator(); iter.hasNext(); ) { Connection c =
+   * (Connection)iter.next(); if (oldest == null || c.getTimeStamp() < oldest.getTimeStamp()) {
+   * oldest = c; } } } // sanity check - don't close anything fresher than 10 seconds or // we'll
+   * start thrashing if (oldest.getTimeStamp() > (System.currentTimeMillis() - 10000)) { if
+   * (owner.lowWaterConnectionCount > 0) { owner.lowWaterConnectionCount += 10; } if
+   * (owner.highWaterConnectionCount > 0) { owner.highWaterConnectionCount += 10; } new Object[] {
+   * owner.lowWaterConnectionCount, owner.highWaterConnectionCount }); break; } if (oldest != null)
+   * { oldest.close(); } }
+   */
+  // }
-  public void dumpConnectionTable() {
-    Iterator iter = connectionMap.keySet().iterator();
-    while (iter.hasNext()) {
-      Object key = iter.next();
-      Object val = connectionMap.get(key);
-    }
-  }
-  */
-  private /*static*/ class PendingConnection {
+   * public void dumpConnectionTable() { Iterator iter = connectionMap.keySet().iterator(); while
+   * (iter.hasNext()) { Object key = iter.next(); Object val = connectionMap.get(key); } }
+   */
+  private /* static */ class PendingConnection {
-    
+
-    
+
-    
+
-    
+
-    
+
-    
+
-    
+
+     * 
-     * @throws IOException 
+     * @throws IOException
-    public synchronized Connection waitForConnect(MembershipManager mgr,
-        long startTime, long ackTimeout, long ackSATimeout) throws IOException
-    {
-      if(connectingThread == Thread.currentThread()) {
+    public synchronized Connection waitForConnect(MembershipManager mgr, long startTime,
+        long ackTimeout, long ackSATimeout) throws IOException {
+      if (connectingThread == Thread.currentThread()) {
-      
-      final Map m = this.preserveOrder ? orderedConnectionMap
-          : unorderedConnectionMap;
+
+      final Map m = this.preserveOrder ? orderedConnectionMap : unorderedConnectionMap;
-        if (!this.pending) break;
+        if (!this.pending)
+          break;
-        
+
-        }
-        catch (InterruptedException ignore) {
+        } catch (InterruptedException ignore) {
-        }
-        finally {
+        } finally {
-        if (!this.pending) break;
+        if (!this.pending)
+          break;
-        if (!severeAlertIssued && ackSATimeout > 0  &&  startTime + ackTimeout < now) {
+        if (!severeAlertIssued && ackSATimeout > 0 && startTime + ackTimeout < now) {
-                new Object[] { targetMember, (ackSATimeout+ackTimeout)/1000 }));
+                new Object[] {targetMember, (ackSATimeout + ackTimeout) / 1000}));
-          }
-          else if (!suspected) {
+          } else if (!suspected) {
-                new Object[] { this.id, (ackTimeout)/1000 }));
-            ((GMSMembershipManager)mgr).suspectMember(targetMember,
+                new Object[] {this.id, (ackTimeout) / 1000}));
+            ((GMSMembershipManager) mgr).suspectMember(targetMember,
-        
+
-        //synchronized (m) {
-          e = m.get(this.id);
-        //}
+        // synchronized (m) {
+        e = m.get(this.id);
+        // }
-          continue;          
+          continue;
-        
+
-        
+
-        }
-        else if (e instanceof Connection) {
-          notifyWaiters((Connection)e);
+        } else if (e instanceof Connection) {
+          notifyWaiters((Connection) e);
-        }
-        else {
+        } else {
-          return ((PendingConnection)e).waitForConnect(mgr, startTime,
-              ackTimeout, ackSATimeout);
+          return ((PendingConnection) e).waitForConnect(mgr, startTime, ackTimeout, ackSATimeout);
-      
+
-  
+
-    
+
+
+
-    
+
-    lastInstance.set(ct);  
+    lastInstance.set(ct);
-    synchronized(connectingSockets) {
+    synchronized (connectingSockets) {
-  /** remove a socket from the tracked set.  It should be connected at this point */
+  /** remove a socket from the tracked set. It should be connected at this point */
-    synchronized(connectingSockets) {
+    synchronized (connectingSockets) {
-  
-  
+
+
+

INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
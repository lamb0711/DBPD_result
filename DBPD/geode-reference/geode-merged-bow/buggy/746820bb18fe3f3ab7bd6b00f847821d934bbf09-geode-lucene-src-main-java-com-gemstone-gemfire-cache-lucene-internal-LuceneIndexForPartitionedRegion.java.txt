GEODE-11: create index repository using raw Lucene directory.

GEODE-11: add RawDirectory using index instance

GEODE-11: add abstract class for index and repositoryManager

remove commented lines in test code

+import com.gemstone.gemfire.cache.lucene.internal.repository.RepositoryManager;
+import com.gemstone.gemfire.internal.cache.GemFireCacheImpl;
+  protected Region<String, File> fileRegion;
+  protected Region<ChunkKey, byte[]> chunkRegion;
+  protected final FileSystemStats fileSystemStats;
+
+    final String statsName = indexName + "-" + regionPath;
+    this.fileSystemStats = new FileSystemStats(cache.getDistributedSystem(), statsName);
-  @Override
-  public void initialize() {
-    if (!hasInitialized) {
-      /* create index region */
-      PartitionedRegion dataRegion = getDataRegion();
-      //assert dataRegion != null;
-      RegionAttributes regionAttributes = dataRegion.getAttributes();
-      DataPolicy dp = regionAttributes.getDataPolicy();
-      final boolean withPersistence = dp.withPersistence();
-      final boolean withStorage = regionAttributes.getPartitionAttributes().getLocalMaxMemory()>0;
-      RegionShortcut regionShortCut;
-      if (withPersistence) {
-        // TODO: add PartitionedRegionAttributes instead
-        regionShortCut = RegionShortcut.PARTITION_PERSISTENT;
-      } else {
-        regionShortCut = RegionShortcut.PARTITION;
-      }
+  protected RepositoryManager createRepositoryManager() {
+    RegionShortcut regionShortCut;
+    final boolean withPersistence = withPersistence(); 
+    RegionAttributes regionAttributes = dataRegion.getAttributes();
+    final boolean withStorage = regionAttributes.getPartitionAttributes().getLocalMaxMemory()>0;
-      // TODO: 1) dataRegion should be withStorage
-      //       2) Persistence to Persistence
-      //       3) Replicate to Replicate, Partition To Partition
-      //       4) Offheap to Offheap
-      if (!withStorage) {
-        throw new IllegalStateException("The data region to create lucene index should be with storage");
-      }
-
-      // create PR fileRegion, but not to create its buckets for now
-      final String fileRegionName = createFileRegionName();
-      PartitionAttributes partitionAttributes = dataRegion.getPartitionAttributes();
-      if (!fileRegionExists(fileRegionName)) {
-        fileRegion = createFileRegion(regionShortCut, fileRegionName, partitionAttributes, regionAttributes);
-      }
-
-      // create PR chunkRegion, but not to create its buckets for now
-      final String chunkRegionName = createChunkRegionName();
-      if (!chunkRegionExists(chunkRegionName)) {
-        chunkRegion = createChunkRegion(regionShortCut, fileRegionName, partitionAttributes, chunkRegionName, regionAttributes);
-      }
-      fileSystemStats.setFileSupplier(() -> (int) getFileRegion().getLocalSize());
-      fileSystemStats.setChunkSupplier(() -> (int) getChunkRegion().getLocalSize());
-      fileSystemStats.setBytesSupplier(() -> getChunkRegion().getPrStats().getDataStoreBytesInUse());
-
-      // we will create RegionDirectories on the fly when data comes in
-      HeterogeneousLuceneSerializer mapper = new HeterogeneousLuceneSerializer(getFieldNames());
-      repositoryManager = new PartitionedRepositoryManager(dataRegion, (PartitionedRegion) fileRegion,
-        (PartitionedRegion) chunkRegion, mapper, analyzer, this.indexStats, this.fileSystemStats);
-      
-      // create AEQ, AEQ listener and specify the listener to repositoryManager
-      createAEQ(dataRegion);
-
-      addExtension(dataRegion);
-      hasInitialized = true;
+    // TODO: 1) dataRegion should be withStorage
+    //       2) Persistence to Persistence
+    //       3) Replicate to Replicate, Partition To Partition
+    //       4) Offheap to Offheap
+    if (!withStorage) {
+      throw new IllegalStateException("The data region to create lucene index should be with storage");
-  }
+    if (withPersistence) {
+      // TODO: add PartitionedRegionAttributes instead
+      regionShortCut = RegionShortcut.PARTITION_PERSISTENT;
+    } else {
+      regionShortCut = RegionShortcut.PARTITION;
+    }
+    
+    // create PR fileRegion, but not to create its buckets for now
+    final String fileRegionName = createFileRegionName();
+    PartitionAttributes partitionAttributes = dataRegion.getPartitionAttributes();
+    if (!fileRegionExists(fileRegionName)) {
+      fileRegion = createFileRegion(regionShortCut, fileRegionName, partitionAttributes, regionAttributes);
+    }
-  private PartitionedRegion getDataRegion() {
-    return (PartitionedRegion) cache.getRegion(regionPath);
-  }
+    // create PR chunkRegion, but not to create its buckets for now
+    final String chunkRegionName = createChunkRegionName();
+    if (!chunkRegionExists(chunkRegionName)) {
+      chunkRegion = createChunkRegion(regionShortCut, fileRegionName, partitionAttributes, chunkRegionName, regionAttributes);
+    }
+    fileSystemStats.setFileSupplier(() -> (int) getFileRegion().getLocalSize());
+    fileSystemStats.setChunkSupplier(() -> (int) getChunkRegion().getLocalSize());
+    fileSystemStats.setBytesSupplier(() -> getChunkRegion().getPrStats().getDataStoreBytesInUse());
-  private PartitionedRegion getFileRegion() {
+    // we will create RegionDirectories on the fly when data comes in
+    HeterogeneousLuceneSerializer mapper = new HeterogeneousLuceneSerializer(getFieldNames());
+    return new PartitionedRepositoryManager(this, mapper);
+  }
+  
+  public PartitionedRegion getFileRegion() {
-  private PartitionedRegion getChunkRegion() {
+  public PartitionedRegion getChunkRegion() {
-  private AsyncEventQueueFactoryImpl createAEQFactory(final Region dataRegion) {
-    AsyncEventQueueFactoryImpl factory = (AsyncEventQueueFactoryImpl) cache.createAsyncEventQueueFactory();
-    factory.setParallel(true); // parallel AEQ for PR
-    factory.setMaximumQueueMemory(1000);
-    factory.setDispatcherThreads(1);
-    factory.setIsMetaQueue(true);
-    if(dataRegion.getAttributes().getDataPolicy().withPersistence()) {
-      factory.setPersistent(true);
-    }
-    factory.setDiskStoreName(dataRegion.getAttributes().getDiskStoreName());
-    factory.setDiskSynchronous(dataRegion.getAttributes().isDiskSynchronous());
-    factory.setForwardExpirationDestroy(true);
-    return factory;
+  public FileSystemStats getFileSystemStats() {
+    return fileSystemStats;
-
-  AsyncEventQueue createAEQ(Region dataRegion) {
-    return createAEQ(createAEQFactory(dataRegion));
-  }
-
-  private AsyncEventQueue createAEQ(AsyncEventQueueFactoryImpl factory) {
-    LuceneEventListener listener = new LuceneEventListener(repositoryManager);
-    String aeqId = LuceneServiceImpl.getUniqueIndexName(getName(), regionPath);
-    AsyncEventQueue indexQueue = factory.create(aeqId, listener);
-    return indexQueue;
-  }
-
+  

INS26 INS26 INS40 INS40 INS23 INS23 INS23 INS83 INS74 INS59 INS83 INS74 INS59 INS83 INS83 INS43 INS59 UPD83 INS43 INS42 MOV8 MOV60 MOV60 MOV25 UPD83 UPD83 UPD83 UPD43 UPD42 MOV43 INS43 INS43 INS42 MOV43 INS43 INS5 INS42 UPD42 MOV42 UPD42 MOV42 INS60 INS21 INS42 INS41 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS39 INS85 INS83 MOV43 INS59 INS7 INS14 UPD42 INS42 INS27 MOV22 INS14 MOV43 INS52 MOV42 INS42 INS45 INS42 INS43 INS32 INS42 INS42 INS42 INS42 DEL42 DEL78 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL42 DEL43 DEL42 DEL11 DEL42 DEL52 DEL42 DEL22 DEL14 DEL7 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL39 DEL42 DEL42 DEL38 DEL25 DEL8 DEL83 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL41 DEL8 DEL31 DEL83 DEL43 DEL42 DEL83 DEL42 DEL44 DEL43 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL42 DEL34 DEL32 DEL21 DEL42 DEL42 DEL34 DEL32 DEL21 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL32 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60
GEODE-7800: Add Redis PSUBSCRIBE and PUNSUBSCRIBE commands (#4705)

* GEODE-7800: Add Redis PSUBSCRIBE and PUNSUBSCRIBE commands

Similar to `SUBSCRIBE` and `UNSUBSCRIBE`, `PSUBSCRIBE` allows a client
to subscribe to a pattern. For example: `PSUBSCRIBE sal*s`

The subscription pattern is in the form of a glob supporting `*`, `?`
and ranges. https://redis.io/commands/psubscribe

Pattern subscriptions must be unsubscribed verbatim. i.e., the above
subscription would not be unsubscribed using the pattern `s*`, but must
be unsubscribed using the complete subscribed pattern, namely `sal*s`.

When clients subscribe to overlapping patterns (or channels) they will
receive a message for every matched subscription. Matches for a single
client are not conflated.

    Co-authored-by: Sarah Abbey <sabbey@pivotal.io>
    Co-authored-by: John Hutchison <jhutchison@pivotal.io>
    Co-authored-by: Jens Deppe <jdeppe@pivotal.io>

* Fixes class names in sanctioned-geode-redis-serializables.txt

* Fixes flaky test

* Adds license to PublishResult

* Clean code using spA and make test reliable

stop propagating exceptions that get thrown when disconnecting Jedis

* Cleans up subscribers and publishers after each test or after the whole class as needed

* re-add ignoreExceptions to waitfor test helper method

Co-authored-by: Jens Deppe <jdeppe@pivotal.io>
Co-authored-by: Venkateswara Prasath Durairaj <xtreme-prasath@users.noreply.github.com>

-class Subscriber {
+public abstract class AbstractSubscription implements Subscription {
-  public final Client client;
-  public final String channel;
-  private ExecutionHandlerContext context;
+  private final Client client;
+  private final ExecutionHandlerContext context;
-  public Subscriber(Client client, String channel, ExecutionHandlerContext context) {
+  AbstractSubscription(Client client, ExecutionHandlerContext context) {
+    if (client == null) {
+      throw new IllegalArgumentException("client cannot be null");
+    }
+    if (context == null) {
+      throw new IllegalArgumentException("context cannot be null");
+    }
-    this.channel = channel;
-  public boolean isEqualTo(String channel, Client client) {
-    if (channel == null || client == null) {
-      return false;
-    }
-    return channel.equals(this.channel) && client.equals(this.client);
-  }
-
-  public boolean publishMessage(String channel, String message) {
+  @Override
+  public PublishResult publishMessage(String channel, String message) {
-      return false;
+      return new PublishResult(client, false);
-    return writeToChannelSynchronously(messageByteBuffer);
+    return new PublishResult(client, writeToChannelSynchronously(messageByteBuffer));
+  }
+
+  Client getClient() {
+    return client;
+  }
+
+  @Override
+  public boolean matchesClient(Client client) {
+    return this.client.equals(client);
-   * This method turns the response into a synchronous call. We want to
-   * determine if the response, to the client, resulted in an error - for example if the client has
-   * disconnected and the write fails. In such cases we need to be able to notify the caller.
+   * This method turns the response into a synchronous call. We want to determine if the response,
+   * to the client, resulted in an error - for example if the client has disconnected and the write
+   * fails. In such cases we need to be able to notify the caller.
+

MOV31 INS83 INS83 INS42 INS43 INS31 UPD42 MOV42 UPD83 INS83 UPD42 INS78 INS43 INS43 INS42 INS8 INS78 INS42 INS8 INS25 INS25 INS42 INS42 INS42 INS41 INS42 MOV41 MOV27 INS8 INS27 INS8 INS14 INS42 MOV32 MOV42 UPD66 UPD66 UPD66 INS53 INS42 INS33 INS53 INS43 INS42 MOV32 INS42 INS14 INS14 INS14 INS42 INS43 INS45 INS43 INS45 INS43 INS42 INS9 INS42 INS42 INS42 DEL42 DEL83 DEL83 DEL43 DEL42 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL39 DEL9 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL52 DEL42 DEL22 DEL32 DEL27 DEL42 DEL33 DEL27 DEL27 DEL9 DEL41 DEL8 DEL25 DEL8
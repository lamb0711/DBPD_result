GEODE-5172: refactor txApplyPut to reuse RegionMapPut (#1917)

AbstractRegionMapPut has been introduced and has the common code used for both a non-tx put (RegionMapPut) and a transaction put being committed (RegionMapCommitPut).
RegionMapCommitPut is used by txApplyPut.
-import org.apache.geode.cache.query.internal.index.IndexManager;
-import org.apache.geode.internal.Assert;
-import org.apache.geode.internal.cache.DistributedRegion;
-public class RegionMapPut {
-  private final InternalRegion owner;
-  private final FocusedRegionMap focusedRegionMap;
-  private final EntryEventImpl event;
+public class RegionMapPut extends AbstractRegionMapPut {
+  private final CacheModificationLock cacheModificationLock;
+  private final EntryEventSerialization entryEventSerialization;
-  private final boolean uninitialized;
-  private final CacheModificationLock cacheModificationLock;
-  private final EntryEventSerialization entryEventSerialization;
-  private boolean clearOccured;
-  private long lastModifiedTime;
-  private RegionEntry regionEntry;
-  private boolean create;
-  private boolean completed;
+
-    if (owner == null) {
-      // "fix" for bug 32440
-      Assert.assertTrue(false, "The owner for RegionMap " + this + " is null for event " + event);
-    }
-    this.focusedRegionMap = focusedRegionMap;
-    this.owner = owner;
+    super(focusedRegionMap, owner, event);
-    this.event = event;
-    this.uninitialized = !owner.isInitialized();
-    this.replaceOnClient =
-        event.getOperation() == Operation.REPLACE && owner.getServerProxy() != null;
+    this.replaceOnClient = event.getOperation() == Operation.REPLACE && owner.hasServerProxy();
-    if (isCacheWrite()) {
-      if (getCacheWriter() == null && owner.getScope().isDistributed()) {
-        this.netWriteRecipients =
-            ((DistributedRegion) owner).getCacheDistributionAdvisor().adviseNetWrite();
-      } else {
-        this.netWriteRecipients = null;
-      }
+    if (isCacheWrite() && getCacheWriter() == null) {
+      this.netWriteRecipients = owner.adviseNetWrite();
-  private boolean isUninitialized() {
-    return uninitialized;
-  }
-
-  private boolean isRetrieveOldValueForDelta() {
+  boolean isRetrieveOldValueForDelta() {
-  private boolean isReplaceOnClient() {
+  boolean isReplaceOnClient() {
-  private boolean isOnlyExisting() {
-    return onlyExisting;
-  }
-
-  private boolean isCacheWrite() {
+  boolean isCacheWrite() {
-  private boolean getClearOccured() {
-    return clearOccured;
-  }
-
-  private void setClearOccured(boolean clearOccured) {
-    this.clearOccured = clearOccured;
-  }
-
-  private long getLastModifiedTime() {
-    return lastModifiedTime;
-  }
-
-  private void setLastModifiedTime(long lastModifiedTime) {
-    this.lastModifiedTime = lastModifiedTime;
-  }
-
-  private RegionEntry getRegionEntry() {
-    return regionEntry;
-  }
-
-  private void setRegionEntry(RegionEntry regionEntry) {
-    this.regionEntry = regionEntry;
-  }
-
-  /**
-   * @return true if put created a new entry; false if it updated an existing one.
-   */
-  private boolean isCreate() {
-    return create;
-  }
-
-  private void setCreate(boolean v) {
-    this.create = v;
-  }
-
-  private EntryEventImpl getEvent() {
-    return event;
-  }
-
-  private boolean isCompleted() {
-    return this.completed;
-  }
-
-  private void setCompleted(boolean b) {
-    this.completed = b;
-  }
-
-  private InternalRegion getOwner() {
-    return owner;
+  @Override
+  protected boolean isOnlyExisting() {
+    return onlyExisting;
-  private FocusedRegionMap getRegionMap() {
-    return focusedRegionMap;
+  @Override
+  protected boolean entryExists(RegionEntry regionEntry) {
+    return regionEntry != null && !regionEntry.isTombstone();
-  /**
-   * @return regionEntry if put completed, otherwise null.
-   */
-  public RegionEntry put() {
+  @Override
+  protected void serializeNewValueIfNeeded() {
-    runWhileLockedForCacheModification(this::doPut);
-    if (isCompleted()) {
-      return getRegionEntry();
-    } else {
-      return null;
-    }
-  private void doPut() {
-    try {
-      doWithIndexInUpdateMode(this::doPutRetryingIfNeeded);
-    } catch (DiskAccessException dae) {
-      getOwner().handleDiskAccessException(dae);
-      throw dae;
-    } finally {
-      doAfterPut();
-    }
-  }
-
-  private void doWithIndexInUpdateMode(Runnable r) {
-    final IndexManager oqlIndexManager = getInitializedIndexManager();
-    if (oqlIndexManager != null) {
-      try {
-        r.run();
-      } finally {
-        oqlIndexManager.countDownIndexUpdaters();
-      }
-    } else {
-      r.run();
-    }
-  }
-
-  private IndexManager getInitializedIndexManager() {
-    IndexManager oqlIndexManager;
-    // Fix for Bug #44431. We do NOT want to update the region and wait
-    // later for index INIT as region.clear() can cause inconsistency if
-    // happened in parallel as it also does index INIT.
-    oqlIndexManager = getOwner().getIndexManager();
-    if (oqlIndexManager != null) {
-      oqlIndexManager.waitForIndexInit();
-    }
-    return oqlIndexManager;
-  }
-
-  private void doPutRetryingIfNeeded() {
-    do {
-      setRegionEntry(null);
-      if (!findExistingEntry()) {
-        return;
-      }
-      createNewEntryIfNeeded();
-    } while (!addRegionEntryToMapAndDoPut());
-  }
-
-  private void runWhileLockedForCacheModification(Runnable r) {
+  @Override
+  protected void runWhileLockedForCacheModification(Runnable r) {
-
-  /**
-   * @return false if an existing entry was not found and this put requires
-   *         an existing one; otherwise returns true.
-   */
-  private boolean findExistingEntry() {
-    RegionEntry re = getRegionMap().getEntry(getEvent());
-    if (isOnlyExisting()) {
-      if (re == null || re.isTombstone()) {
-        return false;
-      }
-    }
-    setRegionEntry(re);
-    return true;
-  }
-
-  /**
-   * Stores the created entry in getRegionEntry.
-   */
-  private void createNewEntryIfNeeded() {
-    setCreate(getRegionEntry() == null);
-    if (isCreate()) {
-      final Object key = getEvent().getKey();
-      RegionEntry newEntry =
-          getRegionMap().getEntryFactory().createEntry(getOwner(), key, Token.REMOVED_PHASE1);
-      setRegionEntry(newEntry);
-    }
-  }
-
-  /**
-   * @return false if caller should retry
-   */
-  private boolean addRegionEntryToMapAndDoPut() {
-    synchronized (getRegionEntry()) {
-      putIfAbsentNewEntry();
-      return doPutOnRegionEntryInMap();
-    }
-  }
-
-  private void putIfAbsentNewEntry() {
-    if (isCreate()) {
-      RegionEntry oldRe = getRegionMap().putEntryIfAbsent(getEvent().getKey(), getRegionEntry());
-      if (oldRe != null) {
-        setCreate(false);
-        setRegionEntry(oldRe);
-      }
-    }
-  }
-
-  /**
-   * @return false if caller should retry because entry is no longer in the map
-   */
-  private boolean doPutOnRegionEntryInMap() {
-    final RegionEntry re = getRegionEntry();
-
-    synchronized (re) {
-      if (isRegionEntryRemoved()) {
-        return false;
-      }
-
-      setOldValueForDelta();
-      try {
-        setOldValueInEvent();
-        doPutIfPreconditionsPass();
-        return true;
-      } finally {
-        OffHeapHelper.release(getOldValueForDelta());
-        setOldValueForDelta(null);
-        if (isCreate() && re.getValueAsToken() == Token.REMOVED_PHASE1) {
-          // Region entry remove needs to be done while still synced on re.
-          getRegionMap().removeEntry(getEvent().getKey(), re, false);
-        }
-      }
-    }
-  }
-
-  private void doAfterPut() {
-    if (isCompleted()) {
-      try {
-        final boolean invokeListeners = getEvent().basicGetNewValue() != Token.TOMBSTONE;
-        getOwner().basicPutPart3(getEvent(), getRegionEntry(), !isUninitialized(),
-            getLastModifiedTime(), invokeListeners, isIfNew(), isIfOld(), getExpectedOldValue(),
-            isRequireOldValue());
-      } finally {
-        if (!getClearOccured()) {
-          try {
-            getRegionMap().lruUpdateCallback();
-          } catch (DiskAccessException dae) {
-            getOwner().handleDiskAccessException(dae);
-            throw dae;
-          }
-        }
-      }
-    } else {
-      getRegionMap().resetThreadLocals();
-    }
-  }
-
-  /**
-   * @return false if precondition indicates that
-   *         the put should not be done.
-   */
-  private boolean checkPreconditions() {
-    if (continueUpdate() && continueOverwriteDestroyed() && satisfiesExpectedOldValue()) {
-      return true;
-    }
-    return false;
-  }
-
-  private void doPutIfPreconditionsPass() {
-    if (!checkPreconditions()) {
-      return;
-    }
-    invokeCacheWriter();
-    runWithIndexUpdatingInProgress(this::doPutAndDeliverEvent);
-  }
-
-  private void doPutAndDeliverEvent() {
-    final EntryEventImpl event = getEvent();
-    createOrUpdateEntry();
-    if (isUninitialized()) {
-      event.inhibitCacheListenerNotification(true);
-    }
-    updateLru();
-
-    final RegionEntry re = getRegionEntry();
-    long lastModTime = getOwner().basicPutPart2(event, re, !isUninitialized(),
-        getLastModifiedTime(), getClearOccured());
-    setLastModifiedTime(lastModTime);
-    setCompleted(true);
-  }
-
-  private void runWithIndexUpdatingInProgress(Runnable r) {
-    notifyIndex(true);
-    try {
-      r.run();
-    } finally {
-      notifyIndex(false);
-    }
-  }
-
-  private void notifyIndex(boolean isUpdating) {
-    if (getOwner().getIndexMaintenanceSynchronous()) {
-      getRegionEntry().setUpdateInProgress(isUpdating);
-    }
-  }
-
-  private void createOrUpdateEntry() {
-    final EntryEventImpl event = getEvent();
-    try {
-      if (isUpdate()) {
-        updateEntry();
-      } else {
-        createEntry();
-      }
-      getOwner().recordEvent(event);
-    } catch (RegionClearedException rce) {
-      setClearOccured(true);
-      getOwner().recordEvent(event);
-    } catch (ConcurrentCacheModificationException ccme) {
-      VersionTag tag = event.getVersionTag();
-      if (tag != null && tag.isTimeStampUpdated()) {
-        getOwner().notifyTimestampsToGateways(event);
-      }
-      throw ccme;
-    }
-  }
-
-  private boolean isUpdate() {
-    if (isCacheWrite() && getEvent().getOperation().isUpdate()) {
-      // if there is a cacheWriter, type of event has already been set
-      return true;
-    }
-    if (isReplaceOnClient()) {
-      return true;
-    }
-    if (!getRegionEntry().isRemoved()) {
-      return true;
-    }
-    return false;
-  }
-
-  private void setOldValueForDelta() {
+  @Override
+  protected void setOldValueForDelta() {
-        // Old value is faulted in from disk if not found in memory.
-        // OFFHEAP: if we are synced on region entry no issue since we can use ARE's ref
-  /**
-   * If the re goes into removed2 state, it will be removed from the map.
-   *
-   * @return true if re was remove phase 2
-   */
-  private boolean isRegionEntryRemoved() {
-    final RegionEntry re = getRegionEntry();
-    if (re.isRemovedPhase2()) {
-      getOwner().getCachePerfStats().incRetries();
-      getRegionMap().getEntryMap().remove(getEvent().getKey(), re);
-      return true;
-    } else {
-      return false;
-    }
-  }
-
-  private boolean satisfiesExpectedOldValue() {
-    // replace is propagated to server, so no need to check
-    // satisfiesOldValue on client
-    final EntryEventImpl event = getEvent();
-    if (getExpectedOldValue() != null && !isReplaceOnClient()) {
-      assert event.getOperation().guaranteesOldValue();
-      // We already called setOldValueInEvent so the event will have the old value.
-      @Unretained
-      Object v = event.getRawOldValue();
-      // Note that v will be null instead of INVALID because setOldValue
-      // converts INVALID to null.
-      // But checkExpectedOldValue handle this and says INVALID equals null.
-      if (!AbstractRegionEntry.checkExpectedOldValue(getExpectedOldValue(), v, event.getRegion())) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  private void setOldValueInEvent() {
+  @Override
+  protected void setOldValueInEvent() {
-  private void createEntry() throws RegionClearedException {
-    final EntryEventImpl event = getEvent();
-    final RegionEntry re = getRegionEntry();
-    final boolean wasTombstone = re.isTombstone();
-    getRegionMap().processVersionTag(re, event);
-    event.putNewEntry(getOwner(), re);
-    updateSize(0, false, wasTombstone);
-    if (!event.getRegion().isInitialized()) {
-      getOwner().getImageState().removeDestroyedEntry(event.getKey());
-    }
+  @Override
+  protected void unsetOldValueForDelta() {
+    OffHeapHelper.release(getOldValueForDelta());
+    setOldValueForDelta(null);
-  private void updateEntry() throws RegionClearedException {
+  @Override
+  protected void invokeCacheWriter() {
-    final RegionEntry re = getRegionEntry();
-    final boolean wasTombstone = re.isTombstone();
-    final int oldSize = event.getRegion().calculateRegionEntryValueSize(re);
-    getRegionMap().processVersionTag(re, event);
-    event.putExistingEntry(event.getRegion(), re, isRequireOldValue(), getOldValueForDelta());
-    EntryLogger.logPut(event);
-    updateSize(oldSize, true/* isUpdate */, wasTombstone);
-  }
-
-  private void updateLru() {
-    if (!getClearOccured()) {
-      if (getEvent().getOperation().isCreate()) {
-        getRegionMap().lruEntryCreate(getRegionEntry());
-      } else {
-        getRegionMap().lruEntryUpdate(getRegionEntry());
-      }
-    }
-  }
-
-  private void invokeCacheWriter() {
-    final EntryEventImpl event = getEvent();
-    // invoke listeners only if region is initialized
-      // event.setOldValue already called in setOldValueInEvent
-
-      // bug #42638 for replaceOnClient, do not make the event create
-      // or update since replace must propagate to server
-      // block setting of old value in putNewValueNoSync, don't need it
-  private boolean continueOverwriteDestroyed() {
-    Token oldValueInVM = getRegionEntry().getValueAsToken();
-    // if region is under GII, check if token is destroyed
-    if (!isOverwriteDestroyed()) {
-      if (!getOwner().isInitialized()
-          && (oldValueInVM == Token.DESTROYED || oldValueInVM == Token.TOMBSTONE)) {
-        getEvent().setOldValueDestroyedToken();
-        return false;
+  @Override
+  protected void createOrUpdateEntry() {
+    try {
+      if (isUpdate()) {
+        updateEntry();
+      } else {
+        createEntry();
+      }
+    } catch (RegionClearedException rce) {
+      setClearOccurred(true);
+    } catch (ConcurrentCacheModificationException ccme) {
+      final EntryEventImpl event = getEvent();
+      VersionTag tag = event.getVersionTag();
+      if (tag != null && tag.isTimeStampUpdated()) {
+        getOwner().notifyTimestampsToGateways(event);
+      }
+      throw ccme;
+    }
+  }
+
+  @Override
+  protected void doBeforeCompletionActions() {
+    final EntryEventImpl event = getEvent();
+    getOwner().recordEvent(event);
+    if (!isOwnerInitialized()) {
+      event.inhibitCacheListenerNotification(true);
+    }
+    updateLru();
+
+    final RegionEntry re = getRegionEntry();
+    long lastModTime = getOwner().basicPutPart2(event, re, isOwnerInitialized(),
+        getLastModifiedTime(), isClearOccurred());
+    setLastModifiedTime(lastModTime);
+  }
+
+  private void updateLru() {
+    if (!isClearOccurred()) {
+      if (getEvent().getOperation().isCreate()) {
+        getRegionMap().lruEntryCreate(getRegionEntry());
+      } else {
+        getRegionMap().lruEntryUpdate(getRegionEntry());
-    if (isIfNew() && !Token.isRemoved(oldValueInVM)) {
-      return false;
+  }
+
+  @Override
+  protected boolean shouldCreatedEntryBeRemoved() {
+    return getRegionEntry().getValueAsToken() == Token.REMOVED_PHASE1;
+  }
+
+  @Override
+  protected void doAfterCompletionActions() {
+    if (isCompleted()) {
+      try {
+        final boolean invokeListeners = getEvent().basicGetNewValue() != Token.TOMBSTONE;
+        getOwner().basicPutPart3(getEvent(), getRegionEntry(), isOwnerInitialized(),
+            getLastModifiedTime(), invokeListeners, isIfNew(), isIfOld(), getExpectedOldValue(),
+            isRequireOldValue());
+      } finally {
+        if (!isClearOccurred()) {
+          try {
+            getRegionMap().lruUpdateCallback();
+          } catch (DiskAccessException dae) {
+            getOwner().handleDiskAccessException(dae);
+            throw dae;
+          }
+        }
+      }
+    } else {
+      getRegionMap().resetThreadLocals();
-    return true;
+  }
+
+  private boolean isUpdate() {
+    if (isCacheWrite() && getEvent().getOperation().isUpdate()) {
+      // if there is a cacheWriter, type of event has already been set
+      return true;
+    }
+    if (isReplaceOnClient()) {
+      return true;
+    }
+    if (!getRegionEntry().isRemoved()) {
+      return true;
+    }
+    return false;
+  }
+
+  /**
+   * @return false if precondition indicates that
+   *         the put should not be done.
+   */
+  @Override
+  protected boolean checkPreconditions() {
+    if (continueUpdate() && continueOverwriteDestroyed() && satisfiesExpectedOldValue()) {
+      return true;
+    }
+    return false;
+  private boolean continueOverwriteDestroyed() {
+    Token oldValueInVM = getRegionEntry().getValueAsToken();
+    // if region is under GII, check if token is destroyed
+    if (!isOverwriteDestroyed()) {
+      if (!getOwner().isInitialized()
+          && (oldValueInVM == Token.DESTROYED || oldValueInVM == Token.TOMBSTONE)) {
+        getEvent().setOldValueDestroyedToken();
+        return false;
+      }
+    }
+    if (isIfNew() && !Token.isRemoved(oldValueInVM)) {
+      return false;
+    }
+    return true;
+  }
+
+  private boolean satisfiesExpectedOldValue() {
+    // replace is propagated to server, so no need to check
+    // satisfiesOldValue on client
+    final EntryEventImpl event = getEvent();
+    if (getExpectedOldValue() != null && !isReplaceOnClient()) {
+      assert event.getOperation().guaranteesOldValue();
+      // We already called setOldValueInEvent so the event will have the old value.
+      @Unretained
+      Object v = event.getRawOldValue();
+      // Note that v will be null instead of INVALID because setOldValue
+      // converts INVALID to null.
+      // But checkExpectedOldValue handle this and says INVALID equals null.
+      if (!AbstractRegionEntry.checkExpectedOldValue(getExpectedOldValue(), v, event.getRegion())) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  private void createEntry() throws RegionClearedException {
+    final EntryEventImpl event = getEvent();
+    final RegionEntry re = getRegionEntry();
+    final boolean wasTombstone = re.isTombstone();
+    getRegionMap().processVersionTag(re, event);
+    event.putNewEntry(getOwner(), re);
+    updateSize(0, false, wasTombstone);
+    if (!event.getRegion().isInitialized()) {
+      getOwner().getImageState().removeDestroyedEntry(event.getKey());
+    }
+  }
+
+  private void updateEntry() throws RegionClearedException {
+    final EntryEventImpl event = getEvent();
+    final RegionEntry re = getRegionEntry();
+    final boolean wasTombstone = re.isTombstone();
+    final int oldSize = event.getRegion().calculateRegionEntryValueSize(re);
+    getRegionMap().processVersionTag(re, event);
+    event.putExistingEntry(event.getRegion(), re, isRequireOldValue(), getOldValueForDelta());
+    EntryLogger.logPut(event);
+    updateSize(oldSize, true/* isUpdate */, wasTombstone);
+  }
+
+

MOV23 MOV23 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 INS43 INS31 INS31 INS31 INS31 INS31 UPD42 MOV42 INS78 INS83 INS39 MOV42 MOV8 INS78 UPD83 MOV83 MOV39 UPD42 MOV42 MOV44 INS8 INS78 UPD83 MOV83 MOV39 UPD42 MOV42 MOV8 INS78 UPD83 INS78 UPD83 INS78 UPD83 INS78 UPD83 MOV83 MOV39 INS42 MOV8 INS78 UPD83 INS78 UPD83 INS78 UPD83 UPD42 INS78 UPD83 MOV83 INS39 UPD42 MOV42 INS8 INS78 UPD83 UPD42 INS78 UPD83 INS46 INS42 INS42 INS41 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV21 INS42 MOV41 INS42 INS42 INS42 INS42 INS42 MOV27 MOV8 INS27 INS38 MOV27 MOV32 UPD27 MOV27 INS38 INS32 INS32 INS40 MOV32 UPD42 INS32 MOV60 UPD42 MOV42 MOV32 INS32 UPD42 MOV32 INS42 UPD42 UPD42 MOV42 MOV42 UPD42 MOV42 UPD42 INS42 UPD42 INS32 UPD42 MOV42 UPD42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL59 DEL23 DEL42 DEL33 DEL27 DEL42 DEL42 DEL9 DEL45 DEL52 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL38 DEL7 DEL21 DEL33 DEL27 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL52 DEL42 DEL22 DEL33 DEL7 DEL21 DEL8 DEL25 DEL8 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL83 DEL83 DEL83 DEL39 DEL31 DEL83 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL42 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL42 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL42 DEL52 DEL42 DEL90 DEL32 DEL21 DEL42 DEL32 DEL42 DEL32 DEL41 DEL8 DEL33 DEL41 DEL8 DEL25 DEL83 DEL42 DEL43 DEL42 DEL42 DEL41 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL42 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL31 DEL83 DEL39 DEL42 DEL42 DEL52 DEL42 DEL90 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL31 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL83 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL33 DEL32 DEL21 DEL42 DEL32 DEL38 DEL41 DEL8 DEL25 DEL42 DEL32 DEL21 DEL8 DEL42 DEL32 DEL38 DEL19 DEL8 DEL31 DEL42 DEL32 DEL42 DEL42 DEL32 DEL40 DEL27 DEL27 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL9 DEL32 DEL21 DEL8 DEL25 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL32 DEL32 DEL27 DEL9 DEL41 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL9 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL42 DEL32 DEL21 DEL42 DEL32 DEL83 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL40 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL66 DEL65 DEL29 DEL39 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL42 DEL32 DEL41 DEL8 DEL51 DEL8 DEL31 DEL83 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL9 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL83 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL9 DEL41 DEL8 DEL25 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL9 DEL41 DEL8 DEL54 DEL8 DEL51 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL32 DEL38 DEL41 DEL8 DEL25 DEL42 DEL32 DEL21 DEL42 DEL52 DEL42 DEL90 DEL32 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL9 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL9 DEL32 DEL21 DEL8 DEL54 DEL8 DEL31 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL32 DEL32 DEL42 DEL32 DEL32 DEL38 DEL42 DEL9 DEL32 DEL21 DEL33 DEL9 DEL32 DEL38 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL83 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL21 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL9 DEL41 DEL8 DEL25 DEL8 DEL31
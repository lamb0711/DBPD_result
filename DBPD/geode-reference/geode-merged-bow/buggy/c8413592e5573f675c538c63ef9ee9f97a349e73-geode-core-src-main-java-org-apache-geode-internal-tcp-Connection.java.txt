GEODE-7727: modify sender thread to detect relese of connection (#4751)

* GEODE-7727: modify sender thread to detect relese of connection

* GEODE-7727: Update solution only for shared connections

* GEODE-7727: added test

* GEODE-7727: update ater comments

* GEODE-7727: update test

* GEODE-7727: fix for async write hanging

* GEODE-7727: Test of region operations in the face of closed connections

Adding a test for what happens to region operations when a connection is closed
out from under the system. This test hangs without the changes to let the
reader thread keep running.

Fix to test

* GEODE-7727: Preventing a double release of the input buffer

The releaseInputBuffer method was not thread safe. If it is called
concurrently, it will end up being released twice, which will add the buffer to
to the buffer pool twice. Later, this could result in two threads using the
same buffer, resulting in corruption of the buffer.

With the changes for GEODE-7727, we made it likely that releaseInputBuffer
would be called concurrently. If a member departs, one thread will call
Connection.close. Connection.close will close the socket and call
releaseInputBuffer. However, closing the socket will wake up the reader thread,
which will also call releaseInputBuffer concurrently.

Making releaseInputBuffer thread safe by introducing a lock.

* GEODE-7727: update after merge

* GEODE-7727: update test name

Co-authored-by: Dan Smith <upthewaterspout@apache.org>
+  /** Lock used to protect the input buffer */
+  public final Object inputBufferLock = new Object();
+
+  private boolean asyncMode;
+    asyncMode = false;
+    asyncMode = false;
+      } else {
+        if (sharedResource && !asyncMode) {
+          asyncClose(false);
+        }
-    ByteBuffer tmp = inputBuffer;
-    if (tmp != null) {
-      inputBuffer = null;
-      getBufferPool().releaseReceiveBuffer(tmp);
+    synchronized (inputBufferLock) {
+      ByteBuffer tmp = inputBuffer;
+      if (tmp != null) {
+        inputBuffer = null;
+        getBufferPool().releaseReceiveBuffer(tmp);
+      }
-
-          if (!isReceiver && (handshakeRead || handshakeCancelled)) {
+          if (!isHandShakeReader && !isReceiver && (handshakeRead || handshakeCancelled)) {
-            // Once we have read the handshake the reader can go away
-            break;
+
+            // Once we have read the handshake for unshared connections, the reader can skip
+            // processing messages
+            if (!sharedResource || asyncMode) {
+              break;
+            }
+
-      if (!isHandShakeReader) {
+      if (!isHandShakeReader || (sharedResource && !asyncMode)) {
+          if (preserveOrder && asyncDistributionTimeout != 0) {
+            asyncMode = true;
+          }
+

INS23 INS23 INS29 INS83 INS83 INS43 INS59 INS83 INS39 INS59 INS8 INS65 INS42 INS42 INS14 INS42 INS21 INS21 INS51 INS66 INS43 INS7 INS7 INS42 MOV8 INS42 INS42 INS9 INS42 INS9 INS8 INS27 INS25 INS25 MOV38 INS36 INS27 INS8 INS27 INS8 INS27 INS42 INS27 INS21 INS42 INS38 INS21 INS42 INS38 INS42 INS34 INS7 INS42 INS32 INS42 INS42 INS9 INS42 INS9 INS38 INS25 INS42 INS27 INS8 INS38 INS42 MOV10 INS42
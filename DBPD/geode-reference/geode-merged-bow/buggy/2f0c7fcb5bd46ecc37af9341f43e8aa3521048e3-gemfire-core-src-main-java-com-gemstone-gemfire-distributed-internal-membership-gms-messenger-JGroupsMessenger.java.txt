StateFlushOperation flushing/waiting for multicast messages

As part of the State Flush algorithm we record the state of the multicast
protocol in JGroups and send it to the initial image provider.  There the
information is used to wait for the on-wire multicast messages to be
received.

This change set also includes additional JGroupsMessenger tests for better code
coverage and fixes a few Find Bugs problems in that class and GMSJoinLeave.
One of these required replacing a volatile long with an AtomicLong because
the long was being incremented, which is not necessarily an atomic operation
on a volatile variable.

-import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
-import java.io.File;
-import java.io.OutputStream;
-import java.net.InetAddress;
+import java.util.concurrent.atomic.AtomicLong;
-import org.jgroups.Receiver;
+import org.jgroups.protocols.pbcast.NAKACK2;
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+
-  private static final String DEFAULT_JGROUPS_MCAST_CONFIG = "com/gemstone/gemfire/distributed/internal/membership/gms/messenger/jgroups-mcast.xml";
+  private static final String JGROUPS_MCAST_CONFIG_FILE_NAME = "com/gemstone/gemfire/distributed/internal/membership/gms/messenger/jgroups-mcast.xml";
-  Object nakackDigest;
-
-  protected volatile long pongsReceived;
+  protected AtomicLong pongsReceived = new AtomicLong(0);
+  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value="ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD")
-      r = DEFAULT_JGROUPS_MCAST_CONFIG;
+      r = JGROUPS_MCAST_CONFIG_FILE_NAME;
+  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value="ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD")
-    if (THROW_EXCEPTION_ON_START_HOOK) {
-      THROW_EXCEPTION_ON_START_HOOK = false;
+    if (JGroupsMessenger.THROW_EXCEPTION_ON_START_HOOK) {
+      JGroupsMessenger.THROW_EXCEPTION_ON_START_HOOK = false;
-    long pongsSnapshot = pongsReceived;
+    long pongsSnapshot = pongsReceived.longValue();
-    while (pongsReceived == pongsSnapshot && System.currentTimeMillis() < giveupTime) {
+    while (pongsReceived.longValue() == pongsSnapshot && System.currentTimeMillis() < giveupTime) {
-    return pongsReceived > pongsSnapshot;
+    return pongsReceived.longValue() > pongsSnapshot;
+  }
+  
+  @Override
+  public void getMessageState(InternalDistributedMember target, Map state, boolean includeMulticast) {
+    if (includeMulticast) {
+      NAKACK2 nakack = (NAKACK2)myChannel.getProtocolStack().findProtocol("NAKACK2");
+      if (nakack != null) {
+        long seqno = nakack.getCurrentSeqno();
+        state.put("JGroups.mcastState", Long.valueOf(seqno));
+      }
+    }
+  }
+  
+  @Override
+  public void waitForMessageState(InternalDistributedMember sender, Map state) throws InterruptedException {
+    NAKACK2 nakack = (NAKACK2)myChannel.getProtocolStack().findProtocol("NAKACK2");
+    Long seqno = (Long)state.get("JGroups.mcastState");
+    if (nakack != null && seqno != null) {
+      waitForMessageState(nakack, sender, seqno);
+    }
+  }
+  
+  /**
+   * wait for the mcast state from the given member to reach the given seqno 
+   */
+  protected void waitForMessageState(NAKACK2 nakack, InternalDistributedMember sender, Long seqno)
+    throws InterruptedException {
+    JGAddress jgSender = new JGAddress(sender);
+    Digest digest = nakack.getDigest(jgSender);
+    if (digest != null) {
+      for (;;) {
+        long[] senderSeqnos = digest.get(jgSender);
+        if (senderSeqnos == null || senderSeqnos[0] >= seqno.longValue()) {
+          break;
+        }
+        Thread.sleep(50);
+      }
+    }
-        pongsReceived++;
+        pongsReceived.incrementAndGet();

MOV26 MOV26 MOV26 MOV23 UPD40 UPD40 INS31 INS31 INS31 INS83 UPD43 INS77 INS77 INS78 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS8 UPD42 UPD42 UPD42 INS14 INS40 INS80 INS40 INS80 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS25 INS42 INS43 INS42 INS43 INS42 INS42 INS60 INS60 INS25 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS60 INS60 INS25 INS43 INS34 INS42 INS45 INS42 INS45 INS40 INS42 INS42 INS42 INS8 INS42 INS42 INS43 INS59 INS43 INS59 INS27 INS8 INS66 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS27 INS8 INS42 INS32 INS32 INS60 INS25 INS42 INS42 INS11 INS42 INS42 INS11 INS27 INS27 INS21 INS42 INS42 INS14 INS42 INS42 INS32 INS42 INS33 INS24 INS42 INS42 INS32 INS42 INS42 INS43 INS59 INS27 INS8 INS43 INS32 INS43 INS32 INS42 INS33 INS42 INS33 INS32 INS43 INS42 INS42 INS42 INS42 INS8 UPD42 INS40 INS42 INS42 INS42 INS42 INS11 INS42 INS33 INS60 INS21 INS42 INS32 INS42 INS45 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS60 INS25 INS21 INS43 INS32 INS39 INS59 INS32 INS42 INS42 INS5 INS59 INS27 INS8 INS32 INS32 INS42 INS32 INS42 INS45 INS42 INS32 INS42 INS42 INS45 INS32 INS39 INS85 UPD42 MOV42 INS32 INS27 INS27 INS10 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS2 INS32 INS42 INS34 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL83 DEL83 DEL39 DEL59 DEL23 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL37
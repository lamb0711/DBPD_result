GEODE-7089: Each client registration thread uses its own queue

Co-authored-by: Ryan McMahon <rmcmahon@pivotal.io>
Co-authored-by: Donal Evans <doevans@pivotal.io>
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.locks.ReadWriteLock;
-import java.util.concurrent.locks.ReentrantLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+import org.apache.geode.internal.concurrent.ConcurrentHashSet;
-class ClientRegistrationEventQueueManager {
+public class ClientRegistrationEventQueueManager {
-  private final Map<ClientProxyMembershipID, ClientRegistrationEventQueue> registeringProxyEventQueues =
-      new ConcurrentHashMap<>();
+  private final Set<ClientRegistrationEventQueue> registeringProxyEventQueues =
+      new ConcurrentHashSet<>();
-    for (final Map.Entry<ClientProxyMembershipID, ClientRegistrationEventQueue> eventsReceivedWhileRegisteringClient : registeringProxyEventQueues
-        .entrySet()) {
-      ClientProxyMembershipID clientProxyMembershipID =
-          eventsReceivedWhileRegisteringClient.getKey();
-      ClientRegistrationEventQueue registrationEventQueue =
-          eventsReceivedWhileRegisteringClient.getValue();
-
+    for (final ClientRegistrationEventQueue registrationEventQueue : registeringProxyEventQueues) {
+        ClientProxyMembershipID clientProxyMembershipID =
+            registrationEventQueue.getClientProxyMembershipID();
+
-        if (registeringProxyEventQueues.containsKey(clientProxyMembershipID)) {
+        if (registeringProxyEventQueues.contains(registrationEventQueue)) {
-          processEventAndDeliverConflatable(clientProxyMembershipID, cacheClientNotifier, event,
+          CacheClientProxy cacheClientProxy =
+              cacheClientNotifier.getClientProxy(clientProxyMembershipID);
+
+          processEventAndDeliverConflatable(cacheClientProxy, cacheClientNotifier, event,
+  void drain(final ClientRegistrationEventQueue clientRegistrationEventQueue,
+      final CacheClientNotifier cacheClientNotifier) {
+    try {
+      ClientProxyMembershipID clientProxyMembershipID =
+          clientRegistrationEventQueue.getClientProxyMembershipID();
+
+      if (logger.isDebugEnabled()) {
+        logger.debug("Draining events from registration queue for client proxy "
+            + clientProxyMembershipID
+            + " without synchronization");
+      }
+
+      CacheClientProxy cacheClientProxy = cacheClientNotifier
+          .getClientProxy(clientProxyMembershipID);
+
+      drainEventsReceivedWhileRegisteringClient(
+          cacheClientProxy,
+          clientRegistrationEventQueue,
+          cacheClientNotifier);
+
+      // Prevents additional events from being added to the queue while we process and remove it
+      clientRegistrationEventQueue.lockForDraining();
+
+      if (logger.isDebugEnabled()) {
+        logger.debug("Draining remaining events from registration queue for client proxy "
+            + clientProxyMembershipID
+            + " with synchronization");
+      }
+
+      drainEventsReceivedWhileRegisteringClient(
+          cacheClientProxy,
+          clientRegistrationEventQueue,
+          cacheClientNotifier);
+    } finally {
+      // The queue must be removed before attempting to release the drain lock
+      // so that no additional events can be added from add threads.
+      registeringProxyEventQueues.remove(clientRegistrationEventQueue);
+
+      if (clientRegistrationEventQueue.isLockForDrainingHeld()) {
+        clientRegistrationEventQueue.unlockForDraining();
+      }
+    }
+  }
+
+  ClientRegistrationEventQueue create(
+      final ClientProxyMembershipID clientProxyMembershipID,
+      final Queue<ClientRegistrationEvent> eventQueue,
+      final ReentrantReadWriteLock eventAddDrainLock) {
+    final ClientRegistrationEventQueue clientRegistrationEventQueue =
+        new ClientRegistrationEventQueue(clientProxyMembershipID, eventQueue,
+            eventAddDrainLock);
+    registeringProxyEventQueues.add(clientRegistrationEventQueue);
+    return clientRegistrationEventQueue;
+  }
+
+  private void processEventAndDeliverConflatable(final CacheClientProxy cacheClientProxy,
+      final CacheClientNotifier cacheClientNotifier,
+      final InternalCacheEvent internalCacheEvent,
+      final Conflatable conflatable,
+      final Set<ClientProxyMembershipID> originalFilterClientIDs) {
+    try {
+      // If the cache client proxy is null, the registration was not successful and the proxy
+      // was never added to the initialized proxy collection managed by the cache client notifier.
+      // If that is the case, we can just decrement the put in progress counter on the conflatable
+      // if it is an HAEventWrapper.
+      if (cacheClientProxy != null) {
+        // The first step is to repopulate the filter info for the event to determine if
+        // the client which was registering has a matching CQ or has registered interest
+        // in the key for this event. We need to get the filter profile, filter routing info,
+        // and local filter info in order to do so. If any of these are null, then there is
+        // no need to proceed as the client is not interested.
+        FilterProfile filterProfile =
+            ((LocalRegion) internalCacheEvent.getRegion()).getFilterProfile();
+
+        if (filterProfile != null) {
+          FilterRoutingInfo filterRoutingInfo =
+              filterProfile.getFilterRoutingInfoPart2(null, internalCacheEvent);
+
+          if (filterRoutingInfo != null) {
+            FilterRoutingInfo.FilterInfo filterInfo = filterRoutingInfo.getLocalFilterInfo();
+
+            if (filterInfo != null) {
+              ClientUpdateMessageImpl clientUpdateMessage = conflatable instanceof HAEventWrapper
+                  ? (ClientUpdateMessageImpl) ((HAEventWrapper) conflatable)
+                      .getClientUpdateMessage()
+                  : (ClientUpdateMessageImpl) conflatable;
+
+              internalCacheEvent.setLocalFilterInfo(filterInfo);
+
+              Set<ClientProxyMembershipID> newFilterClientIDs =
+                  cacheClientNotifier.getFilterClientIDs(internalCacheEvent, filterProfile,
+                      filterInfo,
+                      clientUpdateMessage);
+
+              ClientProxyMembershipID proxyID = cacheClientProxy.getProxyID();
+              if (eventNotInOriginalFilterClientIDs(proxyID, newFilterClientIDs,
+                  originalFilterClientIDs) && newFilterClientIDs.contains(proxyID)) {
+                cacheClientProxy.deliverMessage(conflatable);
+              }
+            }
+          }
+        }
+      }
+    } finally {
+      // Once we have processed the conflatable, if it is an HAEventWrapper we can
+      // decrement the PutInProgress counter, allowing the ClientUpdateMessage to be
+      // set to null. See decrementPutInProgressCounter() for more details.
+      if (conflatable instanceof HAEventWrapper) {
+        ((HAEventWrapper) conflatable).decrementPutInProgressCounter();
+      }
+    }
+  }
+
+  /*
+   * This is to handle the edge case where the original filter client IDs
+   * calculated by "normal" put processing did not include the registering client
+   * because the filter info had not been received yet, but we now found that the client
+   * is interested in the event so we should deliver it.
+   */
+  private boolean eventNotInOriginalFilterClientIDs(final ClientProxyMembershipID proxyID,
+      final Set<ClientProxyMembershipID> newFilterClientIDs,
+      final Set<ClientProxyMembershipID> originalFilterClientIDs) {
+    return originalFilterClientIDs == null
+        || (!originalFilterClientIDs.contains(proxyID) && newFilterClientIDs.contains(proxyID));
+  }
+
-  void drain(final ClientProxyMembershipID clientProxyMembershipID,
-      final CacheClientNotifier cacheClientNotifier) {
-    ClientRegistrationEventQueue registrationEventQueue =
-        registeringProxyEventQueues.get(clientProxyMembershipID);
-
-    if (registrationEventQueue != null) {
-      // It is possible that several client registration threads are active for the same
-      // ClientProxyMembershipID, in which case we only want a single drainer to drain
-      // and remove the queue.
-      registrationEventQueue.lockForSingleDrainer();
-      try {
-        // See if the queue is still available after acquiring the lock as it may have
-        // been removed from registeringProxyEventQueues by the previous thread
-        if (registeringProxyEventQueues.containsKey(clientProxyMembershipID)) {
-          // As an optimization, we drain as many events from the queue as we can
-          // before taking out a lock to drain the remaining events. When we lock for draining,
-          // it prevents additional events from being added to the queue while the queue is drained
-          // and removed.
-          if (logger.isDebugEnabled()) {
-            logger.debug("Draining events from registration queue for client proxy "
-                + clientProxyMembershipID
-                + " without synchronization");
-          }
-
-          drainEventsReceivedWhileRegisteringClient(clientProxyMembershipID, registrationEventQueue,
-              cacheClientNotifier);
-
-          // Prevents additional events from being added to the queue while we process and remove it
-          registrationEventQueue.lockForDraining();
-          try {
-            if (logger.isDebugEnabled()) {
-              logger.debug("Draining remaining events from registration queue for client proxy "
-                  + clientProxyMembershipID + " with synchronization");
-            }
-
-            drainEventsReceivedWhileRegisteringClient(clientProxyMembershipID,
-                registrationEventQueue,
-                cacheClientNotifier);
-
-            registeringProxyEventQueues.remove(clientProxyMembershipID);
-          } finally {
-            registrationEventQueue.unlockForDraining();
-          }
-        }
-      } finally {
-        registrationEventQueue.unlockForSingleDrainer();
-      }
-    }
-  }
-
-  private void drainEventsReceivedWhileRegisteringClient(final ClientProxyMembershipID proxyID,
+  private void drainEventsReceivedWhileRegisteringClient(
+      final CacheClientProxy cacheClientProxy,
-      processEventAndDeliverConflatable(proxyID, cacheClientNotifier, internalCacheEvent,
-          conflatable, null);
+      processEventAndDeliverConflatable(cacheClientProxy,
+          cacheClientNotifier, internalCacheEvent, conflatable, null);
-  public ClientRegistrationEventQueue create(
-      final ClientProxyMembershipID clientProxyMembershipID,
-      final Queue<ClientRegistrationEvent> eventQueue,
-      final ReadWriteLock eventAddDrainLock,
-      final ReentrantLock singleDrainerLock) {
-    final ClientRegistrationEventQueue clientRegistrationEventQueue =
-        new ClientRegistrationEventQueue(eventQueue,
-            eventAddDrainLock, singleDrainerLock);
-    registeringProxyEventQueues.putIfAbsent(clientProxyMembershipID,
-        clientRegistrationEventQueue);
-    return clientRegistrationEventQueue;
+  /**
+   * Represents a conflatable and event processed while a client was registering.
+   * This needs to be queued and processed after registration is complete. The conflatable
+   * is what we will actually be delivering to the MessageDispatcher (and thereby adding
+   * to the HARegionQueue). The internal cache event is required to rehydrate the filter
+   * info and determine if the client which was registering does have a CQ that matches or
+   * has registered interest in the key.
+   */
+  private class ClientRegistrationEvent {
+    private final Conflatable conflatable;
+    private final InternalCacheEvent internalCacheEvent;
+
+    ClientRegistrationEvent(final InternalCacheEvent internalCacheEvent,
+        final Conflatable conflatable) {
+      this.conflatable = conflatable;
+      this.internalCacheEvent = internalCacheEvent;
+    }
+    private final ClientProxyMembershipID clientProxyMembershipID;
-    private final ReadWriteLock eventAddDrainLock;
-    private final ReentrantLock singleDrainerLock;
+    private final ReentrantReadWriteLock eventAddDrainLock;
+        final ClientProxyMembershipID clientProxyMembershipID,
-        final ReadWriteLock eventAddDrainLock,
-        final ReentrantLock singleDrainerLock) {
+        final ReentrantReadWriteLock eventAddDrainLock) {
+      this.clientProxyMembershipID = clientProxyMembershipID;
-      this.singleDrainerLock = singleDrainerLock;
+    }
+
+    public ClientProxyMembershipID getClientProxyMembershipID() {
+      return clientProxyMembershipID;
+    private boolean isLockForDrainingHeld() {
+      return eventAddDrainLock.writeLock().isHeldByCurrentThread();
+    }
+
-
-    private void lockForSingleDrainer() {
-      singleDrainerLock.lock();
-    }
-
-    private void unlockForSingleDrainer() {
-      singleDrainerLock.unlock();
-    }
-  }
-
-  private void processEventAndDeliverConflatable(final ClientProxyMembershipID proxyID,
-      final CacheClientNotifier cacheClientNotifier,
-      final InternalCacheEvent internalCacheEvent,
-      final Conflatable conflatable,
-      final Set<ClientProxyMembershipID> originalFilterClientIDs) {
-    // The first step is to repopulate the filter info for the event to determine if
-    // the client which was registering has a matching CQ or has registered interest
-    // in the key for this event. We need to get the filter profile, filter routing info,
-    // and local filter info in order to do so. If any of these are null, then there is
-    // no need to proceed as the client is not interested.
-    FilterProfile filterProfile =
-        ((LocalRegion) internalCacheEvent.getRegion()).getFilterProfile();
-
-    if (filterProfile != null) {
-      FilterRoutingInfo filterRoutingInfo =
-          filterProfile.getFilterRoutingInfoPart2(null, internalCacheEvent);
-
-      if (filterRoutingInfo != null) {
-        FilterRoutingInfo.FilterInfo filterInfo = filterRoutingInfo.getLocalFilterInfo();
-
-        if (filterInfo != null) {
-          ClientUpdateMessageImpl clientUpdateMessage = conflatable instanceof HAEventWrapper
-              ? (ClientUpdateMessageImpl) ((HAEventWrapper) conflatable).getClientUpdateMessage()
-              : (ClientUpdateMessageImpl) conflatable;
-
-          internalCacheEvent.setLocalFilterInfo(filterInfo);
-
-          Set<ClientProxyMembershipID> newFilterClientIDs =
-              cacheClientNotifier.getFilterClientIDs(internalCacheEvent, filterProfile,
-                  filterInfo,
-                  clientUpdateMessage);
-
-          if (eventNotInOriginalFilterClientIDs(proxyID, newFilterClientIDs,
-              originalFilterClientIDs)) {
-            CacheClientProxy cacheClientProxy = cacheClientNotifier.getClientProxy(proxyID);
-
-            if (eventShouldBeDelivered(proxyID, newFilterClientIDs, cacheClientProxy)) {
-              cacheClientProxy.deliverMessage(conflatable);
-            }
-          }
-        }
-      }
-    }
-
-    // Once we have processed the conflatable, if it is an HAEventWrapper we can
-    // decrement the PutInProgress counter, allowing the ClientUpdateMessage to be
-    // set to null. See decrementPutInProgressCounter() for more details.
-    if (conflatable instanceof HAEventWrapper) {
-      ((HAEventWrapper) conflatable).decrementPutInProgressCounter();
-    }
-  }
-
-  private boolean eventShouldBeDelivered(final ClientProxyMembershipID proxyID,
-      final Set<ClientProxyMembershipID> filterClientIDs,
-      final CacheClientProxy cacheClientProxy) {
-    return filterClientIDs.contains(proxyID) && cacheClientProxy != null;
-  }
-
-  /*
-   * This is to handle the edge case where the original filter client IDs
-   * calculated by "normal" put processing did not include the registering client
-   * because the filter info had not been received yet, but we now found that the client
-   * is interested in the event so we should deliver it.
-   */
-  private boolean eventNotInOriginalFilterClientIDs(final ClientProxyMembershipID proxyID,
-      final Set<ClientProxyMembershipID> newFilterClientIDs,
-      final Set<ClientProxyMembershipID> originalFilterClientIDs) {
-    return originalFilterClientIDs == null
-        || (!originalFilterClientIDs.contains(proxyID) && newFilterClientIDs.contains(proxyID));
-  }
-
-  /**
-   * Represents a conflatable and event processed while a client was registering.
-   * This needs to be queued and processed after registration is complete. The conflatable
-   * is what we will actually be delivering to the MessageDispatcher (and thereby adding
-   * to the HARegionQueue). The internal cache event is required to rehydrate the filter
-   * info and determine if the client which was registering does have a CQ that matches or
-   * has registered interest in the key.
-   */
-  private class ClientRegistrationEvent {
-    private final Conflatable conflatable;
-    private final InternalCacheEvent internalCacheEvent;
-
-    ClientRegistrationEvent(final InternalCacheEvent internalCacheEvent,
-        final Conflatable conflatable) {
-      this.conflatable = conflatable;
-      this.internalCacheEvent = internalCacheEvent;
-    }

MOV26 MOV31 MOV31 MOV55 UPD40 UPD40 INS83 MOV23 MOV31 MOV31 UPD74 MOV74 INS44 MOV44 MOV43 INS83 MOV43 INS42 INS54 UPD43 INS54 INS43 INS42 UPD43 INS59 UPD43 MOV59 MOV44 MOV21 UPD83 MOV43 INS42 INS8 UPD39 UPD42 UPD74 INS42 INS8 INS8 UPD42 UPD42 MOV42 INS8 INS8 INS42 UPD42 INS42 UPD42 UPD43 INS41 INS41 UPD43 INS43 UPD42 MOV60 MOV25 INS60 MOV21 MOV21 MOV25 MOV21 MOV21 INS25 UPD42 INS25 MOV25 UPD42 INS42 INS32 UPD42 MOV42 MOV43 MOV43 INS59 INS32 INS8 MOV43 INS42 MOV27 INS8 UPD42 INS32 INS42 INS60 UPD42 INS42 INS32 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 MOV21 MOV60 MOV25 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 MOV43 INS59 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 MOV42 INS42 INS32 UPD42 UPD42 INS60 UPD42 UPD42 INS42 INS42 INS43 INS59 INS42 INS42 INS32 UPD42 INS42 INS42 INS42 INS60 MOV43 INS59 INS27 MOV8 INS42 INS32 MOV32 INS32 INS42 INS42 UPD42 MOV42 UPD42 MOV42 MOV42 DEL40 DEL26 DEL40 DEL26 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL40 DEL43 DEL43 DEL74 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL32 DEL8 DEL32 DEL21 DEL8 DEL54 DEL8 DEL25 DEL8 DEL8 DEL54 DEL8 DEL25 DEL83 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL25 DEL8 DEL83 DEL39 DEL42 DEL83 DEL42 DEL44 DEL83 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL27 DEL41 DEL8 DEL31 DEL42 DEL42 DEL59 DEL83 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL32 DEL21
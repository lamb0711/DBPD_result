GEODE-6803: be able to configure pdx using management rest api (#3638)

* Add PdxManagementController and PdxManager
* add RestEndPoint.getUri for single config object uri for HATOS, make it part of the json response
* rename RuntimeCacheElement to MultiGroupCacheElement since the only usage of it is to support multi group.
* make MultiGroupCacheElement a suplimental interface and list does not have to return MultiGroupCacheElement
* do not require servers to be present in order to create a cache element
* when realizer is not present, assuming the servers needs to be bounced in order for the config change to take effect
+import java.util.Collections;
+import org.apache.geode.cache.configuration.PdxType;
-import org.apache.geode.management.configuration.RuntimeCacheElement;
+import org.apache.geode.management.configuration.MultiGroupCacheElement;
+import org.apache.geode.management.internal.configuration.mutators.PdxManager;
-  private Map<Class, ConfigurationManager> managers;
+  private Map<Class, ConfigurationManager<? extends CacheElement>> managers;
+    managers.put(PdxType.class, new PdxManager());
-    if (targetedMembers.size() == 0) {
-      return new ClusterManagementResult(false,
-          "No members found in group '" + group + "' to create cache element");
-    }
-
+
+    // add the config object which includes the HATOS information of the element created
+    if (result.isSuccessful()) {
+      result.setResult(Collections.singletonList(config));
+    }
-  public ClusterManagementResult list(CacheElement filter) {
-    ConfigurationManager manager = managers.get(filter.getClass());
+  public <T extends CacheElement> ClusterManagementResult list(T filter) {
+    ConfigurationManager<T> manager = (ConfigurationManager<T>) managers.get(filter.getClass());
+
-      List<RuntimeCacheElement> listResults = manager.list(filter, null);
+      List<? extends T> listResults = manager.list(filter, null);
-    List<RuntimeCacheElement> resultList = new ArrayList<>();
-
-    // get a list of all the resultList from all groups that satisfy the filter criteria (all
-    // filters
-    // have been applied except the group)
+    List<T> resultList = new ArrayList<>();
-      List<RuntimeCacheElement> listInGroup = manager.list(filter, currentPersistedConfig);
-      for (RuntimeCacheElement element : listInGroup) {
-        element.getGroups().add(group);
-        int index = resultList.indexOf(element);
-        if (index >= 0) {
-          RuntimeCacheElement exist = resultList.get(index);
-          exist.getGroups().add(group);
-        } else {
+      List<? extends T> listInGroup = manager.list(filter, currentPersistedConfig);
+      for (T element : listInGroup) {
+        if (group.equals(element.getConfigGroup()) || element instanceof MultiGroupCacheElement) {
+          element.setGroup(group);
-    // filtering by group. Do this after iterating through all the groups because some region might
-    // belong to multiple groups and we want the "group" field to show that.
-    if (StringUtils.isNotBlank(filter.getGroup())) {
-      resultList =
-          resultList.stream().filter(e -> e.getGroups().contains(filter.getConfigGroup()))
-              .collect(Collectors.toList());
+    // if empty result, return immediately
+    if (resultList.size() == 0) {
+      return result;
-    // if "cluster" is the only group of the element, remove it
-    for (RuntimeCacheElement element : resultList) {
-      if (element.getGroups().size() == 1 && "cluster".equals(element.getGroup())) {
-        element.getGroups().clear();
+    // right now the list contains [{regionA, group1}, {regionA, group2}...], if the elements are
+    // MultiGroupCacheElement, we need to consolidate the list into [{regionA, [group1, group2]}
+    if (resultList.get(0) instanceof MultiGroupCacheElement) {
+      List<MultiGroupCacheElement> multiGroupList = new ArrayList<>();
+      for (T element : resultList) {
+        int index = multiGroupList.indexOf(element);
+        if (index >= 0) {
+          MultiGroupCacheElement exist = multiGroupList.get(index);
+          exist.getGroups().add(element.getGroup());
+        } else {
+          multiGroupList.add((MultiGroupCacheElement) element);
+        }
+      }
+      if (StringUtils.isNotBlank(filter.getGroup())) {
+        multiGroupList = multiGroupList.stream()
+            .filter(e -> e.getGroups().contains(filter.getConfigGroup()))
+            .collect(Collectors.toList());
+      }
+      // if "cluster" is the only group, clear it
+      for (MultiGroupCacheElement element : multiGroupList) {
+        if (element.getGroups().size() == 1 && "cluster".equals(element.getGroup())) {
+          element.getGroups().clear();
+        }
+      }
+      resultList =
+          (List<T>) multiGroupList.stream().map(CacheElement.class::cast)
+              .collect(Collectors.toList());
+    } else {
+      // for non-MultiGroup CacheElement, just clear out the "cluster" group
+      for (T element : resultList) {
+        if ("cluster".equals(element.getGroup())) {
+          element.setGroup(null);
+        }
-    List<RuntimeCacheElement> result = list.getResult(RuntimeCacheElement.class);
+    List<CacheElement> result = list.getResult(CacheElement.class);
+    if (targetMembers.size() == 0) {
+      return Collections.emptyList();
+    }
+

INS26 INS26 INS26 INS40 INS40 UPD40 INS40 UPD74 MOV25 INS73 INS74 INS21 INS42 INS43 INS43 INS25 INS25 INS25 MOV43 INS76 INS32 INS32 INS42 INS42 INS74 UPD74 INS27 INS8 INS62 INS8 INS8 UPD74 INS27 INS8 INS43 INS42 INS42 INS57 INS14 UPD42 MOV42 UPD42 MOV42 INS21 MOV43 INS43 INS11 UPD43 INS32 INS34 INS41 INS32 INS43 INS60 INS70 MOV25 MOV70 INS21 INS70 UPD43 INS32 INS34 INS41 INS42 INS43 INS43 INS32 INS42 INS74 MOV32 UPD74 UPD42 UPD74 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS74 INS59 INS44 INS42 INS8 UPD42 INS7 INS44 INS42 INS8 UPD42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS43 INS43 UPD43 INS76 MOV43 INS76 UPD43 INS25 INS43 INS43 INS42 INS14 INS43 INS42 INS60 INS25 UPD43 INS42 INS11 INS43 INS42 INS25 UPD43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS43 INS43 UPD42 INS27 MOV8 INS42 INS42 INS74 INS42 INS39 INS59 MOV27 INS8 INS8 UPD42 INS74 INS32 INS42 INS32 INS8 UPD42 INS42 UPD42 MOV42 INS32 INS62 INS21 INS43 INS42 INS32 INS60 MOV21 INS21 UPD42 INS43 INS43 INS32 INS42 INS32 INS45 INS42 INS32 INS21 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS43 INS32 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS42 INS42 INS32 INS42 INS90 INS42 INS42 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS11 INS42 INS42 INS57 INS42 INS42 INS42 INS33 INS42 INS42 INS42 INS42 UPD42 MOV42 INS43 INS42 UPD42 MOV43 INS42 DEL32 DEL34 DEL27 DEL42 DEL43 DEL9 DEL45 DEL42 DEL45 DEL27 DEL14 DEL41 DEL42 DEL43 DEL32 DEL32 DEL21 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL25
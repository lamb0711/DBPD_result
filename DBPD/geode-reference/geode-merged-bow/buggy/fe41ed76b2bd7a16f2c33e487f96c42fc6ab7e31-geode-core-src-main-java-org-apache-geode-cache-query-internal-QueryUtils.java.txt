GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

-import java.util.LinkedList;
-import org.apache.geode.cache.query.internal.parse.OQLLexerTokenTypes;
+import org.apache.geode.cache.query.internal.parse.OQLLexerTokenTypes;
+import org.apache.geode.internal.cache.partitioned.Bucket;
-  public static void assertCompatible(SelectResults sr1, SelectResults sr2) {
+  private static void assertCompatible(SelectResults sr1, SelectResults sr2) {
-
-   * Returns an appropriate, empty <code>SelectResults</code>
+   * Returns an appropriate, empty {@code SelectResults}
-   * @param objectType The <code>ObjectType</code> of the query results
-   * @return an appropriate, empty <code>SelectResults</code>
+   * @param objectType The {@code ObjectType} of the query results
+   * @return an appropriate, empty {@code SelectResults}
-   * Returns an appropriate, empty <code>SelectResults</code>
+   * Returns an appropriate, empty {@code SelectResults}
+   *
+   * TODO: statsOrNull is always null
-   * @param collectionType The <code>CollectionType</code> of the query results
-   * @return an appropriate, empty <code>SelectResults</code>
+   * @param collectionType The {@code CollectionType} of the query results
+   * @return an appropriate, empty {@code SelectResults}
-    // if one is a set and one is a bag,
-    // then treat the set like a bag (and return a bag)
+    // if one is a set and one is a bag, then treat the set like a bag (and return a bag)
-          if (small.occurrences(element) > count) { // bag intersection: only retain smaller number
-                                                    // of dups
+          if (small.occurrences(element) > count) {
+            // bag intersection: only retain smaller number of dups
-      } catch (UnsupportedOperationException e1) {
+      } catch (UnsupportedOperationException ignore) {
-          if (large.occurrences(element) > count) { // bag intersection: only retain smaller number
-                                                    // of dups
+          if (large.occurrences(element) > count) {
+            // bag intersection: only retain smaller number of dups
-      } catch (UnsupportedOperationException e2) {
+      } catch (UnsupportedOperationException ignore) {
-
-    // if one is a set and one is a bag,
-    // then treat the set like a bag (and return a bag)
+    // if one is a set and one is a bag, then treat the set like a bag (and return a bag)
-        for (Iterator itr = small.iterator(); itr.hasNext();) {
-          Object element = itr.next();
+        for (Object element : small) {
-      } catch (UnsupportedOperationException e1) {
+      } catch (UnsupportedOperationException ignore) {
-        for (Iterator itr = large.iterator(); itr.hasNext();) {
-          Object element = itr.next();
+        for (Object element : large) {
-      } catch (UnsupportedOperationException e2) {
+      } catch (UnsupportedOperationException ignore) {
-   * @param context
-  public static List getDependentItrChainForIndpndntItrs(RuntimeIterator[] indpndntItrs,
+  static List getDependentItrChainForIndpndntItrs(RuntimeIterator[] indpndntItrs,
-    for (int k = 0; k < indpndntItrs.length; ++k) {
-      ret.addAll(context.getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(indpndntItrs[k]));
+    for (RuntimeIterator indpndntItr : indpndntItrs) {
+      ret.addAll(context.getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(indpndntItr));
-
-   * @throws FunctionDomainException
-   * @throws TypeMismatchException
-   * @throws NameResolutionException
-   * @throws QueryInvocationTargetException
-   * 
-    // RuntimeIterator levelExpnItr =
-    // expnItr.hasNext()?(RuntimeIterator)expnItr.next():null;
-        (results.length + expansionList.size()), context, operand);
+        results.length + expansionList.size(), context, operand);
-      Iterator itr = individualResultSet.iterator();
-      while (itr.hasNext()) {
+      for (Object anIndividualResultSet : individualResultSet) {
-        Object value = itr.next();
-          itrsForFields[0].setCurrent(value);
+          itrsForFields[0].setCurrent(anIndividualResultSet);
-          Struct struct = (Struct) value;
-          Object fieldValues[] = struct.getFieldValues();
+          Struct struct = (Struct) anIndividualResultSet;
+          Object[] fieldValues = struct.getFieldValues();
-        // TODO:Asif Check this out
-      Iterator cIter = c.iterator();
-      while (cIter.hasNext()) {
-        currLevel.setCurrent(cIter.next());
+      for (Object aC : c) {
+        currLevel.setCurrent(aC);
-      return ((Boolean) result).booleanValue();
+      return (Boolean) result;
-  // TODO:Asif This function is used to do cartesian of index resultset while
-  // expanding/cutting down index resultset
-  // with the intermediate resultset
-  // TODO :Asif :Explain the parameters& Unit test it
+  /**
+   * NOTE: intermediateResults should be a single element array
+   * <p>
+   * NOTE: itrsForIntermediateResults should be a two dimensional array but with only one row
+   * <p>
+   * TODO: This function is used to do cartesian of index resultset while
+   * <p>
+   * expanding/cutting down index resultset with the intermediate resultset
+   */
-      SelectResults[] intermediateResults /*
-                                           * Asif This should be a single element array
-                                           */,
-      RuntimeIterator[][] itrsForIntermediateResults /*
-                                                      * Asif This should be a two dimensional array
-                                                      * but with only one row
-                                                      */, Object[][] indexResults,
-      RuntimeIterator[][] indexFieldToItrsMapping, ListIterator expansionListItr, List finalItrs,
-      ExecutionContext context, List[] checkList, CompiledValue iterOps,
-      IndexCutDownExpansionHelper icdeh[], int level, int maxExpnCartesianDepth)
-      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException {
-    // Object[] checkFields = null;
-    // int len = indexFieldToItrsMapping[level].length;
-    // RuntimeIterator rItr = null;
+      SelectResults[] intermediateResults, RuntimeIterator[][] itrsForIntermediateResults,
+      Object[][] indexResults, RuntimeIterator[][] indexFieldToItrsMapping,
+      ListIterator expansionListItr, List finalItrs, ExecutionContext context, List[] checkList,
+      CompiledValue iterOps, IndexCutDownExpansionHelper[] icdeh, int level,
+      int maxExpnCartesianDepth) throws FunctionDomainException, TypeMismatchException,
+      NameResolutionException, QueryInvocationTargetException {
+
-    // TODO ASif : Since this is constant for a given merge call, pass it as a
+    // TODO: Since this is constant for a given merge call, pass it as a
-        if (level == (indexResults.length - 1)) {
-          // Asif :Set the values in the Intermedaite Resultset
+        if (level == indexResults.length - 1) {
+          // Set the values in the Intermedaite Resultset
-  // TODO:Asif : Test the function & write expnanation of the parameters
+  // TODO: Test the function & write expnanation of the parameters
-      List[] checkList, CompiledValue iterOps, IndexCutDownExpansionHelper icdeh[], int level)
+      List[] checkList, CompiledValue iterOps, IndexCutDownExpansionHelper[] icdeh, int level)
-    // int len = indexFieldToItrsMapping[level].length;
-    // RuntimeIterator rItr = null;
+
-        if (level == (values.length - 1)) {
+        if (level == values.length - 1) {
-  // TODO:Asif : Explain the function & write test cases. A boolean false means
-  // ,
-  // by pass i.e the set value to be ignored
-
+  // TODO: Explain the function & write test cases. A boolean false means by pass i.e the set value
+  // to be ignored
-    Object[] checkFields = null;
-    RuntimeIterator rItr = null;
-      // Asif : this means we have a ResultSet
+      // this means we have a ResultSet
-      Object fieldValues[] = struct.getFieldValues();
+      Object[] fieldValues = struct.getFieldValues();
+      Object[] checkFields = null;
+      RuntimeIterator rItr = null;
-    SelectResults returnSet = null;
+
-    if (orderByClause != null && orderByClause.booleanValue()) {
+    if (orderByClause != null && orderByClause) {
+    SelectResults returnSet = null;
-  // TODO:Asif Explain the parameters passed
+  // TODO: Explain the parameters passed
-    // Object[] checkFields = null;
+
-      if (setIndexFieldValuesInRespectiveIterators(value, indexFieldToItrsMapping, icdeh)) { // does
-                                                                                             // that
-                                                                                             // mean
-                                                                                             // we
-                                                                                             // don't
-                                                                                             // get
-                                                                                             // dupes
-                                                                                             // even
-                                                                                             // if
-                                                                                             // they
-                                                                                             // exist
-                                                                                             // in
-                                                                                             // the
-                                                                                             // index?
+      if (setIndexFieldValuesInRespectiveIterators(value, indexFieldToItrsMapping, icdeh)) {
+        // does that mean we don't get dupes even if they exist in the index?
-      limit = ((Integer) context.cacheGet(CompiledValue.RESULT_LIMIT)) != null
-          ? ((Integer) context.cacheGet(CompiledValue.RESULT_LIMIT)).intValue() : -1;
+      limit = context.cacheGet(CompiledValue.RESULT_LIMIT) != null
+          ? (Integer) context.cacheGet(CompiledValue.RESULT_LIMIT) : -1;
-  public static CompiledID getCompiledIdFromPath(CompiledValue path) {
+  static CompiledID getCompiledIdFromPath(CompiledValue path) {
-  // Add comments
-        // TODO:Asif Optimize the LinkedStructSet implementation so that
-        // Object[] can be added rather than Struct
-        Object values[] = new Object[len];
+        // TODO: Optimize the LinkedStructSet implementation so that Object[] can be added rather
+        // than Struct
+
+        Object[] values = new Object[len];
-
-
-      SelectResults c = null;
-        key = currentLevel.getCmpIteratorDefn().getName() + ":" + currentLevel.getDefinition();
+        key = currentLevel.getCmpIteratorDefn().getName() + ':' + currentLevel.getDefinition();
-            + ":" + currentLevel.getDefinition();
+            + ':' + currentLevel.getDefinition();
+      SelectResults c;
-      // RuntimeIterator next = expansionItrs.hasNext() ?
-      // (RuntimeIterator)expansionItrs.next() : null;
-        // TODO:Asif Check this out
-      Iterator cIter = c.iterator();
-      while (cIter.hasNext()) {
+      for (Object aC : c) {
-        currentLevel.setCurrent(cIter.next());
+        currentLevel.setCurrent(aC);
-   * Ketan/Asif : This function will evaluate the starting CompiledValue for a given CompliedValue.
-   * The value returned will always be either the original CompiledValue, or a CompiledID, or a
+   * This function will evaluate the starting CompiledValue for a given CompliedValue. The value
+   * returned will always be either the original CompiledValue, or a CompiledID, or a
-  public static CompiledValue obtainTheBottomMostCompiledValue(CompiledValue expr) {
+  static CompiledValue obtainTheBottomMostCompiledValue(CompiledValue expr) {
-          expr = operation.getReceiver(null/*
-                                            * pass the ExecutionContext as null, thus never
-                                            * implicitly resolving to RuntimeIterator
-                                            */);
+          // pass the ExecutionContext as null, thus never implicitly resolving to RuntimeIterator
+          expr = operation.getReceiver(null);
-          expr = ((CompiledPath) expr).getReceiver();
+          expr = expr.getReceiver();
-          expr = ((CompiledIndexOperation) expr).getReceiver();
+          expr = expr.getReceiver();
-      if (toContinue)
+      if (toContinue) {
+      }
-   * Asif : This function creates a StructType using Internal IDs of the iterators as the field
-   * names for the StructType. It should be invoked iff the iterators size is greater than 1
+   * This function creates a StructType using Internal IDs of the iterators as the field names for
+   * the StructType. It should be invoked iff the iterators size is greater than 1
-  public static StructType createStructTypeForRuntimeIterators(List runTimeIterators) {
+  static StructType createStructTypeForRuntimeIterators(List runTimeIterators) {
-    String fieldNames[] = new String[len];
+    String[] fieldNames = new String[len];
-    ObjectType fieldTypes[] = new ObjectType[len];
-    // Asif : use an Iterator as the chances are that we will be sending
+    ObjectType[] fieldTypes = new ObjectType[len];
+    // use an Iterator as the chances are that we will be sending
-    StructTypeImpl type = new StructTypeImpl(fieldNames, indexAlternativeFieldNames, fieldTypes);
-    return type;
+    return new StructTypeImpl(fieldNames, indexAlternativeFieldNames, fieldTypes);
-   * Asif :This function returns the ultimate independent RuntimeIterators of current scope on which
-   * the CompiledValue passed is dependent upon. This does not return the RuntimeIterators on which
-   * it may be dependent but are not part of the current scope. If no such RuntimeIterator exists it
+   * This function returns the ultimate independent RuntimeIterators of current scope on which the
+   * CompiledValue passed is dependent upon. This does not return the RuntimeIterators on which it
+   * may be dependent but are not part of the current scope. If no such RuntimeIterator exists it
-   * 
-  public static Set getCurrentScopeUltimateRuntimeIteratorsIfAny(CompiledValue compiledValue,
+  static Set getCurrentScopeUltimateRuntimeIteratorsIfAny(CompiledValue compiledValue,
-    HashSet set = new HashSet();
-    context.computeUtlimateDependencies(compiledValue, set);
-    // if (set.size() != 1) return null;
+    Set set = new HashSet();
+    context.computeUltimateDependencies(compiledValue, set);
-   * Asif :Returns the pair of RangeIndexes available for a composite condition ( equi join across
-   * the region). It will either return two indexes or will return null. *
+   * Returns the pair of RangeIndexes available for a composite condition ( equi join across the
+   * region). It will either return two indexes or will return null. *
-   * @throws AmbiguousNameException
-   * @throws TypeMismatchException
-   * 
-    if (operator != OQLLexerTokenTypes.TOK_EQ)
-      return null;// Operator must be
-    // '='
-    IndexData lhsIndxData =
-        QueryUtils.getAvailableIndexIfAny(lhs, context, false /* Do not use PrimaryKey Index */);// findOnlyFunctionalIndex.
-    if (lhsIndxData == null)
+    if (operator != OQLLexerTokenTypes.TOK_EQ) {
+      // Operator must be '='
-    IndexData rhsIndxData =
-        QueryUtils.getAvailableIndexIfAny(rhs, context, false /* Do not use PrimaryKey Index */);// findOnlyFunctionalIndex.
+    }
+
+    // Do not use PrimaryKey Index
+    IndexData lhsIndxData = QueryUtils.getAvailableIndexIfAny(lhs, context, false);
+    if (lhsIndxData == null) {
+      return null;
+    }
+
+    // Do not use PrimaryKey Index
+    IndexData rhsIndxData = QueryUtils.getAvailableIndexIfAny(rhs, context, false);
+
-   * Asif : Gets an Index available for the condition
+   * Gets an Index available for the condition
-   * @throws AmbiguousNameException
-   * @throws TypeMismatchException
-   * 
-        (operator == OQLLexerTokenTypes.TOK_EQ || operator == OQLLexerTokenTypes.TOK_NE);
+        operator == OQLLexerTokenTypes.TOK_EQ || operator == OQLLexerTokenTypes.TOK_NE;
-  // TODO:Asif : Provide description of the function.
-    context.computeUtlimateDependencies(cv, set);
+    context.computeUltimateDependencies(cv, set);
-    // Asif : The independent iterator is added as the first element
+    // The independent iterator is added as the first element
-
-    // StringBuffer sb = new StringBuffer();
-    // cv.generateCanonicalizedExpression(sb, context);
-   * Asif : Conditions the raw index result obtained on a non composite condition ( i.e a condition
-   * with a format of variable = constant . A constant may be either a CompiledLiteral or an
-   * expression which is completely dependent on iterators other than the current scope. The
-   * variable is a path expression which is completely dependent on iterators belonging only to a
-   * single region ( i.e iterators belonging to a Group of iterators only dependent on a single
-   * indpendent iterator for the region). The raw index result is appropriately expanded / cutdown
-   * with evaluation of iter operand if any , StructType/ObjectType appropriately set, Shuffling of
-   * the fields appropriately done, such that the final result is compatible, in terms of the
-   * position and names of the fields of SelectResults( StructBag) , with the Iterators of the query
-   * from clause ( if complete expansion flag is true) or the chain of iterators identified by the
-   * indpendent iterator for the group.
+   * Conditions the raw index result obtained on a non composite condition ( i.e a condition with a
+   * format of variable = constant . A constant may be either a CompiledLiteral or an expression
+   * which is completely dependent on iterators other than the current scope. The variable is a path
+   * expression which is completely dependent on iterators belonging only to a single region ( i.e
+   * iterators belonging to a Group of iterators only dependent on a single indpendent iterator for
+   * the region). The raw index result is appropriately expanded / cutdown with evaluation of iter
+   * operand if any , StructType/ObjectType appropriately set, Shuffling of the fields appropriately
+   * done, such that the final result is compatible, in terms of the position and names of the
+   * fields of SelectResults( StructBag) , with the Iterators of the query from clause ( if complete
+   * expansion flag is true) or the chain of iterators identified by the indpendent iterator for the
+   * group.
-   * @throws FunctionDomainException
-   * @throws TypeMismatchException
-   * @throws NameResolutionException
-   * @throws QueryInvocationTargetException
-   * 
-  static SelectResults getconditionedIndexResults(SelectResults indexResults, IndexInfo indexInfo,
+  static SelectResults getConditionedIndexResults(SelectResults indexResults, IndexInfo indexInfo,
-      // Asif : If for a Single Base Collection Index usage we are having
+      // If for a Single Base Collection Index usage we are having
-      for (int i = 0; i < len; ++i) {
-        tempItr = grpIndpndntItr[i];
+      for (RuntimeIterator aGrpIndpndntItr : grpIndpndntItr) {
+        tempItr = aGrpIndpndntItr;
-   * Asif :This function is used to evaluate a filter evaluatable CompositeCondition(ie Range
-   * Indexes available on both LHS & RHS operands).This function is invoked from AND junction
-   * evaluation of CompositeGroupJunction. It expands the intermediate resultset passed , to the
-   * level of groups determined by the LHS & RHS operand, using the range indexes. It is possible
-   * that the group of iterators for an operand of condition already exists in the intermediate
-   * resultset passed. In such situation, the intermediate resultset is iterated & the operand (
-   * whose group of iterators are available in the intermediate resultset ) is evaluated. For each
-   * such evaluated value , the other operand's Range Index is queried & the Range Index's results
-   * are appropriately expanded & cut down & a final tuple obtained( which includes the previously
-   * existing fields of intermediate resultset). The array of independent iterators passed from the
-   * Composite Group junction will be null, except for the final condition ( subject to the fact
-   * that complete expansion flag is false. Otherwise even for final condition , the array will be
-   * null) as that array will be used to get the final position of iterators in the resultant
-   * StructBag
+   * This function is used to evaluate a filter evaluatable CompositeCondition(ie Range Indexes
+   * available on both LHS & RHS operands).This function is invoked from AND junction evaluation of
+   * CompositeGroupJunction. It expands the intermediate resultset passed , to the level of groups
+   * determined by the LHS & RHS operand, using the range indexes. It is possible that the group of
+   * iterators for an operand of condition already exists in the intermediate resultset passed. In
+   * such situation, the intermediate resultset is iterated & the operand ( whose group of iterators
+   * are available in the intermediate resultset ) is evaluated. For each such evaluated value , the
+   * other operand's Range Index is queried & the Range Index's results are appropriately expanded &
+   * cut down & a final tuple obtained( which includes the previously existing fields of
+   * intermediate resultset). The array of independent iterators passed from the Composite Group
+   * junction will be null, except for the final condition ( subject to the fact that complete
+   * expansion flag is false. Otherwise even for final condition , the array will be null) as that
+   * array will be used to get the final position of iterators in the resultant StructBag
+   *
+   * TODO: break this method up
-   * @throws FunctionDomainException
-   * @throws TypeMismatchException
-   * @throws NameResolutionException
-   * @throws QueryInvocationTargetException
-   * 
-     * Asif : even if th complete expansion is needed pass the flag of complete expansion as false.
-     * Thus for LHS & RHS we will get the expnasionList for that individual group.
+     * even if the complete expansion is needed pass the flag of complete expansion as false. Thus
+     * for LHS & RHS we will get the expansionList for that individual group.
-    IndexConditioningHelper ich1 =
-        new IndexConditioningHelper(indxInfo[0], context, indexFieldsSize1,
-            false/* Asif : pass it as false, irrespective of actual value */, iterOperands, null);
-    IndexConditioningHelper ich2 =
-        new IndexConditioningHelper(indxInfo[1], context, indexFieldsSize2,
-            false/* Asif : pass it as false, irrespective of actual value */, iterOperands, null);
-    // Asif : We cannot have a condition where in intermediateResultset is empty
+
+    // NOTE: use false for completeExpansion irrespective of actual value
+    IndexConditioningHelper ich1 = new IndexConditioningHelper(indxInfo[0], context,
+        indexFieldsSize1, false, iterOperands, null);
+
+    // NOTE: use false for completeExpansion irrespective of actual value
+    IndexConditioningHelper ich2 = new IndexConditioningHelper(indxInfo[1], context,
+        indexFieldsSize2, false, iterOperands, null);
+
+    // We cannot have a condition where in intermediateResultset is empty
-    // getconditionedRelationshipIndexResultsExpandedToTopOrCGJLevel
-    int noOfIndexesToUse = (intermediateResults == null || intermediateResults.isEmpty()) ? 2 : 0;
+    int noOfIndexesToUse = intermediateResults == null || intermediateResults.isEmpty() ? 2 : 0;
-    // Asif : the set will contain those iterators which we don't have to expand
-    // to
-    // either because they are already present ( because of intermediate results or
-    // because index result already contains them
+    // the set will contain those iterators which we don't have to expand to either because they are
+    // already present ( because of intermediate results or because index result already contains
+    // them
-        // Asif : the iterator below is already present in resultset so needs to
-        // be ignored for expansion
+        // the iterator below is already present in resultset so needs to be ignored for expansion
-          // Asif:We will need to know the intermediate iterators so as to know
+          // We will need to know the intermediate iterators so as to know
-          // Asif : The expnItrsToIgnore set being null at this point implies
-          // that though
-          // complete expansion flag is true but intermediate result set is
-          // empty
+          // The expnItrsToIgnore set being null at this point implies that though complete
+          // expansion flag is true but intermediate result set is empty
-        // Asif : identify the iterators which we need to expand to
-        // TODO:Asif :Make the code compact by using a common function to take
-        // care of this
+        // identify the iterators which we need to expand to
+        // TODO: Make the code compact by using a common function to take care of this
-          // Asif :If the runtimeIterators of scope not present in CheckSet add
-          // it
-          // to
-          // the expansion list
+          // If the runtimeIterators of scope not present in CheckSet add it to the expansion list
-        // Asif : If the independent itrs passed is not null, this implies
-        // that we are evaluating the last filterable cc of the AND junction
-        // so the final resultset should have placement of iterators in the
-        // order of indpendent iterators present in CGJ. Otherwise we will have
-        // struct
-        // set mismatch while doing intersection with GroupJunction results
+        // If the independent itrs passed is not null, this implies that we are evaluating the last
+        // filterable cc of the AND junction so the final resultset should have placement of
+        // iterators in the order of indpendent iterators present in CGJ. Otherwise we will have
+        // struct set mismatch while doing intersection with GroupJunction results
-            // TODO:Asif Change the code in range Index so that while collecting
-            // data
-            // instead of creating
-            // two dimensional object array , we create one dimensional Object
-            // array
-            // of size 2, & each elemnt
-            // stores an Object array
+            // TODO: Change the code in range Index so that while collecting data instead of
+            // creating two dimensional object array , we create one dimensional Object array of
+            // size 2, & each elemnt stores an Object array
-            // Asif : Before doing the cartesian of the Results , we need to
-            // clear
-            // the CheckSet of InexCutDownExpansionHelper. This is needed
-            // because for
-            // a new key , the row of sets needs to be considered fresh as
-            // presence of old row in
-            // checkset may cause us to wrongly skip the similar row of a set ,
-            // even when the row in its entirety
-            // is unique ( made by different data in the other set)
+            // Before doing the cartesian of the Results , we need to clear the CheckSet of
+            // InexCutDownExpansionHelper. This is needed because for a new key , the row of sets
+            // needs to be considered fresh as presence of old row in checkset may cause us to
+            // wrongly skip the similar row of a set , even when the row in its entirety is unique (
+            // made by different data in the other set)
-                  0 /* Level */);
+                  0);
-      // Asif : There exists one independent iterator in the current condition
-      // which is also a part of the intermediate resultset
-      // Identify the final List which will depend upon the complete expansion
-      // flag
-      // Identify the iterators to be expanded to, which will also depend upon
-      // complete
-      // expansion flag..
+      // There exists one independent iterator in the current condition which is also a part of the
+      // intermediate resultset Identify the final List which will depend upon the complete
+      // expansion flag Identify the iterators to be expanded to, which will also depend upon
+      // complete expansion flag..
-        // Asif : identify the iterators which we need to expand to
-        // TODO:Asif :Make the code compact by using a common function to take
-        // care of this
+        // identify the iterators which we need to expand to
+        // TODO: Make the code compact by using a common function to take care of this
-          // Asif :If the runtimeIterators of scope not present in CheckSet add
-          // it
-          // to
-          // the expansion list
+          // If the runtimeIterators of scope not present in CheckSet add it to the expansion list
-        // Asif : If the independent itrs passed is not null, this implies
-        // that we are evaluating the last filterable cc of the AND junction
-        // so the final resultset should have placement of iterators in the
-        // order of indpendent iterators present in CGJ. Otherwise we will havve
-        // struct
-        // set mismatch while doing intersection with GroupJunction results
+        // If the independent itrs passed is not null, this implies that we are evaluating the last
+        // filterable cc of the AND junction so the final resultset should have placement of
+        // iterators in the order of indpendent iterators present in CGJ. Otherwise we will havve
+        // struct set mismatch while doing intersection with GroupJunction results
-      // List[] checkList = new List[] { ich1.checkList, ich2.checkList};
+
-      // Asif :Obtain the empty resultset for the single usable index
+      // Obtain the empty resultset for the single usable index
-      // int singleUsblIndexFieldsSize = -1;
+
-        // singleUsblIndexFieldsSize = ((StructTypeImpl) singlUsblIndxResType)
-        // .getFieldNames().length;
-        // singleUsblIndexFieldsSize = 1;
-      // Asif iterate over the intermediate structset
+      // iterate over the intermediate structset
-          // TODO:Asif : Issue relevant index use callbacks to QueryObserver
+          // TODO: Issue relevant index use callbacks to QueryObserver
-          // TODO:Asif : Check this logic out
-          if (key != null && key.equals(QueryService.UNDEFINED))
+          // TODO: Check this logic out
+          if (key != null && key.equals(QueryService.UNDEFINED)) {
+          }
-      // Asif : This condition is filter evaluatable but both the RHS group as
+      // This condition is filter evaluatable but both the RHS group as
-        StringBuffer tempBuffLhs = new StringBuffer();
-        StringBuffer tempBuffRhs = new StringBuffer();
+        StringBuilder tempBuffLhs = new StringBuilder();
+        StringBuilder tempBuffRhs = new StringBuilder();
-        // Asif : The type of CompiledJunction has to be AND junction as this
-        // function gets invoked only for AND . Also it is OK if we have
-        // iterOperands which
-        // itself is a CompiledJunction. We can have a tree of CompiledJunction
-        // with its
-        // operands being a CompiledComparison & a CompiledJunction. We can live
-        // without
-        // creating a flat structure
+        // The type of CompiledJunction has to be AND junction as this function gets invoked only
+        // for AND . Also it is OK if we have iterOperands which itself is a CompiledJunction. We
+        // can have a tree of CompiledJunction with its operands being a CompiledComparison & a
+        // CompiledJunction. We can live without creating a flat structure
-          Collections.EMPTY_LIST, finalList, context, finalVal);
+          Collections.emptyList(), finalList, context, finalVal);
-   * Asif :This function is used to evaluate a filter evaluatable composite condition. It gets
-   * invoked either from a CompositeGroupJunction of "OR" type or a where clause containing single
-   * composite condition. In the later case the boolean completeExpansion flag is always true. While
-   * in the former case it may be true or false. If it is false, the array of independent iterators
-   * passed is not null.
+   * This function is used to evaluate a filter evaluatable composite condition. It gets invoked
+   * either from a CompositeGroupJunction of "OR" type or a where clause containing single composite
+   * condition. In the later case the boolean completeExpansion flag is always true. While in the
+   * former case it may be true or false. If it is false, the array of independent iterators passed
+   * is not null.
-   * 
-   * 
-   * @throws FunctionDomainException
-   * @throws TypeMismatchException
-   * @throws NameResolutionException
-   * @throws QueryInvocationTargetException
-   * 
-  static SelectResults getconditionedRelationshipIndexResultsExpandedToTopOrCGJLevel(List data,
+  static SelectResults getConditionedRelationshipIndexResultsExpandedToTopOrCGJLevel(List data,
-     * Asif : even if th complete expansion is needed pass the flag of complete expansion as false.
-     * Thus for LHS & RHS we will get the expansionList for that individual group. Thus the total
+     * even if th complete expansion is needed pass the flag of complete expansion as false. Thus
+     * for LHS & RHS we will get the expansionList for that individual group. Thus the total
-    IndexConditioningHelper ich1 =
-        new IndexConditioningHelper(indxInfo[0], context, indexFieldsSize1,
-            false/* Asif : pass it as false, irrespective of actual value */, iterOperands, null);
-    IndexConditioningHelper ich2 =
-        new IndexConditioningHelper(indxInfo[1], context, indexFieldsSize2,
-            false/* Asif : pass it as false, irrespective of actual value */, iterOperands, null);
+
+    // pass completeExpansion as false, irrespective of actual value
+    IndexConditioningHelper ich1 = new IndexConditioningHelper(indxInfo[0], context,
+        indexFieldsSize1, false, iterOperands, null);
+
+    // pass completeExpansion as false, irrespective of actual value
+    IndexConditioningHelper ich2 = new IndexConditioningHelper(indxInfo[1], context,
+        indexFieldsSize2, false, iterOperands, null);
+
-    // List[] checkList = new List[] { ich1.checkList, ich2.checkList};
+
-        // Asif :If the runtimeIterators of scope not present in CheckSet add it
-        // to
-        // the expansion list
+        // If the runtimeIterators of scope not present in CheckSet add it to the expansion list
-          // TODO:Asif Change the code in range Index so that while collecting
-          // data
-          // instead of creating
-          // two dimensional object array , we create one dimensional Object
-          // array
-          // of size 2, & each elemnt
-          // stores an Object array
+          // TODO: Change the code in range Index so that while collecting data instead of creating
+          // two dimensional object array , we create one dimensional Object array of size 2, & each
+          // elemnt stores an Object array
-          // Asif : Before doing the cartesian of the Results , we need to clear
-          // the
-          // CheckSet of IndexCutDownExpansionHelper. This is needed because for
-          // a
-          // new key , the row
-          // of sets needs to be considered fresh as presence of old row in
-          // checkset
-          // may cause us to wrongly
-          // skip the similar row of a set , even when the row in its entirety
-          // is
-          // unique ( made by
+          // Before doing the cartesian of the Results , we need to clear the CheckSet of
+          // IndexCutDownExpansionHelper. This is needed because for a new key , the row of sets
+          // needs to be considered fresh as presence of old row in checkset may cause us to wrongly
+          // skip the similar row of a set , even when the row in its entirety is unique ( made by
-  /*
-   * Asif : This function is used ony for testing the private visibility function
+  /**
+   * This function is used ony for testing the private visibility function
-    List data = null;
-    ArrayList resultData = new ArrayList();
+    List resultData = new ArrayList();
-    PartitionedRegion pr1 = null;
-    IndexProtocol i0 = null;
-    IndexProtocol i1 = null;
-      pr0 = ((BucketRegion) index0.getRegion()).getPartitionedRegion();
+      pr0 = ((Bucket) index0.getRegion()).getPartitionedRegion();
+    PartitionedRegion pr1 = null;
-      pr1 = ((BucketRegion) index1.getRegion()).getPartitionedRegion();
+      pr1 = ((Bucket) index1.getRegion()).getPartitionedRegion();
+    List data = null;
+    IndexProtocol i0 = null;
+    IndexProtocol i1 = null;
-      i0 = (pr0 != null) ? PartitionedIndex.getBucketIndex(pr0, index0.getName(), (Integer) b)
+      i0 = pr0 != null ? PartitionedIndex.getBucketIndex(pr0, index0.getName(), (Integer) b)
-      i1 = (pr1 != null) ? PartitionedIndex.getBucketIndex(pr1, index1.getName(), (Integer) b)
+      i1 = pr1 != null ? PartitionedIndex.getBucketIndex(pr1, index1.getName(), (Integer) b)
-
-
-/**
- * 
- * This is a helper class which provides information on how an index data be used so as to make it
- * compatible with the query.
- * 
- */
-
-class IndexConditioningHelper {
-
-  /**
-   * boolean if true implies that the index results need to be iterated so as to make it compatible
-   * with from clause. Shuffling may be needed for any of the following reasons: 1) Match level not
-   * zero ( implying index result expansion or cutdown) 2) Match level zero , but the relative
-   * positions of iterators in the List of iterators for the group not matching the positions in the
-   * index result StructBag 3) Iter operand is not null. *
-   * 
-   */
-  // If shuffling is not needed , then it can be bcoz of two reasons
-  // 1) The Index results is a ResultSet & match level is zero ( in that case we
-  // don't have to do anything)
-  // 2) The Index results is a StructBag with match level as zero & inddex
-  // fields matching
-  // the order of RuntimeIterators. In that case we just have to change the
-  // StructType of the StructBag
-  boolean shufflingNeeded = true;
-  /**
-   * An arary of RuntimeIterators whose size is equal to the number of fields in the Index results.
-   * It identifies the RuntimeIterator for the field in the Index Results. Thus the Runtime Iterator
-   * at position 0 will be that for field 0 in the index result & so on. For those index fields
-   * which do not have a Runtime Iterator assosciated , the value is null (This is the case if index
-   * results require cut down)
-   * 
-   */
-  RuntimeIterator[] indexFieldToItrsMapping = null;
-  /**
-   * The List containing RuntimeIterators to which the index results need to be expanded This will
-   * usually be Final List of RuntimeIterators - RuntimeIteratosr already accounted for in the index
-   * results
-   */
-  // Asif : The default is initialized as empty List rather than null to avoid
-  // Null Pointer Exception in the function
-  // getconditionedRelationshipIndexResults
-  List expansionList = Collections.EMPTY_LIST;
-  /**
-   * The List containing RuntimeIterators which define the final SelectResults after the relevant
-   * expansion/cutdown of index results
-   */
-  // Asif : Though in case of single index usage , if no shuffling is needed (
-  // exact match) we
-  // do not need finalList , but it is used in relation ship index , even if
-  // match level is zero.
-  // So we should never leave it as null
-  List finalList = null;
-  /**
-   * This is the List of RuntimeIterators which gets created only if the index resulst require a
-   * cutdown. In such cases , it identifies those Runtime Iterators of Index Results which will be
-   * selected to form the result tuple. The RuntimeIterators in this List will have corresponding
-   * fields in the resultset obtained from Index usage. This List will be populated only if there
-   * exists fields in index resultset which will not be selected.If all the fields of index
-   * resultset will be used , then this List should be null or empty. It is used in preventing
-   * unnecessary expansion of same type, when a similar expansion has already occurred. as for eg
-   * 
-   * consider a index result containing 3 fields field1 field2 & field3 . Assume that field3 is for
-   * cutdown. Since the expansion iterators can either be independent of all the fields in the index
-   * result or at the max be dependent on field1 & field2, we should expand for a given combination
-   * of field1 & field2 , only once ( as we have resulst as Set, we can only have unique entries)
-   * ie. suppose a index result tuple has values ( 1,2 , 3 ) & ( 1,2,4) , we should expand only once
-   * ( as field with value 3 & 4 are to be discarded).
-   * 
-   * 
-   * 
-   */
-  /*
-   * Asif: Below Can be null or empty collections if the match level is exact & no shuffling needed
-   */
-  List checkList = null;
-  /**
-   * Asif : This field is meaninful iff the match level is zero, no shuffling needed & there exists
-   * a StructBag (& not a ResultBag)
-   */
-  StructType structType = null;
-  /**
-   * Independent Iterator for the Group to which the Path expression belongs to
-   */
-  RuntimeIterator indpndntItr = null;
-  /**
-   * Indexnfo object for the path expression
-   */
-  IndexInfo indxInfo = null;
-
-  // TODO:Asif :Test this function out
-  public IndexConditioningHelper(IndexInfo indexInfo, ExecutionContext context, int indexFieldsSize,
-      boolean completeExpansion, CompiledValue iterOperands, RuntimeIterator grpIndpndntItr) {
-    /*
-     * Asif : First obtain the match level of index resultset. If the match level happens to be zero
-     * , this implies that we just have to change the StructType ( again if only the Index resultset
-     * is a StructBag). If the match level is zero & expand to to top level flag is true & iff the
-     * total no. of iterators in current scope is greater than the no. of fields in StructBag , then
-     * only we need to do any expansion. The grpIndpndtItr passed can be null if the where clause
-     * comprises of just this condition. However if it is invoked from GroupJunction , it will be
-     * not null
-     * 
-     */
-    this.indxInfo = indexInfo;
-    List grpItrs = null;
-    int size = indexInfo.mapping.length;
-    this.indpndntItr = grpIndpndntItr;
-    this.indexFieldToItrsMapping = new RuntimeIterator[indexFieldsSize];
-    // Asif Obtain the grpIndpndt iterator if it is passed as null
-    if (this.indpndntItr == null) {
-      Set set1 = new HashSet();
-      context.computeUtlimateDependencies(indexInfo._path, set1);
-      Support.Assert(set1.size() == 1,
-          " Since we are in Indexed Evaluate that means there has to be exactly one independent iterator for this compiled comparison");
-      // The ultimate independent RuntimeIterator
-      this.indpndntItr = (RuntimeIterator) set1.iterator().next();
-      Support.Assert(
-          this.indpndntItr.getScopeID() == context.currentScope()
-              .getScopeID()/* context.getScopeCount() */,
-          " Since we are in Indexed Evaluate that means the current scope count & indpenedent iterator's scope count should match");
-    }
-    if (indexInfo._matchLevel == 0
-        && (!completeExpansion || context.getCurrentIterators().size() == size)) {
-      // Asif: Don't do anything , just change the StructType if the set is
-      // structset.
-      if (size > 1) {
-        // The Index resultset is a structType.
-        Support.Assert(indexInfo._index.getResultSetType() instanceof StructType,
-            " If the match level is zero & the size of mapping array is 1 then Index is surely ResultBag else StructBag");
-        // Asif : The independent iterator is added as the first element
-        grpItrs = context.getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(this.indpndntItr);
-        // Asif : Check if reshuffling is needed or just changing the struct
-        // type will suffice
-        boolean isReshufflingNeeded = false;
-        int pos = -1;
-        for (int i = 0; i < size; ++i) {
-          pos = indexInfo.mapping[i];
-          isReshufflingNeeded = isReshufflingNeeded || (pos != (i + 1));
-          this.indexFieldToItrsMapping[pos - 1] = (RuntimeIterator) grpItrs.get(i);
-        }
-        this.finalList = grpItrs;
-        // Asif : Even if Reshuffle is not need but if the iter conditions are
-        // present we need to do evaluation
-        // We can avoid iterating over the set iff reshuffling is not needed &
-        // there is no iter eval condition
-        if (isReshufflingNeeded || iterOperands != null) {
-          // this.expansionList = Collections.EMPTY_LIST;
-          this.checkList = null;
-          // indexReults = QueryUtils.cutDownAndExpandIndexResults(indexReults,
-          // indexFieldToItrsMapping, Collections.EMPTY_LIST, grpItrs,
-          // context, Collections.EMPTY_LIST, iterOperands);
-        } else {
-          this.structType = QueryUtils.createStructTypeForRuntimeIterators(grpItrs);
-          // indexReults.setElementType(structType);
-          // Asif : Shuffling is not needed. Index results is a StructBag
-          // with match level zero & no expansion needed & index fields map
-          // with the RuntimeIterators. But we need to change the StructType
-          // of the StructBag
-          this.shufflingNeeded = false;
-        }
-      } else {
-        // Asif : The finalList should not be left uninitialized, & if the match
-        // level is zero
-        // & the Index Results is a ResultBag ( & not an StructBag ) implying
-        // indexFieldsSize of
-        // 1 , then the final List should contain only the independent iterator
-        this.finalList = new ArrayList();
-        this.finalList.add(this.indpndntItr);
-        Support.Assert(this.indexFieldToItrsMapping.length == 1,
-            "In this else block , it should be guaranteed that there exists only one iterator in query as well as index from clause & that should be nothing but the independent RuntimeIterator of the group  ");
-        this.indexFieldToItrsMapping[0] = this.indpndntItr;
-        // Asif :Shuffling is needed if iter operand is not null even if index results is a
-        // ResultSet
-        // with match level zero & no expansion needed
-        this.shufflingNeeded = (iterOperands != null);
-      }
-    } else {
-      // Asif : There is some expansion or truncation needed on the data
-      // obtained from index.Identify a the iterators belonging to this group
-      // The independent iterator is added as the first element
-      grpItrs = context.getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(this.indpndntItr);
-      // Asif Create an array of RuntimeIterators which map to the fields of the
-      // Index set.
-      // For those fields which do not have corresponding RuntimeIterator , keep
-      // it as null;
-      int pos = -1;
-      this.finalList = completeExpansion ? context.getCurrentIterators() : grpItrs;
-      // This is the List of runtimeIterators which have corresponding fields
-      // in the resultset obtained from Index usage. This List will be populated
-      // only if there exists fields in index resultset which will not be
-      // selected
-      // If all the fields of index resultset will be used , then this List
-      // should
-      // be null or empty
-      this.checkList = new ArrayList();
-      // This List contains the RuntimeIterators which are missing from
-      // index resultset but are present in the final iterators
-      this.expansionList = new LinkedList(finalList);
-      RuntimeIterator tempItr = null;
-      // boolean cutDownNeeded = false;
-      int unMappedFields = indexFieldsSize;
-      for (int i = 0; i < size; ++i) {
-        pos = indexInfo.mapping[i];
-        if (pos > 0) {
-          tempItr = (RuntimeIterator) grpItrs.get(i);
-          this.indexFieldToItrsMapping[pos - 1] = tempItr;
-          this.expansionList.remove(tempItr);
-          this.checkList.add(tempItr);
-          --unMappedFields;
-        }
-      }
-      boolean cutDownNeeded = unMappedFields > 0;
-      if (!cutDownNeeded)
-        this.checkList = null;
-      /*
-       * indexReults = QueryUtils.cutDownAndExpandIndexResults(indexReults, indexFieldToItrsMapping,
-       * expansionList, finalList, context, checkList, iterOperands);
-       */
-    }
-  }
-}
-
-
-/**
- * 
- * This is a helper class which contains informaion on how to expand / cutdown index results for
- * making it compatible with the query.
- * 
- */
-
-class IndexCutDownExpansionHelper {
-
-  /**
-   * booelan which identifies if a cutdown of index results is needed or not.
-   */
-  boolean cutDownNeeded = false;
-  /**
-   * A SelectResults ( ResultBag or StructBag) object used to prevent unnecessary expansion of index
-   * results as described in IndexConditionalHelper class.
-   */
-  SelectResults checkSet = null;
-  /**
-   * ObjectType for the checkSet object ( An ObjectType for a ResultBag & StructType for a
-   * StructBag)
-   */
-  ObjectType checkType = null;
-  int checkSize = -1;
-
-  IndexCutDownExpansionHelper(List checkList, ExecutionContext context) {
-    cutDownNeeded = checkList != null && (checkSize = checkList.size()) > 0;
-    if (cutDownNeeded) {
-      Boolean orderByClause = (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
-      boolean useLinkedDataStructure = false;
-      boolean nullValuesAtStart = true;
-      if (orderByClause != null && orderByClause.booleanValue()) {
-        List orderByAttrs = (List) context.cacheGet(CompiledValue.ORDERBY_ATTRIB);
-        useLinkedDataStructure = orderByAttrs.size() == 1;
-        nullValuesAtStart = !((CompiledSortCriterion) orderByAttrs.get(0)).getCriterion();
-      }
-      if (checkSize > 1) {
-
-        checkType = QueryUtils.createStructTypeForRuntimeIterators(checkList);
-        if (useLinkedDataStructure) {
-          checkSet = context.isDistinct() ? new LinkedStructSet((StructTypeImpl) checkType)
-              : new SortedResultsBag<Struct>((StructTypeImpl) checkType, nullValuesAtStart);
-        } else {
-          checkSet = QueryUtils.createStructCollection(context, (StructTypeImpl) checkType);
-        }
-      } else {
-        checkType = ((RuntimeIterator) checkList.get(0)).getElementType();
-        if (useLinkedDataStructure) {
-          checkSet = context.isDistinct() ? new LinkedResultSet(checkType)
-              : new SortedResultsBag(checkType, nullValuesAtStart);
-        } else {
-          checkSet = QueryUtils.createResultCollection(context, checkType);
-        }
-      }
-    }
-  }
-
-}

MOV26 MOV26 UPD40 UPD83 INS29 MOV60 UPD42 UPD42 INS29 MOV60 MOV25 MOV25 INS70 INS65 INS5 INS5 INS65 UPD66 INS65 INS66 INS65 UPD66 UPD66 INS65 UPD66 INS65 INS66 INS66 INS65 UPD66 UPD66 INS65 INS44 INS42 INS8 INS66 INS66 INS66 INS66 INS66 INS66 INS66 MOV43 INS85 MOV43 INS85 MOV60 UPD66 UPD66 UPD66 UPD66 INS5 INS5 MOV14 UPD66 UPD66 UPD66 UPD43 UPD66 UPD66 INS8 INS8 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD43 INS66 INS66 INS66 INS66 INS66 INS66 MOV43 INS42 MOV21 MOV27 MOV60 MOV60 INS42 INS70 MOV43 INS85 MOV43 INS85 UPD42 UPD42 MOV41 MOV41 MOV27 UPD42 INS70 UPD42 INS70 INS70 MOV11 INS5 INS44 INS42 MOV8 INS8 INS44 INS42 MOV8 MOV27 INS70 INS70 INS44 INS42 MOV8 INS44 INS42 MOV8 MOV43 INS85 INS43 INS42 MOV21 MOV43 INS42 UPD42 UPD42 INS44 INS42 MOV8 UPD42 INS44 INS42 MOV8 UPD42 INS42 INS43 INS42 MOV43 INS42 INS27 MOV11 INS5 UPD42 MOV42 INS32 MOV27 MOV27 MOV43 INS42 MOV43 INS42 UPD42 MOV42 MOV27 MOV27 INS32 INS33 MOV43 INS85 UPD42 MOV42 INS42 INS42 INS42 UPD43 UPD43 INS42 INS42 UPD42 MOV42 MOV42 MOV42 MOV40 INS13 UPD42 UPD42 UPD43 UPD43 INS5 INS13 INS8 UPD43 UPD43 UPD42 UPD42 UPD42 MOV43 INS85 INS18 UPD42 UPD42 MOV43 UPD42 MOV42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL65 DEL83 DEL42 DEL42 DEL2 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL38 DEL8 DEL24 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL36 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL85 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL36 DEL42 DEL32 DEL85 DEL36 DEL85 DEL36 DEL85 DEL42 DEL42 DEL32 DEL36 DEL33 DEL27 DEL42 DEL43 DEL32 DEL11 DEL36 DEL42 DEL32 DEL83 DEL85 DEL45 DEL45 DEL33 DEL42 DEL32 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL83 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL43 DEL42 DEL11 DEL36 DEL83 DEL85 DEL85 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL83 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL36 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL42 DEL2 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL38 DEL24 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL36 DEL18 DEL40 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL36 DEL36 DEL66 DEL66 DEL65 DEL29 DEL42 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL39 DEL42 DEL9 DEL59 DEL23 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL85 DEL5 DEL42 DEL33 DEL59 DEL23 DEL66 DEL66 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL40 DEL59 DEL23 DEL66 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL33 DEL59 DEL23 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL33 DEL59 DEL23 DEL66 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL33 DEL59 DEL23 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL33 DEL59 DEL23 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL33 DEL59 DEL23 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL33 DEL59 DEL60 DEL39 DEL42 DEL40 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL43 DEL85 DEL5 DEL42 DEL3 DEL7 DEL21 DEL52 DEL42 DEL22 DEL33 DEL27 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL40 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL34 DEL27 DEL45 DEL32 DEL21 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL32 DEL11 DEL7 DEL21 DEL42 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL27 DEL45 DEL32 DEL21 DEL8 DEL25 DEL40 DEL34 DEL27 DEL42 DEL38 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL27 DEL27 DEL36 DEL27 DEL42 DEL34 DEL27 DEL42 DEL42 DEL40 DEL42 DEL32 DEL42 DEL43 DEL62 DEL45 DEL32 DEL21 DEL42 DEL42 DEL42 DEL52 DEL42 DEL22 DEL32 DEL7 DEL21 DEL39 DEL42 DEL9 DEL59 DEL60 DEL39 DEL42 DEL34 DEL38 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL38 DEL42 DEL40 DEL42 DEL2 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL34 DEL27 DEL36 DEL27 DEL36 DEL27 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL34 DEL27 DEL2 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL8 DEL24 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL42 DEL33 DEL27 DEL27 DEL52 DEL42 DEL22 DEL33 DEL7 DEL21 DEL8 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL8 DEL25 DEL8 DEL52 DEL42 DEL22 DEL42 DEL43 DEL14 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL32 DEL21 DEL42 DEL42 DEL52 DEL42 DEL22 DEL42 DEL22 DEL34 DEL27 DEL45 DEL32 DEL21 DEL52 DEL42 DEL22 DEL34 DEL2 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL33 DEL27 DEL36 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL42 DEL52 DEL42 DEL22 DEL32 DEL7 DEL21 DEL39 DEL42 DEL34 DEL38 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL32 DEL42 DEL16 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL43 DEL14 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL14 DEL7 DEL21 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL39 DEL42 DEL42 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL38 DEL42 DEL40 DEL42 DEL2 DEL7 DEL21 DEL42 DEL34 DEL27 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL34 DEL27 DEL2 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL21 DEL42 DEL38 DEL21 DEL8 DEL25 DEL8 DEL24 DEL39 DEL42 DEL42 DEL34 DEL27 DEL59 DEL60 DEL42 DEL38 DEL52 DEL42 DEL22 DEL33 DEL7 DEL21 DEL25 DEL8 DEL25 DEL8 DEL31 DEL55 DEL66 DEL66 DEL65 DEL29 DEL42 DEL66 DEL65 DEL29 DEL39 DEL42 DEL9 DEL59 DEL23 DEL66 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL33 DEL59 DEL23 DEL66 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL33 DEL59 DEL23 DEL39 DEL42 DEL34 DEL38 DEL59 DEL23 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL7 DEL36 DEL34 DEL27 DEL27 DEL7 DEL21 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL40 DEL32 DEL11 DEL59 DEL60 DEL39 DEL42 DEL9 DEL59 DEL60 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL27 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL40 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL34 DEL27 DEL7 DEL21 DEL42 DEL42 DEL43 DEL42 DEL42 DEL34 DEL32 DEL11 DEL36 DEL42 DEL32 DEL38 DEL7 DEL21 DEL8 DEL25 DEL42 DEL34 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL43 DEL42 DEL11 DEL14 DEL42 DEL43 DEL74 DEL42 DEL43 DEL42 DEL11 DEL42 DEL14 DEL16 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL43 DEL42 DEL42 DEL34 DEL32 DEL11 DEL36 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL14 DEL42 DEL43 DEL42 DEL42 DEL14 DEL16 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL8 DEL31 DEL55
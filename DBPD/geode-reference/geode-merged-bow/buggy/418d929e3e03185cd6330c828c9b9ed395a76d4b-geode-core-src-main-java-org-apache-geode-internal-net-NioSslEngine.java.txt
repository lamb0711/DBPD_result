GEODE-6661: Fixed use of Direct and Non-Direct buffers (#4267)

- Fixed use of Direct and Non-Direct buffers
-  /**
-   * buffer used to receive data during TLS handshake
-   */
-  ByteBuffer handshakeBuffer;
-
-    this.myNetData = ByteBuffer.allocate(packetBufferSize);
-    this.peerAppData = ByteBuffer.allocate(appBufferSize);
+    this.myNetData = bufferPool.acquireDirectSenderBuffer(packetBufferSize);
+    this.peerAppData = bufferPool.acquireNonDirectReceiveBuffer(appBufferSize);
-    if (peerNetData.capacity() < engine.getSession().getPacketBufferSize()) {
-      if (logger.isDebugEnabled()) {
-        logger.debug("Allocating new buffer for SSL handshake");
-      }
-      this.handshakeBuffer =
-          bufferPool.acquireReceiveBuffer(engine.getSession().getPacketBufferSize());
-    } else {
-      this.handshakeBuffer = peerNetData;
+    if (logger.isDebugEnabled()) {
+      logger.debug("Allocating new buffer for SSL handshake");
-    this.handshakeBuffer.clear();
+    ByteBuffer handshakeBuffer =
+        bufferPool.acquireDirectReceiveBuffer(engine.getSession().getPacketBufferSize());
-    // Process handshaking message
-    while (status != FINISHED &&
-        status != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
-      if (socketChannel.socket().isClosed()) {
-        logger.info("Handshake terminated because socket is closed");
-        throw new SocketException("handshake terminated - socket is closed");
-      }
-
-      if (timeoutNanos > 0) {
-        if (timeoutNanos < System.nanoTime()) {
-          logger.info("TLS handshake is timing out");
-          throw new SocketTimeoutException("handshake timed out");
+    try {
+      // Process handshaking message
+      while (status != FINISHED &&
+          status != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
+        if (socketChannel.socket().isClosed()) {
+          logger.info("Handshake terminated because socket is closed");
+          throw new SocketException("handshake terminated - socket is closed");
+
+        if (timeoutNanos > 0) {
+          if (timeoutNanos < System.nanoTime()) {
+            logger.info("TLS handshake is timing out");
+            throw new SocketTimeoutException("handshake timed out");
+          }
+        }
+
+        switch (status) {
+          case NEED_UNWRAP:
+            // Receive handshaking data from peer
+            int dataRead = socketChannel.read(handshakeBuffer);
+
+            // Process incoming handshaking data
+            handshakeBuffer.flip();
+            engineResult = engine.unwrap(handshakeBuffer, peerAppData);
+            handshakeBuffer.compact();
+            status = engineResult.getHandshakeStatus();
+
+            // if we're not finished, there's nothing to process and no data was read let's hang out
+            // for a little
+            if (peerAppData.remaining() == 0 && dataRead == 0 && status == NEED_UNWRAP) {
+              Thread.sleep(10);
+            }
+
+            if (engineResult.getStatus() == BUFFER_OVERFLOW) {
+              peerAppData =
+                  expandWriteBuffer(TRACKED_RECEIVER, peerAppData, peerAppData.capacity() * 2);
+            }
+            break;
+
+          case NEED_WRAP:
+            // Empty the local network packet buffer.
+            myNetData.clear();
+
+            // Generate handshaking data
+            engineResult = engine.wrap(myAppData, myNetData);
+            status = engineResult.getHandshakeStatus();
+
+            // Check status
+            switch (engineResult.getStatus()) {
+              case BUFFER_OVERFLOW:
+                myNetData =
+                    expandWriteBuffer(TRACKED_SENDER, myNetData,
+                        myNetData.capacity() * 2);
+                break;
+              case OK:
+                myNetData.flip();
+                // Send the handshaking data to peer
+                while (myNetData.hasRemaining()) {
+                  socketChannel.write(myNetData);
+                }
+                break;
+              case CLOSED:
+                break;
+              default:
+                logger.info("handshake terminated with illegal state due to {}", status);
+                throw new IllegalStateException(
+                    "Unknown SSLEngineResult status: " + engineResult.getStatus());
+            }
+            break;
+          case NEED_TASK:
+            // Handle blocking tasks
+            handleBlockingTasks();
+            status = engine.getHandshakeStatus();
+            break;
+          default:
+            logger.info("handshake terminated with illegal state due to {}", status);
+            throw new IllegalStateException("Unknown SSL Handshake state: " + status);
+        }
+        Thread.sleep(10);
-
-      switch (status) {
-        case NEED_UNWRAP:
-          // Receive handshaking data from peer
-          int dataRead = socketChannel.read(handshakeBuffer);
-
-          // Process incoming handshaking data
-          handshakeBuffer.flip();
-          engineResult = engine.unwrap(handshakeBuffer, peerAppData);
-          handshakeBuffer.compact();
-          status = engineResult.getHandshakeStatus();
-
-          // if we're not finished, there's nothing to process and no data was read let's hang out
-          // for a little
-          if (peerAppData.remaining() == 0 && dataRead == 0 && status == NEED_UNWRAP) {
-            Thread.sleep(10);
-          }
-
-          if (engineResult.getStatus() == BUFFER_OVERFLOW) {
-            peerAppData =
-                expandWriteBuffer(TRACKED_RECEIVER, peerAppData, peerAppData.capacity() * 2);
-          }
-          break;
-
-        case NEED_WRAP:
-          // Empty the local network packet buffer.
-          myNetData.clear();
-
-          // Generate handshaking data
-          engineResult = engine.wrap(myAppData, myNetData);
-          status = engineResult.getHandshakeStatus();
-
-          // Check status
-          switch (engineResult.getStatus()) {
-            case BUFFER_OVERFLOW:
-              myNetData =
-                  expandWriteBuffer(TRACKED_SENDER, myNetData,
-                      myNetData.capacity() * 2);
-              break;
-            case OK:
-              myNetData.flip();
-              // Send the handshaking data to peer
-              while (myNetData.hasRemaining()) {
-                socketChannel.write(myNetData);
-              }
-              break;
-            case CLOSED:
-              break;
-            default:
-              logger.info("handshake terminated with illegal state due to {}", status);
-              throw new IllegalStateException(
-                  "Unknown SSLEngineResult status: " + engineResult.getStatus());
-          }
-          break;
-        case NEED_TASK:
-          // Handle blocking tasks
-          handleBlockingTasks();
-          status = engine.getHandshakeStatus();
-          break;
-        default:
-          logger.info("handshake terminated with illegal state due to {}", status);
-          throw new IllegalStateException("Unknown SSL Handshake state: " + status);
-      }
-      Thread.sleep(10);
+    } finally {
+      bufferPool.releaseReceiveBuffer(handshakeBuffer);
-      buffer = bufferPool.acquireBuffer(bufferType, requiredSize);
+      buffer = bufferPool.acquireDirectBuffer(bufferType, requiredSize);

MOV21 MOV21 MOV25 INS60 INS54 MOV43 INS59 INS8 INS8 INS42 MOV32 MOV61 MOV21 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 UPD42 UPD42 DEL66 DEL65 DEL29 DEL42 DEL59 DEL23 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL27 DEL52 DEL42 DEL22 DEL7 DEL21 DEL8 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL25 DEL52 DEL42 DEL22
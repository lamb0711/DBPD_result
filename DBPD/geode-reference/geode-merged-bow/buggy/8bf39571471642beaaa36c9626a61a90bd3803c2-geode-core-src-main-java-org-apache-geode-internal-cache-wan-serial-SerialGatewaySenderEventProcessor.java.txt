Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-   * A <code>Map</code> of events that have not been processed by the primary
-   * yet. This map is created and used by a secondary <code>GatewaySender</code> to
-   * keep track of events that have been received by the secondary but not yet
-   * processed by the primary. Once an event has been processed by the primary,
-   * it is removed from this map. This map will only be used in the event that
-   * this <code>GatewaySender</code> becomes the primary. Any events contained in this
-   * map will need to be sent to other <code>GatewayReceiver</code>s. Note:
-   * unprocessedEventsLock MUST be synchronized before using this map.
+   * A <code>Map</code> of events that have not been processed by the primary yet. This map is
+   * created and used by a secondary <code>GatewaySender</code> to keep track of events that have
+   * been received by the secondary but not yet processed by the primary. Once an event has been
+   * processed by the primary, it is removed from this map. This map will only be used in the event
+   * that this <code>GatewaySender</code> becomes the primary. Any events contained in this map will
+   * need to be sent to other <code>GatewayReceiver</code>s. Note: unprocessedEventsLock MUST be
+   * synchronized before using this map.
-   * A <code>Map</code> of tokens (i.e. longs) of entries that we have heard of
-   * from the primary but not yet the secondary. This map is created and used by
-   * a secondary <code>GatewaySender</code> to keep track. Note: unprocessedEventsLock
-   * MUST be synchronized before using this map. This is not a cut and paste
-   * error. sync unprocessedEventsLock when using unprocessedTokens.
+   * A <code>Map</code> of tokens (i.e. longs) of entries that we have heard of from the primary but
+   * not yet the secondary. This map is created and used by a secondary <code>GatewaySender</code>
+   * to keep track. Note: unprocessedEventsLock MUST be synchronized before using this map. This is
+   * not a cut and paste error. sync unprocessedEventsLock when using unprocessedTokens.
-  
+
-  
+
-  
+
-   * When the Number of unchecked events exceeds this threshold and the number
-   * of tokens in the map exceeds this threshold then a check will be done for
-   * old tokens.
+   * When the Number of unchecked events exceeds this threshold and the number of tokens in the map
+   * exceeds this threshold then a check will be done for old tokens.
-  
-  
+
+
-    super(LoggingThreadGroup.createThreadGroup(
-        "Event Processor for GatewaySender_" + id,
-        logger), "Event Processor for GatewaySender_"
-        + id, sender);
-    
+    super(LoggingThreadGroup.createThreadGroup("Event Processor for GatewaySender_" + id, logger),
+        "Event Processor for GatewaySender_" + id, sender);
+
-    regionNameBuffer.append(id).append(
-        "_SERIAL_GATEWAY_SENDER_QUEUE");
+    regionNameBuffer.append(id).append("_SERIAL_GATEWAY_SENDER_QUEUE");
-        logger.fatal(LocalizedMessage.create(LocalizedStrings.GatewayImpl_AN_INTERRUPTEDEXCEPTION_OCCURRED_THE_THREAD_WILL_EXIT), e);
+        logger.fatal(
+            LocalizedMessage.create(
+                LocalizedStrings.GatewayImpl_AN_INTERRUPTEDEXCEPTION_OCCURRED_THE_THREAD_WILL_EXIT),
+            e);
-  
+
-        logger.warn(LocalizedMessage.create(LocalizedStrings.GatewayImpl_ABOUT_TO_PROCESS_THE_MESSAGE_QUEUE_BUT_NOT_THE_PRIMARY));
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.GatewayImpl_ABOUT_TO_PROCESS_THE_MESSAGE_QUEUE_BUT_NOT_THE_PRIMARY));
-        logger.info(LocalizedMessage.create(LocalizedStrings.GatewayImpl_A_CANCELLATION_OCCURRED_STOPPING_THE_DISPATCHER));
+        logger.info(LocalizedMessage
+            .create(LocalizedStrings.GatewayImpl_A_CANCELLATION_OCCURRED_STOPPING_THE_DISPATCHER));
-      logger.fatal(LocalizedMessage.create(LocalizedStrings.GatewayImpl_MESSAGE_DISPATCH_FAILED_DUE_TO_UNEXPECTED_EXCEPTION), e);
+      logger.fatal(LocalizedMessage.create(
+          LocalizedStrings.GatewayImpl_MESSAGE_DISPATCH_FAILED_DUE_TO_UNEXPECTED_EXCEPTION), e);
-  
+
-   * Handle failover. This method is called when a secondary
-   * <code>GatewaySender</code> becomes a primary <code>GatewaySender</code>.
+   * Handle failover. This method is called when a secondary <code>GatewaySender</code> becomes a
+   * primary <code>GatewaySender</code>.
-   * <li>Process the map of unprocessed events (those it has seen but the
-   * previous primary had not yet processed before it crashed). These will
-   * include both queued and unqueued events. Remove from the queue any events
-   * that were already sent
+   * <li>Process the map of unprocessed events (those it has seen but the previous primary had not
+   * yet processed before it crashed). These will include both queued and unqueued events. Remove
+   * from the queue any events that were already sent
-     * We must hold this lock while we're processing these maps to prevent us
-     * from handling a secondary event while failover occurs. See enqueueEvent
+     * We must hold this lock while we're processing these maps to prevent us from handling a
+     * secondary event while failover occurs. See enqueueEvent
-      logger.info(LocalizedMessage.create(LocalizedStrings.GatewayImpl_GATEWAY_FAILOVER_INITIATED_PROCESSING_0_UNPROCESSED_EVENTS,
-              this.unprocessedEvents.size()));
+      logger.info(LocalizedMessage.create(
+          LocalizedStrings.GatewayImpl_GATEWAY_FAILOVER_INITIATED_PROCESSING_0_UNPROCESSED_EVENTS,
+          this.unprocessedEvents.size()));
-              GatewaySenderEventImpl ge = (GatewaySenderEventImpl)o;
+              GatewaySenderEventImpl ge = (GatewaySenderEventImpl) o;
-          Iterator<Map.Entry<EventID, EventWrapper>> it = this.unprocessedEvents.entrySet().iterator();
+          Iterator<Map.Entry<EventID, EventWrapper>> it =
+              this.unprocessedEvents.entrySet().iterator();
-            if (stopped()) break;
+            if (stopped())
+              break;
-              // Initialize each gateway event. This initializes the key,
-              // value
-              // and callback arg based on the EntryEvent.
-              // TODO:wan70, remove dependencies from old code
-              gatewayEvent.initialize();
+            // Initialize each gateway event. This initializes the key,
+            // value
+            // and callback arg based on the EntryEvent.
+            // TODO:wan70, remove dependencies from old code
+            gatewayEvent.initialize();
-            GatewaySenderEventCallbackArgument seca = gatewayEvent
-                .getSenderCallbackArgument();
+            GatewaySenderEventCallbackArgument seca = gatewayEvent.getSenderCallbackArgument();
-              seca.initializeReceipientDSIds(Collections.singletonList(sender
-                  .getRemoteDSId()));
+              seca.initializeReceipientDSIds(Collections.singletonList(sender.getRemoteDSId()));
-                logger.warn(LocalizedMessage.create(LocalizedStrings.GatewayImpl_EVENT_DROPPED_DURING_FAILOVER_0, gatewayEvent), ex);
+                logger.warn(
+                    LocalizedMessage.create(
+                        LocalizedStrings.GatewayImpl_EVENT_DROPPED_DURING_FAILOVER_0, gatewayEvent),
+                    ex);
-                logger.warn(LocalizedMessage.create(LocalizedStrings.GatewayImpl_EVENT_DROPPED_DURING_FAILOVER_0, gatewayEvent), ex);
+                logger.warn(
+                    LocalizedMessage.create(
+                        LocalizedStrings.GatewayImpl_EVENT_DROPPED_DURING_FAILOVER_0, gatewayEvent),
+                    ex);
-      logger.info(LocalizedMessage.create(LocalizedStrings.GatewayImpl_0__MARKING__1__EVENTS_AS_POSSIBLE_DUPLICATES,
-         new Object[] {getSender(), Integer.valueOf(this.queue.size())}));
+      logger.info(LocalizedMessage.create(
+          LocalizedStrings.GatewayImpl_0__MARKING__1__EVENTS_AS_POSSIBLE_DUPLICATES,
+          new Object[] {getSender(), Integer.valueOf(this.queue.size())}));
-          GatewaySenderEventImpl ge = (GatewaySenderEventImpl)o;
+          GatewaySenderEventImpl ge = (GatewaySenderEventImpl) o;
-  
+
-        for (EventWrapper ew: m.values()) {
+        for (EventWrapper ew : m.values()) {
-  
+
-  public void enqueueEvent(EnumListenerEvent operation, EntryEvent event,
-      Object substituteValue) throws IOException, CacheException {
+  public void enqueueEvent(EnumListenerEvent operation, EntryEvent event, Object substituteValue)
+      throws IOException, CacheException {
-          senderEvent = new GatewaySenderEventImpl(operation, event, substituteValue, false); // OFFHEAP ok
+          senderEvent = new GatewaySenderEventImpl(operation, event, substituteValue, false); // OFFHEAP
+                                                                                              // ok
-      boolean isPDXRegion = (region instanceof DistributedRegion && region.getName().equals(PeerTypeRegistration.REGION_NAME));
+      boolean isPDXRegion = (region instanceof DistributedRegion
+          && region.getName().equals(PeerTypeRegistration.REGION_NAME));
-      
-      boolean queuedEvent =false;
+
+      boolean queuedEvent = false;
-        //When queuePrimaryEvent() failed with some exception, it could
-        //occur after the GatewaySenderEventImpl is put onto the queue.
-        //In that case, the GatewaySenderEventImpl could be released here,
-        //and IllegalStateException could be thrown if getDeserializedValue is called
-        //when the event is accessed through the region queue.
+        // When queuePrimaryEvent() failed with some exception, it could
+        // occur after the GatewaySenderEventImpl is put onto the queue.
+        // In that case, the GatewaySenderEventImpl could be released here,
+        // and IllegalStateException could be thrown if getDeserializedValue is called
+        // when the event is accessed through the region queue.
-      logger.debug("{}: Queueing event ({}): {}", sender.getId(), (statistics.getEventsQueued() + 1), gatewayEvent);
+      logger.debug("{}: Queueing event ({}): {}", sender.getId(),
+          (statistics.getEventsQueued() + 1), gatewayEvent);
-      putDone = this.queue.put(gatewayEvent);      
+      putDone = this.queue.put(gatewayEvent);
-      logger.debug("{}: Queued event ({}): {}", sender.getId(), (statistics.getEventsQueued()), gatewayEvent);
+      logger.debug("{}: Queued event ({}): {}", sender.getId(), (statistics.getEventsQueued()),
+          gatewayEvent);
-    if (!this.eventQueueSizeWarning
-        && queueSize >= AbstractGatewaySender.QUEUE_SIZE_THRESHOLD) {
-      logger.warn(LocalizedMessage.create(LocalizedStrings.GatewayImpl_0_THE_EVENT_QUEUE_SIZE_HAS_REACHED_THE_THRESHOLD_1,
-              new Object[] { sender.getId(), Integer.valueOf(AbstractGatewaySender.QUEUE_SIZE_THRESHOLD) }));
+    if (!this.eventQueueSizeWarning && queueSize >= AbstractGatewaySender.QUEUE_SIZE_THRESHOLD) {
+      logger.warn(LocalizedMessage.create(
+          LocalizedStrings.GatewayImpl_0_THE_EVENT_QUEUE_SIZE_HAS_REACHED_THE_THRESHOLD_1,
+          new Object[] {sender.getId(),
+              Integer.valueOf(AbstractGatewaySender.QUEUE_SIZE_THRESHOLD)}));
-      logger.info(LocalizedMessage.create(LocalizedStrings.GatewayImpl_0__WAITING_FOR_FAILOVER_COMPLETION, this));
+      logger.info(LocalizedMessage
+          .create(LocalizedStrings.GatewayImpl_0__WAITING_FOR_FAILOVER_COMPLETION, this));
-        logger.info(LocalizedMessage.create(LocalizedStrings.GatewayImpl_0_DID_NOT_WAIT_FOR_FAILOVER_COMPLETION_DUE_TO_INTERRUPTION, this));
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.GatewayImpl_0_DID_NOT_WAIT_FOR_FAILOVER_COMPLETION_DUE_TO_INTERRUPTION,
+            this));
-   * Update an unprocessed event in the unprocessed events map. This method is
-   * called by a secondary <code>GatewaySender</code> to store a gateway event until
-   * it is processed by a primary <code>GatewaySender</code>. The complexity of this
-   * method is the fact that the event could be processed first by either the
-   * primary or secondary <code>GatewaySender</code>.
+   * Update an unprocessed event in the unprocessed events map. This method is called by a secondary
+   * <code>GatewaySender</code> to store a gateway event until it is processed by a primary
+   * <code>GatewaySender</code>. The complexity of this method is the fact that the event could be
+   * processed first by either the primary or secondary <code>GatewaySender</code>.
-   * If the primary processes the event first, the map will already contain an
-   * entry for the event (through
+   * If the primary processes the event first, the map will already contain an entry for the event
+   * (through
-   * If the secondary processes the event first, it will add it to the map. When
-   * the primary processes the event (through
+   * If the secondary processes the event first, it will add it to the map. When the primary
+   * processes the event (through
-   * @param senderEvent
-   *          The event being processed
+   * @param senderEvent The event being processed
-   * Update an unprocessed event in the unprocessed events map. This method is
-   * called by a primary <code>Gateway</code> (through
-   * {@link org.apache.geode.internal.cache.wan.serial.SerialSecondaryGatewayListener#afterCreate}
-   * ) to notify the secondary <code>Gateway</code> that an event has been added
-   * to the queue. Once an event has been added to the queue, the secondary no
-   * longer needs to keep track of it in the unprocessed events map. The
-   * complexity of this method is the fact that the event could be processed
-   * first by either the primary or secondary <code>Gateway</code>.
+   * Update an unprocessed event in the unprocessed events map. This method is called by a primary
+   * <code>Gateway</code> (through
+   * {@link org.apache.geode.internal.cache.wan.serial.SerialSecondaryGatewayListener#afterCreate} )
+   * to notify the secondary <code>Gateway</code> that an event has been added to the queue. Once an
+   * event has been added to the queue, the secondary no longer needs to keep track of it in the
+   * unprocessed events map. The complexity of this method is the fact that the event could be
+   * processed first by either the primary or secondary <code>Gateway</code>.
-   * If the primary processes the event first, the map will not contain an entry
-   * for the event. It will be added to the map in this case so that when the
-   * secondary processes it, it will know that the primary has already processed
-   * it, and it can be safely removed.
+   * If the primary processes the event first, the map will not contain an entry for the event. It
+   * will be added to the map in this case so that when the secondary processes it, it will know
+   * that the primary has already processed it, and it can be safely removed.
-   * If the secondary processes the event first, the map will already contain an
-   * entry for the event. In this case, the event can be removed from the map.
+   * If the secondary processes the event first, the map will already contain an entry for the
+   * event. In this case, the event can be removed from the map.
-   * @param gatewayEvent
-   *          The event being processed
+   * @param gatewayEvent The event being processed
-      }
-      catch (RejectedExecutionException ex) {
+      } catch (RejectedExecutionException ex) {
-   * Called when the primary gets rid of an event from the queue This method
-   * added to fix bug 37603
+   * Called when the primary gets rid of an event from the queue This method added to fix bug 37603
-      }
-      catch (RejectedExecutionException ex) {
+      } catch (RejectedExecutionException ex) {
-   * Just remove the event from the unprocessed events map if it is present.
-   * This method added to fix bug 37603
+   * Just remove the event from the unprocessed events map if it is present. This method added to
+   * fix bug 37603
-  protected void basicHandlePrimaryDestroy(
-      final GatewaySenderEventImpl gatewayEvent) {
+  protected void basicHandlePrimaryDestroy(final GatewaySenderEventImpl gatewayEvent) {
-  protected void basicHandlePrimaryEvent(
-      final GatewaySenderEventImpl gatewayEvent) {
+  protected void basicHandlePrimaryEvent(final GatewaySenderEventImpl gatewayEvent) {
-              sender.getId(), gatewayEvent.getEventId(), gatewayEvent.getKey(), gatewayEvent.getValueAsString(true));
+              sender.getId(), gatewayEvent.getEventId(), gatewayEvent.getKey(),
+              gatewayEvent.getValueAsString(true));
-          Long mapValue = Long.valueOf(System.currentTimeMillis()
-              + AbstractGatewaySender.TOKEN_TIMEOUT);
+          Long mapValue =
+              Long.valueOf(System.currentTimeMillis() + AbstractGatewaySender.TOKEN_TIMEOUT);
-          logger.trace("{}: Primary create/update event {}:{}->{} remove from unprocessed events map",
-              sender.getId(), gatewayEvent.getEventId(), gatewayEvent.getKey(), gatewayEvent.getValueAsString(true));
+          logger.trace(
+              "{}: Primary create/update event {}:{}->{} remove from unprocessed events map",
+              sender.getId(), gatewayEvent.getEventId(), gatewayEvent.getKey(),
+              gatewayEvent.getValueAsString(true));
-  private void basicHandleSecondaryEvent(
-      final GatewaySenderEventImpl gatewayEvent) {
+  private void basicHandleSecondaryEvent(final GatewaySenderEventImpl gatewayEvent) {
-    GatewaySenderStats statistics = this.sender.getStatistics();
-    // Get the event from the map
+      GatewaySenderStats statistics = this.sender.getStatistics();
+      // Get the event from the map
-     if (!getSender().getGatewayEventFilters().isEmpty()) {
-      try {
-        gatewayEvent.initialize();
-      }
-      catch (Exception e) {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.GatewayImpl_EVENT_FAILED_TO_BE_INITIALIZED_0, gatewayEvent), e);
-      }
-      if (!sender.beforeEnqueue(gatewayEvent)) {
-        statistics.incEventsFiltered();
-        return;
-      }
-    }
-    Assert.assertHoldsLock(unprocessedEventsLock, true);
-    Assert.assertTrue(unprocessedEvents != null);
-    // @todo add an assertion that !getPrimary()
-    // now we can safely use the unprocessedEvents field
-    Long v = this.unprocessedTokens.remove(gatewayEvent.getEventId());
-
-    if (v == null) {
-      // first time for the event
-      if (logger.isTraceEnabled()) {
-        logger.trace("{}: fromSecondary event {}:{}->{} added from unprocessed events map",
-            sender.getId(), gatewayEvent.getEventId(), gatewayEvent.getKey(), gatewayEvent.getValueAsString(true));
-      }
-      {
-        EventWrapper mapValue = new EventWrapper(gatewayEvent);
-        EventWrapper oldv = this.unprocessedEvents.put(gatewayEvent.getEventId(), mapValue);
-        if (oldv == null) {
-          freeGatewayEvent = false;
-          statistics.incUnprocessedEventsAddedBySecondary();
-        } else {
-          // put old one back in
-          this.unprocessedEvents.put(gatewayEvent.getEventId(), oldv);
-          // already added by secondary (i.e. hub)
+      if (!getSender().getGatewayEventFilters().isEmpty()) {
+        try {
+          gatewayEvent.initialize();
+        } catch (Exception e) {
-              LocalizedStrings.GatewayImpl_0_THE_UNPROCESSED_EVENTS_MAP_ALREADY_CONTAINED_AN_EVENT_FROM_THE_HUB_1_SO_IGNORING_NEW_EVENT_2,
-              new Object[] { sender.getId(), v, gatewayEvent }));
+              LocalizedStrings.GatewayImpl_EVENT_FAILED_TO_BE_INITIALIZED_0, gatewayEvent), e);
+        }
+        if (!sender.beforeEnqueue(gatewayEvent)) {
+          statistics.incEventsFiltered();
+          return;
-    } else {
-      // token already added by primary already removed
-      if (logger.isTraceEnabled()) {
-        logger.trace("{}: Secondary created event {}:{}->{} removed from unprocessed events map",
-            sender.getId(), gatewayEvent.getEventId(), gatewayEvent.getKey(), gatewayEvent.getValueAsString(true));
+      Assert.assertHoldsLock(unprocessedEventsLock, true);
+      Assert.assertTrue(unprocessedEvents != null);
+      // @todo add an assertion that !getPrimary()
+      // now we can safely use the unprocessedEvents field
+      Long v = this.unprocessedTokens.remove(gatewayEvent.getEventId());
+
+      if (v == null) {
+        // first time for the event
+        if (logger.isTraceEnabled()) {
+          logger.trace("{}: fromSecondary event {}:{}->{} added from unprocessed events map",
+              sender.getId(), gatewayEvent.getEventId(), gatewayEvent.getKey(),
+              gatewayEvent.getValueAsString(true));
+        }
+        {
+          EventWrapper mapValue = new EventWrapper(gatewayEvent);
+          EventWrapper oldv = this.unprocessedEvents.put(gatewayEvent.getEventId(), mapValue);
+          if (oldv == null) {
+            freeGatewayEvent = false;
+            statistics.incUnprocessedEventsAddedBySecondary();
+          } else {
+            // put old one back in
+            this.unprocessedEvents.put(gatewayEvent.getEventId(), oldv);
+            // already added by secondary (i.e. hub)
+            logger.warn(LocalizedMessage.create(
+                LocalizedStrings.GatewayImpl_0_THE_UNPROCESSED_EVENTS_MAP_ALREADY_CONTAINED_AN_EVENT_FROM_THE_HUB_1_SO_IGNORING_NEW_EVENT_2,
+                new Object[] {sender.getId(), v, gatewayEvent}));
+          }
+        }
+      } else {
+        // token already added by primary already removed
+        if (logger.isTraceEnabled()) {
+          logger.trace("{}: Secondary created event {}:{}->{} removed from unprocessed events map",
+              sender.getId(), gatewayEvent.getEventId(), gatewayEvent.getKey(),
+              gatewayEvent.getValueAsString(true));
+        }
+        statistics.incUnprocessedTokensRemovedBySecondary();
-      statistics.incUnprocessedTokensRemovedBySecondary();
-    }
-    reapOld(statistics, false);
+      reapOld(statistics, false);
-            //statistics.incUnprocessedTokensRemovedByTimeout(count);
+            // statistics.incUnprocessedTokensRemovedByTimeout(count);
-          Iterator<Map.Entry<EventID, EventWrapper>> it = this.unprocessedEvents.entrySet().iterator();
+          Iterator<Map.Entry<EventID, EventWrapper>> it =
+              this.unprocessedEvents.entrySet().iterator();
-            //statistics.incUnprocessedEventsRemovedByTimeout(count);
+            // statistics.incUnprocessedEventsRemovedByTimeout(count);
-    buffer.append("GatewayEventProcessor[").append("gatewaySenderId=")
-    .append(sender.getId())
-    .append(";remoteDSId=")
-    .append(getSender().getRemoteDSId())
-    .append(";batchSize=")
-    .append(getSender().getBatchSize());
+    buffer.append("GatewayEventProcessor[").append("gatewaySenderId=").append(sender.getId())
+        .append(";remoteDSId=").append(getSender().getRemoteDSId()).append(";batchSize=")
+        .append(getSender().getBatchSize());
-   * Initialize the Executor that handles listener events. Only used by
-   * non-primary gateway senders
+   * Initialize the Executor that handles listener events. Only used by non-primary gateway senders
-    final ThreadGroup loggerGroup = LoggingThreadGroup.createThreadGroup(
-        "Gateway Listener Group", logger);
-    
+    final ThreadGroup loggerGroup =
+        LoggingThreadGroup.createThreadGroup("Gateway Listener Group", logger);
+
-        Thread thread = new Thread(loggerGroup, command,
-            "Queued Gateway Listener Thread");
+        Thread thread = new Thread(loggerGroup, command, "Queued Gateway Listener Thread");
-    this.executor = new ThreadPoolExecutor(1, 1/* max unused */, 120,
-        TimeUnit.SECONDS, q, tf);
+    this.executor = new ThreadPoolExecutor(1, 1/* max unused */, 120, TimeUnit.SECONDS, q, tf);
-  
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
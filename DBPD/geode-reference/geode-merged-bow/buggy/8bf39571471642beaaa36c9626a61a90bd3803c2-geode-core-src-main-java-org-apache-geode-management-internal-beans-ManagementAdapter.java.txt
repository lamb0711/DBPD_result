Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Acts as an intermediate between MBean layer and Federation Layer. Handles all
- * Call backs from GemFire to instantiate or remove MBeans from GemFire Domain.
+ * Acts as an intermediate between MBean layer and Federation Layer. Handles all Call backs from
+ * GemFire to instantiate or remove MBeans from GemFire Domain.
- * Even though this class have a lot of utility functions it interacts with the state 
- * of the system and contains some state itself.
+ * Even though this class have a lot of utility functions it interacts with the state of the system
+ * and contains some state itself.
-  
+
-   * emitter is a helper class for sending notifications on behalf of the
-   * MemberMBean
+   * emitter is a helper class for sending notifications on behalf of the MemberMBean
-  
+
-  
+
-  
-  
- 
-  private volatile boolean serviceInitialised = false;  
-  
+
+
+
+  private volatile boolean serviceInitialised = false;
+
-  
+
-  
-  
+
+
-  
+
-  
+
-   * Adapter life cycle is tied with the Cache . So its better to make all cache
-   * level artifacts as instance variable
+   * Adapter life cycle is tied with the Cache . So its better to make all cache level artifacts as
+   * instance variable
-   * @param cache
-   *          gemfire cache
+   * @param cache gemfire cache
-  public void handleCacheCreation(GemFireCacheImpl cache) throws ManagementException
-  {
-    try{
+  public void handleCacheCreation(GemFireCacheImpl cache) throws ManagementException {
+    try {
-      this.service = (SystemManagementService) ManagementService
-          .getManagementService(cacheImpl);
-      
+      this.service = (SystemManagementService) ManagementService.getManagementService(cacheImpl);
+
-      
-      ObjectName memberMBeanName = MBeanJMXAdapter
-          .getMemberMBeanName(InternalDistributedSystem.getConnectedInstance()
-              .getDistributedMember());
-     
-      memberSource = MBeanJMXAdapter.getMemberNameOrId(cacheImpl.getDistributedSystem().getDistributedMember());
+      ObjectName memberMBeanName = MBeanJMXAdapter.getMemberMBeanName(
+          InternalDistributedSystem.getConnectedInstance().getDistributedMember());
+
+
+      memberSource = MBeanJMXAdapter
+          .getMemberNameOrId(cacheImpl.getDistributedSystem().getDistributedMember());
-      ObjectName changedMBeanName = service.registerInternalMBean(
-          (MemberMXBean) memberBean, memberMBeanName);
+      ObjectName changedMBeanName =
+          service.registerInternalMBean((MemberMXBean) memberBean, memberMBeanName);
-     
-      
-      
+
+
+
-      
+
-      
-      
+
+
-      
+
-    
+
+
-  public void handleManagerStart() throws ManagementException{
+  public void handleManagerStart() throws ManagementException {
-    Map<ObjectName, Object> registeredMBeans = jmxAdapter
-        .getLocalGemFireMBean();
+    Map<ObjectName, Object> registeredMBeans = jmxAdapter.getLocalGemFireMBean();
-   
+
-    ObjectName memberObjectName = MBeanJMXAdapter
-        .getMemberMBeanName(InternalDistributedSystem.getConnectedInstance()
-            .getDistributedMember());
+    ObjectName memberObjectName = MBeanJMXAdapter.getMemberMBeanName(
+        InternalDistributedSystem.getConnectedInstance().getDistributedMember());
-    FederationComponent addedComp = service.getLocalManager().getFedComponents().get(
-        memberObjectName);
-    
-    service.afterCreateProxy(memberObjectName, MemberMXBean.class,
-        localMember, addedComp);
+    FederationComponent addedComp =
+        service.getLocalManager().getFedComponents().get(memberObjectName);
+
+    service.afterCreateProxy(memberObjectName, MemberMXBean.class, localMember, addedComp);
-        
-        FederationComponent newObj = service.getLocalManager().getFedComponents().get(
-            objectName);
-        
+
+        FederationComponent newObj = service.getLocalManager().getFedComponents().get(objectName);
+
-   * Handles all the clean up activities when a Manager is stopped
-   * It clears the distributed mbeans and underlying data structures
+   * Handles all the clean up activities when a Manager is stopped It clears the distributed mbeans
+   * and underlying data structures
-  public void handleManagerStop() throws ManagementException{
+  public void handleManagerStop() throws ManagementException {
-    Map<ObjectName, Object> registeredMBeans = jmxAdapter
-        .getLocalGemFireMBean();
-    
+    Map<ObjectName, Object> registeredMBeans = jmxAdapter.getLocalGemFireMBean();
+
-      aggregatemMBeanPattern = new ObjectName(
-          ManagementConstants.AGGREGATE_MBEAN_PATTERN);
+      aggregatemMBeanPattern = new ObjectName(ManagementConstants.AGGREGATE_MBEAN_PATTERN);
-    
+
-    
-    ObjectName memberObjectName = MBeanJMXAdapter
-        .getMemberMBeanName(InternalDistributedSystem.getConnectedInstance()
-            .getDistributedMember());
-    
-    FederationComponent removedComp = service.getLocalManager().getFedComponents().get(
-        memberObjectName);
-    
-    service.afterRemoveProxy(memberObjectName, MemberMXBean.class,
-        localMember, removedComp);
-    
+
+    ObjectName memberObjectName = MBeanJMXAdapter.getMemberMBeanName(
+        InternalDistributedSystem.getConnectedInstance().getDistributedMember());
+
+    FederationComponent removedComp =
+        service.getLocalManager().getFedComponents().get(memberObjectName);
+
+    service.afterRemoveProxy(memberObjectName, MemberMXBean.class, localMember, removedComp);
+
-    
+
-      if(aggregatemMBeanPattern.apply(objectName)){
+      if (aggregatemMBeanPattern.apply(objectName)) {
-        
-        FederationComponent oldObj = service.getLocalManager().getFedComponents().get(
-            objectName);
-        
+
+        FederationComponent oldObj = service.getLocalManager().getFedComponents().get(objectName);
+
-        logger.warn("Failed to invoke aggregator for {} with exception {}", objectName, e.getMessage(), e);
+        logger.warn("Failed to invoke aggregator for {} with exception {}", objectName,
+            e.getMessage(), e);
-        logger.warn("Failed to invoke aggregator for {} with exception {}", objectName, e.getMessage(), e);
+        logger.warn("Failed to invoke aggregator for {} with exception {}", objectName,
+            e.getMessage(), e);
-  
+
-  public void handleManagerCreation() throws ManagementException{
+  public void handleManagerCreation() throws ManagementException {
-    
+
-  
+
-   * Handles Region Creation. This is the call back which will create the
-   * specified RegionMXBean and will send a notification on behalf of Member
-   * Mbean
+   * Handles Region Creation. This is the call back which will create the specified RegionMXBean and
+   * will send a notification on behalf of Member Mbean
-   * @param region
-   *          the region for which the call back is invoked
+   * @param region the region for which the call back is invoked
-  public <K, V> void handleRegionCreation(Region<K, V> region)
-      throws ManagementException {
+  public <K, V> void handleRegionCreation(Region<K, V> region) throws ManagementException {
-    //Moving region creation operation inside a guarded block
-    //After getting access to regionOpLock it again checks for region
-    //destroy status 
-    
-    synchronized(regionOpLock){
+    // Moving region creation operation inside a guarded block
+    // After getting access to regionOpLock it again checks for region
+    // destroy status
+
+    synchronized (regionOpLock) {
-      if(localRegion.isDestroyed()){
+      if (localRegion.isDestroyed()) {
-      
+
-      ObjectName regionMBeanName = MBeanJMXAdapter.getRegionMBeanName(cacheImpl
-          .getDistributedSystem().getDistributedMember(), region.getFullPath());
-      ObjectName changedMBeanName = service.registerInternalMBean(regionMBean,
-          regionMBeanName);
+      ObjectName regionMBeanName = MBeanJMXAdapter.getRegionMBeanName(
+          cacheImpl.getDistributedSystem().getDistributedMember(), region.getFullPath());
+      ObjectName changedMBeanName = service.registerInternalMBean(regionMBean, regionMBeanName);
-      
-      Notification notification = new Notification(
-          JMXNotificationType.REGION_CREATED, memberSource, SequenceNumber
-              .next(), System.currentTimeMillis(), ManagementConstants.REGION_CREATED_PREFIX
-              + region.getFullPath());
+
+      Notification notification = new Notification(JMXNotificationType.REGION_CREATED, memberSource,
+          SequenceNumber.next(), System.currentTimeMillis(),
+          ManagementConstants.REGION_CREATED_PREFIX + region.getFullPath());
-    
-      
+
+
-    
-   
+
+
-   * Handles Disk Creation. Will create DiskStoreMXBean and will send a
-   * notification
+   * Handles Disk Creation. Will create DiskStoreMXBean and will send a notification
-   * @param disk
-   *          the disk store for which the call back is invoked
+   * @param disk the disk store for which the call back is invoked
-  public void handleDiskCreation(DiskStore disk) throws ManagementException{
+  public void handleDiskCreation(DiskStore disk) throws ManagementException {
-    ObjectName changedMBeanName = service.registerInternalMBean(diskStoreMBean,
-        diskStoreMBeanName);
+    ObjectName changedMBeanName = service.registerInternalMBean(diskStoreMBean, diskStoreMBeanName);
-    Notification notification = new Notification(
-        JMXNotificationType.DISK_STORE_CREATED, memberSource,
-        SequenceNumber.next(), System.currentTimeMillis(),
+    Notification notification = new Notification(JMXNotificationType.DISK_STORE_CREATED,
+        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-  public void handleLockServiceCreation(DLockService lockService) throws ManagementException{
+  public void handleLockServiceCreation(DLockService lockService) throws ManagementException {
-    /** Internal Locks Should not be exposed to client for monitoring**/
-    if(internalLocks.contains(lockService.getName())){
+    /** Internal Locks Should not be exposed to client for monitoring **/
+    if (internalLocks.contains(lockService.getName())) {
-    
+
-    
-    ObjectName changedMBeanName = service.registerInternalMBean(
-        lockServiceMBean, lockServiceMBeanName);
+
+    ObjectName changedMBeanName =
+        service.registerInternalMBean(lockServiceMBean, lockServiceMBeanName);
-    Notification notification = new Notification(
-        JMXNotificationType.LOCK_SERVICE_CREATED, memberSource,
-        SequenceNumber.next(), System.currentTimeMillis(),
+    Notification notification = new Notification(JMXNotificationType.LOCK_SERVICE_CREATED,
+        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-    
+
-   * @param sender
-   *          the specific gateway sender
+   * @param sender the specific gateway sender
-  public void handleGatewaySenderCreation(GatewaySender sender)
-      throws ManagementException {
+  public void handleGatewaySenderCreation(GatewaySender sender) throws ManagementException {
-    ObjectName changedMBeanName = service.registerInternalMBean(senderMBean,
-        senderObjectName);
+    ObjectName changedMBeanName = service.registerInternalMBean(senderMBean, senderObjectName);
-    Notification notification = new Notification(
-        JMXNotificationType.GATEWAY_SENDER_CREATED, memberSource,
-        SequenceNumber.next(), System.currentTimeMillis(),
+    Notification notification = new Notification(JMXNotificationType.GATEWAY_SENDER_CREATED,
+        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-   * @param recv
-   *          specific gateway receiver
+   * @param recv specific gateway receiver
-  public void handleGatewayReceiverCreate(GatewayReceiver recv)
-      throws ManagementException {
+  public void handleGatewayReceiverCreate(GatewayReceiver recv) throws ManagementException {
-    if(!recv.isManualStart()){
+    if (!recv.isManualStart()) {
-    
+
-   
+
-  
-  private void createGatewayReceiverMBean(GatewayReceiver recv){
+
+  private void createGatewayReceiverMBean(GatewayReceiver recv) {
-        .getGatewayReceiverMBeanName(cacheImpl.getDistributedSystem()
-            .getDistributedMember());
+        .getGatewayReceiverMBeanName(cacheImpl.getDistributedSystem().getDistributedMember());
-    ObjectName changedMBeanName = service.registerInternalMBean(receiverMBean,
-        recvObjectName);
+    ObjectName changedMBeanName = service.registerInternalMBean(receiverMBean, recvObjectName);
-    Notification notification = new Notification(
-        JMXNotificationType.GATEWAY_RECEIVER_CREATED, memberSource,
-        SequenceNumber.next(), System.currentTimeMillis(),
+    Notification notification = new Notification(JMXNotificationType.GATEWAY_RECEIVER_CREATED,
+        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-  
-  
+
+
-   * @param recv
-   *          specific gateway receiver
+   * @param recv specific gateway receiver
-  public void handleGatewayReceiverStart(GatewayReceiver recv)
-      throws ManagementException {
+  public void handleGatewayReceiverStart(GatewayReceiver recv) throws ManagementException {
-    
-    if(!recv.isManualStart()){
+
+    if (!recv.isManualStart()) {
-    
-    GatewayReceiverMBean mbean = (GatewayReceiverMBean)service.getLocalGatewayReceiverMXBean();
+
+    GatewayReceiverMBean mbean = (GatewayReceiverMBean) service.getLocalGatewayReceiverMXBean();
-    
+
-    Notification notification = new Notification(
-        JMXNotificationType.GATEWAY_RECEIVER_STARTED, memberSource,
-        SequenceNumber.next(), System.currentTimeMillis(),
+    Notification notification = new Notification(JMXNotificationType.GATEWAY_RECEIVER_STARTED,
+        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-  
-  
+
+
-   * @param recv
-   *          specific gateway receiver
+   * @param recv specific gateway receiver
-  public void handleGatewayReceiverStop(GatewayReceiver recv)
-      throws ManagementException {
+  public void handleGatewayReceiverStop(GatewayReceiver recv) throws ManagementException {
-    GatewayReceiverMBean mbean = (GatewayReceiverMBean)service.getLocalGatewayReceiverMXBean();
+    GatewayReceiverMBean mbean = (GatewayReceiverMBean) service.getLocalGatewayReceiverMXBean();
-    
+
-      
-    Notification notification = new Notification(
-        JMXNotificationType.GATEWAY_RECEIVER_STOPPED, memberSource,
-        SequenceNumber.next(), System.currentTimeMillis(),
+
+    Notification notification = new Notification(JMXNotificationType.GATEWAY_RECEIVER_STOPPED,
+        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-  public void handleAsyncEventQueueCreation(AsyncEventQueue queue)
-      throws ManagementException {
+  public void handleAsyncEventQueueCreation(AsyncEventQueue queue) throws ManagementException {
-    ObjectName changedMBeanName = service.registerInternalMBean(queueMBean,
-        senderObjectName);
+    ObjectName changedMBeanName = service.registerInternalMBean(queueMBean, senderObjectName);
-    Notification notification = new Notification(
-        JMXNotificationType.ASYNC_EVENT_QUEUE_CREATED, memberSource,
-        SequenceNumber.next(), System.currentTimeMillis(),
+    Notification notification = new Notification(JMXNotificationType.ASYNC_EVENT_QUEUE_CREATED,
+        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-  
+
-   * Sends the alert with the Object source as member. This notification will
-   * get filtered out for particular alert level
+   * Sends the alert with the Object source as member. This notification will get filtered out for
+   * particular alert level
-      String systemSource = "DistributedSystem(" + service.getDistributedSystemMXBean().getDistributedSystemId() + ")";
+      String systemSource = "DistributedSystem("
+          + service.getDistributedSystemMXBean().getDistributedSystemId() + ")";
-      
-      Notification notification = new Notification(JMXNotificationType.SYSTEM_ALERT, systemSource, SequenceNumber.next(),
-          details.getMsgTime().getTime(), details.getMsg());
+
+      Notification notification = new Notification(JMXNotificationType.SYSTEM_ALERT, systemSource,
+          SequenceNumber.next(), details.getMsgTime().getTime(), details.getMsg());
-    userData.put(JMXNotificationUserData.ALERT_LEVEL, AlertDetails.getAlertLevelAsString(details.getAlertLevel()));
-  
+    userData.put(JMXNotificationUserData.ALERT_LEVEL,
+        AlertDetails.getAlertLevelAsString(details.getAlertLevel()));
+
-    
+
-   * Assumption is its a cache server instance. For Gateway receiver there will
-   * be a separate method
+   * Assumption is its a cache server instance. For Gateway receiver there will be a separate method
-   * @param cacheServer
-   *          cache server instance
+   * @param cacheServer cache server instance
-    
+
-    ObjectName cacheServerMBeanName = MBeanJMXAdapter
-        .getClientServiceMBeanName(cacheServer.getPort(), cacheImpl
-            .getDistributedSystem().getDistributedMember());
-    
-    ObjectName changedMBeanName = service.registerInternalMBean(
-        (CacheServerMXBean) cacheServerMBean, cacheServerMBeanName);
-    
-    ClientMembershipListener managementClientListener = new CacheServerMembershipListenerAdapter(cacheServerMBean,
-        memberLevelNotifEmitter, changedMBeanName);
+    ObjectName cacheServerMBeanName = MBeanJMXAdapter.getClientServiceMBeanName(
+        cacheServer.getPort(), cacheImpl.getDistributedSystem().getDistributedMember());
+
+    ObjectName changedMBeanName =
+        service.registerInternalMBean((CacheServerMXBean) cacheServerMBean, cacheServerMBeanName);
+
+    ClientMembershipListener managementClientListener = new CacheServerMembershipListenerAdapter(
+        cacheServerMBean, memberLevelNotifEmitter, changedMBeanName);
-    
+
-    
+
-    
-    Notification notification = new Notification(
-        JMXNotificationType.CACHE_SERVER_STARTED, memberSource, SequenceNumber
-            .next(), System.currentTimeMillis(),
-            ManagementConstants.CACHE_SERVER_STARTED_PREFIX);
+
+    Notification notification = new Notification(JMXNotificationType.CACHE_SERVER_STARTED,
+        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
+        ManagementConstants.CACHE_SERVER_STARTED_PREFIX);
-    
+
-   * Assumption is its a cache server instance. For Gateway receiver there will
-   * be a separate method
+   * Assumption is its a cache server instance. For Gateway receiver there will be a separate method
-   * @param server
-   *          cache server instance
+   * @param server cache server instance
-    CacheServerMBean mbean = (CacheServerMBean) service
-        .getLocalCacheServerMXBean(server.getPort());
-    
-    ClientMembershipListener listener = mbean.getBridge()
-        .getClientMembershipListener();
-    
-    if(listener != null){
+    CacheServerMBean mbean = (CacheServerMBean) service.getLocalCacheServerMXBean(server.getPort());
+
+    ClientMembershipListener listener = mbean.getBridge().getClientMembershipListener();
+
+    if (listener != null) {
-   
+
-    ObjectName cacheServerMBeanName = MBeanJMXAdapter
-        .getClientServiceMBeanName(server.getPort(), cacheImpl
-            .getDistributedSystem().getDistributedMember());
+    ObjectName cacheServerMBeanName = MBeanJMXAdapter.getClientServiceMBeanName(server.getPort(),
+        cacheImpl.getDistributedSystem().getDistributedMember());
-    
-    Notification notification = new Notification(
-        JMXNotificationType.CACHE_SERVER_STOPPED, memberSource, SequenceNumber
-            .next(), System.currentTimeMillis(),
-            ManagementConstants.CACHE_SERVER_STOPPED_PREFIX);
+
+    Notification notification = new Notification(JMXNotificationType.CACHE_SERVER_STOPPED,
+        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
+        ManagementConstants.CACHE_SERVER_STOPPED_PREFIX);
-    
+
-   
+
-   * Handles Cache removal. It will automatically remove all MBeans from GemFire
-   * Domain
+   * Handles Cache removal. It will automatically remove all MBeans from GemFire Domain
-   * @param cache
-   *          GemFire Cache instance. For now client cache is not supported
+   * @param cache GemFire Cache instance. For now client cache is not supported
-     
+
-    }finally{
+    } finally {
-      this.memberMBeanBridge =null;
+      this.memberMBeanBridge = null;
-      
-      
+
+
-    
+
-        GatewaySenderMBean senderMBean = (GatewaySenderMBean) service
-            .getLocalGatewaySenderMXBean(sender.getId());
+        GatewaySenderMBean senderMBean =
+            (GatewaySenderMBean) service.getLocalGatewaySenderMXBean(sender.getId());
-    GatewayReceiverMBean receiver = (GatewayReceiverMBean) service
-        .getLocalGatewayReceiverMXBean();
+    GatewayReceiverMBean receiver = (GatewayReceiverMBean) service.getLocalGatewayReceiverMXBean();
-  
-  
+
+
-        CacheServerMBean mbean = (CacheServerMBean) service
-            .getLocalCacheServerMXBean(server.getPort());
+        CacheServerMBean mbean =
+            (CacheServerMBean) service.getLocalCacheServerMXBean(server.getPort());
-          ClientMembershipListener listener = mbean.getBridge()
-            .getClientMembershipListener();
+          ClientMembershipListener listener = mbean.getBridge().getClientMembershipListener();
-   * Handles particular region destroy or close operation it will remove the
-   * corresponding MBean
+   * Handles particular region destroy or close operation it will remove the corresponding MBean
-  public void handleRegionRemoval(Region region) throws ManagementException{
+  public void handleRegionRemoval(Region region) throws ManagementException {
-     * Moved region remove operation to a guarded block. If a region is getting
-     * created it wont allow it to destroy any region.
+     * Moved region remove operation to a guarded block. If a region is getting created it wont
+     * allow it to destroy any region.
-    synchronized(regionOpLock){
+    synchronized (regionOpLock) {
-      ObjectName regionMBeanName = MBeanJMXAdapter.getRegionMBeanName(cacheImpl
-          .getDistributedSystem().getDistributedMember(), region.getFullPath());
+      ObjectName regionMBeanName = MBeanJMXAdapter.getRegionMBeanName(
+          cacheImpl.getDistributedSystem().getDistributedMember(), region.getFullPath());
-        bean = (RegionMBean)service.getLocalRegionMBean(region.getFullPath());
+        bean = (RegionMBean) service.getLocalRegionMBean(region.getFullPath());
-          logger.debug(e.getMessage(), e);          
+          logger.debug(e.getMessage(), e);
-      
-      if(bean != null){
+
+      if (bean != null) {
-      Notification notification = new Notification(
-          JMXNotificationType.REGION_CLOSED, memberSource, SequenceNumber.next(),
-          System.currentTimeMillis(), ManagementConstants.REGION_CLOSED_PREFIX
-              + region.getFullPath());
+      Notification notification = new Notification(JMXNotificationType.REGION_CLOSED, memberSource,
+          SequenceNumber.next(), System.currentTimeMillis(),
+          ManagementConstants.REGION_CLOSED_PREFIX + region.getFullPath());
-  
+
-  public void handleDiskRemoval(DiskStore disk) throws ManagementException{
-    
+  public void handleDiskRemoval(DiskStore disk) throws ManagementException {
+
-    
+
-      bean = (DiskStoreMBean)service.getLocalDiskStoreMBean(disk.getName());
-      if(bean == null) {
-        return ;
+      bean = (DiskStoreMBean) service.getLocalDiskStoreMBean(disk.getName());
+      if (bean == null) {
+        return;
-        logger.debug(e.getMessage(), e);          
+        logger.debug(e.getMessage(), e);
-      
+
-    
+
-    Notification notification = new Notification(
-        JMXNotificationType.DISK_STORE_CLOSED, memberSource, SequenceNumber.next(),
-        System.currentTimeMillis(), ManagementConstants.DISK_STORE_CLOSED_PREFIX
-            + disk.getName());
+    Notification notification = new Notification(JMXNotificationType.DISK_STORE_CLOSED,
+        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
+        ManagementConstants.DISK_STORE_CLOSED_PREFIX + disk.getName());
-   * @param lockService
-   *          lock service instance
+   * @param lockService lock service instance
-   
+
-    LockServiceMXBean bean = service.getLocalLockServiceMBean(lockService
-        .getName());
-    
+    LockServiceMXBean bean = service.getLocalLockServiceMBean(lockService.getName());
+
-    Notification notification = new Notification(
-        JMXNotificationType.LOCK_SERVICE_CLOSED, memberSource, SequenceNumber.next(),
-        System.currentTimeMillis(), ManagementConstants.LOCK_SERVICE_CLOSED_PREFIX
-            + lockService.getName());
+    Notification notification = new Notification(JMXNotificationType.LOCK_SERVICE_CLOSED,
+        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
+        ManagementConstants.LOCK_SERVICE_CLOSED_PREFIX + lockService.getName());
-  
+
-   * Handles management side call backs for a locator creation and start.
-   * Assumption is a cache will be created before hand.
+   * Handles management side call backs for a locator creation and start. Assumption is a cache will
+   * be created before hand.
-   * There is no corresponding handleStopLocator() method. Locator will close
-   * the cache whenever its stopped and it should also shutdown all the
-   * management services by closing the cache.
+   * There is no corresponding handleStopLocator() method. Locator will close the cache whenever its
+   * stopped and it should also shutdown all the management services by closing the cache.
-   * @param locator
-   *          instance of locator which is getting started
+   * @param locator instance of locator which is getting started
-    ObjectName locatorMBeanName = MBeanJMXAdapter.getLocatorMBeanName(cacheImpl
-        .getDistributedSystem().getDistributedMember());
+    ObjectName locatorMBeanName = MBeanJMXAdapter
+        .getLocatorMBeanName(cacheImpl.getDistributedSystem().getDistributedMember());
-    ObjectName changedMBeanName = service.registerInternalMBean(
-        (LocatorMXBean) locatorMBean, locatorMBeanName);
+    ObjectName changedMBeanName =
+        service.registerInternalMBean((LocatorMXBean) locatorMBean, locatorMBeanName);
-    Notification notification = new Notification(
-        JMXNotificationType.LOCATOR_STARTED, memberSource, SequenceNumber
-            .next(), System.currentTimeMillis(),
-            ManagementConstants.LOCATOR_STARTED_PREFIX);
+    Notification notification =
+        new Notification(JMXNotificationType.LOCATOR_STARTED, memberSource, SequenceNumber.next(),
+            System.currentTimeMillis(), ManagementConstants.LOCATOR_STARTED_PREFIX);
-  
-  public void handleGatewaySenderStart(GatewaySender sender)
-      throws ManagementException {
+
+  public void handleGatewaySenderStart(GatewaySender sender) throws ManagementException {
-    GatewaySenderMBean bean = (GatewaySenderMBean) service
-        .getLocalGatewaySenderMXBean(sender.getId());
-    
+    GatewaySenderMBean bean =
+        (GatewaySenderMBean) service.getLocalGatewaySenderMXBean(sender.getId());
+
-    
-    Notification notification = new Notification(
-        JMXNotificationType.GATEWAY_SENDER_STARTED, memberSource,
-        SequenceNumber.next(), System.currentTimeMillis(),
+
+    Notification notification = new Notification(JMXNotificationType.GATEWAY_SENDER_STARTED,
+        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-  public void handleGatewaySenderStop(GatewaySender sender)
-      throws ManagementException {
+  public void handleGatewaySenderStop(GatewaySender sender) throws ManagementException {
-    Notification notification = new Notification(
-        JMXNotificationType.GATEWAY_SENDER_STOPPED, memberSource,
-        SequenceNumber.next(), System.currentTimeMillis(),
+    Notification notification = new Notification(JMXNotificationType.GATEWAY_SENDER_STOPPED,
+        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-  public void handleGatewaySenderPaused(GatewaySender sender)
-      throws ManagementException {
+  public void handleGatewaySenderPaused(GatewaySender sender) throws ManagementException {
-    Notification notification = new Notification(
-        JMXNotificationType.GATEWAY_SENDER_PAUSED, memberSource,
-        SequenceNumber.next(), System.currentTimeMillis(),
+    Notification notification = new Notification(JMXNotificationType.GATEWAY_SENDER_PAUSED,
+        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-  public void handleGatewaySenderResumed(GatewaySender sender)
-      throws ManagementException {
+  public void handleGatewaySenderResumed(GatewaySender sender) throws ManagementException {
-    Notification notification = new Notification(
-        JMXNotificationType.GATEWAY_SENDER_RESUMED, memberSource,
-        SequenceNumber.next(), System.currentTimeMillis(),
+    Notification notification = new Notification(JMXNotificationType.GATEWAY_SENDER_RESUMED,
+        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-  public void handleCacheServiceCreation(CacheService cacheService)
-      throws ManagementException {
+  public void handleCacheServiceCreation(CacheService cacheService) throws ManagementException {
-      Notification notification = new Notification(
-          JMXNotificationType.CACHE_SERVICE_CREATED, memberSource,
-          SequenceNumber.next(), System.currentTimeMillis(),
+      Notification notification = new Notification(JMXNotificationType.CACHE_SERVICE_CREATED,
+          memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-   * Private class which acts as a ClientMembershipListener to propagate client
-   * joined/left notifications
+   * Private class which acts as a ClientMembershipListener to propagate client joined/left
+   * notifications
-  private static class CacheServerMembershipListenerAdapter extends
-      ClientMembershipListenerAdapter {
-    
+  private static class CacheServerMembershipListenerAdapter
+      extends ClientMembershipListenerAdapter {
+
-    
+
-    
-    public CacheServerMembershipListenerAdapter(NotificationBroadcasterSupport serverLevelNotifEmitter,
+
+    public CacheServerMembershipListenerAdapter(
+        NotificationBroadcasterSupport serverLevelNotifEmitter,
-     * Invoked when a client has connected to this process or when this process
-     * has connected to a CacheServer.
+     * Invoked when a client has connected to this process or when this process has connected to a
+     * CacheServer.
-      Notification notification = new Notification(JMXNotificationType.CLIENT_JOINED, serverSource, SequenceNumber
-          .next(), System.currentTimeMillis(), ManagementConstants.CLIENT_JOINED_PREFIX + event.getMemberId());
+      Notification notification = new Notification(JMXNotificationType.CLIENT_JOINED, serverSource,
+          SequenceNumber.next(), System.currentTimeMillis(),
+          ManagementConstants.CLIENT_JOINED_PREFIX + event.getMemberId());
-     * Invoked when a client has gracefully disconnected from this process or
-     * when this process has gracefully disconnected from a CacheServer.
+     * Invoked when a client has gracefully disconnected from this process or when this process has
+     * gracefully disconnected from a CacheServer.
-      Notification notification = new Notification(JMXNotificationType.CLIENT_LEFT, serverSource, SequenceNumber
-          .next(), System.currentTimeMillis(), ManagementConstants.CLIENT_LEFT_PREFIX + event.getMemberId());
+      Notification notification = new Notification(JMXNotificationType.CLIENT_LEFT, serverSource,
+          SequenceNumber.next(), System.currentTimeMillis(),
+          ManagementConstants.CLIENT_LEFT_PREFIX + event.getMemberId());
-     * Invoked when a client has unexpectedly disconnected from this process or
-     * when this process has unexpectedly disconnected from a CacheServer.
+     * Invoked when a client has unexpectedly disconnected from this process or when this process
+     * has unexpectedly disconnected from a CacheServer.
-      Notification notification = new Notification(JMXNotificationType.CLIENT_CRASHED, serverSource, SequenceNumber
-          .next(), System.currentTimeMillis(), ManagementConstants.CLIENT_CRASHED_PREFIX + event.getMemberId());
+      Notification notification = new Notification(JMXNotificationType.CLIENT_CRASHED, serverSource,
+          SequenceNumber.next(), System.currentTimeMillis(),
+          ManagementConstants.CLIENT_CRASHED_PREFIX + event.getMemberId());
-  
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public class CacheServerLauncher  {
+public class CacheServerLauncher {
-  /** Is this VM a dedicated Cache Server?  This value is used mainly by the admin API. */
-  public static boolean isDedicatedCacheServer = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "isDedicatedServer");
+  /** Is this VM a dedicated Cache Server? This value is used mainly by the admin API. */
+  public static boolean isDedicatedCacheServer =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "isDedicatedServer");
-  public static boolean ASSIGN_BUCKETS = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "CacheServerLauncher.assignBucketsToPartitions");
+  public static boolean ASSIGN_BUCKETS = Boolean.getBoolean(
+      DistributionConfig.GEMFIRE_PREFIX + "CacheServerLauncher.assignBucketsToPartitions");
-  //default is to exit if property not defined
-  public static boolean DONT_EXIT_AFTER_LAUNCH = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "CacheServerLauncher.dontExitAfterLaunch");
+  // default is to exit if property not defined
+  public static boolean DONT_EXIT_AFTER_LAUNCH = Boolean
+      .getBoolean(DistributionConfig.GEMFIRE_PREFIX + "CacheServerLauncher.dontExitAfterLaunch");
-  public static final boolean PRINT_LAUNCH_COMMAND = Boolean.getBoolean(
-    CacheServerLauncher.class.getSimpleName() + ".PRINT_LAUNCH_COMMAND");
+  public static final boolean PRINT_LAUNCH_COMMAND =
+      Boolean.getBoolean(CacheServerLauncher.class.getSimpleName() + ".PRINT_LAUNCH_COMMAND");
-  private static final long STATUS_WAIT_TIME
-      = Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "CacheServerLauncher.STATUS_WAIT_TIME_MS", 15000);
-  
+  private static final long STATUS_WAIT_TIME = Long.getLong(
+      DistributionConfig.GEMFIRE_PREFIX + "CacheServerLauncher.STATUS_WAIT_TIME_MS", 15000);
+
-  private static final long SHUTDOWN_WAIT_TIME
-      = Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "CacheServerLauncher.SHUTDOWN_WAIT_TIME_MS", 20000);
+  private static final long SHUTDOWN_WAIT_TIME = Long.getLong(
+      DistributionConfig.GEMFIRE_PREFIX + "CacheServerLauncher.SHUTDOWN_WAIT_TIME_MS", 20000);
-  protected static Status createStatus(final String baseName, final int state, final int pid, final String msg, final Throwable t) {
+  protected static Status createStatus(final String baseName, final int state, final int pid,
+      final String msg, final Throwable t) {
-    out.println("cacheserver start [-J<vmarg>]* [<attName>=<attValue>]* [-dir=<workingdir>] [-classpath=<classpath>] [-disable-default-server] [-rebalance] [-lock-memory] [-server-port=<server-port>] [-server-bind-address=<server-bind-address>] [-critical-heap-percentage=<critical-heap-percentage>] [-eviction-heap-percentage=<eviction-heap-percentage>] [-critical-off-heap-percentage=<critical-off-heap-percentage>] [-eviction-off-heap-percentage=<eviction-off-heap-percentage>]\n" );
-    out.println("\t" + LocalizedStrings.CacheServerLauncher_STARTS_A_GEMFIRE_CACHESERVER_VM.toLocalizedString() );
+    out.println(
+        "cacheserver start [-J<vmarg>]* [<attName>=<attValue>]* [-dir=<workingdir>] [-classpath=<classpath>] [-disable-default-server] [-rebalance] [-lock-memory] [-server-port=<server-port>] [-server-bind-address=<server-bind-address>] [-critical-heap-percentage=<critical-heap-percentage>] [-eviction-heap-percentage=<eviction-heap-percentage>] [-critical-off-heap-percentage=<critical-off-heap-percentage>] [-eviction-off-heap-percentage=<eviction-off-heap-percentage>]\n");
+    out.println("\t"
+        + LocalizedStrings.CacheServerLauncher_STARTS_A_GEMFIRE_CACHESERVER_VM.toLocalizedString());
-    out.println("\t" + LocalizedStrings.CacheServerLauncher_DISABLE_DEFAULT_SERVER.toLocalizedString());
+    out.println(
+        "\t" + LocalizedStrings.CacheServerLauncher_DISABLE_DEFAULT_SERVER.toLocalizedString());
-    out.println("\t" + LocalizedStrings.CacheServerLauncher_SERVER_BIND_ADDRESS.toLocalizedString());
-    out.println("\t" + LocalizedStrings.CacheServerLauncher_CRITICAL_HEAP_PERCENTAGE.toLocalizedString());
-    out.println("\t" + LocalizedStrings.CacheServerLauncher_EVICTION_HEAP_PERCENTAGE.toLocalizedString());
-    out.println("\t" + LocalizedStrings.CacheServerLauncher_CRITICAL_OFF_HEAP_PERCENTAGE.toLocalizedString());
-    out.println("\t" + LocalizedStrings.CacheServerLauncher_EVICTION_OFF_HEAP_PERCENTAGE.toLocalizedString());
+    out.println(
+        "\t" + LocalizedStrings.CacheServerLauncher_SERVER_BIND_ADDRESS.toLocalizedString());
+    out.println(
+        "\t" + LocalizedStrings.CacheServerLauncher_CRITICAL_HEAP_PERCENTAGE.toLocalizedString());
+    out.println(
+        "\t" + LocalizedStrings.CacheServerLauncher_EVICTION_HEAP_PERCENTAGE.toLocalizedString());
+    out.println("\t"
+        + LocalizedStrings.CacheServerLauncher_CRITICAL_OFF_HEAP_PERCENTAGE.toLocalizedString());
+    out.println("\t"
+        + LocalizedStrings.CacheServerLauncher_EVICTION_OFF_HEAP_PERCENTAGE.toLocalizedString());
-    out.println( "cacheserver stop [-dir=<workingdir>]" );
-    out.println("\t" + LocalizedStrings.CacheServerLauncher_STOPS_A_GEMFIRE_CACHESERVER_VM.toLocalizedString());
+    out.println("cacheserver stop [-dir=<workingdir>]");
+    out.println("\t"
+        + LocalizedStrings.CacheServerLauncher_STOPS_A_GEMFIRE_CACHESERVER_VM.toLocalizedString());
-    out.println( "cacheserver status [-dir=<workingdir>]" );
-    out.println( "\t" + LocalizedStrings.CacheServerLauncher_STATUS.toLocalizedString());
+    out.println("cacheserver status [-dir=<workingdir>]");
+    out.println("\t" + LocalizedStrings.CacheServerLauncher_STATUS.toLocalizedString());
-   * Prints the status of the cache server running the configured
-   * working directory.
+   * Prints the status of the cache server running the configured working directory.
-   * Returns the <code>Status</code> of the cache server in the
-   * <code>workingDir</code>.
+   * Returns the <code>Status</code> of the cache server in the <code>workingDir</code>.
-    }
-    else {
+    } else {
-   * Main method that parses the command line and performs an
-   * will start, stop, or get the status of a cache server.  This main
-   * method is also the main method of the launched cacher server VM
+   * Main method that parses the command line and performs an will start, stop, or get the status of
+   * a cache server. This main method is also the main method of the launched cacher server VM
-        }
-        else if (args[0].equalsIgnoreCase("server")) {
+        } else if (args[0].equalsIgnoreCase("server")) {
-        }
-        else if (args[0].equalsIgnoreCase("stop")) {
+        } else if (args[0].equalsIgnoreCase("stop")) {
-        }
-        else if (args[0].equalsIgnoreCase("status")) {
+        } else if (args[0].equalsIgnoreCase("status")) {
-        }
-        else {
+        } else {
-      }
-      else {
+      } else {
-      throw new Exception(LocalizedStrings.CacheServerLauncher_INTERNAL_ERROR_SHOULDNT_REACH_HERE.toLocalizedString());
-    }
-    catch (VirtualMachineError err) {
+      throw new Exception(LocalizedStrings.CacheServerLauncher_INTERNAL_ERROR_SHOULDNT_REACH_HERE
+          .toLocalizedString());
+    } catch (VirtualMachineError err) {
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    }
-    catch (Throwable t) {
+    } catch (Throwable t) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-        launcher.setServerError(LocalizedStrings.CacheServerLauncher_ERROR_STARTING_SERVER_PROCESS
-          .toLocalizedString(), t);
+        launcher.setServerError(
+            LocalizedStrings.CacheServerLauncher_ERROR_STARTING_SERVER_PROCESS.toLocalizedString(),
+            t);
-      }
-      else {
-        System.out.println(LocalizedStrings.CacheServerLauncher_ERROR_0.toLocalizedString(t.getMessage()));
+      } else {
+        System.out.println(
+            LocalizedStrings.CacheServerLauncher_ERROR_0.toLocalizedString(t.getMessage()));
-  protected void restoreStdOut( ) {
-    System.setErr( oldErr );
-    System.setOut( oldOut );
+  protected void restoreStdOut() {
+    System.setErr(oldErr);
+    System.setOut(oldOut);
-  protected static final String DIR     = "dir";
-  protected static final String VMARGS  = "vmargs";
+  protected static final String DIR = "dir";
+  protected static final String VMARGS = "vmargs";
-  public static final String CRITICAL_HEAP_PERCENTAGE =
-    "critical-heap-percentage";
-  public static final String EVICTION_HEAP_PERCENTAGE =
-      "eviction-heap-percentage";
-  public static final String CRITICAL_OFF_HEAP_PERCENTAGE =
-      "critical-off-heap-percentage";
-  public static final String EVICTION_OFF_HEAP_PERCENTAGE =
-      "eviction-off-heap-percentage";
+  public static final String CRITICAL_HEAP_PERCENTAGE = "critical-heap-percentage";
+  public static final String EVICTION_HEAP_PERCENTAGE = "eviction-heap-percentage";
+  public static final String CRITICAL_OFF_HEAP_PERCENTAGE = "critical-off-heap-percentage";
+  public static final String EVICTION_OFF_HEAP_PERCENTAGE = "eviction-off-heap-percentage";
-  protected final File processDirOption(final Map<String, Object> options, final String dirValue) throws FileNotFoundException {
+  protected final File processDirOption(final Map<String, Object> options, final String dirValue)
+      throws FileNotFoundException {
-      throw new FileNotFoundException(LocalizedStrings.CacheServerLauncher_THE_INPUT_WORKING_DIRECTORY_DOES_NOT_EXIST_0
-        .toLocalizedString(dirValue));
+      throw new FileNotFoundException(
+          LocalizedStrings.CacheServerLauncher_THE_INPUT_WORKING_DIRECTORY_DOES_NOT_EXIST_0
+              .toLocalizedString(dirValue));
-   * Populates a map that maps the name of the start options such as {@link #DIR} to its value on the command line.
-   * If no value is specified on the command line, a default one is provided.
+   * Populates a map that maps the name of the start options such as {@link #DIR} to its value on
+   * the command line. If no value is specified on the command line, a default one is provided.
-      }
-      else if (arg.startsWith("-classpath=")) {
+      } else if (arg.startsWith("-classpath=")) {
-      }
-      else if (arg.startsWith("-dir=")) {
+      } else if (arg.startsWith("-dir=")) {
-      }
-      else if (arg.startsWith("-disable-default-server")) {
+      } else if (arg.startsWith("-disable-default-server")) {
-      }
-      else if (arg.startsWith("-lock-memory")) {
+      } else if (arg.startsWith("-lock-memory")) {
-      }
-      else if (arg.startsWith("-rebalance")) {
+      } else if (arg.startsWith("-rebalance")) {
-      }
-      else if (arg.startsWith("-server-port")) {
+      } else if (arg.startsWith("-server-port")) {
-      }
-      else if (arg.startsWith("-" + CRITICAL_HEAP_PERCENTAGE) ) {
+      } else if (arg.startsWith("-" + CRITICAL_HEAP_PERCENTAGE)) {
-      }
-      else if (arg.startsWith("-" + EVICTION_HEAP_PERCENTAGE) ) {
+      } else if (arg.startsWith("-" + EVICTION_HEAP_PERCENTAGE)) {
-      }
-      else if (arg.startsWith("-" + CRITICAL_OFF_HEAP_PERCENTAGE) ) {
+      } else if (arg.startsWith("-" + CRITICAL_OFF_HEAP_PERCENTAGE)) {
-      }
-      else if (arg.startsWith("-" + EVICTION_OFF_HEAP_PERCENTAGE) ) {
+      } else if (arg.startsWith("-" + EVICTION_OFF_HEAP_PERCENTAGE)) {
-      }
-      else if (arg.startsWith("-server-bind-address")) {
+      } else if (arg.startsWith("-server-bind-address")) {
-      }
-      else if (arg.startsWith("-J")) {
+      } else if (arg.startsWith("-J")) {
-      // an 'indexOf' the assignment operator with greater than 0 ensures a non-empty String key value
+      // an 'indexOf' the assignment operator with greater than 0 ensures a non-empty String key
+      // value
-        }
-        else {
+        } else {
-      }
-      else {
-        throw new IllegalArgumentException(LocalizedStrings.CacheServerLauncher_UNKNOWN_ARGUMENT_0
-          .toLocalizedString(arg));
+      } else {
+        throw new IllegalArgumentException(
+            LocalizedStrings.CacheServerLauncher_UNKNOWN_ARGUMENT_0.toLocalizedString(arg));
-    // configure commons-logging to use JDK logging 
+    // configure commons-logging to use JDK logging
-    
+
-  protected void processStartArg(final String key,
-                                 final String value,
-                                 final Map<String, Object> options,
-                                 final List<String> vmArgs,
-                                 final Properties props)
-    throws Exception
-  {
+  protected void processStartArg(final String key, final String value,
+      final Map<String, Object> options, final List<String> vmArgs, final Properties props)
+      throws Exception {
-  protected void processStartOption(final String key,
-                                    final String value,
-                                    final Map<String, Object> options,
-                                    final List<String> vmArgs,
-                                    final Properties props)
-    throws Exception
-  {
+  protected void processStartOption(final String key, final String value,
+      final Map<String, Object> options, final List<String> vmArgs, final Properties props)
+      throws Exception {
-  protected void processUnknownStartOption(final String key,
-                                           final String value,
-                                           final Map<String, Object> options,
-                                           final List<String> vmArgs,
-                                           final Properties props) {
-    throw new IllegalArgumentException(LocalizedStrings.CacheServerLauncher_UNKNOWN_ARGUMENT_0.toLocalizedString(key));
+  protected void processUnknownStartOption(final String key, final String value,
+      final Map<String, Object> options, final List<String> vmArgs, final Properties props) {
+    throw new IllegalArgumentException(
+        LocalizedStrings.CacheServerLauncher_UNKNOWN_ARGUMENT_0.toLocalizedString(key));
-      }
-      else if (arg.startsWith("-dir=")) {
+      } else if (arg.startsWith("-dir=")) {
-      }
-      else if (arg.startsWith("-rebalance")) {
+      } else if (arg.startsWith("-rebalance")) {
-      }
-      else if (arg.startsWith("-disable-default-server")) {
+      } else if (arg.startsWith("-disable-default-server")) {
-      }
-      else if (arg.startsWith("-lock-memory")) {
+      } else if (arg.startsWith("-lock-memory")) {
-      }
-      else if (arg.startsWith("-server-port")) {
+      } else if (arg.startsWith("-server-port")) {
-      }
-      else if (arg.startsWith("-server-bind-address")) {
+      } else if (arg.startsWith("-server-bind-address")) {
-      }
-      else if (arg.startsWith("-" + CRITICAL_HEAP_PERCENTAGE)) {
+      } else if (arg.startsWith("-" + CRITICAL_HEAP_PERCENTAGE)) {
-      }
-      else if (arg.startsWith("-" + EVICTION_HEAP_PERCENTAGE)) {
+      } else if (arg.startsWith("-" + EVICTION_HEAP_PERCENTAGE)) {
-      }
-      else if (arg.startsWith("-" + CRITICAL_OFF_HEAP_PERCENTAGE)) {
+      } else if (arg.startsWith("-" + CRITICAL_OFF_HEAP_PERCENTAGE)) {
-      }
-      else if (arg.startsWith("-" + EVICTION_OFF_HEAP_PERCENTAGE)) {
+      } else if (arg.startsWith("-" + EVICTION_OFF_HEAP_PERCENTAGE)) {
-      }
-      else if (arg.indexOf("=") > 1) {
+      } else if (arg.indexOf("=") > 1) {
-        }
-        else {
+        } else {
-      }
-      else {
-        throw new IllegalArgumentException(LocalizedStrings.CacheServerLauncher_UNKNOWN_ARGUMENT_0.toLocalizedString(arg));
+      } else {
+        throw new IllegalArgumentException(
+            LocalizedStrings.CacheServerLauncher_UNKNOWN_ARGUMENT_0.toLocalizedString(arg));
-   * Extracts configuration information for stopping a cache server based on the contents of the command-line.
-   * This method can also be used with getting the status of a cache server.
+   * Extracts configuration information for stopping a cache server based on the contents of the
+   * command-line. This method can also be used with getting the status of a cache server.
-      }
-      else if (arg.startsWith("-dir=")) {
+      } else if (arg.startsWith("-dir=")) {
-      }
-      else {
-        throw new IllegalArgumentException(LocalizedStrings.CacheServerLauncher_UNKNOWN_ARGUMENT_0
-          .toLocalizedString(arg));
+      } else {
+        throw new IllegalArgumentException(
+            LocalizedStrings.CacheServerLauncher_UNKNOWN_ARGUMENT_0.toLocalizedString(arg));
-   * Configures and spawns a VM that hosts a cache server.  Any output
-   * generated while starting the VM will be placed in a special
-   * {@linkplain #startLogFileName log file}.
+   * Configures and spawns a VM that hosts a cache server. Any output generated while starting the
+   * VM will be placed in a special {@linkplain #startLogFileName log file}.
+   * 
-      throw new IllegalStateException(LocalizedStrings.CacheServerLauncher_A_0_IS_ALREADY_RUNNING_IN_DIRECTORY_1_2
-        .toLocalizedString(this.baseName, workingDir, status));
+      throw new IllegalStateException(
+          LocalizedStrings.CacheServerLauncher_A_0_IS_ALREADY_RUNNING_IN_DIRECTORY_1_2
+              .toLocalizedString(this.baseName, workingDir, status));
-      (String) options.get(CLASSPATH), null, (List<String>) options.get(VMARGS));
+        (String) options.get(CLASSPATH), null, (List<String>) options.get(VMARGS));
-  private int runCommandLine(final Map<String, Object> options, final String[] commandLine) throws Exception {
-    final File startLogFile = new File(workingDir, startLogFileName).getAbsoluteFile(); // see bug 32548
+  private int runCommandLine(final Map<String, Object> options, final String[] commandLine)
+      throws Exception {
+    final File startLogFile = new File(workingDir, startLogFileName).getAbsoluteFile(); // see bug
+                                                                                        // 32548
-      throw new IOException("Unable to delete start log file (" + startLogFile.getAbsolutePath() + ")!");
+      throw new IOException(
+          "Unable to delete start log file (" + startLogFile.getAbsolutePath() + ")!");
-    
+
-  protected void printStartMessage(final Map<String, Object> options, final int pid) throws Exception {
-    System.out.println(LocalizedStrings.CacheServerLauncher_STARTING_0_WITH_PID_1.toLocalizedString(this.baseName, pid));
+  protected void printStartMessage(final Map<String, Object> options, final int pid)
+      throws Exception {
+    System.out.println(LocalizedStrings.CacheServerLauncher_STARTING_0_WITH_PID_1
+        .toLocalizedString(this.baseName, pid));
-    }
-    catch (Exception e) {
+    } catch (Exception e) {
-   * The method that does the work of being a cache server.  It is
-   * invoked in the VM spawned by the {@link #start} method.
-   * Basically, it creates a GemFire {@link Cache} based on
-   * configuration passed in from the command line.  (It will also
-   * take <code>gemfire.properties</code>, etc. into account, just
-   * like an application cache.)
+   * The method that does the work of being a cache server. It is invoked in the VM spawned by the
+   * {@link #start} method. Basically, it creates a GemFire {@link Cache} based on configuration
+   * passed in from the command line. (It will also take <code>gemfire.properties</code>, etc. into
+   * account, just like an application cache.)
-   * After creating the cache and setting the server's status to {@link
-   * #RUNNING}, it periodically monitors the status, waiting for it to
-   * change to {@link #SHUTDOWN_PENDING} (see {@link #stop}).  When
-   * the status does change, it closes the <code>Cache</code> and sets
-   * the status to be {@link #SHUTDOWN}.
+   * After creating the cache and setting the server's status to {@link #RUNNING}, it periodically
+   * monitors the status, waiting for it to change to {@link #SHUTDOWN_PENDING} (see {@link #stop}).
+   * When the status does change, it closes the <code>Cache</code> and sets the status to be
+   * {@link #SHUTDOWN}.
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value="ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD")
+  @edu.umd.cs.findbugs.annotations.SuppressWarnings(
+      value = "ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD")
-    // Connect to the distributed system.  The properties will
+    // Connect to the distributed system. The properties will
-      // Check First if the gemfire.properties set the log-file. If they do, we shouldn't override that default
+      // Check First if the gemfire.properties set the log-file. If they do, we shouldn't override
+      // that default
-        // Do not allow the cache server to log to stdout, override the logger with #defaultLogFileName
+        // Do not allow the cache server to log to stdout, override the logger with
+        // #defaultLogFileName
-    
+
-    
+
-    File statusFile = new File( workingDir, statusName );
-    long lastModified=0, oldModified = statusFile.lastModified();
-    // Every FORCE_STATUS_FILE_READ_ITERATION_COUNT iterations, read the status file despite the modification time
+    File statusFile = new File(workingDir, statusName);
+    long lastModified = 0, oldModified = statusFile.lastModified();
+    // Every FORCE_STATUS_FILE_READ_ITERATION_COUNT iterations, read the status file despite the
+    // modification time
-    while(true) {
+    while (true) {
-        Thread.sleep( 500 ); // allow for it to be finished writing.
-        //Sometimes the status file is partially written causing readObject to
-        //fail, sleep and retry.
+        Thread.sleep(500); // allow for it to be finished writing.
+        // Sometimes the status file is partially written causing readObject to
+        // fail, sleep and retry.
-          status = readStatus( );
-        } catch(IOException ioeSecondChance) {
+          status = readStatus();
+        } catch (IOException ioeSecondChance) {
-            status = readStatus( );
-          } catch(IOException ioeThirdChance) {
+            status = readStatus();
+          } catch (IOException ioeThirdChance) {
-              status = readStatus( );
+              status = readStatus();
-                  logger.warning(LocalizedStrings.CacheServerLauncher_CREATE_STATUS_EXCEPTION_0, e.toString());
+                  logger.warning(LocalizedStrings.CacheServerLauncher_CREATE_STATUS_EXCEPTION_0,
+                      e.toString());
-            stopAdditionalServices();
-            this.disconnect(cache);
-            status.state = SHUTDOWN;
-            writeStatus(status);
+          stopAdditionalServices();
+          this.disconnect(cache);
+          status.state = SHUTDOWN;
+          writeStatus(status);
-          Thread.sleep( 250 );
+          Thread.sleep(250);
-//        System.out.println("System is disconnected.  isReconnecting = " + system.isReconnecting());
+        // System.out.println("System is disconnected. isReconnecting = " +
+        // system.isReconnecting());
-            system = (InternalDistributedSystem)system.getReconnectedSystem();
+            system = (InternalDistributedSystem) system.getReconnectedSystem();
-  
+
-    if(mainLogListener != null) {
+    if (mainLogListener != null) {
-  
+
-    return (InternalDistributedSystem)DistributedSystem.connect(props);
+    return (InternalDistributedSystem) DistributedSystem.connect(props);
-      String criticalHeapThreshold = (String)options
-          .get(CRITICAL_HEAP_PERCENTAGE);
+      String criticalHeapThreshold = (String) options.get(CRITICAL_HEAP_PERCENTAGE);
-        return Float.parseFloat(criticalHeapThreshold
-            .substring(criticalHeapThreshold.indexOf("=") + 1));
+        return Float
+            .parseFloat(criticalHeapThreshold.substring(criticalHeapThreshold.indexOf("=") + 1));
-  
+
-      String evictionHeapThreshold = (String)options
-          .get(EVICTION_HEAP_PERCENTAGE);
+      String evictionHeapThreshold = (String) options.get(EVICTION_HEAP_PERCENTAGE);
-        return Float.parseFloat(evictionHeapThreshold
-            .substring(evictionHeapThreshold.indexOf("=") + 1));
+        return Float
+            .parseFloat(evictionHeapThreshold.substring(evictionHeapThreshold.indexOf("=") + 1));
-  
+
-      String criticalOffHeapThreshold = (String)options
-          .get(CRITICAL_OFF_HEAP_PERCENTAGE);
+      String criticalOffHeapThreshold = (String) options.get(CRITICAL_OFF_HEAP_PERCENTAGE);
-        return Float.parseFloat(criticalOffHeapThreshold
-            .substring(criticalOffHeapThreshold.indexOf("=") + 1));
+        return Float.parseFloat(
+            criticalOffHeapThreshold.substring(criticalOffHeapThreshold.indexOf("=") + 1));
-  
+
-      String evictionOffHeapThreshold = (String)options
-          .get(EVICTION_OFF_HEAP_PERCENTAGE);
+      String evictionOffHeapThreshold = (String) options.get(EVICTION_OFF_HEAP_PERCENTAGE);
-        return Float.parseFloat(evictionOffHeapThreshold
-            .substring(evictionOffHeapThreshold.indexOf("=") + 1));
+        return Float.parseFloat(
+            evictionOffHeapThreshold.substring(evictionOffHeapThreshold.indexOf("=") + 1));
-  
-  protected Cache createCache(InternalDistributedSystem system, Map<String, Object> options) throws IOException {
+
+  protected Cache createCache(InternalDistributedSystem system, Map<String, Object> options)
+      throws IOException {
-    
+
-    // If (disableDefaultServer is not set or it is set but false) AND (the number of cacheservers is 0)
+    // If (disableDefaultServer is not set or it is set but false) AND (the number of cacheservers
+    // is 0)
-      
+
-   * Stops a cache server (which is running in a different VM) by setting its status to {@link #SHUTDOWN_PENDING}.
-   * Waits for the cache server to actually shut down.
+   * Stops a cache server (which is running in a different VM) by setting its status to
+   * {@link #SHUTDOWN_PENDING}. Waits for the cache server to actually shut down.
-      // poll the Cache Server for a response to our shutdown request (passes through if the Cache Server
+      // poll the Cache Server for a response to our shutdown request (passes through if the Cache
+      // Server
-      // after polling, determine the status of the Cache Server one last time and determine how to exit...
+      // after polling, determine the status of the Cache Server one last time and determine how to
+      // exit...
-        System.out.println(LocalizedStrings.CacheServerLauncher_0_STOPPED.toLocalizedString(this.baseName));
+        System.out.println(
+            LocalizedStrings.CacheServerLauncher_0_STOPPED.toLocalizedString(this.baseName));
+      } else {
+        System.out.println(
+            LocalizedStrings.CacheServerLauncher_TIMEOUT_WAITING_FOR_0_TO_SHUTDOWN_STATUS_IS_1
+                .toLocalizedString(this.baseName, this.status));
-      else {
-        System.out.println(LocalizedStrings.CacheServerLauncher_TIMEOUT_WAITING_FOR_0_TO_SHUTDOWN_STATUS_IS_1
-          .toLocalizedString(this.baseName, this.status));
-      }
-    }
-    else {
-      System.out.println(LocalizedStrings.CacheServerLauncher_THE_SPECIFIED_WORKING_DIRECTORY_0_CONTAINS_NO_STATUS_FILE
-        .toLocalizedString(this.workingDir));
+    } else {
+      System.out.println(
+          LocalizedStrings.CacheServerLauncher_THE_SPECIFIED_WORKING_DIRECTORY_0_CONTAINS_NO_STATUS_FILE
+              .toLocalizedString(this.workingDir));
-      }
-      catch (IOException ignore) {
+      } catch (IOException ignore) {
-      }
-      catch (InterruptedException ie) {
+      } catch (InterruptedException ie) {
-   * A class that represents the status of a cache server.  Instances
-   * of this class are serialized to a {@linkplain #statusName file}
-   * on disk.
+   * A class that represents the status of a cache server. Instances of this class are serialized to
+   * a {@linkplain #statusName file} on disk.
-        }
-        else {
+        } else {
-        buffer.append(LocalizedStrings
-            .CacheServerLauncher_SEE_LOG_FILE_FOR_DETAILS.toLocalizedString());
-      }
-      else if (this.dsMsg != null) {
+        buffer.append(
+            LocalizedStrings.CacheServerLauncher_SEE_LOG_FILE_FOR_DETAILS.toLocalizedString());
+      } else if (this.dsMsg != null) {
-   * Notes that an error has occurred in the cache server and that it
-   * has shut down because of it.
+   * Notes that an error has occurred in the cache server and that it has shut down because of it.
-    }
-    catch (Exception e) {
+    } catch (Exception e) {
-      }
-      else {
+      } else {
-   * Sets the status of a cache server by serializing a <code>Status</code>
-   * instance to a file in the server's working directory.
+   * Sets the status of a cache server by serializing a <code>Status</code> instance to a file in
+   * the server's working directory.
-    }
-    finally {
+    } finally {
-   * Reads a cache server's status.  If the status file cannot be read because of I/O problems, it will try again.
+   * Reads a cache server's status. If the status file cannot be read because of I/O problems, it
+   * will try again.
-      }
-      catch (Exception e) {
-        // try again - the status might have been read in the middle of it being written by the server resulting in
+      } catch (Exception e) {
+        // try again - the status might have been read in the middle of it being written by the
+        // server resulting in
-        }
-        catch (InterruptedException ie) {
+        } catch (InterruptedException ie) {
-      // Note, only execute the conditional createStatus statement if we are in native mode; if we are in pure Java mode
+      // Note, only execute the conditional createStatus statement if we are in native mode; if we
+      // are in pure Java mode
-    }
-    catch (ClassNotFoundException e) {
+    } catch (ClassNotFoundException e) {
-    }
-    catch (FileNotFoundException e) {
+    } catch (FileNotFoundException e) {
-      }
-      else {
+      } else {
-    }
-    finally {
+    } finally {
-    if ( status == null ) {
-      throw new Exception(LocalizedStrings.CacheServerLauncher_NO_AVAILABLE_STATUS.toLocalizedString());
+    if (status == null) {
+      throw new Exception(
+          LocalizedStrings.CacheServerLauncher_NO_AVAILABLE_STATUS.toLocalizedString());
-      switch ( status.state  ) {
+      switch (status.state) {
-          while( status.state == STARTING ) {
-            Thread.sleep( 500 ); // fix for bug 36998
+          while (status.state == STARTING) {
+            Thread.sleep(500); // fix for bug 36998
-            
-            //check to see if the status message has changed
-            if(status.dsMsg != null && !status.dsMsg.equals(lastReadMessage)) {
+
+            // check to see if the status message has changed
+            if (status.dsMsg != null && !status.dsMsg.equals(lastReadMessage)) {
-            
-            //if the status message has not changed for 15 seconds, print
-            //out the message.
+
+            // if the status message has not changed for 15 seconds, print
+            // out the message.
-            if(TimeUnit.NANOSECONDS.toMillis(elapsed) > STATUS_WAIT_TIME
-                && lastReadMessage != null &&
-                !lastReadMessage.equals(lastReportedMessage)) {
+            if (TimeUnit.NANOSECONDS.toMillis(elapsed) > STATUS_WAIT_TIME && lastReadMessage != null
+                && !lastReadMessage.equals(lastReportedMessage)) {
-      System.out.println( status );
+      System.out.println(status);
+   * 
-        //throw new GemFireIOException("Failed reading " + url, io);
+        // throw new GemFireIOException("Failed reading " + url, io);
-        System.exit( 1 );
+        System.exit(1);
-      if ( logFile == null || logFile.length() == 0 ) {
+      if (logFile == null || logFile.length() == 0) {
-      //Didnt find a property file, assuming the default is to log to stdout
+      // Didnt find a property file, assuming the default is to log to stdout
-   * Process information contained in the options map and add to the command
-   * line of the subprocess as needed.
+   * Process information contained in the options map and add to the command line of the subprocess
+   * as needed.
-  protected void addToServerCommand(final List<String> commandLine, final Map<String, Object> options) {
+  protected void addToServerCommand(final List<String> commandLine,
+      final Map<String, Object> options) {
-    String criticalHeapThreshold = (String)options.get(CRITICAL_HEAP_PERCENTAGE);
+    String criticalHeapThreshold = (String) options.get(CRITICAL_HEAP_PERCENTAGE);
-    String evictionHeapThreshold = (String)options
-        .get(EVICTION_HEAP_PERCENTAGE);
+    String evictionHeapThreshold = (String) options.get(EVICTION_HEAP_PERCENTAGE);
-    
-    String criticalOffHeapThreshold = (String)options.get(CRITICAL_OFF_HEAP_PERCENTAGE);
+
+    String criticalOffHeapThreshold = (String) options.get(CRITICAL_OFF_HEAP_PERCENTAGE);
-    String evictionOffHeapThreshold = (String)options
-        .get(EVICTION_OFF_HEAP_PERCENTAGE);
+    String evictionOffHeapThreshold = (String) options.get(EVICTION_OFF_HEAP_PERCENTAGE);
-      // Do not allow the cache server to log to stdout; override the logger with #defaultLogFileName
+      // Do not allow the cache server to log to stdout; override the logger with
+      // #defaultLogFileName
-   * This method is called immediately following cache creation in the spawned
-   * process, but prior to setting the RUNNING flag in the status file. So the
-   * spawning process will block until this method completes.
+   * This method is called immediately following cache creation in the spawned process, but prior to
+   * setting the RUNNING flag in the status file. So the spawning process will block until this
+   * method completes.
-  protected void startAdditionalServices(final Cache cache, final Map<String, Object> options) throws Exception {
-  }
+  protected void startAdditionalServices(final Cache cache, final Map<String, Object> options)
+      throws Exception {}
-   * This method is called prior to DistributedSytstem.disconnect(). Care should
-   * be taken not to take too long in this method or else
-   * #CacheServerLauncher.stop may timeout.
+   * This method is called prior to DistributedSytstem.disconnect(). Care should be taken not to
+   * take too long in this method or else #CacheServerLauncher.stop may timeout.
-  protected void stopAdditionalServices() throws Exception {
-  }
+  protected void stopAdditionalServices() throws Exception {}
+   * 
-  protected static class ListWrapper<E> extends AbstractList<E>  {
+  protected static class ListWrapper<E> extends AbstractList<E> {
-  
+
-    
+
-      lastLogMessage = status;      
+      lastLogMessage = status;
-      while(running) {
+      while (running) {
-          //this should not happen.
+          // this should not happen.
-        if(running && safeEquals(lastLogMessage, status.dsMsg)) {
+        if (running && safeEquals(lastLogMessage, status.dsMsg)) {
-            //this could happen if there was a concurrent write to the file
-            //eg a stop.
+            // this could happen if there was a concurrent write to the file
+            // eg a stop.
+
-    if (lastLogMessage == null && dsMsg == null){
+    if (lastLogMessage == null && dsMsg == null) {
-    }
-    else if (lastLogMessage == null || dsMsg == null){
+    } else if (lastLogMessage == null || dsMsg == null) {

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
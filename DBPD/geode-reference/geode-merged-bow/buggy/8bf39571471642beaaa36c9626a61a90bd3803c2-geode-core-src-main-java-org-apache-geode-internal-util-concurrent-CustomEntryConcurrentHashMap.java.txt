Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * (http://backport-jsr166.sourceforge.net) JDK5 version release 3.1
- * with modifications to use generics where appropriate:
- * backport-util-concurrent-Java60-3.1-src.tar.gz 
+ * (http://backport-jsr166.sourceforge.net) JDK5 version release 3.1 with modifications to use
+ * generics where appropriate: backport-util-concurrent-Java60-3.1-src.tar.gz
- * Primary change is to allow HashEntry be an interface so that custom HashEntry
- * implementations can be plugged in. These HashEntry objects are now assumed to
- * be immutable in the sense that they cannot and should not be cloned in a
- * rehash, and the rehash mechanism has been recoded using locking for that. For
- * Geode, this is now used to plugin the RegionEntry implementation
- * directly as a HashEntry instead of having it as a value and then HashEntry as
- * a separate object having references to key/value which reduces the entry
- * overhead substantially. Other change is to add a "create" method that creates
- * a new object using the {@link MapCallback} interface only if required unlike
- * "putIfAbsent" that requires a pre-built object that may ultimately be thrown
- * away. Also added a "removeConditionally" method that allows for evaluation of
- * an arbitrary condition before removal from the map (unlike the normal
- * "remove" that can only check for equality with a provided object). In
- * addition, the segments are now locked using read-write locks. File has been
- * reformatted to conform to GemStone conventions.
- * GemStone additions have been marked with "GemStone addition".
- * GemStone changes have been marked with "GemStone change(s)".
+ * Primary change is to allow HashEntry be an interface so that custom HashEntry implementations can
+ * be plugged in. These HashEntry objects are now assumed to be immutable in the sense that they
+ * cannot and should not be cloned in a rehash, and the rehash mechanism has been recoded using
+ * locking for that. For Geode, this is now used to plugin the RegionEntry implementation directly
+ * as a HashEntry instead of having it as a value and then HashEntry as a separate object having
+ * references to key/value which reduces the entry overhead substantially. Other change is to add a
+ * "create" method that creates a new object using the {@link MapCallback} interface only if
+ * required unlike "putIfAbsent" that requires a pre-built object that may ultimately be thrown
+ * away. Also added a "removeConditionally" method that allows for evaluation of an arbitrary
+ * condition before removal from the map (unlike the normal "remove" that can only check for
+ * equality with a provided object). In addition, the segments are now locked using read-write
+ * locks. File has been reformatted to conform to GemStone conventions. GemStone additions have been
+ * marked with "GemStone addition". GemStone changes have been marked with "GemStone change(s)".
- * Written by Doug Lea with assistance from members of JCP JSR-166
- * Expert Group and released to the public domain, as explained at
- * http://creativecommons.org/licenses/publicdomain
+ * Written by Doug Lea with assistance from members of JCP JSR-166 Expert Group and released to the
+ * public domain, as explained at http://creativecommons.org/licenses/publicdomain
- * A hash table supporting full concurrency of retrievals and adjustable
- * expected concurrency for updates. This class obeys the same functional
- * specification as {@link java.util.Hashtable}, and includes versions of
- * methods corresponding to each method of <tt>Hashtable</tt>. However, even
- * though all operations are thread-safe, retrieval operations do <em>not</em>
- * entail locking, and there is <em>not</em> any support for locking the entire
- * table in a way that prevents all access. This class is fully interoperable
- * with <tt>Hashtable</tt> in programs that rely on its thread safety but not on
- * its synchronization details.
+ * A hash table supporting full concurrency of retrievals and adjustable expected concurrency for
+ * updates. This class obeys the same functional specification as {@link java.util.Hashtable}, and
+ * includes versions of methods corresponding to each method of <tt>Hashtable</tt>. However, even
+ * though all operations are thread-safe, retrieval operations do <em>not</em> entail locking, and
+ * there is <em>not</em> any support for locking the entire table in a way that prevents all access.
+ * This class is fully interoperable with <tt>Hashtable</tt> in programs that rely on its thread
+ * safety but not on its synchronization details.
- * Retrieval operations (including <tt>get</tt>) generally do not block, so may
- * overlap with update operations (including <tt>put</tt> and <tt>remove</tt>).
- * Retrievals reflect the results of the most recently <em>completed</em> update
- * operations holding upon their onset. For aggregate operations such as
- * <tt>putAll</tt> and <tt>clear</tt>, concurrent retrievals may reflect
- * insertion or removal of only some entries. Similarly, Iterators and
- * Enumerations return elements reflecting the state of the hash table at some
- * point at or since the creation of the iterator/enumeration. They do
- * <em>not</em> throw {@link java.util.ConcurrentModificationException}.
- * However, iterators are designed to be used by only one thread at a time.
+ * Retrieval operations (including <tt>get</tt>) generally do not block, so may overlap with update
+ * operations (including <tt>put</tt> and <tt>remove</tt>). Retrievals reflect the results of the
+ * most recently <em>completed</em> update operations holding upon their onset. For aggregate
+ * operations such as <tt>putAll</tt> and <tt>clear</tt>, concurrent retrievals may reflect
+ * insertion or removal of only some entries. Similarly, Iterators and Enumerations return elements
+ * reflecting the state of the hash table at some point at or since the creation of the
+ * iterator/enumeration. They do <em>not</em> throw
+ * {@link java.util.ConcurrentModificationException}. However, iterators are designed to be used by
+ * only one thread at a time.
- * <tt>concurrencyLevel</tt> constructor argument (default <tt>16</tt>), which
- * is used as a hint for internal sizing. The table is internally partitioned to
- * try to permit the indicated number of concurrent updates without contention.
- * Because placement in hash tables is essentially random, the actual
- * concurrency will vary. Ideally, you should choose a value to accommodate as
- * many threads as will ever concurrently modify the table. Using a
- * significantly higher value than you need can waste space and time, and a
- * significantly lower value can lead to thread contention. But overestimates
- * and underestimates within an order of magnitude do not usually have much
- * noticeable impact. A value of one is appropriate when it is known that only
- * one thread will modify and all others will only read. Also, resizing this or
- * any other kind of hash table is a relatively slow operation, so, when
- * possible, it is a good idea to provide estimates of expected table sizes in
+ * <tt>concurrencyLevel</tt> constructor argument (default <tt>16</tt>), which is used as a hint for
+ * internal sizing. The table is internally partitioned to try to permit the indicated number of
+ * concurrent updates without contention. Because placement in hash tables is essentially random,
+ * the actual concurrency will vary. Ideally, you should choose a value to accommodate as many
+ * threads as will ever concurrently modify the table. Using a significantly higher value than you
+ * need can waste space and time, and a significantly lower value can lead to thread contention. But
+ * overestimates and underestimates within an order of magnitude do not usually have much noticeable
+ * impact. A value of one is appropriate when it is known that only one thread will modify and all
+ * others will only read. Also, resizing this or any other kind of hash table is a relatively slow
+ * operation, so, when possible, it is a good idea to provide estimates of expected table sizes in
- * This class and its views and iterators implement all of the <em>optional</em>
- * methods of the {@link Map} and {@link Iterator} interfaces.
+ * This class and its views and iterators implement all of the <em>optional</em> methods of the
+ * {@link Map} and {@link Iterator} interfaces.
- * Like {@link java.util.Hashtable} but unlike {@link java.util.HashMap}, this
- * class does <em>not</em> allow <tt>null</tt> to be used as a key or value.
+ * Like {@link java.util.Hashtable} but unlike {@link java.util.HashMap}, this class does
+ * <em>not</em> allow <tt>null</tt> to be used as a key or value.
- * This class is a member of the <a href="{@docRoot}
- * /../technotes/guides/collections/index.html"> Java Collections Framework</a>.
+ * This class is a member of the <a href="{@docRoot} /../technotes/guides/collections/index.html">
+ * Java Collections Framework</a>.
- * @param <K>
- *          the type of keys maintained by this map
- * @param <V>
- *          the type of mapped values
+ * @param <K> the type of keys maintained by this map
+ * @param <V> the type of mapped values
-public class CustomEntryConcurrentHashMap<K, V> extends AbstractMap<K, V> implements
-    ConcurrentMap<K, V>, Serializable {
+public class CustomEntryConcurrentHashMap<K, V> extends AbstractMap<K, V>
+    implements ConcurrentMap<K, V>, Serializable {
-   * The basic strategy is to subdivide the table among Segments,
-   * each of which itself is a concurrently readable hash table.
+   * The basic strategy is to subdivide the table among Segments, each of which itself is a
+   * concurrently readable hash table.
-   * The default initial capacity for this table, used when not otherwise
-   * specified in a constructor.
+   * The default initial capacity for this table, used when not otherwise specified in a
+   * constructor.
-   * The default load factor for this table, used when not otherwise specified
-   * in a constructor.
+   * The default load factor for this table, used when not otherwise specified in a constructor.
-   * The default concurrency level for this table, used when not otherwise
-   * specified in a constructor.
+   * The default concurrency level for this table, used when not otherwise specified in a
+   * constructor.
-   * The maximum capacity, used if a higher value is implicitly specified by
-   * either of the constructors with arguments. MUST be a power of two <= 1<<30
-   * to ensure that entries are indexable using ints.
+   * The maximum capacity, used if a higher value is implicitly specified by either of the
+   * constructors with arguments. MUST be a power of two <= 1<<30 to ensure that entries are
+   * indexable using ints.
-   * The maximum number of segments to allow; used to bound constructor
-   * arguments.
+   * The maximum number of segments to allow; used to bound constructor arguments.
-   * Number of unsynchronized retries in size and containsValue methods before
-   * resorting to locking. This is used to avoid unbounded retries if tables
-   * undergo continuous modification which would make it impossible to obtain an
-   * accurate result.
+   * Number of unsynchronized retries in size and containsValue methods before resorting to locking.
+   * This is used to avoid unbounded retries if tables undergo continuous modification which would
+   * make it impossible to obtain an accurate result.
-// GemStone addition
+  // GemStone addition
-   * Token object to indicate that {@link #remove(Object)} does not need to
-   * compare against provided value before removing from segment.
+   * Token object to indicate that {@link #remove(Object)} does not need to compare against provided
+   * value before removing from segment.
-// End GemStone addition
+  // End GemStone addition
-   * Mask value for indexing into segments. The upper bits of a key's hash code
-   * are used to choose the segment.
+   * Mask value for indexing into segments. The upper bits of a key's hash code are used to choose
+   * the segment.
-   * If true then use equals for comparing key and value equality else use
-   * reference-equality like an {@link IdentityHashMap}.
+   * If true then use equals for comparing key and value equality else use reference-equality like
+   * an {@link IdentityHashMap}.
-   * Applies a supplemental hash function to a given hashCode, which defends
-   * against poor quality hash functions. This is critical because
-   * ConcurrentHashMap uses power-of-two length hash tables, that otherwise
-   * encounter collisions for hashCodes that do not differ in lower or upper
+   * Applies a supplemental hash function to a given hashCode, which defends against poor quality
+   * hash functions. This is critical because ConcurrentHashMap uses power-of-two length hash
+   * tables, that otherwise encounter collisions for hashCodes that do not differ in lower or upper
-   * @param hash
-   *          the hash code for the key
+   * @param hash the hash code for the key
-// GemStone addition
-// GemStone changed HashEntry to be an interface with original HashEntry
-// as the default implementation HashEntryImpl.
+  // GemStone addition
+  // GemStone changed HashEntry to be an interface with original HashEntry
+  // as the default implementation HashEntryImpl.
-   * [sumedh] Interface for ConcurrentHashMap list entry. Note that this is
-   * never exported out as a user-visible Map.Entry.
+   * [sumedh] Interface for ConcurrentHashMap list entry. Note that this is never exported out as a
+   * user-visible Map.Entry.
-   * Made this public so RegionEntries can directly implement this to reduce
-   * memory overhead of separate {@link org.apache.geode.internal.util.concurrent.CustomEntryConcurrentHashMap.HashEntry} objects for each entry in the
-   * map.
+   * Made this public so RegionEntries can directly implement this to reduce memory overhead of
+   * separate
+   * {@link org.apache.geode.internal.util.concurrent.CustomEntryConcurrentHashMap.HashEntry}
+   * objects for each entry in the map.
-    
+
-     * Return true if the entry's key is equal to k.
-     * GemFire addition to deal with inline keys.
+     * Return true if the entry's key is equal to k. GemFire addition to deal with inline keys.
-   * ConcurrentHashMap list entry. Note that this is never exported out as a
-   * user-visible Map.Entry.
+   * ConcurrentHashMap list entry. Note that this is never exported out as a user-visible Map.Entry.
-   * Because the value field is volatile, not final, it is legal wrt the Java
-   * Memory Model for an unsynchronized reader to see null instead of initial
-   * value when read via a data race. Although a reordering leading to this is
-   * not likely to ever actually occur, the Segment.readValueUnderLock method is
-   * used as a backup in case a null (pre-initialized) value is ever seen in an
-   * unsynchronized access method.
+   * Because the value field is volatile, not final, it is legal wrt the Java Memory Model for an
+   * unsynchronized reader to see null instead of initial value when read via a data race. Although
+   * a reordering leading to this is not likely to ever actually occur, the
+   * Segment.readValueUnderLock method is used as a backup in case a null (pre-initialized) value is
+   * ever seen in an unsynchronized access method.
-    HashEntryImpl(final K key, final int hash, final HashEntry<K, V> next,
-        final V value, final HashEntry<K, V> wrappedEntry) {
+    HashEntryImpl(final K key, final int hash, final HashEntry<K, V> next, final V value,
+        final HashEntry<K, V> wrappedEntry) {
-   * Interface to enable creation of new {@link org.apache.geode.internal.util.concurrent.CustomEntryConcurrentHashMap.HashEntry} objects by caller.
-   * This can be used, for example, to return GemFire RegionEntries directly.
+   * Interface to enable creation of new
+   * {@link org.apache.geode.internal.util.concurrent.CustomEntryConcurrentHashMap.HashEntry}
+   * objects by caller. This can be used, for example, to return GemFire RegionEntries directly.
-     * Create a new {@link org.apache.geode.internal.util.concurrent.CustomEntryConcurrentHashMap.HashEntry} given the key, hash, value and next
-     * element.
+     * Create a new
+     * {@link org.apache.geode.internal.util.concurrent.CustomEntryConcurrentHashMap.HashEntry}
+     * given the key, hash, value and next element.
-    public HashEntry<K, V> newEntry(K key, int hash, HashEntry<K, V> next,
-        V value);
+    public HashEntry<K, V> newEntry(K key, int hash, HashEntry<K, V> next, V value);
-// End GemStone addition
+  // End GemStone addition
-   * Segments are specialized versions of hash tables. This subclasses from
-   * ReentrantLock opportunistically, just to simplify some locking and avoid
-   * separate construction.
+   * Segments are specialized versions of hash tables. This subclasses from ReentrantLock
+   * opportunistically, just to simplify some locking and avoid separate construction.
-  static class Segment<K, V> extends ReentrantReadWriteLock implements
-      Serializable {
+  static class Segment<K, V> extends ReentrantReadWriteLock implements Serializable {
-     * Segments maintain a table of entry lists that are ALWAYS
-     * kept in a consistent state, so can be read without locking.
-     * Next fields of nodes are immutable (final).  All list
-     * additions are performed at the front of each bin. This
-     * makes it easy to check changes, and also fast to traverse.
-     * When nodes would otherwise be changed, new nodes are
-     * created to replace them. This works well for hash tables
-     * since the bin lists tend to be short. (The average length
-     * is less than two for the default load factor threshold.)
+     * Segments maintain a table of entry lists that are ALWAYS kept in a consistent state, so can
+     * be read without locking. Next fields of nodes are immutable (final). All list additions are
+     * performed at the front of each bin. This makes it easy to check changes, and also fast to
+     * traverse. When nodes would otherwise be changed, new nodes are created to replace them. This
+     * works well for hash tables since the bin lists tend to be short. (The average length is less
+     * than two for the default load factor threshold.)
-     * Read operations can thus proceed without locking, but rely
-     * on selected uses of volatiles to ensure that completed
-     * write operations performed by other threads are
-     * noticed. For most purposes, the "count" field, tracking the
-     * number of elements, serves as that volatile variable
-     * ensuring visibility.  This is convenient because this field
-     * needs to be read in many read operations anyway:
+     * Read operations can thus proceed without locking, but rely on selected uses of volatiles to
+     * ensure that completed write operations performed by other threads are noticed. For most
+     * purposes, the "count" field, tracking the number of elements, serves as that volatile
+     * variable ensuring visibility. This is convenient because this field needs to be read in many
+     * read operations anyway:
-     *   - All (unsynchronized) read operations must first read the
-     *     "count" field, and should not look at table entries if
-     *     it is 0.
+     * - All (unsynchronized) read operations must first read the "count" field, and should not look
+     * at table entries if it is 0.
-     *   - All (synchronized) write operations should write to
-     *     the "count" field after structurally changing any bin.
-     *     The operations must not take any action that could even
-     *     momentarily cause a concurrent read operation to see
-     *     inconsistent data. This is made easier by the nature of
-     *     the read operations in Map. For example, no operation
-     *     can reveal that the table has grown but the threshold
-     *     has not yet been updated, so there are no atomicity
-     *     requirements for this with respect to reads.
+     * - All (synchronized) write operations should write to the "count" field after structurally
+     * changing any bin. The operations must not take any action that could even momentarily cause a
+     * concurrent read operation to see inconsistent data. This is made easier by the nature of the
+     * read operations in Map. For example, no operation can reveal that the table has grown but the
+     * threshold has not yet been updated, so there are no atomicity requirements for this with
+     * respect to reads.
-     * As a guide, all critical volatile reads and writes to the
-     * count field are marked in code comments.
+     * As a guide, all critical volatile reads and writes to the count field are marked in code
+     * comments.
-     * Number of updates that alter the size of the table. This is used during
-     * bulk-read methods to make sure they see a consistent snapshot: If
-     * modCounts change during a traversal of segments computing size or
-     * checking containsValue, then we might have an inconsistent view of state
-     * so (usually) must retry.
+     * Number of updates that alter the size of the table. This is used during bulk-read methods to
+     * make sure they see a consistent snapshot: If modCounts change during a traversal of segments
+     * computing size or checking containsValue, then we might have an inconsistent view of state so
+     * (usually) must retry.
-     * The table is rehashed when its size exceeds this threshold. (The value of
-     * this field is always <tt>(int)(capacity *
+     * The table is rehashed when its size exceeds this threshold. (The value of this field is
+     * always <tt>(int)(capacity *
-     * The load factor for the hash table. Even though this value is same for
-     * all segments, it is replicated to avoid needing links to outer object.
+     * The load factor for the hash table. Even though this value is same for all segments, it is
+     * replicated to avoid needing links to outer object.
-// GemStone addition
+    // GemStone addition
-     * {@link org.apache.geode.internal.util.concurrent.CustomEntryConcurrentHashMap.HashEntryCreator} for the map to create {@link org.apache.geode.internal.util.concurrent.CustomEntryConcurrentHashMap.HashEntry}s.
+     * {@link org.apache.geode.internal.util.concurrent.CustomEntryConcurrentHashMap.HashEntryCreator}
+     * for the map to create
+     * {@link org.apache.geode.internal.util.concurrent.CustomEntryConcurrentHashMap.HashEntry}s.
-     * Lock used when updating the {@link org.apache.geode.internal.util.concurrent.CustomEntryConcurrentHashMap.HashEntry#getNextEntry()} link of an
-     * entry.
+     * Lock used when updating the
+     * {@link org.apache.geode.internal.util.concurrent.CustomEntryConcurrentHashMap.HashEntry#getNextEntry()}
+     * link of an entry.
-// End GemStone addition
+    // End GemStone addition
-    Segment(final int initialCapacity, final float lf,
-        final HashEntryCreator<K, V> entryCreator) {
+    Segment(final int initialCapacity, final float lf, final HashEntryCreator<K, V> entryCreator) {
-      setTable(Segment.<K, V> newEntryArray(initialCapacity));
+      setTable(Segment.<K, V>newEntryArray(initialCapacity));
-// GemStone added the method below
+    // GemStone added the method below
-     * Sets table to new HashEntry array. Call only while holding lock or in
-     * constructor.
+     * Sets table to new HashEntry array. Call only while holding lock or in constructor.
-      this.threshold = (int)(newTable.length * this.loadFactor);
+      this.threshold = (int) (newTable.length * this.loadFactor);
-     * Reads value field of an entry under lock. Called if value field ever
-     * appears to be null. This is possible only if a compiler happens to
-     * reorder a HashEntry initialization with its table assignment, which is
-     * legal under memory model but is not known to ever occur.
+     * Reads value field of an entry under lock. Called if value field ever appears to be null. This
+     * is possible only if a compiler happens to reorder a HashEntry initialization with its table
+     * assignment, which is legal under memory model but is not known to ever occur.
+
-    protected boolean equalityCompareWithNulls(final Object key,
-        final Object mapKey) {
+    protected boolean equalityCompareWithNulls(final Object key, final Object mapKey) {
-// GemStone change to acquire the read lock on list updates
-        final ReentrantReadWriteLock.ReadLock listLock = this.listUpdateLock
-            .readLock();
+        // GemStone change to acquire the read lock on list updates
+        final ReentrantReadWriteLock.ReadLock listLock = this.listUpdateLock.readLock();
-    final V getNoLock(final Object key, final int hash,
-        final boolean lockListForRead) {
+    final V getNoLock(final Object key, final int hash, final boolean lockListForRead) {
-// GemStone change to acquire the read lock on list updates
+        // GemStone change to acquire the read lock on list updates
-// GemStone change to acquire the read lock on list updates
-        final ReentrantReadWriteLock.ReadLock listLock = this.listUpdateLock
-            .readLock();
+        // GemStone change to acquire the read lock on list updates
+        final ReentrantReadWriteLock.ReadLock listLock = this.listUpdateLock.readLock();
-// GemStone change to acquire the read lock on list updates
-        ReentrantReadWriteLock.ReadLock readLock = this.listUpdateLock
-            .readLock();
-RETRYLOOP:
-        for (;;) {
+        // GemStone change to acquire the read lock on list updates
+        ReentrantReadWriteLock.ReadLock readLock = this.listUpdateLock.readLock();
+        RETRYLOOP: for (;;) {
-                /* (original code)
-                v = readValueUnderLock(e);
-                */
+                /*
+                 * (original code) v = readValueUnderLock(e);
+                 */
-    final boolean replace(final K key, final int hash, final V oldValue,
-        final V newValue) {
+    final boolean replace(final K key, final int hash, final V oldValue, final V newValue) {
-        while (e != null && (e.getEntryHash() != hash
-            || !equalityKeyCompare(key, e))) {
+        while (e != null && (e.getEntryHash() != hash || !equalityKeyCompare(key, e))) {
-        while (e != null && (e.getEntryHash() != hash
-            || !equalityKeyCompare(key, e))) {
+        while (e != null && (e.getEntryHash() != hash || !equalityKeyCompare(key, e))) {
-    final V put(final K key, final int hash, final V value,
-        final boolean onlyIfAbsent) {
+    final V put(final K key, final int hash, final V value, final boolean onlyIfAbsent) {
-        while (e != null && (e.getEntryHash() != hash
-            || !equalityKeyCompare(key, e))) {
+        while (e != null && (e.getEntryHash() != hash || !equalityKeyCompare(key, e))) {
-        }
-        else {
+        } else {
-// GemStone additions
+    // GemStone additions
-    final <C, P> V create(final K key, final int hash,
-        final MapCallback<K, V, C, P> valueCreator, final C context,
-        final P createParams, final boolean lockForRead) {
+    final <C, P> V create(final K key, final int hash, final MapCallback<K, V, C, P> valueCreator,
+        final C context, final P createParams, final boolean lockForRead) {
-      }
-      else {
+      } else {
-        while (e != null && (e.getEntryHash() != hash
-            || !equalityKeyCompare(key, e))) {
+        while (e != null && (e.getEntryHash() != hash || !equalityKeyCompare(key, e))) {
-          tab[index] = this.entryCreator.newEntry(key, hash, first,
-              currentValue);
+          tab[index] = this.entryCreator.newEntry(key, hash, first, currentValue);
-        }
-        else {
+        } else {
-    final V get(final Object key, final int hash,
-        final MapCallback<K, V, ?, ?> readCallback) {
+    final V get(final Object key, final int hash, final MapCallback<K, V, ?, ?> readCallback) {
-// End GemStone additions
+    // End GemStone additions
-       * Reclassify nodes in each list to new Map.  Because we are
-       * using power-of-two expansion, the elements from each bin
-       * must either stay at same index, or move with a power of two
-       * offset. We eliminate unnecessary node creation by catching
-       * cases where old nodes can be reused because their next
-       * fields won't change. Statistically, at the default
-       * threshold, only about one-sixth of them need cloning when
-       * a table doubles. The nodes they replace will be garbage
-       * collectable as soon as they are no longer referenced by any
-       * reader thread that may be in the midst of traversing table
-       * right now.
+       * Reclassify nodes in each list to new Map. Because we are using power-of-two expansion, the
+       * elements from each bin must either stay at same index, or move with a power of two offset.
+       * We eliminate unnecessary node creation by catching cases where old nodes can be reused
+       * because their next fields won't change. Statistically, at the default threshold, only about
+       * one-sixth of them need cloning when a table doubles. The nodes they replace will be garbage
+       * collectable as soon as they are no longer referenced by any reader thread that may be in
+       * the midst of traversing table right now.
-      this.threshold = (int)(newTable.length * this.loadFactor);
+      this.threshold = (int) (newTable.length * this.loadFactor);
-          }
-          else {
+          } else {
-            for (HashEntry<K, V> last = next; last != null; last = last
-                .getNextEntry()) {
+            for (HashEntry<K, V> last = next; last != null; last = last.getNextEntry()) {
-// GemStone changes BEGIN
+            // GemStone changes BEGIN
-            //Bug 44155 - we need to clone all of the entries, not just
-            //the entries leading up to lastRun, because the entries
-            //in the last run may have their next pointers changed
-            //by a later rehash.
+            // Bug 44155 - we need to clone all of the entries, not just
+            // the entries leading up to lastRun, because the entries
+            // in the last run may have their next pointers changed
+            // by a later rehash.
-              }
-              else {
+              } else {
-            final ReentrantReadWriteLock.WriteLock listWriteLock =
-                this.listUpdateLock.writeLock();
+            final ReentrantReadWriteLock.WriteLock listWriteLock = this.listUpdateLock.writeLock();
-            /* (original code)
-            for (HashEntry<K, V> p = e; p != lastRun; p = p.next) {
-              final int k = p.hash & sizeMask;
-              final HashEntry<K, V> n = newTable[k];
-              newTable[k] = this.entryCreator.newEntry(p.key, p.hash, n,
-                  p.value);
-            }
-            */
-// GemStone changes END
+            /*
+             * (original code) for (HashEntry<K, V> p = e; p != lastRun; p = p.next) { final int k =
+             * p.hash & sizeMask; final HashEntry<K, V> n = newTable[k]; newTable[k] =
+             * this.entryCreator.newEntry(p.key, p.hash, n, p.value); }
+             */
+            // GemStone changes END
-// GemStone change
+    // GemStone change
-        final MapCallback<K, V, C, P> condition, final C context,
-        final P removeParams) {
-// End GemStone change
+        final MapCallback<K, V, C, P> condition, final C context, final P removeParams) {
+      // End GemStone change
-// GemStone change
+        // GemStone change
-        while (e != null && (e.getEntryHash() != hash
-            || !equalityKeyCompare(key, e))) {
+        while (e != null && (e.getEntryHash() != hash || !equalityKeyCompare(key, e))) {
-          }
-          else {
+          } else {
-// GemStone change
+          // GemStone change
-              && (condition == null || condition.doRemoveValue(v, context,
-                  removeParams))) {
-// End GemStone change
+              && (condition == null || condition.doRemoveValue(v, context, removeParams))) {
+            // End GemStone change
-// GemStone changes BEGIN
+            // GemStone changes BEGIN
-            final ReentrantReadWriteLock.WriteLock listWriteLock =
-                this.listUpdateLock.writeLock();
+            final ReentrantReadWriteLock.WriteLock listWriteLock = this.listUpdateLock.writeLock();
-              }
-              else {
+              } else {
-            /* (original code)
-            HashEntry<K, V> newFirst = e.next;
-            for (HashEntry<K, V> p = first; p != e; p = p.next) {
-              newFirst = this.entryCreator.newEntry(p.key, p.hash, newFirst,
-                  p.value);
-            }
-            tab[index] = newFirst;
-            */
-// GemStone changes END
+            /*
+             * (original code) HashEntry<K, V> newFirst = e.next; for (HashEntry<K, V> p = first; p
+             * != e; p = p.next) { newFirst = this.entryCreator.newEntry(p.key, p.hash, newFirst,
+             * p.value); } tab[index] = newFirst;
+             */
+            // GemStone changes END
-    final ArrayList<HashEntry<?,?>> clear(ArrayList<HashEntry<?,?>> clearedEntries) {
+    final ArrayList<HashEntry<?, ?>> clear(ArrayList<HashEntry<?, ?>> clearedEntries) {
-          final boolean checkForGatewaySenderEvent = OffHeapRegionEntryHelper.doesClearNeedToCheckForOffHeap();
+          final boolean checkForGatewaySenderEvent =
+              OffHeapRegionEntryHelper.doesClearNeedToCheckForOffHeap();
-              if (he == null) continue;
+              if (he == null)
+                continue;
-                    GatewaySenderEventImpl.release(((RegionEntry) p)._getValue()); // OFFHEAP _getValue ok
+                    GatewaySenderEventImpl.release(((RegionEntry) p)._getValue()); // OFFHEAP
+                                                                                   // _getValue ok
-   * Extension of {@link org.apache.geode.internal.util.concurrent.CustomEntryConcurrentHashMap.Segment} using reference-equality comparison for key,
-   * value equality instead of equals method.
+   * Extension of
+   * {@link org.apache.geode.internal.util.concurrent.CustomEntryConcurrentHashMap.Segment} using
+   * reference-equality comparison for key, value equality instead of equals method.
+   * 
-  static final class IdentitySegment<K, V> extends Segment<K, V> implements
-      Serializable {
+  static final class IdentitySegment<K, V> extends Segment<K, V> implements Serializable {
-    protected final boolean equalityKeyCompare(final Object key,
-        final HashEntry<K, V> mapEntry) {
+    protected final boolean equalityKeyCompare(final Object key, final HashEntry<K, V> mapEntry) {
-    protected final boolean equalityCompare(final Object key,
-        final Object mapKey) {
+    protected final boolean equalityCompare(final Object key, final Object mapKey) {
-    protected final boolean equalityCompareWithNulls(final Object key,
-        final Object mapKey) {
+    protected final boolean equalityCompareWithNulls(final Object key, final Object mapKey) {
-   * Creates a new, empty map with the specified initial capacity, load factor
-   * and concurrency level.
+   * Creates a new, empty map with the specified initial capacity, load factor and concurrency
+   * level.
-   * @param initialCapacity
-   *          the initial capacity. The implementation performs internal sizing
-   *          to accommodate this many elements.
-   * @param loadFactor
-   *          the load factor threshold, used to control resizing. Resizing may
-   *          be performed when the average number of elements per bin exceeds
-   *          this threshold.
-   * @param concurrencyLevel
-   *          the estimated number of concurrently updating threads. The
-   *          implementation performs internal sizing to try to accommodate this
-   *          many threads.
-   * @throws IllegalArgumentException
-   *           if the initial capacity is negative or the load factor or
-   *           concurrencyLevel are nonpositive.
+   * @param initialCapacity the initial capacity. The implementation performs internal sizing to
+   *        accommodate this many elements.
+   * @param loadFactor the load factor threshold, used to control resizing. Resizing may be
+   *        performed when the average number of elements per bin exceeds this threshold.
+   * @param concurrencyLevel the estimated number of concurrently updating threads. The
+   *        implementation performs internal sizing to try to accommodate this many threads.
+   * @throws IllegalArgumentException if the initial capacity is negative or the load factor or
+   *         concurrencyLevel are nonpositive.
-// GemStone addition
+  // GemStone addition
-   * Creates a new, empty map with the specified initial capacity, load factor
-   * and concurrency level.
+   * Creates a new, empty map with the specified initial capacity, load factor and concurrency
+   * level.
-   * @param initialCapacity
-   *          the initial capacity. The implementation performs internal sizing
-   *          to accommodate this many elements.
-   * @param loadFactor
-   *          the load factor threshold, used to control resizing. Resizing may
-   *          be performed when the average number of elements per bin exceeds
-   *          this threshold.
-   * @param concurrencyLevel
-   *          the estimated number of concurrently updating threads. The
-   *          implementation performs internal sizing to try to accommodate this
-   *          many threads.
-   * @param isIdentityMap
-   *          if true then this will use reference-equality instead of equals
-   *          like an {@link IdentityHashMap}
-   * @throws IllegalArgumentException
-   *           if the initial capacity is negative or the load factor or
-   *           concurrencyLevel are nonpositive.
+   * @param initialCapacity the initial capacity. The implementation performs internal sizing to
+   *        accommodate this many elements.
+   * @param loadFactor the load factor threshold, used to control resizing. Resizing may be
+   *        performed when the average number of elements per bin exceeds this threshold.
+   * @param concurrencyLevel the estimated number of concurrently updating threads. The
+   *        implementation performs internal sizing to try to accommodate this many threads.
+   * @param isIdentityMap if true then this will use reference-equality instead of equals like an
+   *        {@link IdentityHashMap}
+   * @throws IllegalArgumentException if the initial capacity is negative or the load factor or
+   *         concurrencyLevel are nonpositive.
-   * Creates a new, empty map with the specified initial capacity, load factor,
-   * concurrency level and custom {@link HashEntryCreator}.
+   * Creates a new, empty map with the specified initial capacity, load factor, concurrency level
+   * and custom {@link HashEntryCreator}.
-   * @param initialCapacity
-   *          the initial capacity. The implementation performs internal sizing
-   *          to accommodate this many elements.
-   * @param loadFactor
-   *          the load factor threshold, used to control resizing. Resizing may
-   *          be performed when the average number of elements per bin exceeds
-   *          this threshold.
-   * @param concurrencyLevel
-   *          the estimated number of concurrently updating threads. The
-   *          implementation performs internal sizing to try to accommodate this
-   *          many threads.
-   * @param isIdentityMap
-   *          if true then this will use reference-equality instead of equals
-   *          like an {@link IdentityHashMap}
-   * @param entryCreator
-   *          a custom {@link HashEntryCreator} for creating the map entries
+   * @param initialCapacity the initial capacity. The implementation performs internal sizing to
+   *        accommodate this many elements.
+   * @param loadFactor the load factor threshold, used to control resizing. Resizing may be
+   *        performed when the average number of elements per bin exceeds this threshold.
+   * @param concurrencyLevel the estimated number of concurrently updating threads. The
+   *        implementation performs internal sizing to try to accommodate this many threads.
+   * @param isIdentityMap if true then this will use reference-equality instead of equals like an
+   *        {@link IdentityHashMap}
+   * @param entryCreator a custom {@link HashEntryCreator} for creating the map entries
-   * @throws IllegalArgumentException
-   *           if the initial capacity is negative or the load factor or
-   *           concurrencyLevel are nonpositive.
+   * @throws IllegalArgumentException if the initial capacity is negative or the load factor or
+   *         concurrencyLevel are nonpositive.
-      int concurrencyLevel, final boolean isIdentityMap,
-      HashEntryCreator<K, V> entryCreator) {
+      int concurrencyLevel, final boolean isIdentityMap, HashEntryCreator<K, V> entryCreator) {
-    }
-    else {
+    } else {
-        this.segments[i] = new IdentitySegment<K, V>(cap, loadFactor,
-            entryCreator);
+        this.segments[i] = new IdentitySegment<K, V>(cap, loadFactor, entryCreator);
-  static final class DefaultHashEntryCreator<K, V> implements
-      HashEntryCreator<K, V>, Serializable {
+  static final class DefaultHashEntryCreator<K, V> implements HashEntryCreator<K, V>, Serializable {
-    public final HashEntry<K, V> newEntry(final K key, final int hash,
-        final HashEntry<K, V> next, final V value) {
+    public final HashEntry<K, V> newEntry(final K key, final int hash, final HashEntry<K, V> next,
+        final V value) {
-    public final int keyHashCode(final Object key,
-        final boolean compareValues) {
+    public final int keyHashCode(final Object key, final boolean compareValues) {
-// End GemStone addition
+  // End GemStone addition
-   * Creates a new, empty map with the specified initial capacity and load
-   * factor and with the default concurrencyLevel (16).
+   * Creates a new, empty map with the specified initial capacity and load factor and with the
+   * default concurrencyLevel (16).
-   * @param initialCapacity
-   *          The implementation performs internal sizing to accommodate this
-   *          many elements.
-   * @param loadFactor
-   *          the load factor threshold, used to control resizing. Resizing may
-   *          be performed when the average number of elements per bin exceeds
-   *          this threshold.
-   * @throws IllegalArgumentException
-   *           if the initial capacity of elements is negative or the load
-   *           factor is nonpositive
+   * @param initialCapacity The implementation performs internal sizing to accommodate this many
+   *        elements.
+   * @param loadFactor the load factor threshold, used to control resizing. Resizing may be
+   *        performed when the average number of elements per bin exceeds this threshold.
+   * @throws IllegalArgumentException if the initial capacity of elements is negative or the load
+   *         factor is nonpositive
-   * Creates a new, empty map with the specified initial capacity, and with
-   * default load factor (0.75) and concurrencyLevel (16).
+   * Creates a new, empty map with the specified initial capacity, and with default load factor
+   * (0.75) and concurrencyLevel (16).
-   * @param initialCapacity
-   *          the initial capacity. The implementation performs internal sizing
-   *          to accommodate this many elements.
-   * @throws IllegalArgumentException
-   *           if the initial capacity of elements is negative.
+   * @param initialCapacity the initial capacity. The implementation performs internal sizing to
+   *        accommodate this many elements.
+   * @throws IllegalArgumentException if the initial capacity of elements is negative.
-   * Creates a new, empty map with a default initial capacity (16), load factor
-   * (0.75) and concurrencyLevel (16).
+   * Creates a new, empty map with a default initial capacity (16), load factor (0.75) and
+   * concurrencyLevel (16).
-    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR,
-        DEFAULT_CONCURRENCY_LEVEL, false);
+    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, false);
-   * Creates a new map with the same mappings as the given map. The map is
-   * created with a capacity of 1.5 times the number of mappings in the given
-   * map or 16 (whichever is greater), and a default load factor (0.75) and
-   * concurrencyLevel (16).
+   * Creates a new map with the same mappings as the given map. The map is created with a capacity
+   * of 1.5 times the number of mappings in the given map or 16 (whichever is greater), and a
+   * default load factor (0.75) and concurrencyLevel (16).
-   * @param m
-   *          the map
+   * @param m the map
-    this(Math.max((int)(m.size() / DEFAULT_LOAD_FACTOR) + 1,
-        DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR,
-        DEFAULT_CONCURRENCY_LEVEL, false);
+    this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, DEFAULT_INITIAL_CAPACITY),
+        DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, false);
-     * We keep track of per-segment modCounts to avoid ABA
-     * problems in which an element in one segment was added and
-     * in another removed during traversal, in which case the
-     * table was never actually empty at any point. Note the
-     * similar use of modCounts in the size() and containsValue()
-     * methods, which are the only other methods also susceptible
-     * to ABA problems.
+     * We keep track of per-segment modCounts to avoid ABA problems in which an element in one
+     * segment was added and in another removed during traversal, in which case the table was never
+     * actually empty at any point. Note the similar use of modCounts in the size() and
+     * containsValue() methods, which are the only other methods also susceptible to ABA problems.
-      }
-      else {
+      } else {
-   * Returns the number of key-value mappings in this map. If the map contains
-   * more than <tt>Integer.MAX_VALUE</tt> elements, returns
-   * <tt>Integer.MAX_VALUE</tt>.
+   * Returns the number of key-value mappings in this map. If the map contains more than
+   * <tt>Integer.MAX_VALUE</tt> elements, returns <tt>Integer.MAX_VALUE</tt>.
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value="UL_UNRELEASED_LOCK", justification="The lock() calls are followed by unlock() calls without finally-block. Leaving this as is because it's lifted from JDK code and we want to minimize changes.") 
+  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "UL_UNRELEASED_LOCK",
+      justification = "The lock() calls are followed by unlock() calls without finally-block. Leaving this as is because it's lifted from JDK code and we want to minimize changes.")
-    }
-    else {
-      return (int)sum;
+    } else {
+      return (int) sum;
-   * Returns the value to which the specified key is mapped, or {@code null} if
-   * this map contains no mapping for the key.
+   * Returns the value to which the specified key is mapped, or {@code null} if this map contains no
+   * mapping for the key.
-   * More formally, if this map contains a mapping from a key {@code k} to a
-   * value {@code v} such that {@code key.equals(k)}, then this method returns
-   * {@code v}; otherwise it returns {@code null}. (There can be at most one
-   * such mapping.)
+   * More formally, if this map contains a mapping from a key {@code k} to a value {@code v} such
+   * that {@code key.equals(k)}, then this method returns {@code v}; otherwise it returns
+   * {@code null}. (There can be at most one such mapping.)
-   * @throws NullPointerException
-   *           if the specified key is null
+   * @throws NullPointerException if the specified key is null
-   * @param key
-   *          possible key
-   * @return <tt>true</tt> if and only if the specified object is a key in this
-   *         table, as determined by the <tt>equals</tt> method; <tt>false</tt>
-   *         otherwise.
-   * @throws NullPointerException
-   *           if the specified key is null
+   * @param key possible key
+   * @return <tt>true</tt> if and only if the specified object is a key in this table, as determined
+   *         by the <tt>equals</tt> method; <tt>false</tt> otherwise.
+   * @throws NullPointerException if the specified key is null
-   * Returns <tt>true</tt> if this map maps one or more keys to the specified
-   * value. Note: This method requires a full internal traversal of the hash
-   * table, and so is much slower than method <tt>containsKey</tt>.
+   * Returns <tt>true</tt> if this map maps one or more keys to the specified value. Note: This
+   * method requires a full internal traversal of the hash table, and so is much slower than method
+   * <tt>containsKey</tt>.
-   * @param value
-   *          value whose presence in this map is to be tested
-   * @return <tt>true</tt> if this map maps one or more keys to the specified
-   *         value
-   * @throws NullPointerException
-   *           if the specified value is null
+   * @param value value whose presence in this map is to be tested
+   * @return <tt>true</tt> if this map maps one or more keys to the specified value
+   * @throws NullPointerException if the specified value is null
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value="UL_UNRELEASED_LOCK", justification="Leaving this as is because it's lifted from JDK code and we want to minimize changes.") 
+  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "UL_UNRELEASED_LOCK",
+      justification = "Leaving this as is because it's lifted from JDK code and we want to minimize changes.")
-   * Legacy method testing if some key maps into the specified value in this
-   * table. This method is identical in functionality to {@link #containsValue},
-   * and exists solely to ensure full compatibility with class
-   * {@link java.util.Hashtable}, which supported this method prior to
+   * Legacy method testing if some key maps into the specified value in this table. This method is
+   * identical in functionality to {@link #containsValue}, and exists solely to ensure full
+   * compatibility with class {@link java.util.Hashtable}, which supported this method prior to
-   * @param value
-   *          a value to search for
-   * @return <tt>true</tt> if and only if some key maps to the <tt>value</tt>
-   *         argument in this table as determined by the <tt>equals</tt> method;
-   *         <tt>false</tt> otherwise
-   * @throws NullPointerException
-   *           if the specified value is null
+   * @param value a value to search for
+   * @return <tt>true</tt> if and only if some key maps to the <tt>value</tt> argument in this table
+   *         as determined by the <tt>equals</tt> method; <tt>false</tt> otherwise
+   * @throws NullPointerException if the specified value is null
-   * Maps the specified key to the specified value in this table. Neither the
-   * key nor the value can be null.
+   * Maps the specified key to the specified value in this table. Neither the key nor the value can
+   * be null.
-   * The value can be retrieved by calling the <tt>get</tt> method with a key
-   * that is equal to the original key.
+   * The value can be retrieved by calling the <tt>get</tt> method with a key that is equal to the
+   * original key.
-   * @param key
-   *          key with which the specified value is to be associated
-   * @param value
-   *          value to be associated with the specified key
-   * @return the previous value associated with <tt>key</tt>, or <tt>null</tt>
-   *         if there was no mapping for <tt>key</tt>
-   * @throws NullPointerException
-   *           if the specified key or value is null
+   * @param key key with which the specified value is to be associated
+   * @param value value to be associated with the specified key
+   * @return the previous value associated with <tt>key</tt>, or <tt>null</tt> if there was no
+   *         mapping for <tt>key</tt>
+   * @throws NullPointerException if the specified key or value is null
-   * @return the previous value associated with the specified key, or
-   *         <tt>null</tt> if there was no mapping for the key
-   * @throws NullPointerException
-   *           if the specified key or value is null
+   * @return the previous value associated with the specified key, or <tt>null</tt> if there was no
+   *         mapping for the key
+   * @throws NullPointerException if the specified key or value is null
-// GemStone addition
+  // GemStone addition
-   * Create a given key, value mapping if the key does not exist in the map else
-   * do nothing. The difference between this method and
-   * {@link #putIfAbsent(Object, Object)} is that latter always acquires a write
-   * lock on the segment which this acquires a write lock only if entry was not
-   * found. In other words this method is more efficient for the case when
-   * number of entries is small and same entries are being updated repeatedly.
+   * Create a given key, value mapping if the key does not exist in the map else do nothing. The
+   * difference between this method and {@link #putIfAbsent(Object, Object)} is that latter always
+   * acquires a write lock on the segment which this acquires a write lock only if entry was not
+   * found. In other words this method is more efficient for the case when number of entries is
+   * small and same entries are being updated repeatedly.
-   * @return true if the key was successfully put in the map or false if there
-   *         was an existing mapping for the key in the map
+   * @return true if the key was successfully put in the map or false if there was an existing
+   *         mapping for the key in the map
-   * @throws NullPointerException
-   *           if the specified key is null
+   * @throws NullPointerException if the specified key is null
-   * {@link #create(Object, MapCallback, Object, Object, boolean)} rather than
-   * requiring a pre-built object as in {@link #putIfAbsent(Object, Object)}
-   * that may be ultimately thrown away.
+   * {@link #create(Object, MapCallback, Object, Object, boolean)} rather than requiring a pre-built
+   * object as in {@link #putIfAbsent(Object, Object)} that may be ultimately thrown away.
-   * @param <K>
-   *          the type of key of the map
-   * @param <V>
-   *          the type of value of the map
-   * @param <C>
-   *          the type of context parameter passed to the creation/removal
-   *          methods
-   * @param <P>
-   *          the type of extra parameter passed to the creation/removal methods
+   * @param <K> the type of key of the map
+   * @param <V> the type of value of the map
+   * @param <C> the type of context parameter passed to the creation/removal methods
+   * @param <P> the type of extra parameter passed to the creation/removal methods
-     * Create a new instance of the value object given the key and provided
-     * parameters for construction.
+     * Create a new instance of the value object given the key and provided parameters for
+     * construction.
-     * @param key
-     *          the key for which the value is being created
-     * @param context
-     *          any context in which this method has been invoked
-     * @param createParams
-     *          parameters, if any, required for construction of a new value
-     *          object
+     * @param key the key for which the value is being created
+     * @param context any context in which this method has been invoked
+     * @param createParams parameters, if any, required for construction of a new value object
-     * {@link #create(Object, MapCallback, Object, Object, boolean)} method in
-     * the segment when segment is locked for read, or by 
+     * {@link #create(Object, MapCallback, Object, Object, boolean)} method in the segment when
+     * segment is locked for read, or by
-     * @param value
-     *          the value read by create that will be returned
+     * @param value the value read by create that will be returned
-     * @param value
-     *          the value to be removed from the map
-     * @param context
-     *          any context in which this method has been invoked
-     * @param removeParams
-     *          parameters, if any, to be passed for cleanup of the object
+     * @param value the value to be removed from the map
+     * @param context any context in which this method has been invoked
+     * @param removeParams parameters, if any, to be passed for cleanup of the object
-  public static class MapCallbackAdapter<K, V, C, P> implements
-      MapCallback<K, V, C, P> {
+  public static class MapCallbackAdapter<K, V, C, P> implements MapCallback<K, V, C, P> {
-    public void oldValueRead(V value) {
-    }
+    public void oldValueRead(V value) {}
-   * Like {@link #putIfAbsent(Object, Object)} but creates the value only if
-   * none present rather than requiring a passed in pre-created object that may
-   * ultimately be thrown away. Also takes read lock on the segment, if
-   * required, to provide better guarantees w.r.t. remove/replace that checks
-   * against old value when the value may be changed structurally by reading
-   * (e.g. a list as value changed after a call to this method).
+   * Like {@link #putIfAbsent(Object, Object)} but creates the value only if none present rather
+   * than requiring a passed in pre-created object that may ultimately be thrown away. Also takes
+   * read lock on the segment, if required, to provide better guarantees w.r.t. remove/replace that
+   * checks against old value when the value may be changed structurally by reading (e.g. a list as
+   * value changed after a call to this method).
-   * @param key
-   *          key with which the specified value is to be associated
-   * @param valueCreator
-   *          factory object to create the value to be associated with the
-   *          specified key, if required
-   * @param context
-   *          the context in which this method has been invoked and passed to
-   *          <code>valueCreator</code> {@link MapCallback#newValue} method to
-   *          create the new instance
-   * @param createParams
-   *          parameters to be passed to the <code>valueCreator</code>
-   *          {@link MapCallback#newValue} method to create the new instance
-   * @param lockForRead
-   *          if passed as true, then the read from the map prior to creation is
-   *          done under the segment read lock; this provides better guarantees
-   *          with respect to other threads that may be manipulating the value
-   *          object in place after reading from the map
+   * @param key key with which the specified value is to be associated
+   * @param valueCreator factory object to create the value to be associated with the specified key,
+   *        if required
+   * @param context the context in which this method has been invoked and passed to
+   *        <code>valueCreator</code> {@link MapCallback#newValue} method to create the new instance
+   * @param createParams parameters to be passed to the <code>valueCreator</code>
+   *        {@link MapCallback#newValue} method to create the new instance
+   * @param lockForRead if passed as true, then the read from the map prior to creation is done
+   *        under the segment read lock; this provides better guarantees with respect to other
+   *        threads that may be manipulating the value object in place after reading from the map
-   * @return the previous value associated with the specified key, or the new
-   *         value obtained by invoking {@link MapCallback#newValue} if there
-   *         was no mapping for the key; this is paired with the segment read
-   *         lock
+   * @return the previous value associated with the specified key, or the new value obtained by
+   *         invoking {@link MapCallback#newValue} if there was no mapping for the key; this is
+   *         paired with the segment read lock
-   * @throws NullPointerException
-   *           if the specified key or value is null
+   * @throws NullPointerException if the specified key or value is null
-  public final <C, P> V create(final K key,
-      final MapCallback<K, V, C, P> valueCreator, final C context,
-      final P createParams, final boolean lockForRead) {
+  public final <C, P> V create(final K key, final MapCallback<K, V, C, P> valueCreator,
+      final C context, final P createParams, final boolean lockForRead) {
-    return segmentFor(hash).create(key, hash, valueCreator, context,
-        createParams, lockForRead);
+    return segmentFor(hash).create(key, hash, valueCreator, context, createParams, lockForRead);
-   * Returns the value to which the specified key is mapped, or {@code null} if
-   * this map contains no mapping for the key.
+   * Returns the value to which the specified key is mapped, or {@code null} if this map contains no
+   * mapping for the key.
-   * More formally, if this map contains a mapping from a key {@code k} to a
-   * value {@code v} such that {@code key.equals(k)}, then this method returns
-   * {@code v}; otherwise it returns {@code null}. (There can be at most one
-   * such mapping.)
+   * More formally, if this map contains a mapping from a key {@code k} to a value {@code v} such
+   * that {@code key.equals(k)}, then this method returns {@code v}; otherwise it returns
+   * {@code null}. (There can be at most one such mapping.)
-   * This variant locks the segment for reading and if the given
-   * {@link MapCallback} is non-null then its
-   * {@link MapCallback#oldValueRead(Object)} method is invoked in the lock.
+   * This variant locks the segment for reading and if the given {@link MapCallback} is non-null
+   * then its {@link MapCallback#oldValueRead(Object)} method is invoked in the lock.
-   * @throws NullPointerException
-   *           if the specified key is null
+   * @throws NullPointerException if the specified key is null
-  public final V get(final Object key,
-      final MapCallback<K, V, ?, ?> readCallback) {
+  public final V get(final Object key, final MapCallback<K, V, ?, ?> readCallback) {
-   * Removes the entry for a key only if the given condition (
-   * {@link MapCallback#doRemoveValue} evaluates to true. This is equivalent to:
+   * Removes the entry for a key only if the given condition ( {@link MapCallback#doRemoveValue}
+   * evaluates to true. This is equivalent to:
-   * if (map.containsKey(key)
-   *     &amp;&amp; condition.doRemoveInstance(map.get(key), removeParams)) {
+   * if (map.containsKey(key) &amp;&amp; condition.doRemoveInstance(map.get(key), removeParams)) {
-   * }
-   * else {
+   * } else {
-   * @param key
-   *          key with which the specified value is associated
-   * @param condition
-   *          {@link MapCallback#doRemoveValue} is invoked and checked inside
-   *          the segment lock if removal should be done
-   * @param context
-   *          the context in which this method has been invoked and passed to
-   *          <code>condition</code> {@link MapCallback#doRemoveValue} method to
-   *          create the new instance
-   * @param removeParams
-   *          parameters to be passed to the <code>onSuccess</code> parameter
+   * @param key key with which the specified value is associated
+   * @param condition {@link MapCallback#doRemoveValue} is invoked and checked inside the segment
+   *        lock if removal should be done
+   * @param context the context in which this method has been invoked and passed to
+   *        <code>condition</code> {@link MapCallback#doRemoveValue} method to create the new
+   *        instance
+   * @param removeParams parameters to be passed to the <code>onSuccess</code> parameter
-   * @return the previous value associated with <tt>key</tt>, or <tt>null</tt>
-   *         if there was no mapping for <tt>key</tt>
+   * @return the previous value associated with <tt>key</tt>, or <tt>null</tt> if there was no
+   *         mapping for <tt>key</tt>
-   * @throws UnsupportedOperationException
-   *           if the <tt>remove</tt> operation is not supported by this map
-   * @throws ClassCastException
-   *           if the key or value is of an inappropriate type for this map
-   *           (optional)
-   * @throws NullPointerException
-   *           if the specified key or value is null, and this map does not
-   *           permit null keys or values (optional)
+   * @throws UnsupportedOperationException if the <tt>remove</tt> operation is not supported by this
+   *         map
+   * @throws ClassCastException if the key or value is of an inappropriate type for this map
+   *         (optional)
+   * @throws NullPointerException if the specified key or value is null, and this map does not
+   *         permit null keys or values (optional)
-      final MapCallback<K, V, C, P> condition, final C context,
-      final P removeParams) {
+      final MapCallback<K, V, C, P> condition, final C context, final P removeParams) {
-    return segmentFor(hash).remove(key, hash, NO_OBJECT_TOKEN, condition,
-        context, removeParams);
+    return segmentFor(hash).remove(key, hash, NO_OBJECT_TOKEN, condition, context, removeParams);
-// End GemStone addition
+  // End GemStone addition
-   * Copies all of the mappings from the specified map to this one. These
-   * mappings replace any mappings that this map had for any of the keys
-   * currently in the specified map.
+   * Copies all of the mappings from the specified map to this one. These mappings replace any
+   * mappings that this map had for any of the keys currently in the specified map.
-   * @param m
-   *          mappings to be stored in this map
+   * @param m mappings to be stored in this map
-   * Removes the key (and its corresponding value) from this map. This method
-   * does nothing if the key is not in the map.
+   * Removes the key (and its corresponding value) from this map. This method does nothing if the
+   * key is not in the map.
-   * @param key
-   *          the key that needs to be removed
-   * @return the previous value associated with <tt>key</tt>, or <tt>null</tt>
-   *         if there was no mapping for <tt>key</tt>
-   * @throws NullPointerException
-   *           if the specified key is null
+   * @param key the key that needs to be removed
+   * @return the previous value associated with <tt>key</tt>, or <tt>null</tt> if there was no
+   *         mapping for <tt>key</tt>
+   * @throws NullPointerException if the specified key is null
-    return segmentFor(hash)
-        .remove(key, hash, NO_OBJECT_TOKEN, null, null, null);
+    return segmentFor(hash).remove(key, hash, NO_OBJECT_TOKEN, null, null, null);
-   * @throws NullPointerException
-   *           if the specified key is null
+   * @throws NullPointerException if the specified key is null
-   * @throws NullPointerException
-   *           if any of the arguments are null
+   * @throws NullPointerException if any of the arguments are null
-   * @return the previous value associated with the specified key, or
-   *         <tt>null</tt> if there was no mapping for the key
-   * @throws NullPointerException
-   *           if the specified key or value is null
+   * @return the previous value associated with the specified key, or <tt>null</tt> if there was no
+   *         mapping for the key
+   * @throws NullPointerException if the specified key or value is null
-    ArrayList<HashEntry<?,?>> entries = null;
+    ArrayList<HashEntry<?, ?>> entries = null;
-        final ArrayList<HashEntry<?,?>> clearedEntries = entries;
+        final ArrayList<HashEntry<?, ?>> clearedEntries = entries;
-            for (HashEntry<?,?> he: clearedEntries) {
+            for (HashEntry<?, ?> he : clearedEntries) {
-                  ((OffHeapRegionEntry)p).release();
+                  ((OffHeapRegionEntry) p).release();
-          String name = this.getClass().getSimpleName()+"@"+this.hashCode()+" Clear Thread";
+          String name = this.getClass().getSimpleName() + "@" + this.hashCode() + " Clear Thread";
-   * Returns a {@link Set} view of the keys contained in this map. The set is
-   * backed by the map, so changes to the map are reflected in the set, and
-   * vice-versa. The set supports element removal, which removes the
-   * corresponding mapping from this map, via the <tt>Iterator.remove</tt>,
-   * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt>, and
-   * <tt>clear</tt> operations. It does not support the <tt>add</tt> or
-   * <tt>addAll</tt> operations.
+   * Returns a {@link Set} view of the keys contained in this map. The set is backed by the map, so
+   * changes to the map are reflected in the set, and vice-versa. The set supports element removal,
+   * which removes the corresponding mapping from this map, via the <tt>Iterator.remove</tt>,
+   * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt>, and <tt>clear</tt> operations. It
+   * does not support the <tt>add</tt> or <tt>addAll</tt> operations.
-   * The view's <tt>iterator</tt> is a "weakly consistent" iterator that will
-   * never throw {@link java.util.ConcurrentModificationException}, and
-   * guarantees to traverse elements as they existed upon construction of the
-   * iterator, and may (but is not guaranteed to) reflect any modifications
-   * subsequent to construction.
+   * The view's <tt>iterator</tt> is a "weakly consistent" iterator that will never throw
+   * {@link java.util.ConcurrentModificationException}, and guarantees to traverse elements as they
+   * existed upon construction of the iterator, and may (but is not guaranteed to) reflect any
+   * modifications subsequent to construction.
-   * Returns a {@link Collection} view of the values contained in this map. The
-   * collection is backed by the map, so changes to the map are reflected in the
-   * collection, and vice-versa. The collection supports element removal, which
-   * removes the corresponding mapping from this map, via the
-   * <tt>Iterator.remove</tt>, <tt>Collection.remove</tt>, <tt>removeAll</tt>,
-   * <tt>retainAll</tt>, and <tt>clear</tt> operations. It does not support the
-   * <tt>add</tt> or <tt>addAll</tt> operations.
+   * Returns a {@link Collection} view of the values contained in this map. The collection is backed
+   * by the map, so changes to the map are reflected in the collection, and vice-versa. The
+   * collection supports element removal, which removes the corresponding mapping from this map, via
+   * the <tt>Iterator.remove</tt>, <tt>Collection.remove</tt>, <tt>removeAll</tt>,
+   * <tt>retainAll</tt>, and <tt>clear</tt> operations. It does not support the <tt>add</tt> or
+   * <tt>addAll</tt> operations.
-   * The view's <tt>iterator</tt> is a "weakly consistent" iterator that will
-   * never throw {@link java.util.ConcurrentModificationException}, and
-   * guarantees to traverse elements as they existed upon construction of the
-   * iterator, and may (but is not guaranteed to) reflect any modifications
-   * subsequent to construction.
+   * The view's <tt>iterator</tt> is a "weakly consistent" iterator that will never throw
+   * {@link java.util.ConcurrentModificationException}, and guarantees to traverse elements as they
+   * existed upon construction of the iterator, and may (but is not guaranteed to) reflect any
+   * modifications subsequent to construction.
-   * Returns a {@link Set} view of the mappings contained in this map. The set
-   * is backed by the map, so changes to the map are reflected in the set, and
-   * vice-versa. The set supports element removal, which removes the
-   * corresponding mapping from the map, via the <tt>Iterator.remove</tt>,
-   * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt>, and
-   * <tt>clear</tt> operations. It does not support the <tt>add</tt> or
-   * <tt>addAll</tt> operations.
+   * Returns a {@link Set} view of the mappings contained in this map. The set is backed by the map,
+   * so changes to the map are reflected in the set, and vice-versa. The set supports element
+   * removal, which removes the corresponding mapping from the map, via the
+   * <tt>Iterator.remove</tt>, <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt>, and
+   * <tt>clear</tt> operations. It does not support the <tt>add</tt> or <tt>addAll</tt> operations.
-   * The view's <tt>iterator</tt> is a "weakly consistent" iterator that will
-   * never throw {@link java.util.ConcurrentModificationException}, and
-   * guarantees to traverse elements as they existed upon construction of the
-   * iterator, and may (but is not guaranteed to) reflect any modifications
-   * subsequent to construction.
+   * The view's <tt>iterator</tt> is a "weakly consistent" iterator that will never throw
+   * {@link java.util.ConcurrentModificationException}, and guarantees to traverse elements as they
+   * existed upon construction of the iterator, and may (but is not guaranteed to) reflect any
+   * modifications subsequent to construction.
-// GemStone addition
+  // GemStone addition
-   * Returns a {@link Set} view of the mappings contained in this map. The set
-   * is backed by the map, so changes to the map are reflected in the set, and
-   * vice-versa. The set supports element removal, which removes the
-   * corresponding mapping from the map, via the <tt>Iterator.remove</tt>,
-   * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt>, and
-   * <tt>clear</tt> operations. It does not support the <tt>add</tt> or
-   * <tt>addAll</tt> operations.
+   * Returns a {@link Set} view of the mappings contained in this map. The set is backed by the map,
+   * so changes to the map are reflected in the set, and vice-versa. The set supports element
+   * removal, which removes the corresponding mapping from the map, via the
+   * <tt>Iterator.remove</tt>, <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt>, and
+   * <tt>clear</tt> operations. It does not support the <tt>add</tt> or <tt>addAll</tt> operations.
-   * The view's <tt>iterator</tt> is a "weakly consistent" iterator that will
-   * never throw {@link java.util.ConcurrentModificationException}, and
-   * guarantees to traverse elements as they existed upon construction of the
-   * iterator, and may (but is not guaranteed to) reflect any modifications
-   * subsequent to construction.
+   * The view's <tt>iterator</tt> is a "weakly consistent" iterator that will never throw
+   * {@link java.util.ConcurrentModificationException}, and guarantees to traverse elements as they
+   * existed upon construction of the iterator, and may (but is not guaranteed to) reflect any
+   * modifications subsequent to construction.
-   * This set provides entries that are reused during iteration so caller cannot
-   * store the returned <code>Map.Entry</code> objects.
+   * This set provides entries that are reused during iteration so caller cannot store the returned
+   * <code>Map.Entry</code> objects.
-// End GemStone addition
+  // End GemStone addition
-// GemStone changed HashEntry<K, V>[] currentTable to currentSegment
+    // GemStone changed HashEntry<K, V>[] currentTable to currentSegment
-// GemStone changes BEGIN
+      // GemStone changes BEGIN
-        final Segment<K, V> seg = CustomEntryConcurrentHashMap.this
-            .segments[this.currentSegmentIndex];
-        final ReentrantReadWriteLock.ReadLock listLock = seg.listUpdateLock
-            .readLock();
+        final Segment<K, V> seg =
+            CustomEntryConcurrentHashMap.this.segments[this.currentSegmentIndex];
+        final ReentrantReadWriteLock.ReadLock listLock = seg.listUpdateLock.readLock();
-      /* (original code)
-      if (this.nextEntry != null
-          && (this.nextEntry = this.nextEntry.getNextEntry()) != null) {
-        return;
-      }
-
-      while (this.nextTableIndex >= 0) {
-        if ((this.nextEntry = this.currentTable[this.nextTableIndex--])
-            != null) {
-          return;
-        }
-      }
-      */
-// GemStone changes END
+      /*
+       * (original code) if (this.nextEntry != null && (this.nextEntry =
+       * this.nextEntry.getNextEntry()) != null) { return; }
+       * 
+       * while (this.nextTableIndex >= 0) { if ((this.nextEntry =
+       * this.currentTable[this.nextTableIndex--]) != null) { return; } }
+       */
+      // GemStone changes END
-        final Segment<K, V> seg = CustomEntryConcurrentHashMap.this
-            .segments[--this.currentSegmentIndex];
+        final Segment<K, V> seg =
+            CustomEntryConcurrentHashMap.this.segments[--this.currentSegmentIndex];
-          final ReentrantReadWriteLock.ReadLock listLock = seg.listUpdateLock
-              .readLock();
+          final ReentrantReadWriteLock.ReadLock listLock = seg.listUpdateLock.readLock();
-// GemStone added the method below
+    // GemStone added the method below
-     * Copy the tail of list of current matched entry ({@link #nextEntry}) to a
-     * temporary list, so that the read lock can be released after the copy.
+     * Copy the tail of list of current matched entry ({@link #nextEntry}) to a temporary list, so
+     * that the read lock can be released after the copy.
-     * Read lock on {@link #currentSegmentIndex}'s listUpdateLock should already be
-     * acquired.
+     * Read lock on {@link #currentSegmentIndex}'s listUpdateLock should already be acquired.
-      assert segments[currentSegmentIndex] != null: "unexpected null currentSegment";
+      assert segments[currentSegmentIndex] != null : "unexpected null currentSegment";
-      for (HashEntry<K, V> p = this.nextEntry.getNextEntry(); p != null; p = p
-          .getNextEntry()) {
+      for (HashEntry<K, V> p = this.nextEntry.getNextEntry(); p != null; p = p.getNextEntry()) {
-  final class KeyIterator extends HashIterator implements Iterator<K>,
-      Enumeration<K> {
+  final class KeyIterator extends HashIterator implements Iterator<K>, Enumeration<K> {
-  final class ValueIterator extends HashIterator implements Iterator<V>,
-      Enumeration<V> {
+  final class ValueIterator extends HashIterator implements Iterator<V>, Enumeration<V> {
-   * An Entry maintaining a key and a value. The value may be changed using the
-   * <tt>setValue</tt> method. This class facilitates the process of building
-   * custom map implementations. For example, it may be convenient to return
-   * arrays of <tt>SimpleEntry</tt> instances in method
+   * An Entry maintaining a key and a value. The value may be changed using the <tt>setValue</tt>
+   * method. This class facilitates the process of building custom map implementations. For example,
+   * it may be convenient to return arrays of <tt>SimpleEntry</tt> instances in method
-     * Creates an entry representing a mapping from the specified key to the
-     * specified value.
+     * Creates an entry representing a mapping from the specified key to the specified value.
-     * @param key
-     *          the key represented by this entry
-     * @param value
-     *          the value represented by this entry
+     * @param key the key represented by this entry
+     * @param value the value represented by this entry
-     * @param entry
-     *          the entry to copy
+     * @param entry the entry to copy
-     * @param value
-     *          new value to be stored in this entry
+     * @param value new value to be stored in this entry
-     * Compares the specified object with this entry for equality. Returns
-     * {@code true} if the given object is also a map entry and the two entries
-     * represent the same mapping. More formally, two entries {@code e1} and
-     * {@code e2} represent the same mapping if
+     * Compares the specified object with this entry for equality. Returns {@code true} if the given
+     * object is also a map entry and the two entries represent the same mapping. More formally, two
+     * entries {@code e1} and {@code e2} represent the same mapping if
-     * (e1.getKey() == null ? e2.getKey() == null : e1.getKey().equals(
-     *     e2.getKey())) &amp;&amp; (e1.getValue() == null ?
-     *         e2.getValue() == null : e1.getValue().equals(e2.getValue()))
+     * (e1.getKey() == null ? e2.getKey() == null : e1.getKey().equals(e2.getKey()))
+     *     &amp;&amp; (e1.getValue() == null ? e2.getValue() == null : e1.getValue().equals(e2.getValue()))
-     * This ensures that the {@code equals} method works properly across
-     * different implementations of the {@code Map.Entry} interface.
+     * This ensures that the {@code equals} method works properly across different implementations
+     * of the {@code Map.Entry} interface.
-     * @param o
-     *          object to be compared for equality with this map entry
+     * @param o object to be compared for equality with this map entry
-      final Map.Entry<?, ?> e = (Map.Entry<?, ?>)o;
+      final Map.Entry<?, ?> e = (Map.Entry<?, ?>) o;
-     * Returns the hash code value for this map entry. The hash code of a map
-     * entry {@code e} is defined to be:
+     * Returns the hash code value for this map entry. The hash code of a map entry {@code e} is
+     * defined to be:
-     * This ensures that {@code e1.equals(e2)} implies that
-     * {@code e1.hashCode()==e2.hashCode()} for any two Entries {@code e1} and
-     * {@code e2}, as required by the general contract of
+     * This ensures that {@code e1.equals(e2)} implies that {@code e1.hashCode()==e2.hashCode()} for
+     * any two Entries {@code e1} and {@code e2}, as required by the general contract of
-      return System.identityHashCode(this.key)
-          ^ System.identityHashCode(this.value);
+      return System.identityHashCode(this.key) ^ System.identityHashCode(this.value);
-     * Returns a String representation of this map entry. This implementation
-     * returns the string representation of this entry's key followed by the
-     * equals character ("<tt>=</tt>") followed by the string representation of
-     * this entry's value.
+     * Returns a String representation of this map entry. This implementation returns the string
+     * representation of this entry's key followed by the equals character ("<tt>=</tt>") followed
+     * by the string representation of this entry's value.
-   * Custom Entry class used by EntryIterator.next(), that relays setValue
-   * changes to the underlying map.
+   * Custom Entry class used by EntryIterator.next(), that relays setValue changes to the underlying
+   * map.
-     * Creates an entry representing a mapping from the specified key to the
-     * specified value.
+     * Creates an entry representing a mapping from the specified key to the specified value.
-     * @param key
-     *          the key represented by this entry
-     * @param value
-     *          the value represented by this entry
+     * @param key the key represented by this entry
+     * @param value the value represented by this entry
-     * Set our entry's value and write through to the map. The value to return
-     * is somewhat arbitrary here. Since a WriteThroughEntry does not
-     * necessarily track asynchronous changes, the most recent "previous" value
-     * could be different from what we return (or could even have been removed
-     * in which case the put will re-establish). We do not and cannot guarantee
-     * more.
+     * Set our entry's value and write through to the map. The value to return is somewhat arbitrary
+     * here. Since a WriteThroughEntry does not necessarily track asynchronous changes, the most
+     * recent "previous" value could be different from what we return (or could even have been
+     * removed in which case the put will re-establish). We do not and cannot guarantee more.
-  final class EntryIterator extends HashIterator implements
-      Iterator<Map.Entry<K, V>> {
+  final class EntryIterator extends HashIterator implements Iterator<Map.Entry<K, V>> {
-// GemStone change
+    // GemStone change
-// End GemStone change
+    // End GemStone change
-// GemStone change
+    // GemStone change
-      }
-      else {
+      } else {
-// End GemStone change
+    // End GemStone change
-      final Map.Entry<?, ?> e = (Map.Entry<?, ?>)o;
+      final Map.Entry<?, ?> e = (Map.Entry<?, ?>) o;
-      final Map.Entry<?, ?> e = (Map.Entry<?, ?>)o;
+      final Map.Entry<?, ?> e = (Map.Entry<?, ?>) o;
-   * Save the state of the <tt>ConcurrentHashMap</tt> instance to a stream
-   * (i.e., serialize it).
+   * Save the state of the <tt>ConcurrentHashMap</tt> instance to a stream (i.e., serialize it).
-   * @param s
-   *          the stream
-   * @serialData the key (Object) and value (Object) for each key-value mapping,
-   *             followed by a null pair. The key-value mappings are emitted in
-   *             no particular order.
+   * @param s the stream
+   * @serialData the key (Object) and value (Object) for each key-value mapping, followed by a null
+   *             pair. The key-value mappings are emitted in no particular order.
-  private void writeObject(final java.io.ObjectOutputStream s)
-      throws IOException {
+  private void writeObject(final java.io.ObjectOutputStream s) throws IOException {
-   * Reconstitute the <tt>ConcurrentHashMap</tt> instance from a stream (i.e.,
-   * deserialize it).
+   * Reconstitute the <tt>ConcurrentHashMap</tt> instance from a stream (i.e., deserialize it).
-   * @param s
-   *          the stream
+   * @param s the stream
-      final K key = (K)s.readObject();
-      final V value = (V)s.readObject();
+      final K key = (K) s.readObject();
+      final V value = (V) s.readObject();

MOV65 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 MOV66 UPD65 UPD65 MOV66 MOV65 MOV65 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV65 UPD66 UPD66 UPD66 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV65 UPD66 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS42 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL42 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
GEODE-420: Clean up of SocketCreator code in tests.
SocketCreatorFactory currently singleton, to amend at later stage

-import com.gemstone.gemfire.*;
+import static com.gemstone.gemfire.distributed.ConfigurationProperties.*;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.Reader;
+import java.lang.reflect.Array;
+import java.net.InetAddress;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Properties;
+import java.util.Set;
+import java.util.SortedSet;
+import java.util.StringTokenizer;
+import java.util.TreeSet;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.apache.logging.log4j.Logger;
+
+import com.gemstone.gemfire.CancelCriterion;
+import com.gemstone.gemfire.CancelException;
+import com.gemstone.gemfire.ForcedDisconnectException;
+import com.gemstone.gemfire.GemFireConfigException;
+import com.gemstone.gemfire.GemFireIOException;
+import com.gemstone.gemfire.LogWriter;
+import com.gemstone.gemfire.StatisticDescriptor;
+import com.gemstone.gemfire.Statistics;
+import com.gemstone.gemfire.StatisticsType;
+import com.gemstone.gemfire.StatisticsTypeFactory;
+import com.gemstone.gemfire.SystemConnectException;
+import com.gemstone.gemfire.SystemFailure;
-import com.gemstone.gemfire.internal.*;
+import com.gemstone.gemfire.internal.Assert;
+import com.gemstone.gemfire.internal.DSFIDFactory;
+import com.gemstone.gemfire.internal.DummyStatisticsImpl;
+import com.gemstone.gemfire.internal.GemFireStatSampler;
+import com.gemstone.gemfire.internal.InternalDataSerializer;
+import com.gemstone.gemfire.internal.InternalInstantiator;
+import com.gemstone.gemfire.internal.LinuxProcFsStatistics;
+import com.gemstone.gemfire.internal.LocalStatisticsImpl;
+import com.gemstone.gemfire.internal.OsStatisticsFactory;
+import com.gemstone.gemfire.internal.StatisticsImpl;
+import com.gemstone.gemfire.internal.StatisticsManager;
+import com.gemstone.gemfire.internal.StatisticsTypeFactoryImpl;
+import com.gemstone.gemfire.internal.SystemTimer;
+import com.gemstone.gemfire.internal.net.SocketCreatorFactory;
-import org.apache.logging.log4j.Logger;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.Reader;
-import java.lang.reflect.Array;
-import java.net.InetAddress;
-import java.util.*;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.CopyOnWriteArrayList;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-
-import static com.gemstone.gemfire.distributed.ConfigurationProperties.LOCATORS;
-import static com.gemstone.gemfire.distributed.ConfigurationProperties.MCAST_PORT;
- *
- *
-public class InternalDistributedSystem
-  extends DistributedSystem
-  implements OsStatisticsFactory, StatisticsManager
-{
+public class InternalDistributedSystem extends DistributedSystem implements OsStatisticsFactory, StatisticsManager {
+
-  
+
-  
-  /** The distribution manager that is used to communicate with the
-   * distributed system. */
+
+  /**
+   * The distribution manager that is used to communicate with the
+   * distributed system.
+   */
+
-  
-  /** Numeric id that identifies this node in a DistributedSystem */
+
+  /**
+   * Numeric id that identifies this node in a DistributedSystem
+   */
-  /** The log writer used to log information messages */
+  /**
+   * The log writer used to log information messages
+   */
-  /** The log writer used to log security related messages */
+  /**
+   * The log writer used to log security related messages
+   */
- 
-  /** Distributed System clock */
+
+  /**
+   * Distributed System clock
+   */
-//  /** The log writer was provided by an external entity */
-//  private boolean externalLogWriterProvided = false;
-//
+  //  /** The log writer was provided by an external entity */
+  //  private boolean externalLogWriterProvided = false;
+  //
-  
-  /** Time this system was created */
+
+  /**
+   * Time this system was created
+   */
-  
-  /** Is this <code>DistributedSystem</code> connected to a
-   * distributed system? 
-   *
+
+  /**
+   * Is this <code>DistributedSystem</code> connected to a
+   * distributed system?
+   * <p>
-  /** The sampler for this DistributedSystem.
+  /**
+   * The sampler for this DistributedSystem.
-  /** A set of listeners that are invoked when this connection to the
-   * distributed system is disconnected */
+  /**
+   * A set of listeners that are invoked when this connection to the
+   * distributed system is disconnected
+   */
-  /** Set of listeners that are invoked whenever a connection is created to
-   * the distributed system */
-  private static Set connectListeners = new LinkedHashSet(); // needs to be ordered
-  
-  /** auto-reconnect listeners */
-  private static List<ReconnectListener> reconnectListeners = new ArrayList<ReconnectListener>();
-  
-   * whether this DS is one created to reconnect to the distributed 
+   * Set of listeners that are invoked whenever a connection is created to
+   * the distributed system
+   */
+  private static Set connectListeners = new LinkedHashSet(); // needs to be ordered
+
+  /**
+   * auto-reconnect listeners
+   */
+  private static List<ReconnectListener> reconnectListeners = new ArrayList<ReconnectListener>();
+
+  /**
+   * whether this DS is one created to reconnect to the distributed
-  
+
+
-  /** The config object used to create this distributed system */
+  /**
+   * The config object used to create this distributed system
+   */
-  /** The config object to which most configuration work is delegated */
+  /**
+   * The config object to which most configuration work is delegated
+   */
-  /** if this distributed system starts a locator, it is stored here */
+  /**
+   * if this distributed system starts a locator, it is stored here
+   */
-  
+
-  
+
-  
+
-    InternalDistributedSystem newSystem = new InternalDistributedSystem(config);
-    newSystem.initialize();
-    reconnectAttemptCounter = 0; // reset reconnect count since we just got a new connection
-    notifyConnectListeners(newSystem);
-    success = true;
-    return newSystem;
+      InternalDistributedSystem newSystem = new InternalDistributedSystem(config);
+      newSystem.initialize();
+      reconnectAttemptCounter = 0; // reset reconnect count since we just got a new connection
+      notifyConnectListeners(newSystem);
+      success = true;
+      return newSystem;
-  
-  
+
+
-   *
-   *
+   * <p>
-        InternalDistributedSystem existingSystem =
-          (InternalDistributedSystem) existingSystems.get(0);
-        if (existingSystem.isConnected())
+        InternalDistributedSystem existingSystem = (InternalDistributedSystem) existingSystems.get(0);
+        if (existingSystem.isConnected()) {
+        }
-  
+
-  
+
-  
+
-  
+
-  
-  /** reset the reconnectAttempt counter for a new go at reconnecting */
+
+  /**
+   * reset the reconnectAttempt counter for a new go at reconnecting
+   */
-   *
-   * @param nonDefault
-   *        The non-default configuration properties specified by the
-   *        caller
+   * @param nonDefault The non-default configuration properties specified by the
+   * caller
-      this.isReconnectingDS = ((Boolean)o).booleanValue();
+      this.isReconnectingDS = ((Boolean) o).booleanValue();
-    
+
-      this.quorumChecker = (QuorumChecker)o;
+      this.quorumChecker = (QuorumChecker) o;
-    
-    ((DistributionConfigImpl)this.originalConfig).checkForDisallowedDefaults(); // throws IllegalStateEx
+
+    ((DistributionConfigImpl) this.originalConfig).checkForDisallowedDefaults(); // throws IllegalStateEx
-    
+
-//    if (DistributionConfigImpl.multicastTest) {
-//      this.logger.warning("Use of multicast has been forced");
-//    }
-//    if (DistributionConfigImpl.forceDisableTcp) {
-//      this.logger.warning("Use of UDP has been forced");
-//    }
-//    if (com.gemstone.gemfire.distributed.internal.membership.jgroup.JGroupMembershipManager.multicastTest) {
-//      this.logger.warning("Use of multicast for all distributed cache operations has been forced");
-//    }
+    //    if (DistributionConfigImpl.multicastTest) {
+    //      this.logger.warning("Use of multicast has been forced");
+    //    }
+    //    if (DistributionConfigImpl.forceDisableTcp) {
+    //      this.logger.warning("Use of UDP has been forced");
+    //    }
+    //    if (com.gemstone.gemfire.distributed.internal.membership.jgroup.JGroupMembershipManager.multicastTest) {
+    //      this.logger.warning("Use of multicast for all distributed cache operations has been forced");
+    //    }
-  
+
-   * 
-   * @param listener
-   *          listener to be added
+   * @param listener listener to be added
-  
+
-   * 
-   * @param listener
-   *          listener to be removed
+   * @param listener listener to be removed
-   * 
-   * @param event
-   *          Resource event
-   * @param resource
-   *          resource on which event is generated
+   * @param event Resource event
+   * @param resource resource on which event is generated
-  /** Returns true if system is a loner (for testing) */
+  /**
+   * Returns true if system is a loner (for testing)
+   */
-  
+
-  
+
-        throw new GemFireConfigException("The "
-            + LOCATORS
-                                          + " attribute can not be empty when the "
-            + MCAST_PORT
-                                          + " attribute is non-zero.");
+        throw new GemFireConfigException("The " + LOCATORS + " attribute can not be empty when the " + MCAST_PORT + " attribute is non-zero.");
-    SocketCreator.getDefaultInstance(this.config);
+      SocketCreatorFactory.setDistributionConfig(config);
-    // LOG: create LogWriterAppender(s) if log-file or security-log-file is specified
-    final boolean hasLogFile = this.config.getLogFile() != null && !this.config.getLogFile().equals(new File(""));
-    final boolean hasSecurityLogFile = this.config.getSecurityLogFile() != null && !this.config.getSecurityLogFile().equals(new File(""));
-    LogService.configureLoggers(hasLogFile, hasSecurityLogFile);
-    if (hasLogFile || hasSecurityLogFile) {
-      
-      // main log file
-      if (hasLogFile) {
-        // if log-file then create logWriterAppender
-        this.logWriterAppender = LogWriterAppenders.getOrCreateAppender(LogWriterAppenders.Identifier.MAIN, this.isLoner, this.config, true);
-      }
-      
-      // security log file
-      if (hasSecurityLogFile) {
-        // if security-log-file then create securityLogWriterAppender
-        this.securityLogWriterAppender = LogWriterAppenders.getOrCreateAppender(LogWriterAppenders.Identifier.SECURITY, this.isLoner, this.config, false);
-      } else {
-        // let security route to regular log-file or stdout
-      }
-    }
-    
-    // LOG: create LogWriterLogger(s) for backwards compatibility of getLogWriter and getSecurityLogWriter
-    if (this.logWriter == null) {
-      this.logWriter = LogWriterFactory.createLogWriterLogger(this.isLoner, false, this.config, true);
-      this.logWriter.fine("LogWriter is created.");
-    }
-    
-//    logWriter.info("Created log writer for IDS@"+System.identityHashCode(this));
-    
-    if (this.securityLogWriter == null) {
-      // LOG: whole new LogWriterLogger instance for security
-      this.securityLogWriter = LogWriterFactory.createLogWriterLogger(this.isLoner, true, this.config, false);
-      this.securityLogWriter.fine("SecurityLogWriter is created.");
-    }
-    
-    Services.setLogWriter(this.logWriter);
-    Services.setSecurityLogWriter(this.securityLogWriter);
+      // LOG: create LogWriterAppender(s) if log-file or security-log-file is specified
+      final boolean hasLogFile = this.config.getLogFile() != null && !this.config.getLogFile().equals(new File(""));
+      final boolean hasSecurityLogFile = this.config.getSecurityLogFile() != null && !this.config.getSecurityLogFile().equals(new File(""));
+      LogService.configureLoggers(hasLogFile, hasSecurityLogFile);
+      if (hasLogFile || hasSecurityLogFile) {
-    this.clock = new DSClock(this.isLoner);
-    
-    if (this.attemptingToReconnect && logger.isDebugEnabled()) {
-      logger.debug("This thread is initializing a new DistributedSystem in order to reconnect to other members");
-    }
-    // Note we need loners to load the license in case they are a
-    // bridge server and will need to enforce the member limit
-    if (Boolean.getBoolean(InternalLocator.FORCE_LOCATOR_DM_TYPE)) {
-      this.locatorDMTypeForced = true;
-    }
+        // main log file
+        if (hasLogFile) {
+          // if log-file then create logWriterAppender
+          this.logWriterAppender = LogWriterAppenders.getOrCreateAppender(LogWriterAppenders.Identifier.MAIN, this.isLoner, this.config, true);
+        }
-    // Initialize the Diffie-Hellman and public/private keys
-    try {
-      HandShake.initCertsMap(this.config.getSecurityProps());
-      HandShake.initPrivateKey(this.config.getSecurityProps());
-      HandShake.initDHKeys(this.config);
-    }
-    catch (Exception ex) {
-      throw new GemFireSecurityException(
-        LocalizedStrings.InternalDistributedSystem_PROBLEM_IN_INITIALIZING_KEYS_FOR_CLIENT_AUTHENTICATION.toLocalizedString(), ex);
-    }
-
-    final long offHeapMemorySize = OffHeapStorage.parseOffHeapMemorySize(getConfig().getOffHeapMemorySize());
-
-    this.offHeapStore = OffHeapStorage.createOffHeapStorage(this, offHeapMemorySize, this);
-    
-    // Note: this can only happen on a linux system
-    if (getConfig().getLockMemory()) {
-      // This calculation is not exact, but seems fairly close.  So far we have
-      // not loaded much into the heap and the current RSS usage is already 
-      // included the available memory calculation.
-      long avail = LinuxProcFsStatistics.getAvailableMemory(logger);
-      long size = offHeapMemorySize + Runtime.getRuntime().totalMemory();
-      if (avail < size) {
-        if (GemFireCacheImpl.ALLOW_MEMORY_LOCK_WHEN_OVERCOMMITTED) {
-          logger.warn(LocalizedMessage.create(LocalizedStrings.InternalDistributedSystem_MEMORY_OVERCOMMIT_WARN, size - avail));
+        // security log file
+        if (hasSecurityLogFile) {
+          // if security-log-file then create securityLogWriterAppender
+          this.securityLogWriterAppender = LogWriterAppenders.getOrCreateAppender(LogWriterAppenders.Identifier.SECURITY, this.isLoner, this.config, false);
-          throw new IllegalStateException(LocalizedStrings.InternalDistributedSystem_MEMORY_OVERCOMMIT.toLocalizedString(avail, size));
+          // let security route to regular log-file or stdout
-      
-      logger.info("Locking memory. This may take a while...");
-      GemFireCacheImpl.lockMemory();
-      logger.info("Finished locking memory.");
-    }
-    try {
-      startInitLocator();
-    } catch (InterruptedException e) {
-      throw new SystemConnectException("Startup has been interrupted", e);
-    }
+      // LOG: create LogWriterLogger(s) for backwards compatibility of getLogWriter and getSecurityLogWriter
+      if (this.logWriter == null) {
+        this.logWriter = LogWriterFactory.createLogWriterLogger(this.isLoner, false, this.config, true);
+        this.logWriter.fine("LogWriter is created.");
+      }
-    synchronized (this.isConnectedMutex) {
-      this.isConnected = true;
-    }
-    
-    if (!this.isLoner) {
+      //    logWriter.info("Created log writer for IDS@"+System.identityHashCode(this));
+
+      if (this.securityLogWriter == null) {
+        // LOG: whole new LogWriterLogger instance for security
+        this.securityLogWriter = LogWriterFactory.createLogWriterLogger(this.isLoner, true, this.config, false);
+        this.securityLogWriter.fine("SecurityLogWriter is created.");
+      }
+
+      Services.setLogWriter(this.logWriter);
+      Services.setSecurityLogWriter(this.securityLogWriter);
+
+      this.clock = new DSClock(this.isLoner);
+
+      if (this.attemptingToReconnect && logger.isDebugEnabled()) {
+        logger.debug("This thread is initializing a new DistributedSystem in order to reconnect to other members");
+      }
+      // Note we need loners to load the license in case they are a
+      // bridge server and will need to enforce the member limit
+      if (Boolean.getBoolean(InternalLocator.FORCE_LOCATOR_DM_TYPE)) {
+        this.locatorDMTypeForced = true;
+      }
+
+      // Initialize the Diffie-Hellman and public/private keys
-        if (this.quorumChecker != null) {
-          this.quorumChecker.suspend();
-        }
-        this.dm = DistributionManager.create(this);
-        // fix bug #46324
-        if (InternalLocator.hasLocator()) {
-          InternalLocator locator = InternalLocator.getLocator();
-          getDistributionManager().addHostedLocators(getDistributedMember(), InternalLocator.getLocatorStrings(), locator.isSharedConfigurationEnabled());
-        }
+        HandShake.initCertsMap(this.config.getSecurityProps());
+        HandShake.initPrivateKey(this.config.getSecurityProps());
+        HandShake.initDHKeys(this.config);
+      } catch (Exception ex) {
+        throw new GemFireSecurityException(LocalizedStrings.InternalDistributedSystem_PROBLEM_IN_INITIALIZING_KEYS_FOR_CLIENT_AUTHENTICATION.toLocalizedString(), ex);
-      finally {
-        if (this.dm == null && this.quorumChecker != null) {
-          this.quorumChecker.resume();
+
+      final long offHeapMemorySize = OffHeapStorage.parseOffHeapMemorySize(getConfig().getOffHeapMemorySize());
+
+      this.offHeapStore = OffHeapStorage.createOffHeapStorage(this, offHeapMemorySize, this);
+
+      // Note: this can only happen on a linux system
+      if (getConfig().getLockMemory()) {
+        // This calculation is not exact, but seems fairly close.  So far we have
+        // not loaded much into the heap and the current RSS usage is already
+        // included the available memory calculation.
+        long avail = LinuxProcFsStatistics.getAvailableMemory(logger);
+        long size = offHeapMemorySize + Runtime.getRuntime().totalMemory();
+        if (avail < size) {
+          if (GemFireCacheImpl.ALLOW_MEMORY_LOCK_WHEN_OVERCOMMITTED) {
+            logger.warn(LocalizedMessage.create(LocalizedStrings.InternalDistributedSystem_MEMORY_OVERCOMMIT_WARN, size - avail));
+          } else {
+            throw new IllegalStateException(LocalizedStrings.InternalDistributedSystem_MEMORY_OVERCOMMIT.toLocalizedString(avail, size));
+          }
-        setDisconnected();
+
+        logger.info("Locking memory. This may take a while...");
+        GemFireCacheImpl.lockMemory();
+        logger.info("Finished locking memory.");
-    }
-    else {
-      this.dm = new LonerDistributionManager(this, this.logWriter);
-    }
-    
-    Assert.assertTrue(this.dm != null);
-    Assert.assertTrue(this.dm.getSystem() == this);
-    try {
-      this.id = this.dm.getChannelId();
-    } catch (DistributedSystemDisconnectedException e) {
-      // bug #48144 - The dm's channel threw an NPE.  It now throws this exception
-      // but during startup we should instead throw a SystemConnectException
-      throw new SystemConnectException(
-          LocalizedStrings.InternalDistributedSystem_DISTRIBUTED_SYSTEM_HAS_DISCONNECTED
-            .toLocalizedString(), e);
-    }
-
-    synchronized (this.isConnectedMutex) {
-      this.isConnected = true;
-    }
-    if (attemptingToReconnect  &&  (this.startedLocator == null)) {
-    }
-    try {
-      endInitLocator();
-    }
-    catch (IOException e) {
-      throw new GemFireIOException("Problem finishing a locator service start", e);
-    }
+
+      synchronized (this.isConnectedMutex) {
+        this.isConnected = true;
+      }
+
+      if (!this.isLoner) {
+        try {
+          if (this.quorumChecker != null) {
+            this.quorumChecker.suspend();
+          }
+          this.dm = DistributionManager.create(this);
+          // fix bug #46324
+          if (InternalLocator.hasLocator()) {
+            InternalLocator locator = InternalLocator.getLocator();
+            getDistributionManager().addHostedLocators(getDistributedMember(), InternalLocator.getLocatorStrings(), locator.isSharedConfigurationEnabled());
+          }
+        } finally {
+          if (this.dm == null && this.quorumChecker != null) {
+            this.quorumChecker.resume();
+          }
+          setDisconnected();
+        }
+      } else {
+        this.dm = new LonerDistributionManager(this, this.logWriter);
+      }
+
+      Assert.assertTrue(this.dm != null);
+      Assert.assertTrue(this.dm.getSystem() == this);
+
+      try {
+        this.id = this.dm.getChannelId();
+      } catch (DistributedSystemDisconnectedException e) {
+        // bug #48144 - The dm's channel threw an NPE.  It now throws this exception
+        // but during startup we should instead throw a SystemConnectException
+        throw new SystemConnectException(LocalizedStrings.InternalDistributedSystem_DISTRIBUTED_SYSTEM_HAS_DISCONNECTED.toLocalizedString(), e);
+      }
+
+      synchronized (this.isConnectedMutex) {
+        this.isConnected = true;
+      }
+      if (attemptingToReconnect && (this.startedLocator == null)) {
+        try {
+          startInitLocator();
+        } catch (InterruptedException e) {
+          throw new SystemConnectException("Startup has been interrupted", e);
+        }
+      }
+      try {
+        endInitLocator();
+      } catch (IOException e) {
+        throw new GemFireIOException("Problem finishing a locator service start", e);
+      }
-      this.sampler = new GemFireStatSampler(this);
-      this.sampler.start();
-    }
+        this.sampler = new GemFireStatSampler(this);
+        this.sampler.start();
+      }
-    if (this.logWriterAppender != null) {
-      LogWriterAppenders.startupComplete(LogWriterAppenders.Identifier.MAIN);
-    }
-    if (this.securityLogWriterAppender != null) {
-      LogWriterAppenders.startupComplete(LogWriterAppenders.Identifier.SECURITY);
-    }
-    
-    //this.logger.info("ds created", new RuntimeException("DEBUG: STACK"));
+      if (this.logWriterAppender != null) {
+        LogWriterAppenders.startupComplete(LogWriterAppenders.Identifier.MAIN);
+      }
+      if (this.securityLogWriterAppender != null) {
+        LogWriterAppenders.startupComplete(LogWriterAppenders.Identifier.SECURITY);
+      }
-    //Log any instantiators that were registered before the log writer
-    //was created
-    InternalInstantiator.logInstantiators();
-    }
-    catch (RuntimeException ex) {
+      //this.logger.info("ds created", new RuntimeException("DEBUG: STACK"));
+
+      //Log any instantiators that were registered before the log writer
+      //was created
+      InternalInstantiator.logInstantiators();
+    } catch (RuntimeException ex) {
-    
+
-          if (!quorumChecker.checkForQuorum(3*this.config.getMemberTimeout())) {
+          if (!quorumChecker.checkForQuorum(3 * this.config.getMemberTimeout())) {
-        this.startedLocator = InternalLocator.createLocator(
-            locId.getPort(), 
-            null,
-            null,
-            this.logWriter, // LOG: this is after IDS has created LogWriterLoggers and Appenders 
-            this.securityLogWriter, // LOG: this is after IDS has created LogWriterLoggers and Appenders
-            locId.getHost(),
-            locId.getHostnameForClients(),
-            this.originalConfig.toProperties(), false);
-        if(locId.isPeerLocator()) {
+        this.startedLocator = InternalLocator.createLocator(locId.getPort(), null, null, this.logWriter, // LOG: this is after IDS has created LogWriterLoggers and Appenders
+          this.securityLogWriter, // LOG: this is after IDS has created LogWriterLoggers and Appenders
+          locId.getHost(), locId.getHostnameForClients(), this.originalConfig.toProperties(), false);
+        if (locId.isPeerLocator()) {
-        throw new GemFireIOException( LocalizedStrings.
-          InternalDistributedSystem_PROBLEM_STARTING_A_LOCATOR_SERVICE
-            .toLocalizedString(), e);
+        throw new GemFireIOException(LocalizedStrings.
+          InternalDistributedSystem_PROBLEM_STARTING_A_LOCATOR_SERVICE.toLocalizedString(), e);
-  
+
-//      DistributionLocatorId locId = new DistributionLocatorId(locatorString);
+      //      DistributionLocatorId locId = new DistributionLocatorId(locatorString);
-      
+
-  /** record a locator as a dependent of this distributed system */
+  /**
+   * record a locator as a dependent of this distributed system
+   */
-  
-  /** Used by DistributionManager to fix bug 33362
+
+  /**
+   * Used by DistributionManager to fix bug 33362
-   *
-   * @throws DistributedSystemDisconnectedException
-   *         This connection has been {@link #disconnect(boolean, String, boolean) disconnected}
+   * @throws DistributedSystemDisconnectedException This connection has been {@link #disconnect(boolean, String, boolean) disconnected}
-      throw new DistributedSystemDisconnectedException(LocalizedStrings.InternalDistributedSystem_THIS_CONNECTION_TO_A_DISTRIBUTED_SYSTEM_HAS_BEEN_DISCONNECTED.toLocalizedString(),
-          dm.getRootCause());
+      throw new DistributedSystemDisconnectedException(LocalizedStrings.InternalDistributedSystem_THIS_CONNECTION_TO_A_DISTRIBUTED_SYSTEM_HAS_BEEN_DISCONNECTED.toLocalizedString(), dm
+        .getRootCause());
-  
+
+
-    
+
-  
+
-  
+
-  
+
-    }
+  }
-  
+
+
-  
-  /** Has this system started the disconnect process? */
+
+  /**
+   * Has this system started the disconnect process?
+   */
-  
+
-  
+
-  
+
-  static private final long MAX_DISCONNECT_WAIT =
-    Long.getLong("DistributionManager.DISCONNECT_WAIT", 
-        10 * 1000).longValue();
+  static private final long MAX_DISCONNECT_WAIT = Long.getLong("DistributionManager.DISCONNECT_WAIT", 10 * 1000).longValue();
-   *
-  private void runDisconnect(final DisconnectListener dc,
-      ThreadGroup tg) {
+  private void runDisconnect(final DisconnectListener dc, ThreadGroup tg) {
-        }
-        catch (CancelException e) {
+        } catch (CancelException e) {
-    }
-    catch (InterruptedException e) {
+    } catch (InterruptedException e) {
-      }
-      catch (InterruptedException e) {
+      } catch (InterruptedException e) {
-      
+
-    
-  }
-  
-  public boolean isDisconnectListenerThread() {
-    Boolean disconnectListenerThreadBoolean = 
-      (Boolean) this.disconnectListenerThread.get();
-    return disconnectListenerThreadBoolean != null &&
-           disconnectListenerThreadBoolean.booleanValue();
-  
+
+  public boolean isDisconnectListenerThread() {
+    Boolean disconnectListenerThreadBoolean = (Boolean) this.disconnectListenerThread.get();
+
+    return disconnectListenerThreadBoolean != null && disconnectListenerThreadBoolean.booleanValue();
+  }
+
-  private void runDisconnectForReconnect(final DisconnectListener dc,
-      ThreadGroup tg){
+  private void runDisconnectForReconnect(final DisconnectListener dc, ThreadGroup tg) {
-  private final ThreadGroup disconnectListenerThreadGroup = 
-    LoggingThreadGroup.createThreadGroup("Disconnect Listeners");
-  
+  private final ThreadGroup disconnectListenerThreadGroup = LoggingThreadGroup.createThreadGroup("Disconnect Listeners");
+
-   * 
-   * 
+   *
-    for (;;) {
+    for (; ; ) {
-        listener = (DisconnectListener)itr.next();
+        listener = (DisconnectListener) itr.next();
-     
-      if (doReconnect){
+
+      if (doReconnect) {
-  
+
-   * 
-      ShutdownListener s = (ShutdownListener)it.next();
+      ShutdownListener s = (ShutdownListener) it.next();
-      }
-      catch (VirtualMachineError err) {
+      } catch (VirtualMachineError err) {
-      }
-      catch (Throwable t) {
+      } catch (Throwable t) {
-    for (;;) {
+    for (; ; ) {
-        if (!itr.hasNext())
+        if (!itr.hasNext()) {
-        dcListener = (DisconnectListener)itr.next();
+        }
+        dcListener = (DisconnectListener) itr.next();
-        if (dcListener instanceof ShutdownListener)
-          sdListener = (ShutdownListener)dcListener;
+        if (dcListener instanceof ShutdownListener) {
+          sdListener = (ShutdownListener) dcListener;
+        }
-        }
-        catch (VirtualMachineError err) {
+        } catch (VirtualMachineError err) {
-        }
-        catch (Throwable t) {
+        } catch (Throwable t) {
-  
+
-  
+
-   * 
-    if (emergencyClassesLoaded) return;
+    if (emergencyClassesLoaded) {
+      return;
+    }
-  
+
-   * 
-    
+
-  
+
-        }
-        catch (InterruptedException e) {
+        } catch (InterruptedException e) {
-          getLogWriter().convertToLogWriterI18n().warning(
-            LocalizedStrings.InternalDistributedSystem_DISCONNECT_WAIT_INTERRUPTED, e);
-        }
-        finally {
+          getLogWriter().convertToLogWriterI18n().warning(LocalizedStrings.InternalDistributedSystem_DISCONNECT_WAIT_INTERRUPTED, e);
+        } finally {
-   * 
-   * @param preparingForReconnect
-   *          true if called by a reconnect operation
-   * @param reason
-   *          the reason the disconnect is being performed
-   * @param keepAlive
-   *          true if user requested durable subscriptions are to be retained at
-   *          server.
+   * @param preparingForReconnect true if called by a reconnect operation
+   * @param reason the reason the disconnect is being performed
+   * @param keepAlive true if user requested durable subscriptions are to be retained at
+   * server.
-    boolean isShutdownHook = (shutdownHook != null)
-                             && (Thread.currentThread() == shutdownHook);
+    boolean isShutdownHook = (shutdownHook != null) && (Thread.currentThread() == shutdownHook);
-//      logger.info("disconnecting IDS@"+System.identityHashCode(this));
-      synchronized(reconnectListeners) {
+      //      logger.info("disconnecting IDS@"+System.identityHashCode(this));
+      synchronized (reconnectListeners) {
-    
+
-            } 
-            catch (VirtualMachineError e) {
+            } catch (VirtualMachineError e) {
-            }
-            catch (Throwable e) {
+            } catch (Throwable e) {
-            }
-            finally {
+            } finally {
-          } 
+          }
-    
+
-        
+
-        
-      }
-      finally { // be ABSOLUTELY CERTAIN that dm closed
+
+      } finally { // be ABSOLUTELY CERTAIN that dm closed
-      if(functionServiceStats != null){
+      if (functionServiceStats != null) {
-    }
-    finally {
+    } finally {
-      try {
-        removeSystem(this);
-        // Close the config object
-        this.config.close();
-      }
-      finally {
-        // Finally, mark ourselves as disconnected
-        setDisconnected();
-        SystemFailure.stopThreads();
-      }
+        try {
+          removeSystem(this);
+          // Close the config object
+          this.config.close();
+        } finally {
+          // Finally, mark ourselves as disconnected
+          setDisconnected();
+          SystemFailure.stopThreads();
+        }
-  
+
-  
+
-   *
-   *
-   *
-      }
-      else {
+      } else {
-  
+
+
-  
+
-   *
+
+
-  
-  
+
-    
+
-    for(InternalDistributedMember member: allMembers) {
-      
+    for (InternalDistributedMember member : allMembers) {
+
-      if(address.equals(member.getInetAddress()) || equivalentAddresses.contains(address)) {
+      if (address.equals(member.getInetAddress()) || equivalentAddresses.contains(address)) {
-    
+
-    for(DistributedMember member : allMembers) {
-      if(member.getName().equals(name)) {
+    for (DistributedMember member : allMembers) {
+      if (member.getName().equals(name)) {
+
-   *
-    
+
-  
+
-  private final ConcurrentHashMap<String, FunctionStats>  functionExecutionStatsMap = new ConcurrentHashMap<String, FunctionStats>();
+  private final ConcurrentHashMap<String, FunctionStats> functionExecutionStatsMap = new ConcurrentHashMap<String, FunctionStats>();
-  
+
+
-  
+
-  
+
-  
+
+
+
+
-    FunctionStats stats = (FunctionStats)functionExecutionStatsMap.get(textId);
+    FunctionStats stats = (FunctionStats) functionExecutionStatsMap.get(textId);
-      FunctionStats oldStats = functionExecutionStatsMap.putIfAbsent(textId,
-          stats);
+      FunctionStats oldStats = functionExecutionStatsMap.putIfAbsent(textId, stats);
-  
+
-        if(functionServiceStats == null){
+        if (functionServiceStats == null) {
-    for (Statistics s: this.statsList) {
+    for (Statistics s : this.statsList) {
+
-  
+
-  
-  
+
+
-        public void visit(Statistics s) {
-          if (type == s.getType()) {
-            hits.add(s);
-          }
+      public void visit(Statistics s) {
+        if (type == s.getType()) {
+          hits.add(s);
-      });
+      }
+    });
-    return (Statistics[])hits.toArray(result);
+    return (Statistics[]) hits.toArray(result);
-  
+
-        public void visit(Statistics s) {
-          if (s.getTextId().equals(textId)) {
-            hits.add(s);
-          }
+      public void visit(Statistics s) {
+        if (s.getTextId().equals(textId)) {
+          hits.add(s);
-      });
+      }
+    });
-    return (Statistics[])hits.toArray(result);
+    return (Statistics[]) hits.toArray(result);
+
-        public void visit(Statistics s) {
-          if (numericId == s.getNumericId()) {
-            hits.add(s);
-          }
+      public void visit(Statistics s) {
+        if (numericId == s.getNumericId()) {
+          hits.add(s);
-      });
+      }
+    });
-    return (Statistics[])hits.toArray(result);
+    return (Statistics[]) hits.toArray(result);
+
-    for (Statistics s: this.statsList) {
+    for (Statistics s : this.statsList) {
-  /** for internal use only. Its called by {@link LocalStatisticsImpl#close}. */
+  /**
+   * for internal use only. Its called by {@link LocalStatisticsImpl#close}.
+   */
+
+
-    
+
-  public StatisticsType createType(String name, String description,
-                                   StatisticDescriptor[] stats) {
+  public StatisticsType createType(String name, String description, StatisticDescriptor[] stats) {
+
-  public StatisticsType[] createTypesFromXml(Reader reader)
-    throws IOException {
+
+  public StatisticsType[] createTypesFromXml(Reader reader) throws IOException {
-  public StatisticDescriptor createIntCounter(String name, String description,
-                                              String units) {
+  public StatisticDescriptor createIntCounter(String name, String description, String units) {
-  public StatisticDescriptor createLongCounter(String name, String description,
-                                               String units) {
+
+  public StatisticDescriptor createLongCounter(String name, String description, String units) {
-  public StatisticDescriptor createDoubleCounter(String name, String description,
-                                                 String units) {
+
+  public StatisticDescriptor createDoubleCounter(String name, String description, String units) {
-  public StatisticDescriptor createIntGauge(String name, String description,
-                                            String units) {
+
+  public StatisticDescriptor createIntGauge(String name, String description, String units) {
-  public StatisticDescriptor createLongGauge(String name, String description,
-                                             String units) {
+
+  public StatisticDescriptor createLongGauge(String name, String description, String units) {
-  public StatisticDescriptor createDoubleGauge(String name, String description,
-                                               String units) {
+
+  public StatisticDescriptor createDoubleGauge(String name, String description, String units) {
-  public StatisticDescriptor createIntCounter(String name, String description,
-                                              String units, boolean largerBetter) {
+
+  public StatisticDescriptor createIntCounter(String name, String description, String units, boolean largerBetter) {
-  public StatisticDescriptor createLongCounter(String name, String description,
-                                               String units, boolean largerBetter) {
+
+  public StatisticDescriptor createLongCounter(String name, String description, String units, boolean largerBetter) {
-  public StatisticDescriptor createDoubleCounter(String name, String description,
-                                                 String units, boolean largerBetter) {
+
+  public StatisticDescriptor createDoubleCounter(String name, String description, String units, boolean largerBetter) {
-  public StatisticDescriptor createIntGauge(String name, String description,
-                                            String units, boolean largerBetter) {
+
+  public StatisticDescriptor createIntGauge(String name, String description, String units, boolean largerBetter) {
-  public StatisticDescriptor createLongGauge(String name, String description,
-                                             String units, boolean largerBetter) {
+
+  public StatisticDescriptor createLongGauge(String name, String description, String units, boolean largerBetter) {
-  public StatisticDescriptor createDoubleGauge(String name, String description,
-                                               String units, boolean largerBetter) {
+
+  public StatisticDescriptor createDoubleGauge(String name, String description, String units, boolean largerBetter) {
-   * 
+   * <p>
-//    (new ManagerLogWriter(LogWriterImpl.FINE_LEVEL, System.out)).fine("registering reconnect listener: " + listener);
+    //    (new ManagerLogWriter(LogWriterImpl.FINE_LEVEL, System.out)).fine("registering reconnect listener: " + listener);
-      for (Iterator iter = connectListeners.iterator(); iter.hasNext();) {
+      for (Iterator iter = connectListeners.iterator(); iter.hasNext(); ) {
-        }
-        catch (VirtualMachineError err) {
+        } catch (VirtualMachineError err) {
-        }
-        catch (Throwable t) {
+        } catch (Throwable t) {
-    for (ReconnectListener listener: listeners) {
+    for (ReconnectListener listener : listeners) {
-          err = (Error)t;
+          err = (Error) t;
-   * 
-   * @param event
-   *          Enumeration depicting particular resource event
-   * @param resource
-   *          the actual resource object.
+   * @param event Enumeration depicting particular resource event
+   * @param resource the actual resource object.
-    for (Iterator<ResourceEventsListener> iter = resourceListeners.iterator(); iter
-        .hasNext();) {
+    for (Iterator<ResourceEventsListener> iter = resourceListeners.iterator(); iter.hasNext(); ) {
-      } catch(CancelException e) {
+      } catch (CancelException e) {
-      Boolean disconnectListenerThreadBoolean = 
-        (Boolean) disconnectListenerThread.get();
+      Boolean disconnectListenerThreadBoolean = (Boolean) disconnectListenerThread.get();
-      if (disconnectListenerThreadBoolean == null ||
-          !disconnectListenerThreadBoolean.booleanValue()) {
+      if (disconnectListenerThreadBoolean == null || !disconnectListenerThreadBoolean.booleanValue()) {
-          throw new DistributedSystemDisconnectedException(LocalizedStrings.InternalDistributedSystem_NO_LISTENERS_PERMITTED_AFTER_SHUTDOWN_0.toLocalizedString(reason), dm.getRootCause());
+          throw new DistributedSystemDisconnectedException(LocalizedStrings.InternalDistributedSystem_NO_LISTENERS_PERMITTED_AFTER_SHUTDOWN_0.toLocalizedString(reason), dm
+            .getRootCause());
-  
+
-    }
-    else {
-      return (InternalDistributedSystem)l.get(0);
+    } else {
+      return (InternalDistributedSystem) l.get(0);
+
-  
+
-   *
-     */
+   */
-      if( ! Boolean.getBoolean(DISABLE_SHUTDOWN_HOOK_PROPERTY)) {
+      if (!Boolean.getBoolean(DISABLE_SHUTDOWN_HOOK_PROPERTY)) {
-              LogWriterI18n log = ((InternalDistributedSystem)ds).getInternalLogWriter();
+              LogWriterI18n log = ((InternalDistributedSystem) ds).getInternalLogWriter();
-              DurableClientAttributes dca = ((InternalDistributedSystem)ds).getDistributedMember().getDurableClientAttributes();
+              DurableClientAttributes dca = ((InternalDistributedSystem) ds).getDistributedMember().getDurableClientAttributes();
-              
-              if(dca != null) {
-                  isDurableClient = ((dca.getId() == null || dca.getId().isEmpty()) ? false : true);
+
+              if (dca != null) {
+                isDurableClient = ((dca.getId() == null || dca.getId().isEmpty()) ? false : true);
-                            	 
-              ((InternalDistributedSystem)ds).disconnect(false,
-                  LocalizedStrings.InternalDistributedSystem_NORMAL_DISCONNECT
-                      .toLocalizedString(), isDurableClient/*keep alive drive from this*/);
+
+              ((InternalDistributedSystem) ds).disconnect(false, LocalizedStrings.InternalDistributedSystem_NORMAL_DISCONNECT.toLocalizedString(), isDurableClient/*keep alive drive from this*/);
-//              InternalDistributedSystem ids = (InternalDistributedSystem)ds;
-//              if (ids.getDistributionManager() != null &&
-//                  ids.getDistributionManager().getMembershipManager() != null) {
-//                ids.getDistributionManager().getMembershipManager()
-//                  .uncleanShutdown("VM is exiting", null);
-//              }
+              //              InternalDistributedSystem ids = (InternalDistributedSystem)ds;
+              //              if (ids.getDistributionManager() != null &&
+              //                  ids.getDistributionManager().getMembershipManager() != null) {
+              //                ids.getDistributionManager().getMembershipManager()
+              //                  .uncleanShutdown("VM is exiting", null);
+              //              }
-     *
-  
+
+
-     * 
-    
+
-   *
+
-   * */
+   */
-   * */
+   */
-  
+
-  
+
-  
-  
+
+
-  public boolean isReconnecting(){
+  public boolean isReconnecting() {
-  
+
-  
+
-  
+
-  /** Make sure this instance of DS never does a reconnect.
+  /**
+   * Make sure this instance of DS never does a reconnect.
-//    (new ManagerLogWriter(LogWriterImpl.FINE_LEVEL, System.out)).fine("cancelReconnect invoked", new Exception("stack trace"));
+    //    (new ManagerLogWriter(LogWriterImpl.FINE_LEVEL, System.out)).fine("cancelReconnect invoked", new Exception("stack trace"));
-    	  // then on this.reconnectLock.
+        // then on this.reconnectLock.
-  
+
-   * 
-   *
-   * */
+   */
-  
+
-   *
-   * */
+   */
-    
+
-    
+
-    
+
-    
+
-    
+
-    
+
-          if(reconnectAttemptCounter >= maxTries){
+          if (reconnectAttemptCounter >= maxTries) {
-        
+
-        
+
-    
+
-        }
-        catch(Exception ee){
+        } catch (Exception ee) {
-        
+
-        }
-        catch (InterruptedException e) {
+        } catch (InterruptedException e) {
-        
-    
-        logger.info(LocalizedMessage.create(LocalizedStrings.DISTRIBUTED_SYSTEM_RECONNECTING, new Object[]{reconnectAttemptCounter}));
-        
+
+
+        logger.info(LocalizedMessage.create(LocalizedStrings.DISTRIBUTED_SYSTEM_RECONNECTING, new Object[] { reconnectAttemptCounter }));
+
-            newDS = (InternalDistributedSystem)connect(configProps);
+            newDS = (InternalDistributedSystem) connect(configProps);
-            if (newDS == null  &&  quorumChecker != null) {
+            if (newDS == null && quorumChecker != null) {
-        }
-        catch (SystemConnectException e) {
+        } catch (SystemConnectException e) {
-        }
-        catch (GemFireConfigException e) {
+        } catch (GemFireConfigException e) {
-        }
-        catch (Exception ee) {
+        } catch (Exception ee) {
-        }
-        finally {
+        } finally {
-          if (((DistributionManager)newDM).getDMType() != DistributionManager.ADMIN_ONLY_DM_TYPE) {
+          if (((DistributionManager) newDM).getDMType() != DistributionManager.ADMIN_ONLY_DM_TYPE) {
-              if (cache.getCachePerfStats().getReliableRegionsMissing() == 0){
+              if (cache.getCachePerfStats().getReliableRegionsMissing() == 0) {
-              }
-              else {
+              } else {
-            }
-            catch (CancelException ignor) {
-              logger.warn("Exception occured while trying to create the cache during reconnect",ignor);
+            } catch (CancelException ignor) {
+              logger.warn("Exception occured while trying to create the cache during reconnect", ignor);
-            }
-            catch (Exception e) {
+            } catch (Exception e) {
-        System.setProperty(APPEND_TO_LOG_FILE,  appendToLogFile);
+        System.setProperty(APPEND_TO_LOG_FILE, appendToLogFile);
-  public void createAndStartCacheServers(
-      List<CacheServerCreation> cacheServerCreation, GemFireCacheImpl cache) {
+  public void createAndStartCacheServers(List<CacheServerCreation> cacheServerCreation, GemFireCacheImpl cache) {
-    
+
-      for (CacheServerCreation bridge: cacheServerCreation) {
-        CacheServerImpl impl = (CacheServerImpl)cache.addCacheServer();
+      for (CacheServerCreation bridge : cacheServerCreation) {
+        CacheServerImpl impl = (CacheServerImpl) cache.addCacheServer();
-    
+
-    for (CacheServer server: servers) {
+    for (CacheServer server : servers) {
-        throw new GemFireIOException(
-            LocalizedStrings.CacheCreation_WHILE_STARTING_CACHE_SERVER_0
-                .toLocalizedString(server), ex);
+        throw new GemFireIOException(LocalizedStrings.CacheCreation_WHILE_STARTING_CACHE_SERVER_0.toLocalizedString(server), ex);
-    
+
+   *
-  public void validateSameProperties(Properties propsToCheck, boolean isConnected)
-  {
+  public void validateSameProperties(Properties propsToCheck, boolean isConnected) {
-            .toLocalizedString(sb.toString()));
+          .toLocalizedString(sb.toString()));
-            .toLocalizedString(sb.toString()), this.creationStack);
+          .toLocalizedString(sb.toString()), this.creationStack);
-        return "-not-array-object-";
+      return "-not-array-object-";
-    for (int i = 0; i < arrayLength - 1; i++ ) {
-        buff.append(Array.get(obj, i).toString());
-        buff.append(",");
+    for (int i = 0; i < arrayLength - 1; i++) {
+      buff.append(Array.get(obj, i).toString());
+      buff.append(",");
-    buff.append(Array.get(obj, arrayLength - 1).toString());
+    if(arrayLength > 0) {
+      buff.append(Array.get(obj, arrayLength - 1).toString());
+    }
-  public boolean isShareSockets()
-  {
+  public boolean isShareSockets() {
-  public void setShareSockets(boolean shareSockets)
-  {
+  public void setShareSockets(boolean shareSockets) {
-  
+
-  
+
-  
+
-  
-  public boolean isServerLocator(){
+
+  public boolean isServerLocator() {
-   *
-  public boolean waitUntilReconnected(long time, TimeUnit units)
-      throws InterruptedException {
+  public boolean waitUntilReconnected(long time, TimeUnit units) throws InterruptedException {
-    synchronized(this.reconnectLock) {
+    synchronized (this.reconnectLock) {
-        if (time == 0  ||  System.currentTimeMillis() > endTime) {
+        if (time == 0 || System.currentTimeMillis() > endTime) {
-      return !attemptingToReconnect  &&  recon != null  &&  recon.isConnected();
+      return !attemptingToReconnect && recon != null && recon.isConnected();
-  
+
-//    (new ManagerLogWriter(LogWriterImpl.FINE_LEVEL, System.out)).fine("stopReconnecting invoked", new Exception("stack trace"));
+    //    (new ManagerLogWriter(LogWriterImpl.FINE_LEVEL, System.out)).fine("stopReconnecting invoked", new Exception("stack trace"));
-    synchronized(this.reconnectLock) {
+    synchronized (this.reconnectLock) {
-  
+
-   * Provides hook for dunit to generate and store a detailed creation stack 
-   * trace that includes the keys/values of DistributionConfig including 
+   * Provides hook for dunit to generate and store a detailed creation stack
+   * trace that includes the keys/values of DistributionConfig including
-   * 
+

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 UPD40 INS40 UPD40 INS40 INS40 INS40 UPD40 INS40 INS40 UPD40 INS40 INS40 INS40 INS40 INS25 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS8 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 INS27 INS8 UPD66 UPD66 INS41 INS42 INS34 MOV21 UPD42 UPD42 INS42 INS8 INS8 INS8 MOV21 INS10 MOV21 DEL52 DEL42 DEL22 DEL10 DEL41
GEODE-2197: refactor cluster config and fix the test failures

+import java.io.FileFilter;
-import java.io.FilenameFilter;
-import java.util.Collection;
+import java.util.Arrays;
+import java.util.stream.Collector;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
-  private final String configDiskDirName;
-  private final Set<PersistentMemberPattern> newerSharedConfigurationLocatorInfo =
-      new HashSet<PersistentMemberPattern>();
-  private final AtomicReference<SharedConfigurationStatus> status =
-      new AtomicReference<SharedConfigurationStatus>();
-  private static final JarFileFilter jarFileFilter = new JarFileFilter();
+  private final Set<PersistentMemberPattern> newerSharedConfigurationLocatorInfo = new HashSet<>();
+  private final AtomicReference<SharedConfigurationStatus> status = new AtomicReference<>();
-    this.configDiskDirName =
-        CLUSTER_CONFIG_DISK_DIR_PREFIX + cache.getDistributedSystem().getName();
-    String clusterConfigDir =
+    // resolve the cluster config dir
+    String clusterConfigRootDir =
-    if (StringUtils.isBlank(clusterConfigDir)) {
-      clusterConfigDir = System.getProperty("user.dir");
+    if (StringUtils.isBlank(clusterConfigRootDir)) {
+      clusterConfigRootDir = System.getProperty("user.dir");
-      File diskDir = new File(clusterConfigDir);
+      File diskDir = new File(clusterConfigRootDir);
-        throw new IOException("Cannot create directory : " + clusterConfigDir);
+        throw new IOException("Cannot create directory : " + clusterConfigRootDir);
-      clusterConfigDir = diskDir.getCanonicalPath();
+      clusterConfigRootDir = diskDir.getCanonicalPath();
-    this.configDiskDirPath = FilenameUtils.concat(clusterConfigDir, this.configDiskDirName);
-    configDirPath = FilenameUtils.concat(clusterConfigDir, CLUSTER_CONFIG_ARTIFACTS_DIR_NAME);
+
+    // resolve the file paths
+    String configDiskDirName =
+        CLUSTER_CONFIG_DISK_DIR_PREFIX + cache.getDistributedSystem().getName();
+
+    configDirPath = FilenameUtils.concat(clusterConfigRootDir, CLUSTER_CONFIG_ARTIFACTS_DIR_NAME);
+    configDiskDirPath = FilenameUtils.concat(clusterConfigRootDir, configDiskDirName);
-  /**
-   * Add jar information into the shared configuration and save the jars in the file system
-   * @return true on success
-   */
-  public boolean addJarsToThisLocator(String[] jarNames, byte[][] jarBytes, String[] groups) {
-    boolean success = true;
-    try {
-      if (groups == null) {
-        groups = new String[]{SharedConfiguration.CLUSTER_CONFIG};
-      }
-      Region<String, Configuration> configRegion = getConfigurationRegion();
-      for (String group : groups) {
-        Configuration configuration = configRegion.get(group);
-
-        if (configuration == null) {
-          configuration = new Configuration(group);
-          createConfigDirIfNecessary(group);
-        }
-        String groupDir = FilenameUtils.concat(configDirPath, group);
-        writeJarFiles(groupDir, jarNames, jarBytes);
-
-        // update the record after writing the jars to the file system, since the listener
-        // will need the jars on file to upload to other locators.
-        configuration.addJarNames(jarNames);
-        configRegion.put(group, configuration);
-      }
-    } catch (Exception e) {
-      success = false;
-      logger.info(e.getMessage(), e);
-    }
-    return success;
-  }
-   * Adds/replaces the xml entity in the shared configuration
+   * Adds/replaces the xml entity in the shared configuration we don't need to trigger the change
+   * listener for this modification, so it's ok to operate on the original configuration object
-      groups = new String[]{SharedConfiguration.CLUSTER_CONFIG};
+      groups = new String[] {SharedConfiguration.CLUSTER_CONFIG};
-//      writeConfig(configuration);
-    }
-  }
-
-  public void clearSharedConfiguration() throws Exception {
-    Region<String, Configuration> configRegion = getConfigurationRegion();
-    if (configRegion != null) {
-      configRegion.clear();
+   * Deletes the xml entity from the shared configuration.
+   */
+  public void deleteXmlEntity(final XmlEntity xmlEntity, String[] groups) throws Exception {
+    Region<String, Configuration> configRegion = getConfigurationRegion();
+    // No group is specified, so delete in every single group if it exists.
+    if (groups == null) {
+      Set<String> groupSet = configRegion.keySet();
+      groups = groupSet.toArray(new String[groupSet.size()]);
+    }
+    for (String group : groups) {
+      Configuration configuration = (Configuration) configRegion.get(group);
+      if (configuration != null) {
+        String xmlContent = configuration.getCacheXmlContent();
+        if (xmlContent != null && !xmlContent.isEmpty()) {
+          Document doc = createAndUpgradeDocumentFromXml(xmlContent);
+          XmlUtils.deleteNode(doc, xmlEntity);
+          configuration.setCacheXmlContent(XmlUtils.prettyXml(doc));
+          configRegion.put(group, configuration);
+        }
+      }
+    }
+  }
+
+  // we don't need to trigger the change listener for this modification, so it's ok to
+  // operate on the original configuration object
+  public void modifyXmlAndProperties(Properties properties, XmlEntity xmlEntity, String[] groups)
+      throws Exception {
+    if (groups == null) {
+      groups = new String[] {SharedConfiguration.CLUSTER_CONFIG};
+    }
+    Region<String, Configuration> configRegion = getConfigurationRegion();
+    for (String group : groups) {
+      Configuration configuration = configRegion.get(group);
+      if (configuration == null) {
+        configuration = new Configuration(group);
+      }
+
+      if (xmlEntity != null) {
+        String xmlContent = configuration.getCacheXmlContent();
+        if (xmlContent == null || xmlContent.isEmpty()) {
+          StringWriter sw = new StringWriter();
+          PrintWriter pw = new PrintWriter(sw);
+          CacheXmlGenerator.generateDefault(pw);
+          xmlContent = sw.toString();
+        }
+
+        Document doc = createAndUpgradeDocumentFromXml(xmlContent);
+
+        // Modify the cache attributes
+        XmlUtils.modifyRootAttributes(doc, xmlEntity);
+
+        // Change the xml content of the configuration and put it the config region
+        configuration.setCacheXmlContent(XmlUtils.prettyXml(doc));
+      }
+
+      if (properties != null) {
+        configuration.getGemfireProperties().putAll(properties);
+      }
+      configRegion.put(group, configuration);
+    }
+  }
+
+
+  /**
+   * Add jar information into the shared configuration and save the jars in the file system used
+   * when deploying jars
+   * 
+   * @return true on success
+   */
+  public boolean addJarsToThisLocator(String[] jarNames, byte[][] jarBytes, String[] groups) {
+    boolean success = true;
+    try {
+      if (groups == null) {
+        groups = new String[] {SharedConfiguration.CLUSTER_CONFIG};
+      }
+      Region<String, Configuration> configRegion = getConfigurationRegion();
+      for (String group : groups) {
+        Configuration configuration = configRegion.get(group);
+
+        if (configuration == null) {
+          configuration = new Configuration(group);
+          createConfigDirIfNecessary(group);
+        }
+
+        String groupDir = FilenameUtils.concat(configDirPath, group);
+        for (int i = 0; i < jarNames.length; i++) {
+          String filePath = FilenameUtils.concat(groupDir, jarNames[i]);
+          File jarFile = new File(filePath);
+          try {
+            FileUtils.writeByteArrayToFile(jarFile, jarBytes[i]);
+          } catch (IOException e) {
+            logger.info(e);
+          }
+        }
+
+        // update the record after writing the jars to the file system, since the listener
+        // will need the jars on file to upload to other locators.
+        Configuration configurationCopy = new Configuration(configuration);
+        configurationCopy.addJarNames(jarNames);
+        configRegion.put(group, configurationCopy);
+      }
+    } catch (Exception e) {
+      success = false;
+      logger.info(e.getMessage(), e);
+    }
+    return success;
+  }
+
+  /**
+   * read the jar bytes in the file system
+   * 
+   * @return
+   * @throws Exception
+   */
+  // used when creating cluster config response
+  // and used when uploading the jars to another locator
+  public byte[] getJarBytesFromThisLocator(String group, String jarName) throws Exception {
+    Configuration configuration = getConfiguration(group);
+
+    // TODO: Should we check like this, or just check jar.exists below()?
+    if (configuration == null || !configuration.getJarNames().contains(jarName)) {
+      return null;
+    }
+
+    File jar = getPathToJarOnThisLocator(group, jarName).toFile();
+    return FileUtils.readFileToByteArray(jar);
+  }
+
+  /**
+   * Removes the jar files from the shared configuration. used when undeploy jars
+   *
+   * @param jarNames Names of the jar files.
+   * @param groups Names of the groups which had the jar file deployed.
+   * @return true on success.
+   */
+  public boolean removeJars(final String[] jarNames, String[] groups) {
+    boolean success = true;
+    try {
+      Region<String, Configuration> configRegion = getConfigurationRegion();
+      if (groups == null) {
+        groups = configRegion.keySet().stream().toArray(String[]::new);
+      }
+      for (String group : groups) {
+        Configuration configuration = configRegion.get(group);
+        if (configuration == null) {
+          break;
+        }
+        Configuration configurationCopy = new Configuration(configuration);
+        configurationCopy.removeJarNames(jarNames);
+        configRegion.put(group, configurationCopy);
+      }
+    } catch (Exception e) {
+      logger.info("Exception occurred while deleting the jar files", e);
+      success = false;
+    }
+    return success;
+  }
+
+  // used in the cluster config change listener when jarnames are changed in the internal region
+  public void downloadJarFromOtherLocators(String groupName, String jarName) throws Exception {
+    logger.info("Getting Jar files from other locators");
+    DM dm = cache.getDistributionManager();
+    DistributedMember me = cache.getMyId();
+    Set<DistributedMember> locators =
+        new HashSet<>(dm.getAllHostedLocatorsWithSharedConfiguration().keySet());
+    locators.remove(me);
+
+    createConfigDirIfNecessary(groupName);
+
+    byte[] jarBytes = locators.stream()
+        .map((DistributedMember locator) -> downloadJarFromLocator(locator, groupName, jarName))
+        .filter(Objects::nonNull).findFirst().orElseThrow(() -> new IllegalStateException(
+            "No locators have a deployed jar named " + jarName + " in " + groupName));
+
+    File jarToWrite = getPathToJarOnThisLocator(groupName, jarName).toFile();
+    FileUtils.writeByteArrayToFile(jarToWrite, jarBytes);
+  }
+
+
+  // used when creating cluster config response
+  public Map<String, byte[]> getAllJarsFromThisLocator(Set<String> groups) throws Exception {
+    Map<String, byte[]> jarNamesToJarBytes = new HashMap<>();
+
+    for (String group : groups) {
+      Configuration groupConfig = getConfiguration(group);
+      if (groupConfig == null) {
+        break;
+      }
+
+      Set<String> jars = groupConfig.getJarNames();
+      for (String jar : jars) {
+        byte[] jarBytes = getJarBytesFromThisLocator(group, jar);
+        jarNamesToJarBytes.put(jar, jarBytes);
+      }
+    }
+
+    return jarNamesToJarBytes;
+  }
+
+  public void clearSharedConfiguration() throws Exception {
+    Region<String, Configuration> configRegion = getConfigurationRegion();
+    configRegion.clear();
+  }
+
+  /**
+   * 
-   * directory
+   *        directory
+    lockSharedConfiguration();
-    if (loadSharedConfigFromDir) {
-      lockSharedConfiguration();
-      try {
+    try {
+      if (loadSharedConfigFromDir) {
-
-        Map<String, Configuration> sharedConfigMap = this.readSharedConfigurationFromDisk();
-        // Clear the configuration region and load the configuration read from the 'shared_config'
-        // directory
-        // on region entry create/update, it will upload the jars to all other locators
-        configRegion.clear();
-        configRegion.putAll(sharedConfigMap);
-      } finally {
-        unlockSharedConfiguration();
-      }
-    } else {
-      // Write out the existing configuration into the 'shared_config' directory
-      // And get deployed jars from other locators.
-      lockSharedConfiguration();
-      try {
-        // on region entry create/update, it should download missing jars from other locators
+        this.loadSharedConfigurationFromDisk();
+      } else {
-      } finally {
-        unlockSharedConfiguration();
+        Set<String> groups = configRegion.keySet();
+        for (String group : groups) {
+          Configuration config = configRegion.get(group);
+          // for those groups that have jar files, need to download the jars from other locators
+          // if it doesn't exist yet
+          for (String jar : config.getJarNames()) {
+            if (!(getPathToJarOnThisLocator(group, jar).toFile()).exists()) {
+              downloadJarFromOtherLocators(group, jar);
+            }
+          }
+        }
+    } finally {
+      unlockSharedConfiguration();
-   * @return {@link SharedConfigurationStatusResponse} containing the {@link
-   * SharedConfigurationStatus}
+   * 
+   * @return {@link SharedConfigurationStatusResponse} containing the
+   *         {@link SharedConfigurationStatus}
-   * Deletes the xml entity from the shared configuration.
-   */
-  public void deleteXmlEntity(final XmlEntity xmlEntity, String[] groups) throws Exception {
-    Region<String, Configuration> configRegion = getConfigurationRegion();
-    // No group is specified, so delete in every single group if it exists.
-    if (groups == null) {
-      Set<String> groupSet = configRegion.keySet();
-      groups = groupSet.toArray(new String[groupSet.size()]);
-    }
-    for (String group : groups) {
-      Configuration configuration = (Configuration) configRegion.get(group);
-      if (configuration != null) {
-        String xmlContent = configuration.getCacheXmlContent();
-        if (xmlContent != null && !xmlContent.isEmpty()) {
-          Document doc = createAndUpgradeDocumentFromXml(xmlContent);
-          XmlUtils.deleteNode(doc, xmlEntity);
-          configuration.setCacheXmlContent(XmlUtils.prettyXml(doc));
-          configRegion.put(group, configuration);
-          //writeConfig(configuration);
-        }
-      }
-    }
-  }
-
-  public void modifyCacheAttributes(final XmlEntity xmlEntity, String[] groups) throws Exception {
-    Region<String, Configuration> configRegion = getConfigurationRegion();
-    // No group is specified, so modify the cache attributes for a in every single group if it
-    // exists.
-    if (groups == null) {
-      Set<String> groupSet = configRegion.keySet();
-      groups = groupSet.toArray(new String[groupSet.size()]);
-    }
-    for (String group : groups) {
-      Configuration configuration = (Configuration) configRegion.get(group);
-
-      if (configuration == null) {
-        configuration = new Configuration(group);
-      }
-      String xmlContent = configuration.getCacheXmlContent();
-      if (xmlContent == null || xmlContent.isEmpty()) {
-        StringWriter sw = new StringWriter();
-        PrintWriter pw = new PrintWriter(sw);
-        CacheXmlGenerator.generateDefault(pw);
-        xmlContent = sw.toString();
-      }
-
-      Document doc = createAndUpgradeDocumentFromXml(xmlContent);
-
-      // Modify the cache attributes
-      XmlUtils.modifyRootAttributes(doc, xmlEntity);
-
-      // Change the xml content of the configuration and put it the config region
-      configuration.setCacheXmlContent(XmlUtils.prettyXml(doc));
-      configRegion.put(group, configuration);
-      //writeConfig(configuration);
-    }
-  }
-
-  /**
-  public byte[] getJarBytesFromThisLocator(String group, String jarName) throws Exception {
-    Configuration configuration = getConfiguration(group);
-
-    //TODO: Should we check  like this, or just check jar.exists below()?
-    if (configuration == null || !configuration.getJarNames().contains(jarName)) {
-      return null;
-    }
-
-    File jar = getPathToJarOnThisLocator(group, jarName).toFile();
-    return FileUtils.readFileToByteArray(jar);
-  }
-
-  public Map<String, byte[]> getAllJarsFromThisLocator(Set<String> groups) throws Exception {
-    Map<String, byte[]> jarNamesToJarBytes = new HashMap<>();
-
-    for (String group : groups) {
-      Configuration groupConfig = getConfiguration(group);
-      if (groupConfig == null) {
-        break;
-      }
-
-      Set<String> jars = groupConfig.getJarNames();
-      for (String jar : jars) {
-        byte[] jarBytes = getJarBytesFromThisLocator(group, jar);
-        jarNamesToJarBytes.put(jar, jarBytes);
-      }
-    }
-
-    return jarNamesToJarBytes;
-  }
-
+   * 
+   * 
-   * Loads the
+   * Loads the internal region with the configuration in the configDirPath
-    Map<String, Configuration> sharedConfigurationMap = readSharedConfigurationFromDisk();
+    File[] groupNames =
+        new File(configDirPath).listFiles((FileFilter) DirectoryFileFilter.INSTANCE);
+    Map<String, Configuration> sharedConfiguration = new HashMap<String, Configuration>();
+
+    for (File groupName : groupNames) {
+      Configuration configuration = readConfiguration(groupName);
+      sharedConfiguration.put(groupName.getName(), configuration);
+    }
+
-    getConfigurationRegion().putAll(sharedConfigurationMap);
+    getConfigurationRegion().putAll(sharedConfiguration);
-  public void modifyProperties(final Properties properties, String[] groups) throws Exception {
-    if (groups == null) {
-      groups = new String[]{SharedConfiguration.CLUSTER_CONFIG};
-    }
-    Region<String, Configuration> configRegion = getConfigurationRegion();
-    for (String group : groups) {
-      Configuration configuration = configRegion.get(group);
-      if (configuration == null) {
-        configuration = new Configuration(group);
-      }
-      configuration.getGemfireProperties().putAll(properties);
-      configRegion.put(group, configuration);
-      //writeConfig(configuration);
-    }
-  }
-  /**
-   * Removes the jar files from the shared configuration.
-   * @param jarNames Names of the jar files.
-   * @param groups Names of the groups which had the jar file deployed.
-   * @return true on success.
-   */
-  public boolean removeJars(final String[] jarNames, String[] groups) {
-    boolean success = true;
-    try {
-      Region<String, Configuration> configRegion = getConfigurationRegion();
-      if (groups == null) {
-        groups = configRegion.keySet().stream().toArray(String[]::new);
-      }
-      for (String group : groups) {
-        Configuration configuration = configRegion.get(group);
-        if (configuration == null) {
-          break;
-        }
-        configuration.removeJarNames(jarNames);
-        configRegion.put(group, configuration);
-      }
-    } catch (Exception e) {
-      logger.info("Exception occurred while deleting the jar files", e);
-      success = false;
-    }
-    return success;
-  }
-  /**
-   * Creates a directory for this configuration if it doesn't already exist.
-   */
-  private File createConfigDirIfNecessary(final String configName) throws Exception {
-    File clusterConfigDir = new File(getSharedConfigurationDirPath());
-    if (!clusterConfigDir.exists()) {
-      if (!clusterConfigDir.mkdirs()) {
-        throw new IOException("Cannot create directory : " + getSharedConfigurationDirPath());
-      }
-    }
-    Path configDirPath = clusterConfigDir.toPath().resolve(configName);
-    File configDir = configDirPath.toFile();
-    if (!configDir.exists()) {
-      if (!configDir.mkdir()) {
-        throw new IOException("Cannot create directory : " + configDirPath);
-      }
-    }
-
-    return configDir;
-  }
-
+  // Write the content of xml and properties into the file system for exporting purpose
-  public void addJarFromOtherLocators(String groupName, String jarName) throws Exception {
-    logger.info("Getting Jar files from other locators");
-    DM dm = cache.getDistributionManager();
-    DistributedMember me = cache.getMyId();
-    Set<DistributedMember> locators =
-        new HashSet<>(dm.getAllHostedLocatorsWithSharedConfiguration().keySet());
-    locators.remove(me);
-
-    createConfigDirIfNecessary(groupName);
-
-    byte[] jarBytes = locators.stream()
-        .map((DistributedMember locator) -> downloadJarFromLocator(locator, groupName, jarName))
-        .filter(Objects::nonNull)
-        .findFirst()
-        .orElseThrow(() -> new IllegalStateException(
-            "No locators have a deployed jar named " + jarName + " in " + groupName));
-
-    File jarToWrite = getPathToJarOnThisLocator(groupName, jarName).toFile();
-    FileUtils.writeByteArrayToFile(jarToWrite, jarBytes);
-  }
-                                        String jarName) {
+      String jarName) {
-        .executeFunction(new UploadJarFunction(), new Object[]{groupName, jarName}, locator);
+        .executeFunction(new UploadJarFunction(), new Object[] {groupName, jarName}, locator);
-    return result.stream()
-        .filter(Objects::nonNull)
-        .findFirst()
-        .orElse(null);
+    return result.stream().filter(Objects::nonNull).findFirst().orElse(null);
-   * @return {@link Region} ConfigurationRegion
+   * 
+   * @return {@link Region} ConfigurationRegion, this should never be null
+   * 
-  private Configuration readConfiguration(final String configName, final String configDirectory)
+  private Configuration readConfiguration(File groupConfigDir)
-      TransformerException {
-    Configuration configuration = new Configuration(configName);
-    String cacheXmlFullPath =
-        FilenameUtils.concat(configDirectory, configuration.getCacheXmlFileName());
-    String propertiesFullPath =
-        FilenameUtils.concat(configDirectory, configuration.getPropertiesFileName());
+      TransformerException, IOException {
+    Configuration configuration = new Configuration(groupConfigDir.getName());
+    File cacheXmlFull = new File(groupConfigDir, configuration.getCacheXmlFileName());
+    File propertiesFull = new File(groupConfigDir, configuration.getPropertiesFileName());
-    File file = new File(configDirectory);
-    String[] jarFileNames = file.list(jarFileFilter);
+    configuration.setCacheXmlFile(cacheXmlFull);
+    configuration.setPropertiesFile(propertiesFull);
-    if (jarFileNames != null && jarFileNames.length != 0) {
-      configuration.addJarNames(jarFileNames);
-    }
-
-    try {
-      configuration.setCacheXmlContent(XmlUtils.readXmlAsStringFromFile(cacheXmlFullPath));
-      configuration.setGemfireProperties(readProperties(propertiesFullPath));
-    } catch (IOException e) {
-      logger.info(e);
-    }
+    Set<String> jarFileNames = Arrays.stream(groupConfigDir.list())
+        .filter((String filename) -> filename.endsWith(".jar")).collect(Collectors.toSet());
+    configuration.addJarNames(jarFileNames);
-   * Reads the properties from the properties file.
-   * @return {@link Properties}
+   * Creates a directory for this configuration if it doesn't already exist.
-  private Properties readProperties(final String propertiesFilePath) throws IOException {
-    Properties properties = new Properties();
-    File propsFile = new File(propertiesFilePath);
-    FileInputStream fis = null;
-    if (propsFile.exists()) {
-      try {
-        fis = new FileInputStream(propsFile);
-        properties.load(fis);
-      } finally {
-        if (fis != null) {
-          fis.close();
-        }
+  private File createConfigDirIfNecessary(final String configName) throws Exception {
+    File clusterConfigDir = new File(getSharedConfigurationDirPath());
+    if (!clusterConfigDir.exists()) {
+      if (!clusterConfigDir.mkdirs()) {
+        throw new IOException("Cannot create directory : " + getSharedConfigurationDirPath());
-    return properties;
-  }
+    Path configDirPath = clusterConfigDir.toPath().resolve(configName);
-  /**
-   * Reads the "shared_config" directory and loads all the cache.xml, gemfire.properties and
-   * deployed jars information
-   * @return {@link Map}
-   */
-  private Map<String, Configuration> readSharedConfigurationFromDisk() throws SAXException,
-      ParserConfigurationException, TransformerFactoryConfigurationError, TransformerException {
-    String[] subdirectoryNames = getSubdirectories(configDirPath);
-    Map<String, Configuration> sharedConfiguration = new HashMap<String, Configuration>();
-
-    if (subdirectoryNames != null) {
-      for (String subdirectoryName : subdirectoryNames) {
-        String fullpath = FilenameUtils.concat(configDirPath, subdirectoryName);
-        Configuration configuration = readConfiguration(subdirectoryName, fullpath);
-        sharedConfiguration.put(subdirectoryName, configuration);
+    File configDir = configDirPath.toFile();
+    if (!configDir.exists()) {
+      if (!configDir.mkdir()) {
+        throw new IOException("Cannot create directory : " + configDirPath);
-    return sharedConfiguration;
-  }
-  /**
-   * Writes the
-   * @param dirPath target directory , where the jar files are to be written
-   * @param jarNames Array containing the name of the jar files.
-   * @param jarBytes Array of byte arrays for the jar files.
-   */
-  private void writeJarFiles(final String dirPath, final String[] jarNames,
-                             final byte[][] jarBytes) {
-    for (int i = 0; i < jarNames.length; i++) {
-      String filePath = FilenameUtils.concat(dirPath, jarNames[i]);
-      File jarFile = new File(filePath);
-      try {
-        FileUtils.writeByteArrayToFile(jarFile, jarBytes[i]);
-      } catch (IOException e) {
-        logger.info(e);
-      }
-    }
+    return configDir;
+   * 
-  // UnitTest SharedConfigurationJUnitTest.testCreateAndUpgradeDocumentFromXml
-
-  /**
-   * Returns an array containing the names of the subdirectories in a given directory
-   * @param path Path of the directory whose subdirectories are listed
-   * @return String[] names of first level subdirectories, null if no subdirectories are found or if
-   * the path is incorrect
-   */
-  private static String[] getSubdirectories(String path) {
-    File directory = new File(path);
-    return directory.list(DirectoryFileFilter.INSTANCE);
-  }
-
-  private static class JarFileFilter implements FilenameFilter {
-    @Override
-    public boolean accept(File dir, String name) {
-      return name.endsWith(".jar");
-    }
-  }

MOV26 MOV26 INS26 INS26 INS26 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 UPD40 INS40 UPD40 INS40 INS40 INS31 INS31 UPD42 INS44 INS29 UPD42 INS8 MOV29 MOV83 MOV39 MOV42 MOV43 INS8 MOV29 MOV83 MOV43 MOV42 MOV44 MOV43 MOV43 MOV43 MOV43 MOV43 INS8 INS60 MOV43 INS42 MOV25 INS65 INS65 INS65 MOV21 MOV21 MOV60 MOV21 INS54 MOV21 INS60 MOV60 MOV70 MOV21 MOV21 MOV43 UPD42 MOV60 MOV60 MOV60 MOV21 MOV21 INS60 MOV21 MOV41 UPD74 UPD74 MOV43 INS59 UPD66 INS66 MOV27 UPD66 INS66 INS66 INS42 UPD66 INS8 MOV8 UPD66 UPD66 INS5 INS59 UPD42 UPD66 MOV43 MOV43 MOV43 INS74 INS59 UPD42 UPD42 INS42 MOV27 INS42 UPD42 MOV42 MOV33 INS25 INS25 MOV25 UPD43 MOV43 MOV85 INS42 INS32 MOV43 UPD42 UPD42 UPD42 INS14 UPD42 UPD42 UPD42 MOV42 UPD42 UPD42 MOV42 UPD43 MOV43 MOV43 INS42 INS32 MOV43 UPD42 INS42 UPD42 UPD42 MOV43 INS59 INS27 INS8 INS27 INS8 INS8 INS8 UPD42 INS14 INS42 INS11 MOV43 MOV43 INS32 MOV43 INS42 MOV32 MOV43 UPD42 MOV32 UPD42 INS32 INS42 INS32 UPD42 UPD42 MOV42 MOV42 INS42 INS32 INS42 INS33 MOV60 MOV25 MOV60 MOV21 MOV21 INS42 INS33 MOV21 INS24 INS60 INS60 MOV21 INS21 MOV21 INS60 INS70 MOV43 INS42 INS43 INS40 UPD42 INS32 INS42 INS42 INS32 INS42 INS86 INS42 INS42 MOV43 UPD42 MOV42 MOV42 MOV42 MOV58 MOV27 MOV37 INS8 MOV43 INS59 MOV43 INS59 INS32 MOV74 INS59 INS44 INS42 INS8 UPD42 MOV42 UPD42 UPD42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 INS32 INS44 INS32 INS60 MOV60 MOV54 INS42 INS42 INS14 UPD42 UPD42 INS42 INS14 UPD42 UPD42 INS52 INS42 UPD43 MOV43 INS42 MOV32 MOV43 INS42 INS60 INS70 UPD42 MOV42 MOV42 MOV43 UPD42 MOV42 UPD42 MOV42 MOV42 MOV45 UPD42 MOV42 MOV43 INS59 MOV43 INS42 MOV43 INS42 UPD42 MOV43 MOV59 INS44 INS32 INS8 INS42 INS32 MOV21 MOV42 UPD42 INS43 INS42 UPD42 MOV42 UPD42 MOV42 INS25 INS42 INS42 INS42 MOV2 UPD42 INS42 INS42 INS42 INS38 INS8 UPD42 UPD42 UPD42 MOV2 INS32 MOV21 INS36 INS42 INS32 UPD42 INS42 INS42 INS32 INS42 UPD42 MOV42 INS42 INS42 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL42 DEL43 DEL42 DEL43 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL23 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL3 DEL32 DEL42 DEL11 DEL59 DEL42 DEL42 DEL33 DEL27 DEL8 DEL25 DEL52 DEL74 DEL60 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL32 DEL21 DEL8 DEL8 DEL54 DEL8 DEL8 DEL42 DEL33 DEL27 DEL42 DEL42 DEL43 DEL42 DEL14 DEL7 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL31 DEL83 DEL39 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL5 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL40 DEL34 DEL27 DEL27 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL31 DEL66 DEL65 DEL66 DEL42 DEL65 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL14 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL66 DEL66 DEL65 DEL66 DEL42 DEL65 DEL65 DEL29 DEL83 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL44 DEL83 DEL39 DEL85 DEL85 DEL5 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL24 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL14 DEL59 DEL60 DEL40 DEL32 DEL41 DEL8 DEL31 DEL83 DEL83 DEL42 DEL42 DEL43 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL44 DEL42 DEL43 DEL44 DEL32 DEL41 DEL8 DEL31 DEL55
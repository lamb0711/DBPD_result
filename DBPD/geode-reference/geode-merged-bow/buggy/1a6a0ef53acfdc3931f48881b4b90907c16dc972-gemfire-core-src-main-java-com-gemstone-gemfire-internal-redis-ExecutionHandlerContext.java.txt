Fix for GEODE-109

1) To fix this floating meta data problem for the redis list implementation, this meta data has been moved into the list region itself
2) Sorted set query failures are fixed by using fully qualified names and also depends on GEODE-146
3) Concurrent region creation/destruction logic completely changed to use dedicated locks for synchronization, fixed distributed deadlock
4) Added integration tests
5) Add javadocs where necessary

This closes #13

+import com.gemstone.gemfire.cache.CacheClosedException;
+import com.gemstone.gemfire.cache.query.QueryInvocationTargetException;
+/**
+ * This class extends {@link ChannelInboundHandlerAdapter} from Netty and it is
+ * the last part of the channel pipeline. The {@link ByteToCommandDecoder} forwards a
+ * {@link Command} to this class which executes it and sends the result back to the
+ * client. Additionally, all exception handling is done by this class. 
+ * <p>
+ * Besides being part of Netty's pipeline, this class also serves as a context to the
+ * execution of a command. It abstracts transactions, provides access to the {@link RegionProvider}
+ * and anything else an executing {@link Command} may need.
+ * 
+ * @author Vitaliy Gavrilov
+ *
+ */
-  private static final int MAXIMUM_NUM_RETRIES = 5;
+  private static final int WAIT_REGION_DSTRYD_MILLIS = 100;
+  private static final int MAXIMUM_NUM_RETRIES = (1000*60)/WAIT_REGION_DSTRYD_MILLIS; // 60 seconds total
-  private final RegionCache regionCache;
+  private final RegionProvider regionProvider;
-  public ExecutionHandlerContext(Channel ch, Cache cache, RegionCache regions, GemFireRedisServer server, byte[] pwd) {
+  /**
+   * Default constructor for execution contexts. 
+   * 
+   * @param ch Channel used by this context, should be one to one
+   * @param cache The Geode cache instance of this vm
+   * @param regionProvider The region provider of this context
+   * @param server Instance of the server it is attached to, only used so that any execution can initiate a shutdwon
+   * @param pwd Authentication password for each context, can be null
+   */
+  public ExecutionHandlerContext(Channel ch, Cache cache, RegionProvider regionProvider, GemFireRedisServer server, byte[] pwd) {
+    if (ch == null || cache == null || regionProvider == null || server == null)
+      throw new IllegalArgumentException("Only the authentication password may be null");
-    this.regionCache = regions;
+    this.regionProvider = regionProvider;
-  private void writeToChannel(Object message) {
+  private void writeToChannel(ByteBuf message) {
+  /**
+   * This will handle the execution of received commands
+   */
+  /**
+   * Exception handler for the entire pipeline
+   */
-    else if (cause instanceof RegionCreationException)
+    else if (cause instanceof RegionCreationException) {
+      this.logger.error(cause);
-    else if (cause instanceof InterruptedException)
+    } else if (cause instanceof InterruptedException || cause instanceof CacheClosedException)
-      response = Coder.getErrorResponse(this.byteBufAllocator,  cause.getMessage());
+      response = Coder.getErrorResponse(this.byteBufAllocator, cause.getMessage());
-        this.logger.error("GemFireRedisServer-Unexpected error handler", cause);
+        this.logger.error("GemFireRedisServer-Unexpected error handler for " + ctx.channel(), cause);
-  /**
-   * This method is used to execute the command. The executor is 
-   * determined by the {@link RedisCommandType} and then the execution
-   * is started.
-   * 
-   * @param command Command to be executed
-   * @param cache The Cache instance of this server
-   * @param client The client data associated with the client
-   * @throws Exception 
-   */
-  public void executeCommand(ChannelHandlerContext ctx, Command command) throws Exception {
+  private void executeCommand(ChannelHandlerContext ctx, Command command) throws Exception {
-        executeWithoutTransaction(exec, command, MAXIMUM_NUM_RETRIES); 
+        executeWithoutTransaction(exec, command); 
-   * @param cache Cache instance
-   * @param client Client data associated with client
-   * @param n Recursive max depth of retries
-  private void executeWithoutTransaction(final Executor exec, Command command, int n) throws Exception {
-    try {
-      exec.executeCommand(command, this);
-    } catch (RegionDestroyedException e) {
-      if (n > 0)
-        executeWithoutTransaction(exec, command, n - 1);
-      else
-        throw e;
+  private void executeWithoutTransaction(final Executor exec, Command command) throws Exception {
+    Exception cause = null;
+    for (int i = 0; i < MAXIMUM_NUM_RETRIES; i++) {
+      try {
+        exec.executeCommand(command, this);
+        return;
+      } catch (Exception e) {
+        cause = e;
+        if (e instanceof RegionDestroyedException || e.getCause() instanceof QueryInvocationTargetException)
+          Thread.sleep(WAIT_REGION_DSTRYD_MILLIS);
+      }
+    throw cause;
-  /**
-   * Private method to execute a command when a transaction has been started
-   * 
-   * @param exec Executor to use
-   * @param command Command to execute
-   * @param cache Cache instance
-   * @param client Client data associated with client
-   * @throws Exception Throws exception if exception is from within execution and unrelated to transactions
-   */
+  /**
+   * {@link ByteBuf} allocator for this context. All executors
+   * must use this pooled allocator as opposed to having unpooled buffers
+   * for maximum performance
+   * 
+   * @return allocator instance
+   */
-  public RegionCache getRegionCache() {
-    return this.regionCache;
+  /**
+   * Gets the provider of Regions
+   * 
+   * @return Provider
+   */
+  public RegionProvider getRegionProvider() {
+    return this.regionProvider;
+  /**
+   * Getter for manager to allow pausing and resuming transactions
+   * @return Instance
+   */
+  /**
+   * Getter for logger
+   * @return instance
+   */
+  /**
+   * Get the channel for this context
+   * @return instance
+   *
+   */
+  /**
+   * Get the authentication password, this will be same server wide.
+   * It is exposed here as opposed to {@link GemFireRedisServer}.
+   * @return password
+   */
+  /**
+   * Checker if user has authenticated themselves
+   * @return True if no authentication required or authentication complete, false otherwise
+   */
+  /**
+   * Lets this context know the authentication is complete
+   */

INS26 INS26 INS40 INS40 INS29 INS23 INS65 INS65 INS83 INS83 INS83 INS39 INS59 UPD43 INS29 INS29 INS29 UPD83 INS8 INS29 INS29 UPD43 UPD42 INS29 INS29 INS29 INS29 INS29 INS66 INS65 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS42 INS34 INS27 UPD42 UPD42 INS65 INS65 INS65 INS65 INS65 INS65 UPD43 UPD42 INS25 UPD43 INS65 INS65 INS60 INS24 INS53 INS65 INS65 INS65 INS65 UPD42 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS42 INS42 INS42 INS42 INS36 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 UPD42 INS27 INS53 UPD42 INS66 INS66 INS43 INS59 INS58 INS27 INS37 INS8 INS42 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS27 INS27 INS27 INS14 UPD42 INS42 INS42 INS33 INS39 INS59 INS42 INS42 INS42 MOV54 INS42 UPD42 INS42 INS34 INS34 INS27 INS27 INS42 INS33 INS43 INS45 UPD42 INS8 INS42 INS34 INS27 INS27 INS42 INS33 INS42 MOV21 MOV21 INS27 INS41 INS42 INS33 INS42 INS33 MOV62 INS62 INS43 INS21 INS42 INS43 INS42 INS7 UPD27 INS42 INS21 INS42 INS42 INS62 INS62 INS32 INS42 MOV43 INS32 INS43 UPD42 UPD42 UPD42 INS22 INS42 INS27 INS42 INS42 INS42 INS42 INS52 INS42 INS45 INS32 INS42 INS42 DEL34 DEL45 DEL66 DEL66 DEL42 DEL65 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL42 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL39 DEL42 DEL44 DEL42 DEL34 DEL42 DEL34 DEL27 DEL42 DEL53 DEL8 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31
GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

-
+import static org.apache.geode.internal.lang.SystemUtils.getLineSeparator;
+import org.apache.geode.Delta;
-import org.apache.geode.cache.RegionMembershipListener;
-import org.apache.geode.internal.InternalStatisticsDisabledException;
+import org.apache.geode.internal.cache.partitioned.Bucket;
+import org.apache.geode.internal.offheap.Releasable;
-import java.util.Hashtable;
+import javax.transaction.RollbackException;
+import javax.transaction.Status;
+import javax.transaction.SystemException;
+import javax.transaction.Transaction;
+
- *
-  private static final Logger logger = LogService.getLogger();
+
+  // package-private to avoid synthetic accessor
+  static final Logger logger = LogService.getLogger();
+
-    public void call(LocalRegion r, Operation op, RegionEntry re);
+    void call(LocalRegion r, Operation op, RegionEntry re);
-  // iniitialization level
+  // initialization level
-  private static final ThreadLocal initializationThread = new ThreadLocal();
+  private static final ThreadLocal<Integer> initializationThread = new ThreadLocal();
-  protected static final ThreadLocal isConversion = new ThreadLocal();
+  static final ThreadLocal isConversion = new ThreadLocal();
-  protected Map entryUserAttributes; // @todo darrel: shouldn't this be an
-
-  // identity map whose key is a RegionEntry?
+  // TODO: shouldn't this be an identity map whose key is a RegionEntry?
+  Map entryUserAttributes;
-  // set to true only if isDestroyed is also true
-  // and region is about to be recreated due to reinitialization by loading
-  // of a snapshot, etc.
+  /**
+   * set to true only if isDestroyed is also true and region is about to be recreated due to
+   * reinitialization by loading of a snapshot, etc.
+   */
-  // In case of parallel wan, when a destroy is called on userPR, it waits for
-  // parallelQueue to drain and then destroys paralleQueue. In this time if
-  // operation like put happens on userPR then it will keep on building parallel
-  // queue increasing time of userPR to get destroyed.this volatile boolean will
-  // block such put operation by throwing RegionDestroyedException
-  protected volatile boolean isDestroyedForParallelWAN = false;
+  /**
+   * In case of parallel wan, when a destroy is called on userPR, it waits for parallelQueue to
+   * drain and then destroys parallelQueue. In this time if operation like put happens on userPR
+   * then it will keep on building parallel queue increasing time of userPR to get destroyed.this
+   * volatile boolean will block such put operation by throwing RegionDestroyedException
+   */
+  volatile boolean isDestroyedForParallelWAN = false;
-  // set to true after snapshot is loaded, to help get initial image
-  // make sure this is the right incarnation of this region
+  /**
+   * set to true after snapshot is loaded, to help get initial image make sure this is the right
+   * incarnation of this region
+   */
-  // guarded by regionExpiryLock.
+  /** GuardedBy regionExpiryLock. */
-  // guarded by regionExpiryLock.
+
+  /** GuardedBy regionExpiryLock. */
-  // guarded by regionExpiryLock. Keeps track of how many txs are writing to this region.
+
+  /**
+   * GuardedBy regionExpiryLock. Keeps track of how many txs are writing to this region.
+   */
-      new ConcurrentHashMap<RegionEntry, EntryExpiryTask>();
+      new ConcurrentHashMap<>();
+  /**
+   * TODO: make this private and introduce wrappers
+   */
-  protected EventTracker eventTracker;
+  EventTracker eventTracker;
-   * tracks region-level version information for members. See
-   * https://wiki.gemstone.com/display/gfe70/Consistency+in+Replicated+Regions+and+WAN
+   * tracks region-level version information for members
-  private volatile boolean entriesInitialized;
+  private final boolean entriesInitialized;
-  // Used for synchronizzing access to client Cqs
-  // private final Object clientCqsSync = new Object();
-
-  protected final StoppableCountDownLatch initializationLatchBeforeGetInitialImage;
+  final StoppableCountDownLatch initializationLatchBeforeGetInitialImage;
-  protected final StoppableCountDownLatch initializationLatchAfterGetInitialImage;
+  final StoppableCountDownLatch initializationLatchAfterGetInitialImage;
-  protected final ConcurrentMap getFutures = new ConcurrentHashMap();
+  private final ConcurrentMap getFutures = new ConcurrentHashMap();
-  /*
-   * Asif: This boolean needs to be made true if the test needs to receive a synchronous callback
+  /**
+   * TODO: This boolean needs to be made true if the test needs to receive a synchronous callback
-  final private boolean isUsedForPartitionedRegionAdmin;
+  private final boolean isUsedForPartitionedRegionAdmin;
-  final private boolean isUsedForPartitionedRegionBucket;
+  private final boolean isUsedForPartitionedRegionBucket;
-  final private boolean isUsedForMetaRegion;
+  private final boolean isUsedForMetaRegion;
-  final private boolean isMetaRegionWithTransactions;
+  private final boolean isMetaRegionWithTransactions;
-  final private boolean isUsedForSerialGatewaySenderQueue;
+  private final boolean isUsedForSerialGatewaySenderQueue;
-  final private boolean isUsedForParallelGatewaySenderQueue;
+  private final boolean isUsedForParallelGatewaySenderQueue;
-  final private AbstractGatewaySender serialGatewaySender;
+  private final AbstractGatewaySender serialGatewaySender;
-  protected final LoaderHelperFactory loaderHelperFactory;
+  final LoaderHelperFactory loaderHelperFactory;
-   * Allow for different cacheperfstats locations... primarily for PartitionedRegions
+   * Allow for different CachePerfStats locations... primarily for PartitionedRegions
+
-
+
-   * 
-   * @guarded.By {@link #imageState}
+   * <p>
+   * since always written while holding an exclusive write lock and only read while holding a read
+   * lock it does not need to be atomic or protected by any other sync.
+   * <p>
+   * GuardedBy {@link #imageState}
-  private int riCnt =
-      0; /*
-          * since always written while holding an exclusive write lock and only read while holding a
-          * read lock it does not need to be atomic or protected by any other sync.
-          */
-
+  private int riCnt = 0;
-  // Lock for updating PR MetaData on client side
+  /**
+   * Lock for updating PR MetaData on client side
+   * <p>
+   * TODO: move this to ClientMetadataService into {@code Map<Region, Lock>}
+   */
-   *
-   *
-      // ---
-      Cache c = LocalRegion.this.getCache();
-      if (c == null) {
+      Cache cache = LocalRegion.this.getCache();
+      if (cache == null) {
-      // --- end of grossness
-      return c.getCancelCriterion().cancelInProgress();
+      return cache.getCancelCriterion().cancelInProgress();
-    /*
-     * (non-Javadoc)
-     * 
-     * @see org.apache.geode.CancelCriterion#generateCancelledException(java.lang.Throwable)
-     */
-      // ---
-      Cache c = LocalRegion.this.getCache();
-      if (c == null) {
+      Cache cache = LocalRegion.this.getCache();
+      if (cache == null) {
-      // --- end of grossness
-      return c.getCancelCriterion().generateCancelledException(e);
+      return cache.getCancelCriterion().generateCancelledException(e);
-  protected CancelCriterion createStopper() {
+  // TODO: change createStopper to be private (fix EventTrackerTest)
+  public CancelCriterion createStopper() {
-  private final static ThreadLocal<LocalRegion> initializingRegion = new ThreadLocal<LocalRegion>();
+  private static final ThreadLocal<LocalRegion> initializingRegion = new ThreadLocal<LocalRegion>();
-  public static LocalRegion getInitializingRegion() {
+  static LocalRegion getInitializingRegion() {
-  protected Map<String, CacheServiceProfile> cacheServiceProfiles;
+  Map<String, CacheServiceProfile> cacheServiceProfiles;
-  ////////////////// Public Methods ///////////////////////////////////////////
-
-  static String calcFullPath(String regionName, LocalRegion parentRegion) {
+  private static String calcFullPath(String regionName, LocalRegion parentRegion) {
-      GemFireCacheImpl cache, InternalRegionArguments internalRegionArgs)
-      throws DiskAccessException {
+      InternalCache cache, InternalRegionArguments internalRegionArgs) throws DiskAccessException {
+
-    this.dsi = findDiskStore(attrs, internalRegionArgs);
+    this.diskStoreImpl = findDiskStore(attrs, internalRegionArgs);
+
+
-    this.srp = (this.getPoolName() != null) ? new ServerRegionProxy(this) : null;
-    this.imageState = new UnsharedImageState(this.srp != null,
+    this.serverRegionProxy = this.getPoolName() != null ? new ServerRegionProxy(this) : null;
+    this.imageState = new UnsharedImageState(this.serverRegionProxy != null,
-
-   * that require one should reimplement this method and create one like so: <code><pre>
-   *     this.eventTracker = new EventTracker(this.cache);
-   *     this.eventTracker.start();
-   * </pre></code>
+   * that require one should reimplement this method and create one like so:
+   *
+   * <pre>
+   * {@code
+   * this.eventTracker = new EventTracker(this.cache);
+   * this.eventTracker.start();
+   * }
+   * </pre>
-
-   * 
-  protected EventTracker getEventTracker() {
+  EventTracker getEventTracker() {
-  public Object getSizeGuard() {
+  Object getSizeGuard() {
-  protected void createVersionVector() {
-
+  void createVersionVector() {
-    if (dataPolicy.withPersistence()) {
+    if (this.dataPolicy.withPersistence()) {
-    } else if (!dataPolicy.withStorage()) {
+    } else if (!this.dataPolicy.withStorage()) {
-    if (this.srp != null) {
+    if (this.serverRegionProxy != null) {
-   * @param key
-  protected final ServerRegionProxy srp;
+  final ServerRegionProxy serverRegionProxy;
-  public final ServerRegionProxy getServerProxy() {
-    return this.srp;
+  public ServerRegionProxy getServerProxy() {
+    return this.serverRegionProxy;
-  public final boolean hasServerProxy() {
-    return this.srp != null;
+  public boolean hasServerProxy() {
+    return this.serverRegionProxy != null;
-  void performExpiryTimeout(ExpiryTask p_task) throws CacheException {
-    if (p_task != null) {
-      p_task.basicPerformTimeout(false);
+  void performExpiryTimeout(ExpiryTask expiryTask) throws CacheException {
+    if (expiryTask != null) {
+      expiryTask.basicPerformTimeout(false);
-
+  @Override
-  public Region createSubregion(String subregionName, RegionAttributes regionAttributes)
+  @Override
+  public Region createSubregion(String subregionName, RegionAttributes aRegionAttributes)
-      return createSubregion(subregionName, regionAttributes,
+      return createSubregion(subregionName, aRegionAttributes,
-    } catch (IOException e) {
+    } catch (IOException | ClassNotFoundException e) {
-      InternalGemFireError assErr = new InternalGemFireError(
-          LocalizedStrings.LocalRegion_UNEXPECTED_EXCEPTION.toLocalizedString());
-      assErr.initCause(e);
-      throw assErr;
-
-    } catch (ClassNotFoundException e) {
-      // only happens when loading a snapshot, not here
-      InternalGemFireError assErr = new InternalGemFireError(
-          LocalizedStrings.LocalRegion_UNEXPECTED_EXCEPTION.toLocalizedString());
-      assErr.initCause(e);
-      throw assErr;
-
+      throw new InternalGemFireError(
+          LocalizedStrings.LocalRegion_UNEXPECTED_EXCEPTION.toLocalizedString(), e);
-    return this.cache.getMyId();
+    return this.cache.getInternalDistributedSystem().getDistributedMember();
-    if (dataPolicy.withPersistence()) {
+    if (this.dataPolicy.withPersistence()) {
-      return this.cache.getMyId();
+      return this.cache.getInternalDistributedSystem().getDistributedMember();
+  // TODO: createSubregion method is too complex for IDE to analyze
+
-    LocalRegion newRegion = null;
-    attrs = cache.invokeRegionBefore(this, subregionName, attrs, internalRegionArgs);
+    // TODO: attrs is reassigned but never used
+    attrs = this.cache.invokeRegionBefore(this, subregionName, attrs, internalRegionArgs);
+
+
+    LocalRegion newRegion = null;
-        String regionPath = calcFullPath(subregionName, this);
-            Object o = this.subregions.putIfAbsent(subregionName, newRegion);
+            Object previousValue = this.subregions.putIfAbsent(subregionName, newRegion);
-            Assert.assertTrue(o == null);
+            Assert.assertTrue(previousValue == null);
-            //
-        if (getDestroyLock)
+        if (getDestroyLock) {
+        }
-
-        newRegion.initialize(snapshotInputStream, imageTarget, internalRegionArgs); // releases
-                                                                                    // initialization
-                                                                                    // Latches
+
+        // releases initialization Latches
+        newRegion.initialize(snapshotInputStream, imageTarget, internalRegionArgs);
+
-            cache.getInternalResourceManager().addResourceListener(ResourceType.MEMORY, newRegion);
+            this.cache.getInternalResourceManager().addResourceListener(ResourceType.MEMORY,
+                newRegion);
-                  cache.getInternalResourceManager().getHeapMonitor().getState().isCritical(),
-                  cache.getResourceAdvisor().adviseCritialMembers());
+                  this.cache.getInternalResourceManager().getHeapMonitor().getState().isCritical(),
+                  this.cache.getResourceAdvisor().adviseCritialMembers());
-              newRegion.initialCriticalMembers(cache.getInternalResourceManager().getHeapMonitor()
-                  .getState().isCritical()
-                  || cache.getInternalResourceManager().getOffHeapMonitor().getState().isCritical(),
-                  cache.getResourceAdvisor().adviseCritialMembers());
+              newRegion.initialCriticalMembers(
+                  this.cache.getInternalResourceManager().getHeapMonitor().getState().isCritical()
+                      || this.cache.getInternalResourceManager().getOffHeapMonitor().getState()
+                          .isCritical(),
+                  this.cache.getResourceAdvisor().adviseCritialMembers());
-      } catch (final RuntimeException validationException) {
+      } catch (RuntimeException validationException) {
-          cache.getInternalResourceManager(false).removeResourceListener(newRegion);
+          this.cache.getInternalResourceManager(false).removeResourceListener(newRegion);
-    cache.invokeRegionAfter(newRegion);
+    this.cache.invokeRegionAfter(newRegion);
+  @Override
-  public final void validatedCreate(EntryEventImpl event, long startPut)
+  private void validatedCreate(EntryEventImpl event, long startPut)
-      event.setNewEventId(cache.getDistributedSystem());
+      event.setNewEventId(this.cache.getDistributedSystem());
-  public final EntryEventImpl newCreateEntryEvent(Object key, Object value,
-      Object aCallbackArgument) {
+  private EntryEventImpl newCreateEntryEvent(Object key, Object value, Object aCallbackArgument) {
-   * <p>
-   * author Asif
-   * 
-  public final Object destroy(Object key, Object aCallbackArgument)
+  @Override
+  public Object destroy(Object key, Object aCallbackArgument)
-      event.setNewEventId(cache.getDistributedSystem());
+      event.setNewEventId(this.cache.getDistributedSystem());
-  public final EntryEventImpl newDestroyEntryEvent(Object key, Object aCallbackArgument) {
+  EntryEventImpl newDestroyEntryEvent(Object key, Object aCallbackArgument) {
+  @Override
-   * @param preferCD true if the preferred result form is CachedDeserializable
+   * @param preferCachedDeserializable true if the preferred result form is CachedDeserializable
-  public final Object getDeserializedValue(RegionEntry re, final KeyInfo keyInfo,
-      final boolean updateStats, boolean disableCopyOnRead, boolean preferCD,
+  public Object getDeserializedValue(RegionEntry regionEntry, final KeyInfo keyInfo,
+      final boolean updateStats, boolean disableCopyOnRead, boolean preferCachedDeserializable,
-      if (re == null) {
-        re = this.entries.getEntry(keyInfo.getKey());
+      if (regionEntry == null) {
+        regionEntry = this.entries.getEntry(keyInfo.getKey());
-      if (re == null) {
+      if (regionEntry == null) {
-      if (clientEvent != null && re.getVersionStamp() != null) {
+      if (clientEvent != null && regionEntry.getVersionStamp() != null) {
-          synchronized (re) { // bug #51059 value & version must be obtained atomically
-            clientEvent.setVersionTag(re.getVersionStamp().asVersionTag());
-            value = getDeserialized(re, updateStats, disableCopyOnRead, preferCD, retainResult);
+          synchronized (regionEntry) { // bug #51059 value & version must be obtained atomically
+            clientEvent.setVersionTag(regionEntry.getVersionStamp().asVersionTag());
+            value = getDeserialized(regionEntry, updateStats, disableCopyOnRead,
+                preferCachedDeserializable, retainResult);
-        value = getDeserialized(re, updateStats, disableCopyOnRead, preferCD, retainResult);
+        value = getDeserialized(regionEntry, updateStats, disableCopyOnRead,
+            preferCachedDeserializable, retainResult);
-            keyInfo.getKey(),
-            (re.getVersionStamp() == null ? "null" : re.getVersionStamp().asVersionTag()),
+            keyInfo.getKey(), regionEntry.getVersionStamp() == null ? "null"
+                : regionEntry.getVersionStamp().asVersionTag(),
-   *
-   * @param re
-   * @param updateStats
-   * @param preferCD true if the preferred result form is CachedDeserializable
+   * @param preferCachedDeserializable true if the preferred result form is CachedDeserializable
-  protected final Object getDeserialized(RegionEntry re, boolean updateStats,
-      boolean disableCopyOnRead, boolean preferCD, boolean retainResult) {
-    assert !retainResult || preferCD;
+  Object getDeserialized(RegionEntry regionEntry, boolean updateStats, boolean disableCopyOnRead,
+      boolean preferCachedDeserializable, boolean retainResult) {
+    assert !retainResult || preferCachedDeserializable;
-      Object v = null;
+      Object value;
-          v = re.getValueRetain(this);
+          value = regionEntry.getValueRetain(this);
-          v = re.getValue(this);
+          value = regionEntry.getValue(this);
-      if (v == null) {
+      if (value == null) {
-      if (v instanceof CachedDeserializable) {
-        if (!preferCD) {
+      if (value instanceof CachedDeserializable) {
+        if (!preferCachedDeserializable) {
-              v = ((CachedDeserializable) v).getDeserializedForReading();
+              value = ((CachedDeserializable) value).getDeserializedForReading();
-              v = ((CachedDeserializable) v).getDeserializedWritableCopy(this, re);
+              value = ((CachedDeserializable) value).getDeserializedWritableCopy(this, regionEntry);
-            v = ((CachedDeserializable) v).getDeserializedValue(this, re);
+            value = ((CachedDeserializable) value).getDeserializedValue(this, regionEntry);
-        v = conditionalCopy(v);
+        value = conditionalCopy(value);
-        updateStatsForGet(re, v != null && !Token.isInvalid(v));
+        updateStatsForGet(regionEntry, value != null && !Token.isInvalid(value));
-      return v;
+      return value;
-      IllegalArgumentException iae = new IllegalArgumentException(LocalizedStrings.DONT_RELEASE
-          .toLocalizedString("Error while deserializing value for key=" + re.getKey()));
-      iae.initCause(i);
-      throw iae;
+      throw new IllegalArgumentException(LocalizedStrings.DONT_RELEASE
+          .toLocalizedString("Error while deserializing value for key=" + regionEntry.getKey()), i);
-  /*
-   * @see BucketRegion#getSerialized(KeyInfo, boolean, boolean)
+  /**
+   * @see BucketRegion#getSerialized(KeyInfo, boolean, boolean, ClientProxyMembershipID,
+   *      EntryEventImpl, boolean)
-  public Object getRetained(Object key, Object aCallbackArgument, boolean generateCallbacks,
+  private Object getRetained(Object key, Object aCallbackArgument, boolean generateCallbacks,
-  final public void recordMiss(final RegionEntry re, Object key) {
+  public void recordMiss(final RegionEntry re, Object key) {
-   * @param keyInfo
-   * @param p_isCreate true if call found no entry; false if updating an existing entry
-   * @param generateCallbacks
-   * @param p_localValue the value retrieved from the region for this object.
+   * @param isCreate true if call found no entry; false if updating an existing entry
+   * @param localValue the value retrieved from the region for this object.
-  Object nonTxnFindObject(KeyInfo keyInfo, boolean p_isCreate, boolean generateCallbacks,
-      Object p_localValue, boolean disableCopyOnRead, boolean preferCD,
+  Object nonTxnFindObject(KeyInfo keyInfo, boolean isCreate, boolean generateCallbacks,
+      Object localValue, boolean disableCopyOnRead, boolean preferCD,
-    final Object key = keyInfo.getKey();
-    Object localValue = p_localValue;
-    boolean isCreate = p_isCreate;
-    Object[] valueAndVersion = null;
-        valueAndVersion = (Object[]) otherFuture.get();
+        Object[] valueAndVersion = (Object[]) otherFuture.get();
-          RegionEntry re = null;
-            re = basicGetEntry(keyInfo.getKey());
-            updateStatsForGet(re, true);
+            RegionEntry regionEntry = basicGetEntry(keyInfo.getKey());
+            updateStatsForGet(regionEntry, true);
-      } catch (InterruptedException e) {
+      } catch (InterruptedException ignore) {
-        InternalGemFireError err = new InternalGemFireError(
-            LocalizedStrings.LocalRegion_UNEXPECTED_EXCEPTION.toLocalizedString());
-        err.initCause(err);
-        throw err;
+        // NOTE: this was creating InternalGemFireError and initCause with itself
+        throw new InternalGemFireError(
+            LocalizedStrings.LocalRegion_UNEXPECTED_EXCEPTION.toLocalizedString(), e);
-        // This code was moved from PartitionedRegion.nonTxnFindObject(). That method has been
-        // removed.
-        // because
-        // it can invoke code that is transactional.
+        // because it can invoke code that is transactional.
-        VersionTag tag = (clientEvent == null) ? null : clientEvent.getVersionTag();
+        VersionTag tag = clientEvent == null ? null : clientEvent.getVersionTag();
-  protected Object conditionalCopy(Object o) {
+  Object conditionalCopy(Object o) {
+  @Override
-  // public String getFullPath() {
-  // // work way up to root region, prepending
-  // // the region names to a buffer
-  // StringBuffer buf = new StringBuffer(SEPARATOR);
-  // Assert.assertTrue(this.regionName != null);
-  // buf.append(this.regionName);
-  // LocalRegion r = this;
-  // while ((r = r.parentRegion) != null) {
-  // buf.insert(0, r.regionName);
-  // buf.insert(0, SEPARATOR_CHAR);
-  // }
-  // return buf.toString();
-  // }
-
+  @Override
-    // checkReadiness();
+  @Override
+  @Override
+  @Override
-  public final Object validatedPut(EntryEventImpl event, long startPut)
+  Object validatedPut(EntryEventImpl event, long startPut)
-      event.setNewEventId(cache.getDistributedSystem());
+      event.setNewEventId(this.cache.getDistributedSystem());
-  public final EntryEventImpl newUpdateEntryEvent(Object key, Object value,
-      Object aCallbackArgument) {
+  EntryEventImpl newUpdateEntryEvent(Object key, Object value, Object aCallbackArgument) {
-      boolean extractDelta = false;
-      if (this.getSystem().getConfig().getDeltaPropagation()
-          && value instanceof org.apache.geode.Delta) {
+      if (getSystem().getConfig().getDeltaPropagation() && value instanceof Delta) {
+        boolean extractDelta = false;
-          if ((this instanceof PartitionedRegion)) {
+          if (this instanceof PartitionedRegion) {
-                if (this.getSystem().getMemberId().equals(ids.getId())) {
-                  extractDelta = hasAdjunctRecipientsNeedingDelta(event);
-                } else {
-                  extractDelta = true;
-                }
+                extractDelta = !this.getSystem().getMemberId().equals(ids.getId())
+                    || hasAdjunctRecipientsNeedingDelta(event);
-          } else if ((this instanceof DistributedRegion)
+          } else if (this instanceof DistributedRegion
-              && ((DistributedRegion) this).getCacheDistributionAdvisor().adviseCacheOp()
-                  .size() > 0) {
+              && !((CacheDistributionAdvisee) this).getCacheDistributionAdvisor().adviseCacheOp()
+                  .isEmpty()) {
-    PartitionedRegion pr = ((PartitionedRegion) this);
-    BucketRegion br = null;
-    FilterRoutingInfo filterRouting = null;
-    Set twoMessages = Collections.EMPTY_SET;
-    Set adjunctRecipients = Collections.EMPTY_SET;
-    Set cacheservers = null;
+    PartitionedRegion partitionedRegion = (PartitionedRegion) this;
+    BucketRegion bucketRegion;
-      br = pr.dataStore.getInitializedBucketForId(event.getKey(), bId);
-    } catch (ForceReattemptException fre) {
+      bucketRegion = partitionedRegion.dataStore.getInitializedBucketForId(event.getKey(), bId);
+    } catch (ForceReattemptException ignore) {
-        br.getCacheDistributionAdvisor().adviseUpdate(event);
-    twoMessages = br.getBucketAdvisor().adviseRequiresTwoMessages();
-    CacheDistributionAdvisor cda = pr.getCacheDistributionAdvisor();
-    filterRouting = cda.adviseFilterRouting(event, recipients);
-    adjunctRecipients = br.getAdjunctReceivers(event, recipients, twoMessages, filterRouting);
-    cacheservers = cda.adviseCacheServers();
-    return !Collections.disjoint(adjunctRecipients, cacheservers);
+        bucketRegion.getCacheDistributionAdvisor().adviseUpdate(event);
+    Set<Object> twoMessages = bucketRegion.getBucketAdvisor().adviseRequiresTwoMessages();
+    CacheDistributionAdvisor cda = partitionedRegion.getCacheDistributionAdvisor();
+    FilterRoutingInfo filterRouting = cda.adviseFilterRouting(event, recipients);
+    Set<Object> adjunctRecipients =
+        bucketRegion.getAdjunctReceivers(event, recipients, twoMessages, filterRouting);
+    Set cacheServerMembers = cda.adviseCacheServers();
+    return !Collections.disjoint(adjunctRecipients, cacheServerMembers);
+  @Override
-   * @param key
-    RegionMap rm;
+      RegionMap regionMap;
-          && (rm = this.diskRegion.getRecoveredEntryMap()) != null && (size = rm.size()) > 0) {
+          && (regionMap = this.diskRegion.getRecoveredEntryMap()) != null
+          && (size = regionMap.size()) > 0) {
-      if ((rm = getRegionMap()) != null) {
-        return rm.size();
+      if ((regionMap = getRegionMap()) != null) {
+        return regionMap.size();
-   * @param keyInfo
-   * @return TODO
-    boolean miss = (re == null || re.isDestroyedOrRemoved());
+    boolean miss = re == null || re.isDestroyedOrRemoved();
-    Region.Entry ren = new NonTXEntry(re);
-    // long start=0, end=0;
-    // start = System.currentTimeMillis();
-    // end = System.currentTimeMillis();
-    // System.out.println("getEntry: " + (end-start));
-    return ren;
+    return new NonTXEntry(re);
-  public boolean isThisRegionBeingClosedOrDestroyed() {
+  boolean isThisRegionBeingClosedOrDestroyed() {
+  @Override
+
-    // boolean result = false;
+
-    // if (!isInitialized()) { // don't return true if still initializing
-    // if (finestEnabled) {
-    // log.finest("isDestroyed: false, not initialized: " + getFullPath());
-    // }
-    // return false;
-    // }
-    // @todo we could check parents here if we want this to be more accurate,
-    // and the isDestroyed field could be made volatile as well.
-    // if (this.parentRegion != null) return this.parentRegion.isDestroyed();
+
-  protected Set basicSubregions(boolean recursive) {
+  Set basicSubregions(boolean recursive) {
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
-        if (entry == null) {
-          return false;
-        } else {
-          return (entry.getValue() == Token.TOMBSTONE);
-        }
-      } catch (EntryDestroyedException e) {
+        return entry != null && entry.getValue() == Token.TOMBSTONE;
+      } catch (EntryDestroyedException ignore) {
-      RegionEntry re = this.entries.getEntry(keyInfo.getKey());
-      // TODO:KIRK:OK if (re == null || Token.isRemoved(re.getValueInVM(this))) {
-      if (re == null || re.isDestroyedOrRemoved()) {
+      RegionEntry regionEntry = this.entries.getEntry(keyInfo.getKey());
+      if (regionEntry == null || regionEntry.isDestroyedOrRemoved()) {
+  @Override
-  /**
-   * @param keyInfo
-   * @return TODO
-   */
-        Object val = entry.getTransformedValue(); // no need to decompress since we only want to
-                                                  // know if we have an existing value
+        // no need to decompress since we only want to know if we have an existing value
+        Object val = entry.getTransformedValue();
+  @Override
-    // checkReadiness();
+  @Override
-   *
-   *      author David Whitlock
-  public final int entryCount() {
+  public int entryCount() {
-  public int entryCountEstimate(final TXStateInterface tx, Set<Integer> buckets,
-      boolean entryCountEstimate) {
-    return entryCount(buckets, entryCountEstimate);
-  }
-
-   * Returns the <code>DiskRegion</code> that this region uses to access data on disk.
+   * Returns the {@code DiskRegion} that this region uses to access data on disk.
-   * @return <code>null</code> if disk regions are not being used
+   * @return {@code null} if disk regions are not being used
+  @Override
-  /**
-   *
-   * Initially called by EvictorThread.run
-   *
-   * @since GemFire 3.5.1
-   */
-  public void checkLRU() {
-    if (this.entriesInitialized) {
-      try {
-        this.entries.lruUpdateCallback();
-      } catch (DiskAccessException dae) {
-        this.handleDiskAccessException(dae);
-        throw dae;
-      }
-    }
-  }
-
-  protected boolean isOverflowEnabled() {
+  private boolean isOverflowEnabled() {
+  @Override
+  @Override
+  @Override
+  @Override
-  protected void validatedInvalidate(Object key, Object aCallbackArgument)
+  void validatedInvalidate(Object key, Object aCallbackArgument)
-        event.setNewEventId(cache.getDistributedSystem());
+        event.setNewEventId(this.cache.getDistributedSystem());
+  @Override
-      event.setNewEventId(cache.getDistributedSystem());
+      event.setNewEventId(this.cache.getDistributedSystem());
+  @Override
+  @Override
-
-  public void localInvalidate(Object key, Object callbackArgument) throws EntryNotFoundException {
+  @Override
+  public void localInvalidate(Object key, Object aCallbackArgument) throws EntryNotFoundException {
-        null/* newValue */, callbackArgument, false, getMyId());
+        null/* newValue */, aCallbackArgument, false, getMyId());
-        event.setNewEventId(cache.getDistributedSystem());
+        event.setNewEventId(this.cache.getDistributedSystem());
+  @Override
-  public static LocalRegion getRegionFromPath(DistributedSystem system, String path) {
-    Cache c = GemFireCacheImpl.getInstance();
-    if (c == null) {
+  static LocalRegion getRegionFromPath(DistributedSystem system, String path) {
+    Cache cache = GemFireCacheImpl.getInstance();
+    if (cache == null) {
-      return (LocalRegion) c.getRegion(path);
+      return (LocalRegion) cache.getRegion(path);
-  // public void dumpEntryMapStats(PrintStream out) {
-  // ((ConcurrentHashMap)this.entries).dumpStats(out);
-  // }
-
-  ////////////////// Protected Methods ////////////////////////////////////////
-
-   * @param internalRegionArgs
-        cache.getInternalResourceManager().addResourceListener(ResourceType.MEMORY, this);
+        this.cache.getInternalResourceManager().addResourceListener(ResourceType.MEMORY, this);
-          { // This block was added so that early recovery could figure out that
-            // this data needs to be recovered from disk. Local regions used to
-            // not bother assigning a memberId but that is what the early
-            // recovery
-            // code uses to figure out that a region needs to be recovered.
-            PersistentMemberID oldId = this.diskRegion.getMyInitializingID();
-            if (oldId == null) {
-              oldId = this.diskRegion.getMyPersistentID();
-            }
-            if (oldId == null) {
-              PersistentMemberID newId = this.diskRegion.generatePersistentID();
-              this.diskRegion.setInitializing(newId);
-              this.diskRegion.setInitialized();
-            }
+          // This block was added so that early recovery could figure out that
+          // this data needs to be recovered from disk. Local regions used to
+          // not bother assigning a memberId but that is what the early
+          // recovery
+          // code uses to figure out that a region needs to be recovered.
+          PersistentMemberID oldId = this.diskRegion.getMyInitializingID();
+          if (oldId == null) {
+            oldId = this.diskRegion.getMyPersistentID();
+          }
+          if (oldId == null) {
+            PersistentMemberID newId = this.diskRegion.generatePersistentID();
+            this.diskRegion.setInitializing(newId);
+            this.diskRegion.setInitialized();
+
+
-    } catch (RegionDestroyedException e) {
+    } catch (RegionDestroyedException ignore) {
-  protected void createOQLIndexes(InternalRegionArguments internalRegionArgs) {
+  void createOQLIndexes(InternalRegionArguments internalRegionArgs) {
-  protected void createOQLIndexes(InternalRegionArguments internalRegionArgs,
-      boolean recoverFromDisk) {
+  void createOQLIndexes(InternalRegionArguments internalRegionArgs, boolean recoverFromDisk) {
-        || internalRegionArgs.getIndexes().size() == 0) {
+        || internalRegionArgs.getIndexes().isEmpty()) {
-    Set<Index> indexes = new HashSet<Index>();
-    Set<Index> prIndexes = new HashSet<Index>();
-    int initLevel = 0;
+    Set<Index> indexes = new HashSet<Index>();
+    Set<Index> prIndexes = new HashSet<>();
+    int initLevel = 0;
-            DefaultQueryService qs =
-                (DefaultQueryService) this.getGemFireCache().getLocalQueryService();
+            DefaultQueryService qs = (DefaultQueryService) getGemFireCache().getLocalQueryService();
-                (icd.getIndexType() == IndexType.FUNCTIONAL || icd.getIndexType() == IndexType.HASH)
+                icd.getIndexType() == IndexType.FUNCTIONAL || icd.getIndexType() == IndexType.HASH
-            InternalGemFireError err =
-                new InternalGemFireError(LocalizedStrings.GemFireCache_INDEX_CREATION_EXCEPTION_1
-                    .toLocalizedString(new Object[] {icd.getIndexName(), this.getFullPath()}));
-            err.initCause(ex);
-            throw err;
+            throw new InternalGemFireError(LocalizedStrings.GemFireCache_INDEX_CREATION_EXCEPTION_1
+                .toLocalizedString(icd.getIndexName(), this.getFullPath()), ex);
-  protected void populateOQLIndexes(Set<Index> indexes) {
+  private void populateOQLIndexes(Set<Index> indexes) {
-  protected void releaseBeforeGetInitialImageLatch() {
+  void releaseBeforeGetInitialImageLatch() {
-  protected final void releaseAfterGetInitialImageLatch() {
+  final void releaseAfterGetInitialImageLatch() {
-    StoppableCountDownLatch l = this.afterRegionCreateEventLatch;
-    if (l != null && l.getCount() == 0) {
+    StoppableCountDownLatch latch = this.afterRegionCreateEventLatch;
+    if (latch != null && latch.getCount() == 0) {
-    waitOnInitialization(l);
+    waitOnInitialization(latch);
-  private void recursiveDestroyRegion(Set eventSet, RegionEventImpl p_event, boolean cacheWrite)
+  private void recursiveDestroyRegion(Set eventSet, RegionEventImpl regionEvent, boolean cacheWrite)
-    RegionEventImpl event = p_event;
-    final boolean isClose = event.getOperation().isClose();
+    final boolean isClose = regionEvent.getOperation().isClose();
-        cacheWriteBeforeRegionDestroy(event);
+        cacheWriteBeforeRegionDestroy(regionEvent);
-        if (!cache.forcedDisconnect()) {
+        if (!this.cache.forcedDisconnect()) {
-    cache.getInternalResourceManager(false).removeResourceListener(this);
+    this.cache.getInternalResourceManager(false).removeResourceListener(this);
-    if (eventSet != null) { // && hasListener())
-      eventSet.add(event);
+    if (eventSet != null) {
+      eventSet.add(regionEvent);
-        Object element = itr.next(); // element is a LocalRegion
-        LocalRegion rgn;
+        // element is a LocalRegion
+        Object element = itr.next();
+        LocalRegion region;
-            rgn = toRegion(element); // converts to a LocalRegion
+            // converts to a LocalRegion
+            region = toRegion(element);
-        } catch (CancelException e) {
-          rgn = (LocalRegion) element; // ignore, keep going through the motions though
-        } catch (RegionDestroyedException rde) {
+        } catch (CancelException ignore) {
+          // ignore, keep going through the motions though
+          region = (LocalRegion) element;
+        } catch (RegionDestroyedException ignore) {
-        if (rgn.isDestroyed) {
+        if (region.isDestroyed) {
-        /** ** BEGIN operating on subregion of this region (rgn) *** */
+        // BEGIN operating on subregion of this region (rgn)
-          event = (RegionEventImpl) event.clone();
-          event.region = rgn;
+          regionEvent = (RegionEventImpl) regionEvent.clone();
+          regionEvent.region = region;
-          rgn.recursiveDestroyRegion(eventSet, event, cacheWrite);
-          if (!rgn.isInternalRegion()) {
-            InternalDistributedSystem system = rgn.cache.getInternalDistributedSystem();
-            system.handleResourceEvent(ResourceEvent.REGION_REMOVE, rgn);
+          region.recursiveDestroyRegion(eventSet, regionEvent, cacheWrite);
+          if (!region.isInternalRegion()) {
+            InternalDistributedSystem system = region.cache.getInternalDistributedSystem();
+            system.handleResourceEvent(ResourceEvent.REGION_REMOVE, region);
-          if (!cache.forcedDisconnect()) {
+          if (!this.cache.forcedDisconnect()) {
-                rgn.getFullPath()), e);
+                region.getFullPath()), e);
-        /** ** END operating on subregion of this region *** */
+        // END operating on subregion of this region
-        if (!cache.forcedDisconnect()) {
+        if (!this.cache.forcedDisconnect()) {
-      if (event.isReinitializing()) {
+      if (regionEvent.isReinitializing()) {
-        postDestroyRegion(!isClose, event);
+        postDestroyRegion(!isClose, regionEvent);
-  public void checkEntryNotFound(Object entryKey) {
+  void checkEntryNotFound(Object entryKey) {
-   * @param returnTombstones TODO
-   * @see LocalRegion#findObjectInSystem(KeyInfo, boolean, TXStateInterface, boolean, Object,
-   *      boolean, boolean, ClientProxyMembershipID, EntryEventImpl, boolean)
+
-    {
-      ServerRegionProxy mySRP = getServerProxy();
-      if (mySRP != null) {
-        holder = new VersionTagHolder();
-        value = mySRP.get(key, aCallbackArgument, holder);
-        fromServer = value != null;
-      }
+    ServerRegionProxy mySRP = getServerProxy();
+    if (mySRP != null) {
+      holder = new VersionTagHolder();
+      value = mySRP.get(key, aCallbackArgument, holder);
+      fromServer = value != null;
-            loaderHelperFactory.createLoaderHelper(key, aCallbackArgument,
+            this.loaderHelperFactory.createLoaderHelper(key, aCallbackArgument,
-          event.setNewEventId(cache.getDistributedSystem());
+          event.setNewEventId(this.cache.getDistributedSystem());
-            if (fromServer && (event.getRawNewValue() == Token.TOMBSTONE)) {
+            if (fromServer && event.getRawNewValue() == Token.TOMBSTONE) {
-          } catch (ConcurrentCacheModificationException e) {
+          } catch (ConcurrentCacheModificationException ignore) {
-   * @param key
-   * @param event
-  protected boolean alreadyInvalid(Object key, EntryEventImpl event) {
+  private boolean alreadyInvalid(Object key, EntryEventImpl event) {
-  protected boolean bridgeWriteBeforeDestroy(EntryEventImpl event, Object expectedOldValue)
+  boolean bridgeWriteBeforeDestroy(EntryEventImpl event, Object expectedOldValue)
-  protected void serverRegionDestroy(RegionEventImpl regionEvent) {
+  void serverRegionDestroy(RegionEventImpl regionEvent) {
-  protected void serverRegionClear(RegionEventImpl regionEvent) {
+  private void serverRegionClear(RegionEventImpl regionEvent) {
-  protected void serverRegionInvalidate(RegionEventImpl regionEvent) {
-    if (regionEvent.getOperation().isDistributed()) {
-      ServerRegionProxy mySRP = getServerProxy();
-      if (mySRP != null) {
-        // @todo grid: add a client to server Op message for this
-      }
-    }
-  }
-
-  /**
-   * @since GemFire 5.7
-   */
-  protected void serverPut(EntryEventImpl event, boolean requireOldValue, Object expectedOldValue) {
+  void serverPut(EntryEventImpl event, boolean requireOldValue, Object expectedOldValue) {
-        // @todo grid: is the newEntry flag needed?
+        // TODO: is the newEntry flag needed?
+
-        // bug #42296, serverproxy returns null when cache is closing
+
+        // bug #42296, serverProxy returns null when cache is closing
-              throw new EntryNotFoundException("entry existed for putIfAbsent"); // customers don't
-                                                                                 // see this
-                                                                                 // exception
+              // customers don't see this exception
+              throw new EntryNotFoundException("entry existed for putIfAbsent");
-              if (!((Boolean) result).booleanValue()) {
-                throw new EntryNotFoundException("entry found with wrong value"); // customers don't
-                                                                                  // see this
-                                                                                  // exception
+              if (!(Boolean) result) {
+                // customers don't see this exception
+                throw new EntryNotFoundException("entry found with wrong value");
-  protected void serverDestroy(EntryEventImpl event, Object expectedOldValue) {
+  void serverDestroy(EntryEventImpl event, Object expectedOldValue) {
-  protected boolean cacheWriteBeforeRegionClear(RegionEventImpl event)
+  private void cacheWriteBeforeRegionClear(RegionEventImpl event)
-    boolean result = false;
-      result = true;
-    return result;
-  /**
-   * @see DistributedRegion#cacheWriteBeforePut(EntryEventImpl, Set, CacheWriter, boolean, Object)
-   * @param event
-   * @param netWriteRecipients
-   * @param localWriter
-   * @param requireOldValue
-   * @param expectedOldValue
-   * @throws CacheWriterException
-   * @throws TimeoutException
-   */
-    Operation op = event.getOperation();
-    if (!(op == Operation.PUT_IF_ABSENT || op == Operation.REPLACE) && (localWriter != null)
-        && !((EntryEventImpl) event).inhibitAllNotifications()) {
+    Operation operation = event.getOperation();
+    boolean isPutIfAbsentOrReplace =
+        operation == Operation.PUT_IF_ABSENT || operation == Operation.REPLACE;
+    if (!isPutIfAbsentOrReplace && localWriter != null && !event.inhibitAllNotifications()) {
-  protected void validateKey(Object key) {
+  void validateKey(Object key) {
-            LocalizedStrings.LocalRegion_KEY_0_DOES_NOT_SATISFY_KEYCONSTRAINT_1.toLocalizedString(
-                new Object[] {key.getClass().getName(), this.keyConstraint.getName()}));
+            LocalizedStrings.LocalRegion_KEY_0_DOES_NOT_SATISFY_KEYCONSTRAINT_1
+                .toLocalizedString(key.getClass().getName(), this.keyConstraint.getName()));
-   * Starting in 3.5, we don't check to see if the callback argument is <code>Serializable</code>.
-   * We instead rely on the actual serialization (which happens in-thread with the put) to tell us
-   * if there are any problems.
+   * Starting in 3.5, we don't check to see if the callback argument is {@code Serializable}. We
+   * instead rely on the actual serialization (which happens in-thread with the put) to tell us if
+   * there are any problems. TODO: delete method validateCallbackArg
-  protected void validateCallbackArg(Object aCallbackArgument) {
-
+  void validateCallbackArg(Object aCallbackArgument) {
+    // do nothing
-  private final boolean DO_EXPENSIVE_VALIDATIONS =
+  private final boolean doExpensiveValidations =
-  protected AtomicInteger tombstoneCount = new AtomicInteger();
+  private final AtomicInteger tombstoneCount = new AtomicInteger();
-   * Starting in 3.5, we don't check to see if the value is <code>Serializable</code>. We instead
-   * rely on the actual serialization (which happens in-thread with the put) to tell us if there are
-   * any problems.
+   * Starting in 3.5, we don't check to see if the value is {@code Serializable}. We instead rely on
+   * the actual serialization (which happens in-thread with the put) to tell us if there are any
+   * problems.
-  protected void validateValue(Object p_value) {
-    Object value = p_value;
-
+  private void validateValue(Object value) {
-          if (DO_EXPENSIVE_VALIDATIONS) {
+          if (this.doExpensiveValidations) {
-              Object type = (String) pdx.getField("@type");
+              Object type = pdx.getField("@type");
-                  .toLocalizedString(
-                      new Object[] {valueClassName, this.valueConstraint.getName()}));
+                  .toLocalizedString(valueClassName, this.valueConstraint.getName()));
+  @Override
-  public void incTombstoneCount(int delta) {
+  void incTombstoneCount(int delta) {
-  public void scheduleTombstone(RegionEntry entry, VersionTag destroyedVersion) {
+  void scheduleTombstone(RegionEntry entry, VersionTag destroyedVersion) {
-  public void scheduleTombstone(RegionEntry entry, VersionTag destroyedVersion,
+  private void scheduleTombstone(RegionEntry entry, VersionTag destroyedVersion,
-    // Object sync = TombstoneService.DEBUG_TOMBSTONE_COUNT? TombstoneService.debugSync : new
-    // Object();
-    // lastUnscheduled.set(null);
-    // synchronized(sync) {
+
-    // if (entry instanceof AbstractRegionEntry) {
-    // AbstractRegionEntry are = (AbstractRegionEntry)entry;
-    // if (are.isTombstoneScheduled()) {
-    // log.severe(LocalizedStrings.DEBUG, "Scheduling a tombstone for an entry that is already a
-    // tombstone: " + entry, new Exception("stack trace"));
-    // throw new IllegalStateException("Attempt to schedule a tombstone for a destroyed entry that
-    // is already scheduled for expiration");
-    // }
-    // are.setTombstoneScheduled(true);
-    // }
+
-    // }
-  // ThreadLocal<RegionEntry> lastUnscheduled = new ThreadLocal<RegionEntry>();
-  // ThreadLocal<Exception> lastUnscheduledPlace = new ThreadLocal<Exception>();
-
-  public void rescheduleTombstone(RegionEntry entry, VersionTag version) {
+  void rescheduleTombstone(RegionEntry entry, VersionTag version) {
-  public void unscheduleTombstone(RegionEntry entry) {
+  void unscheduleTombstone(RegionEntry entry) {
-    Set<Object> keys = null;
+    Set<Object> keys = null;
-
-
-      Assert.assertTrue(this.entries.size() == 0,
+      Assert.assertTrue(this.entries.isEmpty(),
-  protected void validateSubregionAttributes(RegionAttributes attrs) {
+  private void validateSubregionAttributes(RegionAttributes attrs) {
-   * value does not reside in the VM because it has been overflowed to disk, <code>null</code> will
-   * be returned. This method is intended for testing.testing purposes only.
+   * value does not reside in the VM because it has been overflowed to disk, {@code null} will be
+   * returned. This method is intended for testing.testing purposes only.
-   * @throws EntryNotFoundException No entry with <code>key</code> exists
+   * @throws EntryNotFoundException No entry with {@code key} exists
-    return basicGetValueInVM(key, true/* rememberRead */);
+    return basicGetValueInVM(key, true);
-    return basicGetValueInVM(event.getKey(), true/* rememberRead */);
+    return basicGetValueInVM(event.getKey(), true);
-  /**
-   * @param keyInfo
-   * @return TODO
-   */
-  protected Object nonTXbasicGetValueInVM(KeyInfo keyInfo) {
-    RegionEntry re = this.entries.getEntry(keyInfo.getKey());
-    if (re == null) {
+  Object nonTXbasicGetValueInVM(KeyInfo keyInfo) {
+    RegionEntry regionEntry = this.entries.getEntry(keyInfo.getKey());
+    if (regionEntry == null) {
-    Object v = re.getValueInVM(this); // OFFHEAP returned to callers
-    if (Token.isRemoved(v)) {
+    // OFFHEAP returned to callers
+    Object value = regionEntry.getValueInVM(this);
+    if (Token.isRemoved(value)) {
-    if (v == Token.NOT_AVAILABLE) {
+    if (value == Token.NOT_AVAILABLE) {
-    return v;
+    return value;
-    if (!isTX())
+    if (!isTX()) {
+    }
-      return Collections.EMPTY_SET;
+      return Collections.emptySet();
-      return Collections.EMPTY_SET;
+      return Collections.emptySet();
-   * be read from disk, it is <b>not </b> stored into the entry in the VM. This method is intended
+   * be read from disk, it is <b>not</b> stored into the entry in the VM. This method is intended
-   * @throws EntryNotFoundException No entry with <code>key</code> exists
+   * @throws EntryNotFoundException No entry with {@code key} exists
-   * 
-   * @param key
-   * @return Object
-   * @throws EntryNotFoundException
-   * Get the serialized bytes from disk. This method only looks for the value on the disk, ignoring
-   * heap data. This method is intended for testing purposes only.
-   * 
-   * @param key the object whose hashCode is used to find the value
-   * @return either a byte array, a CacheDeserializable with the serialized value, or null if the
-   *         entry exists but no value data exists.
-   * @throws IllegalStateException when the region is not persistent
-   * @throws EntryNotFoundException if there is no entry for the given key
-   * @since GemFire 5.7
-   */
-  public Object getSerializedValueOnDisk(Object key) throws EntryNotFoundException {
-    // Ok for this to ignore tx state
-    RegionEntry re = this.entries.getEntry(key);
-    if (re == null) {
-      throw new EntryNotFoundException(key.toString());
-    }
-    Object result = re.getSerializedValueOnDisk(this);
-    if (Token.isInvalid(result)) {
-      result = null;
-    } else if (Token.isRemoved(result)) {
-      throw new EntryNotFoundException(key.toString());
-    }
-    return result;
-  }
-
-  /**
-   * @throws EntryNotFoundException No entry with <code>key</code> exists
+   * @throws EntryNotFoundException No entry with {@code key} exists
-  public Object getNoLRU(Object k, boolean adamant, boolean allowTombstone,
-      boolean serializedFormOkay) {
-    Object o = null;
+  Object getNoLRU(Object key, boolean adamant, boolean allowTombstone, boolean serializedFormOkay) {
+    Object value = null;
-      o = getValueInVM(k); // OFFHEAP deserialize
-      if (o == null) {
+      value = getValueInVM(key); // OFFHEAP deserialize
+      if (value == null) {
-        o = getValueOnDiskOrBuffer(k);
-        if (o == null) {
+        value = getValueOnDiskOrBuffer(key);
+        if (value == null) {
-          o = getValueInVM(k); // OFFHEAP deserialize
-          if (o == null) {
+          value = getValueInVM(key); // OFFHEAP deserialize
+          if (value == null) {
-              o = get(k);
+              value = get(key);
-            if (!serializedFormOkay && (o instanceof CachedDeserializable)) {
-              o = ((CachedDeserializable) o).getDeserializedValue(this, getRegionEntry(k));
+            if (!serializedFormOkay && value instanceof CachedDeserializable) {
+              value =
+                  ((CachedDeserializable) value).getDeserializedValue(this, getRegionEntry(key));
-        if (!serializedFormOkay && (o instanceof CachedDeserializable)) {
-          o = ((CachedDeserializable) o).getDeserializedValue(this, getRegionEntry(k));
+        if (!serializedFormOkay && value instanceof CachedDeserializable) {
+          value = ((CachedDeserializable) value).getDeserializedValue(this, getRegionEntry(key));
-    } catch (EntryNotFoundException ok) {
+    } catch (EntryNotFoundException ignore) {
-    if (o == Token.TOMBSTONE && !allowTombstone) {
-      o = null;
+    if (value == Token.TOMBSTONE && !allowTombstone) {
+      value = null;
-    return o;
+    return value;
+  @Override
-      for (Iterator itr = entrySet(false).iterator(); itr.hasNext();) {
-        Region.Entry entry = (Region.Entry) itr.next();
+      for (Object entryObject : entrySet(false)) {
+        Entry entry = (Entry) entryObject;
-          if (value == null) { // fix for bug 33311
-            LocalRegion.NonTXEntry lre = (LocalRegion.NonTXEntry) entry;
+          if (value == null) {
+            // fix for bug 33311
+            NonTXEntry lre = (NonTXEntry) entry;
-            value = re.getValue(this); // OFFHEAP: incrc, copy info heap cd for serialization, decrc
+            // OFFHEAP: incrc, copy info heap cd for serialization, decrc
+            value = re.getValue(this);
-        } catch (EntryDestroyedException e) {
+        } catch (EntryDestroyedException ignore) {
-  public void loadSnapshot4ConvertTo65(InputStream inputStream)
-      throws CacheWriterException, TimeoutException, ClassNotFoundException, IOException {
-    isConversion.set(Boolean.valueOf(true));
-    try {
-      loadSnapshot(inputStream);
-    } finally {
-      isConversion.remove();
-    }
-  }
-
+  @Override
+  @Override
+  @Override
+  @Override
-      cache.registerInterestStarted();
+      this.cache.registerInterestStarted();
-      } catch (InterruptedException e) {
+      } catch (InterruptedException ignore) {
+
-      cache.registerInterestCompleted();
+      this.cache.registerInterestCompleted();
-  // TODO this is distressingly similar to code in the client.internal package
-  private void processSingleInterest(Object key, int interestType, InterestResultPolicy pol,
-      boolean isDurable, boolean receiveUpdatesAsInvalidates) {
+  // TODO: this is distressingly similar to code in the client.internal package
+  private void processSingleInterest(Object key, int interestType,
+      InterestResultPolicy interestResultPolicy, boolean isDurable,
+      boolean receiveUpdatesAsInvalidates) {
-    if (key == null)
+    if (key == null) {
+    }
+
+
-      List serverKeys;
-
-      this.clearKeysOfInterest(key, interestType, pol);
+      this.clearKeysOfInterest(key, interestType, interestResultPolicy);
+
+      List serverKeys;
+
-          serverKeys = proxy.registerInterest(key, interestType, pol, isDurable,
+          serverKeys = proxy.registerInterest(key, interestType, interestResultPolicy, isDurable,
+
-
-
-            serverKeys = proxy.registerInterest(".*", InterestType.REGULAR_EXPRESSION, pol,
-                isDurable, receiveUpdatesAsInvalidates, regionDataPolicy);
+            serverKeys = proxy.registerInterest(".*", InterestType.REGULAR_EXPRESSION,
+                interestResultPolicy, isDurable, receiveUpdatesAsInvalidates, regionDataPolicy);
-              serverKeys = proxy.registerInterestList((List) key, pol, isDurable,
+              serverKeys = proxy.registerInterestList((List) key, interestResultPolicy, isDurable,
-              serverKeys = proxy.registerInterest(key, InterestType.KEY, pol, isDurable,
-                  receiveUpdatesAsInvalidates, regionDataPolicy);
+              serverKeys = proxy.registerInterest(key, InterestType.KEY, interestResultPolicy,
+                  isDurable, receiveUpdatesAsInvalidates, regionDataPolicy);
+
-          serverKeys = proxy.registerInterest(key, InterestType.OQL_QUERY, pol, isDurable,
-              receiveUpdatesAsInvalidates, regionDataPolicy);
+          serverKeys = proxy.registerInterest(key, InterestType.OQL_QUERY, interestResultPolicy,
+              isDurable, receiveUpdatesAsInvalidates, regionDataPolicy);
+
-          Pattern.compile(regex);
-          serverKeys = proxy.registerInterest(regex, InterestType.REGULAR_EXPRESSION, pol,
-              isDurable, receiveUpdatesAsInvalidates, regionDataPolicy);
+          Pattern.compile(regex); // TODO: result of Pattern.compile is ignored
+          serverKeys = proxy.registerInterest(regex, InterestType.REGULAR_EXPRESSION,
+              interestResultPolicy, isDurable, receiveUpdatesAsInvalidates, regionDataPolicy);
+
+
-        refreshEntriesFromServerKeys(null, serverKeys, pol);
-
+        refreshEntriesFromServerKeys(null, serverKeys, interestResultPolicy);
+
+
+
+
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
-  public void registerInterestFilter(String className) {
-    registerInterestFilter(className, false);
-  }
-
-  public void registerInterestFilter(String className, boolean isDurable) {
+  private void registerInterestFilter(String className, boolean isDurable) {
-  public void registerInterestFilter(String className, boolean isDurable, boolean receiveValues) {
+  private void registerInterestFilter(String className, boolean isDurable, boolean receiveValues) {
-  public void registerInterestOQL(String query) {
-    registerInterestOQL(query, false);
-  }
-
-  public void registerInterestOQL(String query, boolean isDurable) {
+  private void registerInterestOQL(String query, boolean isDurable) {
-  public void registerInterestOQL(String query, boolean isDurable, boolean receiveValues) {
+  private void registerInterestOQL(String query, boolean isDurable, boolean receiveValues) {
+  @Override
+  @Override
+  @Override
-    Set ret = null;
+    Set ret;
+
-        for (Iterator it = this.keySet(allowTombstones).iterator(); it.hasNext();) {
-          Object entryKey = it.next();
+        for (Object entryKey : this.keySet(allowTombstones)) {
+
-          if (this.containsKey(entryKey) || (allowTombstones && this.containsTombstone(entryKey))) {
+          if (this.containsKey(entryKey) || allowTombstones && this.containsTombstone(entryKey)) {
+
+
+
-          .toLocalizedString(Integer.valueOf(interestType)));
+          .toLocalizedString(interestType));
-  public List getInterestListRegex() {
+  @Override
+  public List<String> getInterestListRegex() {
-  public List getInterestListFilters() {
-    ServerRegionProxy proxy = getServerProxy();
-    if (proxy != null) {
-      return proxy.getInterestList(InterestType.FILTER_CLASS);
-    } else {
-      throw new UnsupportedOperationException(
-          LocalizedStrings.LocalRegion_INTEREST_LIST_RETRIEVAL_REQUIRES_A_POOL.toLocalizedString());
-    }
-  }
-
-  public List getInterestListOQL() {
-    ServerRegionProxy proxy = getServerProxy();
-    if (proxy != null) {
-      return proxy.getInterestList(InterestType.OQL_QUERY);
-    } else {
-      throw new UnsupportedOperationException(
-          LocalizedStrings.LocalRegion_INTEREST_LIST_RETRIEVAL_REQUIRES_A_POOL.toLocalizedString());
-    }
-  }
-
+  @Override
+  @Override
-   *
-   * @param key
-   * @see DistributedRegion#localDestroyNoCallbacks(Object)
-    } catch (EntryNotFoundException e) {
+    } catch (EntryNotFoundException ignore) {
-    for (Iterator it = this.entrySet(false).iterator(); it.hasNext();) {
-      Region.Entry entry = (Region.Entry) it.next();
+    for (Object entryObject : entrySet(false)) {
+      Entry entry = (Entry) entryObject;
-        for (Iterator it2 = keys.iterator(); it2.hasNext();) {
-          Object k = it2.next();
-          if (entryKey.equals(k)) {
+        for (Object key : keys) {
+          if (entryKey.equals(key)) {
-    // @todo: if (key.equals(".*)) then cmnClearRegionNoCallbacks
+    // TODO: if (key.equals(".*)) then cmnClearRegionNoCallbacks
-        if (!(entryKey instanceof String))
+        if (!(entryKey instanceof String)) {
+        }
-   * @see #registerInterestFilter(String)
-    Class filterClass;
-      filterClass = ClassLoadUtil.classFromName(key);
+      Class filterClass = ClassLoadUtil.classFromName(key);
-    for (Iterator it = this.entrySet(false).iterator(); it.hasNext();) {
-      Region.Entry entry = (Region.Entry) it.next();
+    for (Object entryObject : entrySet(false)) {
+      Entry entry = (Entry) entryObject;
-        if (!(entryKey instanceof String))
+        if (!(entryKey instanceof String)) {
+        }
-   *
-   * @param query
-   * @see #registerInterestOQL(String)
-   * 
-   * @param serverKeys
-      InterestResultPolicy pol) {
+      InterestResultPolicy interestResultPolicy) {
-      logKeys(serverKeys, pol);
+      logKeys(serverKeys, interestResultPolicy);
-    if (pol == InterestResultPolicy.NONE) {
+    if (interestResultPolicy == InterestResultPolicy.NONE) {
-    for (Iterator it = serverKeys.iterator(); it.hasNext();) {
-      ArrayList keysList = (ArrayList) it.next();
+    for (Object serverKey : serverKeys) {
+      ArrayList keysList = (ArrayList) serverKey;
-        ArrayList list = new ArrayList(keysList);
-        if (pol != InterestResultPolicy.KEYS_VALUES) {
-          for (Iterator it2 = keysList.iterator(); it2.hasNext();) {
-            Object currentKey = it2.next();
-            // Dont apply riResponse if the entry was destroyed when
+        List list = new ArrayList(keysList);
+        if (interestResultPolicy != InterestResultPolicy.KEYS_VALUES) {
+          for (Object currentKey : keysList) {
+            // Don't apply riResponse if the entry was destroyed when
-        if (pol == InterestResultPolicy.KEYS) {
+        if (interestResultPolicy == InterestResultPolicy.KEYS) {
-            for (Iterator it2 = list.iterator(); it2.hasNext();) {
-              Object currentKey = it2.next();
-              entries.initialImagePut(currentKey, 0, Token.LOCAL_INVALID, false, false, null, null,
-                  false);
-
+            for (Object currentKey : list) {
+              this.entries.initialImagePut(currentKey, 0, Token.LOCAL_INVALID, false, false, null,
+                  null, false);
-          Assert.assertTrue(pol == InterestResultPolicy.KEYS_VALUES);
-          // for (Iterator it2 = list.iterator(); it2.hasNext();) {
-          // Object currentKey = ((Entry)it2.next()).getKey();
-          // localDestroyNoCallbacks(currentKey);
-          // }
-          VersionedObjectList values = (VersionedObjectList) list.get(0); // proxy.getAllOnPrimaryForRegisterInterest(con,
-                                                                          // list);
+          Assert.assertTrue(interestResultPolicy == InterestResultPolicy.KEYS_VALUES);
+
+          VersionedObjectList values = (VersionedObjectList) list.get(0);
+
-                && (entry.getVersionTag() != null);
+                && entry.getVersionTag() != null;
-                entries.initialImagePut(currentKey, 0, val, false, false, tag, null, false);
+                this.entries.initialImagePut(currentKey, 0, val, false, false, tag, null, false);
-              RegionEntry re = entries.getEntry(currentKey);
+              RegionEntry regionEntry = this.entries.getEntry(currentKey);
-                entries.initialImagePut(currentKey, 0, Token.LOCAL_INVALID, false, false, tag, null,
-                    false);
+                this.entries.initialImagePut(currentKey, 0, Token.LOCAL_INVALID, false, false, tag,
+                    null, false);
-                if (re != null) {
-                  synchronized (re) {
-                    if (re.isDestroyedOrRemovedButNotTombstone()) {
-                      entries.removeEntry(currentKey, re, false);
+                if (regionEntry != null) {
+                  synchronized (regionEntry) {
+                    if (regionEntry.isDestroyedOrRemovedButNotTombstone()) {
+                      this.entries.removeEntry(currentKey, regionEntry, false);
-    for (Iterator it = serverKeys.iterator(); it.hasNext();) {
-      ArrayList keysList = (ArrayList) it.next();
+    for (final Object serverKey : serverKeys) {
+      List keysList = (List) serverKey;
-      // TODO is this still possible?
-      if (keysList == null)
+      // TODO: is this still possible?
+      if (keysList == null) {
+      }
-      for (Iterator it2 = keysList.iterator(); it2.hasNext();) {
-        Object key = it2.next();
+      for (Object key : keysList) {
-              buffer.append("  " + k).append("\n");
+              buffer.append("  ").append(k).append(getLineSeparator());
-            buffer.append("  " + key).append("\n");
+            buffer.append("  ").append(key).append(getLineSeparator());
-      logger.debug("{} refreshEntriesFromServerKeys count={} policy={}\n{}", this, totalKeys, pol,
-          buffer);
+      logger.debug("{} refreshEntriesFromServerKeys count={} policy={}{}{}", this, totalKeys, pol,
+          getLineSeparator(), buffer);
+   * TODO: interestResultPolicy is never used
+   *
-   * @param pol the policy from {@link InterestResultPolicy}
+   * @param interestResultPolicy the policy from {@link InterestResultPolicy}
-  public void clearKeysOfInterest(Object key, int interestType, InterestResultPolicy pol) {
+  public void clearKeysOfInterest(Object key, int interestType,
+      InterestResultPolicy interestResultPolicy) {
-  //////////////////// Package Methods ////////////////////////////////////////
-
-   * the region will go through regular GetInitalImage if it is a mirrored replicate.
+   * the region will go through regular GetInitialImage if it is a mirrored replicate.
-      boolean getDestroyLock = false;
-      if (this.dsi != null && this.dsi.getName().equals(DiskStoreFactory.DEFAULT_DISK_STORE_NAME)
+      if (this.diskStoreImpl != null
+          && this.diskStoreImpl.getName().equals(DiskStoreFactory.DEFAULT_DISK_STORE_NAME)
-        this.diskStoreName = this.dsi.getName();
+        this.diskStoreName = this.diskStoreImpl.getName();
-      InternalRegionArguments iargs = new InternalRegionArguments()
+      boolean getDestroyLock = false;
+      InternalRegionArguments internalRegionArguments = new InternalRegionArguments()
-        iargs.setPartitionedRegionBucketRedundancy(me.getRedundancyLevel());
+        internalRegionArguments.setPartitionedRegionBucketRedundancy(me.getRedundancyLevel());
-        newRegion = this.cache.createVMRegion(this.regionName, attrs, iargs);
+        newRegion = this.cache.createVMRegion(this.regionName, attrs, internalRegionArguments);
-        newRegion = parent.createSubregion(this.regionName, attrs, iargs);
+        newRegion = parent.createSubregion(this.regionName, attrs, internalRegionArguments);
-      // note that createVMRegion and createSubregion now call
-      // regionReinitialized
+      // note that createVMRegion and createSubregion now call regionReinitialized
-      InternalGemFireError error = new InternalGemFireError(
+      throw new InternalGemFireError(
-              .toLocalizedString());
-      error.initCause(e);
-      throw error;
+              .toLocalizedString(),
+          e);
-      if (newRegion == null) { // failed to create region
+      if (newRegion == null) {
+        // failed to create region
-                .toLocalizedString(
-                    new Object[] {Byte.valueOf(snapshotVersion), Byte.valueOf(SNAPSHOT_VERSION)}));
+                .toLocalizedString(new Object[] {snapshotVersion, SNAPSHOT_VERSION}));
-        if (key == null)
+        if (key == null) {
-        byte b = in.readByte();
+        }
+        byte aByte = in.readByte();
-        if (b == SNAPSHOT_VALUE_OBJ) {
+        if (aByte == SNAPSHOT_VALUE_OBJ) {
-        } else if (b == SNAPSHOT_VALUE_INVALID) {
-          // Even though it was a distributed invalidate when the
-          // snapshot was created I think it is correct to turn it
-          // into a local invalidate when we load the snapshot since
-          // we don't do a distributed invalidate operation when loading.
-          value = Token.LOCAL_INVALID;
-        } else if (b == SNAPSHOT_VALUE_LOCAL_INVALID) {
+        } else if (aByte == SNAPSHOT_VALUE_INVALID || aByte == SNAPSHOT_VALUE_LOCAL_INVALID) {
+          // Even though it was a distributed invalidate when the snapshot was created I think it is
+          // correct to turn it into a local invalidate when we load the snapshot since we don't do
+          // a distributed invalidate operation when loading.
-                  .toLocalizedString(new Byte(b)));
+                  .toLocalizedString(aByte));
-        // If versioning is enabled, we will give the entry a "fake"
-        // version.
+        // If versioning is enabled, we will give the entry a "fake" version.
-  /** Package helper method */
-  @Retained
-  Object getEntryValue(RegionEntry entry) {
-    if (entry == null) {
-      return null;
-    }
-
-    try {
-      return entry.getValue(this);
-    } catch (DiskAccessException dae) {
-      this.handleDiskAccessException(dae);
-      throw dae;
-    }
-
-  }
-
+
-    if (path.length() == 0) {
+    if (path.isEmpty()) {
-
-    if (path.charAt(0) == SEPARATOR_CHAR)
+    if (path.charAt(0) == SEPARATOR_CHAR) {
+    }
-    int sep_idx; // the index of the next separator
-    LocalRegion r = this;
+    LocalRegion region = this;
+
-    String n = path;
-    String next; // the next part of the path
-    boolean last; // last: are we on the last part of the path?
+    String name = path;
+
+    // last: are we on the last part of the path?
+    boolean last;
-      // if the rest of the name is empty, then we're done, return
-      // current region
-      if (n.length() == 0) {
-        break; // return r
+      // if the rest of the name is empty, then we're done, return current region
+      if (name.isEmpty()) {
+        // return region
+        break;
-      sep_idx = n.indexOf(SEPARATOR_CHAR);
-      last = sep_idx < 0; // this is the last part if no separator
+
+      // the index of the next separator
+      int separatorIndex = name.indexOf(SEPARATOR_CHAR);
+
+      // this is the last part if no separator
+      last = separatorIndex < 0;
+
-      next = last ? n : n.substring(0, sep_idx);
-      r = r.basicGetSubregion(next);
-      if (r == null) {
+      String next = last ? name : name.substring(0, separatorIndex);
+      region = region.basicGetSubregion(next);
+      if (region == null) {
-      if (r.isDestroyed() && !destroyedRegionOk) {
+      if (region.isDestroyed() && !destroyedRegionOk) {
-      if (!last) // if found but still more to do, get next rest of path
-        n = n.substring(sep_idx + 1);
+
+      if (!last) {
+        // if found but still more to do, get next rest of path
+        name = name.substring(separatorIndex + 1);
+      }
-    r.waitOnInitialization();
+    region.waitOnInitialization();
-    if (r.isDestroyed()) {
+    if (region.isDestroyed()) {
-      return r;
+      return region;
-    return r;
+    return region;
-    if (level == AFTER_INITIAL_IMAGE) { // if setting to default, just reset
-      initializationThread.set(null);
+    if (level == AFTER_INITIAL_IMAGE) {
+      // if setting to default, just reset
+      initializationThread.remove();
-      initializationThread.set(Integer.valueOf(level));
+      initializationThread.set(level);
-    Integer initLevel = (Integer) initializationThread.get();
+    Integer initLevel = initializationThread.get();
-    return initLevel.intValue();
+    return initLevel;
-  public boolean checkForInitialization() {
+  boolean checkForInitialization() {
-    if (latch == null)
+    if (latch == null) {
-
+    }
-      cache.getCancelCriterion().checkCancelInProgress(null);
+      this.cache.getCancelCriterion().checkCancelInProgress(null);
-        cache.getCancelCriterion().checkCancelInProgress(e);
+        this.cache.getCancelCriterion().checkCancelInProgress(e);
-        if (interrupted) // set interrupted flag if was interrupted
+        if (interrupted) {
+          // set interrupted flag if was interrupted
+        }
-    RegionEntry re = this.entries.getEntry(key);
-    if (re != null && re.isRemoved()) {
-      re = null;
+    RegionEntry regionEntry = this.entries.getEntry(key);
+    if (regionEntry != null && regionEntry.isRemoved()) {
+      regionEntry = null;
-    return re;
+    return regionEntry;
-  public DiskEntry initializeRecoveredEntry(Object key, DiskEntry.RecoveredEntry value) {
+  @Override
+  public DiskEntry initializeRecoveredEntry(Object key, DiskEntry.RecoveredEntry re) {
-    RegionEntry re = this.entries.initRecoveredEntry(key, value);
-    if (re == null) {
+    RegionEntry regionEntry = this.entries.initRecoveredEntry(key, re);
+    if (regionEntry == null) {
-    return (DiskEntry) re;
+    return (DiskEntry) regionEntry;
-  public DiskEntry updateRecoveredEntry(Object key, DiskEntry.RecoveredEntry value) {
+  @Override
+  public DiskEntry updateRecoveredEntry(Object key, DiskEntry.RecoveredEntry re) {
-    RegionEntry re = this.entries.updateRecoveredEntry(key, value);
-    return (DiskEntry) re;
+    RegionEntry regionEntry = this.entries.updateRecoveredEntry(key, re);
+    return (DiskEntry) regionEntry;
+  @Override
+  @Override
-    // TODO - RVV - I'm not sure about this recordGCVersion method. It seems
-    // like it's not doing the right thing if the current member is the member
-    // we just recovered.
-    // We need to update the RVV in memory
+    // TODO - RVV - I'm not sure about this recordGCVersion method. It seems like it's not doing the
+    // right thing if the current member is the member we just recovered. We need to update the RVV
+    // in memory
-    DiskRegion dr = this.getDiskRegion();
-    if (dr != null) {
-      dr.recordRecoveredGCVersion(member, gcVersion);
+    DiskRegion region = this.getDiskRegion();
+    if (region != null) {
+      region.recordRecoveredGCVersion(member, gcVersion);
+  @Override
-      DiskRegion dr = this.getDiskRegion();
+      DiskRegion region = this.getDiskRegion();
-      if (dr != null) {
-        dr.recordRecoveredVersonHolder(member, versionHolder, latestOplog);
+      if (region != null) {
+        region.recordRecoveredVersonHolder(member, versionHolder, latestOplog);
-      DiskRegion dr = this.getDiskRegion();
+      DiskRegion region = this.getDiskRegion();
-      if (dr != null) {
-        dr.recordRecoveredVersionTag(tag);
+      if (region != null) {
+        region.recordRecoveredVersionTag(tag);
-
-
-      DiskRegion dr = this.getDiskRegion();
-      // Update whether or not the RVV we have recovered is trusted (accurately
-      // represents what we have on disk).
-      if (dr != null) {
-        dr.setRVVTrusted(rvvTrusted);
+      DiskRegion region = this.getDiskRegion();
+      // Update whether or not the RVV we have recovered is trusted (accurately represents what we
+      // have on disk).
+      if (region != null) {
+        region.setRVVTrusted(rvvTrusted);
-    int count = 0;
-    VersionSource<?> myId = this.getVersionMember();
+    VersionSource<?> myId = getVersionMember();
+
+
-
-   * Asif:Made this function protected as this is over ridden in HARegion to abort expiry of Events
-   * which have key as Long , if it is not able to destroy from availableIDs
+   * basicInvalidate is overridden in HARegion to abort expiry of Events which have key as Long , if
+   * it is not able to destroy from availableIDs
-   * 
-        && getDataPolicy().withReplication()
-        && invokeCallbacks /*
-                            * catches case where being called by (distributed) invalidateRegion
-                            */) {
+        && getDataPolicy().withReplication() && invokeCallbacks) {
+      // catches case where being called by (distributed) invalidateRegion
-  void basicInvalidatePart2(RegionEntry re, EntryEventImpl event, boolean conflictwithClear,
-      boolean invokeCallbacks) {
+  void basicInvalidatePart2(RegionEntry regionEntry, EntryEventImpl event,
+      boolean conflictWithClear, boolean invokeCallbacks) {
-        re.dispatchListenerEvents(event);
-      } catch (InterruptedException ie) {
+        regionEntry.dispatchListenerEvents(event);
+      } catch (InterruptedException ignore) {
-        stopper.checkCancelInProgress(null);
-        return;
+        this.stopper.checkCancelInProgress(null);
-    // No op. overriden by sub classes.
+    // No op. overridden by sub classes.
-    // Notify bridge clients (if this is a BridgeServer)
+    // Notify bridge clients (if this is a CacheServer)
-   * @param rmtOrigin true if transaction being applied had a remote origin
-   * @param filterRoutingInfo
-   * @param bridgeContext
-  final void txApplyInvalidate(Object key, Object newValue, boolean didDestroy,
-      TransactionId rmtOrigin, TXRmtEvent event, boolean localOp, EventID eventId,
+  void txApplyInvalidate(Object key, Object newValue, boolean didDestroy,
+      TransactionId transactionId, TXRmtEvent event, boolean localOp, EventID eventId,
-    this.entries.txApplyInvalidate(key, newValue, didDestroy, rmtOrigin, event, localOp, eventId,
-        aCallbackArgument, pendingCallbacks, filterRoutingInfo, bridgeContext, txEntryState,
-        versionTag, tailKey);
+
+    this.entries.txApplyInvalidate(key, newValue, didDestroy, transactionId, event, localOp,
+        eventId, aCallbackArgument, pendingCallbacks, filterRoutingInfo, bridgeContext,
+        txEntryState, versionTag, tailKey);
-  final void txApplyInvalidatePart2(RegionEntry re, Object key, boolean didDestroy,
-      boolean didInvalidate, boolean clearConflict) {
+  void txApplyInvalidatePart2(RegionEntry regionEntry, Object key, boolean didDestroy,
+      boolean didInvalidate) {
-      this.testCallable.call(this, Operation.INVALIDATE, re);
+      this.testCallable.call(this, Operation.INVALIDATE, regionEntry);
-      // Bug 40842: clearing index of the old value
-      // performed in AbstractRegionMap
+      // Bug 40842: clearing index of the old value performed in AbstractRegionMap
-  protected final boolean basicPut(EntryEventImpl event, boolean ifNew, boolean ifOld,
+  protected boolean basicPut(EntryEventImpl event, boolean ifNew, boolean ifOld,
-   * @param rmtOrigin true if transaction being applied had a remote origin
-   * @param filterRoutingInfo
-   * @param bridgeContext
-  final void txApplyPut(Operation putOp, Object key, Object newValue, boolean didDestroy,
-      TransactionId rmtOrigin, TXRmtEvent event, EventID eventId, Object aCallbackArgument,
+  void txApplyPut(Operation putOp, Object key, Object newValue, boolean didDestroy,
+      TransactionId transactionId, TXRmtEvent event, EventID eventId, Object aCallbackArgument,
-    this.entries.txApplyPut(putOp, key, newValue, didDestroy, rmtOrigin, event, eventId,
+    this.entries.txApplyPut(putOp, key, newValue, didDestroy, transactionId, event, eventId,
-    this.checkReadiness();
+    checkReadiness();
-  final void txApplyPutPart2(RegionEntry re, Object key, Object newValue, long lastModified,
-      boolean isCreate, boolean didDestroy, boolean clearConflict) {
+  void txApplyPutPart2(RegionEntry regionEntry, Object key, long lastModified, boolean isCreate,
+      boolean didDestroy, boolean clearConflict) {
-      this.testCallable.call(this, op, re);
+      this.testCallable.call(this, op, regionEntry);
-          this.indexManager.updateIndexes(re,
+          this.indexManager.updateIndexes(regionEntry,
-      addExpiryTaskIfAbsent(re);
+      addExpiryTaskIfAbsent(regionEntry);
-      Object p_callbackArg, final ClientProxyMembershipID client, boolean fromClient,
+      Object callbackArg, final ClientProxyMembershipID client, boolean fromClient,
+
-    Object callbackArg = p_callbackArg;
+    Object theCallbackArg = callbackArg;
+
-        callbackArg = new GatewaySenderEventCallbackArgument(callbackArg);
+        theCallbackArg = new GatewaySenderEventCallbackArgument(theCallbackArg);
+
-        callbackArg, false /* origin remote */, client.getDistributedMember(),
+        theCallbackArg, false /* origin remote */, client.getDistributedMember(),
+
-      boolean ifNew = true; // cannot overwrite an existing key
-      boolean ifOld = false; // can create a new key
-      long lastModified = 0L; // use now
-      boolean overwriteDestroyed = false; // not okay to overwrite the DESTROYED
-      // token
+      // cannot overwrite an existing key
+      boolean ifNew = true;
+      // can create a new key
+      boolean ifOld = false;
+      // use now
+      long lastModified = 0L;
+      // not okay to overwrite the DESTROYED token
+      boolean overwriteDestroyed = false;
+
+
-      Object p_callbackArg, ClientProxyMembershipID memberId, boolean fromClient,
+      Object callbackArg, ClientProxyMembershipID memberId, boolean fromClient,
+
-    Object callbackArg = p_callbackArg;
+    Object theCallbackArg = callbackArg;
+
-        callbackArg = new GatewaySenderEventCallbackArgument(callbackArg);
+        theCallbackArg = new GatewaySenderEventCallbackArgument(theCallbackArg);
-        null /* new value */, callbackArg, false /* origin remote */,
+        null /* new value */, theCallbackArg, false /* origin remote */,
+
-      // Set the new value to the input byte[]
-      // If the byte[] represents an object, then store it
-      // serialized in a CachedDeserializable; otherwise store it directly
-      // as a byte[].
+      // Set the new value to the input byte[]. If the byte[] represents an object, then store it
+      // serialized in a CachedDeserializable; otherwise store it directly as a byte[].
-      boolean ifNew = false; // can overwrite an existing key
-
-      boolean ifOld = false; // can create a new key
-      long lastModified = 0L; // use now
-      boolean overwriteDestroyed = false; // not okay to overwrite the DESTROYED token
+
+        boolean ifNew = false; // can overwrite an existing key
+        boolean ifOld = false; // can create a new key
+        long lastModified = 0L; // use now
+        boolean overwriteDestroyed = false; // not okay to overwrite the DESTROYED token
-      } catch (ConcurrentCacheModificationException ex) { // thrown by WAN conflicts
+
+      } catch (ConcurrentCacheModificationException ignore) {
+        // thrown by WAN conflicts
+
+
+
-   * 
-   * @param tag
-    if (!this.concurrencyMessageIssued && ((tag != null) != this.concurrencyChecksEnabled)) {
+    if (!this.concurrencyMessageIssued && tag == null && this.concurrencyChecksEnabled) {
-   *
-   * @throws CacheWriterException TODO-javadocs
+
+
+
-   *
-   * @throws EntryNotFoundException TODO-javadocs
+
-          // [bruce] changed to force new entry creation for consistency
+          // changed to force new entry creation for consistency
-          if (event.isConcurrencyConflict()) { // bug #45520 - we must throw this for the
-                                               // CacheClientUpdater
+          if (event.isConcurrencyConflict()) {
+            // bug #45520 - we must throw this for the CacheClientUpdater
-   *
-   * @throws EntryNotFoundException TODO-javadocs
+
+
+
-          basicDestroy(event, false, // cacheWrite
-              null); // expectedOldValue
-          if (event.isConcurrencyConflict()) { // bug #45520 - we must throw an exception for
-                                               // CacheClientUpdater
+          basicDestroy(event, false, null);
+          if (event.isConcurrencyConflict()) {
+            // bug #45520 - we must throw an exception for CacheClientUpdater
-
-
-  public void basicBridgeDestroy(Object key, Object p_callbackArg, ClientProxyMembershipID memberId,
+  public void basicBridgeDestroy(Object key, Object callbackArg, ClientProxyMembershipID memberId,
-    Object callbackArg = p_callbackArg;
+
+    Object theCallbackArg = callbackArg;
-        callbackArg = new GatewaySenderEventCallbackArgument(callbackArg);
+        theCallbackArg = new GatewaySenderEventCallbackArgument(theCallbackArg);
-    final EntryEventImpl event = EntryEventImpl.create(this, Operation.DESTROY, key,
-        null /* new value */, callbackArg, false /* origin remote */,
-        memberId.getDistributedMember(), true /* generateCallbacks */, clientEvent.getEventId());
+    final EntryEventImpl event = EntryEventImpl.create(this, Operation.DESTROY, key, null,
+        theCallbackArg, false, memberId.getDistributedMember(), true, clientEvent.getEventId());
+
-        basicDestroy(event, true, // cacheWrite
-            null); // expectedOldValue
-      } catch (ConcurrentCacheModificationException ex) { // thrown by WAN conflicts
+        basicDestroy(event, true, null);
+      } catch (ConcurrentCacheModificationException ignore) {
+        // thrown by WAN conflicts
-
-  public void basicBridgeInvalidate(Object key, Object p_callbackArg,
+  // TODO: fromClient is always true
+  public void basicBridgeInvalidate(Object key, Object callbackArg,
-    Object callbackArg = p_callbackArg;
+
+    Object theCallbackArg = callbackArg;
-        callbackArg = new GatewaySenderEventCallbackArgument(callbackArg);
+        theCallbackArg = new GatewaySenderEventCallbackArgument(theCallbackArg);
-    final EntryEventImpl event = EntryEventImpl.create(this, Operation.INVALIDATE, key,
-        null /* new value */, callbackArg, false /* origin remote */,
-        memberId.getDistributedMember(), true /* generateCallbacks */, clientEvent.getEventId());
+    final EntryEventImpl event = EntryEventImpl.create(this, Operation.INVALIDATE, key, null,
+        theCallbackArg, false, memberId.getDistributedMember(), true, clientEvent.getEventId());
+
-  public void basicBridgeUpdateVersionStamp(Object key, Object p_callbackArg,
+  // TODO: fromClient is always false and never used
+  // TODO: callbackArg is never used
+  public void basicBridgeUpdateVersionStamp(Object key, Object callbackArg,
-    EntryEventImpl event = EntryEventImpl.create(this, Operation.UPDATE_VERSION_STAMP, key,
-        null /* new value */, null /* callbackArg */, false /* origin remote */,
-        memberId.getDistributedMember(), false /* generateCallbacks */, clientEvent.getEventId());
+    EntryEventImpl event = EntryEventImpl.create(this, Operation.UPDATE_VERSION_STAMP, key, null,
+        null, false, memberId.getDistributedMember(), false, clientEvent.getEventId());
+
-   * Allows null as new value to accomodate create with a null value.
+   * Allows null as new value to accommodate create with a null value.
+
-      if (!this.keyConstraint.isInstance(event.getKey()))
+      if (!this.keyConstraint.isInstance(event.getKey())) {
-                new Object[] {event.getKey().getClass().getName(), this.keyConstraint.getName()}));
+                event.getKey().getClass().getName(), this.keyConstraint.getName()));
+      }
-   *
-   * @see DistributedRegion#virtualPut(EntryEventImpl, boolean, boolean, Object, boolean, long,
-   *      boolean)
+
+
-    RegionEntry oldEntry = null;
+    RegionEntry oldEntry;
-    } catch (ConcurrentCacheModificationException e) {
+
+    } catch (ConcurrentCacheModificationException ignore) {
-   * 
-   * @param evi
-   * @throws LowMemoryException
-  public void checkIfAboveThreshold(final EntryEventImpl evi) throws LowMemoryException {
-    if (evi == null) {
+  public void checkIfAboveThreshold(final EntryEventImpl entryEvent) throws LowMemoryException {
+    if (entryEvent == null) {
-    boolean alreadyCheckedThreshold = hasServerProxy() && evi.getOperation().isPutAll();
-    if (!alreadyCheckedThreshold && !evi.isOriginRemote()) {
-      checkIfAboveThreshold(evi.getKey());
+    boolean alreadyCheckedThreshold = hasServerProxy() && entryEvent.getOperation().isPutAll();
+    if (!alreadyCheckedThreshold && !entryEvent.isOriginRemote()) {
+      checkIfAboveThreshold(entryEvent.getKey());
-    if (memoryThresholdReached.get()) {
-      Set<DistributedMember> htrm = getMemoryThresholdReachedMembers();
+    if (this.memoryThresholdReached.get()) {
+      Set<DistributedMember> membersThatReachedThreshold = getMemoryThresholdReachedMembers();
-      InternalResourceManager.getInternalResourceManager(cache).getHeapMonitor()
+      InternalResourceManager.getInternalResourceManager(this.cache).getHeapMonitor()
-      Object[] prms = new Object[] {getFullPath(), key, htrm};
-          LocalizedStrings.ResourceManager_LOW_MEMORY_IN_0_FOR_PUT_1_MEMBER_2
-              .toLocalizedString(prms),
-          htrm);
+          LocalizedStrings.ResourceManager_LOW_MEMORY_IN_0_FOR_PUT_1_MEMBER_2.toLocalizedString(
+              getFullPath(), key, membersThatReachedThreshold),
+          membersThatReachedThreshold);
-   * Perform a put without invoking callbacks or checking for transactions
-   */
-  /*
-   * public Object putNoCallbacks(Object key, Object value) { EntryEventImpl event = new
-   * EntryEventImpl( this, Operation.UPDATE, key, value, nullcallbackobj, false, getMyId(), true,
-   * true); event.setNewEventId(getCache().getDistributedSystem()); boolean didPut =
-   * this.entries.basicPut(event, System.currentTimeMillis(), false, false, true, false) != null; if
-   * (didPut) { return event.getOldValue(); } else { return null; } }
-   */
-
-  /**
-   * Allows null as new value to accomodate create with a null value.
+   * Allows null as new value to accommodate create with a null value.
+
-    // Note we are doing a load or netsearch result so it seems like
-    // we should set ifNew to true. The entry should not yet exist.
-    // However since the non-tx code sets ifNew to false this code will also.
+
+    // Note we are doing a load or netsearch result so it seems like we should set ifNew to true.
+    // The entry should not yet exist. However since the non-tx code sets ifNew to false this code
+    // will also.
-      RegionEntry oldEntry = this.entries.basicPut(event, lastModified, ifNew, false, // ifOld
-          null, // expectedOldValue
-          false, // requireOldValue
-          false); // overwriteDestroyed
-      return oldEntry;
+      return this.entries.basicPut(event, lastModified, ifNew, false, null, false, false);
+
+
+
+
+
-        // fix for #46662: skip wan notification during import
-        // newwan moves notification to here from invokePutCallbacks
+        // fix for #46662: skip wan notification during import newwan moves notification to here
+        // from invokePutCallbacks
+
+
-          } catch (InterruptedException ie) {
+          } catch (InterruptedException ignore) {
-            stopper.checkCancelInProgress(null);
+            this.stopper.checkCancelInProgress(null);
-   * To lower latency, PRs generate the local filter rounting in DistributedCacheOperation after
+   * To lower latency, PRs generate the local filter routing in DistributedCacheOperation after
-   * Warning: Even if you comment out bucket condition in following method, getLocalRountingInfo()
-   * does NOT process CQs for bucket regions internally. Check
+   * Warning: Even if you comment out bucket condition in following method, getLocalRoutingInfo()
+   * does NOT process CQs for bucket regions internally. See
-   * 
-   * @param event
-    FilterProfile fp = this.getFilterProfile();
+    FilterProfile filterProfile = this.getFilterProfile();
-    boolean lockForCQ = false;
-    Object re = null;
-    if (fp != null && routing == null) {
+
+    if (filterProfile != null && routing == null) {
+      boolean lockForCQ = false;
+      Object regionEntryObject = null;
+
-        re = entryEvent.getRegionEntry();
+        regionEntryObject = entryEvent.getRegionEntry();
-          Assert.assertTrue(re != null);
+          Assert.assertTrue(regionEntryObject != null);
-        synchronized (re) {
-          routing = fp.getLocalFilterRouting(event);
+        synchronized (regionEntryObject) {
+          routing = filterProfile.getLocalFilterRouting(event);
-        routing = fp.getLocalFilterRouting(event);
+        routing = filterProfile.getLocalFilterRouting(event);
+
-   * 
-   * @param event
-  protected void notifyTimestampsToGateways(EntryEventImpl event) {
-
+  void notifyTimestampsToGateways(EntryEventImpl event) {
-
-      BucketRegion br = (BucketRegion) event.getRegion();
-      PartitionedRegion pr = br.getPartitionedRegion();
-      updateTimeStampEvent.setRegion(pr);
+      BucketRegion bucketRegion = (BucketRegion) event.getRegion();
+      PartitionedRegion partitionedRegion = bucketRegion.getPartitionedRegion();
+      updateTimeStampEvent.setRegion(partitionedRegion);
-      if (pr.isParallelWanEnabled()) {
-        br.handleWANEvent(updateTimeStampEvent);
+      if (partitionedRegion.isParallelWanEnabled()) {
+        bucketRegion.handleWANEvent(updateTimeStampEvent);
-      if (pr.isInitialized()) {
-        pr.notifyGatewaySender(EnumListenerEvent.TIMESTAMP_UPDATE, updateTimeStampEvent);
+      if (partitionedRegion.isInitialized()) {
+        partitionedRegion.notifyGatewaySender(EnumListenerEvent.TIMESTAMP_UPDATE,
+            updateTimeStampEvent);
-
+
+
+
+
-   * @see DistributedRegion#postUpdate(EntryEventImpl, long)
-   * @param event
-   * @param lastModifiedTime
-   */
-  protected void postUpdate(EntryEventImpl event, long lastModifiedTime) {}
-
-  /**
-   * 
-   * @param event
-   * @param entry
-  public void generateAndSetVersionTag(InternalCacheEvent event, RegionEntry entry) {
+  void generateAndSetVersionTag(InternalCacheEvent event, RegionEntry entry) {
-        boolean eventHasDelta = (getSystem().getConfig().getDeltaPropagation()
-            && !this.scope.isDistributedNoAck() && entryEvent.getDeltaBytes() != null);
+        boolean eventHasDelta = getSystem().getConfig().getDeltaPropagation()
+            && !this.scope.isDistributedNoAck() && entryEvent.getDeltaBytes() != null;
-   * 
-   * @param event
-   * @param event
-    boolean isDup = false;
+    boolean isDuplicate = false;
+
-      // so that an operation inteded for a previous version of a bucket
+      // so that an operation intended for a previous version of a bucket
-      isDup = this.eventTracker.hasSeenEvent(event);
-      if (isDup) {
+
+      isDuplicate = this.eventTracker.hasSeenEvent(event);
+      if (isDuplicate) {
-            && (event.getVersionTag() == null) && (event.getEventId() != null)) {
+            && event.getVersionTag() == null && event.getEventId() != null) {
-    return isDup;
+
+    return isDuplicate;
-   * @param eventId
-   * @param eventId
-    boolean isDup = false;
+    boolean isDuplicate = false;
-      isDup = this.eventTracker.hasSeenEvent(eventID, null);
+      isDuplicate = this.eventTracker.hasSeenEvent(eventID, null);
-    return isDup;
+    return isDuplicate;
-   * @param r - a Runnable to wrap the processing of the bulk op
-   * @param eventID - the base event ID of the bulk op
+   * @param task - a Runnable to wrap the processing of the bulk op
+   * @param eventId - the base event ID of the bulk op
-  public void syncBulkOp(Runnable r, EventID eventID) {
+  void syncBulkOp(Runnable task, EventID eventId) {
-      this.eventTracker.syncBulkOp(r, eventID);
+      this.eventTracker.syncBulkOp(task, eventId);
-      r.run();
+      task.run();
-  final protected void notifyBridgeClients(CacheEvent event) {
+  protected void notifyBridgeClients(CacheEvent event) {
-    int serialGatewayCount = 0;
+        int serialGatewayCount = 0;
-
-    if (isPdxTypesRegion()
-        || event.isConcurrencyConflict() /* usually concurrent cache modification problem */) {
+    if (isPdxTypesRegion() || event.isConcurrencyConflict()) {
+      // isConcurrencyConflict is usually a concurrent cache modification problem
-
-    Set<String> allGatewaySenderIds = null;
+    Set<String> allGatewaySenderIds;
-          if ((!this.getDataPolicy().withStorage()) && sender.isParallel()) {
+          if (!this.getDataPolicy().withStorage() && sender.isParallel()) {
-
-
-      // if (shouldNotifyGatewaySender()) {
-      // // Get All WAN site DSID's to be sent to each WAN site so that they
-      // // don't redistribute it to same WAN sites again again (infinite loop).
-      // if (!this.getName().equals(PeerTypeRegistration.REGION_NAME)) { //This is for all region
-      // except pdx Region
-      // for (GatewaySender sender : getCache().getAllGatewaySenders()) {
-      // if (allGatewaySenderIds.contains(sender.getId())) { //Make sure we are distributing to only
-      // those senders whose id is avaialble on this region
-      // if(this.partitionAttributes == null && sender.isParallel()){ //ParalleGatewaySender with DR
-      // is not allowed
-      // throw new IllegalStateException(
-      // LocalizedStrings.AttributesFactory_PARALLELGATEWAYSENDER_0_IS_INCOMPATIBLE_WITH_DISTRIBUTED_REPLICATION
-      // .toLocalizedString(sender.getId()));
-      // }
-      // if (allRemoteDSIds == null) {
-      // allRemoteDSIds = new ArrayList<Integer>();
-      // }
-      // allRemoteDSIds.add(sender.getRemoteDSId());
-      // }
-      // else { //this else is for PDX region
-      // if (allRemoteDSIds == null) {
-      // allRemoteDSIds = new ArrayList<Integer>();
-      // }
-      // allRemoteDSIds.add(sender.getRemoteDSId());
-      // }
-      // }
-      // }
-      // if (allRemoteDSIds == null) {
-      // allRemoteDSIds = Collections.emptyList();
-      // }
-      //
-      // // Now distribute the event to each WAN site.
-      // if (!this.getName().equals(PeerTypeRegistration.REGION_NAME)) {
-      // for (GatewaySender sender : getCache().getAllGatewaySenders()) {
-      // if (allGatewaySenderIds.contains(sender.getId())) {
-      // if((!this.getDataPolicy().withStorage()) && sender.isParallel()){
-      // return;
-      // }
-      // ((AbstractGatewaySender)sender).distribute(operation, event,
-      // allRemoteDSIds);
-      // }
-      // }
-      // }
-      // }
-  public void checkSameSenderIdsAvailableOnAllNodes() {}
+  public void checkSameSenderIdsAvailableOnAllNodes() {
+    // do nothing
+  }
-    HashSet eventSet = null;
+
-        } catch (CancelException e) {
-          // ignore
+        } catch (CancelException ignore) {
-      try { // maintain destroy lock and TXStateInterface
+
+      try {
+        // maintain destroy lock and TXStateInterface
-        try { // ensure that destroy events are dispatched
+        HashSet eventSet = null;
+        try { // ensure that destroy events are dispatched
-            // "Bubble up" the cache statistics to parent if this regions are more
-            // recent
+            // "Bubble up" the cache statistics to parent if this regions are more recent
-
-            if (!cache.forcedDisconnect()) {
+            if (!this.cache.forcedDisconnect()) {
-          // at this point all subregions are destroyed and this region
-          // has been marked as destroyed and postDestroyRegion has been
-          // called for each region. The only detail left is
-          // unhooking this region from the parent subregion map, and
-          // sending listener events
+          // at this point all subregions are destroyed and this region has been marked as destroyed
+          // and postDestroyRegion has been called for each region. The only detail left is
+          // unhooking this region from the parent subregion map, and sending listener events
-          /**
-           * Added for M&M : At this point we can safely call ResourceEvent to remove the region
-           * artifacts From Management Layer
-           **/
+          // Added for M&M : At this point we can safely call ResourceEvent to remove the region
+          // artifacts From Management Layer
-            if (!cache.forcedDisconnect()) {
+            if (!this.cache.forcedDisconnect()) {
-        } // ensure that destroy events are dispatched
-        finally {
+
+        } finally {
+          // ensure that destroy events are dispatched
+
-            } catch (CancelException e) {
+            } catch (CancelException ignore) {
-      } // maintain destroy lock and TXStateInterface
-      finally {
+
+      } finally {
-          } catch (CancelException e) {
+          } catch (CancelException ignore) {
+
-
+    // do nothing
-  protected void distributeDestroyRegion(RegionEventImpl event, boolean notifyOfRegionDeparture) {}
+  protected void distributeDestroyRegion(RegionEventImpl event, boolean notifyOfRegionDeparture) {
+    // do nothing
+  }
-      final LogWriter logWriter = cache.getLogger();
+      final LogWriter logWriter = this.cache.getLogger();
+
+
-    initializingRegion.set(null);
-  }
-
-  /**
-   * notify region membership listeners of the initial membership
-   * 
-   * @param listeners an array of listeners to notify
-   */
-  public void notifyOfInitialMembers(CacheListener[] listeners, Set others) {
-    if (listeners != null) {
-      for (int i = 0; i < listeners.length; i++) {
-        if (listeners[i] instanceof RegionMembershipListener) {
-          RegionMembershipListener rml = (RegionMembershipListener) listeners[i];
-          try {
-            DistributedMember[] otherDms = new DistributedMember[others.size()];
-            others.toArray(otherDms);
-            rml.initialMembers(this, otherDms);
-          } catch (VirtualMachineError err) {
-            SystemFailure.initiateFailure(err);
-            // If this ever returns, rethrow the error. We're poisoned
-            // now, so don't let this thread continue.
-            throw err;
-          } catch (Throwable t) {
-            // Whenever you catch Error or Throwable, you must also
-            // catch VirtualMachineError (see above). However, there is
-            // _still_ a possibility that you are dealing with a cascading
-            // error condition, so you also need to check to see if the JVM
-            // is still usable:
-            SystemFailure.checkFailure();
-            logger.error(
-                LocalizedMessage.create(
-                    LocalizedStrings.DistributedRegion_EXCEPTION_OCCURRED_IN_REGIONMEMBERSHIPLISTENER),
-                t);
-          }
-        }
-      }
-    }
+    initializingRegion.remove();
-      } catch (CancelException e) {
+      } catch (CancelException ignore) {
-  final public void discoverJTA() {
-    if (!isSecret() && !isUsedForPartitionedRegionAdmin() && !isUsedForMetaRegion()) { // prevent
-                                                                                       // internal
-                                                                                       // regions
-                                                                                       // from
-                                                                                       // participating
-                                                                                       // in a TX
+  void discoverJTA() {
+    if (!isSecret() && !isUsedForPartitionedRegionAdmin() && !isUsedForMetaRegion()) {
+      // prevent internal regions from participating in a TX
-  public final boolean isTX() {
+  public boolean isTX() {
-  final boolean mapDestroy(final EntryEventImpl event, final boolean cacheWrite,
-      final boolean isEviction, Object expectedOldValue)
+  boolean mapDestroy(final EntryEventImpl event, final boolean cacheWrite, final boolean isEviction,
+      Object expectedOldValue)
+
-  final boolean mapDestroy(final EntryEventImpl event, final boolean cacheWrite,
+  private boolean mapDestroy(final EntryEventImpl event, final boolean cacheWrite,
+
+
-      final boolean needRIDestroyToken = inRI && (this.riCnt > 0);
+      final boolean needRIDestroyToken = inRI && this.riCnt > 0;
+
-      boolean result = this.entries.destroy(event, inTokenMode, needRIDestroyToken, cacheWrite,
-          isEviction, expectedOldValue, removeRecoveredEntry);
-      // AbstractRegionMap.destroy now calls cancelExpiryTask
-      return result;
-    } catch (ConcurrentCacheModificationException e) {
+      return this.entries.destroy(event, inTokenMode, needRIDestroyToken, cacheWrite, isEviction,
+          expectedOldValue, removeRecoveredEntry);
+
+    } catch (ConcurrentCacheModificationException ignore) {
+
+
-  static boolean causedByRDE(DiskAccessException dae) {
+  static boolean causedByRDE(DiskAccessException diskAccessException) {
-    if (dae != null) {
-      Throwable cause = dae.getCause();
+    if (diskAccessException != null) {
+      Throwable cause = diskAccessException.getCause();
-  final public void handleDiskAccessException(DiskAccessException dae) {
+  @Override
+  public void handleDiskAccessException(DiskAccessException dae) {
-  // Asif:To Fix bug 39079, we are locally destroying the region, the
-  // destruction takes place here & not at DiskRegion or AbstractOplogDiskRegionEntry level
-  // is to eliminate any possibility of deadlocks ,as it is an entry operation thread
-  // which is implictly closing the region & stopping the Servers
-  final public void handleDiskAccessException(DiskAccessException dae,
-      boolean duringInitialization) {
+  public void handleDiskAccessException(DiskAccessException dae, boolean duringInitialization) {
+
-      event.setNewEventId(cache.getDistributedSystem());
+      event.setNewEventId(this.cache.getDistributedSystem());
-
+
+
-  protected void basicDestroyBeforeRemoval(RegionEntry entry, EntryEventImpl event) {}
+  protected void basicDestroyBeforeRemoval(RegionEntry entry, EntryEventImpl event) {
+    // do nothing
+  }
-    /**
+    /*
+
-     * token. if (!isProxy() && !conflictWithClear) { if (this.indexManager != null) { try {
-     * this.indexManager.updateIndexes(re, IndexManager.REMOVE_ENTRY); } catch (QueryException e) {
-     * throw new IndexMaintenanceException(e); } } }
+     * token.
-    // invoke callbacks if initialized and told to do so, or if this
-    // is a bucket in a partitioned region
+    // invoke callbacks if initialized and told to do so, or if this is a bucket in a partitioned
+    // region
-      if ((isInitialized() && (!inTokenMode || duringRI))
-          || this.isUsedForPartitionedRegionBucket) {
+      if (isInitialized() && (!inTokenMode || duringRI) || this.isUsedForPartitionedRegionBucket) {
-        } catch (InterruptedException ie) {
+        } catch (InterruptedException ignore) {
-          stopper.checkCancelInProgress(null);
-          return;
+          this.stopper.checkCancelInProgress(null);
+
-
-  // Asif : This method will clear the tranxnl entries
-  final void txClearRegion() {
+  void txClearRegion() {
+
-
+
-    Operation op = event.getOperation();
+    Operation operation = event.getOperation();
-    if (op == Operation.REMOVE) {
+    if (operation == Operation.REMOVE) {
-    } else if (op == Operation.PUT_IF_ABSENT) {
+    } else if (operation == Operation.PUT_IF_ABSENT) {
-    } else if (op == Operation.REPLACE) {
+    } else if (operation == Operation.REPLACE) {
-      if (event.getInvokePRCallbacks() || (!(event.getRegion() instanceof PartitionedRegion)
-          && !(event.getRegion().isUsedForPartitionedRegionBucket()))) {
+      if (event.getInvokePRCallbacks() || !(event.getRegion() instanceof PartitionedRegion)
+          && !event.getRegion().isUsedForPartitionedRegionBucket()) {
-
-   * @param filterRoutingInfo
-   * @param bridgeContext
-  final void txApplyDestroy(Object key, TransactionId rmtOrigin, TXRmtEvent event,
+  void txApplyDestroy(Object key, TransactionId rmtOrigin, TXRmtEvent event,
+
-    final boolean needRIDestroyToken = inRI && (this.riCnt > 0);
-    final boolean inTokenMode = needTokensForGII || needRIDestroyToken;
+    final boolean needRIDestroyToken = inRI && this.riCnt > 0;
+      final boolean inTokenMode = needTokensForGII || needRIDestroyToken;
-  /**
-   * @see DistributedRegion#basicInvalidateRegion(RegionEventImpl)
-   * @param event
-   */
+
-      for (Iterator itr = allSubregions.iterator(); itr.hasNext();) {
-        LocalRegion rgn = (LocalRegion) itr.next();
-        rgn.regionInvalid = true;
+      for (Object allSubregion : allSubregions) {
+        LocalRegion region = (LocalRegion) allSubregion;
+        region.regionInvalid = true;
-          rgn.getImageState().setRegionInvalidated(true);
-          rgn.invalidateAllEntries(event);
+          region.getImageState().setRegionInvalidated(true);
+          region.invalidateAllEntries(event);
-          if (!rgn.isInitialized())
+          if (!region.isInitialized()) {
+          }
-          if (rgn.hasListener()) {
+          if (region.hasListener()) {
-            event2.region = rgn;
-            rgn.dispatchListenerEvent(EnumListenerEvent.AFTER_REGION_INVALIDATE, event2);
+            event2.region = region;
+            region.dispatchListenerEvent(EnumListenerEvent.AFTER_REGION_INVALIDATE, event2);
-      if (!isInitialized())
+      if (!isInitialized()) {
+      }
+
-
-    if (!getAttributes().getStatisticsEnabled())
+    if (!getAttributes().getStatisticsEnabled()) {
+    }
-      expTime = (new NetSearchExpirationCalculator(this, key, ttl, idleTime)).getExpirationTime();
-    } catch (EntryNotFoundException ex) {
+      expTime = new NetSearchExpirationCalculator(this, key, ttl, idleTime).getExpirationTime();
+    } catch (EntryNotFoundException ignore) {
-    if (expTime == 0)
-      return false;
-    return expTime <= cacheTimeMillis();
+
+    return expTime != 0 && expTime <= cacheTimeMillis();
-      // Assert.assertTrue(event.getRegion() == this);
+
-      boolean origOriginRemote = false;
-      boolean isOriginRemoteSet = false;
+      boolean isOriginRemote = false;
+      boolean isOriginRemoteSetOnEvent = false;
-        if ((isEntryEvent)) {
+        if (isEntryEvent) {
-            origOriginRemote = event.isOriginRemote();
+            isOriginRemote = event.isOriginRemote();
-            isOriginRemoteSet = true;
+            isOriginRemoteSetOnEvent = true;
-          RegionEntry re = ((EntryEventImpl) event).getRegionEntry();
-          if (re != null) {
+          RegionEntry regionEntry = ((EntryEventImpl) event).getRegionEntry();
+          if (regionEntry != null) {
-          final EventDispatcher ed = new EventDispatcher(event, op);
+          final EventDispatcher eventDispatcher = new EventDispatcher(event, op);
-            this.cache.getEventThreadPool().execute(ed);
-          } catch (RejectedExecutionException rex) {
-            ed.release();
+            this.cache.getEventThreadPool().execute(eventDispatcher);
+          } catch (RejectedExecutionException ignore) {
+            eventDispatcher.release();
+
-        if (isOriginRemoteSet) {
-          ((EntryEventImpl) event).setOriginRemote(origOriginRemote);
+        if (isOriginRemoteSetOnEvent) {
+          ((EntryEventImpl) event).setOriginRemote(isOriginRemote);
-          RegionEntry re = ((EntryEventImpl) event).getRegionEntry();
-          if (re != null) {
-            re.setCacheListenerInvocationInProgress(false);
+          RegionEntry regionEntry = ((EntryEventImpl) event).getRegionEntry();
+          if (regionEntry != null) {
+            regionEntry.setCacheListenerInvocationInProgress(false);
-    } else {
-      long count;
-      StoppableCountDownLatch latch = this.initializationLatchAfterGetInitialImage;
-      if (latch == null) {
-        return true;
-      }
-      count = latch.getCount();
-      if (count == 0) {
-        this.initialized = true;
-        return true;
-      } else {
-        return false;
-      }
+
+    StoppableCountDownLatch latch = this.initializationLatchAfterGetInitialImage;
+    if (latch == null) {
+      return true;
+    }
+
+    long count = latch.getCount();
+    if (count == 0) {
+      this.initialized = true;
+      return true;
+    }
+
+    return false;
-  public boolean isEventTrackerInitialized() {
-    if (this.eventTracker != null) {
-      return this.eventTracker.isInitialized();
-    }
-    return false;
+  boolean isEventTrackerInitialized() {
+    return this.eventTracker != null && this.eventTracker.isInitialized();
-  public boolean hasEventTracker() {
-    return (this.eventTracker != null);
+  boolean hasEventTracker() {
+    return this.eventTracker != null;
+
-    closeEntries(); // fixes bug 41333
+
+    // fixes bug 41333
+    closeEntries();
+
+
+
-          diskRegion.cleanupFailedInitialization(this);
-        } catch (IllegalStateException ex) {
+          this.diskRegion.cleanupFailedInitialization(this);
+        } catch (IllegalStateException ignore) {
+
-  //////////////////// Private Methods ////////////////////////////////////////
-
-    LocalRegion r = this;
-    while (r.parentRegion != null) {
-      r = r.parentRegion;
+    LocalRegion region = this;
+    while (region.parentRegion != null) {
+      region = region.parentRegion;
-    return r;
+    return region;
-    synchronized (this.subregionsLock) { // bugfix for bug#34883 (tushar)
+    // bugfix for bug#34883
+    synchronized (this.subregionsLock) {
-   * @param p_lastModified time, may be 0 in which case uses now instead
+   * @param lastModified time, may be 0 in which case uses now instead
-  long updateStatsForPut(RegionEntry entry, long p_lastModified, boolean lruRecentUse) {
-    long lastModified = p_lastModified;
+  long updateStatsForPut(RegionEntry entry, long lastModified, boolean lruRecentUse) {
-      entry.setRecentlyUsed(); // fix for bug 31102
+      // fix for bug 31102
+      entry.setRecentlyUsed();
+
+
+
-    LocalRegion r = toRegion(this.subregions.get(name));
+    LocalRegion region = toRegion(this.subregions.get(name));
+
-    if (r == null && threadInitLevelRequirement() != ANY_INIT) {
-      // try future
-      // Region p = this.parentRegion;
+
+    if (region == null && threadInitLevelRequirement() != ANY_INIT) {
-      r = this.cache.getReinitializingRegion(thePath);
+      region = this.cache.getReinitializingRegion(thePath);
-        logger.debug("Reinitialized region is {}", r);
+        logger.debug("Reinitialized region is {}", region);
-    return r;
+
+    return region;
-    LocalRegion rgn = (LocalRegion) element;
-    if (rgn != null) {
-      // do not return until done initializing (unless this is an initializing
-      // thread)
-      rgn.waitOnInitialization();
+    LocalRegion region = (LocalRegion) element;
+    if (region != null) {
+      // do not return until done initializing (unless this is an initializing thread)
+      region.waitOnInitialization();
-    return rgn;
+    return region;
-   * @param re the entry whose value was accessed
+   * @param regionEntry the entry whose value was accessed
-  public void updateStatsForGet(final RegionEntry re, final boolean hit) {
+  public void updateStatsForGet(final RegionEntry regionEntry, final boolean hit) {
-    if (re != null) {
-      re.updateStatsForGet(hit, now);
+    if (regionEntry != null) {
+      regionEntry.updateStatsForGet(hit, now);
-        addExpiryTaskIfAbsent(re);
+        addExpiryTaskIfAbsent(regionEntry);
-  private void sendPendingRegionDestroyEvents(HashSet set) {
-    Iterator iterator = set.iterator();
-    while (iterator.hasNext()) {
-      RegionEventImpl event = (RegionEventImpl) iterator.next();
-      event.region.dispatchListenerEvent(EnumListenerEvent.AFTER_REGION_DESTROY, event);
-      if (!cache.forcedDisconnect()) {
-        SystemMemberCacheEventProcessor.send(getCache(), event.getRegion(), event.getOperation());
+  private void sendPendingRegionDestroyEvents(Set regionEvents) {
+    for (Object regionEvent : regionEvents) {
+      RegionEventImpl regionEventImpl = (RegionEventImpl) regionEvent;
+      regionEventImpl.region.dispatchListenerEvent(EnumListenerEvent.AFTER_REGION_DESTROY,
+          regionEventImpl);
+      if (!this.cache.forcedDisconnect()) {
+        SystemMemberCacheEventProcessor.send(getCache(), regionEventImpl.getRegion(),
+            regionEventImpl.getOperation());
-      for (int i = 0; i < listeners.length; i++) {
-        closeCacheCallback(listeners[i]);
+      for (final CacheListener listener : listeners) {
+        closeCacheCallback(listener);
-    ServerRegionProxy mySRP = getServerProxy();
-    if (mySRP != null) {
-      GemFireCacheImpl gc = getCache();
-      String poolname = this.getPoolName();
-      PoolImpl dpool = (PoolImpl) PoolManager.find(this.getPoolName());
-      if (poolname != null && dpool != null) {
-        mySRP.detach(gc.keepDurableSubscriptionsAlive() || dpool.getKeepAlive());
+    ServerRegionProxy serverRegionProxy = getServerProxy();
+    if (serverRegionProxy != null) {
+      InternalCache internalCache = getCache();
+      String poolName = this.getPoolName();
+      PoolImpl pool = (PoolImpl) PoolManager.find(this.getPoolName());
+      if (poolName != null && pool != null) {
+        serverRegionProxy
+            .detach(internalCache.keepDurableSubscriptionsAlive() || pool.getKeepAlive());
-        mySRP.detach(gc.keepDurableSubscriptionsAlive());
+        serverRegionProxy.detach(internalCache.keepDurableSubscriptionsAlive());
-  void handleCacheClose(Operation op) {
-    RegionEventImpl ev = new RegionEventImpl(this, op, null, false, getMyId(), generateEventID());
-    if (!this.isDestroyed) { // bruce: don't destroy if already destroyed
+  void handleCacheClose(Operation operation) {
+    RegionEventImpl event =
+        new RegionEventImpl(this, operation, null, false, getMyId(), generateEventID());
+    if (!this.isDestroyed) { // don't destroy if already destroyed
-        basicDestroyRegion(ev, false, true, true);
+        basicDestroyRegion(event, false, true, true);
-        InternalDistributedSystem ids = (this.getCache().getInternalDistributedSystem());
+        InternalDistributedSystem ids = getCache().getInternalDistributedSystem();
-  void cleanUpOnIncompleteOp(EntryEventImpl event, RegionEntry re) {
+  void cleanUpOnIncompleteOp(EntryEventImpl event, RegionEntry regionEntry) {
-    this.entries.removeEntry(event.getKey(), re, false);
+    this.entries.removeEntry(event.getKey(), regionEntry, false);
-      throw cache.getCacheClosedException(null, null);
+      throw this.cache.getCacheClosedException(null, null);
+
-      RegionDestroyedException ex;
+      RegionDestroyedException regionDestroyedException;
-        ex = new RegionReinitializedException(toString(), getFullPath());
+        regionDestroyedException = new RegionReinitializedException(toString(), getFullPath());
-        ex = new RegionDestroyedException(toString(), getFullPath());
+        regionDestroyedException = new RegionDestroyedException(toString(), getFullPath());
+
-      throw ex;
+
+      throw regionDestroyedException;
+  @Override
-    Iterator it = this.entries.regionEntriesInVM().iterator();
-    while (it.hasNext()) {
-      callback.handleRegionEntry((RegionEntry) it.next());
+    for (RegionEntry regionEntry : this.entries.regionEntriesInVM()) {
+      callback.handleRegionEntry(regionEntry);
-    public void handleRegionEntry(RegionEntry re);
+    void handleRegionEntry(RegionEntry regionEntry);
-    // Actiual: disallow local invalidation for replicated regions
-    if (getScope().isDistributed() && getDataPolicy().withReplication() && (!event.isDistributed())
+    // disallow local invalidation for replicated regions
+    if (getScope().isDistributed() && getDataPolicy().withReplication() && !event.isDistributed()
-  protected int allSubregionsSize() {
-    int sz = 1; /* 1 for this region */
-    for (Iterator itr = this.subregions.values().iterator(); itr.hasNext();) {
-      LocalRegion r = (LocalRegion) itr.next();
-      if (r != null && r.isInitialized() && !r.isDestroyed()) {
-        sz += r.allSubregionsSize();
+  private int allSubregionsSize() {
+    int size = 1; /* 1 for this region */
+    for (Object regionObject : this.subregions.values()) {
+      LocalRegion region = (LocalRegion) regionObject;
+      if (region != null && region.isInitialized() && !region.isDestroyed()) {
+        size += region.allSubregionsSize();
-    return sz;
+    return size;
-  protected int allEntriesSize() {
-    int sz = entryCount();
-    for (Iterator itr = this.subregions.values().iterator(); itr.hasNext();) {
-      LocalRegion r = toRegion(itr.next());
-      if (r != null && !r.isDestroyed()) {
-        sz += r.allEntriesSize();
+  int allEntriesSize() {
+    int size = entryCount();
+    for (Object regionObject : this.subregions.values()) {
+      LocalRegion region = toRegion(regionObject);
+      if (region != null && !region.isDestroyed()) {
+        size += region.allEntriesSize();
-    return sz;
+    return size;
-    Operation op = Operation.LOCAL_INVALIDATE;
+    Operation operation = Operation.LOCAL_INVALIDATE;
-      op = Operation.INVALIDATE;
+      operation = Operation.INVALIDATE;
-
-
-    for (Iterator itr = keySet().iterator(); itr.hasNext();) {
+    for (Object keyObject : keySet()) {
+
-        EntryEventImpl event =
-            EntryEventImpl.create(this, op, itr.next() /* key */, null/* newValue */,
-                null/* callbackArg */, rgnEvent.isOriginRemote(), rgnEvent.getDistributedMember());
+        EntryEventImpl event = EntryEventImpl.create(this, operation, keyObject, null, null,
+            rgnEvent.isOriginRemote(), rgnEvent.getDistributedMember());
+
-      } catch (EntryNotFoundException e) {
+
+      } catch (EntryNotFoundException ignore) {
-  private final DiskStoreImpl dsi;
+  private final DiskStoreImpl diskStoreImpl;
+  @Override
-    return this.dsi;
+    return this.diskStoreImpl;
-    assert (getDiskStoreName() == null);
+    assert getDiskStoreName() == null;
-    DiskWriteAttributesFactory dwf = new DiskWriteAttributesFactory();
-    dwf.setSynchronous(false);
-    if (dwf.create().equals(getDiskWriteAttributes())) {
+
+    DiskWriteAttributesFactory attributesFactory = new DiskWriteAttributesFactory();
+    attributesFactory.setSynchronous(false);
+    if (attributesFactory.create().equals(getDiskWriteAttributes())) {
-    dwf.setSynchronous(true);
-    if (dwf.create().equals(getDiskWriteAttributes())) {
-      return true;
-    }
-    return false;
+    attributesFactory.setSynchronous(true);
+
+    return attributesFactory.create().equals(getDiskWriteAttributes());
-  protected boolean usesDiskStore(RegionAttributes ra) {
+  protected boolean usesDiskStore(RegionAttributes regionAttributes) {
-  protected DiskStoreImpl findDiskStore(RegionAttributes ra,
+  protected DiskStoreImpl findDiskStore(RegionAttributes regionAttributes,
-    if (usesDiskStore(ra)) {
+    if (usesDiskStore(regionAttributes)) {
+
-      } else /* backwards compat mode */ {
-        DiskStoreFactory dsf = getGemFireCache().createDiskStoreFactory();
-        dsf.setDiskDirsAndSizes(getDiskDirs(), getDiskDirSizes());
+
+      } else {
+        // backwards compat mode
+        DiskStoreFactory diskStoreFactory = getGemFireCache().createDiskStoreFactory();
+        diskStoreFactory.setDiskDirsAndSizes(getDiskDirs(), getDiskDirSizes());
-        dsf.setAutoCompact(dwa.isRollOplogs());
-        dsf.setMaxOplogSize(dwa.getMaxOplogSize());
-        dsf.setTimeInterval(dwa.getTimeInterval());
+        diskStoreFactory.setAutoCompact(dwa.isRollOplogs());
+        diskStoreFactory.setMaxOplogSize(dwa.getMaxOplogSize());
+        diskStoreFactory.setTimeInterval(dwa.getTimeInterval());
+
-          dsf.setQueueSize(1);
+          diskStoreFactory.setQueueSize(1);
-          dsf.setQueueSize(0);
+          diskStoreFactory.setQueueSize(0);
-        DiskStoreFactoryImpl dsfi = (DiskStoreFactoryImpl) dsf;
-        return dsfi.createOwnedByRegion(getFullPath().replace('/', '_'),
+
+        DiskStoreFactoryImpl diskStoreFactoryImpl = (DiskStoreFactoryImpl) diskStoreFactory;
+        return diskStoreFactoryImpl.createOwnedByRegion(getFullPath().replace('/', '_'),
-   * Creates a new <code>DiskRegion</code> for this region. We assume that the attributes and the
-   * name of the region have been set.
+   * Creates a new {@code DiskRegion} for this region. We assume that the attributes and the name of
+   * the region have been set.
-   * @return <code>null</code> is a disk region is not desired
+   * @return {@code null} is a disk region is not desired
-    if (internalRegionArgs.getDiskRegion() != null) {
-      DiskRegion dr = internalRegionArgs.getDiskRegion();
-      dr.createDataStorage();
-      return dr;
-    }
-    // A Proxy inherently has no storage.
-    if (dsi != null) {
-      DiskRegionStats stats;
-      if (this instanceof BucketRegion) {
-        stats = internalRegionArgs.getPartitionedRegion().getDiskRegionStats();
-      } else {
-        stats = new DiskRegionStats(getCache().getDistributedSystem(), getFullPath());
-      }
-      EnumSet<DiskRegionFlag> diskFlags = EnumSet.noneOf(DiskRegionFlag.class);
-      // Add flag if this region has versioning enabled
-      if (this.getAttributes().getConcurrencyChecksEnabled()) {
-        diskFlags.add(DiskRegionFlag.IS_WITH_VERSIONING);
-      }
-      return DiskRegion.create(dsi, getFullPath(), false, getDataPolicy().withPersistence(),
-          isOverflowEnabled(), isDiskSynchronous(), stats, getCancelCriterion(), this,
-          getAttributes(), diskFlags, "NO_PARTITITON", -1, getCompressor(), getOffHeap());
-    } else {
+    if (internalRegionArgs.getDiskRegion() != null) {
+      DiskRegion region = internalRegionArgs.getDiskRegion();
+      region.createDataStorage();
+      return region;
+    }
+
+    if (this.diskStoreImpl == null) {
+
+    DiskRegionStats stats;
+
+    if (this instanceof BucketRegion) {
+      stats = internalRegionArgs.getPartitionedRegion().getDiskRegionStats();
+    } else {
+      stats = new DiskRegionStats(getCache().getDistributedSystem(), getFullPath());
+    }
+
+    EnumSet<DiskRegionFlag> diskFlags = EnumSet.noneOf(DiskRegionFlag.class);
+
+    // Add flag if this region has versioning enabled
+    if (this.getAttributes().getConcurrencyChecksEnabled()) {
+      diskFlags.add(DiskRegionFlag.IS_WITH_VERSIONING);
+    }
+
+    // TODO: fix NO_PARTITITON typo
+    return DiskRegion.create(this.diskStoreImpl, getFullPath(), false,
+        getDataPolicy().withPersistence(), isOverflowEnabled(), isDiskSynchronous(), stats,
+        getCancelCriterion(), this, getAttributes(), diskFlags, "NO_PARTITITON", -1,
+        getCompressor(), getOffHeap());
-  /** ************************ Expiration methods ******************************* */
-
+
+
+
-  final void addIdleExpiryTask() {
+  void addIdleExpiryTask() {
+
+
+
-        logger.debug("Scheduling Region Idle Expiry Task {} which replaces ", task,
+        logger.debug("Scheduling Region Idle Expiry Task {} which replaces {}", task,
-    if (customEntryTimeToLive != null) {
+    if (this.customEntryTimeToLive != null) {
-    } else if (entryTimeToLive > 0 && (oldTimeout == 0 || entryTimeToLive < oldTimeout)) {
-      rescheduleEntryExpiryTasks();
-    } else {
-      // It's safe to let them get rescheduled lazily, as the old expiration
-      // time will cause the tasks to fire sooner than the new ones.
+    if (this.entryTimeToLive > 0 && (oldTimeout == 0 || this.entryTimeToLive < oldTimeout)) {
+      rescheduleEntryExpiryTasks();
+    }
+    // else it's safe to let them get rescheduled lazily, as the old expiration time will cause the
+    // tasks to fire sooner than the new ones.
-    if (customEntryIdleTimeout != null) {
+    if (this.customEntryIdleTimeout != null) {
-    } else if (entryIdleTimeout > 0 && (oldTimeout == 0 || entryIdleTimeout < oldTimeout)) {
-      rescheduleEntryExpiryTasks();
-    } else {
-      // It's safe to let them get rescheduled lazily, as the old expiration
-      // time will cause the tasks to fire sooner than the new ones.
+    if (this.entryIdleTimeout > 0 && (oldTimeout == 0 || this.entryIdleTimeout < oldTimeout)) {
+      rescheduleEntryExpiryTasks();
+    }
+    // else it's safe to let them get rescheduled lazily, as the old expiration time will cause the
+    // tasks to fire sooner than the new ones.
-  protected void rescheduleEntryExpiryTasks() {
+  void rescheduleEntryExpiryTasks() {
-   *
-    private final RegionEntry re;
+    private final RegionEntry regionEntry;
-    public ExpiryRegionEntry(LocalRegion lr, RegionEntry re) {
-      this.region = lr;
-      this.re = re;
+    ExpiryRegionEntry(LocalRegion region, RegionEntry regionEntry) {
+      this.region = region;
+      this.regionEntry = regionEntry;
-      result = prime * result + ((re == null) ? 0 : re.hashCode());
-      result = prime * result + ((region == null) ? 0 : region.hashCode());
+      result = prime * result + (this.regionEntry == null ? 0 : this.regionEntry.hashCode());
+      result = prime * result + (this.region == null ? 0 : this.region.hashCode());
-      if (this == obj)
+      if (this == obj) {
-      if (obj == null)
+      }
+      if (obj == null) {
-      if (getClass() != obj.getClass())
+      }
+      if (getClass() != obj.getClass()) {
+      }
-      if (re == null) {
-        if (other.re != null)
+      if (this.regionEntry == null) {
+        if (other.regionEntry != null) {
-      } else if (!re.equals(other.re))
+        }
+      } else if (!this.regionEntry.equals(other.regionEntry)) {
-      if (region == null) {
-        if (other.region != null)
+      }
+      if (this.region == null) {
+        if (other.region != null) {
-      } else if (!region.equals(other.region))
+        }
+      } else if (!this.region.equals(other.region))
-      return "region=" + region.getFullPath() + ", key=" + getKey() + " value=" + getValue();
+      return "region=" + this.region.getFullPath() + ", key=" + getKey() + " value=" + getValue();
-      RegionEntry result = this.re;
-      if (re.isDestroyedOrRemoved()) {
-        throw new EntryNotFoundException("Entry for key " + re.getKey() + " no longer exists");
+      if (this.regionEntry.isDestroyedOrRemoved()) {
+        throw new EntryNotFoundException(
+            "Entry for key " + this.regionEntry.getKey() + " no longer exists");
-      return result;
+      return this.regionEntry;
-        lr.entryUserAttributes = new Hashtable();
+        lr.entryUserAttributes = new ConcurrentHashMap();
-      if (this.re.isDestroyedOrRemoved())
-        return true;
-      return false;
+      return this.regionEntry.isDestroyedOrRemoved();
-      return this.re.getKey();
+      return this.regionEntry.getKey();
-  private EntryExpiryTask createExpiryTask(RegionEntry re) {
-    if (re == null || re.isDestroyedOrRemoved()) {
+  private EntryExpiryTask createExpiryTask(RegionEntry regionEntry) {
+    if (regionEntry == null || regionEntry.isDestroyedOrRemoved()) {
-      ExpiryRegionEntry ere = new ExpiryRegionEntry(this, re);
-      ExpirationAttributes ttlAtts = null;
-      ExpirationAttributes idleAtts = null;
-      final RegionAttributes<?, ?> ra = this.getAttributes();
-      {
-        final CustomExpiry<?, ?> customTTL = ra.getCustomEntryTimeToLive();
-        if (customTTL != null) {
-          try {
-            ttlAtts = customTTL.getExpiry(ere);
-            if (ttlAtts != null) {
-              this.checkEntryTimeoutAction("timeToLive", ttlAtts.getAction());
-            }
-          } catch (RegionDestroyedException rde) {
-            // Ignore - #42273
-          } catch (EntryNotFoundException enfe) {
-            // Ignore - #51933
-          } catch (EntryDestroyedException edf) {
-            // Ignore - #51933
-          } catch (Exception e) {
-            logger.fatal(LocalizedMessage.create(
-                LocalizedStrings.EntryExpiryTask_ERROR_CALCULATING_EXPIRATION_0, e.getMessage()),
-                e);
+      ExpiryRegionEntry expiryRegionEntry = new ExpiryRegionEntry(this, regionEntry);
+      ExpirationAttributes ttlAttributes = null;
+      ExpirationAttributes idleAttributes = null;
+      final RegionAttributes<?, ?> regionAttributes = this.getAttributes();
+
+      final CustomExpiry<?, ?> customTTL = regionAttributes.getCustomEntryTimeToLive();
+      if (customTTL != null) {
+        try {
+          ttlAttributes = customTTL.getExpiry(expiryRegionEntry);
+          if (ttlAttributes != null) {
+            this.checkEntryTimeoutAction("timeToLive", ttlAttributes.getAction());
-        }
-        if (ttlAtts == null) {
-          ttlAtts = ra.getEntryTimeToLive();
+        } catch (RegionDestroyedException ignore) {
+          // Ignore - #42273
+        } catch (EntryNotFoundException ignore) {
+          // Ignore - #51933
+        } catch (EntryDestroyedException ignore) {
+          // Ignore - #51933
+        } catch (Exception e) {
+          logger.fatal(
+              LocalizedMessage.create(
+                  LocalizedStrings.EntryExpiryTask_ERROR_CALCULATING_EXPIRATION_0, e.getMessage()),
+              e);
-      {
-        CustomExpiry<?, ?> customIdle = ra.getCustomEntryIdleTimeout();
-        if (customIdle != null) {
-          try {
-            idleAtts = customIdle.getExpiry(ere);
-            if (idleAtts != null) {
-              this.checkEntryTimeoutAction("idleTimeout", idleAtts.getAction());
-            }
-          } catch (RegionDestroyedException rde) {
-            // Ignore - #42273
-          } catch (EntryNotFoundException enfe) {
-            // Ignore - #51933
-          } catch (EntryDestroyedException edf) {
-            // Ignore - #51933
-          } catch (Exception e) {
-            logger.fatal(LocalizedMessage.create(
-                LocalizedStrings.EntryExpiryTask_ERROR_CALCULATING_EXPIRATION_0, e.getMessage()),
-                e);
+      if (ttlAttributes == null) {
+        ttlAttributes = regionAttributes.getEntryTimeToLive();
+      }
+
+      CustomExpiry<?, ?> customIdle = regionAttributes.getCustomEntryIdleTimeout();
+      if (customIdle != null) {
+        try {
+          idleAttributes = customIdle.getExpiry(expiryRegionEntry);
+          if (idleAttributes != null) {
+            this.checkEntryTimeoutAction("idleTimeout", idleAttributes.getAction());
-        }
-        if (idleAtts == null) {
-          idleAtts = ra.getEntryIdleTimeout();
+        } catch (RegionDestroyedException ignore) {
+          // Ignore - #42273
+        } catch (EntryNotFoundException ignore) {
+          // Ignore - #51933
+        } catch (EntryDestroyedException ignore) {
+          // Ignore - #51933
+        } catch (Exception e) {
+          logger.fatal(
+              LocalizedMessage.create(
+                  LocalizedStrings.EntryExpiryTask_ERROR_CALCULATING_EXPIRATION_0, e.getMessage()),
+              e);
-      final boolean ttlDisabled = ttlAtts == null || ttlAtts.getTimeout() == 0;
-      final boolean idleDisabled = idleAtts == null || idleAtts.getTimeout() == 0;
+      if (idleAttributes == null) {
+        idleAttributes = regionAttributes.getEntryIdleTimeout();
+      }
+
+      final boolean ttlDisabled = ttlAttributes == null || ttlAttributes.getTimeout() == 0;
+      final boolean idleDisabled = idleAttributes == null || idleAttributes.getTimeout() == 0;
+
-      } else if ((ttlDisabled || ttlAtts.equals(ra.getEntryTimeToLive()))
-          && (idleDisabled || idleAtts.equals(ra.getEntryIdleTimeout()))) {
+      } else if ((ttlDisabled || ttlAttributes.equals(regionAttributes.getEntryTimeToLive()))
+          && (idleDisabled || idleAttributes.equals(regionAttributes.getEntryIdleTimeout()))) {
-        return new EntryExpiryTask(this, re);
+        return new EntryExpiryTask(this, regionEntry);
-        return new CustomEntryExpiryTask(this, re, ttlAtts, idleAtts);
+        return new CustomEntryExpiryTask(this, regionEntry, ttlAttributes, idleAttributes);
+
-      return new EntryExpiryTask(this, re);
+      return new EntryExpiryTask(this, regionEntry);
-  private void addExpiryTask(RegionEntry re, boolean ifAbsent) {
+  private void addExpiryTask(RegionEntry regionEntry, boolean ifAbsent) {
-      return; // don't schedule expiration until region is initialized (bug
-      // 35214)
+      // don't schedule expiration until region is initialized (#35214)
+      return;
-      EntryExpiryTask oldTask = null;
+      EntryExpiryTask oldTask;
-        oldTask = (EntryExpiryTask) this.entryExpiryTasks.get(re);
+        oldTask = this.entryExpiryTasks.get(regionEntry);
-            newTask = createExpiryTask(re);
+            newTask = createExpiryTask(regionEntry);
-            long ntTime = newTask.getExpirationTime();
+            long newTaskTime = newTask.getExpirationTime();
-              if (ntTime != 0 && ntTime < oldTask.getExpirationTime()) {
+              if (newTaskTime != 0 && newTaskTime < oldTask.getExpirationTime()) {
-            } catch (EntryNotFoundException ex) {
+            } catch (EntryNotFoundException ignore) {
-              logger
-                  .trace("Expiry Task not added because one already present. Key={}" + re.getKey());
+              logger.trace("Expiry Task not added because one already present. Key={}",
+                  regionEntry.getKey());
-        newTask = createExpiryTask(re);
+        newTask = createExpiryTask(regionEntry);
-      oldTask = this.entryExpiryTasks.put(re, newTask);
-      ExpirationScheduler es = this.cache.getExpirationScheduler();
+      oldTask = this.entryExpiryTasks.put(regionEntry, newTask);
+      ExpirationScheduler scheduler = this.cache.getExpirationScheduler();
-          es.incCancels();
+          scheduler.incCancels();
-      if (!es.addEntryExpiryTask(newTask)) {
-        this.entryExpiryTasks.remove(re);
+      if (!scheduler.addEntryExpiryTask(newTask)) {
+        this.entryExpiryTasks.remove(regionEntry);
-        if (EntryExpiryTask.expiryTaskListener != null) {
-          EntryExpiryTask.expiryTaskListener.afterSchedule(newTask);
+        if (ExpiryTask.expiryTaskListener != null) {
+          ExpiryTask.expiryTaskListener.afterSchedule(newTask);
-      // @todo darrel: merge question: should we catch EntryNotFoundException
-      // if addExpiryTask throws it?
-      // } catch (EntryNotFoundException e) {
-      // // ignore - there are unsynchronized paths that allow an entry to
-      // // be destroyed out from under us.
-      // return;
-      // }
-  void cancelExpiryTask(RegionEntry re) {
-    cancelExpiryTask(re, null);
+  void cancelExpiryTask(RegionEntry regionEntry) {
+    cancelExpiryTask(regionEntry, null);
-  void cancelExpiryTask(RegionEntry re, ExpiryTask expiryTask) {
+  void cancelExpiryTask(RegionEntry regionEntry, ExpiryTask expiryTask) {
-      this.entryExpiryTasks.remove(re, expiryTask);
+      this.entryExpiryTasks.remove(regionEntry, expiryTask);
-      EntryExpiryTask oldTask = this.entryExpiryTasks.remove(re);
+      EntryExpiryTask oldTask = this.entryExpiryTasks.remove(regionEntry);
-  public void cancelAllEntryExpiryTasks() {
+  private void cancelAllEntryExpiryTasks() {
-    Iterator<EntryExpiryTask> tasksIter = this.entryExpiryTasks.values().iterator();
-    while (tasksIter.hasNext()) {
-      EntryExpiryTask task = tasksIter.next();
-      task.cancel(); // no need to call incCancels since we will call forcePurge
+    for (EntryExpiryTask task : this.entryExpiryTasks.values()) {
+      // no need to call incCancels since we will call forcePurge
+      task.cancel();
-   * Used internally by EntryExpiryTask. Ok for it to ignore transaction.
-   *
-   * @return 0 if statistics not available
-   */
-  long getLastAccessedTime(Object key) throws EntryNotFoundException {
-    RegionEntry entry = this.entries.getEntry(key);
-    if (entry == null)
-      throw new EntryNotFoundException(key.toString());
-    try {
-      return entry.getLastAccessed();
-    } catch (InternalStatisticsDisabledException e) {
-      return 0;
-    }
-  }
-
-  /**
-   * Used internally by EntryExpiryTask. Ok for it to ignore transaction.
-   */
-  long getLastModifiedTime(Object key) throws EntryNotFoundException {
-    RegionEntry entry = this.entries.getEntry(key);
-    if (entry == null)
-      throw new EntryNotFoundException(key.toString());
-    return entry.getLastModified();
-  }
-
-  /**
-  protected final ImageState getImageState() {
+  ImageState getImageState() {
-    ImageState is = getImageState();
-    if (is.isReplicate() && !isInitialized()) {
-      is.lockGII();
+    ImageState imageState = getImageState();
+    if (imageState.isReplicate() && !isInitialized()) {
+      imageState.lockGII();
-        is.unlockGII();
+        imageState.unlockGII();
-    ImageState is = getImageState();
-    assert is.isReplicate();
-    is.unlockGII();
+    ImageState imageState = getImageState();
+    assert imageState.isReplicate();
+    imageState.unlockGII();
-  public LocalRegion basicGetParentRegion() {
+  LocalRegion basicGetParentRegion() {
-  /////////////////////// Transaction Helper Methods ////////////////////
-
-  public final TXStateProxy getTXState() {
+  public TXStateProxy getTXState() {
-  final TXId getTXId() {
+  TXId getTXId() {
-  protected final TXRegionState txReadRegion() {
-    final TXStateInterface tx = getTXState();
-    if (tx != null) {
-      return tx.txReadRegion(this);
+  private TXRegionState txReadRegion() {
+    final TXStateInterface txState = getTXState();
+    if (txState != null) {
+      return txState.txReadRegion(this);
-  public TXEntryState createReadEntry(TXRegionState txr, KeyInfo keyInfo, boolean createIfAbsent) {
+  TXEntryState createReadEntry(TXRegionState txRegionState, KeyInfo keyInfo,
+      boolean createIfAbsent) {
-    final RegionEntry re = this.basicGetTXEntry(keyInfo);
-    if (re != null) {
+    final RegionEntry regionEntry = this.basicGetTXEntry(keyInfo);
+    if (regionEntry != null) {
-        synchronized (re) {
-          if (!re.isRemoved()) {
-            if (re instanceof DiskEntry && re instanceof LRUEntry) {
-              LRUEntry le = (LRUEntry) re;
+        synchronized (regionEntry) {
+          if (!regionEntry.isRemoved()) {
+            if (regionEntry instanceof DiskEntry && regionEntry instanceof LRUEntry) {
+              LRUEntry le = (LRUEntry) regionEntry;
-                re.getValue(this);
+                regionEntry.getValue(this);
-            Object value = re.getValueInVM(this);
+            Object value = regionEntry.getValueInVM(this);
-            Object id = re.getTransformedValue();
+            Object id = regionEntry.getTransformedValue();
-            result = txr.createReadEntry(this, keyInfo.getKey(), re, id, value);
+            result = txRegionState.createReadEntry(this, keyInfo.getKey(), regionEntry, id, value);
-      result = txr.createReadEntry(this, keyInfo.getKey(), null, null, null);
+      result = txRegionState.createReadEntry(this, keyInfo.getKey(), null, null, null);
-  protected static final TXEntryState NOOP_INVALIDATE = new TXEntryState();
-
-  protected TXStateInterface getJTAEnlistedTX() {
-    if (ignoreJTA) {
+  private TXStateInterface getJTAEnlistedTX() {
+    if (this.ignoreJTA) {
-    TXStateInterface tx = getTXState();
-    if (tx != null) {
-      return tx;
+    TXStateInterface txState = getTXState();
+    if (txState != null) {
+      return txState;
-      javax.transaction.Transaction jtaTx;
-        if (!ignoreJTA && this.cache.getJTATransactionManager() != null) {
+        if (!this.ignoreJTA && this.cache.getJTATransactionManager() != null) {
-          jtaTx = this.cache.getJTATransactionManager().getTransaction();
-          if (jtaTx == null
-              || jtaTx.getStatus() == javax.transaction.Status.STATUS_NO_TRANSACTION) {
+          Transaction jtaTransaction = this.cache.getJTATransactionManager().getTransaction();
+          if (jtaTransaction == null
+              || jtaTransaction.getStatus() == Status.STATUS_NO_TRANSACTION) {
-          tx = this.cache.getTXMgr().beginJTA();
-          jtaTx.registerSynchronization(tx);
-          return tx;
+          txState = this.cache.getTXMgr().beginJTA();
+          jtaTransaction.registerSynchronization(txState);
+          return txState;
-      } catch (javax.transaction.SystemException se) {
+      } catch (SystemException se) {
-        stopper.checkCancelInProgress(se);
-        jtaEnlistmentFailureCleanup(tx, se);
+        this.stopper.checkCancelInProgress(se);
+        jtaEnlistmentFailureCleanup(txState, se);
-      } catch (javax.transaction.RollbackException re) {
-        jtaEnlistmentFailureCleanup(tx, re);
-        return null;
-      } catch (IllegalStateException ie) {
-        jtaEnlistmentFailureCleanup(tx, ie);
+      } catch (RollbackException | IllegalStateException re) {
+        jtaEnlistmentFailureCleanup(txState, re);
-  private final void jtaEnlistmentFailureCleanup(TXStateInterface tx, Exception reason) {
-    if (cache == null) {
+  private void jtaEnlistmentFailureCleanup(TXStateInterface txState, Exception reason) {
+    if (this.cache == null) {
-    cache.getTXMgr().setTXState(null);
-    if (tx != null) {
-      tx.rollback();
+
+    this.cache.getTXMgr().setTXState(null);
+    if (txState != null) {
+      txState.rollback();
+
-      jtaTransName = cache.getJTATransactionManager().getTransaction().toString();
+      jtaTransName = this.cache.getJTATransactionManager().getTransaction().toString();
-  final void txLRUStart() {
+  void txLRUStart() {
-  final void txLRUEnd() {
+  void txLRUEnd() {
-  final void txDecRefCount(RegionEntry re) {
-    this.entries.decTxRefCount(re);
+  void txDecRefCount(RegionEntry regionEntry) {
+    this.entries.decTxRefCount(regionEntry);
-  /** ******* DEBUG Methods */
-    for (Iterator itr = this.subregions.keySet().iterator(); itr.hasNext();)
-      names.add(itr.next());
+    names.addAll(this.subregions.keySet());
-  protected final static void dispatchEvent(LocalRegion region, InternalCacheEvent event,
-      EnumListenerEvent op) {
+  // package-private to avoid synthetic accessor
+  static void dispatchEvent(LocalRegion region, InternalCacheEvent event,
+      EnumListenerEvent operation) {
-        logger.debug("invoking listeners: " + Arrays.toString(listeners));
+        logger.debug("invoking listeners: {}", Arrays.toString(listeners));
-    if (op != EnumListenerEvent.AFTER_REGION_CREATE) {
+    if (operation != EnumListenerEvent.AFTER_REGION_CREATE) {
-      } catch (CancelException e) {
+      } catch (CancelException ignore) {
-    // Assert.assertTrue(event.getRegion() == region);
+
-    // this check moved earlier for bug 36983
-    // CacheListener[] listeners = region.fetchCacheListenersField();
-    // if (listeners == null || listeners.length == 0)
-    // return;
-    for (int i = 0; i < listeners.length; i++) {
-      CacheListener listener = listeners[i];
+
+    for (CacheListener listener : listeners) {
-          op.dispatchEvent(event, listener);
+          operation.dispatchEvent(event, listener);
-  /** ********************* Class EventDispatcher ***************************** */
-
-
+    @Override
-        ((EntryEventImpl) this.event).release();
+        ((Releasable) this.event).release();
-
-
-  /** ******************* Class SubregionsSet ********************************* */
-
-
-        Iterator currItr = LocalRegion.this.subregions.values().iterator();
+        Iterator currentIterator = LocalRegion.this.subregions.values().iterator();
-        List itrQ; // FIFO queue of iterators
+        List queue; // FIFO queue of iterators
-        Object nextElem = null;
+        Object nextElement = null;
+        @Override
+        @Override
-          if (nextElem != null) {
+          if (this.nextElement != null) {
-            Object el = next(true);
-            if (el != null) {
-              nextElem = el;
+            Object element = next(true);
+            if (element != null) {
+              this.nextElement = element;
-        private boolean _hasNext() {
-          return this.currItr != null && this.currItr.hasNext();
+        private boolean doHasNext() {
+          return this.currentIterator != null && this.currentIterator.hasNext();
-
-          if (nextElem != null) {
-            Object next = nextElem;
-            nextElem = null;
+          if (this.nextElement != null) {
+            Object next = this.nextElement;
+            this.nextElement = null;
-          LocalRegion rgn;
+          LocalRegion region;
-            rgn = null;
-            if (!_hasNext()) {
-              if (itrQ == null || itrQ.isEmpty()) {
+            region = null;
+            if (!doHasNext()) {
+              if (this.queue == null || this.queue.isEmpty()) {
-                this.currItr = (Iterator) itrQ.remove(0);
+                this.currentIterator = (Iterator) queue.remove(0);
-            rgn = (LocalRegion) currItr.next();
-          } while (rgn == null || !rgn.isInitialized() || rgn.isDestroyed());
+            region = (LocalRegion) currentIterator.next();
+          } while (region == null || !region.isInitialized() || region.isDestroyed());
-            Iterator nextIterator = rgn.subregions.values().iterator();
+            Iterator nextIterator = region.subregions.values().iterator();
-              if (itrQ == null) {
-                itrQ = new ArrayList();
+              if (this.queue == null) {
+                this.queue = new ArrayList();
-              itrQ.add(nextIterator);
+              this.queue.add(nextIterator);
-          if (!_hasNext()) {
-            if (itrQ == null || itrQ.isEmpty()) {
-              this.currItr = null;
+          if (!doHasNext()) {
+            if (this.queue == null || this.queue.isEmpty()) {
+              this.currentIterator = null;
-              this.currItr = (Iterator) itrQ.remove(0);
+              this.currentIterator = (Iterator) this.queue.remove(0);
-          return rgn;
+          return region;
-      for (Iterator iter = this.iterator(); iter.hasNext();) {
+      // do NOT use addAll or this results in stack overflow - must use iterator()
+      for (Iterator iter = iterator(); iter.hasNext();) {
-      for (Iterator iter = this.iterator(); iter.hasNext();) {
+      // do NOT use addAll or this results in stack overflow - must use iterator()
+      for (Iterator iter = iterator(); iter.hasNext();) {
-  /** ******************* Class EntriesSet ************************************ */
-
+    @Override
-      RegionEntry re = LocalRegion.this.getRegionMap().getEntry(key);
-      if (re == null) {
+      RegionEntry regionEntry = LocalRegion.this.getRegionMap().getEntry(this.key);
+      if (regionEntry == null) {
-      return re;
+      return regionEntry;
-      RegionEntry re = LocalRegion.this.basicGetEntry(key);
+      RegionEntry re = LocalRegion.this.basicGetEntry(this.key);
+    @Override
-      if (LocalRegion.this.isDestroyed) {
-        this.entryIsDestroyed = true;
-      } else if (LocalRegion.this.basicGetEntry(key) == null) {
+      if (LocalRegion.this.isDestroyed || LocalRegion.this.basicGetEntry(this.key) == null) {
+    @Override
-      return this.basicGetEntry().getKey();
+      return basicGetEntry().getKey();
+    @Override
-      Object value = this.basicGetEntry().getValue((LocalRegion) getRegion());
+      Object value = basicGetEntry().getValue((RegionEntryContext) getRegion());
+    @Override
-      this.basicGetEntry();
+      basicGetEntry();
+    @Override
-      this.basicGetEntry();
+      basicGetEntry();
+    @Override
-      Map userAttr = LocalRegion.this.entryUserAttributes;
-      if (userAttr == null) {
+      Map userAttributes = LocalRegion.this.entryUserAttributes;
+      if (userAttributes == null) {
-      return userAttr.get(this.basicGetEntry().getKey());
+      return userAttributes.get(basicGetEntry().getKey());
-    public Object setUserAttribute(Object value) {
+    @Override
+    public Object setUserAttribute(Object userAttribute) {
-        LocalRegion.this.entryUserAttributes = new Hashtable();
+        LocalRegion.this.entryUserAttributes = new ConcurrentHashMap();
-      return LocalRegion.this.entryUserAttributes.put(this.basicGetEntry().getKey(), value);
+      return LocalRegion.this.entryUserAttributes.put(basicGetEntry().getKey(), userAttribute);
-      LocalRegion.NonTXEntry lre = (LocalRegion.NonTXEntry) obj;
-      return this.basicGetEntry().equals(lre.getRegionEntry())
-          && this.getRegion() == lre.getRegion();
+      LocalRegion.NonTXEntry entry = (LocalRegion.NonTXEntry) obj;
+      return this.basicGetEntry().equals(entry.getRegionEntry())
+          && this.getRegion() == entry.getRegion();
-      return this.basicGetEntry().hashCode() ^ this.getRegion().hashCode();
+      return basicGetEntry().hashCode() ^ getRegion().hashCode();
-    ////////////////// Private Methods
-    // /////////////////////////////////////////
-
-    public Object setValue(Object arg0) {
-      return put(this.getKey(), arg0);
-    }
-  }
-
-  /**
-   * Checks to make sure current thread does not have a transaction. If it does then throws
-   * UnsupportedOperationException
-   */
-  public void checkForTransaction(String opName) {
-    if (isTX()) {
-      throw new UnsupportedOperationException(
-          LocalizedStrings.LocalRegion_0_OPERATIONS_ARE_NOT_ALLOWED_BECAUSE_THIS_THREAD_HAS_AN_ACTIVE_TRANSACTION
-              .toLocalizedString(opName));
+    @Override
+    public Object setValue(Object value) {
+      return put(getKey(), value);
-   * Methods for java.util.Map compliance
-   *
-   * @since GemFire 5.0
-   */
-
-  /**
+  @Override
-      lockRIReadLock(); // bug #40871 - test sees wrong size for region during RI
+      // bug #40871 - test sees wrong size for region during RI
+      lockRIReadLock();
-   * returns an estimate of the number of entries in this region. This method should be prefered
+   * returns an estimate of the number of entries in this region. This method should be preferred
+  @Override
-    return this.size() > 0 ? false : true;
+    return this.size() <= 0;
+  @Override
-    Iterator iterator = new EntriesSet(this, false, IteratorType.VALUES, false).iterator();
-    Object val = null;
-    while (iterator.hasNext()) {
-      val = iterator.next();
-      if (val != null) {
-        if (value.equals(val)) {
+    for (Object entry : new EntriesSet(this, false, IteratorType.VALUES, false)) {
+      if (entry != null) {
+        if (value.equals(entry)) {
+  @Override
-
-
-
+  @Override
-  public Object remove(Object obj) {
+  @Override
+  public Object remove(Object key) {
-    Object returnObject = null;
+    Object value = null;
-      returnObject = destroy(obj);
-    } catch (EntryNotFoundException e) {
+      value = destroy(key);
+    } catch (EntryNotFoundException ignore) {
-    return returnObject;
+    return value;
-  public void basicBridgeDestroyRegion(Object p_callbackArg, final ClientProxyMembershipID client,
+  // TODO: fromClient is always true
+  public void basicBridgeDestroyRegion(Object callbackArg, final ClientProxyMembershipID client,
-    Object callbackArg = p_callbackArg;
-    // long startPut = CachePerfStats.getStatTime();
+
-        false, client.getDistributedMember(), client/* context */, eventId);
+        false, client.getDistributedMember(), client, eventId);
-
-
-
-  public void basicBridgeClear(Object p_callbackArg, final ClientProxyMembershipID client,
+  public void basicBridgeClear(Object callbackArg, final ClientProxyMembershipID client,
-    Object callbackArg = p_callbackArg;
-    // long startPut = CachePerfStats.getStatTime();
+
-        false, client.getDistributedMember(), client/* context */, eventId);
+        false, client.getDistributedMember(), client, eventId);
-
-
-    basicClear(regionEvent, true/* cacheWrite */);
+    basicClear(regionEvent, true);
-
+  // TODO: what does cmn refer to?
-   * Common code used by both clear and localClear. Asif : On the lines of destroyRegion, this
-   * method will be invoked for clearing the local cache.The cmnClearRegion will be overridden in
-   * the derived class DistributedRegion too. For clear operation , no CacheWriter will be invoked .
-   * It will only have afterClear callback. Also like destroyRegion & invalidateRegion , the clear
-   * operation will not take distributedLock. The clear operation will also clear the local tranxnl
-   * entries . The clear operation will have immediate committed state.
+   * Common code used by both clear and localClear. On the lines of destroyRegion, this method will
+   * be invoked for clearing the local cache.The cmnClearRegion will be overridden in the derived
+   * class DistributedRegion too. For clear operation , no CacheWriter will be invoked . It will
+   * only have afterClear callback. Also like destroyRegion & invalidateRegion , the clear operation
+   * will not take distributedLock. The clear operation will also clear the local tranxnl entries .
+   * The clear operation will have immediate committed state.
-    if (this.srp != null) {
+    if (this.serverRegionProxy != null) {
-        logger.trace(LogMarker.RVV, "waiting for my version vector to dominate\nmine={}\nother=",
-            this.versionVector.fullToString(), rvv);
+        logger.trace(LogMarker.RVV, "waiting for my version vector to dominate{}mine={}{} other={}",
+            getLineSeparator(), getLineSeparator(), this.versionVector.fullToString(), rvv);
-          logger.trace(LogMarker.RVV, "incrementing clearTimeouts for {} rvv={}", this.getName(),
+          logger.trace(LogMarker.RVV, "incrementing clearTimeouts for {} rvv={}", getName(),
-    // If the initial image operation is still in progress
-    // then we need will have to do the clear operation at the
-    // end of the GII.For this we try to acquire the lock of GII
-    // the boolean returned is true that means lock was obtained which
-    // also means that GII is still in progress.
-    boolean isGIIInProg = lockGII();
-    if (isGIIInProg) {
+    // If the initial image operation is still in progress then we need will have to do the clear
+    // operation at the end of the GII.For this we try to acquire the lock of GII the boolean
+    // returned is true that means lock was obtained which also means that GII is still in progress.
+    boolean isGIIinProgress = lockGII();
+    if (isGIIinProgress) {
-    if (cacheWrite && !isGIIInProg) {
+    if (cacheWrite && !isGIIinProgress) {
-          myVector.recordVersion(tag.getMemberID(), tag); // clear() events always have the ID in
-                                                          // the tag
+          // clear() events always have the ID in the tag
+          myVector.recordVersion(tag.getMemberID(), tag);
-    // Asif:Clear the expirational task for all the entries. It is possible that
-    // after clearing it some new entries may get added befoe issuing clear
-    // on the map , but that should be OK, as the expirational thread will
+    // Clear the expiration task for all the entries. It is possible that
+    // after clearing it some new entries may get added before issuing clear
+    // on the map , but that should be OK, as the expiration thread will
-     * Asif : First we need to clear the Tranxl state for the current region for the thread. The
-     * operation will not take global lock similar to regionInvalidateor regionDestroy behaviour.
+     * First we need to clear the TX state for the current region for the thread. The operation will
+     * not take global lock similar to regionInvalidator regionDestroy behaviour.
-    // mbid : clear the disk region if present
-    if (diskRegion != null) {
+    // clear the disk region if present
+    if (this.diskRegion != null) {
-              diskRegion.getRegionVersionVector());
+              this.diskRegion.getRegionVersionVector());
-        diskRegion.writeRVV(this, null);
-        diskRegion.writeRVVGC(this);
+        this.diskRegion.writeRVV(this, null);
+        this.diskRegion.writeRVVGC(this);
-      diskRegion.clear(this, rvv);
+      this.diskRegion.clear(this, rvv);
-      // Now remove the tranxnl entries for this region
-      this.txClearRegion();
+      // Now remove the tx entries for this region
+      txClearRegion();
-      if (!this.dataPolicy.withPersistence()) { // persistent regions do not reap IDs
+      if (!this.dataPolicy.withPersistence()) {
+        // persistent regions do not reap IDs
-      // TODO Asif:Have made indexManager variable is made volatile. Is it
-      // necessary?
+
+      // TODO made indexManager variable is made volatile. Is it necessary?
-          // Asif : Create an anonymous inner class of CacheRuntimeException so
+          // Create an anonymous inner class of CacheRuntimeException so
+          // TODO: never throw an annonymous class (and outer-class is not serializable)
-    if (isGIIInProg) {
+    if (isGIIinProgress) {
-    // notifyBridgeClients(EnumListenerEvent.AFTER_REGION_CLEAR, regionEvent);
+
+  // TODO: refactor basicGetAll
-        for (Iterator i = keysList.iterator(); i.hasNext();) {
-          Object key = i.next();
+        for (Iterator iterator = keysList.iterator(); iterator.hasNext();) {
+          Object key = iterator.next();
-            i.remove();
+            iterator.remove();
-            createTombstone = (entry.getVersionTag() != null && this.concurrencyChecksEnabled);
+            createTombstone = entry.getVersionTag() != null && this.concurrencyChecksEnabled;
+
+
+
-            if (!alreadyInvalid(key, event)) { // bug #47716 - don't update if it's already here &
-                                               // invalid
-              TXStateProxy tx = this.cache.getTXMgr().internalSuspend();
+            if (!alreadyInvalid(key, event)) {
+              // bug #47716 - don't update if it's already here & invalid
+              TXStateProxy txState = this.cache.getTXMgr().internalSuspend();
-                      key);
+                      key, e);
-                this.cache.getTXMgr().internalResume(tx);
+                this.cache.getTXMgr().internalResume(txState);
+
-      for (Iterator i = keys.iterator(); i.hasNext();) {
-        Object key = i.next();
+      for (Object key : keys) {
-    Map.Entry mapEntry = null;
+    Map.Entry mapEntry;
-    Iterator iterator = theEntries.iterator();
-    while (iterator.hasNext()) {
-      mapEntry = (Map.Entry) iterator.next();
+    for (Object theEntry : theEntries) {
+      mapEntry = (Map.Entry) theEntry;
-
+
+
-  public VersionedObjectList basicBridgeRemoveAll(ArrayList<Object> keys,
+  public VersionedObjectList basicBridgeRemoveAll(List<Object> keys,
+
+
+  // TODO: return value is never used
-    // generateCallbacks == false
+
-  public final void putAll(Map map, Object callbackArg) {
+  public void putAll(Map map, Object aCallbackArgument) {
-    final DistributedPutAllOperation putAllOp = newPutAllOperation(map, callbackArg);
+    final DistributedPutAllOperation putAllOp = newPutAllOperation(map, aCallbackArgument);
-  public final void putAll(Map map) {
+  public void putAll(Map map) {
-  public final void removeAll(Collection keys) {
+  public void removeAll(Collection keys) {
-  public final void removeAll(Collection keys, Object callbackArg) {
-    final long startOp = CachePerfStats.getStatTime();
-    final DistributedRemoveAllOperation op = newRemoveAllOperation(keys, callbackArg);
-    if (op != null) {
+  public void removeAll(Collection keys, Object aCallbackArgument) {
+    long startOp = CachePerfStats.getStatTime();
+    DistributedRemoveAllOperation operation = newRemoveAllOperation(keys, aCallbackArgument);
+    if (operation != null) {
-        basicRemoveAll(keys, op, null);
+        basicRemoveAll(keys, operation, null);
-        op.getBaseEvent().release();
-        op.freeOffHeapResources();
+        operation.getBaseEvent().release();
+        operation.freeOffHeapResources();
+  // TODO: refactor basicPutAll
+
-      // Gester: We need to "reserve" the eventIds for the entries in map here
-      event.reserveNewEventId(cache.getDistributedSystem(), map.size());
+      // We need to "reserve" the eventIds for the entries in map here
+      event.reserveNewEventId(this.cache.getDistributedSystem(), map.size());
-    RuntimeException e = null;
+    RuntimeException runtimeException = null;
-        TXStateProxyImpl tx = (TXStateProxyImpl) cache.getTxManager().getTXState();
-        tx.getRealDeal(null, this);
+        TXStateProxyImpl txState = (TXStateProxyImpl) this.cache.getTxManager().getTXState();
+        txState.getRealDeal(null, this);
-      } catch (PutAllPartialResultException e1) {
+      } catch (PutAllPartialResultException e) {
-        proxyResult = e1.getSucceededKeysAndVersions();
+        proxyResult = e.getSucceededKeysAndVersions();
-              "putAll in client encountered a PutAllPartialResultException:{}\n. Adjusted keys are: ",
-              e1.getMessage(), proxyResult.getKeys());
+              "putAll in client encountered a PutAllPartialResultException:{}{}. Adjusted keys are: {}",
+              e.getMessage(), getLineSeparator(), proxyResult.getKeys());
-        Throwable txException = e1.getFailure();
+        Throwable txException = e.getFailure();
-            e = (TransactionException) txException;
+            runtimeException = (RuntimeException) txException;
-        if (e == null) {
-          e = getCancelCriterion().generateCancelledException(e1.getFailure());// for cache close
-          if (e == null) {
-            e = new ServerOperationException(
+        if (runtimeException == null) {
+          // for cache close
+          runtimeException = getCancelCriterion().generateCancelledException(e.getFailure());
+          if (runtimeException == null) {
+            runtimeException = new ServerOperationException(
-                e1.getFailure());
+                e.getFailure());
+
+
-
-        final DistributedPutAllOperation dpao = putAllOp;
-        int size = (proxyResult == null) ? map.size() : proxyResult.size();
+        int size = proxyResult == null ? map.size() : proxyResult.size();
-        Runnable r = new Runnable() {
+
+        // TODO: refactor this mess
+        Runnable task = new Runnable() {
+          @Override
-                  basicEntryPutAll(key, value, dpao, offset, tagHolder);
+                  basicEntryPutAll(key, value, putAllOp, offset, tagHolder);
-                // TODO ask Gester if this debug logging can be removed
-        this.syncBulkOp(r, eventId);
+
+        syncBulkOp(task, eventId);
-          if (e == null) {
+          if (runtimeException == null) {
-            if (dpao.isBridgeOperation()) {
+            if (putAllOp.isBridgeOperation()) {
-                e = (CancelException) partialKeys.getFailure();
+                runtimeException = (RuntimeException) partialKeys.getFailure();
-                throw partialKeys.getFailure(); // fix for #43589
+                // fix for #43589
+                throw partialKeys.getFailure();
-                e = new PutAllPartialResultException(partialKeys);
+                runtimeException = new PutAllPartialResultException(partialKeys);
-        e = ex;
+        runtimeException = ex;
-        e = new RuntimeException(ex);
+        runtimeException = new RuntimeException(ex);
-    if (e != null) {
-      throw e;
+    if (runtimeException != null) {
+      throw runtimeException;
-  public VersionedObjectList basicRemoveAll(final Collection<Object> keys,
-      final DistributedRemoveAllOperation removeAllOp, final ArrayList<VersionTag> retryVersions) {
+  VersionedObjectList basicRemoveAll(final Collection<Object> keys,
+      final DistributedRemoveAllOperation removeAllOp, final List<VersionTag> retryVersions) {
+
+
-      // Gester: We need to "reserve" the eventIds for the entries in map here
-      event.reserveNewEventId(cache.getDistributedSystem(), keys.size());
+      // We need to "reserve" the eventIds for the entries in map here
+      event.reserveNewEventId(this.cache.getDistributedSystem(), keys.size());
-    RuntimeException e = null;
+    RuntimeException runtimeException = null;
+
-        TXStateProxyImpl tx = (TXStateProxyImpl) cache.getTxManager().getTXState();
-        tx.getRealDeal(null, this);
+        TXStateProxyImpl txState = (TXStateProxyImpl) this.cache.getTxManager().getTXState();
+        txState.getRealDeal(null, this);
-      } catch (PutAllPartialResultException e1) {
+      } catch (PutAllPartialResultException e) {
-        proxyResult = e1.getSucceededKeysAndVersions();
+        proxyResult = e.getSucceededKeysAndVersions();
-              "removeAll in client encountered a BulkOpPartialResultException: {}\n. Adjusted keys are: {}",
-              e1.getMessage(), proxyResult.getKeys());
+              "removeAll in client encountered a BulkOpPartialResultException: {}{}. Adjusted keys are: {}",
+              e.getMessage(), getLineSeparator(), proxyResult.getKeys());
-        Throwable txException = e1.getFailure();
+        Throwable txException = e.getFailure();
-            e = (TransactionException) txException;
+            runtimeException = (RuntimeException) txException;
-        if (e == null) {
-          e = new ServerOperationException(
+        if (runtimeException == null) {
+          runtimeException = new ServerOperationException(
-              e1.getFailure());
+              e.getFailure());
+
+
-
-        final DistributedRemoveAllOperation op = removeAllOp;
-        int size = (proxyResult == null) ? keys.size() : proxyResult.size();
+        int size = proxyResult == null ? keys.size() : proxyResult.size();
-        Runnable r = new Runnable() {
+
+        // TODO: refactor this mess
+        Runnable task = new Runnable() {
+          @Override
+              tagHolder.setVersionTag(null);
-              tagHolder.setVersionTag(null);
-                if (isInternalRegion()) {
-                  if (isTraceEnabled) {
-                    logger.trace("removeAll {}", key);
-                  }
-                } else {
-                  if (isTraceEnabled) {
-                    logger.trace("removeAll {}", key);
-                  }
+                if (isTraceEnabled) {
+                  logger.trace("removeAll {}", key);
-
+
-                  VersionTag vt = retryVersions.get(offset);
-                  if (vt != null) {
+                  VersionTag versionTag1 = retryVersions.get(offset);
+                  if (versionTag1 != null) {
-                    tagHolder.setVersionTag(vt);
+                    tagHolder.setVersionTag(versionTag1);
-                basicEntryRemoveAll(key, op, offset, tagHolder);
+                basicEntryRemoveAll(key, removeAllOp, offset, tagHolder);
-        syncBulkOp(r, eventId);
+
+        syncBulkOp(task, eventId);
-          if (e == null) {
+          if (runtimeException == null) {
-            if (op.isBridgeOperation()) {
+            if (removeAllOp.isBridgeOperation()) {
-                e = (CancelException) partialKeys.getFailure();
+                runtimeException = (RuntimeException) partialKeys.getFailure();
-                e = new PutAllPartialResultException(partialKeys);
+                runtimeException = new PutAllPartialResultException(partialKeys);
-                  logger.debug("basicRemoveAll:" + partialKeys.detailString());
+                  logger.debug("basicRemoveAll: {}", partialKeys.detailString());
-        e = ex;
+        runtimeException = ex;
-        e = new RuntimeException(ex);
+        runtimeException = new RuntimeException(ex);
-    if (e != null) {
-      throw e;
+    if (runtimeException != null) {
+      throw runtimeException;
-    ARMLockTestHook alth = getRegionMap().getARMLockTestHook();
-    if (alth != null) {
-      alth.beforeBulkLock(this);
+    ARMLockTestHook testHook = getRegionMap().getARMLockTestHook();
+    if (testHook != null) {
+      testHook.beforeBulkLock(this);
-    if (alth != null) {
-      alth.afterBulkLock(this);
+    if (testHook != null) {
+      testHook.afterBulkLock(this);
-    ARMLockTestHook alth = getRegionMap().getARMLockTestHook();
-    if (alth != null) {
-      alth.beforeBulkRelease(this);
+    ARMLockTestHook testHook = getRegionMap().getARMLockTestHook();
+    if (testHook != null) {
+      testHook.beforeBulkRelease(this);
-    if (alth != null) {
-      alth.afterBulkRelease(this);
+    if (testHook != null) {
+      testHook.afterBulkRelease(this);
-
-  public final DistributedPutAllOperation newPutAllOperation(Map<?, ?> map, Object callbackArg) {
+  public DistributedPutAllOperation newPutAllOperation(Map<?, ?> map, Object callbackArg) {
+
-    DistributedPutAllOperation dpao = new DistributedPutAllOperation(event, map.size(), false);
-    return dpao;
+    return new DistributedPutAllOperation(event, map.size(), false);
-  public final DistributedRemoveAllOperation newRemoveAllOperation(Collection<?> keys,
+  private DistributedRemoveAllOperation newRemoveAllOperation(Collection<?> keys,
+
-        null/* newValue */, callbackArg, false, getMyId());
+        null, callbackArg, false, getMyId());
-
-  protected final void basicEntryPutAll(Object key, Object value,
-      DistributedPutAllOperation putallOp, int offset, EntryEventImpl tagHolder)
-      throws TimeoutException, CacheWriterException {
+  private void basicEntryPutAll(Object key, Object value, DistributedPutAllOperation putallOp,
+      int offset, EntryEventImpl tagHolder) throws TimeoutException, CacheWriterException {
+
-    // long startPut = CachePerfStats.getStatTime();
+
+
+
+
-      discoverJTA(); // TODO: This could be called once for the entire putAll instead of calling it
-                     // for every key
+
+      // TODO: could be called once for the entire putAll instead of calling it for every key
+      discoverJTA();
-
-  protected final void basicEntryRemoveAll(Object key, DistributedRemoveAllOperation op, int offset,
+  private void basicEntryRemoveAll(Object key, DistributedRemoveAllOperation op, int offset,
+
+
+
+
-      discoverJTA(); // TODO: This could be called once for the entire removeAll instead of calling
-                     // it for every key
+
+      // TODO: could be called once for the entire removeAll instead of calling it for every key
+      discoverJTA();
-    // getDataView().destroyExistingEntry(event, true, null);
-
-  public void postPutAllFireEvents(DistributedPutAllOperation putallOp,
+  public void postPutAllFireEvents(DistributedPutAllOperation putAllOp,
+
-        && putallOp.getBaseEvent().isBridgeEvent()) {
+        && putAllOp.getBaseEvent().isBridgeEvent()) {
-      putallOp.fillVersionedObjectList(successfulPuts);
+      putAllOp.fillVersionedObjectList(successfulPuts);
+
-    for (Iterator it = putallOp.eventIterator(); it.hasNext();) {
+
+    for (Iterator it = putAllOp.eventIterator(); it.hasNext();) {
+
-  public void postRemoveAllFireEvents(DistributedRemoveAllOperation op,
+  public void postRemoveAllFireEvents(DistributedRemoveAllOperation removeAllOp,
+
-        && op.getBaseEvent().isBridgeEvent()) {
+        && removeAllOp.getBaseEvent().isBridgeEvent()) {
-      op.fillVersionedObjectList(successfulOps);
+      removeAllOp.fillVersionedObjectList(successfulOps);
+
-    for (Iterator it = op.eventIterator(); it.hasNext();) {
+
+    for (Iterator it = removeAllOp.eventIterator(); it.hasNext();) {
+
-  public long postPutAllSend(DistributedPutAllOperation putallOp,
+  public long postPutAllSend(DistributedPutAllOperation putAllOp,
-
-
-  final void handleRemoteLocalRegionDestroyOrClose(InternalDistributedMember sender, int topSerial,
+  void handleRemoteLocalRegionDestroyOrClose(InternalDistributedMember sender, int topSerial,
+    // go through initialization latches
-    // go
-    // through
-    // initialization
-    // latches
-   * @param regionDestroyed
-  private final void basicHandleRemoteLocalRegionDestroyOrClose(InternalDistributedMember sender,
+  private void basicHandleRemoteLocalRegionDestroyOrClose(InternalDistributedMember sender,
-        serialForThisRegion = serialNumber.intValue();
+        serialForThisRegion = serialNumber;
-    for (Iterator itr = this.subregions.values().iterator(); itr.hasNext();) {
-      LocalRegion r = toRegion(itr.next());
-      if (r != null && !r.isDestroyed()) {
+    for (Object regionObject : this.subregions.values()) {
+      LocalRegion region = toRegion(regionObject);
+      if (region != null && !region.isDestroyed()) {
-        r.basicHandleRemoteLocalRegionDestroyOrClose(sender, topSerial, subregionSerialNumbers,
+        region.basicHandleRemoteLocalRegionDestroyOrClose(sender, topSerial, subregionSerialNumbers,
-   * 
-   * @param regionDestroyed
-  final public boolean isUsedForPartitionedRegionAdmin() {
+  boolean isUsedForPartitionedRegionAdmin() {
+  @Override
-      diskRegion.forceRolling();
+      this.diskRegion.forceRolling();
+   * TODO: return value is never used
+   * 
-    DiskRegion dr = getDiskRegion();
-    if (dr != null) {
-      if (dr.isCompactionPossible()) {
-        return dr.forceCompaction();
+    DiskRegion region = getDiskRegion();
+    if (region != null) {
+      if (region.isCompactionPossible()) {
+        return region.forceCompaction();
+  @Override
-
-  public boolean isParallelWanEnabled() {
+  boolean isParallelWanEnabled() {
-    return ((BucketRegion) this).getPartitionedRegion();
+    return ((Bucket) this).getPartitionedRegion();
-  final public boolean isUsedForMetaRegion() {
+  public boolean isUsedForMetaRegion() {
-  final public boolean isMetaRegionWithTransactions() {
+  boolean isMetaRegionWithTransactions() {
-  final public boolean isInternalRegion() {
+  public boolean isInternalRegion() {
-  public CacheServiceProfile getCacheServiceProfile(String id) {
-    return this.cacheServiceProfiles.get(id);
-  }
-
-  public Map<String, CacheServiceProfile> getCacheServiceProfiles() {
+  Map<String, CacheServiceProfile> getCacheServiceProfiles() {
+  @Override
+        @Override
+        @Override
-  public final boolean hasNetLoader(CacheDistributionAdvisor distAdvisor) {
+  boolean hasNetLoader(CacheDistributionAdvisor distAdvisor) {
-   * Return true if some other member of the distributed system, not including self, has a
-   * CacheWriter defined on the region.
-   */
-  public final boolean hasNetWriter(CacheDistributionAdvisor distAdvisor) {
-    return !distAdvisor.accept(netWriterVisitor, null);
-  }
-
-  /**
+  @Override
-    return (this.cache.getCacheServers().size() > 0) && !this.isUsedForPartitionedRegionAdmin
+    return !this.cache.getCacheServers().isEmpty() && !this.isUsedForPartitionedRegionAdmin
-  protected boolean shouldNotifyGatewaySender() {
-    return (this.cache.getAllGatewaySenders().size() > 0);
-  }
-
-  protected boolean shouldDispatchListenerEvent() {
+  boolean shouldDispatchListenerEvent() {
-   * Internal method to return cache as GemFireCache to avoid unnecessary typecasting.
-   * 
-   * @return this region's GemFireCache instance
-   */
-  @Override
-  public GemFireCacheImpl getGemFireCache() {
-    return this.cache;
-  }
-
-  /**
-  void cleanupForClient(CacheClientNotifier ccn, ClientProxyMembershipID client) {
-    if (this.cache.isClosed())
+  void cleanupForClient(CacheClientNotifier clientNotifier, ClientProxyMembershipID client) {
+    if (this.cache.isClosed() || this.isDestroyed) {
-    if (this.isDestroyed)
-      return;
+    }
-    this.filterProfile.cleanupForClient(ccn, client);
+    this.filterProfile.cleanupForClient(clientNotifier, client);
-    Iterator it = (new SubregionsSet(false)).iterator();
-    while (it.hasNext()) {
-      LocalRegion lr = (LocalRegion) it.next();
-      lr.cleanupForClient(ccn, client);
+    for (Object regionObject : new SubregionsSet(false)) {
+      LocalRegion region = (LocalRegion) regionObject;
+      region.cleanupForClient(clientNotifier, client);
-   * Destroys the CQ/interest profile for this region. Use this if your region does not support
-   * client interest (e.g., WAN gateway queue)
-   */
-  public void destroyFilterProfile() {
-    this.filterProfile = null;
-  }
-
-  /**
-    for (Iterator iter = this.subregions.entrySet().iterator(); iter.hasNext();) {
-      Map.Entry entry = (Map.Entry) iter.next();
+    for (Object entryObject : this.subregions.entrySet()) {
+      Map.Entry entry = (Map.Entry) entryObject;
-      map.put(subregion.getFullPath(), Integer.valueOf(subregion.getSerialNumber()));
+      map.put(subregion.getFullPath(), subregion.getSerialNumber());
-
-  public SelectResults query(String p_predicate) throws FunctionDomainException,
+  @Override
+  public SelectResults query(String predicate) throws FunctionDomainException,
-    String predicate = p_predicate;
+
-    SelectResults results = null;
+    SelectResults results;
-      String queryString = null;
-      queryString = constructRegionQueryString(predicate.trim());
+      String queryString = constructRegionQueryString(predicate.trim());
+      // TODO: params size is always zero so this whole block is wasted
-    final String queryString;// Compare the query patterns to the 'predicate'. If one matches,
-    for (int i = 0; i < QUERY_PATTERNS.length; i++) {
-      if (QUERY_PATTERNS[i].matcher(predicate).matches()) {
+    for (Pattern queryPattern : QUERY_PATTERNS) {
+      if (queryPattern.matcher(predicate).matches()) {
+    final String queryString;// Compare the query patterns to the 'predicate'. If one matches,
-   * Called from the RegionMap when the {@link RegionEntry} is synchronized and it is safe to make
-   * decisions about Entry state
-   * 
-   * @param txEvent the pending transaction event to be applied
-   */
-  protected void checkBeforeEntrySync(TXRmtEvent txEvent) {}
-
-
-  /**
-   * @param function
-   * @param args
-   * @param filter
-    if (function.optimizeForWrite() && memoryThresholdReached.get()
+    if (function.optimizeForWrite() && this.memoryThresholdReached.get()
-      Set<DistributedMember> htrm = getMemoryThresholdReachedMembers();
+      Set<DistributedMember> members = getMemoryThresholdReachedMembers();
-              .toLocalizedString(new Object[] {function.getId(), htrm}),
-          htrm);
+              .toLocalizedString(function.getId(), members),
+          members);
-    final LocalResultCollector<?, ?> localRC = execution.getLocalResultCollector(function, rc);
+    final LocalResultCollector<?, ?> resultCollector =
+        execution.getLocalResultCollector(function, rc);
-        new DistributedRegionFunctionResultSender(dm, localRC, function, sender);
+        new DistributedRegionFunctionResultSender(dm, resultCollector, function, sender);
-    return localRC;
+    return resultCollector;
-    return Collections.<DistributedMember>singleton(this.cache.getMyId());
+    return Collections.singleton(this.cache.getMyId());
-  /*
-   * (non-Javadoc)
-   * 
-   * @see org.apache.geode.cache.control.ResourceListener#onEvent(java.lang.Object)
-   */
-  public final void onEvent(MemoryEvent event) {
+  @Override
+  public void onEvent(MemoryEvent event) {
-        memoryThresholdReached.set(true);
+        this.memoryThresholdReached.set(true);
-        memoryThresholdReached.set(false);
+        this.memoryThresholdReached.set(false);
-  public int calculateValueSize(Object val) {
+  @Override
+  public int calculateValueSize(Object value) {
-  public int calculateRegionEntryValueSize(RegionEntry re) {
+  @Override
+  public int calculateRegionEntryValueSize(RegionEntry regionEntry) {
+  // TODO: return value is never used
+  @Override
+  @Override
-   * This method is meant to be overriden by DistributedRegion and PartitionedRegions to cleanup
+   * This method is meant to be overridden by DistributedRegion and PartitionedRegions to cleanup
-    Assert.assertTrue(false); // should not be called for LocalRegion
+    // should not be called for LocalRegion
+    Assert.assertTrue(false);
-   * @param critialMembers set of members whose memory is in a critical state
+   * @param criticalMembers set of members whose memory is in a critical state
-      Set<InternalDistributedMember> critialMembers) {
+      Set<InternalDistributedMember> criticalMembers) {
-      memoryThresholdReached.set(true);
+      this.memoryThresholdReached.set(true);
+  @Override
+  @Override
+  @Override
-    RegionEntry re = this.entries.getEntry(key);
-    if (re != null && re.isRemoved() && !re.isTombstone()) {
-      re = null;
+    RegionEntry regionEntry = this.entries.getEntry(key);
+    if (regionEntry != null && regionEntry.isRemoved() && !regionEntry.isTombstone()) {
+      regionEntry = null;
-    return (DiskEntry) re;
+    return (DiskEntry) regionEntry;
-   * 
-   * @param key
-   * @param key
-    public RegionPerfStats(GemFireCacheImpl cache, CachePerfStats superStats, String regionName) {
+    RegionPerfStats(InternalCache cache, CachePerfStats superStats, String regionName) {
-      stats.incInt(reliableQueuedOpsId, inc);
+      this.stats.incInt(reliableQueuedOpsId, inc);
-      stats.incInt(reliableQueueSizeId, inc);
+      this.stats.incInt(reliableQueueSizeId, inc);
-      stats.incInt(reliableQueueMaxId, inc);
+      this.stats.incInt(reliableQueueMaxId, inc);
-      stats.incInt(reliableRegionsId, inc);
+      this.stats.incInt(reliableRegionsId, inc);
-      stats.incInt(reliableRegionsMissingId, inc);
+      this.stats.incInt(reliableRegionsMissingId, inc);
-      stats.incInt(reliableRegionsQueuingId, inc);
+      this.stats.incInt(reliableRegionsQueuingId, inc);
-      stats.incInt(reliableRegionsMissingFullAccessId, inc);
+      this.stats.incInt(reliableRegionsMissingFullAccessId, inc);
-      stats.incInt(reliableRegionsMissingLimitedAccessId, inc);
+      this.stats.incInt(reliableRegionsMissingLimitedAccessId, inc);
-      stats.incInt(reliableRegionsMissingNoAccessId, inc);
+      this.stats.incInt(reliableRegionsMissingNoAccessId, inc);
-      stats.incInt(loadsInProgressId, 1);
+      this.stats.incInt(loadsInProgressId, 1);
-      // return NanoTimer.getTime(); // don't use getStatTime so always enabled
-      long ts = NanoTimer.getTime(); // don't use getStatTime so always enabled
-      stats.incLong(loadTimeId, ts - start);
-      stats.incInt(loadsInProgressId, -1);
-      stats.incInt(loadsCompletedId, 1);
-      this.cachePerfStats.endLoad(start); // need to think about timings
+
+      // don't use getStatTime so always enabled
+      long ts = NanoTimer.getTime();
+      this.stats.incLong(loadTimeId, ts - start);
+      this.stats.incInt(loadsInProgressId, -1);
+      this.stats.incInt(loadsCompletedId, 1);
+
+      // need to think about timings
+      this.cachePerfStats.endLoad(start);
-      stats.incInt(netloadsInProgressId, 1);
+      this.stats.incInt(netloadsInProgressId, 1);
-        stats.incLong(netloadTimeId, getStatTime() - start);
+        this.stats.incLong(netloadTimeId, getStatTime() - start);
-      stats.incInt(netloadsInProgressId, -1);
-      stats.incInt(netloadsCompletedId, 1);
+      this.stats.incInt(netloadsInProgressId, -1);
+      this.stats.incInt(netloadsCompletedId, 1);
-      stats.incInt(netsearchesInProgressId, 1);
+      this.stats.incInt(netsearchesInProgressId, 1);
-      // return NanoTimer.getTime(); // don't use getStatTime so always enabled
-      long ts = NanoTimer.getTime(); // don't use getStatTime so always enabled
-      stats.incLong(netsearchTimeId, ts - start);
-      stats.incInt(netsearchesInProgressId, -1);
-      stats.incInt(netsearchesCompletedId, 1);
+
+      // don't use getStatTime so always enabled
+      long ts = NanoTimer.getTime();
+      this.stats.incLong(netsearchTimeId, ts - start);
+      this.stats.incInt(netsearchesInProgressId, -1);
+      this.stats.incInt(netsearchesCompletedId, 1);
-      stats.incInt(cacheWriterCallsInProgressId, 1);
+      this.stats.incInt(cacheWriterCallsInProgressId, 1);
-        stats.incLong(cacheWriterCallTimeId, getStatTime() - start);
+        this.stats.incLong(cacheWriterCallTimeId, getStatTime() - start);
-      stats.incInt(cacheWriterCallsInProgressId, -1);
-      stats.incInt(cacheWriterCallsCompletedId, 1);
+      this.stats.incInt(cacheWriterCallsInProgressId, -1);
+      this.stats.incInt(cacheWriterCallsCompletedId, 1);
-      stats.incInt(cacheListenerCallsInProgressId, 1);
+      this.stats.incInt(cacheListenerCallsInProgressId, 1);
-        stats.incLong(cacheListenerCallTimeId, getStatTime() - start);
+        this.stats.incLong(cacheListenerCallTimeId, getStatTime() - start);
-      stats.incInt(cacheListenerCallsInProgressId, -1);
-      stats.incInt(cacheListenerCallsCompletedId, 1);
+      this.stats.incInt(cacheListenerCallsInProgressId, -1);
+      this.stats.incInt(cacheListenerCallsCompletedId, 1);
-      stats.incInt(getInitialImagesInProgressId, 1);
+      this.stats.incInt(getInitialImagesInProgressId, 1);
-        stats.incLong(getInitialImageTimeId, getStatTime() - start);
+        this.stats.incLong(getInitialImageTimeId, getStatTime() - start);
-      stats.incInt(getInitialImagesInProgressId, -1);
-      stats.incInt(getInitialImagesCompletedId, 1);
+      this.stats.incInt(getInitialImagesInProgressId, -1);
+      this.stats.incInt(getInitialImagesCompletedId, 1);
-        stats.incLong(getInitialImageTimeId, getStatTime() - start);
+        this.stats.incLong(getInitialImageTimeId, getStatTime() - start);
-      stats.incInt(getInitialImagesInProgressId, -1);
+      this.stats.incInt(getInitialImagesInProgressId, -1);
-      stats.incInt(getInitialImageKeysReceivedId, 1);
+      this.stats.incInt(getInitialImageKeysReceivedId, 1);
-      stats.incInt(indexUpdateInProgressId, 1);
+      this.stats.incInt(indexUpdateInProgressId, 1);
-      stats.incLong(indexUpdateTimeId, ts - start);
-      stats.incInt(indexUpdateInProgressId, -1);
-      stats.incInt(indexUpdateCompletedId, 1);
+      this.stats.incLong(indexUpdateTimeId, ts - start);
+      this.stats.incInt(indexUpdateInProgressId, -1);
+      this.stats.incInt(indexUpdateCompletedId, 1);
-      stats.incInt(regionsId, inc);
+      this.stats.incInt(regionsId, inc);
-      stats.incInt(partitionedRegionsId, inc);
+      this.stats.incInt(partitionedRegionsId, inc);
-      stats.incInt(destroysId, 1);
+      this.stats.incInt(destroysId, 1);
-      stats.incInt(createsId, 1);
+      this.stats.incInt(createsId, 1);
-      stats.incInt(invalidatesId, 1);
+      this.stats.incInt(invalidatesId, 1);
-    public void incTombstoneCount(int delta) {
-      stats.incInt(tombstoneCountId, delta);
-      this.cachePerfStats.incTombstoneCount(delta);
+    public void incTombstoneCount(int amount) {
+      this.stats.incInt(tombstoneCountId, amount);
+      this.cachePerfStats.incTombstoneCount(amount);
-        stats.incLong(getTimeId, getStatTime() - start);
+        this.stats.incLong(getTimeId, getStatTime() - start);
-      stats.incInt(getsId, 1);
+      this.stats.incInt(getsId, 1);
-        stats.incInt(missesId, 1);
+        this.stats.incInt(missesId, 1);
-        stats.incInt(updatesId, 1);
+        this.stats.incInt(updatesId, 1);
-          stats.incLong(updateTimeId, total);
+          this.stats.incLong(updateTimeId, total);
-        stats.incInt(putsId, 1);
+        this.stats.incInt(putsId, 1);
-          stats.incLong(putTimeId, total);
+          this.stats.incLong(putTimeId, total);
-      stats.incInt(putallsId, 1);
-      if (enableClockStats)
-        stats.incLong(putallTimeId, getStatTime() - start);
+      this.stats.incInt(putallsId, 1);
+      if (enableClockStats) {
+        this.stats.incLong(putallTimeId, getStatTime() - start);
+      }
-      stats.incInt(queryExecutionsId, 1);
+      this.stats.incInt(queryExecutionsId, 1);
-        stats.incLong(queryExecutionTimeId, executionTime);
+        this.stats.incLong(queryExecutionTimeId, executionTime);
-        stats.incLong(queryResultsHashCollisionProbeTimeId, getStatTime() - start);
+        this.stats.incLong(queryResultsHashCollisionProbeTimeId, getStatTime() - start);
-      stats.incInt(queryResultsHashCollisionsId, 1);
+      this.stats.incInt(queryResultsHashCollisionsId, 1);
-      stats.incLong(txConflictCheckTimeId, delta);
+      this.stats.incLong(txConflictCheckTimeId, delta);
-      stats.incInt(txCommitsId, 1);
-      stats.incInt(txCommitChangesId, txChanges);
-      stats.incLong(txCommitTimeId, opTime);
-      stats.incLong(txSuccessLifeTimeId, txLifeTime);
+      this.stats.incInt(txCommitsId, 1);
+      this.stats.incInt(txCommitChangesId, txChanges);
+      this.stats.incLong(txCommitTimeId, opTime);
+      this.stats.incLong(txSuccessLifeTimeId, txLifeTime);
-      stats.incInt(txFailuresId, 1);
-      stats.incInt(txFailureChangesId, txChanges);
-      stats.incLong(txFailureTimeId, opTime);
-      stats.incLong(txFailedLifeTimeId, txLifeTime);
+      this.stats.incInt(txFailuresId, 1);
+      this.stats.incInt(txFailureChangesId, txChanges);
+      this.stats.incLong(txFailureTimeId, opTime);
+      this.stats.incLong(txFailedLifeTimeId, txLifeTime);
-      stats.incInt(txRollbacksId, 1);
-      stats.incInt(txRollbackChangesId, txChanges);
-      stats.incLong(txRollbackTimeId, opTime);
-      stats.incLong(txRollbackLifeTimeId, txLifeTime);
+      this.stats.incInt(txRollbacksId, 1);
+      this.stats.incInt(txRollbackChangesId, txChanges);
+      this.stats.incLong(txRollbackTimeId, opTime);
+      this.stats.incLong(txRollbackLifeTimeId, txLifeTime);
-      stats.incLong(importedEntriesCountId, entryCount);
+      this.stats.incLong(importedEntriesCountId, entryCount);
-        stats.incLong(importTimeId, getStatTime() - start);
+        this.stats.incLong(importTimeId, getStatTime() - start);
-      cachePerfStats.endImport(entryCount, start);
+      this.cachePerfStats.endImport(entryCount, start);
-      stats.incLong(exportedEntriesCountId, entryCount);
+      this.stats.incLong(exportedEntriesCountId, entryCount);
-        stats.incLong(exportTimeId, getStatTime() - start);
+        this.stats.incLong(exportTimeId, getStatTime() - start);
-      cachePerfStats.endExport(entryCount, start);
+      this.cachePerfStats.endExport(entryCount, start);
+    @Override
-      stats.incLong(compressionCompressionsId, 1);
-      cachePerfStats.stats.incLong(compressionCompressionsId, 1);
+      this.stats.incLong(compressionCompressionsId, 1);
+      this.cachePerfStats.stats.incLong(compressionCompressionsId, 1);
+    @Override
-        stats.incLong(compressionCompressTimeId, time);
-        cachePerfStats.stats.incLong(compressionCompressTimeId, time);
+        this.stats.incLong(compressionCompressTimeId, time);
+        this.cachePerfStats.stats.incLong(compressionCompressTimeId, time);
-      stats.incLong(compressionPreCompressedBytesId, startSize);
-      stats.incLong(compressionPostCompressedBytesId, endSize);
+      this.stats.incLong(compressionPreCompressedBytesId, startSize);
+      this.stats.incLong(compressionPostCompressedBytesId, endSize);
-      cachePerfStats.stats.incLong(compressionPreCompressedBytesId, startSize);
-      cachePerfStats.stats.incLong(compressionPostCompressedBytesId, endSize);
+      this.cachePerfStats.stats.incLong(compressionPreCompressedBytesId, startSize);
+      this.cachePerfStats.stats.incLong(compressionPostCompressedBytesId, endSize);
+    @Override
-      stats.incLong(compressionDecompressionsId, 1);
-      cachePerfStats.stats.incLong(compressionDecompressionsId, 1);
+      this.stats.incLong(compressionDecompressionsId, 1);
+      this.cachePerfStats.stats.incLong(compressionDecompressionsId, 1);
+    @Override
-        stats.incLong(compressionDecompressTimeId, time);
-        cachePerfStats.stats.incLong(compressionDecompressTimeId, time);
+        this.stats.incLong(compressionDecompressTimeId, time);
+        this.cachePerfStats.stats.incLong(compressionDecompressTimeId, time);
-        ((AbstractRegionMap) (this.entries)).verifyTombstoneCount(this.tombstoneCount);
+        ((AbstractRegionMap) this.entries).verifyTombstoneCount(this.tombstoneCount);
-  /** test hook - verify tombstone count matches what is in the entry map */
-  public void verifyTombstoneCount() {
-    synchronized (this.entries) {
-      if (this.entries instanceof AbstractRegionMap) {
-        // if (!((AbstractRegionMap)(this.entries)).verifyTombstoneCount(this.tombstoneCount)) {
-        // throw new RuntimeException("tombstone count is wrong in " + this);
-        // }
-      }
-    }
-  }
-
-  ////////////////// ConcurrentMap methods //////////////////
-
-    if (this.srp == null && ((this.dataPolicy == DataPolicy.NORMAL && this.scope.isDistributed())
-        || this.dataPolicy == DataPolicy.EMPTY)) {
+    if (this.serverRegionProxy == null
+        && (this.dataPolicy == DataPolicy.NORMAL && this.scope.isDistributed()
+            || this.dataPolicy == DataPolicy.EMPTY)) {
-   * @param callbackArgument
-   * @throws TimeoutException if timed out getting distributed lock for <code>Scope.GLOBAL</code>
+   * @throws TimeoutException if timed out getting distributed lock for {@code Scope.GLOBAL}
+
-    // if (value == null) {
-    // throw new
-    // NullPointerException(LocalizedStrings.LocalRegion_VALUE_MUST_NOT_BE_NULL.toLocalizedString());
-    // }
+
+
-    final Object oldValue = null;
-    final boolean ifNew = true;
-    final boolean ifOld = false;
-    final boolean requireOldValue = true;
+
-        event.setNewEventId(cache.getDistributedSystem());
+        event.setNewEventId(this.cache.getDistributedSystem());
+      final Object oldValue = null;
+      final boolean ifNew = true;
+      final boolean ifOld = false;
+      final boolean requireOldValue = true;
-    } catch (EntryNotFoundException e) {
+    } catch (EntryNotFoundException ignore) {
-  /*
-   * (non-Javadoc)
-   * 
-   * @see java.util.concurrent.ConcurrentMap#putIfAbsent(java.lang.Object, java.lang.Object)
-   */
+  @Override
-  /*
-   * (non-Javadoc)
-   * 
-   * @see java.util.concurrent.ConcurrentMap#remove(java.lang.Object, java.lang.Object)
-   */
+  @Override
-  // @todo expand on this javadoc
-  public boolean remove(Object key, Object pvalue, Object callbackArg) {
-    Object value = pvalue;
+  public boolean remove(Object key, Object value, Object callbackArg) {
+
+
-    EntryEventImpl event = EntryEventImpl.create(this, Operation.REMOVE, key, null, // newValue
-        callbackArg, false, getMyId());
+    EntryEventImpl event =
+        EntryEventImpl.create(this, Operation.REMOVE, key, null, callbackArg, false, getMyId());
-    } catch (EntryNotFoundException enfe) {
+
+    } catch (EntryNotFoundException ignore) {
-        RegionDestroyedException rde2 = new RegionDestroyedException(toString(), getFullPath());
-        rde2.initCause(rde);
-        throw rde2;
+        throw new RegionDestroyedException(toString(), getFullPath(), rde);
+  @Override
-  public boolean replace(Object key, Object pexpectedOldValue, Object newValue,
-      Object callbackArg) {
+  public boolean replace(Object key, Object expectedOldValue, Object newValue, Object callbackArg) {
-    Object expectedOldValue = pexpectedOldValue;
+
+
-    EntryEventImpl event =
-        EntryEventImpl.create(this, Operation.REPLACE, key, newValue, callbackArg, false, // originRemote
-            getMyId());
+    EntryEventImpl event = EntryEventImpl.create(this, Operation.REPLACE, key, newValue,
+        callbackArg, false, getMyId());
-        event.setNewEventId(cache.getDistributedSystem());
+        event.setNewEventId(this.cache.getDistributedSystem());
-      if (!basicPut(event, false, // ifNew
-          true, // ifOld
-          expectedOldValue, false // requireOldValue
-      )) {
+      if (!basicPut(event, false, true, expectedOldValue, false)) {
-    } catch (EntryNotFoundException e) { // put failed on server
+
+    } catch (EntryNotFoundException ignore) {
+      // put failed on server
+  @Override
+   * <p>
+   * TODO: callbackArg is always null but this method is for callbacks??
-  public Object replaceWithCallbackArgument(Object key, Object value, Object callbackArg) {
+  private Object replaceWithCallbackArgument(Object key, Object value, Object callbackArg) {
+
-        EntryEventImpl.create(this, Operation.REPLACE, key, value, callbackArg, false, // originRemote
-            getMyId());
+        EntryEventImpl.create(this, Operation.REPLACE, key, value, callbackArg, false, getMyId());
+
-        event.setNewEventId(cache.getDistributedSystem());
+        event.setNewEventId(this.cache.getDistributedSystem());
-      if (!basicPut(event, false, // ifNew
-          true, // ifOld
-          null, // expectedOldValue
-          true // requireOldValue
-      )) {
+      if (!basicPut(event, false, true, null, true)) {
-    } catch (EntryNotFoundException enf) {// put failed on server
+
+    } catch (EntryNotFoundException ignore) {
+      // put failed on server
+  // TODO: fromClient is always null
-      Object p_callbackArg, final ClientProxyMembershipID client, boolean fromClient,
+      Object callbackArg, final ClientProxyMembershipID client, boolean fromClient,
+
-    Object callbackArg = p_callbackArg;
+
-    final EntryEventImpl event = EntryEventImpl.create(this, Operation.PUT_IF_ABSENT, key,
-        null /* new value */, callbackArg, false /* origin remote */, client.getDistributedMember(),
-        true /* generateCallbacks */, eventId);
+    final EntryEventImpl event = EntryEventImpl.create(this, Operation.PUT_IF_ABSENT, key, null,
+        callbackArg, false, client.getDistributedMember(), true, eventId);
+
-      /// *
-      validateArguments(key, event.basicGetNewValue(), p_callbackArg);
+      validateArguments(key, event.basicGetNewValue(), callbackArg);
-      boolean ifNew = true; // cannot overwrite an existing key
-      boolean ifOld = false; // can create a new key
-      boolean requireOldValue = true; // need the old value if the create fails
+      // cannot overwrite an existing key
+      boolean ifNew = true;
+      // can create a new key
+      boolean ifOld = false;
+      // need the old value if the create fails
+      boolean requireOldValue = true;
+
+
+
+
+
-
+  // TODO: fromClient is always true
-      boolean isObject, Object p_callbackArg, final ClientProxyMembershipID client,
+      boolean isObject, Object callbackArg, final ClientProxyMembershipID client,
+
-    Object callbackArg = p_callbackArg;
+
-    final EntryEventImpl event = EntryEventImpl.create(this, Operation.REPLACE, key,
-        null /* new value */, callbackArg, false /* origin remote */, client.getDistributedMember(),
-        true /* generateCallbacks */, eventId);
+    final EntryEventImpl event = EntryEventImpl.create(this, Operation.REPLACE, key, null,
+        callbackArg, false, client.getDistributedMember(), true, eventId);
+
-      /// *
-      validateArguments(key, event.basicGetNewValue(), p_callbackArg);
+      validateArguments(key, event.basicGetNewValue(), callbackArg);
-      boolean ifNew = false; // can overwrite an existing key
-      boolean ifOld = true; // cannot create a new key
+      // can overwrite an existing key
+      boolean ifNew = false;
+      // cannot create a new key
+      boolean ifOld = true;
+
+
+
+
+  // TODO: fromClient is always true
-      Object p_callbackArg, final ClientProxyMembershipID client, boolean fromClient,
+      Object callbackArg, final ClientProxyMembershipID client, boolean fromClient,
+
-    Object callbackArg = p_callbackArg;
+
-    final EntryEventImpl event = EntryEventImpl.create(this, Operation.REPLACE, key,
-        null /* new value */, callbackArg, false /* origin remote */, client.getDistributedMember(),
-        true /* generateCallbacks */, eventId);
+    final EntryEventImpl event = EntryEventImpl.create(this, Operation.REPLACE, key, null,
+        callbackArg, false, client.getDistributedMember(), true, eventId);
+
-      /// *
-      validateArguments(key, event.basicGetNewValue(), p_callbackArg);
+      validateArguments(key, event.basicGetNewValue(), callbackArg);
-      boolean ifNew = false; // can overwrite an existing key
-      boolean ifOld = true; // cannot create a new key
+      // can overwrite an existing key
+      boolean ifNew = false;
+      // cannot create a new key
+      boolean ifOld = true;
+
+
+
-        if (oldValue == null) { // EntryEventImpl.setOldValue translates INVALID to null
+        if (oldValue == null) {
+          // EntryEventImpl.setOldValue translates INVALID to null
-  public void basicBridgeRemove(Object key, Object expectedOldValue, Object p_callbackArg,
+  // TODO: fromClient is always true
+  public void basicBridgeRemove(Object key, Object expectedOldValue, Object callbackArg,
-    Object callbackArg = p_callbackArg;
+
-    final EntryEventImpl event = EntryEventImpl.create(this, Operation.REMOVE, key,
-        null /* new value */, callbackArg, false /* origin remote */,
-        memberId.getDistributedMember(), true /* generateCallbacks */, clientEvent.getEventId());
+    final EntryEventImpl event = EntryEventImpl.create(this, Operation.REMOVE, key, null,
+        callbackArg, false, memberId.getDistributedMember(), true, clientEvent.getEventId());
+
-        basicDestroy(event, true, // cacheWrite
-            expectedOldValue);
+        basicDestroy(event, true, expectedOldValue);
-  /*
-   * (non-Javadoc)
-   * 
-   * @see
-   * org.apache.geode.internal.cache.DiskRecoveryStore#getVersionForMember(org.apache.geode.internal
-   * .cache.versions.VersionSource)
-   */
-   * 
+   *
+   * TODO: none of the parameters are ever used
+   *
-  /**
-   * Return an IndexMap that is persisted to the disk store used by this region. This method returns
-   * map that might not support range queries.
-   * 
-   * This IndexMap should be used as the backing map for any regions that are using the Soplog
-   * persistence.
-   * 
-   * Calling this method may create a branch new index map on disk, or it may recover an index map
-   * that was previously persisted, depending on whether the index previously existed.
-   * 
-   * @param indexName the name of the index
-   * @param indexedExpression the index expression
-   * @param fromClause the from clause.
-   * 
-   * @return The index map.
-   * 
-   * @throws IllegalStateException if this region is not using soplog persistence
-   * 
-   * @throws IllegalStateException if this index was previously persisted with a different
-   *         expression or from clause.
-   * 
-   */
-  public IndexMap getUnsortedIndexMap(String indexName, String indexedExpression,
-      String fromClause) {
-    return new IndexMapImpl();
-  }
-  ////////////////// End of ConcurrentMap methods //////////////////
-
-  public void setInUseByTransaction(boolean v) {
+  void setInUseByTransaction(boolean value) {
-      if (v) {
+      if (value) {
-  public boolean expireRegion(RegionExpiryTask regionExpiryTask, boolean distributed,
-      boolean destroy) {
+  boolean expireRegion(RegionExpiryTask regionExpiryTask, boolean distributed, boolean destroy) {
-    { // release the sync before doing the operation to prevent deadlock caused by r48875
-      Operation op = destroy
-          ? (distributed ? Operation.REGION_EXPIRE_DESTROY : Operation.REGION_EXPIRE_LOCAL_DESTROY)
-          : (distributed ? Operation.REGION_EXPIRE_INVALIDATE
-              : Operation.REGION_EXPIRE_LOCAL_INVALIDATE);
-      RegionEventImpl event =
-          new RegionEventImpl(this, op, null, false, getMyId(), generateEventID());
-      if (destroy) {
-        basicDestroyRegion(event, distributed);
-      } else {
-        basicInvalidateRegion(event);
-      }
-      return true;
+    // release the sync before doing the operation to prevent deadlock caused by r48875
+    Operation op = destroy
+        ? distributed ? Operation.REGION_EXPIRE_DESTROY : Operation.REGION_EXPIRE_LOCAL_DESTROY
+        : distributed ? Operation.REGION_EXPIRE_INVALIDATE
+            : Operation.REGION_EXPIRE_LOCAL_INVALIDATE;
+    RegionEventImpl event =
+        new RegionEventImpl(this, op, null, false, getMyId(), generateEventID());
+    if (destroy) {
+      basicDestroyRegion(event, distributed);
+    } else {
+      basicInvalidateRegion(event);
-  }
-
-  private boolean isTest = false;
-  protected static boolean simulateClearForTests = false;
-
-  private AtomicInteger countNotFoundInLocal = null;
-
-  public void setIsTest() {
-    isTest = true;
-    countNotFoundInLocal = new AtomicInteger();
-  }
-
-  public boolean isTest() {
-    return isTest;
-  }
-
-  public void incCountNotFoundInLocal() {
-    countNotFoundInLocal.incrementAndGet();
-  }
-
-  public Integer getCountNotFoundInLocal() {
-    return countNotFoundInLocal.get();
-  }
-
-  public static void simulateClearForTests(boolean flag) {
-    simulateClearForTests = flag;
-
+    return true;

MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 MOV31 INS40 UPD40 INS40 UPD40 INS40 UPD40 INS40 INS40 MOV31 INS31 INS31 INS74 INS29 INS29 INS29 INS29 INS29 INS29 INS29 UPD83 UPD83 INS29 INS83 INS83 INS83 INS83 INS83 INS83 INS83 INS29 UPD83 INS83 INS83 MOV43 MOV43 INS78 INS78 INS44 MOV60 INS78 UPD83 UPD83 INS78 INS78 INS29 UPD83 INS78 INS78 INS78 INS78 INS78 MOV8 INS78 INS78 INS78 INS78 INS78 INS78 INS78 INS78 INS78 INS78 INS78 INS78 UPD83 INS78 INS78 UPD42 INS78 UPD42 MOV44 INS78 INS78 INS78 INS78 INS78 INS78 MOV8 MOV60 MOV60 MOV60 UPD83 UPD83 UPD83 UPD83 UPD39 UPD83 INS83 UPD83 INS78 UPD83 MOV60 UPD83 MOV43 MOV25 MOV60 MOV44 INS78 INS78 INS78 INS78 INS78 INS78 INS78 INS78 INS78 INS78 INS78 INS78 INS78 INS78 UPD83 UPD83 UPD83 UPD83 INS78 INS78 INS78 INS78 INS74 INS78 INS78 INS78 INS44 INS78 MOV44 INS78 INS78 INS78 INS44 INS44 INS29 MOV29 MOV60 UPD83 INS78 MOV8 MOV60 MOV8 MOV43 MOV44 INS78 UPD83 MOV43 INS78 MOV43 MOV44 MOV8 UPD83 UPD83 INS42 INS8 UPD83 MOV44 INS78 INS78 INS78 INS78 INS78 INS78 MOV44 INS44 MOV78 MOV83 MOV39 UPD42 MOV42 MOV44 MOV44 MOV8 MOV60 MOV60 UPD83 UPD83 UPD83 INS78 INS78 INS78 INS78 INS78 MOV60 INS78 MOV78 INS78 MOV83 MOV39 MOV42 MOV44 MOV8 INS78 INS78 INS78 INS78 INS78 MOV44 INS78 INS78 MOV78 MOV78 UPD83 MOV44 MOV44 MOV8 MOV43 MOV43 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 UPD43 UPD42 UPD42 INS42 INS42 MOV43 INS42 INS42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 INS65 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS54 INS60 INS60 INS60 INS60 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS25 MOV25 MOV21 MOV25 MOV21 MOV25 INS54 MOV43 MOV42 MOV60 MOV25 MOV60 UPD42 UPD42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV43 INS43 INS42 INS42 INS70 INS70 UPD42 INS70 INS70 UPD42 MOV60 INS42 MOV43 INS42 INS60 INS41 INS42 UPD42 MOV60 MOV41 INS42 INS42 INS42 MOV43 INS42 UPD42 UPD42 MOV43 INS42 UPD42 MOV43 UPD42 INS43 UPD42 INS43 UPD42 UPD42 INS43 INS42 INS43 INS42 UPD42 MOV65 MOV65 UPD42 UPD42 UPD42 INS42 MOV60 INS25 MOV41 UPD42 UPD42 UPD42 INS70 UPD42 MOV43 INS42 INS42 INS70 INS70 INS70 INS70 UPD42 INS42 INS41 UPD42 MOV25 INS25 INS25 INS25 INS25 INS25 INS78 MOV78 UPD42 UPD42 MOV43 INS42 MOV43 INS42 INS70 INS60 MOV60 INS60 MOV25 UPD42 MOV60 UPD42 MOV43 INS42 INS21 UPD42 INS70 MOV78 INS8 MOV8 INS78 MOV29 UPD83 MOV43 INS42 UPD83 MOV43 INS42 INS78 INS78 MOV43 INS42 INS8 INS78 INS78 INS78 INS78 MOV43 INS78 INS78 INS42 INS42 INS42 INS70 INS42 INS42 INS42 UPD42 UPD42 INS70 UPD74 INS43 INS42 UPD43 UPD42 INS25 UPD74 MOV25 MOV60 MOV60 MOV43 UPD42 INS25 MOV43 INS42 MOV25 MOV43 UPD42 INS70 INS42 INS65 INS42 INS42 INS42 UPD42 INS70 INS70 INS42 UPD42 INS70 INS42 UPD42 INS42 UPD42 INS42 INS42 UPD42 INS42 INS42 INS42 MOV60 INS78 INS78 MOV44 MOV44 INS78 MOV44 MOV44 INS78 INS78 INS78 MOV78 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV51 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 UPD74 INS66 UPD66 INS66 INS66 INS66 UPD66 MOV66 MOV66 MOV66 INS66 INS66 INS66 INS66 UPD66 MOV66 MOV65 INS66 INS66 INS66 INS65 INS60 MOV60 UPD42 UPD66 INS66 INS65 UPD66 UPD42 UPD42 INS68 UPD42 UPD42 MOV8 MOV12 MOV12 INS74 INS59 MOV43 INS59 INS74 INS59 MOV43 INS59 MOV14 INS66 INS65 UPD66 INS66 INS65 UPD66 MOV32 MOV38 INS8 MOV32 MOV8 INS12 UPD27 MOV27 INS83 INS39 INS59 MOV27 INS43 INS39 UPD66 INS65 INS66 UPD66 UPD66 UPD66 INS65 INS66 UPD66 UPD66 UPD66 INS65 INS66 UPD66 UPD66 INS65 INS66 INS27 INS32 UPD42 INS8 UPD66 UPD66 INS65 INS66 UPD66 INS65 INS66 MOV42 UPD42 INS8 MOV60 INS42 INS44 INS32 MOV8 MOV58 MOV32 INS44 INS32 MOV8 MOV32 INS44 INS42 MOV8 INS44 INS42 MOV8 MOV32 INS66 UPD42 UPD66 MOV60 INS32 INS8 MOV43 UPD42 MOV43 INS42 INS8 INS43 UPD42 INS43 INS59 INS11 INS43 UPD66 UPD66 INS42 INS42 MOV43 MOV78 MOV43 MOV43 MOV78 MOV43 INS42 MOV43 MOV78 MOV43 INS42 UPD66 UPD66 UPD66 UPD66 UPD66 UPD42 UPD42 UPD42 UPD42 MOV60 MOV8 INS12 INS27 MOV22 MOV8 INS27 MOV27 MOV43 UPD42 UPD42 UPD42 MOV43 UPD42 UPD42 MOV44 INS42 INS8 MOV43 INS44 MOV32 INS8 UPD42 INS44 MOV32 INS8 UPD42 MOV44 MOV32 INS8 UPD42 INS44 MOV32 MOV8 MOV27 INS32 INS66 INS65 UPD66 UPD66 INS66 INS65 UPD66 INS27 MOV8 MOV27 MOV8 MOV27 MOV8 MOV27 MOV8 MOV27 MOV8 UPD42 UPD42 MOV43 INS42 INS25 INS42 INS41 MOV8 INS44 MOV32 MOV8 MOV43 INS59 INS83 MOV43 INS59 MOV8 INS22 MOV8 MOV43 MOV32 MOV32 INS44 INS42 MOV8 MOV60 INS24 MOV41 MOV60 MOV41 INS42 MOV60 INS60 INS42 INS42 INS41 INS42 INS42 INS21 INS42 INS42 MOV21 INS42 UPD42 MOV41 INS42 INS43 INS42 UPD66 UPD27 MOV27 INS44 MOV14 MOV8 UPD42 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD42 UPD42 MOV43 INS44 INS42 MOV8 UPD43 MOV43 INS42 UPD42 MOV27 INS8 INS43 UPD43 MOV14 INS27 INS8 INS44 MOV32 INS8 INS66 UPD27 MOV27 INS27 INS8 INS44 MOV14 INS8 INS44 MOV32 MOV8 INS44 INS42 MOV8 UPD42 UPD66 UPD42 INS43 UPD43 MOV25 MOV25 MOV25 MOV25 MOV25 INS42 UPD42 INS21 MOV25 MOV8 MOV25 MOV25 INS42 MOV25 INS42 MOV25 INS42 MOV41 INS42 INS42 MOV41 UPD27 MOV27 MOV36 UPD66 INS65 INS12 MOV12 INS66 INS66 INS66 INS66 MOV43 INS59 MOV66 MOV66 INS22 UPD42 UPD42 INS32 UPD42 INS22 INS22 UPD42 MOV25 INS42 INS42 MOV69 MOV69 MOV69 MOV69 MOV69 MOV69 UPD42 MOV11 UPD42 MOV43 MOV43 INS42 INS32 INS42 MOV32 MOV43 INS43 INS42 INS32 INS42 MOV32 MOV60 MOV27 INS66 INS66 UPD42 MOV42 INS25 MOV21 INS25 INS44 MOV8 MOV27 UPD42 UPD42 INS42 INS32 INS42 UPD42 MOV32 UPD42 INS27 INS27 INS66 INS66 INS66 INS66 UPD42 INS42 INS33 UPD42 INS42 INS42 INS42 UPD42 MOV53 INS66 INS66 UPD42 INS70 MOV53 MOV43 INS42 UPD42 MOV42 INS9 INS60 MOV60 INS60 MOV43 INS42 MOV42 MOV9 UPD42 MOV43 INS42 INS83 MOV43 INS42 INS70 MOV42 UPD42 MOV42 MOV53 UPD42 UPD42 INS60 INS60 MOV25 UPD42 UPD42 MOV32 INS41 MOV21 INS42 UPD42 INS42 INS42 INS32 UPD42 MOV43 INS42 INS42 UPD42 UPD42 UPD42 UPD42 MOV22 UPD42 MOV22 UPD42 UPD42 UPD42 UPD42 UPD42 INS27 MOV22 UPD42 UPD42 UPD42 UPD42 MOV44 UPD42 INS22 UPD42 MOV60 INS60 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV60 INS70 INS44 MOV8 INS27 MOV27 MOV32 MOV27 MOV32 UPD42 UPD40 UPD42 MOV27 UPD42 UPD42 UPD42 UPD42 MOV60 MOV21 MOV25 INS70 UPD42 UPD42 UPD42 UPD42 MOV43 INS42 MOV21 MOV38 UPD42 MOV43 INS42 MOV60 MOV25 UPD42 UPD42 MOV60 MOV25 UPD42 INS43 INS42 UPD42 UPD42 UPD42 MOV32 UPD42 MOV32 MOV42 MOV32 UPD42 INS66 INS66 INS22 INS33 INS22 INS22 INS22 MOV8 MOV8 INS8 INS27 INS32 MOV8 INS22 INS32 MOV60 MOV25 MOV25 MOV60 MOV25 MOV25 MOV8 INS21 UPD42 MOV21 MOV43 INS42 INS42 MOV32 UPD42 UPD42 UPD42 INS42 INS32 UPD42 UPD42 UPD42 INS52 INS42 UPD42 UPD42 INS22 UPD42 UPD42 UPD42 INS42 UPD42 MOV43 INS42 INS58 MOV32 MOV8 UPD42 MOV43 INS59 INS27 INS32 MOV43 INS32 MOV8 INS27 INS42 MOV43 INS42 UPD42 UPD42 INS22 INS70 MOV43 INS42 UPD42 UPD42 UPD42 INS21 MOV21 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV38 MOV22 INS32 MOV21 INS21 MOV43 MOV21 MOV43 MOV43 INS42 MOV60 MOV25 UPD42 UPD42 INS38 MOV38 MOV38 MOV38 MOV32 MOV22 INS41 UPD42 MOV43 INS42 MOV60 MOV21 INS43 INS42 INS43 INS42 UPD42 INS42 UPD42 UPD42 UPD42 INS8 INS32 INS66 MOV60 MOV60 MOV60 MOV60 INS44 INS44 MOV8 MOV44 INS21 MOV21 INS42 MOV32 UPD42 UPD42 UPD42 MOV32 UPD42 UPD42 MOV27 INS52 INS42 UPD42 UPD42 INS84 MOV22 INS42 INS52 INS42 INS22 INS52 INS42 MOV8 INS62 INS25 UPD42 INS53 INS27 UPD42 MOV32 MOV42 UPD42 INS42 UPD42 MOV42 MOV42 MOV42 MOV42 MOV42 MOV42 UPD42 MOV32 UPD42 MOV38 INS8 MOV27 MOV8 MOV43 INS42 UPD42 UPD74 UPD42 MOV32 INS42 INS22 INS27 INS27 MOV38 MOV27 UPD42 INS32 INS32 MOV8 MOV43 INS42 UPD42 INS44 MOV32 MOV8 UPD42 INS43 INS59 MOV43 INS59 UPD43 MOV43 MOV43 INS8 INS44 INS42 MOV8 INS32 INS39 INS59 MOV43 INS59 INS8 UPD42 INS32 UPD42 UPD42 MOV22 INS42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 MOV32 INS12 MOV38 INS27 UPD42 MOV32 MOV32 MOV12 UPD42 MOV32 MOV32 INS8 UPD42 INS52 INS42 MOV32 UPD42 MOV43 INS59 UPD42 INS83 MOV32 UPD42 MOV43 UPD42 MOV27 INS44 INS42 MOV8 INS8 MOV43 INS42 INS42 INS34 UPD42 MOV42 MOV33 MOV43 INS44 INS42 INS8 UPD43 MOV43 UPD42 UPD42 MOV43 MOV43 UPD42 MOV42 MOV12 UPD42 UPD42 UPD42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS52 INS42 INS22 INS22 INS42 UPD42 INS41 INS22 INS8 INS22 INS33 MOV41 INS22 MOV42 INS52 INS42 MOV22 MOV42 UPD42 UPD42 MOV43 MOV43 MOV43 INS7 MOV32 MOV43 UPD42 INS42 UPD42 INS52 INS42 INS22 MOV43 INS59 MOV43 UPD42 UPD42 INS42 INS32 MOV22 INS27 INS32 INS42 INS42 UPD42 UPD42 UPD42 MOV22 UPD42 UPD42 MOV32 INS27 UPD42 UPD42 UPD42 UPD42 INS52 INS42 MOV44 INS42 MOV8 UPD42 UPD42 INS32 MOV32 INS12 UPD42 MOV32 MOV12 UPD42 INS32 INS42 INS32 MOV43 INS78 INS78 MOV32 UPD42 MOV42 MOV43 MOV32 MOV43 INS42 INS22 UPD42 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 MOV27 INS22 MOV38 INS22 INS22 INS22 MOV38 INS22 INS22 INS22 INS22 MOV38 INS22 INS22 INS22 MOV38 INS22 INS22 INS22 MOV38 INS22 INS22 MOV21 INS22 MOV38 INS22 INS22 MOV38 INS22 INS22 INS22 MOV27 INS22 MOV38 INS22 INS22 INS22 INS22 INS22 INS22 INS22 UPD42 INS22 INS42 INS42 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 MOV60 INS22 INS22 INS22 INS22 INS22 INS22 MOV60 MOV21 INS33 INS27 MOV32 MOV8 MOV43 INS42 MOV43 INS42 MOV8 UPD42 MOV32 UPD42 INS32 UPD42 MOV16 MOV16 MOV42 INS22 UPD42 UPD42 MOV43 MOV43 MOV14 INS32 UPD42 INS52 INS42 UPD42 UPD42 MOV41 UPD42 UPD42 INS42 INS43 MOV38 INS8 INS14 INS60 INS32 INS62 MOV60 UPD42 UPD42 UPD42 UPD42 MOV41 UPD42 INS21 INS54 UPD42 INS52 INS42 UPD42 UPD42 INS42 INS40 INS42 INS40 INS42 INS42 MOV32 INS42 INS42 INS42 INS42 UPD42 UPD42 UPD42 MOV43 INS42 INS22 INS22 UPD42 INS70 INS42 INS42 INS11 INS70 INS42 MOV32 INS42 UPD42 INS18 INS43 INS42 UPD45 INS32 UPD42 INS21 MOV14 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS42 INS16 UPD42 UPD42 INS21 UPD42 MOV42 MOV32 INS42 INS33 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV22 UPD42 MOV22 UPD42 UPD42 MOV60 MOV60 MOV60 MOV60 INS44 MOV8 MOV42 MOV33 MOV53 UPD42 UPD42 UPD42 INS42 INS33 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV60 MOV60 INS42 INS27 MOV27 UPD42 MOV27 MOV43 INS42 INS41 UPD42 UPD42 UPD42 UPD40 UPD42 UPD42 UPD42 UPD42 UPD40 UPD42 INS83 MOV43 INS42 MOV21 UPD42 UPD42 UPD42 UPD42 INS22 UPD42 UPD42 MOV42 UPD42 UPD42 UPD42 INS8 UPD42 UPD42 INS52 INS42 MOV27 INS52 INS42 MOV27 INS52 INS42 UPD42 MOV27 MOV27 MOV9 INS52 INS42 INS8 INS41 INS52 INS42 INS8 MOV22 MOV52 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS32 UPD42 UPD42 UPD42 UPD42 MOV32 UPD42 UPD42 INS52 INS42 UPD42 INS42 INS32 INS22 MOV52 INS42 INS22 MOV32 MOV33 INS42 INS42 INS32 MOV32 INS32 UPD42 UPD42 INS22 INS42 INS42 INS32 MOV32 INS44 MOV44 MOV44 INS8 MOV32 MOV44 MOV60 MOV44 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS22 UPD42 UPD43 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV32 MOV32 INS52 INS42 UPD42 UPD42 INS22 UPD42 UPD42 UPD42 UPD42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS42 INS52 INS42 INS52 INS42 INS22 INS42 INS22 INS42 INS52 INS42 INS22 INS42 UPD42 MOV27 INS27 INS21 INS21 INS42 INS42 MOV32 INS42 UPD42 UPD42 UPD42 INS52 INS42 INS42 MOV22 INS42 INS8 INS22 INS22 INS42 INS38 UPD42 MOV42 INS21 MOV43 MOV32 INS42 MOV5 INS59 UPD42 INS22 INS32 UPD42 MOV42 INS42 INS43 MOV38 MOV25 MOV27 UPD40 INS27 UPD42 UPD42 UPD42 INS22 UPD42 INS32 MOV8 MOV12 UPD40 MOV8 MOV27 UPD42 UPD42 UPD43 INS52 INS42 UPD42 INS52 INS42 INS44 MOV32 MOV8 INS43 INS42 INS44 INS42 MOV8 INS8 UPD43 INS42 INS8 MOV43 INS42 MOV43 UPD43 INS42 UPD42 MOV42 INS42 INS7 INS42 INS8 UPD42 MOV42 MOV42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV32 UPD42 UPD42 MOV7 UPD42 INS8 UPD42 INS43 INS42 UPD42 UPD42 UPD42 MOV32 UPD42 INS42 UPD42 UPD42 INS22 UPD42 INS42 MOV27 UPD42 INS22 MOV43 MOV14 INS42 UPD42 MOV43 INS42 INS22 UPD42 UPD42 INS52 INS42 MOV43 INS42 UPD42 MOV42 UPD42 UPD42 INS22 INS22 UPD40 INS41 INS22 UPD40 MOV9 INS41 INS22 MOV43 MOV43 UPD42 UPD42 MOV12 MOV12 UPD42 MOV12 MOV12 MOV43 UPD42 MOV22 INS42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV32 UPD43 INS84 UPD42 MOV43 INS78 INS78 UPD42 INS42 INS52 INS42 MOV43 INS52 INS42 MOV52 INS22 UPD43 MOV22 INS42 UPD42 MOV42 INS42 INS42 UPD42 INS52 INS42 MOV32 UPD42 MOV42 MOV43 INS42 INS22 INS42 MOV43 MOV43 INS42 INS61 INS39 INS21 INS22 MOV43 UPD42 MOV61 UPD42 MOV42 UPD42 INS52 INS42 UPD42 MOV43 INS42 MOV43 INS42 INS42 MOV32 INS42 INS52 INS42 INS22 UPD42 INS22 UPD42 INS22 UPD42 INS22 UPD42 INS22 UPD42 INS22 UPD42 INS22 INS22 UPD42 INS22 UPD42 INS22 UPD42 INS22 INS22 UPD42 INS22 UPD42 INS22 UPD42 INS52 INS42 INS22 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS22 UPD42 UPD42 INS42 INS22 MOV40 INS32 INS53 MOV32 MOV32 INS21 INS52 INS42 INS52 INS42 UPD42 UPD42 INS16 INS42 INS7 UPD42 INS42 MOV11 INS25 MOV14 INS52 INS42 INS32 INS42 INS42 INS25 MOV60 MOV60 MOV54 MOV21 MOV21 UPD42 UPD42 INS27 MOV27 INS52 INS42 INS32 INS42 INS40 INS52 MOV21 MOV21 UPD42 UPD42 INS44 MOV8 MOV44 UPD42 MOV32 MOV32 UPD42 UPD42 INS62 INS42 UPD42 UPD42 UPD42 INS43 INS42 INS42 INS43 INS42 INS18 INS42 INS18 UPD42 INS70 UPD42 UPD42 UPD42 INS42 INS32 MOV43 INS10 UPD42 UPD42 INS27 MOV8 UPD42 UPD42 UPD42 MOV21 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 INS22 UPD42 UPD42 UPD42 MOV27 INS27 MOV27 INS52 INS42 INS52 INS42 MOV32 UPD42 UPD40 INS60 MOV60 UPD42 UPD42 INS52 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV43 UPD45 INS52 INS42 INS52 INS42 INS27 INS27 MOV9 INS52 INS42 MOV9 INS52 INS42 UPD43 UPD42 UPD42 UPD42 UPD42 INS32 UPD42 UPD40 UPD42 INS60 INS42 INS43 MOV43 INS45 MOV32 UPD42 UPD42 UPD42 INS42 INS42 INS52 INS42 UPD42 UPD43 UPD42 UPD45 INS32 INS32 INS22 INS22 MOV43 UPD42 UPD42 INS52 INS42 UPD42 UPD42 MOV43 MOV27 INS8 UPD42 INS16 UPD42 UPD42 INS7 INS52 INS42 UPD42 UPD42 MOV43 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS42 INS52 INS42 MOV22 INS42 INS52 INS42 INS42 INS42 INS32 INS14 INS42 UPD42 MOV32 UPD42 UPD42 UPD42 MOV27 MOV45 MOV32 MOV32 INS8 INS42 INS32 INS42 INS8 MOV43 INS42 MOV27 UPD42 MOV42 MOV62 INS25 INS27 INS8 INS42 UPD42 MOV42 MOV21 UPD42 MOV42 INS42 INS33 INS22 INS22 INS22 INS42 INS43 INS42 UPD42 INS22 INS22 UPD42 MOV8 UPD42 MOV42 MOV43 UPD43 INS42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 INS44 INS42 MOV8 MOV38 INS22 INS42 MOV22 INS42 INS42 MOV22 UPD42 INS27 INS27 UPD42 INS22 UPD42 UPD42 UPD42 UPD42 MOV32 MOV32 INS52 INS42 UPD42 MOV32 MOV22 MOV27 MOV43 UPD42 UPD42 MOV43 INS42 INS8 INS43 INS59 INS43 UPD42 UPD42 UPD42 UPD42 INS32 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS22 MOV33 INS22 INS22 MOV33 INS22 INS22 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS43 INS42 UPD42 UPD42 UPD42 MOV43 UPD42 UPD42 UPD42 UPD42 MOV22 INS42 INS42 UPD42 INS22 INS43 INS59 MOV8 UPD42 INS22 UPD42 INS42 UPD42 INS22 UPD43 MOV43 UPD42 UPD42 INS42 INS42 INS52 INS42 INS52 INS42 UPD42 MOV43 UPD42 MOV43 INS25 MOV21 UPD42 MOV27 MOV32 MOV32 UPD42 INS42 MOV14 MOV43 UPD42 MOV27 MOV32 INS42 INS42 UPD42 INS52 INS42 INS22 INS22 UPD42 INS22 UPD42 INS52 INS42 MOV22 INS42 MOV43 MOV32 MOV32 INS42 UPD42 INS22 UPD42 UPD42 INS25 INS42 INS42 UPD42 UPD42 MOV60 MOV21 INS27 INS8 MOV38 MOV27 MOV21 UPD42 MOV42 UPD42 UPD42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS42 UPD42 UPD40 UPD42 UPD42 UPD42 INS22 INS52 INS42 INS52 INS42 UPD42 UPD42 UPD42 INS42 UPD42 MOV42 UPD42 MOV43 INS42 INS70 UPD42 UPD42 INS52 INS42 UPD42 MOV42 MOV42 UPD42 MOV42 MOV42 UPD42 INS22 INS52 INS42 UPD42 MOV38 UPD42 INS18 UPD42 INS42 INS42 MOV32 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 INS22 UPD42 UPD42 MOV32 MOV42 MOV43 UPD42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 UPD40 INS52 INS42 INS42 INS42 MOV32 UPD42 UPD42 UPD42 INS52 INS42 INS52 INS42 UPD42 UPD42 INS22 INS22 UPD42 MOV32 UPD42 UPD42 MOV62 INS8 UPD42 UPD42 UPD42 UPD42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS52 INS42 INS22 UPD42 UPD42 UPD42 UPD42 MOV42 MOV8 INS8 UPD42 MOV27 MOV8 MOV62 MOV38 INS38 INS21 INS32 UPD42 MOV42 MOV43 INS52 INS42 UPD42 UPD42 INS52 INS42 INS22 UPD42 INS42 MOV32 UPD42 UPD43 MOV27 INS44 INS42 INS8 UPD42 INS42 INS42 MOV43 INS52 INS42 UPD42 UPD42 UPD42 UPD42 INS22 UPD42 UPD42 UPD42 INS52 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV43 MOV43 UPD42 UPD40 INS52 INS42 INS52 INS42 MOV43 MOV27 UPD42 MOV43 UPD42 INS22 INS22 UPD45 INS32 INS32 INS21 INS10 UPD42 UPD42 INS78 INS22 UPD45 MOV32 UPD42 INS78 MOV52 MOV42 UPD42 INS52 INS42 INS21 UPD42 UPD42 MOV32 UPD42 MOV60 INS32 INS7 MOV42 INS42 MOV14 UPD42 UPD42 UPD42 INS22 INS52 INS42 MOV27 INS62 UPD42 INS42 UPD42 UPD42 MOV43 INS42 MOV21 UPD42 INS32 INS42 INS52 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV41 UPD42 UPD42 INS22 INS22 UPD42 UPD42 INS52 INS42 UPD42 MOV27 INS52 INS42 UPD42 INS42 MOV42 INS42 INS7 INS42 UPD42 INS52 INS42 UPD42 UPD42 INS42 UPD42 UPD42 INS22 UPD42 UPD42 INS7 UPD42 INS52 INS42 MOV27 INS42 INS32 INS42 INS42 INS9 INS32 INS42 MOV43 MOV27 INS42 UPD40 INS52 INS42 UPD42 MOV42 MOV43 UPD42 UPD43 INS32 INS42 INS42 INS42 INS22 UPD42 UPD42 UPD42 UPD42 UPD42 MOV43 INS42 UPD42 UPD42 MOV43 UPD42 UPD42 UPD42 MOV32 UPD42 INS52 INS42 INS52 INS42 UPD42 MOV43 UPD42 INS22 INS22 INS42 INS11 UPD42 UPD42 INS8 UPD42 UPD42 MOV21 MOV8 INS52 INS42 UPD42 UPD42 INS42 INS32 INS32 INS42 MOV42 INS42 MOV32 MOV32 MOV32 UPD42 UPD42 INS42 MOV22 MOV27 MOV38 INS32 MOV42 MOV42 INS45 INS52 INS42 INS22 INS22 INS45 INS32 INS22 UPD42 UPD42 UPD40 INS22 INS22 INS52 INS42 INS52 INS42 UPD42 INS43 INS42 INS21 MOV43 UPD42 INS36 INS42 INS52 INS42 UPD42 MOV7 INS36 INS42 MOV42 UPD42 UPD42 INS32 INS42 INS42 INS42 INS52 INS42 INS52 INS42 UPD42 UPD42 UPD42 MOV42 MOV42 MOV43 UPD42 INS52 INS42 INS22 INS22 INS52 INS42 INS52 INS42 UPD42 UPD42 MOV43 INS42 UPD42 INS7 INS21 MOV8 MOV21 INS22 INS22 INS11 INS27 MOV9 INS11 MOV11 UPD42 INS22 MOV42 MOV42 INS45 UPD42 INS52 INS42 INS52 INS42 INS22 INS22 UPD42 INS42 INS11 INS7 MOV21 UPD42 INS52 INS42 INS52 INS42 UPD42 MOV43 INS42 INS38 MOV32 INS43 INS52 UPD42 INS22 INS52 INS42 MOV22 UPD42 UPD42 MOV43 INS52 INS42 INS52 INS42 INS43 MOV32 INS42 MOV14 UPD43 UPD42 INS22 MOV32 INS42 INS52 INS42 UPD42 UPD42 INS42 UPD42 UPD42 INS52 INS42 INS22 INS22 INS42 INS45 MOV32 INS52 INS42 INS52 INS42 UPD42 UPD42 UPD42 UPD42 MOV22 UPD42 UPD42 INS52 INS42 DEL83 DEL83 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL83 DEL66 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL65 DEL65 DEL42 DEL59 DEL60 DEL83 DEL83 DEL83 DEL36 DEL83 DEL83 DEL83 DEL42 DEL42 DEL42 DEL65 DEL83 DEL83 DEL83 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL43 DEL40 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL52 DEL32 DEL59 DEL60 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL83 DEL42 DEL42 DEL83 DEL42 DEL83 DEL66 DEL66 DEL83 DEL42 DEL83 DEL83 DEL83 DEL16 DEL36 DEL42 DEL65 DEL42 DEL65 DEL83 DEL83 DEL33 DEL52 DEL42 DEL42 DEL42 DEL11 DEL36 DEL42 DEL52 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL43 DEL62 DEL8 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL25 DEL42 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL83 DEL42 DEL65 DEL42 DEL65 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL59 DEL60 DEL39 DEL42 DEL42 DEL59 DEL60 DEL42 DEL33 DEL59 DEL60 DEL42 DEL7 DEL21 DEL33 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL36 DEL83 DEL83 DEL83 DEL42 DEL83 DEL83 DEL36 DEL36 DEL42 DEL43 DEL52 DEL11 DEL36 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL34 DEL27 DEL27 DEL52 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL40 DEL43 DEL62 DEL27 DEL25 DEL54 DEL8 DEL36 DEL33 DEL42 DEL33 DEL59 DEL60 DEL42 DEL40 DEL59 DEL60 DEL42 DEL40 DEL59 DEL60 DEL42 DEL33 DEL59 DEL60 DEL42 DEL32 DEL7 DEL21 DEL42 DEL7 DEL21 DEL42 DEL32 DEL7 DEL21 DEL42 DEL7 DEL21 DEL42 DEL65 DEL42 DEL65 DEL66 DEL65 DEL36 DEL40 DEL43 DEL42 DEL59 DEL60 DEL42 DEL83 DEL83 DEL36 DEL42 DEL33 DEL27 DEL8 DEL25 DEL42 DEL65 DEL66 DEL65 DEL29 DEL66 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL74 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL31 DEL83 DEL42 DEL42 DEL42 DEL83 DEL42 DEL65 DEL54 DEL42 DEL42 DEL32 DEL42 DEL40 DEL52 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL25 DEL42 DEL44 DEL12 DEL54 DEL8 DEL83 DEL83 DEL34 DEL27 DEL42 DEL43 DEL52 DEL36 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL85 DEL5 DEL4 DEL3 DEL42 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL59 DEL42 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL83 DEL42 DEL66 DEL65 DEL42 DEL42 DEL69 DEL42 DEL43 DEL69 DEL39 DEL69 DEL39 DEL69 DEL68 DEL65 DEL8 DEL42 DEL42 DEL36 DEL42 DEL65 DEL42 DEL65 DEL83 DEL83 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL8 DEL25 DEL8 DEL25 DEL8 DEL31 DEL83 DEL36 DEL42 DEL32 DEL83 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL9 DEL7 DEL21 DEL42 DEL41 DEL42 DEL42 DEL42 DEL43 DEL69 DEL42 DEL43 DEL69 DEL42 DEL43 DEL69 DEL39 DEL69 DEL42 DEL43 DEL69 DEL68 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL29 DEL83 DEL39 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL40 DEL27 DEL42 DEL40 DEL27 DEL27 DEL36 DEL36 DEL42 DEL43 DEL42 DEL11 DEL36 DEL83 DEL42 DEL43 DEL85 DEL5 DEL4 DEL3 DEL83 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL43 DEL11 DEL42 DEL43 DEL85 DEL5 DEL42 DEL4 DEL3 DEL83 DEL83 DEL83 DEL83 DEL34 DEL27 DEL42 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL42 DEL32 DEL42 DEL33 DEL27 DEL40 DEL40 DEL42 DEL65 DEL66 DEL65 DEL42 DEL65 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL14 DEL53 DEL8 DEL25 DEL42 DEL42 DEL42 DEL52 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL33 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL53 DEL8 DEL25 DEL25 DEL42 DEL41 DEL8 DEL31 DEL83 DEL62 DEL36 DEL62 DEL36 DEL42 DEL43 DEL42 DEL40 DEL40 DEL42 DEL42 DEL32 DEL40 DEL40 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL31 DEL42 DEL42 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL31 DEL33 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL43 DEL42 DEL42 DEL32 DEL59 DEL58 DEL24 DEL36 DEL42 DEL42 DEL32 DEL83 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL40 DEL32 DEL41 DEL8 DEL42 DEL43 DEL40 DEL42 DEL32 DEL14 DEL53 DEL8 DEL25 DEL8 DEL31 DEL83 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL40 DEL32 DEL41 DEL8 DEL42 DEL43 DEL40 DEL42 DEL32 DEL14 DEL53 DEL8 DEL25 DEL8 DEL31 DEL42 DEL65 DEL42 DEL42 DEL69 DEL68 DEL65 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL32 DEL24 DEL42 DEL43 DEL42 DEL52 DEL42 DEL9 DEL32 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL40 DEL43 DEL42 DEL40 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL18 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL42 DEL59 DEL60 DEL42 DEL7 DEL21 DEL40 DEL40 DEL42 DEL42 DEL32 DEL18 DEL42 DEL43 DEL42 DEL52 DEL32 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL65 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL42 DEL65 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL24 DEL36 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL43 DEL42 DEL42 DEL32 DEL18 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL45 DEL42 DEL27 DEL45 DEL45 DEL42 DEL27 DEL45 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL10 DEL27 DEL42 DEL43 DEL42 DEL14 DEL27 DEL42 DEL40 DEL7 DEL21 DEL8 DEL25 DEL66 DEL65 DEL29 DEL42 DEL78 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL52 DEL32 DEL41 DEL8 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL54 DEL8 DEL31 DEL32 DEL34 DEL27 DEL39 DEL42 DEL59 DEL60 DEL42 DEL59 DEL60 DEL32 DEL34 DEL27 DEL42 DEL32 DEL7 DEL21 DEL42 DEL16 DEL7 DEL21 DEL42 DEL33 DEL27 DEL25 DEL21 DEL33 DEL42 DEL42 DEL32 DEL42 DEL43 DEL11 DEL42 DEL42 DEL32 DEL83 DEL41 DEL42 DEL42 DEL42 DEL7 DEL42 DEL33 DEL32 DEL21 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL11 DEL41 DEL39 DEL42 DEL34 DEL59 DEL60 DEL52 DEL42 DEL43 DEL42 DEL42 DEL41 DEL42 DEL66 DEL65 DEL42 DEL65 DEL42 DEL65 DEL83 DEL83 DEL42 DEL43 DEL42 DEL39 DEL42 DEL44 DEL83 DEL42 DEL66 DEL65 DEL42 DEL65 DEL42 DEL65 DEL83 DEL52 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL65 DEL27 DEL36 DEL27 DEL36 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL43 DEL12 DEL42 DEL43 DEL85 DEL5 DEL4 DEL3 DEL42 DEL42 DEL42 DEL43 DEL69 DEL39 DEL69 DEL39 DEL69 DEL69 DEL39 DEL69 DEL39 DEL69 DEL39 DEL69 DEL68 DEL65 DEL33 DEL42 DEL43 DEL42 DEL44 DEL42 DEL65 DEL42 DEL65 DEL42 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL4 DEL3 DEL59 DEL60 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL65 DEL42 DEL33 DEL59 DEL60 DEL42 DEL65 DEL83 DEL42 DEL42 DEL42 DEL43 DEL69 DEL39 DEL69 DEL68 DEL65 DEL42 DEL65 DEL42 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL8 DEL31 DEL42 DEL65 DEL42 DEL65 DEL83 DEL36 DEL42 DEL65 DEL42 DEL65 DEL36 DEL36 DEL42 DEL65 DEL42 DEL65 DEL29 DEL83 DEL83 DEL33 DEL36 DEL42 DEL42 DEL42 DEL33 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL85 DEL5 DEL42 DEL44 DEL42 DEL33 DEL27 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL2 DEL11 DEL59 DEL60 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL32 DEL3 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL52 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL42 DEL44 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL40 DEL32 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL24 DEL8 DEL25 DEL8 DEL31 DEL83 DEL83 DEL83 DEL83 DEL42 DEL42 DEL42 DEL43 DEL83 DEL83 DEL42 DEL36 DEL42 DEL41 DEL83 DEL36 DEL36 DEL42 DEL65 DEL42 DEL65 DEL83 DEL36 DEL83 DEL39 DEL42 DEL42 DEL36 DEL27 DEL59 DEL60 DEL42 DEL42 DEL69 DEL68 DEL65 DEL42 DEL65 DEL29 DEL42 DEL42 DEL32 DEL18 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL41 DEL9 DEL41 DEL36 DEL42 DEL34 DEL27 DEL9 DEL41 DEL25 DEL42 DEL36 DEL42 DEL59 DEL60 DEL42 DEL7 DEL21 DEL25 DEL8 DEL83 DEL25 DEL9 DEL41 DEL8 DEL83 DEL36 DEL42 DEL39 DEL42 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL8 DEL61 DEL42 DEL42 DEL2 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL8 DEL24 DEL42 DEL43 DEL52 DEL32 DEL36 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL8 DEL61 DEL83 DEL36 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL8 DEL24 DEL83 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL8 DEL24 DEL42 DEL32 DEL42 DEL44 DEL8 DEL12 DEL43 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL36 DEL32 DEL25 DEL42 DEL44 DEL42 DEL42 DEL33 DEL27 DEL25 DEL8 DEL83 DEL42 DEL42 DEL42 DEL8 DEL25 DEL25 DEL42 DEL42 DEL42 DEL8 DEL25 DEL25 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL27 DEL36 DEL42 DEL36 DEL42 DEL9 DEL41 DEL41 DEL42 DEL41 DEL42 DEL41 DEL41 DEL42 DEL9 DEL41 DEL42 DEL42 DEL22 DEL59 DEL60 DEL42 DEL32 DEL25 DEL42 DEL32 DEL25 DEL9 DEL41 DEL42 DEL8 DEL8 DEL33 DEL11 DEL42 DEL45 DEL32 DEL27 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL7 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL66 DEL65 DEL66 DEL65 DEL29 DEL39 DEL42 DEL42 DEL43 DEL42 DEL33 DEL27 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL53 DEL25 DEL42 DEL42 DEL32 DEL41 DEL8 DEL42 DEL43 DEL42 DEL44 DEL34 DEL41 DEL8 DEL12 DEL54 DEL8 DEL31 DEL66 DEL65 DEL29 DEL39 DEL42 DEL42 DEL43 DEL42 DEL33 DEL27 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL53 DEL25 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL83 DEL83 DEL42 DEL59 DEL60 DEL83 DEL83 DEL83 DEL83 DEL42 DEL8 DEL83 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL23 DEL42 DEL83 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL40 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL7 DEL21 DEL40 DEL42 DEL40 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL21 DEL33 DEL41 DEL8 DEL12 DEL83 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL24 DEL83 DEL83 DEL45 DEL27 DEL42 DEL42 DEL42 DEL2 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL24 DEL66 DEL65 DEL29 DEL42 DEL42 DEL9 DEL41 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL52 DEL42 DEL43 DEL42 DEL52 DEL42 DEL32 DEL59 DEL58 DEL24 DEL8 DEL66 DEL65 DEL29 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL27 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL8 DEL25 DEL42 DEL8 DEL52 DEL52 DEL52 DEL42 DEL32 DEL21 DEL52 DEL52 DEL52 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL27 DEL27 DEL41 DEL52 DEL52 DEL42 DEL52 DEL66 DEL66 DEL65 DEL29 DEL42 DEL43 DEL40 DEL42 DEL42 DEL32 DEL14 DEL53 DEL8 DEL25 DEL8 DEL31 DEL9 DEL9 DEL16 DEL42 DEL7 DEL21 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL59 DEL60 DEL61 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL59 DEL60 DEL52 DEL42 DEL42 DEL42 DEL42 DEL42 DEL52 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL36 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL33 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL39 DEL42 DEL31 DEL42 DEL83 DEL42 DEL52 DEL83 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL42 DEL32 DEL42 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL7 DEL21 DEL10 DEL8 DEL25 DEL8 DEL61 DEL36 DEL83 DEL42 DEL42 DEL59 DEL60 DEL39 DEL42 DEL36 DEL16 DEL59 DEL60 DEL42 DEL32 DEL42 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL42 DEL11 DEL7 DEL21 DEL8 DEL42 DEL7 DEL21 DEL45 DEL27 DEL42 DEL42 DEL7 DEL21 DEL8 DEL12 DEL42 DEL83 DEL42 DEL59 DEL60 DEL42 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL83 DEL42 DEL65 DEL83 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL8 DEL24 DEL42 DEL65 DEL83 DEL83 DEL42 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL83 DEL83 DEL83 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL33 DEL32 DEL38 DEL41 DEL8 DEL31 DEL34 DEL36 DEL27 DEL83 DEL39 DEL42 DEL31 DEL83 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL31 DEL41 DEL41 DEL25 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL36 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL8 DEL61 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL33 DEL7 DEL21 DEL8 DEL31 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL43 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL33 DEL42 DEL43 DEL33 DEL42 DEL7 DEL21 DEL42 DEL42 DEL2 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL24 DEL66 DEL42 DEL65 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL8 DEL31 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL4 DEL3 DEL42 DEL43 DEL83 DEL42 DEL42 DEL31 DEL42 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL65 DEL42 DEL65 DEL83 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL40 DEL42 DEL40 DEL42 DEL42 DEL40 DEL40 DEL42 DEL40 DEL42 DEL40 DEL42 DEL42 DEL42 DEL32 DEL21 DEL36 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL42 DEL43 DEL62 DEL8 DEL25 DEL8 DEL51 DEL8 DEL31 DEL52 DEL42 DEL22 DEL33 DEL27 DEL36 DEL27 DEL42 DEL65 DEL41 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL34 DEL27 DEL36 DEL41 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL42 DEL44 DEL12 DEL42 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL14 DEL41 DEL8 DEL31 DEL83 DEL83 DEL36 DEL36 DEL8 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL33 DEL59 DEL23 DEL83 DEL39 DEL42 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL43 DEL14 DEL7 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL83 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL7 DEL21 DEL8 DEL31
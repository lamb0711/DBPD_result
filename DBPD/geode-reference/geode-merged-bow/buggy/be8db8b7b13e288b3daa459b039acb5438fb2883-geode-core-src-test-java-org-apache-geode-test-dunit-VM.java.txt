GEODE-1965 Create backward-compatibility unit test framework

See
https://cwiki.apache.org/confluence/display/GEODE/Writing+Backward-compatibility+DUnit+tests

This extends the distributed unit test framework to allow you to boot a
VM running an older version of Geode.  Using this extension you can create
rolling upgrade tests, client/server interoperability tests, persistent
store upgrade tests and so on.

VM numbering has not changed.  If you request that a VM use a certain
version of GEODE it will be bounced if necessary and its classpath modified
to point to that version.  The VM will continue to use that version until
bounced to a different version or the next test class is started.  All
VMs are moved to the current version at the beginning of a new test class.

Console output from versioned VMs will contain the symbolic version in use
by the VM, such as "[vm0_v100]" to help you know it is running a different
version of GEODE.

Tests are all compiled with the current Geode code, so if there are API
changes you must use reflection in order to invoke the old versions of
the API.  RollingUpgradeDUnitTests shows how to do this.

ClientServerMiscBCDUnitTest shows how to subclass an existing class to
make it run with multiple versions of Geode.  In this case the clients
are parameterized to run with older versions while servers are held to
the current version.

I will be opening a few tickets to track problems I have already encountered
with these tests.

+import org.apache.geode.test.dunit.standalone.VersionManager;
+  /** The version of Geode used in this VM */
+  private String version;
+
+   * Returns the name of a VM for use in the RMI naming service or working directory on disk
+   */
+  public static String getVMName(String version, int pid) {
+    if (pid == -2) {
+      return "locator";
+    }
+    if (pid < 0 || VersionManager.isCurrentVersion(version)) {
+      return "vm" + pid;
+    } else {
+      return "vm" + pid + "_v" + version;
+    }
+  }
+
+  /**
+    this(host, VersionManager.CURRENT_VERSION, pid, client);
+  }
+
+  public VM(final Host host, final String version, final int pid, final RemoteDUnitVMIF client) {
+    this.version = version;
+   * Returns the version of Geode used in this VM.
+   * 
+   * @see VersionManager#CURRENT_VERSION
+   * @see Host#getVM(String, int)
+   */
+  public String getVersion() {
+    return this.version;
+  }
+
+  /**
+    bounce(this.version);
+  }
+
+  public synchronized void bounce(String targetVersion) {
-      BounceResult result = DUnitEnv.get().bounce(this.pid);
+      BounceResult result = DUnitEnv.get().bounce(targetVersion, this.pid);
+      this.version = targetVersion;
-    return "VM " + getPid() + " running on " + getHost();
+    return "VM " + getPid() + " running on " + getHost()
+        + (VersionManager.isCurrentVersion(version) ? "" : (" with version " + version));
-    return DUnitEnv.get().getWorkingDirectory(getPid());
+    return DUnitEnv.get().getWorkingDirectory(getVersion(), getPid());

INS26 INS40 INS23 INS31 INS31 INS31 INS31 INS29 INS83 INS43 INS59 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS8 MOV29 INS83 INS42 INS44 INS44 INS44 INS8 INS44 INS29 INS83 INS43 INS42 INS8 MOV29 INS83 INS83 INS39 INS42 INS8 INS44 INS65 INS42 INS42 INS65 INS42 INS43 INS42 INS39 INS42 INS25 INS25 INS83 INS43 INS42 INS83 INS39 INS42 INS83 INS43 INS42 INS17 INS83 INS43 INS42 INS21 INS65 INS65 INS65 INS42 INS41 INS21 INS43 INS42 INS66 INS66 INS42 INS27 INS8 INS27 INS8 INS8 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS7 INS66 INS67 INS68 INS22 INS32 INS42 INS42 INS38 INS41 INS27 INS32 INS41 INS41 INS22 INS42 INS42 INS42 INS42 INS42 INS69 INS69 INS52 INS42 INS42 INS22 INS21 INS36 INS32 INS34 INS45 INS42 INS34 INS42 INS42 INS42 INS27 INS27 INS52 INS42 INS43 INS39 INS52 INS42 INS7 INS16 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS42 INS22 INS42 INS32 INS45 INS36 INS42 INS52 INS42 INS42 INS42 INS42 INS27 INS45 INS42
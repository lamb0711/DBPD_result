Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Implementation of a local scoped-region. Note that this class has a different
- * meaning starting with 3.0. In previous versions, a LocalRegion was the
- * representation of a region in the VM. Starting with 3.0, a LocalRegion is a
- * non-distributed region. The subclass DistributedRegion adds distribution
- * behavior.
+ * Implementation of a local scoped-region. Note that this class has a different meaning starting
+ * with 3.0. In previous versions, a LocalRegion was the representation of a region in the VM.
+ * Starting with 3.0, a LocalRegion is a non-distributed region. The subclass DistributedRegion adds
+ * distribution behavior.
-public class LocalRegion extends AbstractRegion
-  implements LoaderHelperFactory, ResourceListener<MemoryEvent>,
-             DiskExceptionHandler, DiskRecoveryStore
-{
+public class LocalRegion extends AbstractRegion implements LoaderHelperFactory,
+    ResourceListener<MemoryEvent>, DiskExceptionHandler, DiskRecoveryStore {
+   * 
-   * thread local to indicate that this thread should bypass the initialization
-   * Latch
+   * thread local to indicate that this thread should bypass the initialization Latch
-  
+
-  //guarded by regionExpiryLock.
+  // guarded by regionExpiryLock.
-  //guarded by regionExpiryLock.
+  // guarded by regionExpiryLock.
-  
+
-  private final ConcurrentHashMap<RegionEntry, EntryExpiryTask> entryExpiryTasks = new ConcurrentHashMap<RegionEntry, EntryExpiryTask>();
+  private final ConcurrentHashMap<RegionEntry, EntryExpiryTask> entryExpiryTasks =
+      new ConcurrentHashMap<RegionEntry, EntryExpiryTask>();
-   * Set to true after an invalidate region expiration so we don't get multiple
-   * expirations
+   * Set to true after an invalidate region expiration so we don't get multiple expirations
-  
-  /** tracks region-level version information for members.  See
+
+  /**
+   * tracks region-level version information for members. See
-      Pattern.compile("^\\(*select .*", Pattern.CASE_INSENSITIVE
-          | Pattern.UNICODE_CASE | Pattern.DOTALL),
-      Pattern.compile("^import .*", Pattern.CASE_INSENSITIVE
-          | Pattern.UNICODE_CASE | Pattern.DOTALL) };
+      Pattern.compile("^\\(*select .*",
+          Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE | Pattern.DOTALL),
+      Pattern.compile("^import .*",
+          Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE | Pattern.DOTALL)};
-  public static final String EXPIRY_MS_PROPERTY = DistributionConfig.GEMFIRE_PREFIX + "EXPIRY_UNITS_MS";
-  
+  public static final String EXPIRY_MS_PROPERTY =
+      DistributionConfig.GEMFIRE_PREFIX + "EXPIRY_UNITS_MS";
+
-   * Used by unit tests to set expiry to milliseconds instead of the default
-   * seconds. Used in ExpiryTask.
+   * Used by unit tests to set expiry to milliseconds instead of the default seconds. Used in
+   * ExpiryTask.
-   * contains Regions themselves // marked volatile to make sure it is fully
-   * initialized before being // accessed; (actually should be final)
+   * contains Regions themselves // marked volatile to make sure it is fully initialized before
+   * being // accessed; (actually should be final)
-//  private final Object clientCqsSync = new Object();
+  // private final Object clientCqsSync = new Object();
-   * Prevents access to this region until it is done initializing, except for
-   * some special initializing operations such as replying to create region
-   * messages In JDK 1.5 we will use java.util.concurrent.CountDownLatch instead
-   * of org.apache.geode.internal.util.CountDownLatch.
+   * Prevents access to this region until it is done initializing, except for some special
+   * initializing operations such as replying to create region messages In JDK 1.5 we will use
+   * java.util.concurrent.CountDownLatch instead of org.apache.geode.internal.util.CountDownLatch.
-   * Used to hold off cache listener events until the afterRegionCreate is
-   * called
+   * Used to hold off cache listener events until the afterRegionCreate is called
-  
+
-   * Used by transactions to suspend entry expiration while a transaction is in
-   * progress on a region. This field is only initialized if expiration is
-   * configured and transactions are possible.
+   * Used by transactions to suspend entry expiration while a transaction is in progress on a
+   * region. This field is only initialized if expiration is configured and transactions are
+   * possible.
-   * Used for serializing netSearch and netLoad on a per key basis.
-   * CM <Object, Future>
+   * Used for serializing netSearch and netLoad on a per key basis. CM <Object, Future>
-   * Asif: This boolean needs to be made true if the test needs to receive a
-   * synchronous callback just after clear on map is done. Its visibility is
-   * default so that only tests present in org.apache.geode.internal.cache
-   * will be able to see it
+   * Asif: This boolean needs to be made true if the test needs to receive a synchronous callback
+   * just after clear on map is done. Its visibility is default so that only tests present in
+   * org.apache.geode.internal.cache will be able to see it
-   * A flag used to indicate that this Region is being used as an administrative
-   * Region, holding meta-data for a PartitionedRegion
+   * A flag used to indicate that this Region is being used as an administrative Region, holding
+   * meta-data for a PartitionedRegion
-  
+
-  
+
-  
+
-  
+
-  private final boolean hasOwnStats; 
+  private final boolean hasOwnStats;
-   * Register interest count to track if any register interest is in progress for
-   * this region. This count will be incremented when register interest starts
-   * and decremented when register interest finishes.
+   * Register interest count to track if any register interest is in progress for this region. This
+   * count will be incremented when register interest starts and decremented when register interest
+   * finishes.
+   * 
-  private int riCnt = 0; /*
-                          * since always written while holding an exclusive write lock
-                          * and only read while holding a read lock
-                          * it does not need to be atomic or
-                          * protected by any other sync.
-                          */
+  private int riCnt =
+      0; /*
+          * since always written while holding an exclusive write lock and only read while holding a
+          * read lock it does not need to be atomic or protected by any other sync.
+          */
-   * Map of subregion full paths to serial numbers. These are subregions that
-   * were destroyed when this region was destroyed. This map remains null until
-   * this region is destroyed.
+   * Map of subregion full paths to serial numbers. These are subregions that were destroyed when
+   * this region was destroyed. This map remains null until this region is destroyed.
-   * This boolean is true when a member who has this region is running low on memory.
-   * It is used to reject region operations.
+   * This boolean is true when a member who has this region is running low on memory. It is used to
+   * reject region operations.
-  // Lock for updating PR MetaData on client side 
+  // Lock for updating PR MetaData on client side
-  
+
-   * There seem to be cases where a region can be created and yet the
-   * distributed system is not yet in place...
+   * There seem to be cases where a region can be created and yet the distributed system is not yet
+   * in place...
-    /* (non-Javadoc)
+    /*
+     * (non-Javadoc)
+     * 
-   * Currently used by the OpLog layer to initialize the
-   * {@link KeyWithRegionContext} if required.
+   * Currently used by the OpLog layer to initialize the {@link KeyWithRegionContext} if required.
-  private final static ThreadLocal<LocalRegion> initializingRegion =
-    new ThreadLocal<LocalRegion>();
+  private final static ThreadLocal<LocalRegion> initializingRegion = new ThreadLocal<LocalRegion>();
-   * Set to true if the region contains keys implementing
-   * {@link KeyWithRegionContext} that require setting up of region specific
-   * context after deserialization or recovery from disk.
+   * Set to true if the region contains keys implementing {@link KeyWithRegionContext} that require
+   * setting up of region specific context after deserialization or recovery from disk.
-   * Note that this value is cleared after the initialization of LocalRegion is
-   * done so is valid only for the duration of region creation and
-   * initialization.
+   * Note that this value is cleared after the initialization of LocalRegion is done so is valid
+   * only for the duration of region creation and initialization.
-  protected Map<String,CacheServiceProfile> cacheServiceProfiles;
+  protected Map<String, CacheServiceProfile> cacheServiceProfiles;
-    }
-    else {
+    } else {
-  protected LocalRegion(String regionName, RegionAttributes attrs,
-      LocalRegion parentRegion, GemFireCacheImpl cache,
-      InternalRegionArguments internalRegionArgs) throws DiskAccessException {
-    super(cache, attrs,regionName, internalRegionArgs);
+  protected LocalRegion(String regionName, RegionAttributes attrs, LocalRegion parentRegion,
+      GemFireCacheImpl cache, InternalRegionArguments internalRegionArgs)
+      throws DiskAccessException {
+    super(cache, attrs, regionName, internalRegionArgs);
-    this.EXPIRY_UNITS_MS = parentRegion != null ? parentRegion.EXPIRY_UNITS_MS : Boolean.getBoolean(EXPIRY_MS_PROPERTY);
+    this.EXPIRY_UNITS_MS = parentRegion != null ? parentRegion.EXPIRY_UNITS_MS
+        : Boolean.getBoolean(EXPIRY_MS_PROPERTY);
-    this.offHeap = attrs.getOffHeap() || Boolean.getBoolean(myName+":OFF_HEAP");
+    this.offHeap = attrs.getOffHeap() || Boolean.getBoolean(myName + ":OFF_HEAP");
-        throw new IllegalStateException(LocalizedStrings.
-            LocalRegion_THE_REGION_0_WAS_CONFIGURED_TO_USE_OFF_HEAP_MEMORY_BUT_OFF_HEAP_NOT_CONFIGURED.toLocalizedString(myName));
+        throw new IllegalStateException(
+            LocalizedStrings.LocalRegion_THE_REGION_0_WAS_CONFIGURED_TO_USE_OFF_HEAP_MEMORY_BUT_OFF_HEAP_NOT_CONFIGURED
+                .toLocalizedString(myName));
-    
+
-      this.cachePerfStats = internalRegionArgs.getCachePerfStatsHolder()
-          .getCachePerfStats();
-    }
-    else {
+      this.cachePerfStats = internalRegionArgs.getCachePerfStatsHolder().getCachePerfStats();
+    } else {
-      }
-      else {
+      } else {
-    }
-    else {
+    } else {
-    this.isUsedForPartitionedRegionAdmin = internalRegionArgs
-        .isUsedForPartitionedRegionAdmin();
-    this.isUsedForPartitionedRegionBucket = internalRegionArgs
-        .isUsedForPartitionedRegionBucket();
-    this.isUsedForMetaRegion = internalRegionArgs
-        .isUsedForMetaRegion();
+    this.isUsedForPartitionedRegionAdmin = internalRegionArgs.isUsedForPartitionedRegionAdmin();
+    this.isUsedForPartitionedRegionBucket = internalRegionArgs.isUsedForPartitionedRegionBucket();
+    this.isUsedForMetaRegion = internalRegionArgs.isUsedForMetaRegion();
-    this.isUsedForParallelGatewaySenderQueue = internalRegionArgs.isUsedForParallelGatewaySenderQueue();
+    this.isUsedForParallelGatewaySenderQueue =
+        internalRegionArgs.isUsedForParallelGatewaySenderQueue();
-    this.cacheServiceProfiles = internalRegionArgs.getCacheServiceProfiles() == null
-        ? null
+    this.cacheServiceProfiles = internalRegionArgs.getCacheServiceProfiles() == null ? null
-        && !isUsedForPartitionedRegionBucket
-        && !isUsedForSerialGatewaySenderQueue
+        && !isUsedForPartitionedRegionBucket && !isUsedForSerialGatewaySenderQueue
-    
+
-    this.srp = (this.getPoolName() != null)
-      ? new ServerRegionProxy(this)
-      : null;
-    this.imageState =
-      new UnsharedImageState(this.srp != null,
-                             getDataPolicy().withReplication() || getDataPolicy().isPreloaded(),
-                             getAttributes().getDataPolicy().withPersistence(),
-                             this.stopper);
+    this.srp = (this.getPoolName() != null) ? new ServerRegionProxy(this) : null;
+    this.imageState = new UnsharedImageState(this.srp != null,
+        getDataPolicy().withReplication() || getDataPolicy().isPreloaded(),
+        getAttributes().getDataPolicy().withPersistence(), this.stopper);
-    this.supportsTX = !isSecret() && !isUsedForPartitionedRegionAdmin()
-        && !isUsedForMetaRegion() || isMetaRegionWithTransactions();
+    this.supportsTX = !isSecret() && !isUsedForPartitionedRegionAdmin() && !isUsedForMetaRegion()
+        || isMetaRegionWithTransactions();
-    
+
-  
+
-   * initialize the event tracker.  Not all region implementations want or
-   * need one of these. Regions that require one should reimplement this method
-   * and create one like so:
-   * <code><pre>
+   * initialize the event tracker. Not all region implementations want or need one of these. Regions
+   * that require one should reimplement this method and create one like so: <code><pre>
-  
-  
+
+
-   * this method is for testing only.  Other region classes may track events using
-   * different mechanisms than EventTrackers
+   * this method is for testing only. Other region classes may track events using different
+   * mechanisms than EventTrackers
-  
+
-  
+
-      return this.fullPath; // avoids creating another sync object - could be anything unique to this region
+      return this.fullPath; // avoids creating another sync object - could be anything unique to
+                            // this region
-  
+
-    
+
-    
+
-      //copy the versions that we have recovered from disk into
-      //the version vector.
+      // copy the versions that we have recovered from disk into
+      // the version vector.
-  
+
-  protected void updateEntryExpiryPossible()
-  {
+  protected void updateEntryExpiryPossible() {
-  boolean isCacheClosing()
-  {
+  boolean isCacheClosing() {
-  
+
-   * Test hook - returns the version stamp for an entry in the form of a
-   * version tag
+   * Test hook - returns the version stamp for an entry in the form of a version tag
+   * 
-      tag = ((EntrySnapshot)entry).getVersionTag();
+      tag = ((EntrySnapshot) entry).getVersionTag();
-      tag = ((NonTXEntry)entry).getRegionEntry().getVersionStamp().asVersionTag();
+      tag = ((NonTXEntry) entry).getRegionEntry().getVersionStamp().asVersionTag();
-  
-  /** removes any destroyed entries from the region and clear the destroyedKeys
-   * assert: Caller must be holding writeLock on is
+
+  /**
+   * removes any destroyed entries from the region and clear the destroyedKeys assert: Caller must
+   * be holding writeLock on is
-  
+
-  protected boolean isExpirationAllowed(ExpiryTask expiry)
-  {
+  protected boolean isExpirationAllowed(ExpiryTask expiry) {
-  void performExpiryTimeout(ExpiryTask p_task) throws CacheException
-  {
+  void performExpiryTimeout(ExpiryTask p_task) throws CacheException {
-  private void initRoot()
-  {
+  private void initRoot() {
-    
-    RegionEventImpl event = new RegionEventImpl(this,
-        Operation.MARKER, null, false, getMyId(),
+
+    RegionEventImpl event = new RegionEventImpl(this, Operation.MARKER, null, false, getMyId(),
-  public AttributesMutator getAttributesMutator()
-  {
+  public AttributesMutator getAttributesMutator() {
-  public Region createSubregion(String subregionName,
-      RegionAttributes regionAttributes) throws RegionExistsException,
-      TimeoutException
-  {
+  public Region createSubregion(String subregionName, RegionAttributes regionAttributes)
+      throws RegionExistsException, TimeoutException {
-          new InternalRegionArguments().setDestroyLockFlag(true)
-              .setRecreateFlag(false));
-    }
-    catch (IOException e) {
+          new InternalRegionArguments().setDestroyLockFlag(true).setRecreateFlag(false));
+    } catch (IOException e) {
-      InternalGemFireError assErr = new InternalGemFireError(LocalizedStrings.LocalRegion_UNEXPECTED_EXCEPTION.toLocalizedString());
+      InternalGemFireError assErr = new InternalGemFireError(
+          LocalizedStrings.LocalRegion_UNEXPECTED_EXCEPTION.toLocalizedString());
-    }
-    catch (ClassNotFoundException e) {
+    } catch (ClassNotFoundException e) {
-      InternalGemFireError assErr = new InternalGemFireError(LocalizedStrings.LocalRegion_UNEXPECTED_EXCEPTION.toLocalizedString());
+      InternalGemFireError assErr = new InternalGemFireError(
+          LocalizedStrings.LocalRegion_UNEXPECTED_EXCEPTION.toLocalizedString());
-  protected InternalDistributedMember getMyId()
-  {
+  protected InternalDistributedMember getMyId() {
-  
-  public VersionSource getVersionMember()
-  {
-    if(dataPolicy.withPersistence()) {
+
+  public VersionSource getVersionMember() {
+    if (dataPolicy.withPersistence()) {
-  public Region createSubregion(String subregionName,
-      RegionAttributes attrs,
-      InternalRegionArguments internalRegionArgs) throws RegionExistsException,
-      TimeoutException, IOException, ClassNotFoundException
-  {
+  public Region createSubregion(String subregionName, RegionAttributes attrs,
+      InternalRegionArguments internalRegionArgs)
+      throws RegionExistsException, TimeoutException, IOException, ClassNotFoundException {
-    final InputStream snapshotInputStream = internalRegionArgs
-        .getSnapshotInputStream();
+    final InputStream snapshotInputStream = internalRegionArgs.getSnapshotInputStream();
-    final InternalDistributedMember imageTarget = internalRegionArgs
-        .getImageTarget();
+    final InternalDistributedMember imageTarget = internalRegionArgs.getImageTarget();
-          
-          existing = (LocalRegion)this.subregions.get(subregionName);
+
+          existing = (LocalRegion) this.subregions.get(subregionName);
-              final PartitionedRegion pr = internalRegionArgs
-                  .getPartitionedRegion();
+              final PartitionedRegion pr = internalRegionArgs.getPartitionedRegion();
-                newRegion = new BucketRegionQueue(subregionName, regionAttributes,
-                  this, this.cache, internalRegionArgs);
+                newRegion = new BucketRegionQueue(subregionName, regionAttributes, this, this.cache,
+                    internalRegionArgs);
-                newRegion = new BucketRegion(subregionName, regionAttributes,
-                    this, this.cache, internalRegionArgs);  
+                newRegion = new BucketRegion(subregionName, regionAttributes, this, this.cache,
+                    internalRegionArgs);
-            }
-            else if (regionAttributes.getPartitionAttributes() != null) {
-              newRegion = new PartitionedRegion(subregionName,
-                  regionAttributes, this, this.cache,  internalRegionArgs);
-            }
-            else {
+            } else if (regionAttributes.getPartitionAttributes() != null) {
+              newRegion = new PartitionedRegion(subregionName, regionAttributes, this, this.cache,
+                  internalRegionArgs);
+            } else {
-              newRegion = local ? new LocalRegion(subregionName,
-                  regionAttributes, this, this.cache, internalRegionArgs)
-                  : new DistributedRegion(subregionName, regionAttributes,
-                      this, this.cache, internalRegionArgs);
+              newRegion = local
+                  ? new LocalRegion(subregionName, regionAttributes, this, this.cache,
+                      internalRegionArgs)
+                  : new DistributedRegion(subregionName, regionAttributes, this, this.cache,
+                      internalRegionArgs);
-      }
-      finally {
+      } finally {
-      
-      //Fix for bug 42127 - moved to outside of the destroy lock.
+
+      // Fix for bug 42127 - moved to outside of the destroy lock.
-      
+
-        if (regionAttributes instanceof UserSpecifiedRegionAttributes){
-          internalRegionArgs.setIndexes((
-            (UserSpecifiedRegionAttributes)regionAttributes).getIndexes());  
+        if (regionAttributes instanceof UserSpecifiedRegionAttributes) {
+          internalRegionArgs
+              .setIndexes(((UserSpecifiedRegionAttributes) regionAttributes).getIndexes());
-        newRegion.initialize(snapshotInputStream, imageTarget, internalRegionArgs); // releases initialization Latches
-        //register the region with resource manager to get memory events
-        if(!newRegion.isInternalRegion()){
+        newRegion.initialize(snapshotInputStream, imageTarget, internalRegionArgs); // releases
+                                                                                    // initialization
+                                                                                    // Latches
+        // register the region with resource manager to get memory events
+        if (!newRegion.isInternalRegion()) {
-            
+
-              newRegion.initialCriticalMembers(cache.getResourceManager().getHeapMonitor().getState().isCritical(), cache
-                  .getResourceAdvisor().adviseCritialMembers());
+              newRegion.initialCriticalMembers(
+                  cache.getResourceManager().getHeapMonitor().getState().isCritical(),
+                  cache.getResourceAdvisor().adviseCritialMembers());
-              newRegion.initialCriticalMembers(cache.getResourceManager().getHeapMonitor().getState().isCritical()
-                  || cache.getResourceManager().getOffHeapMonitor().getState().isCritical(), cache.getResourceAdvisor()
-                  .adviseCritialMembers());
+              newRegion.initialCriticalMembers(
+                  cache.getResourceManager().getHeapMonitor().getState().isCritical()
+                      || cache.getResourceManager().getOffHeapMonitor().getState().isCritical(),
+                  cache.getResourceAdvisor().adviseCritialMembers());
-            // of the Resource Event listeners            
-            
-            InternalDistributedSystem system = this.cache
-                .getDistributedSystem();
+            // of the Resource Event listeners
+
+            InternalDistributedSystem system = this.cache.getDistributedSystem();
-        logger.warn(LocalizedMessage.create(LocalizedStrings.LocalRegion_INITIALIZATION_FAILED_FOR_REGION_0,
-            getFullPath()), validationException);
+        logger
+            .warn(
+                LocalizedMessage.create(
+                    LocalizedStrings.LocalRegion_INITIALIZATION_FAILED_FOR_REGION_0, getFullPath()),
+                validationException);
-      }
-      finally {
+      } finally {
-    }
-    finally {
+    } finally {
-    @Released EntryEventImpl event = newCreateEntryEvent(key, value, aCallbackArgument);
+    @Released
+    EntryEventImpl event = newCreateEntryEvent(key, value, aCallbackArgument);
-      if (event.getEventId() == null && generateEventID()) {
-        event.setNewEventId(cache.getDistributedSystem());
+    if (event.getEventId() == null && generateEventID()) {
+      event.setNewEventId(cache.getDistributedSystem());
+    }
+    // Fix for 42448 - Only make create with null a local invalidate for
+    // normal regions. Otherwise, it will become a distributed invalidate.
+    if (getDataPolicy() == DataPolicy.NORMAL) {
+      event.setLocalInvalid(true);
+    }
+    discoverJTA();
+    if (!basicPut(event, true, // ifNew
+        false, // ifOld
+        null, // expectedOldValue
+        true // requireOldValue TODO txMerge why is oldValue required for
+             // create? I think so that the EntryExistsException will have it.
+    )) {
+      throw new EntryExistsException(event.getKey().toString(), event.getOldValue());
+    } else {
+      if (!getDataView().isDeferredStats()) {
+        getCachePerfStats().endPut(startPut, false);
-      // Fix for 42448 - Only make create with null a local invalidate for
-      // normal regions. Otherwise, it will become a distributed invalidate.
-      if (getDataPolicy() == DataPolicy.NORMAL) {
-        event.setLocalInvalid(true);
-      }
-      discoverJTA();
-      if (!basicPut(event, true, // ifNew
-          false, // ifOld
-          null, // expectedOldValue
-          true // requireOldValue TODO txMerge why is oldValue required for
-               // create? I think so that the EntryExistsException will have it.
-      )) {
-        throw new EntryExistsException(event.getKey().toString(),
-            event.getOldValue());
-      } else {
-        if (!getDataView().isDeferredStats()) {
-          getCachePerfStats().endPut(startPut, false);
-        }
-      }
+    }
-    return EntryEventImpl.create(this, Operation.CREATE, key,
-        value, aCallbackArgument, false, getMyId())
+    return EntryEventImpl
+        .create(this, Operation.CREATE, key, value, aCallbackArgument, false, getMyId())
-   * The default Region implementation will generate EvenTID in the EntryEvent
-   * object. This method is overridden in special Region objects like HARegion
-   * or SingleWriteSingleReadRegionQueue.SingleReadWriteMetaRegion to return
-   * false as the event propagation from those regions do not need EventID
-   * objects
+   * The default Region implementation will generate EvenTID in the EntryEvent object. This method
+   * is overridden in special Region objects like HARegion or
+   * SingleWriteSingleReadRegionQueue.SingleReadWriteMetaRegion to return false as the event
+   * propagation from those regions do not need EventID objects
-   * <p>author Asif
+   * <p>
+   * author Asif
+   * 
-  public boolean generateEventID()
-  {     
+  public boolean generateEventID() {
-    @Released EntryEventImpl event = newDestroyEntryEvent(key, aCallbackArgument);
+    @Released
+    EntryEventImpl event = newDestroyEntryEvent(key, aCallbackArgument);
-   * Destroys entry without performing validations. Call this after validating
-   * key, callback arg, and runtime state.
+   * Destroys entry without performing validations. Call this after validating key, callback arg,
+   * and runtime state.
-      throws TimeoutException, EntryNotFoundException, CacheWriterException
- {
-      if (event.getEventId() == null && generateEventID()) {
-        event.setNewEventId(cache.getDistributedSystem());
-      }
-      basicDestroy(event, true, // cacheWrite
-          null); // expectedOldValue
-      if (event.isOldValueOffHeap()) {
-        return null;
-      } else {
-        return handleNotAvailable(event.getOldValue());
-      }
+      throws TimeoutException, EntryNotFoundException, CacheWriterException {
+    if (event.getEventId() == null && generateEventID()) {
+      event.setNewEventId(cache.getDistributedSystem());
+    }
+    basicDestroy(event, true, // cacheWrite
+        null); // expectedOldValue
+    if (event.isOldValueOffHeap()) {
+      return null;
+    } else {
+      return handleNotAvailable(event.getOldValue());
+    }
-  public final EntryEventImpl newDestroyEntryEvent(Object key,
-      Object aCallbackArgument) {
+  public final EntryEventImpl newDestroyEntryEvent(Object key, Object aCallbackArgument) {
-    return EntryEventImpl.create(this, Operation.DESTROY, key,
-        null/* newValue */, aCallbackArgument, false, getMyId());
+    return EntryEventImpl.create(this, Operation.DESTROY, key, null/* newValue */,
+        aCallbackArgument, false, getMyId());
-      throws CacheWriterException, TimeoutException
-  {
+      throws CacheWriterException, TimeoutException {
-    RegionEventImpl event = new RegionEventImpl(this, Operation.REGION_DESTROY,
-        aCallbackArgument, false, getMyId(), generateEventID());
+    RegionEventImpl event = new RegionEventImpl(this, Operation.REGION_DESTROY, aCallbackArgument,
+        false, getMyId(), generateEventID());
+   * 
-  public final Object getDeserializedValue(RegionEntry re,
-                                           final KeyInfo keyInfo,
-                                           final boolean updateStats,
-                                           boolean disableCopyOnRead,
-                                           boolean preferCD,
-                                           EntryEventImpl clientEvent,
-                                           boolean returnTombstones,
-                                           boolean retainResult) {
+  public final Object getDeserializedValue(RegionEntry re, final KeyInfo keyInfo,
+      final boolean updateStats, boolean disableCopyOnRead, boolean preferCD,
+      EntryEventImpl clientEvent, boolean returnTombstones, boolean retainResult) {
-      //skip updating the stats if the value is null
+      // skip updating the stats if the value is null
-        synchronized(re) { // bug #51059 value & version must be obtained atomically
-          clientEvent.setVersionTag(re.getVersionStamp().asVersionTag());
-          value = getDeserialized(re, updateStats, disableCopyOnRead, preferCD, retainResult);
-        }
+          synchronized (re) { // bug #51059 value & version must be obtained atomically
+            clientEvent.setVersionTag(re.getVersionStamp().asVersionTag());
+            value = getDeserialized(re, updateStats, disableCopyOnRead, preferCD, retainResult);
+          }
-          }catch( DiskAccessException dae) {
+          } catch (DiskAccessException dae) {
-        logger.trace("getDeserializedValue for {} returning version: {} returnTombstones: {} value: {}",
-            keyInfo.getKey(), (re.getVersionStamp()==null? "null" : re.getVersionStamp().asVersionTag()), returnTombstones, value);
+        logger.trace(
+            "getDeserializedValue for {} returning version: {} returnTombstones: {} value: {}",
+            keyInfo.getKey(),
+            (re.getVersionStamp() == null ? "null" : re.getVersionStamp().asVersionTag()),
+            returnTombstones, value);
-    }
-    finally {
+    } finally {
-   *  <ul>
-   *    <li> null if the value was removed from the region entry
-   *    <li>Token.INVALID if the value of the region entry is invalid
-   *    <li>Token.LOCAL_INVALID if the value of the region entry is local invalid
-   *  </ul>
+   *         <ul>
+   *         <li>null if the value was removed from the region entry
+   *         <li>Token.INVALID if the value of the region entry is invalid
+   *         <li>Token.LOCAL_INVALID if the value of the region entry is local invalid
+   *         </ul>
-  protected final Object getDeserialized(RegionEntry re, boolean updateStats, boolean disableCopyOnRead, boolean preferCD, boolean retainResult) {
+  protected final Object getDeserialized(RegionEntry re, boolean updateStats,
+      boolean disableCopyOnRead, boolean preferCD, boolean retainResult) {
-      @Retained Object v = null;
+      @Retained
+      Object v = null;
-      } catch(DiskAccessException dae) {
+      } catch (DiskAccessException dae) {
-  
-      //skip updating the stats if the value is null
+
+      // skip updating the stats if the value is null
-              v = ((CachedDeserializable)v).getDeserializedForReading();
+              v = ((CachedDeserializable) v).getDeserializedForReading();
-              v = ((CachedDeserializable)v).getDeserializedWritableCopy(this, re);
+              v = ((CachedDeserializable) v).getDeserializedWritableCopy(this, re);
-            v = ((CachedDeserializable)v).getDeserializedValue(this, re);
+            v = ((CachedDeserializable) v).getDeserializedValue(this, re);
+      } else if (!disableCopyOnRead) {
+        v = conditionalCopy(v);
-      else if (!disableCopyOnRead) {
-          v = conditionalCopy(v);
-      }
-  
+
-    } catch(IllegalArgumentException i) {
-      IllegalArgumentException iae = new IllegalArgumentException(LocalizedStrings.DONT_RELEASE.toLocalizedString("Error while deserializing value for key="+re.getKey()));
+    } catch (IllegalArgumentException i) {
+      IllegalArgumentException iae = new IllegalArgumentException(LocalizedStrings.DONT_RELEASE
+          .toLocalizedString("Error while deserializing value for key=" + re.getKey()));
-      if(disabledLRUCallback) {
+      if (disabledLRUCallback) {
-  
+
-  public Object get(Object key, Object aCallbackArgument,
-      boolean generateCallbacks, EntryEventImpl clientEvent) throws TimeoutException, CacheLoaderException
-  {
-    Object result = get(key, aCallbackArgument, generateCallbacks, false, false, null, clientEvent, false);
+  public Object get(Object key, Object aCallbackArgument, boolean generateCallbacks,
+      EntryEventImpl clientEvent) throws TimeoutException, CacheLoaderException {
+    Object result =
+        get(key, aCallbackArgument, generateCallbacks, false, false, null, clientEvent, false);
-  
+
-  public Object get(Object key,
-                    Object aCallbackArgument,
-                    boolean generateCallbacks,
-                    boolean disableCopyOnRead,
-                    boolean preferCD,
-                    ClientProxyMembershipID requestingClient,
-                    EntryEventImpl clientEvent,
-                    boolean returnTombstones) throws TimeoutException, CacheLoaderException {
-	  return get(key, aCallbackArgument,
-		      generateCallbacks, disableCopyOnRead, preferCD,requestingClient, clientEvent, returnTombstones, false, false);
+  public Object get(Object key, Object aCallbackArgument, boolean generateCallbacks,
+      boolean disableCopyOnRead, boolean preferCD, ClientProxyMembershipID requestingClient,
+      EntryEventImpl clientEvent, boolean returnTombstones)
+      throws TimeoutException, CacheLoaderException {
+    return get(key, aCallbackArgument, generateCallbacks, disableCopyOnRead, preferCD,
+        requestingClient, clientEvent, returnTombstones, false, false);
-  
+
-  public Object getRetained(Object key, Object aCallbackArgument,
-      boolean generateCallbacks, boolean disableCopyOnRead,
-      ClientProxyMembershipID requestingClient, EntryEventImpl clientEvent, boolean returnTombstones) throws TimeoutException, CacheLoaderException {
-    return getRetained(key, aCallbackArgument,
-              generateCallbacks, disableCopyOnRead, requestingClient, clientEvent, returnTombstones, false);
+  public Object getRetained(Object key, Object aCallbackArgument, boolean generateCallbacks,
+      boolean disableCopyOnRead, ClientProxyMembershipID requestingClient,
+      EntryEventImpl clientEvent, boolean returnTombstones)
+      throws TimeoutException, CacheLoaderException {
+    return getRetained(key, aCallbackArgument, generateCallbacks, disableCopyOnRead,
+        requestingClient, clientEvent, returnTombstones, false);
-   * @param opScopeIsLocal if true then just check local storage for a value; if false then try to find the value if it is not local
+   * 
+   * @param opScopeIsLocal if true then just check local storage for a value; if false then try to
+   *        find the value if it is not local
-  public Object getRetained(Object key, Object aCallbackArgument,
-      boolean generateCallbacks, boolean disableCopyOnRead,
-      ClientProxyMembershipID requestingClient, EntryEventImpl clientEvent, boolean returnTombstones, boolean opScopeIsLocal) throws TimeoutException, CacheLoaderException {
-    return get(key, aCallbackArgument, generateCallbacks, disableCopyOnRead, true, requestingClient, clientEvent, returnTombstones, opScopeIsLocal,
-      false /* see GEODE-1291*/);
+  public Object getRetained(Object key, Object aCallbackArgument, boolean generateCallbacks,
+      boolean disableCopyOnRead, ClientProxyMembershipID requestingClient,
+      EntryEventImpl clientEvent, boolean returnTombstones, boolean opScopeIsLocal)
+      throws TimeoutException, CacheLoaderException {
+    return get(key, aCallbackArgument, generateCallbacks, disableCopyOnRead, true, requestingClient,
+        clientEvent, returnTombstones, opScopeIsLocal, false /* see GEODE-1291 */);
+
-   * @param opScopeIsLocal if true then just check local storage for a value; if false then try to find the value if it is not local
+   * @param opScopeIsLocal if true then just check local storage for a value; if false then try to
+   *        find the value if it is not local
-  public Object get(Object key, Object aCallbackArgument,
-                    boolean generateCallbacks, boolean disableCopyOnRead, boolean preferCD,
-                    ClientProxyMembershipID requestingClient, EntryEventImpl clientEvent, boolean returnTombstones,
-                    boolean opScopeIsLocal, boolean retainResult) throws TimeoutException, CacheLoaderException
-  {
+  public Object get(Object key, Object aCallbackArgument, boolean generateCallbacks,
+      boolean disableCopyOnRead, boolean preferCD, ClientProxyMembershipID requestingClient,
+      EntryEventImpl clientEvent, boolean returnTombstones, boolean opScopeIsLocal,
+      boolean retainResult) throws TimeoutException, CacheLoaderException {
-      Object value = getDataView().getDeserializedValue(keyInfo, this, true, disableCopyOnRead, preferCD, clientEvent, returnTombstones,
-        retainResult);
+      Object value = getDataView().getDeserializedValue(keyInfo, this, true, disableCopyOnRead,
+          preferCD, clientEvent, returnTombstones, retainResult);
-            && ((getScope().isDistributed())
-                || hasServerProxy()
-                || basicGetLoader() != null)) { 
+            && ((getScope().isDistributed()) || hasServerProxy() || basicGetLoader() != null)) {
-          value = getDataView().findObject(keyInfo,
-              this, isCreate, generateCallbacks, value, disableCopyOnRead,
-              preferCD, requestingClient, clientEvent, returnTombstones);
+          value = getDataView().findObject(keyInfo, this, isCreate, generateCallbacks, value,
+              disableCopyOnRead, preferCD, requestingClient, clientEvent, returnTombstones);
-        }
-        else { // local scope with no loader, still might need to update stats
+        } else { // local scope with no loader, still might need to update stats
-    }
-    finally {
+    } finally {
-   * Update region and potentially entry stats for the miss case 
+   * Update region and potentially entry stats for the miss case
+   * 
-   * optimized to only allow one thread to do a search/load, other threads wait
-   * on a future
-   *  @param keyInfo
-   * @param p_isCreate
-   *                true if call found no entry; false if updating an existing
-   *                entry
+   * optimized to only allow one thread to do a search/load, other threads wait on a future
+   * 
+   * @param keyInfo
+   * @param p_isCreate true if call found no entry; false if updating an existing entry
-   * @param p_localValue
-*                the value retrieved from the region for this object.
+   * @param p_localValue the value retrieved from the region for this object.
-  Object nonTxnFindObject(KeyInfo keyInfo,
-                          boolean p_isCreate,
-                          boolean generateCallbacks,
-                          Object p_localValue,
-                          boolean disableCopyOnRead,
-                          boolean preferCD,
-                          ClientProxyMembershipID requestingClient,
-                          EntryEventImpl clientEvent,
-                          boolean returnTombstones)
-      throws TimeoutException, CacheLoaderException
-  {
+  Object nonTxnFindObject(KeyInfo keyInfo, boolean p_isCreate, boolean generateCallbacks,
+      Object p_localValue, boolean disableCopyOnRead, boolean preferCD,
+      ClientProxyMembershipID requestingClient, EntryEventImpl clientEvent,
+      boolean returnTombstones) throws TimeoutException, CacheLoaderException {
-  
+
-    @Retained Object result = null;
+    @Retained
+    Object result = null;
-    Future otherFuture = (Future)this.getFutures.putIfAbsent(keyInfo.getKey(), thisFuture);
+    Future otherFuture = (Future) this.getFutures.putIfAbsent(keyInfo.getKey(), thisFuture);
-        valueAndVersion = (Object[])otherFuture.get();
+        valueAndVersion = (Object[]) otherFuture.get();
-            clientEvent.setVersionTag((VersionTag)valueAndVersion[1]);
+            clientEvent.setVersionTag((VersionTag) valueAndVersion[1]);
-            CachedDeserializable cd = (CachedDeserializable)result;
+            CachedDeserializable cd = (CachedDeserializable) result;
-           
+
-         // what was a miss is now a hit
+          // what was a miss is now a hit
-      }
-      catch (InterruptedException e) {
+      } catch (InterruptedException e) {
-      }
-      catch (ExecutionException e) {
+      } catch (ExecutionException e) {
-        InternalGemFireError err = new InternalGemFireError(LocalizedStrings.LocalRegion_UNEXPECTED_EXCEPTION.toLocalizedString());
+        InternalGemFireError err = new InternalGemFireError(
+            LocalizedStrings.LocalRegion_UNEXPECTED_EXCEPTION.toLocalizedString());
-        localValue = getDeserializedValue(null, keyInfo, isCreate, disableCopyOnRead, preferCD, clientEvent, false,
-          false);
+        localValue = getDeserializedValue(null, keyInfo, isCreate, disableCopyOnRead, preferCD,
+            clientEvent, false, false);
-        result = findObjectInSystem(keyInfo, isCreate, null, generateCallbacks,
-            localValue, disableCopyOnRead, preferCD, requestingClient, clientEvent, returnTombstones);
+        result = findObjectInSystem(keyInfo, isCreate, null, generateCallbacks, localValue,
+            disableCopyOnRead, preferCD, requestingClient, clientEvent, returnTombstones);
-        
-        // This code was moved from PartitionedRegion.nonTxnFindObject().  That method has been removed.
-        // For PRs we don't want to deserialize the value and we can't use findObjectInSystem because
+
+        // This code was moved from PartitionedRegion.nonTxnFindObject(). That method has been
+        // removed.
+        // For PRs we don't want to deserialize the value and we can't use findObjectInSystem
+        // because
-        result = getSharedDataView().findObject(keyInfo, this, isCreate, generateCallbacks,
-            localValue, disableCopyOnRead, preferCD, requestingClient, clientEvent, returnTombstones);
+        result =
+            getSharedDataView().findObject(keyInfo, this, isCreate, generateCallbacks, localValue,
+                disableCopyOnRead, preferCD, requestingClient, clientEvent, returnTombstones);
-    }
-    finally {
+    } finally {
-        VersionTag tag = (clientEvent==null)? null : clientEvent.getVersionTag();
-        thisFuture.set(new Object[]{result, tag});
+        VersionTag tag = (clientEvent == null) ? null : clientEvent.getVersionTag();
+        thisFuture.set(new Object[] {result, tag});
-  protected boolean isCopyOnRead()
-  {
-    return this.compressor == null
-      && this.cache.isCopyOnRead()
-      && ! this.isUsedForPartitionedRegionAdmin
-      && ! this.isUsedForMetaRegion
-      && ! getOffHeap()
-      && ! isSecret();
+  protected boolean isCopyOnRead() {
+    return this.compressor == null && this.cache.isCopyOnRead()
+        && !this.isUsedForPartitionedRegionAdmin && !this.isUsedForMetaRegion && !getOffHeap()
+        && !isSecret();
-  protected Object conditionalCopy(Object o)
-  {
+  protected Object conditionalCopy(Object o) {
-    }
-    else {
+    } else {
-  public String getFullPath()
-  {
+  public String getFullPath() {
-  //   public String getFullPath() {
-  //     // work way up to root region, prepending
-  //     // the region names to a buffer
-  //     StringBuffer buf = new StringBuffer(SEPARATOR);
-  //     Assert.assertTrue(this.regionName != null);
-  //     buf.append(this.regionName);
-  //     LocalRegion r = this;
-  //     while ((r = r.parentRegion) != null) {
-  //       buf.insert(0, r.regionName);
-  //       buf.insert(0, SEPARATOR_CHAR);
-  //     }
-  //     return buf.toString();
-  //   }
+  // public String getFullPath() {
+  // // work way up to root region, prepending
+  // // the region names to a buffer
+  // StringBuffer buf = new StringBuffer(SEPARATOR);
+  // Assert.assertTrue(this.regionName != null);
+  // buf.append(this.regionName);
+  // LocalRegion r = this;
+  // while ((r = r.parentRegion) != null) {
+  // buf.insert(0, r.regionName);
+  // buf.insert(0, SEPARATOR_CHAR);
+  // }
+  // return buf.toString();
+  // }
-  public Region getParentRegion()
-  {
-    //checkReadiness();
+  public Region getParentRegion() {
+    // checkReadiness();
-  public Region getSubregion(String path)
-  {
+  public Region getSubregion(String path) {
-  public void invalidateRegion(Object aCallbackArgument)
-      throws TimeoutException
-  {
+  public void invalidateRegion(Object aCallbackArgument) throws TimeoutException {
-      aCallbackArgument, false, getMyId(), generateEventID());
+        aCallbackArgument, false, getMyId(), generateEventID());
-    @Released EntryEventImpl event = newUpdateEntryEvent(key, value, aCallbackArgument);
+    @Released
+    EntryEventImpl event = newUpdateEntryEvent(key, value, aCallbackArgument);
-      if (event.getEventId() == null && generateEventID()) {
-        event.setNewEventId(cache.getDistributedSystem());
+    if (event.getEventId() == null && generateEventID()) {
+      event.setNewEventId(cache.getDistributedSystem());
+    }
+    Object oldValue = null;
+    if (basicPut(event, false, // ifNew
+        false, // ifOld
+        null, // expectedOldValue
+        false // requireOldValue
+    )) {
+      if (!event.isOldValueOffHeap()) {
+        // don't copy it to heap just to return from put.
+        // TODO: come up with a better way to do this.
+        oldValue = event.getOldValue();
-      Object oldValue = null;
-      if (basicPut(event, false, // ifNew
-          false, // ifOld
-          null, // expectedOldValue
-          false // requireOldValue
-      )) {
-        if (!event.isOldValueOffHeap()) {
-          // don't copy it to heap just to return from put.
-          // TODO: come up with a better way to do this.
-          oldValue = event.getOldValue();
-        }
-        if (!getDataView().isDeferredStats()) {
-          getCachePerfStats().endPut(startPut, false);
-        }
+      if (!getDataView().isDeferredStats()) {
+        getCachePerfStats().endPut(startPut, false);
-      return handleNotAvailable(oldValue);
+    }
+    return handleNotAvailable(oldValue);
-      throw new NullPointerException(LocalizedStrings
-          .LocalRegion_VALUE_MUST_NOT_BE_NULL.toLocalizedString());
+      throw new NullPointerException(
+          LocalizedStrings.LocalRegion_VALUE_MUST_NOT_BE_NULL.toLocalizedString());
-    //   generate EventID
-    @Retained final EntryEventImpl event = EntryEventImpl.create(
-        this, Operation.UPDATE, key,
-        value, aCallbackArgument, false, getMyId());
+    // generate EventID
+    @Retained
+    final EntryEventImpl event = EntryEventImpl.create(this, Operation.UPDATE, key, value,
+        aCallbackArgument, false, getMyId());
-    extractDeltaIntoEvent(value, event);
-    eventReturned = true;
-    return event;
+      extractDeltaIntoEvent(value, event);
+      eventReturned = true;
+      return event;
-      if (!eventReturned) event.release();
+      if (!eventReturned)
+        event.release();
+
-    // 3. Check if it has server region proxy. 
-    //    We do not have a handle to event in PutOpImpl to check if we have 
-    //    delta bytes calculated already. So no need to calculate it here.
+    // 3. Check if it has server region proxy.
+    // We do not have a handle to event in PutOpImpl to check if we have
+    // delta bytes calculated already. So no need to calculate it here.
-            if (((PartitionedRegion)this).getRedundantCopies() > 0) {
+            if (((PartitionedRegion) this).getRedundantCopies() > 0) {
-              InternalDistributedMember ids = (InternalDistributedMember)PartitionRegionHelper
+              InternalDistributedMember ids = (InternalDistributedMember) PartitionRegionHelper
-              && !((DistributedRegion)this).scope.isDistributedNoAck()
-              && ((DistributedRegion)this).getCacheDistributionAdvisor()
-                  .adviseCacheOp().size() > 0) {
+              && !((DistributedRegion) this).scope.isDistributedNoAck()
+              && ((DistributedRegion) this).getCacheDistributionAdvisor().adviseCacheOp()
+                  .size() > 0) {
-        if (extractDelta && ((org.apache.geode.Delta)value).hasDelta()) {
+        if (extractDelta && ((org.apache.geode.Delta) value).hasDelta()) {
-            ((org.apache.geode.Delta)value).toDelta(hdos);
+            ((org.apache.geode.Delta) value).toDelta(hdos);
-                    .toLocalizedString(), e);
+                    .toLocalizedString(),
+                e);
-    PartitionedRegion pr = ((PartitionedRegion)this);
+    PartitionedRegion pr = ((PartitionedRegion) this);
-    Set<InternalDistributedMember> recipients = br.getCacheDistributionAdvisor().adviseUpdate(event);
+    Set<InternalDistributedMember> recipients =
+        br.getCacheDistributionAdvisor().adviseUpdate(event);
-  public Region.Entry getEntry(Object key)
-  {
+  public Region.Entry getEntry(Object key) {
-   * Just like getEntry but also updates the stats that get would have depending
-   * on a flag. See bug 42410. Also skips discovering JTA
+   * Just like getEntry but also updates the stats that get would have depending on a flag. See bug
+   * 42410. Also skips discovering JTA
-    if(updateStats) {
+    if (updateStats) {
-          && (rm = this.diskRegion.getRecoveredEntryMap()) != null
-          && (size = rm.size()) > 0) {
+          && (rm = this.diskRegion.getRecoveredEntryMap()) != null && (size = rm.size()) > 0) {
-    /**
+
+  /**
-   * @param access
-   *          true if caller wants last accessed time updated
+   * @param access true if caller wants last accessed time updated
-    //long start=0, end=0;
-    //start = System.currentTimeMillis();
-    //end = System.currentTimeMillis();
-    //System.out.println("getEntry: " + (end-start));
+    // long start=0, end=0;
+    // start = System.currentTimeMillis();
+    // end = System.currentTimeMillis();
+    // System.out.println("getEntry: " + (end-start));
-  protected boolean isClosed()
-  {
+  protected boolean isClosed() {
-   * Returns true if this region is or has been closed or destroyed.
-   * Note that unlike {@link #isDestroyed()} this method will not
-   * return true if the cache is closing but has not yet started closing
-   * this region.
+   * Returns true if this region is or has been closed or destroyed. Note that unlike
+   * {@link #isDestroyed()} this method will not return true if the cache is closing but has not yet
+   * started closing this region.
-  
+
-  public boolean isDestroyed()
-  {
+  public boolean isDestroyed() {
-    //    boolean result = false;
+    // boolean result = false;
-    //    if (!isInitialized()) { // don't return true if still initializing
-    //      if (finestEnabled) {
-    //        log.finest("isDestroyed: false, not initialized: " + getFullPath());
-    //      }
-    //      return false;
-    //    }
+    // if (!isInitialized()) { // don't return true if still initializing
+    // if (finestEnabled) {
+    // log.finest("isDestroyed: false, not initialized: " + getFullPath());
+    // }
+    // return false;
+    // }
-  
+
+   * 
-  public Set testHookKeys()
-  {
+  public Set testHookKeys() {
-  public Set keys()
-  {
+  public Set keys() {
+   * 
-  public Collection values()
-  {
+  public Collection values() {
-  public Object getUserAttribute()
-  {
+  public Object getUserAttribute() {
-  public void setUserAttribute(Object value)
-  {
+  public void setUserAttribute(Object value) {
-  public boolean containsKey(Object key)
-  {
+  public boolean containsKey(Object key) {
-  public boolean containsTombstone(Object key)
-  {
+  public boolean containsTombstone(Object key) {
-  public boolean containsValueForKey(Object key)
-  {
+  public boolean containsValueForKey(Object key) {
-        Object val = entry.getTransformedValue(); // no need to decompress since we only want to know if we have an existing value 
+        Object val = entry.getTransformedValue(); // no need to decompress since we only want to
+                                                  // know if we have an existing value
-        // No need to to check CachedDeserializable because of Bruce's fix in r30960 for bug 42162. See bug 42732.
+        // No need to to check CachedDeserializable because of Bruce's fix in r30960 for bug 42162.
+        // See bug 42732.
-    }
-    finally {
+    } finally {
-  public RegionAttributes getAttributes()
-  {
+  public RegionAttributes getAttributes() {
-    //checkReadiness();
+    // checkReadiness();
-  public String getName()
-  {
+  public String getName() {
-   * Convenience method to get region name for logging/exception messages.
-   * if this region is an instanceof bucket region, it returns the
-   * bucket region name
+   * Convenience method to get region name for logging/exception messages. if this region is an
+   * instanceof bucket region, it returns the bucket region name
+   * 
-  
+
-   * Returns the number of entries in this region. Note that because of the
-   * concurrency properties of the {@link RegionMap}, the number of entries is
-   * only an approximate. That is, other threads may change the number of
-   * entries in this region while this method is being invoked.
+   * Returns the number of entries in this region. Note that because of the concurrency properties
+   * of the {@link RegionMap}, the number of entries is only an approximate. That is, other threads
+   * may change the number of entries in this region while this method is being invoked.
-   * author David Whitlock
+   *      author David Whitlock
-  protected int entryCount( Set<Integer> buckets, boolean estimate) {
-    assert buckets == null: "unexpected buckets " + buckets + " for region "
-        + toString();
+  protected int entryCount(Set<Integer> buckets, boolean estimate) {
+    assert buckets == null : "unexpected buckets " + buckets + " for region " + toString();
-  public int entryCountEstimate(final TXStateInterface tx, Set<Integer> buckets, boolean entryCountEstimate) {
+  public int entryCountEstimate(final TXStateInterface tx, Set<Integer> buckets,
+      boolean entryCountEstimate) {
-    synchronized(getSizeGuard()) {
+    synchronized (getSizeGuard()) {
-   * Returns the <code>DiskRegion</code> that this region uses to access data
-   * on disk.
+   * Returns the <code>DiskRegion</code> that this region uses to access data on disk.
-  public DiskRegion getDiskRegion()
-  {
+  public DiskRegion getDiskRegion() {
+
-   * Lets the customer do an explicit evict of a value to disk and removes the value
-   * from memory.
+   * Lets the customer do an explicit evict of a value to disk and removes the value from memory.
-  public void checkLRU()
-  {
+  public void checkLRU() {
-      }catch( DiskAccessException dae) {
+      } catch (DiskAccessException dae) {
-  
-  public void writeToDisk()
-  {
+
+  public void writeToDisk() {
-        throw new IllegalStateException(LocalizedStrings.LocalRegion_CANNOT_WRITE_A_REGION_WITH_DATAPOLICY_0_TO_DISK.toLocalizedString(dp));
+        throw new IllegalStateException(
+            LocalizedStrings.LocalRegion_CANNOT_WRITE_A_REGION_WITH_DATAPOLICY_0_TO_DISK
+                .toLocalizedString(dp));
+      } else if (!dp.withPersistence() && !isOverflowEnabled()) {
+        throw new IllegalStateException(
+            LocalizedStrings.LocalRegion_CANNOT_WRITE_A_REGION_THAT_IS_NOT_CONFIGURED_TO_ACCESS_DISKS
+                .toLocalizedString());
-      else if (!dp.withPersistence() && !isOverflowEnabled()) {
-        throw new IllegalStateException(LocalizedStrings.LocalRegion_CANNOT_WRITE_A_REGION_THAT_IS_NOT_CONFIGURED_TO_ACCESS_DISKS.toLocalizedString());
-      }
-    }
-    else {
+    } else {
-  public void forceFlush()
-  {
+  public void forceFlush() {
-  public Lock getRegionDistributedLock() throws IllegalStateException
-  {
+  public Lock getRegionDistributedLock() throws IllegalStateException {
-    throw new IllegalStateException(LocalizedStrings.LocalRegion_ONLY_SUPPORTED_FOR_GLOBAL_SCOPE_NOT_LOCAL.toLocalizedString());
+    throw new IllegalStateException(
+        LocalizedStrings.LocalRegion_ONLY_SUPPORTED_FOR_GLOBAL_SCOPE_NOT_LOCAL.toLocalizedString());
-  public Lock getDistributedLock(Object key) throws IllegalStateException
-  {
+  public Lock getDistributedLock(Object key) throws IllegalStateException {
-    throw new IllegalStateException(LocalizedStrings.LocalRegion_ONLY_SUPPORTED_FOR_GLOBAL_SCOPE_NOT_LOCAL.toLocalizedString());
+    throw new IllegalStateException(
+        LocalizedStrings.LocalRegion_ONLY_SUPPORTED_FOR_GLOBAL_SCOPE_NOT_LOCAL.toLocalizedString());
-      throws TimeoutException, EntryNotFoundException
-  {
+      throws TimeoutException, EntryNotFoundException {
-   * Destroys entry without performing validations. Call this after validating
-   * key, callback arg, and runtime state.
+   * Destroys entry without performing validations. Call this after validating key, callback arg,
+   * and runtime state.
-      throws TimeoutException, EntryNotFoundException
-  {
-    @Released EntryEventImpl event = EntryEventImpl.create(
-        this, Operation.INVALIDATE,
-        key, null, aCallbackArgument, false, getMyId());
+      throws TimeoutException, EntryNotFoundException {
+    @Released
+    EntryEventImpl event = EntryEventImpl.create(this, Operation.INVALIDATE, key, null,
+        aCallbackArgument, false, getMyId());
-    if (generateEventID()) {
-      event.setNewEventId(cache.getDistributedSystem());
-    }
-    basicInvalidate(event);
+      if (generateEventID()) {
+        event.setNewEventId(cache.getDistributedSystem());
+      }
+      basicInvalidate(event);
-  public void localDestroy(Object key, Object aCallbackArgument)
-      throws EntryNotFoundException
-  {
+  public void localDestroy(Object key, Object aCallbackArgument) throws EntryNotFoundException {
-    @Released EntryEventImpl event = EntryEventImpl.create(
-        this,
-        Operation.LOCAL_DESTROY, key, null, aCallbackArgument, false, getMyId());
+    @Released
+    EntryEventImpl event = EntryEventImpl.create(this, Operation.LOCAL_DESTROY, key, null,
+        aCallbackArgument, false, getMyId());
-      basicDestroy(event,
-                   false,
-                   null); // expectedOldValue
-    }
-    catch (CacheWriterException e) {
+      basicDestroy(event, false, null); // expectedOldValue
+    } catch (CacheWriterException e) {
-      throw new Error(LocalizedStrings.LocalRegion_CACHE_WRITER_SHOULD_NOT_HAVE_BEEN_CALLED_FOR_LOCALDESTROY.toLocalizedString(), e);
-    }
-    catch (TimeoutException e) {
+      throw new Error(
+          LocalizedStrings.LocalRegion_CACHE_WRITER_SHOULD_NOT_HAVE_BEEN_CALLED_FOR_LOCALDESTROY
+              .toLocalizedString(),
+          e);
+    } catch (TimeoutException e) {
-      throw new Error(LocalizedStrings.LocalRegion_NO_DISTRIBUTED_LOCK_SHOULD_HAVE_BEEN_ATTEMPTED_FOR_LOCALDESTROY.toLocalizedString(), e);
+      throw new Error(
+          LocalizedStrings.LocalRegion_NO_DISTRIBUTED_LOCK_SHOULD_HAVE_BEEN_ATTEMPTED_FOR_LOCALDESTROY
+              .toLocalizedString(),
+          e);
-  public void localDestroyRegion(Object aCallbackArgument)
-  {
+  public void localDestroyRegion(Object aCallbackArgument) {
-    RegionEventImpl event = new RegionEventImpl(this,
-        Operation.REGION_LOCAL_DESTROY, aCallbackArgument, false, getMyId(),
-        generateEventID()/* generate EventID */);
+    RegionEventImpl event = new RegionEventImpl(this, Operation.REGION_LOCAL_DESTROY,
+        aCallbackArgument, false, getMyId(), generateEventID()/* generate EventID */);
-    }
-    catch (CacheWriterException e) {
+    } catch (CacheWriterException e) {
-      throw new Error(LocalizedStrings.LocalRegion_CACHEWRITEREXCEPTION_SHOULD_NOT_BE_THROWN_IN_LOCALDESTROYREGION.toLocalizedString(), e);
-    }
-    catch (TimeoutException e) {
+      throw new Error(
+          LocalizedStrings.LocalRegion_CACHEWRITEREXCEPTION_SHOULD_NOT_BE_THROWN_IN_LOCALDESTROYREGION
+              .toLocalizedString(),
+          e);
+    } catch (TimeoutException e) {
-      throw new Error(LocalizedStrings.LocalRegion_TIMEOUTEXCEPTION_SHOULD_NOT_BE_THROWN_IN_LOCALDESTROYREGION.toLocalizedString(), e);
+      throw new Error(
+          LocalizedStrings.LocalRegion_TIMEOUTEXCEPTION_SHOULD_NOT_BE_THROWN_IN_LOCALDESTROYREGION
+              .toLocalizedString(),
+          e);
-  public void close()
-  {
+  public void close() {
-    RegionEventImpl event = new RegionEventImpl(this, Operation.REGION_CLOSE,
-        null, false, getMyId(), generateEventID()/* generate EventID */);
+    RegionEventImpl event = new RegionEventImpl(this, Operation.REGION_CLOSE, null, false,
+        getMyId(), generateEventID()/* generate EventID */);
-    }
-    catch (CacheWriterException e) {
+    } catch (CacheWriterException e) {
-      throw new Error(LocalizedStrings.LocalRegion_CACHEWRITEREXCEPTION_SHOULD_NOT_BE_THROWN_IN_LOCALDESTROYREGION.toLocalizedString(), e);
-    }
-    catch (TimeoutException e) {
+      throw new Error(
+          LocalizedStrings.LocalRegion_CACHEWRITEREXCEPTION_SHOULD_NOT_BE_THROWN_IN_LOCALDESTROYREGION
+              .toLocalizedString(),
+          e);
+    } catch (TimeoutException e) {
-      throw new Error(LocalizedStrings.LocalRegion_TIMEOUTEXCEPTION_SHOULD_NOT_BE_THROWN_IN_LOCALDESTROYREGION.toLocalizedString(), e);
+      throw new Error(
+          LocalizedStrings.LocalRegion_TIMEOUTEXCEPTION_SHOULD_NOT_BE_THROWN_IN_LOCALDESTROYREGION
+              .toLocalizedString(),
+          e);
-  public void localInvalidate(Object key, Object callbackArgument)
-      throws EntryNotFoundException
-  {
+  public void localInvalidate(Object key, Object callbackArgument) throws EntryNotFoundException {
-    @Released EntryEventImpl event = EntryEventImpl.create(
-        this,
-        Operation.LOCAL_INVALIDATE, key, null/* newValue */, callbackArgument,
-        false, getMyId());
+    @Released
+    EntryEventImpl event = EntryEventImpl.create(this, Operation.LOCAL_INVALIDATE, key,
+        null/* newValue */, callbackArgument, false, getMyId());
-    if (generateEventID()) {
-      event.setNewEventId(cache.getDistributedSystem());
-    }
-    event.setLocalInvalid(true);
-    basicInvalidate(event);
+      if (generateEventID()) {
+        event.setNewEventId(cache.getDistributedSystem());
+      }
+      event.setLocalInvalid(true);
+      basicInvalidate(event);
-  public void localInvalidateRegion(Object aCallbackArgument)
-  {
+  public void localInvalidateRegion(Object aCallbackArgument) {
-    RegionEventImpl event = new RegionEventImpl(this,
-        Operation.REGION_LOCAL_INVALIDATE, aCallbackArgument, false, getMyId());
+    RegionEventImpl event = new RegionEventImpl(this, Operation.REGION_LOCAL_INVALIDATE,
+        aCallbackArgument, false, getMyId());
-   * @param system
-   *          the distributed system whose cache contains the root of interest
+   * @param system the distributed system whose cache contains the root of interest
-  public static LocalRegion getRegionFromPath(DistributedSystem system,
-      String path)
-  {
+  public static LocalRegion getRegionFromPath(DistributedSystem system, String path) {
-    if(c==null) {
+    if (c == null) {
-      return (LocalRegion)c.getRegion(path);
+      return (LocalRegion) c.getRegion(path);
-  //   public void dumpEntryMapStats(PrintStream out) {
-  //     ((ConcurrentHashMap)this.entries).dumpStats(out);
-  //   }
+  // public void dumpEntryMapStats(PrintStream out) {
+  // ((ConcurrentHashMap)this.entries).dumpStats(out);
+  // }
-   * Do any extra initialization required. Region is already visible in parent's
-   * subregion map. This method releases the initialization Latches, so
-   * subclasses should call this super method last after performing additional
-   * initialization.
+   * Do any extra initialization required. Region is already visible in parent's subregion map. This
+   * method releases the initialization Latches, so subclasses should call this super method last
+   * after performing additional initialization.
-   * @param imageTarget
-   *          ignored, used by subclass for get initial image
-   * @param internalRegionArgs 
-   * @see DistributedRegion#initialize(InputStream, InternalDistributedMember, InternalRegionArguments)
+   * @param imageTarget ignored, used by subclass for get initial image
+   * @param internalRegionArgs
+   * @see DistributedRegion#initialize(InputStream, InternalDistributedMember,
+   *      InternalRegionArguments)
-  protected void initialize(InputStream snapshotInputStream,
-      InternalDistributedMember imageTarget, InternalRegionArguments internalRegionArgs) throws TimeoutException,
-      IOException, ClassNotFoundException
-  {
+  protected void initialize(InputStream snapshotInputStream, InternalDistributedMember imageTarget,
+      InternalRegionArguments internalRegionArgs)
+      throws TimeoutException, IOException, ClassNotFoundException {
-      }catch(DiskAccessException dae) {
+      } catch (DiskAccessException dae) {
-    }
-    catch (RegionDestroyedException e) {
+    } catch (RegionDestroyedException e) {
- 
-  protected void createOQLIndexes(InternalRegionArguments internalRegionArgs) {  
+
+  protected void createOQLIndexes(InternalRegionArguments internalRegionArgs) {
- 
-  protected void createOQLIndexes(InternalRegionArguments internalRegionArgs, boolean recoverFromDisk) {
-    
-    if (internalRegionArgs == null || internalRegionArgs.getIndexes() == null || internalRegionArgs.getIndexes().size() == 0){
+
+  protected void createOQLIndexes(InternalRegionArguments internalRegionArgs,
+      boolean recoverFromDisk) {
+
+    if (internalRegionArgs == null || internalRegionArgs.getIndexes() == null
+        || internalRegionArgs.getIndexes().size() == 0) {
-    if(dr != null) {
+    if (dr != null) {
-      if(recoverFromDisk && !isOverflowToDisk) {
+      if (recoverFromDisk && !isOverflowToDisk) {
-        // For disk regions, index creation should wait for async value creation to complete before it starts its iteration
-        // In case of disk overflow regions the waitForAsyncRecovery is done in populateOQLIndexes method via getBestIterator() 
+        // For disk regions, index creation should wait for async value creation to complete before
+        // it starts its iteration
+        // In case of disk overflow regions the waitForAsyncRecovery is done in populateOQLIndexes
+        // method via getBestIterator()
-        IndexCreationData icd = (IndexCreationData)o;
+        IndexCreationData icd = (IndexCreationData) o;
-              externalContext.setBucketRegion(internalRegionArgs.getPartitionedRegion(), (BucketRegion)this);
+              externalContext.setBucketRegion(internalRegionArgs.getPartitionedRegion(),
+                  (BucketRegion) this);
-            //load entries during initialization only for non overflow regions
-            indexes.add(this.indexManager.createIndex(icd.getIndexName(), icd.getIndexType(), 
-                icd.getIndexExpression(), icd.getIndexFromClause(), 
-                icd.getIndexImportString(), externalContext, icd.getPartitionedIndex(), !isOverflowToDisk));
+            // load entries during initialization only for non overflow regions
+            indexes.add(this.indexManager.createIndex(icd.getIndexName(), icd.getIndexType(),
+                icd.getIndexExpression(), icd.getIndexFromClause(), icd.getIndexImportString(),
+                externalContext, icd.getPartitionedIndex(), !isOverflowToDisk));
-            DefaultQueryService qs = (DefaultQueryService) this.getGemFireCache().getLocalQueryService();
-            String fromClause = (icd.getIndexType() == IndexType.FUNCTIONAL || icd.getIndexType() == IndexType.HASH)? icd.getIndexFromClause() : this.getFullPath();
-            //load entries during initialization only for non overflow regions
-            indexes.add(qs.createIndex(icd.getIndexName(), icd.getIndexType(), icd.getIndexExpression(), fromClause, icd.getIndexImportString(), !isOverflowToDisk));
+            DefaultQueryService qs =
+                (DefaultQueryService) this.getGemFireCache().getLocalQueryService();
+            String fromClause =
+                (icd.getIndexType() == IndexType.FUNCTIONAL || icd.getIndexType() == IndexType.HASH)
+                    ? icd.getIndexFromClause() : this.getFullPath();
+            // load entries during initialization only for non overflow regions
+            indexes.add(
+                qs.createIndex(icd.getIndexName(), icd.getIndexType(), icd.getIndexExpression(),
+                    fromClause, icd.getIndexImportString(), !isOverflowToDisk));
-        }
-        catch (Exception ex) {
-          logger.info("Failed to create index {} on region {} with exception: {}", icd.getIndexName(), this.getFullPath(), ex);
+        } catch (Exception ex) {
+          logger.info("Failed to create index {} on region {} with exception: {}",
+              icd.getIndexName(), this.getFullPath(), ex);
-          // Other case is when bucket regions are created dynamically, in that case ignore the exception.
+          // Other case is when bucket regions are created dynamically, in that case ignore the
+          // exception.
-            InternalGemFireError err = new InternalGemFireError(LocalizedStrings.GemFireCache_INDEX_CREATION_EXCEPTION_1.toLocalizedString(new Object[] {icd.getIndexName(), this.getFullPath()}) );
+            InternalGemFireError err =
+                new InternalGemFireError(LocalizedStrings.GemFireCache_INDEX_CREATION_EXCEPTION_1
+                    .toLocalizedString(new Object[] {icd.getIndexName(), this.getFullPath()}));
-    if(isOverflowToDisk){
-      if(recoverFromDisk) {
+    if (isOverflowToDisk) {
+      if (recoverFromDisk) {
-      //due to bug #52096, the pr index populate flags were not being set 
-      //we should revisit and clean up the index creation code paths
+      // due to bug #52096, the pr index populate flags were not being set
+      // we should revisit and clean up the index creation code paths
-  
+
-  protected void releaseLatches()
-  {
+  protected void releaseLatches() {
-  protected void releaseBeforeGetInitialImageLatch()
-  {
+  protected void releaseBeforeGetInitialImageLatch() {
-  private void releaseAfterRegionCreateEventLatch()
-  {
+  private void releaseAfterRegionCreateEventLatch() {
-   * Used to cause cache listener events to wait until the after region create
-   * event is delivered.
+   * Used to cause cache listener events to wait until the after region create event is delivered.
-  private void waitForRegionCreateEvent()
-  {
+  private void waitForRegionCreateEvent() {
-  private static void releaseLatch(StoppableCountDownLatch latch)
-  {
+  private static void releaseLatch(StoppableCountDownLatch latch) {
-   * @param eventSet
-   *          collects the events for all destroyed regions if null, then we're
-   *          closing so don't send events to callbacks or destroy the disk
-   *          region
+   * @param eventSet collects the events for all destroyed regions if null, then we're closing so
+   *        don't send events to callbacks or destroy the disk region
-  private void recursiveDestroyRegion(Set eventSet, RegionEventImpl p_event,
-      boolean cacheWrite) throws CacheWriterException, TimeoutException
-  {
+  private void recursiveDestroyRegion(Set eventSet, RegionEventImpl p_event, boolean cacheWrite)
+      throws CacheWriterException, TimeoutException {
-      }
-      catch (CancelException e) {
-        // I don't think this should ever happens:  bulletproofing for bug 39454
+      } catch (CancelException e) {
+        // I don't think this should ever happens: bulletproofing for bug 39454
-          logger.warn(LocalizedMessage.create(LocalizedStrings.LocalRegion_RECURSIVEDESTROYREGION_PROBLEM_IN_CACHEWRITEBEFOREREGIONDESTROY), e);
+          logger.warn(
+              LocalizedMessage.create(
+                  LocalizedStrings.LocalRegion_RECURSIVEDESTROYREGION_PROBLEM_IN_CACHEWRITEBEFOREREGIONDESTROY),
+              e);
-      logger.trace(LogMarker.RVV, "version vector for {} is {}", getName(), getVersionVector().fullToString());
+      logger.trace(LogMarker.RVV, "version vector for {} is {}", getName(),
+          getVersionVector().fullToString());
-        }
-        catch (CancelException e) {
-          rgn = (LocalRegion)element; // ignore, keep going through the motions though
-        }
-        catch (RegionDestroyedException rde) {
+        } catch (CancelException e) {
+          rgn = (LocalRegion) element; // ignore, keep going through the motions though
+        } catch (RegionDestroyedException rde) {
-          event = (RegionEventImpl)event.clone();
+          event = (RegionEventImpl) event.clone();
-        }
-        catch (CancelException e) {
-          // I don't think this should ever happen:  bulletproofing for bug 39454
+        } catch (CancelException e) {
+          // I don't think this should ever happen: bulletproofing for bug 39454
-            logger.warn(LocalizedMessage.create(LocalizedStrings.LocalRegion_RECURSIVEDESTROYREGION_RECURSION_FAILED_DUE_TO_CACHE_CLOSURE_REGION_0,
+            logger.warn(LocalizedMessage.create(
+                LocalizedStrings.LocalRegion_RECURSIVEDESTROYREGION_RECURSION_FAILED_DUE_TO_CACHE_CLOSURE_REGION_0,
-          }
-          catch (QueryException e) {
+          } catch (QueryException e) {
-      }
-      catch (CancelException e) {
-        // I don't think this should ever happens:  bulletproofing for bug 39454
+      } catch (CancelException e) {
+        // I don't think this should ever happens: bulletproofing for bug 39454
-          logger.warn(LocalizedMessage.create(LocalizedStrings.LocalRegion_BASICDESTROYREGION_INDEX_REMOVAL_FAILED_DUE_TO_CACHE_CLOSURE_REGION_0,
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.LocalRegion_BASICDESTROYREGION_INDEX_REMOVAL_FAILED_DUE_TO_CACHE_CLOSURE_REGION_0,
-    }
-    finally {
+    } finally {
-      }
-      catch (CancelException e) {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.LocalRegion_RECURSIVEDESTROYREGION_POSTDESTROYREGION_FAILED_DUE_TO_CACHE_CLOSURE_REGION_0,
+      } catch (CancelException e) {
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.LocalRegion_RECURSIVEDESTROYREGION_POSTDESTROYREGION_FAILED_DUE_TO_CACHE_CLOSURE_REGION_0,
-      
+
-      }
-      else {
+      } else {
-      if (this.concurrencyChecksEnabled && this.dataPolicy.withReplication() && !this.cache.isClosed()) {
+      if (this.concurrencyChecksEnabled && this.dataPolicy.withReplication()
+          && !this.cache.isClosed()) {
-  
+
+
-  public void checkReadiness()
-  {
+  public void checkReadiness() {
-   * This method should be called when the caller cannot locate an entry and that condition
-   * is unexpected.  This will first double check the cache and region state before throwing
-   * an EntryNotFoundException.  EntryNotFoundException should be a last resort exception.
+   * This method should be called when the caller cannot locate an entry and that condition is
+   * unexpected. This will first double check the cache and region state before throwing an
+   * EntryNotFoundException. EntryNotFoundException should be a last resort exception.
-    throw new EntryNotFoundException(LocalizedStrings.PartitionedRegion_ENTRY_NOT_FOUND_FOR_KEY_0.toLocalizedString(entryKey));    
+    throw new EntryNotFoundException(
+        LocalizedStrings.PartitionedRegion_ENTRY_NOT_FOUND_FOR_KEY_0.toLocalizedString(entryKey));
-  
-  /**
-   * Search for the value in a server (if one exists),
-   * then try a loader.
+  /**
+   * 
+   * Search for the value in a server (if one exists), then try a loader.
+   * 
-   * @param clientEvent the client's event, if any.  If not null, we set the version tag
+   * @param clientEvent the client's event, if any. If not null, we set the version tag
-   * @see LocalRegion#findObjectInSystem(KeyInfo, boolean, TXStateInterface, boolean, Object, boolean, boolean, ClientProxyMembershipID, EntryEventImpl, boolean)
+   * @see LocalRegion#findObjectInSystem(KeyInfo, boolean, TXStateInterface, boolean, Object,
+   *      boolean, boolean, ClientProxyMembershipID, EntryEventImpl, boolean)
-  protected Object findObjectInSystem(KeyInfo keyInfo,
-                                      boolean isCreate,
-                                      TXStateInterface tx,
-                                      boolean generateCallbacks,
-                                      Object localValue,
-                                      boolean disableCopyOnRead,
-                                      boolean preferCD,
-                                      ClientProxyMembershipID requestingClient,
-                                      EntryEventImpl clientEvent,
-                                      boolean returnTombstones)
-      throws CacheLoaderException, TimeoutException
-  {
+  protected Object findObjectInSystem(KeyInfo keyInfo, boolean isCreate, TXStateInterface tx,
+      boolean generateCallbacks, Object localValue, boolean disableCopyOnRead, boolean preferCD,
+      ClientProxyMembershipID requestingClient, EntryEventImpl clientEvent,
+      boolean returnTombstones) throws CacheLoaderException, TimeoutException {
-    
+
-    
+
-        final LoaderHelper loaderHelper
-          = loaderHelperFactory.createLoaderHelper(key, aCallbackArgument,
-                                                   false /* netSearchAllowed */,
-                                                   true  /* netloadAllowed */,
-                                                   null  /* searcher */);
+        final LoaderHelper loaderHelper =
+            loaderHelperFactory.createLoaderHelper(key, aCallbackArgument,
+                false /* netSearchAllowed */, true /* netloadAllowed */, null /* searcher */);
-        }
-        finally {
+        } finally {
-    if (fromServer && 
-        value == Token.TOMBSTONE && !this.concurrencyChecksEnabled) {
+    if (fromServer && value == Token.TOMBSTONE && !this.concurrencyChecksEnabled) {
-    
+
-      }
-      else {
+      } else {
-      @Released EntryEventImpl event
-        = EntryEventImpl.create(this, op, key, value, aCallbackArgument,
-                             false, getMyId(), generateCallbacks);
+      @Released
+      EntryEventImpl event = EntryEventImpl.create(this, op, key, value, aCallbackArgument, false,
+          getMyId(), generateCallbacks);
-      // bug #47716 - do not put an invalid entry into the cache if there's
-      // already one there with the same version
-      if (fromServer) {
-        if (alreadyInvalid(key, event)) {
-          return null;
+        // bug #47716 - do not put an invalid entry into the cache if there's
+        // already one there with the same version
+        if (fromServer) {
+          if (alreadyInvalid(key, event)) {
+            return null;
+          }
+          event.setFromServer(fromServer);
+          event.setVersionTag(holder.getVersionTag());
+          if (clientEvent != null) {
+            clientEvent.setVersionTag(holder.getVersionTag());
+          }
-        event.setFromServer(fromServer);
-        event.setVersionTag(holder.getVersionTag());
-        if (clientEvent != null) {
-          clientEvent.setVersionTag(holder.getVersionTag());
+
+        // set the event id so that we can progagate
+        // the value to the server
+        if (!fromServer) {
+          event.setNewEventId(cache.getDistributedSystem());
-      }
-      
-      //set the event id so that we can progagate 
-      //the value to the server
-      if (!fromServer) {
-        event.setNewEventId(cache.getDistributedSystem());
-      }
-      try {
-          re = basicPutEntry(event, 0L);
-          if (!fromServer && clientEvent != null) {
-            clientEvent.setVersionTag(event.getVersionTag());
-            clientEvent.isConcurrencyConflict(event.isConcurrencyConflict());
+          try {
+            re = basicPutEntry(event, 0L);
+            if (!fromServer && clientEvent != null) {
+              clientEvent.setVersionTag(event.getVersionTag());
+              clientEvent.isConcurrencyConflict(event.isConcurrencyConflict());
+            }
+            if (fromServer && (event.getRawNewValue() == Token.TOMBSTONE)) {
+              return null; // tombstones are destroyed entries
+            }
+          } catch (ConcurrentCacheModificationException e) {
+            // this means the value attempted to overwrite a newer modification and was rejected
+            if (logger.isDebugEnabled()) {
+              logger.debug("caught concurrent modification attempt when applying {}", event);
+            }
+            notifyBridgeClients(event);
-          if (fromServer && (event.getRawNewValue() == Token.TOMBSTONE)) {
-            return null; // tombstones are destroyed entries
+          if (!getDataView().isDeferredStats()) {
+            getCachePerfStats().endPut(startPut, event.isOriginRemote());
-        } catch (ConcurrentCacheModificationException e) {
-          // this means the value attempted to overwrite a newer modification and was rejected
+        } catch (CacheWriterException cwe) {
-            logger.debug("caught concurrent modification attempt when applying {}", event);
+            logger.debug("findObjectInSystem: writer exception putting entry {}", event, cwe);
-          notifyBridgeClients(event);
-        if (!getDataView().isDeferredStats()) {
-          getCachePerfStats().endPut(startPut, event.isOriginRemote());
-        }
-      }
-      catch (CacheWriterException cwe) {
-        if (logger.isDebugEnabled()) {
-          logger.debug("findObjectInSystem: writer exception putting entry {}", event, cwe);
-        }
-      }
-      } finally {     
-          event.release();        
+      } finally {
+        event.release();
-  
+
-   * Returns true if the cache already has this key as an invalid entry
-   * with a version >= the one in the given event.  This is used in
-   * cache-miss processing to avoid overwriting the entry when it is
-   * not necessary, so that we avoid invoking cache listeners.
+   * Returns true if the cache already has this key as an invalid entry with a version >= the one in
+   * the given event. This is used in cache-miss processing to avoid overwriting the entry when it
+   * is not necessary, so that we avoid invoking cache listeners.
-        synchronized(entry) {
+        synchronized (entry) {
-      throws CacheWriterException, EntryNotFoundException, TimeoutException
-  {
+      throws CacheWriterException, EntryNotFoundException, TimeoutException {
-    if (writer != null && event.getOperation() != Operation.REMOVE && 
-        !event.inhibitAllNotifications()) {
+    if (writer != null && event.getOperation() != Operation.REMOVE
+        && !event.inhibitAllNotifications()) {
-      }
-      finally {
+      } finally {
-      throws CacheWriterException, EntryNotFoundException, TimeoutException
-  {
+      throws CacheWriterException, EntryNotFoundException, TimeoutException {
+
-  protected void serverPut(EntryEventImpl event,
-      boolean requireOldValue, Object expectedOldValue) {
+  protected void serverPut(EntryEventImpl event, boolean requireOldValue, Object expectedOldValue) {
-        boolean isCreate = event.isCreate(); 
-        Object result = mySRP.put(key, value, event.getDeltaBytes(), event,
-            op, requireOldValue, expectedOldValue,
-            callbackArg, isCreate);
+        boolean isCreate = event.isCreate();
+        Object result = mySRP.put(key, value, event.getDeltaBytes(), event, op, requireOldValue,
+            expectedOldValue, callbackArg, isCreate);
-              throw new EntryNotFoundException("entry existed for putIfAbsent"); // customers don't see this exception
+              throw new EntryNotFoundException("entry existed for putIfAbsent"); // customers don't
+                                                                                 // see this
+                                                                                 // exception
-              if ( !((Boolean)result).booleanValue() ) {
-                throw new EntryNotFoundException("entry found with wrong value"); // customers don't see this exception
+              if (!((Boolean) result).booleanValue()) {
+                throw new EntryNotFoundException("entry found with wrong value"); // customers don't
+                                                                                  // see this
+                                                                                  // exception
+   * 
-        Object result = mySRP.destroy(key, expectedOldValue, event.getOperation(), event, callbackArg);
+        Object result =
+            mySRP.destroy(key, expectedOldValue, event.getOperation(), event, callbackArg);
-          throw (EntryNotFoundException)result;
+          throw (EntryNotFoundException) result;
+        }
-  }
-  
+
-      throws CacheWriterException, TimeoutException
-  {
+      throws CacheWriterException, TimeoutException {
-      }
-      finally {
+      } finally {
-      throws CacheWriterException, TimeoutException
-  {
+      throws CacheWriterException, TimeoutException {
-      }
-      finally {
+      } finally {
-   * @param expectedOldValue 
+   * @param expectedOldValue
-   void cacheWriteBeforePut(EntryEventImpl event, Set netWriteRecipients,
-      CacheWriter localWriter, 
-      boolean requireOldValue,
-      Object expectedOldValue)
-      throws CacheWriterException, TimeoutException
-  {
+  void cacheWriteBeforePut(EntryEventImpl event, Set netWriteRecipients, CacheWriter localWriter,
+      boolean requireOldValue, Object expectedOldValue)
+      throws CacheWriterException, TimeoutException {
-    if (!(op == Operation.PUT_IF_ABSENT
-          || op == Operation.REPLACE) && (localWriter != null) && 
-          !((EntryEventImpl)event).inhibitAllNotifications()) {
+    if (!(op == Operation.PUT_IF_ABSENT || op == Operation.REPLACE) && (localWriter != null)
+        && !((EntryEventImpl) event).inhibitAllNotifications()) {
-        }
-        else {
+        } else {
-      }
-      finally {
+      } finally {
-  protected void validateArguments(Object key, Object value,
-      Object aCallbackArgument)
-  {
+  protected void validateArguments(Object key, Object value, Object aCallbackArgument) {
-  protected void validateKey(Object key)
-  {
+  protected void validateKey(Object key) {
-      throw new NullPointerException(LocalizedStrings.LocalRegion_KEY_CANNOT_BE_NULL.toLocalizedString());
+      throw new NullPointerException(
+          LocalizedStrings.LocalRegion_KEY_CANNOT_BE_NULL.toLocalizedString());
-        throw new ClassCastException(LocalizedStrings.LocalRegion_KEY_0_DOES_NOT_SATISFY_KEYCONSTRAINT_1.toLocalizedString(new Object[] {key.getClass().getName(), this.keyConstraint.getName()}));
+        throw new ClassCastException(
+            LocalizedStrings.LocalRegion_KEY_0_DOES_NOT_SATISFY_KEYCONSTRAINT_1.toLocalizedString(
+                new Object[] {key.getClass().getName(), this.keyConstraint.getName()}));
-   * Starting in 3.5, we don't check to see if the callback argument is
-   * <code>Serializable</code>. We instead rely on the actual serialization
-   * (which happens in-thread with the put) to tell us if there are any
-   * problems.
+   * Starting in 3.5, we don't check to see if the callback argument is <code>Serializable</code>.
+   * We instead rely on the actual serialization (which happens in-thread with the put) to tell us
+   * if there are any problems.
-  protected void validateCallbackArg(Object aCallbackArgument)
-  {
+  protected void validateCallbackArg(Object aCallbackArgument) {
-  private final boolean DO_EXPENSIVE_VALIDATIONS = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "DO_EXPENSIVE_VALIDATIONS");
+  private final boolean DO_EXPENSIVE_VALIDATIONS =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "DO_EXPENSIVE_VALIDATIONS");
-   * Starting in 3.5, we don't check to see if the value is
-   * <code>Serializable</code>. We instead rely on the actual serialization
-   * (which happens in-thread with the put) to tell us if there are any
-   * problems.
+   * Starting in 3.5, we don't check to see if the value is <code>Serializable</code>. We instead
+   * rely on the actual serialization (which happens in-thread with the put) to tell us if there are
+   * any problems.
-  protected void validateValue(Object p_value)
-  {
+  protected void validateValue(Object p_value) {
-            value = ((CachedDeserializable)value).getDeserializedValue(null, null);
+            value = ((CachedDeserializable) value).getDeserializedValue(null, null);
-          throw new ClassCastException(LocalizedStrings.LocalRegion_VALUE_0_DOES_NOT_SATISFY_VALUECONSTRAINT_1.toLocalizedString(new Object[] {value.getClass().getName(), this.valueConstraint.getName()}));
+          throw new ClassCastException(
+              LocalizedStrings.LocalRegion_VALUE_0_DOES_NOT_SATISFY_VALUECONSTRAINT_1
+                  .toLocalizedString(
+                      new Object[] {value.getClass().getName(), this.valueConstraint.getName()}));
+
-  
+
-    
-    //Fix for 45204 - don't include the tombstones in
-    //any of our entry count stats.
+
+    // Fix for 45204 - don't include the tombstones in
+    // any of our entry count stats.
-  
+
+
-  
-  public void scheduleTombstone(RegionEntry entry, VersionTag destroyedVersion, boolean reschedule) {
+
+  public void scheduleTombstone(RegionEntry entry, VersionTag destroyedVersion,
+      boolean reschedule) {
-//    Object sync = TombstoneService.DEBUG_TOMBSTONE_COUNT? TombstoneService.debugSync : new Object();
-//    lastUnscheduled.set(null);
-//    synchronized(sync) {
+    // Object sync = TombstoneService.DEBUG_TOMBSTONE_COUNT? TombstoneService.debugSync : new
+    // Object();
+    // lastUnscheduled.set(null);
+    // synchronized(sync) {
-//      if (entry instanceof AbstractRegionEntry) {
-//        AbstractRegionEntry are = (AbstractRegionEntry)entry;
-//        if (are.isTombstoneScheduled()) {
-//          log.severe(LocalizedStrings.DEBUG, "Scheduling a tombstone for an entry that is already a tombstone: " + entry, new Exception("stack trace"));
-//          throw new IllegalStateException("Attempt to schedule a tombstone for a destroyed entry that is already scheduled for expiration");
-//        }
-//        are.setTombstoneScheduled(true);
-//      }
-      if (logger.isTraceEnabled(LogMarker.TOMBSTONE_COUNT)) {
-        logger.trace(LogMarker.TOMBSTONE_COUNT, "{} tombstone for {} version={} count is {} entryMap size is {}", reschedule ? "rescheduling" : "scheduling",
-            entry.getKey(), entry.getVersionStamp().asVersionTag(), this.tombstoneCount.get(), this.entries.size()/*, new Exception("stack trace")*/);
-        // this can be useful for debugging tombstone count problems if there aren't a lot of concurrent threads
-//        if (TombstoneService.DEBUG_TOMBSTONE_COUNT && this.entries instanceof AbstractRegionMap) {
-//          ((AbstractRegionMap)this.entries).verifyTombstoneCount(tombstoneCount);
-//        }
-      }
-      getGemFireCache().getTombstoneService().scheduleTombstone(this, entry,
-          destroyedVersion);
-//    }
+    // if (entry instanceof AbstractRegionEntry) {
+    // AbstractRegionEntry are = (AbstractRegionEntry)entry;
+    // if (are.isTombstoneScheduled()) {
+    // log.severe(LocalizedStrings.DEBUG, "Scheduling a tombstone for an entry that is already a
+    // tombstone: " + entry, new Exception("stack trace"));
+    // throw new IllegalStateException("Attempt to schedule a tombstone for a destroyed entry that
+    // is already scheduled for expiration");
+    // }
+    // are.setTombstoneScheduled(true);
+    // }
+    if (logger.isTraceEnabled(LogMarker.TOMBSTONE_COUNT)) {
+      logger.trace(LogMarker.TOMBSTONE_COUNT,
+          "{} tombstone for {} version={} count is {} entryMap size is {}",
+          reschedule ? "rescheduling" : "scheduling", entry.getKey(),
+          entry.getVersionStamp().asVersionTag(), this.tombstoneCount.get(),
+          this.entries.size()/* , new Exception("stack trace") */);
+      // this can be useful for debugging tombstone count problems if there aren't a lot of
+      // concurrent threads
+      // if (TombstoneService.DEBUG_TOMBSTONE_COUNT && this.entries instanceof AbstractRegionMap) {
+      // ((AbstractRegionMap)this.entries).verifyTombstoneCount(tombstoneCount);
+      // }
+    }
+    getGemFireCache().getTombstoneService().scheduleTombstone(this, entry, destroyedVersion);
+    // }
-//  ThreadLocal<RegionEntry> lastUnscheduled = new ThreadLocal<RegionEntry>();
-//  ThreadLocal<Exception> lastUnscheduledPlace = new ThreadLocal<Exception>();
-  
+  // ThreadLocal<RegionEntry> lastUnscheduled = new ThreadLocal<RegionEntry>();
+  // ThreadLocal<Exception> lastUnscheduledPlace = new ThreadLocal<Exception>();
+
-  
+
-  
+
-      logger.trace(LogMarker.TOMBSTONE, "unscheduling tombstone for {} count is {} entryMap size is {}",
-          entry.getKey(), this.tombstoneCount.get(), this.entries.size()/*, new Exception("stack trace")*/);
+      logger.trace(LogMarker.TOMBSTONE,
+          "unscheduling tombstone for {} count is {} entryMap size is {}", entry.getKey(),
+          this.tombstoneCount.get(), this.entries.size()/* , new Exception("stack trace") */);
-    // changed.  It would be costly to iterate over the tombstone list for
+    // changed. It would be costly to iterate over the tombstone list for
-    //this.cache.getTombstoneService().unscheduleTombstone(entry);
+    // this.cache.getTombstoneService().unscheduleTombstone(entry);
-  
-  /** remove any tombstones from the given member that are <= the given version 
+
+  /**
+   * remove any tombstones from the given member that are <= the given version
+   * 
-  public void expireTombstones(Map<VersionSource, Long> regionGCVersions, EventID eventID, FilterInfo clientRouting) {
+  public void expireTombstones(Map<VersionSource, Long> regionGCVersions, EventID eventID,
+      FilterInfo clientRouting) {
-      keys = this.cache.getTombstoneService().gcTombstones(this, regionGCVersions, needsTombstoneGCKeysForClients(eventID, clientRouting));
+      keys = this.cache.getTombstoneService().gcTombstones(this, regionGCVersions,
+          needsTombstoneGCKeysForClients(eventID, clientRouting));
-  
+
-  
+
-  /** pass tombstone garbage-collection info to clients 
+
+  /**
+   * pass tombstone garbage-collection info to clients
+   * 
-  protected void notifyClientsOfTombstoneGC(Map<VersionSource, Long> regionGCVersions, Set<Object>keysRemoved, EventID eventID, FilterInfo routing) {
+  protected void notifyClientsOfTombstoneGC(Map<VersionSource, Long> regionGCVersions,
+      Set<Object> keysRemoved, EventID eventID, FilterInfo routing) {
-        RegionEventImpl regionEvent = new RegionEventImpl(this, Operation.REGION_DESTROY, null, true, getMyId());
+        RegionEventImpl regionEvent =
+            new RegionEventImpl(this, Operation.REGION_DESTROY, null, true, getMyId());
-        regionEvent.setLocalFilterInfo(clientRouting); 
-        ClientUpdateMessage clientMessage = ClientTombstoneMessage.gc(this, regionGCVersions,
-            eventID);
-        CacheClientNotifier.notifyClients(regionEvent, clientMessage); 
+        regionEvent.setLocalFilterInfo(clientRouting);
+        ClientUpdateMessage clientMessage =
+            ClientTombstoneMessage.gc(this, regionGCVersions, eventID);
+        CacheClientNotifier.notifyClients(regionEvent, clientMessage);
-  
-  
+
+
-      return this.concurrencyChecksEnabled && (entry.getVersionStamp().hasValidVersion() || this.dataPolicy.withReplication());
+      return this.concurrencyChecksEnabled
+          && (entry.getVersionStamp().hasValidVersion() || this.dataPolicy.withReplication());
-      Assert.assertTrue(this.entries.size() == 0, "RegionMap should be empty but was of size:"+this.entries.size());
+      Assert.assertTrue(this.entries.size() == 0,
+          "RegionMap should be empty but was of size:" + this.entries.size());
-  
+
-   * @throws IllegalArgumentException
-   *           if attrs is null
-   * @throws IllegalStateException
-   *           if attributes are invalid
+   * @throws IllegalArgumentException if attrs is null
+   * @throws IllegalStateException if attributes are invalid
-  protected void validateSubregionAttributes(RegionAttributes attrs)
-  {
+  protected void validateSubregionAttributes(RegionAttributes attrs) {
-      throw new IllegalArgumentException(LocalizedStrings.LocalRegion_REGION_ATTRIBUTES_MUST_NOT_BE_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.LocalRegion_REGION_ATTRIBUTES_MUST_NOT_BE_NULL.toLocalizedString());
-      throw new IllegalStateException(LocalizedStrings.LocalRegion_A_REGION_WITH_SCOPELOCAL_CAN_ONLY_HAVE_SUBREGIONS_WITH_SCOPELOCAL.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.LocalRegion_A_REGION_WITH_SCOPELOCAL_CAN_ONLY_HAVE_SUBREGIONS_WITH_SCOPELOCAL
+              .toLocalizedString());
-   * Returns the value of the entry with the given key as it is stored in the
-   * VM. This means that if the value is invalid, the invalid token will be
-   * returned. If the value is a {@link CachedDeserializable}received from
-   * another VM, that object will be returned. If the value does not reside in
-   * the VM because it has been overflowed to disk, <code>null</code> will be
-   * returned. This method is intended for testing.testing purposes only.
+   * Returns the value of the entry with the given key as it is stored in the VM. This means that if
+   * the value is invalid, the invalid token will be returned. If the value is a
+   * {@link CachedDeserializable}received from another VM, that object will be returned. If the
+   * value does not reside in the VM because it has been overflowed to disk, <code>null</code> will
+   * be returned. This method is intended for testing.testing purposes only.
-   * @throws EntryNotFoundException
-   *           No entry with <code>key</code> exists
+   * @throws EntryNotFoundException No entry with <code>key</code> exists
-  public Object getValueInVM(Object key) throws EntryNotFoundException
-  {
-    return basicGetValueInVM(key, true/*rememberRead*/);
+  public Object getValueInVM(Object key) throws EntryNotFoundException {
+    return basicGetValueInVM(key, true/* rememberRead */);
-  public Object getValueInVM(EntryEventImpl event)
-      throws EntryNotFoundException {
-    return basicGetValueInVM(event.getKey(), true/*rememberRead*/);
+  public Object getValueInVM(EntryEventImpl event) throws EntryNotFoundException {
+    return basicGetValueInVM(event.getKey(), true/* rememberRead */);
-  private Object basicGetValueInVM(Object key, boolean rememberRead)
-    throws EntryNotFoundException
-  {
+  private Object basicGetValueInVM(Object key, boolean rememberRead) throws EntryNotFoundException {
-    /**
-     * This is a test hook method used to find out what keys the current tx
-     * has read or written.
-     * @return an unmodifiable set of keys that have been read or written
-     * by the transaction on this thread.
-     * @throws IllegalStateException if not tx in progress
-     * @since GemFire 5.5
-     */
-    public Set testHookTXKeys() {
-      if (!isTX()) throw new IllegalStateException(LocalizedStrings.LocalRegion_TX_NOT_IN_PROGRESS.toLocalizedString());
-      TXStateProxyImpl tx = (TXStateProxyImpl) getTXState();
-      if (!tx.isRealDealLocal()) {
-        return Collections.EMPTY_SET;
-      }
-      TXRegionState txr = txReadRegion();
-      if (txr == null) {
-        return Collections.EMPTY_SET;
-      } else {
-        return txr.getEntryKeys();
-      }
+  /**
+   * This is a test hook method used to find out what keys the current tx has read or written.
+   * 
+   * @return an unmodifiable set of keys that have been read or written by the transaction on this
+   *         thread.
+   * @throws IllegalStateException if not tx in progress
+   * @since GemFire 5.5
+   */
+  public Set testHookTXKeys() {
+    if (!isTX())
+      throw new IllegalStateException(
+          LocalizedStrings.LocalRegion_TX_NOT_IN_PROGRESS.toLocalizedString());
+    TXStateProxyImpl tx = (TXStateProxyImpl) getTXState();
+    if (!tx.isRealDealLocal()) {
+      return Collections.EMPTY_SET;
+    TXRegionState txr = txReadRegion();
+    if (txr == null) {
+      return Collections.EMPTY_SET;
+    } else {
+      return txr.getEntryKeys();
+    }
+  }
-   * Returns the value of the entry with the given key as it is stored on disk.
-   * While the value may be read from disk, it is <b>not </b> stored into the
-   * entry in the VM. This method is intended for testing purposes only.
+   * Returns the value of the entry with the given key as it is stored on disk. While the value may
+   * be read from disk, it is <b>not </b> stored into the entry in the VM. This method is intended
+   * for testing purposes only.
-   * @throws EntryNotFoundException
-   *           No entry with <code>key</code> exists
-   * @throws IllegalStateException
-   *           If this region does not write to disk
+   * @throws EntryNotFoundException No entry with <code>key</code> exists
+   * @throws IllegalStateException If this region does not write to disk
-  public Object getValueOnDisk(Object key) throws EntryNotFoundException
-  {
+  public Object getValueOnDisk(Object key) throws EntryNotFoundException {
-   * @param 	key
-   * @return	Object
-   * @throws 	EntryNotFoundException
+   * @param key
+   * @return Object
+   * @throws EntryNotFoundException
-	RegionEntry re = this.entries.getEntry(key);
-	if (re == null) {
-		throw new EntryNotFoundException(key.toString());
-	}
-	return re.getValueInVMOrDiskWithoutFaultIn(this);
+    RegionEntry re = this.entries.getEntry(key);
+    if (re == null) {
+      throw new EntryNotFoundException(key.toString());
+    }
+    return re.getValueInVMOrDiskWithoutFaultIn(this);
-  
+
-   * Get the serialized bytes from disk. This method only looks for the value on
-   * the disk, ignoring heap data. This method is intended for testing purposes
-   * only. 
+   * Get the serialized bytes from disk. This method only looks for the value on the disk, ignoring
+   * heap data. This method is intended for testing purposes only.
-   * @return either a byte array, a CacheDeserializable with the serialized value,
-   * or null if the entry exists but no value data exists.
+   * @return either a byte array, a CacheDeserializable with the serialized value, or null if the
+   *         entry exists but no value data exists.
-  public Object getSerializedValueOnDisk(Object key) throws EntryNotFoundException
-  {
+  public Object getSerializedValueOnDisk(Object key) throws EntryNotFoundException {
-   * Returns the value of the entry with the given key as it is stored present
-   * in the buffer or disk. While the value may be read from disk or buffer,
-   * it is <b>not</b>
-   * stored into the entry in the VM.  This is different from  getValueonDisk in that
-   * it checks for a value both in asynch buffers ( subject to asynch mode
-   * enabled) as well as Disk
+   * Returns the value of the entry with the given key as it is stored present in the buffer or
+   * disk. While the value may be read from disk or buffer, it is <b>not</b> stored into the entry
+   * in the VM. This is different from getValueonDisk in that it checks for a value both in asynch
+   * buffers ( subject to asynch mode enabled) as well as Disk
-   * @throws EntryNotFoundException
-   *         No entry with <code>key</code> exists
-   * @throws IllegalStateException
-   *         If this region does not write to disk
+   * @throws EntryNotFoundException No entry with <code>key</code> exists
+   * @throws IllegalStateException If this region does not write to disk
-  public Object getValueOnDiskOrBuffer(Object key)
-  throws EntryNotFoundException {
+  public Object getValueOnDiskOrBuffer(Object key) throws EntryNotFoundException {
-  
+
-   * Does a get that attempts to not fault values in from disk or make the entry
-   * the most recent in the LRU.
+   * Does a get that attempts to not fault values in from disk or make the entry the most recent in
+   * the LRU.
+   * 
-  public Object getNoLRU(Object k, boolean adamant, boolean allowTombstone, boolean serializedFormOkay) {
+  public Object getNoLRU(Object k, boolean adamant, boolean allowTombstone,
+      boolean serializedFormOkay) {
-              o = ((CachedDeserializable)o).getDeserializedValue(this,
-                  getRegionEntry(k));
+              o = ((CachedDeserializable) o).getDeserializedValue(this, getRegionEntry(k));
-          o = ((CachedDeserializable)o).getDeserializedValue(this,
-              getRegionEntry(k));
+          o = ((CachedDeserializable) o).getDeserializedValue(this, getRegionEntry(k));
-   * Bump this number any time an incompatible change is made to the snapshot
-   * format.
+   * Bump this number any time an incompatible change is made to the snapshot format.
-  public void saveSnapshot(OutputStream outputStream) throws IOException
-  {
+  public void saveSnapshot(OutputStream outputStream) throws IOException {
-      throw new UnsupportedOperationException(LocalizedStrings.LocalRegion_REGIONS_WITH_DATAPOLICY_0_DO_NOT_SUPPORT_SAVESNAPSHOT.toLocalizedString(getDataPolicy()));
+      throw new UnsupportedOperationException(
+          LocalizedStrings.LocalRegion_REGIONS_WITH_DATAPOLICY_0_DO_NOT_SUPPORT_SAVESNAPSHOT
+              .toLocalizedString(getDataPolicy()));
-        Region.Entry entry = (Region.Entry)itr.next();
+        Region.Entry entry = (Region.Entry) itr.next();
-            LocalRegion.NonTXEntry lre = (LocalRegion.NonTXEntry)entry;
+            LocalRegion.NonTXEntry lre = (LocalRegion.NonTXEntry) entry;
-            }
-            else if (value == Token.LOCAL_INVALID) {
+            } else if (value == Token.LOCAL_INVALID) {
-            }
-            else {
+            } else {
-          }
-          else {
+          } else {
-        }
-        catch (EntryDestroyedException e) {
+        } catch (EntryDestroyedException e) {
-    }
-    finally {
+    } finally {
-  public void loadSnapshot4ConvertTo65(InputStream inputStream) throws CacheWriterException, TimeoutException, ClassNotFoundException, IOException {
+  public void loadSnapshot4ConvertTo65(InputStream inputStream)
+      throws CacheWriterException, TimeoutException, ClassNotFoundException, IOException {
-  
+
-      throws CacheWriterException, TimeoutException, ClassNotFoundException,
-      IOException
-  {
+      throws CacheWriterException, TimeoutException, ClassNotFoundException, IOException {
-      throw new UnsupportedOperationException(LocalizedStrings.LocalRegion_REGIONS_WITH_DATAPOLICY_0_DO_NOT_SUPPORT_LOADSNAPSHOT.toLocalizedString(getDataPolicy()));
+      throw new UnsupportedOperationException(
+          LocalizedStrings.LocalRegion_REGIONS_WITH_DATAPOLICY_0_DO_NOT_SUPPORT_LOADSNAPSHOT
+              .toLocalizedString(getDataPolicy()));
-      throw new NullPointerException(LocalizedStrings.LocalRegion_INPUTSTREAM_MUST_NOT_BE_NULL.toLocalizedString());
+      throw new NullPointerException(
+          LocalizedStrings.LocalRegion_INPUTSTREAM_MUST_NOT_BE_NULL.toLocalizedString());
-    RegionEventImpl event = new RegionEventImpl(this,
-        Operation.REGION_LOAD_SNAPSHOT, null, false, getMyId(),
-        generateEventID()/* generate EventID */);
+    RegionEventImpl event = new RegionEventImpl(this, Operation.REGION_LOAD_SNAPSHOT, null, false,
+        getMyId(), generateEventID()/* generate EventID */);
-  public void registerInterest(Object key)
-  {
+  public void registerInterest(Object key) {
-  
-  public void registerInterest(Object key, boolean isDurable,
-      boolean receiveValues)
-  {
+
+  public void registerInterest(Object key, boolean isDurable, boolean receiveValues) {
-      if(logger.isDebugEnabled()) {
+      if (logger.isDebugEnabled()) {
-      try { Thread.sleep(20000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); return; }
-      if(logger.isDebugEnabled()) {
+      try {
+        Thread.sleep(20000);
+      } catch (InterruptedException e) {
+        Thread.currentThread().interrupt();
+        return;
+      }
+      if (logger.isDebugEnabled()) {
-      Assert.assertTrue(this.riCnt >= 0 , "register interest count can not be < 0 ");
+      Assert.assertTrue(this.riCnt >= 0, "register interest count can not be < 0 ");
-  private void processSingleInterest(Object key, int interestType,
-      InterestResultPolicy pol, boolean isDurable,
-      boolean receiveUpdatesAsInvalidates)
-  {
+  private void processSingleInterest(Object key, int interestType, InterestResultPolicy pol,
+      boolean isDurable, boolean receiveUpdatesAsInvalidates) {
-      throw new UnsupportedOperationException(LocalizedStrings.LocalRegion_INTEREST_REGISTRATION_REQUIRES_A_POOL.toLocalizedString());
+      throw new UnsupportedOperationException(
+          LocalizedStrings.LocalRegion_INTEREST_REGISTRATION_REQUIRES_A_POOL.toLocalizedString());
-      throw new IllegalStateException(LocalizedStrings.LocalRegion_DURABLE_FLAG_ONLY_APPLICABLE_FOR_DURABLE_CLIENTS.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.LocalRegion_DURABLE_FLAG_ONLY_APPLICABLE_FOR_DURABLE_CLIENTS
+              .toLocalizedString());
-      throw new UnsupportedOperationException(LocalizedStrings.LocalRegion_INTEREST_REGISTRATION_NOT_SUPPORTED_ON_REPLICATED_REGIONS.toLocalizedString());
+      throw new UnsupportedOperationException(
+          LocalizedStrings.LocalRegion_INTEREST_REGISTRATION_NOT_SUPPORTED_ON_REPLICATED_REGIONS
+              .toLocalizedString());
-      throw new IllegalArgumentException(LocalizedStrings.LocalRegion_INTEREST_KEY_MUST_NOT_BE_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.LocalRegion_INTEREST_KEY_MUST_NOT_BE_NULL.toLocalizedString());
-    //     because it isn't interested in that key.
+    // because it isn't interested in that key.
-    
+
-      }// Test Code Ends
+      } // Test Code Ends
-      case InterestType.FILTER_CLASS:
-        serverKeys = proxy.registerInterest(key, interestType, pol,
-              isDurable, receiveUpdatesAsInvalidates, regionDataPolicy);
-        break;
-      case InterestType.KEY:
-        
-        if (key instanceof String && key.equals("ALL_KEYS")) {
-          
-          serverKeys = proxy.registerInterest(".*",
-                                              InterestType.REGULAR_EXPRESSION,
-                                              pol,
-                                              isDurable,
-                                              receiveUpdatesAsInvalidates,
-                                              regionDataPolicy);
-        }
-        else {
-          if (key instanceof List) {
-            serverKeys = proxy.registerInterestList((List)key, pol,
-                  isDurable, receiveUpdatesAsInvalidates, regionDataPolicy);
+        case InterestType.FILTER_CLASS:
+          serverKeys = proxy.registerInterest(key, interestType, pol, isDurable,
+              receiveUpdatesAsInvalidates, regionDataPolicy);
+          break;
+        case InterestType.KEY:
+
+          if (key instanceof String && key.equals("ALL_KEYS")) {
+
+            serverKeys = proxy.registerInterest(".*", InterestType.REGULAR_EXPRESSION, pol,
+                isDurable, receiveUpdatesAsInvalidates, regionDataPolicy);
-            serverKeys = proxy.registerInterest(key, InterestType.KEY, pol,
-                  isDurable, receiveUpdatesAsInvalidates, regionDataPolicy);
-          }
-        }
-        break;
-      case InterestType.OQL_QUERY:
-        serverKeys = proxy.registerInterest(key, InterestType.OQL_QUERY, pol,
-              isDurable, receiveUpdatesAsInvalidates, regionDataPolicy);
-        break;
-      case InterestType.REGULAR_EXPRESSION: {
-        String regex = (String)key;
-        // compile regex throws java.util.regex.PatternSyntaxException if invalid
-        // we do this before sending to the server because it's more efficient
-        // and the client is not receiving exception messages properly
-        Pattern.compile(regex);
-        serverKeys = proxy.registerInterest(regex,
-                                            InterestType.REGULAR_EXPRESSION,
-                                            pol,
-                                            isDurable,
-                                            receiveUpdatesAsInvalidates,
-                                            regionDataPolicy);
-        break;
-      }
-      default:
-        throw new InternalGemFireError(LocalizedStrings.LocalRegion_UNKNOWN_INTEREST_TYPE.toLocalizedString());
-    }
-    boolean finishedRefresh = false;
-    try {
-      refreshEntriesFromServerKeys(null, serverKeys, pol);
-      
-      finishedRefresh = true;      
-    }
-    finally {
-      if (!finishedRefresh) {
-        // unregister before throwing the exception caused by the refresh
-        switch (interestType) {
-          case InterestType.FILTER_CLASS:
-            proxy.unregisterInterest(key, interestType, false, false);
-            break;
-          case InterestType.KEY:
-            if (key instanceof String && key.equals("ALL_KEYS")) {
-              proxy.unregisterInterest(".*", InterestType.REGULAR_EXPRESSION, false, false);
-            }
-            else if (key instanceof List) {
-              proxy.unregisterInterestList((List)key, false, false);
+            if (key instanceof List) {
+              serverKeys = proxy.registerInterestList((List) key, pol, isDurable,
+                  receiveUpdatesAsInvalidates, regionDataPolicy);
-              proxy.unregisterInterest(key, InterestType.KEY, false, false);
+              serverKeys = proxy.registerInterest(key, InterestType.KEY, pol, isDurable,
+                  receiveUpdatesAsInvalidates, regionDataPolicy);
-            break;
-          case InterestType.OQL_QUERY:
-            proxy.unregisterInterest(key, InterestType.OQL_QUERY, false, false);
-            break;
-          case InterestType.REGULAR_EXPRESSION: {
-            proxy.unregisterInterest(key, InterestType.REGULAR_EXPRESSION, false, false);
-            break;
-          default:
-            throw new InternalGemFireError(LocalizedStrings.LocalRegion_UNKNOWN_INTEREST_TYPE.toLocalizedString());
+          break;
+        case InterestType.OQL_QUERY:
+          serverKeys = proxy.registerInterest(key, InterestType.OQL_QUERY, pol, isDurable,
+              receiveUpdatesAsInvalidates, regionDataPolicy);
+          break;
+        case InterestType.REGULAR_EXPRESSION: {
+          String regex = (String) key;
+          // compile regex throws java.util.regex.PatternSyntaxException if invalid
+          // we do this before sending to the server because it's more efficient
+          // and the client is not receiving exception messages properly
+          Pattern.compile(regex);
+          serverKeys = proxy.registerInterest(regex, InterestType.REGULAR_EXPRESSION, pol,
+              isDurable, receiveUpdatesAsInvalidates, regionDataPolicy);
+          break;
+        }
+        default:
+          throw new InternalGemFireError(
+              LocalizedStrings.LocalRegion_UNKNOWN_INTEREST_TYPE.toLocalizedString());
+      }
+      boolean finishedRefresh = false;
+      try {
+        refreshEntriesFromServerKeys(null, serverKeys, pol);
+
+        finishedRefresh = true;
+      } finally {
+        if (!finishedRefresh) {
+          // unregister before throwing the exception caused by the refresh
+          switch (interestType) {
+            case InterestType.FILTER_CLASS:
+              proxy.unregisterInterest(key, interestType, false, false);
+              break;
+            case InterestType.KEY:
+              if (key instanceof String && key.equals("ALL_KEYS")) {
+                proxy.unregisterInterest(".*", InterestType.REGULAR_EXPRESSION, false, false);
+              } else if (key instanceof List) {
+                proxy.unregisterInterestList((List) key, false, false);
+              } else {
+                proxy.unregisterInterest(key, InterestType.KEY, false, false);
+              }
+              break;
+            case InterestType.OQL_QUERY:
+              proxy.unregisterInterest(key, InterestType.OQL_QUERY, false, false);
+              break;
+            case InterestType.REGULAR_EXPRESSION: {
+              proxy.unregisterInterest(key, InterestType.REGULAR_EXPRESSION, false, false);
+              break;
+            }
+            default:
+              throw new InternalGemFireError(
+                  LocalizedStrings.LocalRegion_UNKNOWN_INTEREST_TYPE.toLocalizedString());
-    }
-    finally {
+    } finally {
-  public void registerInterest(Object key, InterestResultPolicy policy)
-  {
+  public void registerInterest(Object key, InterestResultPolicy policy) {
-  public void registerInterest(Object key, InterestResultPolicy policy,
-      boolean isDurable) {
+
+  public void registerInterest(Object key, InterestResultPolicy policy, boolean isDurable) {
-  public void registerInterest(Object key, InterestResultPolicy policy,
-      boolean isDurable, boolean receiveValues)
-  {
+
+  public void registerInterest(Object key, InterestResultPolicy policy, boolean isDurable,
+      boolean receiveValues) {
-  public void registerInterestRegex(String regex)
-  {
+  public void registerInterestRegex(String regex) {
-  public void registerInterestRegex(String regex, boolean isDurable,
-      boolean receiveValues)
-  {
+
+  public void registerInterestRegex(String regex, boolean isDurable, boolean receiveValues) {
-  public void registerInterestRegex(String regex, InterestResultPolicy policy)
-  {
+
+  public void registerInterestRegex(String regex, InterestResultPolicy policy) {
-  public void registerInterestRegex(String regex, InterestResultPolicy policy,
-      boolean isDurable) {
+  public void registerInterestRegex(String regex, InterestResultPolicy policy, boolean isDurable) {
-  public void registerInterestRegex(String regex, InterestResultPolicy policy,
-      boolean isDurable, boolean receiveValues)
-  {
-    processSingleInterest(regex, InterestType.REGULAR_EXPRESSION, policy,
-        isDurable, !receiveValues);
+
+  public void registerInterestRegex(String regex, InterestResultPolicy policy, boolean isDurable,
+      boolean receiveValues) {
+    processSingleInterest(regex, InterestType.REGULAR_EXPRESSION, policy, isDurable,
+        !receiveValues);
-  public void registerInterestFilter(String className)
-  {
+
+  public void registerInterestFilter(String className) {
+
-  public void registerInterestFilter(String className, boolean isDurable,
-      boolean receiveValues)
-  {
-    processSingleInterest(className, InterestType.FILTER_CLASS,
-        InterestResultPolicy.DEFAULT, isDurable, !receiveValues);
+
+  public void registerInterestFilter(String className, boolean isDurable, boolean receiveValues) {
+    processSingleInterest(className, InterestType.FILTER_CLASS, InterestResultPolicy.DEFAULT,
+        isDurable, !receiveValues);
-  public void registerInterestOQL(String query)
-  {
+
+  public void registerInterestOQL(String query) {
+
-  public void registerInterestOQL(String query, boolean isDurable,
-      boolean receiveValues)
-  {
-    processSingleInterest(query, InterestType.OQL_QUERY,
-        InterestResultPolicy.DEFAULT, isDurable, !receiveValues);
+
+  public void registerInterestOQL(String query, boolean isDurable, boolean receiveValues) {
+    processSingleInterest(query, InterestType.OQL_QUERY, InterestResultPolicy.DEFAULT, isDurable,
+        !receiveValues);
-  public void unregisterInterest(Object key)
-  {
+  public void unregisterInterest(Object key) {
-      }
-      else if (key instanceof List) {
-        proxy.unregisterInterestList((List)key, false, false);
-      }
-      else {
+      } else if (key instanceof List) {
+        proxy.unregisterInterestList((List) key, false, false);
+      } else {
-    }
-    else {
-      throw new UnsupportedOperationException(LocalizedStrings.LocalRegion_INTEREST_UNREGISTRATION_REQUIRES_A_POOL.toLocalizedString());
+    } else {
+      throw new UnsupportedOperationException(
+          LocalizedStrings.LocalRegion_INTEREST_UNREGISTRATION_REQUIRES_A_POOL.toLocalizedString());
-  public void unregisterInterestRegex(String regex)
-  {
+  public void unregisterInterestRegex(String regex) {
-    }
-    else {
-      throw new UnsupportedOperationException(LocalizedStrings.LocalRegion_INTEREST_UNREGISTRATION_REQUIRES_A_POOL.toLocalizedString());
+    } else {
+      throw new UnsupportedOperationException(
+          LocalizedStrings.LocalRegion_INTEREST_UNREGISTRATION_REQUIRES_A_POOL.toLocalizedString());
-    }
-    else {
-      throw new UnsupportedOperationException(LocalizedStrings.LocalRegion_INTEREST_UNREGISTRATION_REQUIRES_A_POOL.toLocalizedString());
+    } else {
+      throw new UnsupportedOperationException(
+          LocalizedStrings.LocalRegion_INTEREST_UNREGISTRATION_REQUIRES_A_POOL.toLocalizedString());
-  public void unregisterInterestOQL(String query)
-  {
+  public void unregisterInterestOQL(String query) {
-    }
-    else {
-      throw new UnsupportedOperationException(LocalizedStrings.LocalRegion_INTEREST_UNREGISTRATION_REQUIRES_A_POOL.toLocalizedString());
+    } else {
+      throw new UnsupportedOperationException(
+          LocalizedStrings.LocalRegion_INTEREST_UNREGISTRATION_REQUIRES_A_POOL.toLocalizedString());
-  public List getInterestList()
-  {
+  public List getInterestList() {
-    }
-    else {
-      throw new UnsupportedOperationException(LocalizedStrings.LocalRegion_INTEREST_UNREGISTRATION_REQUIRES_A_POOL.toLocalizedString());
+    } else {
+      throw new UnsupportedOperationException(
+          LocalizedStrings.LocalRegion_INTEREST_UNREGISTRATION_REQUIRES_A_POOL.toLocalizedString());
-  /** finds the keys in this region using the given interestType and argument.  Currently only
+  /**
+   * finds the keys in this region using the given interestType and argument. Currently only
-  public Set getKeysWithInterest(int interestType, Object interestArg, boolean allowTombstones)
-  {
+  public Set getKeysWithInterest(int interestType, Object interestArg, boolean allowTombstones) {
-      }
-      else {
+      } else {
-          throw new IllegalArgumentException(LocalizedStrings.AbstractRegion_REGULAR_EXPRESSION_ARGUMENT_WAS_NOT_A_STRING.toLocalizedString());
+          throw new IllegalArgumentException(
+              LocalizedStrings.AbstractRegion_REGULAR_EXPRESSION_ARGUMENT_WAS_NOT_A_STRING
+                  .toLocalizedString());
-        Pattern keyPattern = Pattern.compile((String)interestArg);
+        Pattern keyPattern = Pattern.compile((String) interestArg);
-          if(!(entryKey instanceof String)) {
-            //key is not a String, cannot apply regex to this entry
+          if (!(entryKey instanceof String)) {
+            // key is not a String, cannot apply regex to this entry
-          if(!keyPattern.matcher((String) entryKey).matches()) {
-            //key does not match the regex, this entry should not be returned.
+          if (!keyPattern.matcher((String) entryKey).matches()) {
+            // key does not match the regex, this entry should not be returned.
-    }
-    else if (interestType == InterestType.KEY) {
+    } else if (interestType == InterestType.KEY) {
-        ret = new HashSet();  // TODO optimize initial size
-        List keyList = (List)interestArg;
+        ret = new HashSet(); // TODO optimize initial size
+        List keyList = (List) interestArg;
-      }
-      else {
+      } else {
-        if (this.containsKey(interestArg) || (allowTombstones && this.containsTombstone(interestArg))) {
+        if (this.containsKey(interestArg)
+            || (allowTombstones && this.containsTombstone(interestArg))) {
-    }
-    else if (interestType == InterestType.FILTER_CLASS) {
-      throw new UnsupportedOperationException(LocalizedStrings.AbstractRegion_INTERESTTYPEFILTER_CLASS_NOT_YET_SUPPORTED.toLocalizedString());
-    }
-    else if (interestType == InterestType.OQL_QUERY) {
-      throw new UnsupportedOperationException(LocalizedStrings.AbstractRegion_INTERESTTYPEOQL_QUERY_NOT_YET_SUPPORTED.toLocalizedString());
-    }
-    else {
-      throw new IllegalArgumentException(LocalizedStrings.AbstractRegion_UNSUPPORTED_INTEREST_TYPE_0.toLocalizedString(Integer.valueOf(interestType)));
+    } else if (interestType == InterestType.FILTER_CLASS) {
+      throw new UnsupportedOperationException(
+          LocalizedStrings.AbstractRegion_INTERESTTYPEFILTER_CLASS_NOT_YET_SUPPORTED
+              .toLocalizedString());
+    } else if (interestType == InterestType.OQL_QUERY) {
+      throw new UnsupportedOperationException(
+          LocalizedStrings.AbstractRegion_INTERESTTYPEOQL_QUERY_NOT_YET_SUPPORTED
+              .toLocalizedString());
+    } else {
+      throw new IllegalArgumentException(LocalizedStrings.AbstractRegion_UNSUPPORTED_INTEREST_TYPE_0
+          .toLocalizedString(Integer.valueOf(interestType)));
-  public List getInterestListRegex()
-  {
+  public List getInterestListRegex() {
-    }
-    else {
-      throw new UnsupportedOperationException( LocalizedStrings.LocalRegion_INTEREST_LIST_RETRIEVAL_REQUIRES_A_POOL.toLocalizedString());
+    } else {
+      throw new UnsupportedOperationException(
+          LocalizedStrings.LocalRegion_INTEREST_LIST_RETRIEVAL_REQUIRES_A_POOL.toLocalizedString());
-  public List getInterestListFilters()
-  {
+  public List getInterestListFilters() {
-    }
-    else {
-      throw new UnsupportedOperationException( LocalizedStrings.LocalRegion_INTEREST_LIST_RETRIEVAL_REQUIRES_A_POOL.toLocalizedString());
+    } else {
+      throw new UnsupportedOperationException(
+          LocalizedStrings.LocalRegion_INTEREST_LIST_RETRIEVAL_REQUIRES_A_POOL.toLocalizedString());
-  public List getInterestListOQL()
-  {
+  public List getInterestListOQL() {
-    }
-    else {
-      throw new UnsupportedOperationException( LocalizedStrings.LocalRegion_INTEREST_LIST_RETRIEVAL_REQUIRES_A_POOL.toLocalizedString());
+    } else {
+      throw new UnsupportedOperationException(
+          LocalizedStrings.LocalRegion_INTEREST_LIST_RETRIEVAL_REQUIRES_A_POOL.toLocalizedString());
-      throw new UnsupportedOperationException(LocalizedStrings.LocalRegion_SERVER_KEYSET_REQUIRES_A_POOL.toLocalizedString());
+      throw new UnsupportedOperationException(
+          LocalizedStrings.LocalRegion_SERVER_KEYSET_REQUIRES_A_POOL.toLocalizedString());
-      throw new UnsupportedOperationException(LocalizedStrings.LocalRegion_SERVER_KEYSET_REQUIRES_A_POOL.toLocalizedString());
+      throw new UnsupportedOperationException(
+          LocalizedStrings.LocalRegion_SERVER_KEYSET_REQUIRES_A_POOL.toLocalizedString());
-  protected void localDestroyNoCallbacks(Object key)
-  {
-    if(logger.isDebugEnabled()) {
+  protected void localDestroyNoCallbacks(Object key) {
+    if (logger.isDebugEnabled()) {
-    @Released EntryEventImpl event = EntryEventImpl.create(this, Operation.LOCAL_DESTROY,
-        key, false, getMyId(), false /* generateCallbacks */, true);
+    @Released
+    EntryEventImpl event = EntryEventImpl.create(this, Operation.LOCAL_DESTROY, key, false,
+        getMyId(), false /* generateCallbacks */, true);
-      basicDestroy(event,
-                   false,
-                   null); // expectedOldValue
-    }
-    catch (CacheWriterException e) {
+      basicDestroy(event, false, null); // expectedOldValue
+    } catch (CacheWriterException e) {
-      throw new Error(LocalizedStrings.LocalRegion_CACHE_WRITER_SHOULD_NOT_HAVE_BEEN_CALLED_FOR_LOCALDESTROY.toLocalizedString(), e);
-    }
-    catch (TimeoutException e) {
+      throw new Error(
+          LocalizedStrings.LocalRegion_CACHE_WRITER_SHOULD_NOT_HAVE_BEEN_CALLED_FOR_LOCALDESTROY
+              .toLocalizedString(),
+          e);
+    } catch (TimeoutException e) {
-      throw new Error(LocalizedStrings.LocalRegion_NO_DISTRIBUTED_LOCK_SHOULD_HAVE_BEEN_ATTEMPTED_FOR_LOCALDESTROY.toLocalizedString(), e);
-    }
-    catch (EntryNotFoundException e) {
+      throw new Error(
+          LocalizedStrings.LocalRegion_NO_DISTRIBUTED_LOCK_SHOULD_HAVE_BEEN_ATTEMPTED_FOR_LOCALDESTROY
+              .toLocalizedString(),
+          e);
+    } catch (EntryNotFoundException e) {
-   * @param keys
-   *          the list of arrays of keys to invalidate
+   * @param keys the list of arrays of keys to invalidate
-  private void clearViaList(List keys)
-  {
+  private void clearViaList(List keys) {
-      Region.Entry entry = (Region.Entry)it.next();
+      Region.Entry entry = (Region.Entry) it.next();
-      }
-      catch (EntryDestroyedException ignore) {
+      } catch (EntryDestroyedException ignore) {
-   * @param key
-   *          the regular expression to match on
+   * @param key the regular expression to match on
-  private void clearViaRegEx(String key)
-  {
+  private void clearViaRegEx(String key) {
-      Region.Entry entry = (Region.Entry)it.next();
+      Region.Entry entry = (Region.Entry) it.next();
-        if (!keyPattern.matcher((String)entryKey).matches()) {
-          //key does not match the regex, this entry should not be returned.
+        if (!keyPattern.matcher((String) entryKey).matches()) {
+          // key does not match the regex, this entry should not be returned.
-      }
-      catch (EntryDestroyedException ignore) {
+      } catch (EntryDestroyedException ignore) {
-   * @param key
-   *          the regular expression to match on
+   * @param key the regular expression to match on
-  private void clearViaFilterClass(String key)
-  {
+  private void clearViaFilterClass(String key) {
-      filter = (InterestFilter)filterClass.newInstance();
-    }
-    catch (ClassNotFoundException cnfe) {
-      throw new RuntimeException(LocalizedStrings.LocalRegion_CLASS_0_NOT_FOUND_IN_CLASSPATH.toLocalizedString(key), cnfe);
-    }
-    catch (Exception e) {
-      throw new RuntimeException(LocalizedStrings.LocalRegion_CLASS_0_COULD_NOT_BE_INSTANTIATED.toLocalizedString(key), e);
+      filter = (InterestFilter) filterClass.newInstance();
+    } catch (ClassNotFoundException cnfe) {
+      throw new RuntimeException(
+          LocalizedStrings.LocalRegion_CLASS_0_NOT_FOUND_IN_CLASSPATH.toLocalizedString(key), cnfe);
+    } catch (Exception e) {
+      throw new RuntimeException(
+          LocalizedStrings.LocalRegion_CLASS_0_COULD_NOT_BE_INSTANTIATED.toLocalizedString(key), e);
-      Region.Entry entry = (Region.Entry)it.next();
+      Region.Entry entry = (Region.Entry) it.next();
-          //the filter does not want to know about this entry, so skip it.
+          // the filter does not want to know about this entry, so skip it.
-      }
-      catch (EntryDestroyedException ignore) {
+      } catch (EntryDestroyedException ignore) {
-  private void clearViaQuery(String query)
-  {
-    throw new InternalGemFireError(LocalizedStrings.LocalRegion_NOT_YET_SUPPORTED.toLocalizedString());
+  private void clearViaQuery(String query) {
+    throw new InternalGemFireError(
+        LocalizedStrings.LocalRegion_NOT_YET_SUPPORTED.toLocalizedString());
+   * 
-      InterestResultPolicy pol)
-  {
+      InterestResultPolicy pol) {
-    if(logger.isDebugEnabled()) {
+    if (logger.isDebugEnabled()) {
-      ArrayList keysList = (ArrayList)it.next();
+      ArrayList keysList = (ArrayList) it.next();
-      if(EntryLogger.isEnabled()) {
-        if(con != null) {
+      if (EntryLogger.isEnabled()) {
+        if (con != null) {
-          if(endpoint != null) {
+          if (endpoint != null) {
-        for (Iterator it2 = keysList.iterator(); it2.hasNext();) {
-          Object currentKey = it2.next();
-          // Dont apply riResponse if the entry was destroyed when
-          // ri is in progress
-          if (currentKey == null || getImageState().hasDestroyedEntry(currentKey)){
-            list.remove(currentKey);
+          for (Iterator it2 = keysList.iterator(); it2.hasNext();) {
+            Object currentKey = it2.next();
+            // Dont apply riResponse if the entry was destroyed when
+            // ri is in progress
+            if (currentKey == null || getImageState().hasDestroyedEntry(currentKey)) {
+              list.remove(currentKey);
+            }
-        }
-              entries.initialImagePut(currentKey, 0, Token.LOCAL_INVALID, false,
-                  false, null, null, false);
-              
+              entries.initialImagePut(currentKey, 0, Token.LOCAL_INVALID, false, false, null, null,
+                  false);
+
-        }
-        else if(!list.isEmpty()) {
+        } else if (!list.isEmpty()) {
-//          for (Iterator it2 = list.iterator(); it2.hasNext();) {
-//            Object currentKey = ((Entry)it2.next()).getKey();
-//            localDestroyNoCallbacks(currentKey);
-//          }
-          VersionedObjectList values = (VersionedObjectList)list.get(0); // proxy.getAllOnPrimaryForRegisterInterest(con, list);
-          if(logger.isDebugEnabled()) {
+          // for (Iterator it2 = list.iterator(); it2.hasNext();) {
+          // Object currentKey = ((Entry)it2.next()).getKey();
+          // localDestroyNoCallbacks(currentKey);
+          // }
+          VersionedObjectList values = (VersionedObjectList) list.get(0); // proxy.getAllOnPrimaryForRegisterInterest(con,
+                                                                          // list);
+          if (logger.isDebugEnabled()) {
-            boolean isTombstone = this.concurrencyChecksEnabled
-                                  && entry.isKeyNotOnServer()
-                                  && (entry.getVersionTag() != null);
+            boolean isTombstone = this.concurrencyChecksEnabled && entry.isKeyNotOnServer()
+                && (entry.getVersionTag() != null);
-              logger.warn(LocalizedMessage.create(LocalizedStrings.LocalRegion_CAUGHT_THE_FOLLOWING_EXCEPTION_FOR_KEY_0_WHILE_PERFORMING_A_REMOTE_GETALL,
-                      currentKey), (Throwable)val);
+              logger.warn(LocalizedMessage.create(
+                  LocalizedStrings.LocalRegion_CAUGHT_THE_FOLLOWING_EXCEPTION_FOR_KEY_0_WHILE_PERFORMING_A_REMOTE_GETALL,
+                  currentKey), (Throwable) val);
-              if(logger.isDebugEnabled()) {
+              if (logger.isDebugEnabled()) {
-            
-            if(val instanceof byte[] && !isBytes) {
+
+            if (val instanceof byte[] && !isBytes) {
-            
+
-            }
-            else {
+            } else {
-                entries.initialImagePut(currentKey, 0, Token.LOCAL_INVALID,
-                      false,false, tag, null, false);
-              }
-              else {
+                entries.initialImagePut(currentKey, 0, Token.LOCAL_INVALID, false, false, tag, null,
+                    false);
+              } else {
-                    if (re.isDestroyedOrRemovedButNotTombstone()) { 
+                    if (re.isDestroyedOrRemovedButNotTombstone()) {
-      }
-      catch (DiskAccessException dae) {
+      } catch (DiskAccessException dae) {
-  private void logKeys(List serverKeys, InterestResultPolicy pol)
-  {
+  private void logKeys(List serverKeys, InterestResultPolicy pol) {
-      ArrayList keysList = (ArrayList)it.next();
+      ArrayList keysList = (ArrayList) it.next();
-            Set keys = ((VersionedObjectList)key).keySet();
+            Set keys = ((VersionedObjectList) key).keySet();
-    if(logger.isDebugEnabled()) {
-      logger.debug("{} refreshEntriesFromServerKeys count={} policy={}\n{}", this, totalKeys, pol, buffer);
+    if (logger.isDebugEnabled()) {
+      logger.debug("{} refreshEntriesFromServerKeys count={} policy={}\n{}", this, totalKeys, pol,
+          buffer);
+
-   * @param key
-   *          the interest key
-   * @param interestType
-   *          the interest type from {@link InterestType}
-   * @param pol
-   *          the policy from {@link InterestResultPolicy}
+   * @param key the interest key
+   * @param interestType the interest type from {@link InterestType}
+   * @param pol the policy from {@link InterestResultPolicy}
-  public void clearKeysOfInterest(Object key, int interestType,
-      InterestResultPolicy pol)
-  {
+  public void clearKeysOfInterest(Object key, int interestType, InterestResultPolicy pol) {
-    case InterestType.FILTER_CLASS:
-      clearViaFilterClass((String)key);
-      break;
-    case InterestType.KEY:
-      if (key instanceof String && key.equals("ALL_KEYS"))
-        clearViaRegEx(".*");
-      else if (key instanceof List)
-        clearViaList((List)key);
-      else
-        localDestroyNoCallbacks(key);
-      break;
-    case InterestType.OQL_QUERY:
-      clearViaQuery((String)key);
-      break;
-    case InterestType.REGULAR_EXPRESSION:
-      clearViaRegEx((String)key);
-      break;
-    default:
-      throw new InternalGemFireError(LocalizedStrings.LocalRegion_UNKNOWN_INTEREST_TYPE.toLocalizedString());
+      case InterestType.FILTER_CLASS:
+        clearViaFilterClass((String) key);
+        break;
+      case InterestType.KEY:
+        if (key instanceof String && key.equals("ALL_KEYS"))
+          clearViaRegEx(".*");
+        else if (key instanceof List)
+          clearViaList((List) key);
+        else
+          localDestroyNoCallbacks(key);
+        break;
+      case InterestType.OQL_QUERY:
+        clearViaQuery((String) key);
+        break;
+      case InterestType.REGULAR_EXPRESSION:
+        clearViaRegEx((String) key);
+        break;
+      default:
+        throw new InternalGemFireError(
+            LocalizedStrings.LocalRegion_UNKNOWN_INTEREST_TYPE.toLocalizedString());
-   * Destroys and recreates this region. If this is triggered by loadSnapshot
-   * inputStream will be supplied. If this is triggered by LossAction of
-   * reinitialize then inputStream will be null, and the region will go through
-   * regular GetInitalImage if it is a mirrored replicate.
+   * Destroys and recreates this region. If this is triggered by loadSnapshot inputStream will be
+   * supplied. If this is triggered by LossAction of reinitialize then inputStream will be null, and
+   * the region will go through regular GetInitalImage if it is a mirrored replicate.
-      throws TimeoutException, IOException, ClassNotFoundException
-  {
+      throws TimeoutException, IOException, ClassNotFoundException {
-    }
-    finally {
+    } finally {
-      throws TimeoutException, IOException, ClassNotFoundException
-  {
+      throws TimeoutException, IOException, ClassNotFoundException {
-   * Returns true if this region was reinitialized, e.g. a snapshot was loaded,
-   * and this is the recreated region
+   * Returns true if this region was reinitialized, e.g. a snapshot was loaded, and this is the
+   * recreated region
-  boolean reinitialized_new()
-  {
+  boolean reinitialized_new() {
-  void reinitialize_destroy(RegionEventImpl event) throws CacheWriterException,
-      TimeoutException
-  {
+  void reinitialize_destroy(RegionEventImpl event) throws CacheWriterException, TimeoutException {
-  private void recreate(InputStream inputStream,
-      InternalDistributedMember imageTarget) throws TimeoutException,
-      IOException, ClassNotFoundException
-  {
+  private void recreate(InputStream inputStream, InternalDistributedMember imageTarget)
+      throws TimeoutException, IOException, ClassNotFoundException {
-      if (this.dsi!=null && this.dsi.getName().equals(DiskStoreFactory.DEFAULT_DISK_STORE_NAME)
+      if (this.dsi != null && this.dsi.getName().equals(DiskStoreFactory.DEFAULT_DISK_STORE_NAME)
-      .setDestroyLockFlag(getDestroyLock)
-      .setSnapshotInputStream(inputStream)
-      .setImageTarget(imageTarget)
-      .setRecreateFlag(true);
+          .setDestroyLockFlag(getDestroyLock).setSnapshotInputStream(inputStream)
+          .setImageTarget(imageTarget).setRecreateFlag(true);
-      }
-      else {
+      } else {
-    }
-    catch (RegionExistsException e) {
+    } catch (RegionExistsException e) {
-      InternalGemFireError error = new InternalGemFireError(LocalizedStrings.LocalRegion_GOT_REGIONEXISTSEXCEPTION_IN_REINITIALIZE_WHEN_HOLDING_DESTROY_LOCK.toLocalizedString());
+      InternalGemFireError error = new InternalGemFireError(
+          LocalizedStrings.LocalRegion_GOT_REGIONEXISTSEXCEPTION_IN_REINITIALIZE_WHEN_HOLDING_DESTROY_LOCK
+              .toLocalizedString());
-    }
-    finally {
+    } finally {
-      throws IOException, ClassNotFoundException
-  {
+      throws IOException, ClassNotFoundException {
-        throw new IllegalArgumentException(LocalizedStrings.LocalRegion_UNSUPPORTED_SNAPSHOT_VERSION_0_ONLY_VERSION_1_IS_SUPPORTED.toLocalizedString(new Object[] {Byte.valueOf(snapshotVersion), Byte.valueOf(SNAPSHOT_VERSION)}));
+        throw new IllegalArgumentException(
+            LocalizedStrings.LocalRegion_UNSUPPORTED_SNAPSHOT_VERSION_0_ONLY_VERSION_1_IS_SUPPORTED
+                .toLocalizedString(
+                    new Object[] {Byte.valueOf(snapshotVersion), Byte.valueOf(SNAPSHOT_VERSION)}));
-        }
-        else if (b == SNAPSHOT_VALUE_INVALID) {
+        } else if (b == SNAPSHOT_VALUE_INVALID) {
-        }
-        else if (b == SNAPSHOT_VALUE_LOCAL_INVALID) {
+        } else if (b == SNAPSHOT_VALUE_LOCAL_INVALID) {
+        } else {
+          throw new IllegalArgumentException(
+              LocalizedStrings.LocalRegion_UNEXPECTED_SNAPSHOT_CODE_0_THIS_SNAPSHOT_WAS_PROBABLY_WRITTEN_BY_AN_EARLIER_INCOMPATIBLE_RELEASE
+                  .toLocalizedString(new Byte(b)));
-        else {
-          throw new IllegalArgumentException(LocalizedStrings.LocalRegion_UNEXPECTED_SNAPSHOT_CODE_0_THIS_SNAPSHOT_WAS_PROBABLY_WRITTEN_BY_AN_EARLIER_INCOMPATIBLE_RELEASE.toLocalizedString(new Byte(b)));
-        }
-        
-        //If versioning is enabled, we will give the entry a "fake"
-        //version.
+
+        // If versioning is enabled, we will give the entry a "fake"
+        // version.
-        if(this.concurrencyChecksEnabled) {
+        if (this.concurrencyChecksEnabled) {
-        map.initialImagePut(key, cacheTimeMillis(), value, false,
-            false, tag, null, false);
+        map.initialImagePut(key, cacheTimeMillis(), value, false, false, tag, null, false);
-    }
-    finally {
+    } finally {
-  Object getEntryValue(RegionEntry entry)
-  {
+  Object getEntryValue(RegionEntry entry) {
-    
+
-    }catch(DiskAccessException dae) {
+    } catch (DiskAccessException dae) {
-   * @param destroyedRegionOk
-   *          true if it is okay to return a region that isDestroyed
+   * @param destroyedRegionOk true if it is okay to return a region that isDestroyed
-  Region getSubregion(String path, boolean destroyedRegionOk)
-  {
+  Region getSubregion(String path, boolean destroyedRegionOk) {
-    }
-    else if (isDestroyed()) {
+    } else if (isDestroyed()) {
-      throw new IllegalArgumentException(LocalizedStrings.LocalRegion_PATH_SHOULD_NOT_BE_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.LocalRegion_PATH_SHOULD_NOT_BE_NULL.toLocalizedString());
-      throw new IllegalArgumentException(LocalizedStrings.LocalRegion_PATH_SHOULD_NOT_START_WITH_A_SLASH.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.LocalRegion_PATH_SHOULD_NOT_START_WITH_A_SLASH.toLocalizedString());
-   * Called by a thread that is doing region initialization. Causes the
-   * initialization Latch to be bypassed by this thread.
+   * Called by a thread that is doing region initialization. Causes the initialization Latch to be
+   * bypassed by this thread.
-  public static int setThreadInitLevelRequirement(int level)
-  {
+  public static int setThreadInitLevelRequirement(int level) {
-    }
-    else {
+    } else {
-   * Return the access level this thread has for regions with respect to how
-   * initialized they need to be before this thread can have a reference to it.
-   * AFTER_INITIAL_IMAGE: Must be fully initialized (the default)
-   * BEFORE_INITIAL_IMAGE: Must have had first latch opened ANY_INIT: Thread
-   * uses region as soon as possible
+   * Return the access level this thread has for regions with respect to how initialized they need
+   * to be before this thread can have a reference to it. AFTER_INITIAL_IMAGE: Must be fully
+   * initialized (the default) BEFORE_INITIAL_IMAGE: Must have had first latch opened ANY_INIT:
+   * Thread uses region as soon as possible
-  public static int threadInitLevelRequirement()
-  {
-    Integer initLevel = (Integer)initializationThread.get();
+  public static int threadInitLevelRequirement() {
+    Integer initLevel = (Integer) initializationThread.get();
-  
+
-    case AFTER_INITIAL_IMAGE:
-      return checkForInitialization(this.initializationLatchAfterGetInitialImage);
-    case BEFORE_INITIAL_IMAGE:
-      return checkForInitialization(this.initializationLatchBeforeGetInitialImage);
-    case ANY_INIT:
-      return true;
-    default:
-      throw new InternalGemFireError(LocalizedStrings.LocalRegion_UNEXPECTED_THREADINITLEVELREQUIREMENT.toLocalizedString());
+      case AFTER_INITIAL_IMAGE:
+        return checkForInitialization(this.initializationLatchAfterGetInitialImage);
+      case BEFORE_INITIAL_IMAGE:
+        return checkForInitialization(this.initializationLatchBeforeGetInitialImage);
+      case ANY_INIT:
+        return true;
+      default:
+        throw new InternalGemFireError(
+            LocalizedStrings.LocalRegion_UNEXPECTED_THREADINITLEVELREQUIREMENT.toLocalizedString());
-  private boolean checkForInitialization(
-      StoppableCountDownLatch latch) {
+  private boolean checkForInitialization(StoppableCountDownLatch latch) {
-  public void waitOnInitialization()
-  {
+  public void waitOnInitialization() {
-    case AFTER_INITIAL_IMAGE:
-      waitOnInitialization(this.initializationLatchAfterGetInitialImage);
-      break;
-    case BEFORE_INITIAL_IMAGE:
-      waitOnInitialization(this.initializationLatchBeforeGetInitialImage);
-      break;
-    case ANY_INIT:
-      return;
-    default:
-      throw new InternalGemFireError(LocalizedStrings.LocalRegion_UNEXPECTED_THREADINITLEVELREQUIREMENT.toLocalizedString());
+      case AFTER_INITIAL_IMAGE:
+        waitOnInitialization(this.initializationLatchAfterGetInitialImage);
+        break;
+      case BEFORE_INITIAL_IMAGE:
+        waitOnInitialization(this.initializationLatchBeforeGetInitialImage);
+        break;
+      case ANY_INIT:
+        return;
+      default:
+        throw new InternalGemFireError(
+            LocalizedStrings.LocalRegion_UNEXPECTED_THREADINITLEVELREQUIREMENT.toLocalizedString());
-  protected void waitOnInitialization(StoppableCountDownLatch latch)
-  {
+  protected void waitOnInitialization(StoppableCountDownLatch latch) {
-      while (true) {
-        cache.getCancelCriterion().checkCancelInProgress(null);
-        boolean interrupted = Thread.interrupted();
-        try {
-          latch.await();
-          break;
-        }
-        catch (InterruptedException e) {
-          interrupted = true;
-          cache.getCancelCriterion().checkCancelInProgress(e);
-          // continue waiting
-        }
-        finally {
-          if (interrupted) // set interrupted flag if was interrupted
-            Thread.currentThread().interrupt();
-        }
-      } // while
+    while (true) {
+      cache.getCancelCriterion().checkCancelInProgress(null);
+      boolean interrupted = Thread.interrupted();
+      try {
+        latch.await();
+        break;
+      } catch (InterruptedException e) {
+        interrupted = true;
+        cache.getCancelCriterion().checkCancelInProgress(e);
+        // continue waiting
+      } finally {
+        if (interrupted) // set interrupted flag if was interrupted
+          Thread.currentThread().interrupt();
+      }
+    } // while
-  public RegionEntry basicGetEntry(Object key)
-  {
+  public RegionEntry basicGetEntry(Object key) {
-   * Return true if invalidation occurred; false if it did not, for example if
-   * it was already invalidated
+   * Return true if invalidation occurred; false if it did not, for example if it was already
+   * invalidated
-  void basicInvalidate(EntryEventImpl event) throws EntryNotFoundException
-  {
+  void basicInvalidate(EntryEventImpl event) throws EntryNotFoundException {
-   * Used by disk regions when recovering data from backup. Currently this "put"
-   * is done at a very low level to keep it from generating events or pushing
-   * updates to others.
+   * Used by disk regions when recovering data from backup. Currently this "put" is done at a very
+   * low level to keep it from generating events or pushing updates to others.
-  public DiskEntry initializeRecoveredEntry(Object key, DiskEntry.RecoveredEntry value)
-  {
+  public DiskEntry initializeRecoveredEntry(Object key, DiskEntry.RecoveredEntry value) {
-      throw new InternalGemFireError(LocalizedStrings.LocalRegion_ENTRY_ALREADY_EXISTED_0.toLocalizedString(key));
+      throw new InternalGemFireError(
+          LocalizedStrings.LocalRegion_ENTRY_ALREADY_EXISTED_0.toLocalizedString(key));
-    return (DiskEntry)re;
+    return (DiskEntry) re;
+
-   * Used by disk regions when recovering data from backup and
-   * initializedRecoveredEntry has already been called for the given key.
-   * Currently this "put"
-   * is done at a very low level to keep it from generating events or pushing
-   * updates to others.
+   * Used by disk regions when recovering data from backup and initializedRecoveredEntry has already
+   * been called for the given key. Currently this "put" is done at a very low level to keep it from
+   * generating events or pushing updates to others.
-  public DiskEntry updateRecoveredEntry(Object key, DiskEntry.RecoveredEntry value)
-  {
+  public DiskEntry updateRecoveredEntry(Object key, DiskEntry.RecoveredEntry value) {
-    return (DiskEntry)re;
+    return (DiskEntry) re;
-  
+
-  
+
-  //TODO - RVV - I'm not sure about this recordGCVersion method. It seems
-    //like it's not doing the right thing if the current member is the member
-    //we just recovered.
-    //We need to update the RVV in memory
+    // TODO - RVV - I'm not sure about this recordGCVersion method. It seems
+    // like it's not doing the right thing if the current member is the member
+    // we just recovered.
+    // We need to update the RVV in memory
-    
-    //We also need to update the RVV that represents what we have persisted on disk
+
+    // We also need to update the RVV that represents what we have persisted on disk
-    if(dr != null) {
+    if (dr != null) {
-  public void recordRecoveredVersonHolder(VersionSource member,
-      RegionVersionHolder versionHolder, boolean latestOplog) {
-    if(this.concurrencyChecksEnabled) {
-      //We need to update the RVV in memory
+  public void recordRecoveredVersonHolder(VersionSource member, RegionVersionHolder versionHolder,
+      boolean latestOplog) {
+    if (this.concurrencyChecksEnabled) {
+      // We need to update the RVV in memory
-      //We also need to update the RVV that represents what we have persisted on disk
-      if(dr != null) {
+      // We also need to update the RVV that represents what we have persisted on disk
+      if (dr != null) {
-  
+
-    if(this.concurrencyChecksEnabled) {
+    if (this.concurrencyChecksEnabled) {
-      //We also need to update the RVV that represents what we have persisted on disk
-      if(dr != null) {
+      // We also need to update the RVV that represents what we have persisted on disk
+      if (dr != null) {
-  
-  
+
+
-    if(this.concurrencyChecksEnabled) {
+    if (this.concurrencyChecksEnabled) {
-      //Update whether or not the RVV we have recovered is trusted (accurately
-      //represents what we have on disk).
-      if(dr != null) {
+      // Update whether or not the RVV we have recovered is trusted (accurately
+      // represents what we have on disk).
+      if (dr != null) {
-  
+
-    if(this instanceof DistributedRegion) {
-      return ((DistributedRegion)this).getBestIterator(includeValues);
+    if (this instanceof DistributedRegion) {
+      return ((DistributedRegion) this).getBestIterator(includeValues);
-    
+
-  
+
-   * Fix up our RVV by iterating over the entries in the region
-   * and making sure they are applied to the RVV.
+   * Fix up our RVV by iterating over the entries in the region and making sure they are applied to
+   * the RVV.
-   * If we failed to do a GII, we may have applied the RVV from a remote member.
-   * That RVV may not have seen some of the events in our local RVV. Those
-   * entries were supposed to be replaced with the results of the GII. However,
-   * if we failed the GII, those entries may still be in the cache, but are 
-   * no longer reflected in the local RVV. This method iterates over those
-   * keys and makes sure their versions are applied to the local RVV.
+   * If we failed to do a GII, we may have applied the RVV from a remote member. That RVV may not
+   * have seen some of the events in our local RVV. Those entries were supposed to be replaced with
+   * the results of the GII. However, if we failed the GII, those entries may still be in the cache,
+   * but are no longer reflected in the local RVV. This method iterates over those keys and makes
+   * sure their versions are applied to the local RVV.
-   * TODO - this method should probably rebuild the RVV from scratch, instead
-   * of starting with the existing RVV. By starting with the existing RVV, we
-   * may claim to have entries that we actually don't have. Unfortunately, we
-   * can't really rebuild the RVV from scratch because we will end up with
-   * huge exception lists.
+   * TODO - this method should probably rebuild the RVV from scratch, instead of starting with the
+   * existing RVV. By starting with the existing RVV, we may claim to have entries that we actually
+   * don't have. Unfortunately, we can't really rebuild the RVV from scratch because we will end up
+   * with huge exception lists.
-   * However, if we are in the state of recovering from disk with an untrusted
-   * RVV, we must be newer than any other surviving members. So they shouldn't
-   * have any entries in their cache that match entries that we failed to receive
-   * through the GII but are reflected in our current RVV. So it should be 
-   * safe to start with the current RVV.
+   * However, if we are in the state of recovering from disk with an untrusted RVV, we must be newer
+   * than any other surviving members. So they shouldn't have any entries in their cache that match
+   * entries that we failed to receive through the GII but are reflected in our current RVV. So it
+   * should be safe to start with the current RVV.
-    
-    if(rvv == null) {
-      //No need to do anything.
+
+    if (rvv == null) {
+      // No need to do anything.
-    
+
-    //Iterate over the all of the entries
+    // Iterate over the all of the entries
-      //Make sure the version is applied to the regions RVV
+      // Make sure the version is applied to the regions RVV
-      
+
-   * Return true if invalidation occurred; false if it did not, for example if
-   * it was already invalidated
+   * Return true if invalidation occurred; false if it did not, for example if it was already
+   * invalidated
-  private void basicInvalidate(final EntryEventImpl event,
-      boolean invokeCallbacks) throws EntryNotFoundException
-  {
+  private void basicInvalidate(final EntryEventImpl event, boolean invokeCallbacks)
+      throws EntryNotFoundException {
-   * Asif:Made this function protected as this is over ridden in HARegion to
-   * abort expiry of Events which have key as Long , if it is not able to
-   * destroy from availableIDs
+   * Asif:Made this function protected as this is over ridden in HARegion to abort expiry of Events
+   * which have key as Long , if it is not able to destroy from availableIDs
-   * @param forceNewEntry
-   *          true if we are a mirror and still in the initialization phase.
-   *          Called from InvalidateOperation.InvalidateMessage
-
+   * @param forceNewEntry true if we are a mirror and still in the initialization phase. Called from
+   *        InvalidateOperation.InvalidateMessage
+   * 
-      final boolean forceNewEntry) throws EntryNotFoundException
-  {
-    if (!event.isOriginRemote() && !event.isDistributed()
-        && getScope().isDistributed() && getDataPolicy().withReplication()
+      final boolean forceNewEntry) throws EntryNotFoundException {
+    if (!event.isOriginRemote() && !event.isDistributed() && getScope().isDistributed()
+        && getDataPolicy().withReplication()
-                            * catches case where being called by (distributed)
-                            * invalidateRegion
+                            * catches case where being called by (distributed) invalidateRegion
-      throw new IllegalStateException(LocalizedStrings.LocalRegion_CANNOT_DO_A_LOCAL_INVALIDATE_ON_A_REPLICATED_REGION.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.LocalRegion_CANNOT_DO_A_LOCAL_INVALIDATE_ON_A_REPLICATED_REGION
+              .toLocalizedString());
-      if(logger.isTraceEnabled(LogMarker.DM)) {
-        logger.trace(LogMarker.DM, "LR.basicInvalidate: this cache has already seen this event {}", event);
+      if (logger.isTraceEnabled(LogMarker.DM)) {
+        logger.trace(LogMarker.DM, "LR.basicInvalidate: this cache has already seen this event {}",
+            event);
-      if (this.concurrencyChecksEnabled && event.getVersionTag() != null && !event.getVersionTag().isRecorded()) {
-        getVersionVector().recordVersion((InternalDistributedMember) event.getDistributedMember(), event.getVersionTag());
+      if (this.concurrencyChecksEnabled && event.getVersionTag() != null
+          && !event.getVersionTag().isRecorded()) {
+        getVersionVector().recordVersion((InternalDistributedMember) event.getDistributedMember(),
+            event.getVersionTag());
-  void basicInvalidatePart2(RegionEntry re, EntryEventImpl event,
-      boolean conflictwithClear, boolean invokeCallbacks)
-  {
+  void basicInvalidatePart2(RegionEntry re, EntryEventImpl event, boolean conflictwithClear,
+      boolean invokeCallbacks) {
-      }
-      catch (InterruptedException ie) {
+      } catch (InterruptedException ie) {
-    }
-    else {
+    } else {
-  void basicInvalidatePart3(RegionEntry re, EntryEventImpl event,
-      boolean invokeCallbacks) {
+  void basicInvalidatePart3(RegionEntry re, EntryEventImpl event, boolean invokeCallbacks) {
-    if(callDispatchListenerEvent){
+    if (callDispatchListenerEvent) {
-   * @param key
-   *          the key of the entry to invalidate
-   * @param newValue
-   *          the new value of the entry
-   * @param didDestroy
-   *          true if tx destroyed this entry at some point
-   * @param rmtOrigin
-   *          true if transaction being applied had a remote origin
-   * @param event
-   *          filled in if operation performed
-   * @param filterRoutingInfo 
-   * @param bridgeContext 
+   * @param key the key of the entry to invalidate
+   * @param newValue the new value of the entry
+   * @param didDestroy true if tx destroyed this entry at some point
+   * @param rmtOrigin true if transaction being applied had a remote origin
+   * @param event filled in if operation performed
+   * @param filterRoutingInfo
+   * @param bridgeContext
-      TransactionId rmtOrigin, TXRmtEvent event, boolean localOp, 
-      EventID eventId, Object aCallbackArgument,List<EntryEventImpl> pendingCallbacks, FilterRoutingInfo filterRoutingInfo,
-      ClientProxyMembershipID bridgeContext, TXEntryState txEntryState, VersionTag versionTag, long tailKey)
-  {
-    this.entries.txApplyInvalidate(key, newValue, didDestroy, rmtOrigin, 
-        event, localOp, eventId, aCallbackArgument,pendingCallbacks,filterRoutingInfo,bridgeContext, txEntryState, versionTag, tailKey);
+      TransactionId rmtOrigin, TXRmtEvent event, boolean localOp, EventID eventId,
+      Object aCallbackArgument, List<EntryEventImpl> pendingCallbacks,
+      FilterRoutingInfo filterRoutingInfo, ClientProxyMembershipID bridgeContext,
+      TXEntryState txEntryState, VersionTag versionTag, long tailKey) {
+    this.entries.txApplyInvalidate(key, newValue, didDestroy, rmtOrigin, event, localOp, eventId,
+        aCallbackArgument, pendingCallbacks, filterRoutingInfo, bridgeContext, txEntryState,
+        versionTag, tailKey);
-   * Called by lower levels, while still holding the write sync lock, and the
-   * low level has completed its part of the basic destroy
+   * Called by lower levels, while still holding the write sync lock, and the low level has
+   * completed its part of the basic destroy
-  final void txApplyInvalidatePart2(RegionEntry re, Object key,
-      boolean didDestroy, boolean didInvalidate, boolean clearConflict)
-  {
+  final void txApplyInvalidatePart2(RegionEntry re, Object key, boolean didDestroy,
+      boolean didInvalidate, boolean clearConflict) {
-      // Bug 40842: clearing index of the old value 
+      // Bug 40842: clearing index of the old value
-   * Allows null as new value to accomodate create with a null value. Assumes
-   * all key, value, and callback validations have been performed.
+   * Allows null as new value to accomodate create with a null value. Assumes all key, value, and
+   * callback validations have been performed.
-   * @param event
-   *          the event object for this operation, with the exception that the
-   *          oldValue parameter is not yet filled in. The oldValue will be
-   *          filled in by this operation.
+   * @param event the event object for this operation, with the exception that the oldValue
+   *        parameter is not yet filled in. The oldValue will be filled in by this operation.
-   * @param ifNew
-   *          true if this operation must not overwrite an existing key
-   * @param ifOld
-   *          true if this operation must not create a new key
-   * @param expectedOldValue
-   *          only succeed if old value is equal to this value. If null,
-   *          then doesn't matter what old value is. If INVALID token,
-   *          must be INVALID.
-   * @param requireOldValue
-   *          true if the oldValue should be set in event even if ifNew
-   *          and entry exists
-   * @return false if ifNew is true and there is an existing key or
-   *         if ifOld is true and expectedOldValue does not match the current
-   *         value in the cache.  Otherwise return true.
+   * @param ifNew true if this operation must not overwrite an existing key
+   * @param ifOld true if this operation must not create a new key
+   * @param expectedOldValue only succeed if old value is equal to this value. If null, then doesn't
+   *        matter what old value is. If INVALID token, must be INVALID.
+   * @param requireOldValue true if the oldValue should be set in event even if ifNew and entry
+   *        exists
+   * @return false if ifNew is true and there is an existing key or if ifOld is true and
+   *         expectedOldValue does not match the current value in the cache. Otherwise return true.
-  protected final boolean basicPut(EntryEventImpl event,
-      boolean ifNew,
-      boolean ifOld,
-      Object expectedOldValue,
-      boolean requireOldValue)
-  throws TimeoutException, CacheWriterException {
-	 return getDataView().putEntry(event, ifNew, ifOld, expectedOldValue, requireOldValue, 0L, false);
+  protected final boolean basicPut(EntryEventImpl event, boolean ifNew, boolean ifOld,
+      Object expectedOldValue, boolean requireOldValue)
+      throws TimeoutException, CacheWriterException {
+    return getDataView().putEntry(event, ifNew, ifOld, expectedOldValue, requireOldValue, 0L,
+        false);
-   * @param putOp
-   *          describes the operation that did the put
-   * @param key
-   *          the key of the entry to put
-   * @param newValue
-   *          the new value of the entry
-   * @param didDestroy
-   *          true if tx destroyed this entry at some point
-   * @param rmtOrigin
-   *          true if transaction being applied had a remote origin
-   * @param event
-   *          filled in if operation performed
-   * @param aCallbackArgument
-   *            argument passed in by user
-   * @param filterRoutingInfo 
-   * @param bridgeContext 
+   * @param putOp describes the operation that did the put
+   * @param key the key of the entry to put
+   * @param newValue the new value of the entry
+   * @param didDestroy true if tx destroyed this entry at some point
+   * @param rmtOrigin true if transaction being applied had a remote origin
+   * @param event filled in if operation performed
+   * @param aCallbackArgument argument passed in by user
+   * @param filterRoutingInfo
+   * @param bridgeContext
-  final void txApplyPut(Operation putOp, Object key, Object newValue,
-      boolean didDestroy, TransactionId rmtOrigin, TXRmtEvent event, 
-      EventID eventId, Object aCallbackArgument,List<EntryEventImpl> pendingCallbacks, FilterRoutingInfo filterRoutingInfo,
-      ClientProxyMembershipID bridgeContext, TXEntryState txEntryState, VersionTag versionTag, long tailKey)
-  {
+  final void txApplyPut(Operation putOp, Object key, Object newValue, boolean didDestroy,
+      TransactionId rmtOrigin, TXRmtEvent event, EventID eventId, Object aCallbackArgument,
+      List<EntryEventImpl> pendingCallbacks, FilterRoutingInfo filterRoutingInfo,
+      ClientProxyMembershipID bridgeContext, TXEntryState txEntryState, VersionTag versionTag,
+      long tailKey) {
-    this.entries.txApplyPut(putOp, key, newValue, didDestroy, rmtOrigin, 
-        event, eventId, aCallbackArgument,pendingCallbacks,filterRoutingInfo,bridgeContext, txEntryState, versionTag, tailKey);
+    this.entries.txApplyPut(putOp, key, newValue, didDestroy, rmtOrigin, event, eventId,
+        aCallbackArgument, pendingCallbacks, filterRoutingInfo, bridgeContext, txEntryState,
+        versionTag, tailKey);
-    //Fix for 47507 - make sure we throw an exception if we skip the TX put because
-    //the region is cleared (due to a destroy).
+    // Fix for 47507 - make sure we throw an exception if we skip the TX put because
+    // the region is cleared (due to a destroy).
-  final void txApplyPutPart2(RegionEntry re, Object key, Object newValue,
-      long lastModified, boolean isCreate, boolean didDestroy, boolean clearConflict )
-  {
+  final void txApplyPutPart2(RegionEntry re, Object key, Object newValue, long lastModified,
+      boolean isCreate, boolean didDestroy, boolean clearConflict) {
-                                          isCreate ? IndexManager.ADD_ENTRY :
-                                                     IndexManager.UPDATE_ENTRY,
-                                          isCreate ? IndexProtocol.OTHER_OP :
-                                                     IndexProtocol.AFTER_UPDATE_OP);
-        }
-        catch (QueryException e) {
+              isCreate ? IndexManager.ADD_ENTRY : IndexManager.UPDATE_ENTRY,
+              isCreate ? IndexProtocol.OTHER_OP : IndexProtocol.AFTER_UPDATE_OP);
+        } catch (QueryException e) {
-  public boolean basicBridgeCreate(final Object key, final byte[] value,
-      boolean isObject, Object p_callbackArg, final ClientProxyMembershipID client,
-      boolean fromClient, EntryEventImpl clientEvent, boolean throwEntryExists) throws TimeoutException,
-      EntryExistsException, CacheWriterException
-  {
+  public boolean basicBridgeCreate(final Object key, final byte[] value, boolean isObject,
+      Object p_callbackArg, final ClientProxyMembershipID client, boolean fromClient,
+      EntryEventImpl clientEvent, boolean throwEntryExists)
+      throws TimeoutException, EntryExistsException, CacheWriterException {
-      if(isGatewaySenderEnabled()) {
+      if (isGatewaySenderEnabled()) {
-    @Released final EntryEventImpl event = EntryEventImpl.create(this, Operation.CREATE, key,
-       value, callbackArg,  false /* origin remote */, client.getDistributedMember(),
-        true /* generateCallbacks */,
-        eventId);
+    @Released
+    final EntryEventImpl event = EntryEventImpl.create(this, Operation.CREATE, key, value,
+        callbackArg, false /* origin remote */, client.getDistributedMember(),
+        true /* generateCallbacks */, eventId);
-    event.setContext(client);
-    
-    // if this is a replayed operation or WAN event we may already have a version tag
-    event.setVersionTag(clientEvent.getVersionTag());
-    //carry over the possibleDuplicate flag from clientEvent
-    event.setPossibleDuplicate(clientEvent.isPossibleDuplicate());
+      event.setContext(client);
-    //Fix for 42448 - Only make create with null a local invalidate for
-    //normal regions. Otherwise, it will become a distributed invalidate.
-    if(getDataPolicy() == DataPolicy.NORMAL) {
-      event.setLocalInvalid(true);
-    }
+      // if this is a replayed operation or WAN event we may already have a version tag
+      event.setVersionTag(clientEvent.getVersionTag());
+      // carry over the possibleDuplicate flag from clientEvent
+      event.setPossibleDuplicate(clientEvent.isPossibleDuplicate());
-    // Set the new value to the input byte[] if it isn't null
-    if (value != null) {
-      // If the byte[] represents an object, then store it serialized
-      // in a CachedDeserializable; otherwise store it directly as a byte[]
-      if (isObject) {
-        // The value represents an object
-        event.setSerializedNewValue(value);
+      // Fix for 42448 - Only make create with null a local invalidate for
+      // normal regions. Otherwise, it will become a distributed invalidate.
+      if (getDataPolicy() == DataPolicy.NORMAL) {
+        event.setLocalInvalid(true);
-      else {
-        // The value does not represent an object
-        event.setNewValue(value);
-      }
-    }
-    boolean ifNew = true; // cannot overwrite an existing key
-    boolean ifOld = false; // can create a new key
-    long lastModified = 0L; // use now
-    boolean overwriteDestroyed = false; // not okay to overwrite the DESTROYED
-    // token
-    boolean success = basicUpdate(event, ifNew, ifOld, lastModified,
-        overwriteDestroyed);
-    clientEvent.isConcurrencyConflict(event.isConcurrencyConflict());
-    if (success) {
-      clientEvent.setVersionTag(event.getVersionTag());
-      getCachePerfStats().endPut(startPut, event.isOriginRemote());
-    }
-    else {
-      this.stopper.checkCancelInProgress(null);
-      if (throwEntryExists) {
-        throw new EntryExistsException(""+key, event.getOldValue());
+      // Set the new value to the input byte[] if it isn't null
+      if (value != null) {
+        // If the byte[] represents an object, then store it serialized
+        // in a CachedDeserializable; otherwise store it directly as a byte[]
+        if (isObject) {
+          // The value represents an object
+          event.setSerializedNewValue(value);
+        } else {
+          // The value does not represent an object
+          event.setNewValue(value);
+        }
-    }
-    return success;
+
+      boolean ifNew = true; // cannot overwrite an existing key
+      boolean ifOld = false; // can create a new key
+      long lastModified = 0L; // use now
+      boolean overwriteDestroyed = false; // not okay to overwrite the DESTROYED
+      // token
+      boolean success = basicUpdate(event, ifNew, ifOld, lastModified, overwriteDestroyed);
+      clientEvent.isConcurrencyConflict(event.isConcurrencyConflict());
+      if (success) {
+        clientEvent.setVersionTag(event.getVersionTag());
+        getCachePerfStats().endPut(startPut, event.isOriginRemote());
+      } else {
+        this.stopper.checkCancelInProgress(null);
+        if (throwEntryExists) {
+          throw new EntryExistsException("" + key, event.getOldValue());
+        }
+      }
+      return success;
-  public boolean basicBridgePut(Object key, Object value, byte[] deltaBytes,
-      boolean isObject, Object p_callbackArg, ClientProxyMembershipID memberId,
-      boolean fromClient, EntryEventImpl clientEvent)
-      throws TimeoutException, CacheWriterException {
+  public boolean basicBridgePut(Object key, Object value, byte[] deltaBytes, boolean isObject,
+      Object p_callbackArg, ClientProxyMembershipID memberId, boolean fromClient,
+      EntryEventImpl clientEvent) throws TimeoutException, CacheWriterException {
-      if(isGatewaySenderEnabled()) {
+      if (isGatewaySenderEnabled()) {
-   
-    @Released final EntryEventImpl event = EntryEventImpl.create(this, Operation.UPDATE, key,
-        null /* new value */, callbackArg,
-        false /* origin remote */, memberId.getDistributedMember(),
-        true /* generateCallbacks */,
-        eventID);
-    try {
-    event.setContext(memberId);
-    event.setDeltaBytes(deltaBytes);
-    // if this is a replayed operation we may already have a version tag
-    event.setVersionTag(clientEvent.getVersionTag());
-    //carry over the possibleDuplicate flag from clientEvent
-    event.setPossibleDuplicate(clientEvent.isPossibleDuplicate());
-    
-    // Set the new value to the input byte[]
-    // If the byte[] represents an object, then store it
-    // serialized in a CachedDeserializable; otherwise store it directly
-    // as a byte[].
-    if (isObject && value instanceof byte[]) {
-      event.setSerializedNewValue((byte[])value);
-    }
-    else {
-      event.setNewValue(value);
-    }
-
-    boolean ifNew = false; // can overwrite an existing key
-    
-    boolean ifOld = false; // can create a new key
-    long lastModified = 0L; // use now
-    boolean overwriteDestroyed = false; // not okay to overwrite the DESTROYED token
-    boolean success = false;
+    @Released
+    final EntryEventImpl event = EntryEventImpl.create(this, Operation.UPDATE, key,
+        null /* new value */, callbackArg, false /* origin remote */,
+        memberId.getDistributedMember(), true /* generateCallbacks */, eventID);
-      success = basicUpdate(event, ifNew, ifOld, lastModified,
-       overwriteDestroyed);
-    } catch (ConcurrentCacheModificationException ex) { // thrown by WAN conflicts
-      event.isConcurrencyConflict(true);
-    }
-    clientEvent.isConcurrencyConflict(event.isConcurrencyConflict());
-    if (success) {
-      clientEvent.setVersionTag(event.getVersionTag());
-      getCachePerfStats().endPut(startPut, event.isOriginRemote());
-    }
-    else {
-      this.stopper.checkCancelInProgress(null);
-    }
-    return success;
+      event.setContext(memberId);
+      event.setDeltaBytes(deltaBytes);
+
+      // if this is a replayed operation we may already have a version tag
+      event.setVersionTag(clientEvent.getVersionTag());
+      // carry over the possibleDuplicate flag from clientEvent
+      event.setPossibleDuplicate(clientEvent.isPossibleDuplicate());
+
+      // Set the new value to the input byte[]
+      // If the byte[] represents an object, then store it
+      // serialized in a CachedDeserializable; otherwise store it directly
+      // as a byte[].
+      if (isObject && value instanceof byte[]) {
+        event.setSerializedNewValue((byte[]) value);
+      } else {
+        event.setNewValue(value);
+      }
+
+      boolean ifNew = false; // can overwrite an existing key
+
+      boolean ifOld = false; // can create a new key
+      long lastModified = 0L; // use now
+      boolean overwriteDestroyed = false; // not okay to overwrite the DESTROYED token
+      boolean success = false;
+      try {
+        success = basicUpdate(event, ifNew, ifOld, lastModified, overwriteDestroyed);
+      } catch (ConcurrentCacheModificationException ex) { // thrown by WAN conflicts
+        event.isConcurrencyConflict(true);
+      }
+      clientEvent.isConcurrencyConflict(event.isConcurrencyConflict());
+      if (success) {
+        clientEvent.setVersionTag(event.getVersionTag());
+        getCachePerfStats().endPut(startPut, event.isOriginRemote());
+      } else {
+        this.stopper.checkCancelInProgress(null);
+      }
+      return success;
-   * issue a config message if the server and client have different
-   * concurrency checking expectations
+   * issue a config message if the server and client have different concurrency checking
+   * expectations
+   * 
-      logger.info(LocalizedMessage.create(LocalizedStrings.LocalRegion_SERVER_HAS_CONCURRENCY_CHECKS_ENABLED_0_BUT_CLIENT_HAS_1_FOR_REGION_2,
-          new Object[]{ !this.concurrencyChecksEnabled, this.concurrencyChecksEnabled, this}));
+      logger.info(LocalizedMessage.create(
+          LocalizedStrings.LocalRegion_SERVER_HAS_CONCURRENCY_CHECKS_ENABLED_0_BUT_CLIENT_HAS_1_FOR_REGION_2,
+          new Object[] {!this.concurrencyChecksEnabled, this.concurrencyChecksEnabled, this}));
-   * Perform an update in a bridge client. See CacheClientUpdater.handleUpdate()
-   * The op is from the bridge server and should not be distributed back to it.
+   * Perform an update in a bridge client. See CacheClientUpdater.handleUpdate() The op is from the
+   * bridge server and should not be distributed back to it.
-  public void basicBridgeClientUpdate(DistributedMember serverId, Object key,
-      Object value, byte[] deltaBytes, boolean isObject,
-      Object callbackArgument, boolean isCreate, boolean processedMarker,
-      EntryEventImpl event, EventID eventID) throws TimeoutException,
-      CacheWriterException {
+  public void basicBridgeClientUpdate(DistributedMember serverId, Object key, Object value,
+      byte[] deltaBytes, boolean isObject, Object callbackArgument, boolean isCreate,
+      boolean processedMarker, EntryEventImpl event, EventID eventID)
+      throws TimeoutException, CacheWriterException {
-        event.setSerializedNewValue((byte[])value);
-      }
-      else {
+        event.setSerializedNewValue((byte[]) value);
+      } else {
-      boolean overwriteDestroyed = true; //okay to overwrite the DESTROYED token
+      boolean overwriteDestroyed = true; // okay to overwrite the DESTROYED token
-    }
-    else {
+    } else {
-        invokePutCallbacks(isCreate ? EnumListenerEvent.AFTER_CREATE
-            : EnumListenerEvent.AFTER_UPDATE, event, true, true);
+        invokePutCallbacks(
+            isCreate ? EnumListenerEvent.AFTER_CREATE : EnumListenerEvent.AFTER_UPDATE, event, true,
+            true);
-   * Perform an invalidate in a bridge client.
-   * The op is from the bridge server and should not be distributed back to it.
+   * Perform an invalidate in a bridge client. The op is from the bridge server and should not be
+   * distributed back to it.
-      Object callbackArgument, boolean processedMarker, EventID eventID,
-      VersionTag versionTag)
-  throws EntryNotFoundException {
+      Object callbackArgument, boolean processedMarker, EventID eventID, VersionTag versionTag)
+      throws EntryNotFoundException {
-      @Released EntryEventImpl event =
-        EntryEventImpl.create(this,
-                           Operation.INVALIDATE,
-                           key, null /* newValue */,
-                           callbackArgument /* callbackArg*/,
-                           true /*originRemote*/,
-                           serverId
-                           );
+      @Released
+      EntryEventImpl event =
+          EntryEventImpl.create(this, Operation.INVALIDATE, key, null /* newValue */,
+              callbackArgument /* callbackArg */, true /* originRemote */, serverId);
-      event.setVersionTag(versionTag);
-      event.setFromServer(true);
-      if (generateEventID() && !this.cache.getCacheServers().isEmpty()) {
-        event.setNewEventId(cache.getDistributedSystem());
-      } else {
-        event.setEventId(eventID);
-      }
+        event.setVersionTag(versionTag);
+        event.setFromServer(true);
+        if (generateEventID() && !this.cache.getCacheServers().isEmpty()) {
+          event.setNewEventId(cache.getDistributedSystem());
+        } else {
+          event.setEventId(eventID);
+        }
-      // If the marker has been processed, process this invalidate event
-      // normally; otherwise, this event occurred in the past and has been
-      // stored for a durable client. In this case, just invoke the invalidate
-      // callbacks.
-      if (processedMarker) {
-        // [bruce] changed to force new entry creation for consistency
-        final boolean forceNewEntry = this.concurrencyChecksEnabled;
-        basicInvalidate(event, true, forceNewEntry);
-        if (event.isConcurrencyConflict()) { // bug #45520 - we must throw this for the CacheClientUpdater
-          throw new ConcurrentCacheModificationException();
+        // If the marker has been processed, process this invalidate event
+        // normally; otherwise, this event occurred in the past and has been
+        // stored for a durable client. In this case, just invoke the invalidate
+        // callbacks.
+        if (processedMarker) {
+          // [bruce] changed to force new entry creation for consistency
+          final boolean forceNewEntry = this.concurrencyChecksEnabled;
+          basicInvalidate(event, true, forceNewEntry);
+          if (event.isConcurrencyConflict()) { // bug #45520 - we must throw this for the
+                                               // CacheClientUpdater
+            throw new ConcurrentCacheModificationException();
+          }
+        } else {
+          if (isInitialized()) {
+            invokeInvalidateCallbacks(EnumListenerEvent.AFTER_INVALIDATE, event, true);
+          }
-      } else {
-        if (isInitialized()) {
-          invokeInvalidateCallbacks(EnumListenerEvent.AFTER_INVALIDATE, event,
-              true);
-        }
-      }
-   * Perform a destroy in a bridge client.
-   * The op is from the bridge server and should not be distributed back to it.
+   * Perform a destroy in a bridge client. The op is from the bridge server and should not be
+   * distributed back to it.
-      Object callbackArgument, boolean processedMarker, EventID eventID,
-      VersionTag versionTag)
-    throws EntryNotFoundException {
+      Object callbackArgument, boolean processedMarker, EventID eventID, VersionTag versionTag)
+      throws EntryNotFoundException {
-      @Released EntryEventImpl event =
-        EntryEventImpl.create(this,
-                           Operation.DESTROY,
-                           key, null /* newValue */,
-                           callbackArgument /* callbackArg*/,
-                           true /*originRemote*/,
-                           serverId
-                           );
+      @Released
+      EntryEventImpl event =
+          EntryEventImpl.create(this, Operation.DESTROY, key, null /* newValue */,
+              callbackArgument /* callbackArg */, true /* originRemote */, serverId);
-      event.setFromServer(true);
-      event.setVersionTag(versionTag);
-      
-      if (generateEventID() && !this.cache.getCacheServers().isEmpty()) {
-        event.setNewEventId(cache.getDistributedSystem());
-      } else {
-        event.setEventId(eventID);
-      }
-      // If the marker has been processed, process this destroy event normally;
-      // otherwise, this event occurred in the past and has been stored for a
-      // durable client. In this case, just invoke the destroy callbacks.
-      if(logger.isDebugEnabled()) {
-        logger.debug("basicBridgeClientDestroy(processedMarker={})", processedMarker);
-      }
-      if (processedMarker) {
-        basicDestroy(event,
-                     false, // cacheWrite
-                     null); // expectedOldValue
-        if (event.isConcurrencyConflict()) { // bug #45520 - we must throw an exception for CacheClientUpdater
-          throw new ConcurrentCacheModificationException();
+        event.setFromServer(true);
+        event.setVersionTag(versionTag);
+
+        if (generateEventID() && !this.cache.getCacheServers().isEmpty()) {
+          event.setNewEventId(cache.getDistributedSystem());
+        } else {
+          event.setEventId(eventID);
-      } else {
-        if (isInitialized()) {
-          invokeDestroyCallbacks(EnumListenerEvent.AFTER_DESTROY, event, true, true);
+        // If the marker has been processed, process this destroy event normally;
+        // otherwise, this event occurred in the past and has been stored for a
+        // durable client. In this case, just invoke the destroy callbacks.
+        if (logger.isDebugEnabled()) {
+          logger.debug("basicBridgeClientDestroy(processedMarker={})", processedMarker);
-      }
+        if (processedMarker) {
+          basicDestroy(event, false, // cacheWrite
+              null); // expectedOldValue
+          if (event.isConcurrencyConflict()) { // bug #45520 - we must throw an exception for
+                                               // CacheClientUpdater
+            throw new ConcurrentCacheModificationException();
+          }
+        } else {
+          if (isInitialized()) {
+            invokeDestroyCallbacks(EnumListenerEvent.AFTER_DESTROY, event, true, true);
+          }
+        }
-   * @param callbackArgument The callback argument. This is currently null
-   * since {@link java.util.Map#clear} supports no parameters.
-   * @param processedMarker Whether the marker has been processed (for durable
-   * clients)
+   * 
+   * @param callbackArgument The callback argument. This is currently null since
+   *        {@link java.util.Map#clear} supports no parameters.
+   * @param processedMarker Whether the marker has been processed (for durable clients)
-    RegionEventImpl event = new RegionEventImpl(this,
-        Operation.REGION_LOCAL_CLEAR, callbackArgument, true, getMyId(),
-        generateEventID()/* generate EventID */);
+    RegionEventImpl event = new RegionEventImpl(this, Operation.REGION_LOCAL_CLEAR,
+        callbackArgument, true, getMyId(), generateEventID()/* generate EventID */);
-  
-  
-  
-  public void basicBridgeDestroy(Object key, Object p_callbackArg,
-      ClientProxyMembershipID memberId, boolean fromClient, EntryEventImpl clientEvent)
-      throws TimeoutException, EntryNotFoundException, CacheWriterException
-  {
+
+
+
+  public void basicBridgeDestroy(Object key, Object p_callbackArg, ClientProxyMembershipID memberId,
+      boolean fromClient, EntryEventImpl clientEvent)
+      throws TimeoutException, EntryNotFoundException, CacheWriterException {
-      if(isGatewaySenderEnabled()) {
+      if (isGatewaySenderEnabled()) {
-    @Released final EntryEventImpl event = EntryEventImpl.create(this, Operation.DESTROY, key,
-        null /* new value */, callbackArg,
-        false /* origin remote */, memberId.getDistributedMember(),
-        true /* generateCallbacks */,
-        clientEvent.getEventId());
+    @Released
+    final EntryEventImpl event = EntryEventImpl.create(this, Operation.DESTROY, key,
+        null /* new value */, callbackArg, false /* origin remote */,
+        memberId.getDistributedMember(), true /* generateCallbacks */, clientEvent.getEventId());
-    event.setContext(memberId);
-    // if this is a replayed or WAN operation we may already have a version tag
-    event.setVersionTag(clientEvent.getVersionTag());
-    try {
-      basicDestroy(event,
-                 true,  // cacheWrite
-                 null); // expectedOldValue
-    } catch (ConcurrentCacheModificationException ex) { // thrown by WAN conflicts
-      event.isConcurrencyConflict(true);
-    } finally {
-      clientEvent.setVersionTag(event.getVersionTag());
-      clientEvent.isConcurrencyConflict(event.isConcurrencyConflict());
-      clientEvent.setIsRedestroyedEntry(event.getIsRedestroyedEntry());
-    }
+      event.setContext(memberId);
+      // if this is a replayed or WAN operation we may already have a version tag
+      event.setVersionTag(clientEvent.getVersionTag());
+      try {
+        basicDestroy(event, true, // cacheWrite
+            null); // expectedOldValue
+      } catch (ConcurrentCacheModificationException ex) { // thrown by WAN conflicts
+        event.isConcurrencyConflict(true);
+      } finally {
+        clientEvent.setVersionTag(event.getVersionTag());
+        clientEvent.isConcurrencyConflict(event.isConcurrencyConflict());
+        clientEvent.setIsRedestroyedEntry(event.getIsRedestroyedEntry());
+      }
-  
+
-      throws TimeoutException, EntryNotFoundException, CacheWriterException
-  {
+      throws TimeoutException, EntryNotFoundException, CacheWriterException {
-      if(isGatewaySenderEnabled()) {
+      if (isGatewaySenderEnabled()) {
-    @Released final EntryEventImpl event = EntryEventImpl.create(this, Operation.INVALIDATE, key,
-        null /* new value */, callbackArg,
-        false /* origin remote */, memberId.getDistributedMember(),
-        true /* generateCallbacks */,
-        clientEvent.getEventId());
+    @Released
+    final EntryEventImpl event = EntryEventImpl.create(this, Operation.INVALIDATE, key,
+        null /* new value */, callbackArg, false /* origin remote */,
+        memberId.getDistributedMember(), true /* generateCallbacks */, clientEvent.getEventId());
-    event.setContext(memberId);
-    
-    // if this is a replayed operation we may already have a version tag
-    event.setVersionTag(clientEvent.getVersionTag());
+      event.setContext(memberId);
-    try {
-      basicInvalidate(event);
-    } finally {
-      clientEvent.setVersionTag(event.getVersionTag());
-      clientEvent.isConcurrencyConflict(event.isConcurrencyConflict());
-    }
+      // if this is a replayed operation we may already have a version tag
+      event.setVersionTag(clientEvent.getVersionTag());
+
+      try {
+        basicInvalidate(event);
+      } finally {
+        clientEvent.setVersionTag(event.getVersionTag());
+        clientEvent.isConcurrencyConflict(event.isConcurrencyConflict());
+      }
- 
+
-    @Released EntryEventImpl event = EntryEventImpl.create(this, Operation.UPDATE_VERSION_STAMP, key,
-        null /* new value */, null /*callbackArg*/,
-        false /* origin remote */, memberId.getDistributedMember(),
-        false /* generateCallbacks */,
-        clientEvent.getEventId());
+    @Released
+    EntryEventImpl event = EntryEventImpl.create(this, Operation.UPDATE_VERSION_STAMP, key,
+        null /* new value */, null /* callbackArg */, false /* origin remote */,
+        memberId.getDistributedMember(), false /* generateCallbacks */, clientEvent.getEventId());
-    
+
-      if(logger.isTraceEnabled(LogMarker.DM)) {
-        logger.trace(LogMarker.DM, "LR.basicDestroy: this cache has already seen this event {}", event);
+      if (logger.isTraceEnabled(LogMarker.DM)) {
+        logger.trace(LogMarker.DM, "LR.basicDestroy: this cache has already seen this event {}",
+            event);
-      if (this.concurrencyChecksEnabled && event.getVersionTag() != null && !event.getVersionTag().isRecorded()) {
-        getVersionVector().recordVersion((InternalDistributedMember) event.getDistributedMember(), event.getVersionTag());
+      if (this.concurrencyChecksEnabled && event.getVersionTag() != null
+          && !event.getVersionTag().isRecorded()) {
+        getVersionVector().recordVersion((InternalDistributedMember) event.getDistributedMember(),
+            event.getVersionTag());
-   * @param event
-   *          the event object for this operation, with the exception that the
-   *          oldValue parameter is not yet filled in. The oldValue will be
-   *          filled in by this operation.
+   * @param event the event object for this operation, with the exception that the oldValue
+   *        parameter is not yet filled in. The oldValue will be filled in by this operation.
-   * @param ifNew
-   *          true if this operation must not overwrite an existing key
-   * @param ifOld
-   *          true if this operation must not create a new entry
-   * @param lastModified
-   *          the lastModified time to set with the value; if 0L, then the
-   *          lastModified time will be set to now.
-   * @param overwriteDestroyed
-   *          true if okay to overwrite the DESTROYED token: when this is true
-   *          has the following effect: even when ifNew is true will write over
-   *          DESTROYED token when overwriteDestroyed is false and ifNew or
-   *          ifOld is true then if the put doesn't occur because there is a
-   *          DESTROYED token present then the entry flag blockedDestroyed is
-   *          set.
-   * @return false if ifNew is true and there is an existing key, or ifOld is
-   *         true and there is no existing entry; otherwise return true.
+   * @param ifNew true if this operation must not overwrite an existing key
+   * @param ifOld true if this operation must not create a new entry
+   * @param lastModified the lastModified time to set with the value; if 0L, then the lastModified
+   *        time will be set to now.
+   * @param overwriteDestroyed true if okay to overwrite the DESTROYED token: when this is true has
+   *        the following effect: even when ifNew is true will write over DESTROYED token when
+   *        overwriteDestroyed is false and ifNew or ifOld is true then if the put doesn't occur
+   *        because there is a DESTROYED token present then the entry flag blockedDestroyed is set.
+   * @return false if ifNew is true and there is an existing key, or ifOld is true and there is no
+   *         existing entry; otherwise return true.
-  final boolean basicUpdate(final EntryEventImpl event, 
-                            final boolean ifNew,
-                            final boolean ifOld,
-                            final long lastModified,
-                            final boolean overwriteDestroyed)
-  throws TimeoutException,
-        CacheWriterException {
+  final boolean basicUpdate(final EntryEventImpl event, final boolean ifNew, final boolean ifOld,
+      final long lastModified, final boolean overwriteDestroyed)
+      throws TimeoutException, CacheWriterException {
-        throw new ClassCastException(LocalizedStrings.LocalRegion_KEY_0_DOES_NOT_SATISFY_KEYCONSTRAINT_1.toLocalizedString(new Object[] {event.getKey().getClass().getName(), this.keyConstraint.getName()}));
+        throw new ClassCastException(
+            LocalizedStrings.LocalRegion_KEY_0_DOES_NOT_SATISFY_KEYCONSTRAINT_1.toLocalizedString(
+                new Object[] {event.getKey().getClass().getName(), this.keyConstraint.getName()}));
-    return getDataView().putEntry(event, ifNew, ifOld, null, false, lastModified, overwriteDestroyed);
+    return getDataView().putEntry(event, ifNew, ifOld, null, false, lastModified,
+        overwriteDestroyed);
-   * @see DistributedRegion#virtualPut(EntryEventImpl, boolean, boolean,
-   *      Object, boolean, long, boolean)
+   * @see DistributedRegion#virtualPut(EntryEventImpl, boolean, boolean, Object, boolean, long,
+   *      boolean)
-  boolean virtualPut(final EntryEventImpl event,
-                     final boolean ifNew,
-                     final boolean ifOld,
-                     Object expectedOldValue,
-                     boolean requireOldValue,
-                     final long lastModified,
-                     final boolean overwriteDestroyed)
-  throws TimeoutException,
-        CacheWriterException {
+  boolean virtualPut(final EntryEventImpl event, final boolean ifNew, final boolean ifOld,
+      Object expectedOldValue, boolean requireOldValue, final long lastModified,
+      final boolean overwriteDestroyed) throws TimeoutException, CacheWriterException {
-    
-    try { 
-      oldEntry = this.entries.basicPut(event,
-                                 lastModified,
-                                 ifNew,
-                                 ifOld,
-                                 expectedOldValue,
-                                 requireOldValue,
-                                 overwriteDestroyed);
+
+    try {
+      oldEntry = this.entries.basicPut(event, lastModified, ifNew, ifOld, expectedOldValue,
+          requireOldValue, overwriteDestroyed);
-      if(logger.isDebugEnabled()) {
+      if (logger.isDebugEnabled()) {
-    
+
-  
+
+   * 
-    if (! alreadyCheckedThreshold && !evi.isOriginRemote()) {
+    if (!alreadyCheckedThreshold && !evi.isOriginRemote()) {
-  
+
-   * Checks to see if the event should be rejected because of sick state either due to
-   * exceeding local critical threshold or a remote member exceeding critical threshold 
+   * Checks to see if the event should be rejected because of sick state either due to exceeding
+   * local critical threshold or a remote member exceeding critical threshold
+   * 
-  private void checkIfAboveThreshold(final Object key) throws LowMemoryException{
+  private void checkIfAboveThreshold(final Object key) throws LowMemoryException {
-      // #45603: trigger a background eviction since we're above the the critical 
+      // #45603: trigger a background eviction since we're above the the critical
-      InternalResourceManager.getInternalResourceManager(cache).getHeapMonitor().updateStateAndSendEvent();
+      InternalResourceManager.getInternalResourceManager(cache).getHeapMonitor()
+          .updateStateAndSendEvent();
-      throw new LowMemoryException(LocalizedStrings.ResourceManager_LOW_MEMORY_IN_0_FOR_PUT_1_MEMBER_2.toLocalizedString(prms),
+      throw new LowMemoryException(
+          LocalizedStrings.ResourceManager_LOW_MEMORY_IN_0_FOR_PUT_1_MEMBER_2
+              .toLocalizedString(prms),
-  
+
-  /*public Object putNoCallbacks(Object key, Object value) {
-    EntryEventImpl event = new EntryEventImpl(
-        this, Operation.UPDATE, key,
-        value,
-        nullcallbackobj, false,
-        getMyId(),
-        true, true);
-    event.setNewEventId(getCache().getDistributedSystem());
-    boolean didPut = this.entries.basicPut(event, System.currentTimeMillis(),
-        false, false, true, false) != null;
-    if (didPut) {
-      return event.getOldValue();
-    }
-    else {
-      return null;
-    }
-  }*/
+  /*
+   * public Object putNoCallbacks(Object key, Object value) { EntryEventImpl event = new
+   * EntryEventImpl( this, Operation.UPDATE, key, value, nullcallbackobj, false, getMyId(), true,
+   * true); event.setNewEventId(getCache().getDistributedSystem()); boolean didPut =
+   * this.entries.basicPut(event, System.currentTimeMillis(), false, false, true, false) != null; if
+   * (didPut) { return event.getOldValue(); } else { return null; } }
+   */
-   * @param event
-   *          the event object for this operation, with the exception that the
-   *          oldValue parameter is not yet filled in. The oldValue will be
-   *          filled in by this operation.
-   * @param lastModified
-   *          the lastModified time to set with the value; if 0L then the
-   *          lastModified time will be set to now.
+   * @param event the event object for this operation, with the exception that the oldValue
+   *        parameter is not yet filled in. The oldValue will be filled in by this operation.
+   * @param lastModified the lastModified time to set with the value; if 0L then the lastModified
+   *        time will be set to now.
-  protected RegionEntry basicPutEntry(final EntryEventImpl event,
-                                            final long lastModified)
-  throws TimeoutException, CacheWriterException {
+  protected RegionEntry basicPutEntry(final EntryEventImpl event, final long lastModified)
+      throws TimeoutException, CacheWriterException {
-    }
-    else {
+    } else {
-      
-      RegionEntry oldEntry = this.entries.basicPut(event,
-                                   lastModified,
-                                   ifNew,
-                                   false,  // ifOld
-                                   null,   // expectedOldValue
-                                   false,  // requireOldValue
-                                   false); // overwriteDestroyed
+
+      RegionEntry oldEntry = this.entries.basicPut(event, lastModified, ifNew, false, // ifOld
+          null, // expectedOldValue
+          false, // requireOldValue
+          false); // overwriteDestroyed
-  protected long basicPutPart2(EntryEventImpl event, RegionEntry entry,
-      boolean isInitialized, long lastModified,
-      boolean clearConflict)
-  {
+  protected long basicPutPart2(EntryEventImpl event, RegionEntry entry, boolean isInitialized,
+      long lastModified, boolean clearConflict) {
-    //Invoke callbacks only if we are not creating a tombstone
+    // Invoke callbacks only if we are not creating a tombstone
-                isNewKey ? IndexManager.ADD_ENTRY :
-                  IndexManager.UPDATE_ENTRY,
-                  isNewKey ? IndexProtocol.OTHER_OP :
-                    IndexProtocol.AFTER_UPDATE_OP);
+                isNewKey ? IndexManager.ADD_ENTRY : IndexManager.UPDATE_ENTRY,
+                isNewKey ? IndexProtocol.OTHER_OP : IndexProtocol.AFTER_UPDATE_OP);
-        }
-        catch (QueryException e) {
+        } catch (QueryException e) {
-      }
-      else if (this.isUsedForPartitionedRegionBucket) {
+      } else if (this.isUsedForPartitionedRegionBucket) {
-        notifyGatewaySender(event.getOperation().isUpdate()? EnumListenerEvent.AFTER_UPDATE
-                                             : EnumListenerEvent.AFTER_CREATE, event);
+        notifyGatewaySender(event.getOperation().isUpdate() ? EnumListenerEvent.AFTER_UPDATE
+            : EnumListenerEvent.AFTER_CREATE, event);
-          }
-          catch (InterruptedException ie) {
+          } catch (InterruptedException ie) {
-   * To lower latency, PRs generate the local filter rounting in
-   * DistributedCacheOperation after message distribution and before waiting for
-   * responses.
+   * To lower latency, PRs generate the local filter rounting in DistributedCacheOperation after
+   * message distribution and before waiting for responses.
-   * Warning: Even if you comment out bucket condition in following method,
-   * getLocalRountingInfo() does NOT process CQs for bucket regions internally.
-   * Check
-   * {@link FilterProfile#getFilterRoutingInfoPart2(FilterRoutingInfo, CacheEvent)}
-   * .
+   * Warning: Even if you comment out bucket condition in following method, getLocalRountingInfo()
+   * does NOT process CQs for bucket regions internally. Check
+   * {@link FilterProfile#getFilterRoutingInfoPart2(FilterRoutingInfo, CacheEvent)} .
-    EntryEventImpl entryEvent = isEntryEvent? (EntryEventImpl)event : null;
-    
+    EntryEventImpl entryEvent = isEntryEvent ? (EntryEventImpl) event : null;
+
-        if(logger.isDebugEnabled()) {
+        if (logger.isDebugEnabled()) {
-        synchronized(re) {
+        synchronized (re) {
-    if (routing != null  &&  event.getOperation().isEntry()
-        &&  ((EntryEventImpl)event).isConcurrencyConflict()) {
-      if(logger.isDebugEnabled()) {
+    if (routing != null && event.getOperation().isEntry()
+        && ((EntryEventImpl) event).isConcurrencyConflict()) {
+      if (logger.isDebugEnabled()) {
-    
+
-    
-    
+
+
-      BucketRegion br = (BucketRegion)event.getRegion();
+      BucketRegion br = (BucketRegion) event.getRegion();
-   
+
-      
+
-  public void basicPutPart3(EntryEventImpl event, RegionEntry entry,
-      boolean isInitialized, long lastModified, boolean invokeCallbacks,
-      boolean ifNew, boolean ifOld, Object expectedOldValue,
-      boolean requireOldValue)
-  {
+  public void basicPutPart3(EntryEventImpl event, RegionEntry entry, boolean isInitialized,
+      long lastModified, boolean invokeCallbacks, boolean ifNew, boolean ifOld,
+      Object expectedOldValue, boolean requireOldValue) {
-  public void invokePutCallbacks(final EnumListenerEvent eventType,
-      final EntryEventImpl event, final boolean callDispatchListenerEvent, boolean notifyGateways) {
+  public void invokePutCallbacks(final EnumListenerEvent eventType, final EntryEventImpl event,
+      final boolean callDispatchListenerEvent, boolean notifyGateways) {
-    
+
-    if(callDispatchListenerEvent){
+    if (callDispatchListenerEvent) {
-  protected void postUpdate(EntryEventImpl event, long lastModifiedTime)
-  {
-  }
-  
+  protected void postUpdate(EntryEventImpl event, long lastModifiedTime) {}
+
-   * retrieve a deep copy of the Region's event state.  This is used
-   * for getInitialImage.  The result is installed in the receiver of
-   * the image.
+   * retrieve a deep copy of the Region's event state. This is used for getInitialImage. The result
+   * is installed in the receiver of the image.
-    }
-    else {
+    } else {
-  
+
-   * Record the event state encapsulated in the given Map.<p>
+   * Record the event state encapsulated in the given Map.
+   * <p>
+   * 
-  
+
+   * 
-      EntryEventImpl entryEvent = (EntryEventImpl)event;
+      EntryEventImpl entryEvent = (EntryEventImpl) event;
-            && !this.scope.isDistributedNoAck()
-            && entryEvent.getDeltaBytes() != null);
+            && !this.scope.isDistributedNoAck() && entryEvent.getDeltaBytes() != null);
-        if(logger.isDebugEnabled()) {
+        if (logger.isDebugEnabled()) {
+   * 
-  
+
+   * 
-   public boolean hasSeenEvent(EntryEventImpl event) {
-     boolean isDup = false;
-     if (this.eventTracker != null) {
-       // bug 41289 - wait for event tracker to be initialized before checkin
-       // so that an operation inteded for a previous version of a bucket
-       // is not prematurely applied to a new version of the bucket
-       if (this.isUsedForPartitionedRegionBucket()) {
-         try {
-           this.eventTracker.waitOnInitialization();
-         } catch (InterruptedException ie) {
-           this.stopper.checkCancelInProgress(ie);
-           Thread.currentThread().interrupt();
-         }
-       }
-       isDup = this.eventTracker.hasSeenEvent(event);
-       if (isDup) {
-         event.setPossibleDuplicate(true);
-         if (this.concurrencyChecksEnabled && event.getVersionTag() == null) {
-           event.setVersionTag(findVersionTagForClientEvent(event.getEventId()));
-         }
-       } else {
-         // bug #48205 - a retried PR operation may already have a version assigned to it
-         // in another VM 
-         if (event.isPossibleDuplicate()
-             && event.getRegion().concurrencyChecksEnabled
-             && (event.getVersionTag() == null)
-             && (event.getEventId() != null)) {
-           boolean isBulkOp = event.getOperation().isPutAll() || event.getOperation().isRemoveAll();
-           VersionTag tag = FindVersionTagOperation.findVersionTag(event.getRegion(), event.getEventId(), isBulkOp);
-           event.setVersionTag(tag);
-         }
-       }
-     } 
-     return isDup;
-   }
-   
-   /**
-    * tries to find the version tag for a replayed client event
-    * @param eventId
-    * @return the version tag, if known.  Null if not
-    */
-   public VersionTag findVersionTagForClientEvent(EventID eventId) {
-     if (this.eventTracker != null) {
-       return this.eventTracker.findVersionTag(eventId);
-     }
-     return null;
-   }
-   
-   public VersionTag findVersionTagForGatewayEvent(EventID eventId) {
-     if (this.eventTracker != null) {
-       return this.eventTracker.findVersionTagForGateway(eventId);
-     }
-     return null;
-   }
-   
-   /**
-    * tries to find the version tag for a replayed client event
-    * @param eventId
-    * @return the version tag, if known.  Null if not
-    */
-   public VersionTag findVersionTagForClientBulkOp(EventID eventId) {
-     if (eventId == null) {
-       return null;
-     }
-     if (this.eventTracker != null) {
-       return this.eventTracker.findVersionTagForBulkOp(eventId);
-     }
-     return null;
-   }
-
-   /**
-    * has the Region's event state seen this event?  Most checks should use
-    * the method that takes an Event, not an ID, but with transactions we
-    * do not have an event at the time the check needs to be made.  Consequently,
-    * this method may cause events to be recorded that would otherwise be
-    * ignored.
-    * @param eventID the identifier of the event
-    * @return true if the Region's event state has seen the event
-    */
-    public boolean hasSeenEvent(EventID eventID) {
-      if (eventID == null) {
-        return false;
-      }
-      boolean isDup = false;
-      if (this.eventTracker != null) {
-        // bug 41289 - wait for event tracker to be initialized before checkin
-        // so that an operation intended for a previous version of a bucket
-        // is not prematurely applied to a new version of the bucket
-        if (this.isUsedForPartitionedRegionBucket()) {
-          try {
-            this.eventTracker.waitOnInitialization();
-          } catch (InterruptedException ie) {
-            this.stopper.checkCancelInProgress(ie);
-            Thread.currentThread().interrupt();
-          }
+  public boolean hasSeenEvent(EntryEventImpl event) {
+    boolean isDup = false;
+    if (this.eventTracker != null) {
+      // bug 41289 - wait for event tracker to be initialized before checkin
+      // so that an operation inteded for a previous version of a bucket
+      // is not prematurely applied to a new version of the bucket
+      if (this.isUsedForPartitionedRegionBucket()) {
+        try {
+          this.eventTracker.waitOnInitialization();
+        } catch (InterruptedException ie) {
+          this.stopper.checkCancelInProgress(ie);
+          Thread.currentThread().interrupt();
-        isDup = this.eventTracker.hasSeenEvent(eventID, null);
-      } 
-      return isDup;
+      }
+      isDup = this.eventTracker.hasSeenEvent(event);
+      if (isDup) {
+        event.setPossibleDuplicate(true);
+        if (this.concurrencyChecksEnabled && event.getVersionTag() == null) {
+          event.setVersionTag(findVersionTagForClientEvent(event.getEventId()));
+        }
+      } else {
+        // bug #48205 - a retried PR operation may already have a version assigned to it
+        // in another VM
+        if (event.isPossibleDuplicate() && event.getRegion().concurrencyChecksEnabled
+            && (event.getVersionTag() == null) && (event.getEventId() != null)) {
+          boolean isBulkOp = event.getOperation().isPutAll() || event.getOperation().isRemoveAll();
+          VersionTag tag = FindVersionTagOperation.findVersionTag(event.getRegion(),
+              event.getEventId(), isBulkOp);
+          event.setVersionTag(tag);
+        }
+      }
+    return isDup;
+  }
-   * A routine to provide synchronization running based on <memberShipID, threadID> 
-   * of the requesting client for the region's event state
+   * tries to find the version tag for a replayed client event
+   * 
+   * @param eventId
+   * @return the version tag, if known. Null if not
+   */
+  public VersionTag findVersionTagForClientEvent(EventID eventId) {
+    if (this.eventTracker != null) {
+      return this.eventTracker.findVersionTag(eventId);
+    }
+    return null;
+  }
+
+  public VersionTag findVersionTagForGatewayEvent(EventID eventId) {
+    if (this.eventTracker != null) {
+      return this.eventTracker.findVersionTagForGateway(eventId);
+    }
+    return null;
+  }
+
+  /**
+   * tries to find the version tag for a replayed client event
+   * 
+   * @param eventId
+   * @return the version tag, if known. Null if not
+   */
+  public VersionTag findVersionTagForClientBulkOp(EventID eventId) {
+    if (eventId == null) {
+      return null;
+    }
+    if (this.eventTracker != null) {
+      return this.eventTracker.findVersionTagForBulkOp(eventId);
+    }
+    return null;
+  }
+
+  /**
+   * has the Region's event state seen this event? Most checks should use the method that takes an
+   * Event, not an ID, but with transactions we do not have an event at the time the check needs to
+   * be made. Consequently, this method may cause events to be recorded that would otherwise be
+   * ignored.
+   * 
+   * @param eventID the identifier of the event
+   * @return true if the Region's event state has seen the event
+   */
+  public boolean hasSeenEvent(EventID eventID) {
+    if (eventID == null) {
+      return false;
+    }
+    boolean isDup = false;
+    if (this.eventTracker != null) {
+      // bug 41289 - wait for event tracker to be initialized before checkin
+      // so that an operation intended for a previous version of a bucket
+      // is not prematurely applied to a new version of the bucket
+      if (this.isUsedForPartitionedRegionBucket()) {
+        try {
+          this.eventTracker.waitOnInitialization();
+        } catch (InterruptedException ie) {
+          this.stopper.checkCancelInProgress(ie);
+          Thread.currentThread().interrupt();
+        }
+      }
+      isDup = this.eventTracker.hasSeenEvent(eventID, null);
+    }
+    return isDup;
+  }
+
+  /**
+   * A routine to provide synchronization running based on <memberShipID, threadID> of the
+   * requesting client for the region's event state
+   * 
-    }
-    else {
+    } else {
-  
+
-  
-  final protected void notifyBridgeClients(CacheEvent event)
-  {
+
+  final protected void notifyBridgeClients(CacheEvent event) {
-      if (((EntryEventImpl)event).inhibitAllNotifications()) {
-        if(logger.isDebugEnabled()) {
+      if (((EntryEventImpl) event).inhibitAllNotifications()) {
+        if (logger.isDebugEnabled()) {
-        if(logger.isDebugEnabled()) {
-          logger.debug("{}: notifying {} bridge servers of event: {}", this.getName(), numBS, event);
+        if (logger.isDebugEnabled()) {
+          logger.debug("{}: notifying {} bridge servers of event: {}", this.getName(), numBS,
+              event);
-      
+
-        EntryEventImpl e = (EntryEventImpl)event;
+        EntryEventImpl e = (EntryEventImpl) event;
-      InternalCacheEvent ice = (InternalCacheEvent)event;
+      InternalCacheEvent ice = (InternalCacheEvent) event;
-      CacheClientNotifier.notifyClients((InternalCacheEvent)event);
+      CacheClientNotifier.notifyClients((InternalCacheEvent) event);
-  
-  protected void notifyGatewaySender(EnumListenerEvent operation,
-      EntryEventImpl event) {
-    
-    if (isPdxTypesRegion() || event.isConcurrencyConflict() /* usually concurrent cache modification problem */) { 
+
+  protected void notifyGatewaySender(EnumListenerEvent operation, EntryEventImpl event) {
+
+    if (isPdxTypesRegion()
+        || event.isConcurrencyConflict() /* usually concurrent cache modification problem */) {
-    if (event.inhibitAllNotifications()){
-      if(logger.isDebugEnabled()) {
+    if (event.inhibitAllNotifications()) {
+      if (logger.isDebugEnabled()) {
-    
-    
+
+
-          //TODO: This is a BUG. Why return and not continue?
-          if((!this.getDataPolicy().withStorage()) && sender.isParallel()){
+          // TODO: This is a BUG. Why return and not continue?
+          if ((!this.getDataPolicy().withStorage()) && sender.isParallel()) {
-          if(logger.isDebugEnabled()) {
+          if (logger.isDebugEnabled()) {
-          ((AbstractGatewaySender)sender).distribute(operation, event,
-              allRemoteDSIds);
+          ((AbstractGatewaySender) sender).distribute(operation, event, allRemoteDSIds);
-      
-//      if (shouldNotifyGatewaySender()) {
-//        // Get All WAN site DSID's to be sent to each WAN site so that they
-//        // don't redistribute it to same WAN sites again again (infinite loop).
-//        if (!this.getName().equals(PeerTypeRegistration.REGION_NAME)) { //This is for all region except pdx Region
-//          for (GatewaySender sender : getCache().getAllGatewaySenders()) {
-//            if (allGatewaySenderIds.contains(sender.getId())) { //Make sure we are distributing to only those senders whose id is avaialble on this region
-//              if(this.partitionAttributes == null && sender.isParallel()){ //ParalleGatewaySender with DR is not allowed
-//                throw new IllegalStateException(
-//                    LocalizedStrings.AttributesFactory_PARALLELGATEWAYSENDER_0_IS_INCOMPATIBLE_WITH_DISTRIBUTED_REPLICATION
-//                        .toLocalizedString(sender.getId()));
-//              }
-//              if (allRemoteDSIds == null) {
-//                allRemoteDSIds = new ArrayList<Integer>();
-//              }
-//              allRemoteDSIds.add(sender.getRemoteDSId());
-//            }
-//            else { //this else is for PDX region    
-//              if (allRemoteDSIds == null) {
-//                allRemoteDSIds = new ArrayList<Integer>();
-//              }
-//              allRemoteDSIds.add(sender.getRemoteDSId());
-//            }
-//          }
-//        }
-//        if (allRemoteDSIds == null) {
-//          allRemoteDSIds = Collections.emptyList();
-//        }
-//        
-//        // Now distribute the event to each WAN site.
-//        if (!this.getName().equals(PeerTypeRegistration.REGION_NAME)) {
-//          for (GatewaySender sender : getCache().getAllGatewaySenders()) {
-//            if (allGatewaySenderIds.contains(sender.getId())) {
-//              if((!this.getDataPolicy().withStorage()) && sender.isParallel()){
-//                return;
-//              }
-//              ((AbstractGatewaySender)sender).distribute(operation, event,
-//                  allRemoteDSIds);
-//            }
-//          }
-//        }
-//      }
+
+      // if (shouldNotifyGatewaySender()) {
+      // // Get All WAN site DSID's to be sent to each WAN site so that they
+      // // don't redistribute it to same WAN sites again again (infinite loop).
+      // if (!this.getName().equals(PeerTypeRegistration.REGION_NAME)) { //This is for all region
+      // except pdx Region
+      // for (GatewaySender sender : getCache().getAllGatewaySenders()) {
+      // if (allGatewaySenderIds.contains(sender.getId())) { //Make sure we are distributing to only
+      // those senders whose id is avaialble on this region
+      // if(this.partitionAttributes == null && sender.isParallel()){ //ParalleGatewaySender with DR
+      // is not allowed
+      // throw new IllegalStateException(
+      // LocalizedStrings.AttributesFactory_PARALLELGATEWAYSENDER_0_IS_INCOMPATIBLE_WITH_DISTRIBUTED_REPLICATION
+      // .toLocalizedString(sender.getId()));
+      // }
+      // if (allRemoteDSIds == null) {
+      // allRemoteDSIds = new ArrayList<Integer>();
+      // }
+      // allRemoteDSIds.add(sender.getRemoteDSId());
+      // }
+      // else { //this else is for PDX region
+      // if (allRemoteDSIds == null) {
+      // allRemoteDSIds = new ArrayList<Integer>();
+      // }
+      // allRemoteDSIds.add(sender.getRemoteDSId());
+      // }
+      // }
+      // }
+      // if (allRemoteDSIds == null) {
+      // allRemoteDSIds = Collections.emptyList();
+      // }
+      //
+      // // Now distribute the event to each WAN site.
+      // if (!this.getName().equals(PeerTypeRegistration.REGION_NAME)) {
+      // for (GatewaySender sender : getCache().getAllGatewaySenders()) {
+      // if (allGatewaySenderIds.contains(sender.getId())) {
+      // if((!this.getDataPolicy().withStorage()) && sender.isParallel()){
+      // return;
+      // }
+      // ((AbstractGatewaySender)sender).distribute(operation, event,
+      // allRemoteDSIds);
+      // }
+      // }
+      // }
+      // }
-  public void checkSameSenderIdsAvailableOnAllNodes() {
-  }
+  public void checkSameSenderIdsAvailableOnAllNodes() {}
+
-   * @param cacheWrite
-   *          if true, then we're just cleaning up the local cache and calling
-   *          listeners,
-   * @see DistributedRegion#basicDestroyRegion(RegionEventImpl, boolean,
-   *      boolean, boolean)
+   * @param cacheWrite if true, then we're just cleaning up the local cache and calling listeners,
+   * @see DistributedRegion#basicDestroyRegion(RegionEventImpl, boolean, boolean, boolean)
-      throws CacheWriterException, TimeoutException
-  {
+      throws CacheWriterException, TimeoutException {
-  void basicDestroyRegion(RegionEventImpl event, boolean cacheWrite,
-      boolean lock, boolean callbackEvents) throws CacheWriterException,
-      TimeoutException
-  {
+  void basicDestroyRegion(RegionEventImpl event, boolean cacheWrite, boolean lock,
+      boolean callbackEvents) throws CacheWriterException, TimeoutException {
-        }
-        catch (CancelException e) {
+        } catch (CancelException e) {
-          if(logger.isDebugEnabled()) {
-            logger.debug("basicDestroyRegion: acquireDestroyLock failed due to cache closure, region = {}", getFullPath());
+          if (logger.isDebugEnabled()) {
+            logger.debug(
+                "basicDestroyRegion: acquireDestroyLock failed due to cache closure, region = {}",
+                getFullPath());
-              && !((PartitionedRegion)this).getParallelGatewaySenderIds()
-                  .isEmpty()) {
-            ((PartitionedRegion)this).destroyParallelGatewaySenderRegion(event.getOperation(),
+              && !((PartitionedRegion) this).getParallelGatewaySenderIds().isEmpty()) {
+            ((PartitionedRegion) this).destroyParallelGatewaySenderRegion(event.getOperation(),
-  
-        
+
+
-          }
-          catch (CancelException e) {
+          } catch (CancelException e) {
-              logger.warn(LocalizedMessage.create(LocalizedStrings.LocalRegion_RECURSIVEDESTROYREGION_RECURSION_FAILED_DUE_TO_CACHE_CLOSURE_REGION_0,
-                getFullPath()), e);
+              logger.warn(LocalizedMessage.create(
+                  LocalizedStrings.LocalRegion_RECURSIVEDESTROYREGION_RECURSION_FAILED_DUE_TO_CACHE_CLOSURE_REGION_0,
+                  getFullPath()), e);
-          
+
-          
+
-           * Added for M&M : At this point we can safely call ResourceEvent
-           * to remove the region artifacts From Management Layer
+           * Added for M&M : At this point we can safely call ResourceEvent to remove the region
+           * artifacts From Management Layer
-            InternalDistributedSystem system = this.cache
-                .getDistributedSystem();
+            InternalDistributedSystem system = this.cache.getDistributedSystem();
-      
+
-            }
-            else {
+            } else {
-          }
-          catch (CancelException e) {
-            // I don't think this should ever happens:  bulletproofing for bug 39454
+          } catch (CancelException e) {
+            // I don't think this should ever happens: bulletproofing for bug 39454
-              logger.warn(LocalizedMessage.create(LocalizedStrings.LocalRegion_BASICDESTROYREGION_PARENT_REMOVAL_FAILED_DUE_TO_CACHE_CLOSURE_REGION_0, 
-                getFullPath()), e);
+              logger.warn(LocalizedMessage.create(
+                  LocalizedStrings.LocalRegion_BASICDESTROYREGION_PARENT_REMOVAL_FAILED_DUE_TO_CACHE_CLOSURE_REGION_0,
+                  getFullPath()), e);
-        }  // ensure that destroy events are dispatched
+        } // ensure that destroy events are dispatched
-            }
-            catch (CancelException e) {
+            } catch (CancelException e) {
-      }  // maintain destroy lock and TXStateInterface
+      } // maintain destroy lock and TXStateInterface
-          }
-          catch (CancelException e) {
+          } catch (CancelException e) {
-    
+
-  protected void distributeDestroyRegion(RegionEventImpl event, boolean notifyOfRegionDeparture) {
-  }
+  protected void distributeDestroyRegion(RegionEventImpl event, boolean notifyOfRegionDeparture) {}
+
-  protected void postCreateRegion()
-  {
+  protected void postCreateRegion() {
-            logWriter.fine("Enabled heap eviction at " + evictionPercentage + " percent for LRU region");
+            logWriter
+                .fine("Enabled heap eviction at " + evictionPercentage + " percent for LRU region");
-            logWriter.fine("Enabled off-heap eviction at " + evictionPercentage + " percent for LRU region");
+            logWriter.fine(
+                "Enabled off-heap eviction at " + evictionPercentage + " percent for LRU region");
-      
+
-      RegionEventImpl event = new RegionEventImpl(this,
-          Operation.REGION_CREATE, null, false, getMyId());
+      RegionEventImpl event =
+          new RegionEventImpl(this, Operation.REGION_CREATE, null, false, getMyId());
-    SystemMemberCacheEventProcessor.send(getCache(), this,
-        Operation.REGION_CREATE);
+    SystemMemberCacheEventProcessor.send(getCache(), this, Operation.REGION_CREATE);
+   * 
-          RegionMembershipListener rml = (RegionMembershipListener)listeners[i];
+          RegionMembershipListener rml = (RegionMembershipListener) listeners[i];
-            DistributedMember[] otherDms = new DistributedMember[others
-                .size()];
+            DistributedMember[] otherDms = new DistributedMember[others.size()];
-          }
-          catch (VirtualMachineError err) {
+          } catch (VirtualMachineError err) {
-            // If this ever returns, rethrow the error.  We're poisoned
+            // If this ever returns, rethrow the error. We're poisoned
-          }
-          catch (Throwable t) {
+          } catch (Throwable t) {
-            // catch VirtualMachineError (see above).  However, there is
+            // catch VirtualMachineError (see above). However, there is
-            logger.error(LocalizedMessage.create(LocalizedStrings.DistributedRegion_EXCEPTION_OCCURRED_IN_REGIONMEMBERSHIPLISTENER), t);
+            logger.error(
+                LocalizedMessage.create(
+                    LocalizedStrings.DistributedRegion_EXCEPTION_OCCURRED_IN_REGIONMEMBERSHIPLISTENER),
+                t);
-  protected void postDestroyRegion(boolean destroyDiskRegion,
-      RegionEventImpl event)
-  {
+  protected void postDestroyRegion(boolean destroyDiskRegion, RegionEventImpl event) {
-      }
-      else {
+      } else {
-   * @param cacheWrite
-   *          true if cacheWrite should be performed or false if cacheWrite
-   *          should not be performed
+   * @param cacheWrite true if cacheWrite should be performed or false if cacheWrite should not be
+   *        performed
-  void basicDestroy(final EntryEventImpl event,
-                       final boolean cacheWrite,
-                       Object expectedOldValue)
-  throws EntryNotFoundException, CacheWriterException, TimeoutException {
-    
+  void basicDestroy(final EntryEventImpl event, final boolean cacheWrite, Object expectedOldValue)
+      throws EntryNotFoundException, CacheWriterException, TimeoutException {
+
-      if(logger.isTraceEnabled(LogMarker.DM)) {
-        logger.trace(LogMarker.DM, "LR.basicDestroy: this cache has already seen this event {}", event);
+      if (logger.isTraceEnabled(LogMarker.DM)) {
+        logger.trace(LogMarker.DM, "LR.basicDestroy: this cache has already seen this event {}",
+            event);
-      if (this.concurrencyChecksEnabled && event.getVersionTag() != null && !event.getVersionTag().isRecorded()) {
-        getVersionVector().recordVersion((InternalDistributedMember) event.getDistributedMember(), event.getVersionTag());
+      if (this.concurrencyChecksEnabled && event.getVersionTag() != null
+          && !event.getVersionTag().isRecorded()) {
+        getVersionVector().recordVersion((InternalDistributedMember) event.getDistributedMember(),
+            event.getVersionTag());
-      // Bug 49449: When client retried and returned with hasSeenEvent for both LR and DR, the server should still 
-      // notifyGatewayHubs even the event could be duplicated in gateway queues1 
+      // Bug 49449: When client retried and returned with hasSeenEvent for both LR and DR, the
+      // server should still
+      // notifyGatewayHubs even the event could be duplicated in gateway queues1
-   * Do the expensive work of discovering an existing JTA transaction
-   * Only needs to be called at Region.Entry entry points e.g. Region.put, Region.invalidate, etc.
+   * Do the expensive work of discovering an existing JTA transaction Only needs to be called at
+   * Region.Entry entry points e.g. Region.put, Region.invalidate, etc.
+   * 
-    if (!isSecret() && !isUsedForPartitionedRegionAdmin()
-        && !isUsedForMetaRegion()) { // prevent internal regions from participating in a TX
+    if (!isSecret() && !isUsedForPartitionedRegionAdmin() && !isUsedForMetaRegion()) { // prevent
+                                                                                       // internal
+                                                                                       // regions
+                                                                                       // from
+                                                                                       // participating
+                                                                                       // in a TX
-   * @param expectedOldValue if this is non-null, only destroy if key exists
-   *        and old value is equal to expectedOldValue
+   * @param expectedOldValue if this is non-null, only destroy if key exists and old value is equal
+   *        to expectedOldValue
-  final boolean mapDestroy(final EntryEventImpl event,
-                     final boolean cacheWrite,
-                     final boolean isEviction,
-                     Object expectedOldValue)
-  throws CacheWriterException, EntryNotFoundException, TimeoutException {
+  final boolean mapDestroy(final EntryEventImpl event, final boolean cacheWrite,
+      final boolean isEviction, Object expectedOldValue)
+      throws CacheWriterException, EntryNotFoundException, TimeoutException {
-  
-  final boolean mapDestroy(final EntryEventImpl event,
-      final boolean cacheWrite,
-      final boolean isEviction,
-      Object expectedOldValue,
-      boolean needTokensForGII,
+
+  final boolean mapDestroy(final EntryEventImpl event, final boolean cacheWrite,
+      final boolean isEviction, Object expectedOldValue, boolean needTokensForGII,
-    //When register interest is in progress ,
+    // When register interest is in progress ,
-    final boolean inRI = !needTokensForGII
-    && !event.isFromRILocalDestroy()
-    && lockRIReadLock();
+    final boolean inRI = !needTokensForGII && !event.isFromRILocalDestroy() && lockRIReadLock();
-      boolean result = this.entries.destroy(event,
-          inTokenMode,
-          needRIDestroyToken,
-          cacheWrite,
-          isEviction,
-          expectedOldValue,
-          removeRecoveredEntry);
+      boolean result = this.entries.destroy(event, inTokenMode, needRIDestroyToken, cacheWrite,
+          isEviction, expectedOldValue, removeRecoveredEntry);
-      if(logger.isDebugEnabled()) {
+      if (logger.isDebugEnabled()) {
-    } catch(DiskAccessException dae) {
+    } catch (DiskAccessException dae) {
-    }
-    finally {
+    } finally {
-   * Return true if dae was caused by a RegionDestroyedException.
-   * This was added for bug 39603.
+   * Return true if dae was caused by a RegionDestroyedException. This was added for bug 39603.
-  
+
-  //Asif:To Fix bug 39079, we are locally destroying the region, the 
-  //destruction takes place here & not at DiskRegion or AbstractOplogDiskRegionEntry level
-  //is to eliminate any possibility of deadlocks ,as it is an entry operation thread
-  //which is implictly closing the region & stopping the Servers 
-   /**
-    * @param dae DiskAccessException encountered by the thread
-    * @param duringInitialization indicates that this exception occurred during
-    * region initialization. Instead of closing the cache here, we rely on the
-    * region initialization to clean things up.
-    * @see DistributedRegion#initialize(InputStream, InternalDistributedMember, InternalRegionArguments)
-    * @see LocalRegion#initialize(InputStream, InternalDistributedMember, InternalRegionArguments)
-    * @see InitialImageOperation#processChunk
-    */
-  final public void handleDiskAccessException(DiskAccessException dae, boolean duringInitialization) {
+
+  // Asif:To Fix bug 39079, we are locally destroying the region, the
+  // destruction takes place here & not at DiskRegion or AbstractOplogDiskRegionEntry level
+  // is to eliminate any possibility of deadlocks ,as it is an entry operation thread
+  // which is implictly closing the region & stopping the Servers
+  /**
+   * @param dae DiskAccessException encountered by the thread
+   * @param duringInitialization indicates that this exception occurred during region
+   *        initialization. Instead of closing the cache here, we rely on the region initialization
+   *        to clean things up.
+   * @see DistributedRegion#initialize(InputStream, InternalDistributedMember,
+   *      InternalRegionArguments)
+   * @see LocalRegion#initialize(InputStream, InternalDistributedMember, InternalRegionArguments)
+   * @see InitialImageOperation#processChunk
+   */
+  final public void handleDiskAccessException(DiskAccessException dae,
+      boolean duringInitialization) {
-    StringId sid = LocalizedStrings.LocalRegion_A_DISKACCESSEXCEPTION_HAS_OCCURED_WHILE_WRITING_TO_THE_DISK_FOR_REGION_0_THE_CACHE_WILL_BE_CLOSED;
+    StringId sid =
+        LocalizedStrings.LocalRegion_A_DISKACCESSEXCEPTION_HAS_OCCURED_WHILE_WRITING_TO_THE_DISK_FOR_REGION_0_THE_CACHE_WILL_BE_CLOSED;
-  
-  void expireDestroy(final EntryEventImpl event,
-      final boolean cacheWrite) {
+
+  void expireDestroy(final EntryEventImpl event, final boolean cacheWrite) {
-  
+
-   * Creates an event for EVICT_DESTROY operations.
-   * It is intended that this method be overridden to allow for special 
-   * handling of Partitioned Regions.
-   * @param key - the key that this event is related to 
+   * Creates an event for EVICT_DESTROY operations. It is intended that this method be overridden to
+   * allow for special handling of Partitioned Regions.
+   * 
+   * @param key - the key that this event is related to
-    @Retained EntryEventImpl event = EntryEventImpl.create(
-        this, Operation.EVICT_DESTROY, key, null/* newValue */,
-        null, false, getMyId());
+    @Retained
+    EntryEventImpl event = EntryEventImpl.create(this, Operation.EVICT_DESTROY, key,
+        null/* newValue */, null, false, getMyId());
+
-  boolean evictDestroy(LRUEntry entry)
-  {
-    
+  boolean evictDestroy(LRUEntry entry) {
+
-    @Released final EntryEventImpl event = 
-          generateEvictDestroyEvent(entry.getKey());
+    @Released
+    final EntryEventImpl event = generateEvictDestroyEvent(entry.getKey());
-      return mapDestroy(event,
-                        false, // cacheWrite
-                        true,  // isEviction
-                        null); // expectedOldValue
-    }
-    catch (CacheWriterException error) {
-      throw new Error(LocalizedStrings.LocalRegion_CACHE_WRITER_SHOULD_NOT_HAVE_BEEN_CALLED_FOR_EVICTDESTROY.toLocalizedString(), error);
-    }
-    catch (TimeoutException anotherError) {
-      throw new Error(LocalizedStrings.LocalRegion_NO_DISTRIBUTED_LOCK_SHOULD_HAVE_BEEN_ATTEMPTED_FOR_EVICTDESTROY.toLocalizedString(), anotherError);
-    }
-    catch (EntryNotFoundException yetAnotherError) {
-      throw new Error(LocalizedStrings.LocalRegion_ENTRYNOTFOUNDEXCEPTION_SHOULD_BE_MASKED_FOR_EVICTDESTROY.toLocalizedString(), yetAnotherError);
+      return mapDestroy(event, false, // cacheWrite
+          true, // isEviction
+          null); // expectedOldValue
+    } catch (CacheWriterException error) {
+      throw new Error(
+          LocalizedStrings.LocalRegion_CACHE_WRITER_SHOULD_NOT_HAVE_BEEN_CALLED_FOR_EVICTDESTROY
+              .toLocalizedString(),
+          error);
+    } catch (TimeoutException anotherError) {
+      throw new Error(
+          LocalizedStrings.LocalRegion_NO_DISTRIBUTED_LOCK_SHOULD_HAVE_BEEN_ATTEMPTED_FOR_EVICTDESTROY
+              .toLocalizedString(),
+          anotherError);
+    } catch (EntryNotFoundException yetAnotherError) {
+      throw new Error(
+          LocalizedStrings.LocalRegion_ENTRYNOTFOUNDEXCEPTION_SHOULD_BE_MASKED_FOR_EVICTDESTROY
+              .toLocalizedString(),
+          yetAnotherError);
-   * Called by lower levels {@link AbstractRegionMap} while holding the entry
-   * synchronization <bold>and</bold> while the entry remains in the map. Once
-   * the entry is removed from the map, then other operations synchronize on a
-   * new entry, allow for ordering problems between
-   * {@link #create(Object, Object, Object)} and
-   * {@link #destroy(Object, Object)} operations.
+   * Called by lower levels {@link AbstractRegionMap} while holding the entry synchronization
+   * <bold>and</bold> while the entry remains in the map. Once the entry is removed from the map,
+   * then other operations synchronize on a new entry, allow for ordering problems between
+   * {@link #create(Object, Object, Object)} and {@link #destroy(Object, Object)} operations.
-   * @param event
-   *          the event describing the destroy operation
+   * @param event the event describing the destroy operation
-  protected void basicDestroyBeforeRemoval(RegionEntry entry, EntryEventImpl event)
-  {
-  }
+  protected void basicDestroyBeforeRemoval(RegionEntry entry, EntryEventImpl event) {}
-   * Called by lower levels, while still holding the write sync lock, and the
-   * low level has completed its part of the basic destroy
+   * Called by lower levels, while still holding the write sync lock, and the low level has
+   * completed its part of the basic destroy
-  void basicDestroyPart2(RegionEntry re, EntryEventImpl event,
-      boolean inTokenMode, boolean conflictWithClear, boolean duringRI, boolean invokeCallbacks)
-  {
+  void basicDestroyPart2(RegionEntry re, EntryEventImpl event, boolean inTokenMode,
+      boolean conflictWithClear, boolean duringRI, boolean invokeCallbacks) {
-     * destroys that are not part of the cleaning out of keys prior to a register-interest
-     * are marked with Tombstones instead of Destroyed tokens so that they are not
-     * reaped after the RI completes.  RI does not create Tombstones because it
-     * would flood the TombstoneService with unnecessary work.
+     * destroys that are not part of the cleaning out of keys prior to a register-interest are
+     * marked with Tombstones instead of Destroyed tokens so that they are not reaped after the RI
+     * completes. RI does not create Tombstones because it would flood the TombstoneService with
+     * unnecessary work.
-    }
-    else {
+    } else {
-    /* this is too late to do index maintenance with a CompactRangeIndex
-    because we need to have the old value still intact. At this point
-    the old value has already be replaced with a destroyed token.
-    if (!isProxy() && !conflictWithClear) {
-      if (this.indexManager != null) {
-        try {
-          this.indexManager.updateIndexes(re, IndexManager.REMOVE_ENTRY);
-        }
-        catch (QueryException e) {
-          throw new IndexMaintenanceException(e);
-        }
-      }
-    }*/
+    /*
+     * this is too late to do index maintenance with a CompactRangeIndex because we need to have the
+     * old value still intact. At this point the old value has already be replaced with a destroyed
+     * token. if (!isProxy() && !conflictWithClear) { if (this.indexManager != null) { try {
+     * this.indexManager.updateIndexes(re, IndexManager.REMOVE_ENTRY); } catch (QueryException e) {
+     * throw new IndexMaintenanceException(e); } } }
+     */
-    
+
-        }
-        catch (InterruptedException ie) {
+        } catch (InterruptedException ie) {
-   * distribution and callback notification are done in part2 inside
-   * entry lock for maintaining the order of events.
+   * distribution and callback notification are done in part2 inside entry lock for maintaining the
+   * order of events.
-  void basicDestroyPart3(RegionEntry re, EntryEventImpl event,
-      boolean inTokenMode, boolean duringRI, boolean invokeCallbacks,
-      Object expectedOldValue) {
+  void basicDestroyPart3(RegionEntry re, EntryEventImpl event, boolean inTokenMode,
+      boolean duringRI, boolean invokeCallbacks, Object expectedOldValue) {
-    
+
-  
-  //Asif : This method will clear the tranxnl entries
-  final void txClearRegion()
-  {
+
+  // Asif : This method will clear the tranxnl entries
+  final void txClearRegion() {
-  public void invokeDestroyCallbacks(final EnumListenerEvent eventType,
-      final EntryEventImpl event , final boolean callDispatchListenerEvent, boolean notifyGateways)
-  {
+  public void invokeDestroyCallbacks(final EnumListenerEvent eventType, final EntryEventImpl event,
+      final boolean callDispatchListenerEvent, boolean notifyGateways) {
-    if(callDispatchListenerEvent){
+    if (callDispatchListenerEvent) {
-  
-  
-  public void invokeTXCallbacks(final EnumListenerEvent eventType,
-      final EntryEventImpl event , final boolean callDispatchListenerEvent)
-  {
+
+
+  public void invokeTXCallbacks(final EnumListenerEvent eventType, final EntryEventImpl event,
+      final boolean callDispatchListenerEvent) {
-    
+
-    
+
-    if (callDispatchListenerEvent){
-      if (event.getInvokePRCallbacks() || (!(event.getRegion() instanceof PartitionedRegion) && !(event.getRegion().isUsedForPartitionedRegionBucket()))) {
+    if (callDispatchListenerEvent) {
+      if (event.getInvokePRCallbacks() || (!(event.getRegion() instanceof PartitionedRegion)
+          && !(event.getRegion().isUsedForPartitionedRegionBucket()))) {
-  
+
-   * @param key
-   *          the key of the entry to destroy
-   * @param rmtOrigin
-   *          true if transaction being applied had a remote origin
-   * @param event
-   *          filled in if operation performed
-   * @param needTokensForGII
-   *          true if caller has determined we are in destroy token mode and
-   *          will keep us in that mode while this call is executing.
-   * @param filterRoutingInfo 
-   * @param bridgeContext 
+   * @param key the key of the entry to destroy
+   * @param rmtOrigin true if transaction being applied had a remote origin
+   * @param event filled in if operation performed
+   * @param needTokensForGII true if caller has determined we are in destroy token mode and will
+   *        keep us in that mode while this call is executing.
+   * @param filterRoutingInfo
+   * @param bridgeContext
-  final void txApplyDestroy(Object key, TransactionId rmtOrigin,
-      TXRmtEvent event, boolean needTokensForGII, Operation op, 
-      EventID eventId, Object aCallbackArgument,List<EntryEventImpl> pendingCallbacks,
-      FilterRoutingInfo filterRoutingInfo, ClientProxyMembershipID bridgeContext,
-      boolean isOriginRemote, TXEntryState txEntryState, VersionTag versionTag, long tailKey)
-  {
+  final void txApplyDestroy(Object key, TransactionId rmtOrigin, TXRmtEvent event,
+      boolean needTokensForGII, Operation op, EventID eventId, Object aCallbackArgument,
+      List<EntryEventImpl> pendingCallbacks, FilterRoutingInfo filterRoutingInfo,
+      ClientProxyMembershipID bridgeContext, boolean isOriginRemote, TXEntryState txEntryState,
+      VersionTag versionTag, long tailKey) {
-      this.entries.txApplyDestroy(key, rmtOrigin, event, inTokenMode,  needRIDestroyToken,
-        op, eventId, aCallbackArgument,pendingCallbacks,filterRoutingInfo,bridgeContext, isOriginRemote, txEntryState, versionTag, tailKey);
+      this.entries.txApplyDestroy(key, rmtOrigin, event, inTokenMode, needRIDestroyToken, op,
+          eventId, aCallbackArgument, pendingCallbacks, filterRoutingInfo, bridgeContext,
+          isOriginRemote, txEntryState, versionTag, tailKey);
-   * Called by lower levels, while still holding the write sync lock, and the
-   * low level has completed its part of the basic destroy
+   * Called by lower levels, while still holding the write sync lock, and the low level has
+   * completed its part of the basic destroy
-  void txApplyDestroyPart2(RegionEntry re, Object key, boolean inTokenMode, boolean clearConflict)
-  {
+  void txApplyDestroyPart2(RegionEntry re, Object key, boolean inTokenMode, boolean clearConflict) {
-    }
-    else {
+    } else {
-  void basicInvalidateRegion(RegionEventImpl event)
-  {
+  void basicInvalidateRegion(RegionEventImpl event) {
-        LocalRegion rgn = (LocalRegion)itr.next();
+        LocalRegion rgn = (LocalRegion) itr.next();
-            RegionEventImpl event2 = (RegionEventImpl)event.clone();
+            RegionEventImpl event2 = (RegionEventImpl) event.clone();
-            rgn.dispatchListenerEvent(
-                EnumListenerEvent.AFTER_REGION_INVALIDATE, event2);
+            rgn.dispatchListenerEvent(EnumListenerEvent.AFTER_REGION_INVALIDATE, event2);
-        }
-        catch (RegionDestroyedException ignore) {
+        } catch (RegionDestroyedException ignore) {
-    }
-    finally {
+    } finally {
-   * Determines whether the receiver is unexpired with regard to the given
-   * timeToLive and idleTime attributes, which may different from this entry's
-   * actual attributes. Used for validation of objects during netSearch(), which
-   * must validate remote entries against local timeout attributes.
+   * Determines whether the receiver is unexpired with regard to the given timeToLive and idleTime
+   * attributes, which may different from this entry's actual attributes. Used for validation of
+   * objects during netSearch(), which must validate remote entries against local timeout
+   * attributes.
-  boolean isExpiredWithRegardTo(Object key, int ttl, int idleTime)
-  {
+  boolean isExpiredWithRegardTo(Object key, int ttl, int idleTime) {
-      expTime = (new NetSearchExpirationCalculator(this, key, ttl, idleTime))
-          .getExpirationTime();
-    }
-    catch (EntryNotFoundException ex) {
+      expTime = (new NetSearchExpirationCalculator(this, key, ttl, idleTime)).getExpirationTime();
+    } catch (EntryNotFoundException ex) {
-  void dispatchListenerEvent(EnumListenerEvent op, InternalCacheEvent event)
-  {
+  void dispatchListenerEvent(EnumListenerEvent op, InternalCacheEvent event) {
-      if (((EntryEventImpl)event).inhibitAllNotifications()){
+      if (((EntryEventImpl) event).inhibitAllNotifications()) {
-    
+
-      //Assert.assertTrue(event.getRegion() == this);
+      // Assert.assertTrue(event.getRegion() == this);
-      
+
-          if (((EntryEventImpl)event).isSingleHop()) {
+          if (((EntryEventImpl) event).isSingleHop()) {
-            ((EntryEventImpl)event).setOriginRemote(true);
+            ((EntryEventImpl) event).setOriginRemote(true);
-            ((EntryEventImpl) event).getRegionEntry()
-                .setCacheListenerInvocationInProgress(true);
+            ((EntryEventImpl) event).getRegionEntry().setCacheListenerInvocationInProgress(true);
-        
+
-        }
-        else {
+        } else {
-          }
-          catch (RejectedExecutionException rex) {
+          } catch (RejectedExecutionException rex) {
-      }
-      finally {
+      } finally {
-          ((EntryEventImpl)event).setOriginRemote(origOriginRemote);
+          ((EntryEventImpl) event).setOriginRemote(origOriginRemote);
-              re.setCacheListenerInvocationInProgress(false);
+            re.setCacheListenerInvocationInProgress(false);
-  
+
-  public boolean isInitialized()
-  {
+  public boolean isInitialized() {
-    }
-    else {
+    } else {
-      }
-      else {
+      } else {
-  
+
-   * @return true if event state has been transfered to this region
-   *         from another cache
+   * @return true if event state has been transfered to this region from another cache
-  
+
-  public void acquireDestroyLock()
-  {
+  public void acquireDestroyLock() {
-      }
-      catch (InterruptedException ie) {
+      } catch (InterruptedException ie) {
-      }
-      finally {
+      } finally {
-  public void releaseDestroyLock()
-  {
+  public void releaseDestroyLock() {
-  
+
-   * Cleans up any resources that may have been allocated for this region during
-   * its initialization.
+   * Cleans up any resources that may have been allocated for this region during its initialization.
-  void cleanupFailedInitialization()
-  {
+  void cleanupFailedInitialization() {
-    closeEntries(); //fixes bug 41333
+    closeEntries(); // fixes bug 41333
-        }
-        catch (IllegalStateException ex) {
+        } catch (IllegalStateException ex) {
-    }
-    finally {
+    } finally {
-  LocalRegion getRoot()
-  {
+  LocalRegion getRoot() {
-  private void initializationFailed(LocalRegion subregion)
-  {
+  private void initializationFailed(LocalRegion subregion) {
-   * PRECONDITIONS: Synchronized on updateMonitor for this key in order to
-   * guarantee write-through to map entry, and key must be in map
+   * PRECONDITIONS: Synchronized on updateMonitor for this key in order to guarantee write-through
+   * to map entry, and key must be in map
-   * @param p_lastModified
-   *          time, may be 0 in which case uses now instead
+   * @param p_lastModified time, may be 0 in which case uses now instead
-  long updateStatsForPut(RegionEntry entry, long p_lastModified,
-      boolean lruRecentUse)
-  {
+  long updateStatsForPut(RegionEntry entry, long p_lastModified, boolean lruRecentUse) {
-   * Returns a region in the subregion map first, then looks in the
-   * reinitializing region registry.
+   * Returns a region in the subregion map first, then looks in the reinitializing region registry.
-  private LocalRegion basicGetSubregion(String name)
-  {
+  private LocalRegion basicGetSubregion(String name) {
-   * Make a LocalRegion from an element in the subregion map Sent to parent
-   * region.
+   * Make a LocalRegion from an element in the subregion map Sent to parent region.
-   * @return This method may return null or a destroyed region if the region was
-   *         just destroyed
+   * @return This method may return null or a destroyed region if the region was just destroyed
-  private LocalRegion toRegion(Object element)
-  {
-    LocalRegion rgn = (LocalRegion)element;
+  private LocalRegion toRegion(Object element) {
+    LocalRegion rgn = (LocalRegion) element;
-   * @param re
-   *          the entry whose value was accessed
+   * @param re the entry whose value was accessed
-  private void sendPendingRegionDestroyEvents(HashSet set)
-  {
+  private void sendPendingRegionDestroyEvents(HashSet set) {
-      RegionEventImpl event = (RegionEventImpl)iterator.next();
-      event.region.dispatchListenerEvent(
-          EnumListenerEvent.AFTER_REGION_DESTROY, event);
+      RegionEventImpl event = (RegionEventImpl) iterator.next();
+      event.region.dispatchListenerEvent(EnumListenerEvent.AFTER_REGION_DESTROY, event);
-        SystemMemberCacheEventProcessor.send(getCache(), event.getRegion(), event
-            .getOperation());
+        SystemMemberCacheEventProcessor.send(getCache(), event.getRegion(), event.getOperation());
-  protected void closeCallbacksExceptListener()
-  {
+  protected void closeCallbacksExceptListener() {
-  private void closeAllCallbacks()
-  {
+  private void closeAllCallbacks() {
+   * 
-      String poolname =this.getPoolName();
-      PoolImpl dpool= (PoolImpl)PoolManager.find(this.getPoolName());
-      if(poolname!=null && dpool!=null){
-             mySRP.detach(gc.keepDurableSubscriptionsAlive() || dpool.getKeepAlive()); 
-      }else{
-          mySRP.detach(gc.keepDurableSubscriptionsAlive());
+      String poolname = this.getPoolName();
+      PoolImpl dpool = (PoolImpl) PoolManager.find(this.getPoolName());
+      if (poolname != null && dpool != null) {
+        mySRP.detach(gc.keepDurableSubscriptionsAlive() || dpool.getKeepAlive());
+      } else {
+        mySRP.detach(gc.keepDurableSubscriptionsAlive());
-  
+
-      } 
-      catch (VirtualMachineError err) {
+      } catch (VirtualMachineError err) {
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-      }
-      catch (Throwable t) {
+      } catch (Throwable t) {
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-        logger.warn(LocalizedMessage.create(LocalizedStrings.LocalRegion_EXCEPTION_OCCURRED_WHILE_CLOSING_CQS_ON_REGION_DESTORY), t);
+        logger.warn(
+            LocalizedMessage.create(
+                LocalizedStrings.LocalRegion_EXCEPTION_OCCURRED_WHILE_CLOSING_CQS_ON_REGION_DESTORY),
+            t);
-   * Called when the cache is closed. Behaves just like a Region.close except
-   * the operation is CACHE_CLOSE
+   * Called when the cache is closed. Behaves just like a Region.close except the operation is
+   * CACHE_CLOSE
-  void handleCacheClose(Operation op)
-  {
-    RegionEventImpl ev = new RegionEventImpl(this, op, null, false, getMyId(),
-        generateEventID());
+  void handleCacheClose(Operation op) {
+    RegionEventImpl ev = new RegionEventImpl(this, op, null, false, getMyId(), generateEventID());
-      }
-      catch (CancelException ignore) {
+      } catch (CancelException ignore) {
-          logger.debug("handleCacheClose: Encountered cache closure while closing region {}", getFullPath());
+          logger.debug("handleCacheClose: Encountered cache closure while closing region {}",
+              getFullPath());
-      }
-      catch (RegionDestroyedException ignore) {
+      } catch (RegionDestroyedException ignore) {
-      }
-      catch (CacheWriterException e) {
+      } catch (CacheWriterException e) {
-        throw new Error(LocalizedStrings.LocalRegion_CACHEWRITEREXCEPTION_SHOULD_NOT_BE_THROWN_HERE.toLocalizedString(), e);
-      }
-      catch (TimeoutException e) {
+        throw new Error(LocalizedStrings.LocalRegion_CACHEWRITEREXCEPTION_SHOULD_NOT_BE_THROWN_HERE
+            .toLocalizedString(), e);
+      } catch (TimeoutException e) {
-          throw new InternalGemFireError(LocalizedStrings.LocalRegion_TIMEOUTEXCEPTION_SHOULD_NOT_BE_THROWN_HERE.toLocalizedString(), e);
+          throw new InternalGemFireError(
+              LocalizedStrings.LocalRegion_TIMEOUTEXCEPTION_SHOULD_NOT_BE_THROWN_HERE
+                  .toLocalizedString(),
+              e);
+
-    //Ok to remove entry as index has not been modified yet by the operation
-    this.entries.removeEntry(event.getKey(), re, false) ;      
+    // Ok to remove entry as index has not been modified yet by the operation
+    this.entries.removeEntry(event.getKey(), re, false);
-  static void validateRegionName(String name, InternalRegionArguments internalRegionArgs)
-  {
+  static void validateRegionName(String name, InternalRegionArguments internalRegionArgs) {
-      throw new IllegalArgumentException(LocalizedStrings.LocalRegion_NAME_CANNOT_BE_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.LocalRegion_NAME_CANNOT_BE_NULL.toLocalizedString());
-      throw new IllegalArgumentException(LocalizedStrings.LocalRegion_NAME_CANNOT_BE_EMPTY.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.LocalRegion_NAME_CANNOT_BE_EMPTY.toLocalizedString());
-      throw new IllegalArgumentException(LocalizedStrings.LocalRegion_NAME_CANNOT_CONTAIN_THE_SEPARATOR_0.toLocalizedString(SEPARATOR));
+      throw new IllegalArgumentException(
+          LocalizedStrings.LocalRegion_NAME_CANNOT_CONTAIN_THE_SEPARATOR_0
+              .toLocalizedString(SEPARATOR));
-    if (internalRegionArgs.isInternalRegion()){
+    if (internalRegionArgs.isInternalRegion()) {
-      throw new IllegalArgumentException("Region names may not begin with a double-underscore: " + name);
+      throw new IllegalArgumentException(
+          "Region names may not begin with a double-underscore: " + name);
-      throw new IllegalArgumentException("Region names may only be alphanumeric and may contain hyphens or underscores: " + name);
+      throw new IllegalArgumentException(
+          "Region names may only be alphanumeric and may contain hyphens or underscores: " + name);
-  private void checkCacheClosed()
-  {
+  private void checkCacheClosed() {
-  private void checkRegionDestroyed(boolean checkCancel)
-  {
+  private void checkRegionDestroyed(boolean checkCancel) {
-      }
-      else {
+      } else {
-    
+
-              .toLocalizedString(), getFullPath());
+              .toLocalizedString(),
+          getFullPath());
+   * 
-      callback.handleRegionEntry((RegionEntry)it.next());
+      callback.handleRegionEntry((RegionEntry) it.next());
+   * 
-    if (getScope().isDistributed() && getDataPolicy().withReplication()
-        && (!event.isDistributed()) && !isUsedForSerialGatewaySenderQueue()) {
-      throw new IllegalStateException(LocalizedStrings.LocalRegion_NOT_ALLOWED_TO_DO_A_LOCAL_DESTROY_ON_A_REPLICATED_REGION.toLocalizedString());
+    if (getScope().isDistributed() && getDataPolicy().withReplication() && (!event.isDistributed())
+        && !isUsedForSerialGatewaySenderQueue()) {
+      throw new IllegalStateException(
+          LocalizedStrings.LocalRegion_NOT_ALLOWED_TO_DO_A_LOCAL_DESTROY_ON_A_REPLICATED_REGION
+              .toLocalizedString());
-   * Return the number of subregions, including this region. Used for recursive
-   * size calculation in SubregionsSet.size
+   * Return the number of subregions, including this region. Used for recursive size calculation in
+   * SubregionsSet.size
-  protected int allSubregionsSize()
-  {
+  protected int allSubregionsSize() {
-      LocalRegion r = (LocalRegion)itr.next();
+      LocalRegion r = (LocalRegion) itr.next();
-   * Return the number of entries including in subregions. Used for recursive
-   * size calculation in EntriesSet.size.  This does not include tombstone
-   * entries stored in the region.
+   * Return the number of entries including in subregions. Used for recursive size calculation in
+   * EntriesSet.size. This does not include tombstone entries stored in the region.
-  protected int allEntriesSize()
-  {
+  protected int allEntriesSize() {
-   * @param rgnEvent
-   *          the RegionEvent for region invalidation
+   * @param rgnEvent the RegionEvent for region invalidation
-  protected void invalidateAllEntries(RegionEvent rgnEvent)
-  {
+  protected void invalidateAllEntries(RegionEvent rgnEvent) {
-   
+
-   
+
-        //EventID will not be generated by this constructor
-        @Released EntryEventImpl event = EntryEventImpl.create(
-            this, op, itr.next() /*key*/,
-            null/* newValue */, null/* callbackArg */, rgnEvent.isOriginRemote(),
-            rgnEvent.getDistributedMember());
+        // EventID will not be generated by this constructor
+        @Released
+        EntryEventImpl event =
+            EntryEventImpl.create(this, op, itr.next() /* key */, null/* newValue */,
+                null/* callbackArg */, rgnEvent.isOriginRemote(), rgnEvent.getDistributedMember());
-        event.setLocalInvalid(!rgnEvent.getOperation().isDistributed());
-        basicInvalidate(event, false);
+          event.setLocalInvalid(!rgnEvent.getOperation().isDistributed());
+          basicInvalidate(event, false);
-      }
-      catch (EntryNotFoundException e) {
+      } catch (EntryNotFoundException e) {
-  boolean hasListener()
-  {
+  boolean hasListener() {
+
-   * Return true if all disk attributes are defaults.
-   * DWA.isSynchronous can be true or false.
+   * Return true if all disk attributes are defaults. DWA.isSynchronous can be true or false.
-    assert(getDiskStoreName()== null);
+    assert (getDiskStoreName() == null);
-   * Returns true if this region's config indicates that it will use a disk store.
-   * Added for bug 42055.
+   * Returns true if this region's config indicates that it will use a disk store. Added for bug
+   * 42055.
-    return !isProxy()
-      && (getAttributes().getDataPolicy().withPersistence()
-          || isOverflowEnabled());
+    return !isProxy() && (getAttributes().getDataPolicy().withPersistence() || isOverflowEnabled());
-  
-  protected DiskStoreImpl findDiskStore(RegionAttributes ra, InternalRegionArguments internalRegionArgs) {
-    //validate that persistent type registry is persistent
-    if(getAttributes().getDataPolicy().withPersistence()) {
+
+  protected DiskStoreImpl findDiskStore(RegionAttributes ra,
+      InternalRegionArguments internalRegionArgs) {
+    // validate that persistent type registry is persistent
+    if (getAttributes().getDataPolicy().withPersistence()) {
-    
+
-        if (getDiskStoreName() != null) {
-          DiskStoreImpl diskStore = (DiskStoreImpl)getGemFireCache().findDiskStore(getDiskStoreName());
-          if (diskStore == null) {
-            throw new IllegalStateException(LocalizedStrings.CacheCreation_DISKSTORE_NOTFOUND_0.toLocalizedString(getDiskStoreName()));
-          }
-          return diskStore;
+      if (getDiskStoreName() != null) {
+        DiskStoreImpl diskStore =
+            (DiskStoreImpl) getGemFireCache().findDiskStore(getDiskStoreName());
+        if (diskStore == null) {
+          throw new IllegalStateException(LocalizedStrings.CacheCreation_DISKSTORE_NOTFOUND_0
+              .toLocalizedString(getDiskStoreName()));
-        else if (useDefaultDiskStore()){
-          return getGemFireCache().getOrCreateDefaultDiskStore();
-        } else /* backwards compat mode */{
-          DiskStoreFactory dsf = getGemFireCache().createDiskStoreFactory();
-          dsf.setDiskDirsAndSizes(getDiskDirs(), getDiskDirSizes());
-          DiskWriteAttributes dwa = getDiskWriteAttributes();
-          dsf.setAutoCompact(dwa.isRollOplogs());
-          dsf.setMaxOplogSize(dwa.getMaxOplogSize());
-          dsf.setTimeInterval(dwa.getTimeInterval());
-          if (dwa.getBytesThreshold() > 0) {
-            dsf.setQueueSize(1);
-          } else {
-            dsf.setQueueSize(0);
-          }
-          DiskStoreFactoryImpl dsfi = (DiskStoreFactoryImpl)dsf;
-          return dsfi.createOwnedByRegion(getFullPath().replace('/', '_'),
-              this instanceof PartitionedRegion, internalRegionArgs);
+        return diskStore;
+      } else if (useDefaultDiskStore()) {
+        return getGemFireCache().getOrCreateDefaultDiskStore();
+      } else /* backwards compat mode */ {
+        DiskStoreFactory dsf = getGemFireCache().createDiskStoreFactory();
+        dsf.setDiskDirsAndSizes(getDiskDirs(), getDiskDirSizes());
+        DiskWriteAttributes dwa = getDiskWriteAttributes();
+        dsf.setAutoCompact(dwa.isRollOplogs());
+        dsf.setMaxOplogSize(dwa.getMaxOplogSize());
+        dsf.setTimeInterval(dwa.getTimeInterval());
+        if (dwa.getBytesThreshold() > 0) {
+          dsf.setQueueSize(1);
+        } else {
+          dsf.setQueueSize(0);
+        DiskStoreFactoryImpl dsfi = (DiskStoreFactoryImpl) dsf;
+        return dsfi.createOwnedByRegion(getFullPath().replace('/', '_'),
+            this instanceof PartitionedRegion, internalRegionArgs);
+      }
-    
+
+
-   * Creates a new <code>DiskRegion</code> for this region. We assume that the
-   * attributes and the name of the region have been set.
+   * Creates a new <code>DiskRegion</code> for this region. We assume that the attributes and the
+   * name of the region have been set.
-      if(this.getAttributes().getConcurrencyChecksEnabled()) {
+      if (this.getAttributes().getConcurrencyChecksEnabled()) {
-      return DiskRegion.create(dsi, getFullPath(), false,
-                               getDataPolicy().withPersistence(),
-                               isOverflowEnabled(), isDiskSynchronous(),
-                               stats, getCancelCriterion(), this, getAttributes(),
-                               diskFlags, "NO_PARTITITON", -1,
-                               getCompressor(), getOffHeap());
+      return DiskRegion.create(dsi, getFullPath(), false, getDataPolicy().withPersistence(),
+          isOverflowEnabled(), isDiskSynchronous(), stats, getCancelCriterion(), this,
+          getAttributes(), diskFlags, "NO_PARTITITON", -1, getCompressor(), getOffHeap());
+   * 
-  void addTTLExpiryTask()
-  {
+  void addTTLExpiryTask() {
-        this.regionTTLExpiryTask = (RegionTTLExpiryTask)
-        this.cache.getExpirationScheduler().addExpiryTask(
-            new RegionTTLExpiryTask(this));
+        this.regionTTLExpiryTask = (RegionTTLExpiryTask) this.cache.getExpirationScheduler()
+            .addExpiryTask(new RegionTTLExpiryTask(this));
-  void addTTLExpiryTask(RegionTTLExpiryTask callingTask)
-  {
+  void addTTLExpiryTask(RegionTTLExpiryTask callingTask) {
-        logger.debug("Scheduling Region TTL Expiry Task {} which replaces {}", task, this.regionTTLExpiryTask);
+        logger.debug("Scheduling Region TTL Expiry Task {} which replaces {}", task,
+            this.regionTTLExpiryTask);
-      this.regionTTLExpiryTask = (RegionTTLExpiryTask)
-          this.cache.getExpirationScheduler().addExpiryTask(task);
+      this.regionTTLExpiryTask =
+          (RegionTTLExpiryTask) this.cache.getExpirationScheduler().addExpiryTask(task);
-  final void addIdleExpiryTask()
-  {
+  final void addIdleExpiryTask() {
-        this.regionIdleExpiryTask = (RegionIdleExpiryTask)
-            this.cache.getExpirationScheduler().addExpiryTask(
-                new RegionIdleExpiryTask(this));
+        this.regionIdleExpiryTask = (RegionIdleExpiryTask) this.cache.getExpirationScheduler()
+            .addExpiryTask(new RegionIdleExpiryTask(this));
-  void addIdleExpiryTask(RegionIdleExpiryTask callingTask)
-  {
+  void addIdleExpiryTask(RegionIdleExpiryTask callingTask) {
-        logger.debug("Scheduling Region Idle Expiry Task {} which replaces ", task, this.regionIdleExpiryTask);
+        logger.debug("Scheduling Region Idle Expiry Task {} which replaces ", task,
+            this.regionIdleExpiryTask);
-      this.regionIdleExpiryTask = (RegionIdleExpiryTask)
-          this.cache.getExpirationScheduler().addExpiryTask(task);
+      this.regionIdleExpiryTask =
+          (RegionIdleExpiryTask) this.cache.getExpirationScheduler().addExpiryTask(task);
-  protected boolean isEntryIdleExpiryPossible()
-  {
+  protected boolean isEntryIdleExpiryPossible() {
-  private void cancelTTLExpiryTask()
-  {
+  private void cancelTTLExpiryTask() {
-  private void cancelIdleExpiryTask()
-  {
+  private void cancelIdleExpiryTask() {
-  protected void regionTimeToLiveChanged(ExpirationAttributes oldTimeToLive)
-  {
+  protected void regionTimeToLiveChanged(ExpirationAttributes oldTimeToLive) {
-  protected void regionIdleTimeoutChanged(ExpirationAttributes oldIdleTimeout)
-  {
+  protected void regionIdleTimeoutChanged(ExpirationAttributes oldIdleTimeout) {
-  protected void timeToLiveChanged(ExpirationAttributes oldTimeToLive)
-  {
+  protected void timeToLiveChanged(ExpirationAttributes oldTimeToLive) {
-    }
-    else
-    if (entryTimeToLive > 0
-        && (oldTimeout == 0 || entryTimeToLive < oldTimeout)) {
+    } else if (entryTimeToLive > 0 && (oldTimeout == 0 || entryTimeToLive < oldTimeout)) {
-    }
-    else {
+    } else {
-  protected void idleTimeoutChanged(ExpirationAttributes oldIdleTimeout)
-  {
+  protected void idleTimeoutChanged(ExpirationAttributes oldIdleTimeout) {
-    }
-    else
-    if (entryIdleTimeout > 0
-        && (oldTimeout == 0 || entryIdleTimeout < oldTimeout)) {
+    } else if (entryIdleTimeout > 0 && (oldTimeout == 0 || entryIdleTimeout < oldTimeout)) {
-    }
-    else {
+    } else {
-  protected void rescheduleEntryExpiryTasks()
-  {
+  protected void rescheduleEntryExpiryTasks() {
-  void addExpiryTaskIfAbsent(RegionEntry re)
-  {
+  void addExpiryTaskIfAbsent(RegionEntry re) {
-  void addExpiryTask(RegionEntry re)
-  {
+  void addExpiryTask(RegionEntry re) {
-  
+
-   @Override
+    @Override
-  @Override
+    @Override
-    
+
-     * Returns the entry's  RegionEntry if it "checks" out. The check is to
-     * see if the region entry still exists.
+     * Returns the entry's RegionEntry if it "checks" out. The check is to see if the region entry
+     * still exists.
+     * 
-      Object value = this.region.getDeserialized(getCheckedRegionEntry(), false, false, false, false);
+      Object value =
+          this.region.getDeserialized(getCheckedRegionEntry(), false, false, false, false);
-      }
-      else if(Token.isInvalid(value)) {
+      } else if (Token.isInvalid(value)) {
-        throw new StatisticsDisabledException(LocalizedStrings.LocalRegion_STATISTICS_DISABLED_FOR_REGION_0.toLocalizedString(lr.getFullPath()));
+        throw new StatisticsDisabledException(
+            LocalizedStrings.LocalRegion_STATISTICS_DISABLED_FOR_REGION_0
+                .toLocalizedString(lr.getFullPath()));
-      if (this.re.isDestroyedOrRemoved()) return true;
+      if (this.re.isDestroyedOrRemoved())
+        return true;
+
-   * If custom expiration returns non-null expiration attributes
-   * then create a CustomEntryExpiryTask for this region and the given entry and return it.
-   * Otherwise if the region is configured for expiration
-   * then create an EntryExpiryTask for this region and the given entry and return it.
+   * If custom expiration returns non-null expiration attributes then create a CustomEntryExpiryTask
+   * for this region and the given entry and return it. Otherwise if the region is configured for
+   * expiration then create an EntryExpiryTask for this region and the given entry and return it.
-      final RegionAttributes<?,?> ra = this.getAttributes();
+      final RegionAttributes<?, ?> ra = this.getAttributes();
-        final CustomExpiry<?,?> customTTL = ra.getCustomEntryTimeToLive();
+        final CustomExpiry<?, ?> customTTL = ra.getCustomEntryTimeToLive();
-          }
-          catch (RegionDestroyedException rde) {
+          } catch (RegionDestroyedException rde) {
-          }
-          catch (EntryNotFoundException enfe){
-            //Ignore - #51933
-          }
-          catch (EntryDestroyedException edf){
-            //Ignore - #51933
-          }
-          catch (Exception e) {
-            logger.fatal(LocalizedMessage.create(LocalizedStrings.EntryExpiryTask_ERROR_CALCULATING_EXPIRATION_0,
-                e.getMessage()), e);
+          } catch (EntryNotFoundException enfe) {
+            // Ignore - #51933
+          } catch (EntryDestroyedException edf) {
+            // Ignore - #51933
+          } catch (Exception e) {
+            logger.fatal(LocalizedMessage.create(
+                LocalizedStrings.EntryExpiryTask_ERROR_CALCULATING_EXPIRATION_0, e.getMessage()),
+                e);
-          ttlAtts = ra.getEntryTimeToLive();  
+          ttlAtts = ra.getEntryTimeToLive();
-        CustomExpiry<?,?> customIdle = ra.getCustomEntryIdleTimeout();
+        CustomExpiry<?, ?> customIdle = ra.getCustomEntryIdleTimeout();
-          }
-          catch (RegionDestroyedException rde) {
+          } catch (RegionDestroyedException rde) {
-          }
-          catch (EntryNotFoundException enfe){
-            //Ignore - #51933
-          }
-          catch (EntryDestroyedException edf){
-            //Ignore - #51933
-          }
-          catch (Exception e) {
-            logger.fatal(LocalizedMessage.create(LocalizedStrings.EntryExpiryTask_ERROR_CALCULATING_EXPIRATION_0,
-                e.getMessage()), e);
+          } catch (EntryNotFoundException enfe) {
+            // Ignore - #51933
+          } catch (EntryDestroyedException edf) {
+            // Ignore - #51933
+          } catch (Exception e) {
+            logger.fatal(LocalizedMessage.create(
+                LocalizedStrings.EntryExpiryTask_ERROR_CALCULATING_EXPIRATION_0, e.getMessage()),
+                e);
-   * Used by unit tests to get access to the EntryExpiryTask
-   * of the given key. Returns null if the entry exists but
-   * does not have an expiry task.
+   * Used by unit tests to get access to the EntryExpiryTask of the given key. Returns null if the
+   * entry exists but does not have an expiry task.
+   * 
+
-   * Used by unit tests to get access to the RegionIdleExpiryTask
-   * of this region. Returns null if no task exists.
+   * Used by unit tests to get access to the RegionIdleExpiryTask of this region. Returns null if no
+   * task exists.
+
-   * Used by unit tests to get access to the RegionTTLExpiryTask
-   * of this region. Returns null if no task exists.
+   * Used by unit tests to get access to the RegionTTLExpiryTask of this region. Returns null if no
+   * task exists.
-  
-  private void addExpiryTask(RegionEntry re, boolean ifAbsent)
-  {
+
+  private void addExpiryTask(RegionEntry re, boolean ifAbsent) {
-        oldTask = (EntryExpiryTask)this.entryExpiryTasks.get(re);
+        oldTask = (EntryExpiryTask) this.entryExpiryTasks.get(re);
-            try{
-            if (ntTime != 0 && ntTime < oldTask.getExpirationTime()) {
-              // it is so get rid of the old task and schedule the new one.
+            try {
+              if (ntTime != 0 && ntTime < oldTask.getExpirationTime()) {
+                // it is so get rid of the old task and schedule the new one.
+                keepOldTask = false;
+              }
+            } catch (EntryNotFoundException ex) {
-            }catch(EntryNotFoundException ex){
-                keepOldTask=false;
-            }
-              logger.trace("Expiry Task not added because one already present. Key={}" + re.getKey());
+              logger
+                  .trace("Expiry Task not added because one already present. Key={}" + re.getKey());
-      //       } catch (EntryNotFoundException e) {
-      //         // ignore - there are unsynchronized paths that allow an entry to
-      //         // be destroyed out from under us.
-      //         return;
-      //       }
-    }
-    else {
+      // } catch (EntryNotFoundException e) {
+      // // ignore - there are unsynchronized paths that allow an entry to
+      // // be destroyed out from under us.
+      // return;
+      // }
+    } else {
-  
+
-  void cancelExpiryTask(RegionEntry re, ExpiryTask expiryTask)
-  {
+  void cancelExpiryTask(RegionEntry re, ExpiryTask expiryTask) {
-  public void cancelAllEntryExpiryTasks()
-  {
+  public void cancelAllEntryExpiryTasks() {
-    if (this.entryExpiryTasks == null) return;
-    if (this.entryExpiryTasks.isEmpty()) return;
+    if (this.entryExpiryTasks == null)
+      return;
+    if (this.entryExpiryTasks.isEmpty())
+      return;
-  long getLastAccessedTime(Object key) throws EntryNotFoundException
-  {
+  long getLastAccessedTime(Object key) throws EntryNotFoundException {
-    }
-    catch (InternalStatisticsDisabledException e) {
+    } catch (InternalStatisticsDisabledException e) {
-  long getLastModifiedTime(Object key) throws EntryNotFoundException
-  {
+  long getLastModifiedTime(Object key) throws EntryNotFoundException {
-  protected final ImageState getImageState()
-  {
+  protected final ImageState getImageState() {
-   * Callers of this method should always follow the call with: if (lockGII()) {
-   * try { } finally { unlockGII(); } }
+   * Callers of this method should always follow the call with: if (lockGII()) { try { } finally {
+   * unlockGII(); } }
-   * Callers of this method should always follow the call with: if (lockRIReadLock()) {
-   * try { } finally { unlockRIReadLock(); } }
+   * Callers of this method should always follow the call with: if (lockRIReadLock()) { try { }
+   * finally { unlockRIReadLock(); } }
-  public LocalRegion basicGetParentRegion()
-  {
+  public LocalRegion basicGetParentRegion() {
-  Object basicGetEntryUserAttribute(Object entryKey)
-  {
+  Object basicGetEntryUserAttribute(Object entryKey) {
-    }
-    else {
+    } else {
-    return (TXId)tx.getTransactionId();
+    return (TXId) tx.getTransactionId();
-  protected final TXRegionState txReadRegion()
-  {
+  protected final TXRegionState txReadRegion() {
-    }
-    else {
+    } else {
-              LRUEntry le = (LRUEntry)re;
+              LRUEntry le = (LRUEntry) re;
-            }        
+            }
-             * The tx will need the raw value for identity comparison.
-             * Please see TXEntryState#checkForConflict(LocalRegion,Object)
+             * The tx will need the raw value for identity comparison. Please see
+             * TXEntryState#checkForConflict(LocalRegion,Object)
-  
+
-  protected TXStateInterface getJTAEnlistedTX()
-  {
+  protected TXStateInterface getJTAEnlistedTX() {
-    TXStateInterface tx = getTXState(); 
+    TXStateInterface tx = getTXState();
-    }
-    else {
+    } else {
-        }
-        else {
+        } else {
-      }
-      catch (javax.transaction.SystemException se) {
+      } catch (javax.transaction.SystemException se) {
-      }
-      catch (javax.transaction.RollbackException re) {
+      } catch (javax.transaction.RollbackException re) {
-      }
-      catch (IllegalStateException ie) {
+      } catch (IllegalStateException ie) {
-      jtaTransName = cache.getJTATransactionManager().getTransaction()
-          .toString();
-    }
-    catch (VirtualMachineError err) {
+      jtaTransName = cache.getJTATransactionManager().getTransaction().toString();
+    } catch (VirtualMachineError err) {
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    }
-    catch (Throwable ignore) {
+    } catch (Throwable ignore) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-    throw new FailedSynchronizationException(LocalizedStrings.LocalRegion_FAILED_ENLISTEMENT_WITH_TRANSACTION_0.toLocalizedString(jtaTransName), reason);
+    throw new FailedSynchronizationException(
+        LocalizedStrings.LocalRegion_FAILED_ENLISTEMENT_WITH_TRANSACTION_0
+            .toLocalizedString(jtaTransName),
+        reason);
-  final void txLRUStart()
-  {
+  final void txLRUStart() {
-  final void txLRUEnd()
-  {
+  final void txLRUEnd() {
-    try { 
+    try {
-    }catch(DiskAccessException dae) {
+    } catch (DiskAccessException dae) {
-  final void txDecRefCount(RegionEntry re)
-  {
+  final void txDecRefCount(RegionEntry re) {
-  List debugGetSubregionNames()
-  {
+  List debugGetSubregionNames() {
-  protected final static void dispatchEvent(LocalRegion region,
-      InternalCacheEvent event, EnumListenerEvent op)
-  {
-    
+  protected final static void dispatchEvent(LocalRegion region, InternalCacheEvent event,
+      EnumListenerEvent op) {
+
-      }
-      catch (CancelException e) {
+      } catch (CancelException e) {
-          logger.trace("Dispatching events after cache closure for region {}", region.getFullPath());
+          logger.trace("Dispatching events after cache closure for region {}",
+              region.getFullPath());
-    //Assert.assertTrue(event.getRegion() == region);
+    // Assert.assertTrue(event.getRegion() == region);
-// this check moved earlier for bug 36983
-//    CacheListener[] listeners = region.fetchCacheListenersField();
-//    if (listeners == null || listeners.length == 0)
-//      return;
+    // this check moved earlier for bug 36983
+    // CacheListener[] listeners = region.fetchCacheListenersField();
+    // if (listeners == null || listeners.length == 0)
+    // return;
-        }
-        catch (CancelException ignore) {
+        } catch (CancelException ignore) {
-        }
-        catch (VirtualMachineError err) {
+        } catch (VirtualMachineError err) {
-          // If this ever returns, rethrow the error.  We're poisoned
+          // If this ever returns, rethrow the error. We're poisoned
-        }
-        catch (Throwable t) {
+        } catch (Throwable t) {
-          // catch VirtualMachineError (see above).  However, there is
+          // catch VirtualMachineError (see above). However, there is
-          logger.error(LocalizedMessage.create(LocalizedStrings.LocalRegion_EXCEPTION_OCCURRED_IN_CACHELISTENER), t);
+          logger.error(LocalizedMessage
+              .create(LocalizedStrings.LocalRegion_EXCEPTION_OCCURRED_IN_CACHELISTENER), t);
-    }    
+    }
-  class EventDispatcher implements Runnable
-  {
+  class EventDispatcher implements Runnable {
-                
+
-        event = new EntryEventImpl( (EntryEventImpl)event);   
+        event = new EntryEventImpl((EntryEventImpl) event);
-    public void run()
-    {
+    public void run() {
-      }finally {
+      } finally {
-    
+
-        ((EntryEventImpl)this.event).release();
-      }      
+        ((EntryEventImpl) this.event).release();
+      }
-  
-  
+
+
-  private class SubregionsSet extends AbstractSet
-   {
+  private class SubregionsSet extends AbstractSet {
-    public Iterator iterator()
-    {
+    public Iterator iterator() {
-        public void remove()
-        {
-          throw new UnsupportedOperationException(LocalizedStrings.LocalRegion_THIS_ITERATOR_DOES_NOT_SUPPORT_MODIFICATION.toLocalizedString());
+        public void remove() {
+          throw new UnsupportedOperationException(
+              LocalizedStrings.LocalRegion_THIS_ITERATOR_DOES_NOT_SUPPORT_MODIFICATION
+                  .toLocalizedString());
-        public boolean hasNext()
-        {
+        public boolean hasNext() {
-          }
-          else {
+          } else {
-            }
-            else {
+            } else {
-        private boolean _hasNext()
-        {
+        private boolean _hasNext() {
-        
+
-        
+
-        private Object next(boolean nullOK)
-        {
+        private Object next(boolean nullOK) {
-                }
-                else {
+                } else {
-              }
-              else {
-                this.currItr = (Iterator)itrQ.remove(0);
+              } else {
+                this.currItr = (Iterator) itrQ.remove(0);
-            rgn = (LocalRegion)currItr.next();
+            rgn = (LocalRegion) currItr.next();
-            }
-            else {
-              this.currItr = (Iterator)itrQ.remove(0);
+            } else {
+              this.currItr = (Iterator) itrQ.remove(0);
-    public int size()
-    {
+    public int size() {
-      }
-      else {
+      } else {
-    public Object[] toArray()
-    {
+    public Object[] toArray() {
-    public Object[] toArray(Object[] array)
-    {
+    public Object[] toArray(Object[] array) {
-  public class NonTXEntry implements Region.Entry
-  {
+  public class NonTXEntry implements Region.Entry {
-     * Create an Entry given a key. The returned Entry may or may not be
-     * destroyed
+     * Create an Entry given a key. The returned Entry may or may not be destroyed
-        throw new IllegalArgumentException(LocalizedStrings.LocalRegion_REGIONENTRY_SHOULD_NOT_BE_NULL.toLocalizedString());
+        throw new IllegalArgumentException(
+            LocalizedStrings.LocalRegion_REGIONENTRY_SHOULD_NOT_BE_NULL.toLocalizedString());
-    public boolean isDestroyed()
-    {
+    public boolean isDestroyed() {
-    public Object getKey()
-    {
+    public Object getKey() {
-    public Object getValue()
-    {
-        return getValue(false);
+    public Object getValue() {
+      return getValue(false);
-    public Object getValue(boolean ignoreCopyOnRead)
-    {
-        Object value = getDeserialized(this.basicGetEntry(), false, ignoreCopyOnRead, false, false);
-        if (value == null) {
-          throw new EntryDestroyedException(getKey().toString());
-        }
-        else if(Token.isInvalid(value)) {
-          return null;
-        }
+    public Object getValue(boolean ignoreCopyOnRead) {
+      Object value = getDeserialized(this.basicGetEntry(), false, ignoreCopyOnRead, false, false);
+      if (value == null) {
+        throw new EntryDestroyedException(getKey().toString());
+      } else if (Token.isInvalid(value)) {
+        return null;
+      }
-        return value;
+      return value;
+     * 
-    public Object getRawValue()
-    {
-        Object value = this.basicGetEntry().getValue((LocalRegion) getRegion());
-        if (value == null) {
-          throw new EntryDestroyedException(this.getRegionEntry().getKey().toString());
-        }
-        else if(Token.isInvalid(value)) {
-          return null;
-        }
+    public Object getRawValue() {
+      Object value = this.basicGetEntry().getValue((LocalRegion) getRegion());
+      if (value == null) {
+        throw new EntryDestroyedException(this.getRegionEntry().getKey().toString());
+      } else if (Token.isInvalid(value)) {
+        return null;
+      }
-        return value;
+      return value;
-    public Region getRegion()
-    {
+    public Region getRegion() {
-    public CacheStatistics getStatistics()
-    {
+    public CacheStatistics getStatistics() {
-        throw new StatisticsDisabledException(LocalizedStrings.LocalRegion_STATISTICS_DISABLED_FOR_REGION_0.toLocalizedString(getFullPath()));
+        throw new StatisticsDisabledException(
+            LocalizedStrings.LocalRegion_STATISTICS_DISABLED_FOR_REGION_0
+                .toLocalizedString(getFullPath()));
-    public Object getUserAttribute()
-    {
+    public Object getUserAttribute() {
-    public Object setUserAttribute(Object value)
-    {
+    public Object setUserAttribute(Object value) {
-      return LocalRegion.this.entryUserAttributes.put(
-          this.basicGetEntry().getKey(), value);
+      return LocalRegion.this.entryUserAttributes.put(this.basicGetEntry().getKey(), value);
-    public boolean equals(Object obj)
-    {
+    public boolean equals(Object obj) {
-      LocalRegion.NonTXEntry lre = (LocalRegion.NonTXEntry)obj;
+      LocalRegion.NonTXEntry lre = (LocalRegion.NonTXEntry) obj;
-    public int hashCode()
-    {
+    public int hashCode() {
-      return new StringBuilder("NonTXEntry@").append(
-          Integer.toHexString(System.identityHashCode(this))).append(' ')
+      return new StringBuilder("NonTXEntry@")
+          .append(Integer.toHexString(System.identityHashCode(this))).append(' ')
-    public Object setValue(Object arg0)
-    {
+    public Object setValue(Object arg0) {
-  
+
-   * Checks to make sure current thread does not have a transaction. If it does
-   * then throws UnsupportedOperationException
+   * Checks to make sure current thread does not have a transaction. If it does then throws
+   * UnsupportedOperationException
-  public void checkForTransaction(String opName)
-  {
+  public void checkForTransaction(String opName) {
-      throw new UnsupportedOperationException(LocalizedStrings.LocalRegion_0_OPERATIONS_ARE_NOT_ALLOWED_BECAUSE_THIS_THREAD_HAS_AN_ACTIVE_TRANSACTION
-          .toLocalizedString(opName));
+      throw new UnsupportedOperationException(
+          LocalizedStrings.LocalRegion_0_OPERATIONS_ARE_NOT_ALLOWED_BECAUSE_THIS_THREAD_HAS_AN_ACTIVE_TRANSACTION
+              .toLocalizedString(opName));
-  public RegionMap getRegionMap()
-  {
+  public RegionMap getRegionMap() {
-   * (description copied from entryCount() Returns the number of entries in this
-   * region. Note that because of the concurrency properties of the
-   * {@link RegionMap}, the number of entries is only an approximate. That is,
-   * other threads may change the number of entries in this region while this
-   * method is being invoked.
+   * (description copied from entryCount() Returns the number of entries in this region. Note that
+   * because of the concurrency properties of the {@link RegionMap}, the number of entries is only
+   * an approximate. That is, other threads may change the number of entries in this region while
+   * this method is being invoked.
-  public int size()
-  {
+  public int size() {
-   * returns an estimate of the number of entries in this region. This method
-   * should be prefered over size() for hdfs regions where an accurate size is
-   * not needed. This method is not supported on a client
+   * returns an estimate of the number of entries in this region. This method should be prefered
+   * over size() for hdfs regions where an accurate size is not needed. This method is not supported
+   * on a client
-      throw new UnsupportedOperationException(
-          "Method not supported on a client");
+      throw new UnsupportedOperationException("Method not supported on a client");
-  public boolean isEmpty()
-  {
-    //checkForNoAccess(); // size does this check
+  public boolean isEmpty() {
+    // checkForNoAccess(); // size does this check
-  public boolean containsValue(final Object value)
-  {
+  public boolean containsValue(final Object value) {
-      throw new NullPointerException(LocalizedStrings.LocalRegion_VALUE_FOR_CONTAINSVALUEVALUE_CANNOT_BE_NULL.toLocalizedString());
+      throw new NullPointerException(
+          LocalizedStrings.LocalRegion_VALUE_FOR_CONTAINSVALUEVALUE_CANNOT_BE_NULL
+              .toLocalizedString());
-   * Returns a set of the entries present in the Map. This set is Not
-   * Modifiable. If changes are made to this set, they will be not reflected in
-   * the map
+   * Returns a set of the entries present in the Map. This set is Not Modifiable. If changes are
+   * made to this set, they will be not reflected in the map
-  public Set entrySet()
-  {
-    //entries(false) takes care of open transactions
+  public Set entrySet() {
+    // entries(false) takes care of open transactions
-  
-  
+
+
-   * Returns a set of the keys present in the Map. This set is Not Modifiable.
-   * If changes are made to this set, they will be not reflected in the map
+   * Returns a set of the keys present in the Map. This set is Not Modifiable. If changes are made
+   * to this set, they will be not reflected in the map
-  public Set keySet()
-  {
-    //keys() takes care of open transactions
+  public Set keySet() {
+    // keys() takes care of open transactions
-   * removes the object from the Map and returns the object removed. The object
-   * is returned only if present in the localMap. If the value is present in
-   * another Node, null is returned
+   * removes the object from the Map and returns the object removed. The object is returned only if
+   * present in the localMap. If the value is present in another Node, null is returned
-  public Object remove(Object obj)
-  {
+  public Object remove(Object obj) {
-    }
-    catch (EntryNotFoundException e) {
+    } catch (EntryNotFoundException e) {
-  public void basicBridgeDestroyRegion( Object p_callbackArg, final ClientProxyMembershipID client,
-      boolean fromClient, EventID eventId) throws TimeoutException,
-      EntryExistsException, CacheWriterException
-  {
+  public void basicBridgeDestroyRegion(Object p_callbackArg, final ClientProxyMembershipID client,
+      boolean fromClient, EventID eventId)
+      throws TimeoutException, EntryExistsException, CacheWriterException {
-    //long startPut = CachePerfStats.getStatTime();
+    // long startPut = CachePerfStats.getStatTime();
-      if(isGatewaySenderEnabled()) {
+      if (isGatewaySenderEnabled()) {
-    RegionEventImpl event = new ClientRegionEventImpl(this, Operation.REGION_DESTROY,
-         callbackArg,false, client.getDistributedMember(), client/* context */, eventId);
+    RegionEventImpl event = new ClientRegionEventImpl(this, Operation.REGION_DESTROY, callbackArg,
+        false, client.getDistributedMember(), client/* context */, eventId);
-
-  public void basicBridgeClear( Object p_callbackArg, 
-      final ClientProxyMembershipID client,
-      boolean fromClient, EventID eventId) throws TimeoutException,
-      EntryExistsException, CacheWriterException
-  {
+  public void basicBridgeClear(Object p_callbackArg, final ClientProxyMembershipID client,
+      boolean fromClient, EventID eventId)
+      throws TimeoutException, EntryExistsException, CacheWriterException {
-    //long startPut = CachePerfStats.getStatTime();
+    // long startPut = CachePerfStats.getStatTime();
-      if(isGatewaySenderEnabled()) {
+      if (isGatewaySenderEnabled()) {
-    RegionEventImpl event = new ClientRegionEventImpl(this, Operation.REGION_CLEAR,
-         callbackArg,false, client.getDistributedMember(), client/* context */, eventId);
+    RegionEventImpl event = new ClientRegionEventImpl(this, Operation.REGION_CLEAR, callbackArg,
+        false, client.getDistributedMember(), client/* context */, eventId);
-  void basicClear(RegionEventImpl regionEvent)
-  {
+  void basicClear(RegionEventImpl regionEvent) {
-  void basicClear(RegionEventImpl regionEvent, boolean cacheWrite)  {
+  void basicClear(RegionEventImpl regionEvent, boolean cacheWrite) {
-  
-  
+
+
-   * Common code used by both clear and localClear. Asif : On the lines of
-   * destroyRegion, this method will be invoked for clearing the local cache.The
-   * cmnClearRegion will be overridden in the derived class DistributedRegion
-   * too. For clear operation , no CacheWriter will be invoked . It will only
-   * have afterClear callback. Also like destroyRegion & invalidateRegion , the
-   * clear operation will not take distributedLock. The clear operation will
-   * also clear the local tranxnl entries . The clear operation will have
-   * immediate committed state.
+   * Common code used by both clear and localClear. Asif : On the lines of destroyRegion, this
+   * method will be invoked for clearing the local cache.The cmnClearRegion will be overridden in
+   * the derived class DistributedRegion too. For clear operation , no CacheWriter will be invoked .
+   * It will only have afterClear callback. Also like destroyRegion & invalidateRegion , the clear
+   * operation will not take distributedLock. The clear operation will also clear the local tranxnl
+   * entries . The clear operation will have immediate committed state.
-  void clearRegionLocally(RegionEventImpl regionEvent, boolean cacheWrite, RegionVersionVector vector)
-  {
+  void clearRegionLocally(RegionEventImpl regionEvent, boolean cacheWrite,
+      RegionVersionVector vector) {
-    
+
-      // clients and local regions do not maintain a full RVV.  can't use it with clear()
+      // clients and local regions do not maintain a full RVV. can't use it with clear()
-    if (rvv != null && this.dataPolicy.withStorage()) { 
+    if (rvv != null && this.dataPolicy.withStorage()) {
-        logger.trace(LogMarker.RVV, "waiting for my version vector to dominate\nmine={}\nother=", this.versionVector.fullToString(), rvv);
+        logger.trace(LogMarker.RVV, "waiting for my version vector to dominate\nmine={}\nother=",
+            this.versionVector.fullToString(), rvv);
-          logger.trace(LogMarker.RVV, "incrementing clearTimeouts for {} rvv={}", this.getName(), this.versionVector.fullToString());
+          logger.trace(LogMarker.RVV, "incrementing clearTimeouts for {} rvv={}", this.getName(),
+              this.versionVector.fullToString());
-    
-    //If the initial image operation is still in progress
+
+    // If the initial image operation is still in progress
-      //Set a flag which will indicate that the Clear was invoked.
+      // Set a flag which will indicate that the Clear was invoked.
-      }
-      finally {
+      } finally {
-    
+
-          myVector.recordVersion(tag.getMemberID(), tag); // clear() events always have the ID in the tag
+          myVector.recordVersion(tag.getMemberID(), tag); // clear() events always have the ID in
+                                                          // the tag
-    //  Asif:Clear the expirational task for all the entries. It is possible that
-    //after clearing it some new entries may get added befoe issuing clear
-    //on the map , but that should be OK, as the expirational thread will
-    //silently move ahead if the entry to be expired no longer existed
+    // Asif:Clear the expirational task for all the entries. It is possible that
+    // after clearing it some new entries may get added befoe issuing clear
+    // on the map , but that should be OK, as the expirational thread will
+    // silently move ahead if the entry to be expired no longer existed
-    if (rvv == null  &&  myVector != null) {
+    if (rvv == null && myVector != null) {
-    
+
-     * Asif : First we need to clear the Tranxl state for the current region for
-     * the thread. The operation will not take global lock similar to
-     * regionInvalidateor regionDestroy behaviour.
+     * Asif : First we need to clear the Tranxl state for the current region for the thread. The
+     * operation will not take global lock similar to regionInvalidateor regionDestroy behaviour.
-          logger.trace(LogMarker.RVV, "Clear: Saved current rvv: {}", diskRegion.getRegionVersionVector());
+          logger.trace(LogMarker.RVV, "Clear: Saved current rvv: {}",
+              diskRegion.getRegionVersionVector());
-      
+
-    
+
-      //If the indexManager is null we don't have to worry
-      //for any other thread creating index at that instant
+      // If the indexManager is null we don't have to worry
+      // for any other thread creating index at that instant
-      //of entries.
-      //TODO Asif:Have made indexManager variable is made volatile. Is it
+      // of entries.
+      // TODO Asif:Have made indexManager variable is made volatile. Is it
-        }
-        catch (QueryException qe) {
+        } catch (QueryException qe) {
-          throw new CacheRuntimeException(LocalizedStrings.LocalRegion_EXCEPTION_OCCURED_WHILE_RE_CREATING_INDEX_DATA_ON_CLEARED_REGION.toLocalizedString(), qe) {
-            private static final long serialVersionUID = 0L;            
+          throw new CacheRuntimeException(
+              LocalizedStrings.LocalRegion_EXCEPTION_OCCURED_WHILE_RE_CREATING_INDEX_DATA_ON_CLEARED_REGION
+                  .toLocalizedString(),
+              qe) {
+            private static final long serialVersionUID = 0L;
-    
+
-    //Issue a callback to afterClear if the region is initialized
+    // Issue a callback to afterClear if the region is initialized
-  void basicLocalClear(RegionEventImpl rEvent)
-  {
+  void basicLocalClear(RegionEventImpl rEvent) {
-    cmnClearRegion(rEvent, false/* cacheWrite */, false/*useRVV*/);
+    cmnClearRegion(rEvent, false/* cacheWrite */, false/* useRVV */);
-       
+
-    throw new UnsupportedOperationException(LocalizedStrings.
-        LocalRegion_REGION_INTEREST_REGISTRATION_IS_ONLY_SUPPORTED_FOR_PARTITIONEDREGIONS
-        .toLocalizedString());
-  }  
-  
+    throw new UnsupportedOperationException(
+        LocalizedStrings.LocalRegion_REGION_INTEREST_REGISTRATION_IS_ONLY_SUPPORTED_FOR_PARTITIONEDREGIONS
+            .toLocalizedString());
+  }
+
-    
+
-      if(getTXState() == null && hasStorage()) {
+      if (getTXState() == null && hasStorage()) {
-	      for (Iterator i = keysList.iterator(); i.hasNext();) {
-	        Object key = i.next();
-	        Object value;
-	        Region.Entry entry = accessEntry(key, true);
-	        if (entry != null && (value = entry.getValue()) != null) {
-	          allResults.put(key, value);
-	          i.remove();
-	        }
-	      }
-	      if (isDebugEnabled) {
-	        logger.debug("Added local results for getAll request: {}", allResults);
-	      }
+        for (Iterator i = keysList.iterator(); i.hasNext();) {
+          Object key = i.next();
+          Object value;
+          Region.Entry entry = accessEntry(key, true);
+          if (entry != null && (value = entry.getValue()) != null) {
+            allResults.put(key, value);
+            i.remove();
+          }
+        }
+        if (isDebugEnabled) {
+          logger.debug("Added local results for getAll request: {}", allResults);
+        }
-          
+
-          if (value instanceof Throwable){
+          if (value instanceof Throwable) {
-          @Released EntryEventImpl event = EntryEventImpl.create(
-              this, Operation.LOCAL_LOAD_CREATE, key, value,
-              callback, false, getMyId(), true);
+          @Released
+          EntryEventImpl event = EntryEventImpl.create(this, Operation.LOCAL_LOAD_CREATE, key,
+              value, callback, false, getMyId(), true);
-          event.setFromServer(true);
-          event.setVersionTag(entry.getVersionTag());
+            event.setFromServer(true);
+            event.setVersionTag(entry.getVersionTag());
-          if (!alreadyInvalid(key, event)) { // bug #47716 - don't update if it's already here & invalid
-            TXStateProxy tx = this.cache.getTXMgr().internalSuspend();
-            try {
-              basicPutEntry(event, 0L);
-            } catch (ConcurrentCacheModificationException e) {
-              if (isDebugEnabled) {
-                logger.debug("getAll result for {} not stored in cache due to concurrent modification", key);
+            if (!alreadyInvalid(key, event)) { // bug #47716 - don't update if it's already here &
+                                               // invalid
+              TXStateProxy tx = this.cache.getTXMgr().internalSuspend();
+              try {
+                basicPutEntry(event, 0L);
+              } catch (ConcurrentCacheModificationException e) {
+                if (isDebugEnabled) {
+                  logger.debug(
+                      "getAll result for {} not stored in cache due to concurrent modification",
+                      key);
+                }
+              } finally {
+                this.cache.getTXMgr().resume(tx);
-            } finally {
-              this.cache.getTXMgr().resume(tx);
+              getCachePerfStats().endPut(startPut, event.isOriginRemote());
-            getCachePerfStats().endPut(startPut, event.isOriginRemote());
-          }
-          if (!createTombstone) {
-            allResults.put(key, value);
-            if (isTraceEnabled) {
-              logger.trace("Added remote result for getAll request: {}, {}", key, value);
+            if (!createTombstone) {
+              allResults.put(key, value);
+              if (isTraceEnabled) {
+                logger.trace("Added remote result for getAll request: {}, {}", key, value);
+              }
-          }
-          logger.warn(LocalizedMessage.create(LocalizedStrings.LocalRegion_THE_FOLLOWING_EXCEPTION_OCCURRED_ATTEMPTING_TO_GET_KEY_0, key), e);
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.LocalRegion_THE_FOLLOWING_EXCEPTION_OCCURRED_ATTEMPTING_TO_GET_KEY_0,
+              key), e);
-      mapEntry = (Map.Entry)iterator.next();
+      mapEntry = (Map.Entry) iterator.next();
-      // Threshold check should not be performed again 
+      // Threshold check should not be performed again
+
-    for (Object key: keys) {
+    for (Object key : keys) {
+   * 
-   * @param retryVersions a map of key->version tag. If any of the entries
-   * are the result of a retried client event, we need to make sure we send
-   * the original version tag along with the event.
+   * @param retryVersions a map of key->version tag. If any of the entries are the result of a
+   *        retried client event, we need to make sure we send the original version tag along with
+   *        the event.
-  public VersionedObjectList basicBridgePutAll(Map map, Map<Object, VersionTag> retryVersions, ClientProxyMembershipID memberId,
-      EventID eventId, boolean skipCallbacks, Object callbackArg) throws TimeoutException, CacheWriterException
-  {
+  public VersionedObjectList basicBridgePutAll(Map map, Map<Object, VersionTag> retryVersions,
+      ClientProxyMembershipID memberId, EventID eventId, boolean skipCallbacks, Object callbackArg)
+      throws TimeoutException, CacheWriterException {
-    if(isGatewaySenderEnabled()) {
+    if (isGatewaySenderEnabled()) {
-  
-    @Released final EntryEventImpl event = EntryEventImpl.create(this, Operation.PUTALL_CREATE, null,
-        null /* new value */, callbackArg,
-        false /* origin remote */, memberId.getDistributedMember(),
-        !skipCallbacks /* generateCallbacks */,
-        eventId);
+
+    @Released
+    final EntryEventImpl event = EntryEventImpl.create(this, Operation.PUTALL_CREATE, null,
+        null /* new value */, callbackArg, false /* origin remote */,
+        memberId.getDistributedMember(), !skipCallbacks /* generateCallbacks */, eventId);
-    event.setContext(memberId);
-    DistributedPutAllOperation putAllOp = new DistributedPutAllOperation(event,
-        map.size(), true);
-    try {
-    VersionedObjectList result = basicPutAll(map, putAllOp, retryVersions);
-    getCachePerfStats().endPutAll(startPut);
-    return result;
-    } finally {
-      putAllOp.freeOffHeapResources();
-    }
+      event.setContext(memberId);
+      DistributedPutAllOperation putAllOp = new DistributedPutAllOperation(event, map.size(), true);
+      try {
+        VersionedObjectList result = basicPutAll(map, putAllOp, retryVersions);
+        getCachePerfStats().endPutAll(startPut);
+        return result;
+      } finally {
+        putAllOp.freeOffHeapResources();
+      }
-  
+
+   * 
-   * @param retryVersions a collection of version tags. If the client is retrying a key
-   * then that keys slot will be non-null in this collection. Note that keys and retryVersions are parallel lists.
+   * @param retryVersions a collection of version tags. If the client is retrying a key then that
+   *        keys slot will be non-null in this collection. Note that keys and retryVersions are
+   *        parallel lists.
-  public VersionedObjectList basicBridgeRemoveAll(ArrayList<Object> keys, ArrayList<VersionTag> retryVersions, ClientProxyMembershipID memberId,
-      EventID eventId, Object callbackArg) throws TimeoutException, CacheWriterException
-  {
+  public VersionedObjectList basicBridgeRemoveAll(ArrayList<Object> keys,
+      ArrayList<VersionTag> retryVersions, ClientProxyMembershipID memberId, EventID eventId,
+      Object callbackArg) throws TimeoutException, CacheWriterException {
-    if(isGatewaySenderEnabled()) {
+    if (isGatewaySenderEnabled()) {
-  
-    @Released final EntryEventImpl event = EntryEventImpl.create(this, Operation.REMOVEALL_DESTROY, null,
-        null /* new value */, callbackArg,
-        false /* origin remote */, memberId.getDistributedMember(),
-        true /* generateCallbacks */,
-        eventId);
+
+    @Released
+    final EntryEventImpl event = EntryEventImpl.create(this, Operation.REMOVEALL_DESTROY, null,
+        null /* new value */, callbackArg, false /* origin remote */,
+        memberId.getDistributedMember(), true /* generateCallbacks */, eventId);
-    event.setContext(memberId);
-    DistributedRemoveAllOperation removeAllOp = new DistributedRemoveAllOperation(event, keys.size(), true);
-    try {
-    VersionedObjectList result = basicRemoveAll(keys, removeAllOp, retryVersions);
-    getCachePerfStats().endRemoveAll(startOp);
-    return result;
-    } finally {
-      removeAllOp.freeOffHeapResources();
-    }
+      event.setContext(memberId);
+      DistributedRemoveAllOperation removeAllOp =
+          new DistributedRemoveAllOperation(event, keys.size(), true);
+      try {
+        VersionedObjectList result = basicRemoveAll(keys, removeAllOp, retryVersions);
+        getCachePerfStats().endRemoveAll(startOp);
+        return result;
+      } finally {
+        removeAllOp.freeOffHeapResources();
+      }
-  
+
-    @Released EntryEventImpl event = EntryEventImpl.create(this, Operation.PUTALL_CREATE,
-        null, null, null, true, getMyId(), !skipCallbacks);
+    @Released
+    EntryEventImpl event = EntryEventImpl.create(this, Operation.PUTALL_CREATE, null, null, null,
+        true, getMyId(), !skipCallbacks);
-    DistributedPutAllOperation putAllOp = new DistributedPutAllOperation(event, map.size(), false);
-    try {
-    VersionedObjectList result = basicPutAll(map, putAllOp, null);
-    getCachePerfStats().endPutAll(startPut);
-    return result;
-    } finally {
-      putAllOp.freeOffHeapResources();
-    }
+      DistributedPutAllOperation putAllOp =
+          new DistributedPutAllOperation(event, map.size(), false);
+      try {
+        VersionedObjectList result = basicPutAll(map, putAllOp, null);
+        getCachePerfStats().endPutAll(startPut);
+        return result;
+      } finally {
+        putAllOp.freeOffHeapResources();
+      }
-      basicPutAll(map, putAllOp, null);
+        basicPutAll(map, putAllOp, null);
-    
+
-  
+
-  
+
-      basicRemoveAll(keys, op, null);
+        basicRemoveAll(keys, op, null);
-  
+
-   * Returns true if a one-hop (RemoteOperationMessage) should be used when applying the change
-   * to the system.
+   * Returns true if a one-hop (RemoteOperationMessage) should be used when applying the change to
+   * the system.
-        proxyResult = getServerProxy().putAll(map, eventId, !event.isGenerateCallbacks(), event.getCallbackArgument());
+        proxyResult = getServerProxy().putAll(map, eventId, !event.isGenerateCallbacks(),
+            event.getCallbackArgument());
-          logger.debug("putAll in client encountered a PutAllPartialResultException:{}\n. Adjusted keys are: ",
+          logger.debug(
+              "putAll in client encountered a PutAllPartialResultException:{}\n. Adjusted keys are: ",
-          e = getCancelCriterion().generateCancelledException(e1.getFailure());//for cache close
-          if(e == null) {
-            e = new ServerOperationException(LocalizedStrings.Region_PutAll_Applied_PartialKeys_At_Server_0.toLocalizedString(getFullPath()), e1.getFailure());
+          e = getCancelCriterion().generateCancelledException(e1.getFailure());// for cache close
+          if (e == null) {
+            e = new ServerOperationException(
+                LocalizedStrings.Region_PutAll_Applied_PartialKeys_At_Server_0
+                    .toLocalizedString(getFullPath()),
+                e1.getFailure());
-    
-    final VersionedObjectList succeeded = new VersionedObjectList(map.size(), true, this.concurrencyChecksEnabled);
-    // if this is a transactional putAll, we will not have version information as it is only generated at commit
+
+    final VersionedObjectList succeeded =
+        new VersionedObjectList(map.size(), true, this.concurrencyChecksEnabled);
+    // if this is a transactional putAll, we will not have version information as it is only
+    // generated at commit
-        int size = (proxyResult == null)? map.size() : proxyResult.size();
+        int size = (proxyResult == null) ? map.size() : proxyResult.size();
-          logger.debug( "size of put result is {} maps is {} proxyResult is {}", size, map, proxyResult);
+          logger.debug("size of put result is {} maps is {} proxyResult is {}", size, map,
+              proxyResult);
-              Map.Entry mapEntry = (Map.Entry)iterator.next();
+              Map.Entry mapEntry = (Map.Entry) iterator.next();
-                versionTag = ((VersionedObjectList.Entry)mapEntry).getVersionTag();
+                versionTag = ((VersionedObjectList.Entry) mapEntry).getVersionTag();
-                if (versionTag == null && serverIsVersioned && concurrencyChecksEnabled && dataPolicy.withStorage()) {
+                if (versionTag == null && serverIsVersioned && concurrencyChecksEnabled
+                    && dataPolicy.withStorage()) {
-                  // failure or migration during the operation.  We destroy the
+                  // failure or migration during the operation. We destroy the
-                  //If we have received a version tag from a server, add it to the event
+                  // If we have received a version tag from a server, add it to the event
-                  //If this is a retried event, and we have a version tag for the retry,
-                  //add it to the event.
+                  // If this is a retried event, and we have a version tag for the retry,
+                  // add it to the event.
-              } 
-              catch (Exception ex) {
+              } catch (Exception ex) {
-          // Bug 51725: Now succeeded contains an order key list, may be missing the version tags. 
+          // Bug 51725: Now succeeded contains an order key list, may be missing the version tags.
-          // postPutAll() to fill in the version tags. 
+          // postPutAll() to fill in the version tags.
-          logger.info(LocalizedMessage.create(LocalizedStrings.Region_PutAll_Applied_PartialKeys_0_1,
-              new Object[] {getFullPath(), partialKeys}));
+          logger
+              .info(LocalizedMessage.create(LocalizedStrings.Region_PutAll_Applied_PartialKeys_0_1,
+                  new Object[] {getFullPath(), partialKeys}));
-                e = (CancelException)partialKeys.getFailure(); 
+                e = (CancelException) partialKeys.getFailure();
-                throw partialKeys.getFailure();  // fix for #43589
+                throw partialKeys.getFailure(); // fix for #43589
-                  logger.debug("basicPutAll:"+partialKeys.detailString());
+                  logger.debug("basicPutAll:" + partialKeys.detailString());
-      }
-      catch (LowMemoryException lme) {
+      } catch (LowMemoryException lme) {
-      }
-      catch (RuntimeException ex) {
+      } catch (RuntimeException ex) {
-      }
-      catch (Exception ex) {
+      } catch (Exception ex) {
-    final DistributedRemoveAllOperation removeAllOp, final ArrayList<VersionTag> retryVersions) {
+      final DistributedRemoveAllOperation removeAllOp, final ArrayList<VersionTag> retryVersions) {
-          logger.debug("removeAll in client encountered a BulkOpPartialResultException: {}\n. Adjusted keys are: {}", e1.getMessage(), proxyResult.getKeys());
+          logger.debug(
+              "removeAll in client encountered a BulkOpPartialResultException: {}\n. Adjusted keys are: {}",
+              e1.getMessage(), proxyResult.getKeys());
-          e = new ServerOperationException(LocalizedStrings.Region_RemoveAll_Applied_PartialKeys_At_Server_0.toLocalizedString(getFullPath()), e1.getFailure());
+          e = new ServerOperationException(
+              LocalizedStrings.Region_RemoveAll_Applied_PartialKeys_At_Server_0
+                  .toLocalizedString(getFullPath()),
+              e1.getFailure());
-    
-    final VersionedObjectList succeeded = new VersionedObjectList(keys.size(), true, this.concurrencyChecksEnabled);
-    // If this is a transactional removeAll, we will not have version information as it is only generated at commit
+
+    final VersionedObjectList succeeded =
+        new VersionedObjectList(keys.size(), true, this.concurrencyChecksEnabled);
+    // If this is a transactional removeAll, we will not have version information as it is only
+    // generated at commit
-        int size = (proxyResult == null)? keys.size() : proxyResult.size();
+        int size = (proxyResult == null) ? keys.size() : proxyResult.size();
-            logger.trace(
-                "size of removeAll result is {} keys are {} proxyResult is {}", size, keys, proxyResult);
+            logger.trace("size of removeAll result is {} keys are {} proxyResult is {}", size, keys,
+                proxyResult);
-              logger.trace(
-                  "size of removeAll result is {} keys are {} proxyResult is {}", size, keys, proxyResult);
+              logger.trace("size of removeAll result is {} keys are {} proxyResult is {}", size,
+                  keys, proxyResult);
-            logger.trace(
-                "size of removeAll result is {} keys are {} proxyResult is {}", size, keys, proxyResult);
+            logger.trace("size of removeAll result is {} keys are {} proxyResult is {}", size, keys,
+                proxyResult);
-                Map.Entry mapEntry = (Map.Entry)iterator.next();
+                Map.Entry mapEntry = (Map.Entry) iterator.next();
-                versionTag = ((VersionedObjectList.Entry)mapEntry).getVersionTag();
+                versionTag = ((VersionedObjectList.Entry) mapEntry).getVersionTag();
-                  logger.debug("removeAll key {} version={}",key, versionTag);
+                  logger.debug("removeAll key {} version={}", key, versionTag);
-                    logger.debug("removeAll found invalid version tag, which means the entry is not found at server for key={}.", key);
+                    logger.debug(
+                        "removeAll found invalid version tag, which means the entry is not found at server for key={}.",
+                        key);
-                  //If we have received a version tag from a server, add it to the event
+                  // If we have received a version tag from a server, add it to the event
-                    //If this is a retried event, and we have a version tag for the retry,
-                    //add it to the event.
+                    // If this is a retried event, and we have a version tag for the retry,
+                    // add it to the event.
-              } 
-              catch (Exception ex) {
+              } catch (Exception ex) {
-          // Bug 51725: Now succeeded contains an order key list, may be missing the version tags. 
+          // Bug 51725: Now succeeded contains an order key list, may be missing the version tags.
-          logger.info(LocalizedMessage.create(LocalizedStrings.Region_RemoveAll_Applied_PartialKeys_0_1,
-              new Object[] {getFullPath(), partialKeys}));
+          logger.info(
+              LocalizedMessage.create(LocalizedStrings.Region_RemoveAll_Applied_PartialKeys_0_1,
+                  new Object[] {getFullPath(), partialKeys}));
-                e = (CancelException)partialKeys.getFailure(); 
+                e = (CancelException) partialKeys.getFailure();
-                throw partialKeys.getFailure();  // fix for #43589
+                throw partialKeys.getFailure(); // fix for #43589
-                  logger.debug("basicRemoveAll:"+partialKeys.detailString());
+                  logger.debug("basicRemoveAll:" + partialKeys.detailString());
-      }
-      catch (LowMemoryException lme) {
+      } catch (LowMemoryException lme) {
-      }
-      catch (RuntimeException ex) {
+      } catch (RuntimeException ex) {
-      }
-      catch (Exception ex) {
+      } catch (Exception ex) {
-  
+
-   *  bug #46924 - putAll can be partially applied when a clear() occurs, leaving
-   *  the cache in an inconsistent state.  Set the RVV to "cache op in progress"
-   *  so clear() will block until the putAll completes.  This won't work for
-   *  non-replicate regions though since they uses one-hop during basicPutPart2
-   *  to get a valid version tag.
+   * bug #46924 - putAll can be partially applied when a clear() occurs, leaving the cache in an
+   * inconsistent state. Set the RVV to "cache op in progress" so clear() will block until the
+   * putAll completes. This won't work for non-replicate regions though since they uses one-hop
+   * during basicPutPart2 to get a valid version tag.
-    if(alth!=null) { 
-      alth.beforeBulkLock(this); 
+    if (alth != null) {
+      alth.beforeBulkLock(this);
-    
+
-    
-    if(alth!=null) {
+
+    if (alth != null) {
-  
+
-    if(alth!=null) {
+    if (alth != null) {
-    
+
-    
-    if(alth!=null) {
+
+    if (alth != null) {
-      throw new NullPointerException(LocalizedStrings
-          .AbstractRegion_MAP_CANNOT_BE_NULL.toLocalizedString());
+      throw new NullPointerException(
+          LocalizedStrings.AbstractRegion_MAP_CANNOT_BE_NULL.toLocalizedString());
-    // Create a dummy event for the PutAll operation.  Always create a
+    // Create a dummy event for the PutAll operation. Always create a
-    final EntryEventImpl event = EntryEventImpl.create(this,
-        Operation.PUTALL_CREATE, null, null, callbackArg, true, getMyId());
+    final EntryEventImpl event = EntryEventImpl.create(this, Operation.PUTALL_CREATE, null, null,
+        callbackArg, true, getMyId());
-  
-  public final DistributedRemoveAllOperation newRemoveAllOperation(Collection<?> keys, Object callbackArg) {
+
+  public final DistributedRemoveAllOperation newRemoveAllOperation(Collection<?> keys,
+      Object callbackArg) {
-    // Create a dummy event for the removeAll operation.  Always create a
+    // Create a dummy event for the removeAll operation. Always create a
+   * 
-  protected final void basicEntryPutAll(Object key,
-      Object value,
-      DistributedPutAllOperation putallOp,
-      int offset,
-      EntryEventImpl tagHolder)
+  protected final void basicEntryPutAll(Object key, Object value,
+      DistributedPutAllOperation putallOp, int offset, EntryEventImpl tagHolder)
-//    long startPut = CachePerfStats.getStatTime();
+    // long startPut = CachePerfStats.getStatTime();
-      throw new NullPointerException(LocalizedStrings.LocalRegion_VALUE_CANNOT_BE_NULL.toLocalizedString());
+      throw new NullPointerException(
+          LocalizedStrings.LocalRegion_VALUE_CANNOT_BE_NULL.toLocalizedString());
-    @Released EntryEventImpl event = EntryEventImpl.createPutAllEvent(
-        putallOp, this, Operation.PUTALL_CREATE, key, value);
+    @Released
+    EntryEventImpl event =
+        EntryEventImpl.createPutAllEvent(putallOp, this, Operation.PUTALL_CREATE, key, value);
-    if (tagHolder != null) {
-      event.setVersionTag(tagHolder.getVersionTag());
-      event.setFromServer(tagHolder.isFromServer());
-    }
-    if (generateEventID()) {
-      event.setEventId(new EventID(putallOp.getBaseEvent().getEventId(), offset));
-    }
-    discoverJTA(); // TODO: This could be called once for the entire putAll instead of calling it for every key
+      if (tagHolder != null) {
+        event.setVersionTag(tagHolder.getVersionTag());
+        event.setFromServer(tagHolder.isFromServer());
+      }
+      if (generateEventID()) {
+        event.setEventId(new EventID(putallOp.getBaseEvent().getEventId(), offset));
+      }
+      discoverJTA(); // TODO: This could be called once for the entire putAll instead of calling it
+                     // for every key
-    /*
-     * If this is tx, do putEntry, unless it is a local region? 
-     */
-    performPutAllEntry(event);
-    if (tagHolder != null) {
-      tagHolder.setVersionTag(event.getVersionTag());
-      tagHolder.isConcurrencyConflict(event.isConcurrencyConflict());
-    }
+      /*
+       * If this is tx, do putEntry, unless it is a local region?
+       */
+      performPutAllEntry(event);
+      if (tagHolder != null) {
+        tagHolder.setVersionTag(event.getVersionTag());
+        tagHolder.isConcurrencyConflict(event.isConcurrencyConflict());
+      }
-  
-  
-  protected final void basicEntryRemoveAll(Object key,
-      DistributedRemoveAllOperation op,
-      int offset,
-      EntryEventImpl tagHolder)
-      throws TimeoutException, CacheWriterException {
+
+
+  protected final void basicEntryRemoveAll(Object key, DistributedRemoveAllOperation op, int offset,
+      EntryEventImpl tagHolder) throws TimeoutException, CacheWriterException {
-    @Released EntryEventImpl event = EntryEventImpl.createRemoveAllEvent(op, this, key);
+    @Released
+    EntryEventImpl event = EntryEventImpl.createRemoveAllEvent(op, this, key);
-    if (tagHolder != null) {
-      event.setVersionTag(tagHolder.getVersionTag());
-      event.setFromServer(tagHolder.isFromServer());
-    }
-    if (generateEventID()) {
-      event.setEventId(new EventID(op.getBaseEvent().getEventId(), offset));
-    }
-    discoverJTA(); // TODO: This could be called once for the entire removeAll instead of calling it for every key
+      if (tagHolder != null) {
+        event.setVersionTag(tagHolder.getVersionTag());
+        event.setFromServer(tagHolder.isFromServer());
+      }
+      if (generateEventID()) {
+        event.setEventId(new EventID(op.getBaseEvent().getEventId(), offset));
+      }
+      discoverJTA(); // TODO: This could be called once for the entire removeAll instead of calling
+                     // it for every key
-    /*
-     * If this is tx, do removeEntry, unless it is a local region? 
-     */
-    try {
-      performRemoveAllEntry(event);
-    } catch (EntryNotFoundException ignore) {
-      if (event.getVersionTag() == null) {
-        if (logger.isDebugEnabled()) {
-          logger.debug("RemoveAll encoutered EntryNotFoundException: event={}", event);
+      /*
+       * If this is tx, do removeEntry, unless it is a local region?
+       */
+      try {
+        performRemoveAllEntry(event);
+      } catch (EntryNotFoundException ignore) {
+        if (event.getVersionTag() == null) {
+          if (logger.isDebugEnabled()) {
+            logger.debug("RemoveAll encoutered EntryNotFoundException: event={}", event);
+          }
-    }
-    if (tagHolder != null) {
-      tagHolder.setVersionTag(event.getVersionTag());
-      tagHolder.isConcurrencyConflict(event.isConcurrencyConflict());
-    }
+      if (tagHolder != null) {
+        tagHolder.setVersionTag(event.getVersionTag());
+        tagHolder.isConcurrencyConflict(event.isConcurrencyConflict());
+      }
+
+
-    //getDataView().destroyExistingEntry(event, true, null);
+    // getDataView().destroyExistingEntry(event, true, null);
-  public void postPutAllFireEvents(DistributedPutAllOperation putallOp, VersionedObjectList successfulPuts)
-  {
+  public void postPutAllFireEvents(DistributedPutAllOperation putallOp,
+      VersionedObjectList successfulPuts) {
-    for (Object key: successfulPuts.getKeys()) {
+    for (Object key : successfulPuts.getKeys()) {
-    for (Iterator it=putallOp.eventIterator(); it.hasNext(); ) {
-      @Unretained EntryEventImpl event = (EntryEventImpl)it.next();
+    for (Iterator it = putallOp.eventIterator(); it.hasNext();) {
+      @Unretained
+      EntryEventImpl event = (EntryEventImpl) it.next();
-            : EnumListenerEvent.AFTER_UPDATE; 
+            : EnumListenerEvent.AFTER_UPDATE;
-            false /* We must notify gateways inside RegionEntry lock, NOT here, to preserve the order of events sent by gateways for same key*/);
+            false /*
+                   * We must notify gateways inside RegionEntry lock, NOT here, to preserve the
+                   * order of events sent by gateways for same key
+                   */);
-  
-  public void postRemoveAllFireEvents(DistributedRemoveAllOperation op, VersionedObjectList successfulOps) {
+
+  public void postRemoveAllFireEvents(DistributedRemoveAllOperation op,
+      VersionedObjectList successfulOps) {
-    for (Object key: successfulOps.getKeys()) {
+    for (Object key : successfulOps.getKeys()) {
-    for (Iterator it=op.eventIterator(); it.hasNext(); ) {
-      @Unretained EntryEventImpl event = (EntryEventImpl)it.next();
+    for (Iterator it = op.eventIterator(); it.hasNext();) {
+      @Unretained
+      EntryEventImpl event = (EntryEventImpl) it.next();
-        invokeDestroyCallbacks(EnumListenerEvent.AFTER_DESTROY, event, !event.callbacksInvoked() && !event.isPossibleDuplicate(),
-            false /* We must notify gateways inside RegionEntry lock, NOT here, to preserve the order of events sent by gateways for same key*/);
+        invokeDestroyCallbacks(EnumListenerEvent.AFTER_DESTROY, event,
+            !event.callbacksInvoked() && !event.isPossibleDuplicate(),
+            false /*
+                   * We must notify gateways inside RegionEntry lock, NOT here, to preserve the
+                   * order of events sent by gateways for same key
+                   */);
-  
-  public void postPutAllSend(DistributedPutAllOperation putallOp, VersionedObjectList successfulPuts)
-  { 
-          /* No-op for local region of course */
+
+  public void postPutAllSend(DistributedPutAllOperation putallOp,
+      VersionedObjectList successfulPuts) {
+    /* No-op for local region of course */
-  public void postRemoveAllSend(DistributedRemoveAllOperation op, VersionedObjectList successfulOps)
-  { 
-          /* No-op for local region of course */
+
+  public void postRemoveAllSend(DistributedRemoveAllOperation op,
+      VersionedObjectList successfulOps) {
+    /* No-op for local region of course */
-  
-  
+
+
-  protected boolean isCurrentlyLockGrantor()
-  {
+  protected boolean isCurrentlyLockGrantor() {
-   * Handle a local region destroy or a region close that was done on this
-   * region in a remote vm. Currently the only thing needed is to have the
-   * advisor
+   * Handle a local region destroy or a region close that was done on this region in a remote vm.
+   * Currently the only thing needed is to have the advisor
-   * @param regionDestroyed true if the region was destroyed on the remote host (as opposed to closed)
+   * @param regionDestroyed true if the region was destroyed on the remote host (as opposed to
+   *        closed)
-  final void handleRemoteLocalRegionDestroyOrClose(
-      InternalDistributedMember sender,
-      int topSerial,
+  final void handleRemoteLocalRegionDestroyOrClose(InternalDistributedMember sender, int topSerial,
-      basicHandleRemoteLocalRegionDestroyOrClose(
-            sender, topSerial, subregionSerialNumbers, false, regionDestroyed);
-    }
-    finally {
+      basicHandleRemoteLocalRegionDestroyOrClose(sender, topSerial, subregionSerialNumbers, false,
+          regionDestroyed);
+    } finally {
-   * @param regionDestroyed 
+   * @param regionDestroyed
-  private final void basicHandleRemoteLocalRegionDestroyOrClose(
-      InternalDistributedMember sender,
-      int topSerial,
-      Map subregionSerialNumbers,
-      boolean subregion, boolean regionDestroyed) {
+  private final void basicHandleRemoteLocalRegionDestroyOrClose(InternalDistributedMember sender,
+      int topSerial, Map subregionSerialNumbers, boolean subregion, boolean regionDestroyed) {
-      }
-      else {
+      } else {
-        r.basicHandleRemoteLocalRegionDestroyOrClose(
-            sender, topSerial, subregionSerialNumbers, true, regionDestroyed);
+        r.basicHandleRemoteLocalRegionDestroyOrClose(sender, topSerial, subregionSerialNumbers,
+            true, regionDestroyed);
-  
+
-   * @param regionDestroyed 
+   * 
+   * @param regionDestroyed
-  protected void removeSenderFromAdvisor(InternalDistributedMember sender, int serial, boolean regionDestroyed)
-  {
+  protected void removeSenderFromAdvisor(InternalDistributedMember sender, int serial,
+      boolean regionDestroyed) {
-  final public boolean isUsedForPartitionedRegionAdmin()
-  {
+  final public boolean isUsedForPartitionedRegionAdmin() {
-   * This method determines whether this region should synchronize with peer replicated regions
-   * when the given member has crashed.
+   * This method determines whether this region should synchronize with peer replicated regions when
+   * the given member has crashed.
+   * 
-    return this.concurrencyChecksEnabled
-        && this.dataPolicy.withReplication()
-        && !this.isUsedForPartitionedRegionAdmin
-        && !this.isUsedForMetaRegion
+    return this.concurrencyChecksEnabled && this.dataPolicy.withReplication()
+        && !this.isUsedForPartitionedRegionAdmin && !this.isUsedForMetaRegion
- /**
+  /**
+   * 
-    if(this.diskRegion!=null){
+    if (this.diskRegion != null) {
-  
+
-   * filterProfile holds CQ and registerInterest information for clients
-   * having this region
+   * filterProfile holds CQ and registerInterest information for clients having this region
-   * @return int array containing the IDs of the oplogs which will potentially
-   * get rolled else null if no oplogs were available at the time of signal or region
-   * is not having disk persistence. Pls note that the actual number of oplogs 
-   * rolled may be more than what is indicated
+   * @return int array containing the IDs of the oplogs which will potentially get rolled else null
+   *         if no oplogs were available at the time of signal or region is not having disk
+   *         persistence. Pls note that the actual number of oplogs rolled may be more than what is
+   *         indicated
-  public boolean forceCompaction()
-  {
+  public boolean forceCompaction() {
-        throw new IllegalStateException("To call notifyToCompact you must configure the region with <disk-write-attributes allow-force-compaction=true/>");
+        throw new IllegalStateException(
+            "To call notifyToCompact you must configure the region with <disk-write-attributes allow-force-compaction=true/>");
-    }
-    else {
+    } else {
-  public boolean isUsedForPartitionedRegionBucket()
-  {
+  public boolean isUsedForPartitionedRegionBucket() {
-  
+
-  
+
-  
-  public AbstractGatewaySender getSerialGatewaySender(){
+
+  public AbstractGatewaySender getSerialGatewaySender() {
-      if (regionGatewaySenderIds.contains(sender.getId())
-          && sender.isParallel()) {
+      if (regionGatewaySenderIds.contains(sender.getId()) && sender.isParallel()) {
-  
+
-   * @return If this is an instance of {@link BucketRegion}, returns the
-   * {@link PartitionedRegion} otherwise throws an IllegalArgumentException
+   * 
+   * @return If this is an instance of {@link BucketRegion}, returns the {@link PartitionedRegion}
+   *         otherwise throws an IllegalArgumentException
-    return ((BucketRegion)this).getPartitionedRegion();
+    return ((BucketRegion) this).getPartitionedRegion();
+
-  final public boolean isUsedForMetaRegion()
-  {
+  final public boolean isUsedForMetaRegion() {
-  
-  final public boolean isMetaRegionWithTransactions()
-  {
+
+  final public boolean isMetaRegionWithTransactions() {
-  
+
-  final public boolean isInternalRegion(){
+  final public boolean isInternalRegion() {
-           || isUsedForPartitionedRegionBucket();
+        || isUsedForPartitionedRegionBucket();
-      boolean netSearchAllowed, boolean netLoadAllowed,
-      SearchLoadAndWriteProcessor searcher)
-  {
-    return new LoaderHelperImpl(this, key, callbackArgument, netSearchAllowed,
-        netLoadAllowed, searcher);
+      boolean netSearchAllowed, boolean netLoadAllowed, SearchLoadAndWriteProcessor searcher) {
+    return new LoaderHelperImpl(this, key, callbackArgument, netSearchAllowed, netLoadAllowed,
+        searcher);
-  private static final DistributionAdvisor.ProfileVisitor<Void> netLoaderVisitor
-      = new DistributionAdvisor.ProfileVisitor<Void>() {
-    public boolean visit(DistributionAdvisor advisor, Profile profile,
-        int profileIndex, int numProfiles, Void aggregate) {
-      assert profile instanceof CacheProfile;
-      final CacheProfile prof = (CacheProfile)profile;
+  private static final DistributionAdvisor.ProfileVisitor<Void> netLoaderVisitor =
+      new DistributionAdvisor.ProfileVisitor<Void>() {
+        public boolean visit(DistributionAdvisor advisor, Profile profile, int profileIndex,
+            int numProfiles, Void aggregate) {
+          assert profile instanceof CacheProfile;
+          final CacheProfile prof = (CacheProfile) profile;
-      // if region in cache is not yet initialized, exclude
-      if (prof.regionInitialized) { // fix for bug 41102
-        // cut the visit short if we find a CacheLoader
-        return !prof.hasCacheLoader;
-      }
-      // continue the visit
-      return true;
-    }
-  };
+          // if region in cache is not yet initialized, exclude
+          if (prof.regionInitialized) { // fix for bug 41102
+            // cut the visit short if we find a CacheLoader
+            return !prof.hasCacheLoader;
+          }
+          // continue the visit
+          return true;
+        }
+      };
-  private static final DistributionAdvisor.ProfileVisitor<Void> netWriterVisitor
-      = new DistributionAdvisor.ProfileVisitor<Void>() {
-    public boolean visit(DistributionAdvisor advisor, Profile profile,
-        int profileIndex, int numProfiles, Void aggregate) {
-      assert profile instanceof CacheProfile;
-      final CacheProfile prof = (CacheProfile)profile;
+  private static final DistributionAdvisor.ProfileVisitor<Void> netWriterVisitor =
+      new DistributionAdvisor.ProfileVisitor<Void>() {
+        public boolean visit(DistributionAdvisor advisor, Profile profile, int profileIndex,
+            int numProfiles, Void aggregate) {
+          assert profile instanceof CacheProfile;
+          final CacheProfile prof = (CacheProfile) profile;
-      // if region in cache is in recovery
-      if (!prof.inRecovery) {
-        // cut the visit short if we find a CacheWriter
-        return !prof.hasCacheWriter;
-      }
-      // continue the visit
-      return true;
-    }
-  };
+          // if region in cache is in recovery
+          if (!prof.inRecovery) {
+            // cut the visit short if we find a CacheWriter
+            return !prof.hasCacheWriter;
+          }
+          // continue the visit
+          return true;
+        }
+      };
-   * Return true if some other member of the distributed system, not including
-   * self, has a CacheLoader defined on the region.
+   * Return true if some other member of the distributed system, not including self, has a
+   * CacheLoader defined on the region.
-   * Return true if some other member of the distributed system, not including
-   * self, has a CacheWriter defined on the region.
+   * Return true if some other member of the distributed system, not including self, has a
+   * CacheWriter defined on the region.
-  protected boolean isSecret()
-  {
+  protected boolean isSecret() {
-  
+
-   * Used to prevent notification of bridge clients, typically used for internal
-   * "meta" regions and if the cache doesn't have any bridge servers
+   * Used to prevent notification of bridge clients, typically used for internal "meta" regions and
+   * if the cache doesn't have any bridge servers
-  protected boolean shouldNotifyBridgeClients()
-  {
-    return (this.cache.getCacheServers().size() > 0)
-        && !this.isUsedForPartitionedRegionAdmin
-        && !this.isUsedForPartitionedRegionBucket
-        && !this.isUsedForMetaRegion;
+  protected boolean shouldNotifyBridgeClients() {
+    return (this.cache.getCacheServers().size() > 0) && !this.isUsedForPartitionedRegionAdmin
+        && !this.isUsedForPartitionedRegionBucket && !this.isUsedForMetaRegion;
-  
+
-  
+
-  protected boolean shouldDispatchListenerEvent()
-  {
+  protected boolean shouldDispatchListenerEvent() {
-   * Internal method to return cache as GemFireCache to avoid unnecessary
-   * typecasting.
+   * Internal method to return cache as GemFireCache to avoid unnecessary typecasting.
+   * 
-  void cleanupForClient(CacheClientNotifier ccn,
-                        ClientProxyMembershipID client) {
-    if (this.cache.isClosed()) return;
-    if (this.isDestroyed) return;
-    
+  void cleanupForClient(CacheClientNotifier ccn, ClientProxyMembershipID client) {
+    if (this.cache.isClosed())
+      return;
+    if (this.isDestroyed)
+      return;
+
-    
+
-      LocalRegion lr = (LocalRegion)it.next();
+      LocalRegion lr = (LocalRegion) it.next();
-  
+
-  
+
-   * Destroys the CQ/interest profile for this region.  Use this if your
-   * region does not support client interest (e.g., WAN gateway queue)
+   * Destroys the CQ/interest profile for this region. Use this if your region does not support
+   * client interest (e.g., WAN gateway queue)
-  
+
-   * Returns a map of subregions that were destroyed when this region was
-   * destroyed. Map contains subregion full paths to SerialNumbers. Return is
-   * defined as HashMap because DestroyRegionOperation will provide the map to
-   * DataSerializer.writeHashMap which requires HashMap. Returns
-   * {@link #destroyedSubregionSerialNumbers}.
+   * Returns a map of subregions that were destroyed when this region was destroyed. Map contains
+   * subregion full paths to SerialNumbers. Return is defined as HashMap because
+   * DestroyRegionOperation will provide the map to DataSerializer.writeHashMap which requires
+   * HashMap. Returns {@link #destroyedSubregionSerialNumbers}.
-       LocalizedStrings.LocalRegion_REGION_0_MUST_BE_DESTROYED_BEFORE_CALLING_GETDESTROYEDSUBREGIONSERIALNUMBERS
-         .toLocalizedString(getFullPath()));
+          LocalizedStrings.LocalRegion_REGION_0_MUST_BE_DESTROYED_BEFORE_CALLING_GETDESTROYEDSUBREGIONSERIALNUMBERS
+              .toLocalizedString(getFullPath()));
-   * Returns a map of subregion full paths to SerialNumbers. Caller must have
-   * acquired the destroyLock if a stable view is desired. Key is String, value
-   * is Integer.
+   * Returns a map of subregion full paths to SerialNumbers. Caller must have acquired the
+   * destroyLock if a stable view is desired. Key is String, value is Integer.
-   * Iterates over all subregions to put the full path and serial number into
-   * the provided map.
+   * Iterates over all subregions to put the full path and serial number into the provided map.
-   * @param map the map to put the full path and serial number into for each
-   * subregion
+   * @param map the map to put the full path and serial number into for each subregion
-      Map.Entry entry = (Map.Entry)iter.next();
+      Map.Entry entry = (Map.Entry) iter.next();
-      map.put(subregion.getFullPath(),
-              Integer.valueOf(subregion.getSerialNumber()));
+      map.put(subregion.getFullPath(), Integer.valueOf(subregion.getSerialNumber()));
-  
+
-      TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException {
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-      for (int i=0; i<QUERY_PATTERNS.length; i++) {
+      for (int i = 0; i < QUERY_PATTERNS.length; i++) {
-      }
-      else {
+      } else {
-      }
-      catch (Exception e) {
+      } catch (Exception e) {
-    }
-    else {
+    } else {
-      DefaultQuery query = (DefaultQuery)qs.newQuery(queryStr);
-      results = (SelectResults)query.execute(new Object[0]);
+      DefaultQuery query = (DefaultQuery) qs.newQuery(queryStr);
+      results = (SelectResults) query.execute(new Object[0]);
-   * Called from the RegionMap when the {@link RegionEntry} is synchronized
-   * and it is safe to make decisions about Entry state
+   * Called from the RegionMap when the {@link RegionEntry} is synchronized and it is safe to make
+   * decisions about Entry state
+   * 
-  protected void checkBeforeEntrySync(TXRmtEvent txEvent) {
-  }
-  
-  
+  protected void checkBeforeEntrySync(TXRmtEvent txEvent) {}
+
+
-   * Execute the provided named function in all locations that contain the given
-   * keys. So function can be executed on just one fabric node, executed in
-   * parallel on a subset of nodes in parallel across all the nodes.
+   * Execute the provided named function in all locations that contain the given keys. So function
+   * can be executed on just one fabric node, executed in parallel on a subset of nodes in parallel
+   * across all the nodes.
-  public ResultCollector executeFunction(final DistributedRegionFunctionExecutor execution, final Function function, final Object args,
-      final ResultCollector rc,final Set filter, final ServerToClientFunctionResultSender sender) {   
+  public ResultCollector executeFunction(final DistributedRegionFunctionExecutor execution,
+      final Function function, final Object args, final ResultCollector rc, final Set filter,
+      final ServerToClientFunctionResultSender sender) {
-    if (function.optimizeForWrite() && memoryThresholdReached.get() &&
-        !MemoryThresholds.isLowMemoryExceptionDisabled()) {
+    if (function.optimizeForWrite() && memoryThresholdReached.get()
+        && !MemoryThresholds.isLowMemoryExceptionDisabled()) {
-      throw new LowMemoryException(LocalizedStrings.ResourceManager_LOW_MEMORY_FOR_0_FUNCEXEC_MEMBERS_1.toLocalizedString(
-          new Object[] {function.getId(), htrm}), htrm);
+      throw new LowMemoryException(
+          LocalizedStrings.ResourceManager_LOW_MEMORY_FOR_0_FUNCEXEC_MEMBERS_1
+              .toLocalizedString(new Object[] {function.getId(), htrm}),
+          htrm);
-    final LocalResultCollector<?, ?> localRC = execution
-        .getLocalResultCollector(function, rc);
+    final LocalResultCollector<?, ?> localRC = execution.getLocalResultCollector(function, rc);
-    final DistributedRegionFunctionResultSender resultSender = new DistributedRegionFunctionResultSender(
-        dm, localRC, function, sender);
-    final RegionFunctionContextImpl context = new RegionFunctionContextImpl(
-        function.getId(), LocalRegion.this, args, filter, null, null,
-        resultSender, execution.isReExecute());
+    final DistributedRegionFunctionResultSender resultSender =
+        new DistributedRegionFunctionResultSender(dm, localRC, function, sender);
+    final RegionFunctionContextImpl context = new RegionFunctionContextImpl(function.getId(),
+        LocalRegion.this, args, filter, null, null, resultSender, execution.isReExecute());
-  
+
-    return Collections.<DistributedMember> singleton(this.cache.getMyId());
+    return Collections.<DistributedMember>singleton(this.cache.getMyId());
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-      if (event.getState().isCritical()
-          && !event.getPreviousState().isCritical()
-          && (event.getType() == ResourceType.HEAP_MEMORY || (event.getType() == ResourceType.OFFHEAP_MEMORY && getOffHeap()))) {
+      if (event.getState().isCritical() && !event.getPreviousState().isCritical()
+          && (event.getType() == ResourceType.HEAP_MEMORY
+              || (event.getType() == ResourceType.OFFHEAP_MEMORY && getOffHeap()))) {
-      } else if (!event.getState().isCritical()
-          && event.getPreviousState().isCritical()
-          && (event.getType() == ResourceType.HEAP_MEMORY || (event.getType() == ResourceType.OFFHEAP_MEMORY && getOffHeap()))) {
+      } else if (!event.getState().isCritical() && event.getPreviousState().isCritical()
+          && (event.getType() == ResourceType.HEAP_MEMORY
+              || (event.getType() == ResourceType.OFFHEAP_MEMORY && getOffHeap()))) {
+
-   * Calculate and return the size of a value for updating the bucket size.
-   * Zero is always returned for non-bucket regions.
+   * Calculate and return the size of a value for updating the bucket size. Zero is always returned
+   * for non-bucket regions.
+
+
+
-    getDiskRegion().getStats().incNumEntriesInVM(numEntriesInVM); 
+    getDiskRegion().getStats().incNumEntriesInVM(numEntriesInVM);
-   * This method is meant to be overriden by DistributedRegion
-   * and PartitionedRegions to cleanup CRITICAL state
+   * This method is meant to be overriden by DistributedRegion and PartitionedRegions to cleanup
+   * CRITICAL state
-    Assert.assertTrue(false);   //should not be called for LocalRegion
+    Assert.assertTrue(false); // should not be called for LocalRegion
-   * Initialize the set of remote members whose memory state is critical.  This is
-   * called when registering using {@link InternalResourceManager#addResourceListener(ResourceType, ResourceListener)}.
-   * It should only be called once and very early in this region's lifetime.
+   * Initialize the set of remote members whose memory state is critical. This is called when
+   * registering using
+   * {@link InternalResourceManager#addResourceListener(ResourceType, ResourceListener)}. It should
+   * only be called once and very early in this region's lifetime.
-   * @see ResourceManager#setCriticalHeapPercentage(float) and ResourceManager#setCriticalOffHeapPercentage(float)
+   * @see ResourceManager#setCriticalHeapPercentage(float) and
+   *      ResourceManager#setCriticalOffHeapPercentage(float)
-  
+
-    @Released EntryEventImpl event = EntryEventImpl.create(this,
-        Operation.LOCAL_DESTROY, key, null, null, false, getMyId(), false);
+    @Released
+    EntryEventImpl event = EntryEventImpl.create(this, Operation.LOCAL_DESTROY, key, null, null,
+        false, getMyId(), false);
-    event.inhibitCacheListenerNotification(true);
-    mapDestroy(event, true, false, null, false, true);
+      event.inhibitCacheListenerNotification(true);
+      mapDestroy(event, true, false, null, false, true);
+
-    return (DiskEntry)re;
+    return (DiskEntry) re;
-   * Fetch the Region which stores the given key
-   * The resulting Region will be used for a read operation e.g. Region.get
+   * Fetch the Region which stores the given key The resulting Region will be used for a read
+   * operation e.g. Region.get
+   * 
-   * Fetch the Region which stores the given key.
-   * The resulting Region will be used for a write operation e.g. Region.put
+   * Fetch the Region which stores the given key. The resulting Region will be used for a write
+   * operation e.g. Region.put
+   * 
-   * @return a set of keys, intended for use by the various Region set operations
-   * such as {@link EntriesSet}
+   * @return a set of keys, intended for use by the various Region set operations such as
+   *         {@link EntriesSet}
+   * 
-   * @return localMember for local and distributedRegions,
-   * member with parimary bucket for partitionedRegions
+   * @return localMember for local and distributedRegions, member with parimary bucket for
+   *         partitionedRegions
-  
+
-  
-  void senderCreated()
-  {
+
+  void senderCreated() {
-  
-  void distributeUpdatedProfileOnSenderCreation()
-  {
+
+  void distributeUpdatedProfileOnSenderCreation() {
-  } 
-  
-  static class RegionPerfStats extends CachePerfStats{
+  }
+
+  static class RegionPerfStats extends CachePerfStats {
-    
+
-    
-     @Override
+
+    @Override
-       stats.incInt(reliableQueuedOpsId, inc);
-       this.cachePerfStats.incReliableQueuedOps(inc);
-     }
-     
-     @Override
+      stats.incInt(reliableQueuedOpsId, inc);
+      this.cachePerfStats.incReliableQueuedOps(inc);
+    }
+
+    @Override
-       stats.incInt(reliableQueueSizeId, inc);
-       this.cachePerfStats.incReliableQueueSize(inc);
-     }
-     @Override
+      stats.incInt(reliableQueueSizeId, inc);
+      this.cachePerfStats.incReliableQueueSize(inc);
+    }
+
+    @Override
-       stats.incInt(reliableQueueMaxId, inc);
-       this.cachePerfStats.incReliableQueueMax(inc);
-     }
-     @Override
+      stats.incInt(reliableQueueMaxId, inc);
+      this.cachePerfStats.incReliableQueueMax(inc);
+    }
+
+    @Override
-       stats.incInt(reliableRegionsId, inc);
-       this.cachePerfStats.incReliableRegions(inc);
-     }
-     @Override
+      stats.incInt(reliableRegionsId, inc);
+      this.cachePerfStats.incReliableRegions(inc);
+    }
+
+    @Override
-       stats.incInt(reliableRegionsMissingId, inc);
-       this.cachePerfStats.incReliableRegionsMissing(inc);
-     }
-     @Override
+      stats.incInt(reliableRegionsMissingId, inc);
+      this.cachePerfStats.incReliableRegionsMissing(inc);
+    }
+
+    @Override
-       stats.incInt(reliableRegionsQueuingId, inc);
-       this.cachePerfStats.incReliableRegionsQueuing(inc);
-     }
+      stats.incInt(reliableRegionsQueuingId, inc);
+      this.cachePerfStats.incReliableRegionsQueuing(inc);
+    }
-     
+
-      //return NanoTimer.getTime(); // don't use getStatTime so always enabled
-    } 
+      // return NanoTimer.getTime(); // don't use getStatTime so always enabled
+    }
+
-     * @param start the timestamp taken when the operation started 
+     * @param start the timestamp taken when the operation started
-      stats.incLong(loadTimeId, ts-start);
+      stats.incLong(loadTimeId, ts - start);
-      this.cachePerfStats.endLoad(start); //need to think about timings
+      this.cachePerfStats.endLoad(start); // need to think about timings
-    
+
-    } 
+    }
+
-     * @param start the timestamp taken when the operation started 
+     * @param start the timestamp taken when the operation started
-        stats.incLong(netloadTimeId, getStatTime()-start);
+        stats.incLong(netloadTimeId, getStatTime() - start);
-      //return NanoTimer.getTime(); // don't use getStatTime so always enabled
+      // return NanoTimer.getTime(); // don't use getStatTime so always enabled
+
-     * @param start the timestamp taken when the operation started 
+     * @param start the timestamp taken when the operation started
-      stats.incLong(netsearchTimeId, ts-start);
+      stats.incLong(netsearchTimeId, ts - start);
-    
+
+
-     * @param start the timestamp taken when the operation started 
+     * @param start the timestamp taken when the operation started
-        stats.incLong(cacheWriterCallTimeId, getStatTime()-start);
+        stats.incLong(cacheWriterCallTimeId, getStatTime() - start);
-    
+
+
-     * @param start the timestamp taken when the operation started 
+     * @param start the timestamp taken when the operation started
-        stats.incLong(cacheListenerCallTimeId, getStatTime()-start);
+        stats.incLong(cacheListenerCallTimeId, getStatTime() - start);
-    
+
+
-     * @param start the timestamp taken when the operation started 
+     * @param start the timestamp taken when the operation started
-        stats.incLong(getInitialImageTimeId, getStatTime()-start);
+        stats.incLong(getInitialImageTimeId, getStatTime() - start);
-    
+
-     * @param start the timestamp taken when the operation started 
+     * @param start the timestamp taken when the operation started
-        stats.incLong(getInitialImageTimeId, getStatTime()-start);
+        stats.incLong(getInitialImageTimeId, getStatTime() - start);
-    
+
-    } 
+    }
+
-      stats.incLong(indexUpdateTimeId, ts-start);
+      stats.incLong(indexUpdateTimeId, ts - start);
-      
+
+
+
+
+
+
+
+
+
-    
+
-     * @param start the timestamp taken when the operation started 
+     * @param start the timestamp taken when the operation started
-        stats.incLong(getTimeId, getStatTime()-start);
+        stats.incLong(getTimeId, getStatTime() - start);
+
-          total = getStatTime()-start;
+          total = getStatTime() - start;
-          total = getStatTime()-start;
+          total = getStatTime() - start;
-    
+
-        stats.incLong(putallTimeId, getStatTime()-start);
+        stats.incLong(putallTimeId, getStatTime() - start);
-      
+
-    
+
-    }  
-    
+    }
+
-    
+
-    
+
+
+
-    
+
+
+
-    
+
+
+
+
-    
+
-    
+
-      if(enableClockStats) {
-        long time = getStatTime() - startTime;        
+      if (enableClockStats) {
+        long time = getStatTime() - startTime;
-      
+
-      stats.incLong(compressionPostCompressedBytesId, endSize); 
+      stats.incLong(compressionPostCompressedBytesId, endSize);
-      cachePerfStats.stats.incLong(compressionPostCompressedBytesId, endSize); 
+      cachePerfStats.stats.incLong(compressionPostCompressedBytesId, endSize);
-      stats.incLong(compressionDecompressionsId, 1);     
-      cachePerfStats.stats.incLong(compressionDecompressionsId, 1);  
+      stats.incLong(compressionDecompressionsId, 1);
+      cachePerfStats.stats.incLong(compressionDecompressionsId, 1);
-      if(enableClockStats) {
-        long time = getStatTime() - startTime;        
+      if (enableClockStats) {
+        long time = getStatTime() - startTime;
-      }   
-    }
-  }
-  
-  /** test hook - dump the backing map for this region */
-  public void dumpBackingMap() {
-    synchronized(this.entries) {
-        if (this.entries instanceof AbstractRegionMap) {
-          ((AbstractRegionMap)(this.entries)).verifyTombstoneCount(this.tombstoneCount);
-        }
-        logger.debug("Dumping region of size {} tombstones: {}: {}", size(), getTombstoneCount(), this.toString());
-        if (this.entries instanceof AbstractRegionMap) {
-          ((AbstractRegionMap)this.entries).dumpMap();
-        }
-    }
-  }
-  
-  /** test hook - verify tombstone count matches what is in the entry map */
-  public void verifyTombstoneCount() {
-    synchronized(this.entries) {
-      if (this.entries instanceof AbstractRegionMap) {
-//        if (!((AbstractRegionMap)(this.entries)).verifyTombstoneCount(this.tombstoneCount)) {
-//          throw new RuntimeException("tombstone count is wrong in " + this);
-//        }
-  //////////////////  ConcurrentMap methods //////////////////               
+  /** test hook - dump the backing map for this region */
+  public void dumpBackingMap() {
+    synchronized (this.entries) {
+      if (this.entries instanceof AbstractRegionMap) {
+        ((AbstractRegionMap) (this.entries)).verifyTombstoneCount(this.tombstoneCount);
+      }
+      logger.debug("Dumping region of size {} tombstones: {}: {}", size(), getTombstoneCount(),
+          this.toString());
+      if (this.entries instanceof AbstractRegionMap) {
+        ((AbstractRegionMap) this.entries).dumpMap();
+      }
+    }
+  }
+
+  /** test hook - verify tombstone count matches what is in the entry map */
+  public void verifyTombstoneCount() {
+    synchronized (this.entries) {
+      if (this.entries instanceof AbstractRegionMap) {
+        // if (!((AbstractRegionMap)(this.entries)).verifyTombstoneCount(this.tombstoneCount)) {
+        // throw new RuntimeException("tombstone count is wrong in " + this);
+        // }
+      }
+    }
+  }
+
+  ////////////////// ConcurrentMap methods //////////////////
-    if (this.srp == null && 
-        ((this.dataPolicy == DataPolicy.NORMAL && this.scope.isDistributed()) || this.dataPolicy == DataPolicy.EMPTY)) {
+    if (this.srp == null && ((this.dataPolicy == DataPolicy.NORMAL && this.scope.isDistributed())
+        || this.dataPolicy == DataPolicy.EMPTY)) {
+
-   * If the specified key is not already associated
-   * with a value, associate it with the given value.
+   * If the specified key is not already associated with a value, associate it with the given value.
+   * 
-   *   if (!region.containsKey(key)) 
-   *      return region.put(key, value);
-   *   else
-   *      return region.get(key);
+   * if (!region.containsKey(key))
+   *   return region.put(key, value);
+   * else
+   *   return region.get(key);
+   * 
-   * <i>Note that if this method returns null then there is no way to determine
-   * definitely whether this operation succeeded and modified the region, or
-   * if the entry is in an invalidated state and no modification occurred.</i>
+   * <i>Note that if this method returns null then there is no way to determine definitely whether
+   * this operation succeeded and modified the region, or if the entry is in an invalidated state
+   * and no modification occurred.</i>
-   * If this method does not modify the region then no listeners or other
-   * callbacks are executed. If a modification does occur, then the behavior
-   * with respect to callbacks is the same as {@link Region#create(Object, Object)}.
+   * If this method does not modify the region then no listeners or other callbacks are executed. If
+   * a modification does occur, then the behavior with respect to callbacks is the same as
+   * {@link Region#create(Object, Object)}.
-   * @param value the value for the new entry, which may be null meaning
-   *              the new entry starts as if it had been locally invalidated.
+   * @param value the value for the new entry, which may be null meaning the new entry starts as if
+   *        it had been locally invalidated.
-   * @return previous value associated with specified key, or <tt>null</tt>
-   *         if there was no mapping for key.  A <tt>null</tt> return can
-   *         also indicate that the entry in the region was previously in
-   *         an invalidated state.
+   * @return previous value associated with specified key, or <tt>null</tt> if there was no mapping
+   *         for key. A <tt>null</tt> return can also indicate that the entry in the region was
+   *         previously in an invalidated state.
-   * @throws IllegalArgumentException if the key or value
-   *         is not serializable and this is a distributed region
+   * @throws IllegalArgumentException if the key or value is not serializable and this is a
+   *         distributed region
-   public Object putIfAbsent(Object key, Object value, Object callbackArgument) {
-     long startPut = CachePerfStats.getStatTime();
-     
-     checkIfConcurrentMapOpsAllowed();
-     validateArguments(key, value, callbackArgument);
-     // TODO ConcurrentMap.putIfAbsent() treats null as an invalidation operation
-     // BUT we need to return the old value, which Invalidate isn't currently doing
-//     if (value == null) {
-//       throw new NullPointerException(LocalizedStrings.LocalRegion_VALUE_MUST_NOT_BE_NULL.toLocalizedString());
-//     }
-     checkReadiness();
-     checkForLimitedOrNoAccess();
-     discoverJTA();
+  public Object putIfAbsent(Object key, Object value, Object callbackArgument) {
+    long startPut = CachePerfStats.getStatTime();
-     // This used to call the constructor which took the old value. It
-     // was modified to call the other EntryEventImpl constructor so that
-     // an id will be generated by default. Null was passed in anyway.
-     //   generate EventID
-     @Released EntryEventImpl event = EntryEventImpl.create(
-         this, Operation.PUT_IF_ABSENT, key,
-         value, callbackArgument, false, getMyId());
-     final Object oldValue = null;
-     final boolean ifNew = true;
-     final boolean ifOld = false;
-     final boolean requireOldValue = true;
-     try {
-       if (generateEventID()) {
-         event.setNewEventId(cache.getDistributedSystem());
-       }
-       if (!basicPut(event,
-           ifNew,
-           ifOld,
-           oldValue,
-           requireOldValue
-       )) {
-         return event.getOldValue();
-       } else {
-         if (!getDataView().isDeferredStats()) {
-           getCachePerfStats().endPut(startPut, false);
-         }
-         return null;
-       }
-     } catch (EntryNotFoundException e) {
-       return event.getOldValue();
-     } finally {
-       event.release();
-     }
-   }
-          
-  /* (non-Javadoc)
+    checkIfConcurrentMapOpsAllowed();
+    validateArguments(key, value, callbackArgument);
+    // TODO ConcurrentMap.putIfAbsent() treats null as an invalidation operation
+    // BUT we need to return the old value, which Invalidate isn't currently doing
+    // if (value == null) {
+    // throw new
+    // NullPointerException(LocalizedStrings.LocalRegion_VALUE_MUST_NOT_BE_NULL.toLocalizedString());
+    // }
+    checkReadiness();
+    checkForLimitedOrNoAccess();
+    discoverJTA();
+
+    // This used to call the constructor which took the old value. It
+    // was modified to call the other EntryEventImpl constructor so that
+    // an id will be generated by default. Null was passed in anyway.
+    // generate EventID
+    @Released
+    EntryEventImpl event = EntryEventImpl.create(this, Operation.PUT_IF_ABSENT, key, value,
+        callbackArgument, false, getMyId());
+    final Object oldValue = null;
+    final boolean ifNew = true;
+    final boolean ifOld = false;
+    final boolean requireOldValue = true;
+    try {
+      if (generateEventID()) {
+        event.setNewEventId(cache.getDistributedSystem());
+      }
+      if (!basicPut(event, ifNew, ifOld, oldValue, requireOldValue)) {
+        return event.getOldValue();
+      } else {
+        if (!getDataView().isDeferredStats()) {
+          getCachePerfStats().endPut(startPut, false);
+        }
+        return null;
+      }
+    } catch (EntryNotFoundException e) {
+      return event.getOldValue();
+    } finally {
+      event.release();
+    }
+  }
+
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-              
+
-   * Same as {@link #remove(Object, Object)} except a callback argument
-   * is supplied to be passed on to <tt>CacheListener</tt>s and/or
-   * <tt>CacheWriter</tt>s.
+   * Same as {@link #remove(Object, Object)} except a callback argument is supplied to be passed on
+   * to <tt>CacheListener</tt>s and/or <tt>CacheWriter</tt>s.
-    @Released EntryEventImpl event = EntryEventImpl.create(this,
-                                              Operation.REMOVE,
-                                              key,
-                                              null, // newValue
-                                              callbackArg,
-                                              false,
-                                              getMyId());
-    
+    @Released
+    EntryEventImpl event = EntryEventImpl.create(this, Operation.REMOVE, key, null, // newValue
+        callbackArg, false, getMyId());
+
-    }
-    catch (EntryNotFoundException enfe) {
+    } catch (EntryNotFoundException enfe) {
-    }
-    catch (RegionDestroyedException rde) {
+    } catch (RegionDestroyedException rde) {
-        RegionDestroyedException rde2 =
-           new RegionDestroyedException(toString(), getFullPath());
+        RegionDestroyedException rde2 = new RegionDestroyedException(toString(), getFullPath());
-              
+
-   * Same as {@link #replace(Object, Object, Object)} except a callback argument
-   * is supplied to be passed on to <tt>CacheListener</tt>s and/or
-   * <tt>CacheWriter</tt>s.
+   * Same as {@link #replace(Object, Object, Object)} except a callback argument is supplied to be
+   * passed on to <tt>CacheListener</tt>s and/or <tt>CacheWriter</tt>s.
-  public boolean replace(Object key,
-             Object pexpectedOldValue,
-             Object newValue,
-             Object callbackArg) {
+  public boolean replace(Object key, Object pexpectedOldValue, Object newValue,
+      Object callbackArg) {
-    @Released EntryEventImpl event = EntryEventImpl.create(this,
-                                              Operation.REPLACE,
-                                              key,
-                                              newValue,
-                                              callbackArg,
-                                              false, // originRemote
-                                              getMyId());
-    
+    @Released
+    EntryEventImpl event =
+        EntryEventImpl.create(this, Operation.REPLACE, key, newValue, callbackArg, false, // originRemote
+            getMyId());
+
-      
+
-      
+
-      if (!basicPut(event,
-          false, // ifNew
-          true,  // ifOld
-          expectedOldValue,
-          false // requireOldValue
+      if (!basicPut(event, false, // ifNew
+          true, // ifOld
+          expectedOldValue, false // requireOldValue
-      }
-      else {
+      } else {
-    } catch (EntryNotFoundException e) {  // put failed on server
+    } catch (EntryNotFoundException e) { // put failed on server
-  
+
-              
+
-   * Same as {@link #replace(Object, Object)} except a callback argument
-   * is supplied to be passed on to <tt>CacheListener</tt>s and/or
-   * <tt>CacheWriter</tt>s.
+   * Same as {@link #replace(Object, Object)} except a callback argument is supplied to be passed on
+   * to <tt>CacheListener</tt>s and/or <tt>CacheWriter</tt>s.
-  public Object replaceWithCallbackArgument(Object key,
-                                            Object value,
-                                            Object callbackArg) {
+  public Object replaceWithCallbackArgument(Object key, Object value, Object callbackArg) {
-    
+
-    
+
-    @Released EntryEventImpl event = EntryEventImpl.create(this,
-                                              Operation.REPLACE,
-                                              key,
-                                              value,
-                                              callbackArg,
-                                              false, // originRemote
-                                              getMyId());
+    @Released
+    EntryEventImpl event =
+        EntryEventImpl.create(this, Operation.REPLACE, key, value, callbackArg, false, // originRemote
+            getMyId());
-      
+
-  public Object basicBridgePutIfAbsent(final Object key, Object value,
-      boolean isObject, Object p_callbackArg, final ClientProxyMembershipID client,
-      boolean fromClient, EntryEventImpl clientEvent) throws TimeoutException,
-      EntryExistsException, CacheWriterException
-  {
+  public Object basicBridgePutIfAbsent(final Object key, Object value, boolean isObject,
+      Object p_callbackArg, final ClientProxyMembershipID client, boolean fromClient,
+      EntryEventImpl clientEvent)
+      throws TimeoutException, EntryExistsException, CacheWriterException {
-      if(isGatewaySenderEnabled()) {
+      if (isGatewaySenderEnabled()) {
-    @Released final EntryEventImpl event = EntryEventImpl.create(this, Operation.PUT_IF_ABSENT, key,
-        null /* new value */, callbackArg,
-        false /* origin remote */, client.getDistributedMember(),
-        true /* generateCallbacks */,
-        eventId);
+    @Released
+    final EntryEventImpl event = EntryEventImpl.create(this, Operation.PUT_IF_ABSENT, key,
+        null /* new value */, callbackArg, false /* origin remote */, client.getDistributedMember(),
+        true /* generateCallbacks */, eventId);
-    event.setContext(client);
-    
-    // if this is a replayed operation we may already have a version tag
-    event.setVersionTag(clientEvent.getVersionTag());
+      event.setContext(client);
-    // Set the new value to the input byte[] if it isn't null
-    ///*
-    if (value != null) {
-      // If the byte[] represents an object, then store it serialized
-      // in a CachedDeserializable; otherwise store it directly as a byte[]
-      if (isObject) {
-        // The value represents an object
-        event.setSerializedNewValue((byte[])value);
+      // if this is a replayed operation we may already have a version tag
+      event.setVersionTag(clientEvent.getVersionTag());
+
+      // Set the new value to the input byte[] if it isn't null
+      /// *
+      if (value != null) {
+        // If the byte[] represents an object, then store it serialized
+        // in a CachedDeserializable; otherwise store it directly as a byte[]
+        if (isObject) {
+          // The value represents an object
+          event.setSerializedNewValue((byte[]) value);
+        } else {
+          // The value does not represent an object
+          event.setNewValue(value);
+        }
-      else {
-        // The value does not represent an object
-        event.setNewValue(value);
+
+      validateArguments(key, event.basicGetNewValue(), p_callbackArg);
+
+      boolean ifNew = true; // cannot overwrite an existing key
+      boolean ifOld = false; // can create a new key
+      boolean requireOldValue = true; // need the old value if the create fails
+      boolean basicPut = basicPut(event, ifNew, ifOld, null, requireOldValue);
+      getCachePerfStats().endPut(startPut, false);
+      this.stopper.checkCancelInProgress(null);
+      // to fix bug 42968 call getRawOldValue instead of getOldValue
+      Object oldValue = event.getRawOldValueAsHeapObject();
+      if (oldValue == Token.NOT_AVAILABLE) {
+        oldValue = AbstractRegion.handleNotAvailable(oldValue);
-    }
-
-    validateArguments(key, event.basicGetNewValue(), p_callbackArg);
-
-    boolean ifNew = true; // cannot overwrite an existing key
-    boolean ifOld = false; // can create a new key
-    boolean requireOldValue = true; // need the old value if the create fails
-    boolean basicPut = basicPut(event, ifNew, ifOld, null, requireOldValue);
-    getCachePerfStats().endPut(startPut, false);
-    this.stopper.checkCancelInProgress(null);
-    // to fix bug 42968 call getRawOldValue instead of getOldValue
-    Object oldValue = event.getRawOldValueAsHeapObject();
-    if (oldValue == Token.NOT_AVAILABLE) {
-      oldValue = AbstractRegion.handleNotAvailable(oldValue);
-    }
-    if (basicPut) {
-      clientEvent.setVersionTag(event.getVersionTag());
-      clientEvent.isConcurrencyConflict(event.isConcurrencyConflict());
-    } else if (oldValue == null) {
-      // fix for 42189, putIfAbsent on server can return null if the
-      // operation was not performed (oldValue in cache was null).
-      // We return the INVALID token instead of null to distinguish
-      // this case from successful operation
-      return Token.INVALID;
-    }
-    return oldValue;
+      if (basicPut) {
+        clientEvent.setVersionTag(event.getVersionTag());
+        clientEvent.isConcurrencyConflict(event.isConcurrencyConflict());
+      } else if (oldValue == null) {
+        // fix for 42189, putIfAbsent on server can return null if the
+        // operation was not performed (oldValue in cache was null).
+        // We return the INVALID token instead of null to distinguish
+        // this case from successful operation
+        return Token.INVALID;
+      }
+      return oldValue;
-  
-  public boolean basicBridgeReplace(final Object key, Object expectedOldValue,
-      Object value, boolean isObject, Object p_callbackArg,
-      final ClientProxyMembershipID client,
-      boolean fromClient, EntryEventImpl clientEvent) throws TimeoutException,
-      EntryExistsException, CacheWriterException
-  {
+
+  public boolean basicBridgeReplace(final Object key, Object expectedOldValue, Object value,
+      boolean isObject, Object p_callbackArg, final ClientProxyMembershipID client,
+      boolean fromClient, EntryEventImpl clientEvent)
+      throws TimeoutException, EntryExistsException, CacheWriterException {
-      if(isGatewaySenderEnabled()) {
+      if (isGatewaySenderEnabled()) {
-    @Released final EntryEventImpl event = EntryEventImpl.create(this, Operation.REPLACE, key,
-        null /* new value */, callbackArg,
-        false /* origin remote */, client.getDistributedMember(),
-        true /* generateCallbacks */,
-        eventId);
+    @Released
+    final EntryEventImpl event = EntryEventImpl.create(this, Operation.REPLACE, key,
+        null /* new value */, callbackArg, false /* origin remote */, client.getDistributedMember(),
+        true /* generateCallbacks */, eventId);
-    event.setContext(client);
+      event.setContext(client);
-    // Set the new value to the input byte[] if it isn't null
-    ///*
-    if (value != null) {
-      // If the byte[] represents an object, then store it serialized
-      // in a CachedDeserializable; otherwise store it directly as a byte[]
-      if (isObject) {
-        // The value represents an object
-        event.setSerializedNewValue((byte[])value);
+      // Set the new value to the input byte[] if it isn't null
+      /// *
+      if (value != null) {
+        // If the byte[] represents an object, then store it serialized
+        // in a CachedDeserializable; otherwise store it directly as a byte[]
+        if (isObject) {
+          // The value represents an object
+          event.setSerializedNewValue((byte[]) value);
+        } else {
+          // The value does not represent an object
+          event.setNewValue(value);
+        }
-      else {
-        // The value does not represent an object
-        event.setNewValue(value);
+
+      validateArguments(key, event.basicGetNewValue(), p_callbackArg);
+
+      boolean ifNew = false; // can overwrite an existing key
+      boolean ifOld = true; // cannot create a new key
+      boolean requireOldValue = false;
+      boolean success = basicPut(event, ifNew, ifOld, expectedOldValue, requireOldValue);
+      clientEvent.isConcurrencyConflict(event.isConcurrencyConflict());
+      if (success) {
+        clientEvent.setVersionTag(event.getVersionTag());
-    }
-
-    validateArguments(key, event.basicGetNewValue(), p_callbackArg);
-
-    boolean ifNew = false; // can overwrite an existing key
-    boolean ifOld = true; // cannot create a new key
-    boolean requireOldValue = false;
-    boolean success = basicPut(event, ifNew, ifOld, expectedOldValue, requireOldValue);
-    clientEvent.isConcurrencyConflict(event.isConcurrencyConflict());
-    if (success) {
-      clientEvent.setVersionTag(event.getVersionTag());
-    }
-    getCachePerfStats().endPut(startPut, false);
-    this.stopper.checkCancelInProgress(null);
-    return success;
+      getCachePerfStats().endPut(startPut, false);
+      this.stopper.checkCancelInProgress(null);
+      return success;
-  public Object basicBridgeReplace(final Object key,
-      Object value, boolean isObject, Object p_callbackArg,
-      final ClientProxyMembershipID client,
-      boolean fromClient, EntryEventImpl clientEvent) throws TimeoutException,
-      EntryExistsException, CacheWriterException
-  {
+  public Object basicBridgeReplace(final Object key, Object value, boolean isObject,
+      Object p_callbackArg, final ClientProxyMembershipID client, boolean fromClient,
+      EntryEventImpl clientEvent)
+      throws TimeoutException, EntryExistsException, CacheWriterException {
-      if(isGatewaySenderEnabled()) {
+      if (isGatewaySenderEnabled()) {
-    @Released final EntryEventImpl event = EntryEventImpl.create(this, Operation.REPLACE, key,
-        null /* new value */, callbackArg,
-        false /* origin remote */, client.getDistributedMember(),
-        true /* generateCallbacks */,
-        eventId);
+    @Released
+    final EntryEventImpl event = EntryEventImpl.create(this, Operation.REPLACE, key,
+        null /* new value */, callbackArg, false /* origin remote */, client.getDistributedMember(),
+        true /* generateCallbacks */, eventId);
-    event.setContext(client);
+      event.setContext(client);
-    // Set the new value to the input byte[] if it isn't null
-    ///*
-    if (value != null) {
-      // If the byte[] represents an object, then store it serialized
-      // in a CachedDeserializable; otherwise store it directly as a byte[]
-      if (isObject) {
-        // The value represents an object
-        event.setSerializedNewValue((byte[])value);
+      // Set the new value to the input byte[] if it isn't null
+      /// *
+      if (value != null) {
+        // If the byte[] represents an object, then store it serialized
+        // in a CachedDeserializable; otherwise store it directly as a byte[]
+        if (isObject) {
+          // The value represents an object
+          event.setSerializedNewValue((byte[]) value);
+        } else {
+          // The value does not represent an object
+          event.setNewValue(value);
+        }
-      else {
-        // The value does not represent an object
-        event.setNewValue(value);
-      }
-    }
-    validateArguments(key, event.basicGetNewValue(), p_callbackArg);
+      validateArguments(key, event.basicGetNewValue(), p_callbackArg);
-    boolean ifNew = false; // can overwrite an existing key
-    boolean ifOld = true; // cannot create a new key
-    boolean requireOldValue = true;
-    boolean succeeded = basicPut(event, ifNew, ifOld, null, requireOldValue);
-    getCachePerfStats().endPut(startPut, false);
-    this.stopper.checkCancelInProgress(null);
-    clientEvent.isConcurrencyConflict(event.isConcurrencyConflict());
-    if (succeeded) {
-      clientEvent.setVersionTag(event.getVersionTag());
-      // to fix bug 42968 call getRawOldValue instead of getOldValue
-      Object oldValue = event.getRawOldValueAsHeapObject();
-      if (oldValue == Token.NOT_AVAILABLE) {
-        oldValue = AbstractRegion.handleNotAvailable(oldValue);
+      boolean ifNew = false; // can overwrite an existing key
+      boolean ifOld = true; // cannot create a new key
+      boolean requireOldValue = true;
+      boolean succeeded = basicPut(event, ifNew, ifOld, null, requireOldValue);
+      getCachePerfStats().endPut(startPut, false);
+      this.stopper.checkCancelInProgress(null);
+      clientEvent.isConcurrencyConflict(event.isConcurrencyConflict());
+      if (succeeded) {
+        clientEvent.setVersionTag(event.getVersionTag());
+        // to fix bug 42968 call getRawOldValue instead of getOldValue
+        Object oldValue = event.getRawOldValueAsHeapObject();
+        if (oldValue == Token.NOT_AVAILABLE) {
+          oldValue = AbstractRegion.handleNotAvailable(oldValue);
+        }
+        if (oldValue == null) { // EntryEventImpl.setOldValue translates INVALID to null
+          oldValue = Token.INVALID;
+        }
+        return oldValue;
+      } else {
+        return null;
-      if (oldValue == null) {  // EntryEventImpl.setOldValue translates INVALID to null
-        oldValue = Token.INVALID;
-      }
-      return oldValue;
-    } else {
-      return null;
-    }
-  public void basicBridgeRemove(Object key, Object expectedOldValue,
-      Object p_callbackArg,
+  public void basicBridgeRemove(Object key, Object expectedOldValue, Object p_callbackArg,
-      throws TimeoutException, EntryNotFoundException, CacheWriterException
-  {
+      throws TimeoutException, EntryNotFoundException, CacheWriterException {
-      if(isGatewaySenderEnabled()) {
+      if (isGatewaySenderEnabled()) {
-    @Released final EntryEventImpl event = EntryEventImpl.create(this, Operation.REMOVE, key,
-        null /* new value */, callbackArg,
-        false /* origin remote */, memberId.getDistributedMember(),
-        true /* generateCallbacks */,
-        clientEvent.getEventId());
+    @Released
+    final EntryEventImpl event = EntryEventImpl.create(this, Operation.REMOVE, key,
+        null /* new value */, callbackArg, false /* origin remote */,
+        memberId.getDistributedMember(), true /* generateCallbacks */, clientEvent.getEventId());
-    event.setContext(memberId);
-    // we rely on exceptions to tell us that the operation didn't take
-    // place.  AbstractRegionMap performs the checks and throws the exception
-    try {
-    basicDestroy(event,
-        true,  // cacheWrite
-        expectedOldValue);
-    } finally {
-      clientEvent.setVersionTag(event.getVersionTag());
-      clientEvent.setIsRedestroyedEntry(event.getIsRedestroyedEntry());
-    }
+      event.setContext(memberId);
+      // we rely on exceptions to tell us that the operation didn't take
+      // place. AbstractRegionMap performs the checks and throws the exception
+      try {
+        basicDestroy(event, true, // cacheWrite
+            expectedOldValue);
+      } finally {
+        clientEvent.setVersionTag(event.getVersionTag());
+        clientEvent.setIsRedestroyedEntry(event.getIsRedestroyedEntry());
+      }
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.DiskRecoveryStore#getVersionForMember(org.apache.geode.internal.cache.versions.VersionSource)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.DiskRecoveryStore#getVersionForMember(org.apache.geode.internal
+   * .cache.versions.VersionSource)
-   * Return an IndexMap that is persisted to the disk store used
-   * by this region.
+   * Return an IndexMap that is persisted to the disk store used by this region.
-   * This IndexMap should be used as the backing map for any
-   * regions that are using the Soplog persistence.
+   * This IndexMap should be used as the backing map for any regions that are using the Soplog
+   * persistence.
-   * Calling this method may create a branch new index map on disk,
-   * or it may recover an index map that was previously persisted, depending
-   * on whether the index previously existed.
+   * Calling this method may create a branch new index map on disk, or it may recover an index map
+   * that was previously persisted, depending on whether the index previously existed.
-   * @throws IllegalStateException if this region is not using
-   * soplog persistence
+   * @throws IllegalStateException if this region is not using soplog persistence
-   * @throws IllegalStateException if this index was previously
-   * persisted with a different expression or from clause.
+   * @throws IllegalStateException if this index was previously persisted with a different
+   *         expression or from clause.
-  public IndexMap getIndexMap(String indexName, String indexedExpression, 
-      String fromClause) {
-      return new IndexMapImpl();
+  public IndexMap getIndexMap(String indexName, String indexedExpression, String fromClause) {
+    return new IndexMapImpl();
-  
+
-   * Return an IndexMap that is persisted to the disk store used
-   * by this region. This method returns map that might not support
-   * range queries.
+   * Return an IndexMap that is persisted to the disk store used by this region. This method returns
+   * map that might not support range queries.
-   * This IndexMap should be used as the backing map for any
-   * regions that are using the Soplog persistence.
+   * This IndexMap should be used as the backing map for any regions that are using the Soplog
+   * persistence.
-   * Calling this method may create a branch new index map on disk,
-   * or it may recover an index map that was previously persisted, depending
-   * on whether the index previously existed.
+   * Calling this method may create a branch new index map on disk, or it may recover an index map
+   * that was previously persisted, depending on whether the index previously existed.
-   * @throws IllegalStateException if this region is not using
-   * soplog persistence
+   * @throws IllegalStateException if this region is not using soplog persistence
-   * @throws IllegalStateException if this index was previously
-   * persisted with a different expression or from clause.
+   * @throws IllegalStateException if this index was previously persisted with a different
+   *         expression or from clause.
-  public IndexMap getUnsortedIndexMap(String indexName, String indexedExpression, 
+  public IndexMap getUnsortedIndexMap(String indexName, String indexedExpression,
-      return new IndexMapImpl();
+    return new IndexMapImpl();
-  //////////////////  End of ConcurrentMap methods ////////////////// 
+  ////////////////// End of ConcurrentMap methods //////////////////
-  public boolean expireRegion(RegionExpiryTask regionExpiryTask, boolean distributed, boolean destroy) {
+  public boolean expireRegion(RegionExpiryTask regionExpiryTask, boolean distributed,
+      boolean destroy) {
-      Operation op = destroy ? (distributed ? Operation.REGION_EXPIRE_DESTROY : Operation.REGION_EXPIRE_LOCAL_DESTROY)
-          : (distributed ? Operation.REGION_EXPIRE_INVALIDATE : Operation.REGION_EXPIRE_LOCAL_INVALIDATE);
-      RegionEventImpl event = new RegionEventImpl(this, op, null, false, getMyId(), generateEventID());
+      Operation op = destroy
+          ? (distributed ? Operation.REGION_EXPIRE_DESTROY : Operation.REGION_EXPIRE_LOCAL_DESTROY)
+          : (distributed ? Operation.REGION_EXPIRE_INVALIDATE
+              : Operation.REGION_EXPIRE_LOCAL_INVALIDATE);
+      RegionEventImpl event =
+          new RegionEventImpl(this, op, null, false, getMyId(), generateEventID());
+
-  private AtomicInteger countNotFoundInLocal = null; 
+  private AtomicInteger countNotFoundInLocal = null;
+
+
-  } 
+  }
+
-  
+
-    
+
-  
+
-    for (RegionEntry re: getRegionMap().regionEntries()) {
+    for (RegionEntry re : getRegionMap().regionEntries()) {
-  
+
-    for (RegionEntry re: getRegionMap().regionEntries()) {
+    for (RegionEntry re : getRegionMap().regionEntries()) {
-  
+

MOV31 MOV31 INS29 MOV29 UPD42 UPD42 UPD42 UPD42 UPD66 UPD66 UPD66 UPD66 MOV65 MOV65 INS65 MOV65 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
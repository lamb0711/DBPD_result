GEODE-77 bug fixes for LocatorDUnitTest

All tests in LocatorDUnitTest now pass except the quorum check,
which needs a test hook.  GMSJoinLeaveJUnitTest, GMSHealthMonitoryJUnitTest
(except for testSuspectMembersCalledThroughSuspectThread) and
MembershipJUnitTest are all passing with these changes.

+import com.gemstone.gemfire.distributed.DistributedSystemDisconnectedException;
+        services.getConfig().getDistributionConfig().setEnableNetworkPartitionDetection(o.isSplitBrainEnabled());
+        services.getConfig().setNetworkPartitionDetectionEnabled(o.isSplitBrainEnabled());
-    if (logger.isDebugEnabled()) {
-      logger.debug("JoinLeave.processRemoveRequest invoked.  isCoordinator="+isCoordinator+ "; isStopping="+isStopping
-          +"; cancelInProgress="+services.getCancelCriterion().isCancelInProgress());
-    }
+
-        + "; reason="+incomingRequest.getReason());
+        + " from " + incomingRequest.getSender()
+        + " reason="+incomingRequest.getReason());
-    Set<InternalDistributedMember> recips = new HashSet<InternalDistributedMember>(view.getMembers());
+    Set<InternalDistributedMember> recips = new HashSet<>(view.getMembers());
-    recips.addAll(view.getCrashedMembers());
+    Set<InternalDistributedMember> responders = recips;
+    if (!view.getCrashedMembers().isEmpty()) {
+      recips = new HashSet<>(recips);
+      recips.addAll(view.getCrashedMembers());
+    }
-    rp.initialize(id, recips);
+    rp.initialize(id, responders);
-    if (v != null) {
+    services.getCancelCriterion().checkCancelInProgress(null);
+    
+    if (v != null && v.contains(m)) {
-      RemoveMemberMessage msg = new RemoveMemberMessage(v.getAllPreferredCoordinators(filter, getMemberID()), 
+      RemoveMemberMessage msg = new RemoveMemberMessage(v.getPreferredCoordinators(filter, getMemberID(), 5), 
-      services.getMessenger().send(msg);
+      if (this.isCoordinator) {
+        msg.setSender(this.localAddress);
+        processRemoveRequest(msg);
+      } else {
+        services.getMessenger().send(msg);
+      }
+              if (result.isEmpty() || this.conflictingView != null) {
+                break;
+              }
-            /*boolean success = */createAndSendView(requests);
+            try {
+              createAndSendView(requests);
+            } catch (DistributedSystemDisconnectedException e) {
+              shutdown = true;
+            }
-    boolean createAndSendView(List<DistributionMessage> requests) {
+    void createAndSendView(List<DistributionMessage> requests) {
-        oldMembers = oldView.getMembers();
+        oldMembers = new ArrayList<>(oldView.getMembers());
-          if (!oldMembers.contains(mbr) && !joinReqs.contains(mbr)) {
+
+          boolean duplicate = false;
+          for (InternalDistributedMember m: oldMembers) {
+            // check the netMembers, which wildcards the
+            // viewID to detect old IDs still in the view
+            if (mbr.getNetMember().equals(m.getNetMember())) {
+              duplicate = true;
+              break;
+            }
+          }
+          if (!duplicate && !joinReqs.contains(mbr)) {
+      
+      
+      if (removalReqs.isEmpty() && leaveReqs.isEmpty() && joinReqs.isEmpty()) {
+        return;
+      }
+      
+      
+      
-          mbrs = new ArrayList<InternalDistributedMember>(currentView.getMembers());
+          mbrs = new ArrayList<InternalDistributedMember>(oldMembers);
+        mbr.getNetMember().setSplitBrainEnabled(services.getConfig().isNetworkPartitionDetectionEnabled());
-        return true;
+        return;
-            return false;
+            return;
-              return false;
+              return;
-              List<InternalDistributedMember> failures = new ArrayList<InternalDistributedMember>(currentView.getCrashedMembers().size() + unresponsive.size());
+              List<InternalDistributedMember> failures = new ArrayList<>(currentView.getCrashedMembers().size() + unresponsive.size());
-                newView = new NetView(localAddress, newView.getViewId()+1, newView.getMembers(), leaveReqs,
+                List<InternalDistributedMember> newMembers = new ArrayList<>(newView.getMembers());
+                newMembers.removeAll(removalReqs);
+                newView = new NetView(localAddress, newView.getViewId()+1, newMembers, leaveReqs,
-      return true;
+      return;

INS26 INS40 INS60 INS25 MOV21 UPD39 INS74 INS59 INS38 INS8 MOV32 INS27 INS25 INS41 INS43 INS43 INS42 INS42 INS32 INS21 MOV21 UPD42 UPD42 INS33 MOV27 INS32 INS25 INS27 INS8 INS45 INS32 UPD45 UPD74 INS42 INS42 INS32 INS42 INS7 INS42 INS42 INS42 INS22 INS8 INS8 INS32 INS32 INS32 MOV41 INS21 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS14 INS52 INS42 INS21 INS21 MOV21 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS74 INS42 INS32 INS32 INS14 INS60 INS70 INS32 INS42 INS32 INS32 INS42 INS32 INS32 INS42 INS32 INS43 UPD42 INS34 INS42 INS42 INS22 INS42 INS42 INS74 MOV32 INS39 INS59 INS44 INS42 INS8 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS54 INS43 INS42 INS9 INS43 INS42 INS25 INS42 INS42 INS42 INS42 INS8 INS8 INS12 INS42 INS42 INS32 INS8 INS42 INS42 INS25 MOV21 MOV21 INS44 INS8 INS32 INS42 INS32 INS21 INS10 INS27 INS8 INS43 INS42 INS21 INS42 INS42 INS42 INS42 INS7 MOV42 INS32 INS27 INS10 INS42 INS7 INS42 INS9 INS60 INS21 INS42 INS42 INS22 INS33 INS42 INS9 UPD74 INS74 INS59 INS32 INS52 INS42 INS43 INS43 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS74 MOV32 INS42 INS43 INS42 DEL42 DEL42 DEL32 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL45 DEL42 DEL45 DEL42 DEL45 DEL27 DEL32 DEL8 DEL42 DEL42 DEL42 DEL32 DEL9 DEL42 DEL42 DEL32 DEL9 DEL9 DEL9
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Analyze configuration data (gemfire.properties) and configure sockets
- * accordingly for SSL.
+ * Analyze configuration data (gemfire.properties) and configure sockets accordingly for SSL.
- * The following may be included to configure the certificates used by the
- * Sun Provider.
+ * The following may be included to configure the certificates used by the Sun Provider.
- * Additional properties will be set as System properties to be available
- * as needed by other provider implementations.
+ * Additional properties will be set as System properties to be available as needed by other
+ * provider implementations.
-  public static final String USE_LINK_LOCAL_ADDRESSES_PROPERTY = DistributionConfig.GEMFIRE_PREFIX + "net.useLinkLocalAddresses";
+  public static final String USE_LINK_LOCAL_ADDRESSES_PROPERTY =
+      DistributionConfig.GEMFIRE_PREFIX + "net.useLinkLocalAddresses";
-  private static final boolean useLinkLocalAddresses = Boolean.getBoolean(USE_LINK_LOCAL_ADDRESSES_PROPERTY);
+  private static final boolean useLinkLocalAddresses =
+      Boolean.getBoolean(USE_LINK_LOCAL_ADDRESSES_PROPERTY);
-  private static boolean useIPv6Addresses = !Boolean.getBoolean("java.net.preferIPv4Stack") && Boolean.getBoolean("java.net.preferIPv6Addresses");
+  private static boolean useIPv6Addresses = !Boolean.getBoolean("java.net.preferIPv4Stack")
+      && Boolean.getBoolean("java.net.preferIPv6Addresses");
-  public static final boolean FORCE_DNS_USE = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "forceDnsUse");
+  public static final boolean FORCE_DNS_USE =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "forceDnsUse");
-        for (Iterator<InetAddress> it = myInterfaces.iterator(); lhName == null && it.hasNext(); ) {
+        for (Iterator<InetAddress> it = myInterfaces.iterator(); lhName == null && it.hasNext();) {
-        // running as a guest OS on an IPv6-enabled machine.  We also look for
+        // running as a guest OS on an IPv6-enabled machine. We also look for
-   * Whether to enable TCP keep alive for sockets. This boolean is controlled by
-   * the gemfire.setTcpKeepAlive java system property.  If not set then GemFire
-   * will enable keep-alive on server->client and p2p connections.
+   * Whether to enable TCP keep alive for sockets. This boolean is controlled by the
+   * gemfire.setTcpKeepAlive java system property. If not set then GemFire will enable keep-alive on
+   * server->client and p2p connections.
-    // to avoid dropped connections.  It can be turned off by setting this
+    // to avoid dropped connections. It can be turned off by setting this
-  //   Constructor
+  // Constructor
-  //   Static instance accessors
+  // Static instance accessors
-   * All GemFire code should use this method instead of
-   * InetAddress.getLocalHost().  See bug #40619
+   * All GemFire code should use this method instead of InetAddress.getLocalHost(). See bug #40619
-   * returns the host name for the given inet address, using a local cache
-   * of names to avoid dns hits and duplicate strings
+   * returns the host name for the given inet address, using a local cache of names to avoid dns
+   * hits and duplicate strings
-   * returns the host name for the given inet address, using a local cache
-   * of names to avoid dns hits and duplicate strings
+   * returns the host name for the given inet address, using a local cache of names to avoid dns
+   * hits and duplicate strings
-  //   Initializers (change SocketCreator state)
+  // Initializers (change SocketCreator state)
-      if (SecurableCommunicationChannel.CLUSTER.equals(sslConfig.getSecuredCommunicationChannel())) {
+      if (SecurableCommunicationChannel.CLUSTER
+          .equals(sslConfig.getSecuredCommunicationChannel())) {
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
+   * 
-    newSSLContext.init(keyManagers, trustManagers, null /* use the default secure random*/);
+    newSSLContext.init(keyManagers, trustManagers, null /* use the default secure random */);
-   * Used by CacheServerLauncher and SystemAdmin to read the properties from
-   * console
+   * Used by CacheServerLauncher and SystemAdmin to read the properties from console
+   * 
-   * Used to read the properties from console. AgentLauncher calls this method
-   * directly & ignores gemfire.properties. CacheServerLauncher and SystemAdmin
-   * call this through {@link #readSSLProperties(Map)} and do NOT ignore
-   * gemfire.properties.
+   * Used to read the properties from console. AgentLauncher calls this method directly & ignores
+   * gemfire.properties. CacheServerLauncher and SystemAdmin call this through
+   * {@link #readSSLProperties(Map)} and do NOT ignore gemfire.properties.
+   * 
-   * @param ignoreGemFirePropsFile if <code>false</code> existing gemfire.properties file is read, if
-   * <code>true</code>, properties from gemfire.properties file are
-   * ignored.
+   * @param ignoreGemFirePropsFile if <code>false</code> existing gemfire.properties file is read,
+   *        if <code>true</code>, properties from gemfire.properties file are ignored.
-      if (ent.getKey().startsWith(DistributionConfig.SSL_SYSTEM_PROPS_NAME) || ent.getKey().startsWith(DistributionConfig.SYS_PROP_NAME)) {
+      if (ent.getKey().startsWith(DistributionConfig.SSL_SYSTEM_PROPS_NAME)
+          || ent.getKey().startsWith(DistributionConfig.SYS_PROP_NAME)) {
-            throw new GemFireConfigException("SSL properties are empty, but a console is not available");
+            throw new GemFireConfigException(
+                "SSL properties are empty, but a console is not available");
-    String[] knownAlgorithms = { "SSL", "SSLv2", "SSLv3", "TLS", "TLSv1", "TLSv1.1", "TLSv1.2" };
+    String[] knownAlgorithms = {"SSL", "SSLv2", "SSLv3", "TLS", "TLSv1", "TLSv1.1", "TLSv1.2"};
-  private TrustManager[] getTrustManagers() throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {
+  private TrustManager[] getTrustManagers()
+      throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {
-      //read from console, default on empty
+      // read from console, default on empty
-        trustStoreType = consoleReader.readLine("Please enter the trustStoreType (javax.net.ssl.trustStoreType) : ");
+        trustStoreType = consoleReader
+            .readLine("Please enter the trustStoreType (javax.net.ssl.trustStoreType) : ");
-        trustStorePath = consoleReader.readLine("Please enter the trustStore location (javax.net.ssl.trustStore) : ");
+        trustStorePath = consoleReader
+            .readLine("Please enter the trustStore location (javax.net.ssl.trustStore) : ");
-        //read from the console
+        // read from the console
-          password = consoleReader.readPassword("Please enter password for trustStore (javax.net.ssl.trustStorePassword) : ");
+          password = consoleReader.readPassword(
+              "Please enter password for trustStore (javax.net.ssl.trustStorePassword) : ");
-    // default algorithm can be changed by setting property "ssl.TrustManagerFactory.algorithm" in security properties
-    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
+    // default algorithm can be changed by setting property "ssl.TrustManagerFactory.algorithm" in
+    // security properties
+    TrustManagerFactory tmf =
+        TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
-  private KeyManager[] getKeyManagers() throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException, UnrecoverableKeyException {
+  private KeyManager[] getKeyManagers() throws KeyStoreException, IOException,
+      NoSuchAlgorithmException, CertificateException, UnrecoverableKeyException {
-        keyStoreType = consoleReader.readLine("Please enter the keyStoreType (javax.net.ssl.keyStoreType) : ");
+        keyStoreType =
+            consoleReader.readLine("Please enter the keyStoreType (javax.net.ssl.keyStoreType) : ");
-        keyStoreFilePath = consoleReader.readLine("Please enter the keyStore location (javax.net.ssl.keyStore) : ");
+        keyStoreFilePath = consoleReader
+            .readLine("Please enter the keyStore location (javax.net.ssl.keyStore) : ");
-        keyStoreFilePath = System.getProperty("user.home") + System.getProperty("file.separator") + ".keystore";
+        keyStoreFilePath =
+            System.getProperty("user.home") + System.getProperty("file.separator") + ".keystore";
-        //read from the console
+        // read from the console
-          password = consoleReader.readPassword("Please enter password for keyStore (javax.net.ssl.keyStorePassword) : ");
+          password = consoleReader.readPassword(
+              "Please enter password for keyStore (javax.net.ssl.keyStorePassword) : ");
-    // default algorithm can be changed by setting property "ssl.KeyManagerFactory.algorithm" in security properties
-    KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
+    // default algorithm can be changed by setting property "ssl.KeyManagerFactory.algorithm" in
+    // security properties
+    KeyManagerFactory keyManagerFactory =
+        KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
+     * 
-     * @param keyAlias The alias name of the server's keypair and supporting
-     * certificate chain
+     * @param keyAlias The alias name of the server's keypair and supporting certificate chain
-    public String chooseClientAlias(final String[] strings, final Principal[] principals, final Socket socket) {
+    public String chooseClientAlias(final String[] strings, final Principal[] principals,
+        final Socket socket) {
-    public String chooseEngineServerAlias(final String keyType, final Principal[] principals, final SSLEngine sslEngine) {
+    public String chooseEngineServerAlias(final String keyType, final Principal[] principals,
+        final SSLEngine sslEngine) {
-  //   Public methods
+  // Public methods
-   * Return a ServerSocket possibly configured for SSL.
-   * SSL configuration is left up to JSSE properties in java.security file.
+   * Return a ServerSocket possibly configured for SSL. SSL configuration is left up to JSSE
+   * properties in java.security file.
-  public ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr, List<GatewayTransportFilter> transportFilters, int socketBufferSize)
-    throws IOException {
+  public ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr,
+      List<GatewayTransportFilter> transportFilters, int socketBufferSize) throws IOException {
-        BindException throwMe = new BindException(LocalizedStrings.SocketCreator_FAILED_TO_CREATE_SERVER_SOCKET_ON_0_1.toLocalizedString(new Object[] {
-          bindAddr, Integer.valueOf(nport)
-        }));
+        BindException throwMe =
+            new BindException(LocalizedStrings.SocketCreator_FAILED_TO_CREATE_SERVER_SOCKET_ON_0_1
+                .toLocalizedString(new Object[] {bindAddr, Integer.valueOf(nport)}));
-   * Return a ServerSocket possibly configured for SSL.
-   * SSL configuration is left up to JSSE properties in java.security file.
+   * Return a ServerSocket possibly configured for SSL. SSL configuration is left up to JSSE
+   * properties in java.security file.
-  public ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr) throws IOException {
+  public ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr)
+      throws IOException {
-  public ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr, int socketBufferSize) throws IOException {
+  public ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr,
+      int socketBufferSize) throws IOException {
-  private ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr, int socketBufferSize, boolean sslConnection) throws IOException {
+  private ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr,
+      int socketBufferSize, boolean sslConnection) throws IOException {
-        throw new GemFireConfigException("SSL not configured correctly, Please look at previous error");
+        throw new GemFireConfigException(
+            "SSL not configured correctly, Please look at previous error");
-      //log.info("Opening server socket on " + nport, new Exception("SocketCreation"));
+      // log.info("Opening server socket on " + nport, new Exception("SocketCreation"));
-        BindException throwMe = new BindException(LocalizedStrings.SocketCreator_FAILED_TO_CREATE_SERVER_SOCKET_ON_0_1.toLocalizedString(new Object[] {
-          bindAddr, Integer.valueOf(nport)
-        }));
+        BindException throwMe =
+            new BindException(LocalizedStrings.SocketCreator_FAILED_TO_CREATE_SERVER_SOCKET_ON_0_1
+                .toLocalizedString(new Object[] {bindAddr, Integer.valueOf(nport)}));
-   * Creates or bind server socket to a random port selected
-   * from tcp-port-range which is same as membership-port-range.
+   * Creates or bind server socket to a random port selected from tcp-port-range which is same as
+   * membership-port-range.
+   * 
-  public ServerSocket createServerSocketUsingPortRange(InetAddress ba,
-                                                       int backlog,
-                                                       boolean isBindAddress,
-                                                       boolean useNIO,
-                                                       int tcpBufferSize,
-                                                       int[] tcpPortRange) throws IOException {
-    return createServerSocketUsingPortRange(ba, backlog, isBindAddress, useNIO, tcpBufferSize, tcpPortRange, sslConfig.isEnabled());
+  public ServerSocket createServerSocketUsingPortRange(InetAddress ba, int backlog,
+      boolean isBindAddress, boolean useNIO, int tcpBufferSize, int[] tcpPortRange)
+      throws IOException {
+    return createServerSocketUsingPortRange(ba, backlog, isBindAddress, useNIO, tcpBufferSize,
+        tcpPortRange, sslConfig.isEnabled());
-   * Creates or bind server socket to a random port selected
-   * from tcp-port-range which is same as membership-port-range.
+   * Creates or bind server socket to a random port selected from tcp-port-range which is same as
+   * membership-port-range.
+   * 
-  public ServerSocket createServerSocketUsingPortRange(InetAddress ba,
-                                                       int backlog,
-                                                       boolean isBindAddress,
-                                                       boolean useNIO,
-                                                       int tcpBufferSize,
-                                                       int[] tcpPortRange,
-                                                       boolean sslConnection) throws IOException {
+  public ServerSocket createServerSocketUsingPortRange(InetAddress ba, int backlog,
+      boolean isBindAddress, boolean useNIO, int tcpBufferSize, int[] tcpPortRange,
+      boolean sslConnection) throws IOException {
-          throw new SystemConnectException(LocalizedStrings.TCPConduit_UNABLE_TO_FIND_FREE_PORT.toLocalizedString());
+          throw new SystemConnectException(
+              LocalizedStrings.TCPConduit_UNABLE_TO_FIND_FREE_PORT.toLocalizedString());
-          socket = this.createServerSocket(localPort, backlog, isBindAddress ? ba : null, tcpBufferSize, sslConnection);
+          socket = this.createServerSocket(localPort, backlog, isBindAddress ? ba : null,
+              tcpBufferSize, sslConnection);
-  public Socket connectForClient(String host, int port, int timeout, int socketBufferSize) throws IOException {
+  public Socket connectForClient(String host, int port, int timeout, int socketBufferSize)
+      throws IOException {
-  public Socket connectForServer(InetAddress inetadd, int port, int socketBufferSize) throws IOException {
+  public Socket connectForServer(InetAddress inetadd, int port, int socketBufferSize)
+      throws IOException {
-   * Return a client socket, timing out if unable to connect and timeout > 0 (millis).
-   * The parameter <i>timeout</i> is ignored if SSL is being used, as there is no
-   * timeout argument in the ssl socket factory
+   * Return a client socket, timing out if unable to connect and timeout > 0 (millis). The parameter
+   * <i>timeout</i> is ignored if SSL is being used, as there is no timeout argument in the ssl
+   * socket factory
-  public Socket connect(InetAddress inetadd, int port, int timeout, ConnectionWatcher optionalWatcher, boolean clientSide) throws IOException {
+  public Socket connect(InetAddress inetadd, int port, int timeout,
+      ConnectionWatcher optionalWatcher, boolean clientSide) throws IOException {
-   * Return a client socket, timing out if unable to connect and timeout > 0 (millis).
-   * The parameter <i>timeout</i> is ignored if SSL is being used, as there is no
-   * timeout argument in the ssl socket factory
+   * Return a client socket, timing out if unable to connect and timeout > 0 (millis). The parameter
+   * <i>timeout</i> is ignored if SSL is being used, as there is no timeout argument in the ssl
+   * socket factory
-  public Socket connect(InetAddress inetadd, int port, int timeout, ConnectionWatcher optionalWatcher, boolean clientSide, int socketBufferSize)
-    throws IOException {
-    return connect(inetadd, port, timeout, optionalWatcher, clientSide, socketBufferSize, sslConfig.isEnabled());
+  public Socket connect(InetAddress inetadd, int port, int timeout,
+      ConnectionWatcher optionalWatcher, boolean clientSide, int socketBufferSize)
+      throws IOException {
+    return connect(inetadd, port, timeout, optionalWatcher, clientSide, socketBufferSize,
+        sslConfig.isEnabled());
-   * Return a client socket, timing out if unable to connect and timeout > 0 (millis).
-   * The parameter <i>timeout</i> is ignored if SSL is being used, as there is no
-   * timeout argument in the ssl socket factory
+   * Return a client socket, timing out if unable to connect and timeout > 0 (millis). The parameter
+   * <i>timeout</i> is ignored if SSL is being used, as there is no timeout argument in the ssl
+   * socket factory
-  public Socket connect(InetAddress inetadd,
-                        int port,
-                        int timeout,
-                        ConnectionWatcher optionalWatcher,
-                        boolean clientSide,
-                        int socketBufferSize,
-                        boolean sslConnection) throws IOException {
+  public Socket connect(InetAddress inetadd, int port, int timeout,
+      ConnectionWatcher optionalWatcher, boolean clientSide, int socketBufferSize,
+      boolean sslConnection) throws IOException {
-          throw new GemFireConfigException("SSL not configured correctly, Please look at previous error");
+          throw new GemFireConfigException(
+              "SSL not configured correctly, Please look at previous error");
-          logger.debug(LocalizedMessage.create(LocalizedStrings.SocketCreator_SSL_CONNECTION_FROM_PEER_0, ((X509Certificate) peer[0]).getSubjectDN()));
+          logger.debug(
+              LocalizedMessage.create(LocalizedStrings.SocketCreator_SSL_CONNECTION_FROM_PEER_0,
+                  ((X509Certificate) peer[0]).getSubjectDN()));
-          logger.fatal(LocalizedMessage.create(LocalizedStrings.SocketCreator_SSL_ERROR_IN_AUTHENTICATING_PEER_0_1, new Object[] {
-            socket.getInetAddress(), Integer.valueOf(socket.getPort())
-          }), ex);
+          logger.fatal(
+              LocalizedMessage.create(
+                  LocalizedStrings.SocketCreator_SSL_ERROR_IN_AUTHENTICATING_PEER_0_1,
+                  new Object[] {socket.getInetAddress(), Integer.valueOf(socket.getPort())}),
+              ex);
-        logger.fatal(LocalizedMessage.create(LocalizedStrings.SocketCreator_SSL_ERROR_IN_CONNECTING_TO_PEER_0_1, new Object[] {
-          socket.getInetAddress(), Integer.valueOf(socket.getPort())
-        }), ex);
+        logger
+            .fatal(
+                LocalizedMessage.create(
+                    LocalizedStrings.SocketCreator_SSL_ERROR_IN_CONNECTING_TO_PEER_0_1,
+                    new Object[] {socket.getInetAddress(), Integer.valueOf(socket.getPort())}),
+                ex);
-  //   Private implementation methods
+  // Private implementation methods
-      //serverSocket.setWantClientAuth( true );
+      // serverSocket.setWantClientAuth( true );
-   * When a socket is accepted from a server socket, it should be passed to
-   * this method for SSL configuration.
+   * When a socket is accepted from a server socket, it should be passed to this method for SSL
+   * configuration.
-          logger.debug(LocalizedMessage.create(LocalizedStrings.SocketCreator_SSL_CONNECTION_FROM_PEER_0, ((X509Certificate) peer[0]).getSubjectDN()));
+          logger.debug(
+              LocalizedMessage.create(LocalizedStrings.SocketCreator_SSL_CONNECTION_FROM_PEER_0,
+                  ((X509Certificate) peer[0]).getSubjectDN()));
-        logger.fatal(LocalizedMessage.create(LocalizedStrings.SocketCreator_SSL_ERROR_IN_CONNECTING_TO_PEER_0_1, new Object[] {
-          socket.getInetAddress(), Integer.valueOf(socket.getPort())
-        }), ex);
+        logger
+            .fatal(
+                LocalizedMessage.create(
+                    LocalizedStrings.SocketCreator_SSL_ERROR_IN_CONNECTING_TO_PEER_0_1,
+                    new Object[] {socket.getInetAddress(), Integer.valueOf(socket.getPort())}),
+                ex);
-          logger.fatal(LocalizedMessage.create(LocalizedStrings.SocketCreator_SSL_ERROR_IN_AUTHENTICATING_PEER), ex);
+          logger.fatal(LocalizedMessage
+              .create(LocalizedStrings.SocketCreator_SSL_ERROR_IN_AUTHENTICATING_PEER), ex);
-        logger.fatal(LocalizedMessage.create(LocalizedStrings.SocketCreator_SSL_ERROR_IN_CONNECTING_TO_PEER_0_1, new Object[] {
-          socket.getInetAddress(), Integer.valueOf(socket.getPort())
-        }), ex);
+        logger
+            .fatal(
+                LocalizedMessage.create(
+                    LocalizedStrings.SocketCreator_SSL_ERROR_IN_CONNECTING_TO_PEER_0_1,
+                    new Object[] {socket.getInetAddress(), Integer.valueOf(socket.getPort())}),
+                ex);
-    String className = System.getProperty(DistributionConfig.GEMFIRE_PREFIX + "clientSocketFactory");
+    String className =
+        System.getProperty(DistributionConfig.GEMFIRE_PREFIX + "clientSocketFactory");
-    this.clientSocketFactory = new TransportFilterSocketFactory().setGatewayTransportFilters(sender.getGatewayTransportFilters());
+    this.clientSocketFactory = new TransportFilterSocketFactory()
+        .setGatewayTransportFilters(sender.getGatewayTransportFilters());
-      throw new IllegalArgumentException(LocalizedStrings.StartupMessage_UNABLE_TO_EXAMINE_NETWORK_INTERFACES.toLocalizedString(), e);
+      throw new IllegalArgumentException(
+          LocalizedStrings.StartupMessage_UNABLE_TO_EXAMINE_NETWORK_INTERFACES.toLocalizedString(),
+          e);
-          if (addr.isLoopbackAddress() || addr.isAnyLocalAddress() || (!useLinkLocalAddresses && addr.isLinkLocalAddress())) {
+          if (addr.isLoopbackAddress() || addr.isAnyLocalAddress()
+              || (!useLinkLocalAddresses && addr.isLinkLocalAddress())) {
+   * 
-   * @return the host name associated with the address or null if lookup isn't possible or there is no host name for this address
+   * @return the host name associated with the address or null if lookup isn't possible or there is
+   *         no host name for this address
-    //    System.out.println("Looking up: " + lookup);
+    // System.out.println("Looking up: " + lookup);
-      Attributes attrs = ctx.getAttributes(lookup, new String[] { "PTR" });
-      for (NamingEnumeration ae = attrs.getAll(); ae.hasMoreElements(); ) {
+      Attributes attrs = ctx.getAttributes(lookup, new String[] {"PTR"});
+      for (NamingEnumeration ae = attrs.getAll(); ae.hasMoreElements();) {
-        for (Enumeration vals = attr.getAll(); vals.hasMoreElements(); ) {
+        for (Enumeration vals = attr.getAll(); vals.hasMoreElements();) {
-            for (Enumeration en2 = i.getInetAddresses(); en2.hasMoreElements(); ) {
+            for (Enumeration en2 = i.getInetAddresses(); en2.hasMoreElements();) {
-          throw new IllegalArgumentException(LocalizedStrings.InetAddressUtil_UNABLE_TO_QUERY_NETWORK_INTERFACE.toLocalizedString(), e);
+          throw new IllegalArgumentException(
+              LocalizedStrings.InetAddressUtil_UNABLE_TO_QUERY_NETWORK_INTERFACE
+                  .toLocalizedString(),
+              e);
-   * Converts the string host to an instance of InetAddress.  Returns null if
-   * the string is empty.  Fails Assertion if the conversion would result in
-   * <code>java.lang.UnknownHostException</code>.
+   * Converts the string host to an instance of InetAddress. Returns null if the string is empty.
+   * Fails Assertion if the conversion would result in <code>java.lang.UnknownHostException</code>.
+   * 

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * The base PartitionedRegion message type upon which other messages should be
- * based.
+ * The base PartitionedRegion message type upon which other messages should be based.
-public abstract class PartitionMessage extends DistributionMessage implements 
-    MessageWithReply, TransactionMessage
-{
+public abstract class PartitionMessage extends DistributionMessage
+    implements MessageWithReply, TransactionMessage {
-  
+
-  static final ForceReattemptException UNHANDLED_EXCEPTION
-     = (ForceReattemptException)new ForceReattemptException(LocalizedStrings.PartitionMessage_UNKNOWN_EXCEPTION.toLocalizedString()).fillInStackTrace();
+  static final ForceReattemptException UNHANDLED_EXCEPTION =
+      (ForceReattemptException) new ForceReattemptException(
+          LocalizedStrings.PartitionMessage_UNKNOWN_EXCEPTION.toLocalizedString())
+              .fillInStackTrace();
-  
+
-  /* these bit masks are used for encoding the bits of a short on the wire 
-   * instead of transmitting booleans. Any subclasses interested in saving
-   * bits on the wire should add a mask here and then override
-   *  computeCompressedShort and setBooleans
+  /*
+   * these bit masks are used for encoding the bits of a short on the wire instead of transmitting
+   * booleans. Any subclasses interested in saving bits on the wire should add a mask here and then
+   * override computeCompressedShort and setBooleans
-  protected static final short NOTIFICATION_ONLY =
-    DistributionMessage.UNRESERVED_FLAGS_START;
+  protected static final short NOTIFICATION_ONLY = DistributionMessage.UNRESERVED_FLAGS_START;
-  /** The unique transaction Id on the sending member, used to construct a TXId on the receiving side */
+  /**
+   * The unique transaction Id on the sending member, used to construct a TXId on the receiving side
+   */
-  
+
-  /*TODO [DISTTX] Convert into flag*/
+  /* TODO [DISTTX] Convert into flag */
-  public PartitionMessage() {
-  }
+  public PartitionMessage() {}
- 
+
-    this.processorId = processor==null? 0 : processor.getProcessorId();
+    this.processorId = processor == null ? 0 : processor.getProcessorId();
-  public PartitionMessage(Collection<InternalDistributedMember> recipients, int regionId, ReplyProcessor21 processor) {
+  public PartitionMessage(Collection<InternalDistributedMember> recipients, int regionId,
+      ReplyProcessor21 processor) {
-    this.processorId = processor==null? 0 : processor.getProcessorId();
+    this.processorId = processor == null ? 0 : processor.getProcessorId();
-  
+
-        //logger.error("sending rmt txId even though tx is local! txState=" + txState, new RuntimeException("STACK"));
-        throw new IllegalStateException("Sending remote txId even though transaction is local. This should never happen: txState=" + txState);
+        // logger.error("sending rmt txId even though tx is local! txState=" + txState, new
+        // RuntimeException("STACK"));
+        throw new IllegalStateException(
+            "Sending remote txId even though transaction is local. This should never happen: txState="
+                + txState);
-    if(txState!=null && txState.isMemberIdForwardingRequired()) {
+    if (txState != null && txState.isMemberIdForwardingRequired()) {
+
+   * 
+   * 
-    if(txMemberId==null) {
+    if (txMemberId == null) {
-  
+
-   * Severe alert processing enables suspect processing at the ack-wait-threshold
-   * and issuing of a severe alert at the end of the ack-severe-alert-threshold.
-   * Some messages should not support this type of processing
-   * (e.g., GII, or DLockRequests)
-   * @return whether severe-alert processing may be performed on behalf
-   * of this message
+   * Severe alert processing enables suspect processing at the ack-wait-threshold and issuing of a
+   * severe alert at the end of the ack-severe-alert-threshold. Some messages should not support
+   * this type of processing (e.g., GII, or DLockRequests)
+   * 
+   * @return whether severe-alert processing may be performed on behalf of this message
-  
+
-    }
-    else {
+    } else {
-   * @return the compact value that will be sent which represents the
-   *         PartitionedRegion
+   * @return the compact value that will be sent which represents the PartitionedRegion
-  public final int getRegionId()
-  {
+  public final int getRegionId() {
-   * @return the {@link ReplyProcessor21}id associated with the message, null
-   *         if no acknowlegement is required.
+   * @return the {@link ReplyProcessor21}id associated with the message, null if no acknowlegement
+   *         is required.
-  public final int getProcessorId()
-  {
+  public final int getProcessorId() {
-   * @param processorId1 the {@link 
-   * org.apache.geode.distributed.internal.ReplyProcessor21} id associated 
-   * with the message, null if no acknowlegement is required.
+   * @param processorId1 the {@link org.apache.geode.distributed.internal.ReplyProcessor21} id
+   *        associated with the message, null if no acknowlegement is required.
-  public final void registerProcessor(int processorId1)
-  {
+  public final void registerProcessor(int processorId1) {
-   * @return return the message that should be sent to listeners, or null if this message
-   * should not be relayed
+   * @return return the message that should be sent to listeners, or null if this message should not
+   *         be relayed
+   * 
-  
+
-  
+
-  
+
-  
+
-   * Upon receipt of the message, both process the message and send an
-   * acknowledgement, not necessarily in that order. Note: Any hang in this
-   * message may cause a distributed deadlock for those threads waiting for an
-   * acknowledgement.
+   * Upon receipt of the message, both process the message and send an acknowledgement, not
+   * necessarily in that order. Note: Any hang in this message may cause a distributed deadlock for
+   * those threads waiting for an acknowledgement.
-   * @throws PartitionedRegionException if the region does not exist (typically, if it has been destroyed)
+   * @throws PartitionedRegionException if the region does not exist (typically, if it has been
+   *         destroyed)
-  public void process(final DistributionManager dm) 
-  {
+  public void process(final DistributionManager dm) {
-        thr = new CacheClosedException(LocalizedStrings.PartitionMessage_REMOTE_CACHE_IS_CLOSED_0.toLocalizedString(dm.getId()));
+        thr = new CacheClosedException(LocalizedStrings.PartitionMessage_REMOTE_CACHE_IS_CLOSED_0
+            .toLocalizedString(dm.getId()));
-        thr = new ForceReattemptException(LocalizedStrings.PartitionMessage_0_COULD_NOT_FIND_PARTITIONED_REGION_WITH_ID_1.toLocalizedString(new Object[] {dm.getDistributionManagerId(), Integer.valueOf(regionId)}));
-        return;  // reply sent in finally block below
+        thr = new ForceReattemptException(
+            LocalizedStrings.PartitionMessage_0_COULD_NOT_FIND_PARTITIONED_REGION_WITH_ID_1
+                .toLocalizedString(
+                    new Object[] {dm.getDistributionManagerId(), Integer.valueOf(regionId)}));
+        return; // reply sent in finally block below
-      
+
-      if(cache==null) {
-        throw new ForceReattemptException(LocalizedStrings.PartitionMessage_REMOTE_CACHE_IS_CLOSED_0.toLocalizedString());
+      if (cache == null) {
+        throw new ForceReattemptException(
+            LocalizedStrings.PartitionMessage_REMOTE_CACHE_IS_CLOSED_0.toLocalizedString());
-        sendReply = operateOnPartitionedRegion(dm, pr, startTime);        
+        sendReply = operateOnPartitionedRegion(dm, pr, startTime);
-            sendReply = operateOnPartitionedRegion(dm, pr, startTime); 
+            sendReply = operateOnPartitionedRegion(dm, pr, startTime);
-          }  
+          }
-          
+
-    }
-    catch (DistributedSystemDisconnectedException se) {
+    } catch (DistributedSystemDisconnectedException se) {
-//      throw new CacheClosedException("remote system shutting down");
-//      thr = se; cache is closed, no point trying to send a reply
+      // throw new CacheClosedException("remote system shutting down");
+      // thr = se; cache is closed, no point trying to send a reply
-    }
-    catch (RegionDestroyedException | RegionNotFoundException rde ) {
+    } catch (RegionDestroyedException | RegionNotFoundException rde) {
-      //         destroyed, so we must send back an exception.  If the sender's
-      //         region is also destroyed, who cares if we send it an exception
-      //if (pr != null && pr.isClosed) {
-        thr = new ForceReattemptException(LocalizedStrings.PartitionMessage_REGION_IS_DESTROYED_IN_0.toLocalizedString(dm.getDistributionManagerId()), rde);
-      //}
-    }
-    catch (VirtualMachineError err) {
+      // destroyed, so we must send back an exception. If the sender's
+      // region is also destroyed, who cares if we send it an exception
+      // if (pr != null && pr.isClosed) {
+      thr = new ForceReattemptException(LocalizedStrings.PartitionMessage_REGION_IS_DESTROYED_IN_0
+          .toLocalizedString(dm.getDistributionManagerId()), rde);
+      // }
+    } catch (VirtualMachineError err) {
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    }
-    catch (Throwable t) {
+    } catch (Throwable t) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-        }
-        else {
+        } else {
-          thr = new ForceReattemptException(LocalizedStrings.PartitionMessage_DISTRIBUTED_SYSTEM_IS_DISCONNECTING.toLocalizedString());
+          thr = new ForceReattemptException(
+              LocalizedStrings.PartitionMessage_DISTRIBUTED_SYSTEM_IS_DISCONNECTING
+                  .toLocalizedString());
-        logger.trace(LogMarker.DM, "Exception caught while processing message: ", t.getMessage(), t);
+        logger.trace(LogMarker.DM, "Exception caught while processing message: ", t.getMessage(),
+            t);
-    }
-    finally {
+    } finally {
-        
+
-          boolean excludeException = 
-            this.notificationOnly
-                 && ((thr instanceof CancelException)
-                      || (thr instanceof ForceReattemptException));
-          
+          boolean excludeException = this.notificationOnly
+              && ((thr instanceof CancelException) || (thr instanceof ForceReattemptException));
+
-      } 
+      }
-  
-  /** Send a generic ReplyMessage.  This is in a method so that subclasses can override the reply message type
+
+  /**
+   * Send a generic ReplyMessage. This is in a method so that subclasses can override the reply
+   * message type
+   * 
-   *  @see PutMessage#sendReply
+   * @see PutMessage#sendReply
-  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex, PartitionedRegion pr, long startTime) {
+  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex,
+      PartitionedRegion pr, long startTime) {
-      pr.getPrStats().endPartitionMessagesProcessing(startTime); 
+      pr.getPrStats().endPartitionMessagesProcessing(startTime);
-  
+
-   * Allow classes that over-ride to choose whether 
-   * a RegionDestroyException is thrown if no partitioned region is found (typically occurs if the message will be sent 
-   * before the PartitionedRegion has been fully constructed.
+   * Allow classes that over-ride to choose whether a RegionDestroyException is thrown if no
+   * partitioned region is found (typically occurs if the message will be sent before the
+   * PartitionedRegion has been fully constructed.
+   * 
+   * 
-      FilterRoutingInfo filterRoutingInfo, 
-      EntryEventImpl event, PartitionedRegion r, DirectReplyProcessor processor)
-  {
-    this.processorId = processor == null? 0 : processor.getProcessorId();
+      FilterRoutingInfo filterRoutingInfo, EntryEventImpl event, PartitionedRegion r,
+      DirectReplyProcessor processor) {
+    this.processorId = processor == null ? 0 : processor.getProcessorId();
-        
+
-    Set failures1= null;
-    if(!adjunctRecipients.isEmpty()) {
+    Set failures1 = null;
+    if (!adjunctRecipients.isEmpty()) {
-        logger.trace(LogMarker.DM, "Relaying partition message to other processes for listener notification");
+        logger.trace(LogMarker.DM,
+            "Relaying partition message to other processes for listener notification");
-    
+
-    
+
-   * return a new reply processor for this class, for use in relaying a response.
-   * This <b>must</b> be an instance method so subclasses can override it
-   * properly.
+   * return a new reply processor for this class, for use in relaying a response. This <b>must</b>
+   * be an instance method so subclasses can override it properly.
-  
-  protected boolean operateOnRegion(DistributionManager dm,
-      PartitionedRegion pr) {
-    throw new InternalGemFireError(LocalizedStrings.PartitionMessage_SORRY_USE_OPERATEONPARTITIONEDREGION_FOR_PR_MESSAGES.toLocalizedString());
+
+  protected boolean operateOnRegion(DistributionManager dm, PartitionedRegion pr) {
+    throw new InternalGemFireError(
+        LocalizedStrings.PartitionMessage_SORRY_USE_OPERATEONPARTITIONEDREGION_FOR_PR_MESSAGES
+            .toLocalizedString());
-   * An operation upon the messages partitioned region which each subclassing
-   * message must implement
+   * An operation upon the messages partitioned region which each subclassing message must implement
-   * @param dm
-   *          the manager that received the message
-   * @param pr
-   *          the partitioned region that should be modified
+   * @param dm the manager that received the message
+   * @param pr the partitioned region that should be modified
-   * Fill out this instance of the message using the <code>DataInput</code>
-   * Required to be a {@link org.apache.geode.DataSerializable}Note: must
-   * be symmetric with {@link #toData(DataOutput)}in what it reads
+   * Fill out this instance of the message using the <code>DataInput</code> Required to be a
+   * {@link org.apache.geode.DataSerializable}Note: must be symmetric with
+   * {@link #toData(DataOutput)}in what it reads
-    if (InternalDataSerializer.getVersionForDataStream(in).compareTo(
-        Version.GFE_90) >= 0) {
+    if (InternalDataSerializer.getVersionForDataStream(in).compareTo(Version.GFE_90) >= 0) {
-   * Re-construct the booleans using the compressed short. A subclass must override
-   * this method if it is using bits in the compressed short.
+   * Re-construct the booleans using the compressed short. A subclass must override this method if
+   * it is using bits in the compressed short.
-  protected void setBooleans(short s, DataInput in) throws IOException,
-      ClassNotFoundException {
+  protected void setBooleans(short s, DataInput in) throws IOException, ClassNotFoundException {
-    if ((s & NOTIFICATION_ONLY) != 0) this.notificationOnly = true;
-    if ((s & HAS_TX_ID) != 0) this.txUniqId = in.readInt();
+    if ((s & NOTIFICATION_ONLY) != 0)
+      this.notificationOnly = true;
+    if ((s & HAS_TX_ID) != 0)
+      this.txUniqId = in.readInt();
-      this.txMemberId = (InternalDistributedMember)DataSerializer.readObject(in);
+      this.txMemberId = (InternalDistributedMember) DataSerializer.readObject(in);
- 
+
-    if (this.processorId != 0) out.writeInt(this.processorId);
-    if (this.txUniqId != TXManagerImpl.NOTX) out.writeInt(this.txUniqId);
-    if (this.txMemberId != null) DataSerializer.writeObject(this.txMemberId, out);
+    if (this.processorId != 0)
+      out.writeInt(this.processorId);
+    if (this.txUniqId != TXManagerImpl.NOTX)
+      out.writeInt(this.txUniqId);
+    if (this.txMemberId != null)
+      DataSerializer.writeObject(this.txMemberId, out);
-    if (InternalDataSerializer.getVersionForDataStream(out).compareTo(
-        Version.GFE_90) >= 0) {
+    if (InternalDataSerializer.getVersionForDataStream(out).compareTo(Version.GFE_90) >= 0) {
-   * Sets the bits of a short by using the bit masks. A subclass must override
-   * this method if it is using bits in the compressed short.
+   * Sets the bits of a short by using the bit masks. A subclass must override this method if it is
+   * using bits in the compressed short.
+   * 
-    if (this.processorId != 0) s |= HAS_PROCESSOR_ID;
-    if (this.notificationOnly) s |= NOTIFICATION_ONLY;
+    if (this.processorId != 0)
+      s |= HAS_PROCESSOR_ID;
+    if (this.notificationOnly)
+      s |= NOTIFICATION_ONLY;
-  public final static String PN_TOKEN = ".cache."; 
+  public final static String PN_TOKEN = ".cache.";
-  public String toString()
-  {
+  public String toString() {
-//    className.substring(className.lastIndexOf('.', className.lastIndexOf('.') - 1) + 1);  // partition.<foo> more generic version 
+    // className.substring(className.lastIndexOf('.', className.lastIndexOf('.') - 1) + 1); //
+    // partition.<foo> more generic version
-    
+
-    }
-    catch (Exception e) {
+    } catch (Exception e) {
-   * @param buff
-   *          buffer in which to append the state of this instance
+   * @param buff buffer in which to append the state of this instance
-  protected void appendFields(StringBuffer buff)
-  {
+  protected void appendFields(StringBuffer buff) {
-  
+
-  
+
+   * 
-  
+
+
-  public void appendOldValueToMessage(EntryEventImpl event) {
-    
-  }*/
+   * public void appendOldValueToMessage(EntryEventImpl event) {
+   * 
+   * }
+   */
-  
+
-  
+
-   * A processor on which to await a response from the {@link PartitionMessage}
-   * recipient, capturing any CacheException thrown by the recipient and handle
-   * it as an expected exception.
+   * A processor on which to await a response from the {@link PartitionMessage} recipient, capturing
+   * any CacheException thrown by the recipient and handle it as an expected exception.
-    
+
-    
+
-    
+
-    
+
-      if(register) {
+      if (register) {
-    
+
-    
-    public PartitionResponse(InternalDistributedSystem dm, InternalDistributedMember member, boolean register) {
+
+    public PartitionResponse(InternalDistributedSystem dm, InternalDistributedMember member,
+        boolean register) {
-      if(register) {
+      if (register) {
+
-    
+
-          this.prce =  new ForceReattemptException(LocalizedStrings.PartitionMessage_PARTITIONRESPONSE_GOT_MEMBERDEPARTED_EVENT_FOR_0_CRASHED_1.toLocalizedString(new Object[] {id, Boolean.valueOf(crashed)}));
+          this.prce = new ForceReattemptException(
+              LocalizedStrings.PartitionMessage_PARTITIONRESPONSE_GOT_MEMBERDEPARTED_EVENT_FOR_0_CRASHED_1
+                  .toLocalizedString(new Object[] {id, Boolean.valueOf(crashed)}));
-        Exception e = new Exception(LocalizedStrings.PartitionMessage_MEMBERDEPARTED_GOT_NULL_MEMBERID.toLocalizedString());
-        logger.info(LocalizedMessage.create(LocalizedStrings.PartitionMessage_MEMBERDEPARTED_GOT_NULL_MEMBERID_CRASHED_0, Boolean.valueOf(crashed)), e);
+        Exception e = new Exception(
+            LocalizedStrings.PartitionMessage_MEMBERDEPARTED_GOT_NULL_MEMBERID.toLocalizedString());
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.PartitionMessage_MEMBERDEPARTED_GOT_NULL_MEMBERID_CRASHED_0,
+            Boolean.valueOf(crashed)), e);
-     * @throws CacheException  if the recipient threw a cache exception during message processing 
-     * @throws ForceReattemptException if the recipient left the distributed system before the response
-     * was received.  
-     * @throws PrimaryBucketException 
+     * 
+     * @throws CacheException if the recipient threw a cache exception during message processing
+     * @throws ForceReattemptException if the recipient left the distributed system before the
+     *         response was received.
+     * @throws PrimaryBucketException
-    final public void waitForCacheException() 
+    final public void waitForCacheException()
-        if (this.prce!=null || (this.responseRequired && !this.responseReceived)) {
-          throw new ForceReattemptException(LocalizedStrings.PartitionMessage_ATTEMPT_FAILED.toLocalizedString(), this.prce);
+        if (this.prce != null || (this.responseRequired && !this.responseReceived)) {
+          throw new ForceReattemptException(
+              LocalizedStrings.PartitionMessage_ATTEMPT_FAILED.toLocalizedString(), this.prce);
-      }
-      catch (ReplyException e) {
+      } catch (ReplyException e) {
-          throw (CacheException)t;
-        }
-        else if (t instanceof ForceReattemptException) {
-          ForceReattemptException ft = (ForceReattemptException)t;
+          throw (CacheException) t;
+        } else if (t instanceof ForceReattemptException) {
+          ForceReattemptException ft = (ForceReattemptException) t;
-          ForceReattemptException fre = new ForceReattemptException(LocalizedStrings.PartitionMessage_PEER_REQUESTS_REATTEMPT.toLocalizedString(), t);
+          ForceReattemptException fre = new ForceReattemptException(
+              LocalizedStrings.PartitionMessage_PEER_REQUESTS_REATTEMPT.toLocalizedString(), t);
-        }
-        else if (t instanceof PrimaryBucketException) {
+        } else if (t instanceof PrimaryBucketException) {
-          throw new PrimaryBucketException(LocalizedStrings.PartitionMessage_PEER_FAILED_PRIMARY_TEST.toLocalizedString(), t);
-        }
-        else if (t instanceof CancelException) {
-          logger.debug("PartitionResponse got CacheClosedException from {}, throwing ForceReattemptException", e.getSender(), t);
-          throw new ForceReattemptException(LocalizedStrings.PartitionMessage_PARTITIONRESPONSE_GOT_REMOTE_CACHECLOSEDEXCEPTION.toLocalizedString(), t);
-        }
-        else if (t instanceof DiskAccessException) {
-          logger.debug("PartitionResponse got DiskAccessException from {}, throwing ForceReattemptException", e.getSender(), t);
-          throw new ForceReattemptException(LocalizedStrings.PartitionMessage_PARTITIONRESPONSE_GOT_REMOTE_CACHECLOSEDEXCEPTION.toLocalizedString(), t);
-        }
-        else if (t instanceof LowMemoryException) {
-          logger.debug("PartitionResponse re-throwing remote LowMemoryException from {}", e.getSender(), t);
+          throw new PrimaryBucketException(
+              LocalizedStrings.PartitionMessage_PEER_FAILED_PRIMARY_TEST.toLocalizedString(), t);
+        } else if (t instanceof CancelException) {
+          logger.debug(
+              "PartitionResponse got CacheClosedException from {}, throwing ForceReattemptException",
+              e.getSender(), t);
+          throw new ForceReattemptException(
+              LocalizedStrings.PartitionMessage_PARTITIONRESPONSE_GOT_REMOTE_CACHECLOSEDEXCEPTION
+                  .toLocalizedString(),
+              t);
+        } else if (t instanceof DiskAccessException) {
+          logger.debug(
+              "PartitionResponse got DiskAccessException from {}, throwing ForceReattemptException",
+              e.getSender(), t);
+          throw new ForceReattemptException(
+              LocalizedStrings.PartitionMessage_PARTITIONRESPONSE_GOT_REMOTE_CACHECLOSEDEXCEPTION
+                  .toLocalizedString(),
+              t);
+        } else if (t instanceof LowMemoryException) {
+          logger.debug("PartitionResponse re-throwing remote LowMemoryException from {}",
+              e.getSender(), t);
-    }    
+    }
-  
+
-  
+
-   this.isTransactionDistributed = isDistTx;
+    this.isTransactionDistributed = isDistTx;
-  
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
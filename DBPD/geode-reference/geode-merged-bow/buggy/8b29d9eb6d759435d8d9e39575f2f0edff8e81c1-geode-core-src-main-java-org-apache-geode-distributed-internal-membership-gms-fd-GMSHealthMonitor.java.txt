GEODE-6423 availability checks sometimes immediately initiate removal

Ensure that the availability check is performed for the contracted
member-timeout period.  This allows a suspect to survive the check if
it's having a momentary glitch like a brief garbage-collection, or if
there is short network outage.

This change caused some "reconnect" tests to fail due to short
auto-reconnect intervals letting disconnected nodes start reconnecting
before suspect processing completed on the force-disconnected nodes.
I've fixed this by reinitializing the UUID part of the membership ID in
JGroupsMessenger during reconnect attempts.

-    try {
-      logger.debug("Checking member {} with TCP socket connection {}:{}.", suspectMember,
-          suspectMember.getInetAddress(), port);
-      clientSocket =
-          SocketCreatorFactory.getSocketCreatorForComponent(SecurableCommunicationChannel.CLUSTER)
-              .connect(suspectMember.getInetAddress(), port, (int) memberTimeout,
-                  new ConnectTimeoutTask(services.getTimer(), memberTimeout), false, -1, false);
-      clientSocket.setTcpNoDelay(true);
-      return doTCPCheckMember(suspectMember, clientSocket);
-    } catch (IOException e) {
-      // this is expected if it is a connection-timeout or other failure
-      // to connect
-    } catch (IllegalStateException e) {
-      if (!isStopping) {
-        logger.trace("Unexpected exception", e);
-      }
-    } finally {
-      try {
-        if (clientSocket != null) {
-          clientSocket.setSoLinger(true, 0); // abort the connection
-          clientSocket.close();
+    // make sure we try to check on the member for the contracted memberTimeout period
+    // in case a timed socket.connect() returns immediately
+    long giveupTime = System.nanoTime() + TimeUnit.NANOSECONDS.convert(
+        services.getConfig().getMemberTimeout(), TimeUnit.MILLISECONDS);
+    boolean passed = false;
+    int iteration = 0;
+    do {
+      iteration++;
+      if (iteration > 1) {
+        try {
+          Thread.sleep(100);
+        } catch (InterruptedException e) {
+          Thread.currentThread().interrupt();
+          return false;
-      } catch (IOException e) {
-        // expected
-    }
-    return false;
+      try {
+        logger.debug("Checking member {} with TCP socket connection {}:{}.", suspectMember,
+            suspectMember.getInetAddress(), port);
+        clientSocket =
+            SocketCreatorFactory.getSocketCreatorForComponent(SecurableCommunicationChannel.CLUSTER)
+                .connect(suspectMember.getInetAddress(), port, (int) memberTimeout,
+                    new ConnectTimeoutTask(services.getTimer(), memberTimeout), false, -1, false);
+        clientSocket.setTcpNoDelay(true);
+        passed = doTCPCheckMember(suspectMember, clientSocket);
+      } catch (IOException e) {
+        // this is expected if it is a connection-timeout or other failure
+        // to connect
+      } catch (IllegalStateException | GemFireConfigException e) {
+        if (!isStopping) {
+          logger.trace("Unexpected exception", e);
+        }
+      } finally {
+        try {
+          if (clientSocket != null) {
+            clientSocket.setSoLinger(true, 0); // abort the connection
+            clientSocket.close();
+          }
+        } catch (IOException e) {
+          // expected
+        }
+      }
+    } while (!passed && !this.isShutdown() && System.nanoTime() < giveupTime);
+    return passed;

INS8 MOV60 INS60 INS60 INS60 INS19 INS41 INS39 INS59 INS39 INS59 INS39 INS59 MOV8 INS27 INS42 INS42 INS27 INS42 INS9 INS42 INS34 INS21 INS25 INS38 INS38 INS27 INS32 INS32 INS37 INS27 INS8 INS42 INS32 INS32 INS42 INS42 INS42 INS40 INS42 INS32 INS40 INS42 INS42 INS34 INS54 INS21 INS52 INS42 INS42 INS42 INS32 INS42 INS8 INS12 INS7 INS84 INS42 INS42 INS21 INS44 INS8 INS42 MOV32 MOV43 INS43 INS32 INS43 INS42 INS21 MOV41 INS42 INS42 INS42 INS34 INS42 INS32 INS32 INS42 INS42 INS42 DEL41
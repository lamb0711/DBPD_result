GEODE-420: Clean up of SocketCreator code in tests.
SocketCreatorFactory currently singleton, to amend at later stage

+import static com.gemstone.gemfire.distributed.ConfigurationProperties.*;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.lang.reflect.Array;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.StringTokenizer;
+import java.util.TreeSet;
+
+import com.gemstone.gemfire.internal.net.SocketCreator;
-import java.io.*;
-import java.lang.reflect.Array;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.*;
-
-import static com.gemstone.gemfire.distributed.ConfigurationProperties.*;
+
-  
+
+
-  
+
-   * Use {@link #toLoggerString()} instead. If you need to override this in a 
+   * Use {@link #toLoggerString()} instead. If you need to override this in a
-  
+
-    for (ConfigSource fileSource: getFileSources()) {
+    for (ConfigSource fileSource : getFileSources()) {
-  
+
+   *
-    
-    for (int i=0; i < validAttributeNames.length; i++) {
+
+    for (int i = 0; i < validAttributeNames.length; i++) {
-  
+
-   * Gets all the GemFire properties defined using file(s) 
+   * Gets all the GemFire properties defined using file(s)
-    for (ConfigSource fileSource: getFileSources()) {
+    for (ConfigSource fileSource : getFileSources()) {
-  
+
-    for (ConfigSource cs: getAttSourceMap().values()) {
+    for (ConfigSource cs : getAttSourceMap().values()) {
-    for (int i=0; i < validAttributeNames.length; i++) {
+    for (int i = 0; i < validAttributeNames.length; i++) {
-      if(attName.equals(SECURITY_SHIRO_INIT)){
+      if (attName.equals(SECURITY_SHIRO_INIT)) {
-  
+
-  
+
+
+
-  
+
-  
+
-    for (int i=0; i < attNames.length; i++) {
+    for (int i = 0; i < attNames.length; i++) {
+
-    }
-    finally {
+    } finally {
-    for (int i=0; i < validAttributeNames.length; i++) {
+    for (int i = 0; i < validAttributeNames.length; i++) {
-        for (int j=0; j < thisLength; j++) {
+        for (int j = 0; j < thisLength; j++) {
-      throw new IllegalArgumentException(LocalizedStrings.AbstractConfig_UNKNOWN_CONFIGURATION_ATTRIBUTE_NAME_0_VALID_ATTRIBUTE_NAMES_ARE_1.toLocalizedString(new Object[] {attName, SystemAdmin.join(validAttNames)}));
+      throw new IllegalArgumentException(LocalizedStrings.AbstractConfig_UNKNOWN_CONFIGURATION_ATTRIBUTE_NAME_0_VALID_ATTRIBUTE_NAMES_ARE_1.toLocalizedString(new Object[] {
+        attName,
+        SystemAdmin.join(validAttNames)
+      }));
-  
+
-      return (String)result;
+      return (String) result;
-      int[] value = (int[])result;
-      return ""+value[0]+"-"+value[1];
+      int[] value = (int[]) result;
+      return "" + value[0] + "-" + value[1];
-      return SystemAdmin.join((Object[])result);
+      return SystemAdmin.join((Object[]) result);
-      InetAddress addr = (InetAddress)result;
+      InetAddress addr = (InetAddress) result;
+      } else if (valueType.equals(String[].class)) {
+        attObjectValue = commaDelimitedStringToStringArray(attValue);
-        value[1] = Integer.valueOf(attValue.substring(minus+1)).intValue();
+        value[1] = Integer.valueOf(attValue.substring(minus + 1)).intValue();
-          throw new IllegalArgumentException(LocalizedStrings.AbstractConfig_0_VALUE_1_MUST_BE_A_VALID_HOST_NAME_2.toLocalizedString(new Object[] {attName, attValue, ex.toString()}));
+          throw new IllegalArgumentException(LocalizedStrings.AbstractConfig_0_VALUE_1_MUST_BE_A_VALID_HOST_NAME_2.toLocalizedString(new Object[] {
+            attName,
+            attValue,
+            ex.toString()
+          }));
-          throw new UnmodifiableException(LocalizedStrings.AbstractConfig_THE_0_CONFIGURATION_ATTRIBUTE_CAN_NOT_BE_SET_FROM_THE_COMMAND_LINE_SET_1_FOR_EACH_INDIVIDUAL_PARAMETER_INSTEAD.toLocalizedString(new Object[] {attName, trimAttName}));
+          throw new UnmodifiableException(LocalizedStrings.AbstractConfig_THE_0_CONFIGURATION_ATTRIBUTE_CAN_NOT_BE_SET_FROM_THE_COMMAND_LINE_SET_1_FOR_EACH_INDIVIDUAL_PARAMETER_INSTEAD
+            .toLocalizedString(new Object[] { attName, trimAttName }));
-          throw new IllegalArgumentException(LocalizedStrings.AbstractConfig_0_VALUE_1_MUST_HAVE_THREE_ELEMENTS_SEPARATED_BY_COMMAS.toLocalizedString(new Object[] {attName, attValue}));
+          throw new IllegalArgumentException(LocalizedStrings.AbstractConfig_0_VALUE_1_MUST_HAVE_THREE_ELEMENTS_SEPARATED_BY_COMMAS.toLocalizedString(new Object[] {
+            attName,
+            attValue
+          }));
-        float thresh = (float)0.0;
+        float thresh = (float) 0.0;
-          thresh  = Float.valueOf(values[1].trim()).floatValue();
+          thresh = Float.valueOf(values[1].trim()).floatValue();
-        }
-        catch (NumberFormatException e) {
-          throw new IllegalArgumentException(LocalizedStrings.AbstractConfig_0_VALUE_1_MUST_BE_COMPOSED_OF_AN_INTEGER_A_FLOAT_AND_AN_INTEGER.toLocalizedString(new Object[] {attName, attValue}));
+        } catch (NumberFormatException e) {
+          throw new IllegalArgumentException(LocalizedStrings.AbstractConfig_0_VALUE_1_MUST_BE_COMPOSED_OF_AN_INTEGER_A_FLOAT_AND_AN_INTEGER.toLocalizedString(new Object[] {
+            attName,
+            attValue
+          }));
-        throw new InternalGemFireException(LocalizedStrings.AbstractConfig_UNHANDLED_ATTRIBUTE_TYPE_0_FOR_1.toLocalizedString(new Object[] {valueType, attName}));
+        throw new InternalGemFireException(LocalizedStrings.AbstractConfig_UNHANDLED_ATTRIBUTE_TYPE_0_FOR_1.toLocalizedString(new Object[] {
+          valueType,
+          attName
+        }));
-      throw new IllegalArgumentException(LocalizedStrings.AbstractConfig_0_VALUE_1_MUST_BE_A_NUMBER.toLocalizedString(new Object[] {attName, attValue}));
+      throw new IllegalArgumentException(LocalizedStrings.AbstractConfig_0_VALUE_1_MUST_BE_A_NUMBER.toLocalizedString(new Object[] { attName, attValue }));
+  private String[] commaDelimitedStringToStringArray(final String tokenizeString) {
+    StringTokenizer stringTokenizer = new StringTokenizer(tokenizeString, ",");
+    String[] strings = new String[stringTokenizer.countTokens()];
+    for (int i = 0; i < strings.length; i++) {
+      strings[i] = stringTokenizer.nextToken();
+    }
+    return strings;
+  }
+
-    return attName.substring(0, attName.length()-1);
+    return attName.substring(0, attName.length() - 1);
+
-    return (String)getAttDescMap().get(attName);
+    return (String) getAttDescMap().get(attName);

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 INS40 INS40 INS40 INS31 INS83 INS5 INS42 INS44 INS8 INS43 INS85 INS83 INS43 INS42 INS60 INS60 INS24 INS41 UPD66 UPD66 INS42 INS42 INS43 INS59 INS5 INS59 INS58 INS27 INS37 INS8 INS42 INS42 INS42 INS14 INS43 INS85 INS42 INS3 INS39 INS59 INS42 INS40 INS42 INS21 INS25 INS43 INS42 INS45 INS42 INS5 INS32 INS42 INS34 INS7 INS32 INS8 MOV25 INS42 INS43 INS85 INS42 INS42 INS2 INS32 INS42 INS42 INS57 INS21 INS42 INS42 INS42 INS42 INS42 INS5 INS7 INS43 INS85 INS42 INS32 INS42 INS42 INS42
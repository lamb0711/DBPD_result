GEODE-5686: Remove LocalizedStrings

This removes the LocalizedStrings class and most uses of LogWriterI18n.
The I18n interfaces are still in place and still work since they're only
deprecated but there are no longer any uses of the StringID logging methods.

Going forward everyone should use the Log4j logging facility.  If you
must use the deprecated LogWriter use that version and not
LogWriterI18n.

-import org.apache.geode.i18n.StringId;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
-      return LocalizedStrings.PartitionedRegion_SHUTDOWN_LISTENER_FOR_PARTITIONEDREGION
-          .toLocalizedString();
+      return "Shutdown listener for PartitionedRegion";
-          LocalizedStrings.PartitionedRegion_PRIDMAPGET_NOT_SUPPORTED_USE_GETREGION_INSTEAD
-              .toLocalizedString());
+          "PRIdMap.get not supported - use getRegion instead");
-            LocalizedStrings.PartitionedRegion_REGION_FOR_PRID_0_IS_DESTROYED
-                .toLocalizedString(key),
+            String.format("Region for prId= %s  is destroyed",
+                key),
-            LocalizedStrings.PartitionedRegion_REGION_WITH_PRID_0_IS_LOCALLY_DESTROYED_ON_THIS_NODE
-                .toLocalizedString(key));
+            String.format("Region with prId= %s  is locally destroyed on this node",
+                key));
-            LocalizedStrings.PartitionedRegion_REGION_WITH_PRID_0_FAILED_INITIALIZATION_ON_THIS_NODE
-                .toLocalizedString(key));
+            String.format("Region with prId= %s  failed initialization on this node",
+                key));
-            LocalizedStrings.PartitionedRegion_NULL_KEY_NOT_ALLOWED_FOR_PRIDTOPR_MAP
-                .toLocalizedString());
+            "null key not allowed for prIdToPR Map");
-            LocalizedStrings.PartitionedRegion_NULL_VALUE_NOT_ALLOWED_FOR_PRIDTOPR_MAP
-                .toLocalizedString());
+            "null value not allowed for prIdToPR Map");
-            LocalizedStrings.PartitionedRegion_CAN_NOT_REUSE_OLD_PARTITIONED_REGION_ID_0
-                .toLocalizedString(key));
+            String.format("Can NOT reuse old Partitioned Region Id= %s",
+                key));
-              .info(LocalizedMessage.create(LocalizedStrings.PersistenceAdvisorImpl_PERSISTENT_VIEW,
+              .info(
+                  "The following persistent member has gone offline for region {}:{}.  Remaining participating members for the region include: {}",
-                      onlineMembers}));
+                      onlineMembers});
-      logger.info(LocalizedMessage.create(
-          LocalizedStrings.PartitionedRegion_ENABLING_CONCURRENCY_CHECKS_FOR_PERSISTENT_PR,
-          this.getFullPath()));
+      logger.info(
+          "Turning on concurrency checks for region: {} since it has been configured to persist data to disk.",
+          this.getFullPath());
-              LocalizedStrings.PartitionedRegion_FOR_REGION_0_TotalBucketNum_1_SHOULD_NOT_BE_CHANGED_Previous_Configured_2
-                  .toString(prms));
+              String.format(
+                  "For partition region %s,total-num-buckets %s should not be changed. Previous configured number is %s.",
+                  prms));
-              LocalizedStrings.LocalRegion_A_DISKACCESSEXCEPTION_HAS_OCCURRED_WHILE_WRITING_TO_THE_DISK_FOR_REGION_0_THE_REGION_WILL_BE_CLOSED
-                  .toLocalizedString(this.getFullPath()),
+              String.format(
+                  "A DiskAccessException has occurred while writing to the disk for region %s. The region will be closed.",
+                  this.getFullPath()),
-              LocalizedStrings.PartitionedRegion_FOR_REGION_0_ColocatedWith_1_SHOULD_NOT_BE_CHANGED_Previous_Configured_2
-                  .toString(prms));
+              String.format(
+                  "For partition region %s, Cannot change colocated-with to %s because there is persistent data with different colocation. Previous configured value is %s.",
+                  prms));
-            logger.error(
-                LocalizedMessage.create(
-                    LocalizedStrings.DistributedRegion_EXCEPTION_OCCURRED_IN_REGIONMEMBERSHIPLISTENER),
+            logger.error("Exception occurred in RegionMembershipListener",
-          LocalizedStrings.Region_REGION_0_HAS_1_GATEWAY_SENDER_IDS_ANOTHER_CACHE_HAS_THE_SAME_REGION_WITH_2_GATEWAY_SENDER_IDS_FOR_REGION_ACROSS_ALL_MEMBERS_IN_DS_GATEWAY_SENDER_IDS_SHOULD_BE_SAME
-              .toLocalizedString(
-                  new Object[] {this.getName(), senderIds.get(0), senderIds.get(1)}));
+          String.format(
+              "Region %s has %s gateway sender IDs. Another cache has same region with %s gateway sender IDs. For region across all members, gateway sender ids should be same.",
+
+              new Object[] {this.getName(), senderIds.get(0), senderIds.get(1)}));
-          LocalizedStrings.Region_REGION_0_HAS_1_ASYNC_EVENT_QUEUE_IDS_ANOTHER_CACHE_HAS_THE_SAME_REGION_WITH_2_ASYNC_EVENT_QUEUE_IDS_FOR_REGION_ACROSS_ALL_MEMBERS_IN_DS_ASYNC_EVENT_QUEUE_IDS_SHOULD_BE_SAME
-              .toLocalizedString(
-                  new Object[] {this.getName(), asycnQueueIds.get(0), asycnQueueIds.get(1)}));
+          String.format(
+              "Region %s has %s AsyncEvent queue IDs. Another cache has same region with %s AsyncEvent queue IDs. For region across all members, AsyncEvent queue IDs should be same.",
+
+              new Object[] {this.getName(), asycnQueueIds.get(0), asycnQueueIds.get(1)}));
-        logger.info(LocalizedMessage.create(
-            LocalizedStrings.PartitionedRegion_PARTITIONED_REGION_0_IS_BORN_WITH_PRID_1_IDENT_2,
-            new Object[] {getFullPath(), this.partitionedRegionId, getRegionIdentifier()}));
+        logger.info("Partitioned Region {} is born with prId={} ident:{}",
+            new Object[] {getFullPath(), this.partitionedRegionId, getRegionIdentifier()});
-        logger.info(LocalizedMessage.create(
-            LocalizedStrings.PartitionedRegion_PARTITIONED_REGION_0_IS_CREATED_WITH_PRID_1,
-            new Object[] {getFullPath(), this.partitionedRegionId}));
+        logger.info("Partitioned Region {} is created with prId={}",
+            new Object[] {getFullPath(), this.partitionedRegionId});
-          LocalizedStrings.PartitionedRegion_CAN_NOT_CREATE_PARTITIONEDREGION_FAILED_TO_ACQUIRE_REGIONLOCK
-              .toLocalizedString(),
+          "Can not create PartitionedRegion (failed to acquire RegionLock).",
-          LocalizedStrings.PartitionedRegion_AN_EXCEPTION_WAS_CAUGHT_WHILE_REGISTERING_PARTITIONEDREGION_0_DUMPPRID_1
-              .toLocalizedString(getFullPath(), prIdToPR.dump());
+          String.format(
+              "An exception was caught while registering PartitionedRegion %s. dumpPRId: %s",
+              getFullPath(), prIdToPR.dump());
-            logger.info(LocalizedMessage.create(
-                LocalizedStrings.PartitionedRegion_FAILED_REGISTRATION_PRID_0_NAMED_1,
-                new Object[] {this.partitionedRegionId, this.getName()}));
+            logger.info("FAILED_REGISTRATION prId={} named {}",
+                new Object[] {this.partitionedRegionId, this.getName()});
-                    LocalizedStrings.PartitionRegion_NON_COLOCATED_REGIONS_1_2_CANNOT_HAVE_SAME_PARALLEL_GATEWAY_SENDER_ID_2
-                        .toString(new Object[] {this.getFullPath(), config.getFullPath(),
+                    String.format(
+                        "Non colocated regions %s, %s cannot have the same parallel %s id %s configured.",
+                        new Object[] {this.getFullPath(), config.getFullPath(),
-                LocalizedStrings.PartitionRegion_NON_COLOCATED_REGIONS_1_2_CANNOT_HAVE_SAME_PARALLEL_GATEWAY_SENDER_ID_2
-                    .toString(new Object[] {this.getFullPath(), config.getFullPath(),
+                String.format(
+                    "Non colocated regions %s, %s cannot have the same parallel %s id %s configured.",
+                    new Object[] {this.getFullPath(), config.getFullPath(),
-          LocalizedStrings.PRHARedundancyProvider_PARTITIONED_REGION_0_OFFLINE_HAS_UNRECOVERED_PERSISTENT_DATA_1
-              .toLocalizedString(new Object[] {getFullPath(), persistIds}));
+          String.format("Partitioned Region %s is offline due to unrecovered persistent data, %s",
+              new Object[] {getFullPath(), persistIds}));
-          LocalizedStrings.PartitionRegion_NO_VM_AVAILABLE_FOR_GETENTRY_IN_0_ATTEMPTS
-              .toLocalizedString(count));
+          String.format("No VM available for getEntry in %s attempts",
+              count));
-    logger.warn(LocalizedMessage.create(
-        LocalizedStrings.PartitionRegion_NO_VM_AVAILABLE_FOR_GETENTRY_IN_0_ATTEMPTS, count), e);
+    logger.warn(String.format("No VM available for getEntry in %s attempts", count), e);
-          LocalizedStrings.PartitionedRegion_QUERY_MUST_BE_A_SELECT_EXPRESSION_ONLY
-              .toLocalizedString());
+          "query must be a select expression only");
-            LocalizedStrings.PartitionedRegion_UNEXPECTED_QUERY_EXCEPTION_OCCURRED_DURING_QUERY_EXECUTION_0
-                .toLocalizedString(qe.getMessage()),
+            String.format("Unexpected query exception occurred during query execution  %s",
+                qe.getMessage()),
-        logger.warn(
-            LocalizedMessage.create(
-                LocalizedStrings.PartitionedRegion_PRVIRTUALPUT_RETURNING_FALSE_WHEN_IFNEW_AND_IFOLD_ARE_BOTH_FALSE),
-            new Exception(LocalizedStrings.PartitionedRegion_STACK_TRACE.toLocalizedString()));
+        logger.warn("PR.virtualPut returning false when ifNew and ifOld are both false",
+            new Exception("stack trace"));
-      logger.info(LocalizedMessage.create(LocalizedStrings.Region_PutAll_Applied_PartialKeys_0_1,
-          new Object[] {getFullPath(), partialKeys}));
+      logger.info("Region {} putAll: {}",
+          new Object[] {getFullPath(), partialKeys});
-      logger.info(LocalizedMessage.create(LocalizedStrings.Region_PutAll_Applied_PartialKeys_0_1,
-          new Object[] {getFullPath(), partialKeys}));
+      logger.info("Region {} putAll: {}",
+          new Object[] {getFullPath(), partialKeys});
-              LocalizedStrings.PartitionedRegion_FALSE_RESULT_WHEN_IFNEW_AND_IFOLD_IS_UNACCEPTABLE_RETRYING
-                  .toLocalizedString());
+              "false result when !ifNew and !ifOld is unacceptable - retrying");
-            LocalizedStrings.PartitionedRegion_ATTEMPT_TO_ACQUIRE_PRIMARY_NODE_FOR_WRITE_ON_BUCKET_0_TIMED_OUT_IN_1_MS_CURRENT_REDUNDANCY_2_DOES_NOT_SATISFY_MINIMUM_3
-                .toLocalizedString(new Object[] {bucketStringForLogs(bucketId),
+            String.format(
+                "Attempt to acquire primary node for write on bucket  %s  timed out in  %s  ms. Current redundancy [ %s ] does not satisfy minimum [ %s ]",
+                new Object[] {bucketStringForLogs(bucketId),
-            LocalizedStrings.PartitionedRegion_PUTTING_ENTRY_ON_0_FAILED
-                .toLocalizedString(recipient),
+            String.format("Putting entry on  %s  failed",
+                recipient),
-            LocalizedStrings.FOR_FIXED_PARTITION_REGION_0_PARTITION_1_IS_NOT_YET_INITIALIZED_ON_DATASTORE
-                .toString(new Object[] {getName(), partitionName}));
+            String.format(
+                "For FixedPartitionedRegion %s, Partition %s is not yet initialized on datastore",
+                new Object[] {getName(), partitionName}));
-                      LocalizedStrings.PartitionedRegion_MULTIPLE_TARGET_NODE_FOUND_FOR
-                          .toLocalizedString());
+                      "Multiple target nodes found for single hop operation");
-      throw new FunctionException(LocalizedStrings.PartitionedRegion_NO_TARGET_NODE_FOUND_FOR_KEY_0
-          .toLocalizedString(routingKeys));
+      throw new FunctionException(String.format("No target node found for KEY, %s",
+          routingKeys));
-                LocalizedStrings.PartitionedRegion_MULTIPLE_TARGET_NODE_FOUND_FOR
-                    .toLocalizedString());
+                "Multiple target nodes found for single hop operation");
-          LocalizedStrings.PartitionedRegion_NO_TARGET_NODE_FOUND_FOR_KEY_0.toLocalizedString(key));
+          String.format("No target node found for KEY, %s", key));
-              LocalizedStrings.PartitionedRegion_NO_TARGET_NODE_FOUND_FOR_KEY_0
-                  .toLocalizedString(key));
+              String.format("No target node found for KEY, %s",
+                  key));
-          LocalizedStrings.PartitionedRegion_FUNCTION_NOT_EXECUTED_AS_REGION_IS_EMPTY
-              .toLocalizedString());
+          "Region is empty and the function cannot be executed");
-                      LocalizedStrings.PartitionedRegion_MULTIPLE_TARGET_NODE_FOUND_FOR
-                          .toLocalizedString());
+                      "Multiple target nodes found for single hop operation");
-          LocalizedStrings.PartitionedRegion_FUNCTION_NOT_EXECUTED_AS_REGION_IS_EMPTY
-              .toLocalizedString());
+          "Region is empty and the function cannot be executed");
-                LocalizedStrings.PartitionedRegion_TRANSACTIONAL_DATA_MOVED_DUE_TO_REBALANCING
-                    .toLocalizedString(key),
+                "Transactional data moved, due to rebalancing.",
-                LocalizedStrings.PartitionedRegion_TRANSACTIONAL_DATA_MOVED_DUE_TO_REBALANCING
-                    .toLocalizedString(key),
+                "Transactional data moved, due to rebalancing.",
-          LocalizedStrings.PartitionRegion_NO_VM_AVAILABLE_FOR_GET_IN_0_ATTEMPTS
-              .toLocalizedString(count));
+          String.format("No VM available for get in %s attempts",
+              count));
-    logger.warn(LocalizedMessage
-        .create(LocalizedStrings.PartitionRegion_NO_VM_AVAILABLE_FOR_GET_IN_0_ATTEMPTS, count), e);
+    logger.warn(String.format("No VM available for get in %s attempts", count), e);
-                LocalizedStrings.PartitionedRegion_ATTEMPT_TO_ACQUIRE_PRIMARY_NODE_FOR_READ_ON_BUCKET_0_TIMED_OUT_IN_1_MS
-                    .toLocalizedString(new Object[] {getBucketName(buck), snoozer.getRetryTime()}));
+                String.format(
+                    "Attempt to acquire primary node for read on bucket  %s  timed out in  %s  ms",
+                    new Object[] {getBucketName(buck), snoozer.getRetryTime()}));
-      logger.warn(LocalizedMessage.create(
-          LocalizedStrings.PartitionedRegion_RELEASEPRIDLOCK_UNLOCKING_0_CAUGHT_AN_EXCEPTION,
-          Integer.valueOf(PartitionedRegionHelper.MAX_PARTITIONED_REGION_ID)), es);
+      logger.warn(String.format("releasePRIDLock: unlocking %s caught an exception",
+          Integer.valueOf(PartitionedRegionHelper.MAX_PARTITIONED_REGION_ID),
+          es));
-            logger.warn(LocalizedMessage.create(
-                LocalizedStrings.PartitionedRegion_0_IS_USING_PRID_1_FOR_2_BUT_THIS_PROCESS_MAPS_THAT_PRID_TO_3,
-                new Object[] {sender.toString(), prId, pr.getRegionIdentifier()}));
+            logger.warn("{} is using PRID {} for {} but this process maps that PRID to {}",
+                new Object[] {sender.toString(), prId, pr.getRegionIdentifier()});
-          logger.warn(LocalizedMessage.create(
-              LocalizedStrings.PartitionedRegion_0_IS_USING_PRID_1_FOR_2_BUT_THIS_PROCESS_IS_USING_PRID_3,
-              new Object[] {sender, prId, pr.getRegionIdentifier(), pr.getPRId()}));
+          logger.warn("{} is using PRID {} for {} but this process is using PRID {}",
+              new Object[] {sender, prId, pr.getRegionIdentifier(), pr.getPRId()});
-                LocalizedStrings.PartitionedRegion_ENTRY_NOT_FOUND_FOR_KEY_0
-                    .toLocalizedString(event.getKey()));
+                String.format("Entry not found for key  %s",
+                    event.getKey()));
-              LocalizedStrings.PartitionedRegion_TIME_OUT_LOOKING_FOR_TARGET_NODE_FOR_DESTROY_WAITED_0_MS
-                  .toLocalizedString(retryTime.getRetryTime()));
+              String.format("Time out looking for target node for destroy; waited  %s  ms",
+                  retryTime.getRetryTime()));
-            LocalizedStrings.PartitionedRegion_DESTROY_OF_ENTRY_ON_0_FAILED
-                .toLocalizedString(recipient),
+            String.format("Destroy of entry on  %s  failed",
+                recipient),
-          LocalizedMessage.create(
-              LocalizedStrings.PartitionedRegion_PARTITIONEDREGION_CLEANUPFAILEDINITIALIZATION_FAILED_TO_CLEAN_THE_PARTIONREGION_DATA_STORE),
+          "PartitionedRegion#cleanupFailedInitialization(): Failed to clean the PartionRegion data store",
-            LocalizedMessage.create(
-                LocalizedStrings.PartitionedRegion_PARTITIONEDREGION_CLEANUPFAILEDINITIALIZATION_FAILED_TO_CLEAN_THE_PARTIONREGION_DATA_STORE),
+            "PartitionedRegion#cleanupFailedInitialization(): Failed to clean the PartionRegion data store",
-            LocalizedMessage.create(
-                LocalizedStrings.PartitionedRegion_PARTITIONEDREGION_CLEANUPFAILEDINITIALIZATION_FAILED_TO_CLEAN_THE_PARTIONREGION_ALLPARTITIONEDREGIONS),
+            "PartitionedRegion#cleanupFailedInitialization: Failed to clean the PartionRegion allPartitionedRegions",
-          LocalizedStrings.PartitionedRegion_INVALIDATING_REGION_CAUGHT_EXCEPTION
-              .toLocalizedString(count));
+          String.format("Invalidating partitioned region caught exception %s",
+              count));
-                LocalizedStrings.PartitionedRegion_ENTRY_NOT_FOUND_FOR_KEY_0
-                    .toLocalizedString(event.getKey()));
+                String.format("Entry not found for key  %s",
+                    event.getKey()));
-        LocalizedStrings.PartitionedRegion_NO_VM_AVAILABLE_FOR_INVALIDATE_IN_0_ATTEMPTS
-            .toLocalizedString(count)); // Fix for bug 36014
+        String.format("No VM available for invalidate in %s attempts.",
+            count)); // Fix for bug 36014
-      logger.warn(LocalizedMessage.create(
-          LocalizedStrings.PartitionedRegion_NO_VM_AVAILABLE_FOR_INVALIDATE_IN_0_ATTEMPTS, count));
+      logger.warn("No VM available for invalidate in {} attempts.", count);
-            LocalizedStrings.PartitionedRegion_INVALIDATION_OF_ENTRY_ON_0_FAILED
-                .toLocalizedString(recipient),
+            String.format("Invalidation of entry on  %s  failed",
+                recipient),
-            LocalizedStrings.PartitionedRegion_CREATE_OF_ENTRY_ON_0_FAILED
-                .toLocalizedString(recipient),
+            String.format("Create of entry on  %s  failed",
+                recipient),
-          LocalizedStrings.LocalRegion_VALUE_FOR_CONTAINSVALUEVALUE_CANNOT_BE_NULL
-              .toLocalizedString());
+          "Value for containsValue(value) cannot be null");
-      logger.warn(LocalizedMessage.create(LocalizedStrings.PR_CONTAINSVALUE_WARNING),
+      logger.warn("PR containsValue warning. Got an exception while executing function",
-    StringId msg = null;
+    String msg;
-          LocalizedStrings.PartitionedRegion_NO_VM_AVAILABLE_FOR_CONTAINS_VALUE_FOR_KEY_IN_1_ATTEMPTS;
+          "No VM available for contains value for key in %s attempts";
-      msg = LocalizedStrings.PartitionedRegion_NO_VM_AVAILABLE_FOR_CONTAINS_KEY_IN_1_ATTEMPTS;
+      msg = "No VM available for contains key in %s attempts";
-      e = new PartitionedRegionDistributionException(msg.toLocalizedString(countInteger));
+      e = new PartitionedRegionDistributionException(String.format(msg, countInteger));
-    logger.warn(LocalizedMessage.create(msg, countInteger), e);
+    logger.warn(String.format(msg, countInteger), e);
-                    logger.fatal(LocalizedMessage.create(
-                        LocalizedStrings.PartitionedRegion_0_SECONDS_HAVE_ELAPSED_WAITING_FOR_THE_PARTITIONED_REGION_LOCK_HELD_BY_1,
-                        new Object[] {(ackWaitThreshold + ackSAThreshold) / 1000, lockHolder}));
+                    logger.fatal(
+                        "{} seconds have elapsed waiting for the partitioned region lock held by {}",
+                        new Object[] {(ackWaitThreshold + ackSAThreshold) / 1000,
+                            lockHolder});
-                    logger.fatal(LocalizedMessage.create(
-                        LocalizedStrings.PartitionedRegion_0_SECONDS_HAVE_ELAPSED_WAITING_FOR_GLOBAL_REGION_ENTRY_LOCK_HELD_BY_1,
-                        new Object[] {(ackWaitThreshold + ackSAThreshold) / 1000, lockHolder}));
+                    logger.fatal(
+                        "{} seconds have elapsed waiting for global region entry lock held by {}",
+                        (ackWaitThreshold + ackSAThreshold) / 1000,
+                        lockHolder);
-          LocalizedStrings.PartitionedRegion_PR_0_IS_LOCALLY_CLOSED.toLocalizedString(this),
+          String.format("PR  %s  is locally closed", this),
-      logger.info(LocalizedMessage.create(
-          LocalizedStrings.PartitionedRegion_PARTITIONED_REGION_0_WITH_PRID_1_CLOSING,
-          new Object[] {getFullPath(), getPRId()}));
+      logger.info("Partitioned Region {} with prId={} closing.",
+          new Object[] {getFullPath(), getPRId()});
-    logger.info(LocalizedMessage.create(
-        LocalizedStrings.PartitionedRegion_PARTITIONED_REGION_0_WITH_PRID_1_CLOSED,
-        new Object[] {getFullPath(), getPRId()}));
+    logger.info("Partitioned Region {} with prId={} closed.",
+        new Object[] {getFullPath(), getPRId()});
-              LocalizedStrings.PartitionedRegion_GATEWAYSENDER_0_IS_PAUSED_RESUME_IT_BEFORE_DESTROYING_USER_REGION_1
-                  .toLocalizedString(pausedSenders, this.getName());
+              String.format("GatewaySender %s is paused. Resume it before destroying region %s.",
+                  pausedSenders, this.getName());
-              LocalizedStrings.PartitionedRegion_GATEWAYSENDERS_0_ARE_PAUSED_RESUME_THEM_BEFORE_DESTROYING_USER_REGION_1
-                  .toLocalizedString(pausedSenders, this.getName());
+              String.format(
+                  "GatewaySenders %s are paused. Resume them before destroying region %s.",
+                  pausedSenders, this.getName());
-      logger.info(LocalizedMessage.create(
-          LocalizedStrings.PartitionedRegion_PARTITIONED_REGION_0_WITH_PRID_1_IS_BEING_DESTROYED,
-          new Object[] {getFullPath(), getPRId()}));
+      logger.info("Partitioned Region {} with prId={} is being destroyed.",
+          new Object[] {getFullPath(), getPRId()});
-      logger.info(LocalizedMessage.create(
-          LocalizedStrings.PartitionedRegion_PARTITIONED_REGION_0_WITH_PRID_1_IS_DESTROYED,
-          new Object[] {getFullPath(), getPRId()}));
+      logger.info("Partitioned Region {} with prId={} is destroyed.",
+          new Object[] {getFullPath(), getPRId()});
-        logger.info(
-            LocalizedMessage.create(
-                LocalizedStrings.PartitionedRegion_CAUGHT_EXCEPTION_WHILE_TRYING_TO_UNLOCK_DURING_REGION_DESTRUCTION),
+        logger.info("Caught exception while trying to unlock during Region destruction.",
-          LocalizedMessage.create(
-              LocalizedStrings.PartitionedRegion_PARTITIONEDREGION_SENDDESTROYREGIONMESSAGE_CAUGHT_EXCEPTION_DURING_DESTROYREGIONMESSAGE_SEND_AND_WAITING_FOR_RESPONSE),
+          "PartitionedRegion#sendDestroyRegionMessage: Caught exception during DestroyRegionMessage send and waiting for response",
-            LocalizedStrings.PartitionedRegion_DATA_STORE_ON_THIS_VM_IS_NULL_AND_THE_LOCAL_MAX_MEMORY_IS_NOT_ZERO_THE_DATA_POLICY_IS_0_AND_THE_LOCALMAXMEMEORY_IS_1
-                .toLocalizedString(getDataPolicy(), (long) getLocalMaxMemory()));
+            String.format(
+                "Data Store on this vm is null and the local max Memory is not zero, the data policy is  %s  and the localMaxMemeory is :  %s",
+                getDataPolicy(), (long) getLocalMaxMemory()));
-      logger.info(LocalizedMessage.create(
-          LocalizedStrings.PartitionedRegion_THIS_IS_AN_ACCESSOR_VM_AND_DOESNT_CONTAIN_DATA));
+      logger.info("This is an accessor vm and doesnt contain data");
-          LocalizedStrings.IndexManager_INDEX_NAMED_0_ALREADY_EXISTS.toLocalizedString(indexName));
+          String.format("Index named ' %s ' already exists.", indexName));
-            logger.info(LocalizedMessage.create(
-                LocalizedStrings.PartitionedRegion_CREATED_INDEX_LOCALLY_SENDING_INDEX_CREATION_MESSAGE_TO_ALL_MEMBERS_AND_WILL_BE_WAITING_FOR_RESPONSE_0,
-                prIndex));
+            logger.info(
+                "Created index locally, sending index creation message to all members, and will be waiting for response {}.",
+                prIndex);
-                  LocalizedStrings.PartitionedRegion_INDEX_CREATION_FAILED_ROLLING_UPGRADE
-                      .toLocalizedString());
+                  "Indexes should not be created when there are older versions of gemfire in the cluster.");
-            LocalizedStrings.IndexManager_INDEX_NAMED_0_ALREADY_EXISTS
-                .toLocalizedString(indexName));
+            String.format("Index named ' %s ' already exists.",
+                indexName));
-            LocalizedStrings.PartitionedRegion_DATA_STORE_ON_THIS_VM_IS_NULL_AND_THE_LOCAL_MAX_MEMORY_IS_NOT_ZERO_THE_DATA_POLICY_IS_0_AND_THE_LOCALMAXMEMEORY_IS_1
-                .toLocalizedString(getDataPolicy(), (long) getLocalMaxMemory()));
+            String.format(
+                "Data Store on this vm is null and the local max Memory is not zero, the data policy is  %s  and the localMaxMemeory is :  %s",
+                getDataPolicy(), (long) getLocalMaxMemory()));
-          .info(LocalizedStrings.PartitionedRegion_THIS_IS_AN_ACCESSOR_VM_AND_DOESNT_CONTAIN_DATA);
+          .info("This is an accessor vm and doesnt contain data");
-          LocalizedStrings.PartitionedRegion_CREATED_INDEX_LOCALLY_SENDING_INDEX_CREATION_MESSAGE_TO_ALL_MEMBERS_AND_WILL_BE_WAITING_FOR_RESPONSE_0);
+          "Created index locally, sending index creation message to all members, and will be waiting for response.");
-                  LocalizedStrings.PartitionedRegion_INDEX_CREATION_FAILED_ROLLING_UPGRADE
-                      .toLocalizedString()));
+                  "Indexes should not be created when there are older versions of gemfire in the cluster."));
-      logger.info(LocalizedMessage.create(
-          LocalizedStrings.PartitionedRegion_NEWLY_ADDED_MEMBER_TO_THE_PR_IS_AN_ACCESSOR_AND_WILL_NOT_RECEIVE_INDEX_INFORMATION_0,
-          idM));
+      logger.info(
+          "Newly added member to the PR is an accessor and will not receive index information : {}",
+          idM);
-        logger.info(LocalizedStrings.PartitionedRegion_FORCEREATTEMPT_EXCEPTION___0, e);
+        logger.info(String.format("ForceReattempt exception :  %s", e));
-    logger.info(LocalizedMessage.create(
-        LocalizedStrings.PartitionedRegion_REMOVING_ALL_THE_INDEXES_ON_THIS_PARITITION_REGION__0,
-        this));
+    logger.info("Removing all the indexes on this paritition region {}",
+        this);
-        logger.info(LocalizedMessage.create(
-            LocalizedStrings.PartitionedRegion_SENDING_REMOVEINDEX_MESSAGE_TO_ALL_THE_PARTICIPATING_PRS));
+        logger.info("Sending removeIndex message to all the participating prs.");
-          logger.info(LocalizedMessage
-              .create(LocalizedStrings.PartitionedRegion_DONE_WATING_FOR_REMOVE_INDEX));
+          logger.info("Done wating for remove index...");
-      logger.info(LocalizedMessage.create(
-          LocalizedStrings.PartitionedRegion_THIS_INDEX__0_IS_NOT_ON_THIS_PARTITONED_REGION___1,
-          new Object[] {ind, this}));
+      logger.info("This index  %s is not on this partitoned region :  {}",
+          ind, this);
-      logger.info(LocalizedMessage.create(
-          LocalizedStrings.PartitionedRegion_SENDING_REMOVEINDEX_MESSAGE_TO_ALL_THE_PARTICIPATING_PRS));
+      logger.info("Sending removeIndex message to all the participating prs.");
-        logger.info(LocalizedMessage
-            .create(LocalizedStrings.PartitionedRegion_DONE_WATING_FOR_REMOVE_INDEX));
+        logger.info("Done wating for remove index...");
-            LocalizedStrings.PartitionedRegion_TX_ON_DATASTORE.toLocalizedString());
+            "PartitionedRegion Transactions cannot execute on nodes with local max memory zero");
-              LocalizedStrings.PartitionedRegion_TRANSACTIONAL_DATA_MOVED_DUE_TO_REBALANCING
-                  .toLocalizedString(),
+              "Transactional data moved, due to rebalancing.",
-          LocalizedStrings.PartitionedRegion_KEY_0_NOT_COLOCATED_WITH_TRANSACTION
-              .toLocalizedString(entryKey));
+          String.format("Key %s is not colocated with transaction",
+              entryKey));
-                LocalizedStrings.PartitionedRegion_TX_ON_DATASTORE.toLocalizedString());
+                "PartitionedRegion Transactions cannot execute on nodes with local max memory zero");
-          LocalizedStrings.PartitionedRegion_TRANSACTIONAL_DATA_MOVED_DUE_TO_REBALANCING
-              .toLocalizedString(),
+          "Transactional data moved, due to rebalancing.",
-          LocalizedStrings.PartitionedRegion_KEY_0_NOT_COLOCATED_WITH_TRANSACTION
-              .toLocalizedString(entryKey));
+          String.format("Key %s is not colocated with transaction",
+              entryKey));
-              LocalizedStrings.PartitionedRegion_DATA_STORE_ON_THIS_VM_IS_NULL_AND_THE_LOCAL_MAX_MEMORY_IS_NOT_ZERO_0
-                  .toLocalizedString((long) getLocalMaxMemory()));
+              String.format("Data Store on this vm is null and the local max Memory is not zero %s",
+                  (long) getLocalMaxMemory()));
-        logger.info(LocalizedMessage.create(
-            LocalizedStrings.PartitionedRegion_THIS_IS_AN_ACCESSOR_VM_AND_DOESNT_CONTAIN_DATA));
+        logger.info("This is an accessor vm and doesnt contain data");
-                LocalizedStrings.PartitionedRegion_ENTRY_NOT_FOUND_FOR_KEY_0
-                    .toLocalizedString(event.getKey()));
+                String.format("Entry not found for key  %s",
+                    event.getKey()));
-        LocalizedStrings.PartitionedRegion_NO_VM_AVAILABLE_FOR_UPDATE_ENTRY_VERSION_IN_0_ATTEMPTS
-            .toLocalizedString(count)); // Fix for bug 36014
+        String.format("No VM available for update-version in %s attempts.",
+            count)); // Fix for bug 36014
-      logger.warn(LocalizedMessage.create(
-          LocalizedStrings.PartitionedRegion_NO_VM_AVAILABLE_FOR_UPDATE_ENTRY_VERSION_IN_0_ATTEMPTS,
-          count));
+      logger.warn("No VM available for update-version in {} attempts.",
+          count);
-            LocalizedStrings.PartitionedRegion_UPDATE_VERSION_OF_ENTRY_ON_0_FAILED
-                .toLocalizedString(recipient),
+            String.format("Update version of entry on %s failed.",
+                recipient),

MOV8 MOV25 INS70 MOV21 MOV44 INS42 MOV8 MOV43 UPD43 MOV32 MOV21 MOV25 MOV12 MOV43 MOV27 MOV27 INS70 MOV44 UPD42 INS21 UPD42 UPD42 INS45 INS25 INS45 MOV52 INS25 MOV44 MOV44 INS45 MOV32 MOV44 MOV32 MOV8 UPD42 UPD42 INS45 MOV32 MOV32 UPD42 UPD42 INS45 MOV43 MOV43 UPD42 UPD42 INS32 MOV32 MOV32 MOV27 INS8 MOV27 INS8 MOV25 MOV43 UPD42 UPD42 INS45 INS45 UPD42 UPD42 INS45 UPD42 UPD42 INS45 INS45 INS45 MOV44 MOV44 UPD42 INS42 INS45 INS45 MOV42 INS45 INS45 INS45 INS42 INS42 INS45 MOV3 MOV8 UPD42 UPD42 INS45 UPD42 UPD42 INS45 INS45 INS53 INS45 INS45 INS45 MOV42 INS45 INS42 INS52 INS45 INS53 MOV27 UPD42 INS42 INS45 INS45 MOV42 INS45 MOV43 MOV43 INS45 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 MOV32 MOV32 INS45 MOV32 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 INS45 MOV43 INS45 UPD42 INS42 INS45 INS45 UPD42 INS42 INS45 INS14 INS14 INS12 MOV43 INS45 MOV43 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 UPD42 INS45 UPD42 UPD42 INS45 UPD42 INS42 INS45 MOV25 MOV60 UPD42 INS42 INS45 INS45 UPD42 INS42 INS45 UPD42 UPD42 INS45 INS42 UPD42 INS42 INS45 UPD42 INS42 UPD42 MOV43 INS32 INS45 INS45 MOV43 INS45 MOV44 INS8 UPD42 INS42 INS45 MOV25 UPD42 INS42 INS45 MOV43 MOV38 INS8 INS45 MOV43 UPD42 INS42 INS45 INS45 INS45 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 INS42 INS42 INS45 MOV32 MOV11 INS32 INS53 MOV43 INS25 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 MOV32 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 INS42 INS42 INS45 MOV42 INS45 INS14 UPD42 INS42 INS45 UPD42 INS42 INS45 MOV32 UPD42 INS42 INS45 MOV43 UPD42 INS42 INS45 MOV32 MOV8 INS8 MOV43 INS45 UPD42 INS42 INS45 MOV32 UPD42 UPD42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 MOV43 INS45 INS42 UPD42 UPD42 INS45 UPD42 INS42 INS45 MOV32 MOV60 MOV60 MOV60 INS25 INS45 UPD42 UPD42 INS45 UPD42 INS42 INS45 INS45 MOV42 INS45 INS45 INS45 UPD42 UPD42 INS45 MOV32 MOV8 INS8 UPD42 INS42 INS45 MOV43 INS45 UPD42 INS42 INS45 INS53 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 INS14 MOV43 INS45 INS45 MOV43 INS32 INS42 INS42 INS45 MOV3 INS45 INS45 MOV32 UPD42 UPD42 INS45 INS45 INS27 INS42 MOV36 MOV34 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL40 DEL40 DEL40 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL40 DEL40 DEL42 DEL42 DEL32 DEL40 DEL42 DEL42 DEL32 DEL40 DEL40 DEL40 DEL42 DEL42 DEL40 DEL32 DEL40 DEL40 DEL40 DEL42 DEL42 DEL32 DEL40 DEL42 DEL42 DEL32 DEL40 DEL42 DEL32 DEL40 DEL40 DEL42 DEL42 DEL32 DEL40 DEL40 DEL42 DEL32 DEL14 DEL53 DEL8 DEL25 DEL25 DEL42 DEL70 DEL8 DEL70 DEL8 DEL40 DEL40 DEL40 DEL40 DEL42 DEL32 DEL40 DEL42 DEL42 DEL40 DEL32 DEL40 DEL42 DEL32 DEL40 DEL42 DEL42 DEL32 DEL40 DEL42 DEL42 DEL32 DEL40 DEL42 DEL32 DEL40 DEL40 DEL40 DEL40 DEL42 DEL32 DEL40 DEL40 DEL42 DEL32 DEL40 DEL40 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL40 DEL42 DEL42 DEL32 DEL40 DEL42 DEL42 DEL32 DEL40 DEL40 DEL40 DEL40 DEL42 DEL40 DEL42 DEL42 DEL32 DEL40 DEL42 DEL42 DEL32 DEL40 DEL40 DEL40 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL40 DEL40 DEL40 DEL42 DEL42 DEL40 DEL32 DEL40 DEL40 DEL40 DEL42 DEL32 DEL42 DEL42 DEL40 DEL32 DEL33 DEL40 DEL40 DEL40 DEL42 DEL42 DEL32 DEL42 DEL42 DEL40 DEL42 DEL43 DEL85 DEL5 DEL27 DEL42 DEL4 DEL3 DEL32 DEL40 DEL40 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL40 DEL32 DEL32 DEL21 DEL40 DEL40 DEL40 DEL42 DEL42 DEL32 DEL40 DEL42 DEL42 DEL32 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL40 DEL42 DEL42 DEL40 DEL32 DEL40 DEL42 DEL42 DEL40 DEL32 DEL40 DEL42 DEL32 DEL40 DEL40 DEL40 DEL40 DEL42 DEL32 DEL42 DEL42 DEL40 DEL32 DEL40 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL42 DEL43 DEL85 DEL5 DEL42 DEL52 DEL4 DEL3 DEL32 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL40 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL14 DEL53 DEL8 DEL25 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL42 DEL14 DEL53 DEL8 DEL12 DEL40 DEL40 DEL40 DEL42 DEL32 DEL14 DEL53 DEL8 DEL25 DEL42 DEL42 DEL40 DEL32 DEL40 DEL40 DEL42 DEL42 DEL40 DEL32 DEL40
GEODE-2142: Removal of non-compliant org.json implementation.

-package org.json;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.io.StringReader;
-
- * Copyright (c) 2002 JSON.org
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
- * associated documentation files (the "Software"), to deal in the Software without restriction,
- * including without limitation the rights to use, copy, modify, merge, publish, distribute,
- * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- * 
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- * 
- * The Software shall be used for Good, not Evil.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
- * NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
- * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+package org.json;
+
+// Note: this class was written without inspecting the non-free org.json sourcecode.
+
+import java.io.IOException;
+import java.io.Reader;
+
- * A JSONTokener takes a source string and extracts characters and tokens from it. It is used by the
- * JSONObject and JSONArray constructors to parse JSON source strings.
- * 
- * @author JSON.org
- * @version 2012-02-16
+ * Parses a JSON (<a href="http://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>)
+ * encoded string into the corresponding object. Most clients of
+ * this class will use only need the {@link #JSONTokener(String) constructor}
+ * and {@link #nextValue} method. Example usage: <pre>
+ * String json = "{"
+ *         + "  \"query\": \"Pizza\", "
+ *         + "  \"locations\": [ 94043, 90210 ] "
+ *         + "}";
+ *
+ * JSONObject object = (JSONObject) new JSONTokener(json).nextValue();
+ * String query = object.getString("query");
+ * JSONArray locations = object.getJSONArray("locations");</pre>
+ *
+ * <p>For best interoperability and performance use JSON that complies with
+ * RFC 4627, such as that generated by {@link JSONStringer}. For legacy reasons
+ * this parser is lenient, so a successful parse does not indicate that the
+ * input string was valid JSON. All of the following syntax errors will be
+ * ignored:
+ * <ul>
+ * <li>End of line comments starting with {@code //} or {@code #} and ending
+ * with a newline character.
+ * <li>C-style comments starting with {@code /*} and ending with
+ * {@code *}{@code /}. Such comments may not be nested.
+ * <li>Strings that are unquoted or {@code 'single quoted'}.
+ * <li>Hexadecimal integers prefixed with {@code 0x} or {@code 0X}.
+ * <li>Octal integers prefixed with {@code 0}.
+ * <li>Array elements separated by {@code ;}.
+ * <li>Unnecessary array separators. These are interpreted as if null was the
+ * omitted value.
+ * <li>Key-value pairs separated by {@code =} or {@code =>}.
+ * <li>Key-value pairs separated by {@code ;}.
+ * </ul>
+ *
+ * <p>Each tokener may be used to parse a single JSON string. Instances of this
+ * class are not thread safe. Although this class is nonfinal, it was not
+ * designed for inheritance and should not be subclassed. In particular,
+ * self-use by overrideable methods is not specified. See <i>Effective Java</i>
+ * Item 17, "Design and Document or inheritance or else prohibit it" for further
+ * information.
-  private long character;
-  private boolean eof;
-  private long index;
-  private long line;
-  private char previous;
-  private Reader reader;
-  private boolean usePrevious;
+    /**
+     * The input JSON.
+     */
+    private final String in;
+    /**
+     * The index of the next character to be returned by {@link #next}. When
+     * the input is exhausted, this equals the input's length.
+     */
+    private int pos;
-  /**
-   * Construct a JSONTokener from a Reader.
-   *
-   * @param reader A reader.
-   */
-  public JSONTokener(Reader reader) {
-    this.reader = reader.markSupported() ? reader : new BufferedReader(reader);
-    this.eof = false;
-    this.usePrevious = false;
-    this.previous = 0;
-    this.index = 0;
-    this.character = 1;
-    this.line = 1;
-  }
-
-
-  /**
-   * Construct a JSONTokener from an InputStream.
-   */
-  public JSONTokener(InputStream inputStream) throws JSONException {
-    this(new InputStreamReader(inputStream));
-  }
-
-
-  /**
-   * Construct a JSONTokener from a string.
-   *
-   * @param s A source string.
-   */
-  public JSONTokener(String s) {
-    this(new StringReader(s));
-  }
-
-
-  /**
-   * Back up one character. This provides a sort of lookahead capability, so that you can test for a
-   * digit or letter before attempting to parse the next number or identifier.
-   */
-  public void back() throws JSONException {
-    if (this.usePrevious || this.index <= 0) {
-      throw new JSONException("Stepping back two steps is not supported");
-    }
-    this.index -= 1;
-    this.character -= 1;
-    this.usePrevious = true;
-    this.eof = false;
-  }
-
-
-  /**
-   * Get the hex value of a character (base16).
-   * 
-   * @param c A character between '0' and '9' or between 'A' and 'F' or between 'a' and 'f'.
-   * @return An int between 0 and 15, or -1 if c was not a hex digit.
-   */
-  public static int dehexchar(char c) {
-    if (c >= '0' && c <= '9') {
-      return c - '0';
-    }
-    if (c >= 'A' && c <= 'F') {
-      return c - ('A' - 10);
-    }
-    if (c >= 'a' && c <= 'f') {
-      return c - ('a' - 10);
-    }
-    return -1;
-  }
-
-  public boolean end() {
-    return this.eof && !this.usePrevious;
-  }
-
-
-  /**
-   * Determine if the source string still contains characters that next() can consume.
-   * 
-   * @return true if not yet at the end of the source.
-   */
-  public boolean more() throws JSONException {
-    this.next();
-    if (this.end()) {
-      return false;
-    }
-    this.back();
-    return true;
-  }
-
-
-  /**
-   * Get the next character in the source string.
-   *
-   * @return The next character, or 0 if past the end of the source string.
-   */
-  public char next() throws JSONException {
-    int c;
-    if (this.usePrevious) {
-      this.usePrevious = false;
-      c = this.previous;
-    } else {
-      try {
-        c = this.reader.read();
-      } catch (IOException exception) {
-        throw new JSONException(exception);
-      }
-
-      if (c <= 0) { // End of stream
-        this.eof = true;
-        c = 0;
-      }
-    }
-    this.index += 1;
-    if (this.previous == '\r') {
-      this.line += 1;
-      this.character = c == '\n' ? 0 : 1;
-    } else if (c == '\n') {
-      this.line += 1;
-      this.character = 0;
-    } else {
-      this.character += 1;
-    }
-    this.previous = (char) c;
-    return this.previous;
-  }
-
-
-  /**
-   * Consume the next character, and check that it matches a specified character.
-   * 
-   * @param c The character to match.
-   * @return The character.
-   * @throws JSONException if the character does not match.
-   */
-  public char next(char c) throws JSONException {
-    char n = this.next();
-    if (n != c) {
-      throw this.syntaxError("Expected '" + c + "' and instead saw '" + n + "'");
-    }
-    return n;
-  }
-
-
-  /**
-   * Get the next n characters.
-   *
-   * @param n The number of characters to take.
-   * @return A string of n characters.
-   * @throws JSONException Substring bounds error if there are not n characters remaining in the
-   *         source string.
-   */
-  public String next(int n) throws JSONException {
-    if (n == 0) {
-      return "";
+    /**
+     * @param in JSON encoded string. Null is not permitted and will yield a
+     *           tokener that throws {@code NullPointerExceptions} when methods are
+     *           called.
+     */
+    public JSONTokener(String in) {
+        // consume an optional byte order mark (BOM) if it exists
+        if (in != null && in.startsWith("\ufeff")) {
+            in = in.substring(1);
+        }
+        this.in = in;
-    char[] chars = new char[n];
-    int pos = 0;
-
-    while (pos < n) {
-      chars[pos] = this.next();
-      if (this.end()) {
-        throw this.syntaxError("Substring bounds error");
-      }
-      pos += 1;
+    public JSONTokener(Reader input) throws IOException {
+        StringBuilder s = new StringBuilder();
+        char[] readBuf = new char[102400];
+        int n = input.read(readBuf);
+        while (n >= 0) {
+            s.append(readBuf, 0, n);
+            n = input.read(readBuf);
+        }
+        in = s.toString();
+        pos = 0;
-    return new String(chars);
-  }
+    /**
+     * Returns the next value from the input.
+     *
+     * @return a {@link JSONObject}, {@link JSONArray}, String, Boolean,
+     * Integer, Long, Double or {@link JSONObject#NULL}.
+     * @throws JSONException if the input is malformed.
+     */
+    public Object nextValue() throws JSONException {
+        int c = nextCleanInternal();
+        switch (c) {
+            case -1:
+                throw syntaxError("End of input");
-  /**
-   * Get the next char in the string, skipping whitespace.
-   * 
-   * @throws JSONException
-   * @return A character, or 0 if there are no more characters.
-   */
-  public char nextClean() throws JSONException {
-    for (;;) {
-      char c = this.next();
-      if (c == 0 || c > ' ') {
-        return c;
-      }
-    }
-  }
+            case '{':
+                return readObject();
+            case '[':
+                return readArray();
-  /**
-   * Return the characters up to the next close quote character. Backslash processing is done. The
-   * formal JSON format does not allow strings in single quotes, but an implementation is allowed to
-   * accept them.
-   * 
-   * @param quote The quoting character, either <code>"</code>&nbsp;<small>(double quote)</small> or
-   *        <code>'</code>&nbsp;<small>(single quote)</small>.
-   * @return A String.
-   * @throws JSONException Unterminated string.
-   */
-  public String nextString(char quote) throws JSONException {
-    char c;
-    StringBuffer sb = new StringBuffer();
-    for (;;) {
-      c = this.next();
-      switch (c) {
-        case 0:
-        case '\n':
-        case '\r':
-          throw this.syntaxError("Unterminated string");
-        case '\\':
-          c = this.next();
-          switch (c) {
-            case 'b':
-              sb.append('\b');
-              break;
-            case 't':
-              sb.append('\t');
-              break;
-            case 'n':
-              sb.append('\n');
-              break;
-            case 'f':
-              sb.append('\f');
-              break;
-            case 'r':
-              sb.append('\r');
-              break;
-            case 'u':
-              sb.append((char) Integer.parseInt(this.next(4), 16));
-              break;
-            case '"':
-            case '\\':
-            case '/':
-              sb.append(c);
-              break;
+            case '"':
+                return nextString((char) c);
+
-              throw this.syntaxError("Illegal escape.");
-          }
-          break;
-        default:
-          if (c == quote) {
-            return sb.toString();
-          }
-          sb.append(c);
-      }
-    }
-  }
-
-
-  /**
-   * Get the text up but not including the specified character or the end of line, whichever comes
-   * first.
-   * 
-   * @param delimiter A delimiter character.
-   * @return A string.
-   */
-  public String nextTo(char delimiter) throws JSONException {
-    StringBuffer sb = new StringBuffer();
-    for (;;) {
-      char c = this.next();
-      if (c == delimiter || c == 0 || c == '\n' || c == '\r') {
-        if (c != 0) {
-          this.back();
+                pos--;
+                return readLiteral();
-        return sb.toString().trim();
-      }
-      sb.append(c);
-  }
+    private int nextCleanInternal() throws JSONException {
+        while (pos < in.length()) {
+            int c = in.charAt(pos++);
+            switch (c) {
+                case '\t':
+                case ' ':
+                case '\n':
+                case '\r':
+                    continue;
-  /**
-   * Get the text up but not including one of the specified delimiter characters or the end of line,
-   * whichever comes first.
-   * 
-   * @param delimiters A set of delimiter characters.
-   * @return A string, trimmed.
-   */
-  public String nextTo(String delimiters) throws JSONException {
-    char c;
-    StringBuffer sb = new StringBuffer();
-    for (;;) {
-      c = this.next();
-      if (delimiters.indexOf(c) >= 0 || c == 0 || c == '\n' || c == '\r') {
-        if (c != 0) {
-          this.back();
+                case '/':
+                    if (pos == in.length()) {
+                        return c;
+                    }
+
+                    char peek = in.charAt(pos);
+                    switch (peek) {
+                        case '*':
+                            // skip a /* c-style comment */
+                            pos++;
+                            int commentEnd = in.indexOf("*/", pos);
+                            if (commentEnd == -1) {
+                                throw syntaxError("Unterminated comment");
+                            }
+                            pos = commentEnd + 2;
+                            continue;
+
+                        case '/':
+                            // skip a // end-of-line comment
+                            pos++;
+                            skipToEndOfLine();
+                            continue;
+
+                        default:
+                            return c;
+                    }
+
+                case '#':
+                    /*
+                     * Skip a # hash end-of-line comment. The JSON RFC doesn't
+                     * specify this behavior, but it's required to parse
+                     * existing documents. See http://b/2571423.
+                     */
+                    skipToEndOfLine();
+                    continue;
+
+                default:
+                    return c;
+            }
-        return sb.toString().trim();
-      }
-      sb.append(c);
+
+        return -1;
-  }
+    /**
+     * Advances the position until after the next newline character. If the line
+     * is terminated by "\r\n", the '\n' must be consumed as whitespace by the
+     * caller.
+     */
+    private void skipToEndOfLine() {
+        for (; pos < in.length(); pos++) {
+            char c = in.charAt(pos);
+            if (c == '\r' || c == '\n') {
+                pos++;
+                break;
+            }
+        }
+    }
-  /**
-   * Get the next value. The value can be a Boolean, Double, Integer, JSONArray, JSONObject, Long,
-   * or String, or the JSONObject.NULL object.
-   * 
-   * @throws JSONException If syntax error.
-   *
-   * @return An object.
-   */
-  public Object nextValue() throws JSONException {
-    char c = this.nextClean();
-    String string;
+    /**
+     * Returns the string up to but not including {@code quote}, unescaping any
+     * character escape sequences encountered along the way. The opening quote
+     * should have already been read. This consumes the closing quote, but does
+     * not include it in the returned string.
+     *
+     * @param quote either ' or ".
+     * @return The unescaped string.
+     * @throws JSONException if the string isn't terminated by a closing quote correctly.
+     */
+    public String nextString(char quote) throws JSONException {
+        /*
+         * For strings that are free of escape sequences, we can just extract
+         * the result as a substring of the input. But if we encounter an escape
+         * sequence, we need to use a StringBuilder to compose the result.
+         */
+        StringBuilder builder = null;
-    switch (c) {
-      case '"':
-      case '\'':
-        return this.nextString(c);
-      case '{':
-        this.back();
-        return new JSONObject(this);
-      case '[':
-        this.back();
-        return new JSONArray(this);
+        /* the index of the first character not yet appended to the builder. */
+        int start = pos;
+
+        while (pos < in.length()) {
+            int c = in.charAt(pos++);
+            if (c == quote) {
+                if (builder == null) {
+                    // a new string avoids leaking memory
+                    //noinspection RedundantStringConstructorCall
+                    return new String(in.substring(start, pos - 1));
+                } else {
+                    builder.append(in, start, pos - 1);
+                    return builder.toString();
+                }
+            }
+
+            if (c == '\\') {
+                if (pos == in.length()) {
+                    throw syntaxError("Unterminated escape sequence");
+                }
+                if (builder == null) {
+                    builder = new StringBuilder();
+                }
+                builder.append(in, start, pos - 1);
+                builder.append(readEscapeCharacter());
+                start = pos;
+            }
+        }
+
+        throw syntaxError("Unterminated string");
+    }
+
+    /**
+     * Unescapes the character identified by the character or characters that
+     * immediately follow a backslash. The backslash '\' should have already
+     * been read. This supports both unicode escapes "u000A" and two-character
+     * escapes "\n".
+     */
+    private char readEscapeCharacter() throws JSONException {
+        char escaped = in.charAt(pos++);
+        switch (escaped) {
+            case 'u':
+                if (pos + 4 > in.length()) {
+                    throw syntaxError("Unterminated escape sequence");
+                }
+                String hex = in.substring(pos, pos + 4);
+                pos += 4;
+                try {
+                    return (char) Integer.parseInt(hex, 16);
+                } catch (NumberFormatException nfe) {
+                    throw syntaxError("Invalid escape sequence: " + hex);
+                }
+
+            case 't':
+                return '\t';
+
+            case 'b':
+                return '\b';
+
+            case 'n':
+                return '\n';
+
+            case 'r':
+                return '\r';
+
+            case 'f':
+                return '\f';
+
+            case '\'':
+            case '"':
+            case '\\':
+            default:
+                return escaped;
+        }
+    }
+
+    /**
+     * Reads a null, boolean, numeric or unquoted string literal value. Numeric
+     * values will be returned as an Integer, Long, or Double, in that order of
+     * preference.
+     */
+    private Object readLiteral() throws JSONException {
+        String literal = nextToInternal("{}[]/\\:,=;# \t\f");
+
+        if (literal.length() == 0) {
+            throw syntaxError("Expected literal value");
+        } else if ("null".equalsIgnoreCase(literal)) {
+            return JSONObject.NULL;
+        } else if ("true".equalsIgnoreCase(literal)) {
+            return Boolean.TRUE;
+        } else if ("false".equalsIgnoreCase(literal)) {
+            return Boolean.FALSE;
+        }
+
+        /* try to parse as an integral type... */
+        if (literal.indexOf('.') == -1) {
+            int base = 10;
+            String number = literal;
+            if (number.startsWith("0x") || number.startsWith("0X")) {
+                number = number.substring(2);
+                base = 16;
+            } else if (number.startsWith("0") && number.length() > 1) {
+                number = number.substring(1);
+                base = 8;
+            }
+            try {
+                long longValue = Long.parseLong(number, base);
+                if (longValue <= Integer.MAX_VALUE && longValue >= Integer.MIN_VALUE) {
+                    return (int) longValue;
+                } else {
+                    return longValue;
+                }
+            } catch (NumberFormatException e) {
+                /*
+                 * This only happens for integral numbers greater than
+                 * Long.MAX_VALUE, numbers in exponential form (5e-10) and
+                 * unquoted strings. Fall through to try floating point.
+                 */
+            }
+        }
+
+        /* ...next try to parse as a floating point... */
+        try {
+            return Double.valueOf(literal);
+        } catch (NumberFormatException ignored) {
+        }
+
+        /* ... finally give up. We have an unquoted string */
+        //noinspection RedundantStringConstructorCall
+        return new String(literal); // a new string avoids leaking memory
+    }
+
+    /**
+     * Returns the string up to but not including any of the given characters or
+     * a newline character. This does not consume the excluded character.
+     */
+    private String nextToInternal(String excluded) {
+        int start = pos;
+        for (; pos < in.length(); pos++) {
+            char c = in.charAt(pos);
+            if (c == '\r' || c == '\n' || excluded.indexOf(c) != -1) {
+                return in.substring(start, pos);
+            }
+        }
+        return in.substring(start);
+    }
+
+    /**
+     * Reads a sequence of key/value pairs and the trailing closing brace '}' of
+     * an object. The opening brace '{' should have already been read.
+     */
+    private JSONObject readObject() throws JSONException {
+        JSONObject result = new JSONObject();
+
+        /* Peek to see if this is the empty object. */
+        int first = nextCleanInternal();
+        if (first == '}') {
+            return result;
+        } else if (first != -1) {
+            pos--;
+        }
+
+        while (true) {
+            Object name = nextValue();
+            if (!(name instanceof String)) {
+                if (name == null) {
+                    throw syntaxError("Names cannot be null");
+                } else {
+                    throw syntaxError("Names must be strings, but " + name
+                            + " is of type " + name.getClass().getName());
+                }
+            }
+
+            /*
+             * Expect the name/value separator to be either a colon ':', an
+             * equals sign '=', or an arrow "=>". The last two are bogus but we
+             * include them because that's what the original implementation did.
+             */
+            int separator = nextCleanInternal();
+            if (separator != ':' && separator != '=') {
+                throw syntaxError("Expected ':' after " + name);
+            }
+            if (pos < in.length() && in.charAt(pos) == '>') {
+                pos++;
+            }
+
+            result.put((String) name, nextValue());
+
+            switch (nextCleanInternal()) {
+                case '}':
+                    return result;
+                case ';':
+                case ',':
+                    continue;
+                default:
+                    throw syntaxError("Unterminated object");
+            }
+        }
+    }
+
+    /**
+     * Reads a sequence of values and the trailing closing brace ']' of an
+     * array. The opening brace '[' should have already been read. Note that
+     * "[]" yields an empty array, but "[,]" returns a two-element array
+     * equivalent to "[null,null]".
+     */
+    private JSONArray readArray() throws JSONException {
+        JSONArray result = new JSONArray();
+
+        /* to cover input that ends with ",]". */
+        boolean hasTrailingSeparator = false;
+
+        while (true) {
+            switch (nextCleanInternal()) {
+                case -1:
+                    throw syntaxError("Unterminated array");
+                case ']':
+                    if (hasTrailingSeparator) {
+                        result.put(null);
+                    }
+                    return result;
+                case ',':
+                case ';':
+                    /* A separator without a value first means "null". */
+                    result.put(null);
+                    hasTrailingSeparator = true;
+                    continue;
+                default:
+                    pos--;
+            }
+
+            result.put(nextValue());
+
+            switch (nextCleanInternal()) {
+                case ']':
+                    return result;
+                case ',':
+                case ';':
+                    hasTrailingSeparator = true;
+                    continue;
+                default:
+                    throw syntaxError("Unterminated array");
+            }
+        }
+    }
+
+    /**
+     * Returns an exception containing the given message plus the current
+     * position and the entire input string.
+     *
+     * @param message The message we want to include.
+     * @return An exception that we can throw.
+     */
+    public JSONException syntaxError(String message) {
+        return new JSONException(message + this);
+    }
+
+    /**
+     * Returns the current position and the entire input string.
+     */
+    @Override
+    public String toString() {
+        // consistent with the original implementation
+        return " at character " + pos + " of " + in;
-     * Handle unquoted text. This could be the values true, false, or null, or it can be a number.
-     * An implementation (such as this one) is allowed to also accept non-standard forms.
+     * Legacy APIs.
-     * Accumulate characters until we reach the end of the text or a formatting character.
+     * None of the methods below are on the critical path of parsing JSON
+     * documents. They exist only because they were exposed by the original
+     * implementation and may be used by some clients.
-    StringBuffer sb = new StringBuffer();
-    while (c >= ' ' && ",:]}/\\\"[{;=#".indexOf(c) < 0) {
-      sb.append(c);
-      c = this.next();
+    /**
+     * Returns true until the input has been exhausted.
+     *
+     * @return true if more input exists.
+     */
+    public boolean more() {
+        return pos < in.length();
-    this.back();
-    string = sb.toString().trim();
-    if ("".equals(string)) {
-      throw this.syntaxError("Missing value");
+    /**
+     * Returns the next available character, or the null character '\0' if all
+     * input has been exhausted. The return value of this method is ambiguous
+     * for JSON strings that contain the character '\0'.
+     *
+     * @return the next character.
+     */
+    public char next() {
+        return pos < in.length() ? in.charAt(pos++) : '\0';
-    return JSONObject.stringToValue(string);
-  }
-
-  /**
-   * Skip characters until the next character is the requested character. If the requested character
-   * is not found, no characters are skipped.
-   * 
-   * @param to A character to skip to.
-   * @return The requested character, or zero if the requested character is not found.
-   */
-  public char skipTo(char to) throws JSONException {
-    char c;
-    try {
-      long startIndex = this.index;
-      long startCharacter = this.character;
-      long startLine = this.line;
-      this.reader.mark(1000000);
-      do {
-        c = this.next();
-        if (c == 0) {
-          this.reader.reset();
-          this.index = startIndex;
-          this.character = startCharacter;
-          this.line = startLine;
-          return c;
+    /**
+     * Returns the next available character if it equals {@code c}. Otherwise an
+     * exception is thrown.
+     *
+     * @param c The character we are looking for.
+     * @return the next character.
+     * @throws JSONException If the next character isn't {@code c}
+     */
+    public char next(char c) throws JSONException {
+        char result = next();
+        if (result != c) {
+            throw syntaxError("Expected " + c + " but was " + result);
-      } while (c != to);
-    } catch (IOException exc) {
-      throw new JSONException(exc);
+        return result;
-    this.back();
-    return c;
-  }
+    /**
+     * Returns the next character that is not whitespace and does not belong to
+     * a comment. If the input is exhausted before such a character can be
+     * found, the null character '\0' is returned. The return value of this
+     * method is ambiguous for JSON strings that contain the character '\0'.
+     *
+     * @return The next non-whitespace character.
+     * @throws JSONException Should not be possible.
+     */
+    public char nextClean() throws JSONException {
+        int nextCleanInt = nextCleanInternal();
+        return nextCleanInt == -1 ? '\0' : (char) nextCleanInt;
+    }
+    /**
+     * Returns the next {@code length} characters of the input.
+     *
+     * <p>The returned string shares its backing character array with this
+     * tokener's input string. If a reference to the returned string may be held
+     * indefinitely, you should use {@code new String(result)} to copy it first
+     * to avoid memory leaks.
+     *
+     * @param length The desired number of characters to return.
+     * @return The next few characters.
+     * @throws JSONException if the remaining input is not long enough to
+     *                       satisfy this request.
+     */
+    public String next(int length) throws JSONException {
+        if (pos + length > in.length()) {
+            throw syntaxError(length + " is out of bounds");
+        }
+        String result = in.substring(pos, pos + length);
+        pos += length;
+        return result;
+    }
-  /**
-   * Make a JSONException to signal a syntax error.
-   *
-   * @param message The error message.
-   * @return A JSONException object, suitable for throwing
-   */
-  public JSONException syntaxError(String message) {
-    return new JSONException(message + this.toString());
-  }
+    /**
+     * Returns the {@link String#trim trimmed} string holding the characters up
+     * to but not including the first of:
+     * <ul>
+     * <li>any character in {@code excluded}
+     * <li>a newline character '\n'
+     * <li>a carriage return '\r'
+     * </ul>
+     *
+     * <p>The returned string shares its backing character array with this
+     * tokener's input string. If a reference to the returned string may be held
+     * indefinitely, you should use {@code new String(result)} to copy it first
+     * to avoid memory leaks.
+     *
+     * @param excluded The limiting string where the search should stop.
+     * @return a possibly-empty string
+     */
+    public String nextTo(String excluded) {
+        if (excluded == null) {
+            throw new NullPointerException("excluded == null");
+        }
+        return nextToInternal(excluded).trim();
+    }
+    /**
+     * Equivalent to {@code nextTo(String.valueOf(excluded))}.
+     *
+     * @param excluded The limiting character.
+     * @return a possibly-empty string
+     */
+    public String nextTo(char excluded) {
+        return nextToInternal(String.valueOf(excluded)).trim();
+    }
-  /**
-   * Make a printable string of this JSONTokener.
-   *
-   * @return " at {index} [character {character} line {line}]"
-   */
-  public String toString() {
-    return " at " + this.index + " [character " + this.character + " line " + this.line + "]";
-  }
+    /**
+     * Advances past all input up to and including the next occurrence of
+     * {@code thru}. If the remaining input doesn't contain {@code thru}, the
+     * input is exhausted.
+     *
+     * @param thru The string to skip over.
+     */
+    public void skipPast(String thru) {
+        int thruStart = in.indexOf(thru, pos);
+        pos = thruStart == -1 ? in.length() : (thruStart + thru.length());
+    }
+
+    /**
+     * Advances past all input up to but not including the next occurrence of
+     * {@code to}. If the remaining input doesn't contain {@code to}, the input
+     * is unchanged.
+     *
+     * @param to The character we want to skip to.
+     * @return The value of {@code to} or null.
+     */
+    public char skipTo(char to) {
+        int index = in.indexOf(to, pos);
+        if (index != -1) {
+            pos = index;
+            return to;
+        } else {
+            return '\0';
+        }
+    }
+
+    /**
+     * Unreads the most recent character of input. If no input characters have
+     * been read, the input is unchanged.
+     */
+    public void back() {
+        if (--pos == -1) {
+            pos = 0;
+        }
+    }
+
+    /**
+     * Returns the integer [0..15] value for the given hex character, or -1
+     * for non-hex input.
+     *
+     * @param hex a character in the ranges [0-9], [A-F] or [a-f]. Any other
+     *            character will yield a -1 result.
+     * @return The decoded integer.
+     */
+    public static int dehexchar(char hex) {
+        if (hex >= '0' && hex <= '9') {
+            return hex - '0';
+        } else if (hex >= 'A' && hex <= 'F') {
+            return hex - 'A' + 10;
+        } else if (hex >= 'a' && hex <= 'f') {
+            return hex - 'a' + 10;
+        } else {
+            return -1;
+        }
+    }

INS55 INS29 INS83 INS42 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS65 INS29 INS83 INS83 INS43 INS59 INS29 INS83 INS39 INS59 INS29 INS83 INS42 MOV44 INS8 INS83 INS42 MOV44 MOV43 INS8 INS29 INS83 MOV43 INS42 MOV43 INS8 INS83 INS39 INS42 MOV43 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 MOV43 INS42 MOV44 MOV43 INS8 INS29 INS83 INS39 INS42 MOV43 INS8 INS29 INS83 INS43 INS42 MOV43 INS8 INS29 INS83 MOV43 INS42 INS44 INS8 INS29 INS83 INS43 INS42 MOV43 INS8 INS29 INS83 INS43 INS42 MOV43 INS8 INS29 INS83 MOV43 INS42 MOV44 INS8 INS29 INS78 INS83 INS43 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 MOV44 MOV43 INS8 INS29 INS83 INS39 INS42 MOV43 INS8 INS29 INS83 MOV43 INS42 INS44 MOV43 INS8 INS29 INS83 MOV43 INS42 INS44 INS8 INS29 INS83 MOV43 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 MOV44 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS8 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS65 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS42 INS42 INS65 INS42 INS65 UPD42 INS25 INS21 UPD42 INS60 MOV60 INS60 INS61 INS21 INS21 INS65 INS65 INS65 INS60 INS50 INS61 MOV41 INS65 INS24 INS65 INS65 INS65 INS65 INS60 INS60 INS61 INS53 INS65 INS60 INS50 INS65 INS42 INS60 INS25 INS25 INS54 INS41 INS65 MOV43 INS42 INS60 INS24 INS41 INS65 INS42 INS60 INS60 INS25 INS61 INS65 INS42 INS60 INS60 INS61 INS65 INS65 INS65 INS41 INS65 INS42 INS42 INS41 INS65 INS65 INS41 INS65 INS65 INS41 INS65 INS65 INS65 INS65 INS60 INS25 INS41 INS65 INS65 INS65 INS60 INS41 INS65 INS65 INS65 INS65 INS39 INS42 INS25 INS60 INS21 INS41 INS65 INS65 INS65 INS43 INS42 INS25 INS41 INS65 INS65 INS65 INS39 INS42 INS41 INS65 INS65 INS43 INS42 INS60 INS21 INS65 INS65 INS65 INS60 INS25 INS65 INS25 INS65 INS65 INS65 INS39 INS42 INS25 INS68 INS66 INS67 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS42 INS66 INS66 INS65 INS66 INS66 INS27 INS8 INS7 INS43 INS59 MOV5 INS39 INS59 INS27 INS8 INS7 INS7 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS42 INS66 INS39 INS59 INS42 INS49 INS53 MOV49 INS41 MOV49 INS41 MOV49 MOV49 INS41 INS49 INS21 INS41 INS27 INS8 INS66 INS66 INS66 INS27 INS37 INS8 INS66 INS65 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS43 INS59 INS39 INS59 INS27 INS8 INS32 INS66 INS66 INS66 INS66 INS39 INS59 INS42 MOV49 INS25 INS60 INS21 INS54 MOV49 INS41 MOV49 INS41 MOV49 INS41 MOV49 INS41 MOV49 INS41 MOV49 MOV49 MOV49 INS49 INS41 INS66 INS66 INS66 INS43 INS59 INS27 INS8 INS25 INS27 INS8 INS8 INS12 INS14 INS66 INS66 INS39 INS59 INS27 INS37 INS8 INS32 INS66 INS66 INS43 INS59 INS39 INS59 INS27 INS8 INS25 INS9 INS8 INS66 INS66 INS66 INS66 MOV43 INS59 INS39 INS59 INS9 INS8 INS66 INS66 INS42 INS66 INS66 INS14 INS66 INS27 INS66 INS66 INS27 INS66 INS66 INS66 INS66 INS16 INS66 INS65 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS65 INS39 INS59 INS27 INS8 INS42 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS39 INS59 INS16 INS66 INS65 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS66 INS27 INS8 INS43 INS59 INS7 INS42 INS66 INS65 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS42 INS66 INS66 INS42 INS27 INS8 INS32 INS66 INS65 INS66 INS42 INS66 INS66 INS32 INS66 INS65 INS66 INS65 INS66 INS66 INS42 INS66 INS42 INS39 INS59 INS7 INS66 INS65 INS66 INS65 INS66 INS66 INS42 INS66 INS66 INS65 INS66 INS39 INS59 INS27 INS8 INS8 INS66 INS66 INS27 INS8 INS66 INS66 INS42 INS66 INS66 INS66 INS27 INS8 INS25 INS42 INS69 INS42 INS67 INS66 INS27 INS32 INS21 INS22 INS42 INS42 INS42 INS14 UPD42 INS42 INS32 INS42 INS34 INS21 INS21 INS42 INS32 INS42 INS34 INS42 INS42 INS67 INS42 INS32 INS38 INS32 INS32 INS32 INS32 INS37 INS32 INS42 INS32 INS60 INS50 INS42 INS32 INS42 INS60 INS25 INS66 INS42 INS42 INS33 INS42 INS42 INS42 INS32 INS60 INS25 INS25 INS42 INS45 INS42 INS32 INS27 INS8 MOV43 INS59 INS7 INS8 INS12 INS13 INS13 INS13 INS13 INS13 INS42 INS42 INS42 INS32 INS32 INS34 INS53 INS32 INS8 INS25 INS32 INS38 INS60 INS60 INS25 INS54 INS41 INS44 INS8 MOV43 INS42 INS42 INS42 INS42 INS32 INS42 INS60 INS25 INS42 INS42 INS42 INS42 INS42 MOV14 INS42 INS32 INS42 INS13 INS41 INS27 INS8 INS60 INS25 INS60 INS25 INS25 INS21 INS50 INS42 INS14 INS42 INS9 INS50 INS21 INS50 MOV43 INS27 INS45 INS42 INS45 INS42 INS42 INS32 INS27 INS32 INS13 INS66 INS66 INS42 INS32 INS42 INS42 INS53 INS42 INS32 INS27 INS13 INS11 INS66 INS66 INS27 INS32 INS53 INS42 INS42 INS32 INS42 INS42 INS67 INS66 INS66 INS66 INS42 INS33 INS53 INS32 INS42 INS66 INS32 INS42 INS66 INS66 INS42 INS32 INS42 INS16 INS66 INS66 INS66 INS42 INS32 INS42 INS38 INS21 INS41 INS41 INS38 INS38 INS21 INS27 INS27 INS41 INS27 INS8 INS25 INS43 INS42 INS42 INS33 INS42 INS42 INS45 INS7 INS52 INS42 INS43 MOV5 INS34 INS42 INS42 INS42 INS32 INS7 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS45 INS42 INS42 INS42 MOV11 INS42 INS42 INS42 INS42 INS39 INS59 INS42 INS49 INS49 MOV49 MOV49 INS18 INS49 INS25 INS60 INS50 INS49 INS21 INS18 INS49 MOV41 INS42 INS42 INS39 INS59 MOV27 INS8 INS42 INS42 INS39 INS59 MOV27 INS8 INS27 INS8 INS42 INS42 INS37 INS27 INS32 INS53 INS42 INS32 INS42 INS34 INS41 INS44 INS8 INS42 INS45 INS42 INS42 INS32 INS45 INS42 INS42 INS41 INS32 INS8 INS25 INS42 INS42 INS13 INS34 INS39 INS59 INS43 INS59 INS27 INS8 INS25 INS8 INS12 INS32 INS43 INS42 INS42 INS42 INS39 INS59 INS27 INS8 INS42 INS42 INS42 INS38 INS21 INS43 INS59 INS38 INS8 INS39 INS59 INS27 INS8 INS27 INS8 INS32 INS32 INS49 INS41 INS49 INS49 INS18 INS49 INS53 INS43 INS32 INS49 INS53 INS49 INS25 INS41 INS49 INS49 INS21 INS21 INS18 INS49 INS21 INS32 INS32 INS49 INS41 INS49 INS49 INS21 INS18 INS49 INS53 INS42 INS52 INS42 INS42 INS42 INS32 INS42 INS42 INS37 INS42 INS32 INS42 INS42 INS38 INS39 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS42 INS42 INS14 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS27 INS32 INS36 INS42 INS42 INS42 INS42 INS34 INS7 INS42 INS13 INS42 INS34 INS7 INS42 INS13 INS42 INS13 INS27 INS27 INS27 INS41 INS27 INS8 INS8 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS32 INS42 INS32 INS13 INS13 INS13 INS27 MOV8 INS39 INS59 INS42 INS49 INS21 INS60 INS25 INS21 INS18 MOV49 INS21 INS21 INS18 INS49 MOV41 INS13 INS32 INS42 INS32 MOV27 INS21 INS10 INS42 INS32 INS25 INS42 INS13 INS25 INS25 INS21 INS21 INS21 INS42 INS42 INS34 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS11 INS43 INS42 INS53 INS42 INS45 INS40 INS45 INS42 INS42 INS41 INS32 INS8 INS42 INS34 INS42 INS42 INS42 INS32 INS32 INS21 INS21 INS27 INS8 INS60 INS25 INS44 INS8 INS42 INS42 INS42 INS42 INS42 INS32 MOV27 INS27 INS41 INS34 INS37 INS42 INS42 INS32 INS36 INS25 INS42 INS32 INS27 INS27 INS53 INS27 INS27 INS21 INS42 INS42 INS11 INS32 INS42 INS13 INS42 INS13 INS13 INS32 INS42 INS42 INS38 INS32 INS13 INS42 INS8 INS42 INS13 INS13 INS32 INS7 INS37 INS42 INS42 INS32 INS42 INS13 INS42 INS13 INS13 INS7 INS32 INS42 INS42 INS42 INS42 INS27 INS34 INS42 INS27 INS42 INS42 INS43 INS45 INS42 INS42 INS42 INS42 INS38 INS42 INS42 INS27 INS42 INS42 INS42 INS34 INS42 INS13 INS42 INS13 INS42 INS13 INS27 INS27 INS27 INS41 INS41 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS37 INS42 INS32 INS42 INS32 INS13 INS37 INS39 INS59 INS27 INS8 INS7 INS37 INS32 INS42 INS42 INS42 INS42 INS37 INS42 INS42 INS37 INS27 INS8 INS8 INS27 INS8 INS27 INS8 INS32 INS32 INS7 INS42 INS45 INS42 INS34 INS39 INS32 INS42 INS32 INS40 INS45 INS42 INS42 INS41 INS42 INS42 INS45 INS42 INS42 INS45 INS7 INS7 INS32 INS27 INS21 INS21 INS39 INS59 INS27 INS8 INS8 INS43 INS42 INS42 INS42 INS42 MOV27 INS32 INS38 INS32 INS42 INS42 INS62 INS27 INS8 INS8 INS42 INS42 INS13 INS42 INS13 INS32 INS42 INS32 INS32 INS13 INS37 INS43 INS42 INS42 INS42 INS45 INS34 INS42 INS45 INS21 INS42 INS42 INS33 INS42 INS9 INS42 INS42 INS42 INS9 INS42 INS45 INS45 INS42 INS45 INS42 INS42 INS45 INS42 INS34 INS42 INS32 INS27 INS34 INS42 INS13 INS42 INS13 INS27 INS38 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS38 INS53 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS33 INS41 INS21 INS41 INS42 INS32 INS53 INS42 INS33 INS21 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS27 INS40 INS42 INS32 INS42 INS34 INS42 INS42 INS45 INS32 INS34 INS7 INS7 INS42 INS32 INS27 INS27 INS41 INS41 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS33 INS53 INS53 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS13 INS27 INS34 INS34 INS42 INS42 INS45 INS42 INS34 INS32 INS42 INS34 INS14 INS32 INS32 INS42 INS42 INS32 INS7 INS42 INS34 INS42 INS45 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS32 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS40 INS11 INS42 INS42 INS32 INS32 INS45 INS42 INS42 INS42 INS33 INS42 INS13 INS42 INS45 INS43 INS32 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS45 INS42 INS14 INS42 INS42 INS34 INS39 INS42 INS42 INS45 INS42 INS27 INS42 INS42 INS42 INS42 INS27 INS42 INS34 INS43 INS45 INS42 INS45 INS32 INS42 INS34 INS42 INS32 INS42 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL42 DEL42 DEL42 DEL27 DEL42 DEL34 DEL27 DEL27 DEL27 DEL42 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL34 DEL27 DEL27 DEL27 DEL52 DEL40 DEL26 DEL66 DEL66 DEL65 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL59 DEL23 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL14 DEL16 DEL7 DEL21 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL52 DEL42 DEL22 DEL34 DEL7 DEL21 DEL52 DEL42 DEL22 DEL34 DEL7 DEL21 DEL52 DEL42 DEL22 DEL34 DEL7 DEL21 DEL52 DEL42 DEL22 DEL34 DEL7 DEL21 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL17 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL14 DEL17 DEL8 DEL31 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL34 DEL27 DEL27 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL52 DEL42 DEL22 DEL34 DEL7 DEL21 DEL52 DEL42 DEL22 DEL34 DEL7 DEL21 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL13 DEL27 DEL42 DEL13 DEL27 DEL27 DEL42 DEL13 DEL27 DEL41 DEL8 DEL25 DEL42 DEL13 DEL27 DEL42 DEL13 DEL27 DEL27 DEL42 DEL13 DEL34 DEL27 DEL36 DEL27 DEL41 DEL8 DEL25 DEL42 DEL13 DEL27 DEL42 DEL13 DEL27 DEL27 DEL42 DEL13 DEL34 DEL27 DEL36 DEL27 DEL41 DEL8 DEL25 DEL8 DEL31 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL38 DEL27 DEL41 DEL8 DEL31 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL52 DEL42 DEL32 DEL21 DEL52 DEL42 DEL32 DEL9 DEL41 DEL8 DEL25 DEL52 DEL42 DEL32 DEL21 DEL9 DEL41 DEL8 DEL31 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL39 DEL42 DEL59 DEL60 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL42 DEL52 DEL42 DEL22 DEL7 DEL21 DEL8 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL34 DEL27 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL42 DEL34 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL52 DEL42 DEL22 DEL34 DEL7 DEL21 DEL52 DEL42 DEL22 DEL13 DEL27 DEL52 DEL42 DEL22 DEL34 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL13 DEL27 DEL34 DEL34 DEL16 DEL7 DEL21 DEL8 DEL42 DEL13 DEL27 DEL52 DEL42 DEL22 DEL34 DEL7 DEL21 DEL52 DEL42 DEL22 DEL34 DEL7 DEL21 DEL8 DEL52 DEL42 DEL22 DEL34 DEL7 DEL21 DEL8 DEL25 DEL25 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL39 DEL42 DEL52 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL27 DEL52 DEL42 DEL45 DEL42 DEL45 DEL42 DEL45 DEL27 DEL32 DEL53 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL34 DEL27 DEL45 DEL41 DEL8 DEL25 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL42 DEL27 DEL42 DEL42 DEL2 DEL52 DEL42 DEL32 DEL7 DEL21 DEL52 DEL42 DEL32 DEL52 DEL42 DEL45 DEL32 DEL53 DEL8 DEL25 DEL42 DEL34 DEL7 DEL21 DEL8 DEL61 DEL42 DEL14 DEL41 DEL8 DEL31 DEL66 DEL65 DEL42 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL39 DEL42 DEL52 DEL42 DEL32 DEL59 DEL60 DEL42 DEL34 DEL27 DEL42 DEL13 DEL27 DEL27 DEL25 DEL8 DEL24 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL39 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL52 DEL42 DEL32 DEL7 DEL21 DEL42 DEL34 DEL49 DEL52 DEL42 DEL45 DEL32 DEL53 DEL13 DEL49 DEL42 DEL52 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL13 DEL32 DEL21 DEL10 DEL42 DEL42 DEL13 DEL32 DEL21 DEL10 DEL42 DEL42 DEL13 DEL32 DEL21 DEL10 DEL42 DEL42 DEL13 DEL32 DEL21 DEL10 DEL42 DEL42 DEL13 DEL32 DEL21 DEL10 DEL42 DEL42 DEL39 DEL42 DEL42 DEL52 DEL42 DEL34 DEL32 DEL34 DEL32 DEL11 DEL32 DEL21 DEL10 DEL42 DEL42 DEL42 DEL32 DEL21 DEL10 DEL49 DEL52 DEL42 DEL45 DEL32 DEL53 DEL50 DEL10 DEL49 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL50 DEL8 DEL24 DEL8 DEL31 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL39 DEL42 DEL52 DEL42 DEL32 DEL59 DEL60 DEL42 DEL34 DEL27 DEL52 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL24 DEL8 DEL31 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL44 DEL39 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL52 DEL42 DEL32 DEL7 DEL21 DEL42 DEL34 DEL27 DEL52 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL24 DEL8 DEL31 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL39 DEL42 DEL52 DEL42 DEL32 DEL59 DEL60 DEL42 DEL59 DEL60 DEL42 DEL52 DEL42 DEL42 DEL32 DEL41 DEL52 DEL42 DEL32 DEL21 DEL41 DEL52 DEL42 DEL32 DEL21 DEL52 DEL14 DEL41 DEL50 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL13 DEL27 DEL45 DEL42 DEL42 DEL32 DEL34 DEL27 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL52 DEL42 DEL32 DEL7 DEL21 DEL8 DEL61 DEL52 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL7 DEL21 DEL45 DEL42 DEL42 DEL32 DEL52 DEL42 DEL45 DEL32 DEL53 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL39 DEL42 DEL59 DEL60 DEL39 DEL42 DEL52 DEL42 DEL22 DEL59 DEL60 DEL39 DEL42 DEL52 DEL42 DEL22 DEL59 DEL60 DEL39 DEL42 DEL52 DEL42 DEL22 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL34 DEL32 DEL21 DEL42 DEL52 DEL42 DEL32 DEL7 DEL21 DEL42 DEL34 DEL27 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL27 DEL19 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL52 DEL42 DEL32 DEL21 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL52 DEL42 DEL32 DEL27 DEL14 DEL41 DEL8 DEL31 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL45 DEL52 DEL42 DEL22 DEL45 DEL52 DEL42 DEL22 DEL45 DEL52 DEL42 DEL22 DEL45 DEL27 DEL41 DEL8 DEL31 DEL55
GEODE-1965 Create backward-compatibility unit test framework

See
https://cwiki.apache.org/confluence/display/GEODE/Writing+Backward-compatibility+DUnit+tests

This extends the distributed unit test framework to allow you to boot a
VM running an older version of Geode.  Using this extension you can create
rolling upgrade tests, client/server interoperability tests, persistent
store upgrade tests and so on.

VM numbering has not changed.  If you request that a VM use a certain
version of GEODE it will be bounced if necessary and its classpath modified
to point to that version.  The VM will continue to use that version until
bounced to a different version or the next test class is started.  All
VMs are moved to the current version at the beginning of a new test class.

Console output from versioned VMs will contain the symbolic version in use
by the VM, such as "[vm0_v100]" to help you know it is running a different
version of GEODE.

Tests are all compiled with the current Geode code, so if there are API
changes you must use reflection in order to invoke the old versions of
the API.  RollingUpgradeDUnitTests shows how to do this.

ClientServerMiscBCDUnitTest shows how to subclass an existing class to
make it run with multiple versions of Geode.  In this case the clients
are parameterized to run with older versions while servers are held to
the current version.

I will be opening a few tickets to track problems I have already encountered
with these tests.

+import org.apache.geode.test.dunit.VM;
-  private Map<Integer, ProcessHolder> processes = new HashMap<Integer, ProcessHolder>();
+  private Map<Integer, ProcessHolder> processes = new HashMap<>();
+  private VersionManager versionManager;
+    this.versionManager = VersionManager.getInstance();
-    if (processes.containsKey(vmNum)) {
-      throw new IllegalStateException("VM " + vmNum + " is already running.");
+    launchVM(VersionManager.CURRENT_VERSION, vmNum, false);
+  }
+
+  public synchronized void launchVM(String version, int vmNum, boolean bouncedVM)
+      throws IOException {
+    if (processes.containsKey(version)) {
+      throw new IllegalStateException(
+          "For version " + version + ", VM " + vmNum + " is already running.");
-    String[] cmd = buildJavaCommand(vmNum, namingPort);
+    String[] cmd = buildJavaCommand(vmNum, namingPort, version);
-    File workingDir = getVMDir(vmNum);
-    try {
-      FileUtil.delete(workingDir);
-    } catch (IOException e) {
-      // This delete is occasionally failing on some platforms, maybe due to a lingering
-      // process. Allow the process to be launched anyway.
-      System.err.println("Unable to delete " + workingDir + ". Currently contains "
-          + Arrays.asList(workingDir.list()));
+    File workingDir = getVMDir(version, vmNum);
+    if (!workingDir.exists()) {
+      workingDir.mkdirs();
+    } else if (!bouncedVM || DUnitLauncher.MAKE_NEW_WORKING_DIRS) {
+      try {
+        FileUtil.delete(workingDir);
+      } catch (IOException e) {
+        // This delete is occasionally failing on some platforms, maybe due to a lingering
+        // process. Allow the process to be launched anyway.
+        System.err.println("Unable to delete " + workingDir + ". Currently contains "
+            + Arrays.asList(workingDir.list()));
+      }
+      workingDir.mkdirs();
-    workingDir.mkdirs();
-    linkStreams(vmNum, holder, process.getErrorStream(), System.err);
-    linkStreams(vmNum, holder, process.getInputStream(), System.out);
+    linkStreams(version, vmNum, holder, process.getErrorStream(), System.err);
+    linkStreams(version, vmNum, holder, process.getInputStream(), System.out);
-  public static File getVMDir(int vmNum) {
-    return new File(DUnitLauncher.DUNIT_DIR, "vm" + vmNum);
+  public void validateVersion(String version) {
+    if (!versionManager.isValidVersion(version)) {
+      throw new IllegalArgumentException("Version " + version + " is not configured for use");
+    }
+  }
+
+  public static File getVMDir(String version, int vmNum) {
+    return new File(DUnitLauncher.DUNIT_DIR, VM.getVMName(VersionManager.CURRENT_VERSION, vmNum));
-  public synchronized void bounce(int vmNum) {
+  public synchronized void bounce(String version, int vmNum) {
-      launchVM(vmNum);
+      launchVM(version, vmNum, true);
-  private void linkStreams(final int vmNum, final ProcessHolder holder, final InputStream in,
-      final PrintStream out) {
+  private void linkStreams(final String version, final int vmNum, final ProcessHolder holder,
+      final InputStream in, final PrintStream out) {
-        String vmName = (vmNum == -2) ? "[locator]" : "[vm_" + vmNum + "]";
+        String vmName = "[" + VM.getVMName(version, vmNum) + "] ";
-  private String[] buildJavaCommand(int vmNum, int namingPort) {
+  private String[] buildJavaCommand(int vmNum, int namingPort, String version) {
-    String classPath = System.getProperty("java.class.path");
+    String dunitClasspath = System.getProperty("java.class.path");
+    String classPath;
+    if (!VersionManager.isCurrentVersion(version)) {
+      classPath = versionManager.getClasspath(version) + File.pathSeparator + dunitClasspath;
+    } else {
+      classPath = dunitClasspath;
+    }
+
-    String jdkSuspend = vmNum == suspendVM ? "y" : "n";
+    String jdkSuspend = vmNum == suspendVM ? "y" : "n"; // ignore version
+    cmds.add("-D" + DUnitLauncher.VM_VERSION_PARAM + "=" + version);
-      cmds.add("-D" + InternalLocator.INHIBIT_DM_BANNER + "=true");
+      if (version.equals(VersionManager.CURRENT_VERSION)) { // enable the banner for older versions
+        cmds.add("-D" + InternalLocator.INHIBIT_DM_BANNER + "=true");
+      }
+    return getStub(VersionManager.CURRENT_VERSION, i);
+  }
+
+  public RemoteDUnitVMIF getStub(String version, int i)
+      throws AccessException, RemoteException, NotBoundException, InterruptedException {
+
+  private static class VersionedVMNumber {
+    String version;
+    int number;
+
+    VersionedVMNumber(String version, int number) {
+      this.version = version;
+      this.number = number;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) {
+        return true;
+      }
+      if (o == null || getClass() != o.getClass()) {
+        return false;
+      }
+
+      VersionedVMNumber that = (VersionedVMNumber) o;
+
+      if (number != that.number) {
+        return false;
+      }
+      return version.equals(that.version);
+    }
+
+    @Override
+    public int hashCode() {
+      int result = version.hashCode();
+      result = 31 * result + number;
+      return result;
+    }
+  }

INS26 INS40 INS23 INS31 INS31 INS31 INS55 INS83 INS43 INS59 INS83 INS83 INS39 INS42 MOV44 INS43 INS8 INS44 INS44 INS83 INS39 INS42 INS44 INS8 INS44 INS44 INS44 INS44 INS44 INS83 INS43 INS42 INS44 INS43 INS43 INS43 INS43 INS8 INS44 INS83 INS83 INS42 INS23 INS23 INS31 INS31 INS31 INS42 INS42 INS21 INS42 INS21 INS43 INS42 INS39 INS42 INS25 INS43 INS42 INS25 INS43 INS42 INS39 INS42 INS43 INS42 INS83 INS43 INS42 INS43 INS42 INS60 INS25 INS21 INS42 INS39 INS42 INS42 INS42 INS42 INS42 INS41 INS43 INS42 INS43 INS59 INS39 INS59 INS42 INS44 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS8 UPD74 INS7 INS32 INS42 INS38 INS8 INS25 INS42 INS38 INS8 INS42 INS42 INS42 INS42 INS43 INS59 INS38 INS8 INS8 INS32 INS8 INS32 INS42 INS42 INS42 INS42 INS43 INS42 INS39 INS42 INS21 INS21 INS42 INS43 INS42 INS25 INS25 INS60 INS25 INS41 INS42 INS60 INS21 INS41 INS22 INS32 INS42 INS40 INS42 INS9 UPD42 INS32 INS21 INS27 INS8 INS42 INS42 INS32 INS53 INS32 UPD42 INS42 INS42 INS32 INS21 INS21 INS42 INS42 INS27 INS25 INS42 INS40 INS42 INS42 INS7 INS7 INS42 INS27 INS8 INS27 INS8 INS43 INS59 INS27 INS8 INS32 INS39 INS59 INS7 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS38 INS40 MOV54 MOV21 INS42 INS42 INS42 INS14 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS7 INS7 INS45 INS40 INS45 INS42 INS32 MOV8 INS22 INS42 INS22 INS42 INS52 INS42 INS41 INS27 INS27 INS41 INS42 INS42 INS11 INS42 INS40 INS41 INS42 INS42 INS40 INS42 INS32 INS42 INS27 INS42 INS42 INS42 INS43 INS27 INS42 INS9 INS42 INS27 INS42 INS42 INS42 INS42 INS40 INS52 INS42 INS52 INS42 INS9 INS42 INS33 INS32 INS32 INS9 INS43 INS42 INS9 INS42 INS42 INS27 INS42 INS45 INS42 UPD45 INS42 INS45 INS42 INS45 INS32 INS40 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS27 UPD45 MOV45 INS32 UPD45 MOV45 INS42 INS42 INS42 INS42 DEL42 DEL43 DEL42 DEL43 DEL45 DEL42 DEL27 DEL42 DEL34 DEL38 DEL27 DEL36 DEL45 DEL42 DEL27 DEL16
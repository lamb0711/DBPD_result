Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public class IndexManager  {
+public class IndexManager {
-  //Asif : This action is to rerun Index creation after
-  //clear is called on the region
+  // Asif : This action is to rerun Index creation after
+  // clear is called on the region
-   * Map containing <IndexTask, FutureTask<IndexTask> or Index>. IndexTask
-   * represents an index thats completely created or one thats in create phase.
-   * This is done in order to avoid synchronization on the indexes.
+   * Map containing <IndexTask, FutureTask<IndexTask> or Index>. IndexTask represents an index thats
+   * completely created or one thats in create phase. This is done in order to avoid synchronization
+   * on the indexes.
-  //TODO Asif : Fix the appropriate size of the Map & the concurrency level
+  // TODO Asif : Fix the appropriate size of the Map & the concurrency level
-  private final int INDEX_MAINTENANCE_BUFFER = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "AsynchIndexMaintenanceThreshold", -1).intValue();
+  private final int INDEX_MAINTENANCE_BUFFER =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "AsynchIndexMaintenanceThreshold", -1)
+          .intValue();
-  public static boolean JOIN_OPTIMIZATION = !Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "index.DisableJoinOptimization");
-  
+  public static boolean JOIN_OPTIMIZATION =
+      !Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "index.DisableJoinOptimization");
+
-  public static boolean INPLACE_OBJECT_MODIFICATION_FOR_TEST = false;    
+  public static boolean INPLACE_OBJECT_MODIFICATION_FOR_TEST = false;
-  //Added for testing only
-  public static boolean IS_TEST_LDM = false; 
+  // Added for testing only
+  public static boolean IS_TEST_LDM = false;
-  
-  
+
+
-   * System property to maintain the ReverseMap to take care in-place modification of the 
-   * objects by the application. 
-   * In case of in-place modification the EntryEvent will not have the old-value, without this
-   * the old-values are not removed from the index-maps thus resulting in inconsistent results.
+   * System property to maintain the ReverseMap to take care in-place modification of the objects by
+   * the application. In case of in-place modification the EntryEvent will not have the old-value,
+   * without this the old-values are not removed from the index-maps thus resulting in inconsistent
+   * results.
-  public static final boolean INPLACE_OBJECT_MODIFICATION =
-      Boolean.valueOf(System.getProperty(DistributionConfig.GEMFIRE_PREFIX + "index.INPLACE_OBJECT_MODIFICATION", "false")).booleanValue();
+  public static final boolean INPLACE_OBJECT_MODIFICATION = Boolean
+      .valueOf(System.getProperty(
+          DistributionConfig.GEMFIRE_PREFIX + "index.INPLACE_OBJECT_MODIFICATION", "false"))
+      .booleanValue();
-  public static final boolean RANGEINDEX_ONLY =
-      Boolean.valueOf(System.getProperty(DistributionConfig.GEMFIRE_PREFIX + "index.RANGEINDEX_ONLY", "false")).booleanValue();
+  public static final boolean RANGEINDEX_ONLY = Boolean
+      .valueOf(
+          System.getProperty(DistributionConfig.GEMFIRE_PREFIX + "index.RANGEINDEX_ONLY", "false"))
+      .booleanValue();
-  public static final int INDEX_ELEMARRAY_THRESHOLD = Integer.parseInt(System.getProperty(INDEX_ELEMARRAY_THRESHOLD_PROP,"100"));
-  public static final int INDEX_ELEMARRAY_SIZE = Integer.parseInt(System.getProperty(INDEX_ELEMARRAY_SIZE_PROP,"5"));
+  public static final int INDEX_ELEMARRAY_THRESHOLD =
+      Integer.parseInt(System.getProperty(INDEX_ELEMARRAY_THRESHOLD_PROP, "100"));
+  public static final int INDEX_ELEMARRAY_SIZE =
+      Integer.parseInt(System.getProperty(INDEX_ELEMARRAY_SIZE_PROP, "5"));
-  //private int numCreatorsInWaiting = 0;
+  // private int numCreatorsInWaiting = 0;
-    //indexes = Collections.synchronizedSortedMap(new TreeMap());
-    indexMaintenanceSynchronous = region.getAttributes()
-        .getIndexMaintenanceSynchronous();
-    isOverFlowToDisk = region.getAttributes().getEvictionAttributes()
-        .getAction().isOverflowToDisk();
+    // indexes = Collections.synchronizedSortedMap(new TreeMap());
+    indexMaintenanceSynchronous = region.getAttributes().getIndexMaintenanceSynchronous();
+    isOverFlowToDisk =
+        region.getAttributes().getEvictionAttributes().getAction().isOverflowToDisk();
-        LoggingThreadGroup.createThreadGroup("QueryMonitor Thread Group", logger);
+          LoggingThreadGroup.createThreadGroup("QueryMonitor Thread Group", logger);
-                                       "OqlIndexUpdater:" + region.getFullPath());
+          "OqlIndexUpdater:" + region.getFullPath());
-   
+
-   * Stores the largest combination of current time + delta
-   * If there is a large delta/hiccup in timings, this allows us to calculate the 
-   * correct results for a query but, reevaluate more aggressively.
-   * But the large hiccup will eventually be rolled off as time is always increasing
+   * Stores the largest combination of current time + delta If there is a large delta/hiccup in
+   * timings, this allows us to calculate the correct results for a query but, reevaluate more
+   * aggressively. But the large hiccup will eventually be rolled off as time is always increasing
-  
-  /** only for test purposes 
-   * This should not be called from any product code.  Calls from product code will 
-   * possibly cause continous reevaluation (performance issue) OR
-   * incorrect query results (functional issue)
+
+  /**
+   * only for test purposes This should not be called from any product code. Calls from product code
+   * will possibly cause continous reevaluation (performance issue) OR incorrect query results
+   * (functional issue)
-  
+
-   * Calculates whether we need to reevluate the key for the region entry
-   * We added a way to determine whether to reevaluate an entry for query execution
-   * The method is to keep track of the delta and current time in a single long value
-   * The value is then used by the query to determine if a region entry needs to be reevaluated,
-   * based on subtracting the value with the query execution time.  This provides a delta + some false positive time (dts)
-   * If the dts + last modified time of the region entry is > query start time, 
-   * we can assume that it needs to be reevaluated
+   * Calculates whether we need to reevluate the key for the region entry We added a way to
+   * determine whether to reevaluate an entry for query execution The method is to keep track of the
+   * delta and current time in a single long value The value is then used by the query to determine
+   * if a region entry needs to be reevaluated, based on subtracting the value with the query
+   * execution time. This provides a delta + some false positive time (dts) If the dts + last
+   * modified time of the region entry is > query start time, we can assume that it needs to be
+   * reevaluated
-   * This is to fix bug 47475, where references to region entries can be held
-   * by the executing query either directly or indirectly (iterators can hold 
-   * references for next) but the values underneath could change.
+   * This is to fix bug 47475, where references to region entries can be held by the executing query
+   * either directly or indirectly (iterators can hold references for next) but the values
+   * underneath could change.
+   * 
-    return ENABLE_UPDATE_IN_PROGRESS_INDEX_CALCULATION && queryStartTime <= SAFE_QUERY_TIME.get() - queryStartTime + lastModifiedTime;
+    return ENABLE_UPDATE_IN_PROGRESS_INDEX_CALCULATION
+        && queryStartTime <= SAFE_QUERY_TIME.get() - queryStartTime + lastModifiedTime;
-  
+
-      if (oldValue < newValue ) {
+      if (oldValue < newValue) {
-      }
-      else {
+      } else {
-  
+
-   * @param origIndexedExpression the expression to index on, a function
-   *          dependent on region entries individually.
-   * @param origFromClause expression that evaluates to the collection(s) that
-   *          will be queried over, must contain one and only one region path.
+   * @param origIndexedExpression the expression to index on, a function dependent on region entries
+   *        individually.
+   * @param origFromClause expression that evaluates to the collection(s) that will be queried over,
+   *        must contain one and only one region path.
-  public Index createIndex(String indexName, IndexType indexType,
-      String origIndexedExpression, String origFromClause, String imports,
-      ExecutionContext externalContext, PartitionedIndex prIndex, boolean loadEntries)
-      throws IndexNameConflictException, IndexExistsException,
-      IndexInvalidException {
-    
+  public Index createIndex(String indexName, IndexType indexType, String origIndexedExpression,
+      String origFromClause, String imports, ExecutionContext externalContext,
+      PartitionedIndex prIndex, boolean loadEntries)
+      throws IndexNameConflictException, IndexExistsException, IndexInvalidException {
+
-      throw new IndexInvalidException(LocalizedStrings.IndexCreationMsg_CANCELED_DUE_TO_LOW_MEMORY.toLocalizedString());
+      throw new IndexInvalidException(
+          LocalizedStrings.IndexCreationMsg_CANCELED_DUE_TO_LOW_MEMORY.toLocalizedString());
-    
+
-    if (!((GemFireCacheImpl)this.region.getCache()).isClient()) {
+    if (!((GemFireCacheImpl) this.region.getCache()).isClient()) {
-      if (getIndex(indexName) != null) { 
-        throw new IndexNameConflictException(LocalizedStrings.
-            IndexManager_INDEX_NAMED_0_ALREADY_EXISTS.toLocalizedString(indexName)); 
+      if (getIndex(indexName) != null) {
+        throw new IndexNameConflictException(
+            LocalizedStrings.IndexManager_INDEX_NAMED_0_ALREADY_EXISTS
+                .toLocalizedString(indexName));
-      //Hash index not supported for overflow but we "thought" we were so let's maintain backwards compatibility
-      //and create a regular compact range index instead.  This is due to having to reload  entries from overflow just
-      //to recalculate the index key for the entry for comparisons during query.
+      // Hash index not supported for overflow but we "thought" we were so let's maintain backwards
+      // compatibility
+      // and create a regular compact range index instead. This is due to having to reload entries
+      // from overflow just
+      // to recalculate the index key for the entry for comparisons during query.
-        helper = new FunctionalIndexCreationHelper(origFromClause,
-            origIndexedExpression, projectionAttributes, imports, region.getCache(),
-            externalContext, this);
-        //Asif: For now support Map index as non compact .expand later
-        //The limitation for compact range index also apply to hash index for now
-        isCompactOrHash = shouldCreateCompactIndex((FunctionalIndexCreationHelper)helper);
+        helper = new FunctionalIndexCreationHelper(origFromClause, origIndexedExpression,
+            projectionAttributes, imports, region.getCache(), externalContext, this);
+        // Asif: For now support Map index as non compact .expand later
+        // The limitation for compact range index also apply to hash index for now
+        isCompactOrHash = shouldCreateCompactIndex((FunctionalIndexCreationHelper) helper);
-        helper = new PrimaryKeyIndexCreationHelper(origFromClause,
-            origIndexedExpression, projectionAttributes, region.getCache(),
-            externalContext, this);
+        helper = new PrimaryKeyIndexCreationHelper(origFromClause, origIndexedExpression,
+            projectionAttributes, region.getCache(), externalContext, this);
-        
-        if (indexType == IndexType.HASH ) {
+
+        if (indexType == IndexType.HASH) {
-            throw new UnsupportedOperationException(LocalizedStrings.DefaultQueryService_HASH_INDEX_CREATION_IS_NOT_SUPPORTED_FOR_ASYNC_MAINTENANCE.toLocalizedString());
-          } 
-          throw new UnsupportedOperationException(LocalizedStrings.DefaultQueryService_HASH_INDEX_CREATION_IS_NOT_SUPPORTED_FOR_MULTIPLE_ITERATORS.toLocalizedString());
+            throw new UnsupportedOperationException(
+                LocalizedStrings.DefaultQueryService_HASH_INDEX_CREATION_IS_NOT_SUPPORTED_FOR_ASYNC_MAINTENANCE
+                    .toLocalizedString());
+          }
+          throw new UnsupportedOperationException(
+              LocalizedStrings.DefaultQueryService_HASH_INDEX_CREATION_IS_NOT_SUPPORTED_FOR_MULTIPLE_ITERATORS
+                  .toLocalizedString());
-        if(isOverFlowRegion()) {
-          throw new UnsupportedOperationException(LocalizedStrings.DefaultQueryService_INDEX_CREATION_IS_NOT_SUPPORTED_FOR_REGIONS_WHICH_OVERFLOW_TO_DISK_THE_REGION_INVOLVED_IS_0.toLocalizedString(region.getFullPath()));
+        if (isOverFlowRegion()) {
+          throw new UnsupportedOperationException(
+              LocalizedStrings.DefaultQueryService_INDEX_CREATION_IS_NOT_SUPPORTED_FOR_REGIONS_WHICH_OVERFLOW_TO_DISK_THE_REGION_INVOLVED_IS_0
+                  .toLocalizedString(region.getFullPath()));
-        if(isOffHeap()) {
+        if (isOffHeap()) {
-            throw new UnsupportedOperationException(LocalizedStrings.DefaultQueryService_OFF_HEAP_INDEX_CREATION_IS_NOT_SUPPORTED_FOR_ASYNC_MAINTENANCE_THE_REGION_IS_0.toLocalizedString(region.getFullPath()));
-          } 
-          throw new UnsupportedOperationException(LocalizedStrings.DefaultQueryService_OFF_HEAP_INDEX_CREATION_IS_NOT_SUPPORTED_FOR_MULTIPLE_ITERATORS_THE_REGION_IS_0.toLocalizedString(region.getFullPath()));
+            throw new UnsupportedOperationException(
+                LocalizedStrings.DefaultQueryService_OFF_HEAP_INDEX_CREATION_IS_NOT_SUPPORTED_FOR_ASYNC_MAINTENANCE_THE_REGION_IS_0
+                    .toLocalizedString(region.getFullPath()));
+          }
+          throw new UnsupportedOperationException(
+              LocalizedStrings.DefaultQueryService_OFF_HEAP_INDEX_CREATION_IS_NOT_SUPPORTED_FOR_MULTIPLE_ITERATORS_THE_REGION_IS_0
+                  .toLocalizedString(region.getFullPath()));
-        logger.debug("Started creating index with indexName: {} On region: {}", indexName, region.getFullPath());
+        logger.debug("Started creating index with indexName: {} On region: {}", indexName,
+            region.getFullPath());
-      
+
-        
-        if (((LocalRegion)this.region).isInitialized()) {
+
+        if (((LocalRegion) this.region).isInitialized()) {
-        if (oldIndex == null){
-            // Initialize index.
-            indexFutureTask.run();
-            // Set the index.
-            index = (Index)indexFutureTask.get();
+        if (oldIndex == null) {
+          // Initialize index.
+          indexFutureTask.run();
+          // Set the index.
+          index = (Index) indexFutureTask.get();
-          if (!(oldIndex instanceof Index)){
+          if (!(oldIndex instanceof Index)) {
-            ((FutureTask)oldIndex).get();
+            ((FutureTask) oldIndex).get();
-            throw new IndexNameConflictException(LocalizedStrings.
-                IndexManager_INDEX_NAMED_0_ALREADY_EXISTS.toLocalizedString(indexName));
+            throw new IndexNameConflictException(
+                LocalizedStrings.IndexManager_INDEX_NAMED_0_ALREADY_EXISTS
+                    .toLocalizedString(indexName));
-            throw new IndexExistsException(LocalizedStrings.
-                IndexManager_SIMILAR_INDEX_EXISTS.toLocalizedString());          
+            throw new IndexExistsException(
+                LocalizedStrings.IndexManager_SIMILAR_INDEX_EXISTS.toLocalizedString());
-      } catch (InterruptedException ie){
+      } catch (InterruptedException ie) {
-      } catch (ExecutionException ee){
+      } catch (ExecutionException ee) {
-          throw (IndexNameConflictException)c;
-        } else if (c instanceof IndexExistsException){
-          throw (IndexExistsException)c;
+          throw (IndexNameConflictException) c;
+        } else if (c instanceof IndexExistsException) {
+          throw (IndexExistsException) c;
-        // If the index is not successfully created, remove IndexTask from 
+        // If the index is not successfully created, remove IndexTask from
-        if (oldIndex == null && index == null){
+        if (oldIndex == null && index == null) {
-          if (ind != null && !(ind instanceof Index)){
+          if (ind != null && !(ind instanceof Index)) {
-        if (interrupted){
+        if (interrupted) {
-        logger.debug("Completed creating index with indexName: {} On region: {}", indexName, region.getFullPath());
+        logger.debug("Completed creating index with indexName: {} On region: {}", indexName,
+            region.getFullPath());
-      
+
-        ((TXManagerImpl) this.region.getCache().getCacheTransactionManager())
-        .resume(tx);
+        ((TXManagerImpl) this.region.getCache().getCacheTransactionManager()).resume(tx);
-   * Return true if we should create CompactRangeIndex
-   * Required conditions: indexedExpression is a path expression,
-   * fromClause has only one iterator and it is directly on the
-   * region values.
-   * Currently we have to use the "fat" implementation when asynchronous
-   * index updates are on.
-   */   
+   * Return true if we should create CompactRangeIndex Required conditions: indexedExpression is a
+   * path expression, fromClause has only one iterator and it is directly on the region values.
+   * Currently we have to use the "fat" implementation when asynchronous index updates are on.
+   */
-    if (RANGEINDEX_ONLY || TEST_RANGEINDEX_ONLY){
+    if (RANGEINDEX_ONLY || TEST_RANGEINDEX_ONLY) {
-    
+
-    // asynchronous updates the window between cache operation updating the 
+    // asynchronous updates the window between cache operation updating the
-    } 
-    
+    }
+
-        cv = ((CompiledPath)cv).getReceiver();
+        cv = ((CompiledPath) cv).getReceiver();
-      if (nodeType == OQLLexerTokenTypes.TOK_LBRACK && !helper.isMapTypeIndex() && helper.modifiedIndexExpr instanceof MapIndexable) {
-        if (((MapIndexable)helper.modifiedIndexExpr).getIndexingKeys().size() == 1) {
-          
-        }
-        else {
+      if (nodeType == OQLLexerTokenTypes.TOK_LBRACK && !helper.isMapTypeIndex()
+          && helper.modifiedIndexExpr instanceof MapIndexable) {
+        if (((MapIndexable) helper.modifiedIndexExpr).getIndexingKeys().size() == 1) {
+
+        } else {
-      }
-      else {
+      } else {
-    } 
-    
+    }
+
-    String tailId = ((CompiledPath)missingLink).getTailID();
+    String tailId = ((CompiledPath) missingLink).getTailID();
-    } 
+    }
-    if (ind instanceof Index){
-      return (Index)ind;
+    if (ind instanceof Index) {
+      return (Index) ind;
-   * Get the Index with the specified indexType, fromClause, indexedExpression
-   * TODO: Asif :Check if synchronization is needed while obtaining Array of
-   * Indexes as similar to what we have used during index updates. This function
-   * will get the exact index , if available, else will return null
+   * Get the Index with the specified indexType, fromClause, indexedExpression TODO: Asif :Check if
+   * synchronization is needed while obtaining Array of Indexes as similar to what we have used
+   * during index updates. This function will get the exact index , if available, else will return
+   * null
-   * @param definitions the String array containing the required defintions of the
-   *          fromClause of the index
+   * @param definitions the String array containing the required defintions of the fromClause of the
+   *        index
-   * @return the sole index of the region with these parameters, or null if
-   *         there isn't one
-   * @throws NameResolutionException 
-   * @throws TypeMismatchException 
-   * @throws AmbiguousNameException 
+   * @return the sole index of the region with these parameters, or null if there isn't one
+   * @throws NameResolutionException
+   * @throws TypeMismatchException
+   * @throws AmbiguousNameException
-  public IndexData getIndex(IndexType  indexType, String[] definitions,
-      CompiledValue indexedExpression, ExecutionContext context) 
-  throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+  public IndexData getIndex(IndexType indexType, String[] definitions,
+      CompiledValue indexedExpression, ExecutionContext context)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-      if (!(ind instanceof Index)){
+      if (!(ind instanceof Index)) {
-      Index index = (Index)ind;    
-      if( !((IndexProtocol)ind).isMatchingWithIndexExpression(indexedExpression,
-          indexExprStr, context) || index.getType() != indexType) {
+      Index index = (Index) ind;
+      if (!((IndexProtocol) ind).isMatchingWithIndexExpression(indexedExpression, indexExprStr,
+          context) || index.getType() != indexType) {
-      
-      int matchLevel = getMatchLevel(definitions, 
-          ((IndexProtocol)index).getCanonicalizedIteratorDefinitions(), mapping); 
-        
-      if (matchLevel == 0){
-        indxData = new IndexData((IndexProtocol) index, 0/*Exact Match*/, mapping);
+
+      int matchLevel = getMatchLevel(definitions,
+          ((IndexProtocol) index).getCanonicalizedIteratorDefinitions(), mapping);
+
+      if (matchLevel == 0) {
+        indxData = new IndexData((IndexProtocol) index, 0/* Exact Match */, mapping);
-  
+
-   * Asif : Returns the best available Index based on the available iterators in
-   * the Group
+   * Asif : Returns the best available Index based on the available iterators in the Group
-   * TODO: Asif :Check if synchronization is needed while obtaining Array of
-   * Indexes as similar to what we have used during index updates
+   * TODO: Asif :Check if synchronization is needed while obtaining Array of Indexes as similar to
+   * what we have used during index updates
-   * @param definitions String array containing the canonicalized definitions of
-   *          the Iterators of the Group
-   * @param indexedExpression Index Expression path(CompiledValue) on which
-   *          index needs to be created
+   * @param definitions String array containing the canonicalized definitions of the Iterators of
+   *        the Group
+   * @param indexedExpression Index Expression path(CompiledValue) on which index needs to be
+   *        created
-   * @throws NameResolutionException 
-   * @throws TypeMismatchException 
-   * @throws AmbiguousNameException 
+   * @throws NameResolutionException
+   * @throws TypeMismatchException
+   * @throws AmbiguousNameException
-      CompiledValue indexedExpression, ExecutionContext context) 
-  throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+      CompiledValue indexedExpression, ExecutionContext context)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-      if (ind instanceof FutureTask){
-        continue;
-      }
-      
-      //If the index is still empty
-      if(!((AbstractIndex)ind).isPopulated()) {
+      if (ind instanceof FutureTask) {
-      index = (Index)ind;    
-      
+      // If the index is still empty
+      if (!((AbstractIndex) ind).isPopulated()) {
+        continue;
+      }
+
+      index = (Index) ind;
+
-        prIndex = (PartitionedIndex)index;
+        prIndex = (PartitionedIndex) index;
-      
-      //System.out.println(" Index = "+index);
-      //Use simple strategy just pick first compatible index
-      if ( ((IndexProtocol)index).isMatchingWithIndexExpression(indexedExpression,indexExprStr,
-          context) && index.getType() == indexType ){
-  
+
+      // System.out.println(" Index = "+index);
+      // Use simple strategy just pick first compatible index
+      if (((IndexProtocol) index).isMatchingWithIndexExpression(indexedExpression, indexExprStr,
+          context) && index.getType() == indexType) {
+
-            // Index is not there on all buckets. 
+            // Index is not there on all buckets.
-          if (!((AbstractIndex)index).acquireIndexReadLockForRemove()) {
+          if (!((AbstractIndex) index).acquireIndexReadLockForRemove()) {
-        
+
-         * Asif : A match level of zero means exact match. A match level greater
-         * than 0 means the query from clauses have extra iterators as compared
-         * to Index resultset ( This does not neccessarily mean that Index
-         * resultset is not having extra fields. It is just that the criteria
-         * for match level is the absence or presence of extra iterators. The
-         * order of preference will be 0 , <0 , > 0 for first cut.
+         * Asif : A match level of zero means exact match. A match level greater than 0 means the
+         * query from clauses have extra iterators as compared to Index resultset ( This does not
+         * neccessarily mean that Index resultset is not having extra fields. It is just that the
+         * criteria for match level is the absence or presence of extra iterators. The order of
+         * preference will be 0 , <0 , > 0 for first cut.
-        
+
-        
+
-         if (prIndex != null && prevBestPRIndex != null && prevBestPRIndex instanceof PartitionedIndex) {
+          if (prIndex != null && prevBestPRIndex != null
+              && prevBestPRIndex instanceof PartitionedIndex) {
-          } 
+          }
-        } else if(bestIndex != index) {
-          ((AbstractIndex)index).releaseIndexReadLockForRemove();
+        } else if (bestIndex != index) {
+          ((AbstractIndex) index).releaseIndexReadLockForRemove();
-        // If we chose new index we should release lock on previous  index
+        // If we chose new index we should release lock on previous index
-        logger.debug("The best index found for index expression: {} is: {} with Match-level: {} and mapping: {}", indexExprStr, bestIndex, bestIndexMatchLevel, Arrays.toString(bestMapping));
+        logger.debug(
+            "The best index found for index expression: {} is: {} with Match-level: {} and mapping: {}",
+            indexExprStr, bestIndex, bestIndexMatchLevel, Arrays.toString(bestMapping));
-    return bestIndex != null ? new IndexData((IndexProtocol) bestIndex,
-        bestIndexMatchLevel, bestMapping) : null;
+    return bestIndex != null
+        ? new IndexData((IndexProtocol) bestIndex, bestIndexMatchLevel, bestMapping) : null;
-   * Asif : This function returns the best match index. The crietria used to
-   * identify best match index is based currently , relative to the query from
-   * clause. If the iterators of query from clause exactly match the index from
-   * clause , then match level is zero & is the best match. If the query from
-   * clause contain extra iterators , not available in index from clause, then
-   * mach level is > 0 & is not the best. If the match level is < 0 that means
-   * Index from clause have some extra iterators as compared to query. The int
-   * array gives the mapping of query iterator's position relative to the index
-   * resultset fields . The position is '1' based index. That is for the first
-   * query iterator ( 0 position), the mapping will contain 1 which can be
-   * thought of as Index ResultSet value at the field with name index_iter1. If
-   * the second query iterator has a value 3 , that means for (1 position)
-   * iterator , the field will have name index_iter3
+   * Asif : This function returns the best match index. The crietria used to identify best match
+   * index is based currently , relative to the query from clause. If the iterators of query from
+   * clause exactly match the index from clause , then match level is zero & is the best match. If
+   * the query from clause contain extra iterators , not available in index from clause, then mach
+   * level is > 0 & is not the best. If the match level is < 0 that means Index from clause have
+   * some extra iterators as compared to query. The int array gives the mapping of query iterator's
+   * position relative to the index resultset fields . The position is '1' based index. That is for
+   * the first query iterator ( 0 position), the mapping will contain 1 which can be thought of as
+   * Index ResultSet value at the field with name index_iter1. If the second query iterator has a
+   * value 3 , that means for (1 position) iterator , the field will have name index_iter3
-  private static int getMatchLevel(String[] queryDefintions,
-      String[] indexDefinitions, int[] mapping) {
+  private static int getMatchLevel(String[] queryDefintions, String[] indexDefinitions,
+      int[] mapping) {
-   * private static int getMatchLevel(String fromClause, String iFromClause) {
-   * if (fromClause.equals(iFromClause)) return 0; if
-   * (fromClause.startsWith(iFromClause)) { int cnt = -1; int index =
-   * fromClause.indexOf(',', iFromClause.length() + 1); while (index > 0) {
-   * cnt--; index = fromClause.indexOf(',', index + 1); } return cnt; } else if
-   * (iFromClause.startsWith(fromClause)) { int cnt = 1; int index =
-   * iFromClause.indexOf(',', fromClause.length() + 1); while (index > 0) {
-   * cnt++; index = iFromClause.indexOf(',', index + 1); } return cnt; } //No
-   * compatible return Integer.MAX_VALUE; }
+   * private static int getMatchLevel(String fromClause, String iFromClause) { if
+   * (fromClause.equals(iFromClause)) return 0; if (fromClause.startsWith(iFromClause)) { int cnt =
+   * -1; int index = fromClause.indexOf(',', iFromClause.length() + 1); while (index > 0) { cnt--;
+   * index = fromClause.indexOf(',', index + 1); } return cnt; } else if
+   * (iFromClause.startsWith(fromClause)) { int cnt = 1; int index = iFromClause.indexOf(',',
+   * fromClause.length() + 1); while (index > 0) { cnt++; index = iFromClause.indexOf(',', index +
+   * 1); } return cnt; } //No compatible return Integer.MAX_VALUE; }
-   * Get a collection of all the indexes. If the IndexType is specified
-   * returns only the matching indexes.   
-   * @param indexType the type of indexes to get. Currently must be
-   *          Indexable.FUNCTIONAL_SORTED
+   * Get a collection of all the indexes. If the IndexType is specified returns only the matching
+   * indexes.
+   * 
+   * @param indexType the type of indexes to get. Currently must be Indexable.FUNCTIONAL_SORTED
-      if (ind instanceof FutureTask){
+      if (ind instanceof FutureTask) {
-      Index index = (Index)ind;
+      Index index = (Index) ind;
-      } else if(index.getType() == indexType) {
+      } else if (index.getType() == indexType) {
-  }  
-  
+  }
+
-    if (index.getRegion() != this.region) 
-    { 
-      throw new IllegalArgumentException(LocalizedStrings.
-          IndexManager_INDEX_DOES_NOT_BELONG_TO_THIS_INDEXMANAGER.toLocalizedString()); 
+    if (index.getRegion() != this.region) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.IndexManager_INDEX_DOES_NOT_BELONG_TO_THIS_INDEXMANAGER
+              .toLocalizedString());
-    //Asif: We will just remove the Index from the map. Since the
+    // Asif: We will just remove the Index from the map. Since the
-      Map.Entry entry = (Map.Entry)it.next();
+      Map.Entry entry = (Map.Entry) it.next();
-      if (!(ind instanceof Index)){
+      if (!(ind instanceof Index)) {
-      IndexTask indexTask = (IndexTask)entry.getKey();
+      IndexTask indexTask = (IndexTask) entry.getKey();
-  
+
-   * Asif : This function is invoked during clear operation on Region. It causes
-   * re execution of Index Initialization query on the region & before doing
-   * this it makes theexisting data maps null. This is needed so that index does
-   * not miss any entry being put in the region when the Region.clear is in
-   * progress
+   * Asif : This function is invoked during clear operation on Region. It causes re execution of
+   * Index Initialization query on the region & before doing this it makes theexisting data maps
+   * null. This is needed so that index does not miss any entry being put in the region when the
+   * Region.clear is in progress
-    }
-    catch (Exception e) {
-      //Asif Ignore any exception as this should not hamper normal code flow
+    } catch (Exception e) {
+      // Asif Ignore any exception as this should not hamper normal code flow
-        logger.debug("IndexMananger::rerunIndexCreationQuery: Exception in callback beforeRerunningIndexcreationQuery", e);
+        logger.debug(
+            "IndexMananger::rerunIndexCreationQuery: Exception in callback beforeRerunningIndexcreationQuery",
+            e);
-    }
-    else {
-      //System.out.println("Aynchronous update");
+    } else {
+      // System.out.println("Aynchronous update");
-    if(region.getCache().getLogger().infoEnabled()) {
+    if (region.getCache().getLogger().infoEnabled()) {
-        entry.getValue((LocalRegion)this.region);
+        entry.getValue((LocalRegion) this.region);
-        while(indexSetIterator.hasNext()) {
+        while (indexSetIterator.hasNext()) {
-              logger.debug("Adding to index :{}{} value :{}", index.getName(), this.region.getFullPath(), entry.getKey());
+              logger.debug("Adding to index :{}{} value :{}", index.getName(),
+                  this.region.getFullPath(), entry.getKey());
-              if(logger.isDebugEnabled()) {
-                logger.debug("Adding to index failed for: {}, {}", index.getName(), e.getMessage(), e);
+              if (logger.isDebugEnabled()) {
+                logger.debug("Adding to index failed for: {}, {}", index.getName(), e.getMessage(),
+                    e);
-  
+
-   * Sets the {@link AbstractIndex#isPopulated} after 
-   * populating all the indexes in this region
+   * Sets the {@link AbstractIndex#isPopulated} after populating all the indexes in this region
-  
+
-   * @param action action to be taken (IndexManager.ADD_ENTRY,
-   *          IndexManager.UPDATE_ENTRY, IndexManager.REMOVE_ENTRY)
+   * @param action action to be taken (IndexManager.ADD_ENTRY, IndexManager.UPDATE_ENTRY,
+   *        IndexManager.REMOVE_ENTRY)
-  public void updateIndexes(RegionEntry entry, int action, int opCode, boolean isDiskRecoveryInProgress)
-      throws QueryException {
-    if(isDiskRecoveryInProgress) {
-      assert !((LocalRegion)this.region).isInitialized();
+  public void updateIndexes(RegionEntry entry, int action, int opCode,
+      boolean isDiskRecoveryInProgress) throws QueryException {
+    if (isDiskRecoveryInProgress) {
+      assert !((LocalRegion) this.region).isInitialized();
-      assert Assert.assertHoldsLock(entry,true);  
+      assert Assert.assertHoldsLock(entry, true);
-    if(logger.isDebugEnabled()) {
+    if (logger.isDebugEnabled()) {
-    if (entry == null) return;
+    if (entry == null)
+      return;
-      //System.out.println("Synchronous update");
+      // System.out.println("Synchronous update");
-    }
-    else {
-      //System.out.println("Aynchronous update");
+    } else {
+      // System.out.println("Aynchronous update");
-  private void processAction(RegionEntry entry, int action, int opCode)
-      throws QueryException {
+  private void processAction(RegionEntry entry, int action, int opCode) throws QueryException {
-    if (!((GemFireCacheImpl)this.region.getCache()).isClient()) {
+    if (!((GemFireCacheImpl) this.region.getCache()).isClient()) {
-      //Asif: Allow the thread to update iff there is no current index
-      //creator thread in progress. There will not be any issue if
+      // Asif: Allow the thread to update iff there is no current index
+      // creator thread in progress. There will not be any issue if
-      //creator thread in waiting , but that can cause starvation
-      //for index creator thread. So we will give priorityto index
-      //creation thread
+      // creator thread in waiting , but that can cause starvation
+      // for index creator thread. So we will give priorityto index
+      // creation thread
-        testHook.hook(6); //ConcurrentIndexInitOnOverflowRegionDUnitTest
+        testHook.hook(6); // ConcurrentIndexInitOnOverflowRegionDUnitTest
-      
+
-          
-          //Asif The behaviour can arise if an index creation has already
+
+          // Asif The behaviour can arise if an index creation has already
-            if (ind instanceof FutureTask){
+            if (ind instanceof FutureTask) {
-            IndexProtocol index = (IndexProtocol)ind;            
-            
+            IndexProtocol index = (IndexProtocol) ind;
+
-                  logger.debug("Adding to index: {}{} value: {}", index.getName(), this.region.getFullPath(), entry.getKey());
+                  logger.debug("Adding to index: {}{} value: {}", index.getName(),
+                      this.region.getFullPath(), entry.getKey());
-            testHook.hook(9); //QueryDataInconsistencyDUnitTest
+            testHook.hook(9); // QueryDataInconsistencyDUnitTest
-            if (ind instanceof FutureTask){
+            if (ind instanceof FutureTask) {
-            IndexProtocol index = (IndexProtocol)ind;
-            
+            IndexProtocol index = (IndexProtocol) ind;
+
-                if (logger.isDebugEnabled()) {
-                  logger.debug("Updating index: {}{} value: ", index.getName(), this.region.getFullPath(), entry.getKey());
-                }
-                start = ((AbstractIndex) index).updateIndexUpdateStats();
+              if (logger.isDebugEnabled()) {
+                logger.debug("Updating index: {}{} value: ", index.getName(),
+                    this.region.getFullPath(), entry.getKey());
+              }
+              start = ((AbstractIndex) index).updateIndexUpdateStats();
-                index.addIndexMapping(entry);
+              index.addIndexMapping(entry);
-                ((AbstractIndex) index).updateIndexUpdateStats(start);
+              ((AbstractIndex) index).updateIndexUpdateStats(start);
-          
+
-  
+
-                logger.debug("Removing from index: {}{} value: {}", index.getName(), this.region.getFullPath(), entry.getKey());
+                logger.debug("Removing from index: {}{} value: {}", index.getName(),
+                    this.region.getFullPath(), entry.getKey());
-              
+
-          throw new IndexMaintenanceException(LocalizedStrings.IndexManager_INVALID_ACTION.toLocalizedString());
+          throw new IndexMaintenanceException(
+              LocalizedStrings.IndexManager_INVALID_ACTION.toLocalizedString());
-    }
-    finally {
+    } finally {
-        ((TXManagerImpl) this.region.getCache().getCacheTransactionManager())
-          .resume(tx);
+        ((TXManagerImpl) this.region.getCache().getCacheTransactionManager()).resume(tx);
-        ((LocalRegion) getRegion()).getCancelCriterion()
-            .checkCancelInProgress(null);
+        ((LocalRegion) getRegion()).getCancelCriterion().checkCancelInProgress(null);
-  
+
-  
+
-   * Recreates all indexes for this region. This operation blocks all updates
-   * on all indexes while recreate is in progress. This is required as recreate
-   * does NOT lock region entries before index update and hence might cause
-   * inconsistencies in index if concurrent region entry operations are
+   * Recreates all indexes for this region. This operation blocks all updates on all indexes while
+   * recreate is in progress. This is required as recreate does NOT lock region entries before index
+   * update and hence might cause inconsistencies in index if concurrent region entry operations are
-   *  
+   * 
-   * Wait for index initialization before entry create, update, invalidate or destroy
-   * operation.
+   * Wait for index initialization before entry create, update, invalidate or destroy operation.
-   * Note: If the region has a disk region then we should wait for index
-   * initialization before getting region entry lock to avoid deadlock (#44431).
+   * Note: If the region has a disk region then we should wait for index initialization before
+   * getting region entry lock to avoid deadlock (#44431).
-        ((LocalRegion)this.getRegion()).getCancelCriterion().checkCancelInProgress(null);
+        ((LocalRegion) this.getRegion()).getCancelCriterion().checkCancelInProgress(null);
-        }
-        catch (InterruptedException ie) {
+        } catch (InterruptedException ie) {
-        }
-        finally {
+        } finally {
-       --this.numUpdatersInProgress;
-      //Asif: Since Index creator threads can progress only if
+      --this.numUpdatersInProgress;
+      // Asif: Since Index creator threads can progress only if
-    return ((LocalRegion)this.region).getCachePerfStats();
+    return ((LocalRegion) this.region).getCachePerfStats();
+
-    if (!isIndexMaintenanceTypeSynchronous()) updater.shutdown();
+    if (!isIndexMaintenanceTypeSynchronous())
+      updater.shutdown();
-  
+
-   * Removes indexes for a destroyed bucket region from the list of bucket indexes 
-   * in the {@link PartitionedIndex}.
+   * Removes indexes for a destroyed bucket region from the list of bucket indexes in the
+   * {@link PartitionedIndex}.
+   * 
-        Index bucketIndex = (Index)bucketIndexIterator.next();
+        Index bucketIndex = (Index) bucketIndexIterator.next();
-          ((PartitionedIndex)prIndex).removeFromBucketIndexes(this.region, bucketIndex);
+          ((PartitionedIndex) prIndex).removeFromBucketIndexes(this.region, bucketIndex);
-      if (ind instanceof FutureTask){
+      if (ind instanceof FutureTask) {
-      sb.append(((Index)ind).toString()).append('\n');    
+      sb.append(((Index) ind).toString()).append('\n');
+
+
-   * Asif : This function is used exclusively by Index Manager. It gets the
-   * unique Iterator name for a Iterator definition, if it already exists, else
-   * creates a unqiue name & also stores it in a map for subsequent use
+   * Asif : This function is used exclusively by Index Manager. It gets the unique Iterator name for
+   * a Iterator definition, if it already exists, else creates a unqiue name & also stores it in a
+   * map for subsequent use
-    synchronized(canonicalizedIteratorNameMap) {
+    synchronized (canonicalizedIteratorNameMap) {
-        str = new StringBuffer("index_iter").append(this.getIncrementedCounter())
-            .toString();
+        str = new StringBuffer("index_iter").append(this.getIncrementedCounter()).toString();
-        if ((temp = (String) this.canonicalizedIteratorNameMap.putIfAbsent(
-            definition, str)) != null) {
+        if ((temp =
+            (String) this.canonicalizedIteratorNameMap.putIfAbsent(definition, str)) != null) {
-    synchronized(canonicalizedIteratorNameMap) {
+    synchronized (canonicalizedIteratorNameMap) {
-  
+
-   * Asif : Given a definition returns the canonicalized iterator name for the
-   * definition. If the definition does not exist , null is returned
+   * Asif : Given a definition returns the canonicalized iterator name for the definition. If the
+   * definition does not exist , null is returned
- 
-  public class IndexUpdaterThread extends Thread  {
+
+  public class IndexUpdaterThread extends Thread {
+     * 
-      if (updateThreshold > 0){
+      if (updateThreshold > 0) {
-      task[2] = Integer.valueOf(opCode);  // !!!:ezoerner:20081029 change to valueOf jdk 1.5+
+      task[2] = Integer.valueOf(opCode); // !!!:ezoerner:20081029 change to valueOf jdk 1.5+
-      org.apache.geode.CancelCriterion stopper = ((LocalRegion)region).getCancelCriterion();
+      org.apache.geode.CancelCriterion stopper = ((LocalRegion) region).getCancelCriterion();
-            Object[] task = (Object[])pendingTasks.take();
+            Object[] task = (Object[]) pendingTasks.take();
-          }
-          catch (InterruptedException ignore) {
+          } catch (InterruptedException ignore) {
-      }
-      finally {
+      } finally {
-      int action = ((Integer)task[0]).intValue();
-      RegionEntry entry = (RegionEntry)task[1];
-      int opCode = ((Integer)task[2]).intValue();
-      //System.out.println("entry = "+entry.getKey());
+      int action = ((Integer) task[0]).intValue();
+      RegionEntry entry = (RegionEntry) task[1];
+      int opCode = ((Integer) task[2]).intValue();
+      // System.out.println("entry = "+entry.getKey());
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
-     * Used by tests to determine if the updater thread has finished updating
-     * its indexes. The list is cleared without synchronization, which makes
-     * this methods somewhat unsafe from a threading point of view.
+     * Used by tests to determine if the updater thread has finished updating its indexes. The list
+     * is cleared without synchronization, which makes this methods somewhat unsafe from a threading
+     * point of view.
-  
+
-   * Index Task used to create the index. This is used along with the
-   * FutureTask to take care of, same index creation request from multiple
-   * threads. At any time only one thread succeeds and other threads waits
-   * for the completion of the index creation. This avoids usage of
+   * Index Task used to create the index. This is used along with the FutureTask to take care of,
+   * same index creation request from multiple threads. At any time only one thread succeeds and
+   * other threads waits for the completion of the index creation. This avoids usage of
-    public String  origIndexedExpression;
+    public String origIndexedExpression;
-    
+
-    
+
-    
+
-    
-    IndexTask (String indexName, IndexType type, String origFromClause, String origIndexedExpression, IndexCreationHelper helper, boolean isCompactOrHash, PartitionedIndex prIndex, boolean loadEntries){
+
+    IndexTask(String indexName, IndexType type, String origFromClause, String origIndexedExpression,
+        IndexCreationHelper helper, boolean isCompactOrHash, PartitionedIndex prIndex,
+        boolean loadEntries) {
-    IndexTask (String indexName){
+    IndexTask(String indexName) {
-    public boolean equals (Object other){
+    public boolean equals(Object other) {
-      if (this.indexName.equals(otherIndexTask.indexName)){
+      if (this.indexName.equals(otherIndexTask.indexName)) {
-      if(compareIndexData(this.indexType, indexDefinitions,
+      if (compareIndexData(this.indexType, indexDefinitions,
-          otherIndexTask.helper.getCanonicalizedIndexedExpression(), mapping) == 0)
-      {
+          otherIndexTask.helper.getCanonicalizedIndexedExpression(), mapping) == 0) {
-    public int hashCode(){
+    public int hashCode() {
-      IndexStatistics stats = null;    
+      IndexStatistics stats = null;
-        index = new PrimaryKeyIndex(indexName, region, fromClause,indexedExpression,
-             projectionAttributes, origFromClause,
-            origIndexedExpression, definitions, stats);
-        logger.info("Using Primary Key index implementation for '{}' on region {}", indexName, region.getFullPath());
-      } else if (indexType == IndexType.HASH){
-        index = new HashIndex(indexName, region, fromClause,
-            indexedExpression,  projectionAttributes, origFromClause,
-            origIndexedExpression, definitions, stats);
-        
-        logger.info("Using Hash index implementation for '{}' on region {}", indexName, region.getFullPath());
-      }
-      else {
-        //boolean isCompact = !helper.isMapTypeIndex() && shouldCreateCompactIndex((FunctionalIndexCreationHelper)helper);
+        index = new PrimaryKeyIndex(indexName, region, fromClause, indexedExpression,
+            projectionAttributes, origFromClause, origIndexedExpression, definitions, stats);
+        logger.info("Using Primary Key index implementation for '{}' on region {}", indexName,
+            region.getFullPath());
+      } else if (indexType == IndexType.HASH) {
+        index = new HashIndex(indexName, region, fromClause, indexedExpression,
+            projectionAttributes, origFromClause, origIndexedExpression, definitions, stats);
+
+        logger.info("Using Hash index implementation for '{}' on region {}", indexName,
+            region.getFullPath());
+      } else {
+        // boolean isCompact = !helper.isMapTypeIndex() &&
+        // shouldCreateCompactIndex((FunctionalIndexCreationHelper)helper);
-            index = new CompactRangeIndex(indexName, region, fromClause,
-                indexedExpression,  projectionAttributes, origFromClause,
-                origIndexedExpression, definitions, stats);
-            logger.info("Using Compact Range index implementation for '{}' on region {}", indexName, region.getFullPath());       
-          }
-          else {
-            FunctionalIndexCreationHelper fich = (FunctionalIndexCreationHelper)helper;            
+            index = new CompactRangeIndex(indexName, region, fromClause, indexedExpression,
+                projectionAttributes, origFromClause, origIndexedExpression, definitions, stats);
+            logger.info("Using Compact Range index implementation for '{}' on region {}", indexName,
+                region.getFullPath());
+          } else {
+            FunctionalIndexCreationHelper fich = (FunctionalIndexCreationHelper) helper;
-                projectionAttributes, origFromClause,
-               origIndexedExpression, definitions, fich.isAllKeys(), fich.multiIndexKeysPattern,
-               fich.mapKeys, stats);
-            logger.info("Using Compact Map Range index implementation for '{}' on region {}", indexName, region.getFullPath());   
+                projectionAttributes, origFromClause, origIndexedExpression, definitions,
+                fich.isAllKeys(), fich.multiIndexKeysPattern, fich.mapKeys, stats);
+            logger.info("Using Compact Map Range index implementation for '{}' on region {}",
+                indexName, region.getFullPath());
-        }
-        else {
+        } else {
-          if ( !helper.isMapTypeIndex() ) {
-            index = new RangeIndex(indexName, region, fromClause, 
-                indexedExpression,   projectionAttributes, origFromClause,
-                origIndexedExpression, definitions, stats);
-            logger.info("Using Non-Compact index implementation for '{}' on region {}", indexName, region.getFullPath());   
-          }
-          else {
-            FunctionalIndexCreationHelper fich = (FunctionalIndexCreationHelper)helper;            
+          if (!helper.isMapTypeIndex()) {
+            index = new RangeIndex(indexName, region, fromClause, indexedExpression,
+                projectionAttributes, origFromClause, origIndexedExpression, definitions, stats);
+            logger.info("Using Non-Compact index implementation for '{}' on region {}", indexName,
+                region.getFullPath());
+          } else {
+            FunctionalIndexCreationHelper fich = (FunctionalIndexCreationHelper) helper;
-                 projectionAttributes, origFromClause,
-                origIndexedExpression, definitions, fich.isAllKeys(), fich.multiIndexKeysPattern,
-                fich.mapKeys, stats);
-            logger.info("Using Non-Compact Map index implementation for '{}' on region {}", indexName, region.getFullPath());
+                projectionAttributes, origFromClause, origIndexedExpression, definitions,
+                fich.isAllKeys(), fich.multiIndexKeysPattern, fich.mapKeys, stats);
+            logger.info("Using Non-Compact Map index implementation for '{}' on region {}",
+                indexName, region.getFullPath());
-      ((AbstractIndex)index).setPRIndex(prIndex);
-     
+      ((AbstractIndex) index).setPRIndex(prIndex);
+
-          ((LocalRegion)region).setFlagForIndexCreationThread(true);
+          ((LocalRegion) region).setFlagForIndexCreationThread(true);
-                        : "Initialized but entries not yet loaded into the index "
-                            + indexName + " on region: " + region.getFullPath()));
+              : "Initialized but entries not yet loaded into the index " + indexName
+                  + " on region: " + region.getFullPath()));
-          if(loadEntries) {
+          if (loadEntries) {
-              ((AbstractIndex)this.prIndex).setPopulated(true);
+              ((AbstractIndex) this.prIndex).setPopulated(true);
-        }
-        finally {
+        } finally {
-          ((LocalRegion)region).setFlagForIndexCreationThread(false);
-          if (!indexCreatedSuccessfully){
-            ((InternalIndexStatistics)index.getStatistics()).close();
+          ((LocalRegion) region).setFlagForIndexCreationThread(false);
+          if (!indexCreatedSuccessfully) {
+            ((InternalIndexStatistics) index.getStatistics()).close();
-        ((AbstractIndex)index).setPopulated(true);
+        ((AbstractIndex) index).setPopulated(true);
-          ((AbstractIndex)this.prIndex).setPopulated(true);
+          ((AbstractIndex) this.prIndex).setPopulated(true);
-  }   
+  }

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
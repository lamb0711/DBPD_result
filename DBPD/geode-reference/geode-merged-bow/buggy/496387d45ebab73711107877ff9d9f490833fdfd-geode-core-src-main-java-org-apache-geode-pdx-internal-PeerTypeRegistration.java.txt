GEODE-7035 - Updated Enums in PeerTypeRegistration, refactored LocalReverseMap

Brought Enum behaviour in line with PdxType behaviour in
PeerTypeRegistration
Refactored ReverseMap to not be an internal class of
PeerTypeRegistration
Added unit tests for PeerTypeRegistration and
PeerTypeRegistrationReverseMap

Authored-by: Donal Evans <doevans@pivotal.io>

+  private static final String LOCK_NAME = "PDX_LOCK";
-  private LocalReverseMap localReverseMap = new LocalReverseMap();
+  private PeerTypeRegistrationReverseMap reverseMap = new PeerTypeRegistrationReverseMap();
-    AttributesFactory<Object, Object> factory = new AttributesFactory<>();
+    AttributesFactory<Object, Object> factory = getAttributesFactory();
+
-        // update a local map with the pdxtypes registered
+        // update the local map and reverse map with the pdxtypes registered
-          updateLocalMaps(key, value);
+          updateLocalAndReverseMaps(key, value);
-    buildTypeToIdFromIdToType();
+    buildReverseMapsFromRegion();
-  private static final String LOCK_NAME = "PDX_LOCK";
-
-    Integer existingId = localReverseMap.checkIfExistsInLocal(newType);
+    Integer existingId = reverseMap.getIdFromReverseMap(newType);
-      if (localReverseMap.shouldReloadFromRegion()) {
-        buildTypeToIdFromIdToType();
+      if (reverseMap.shouldReloadFromRegion(getIdToType())) {
+        buildReverseMapsFromRegion();
-      localReverseMap.flushLocalMap();
-      // double check if my type is in region in case the typeToId map has been updated while
-      // waiting to obtain a lock
-      existingId = localReverseMap.checkIfExistsInLocal(newType);
+      reverseMap.flushPendingReverseMap();
+
+      // double check if my PdxType is in the reverse map in case it was just flushed into it
+      existingId = reverseMap.getIdFromReverseMap(newType);
-
+
-      localReverseMap.flushLocalMap();
+      // flush the reverse map for the member that introduced this new PdxType
+      reverseMap.flushPendingReverseMap();
-  private void buildTypeToIdFromIdToType() {
+  /**
+   * Should only be called holding the dlock
+   * This method iterates through the entire PdxTypes region and syncs the reverse map with the pdx
+   * region This is an expensive operation and should only be called during initialization. A cache
+   * listener is used to keep the reverse maps up to date.
+   */
+  void buildReverseMapsFromRegion() {
+    int totalEnumIdInDS = 0;
+      reverseMap.clear();
-        Object v = entry.getValue();
-        if (v instanceof PdxType) {
-          PdxType foundType = (PdxType) v;
+        Object v = entry.getValue();
+        if (k instanceof EnumId) {
+          EnumId id = (EnumId) k;
+          int tmpDsId = PLACE_HOLDER_FOR_DS_ID & id.intValue();
+          if (tmpDsId == typeIdPrefix) {
+            totalEnumIdInDS++;
+            if (totalEnumIdInDS >= MAX_TYPE_ID) {
+              throw new InternalGemFireError(
+                  "Used up all of the PDX enum ids for this distributed system. The maximum number of PDX types is "
+                      + MAX_TYPE_ID);
+            }
+          }
+        } else {
-        localReverseMap.save(k, v, false);
+        reverseMap.save(k, v);
-  /** Should be called holding the dlock */
-  private EnumId getExistingIdForEnum(EnumInfo ei) {
-    TXStateProxy currentState = suspendTX();
-    int totalEnumIdInDS = 0;
-    try {
-      EnumId result = null;
-      for (Map.Entry<Object, Object> entry : getIdToType().entrySet()) {
-        Object v = entry.getValue();
-        Object k = entry.getKey();
-        if (k instanceof EnumId) {
-          EnumId id = (EnumId) k;
-          EnumInfo info = (EnumInfo) v;
-          int tmpDsId = PLACE_HOLDER_FOR_DS_ID & id.intValue();
-          if (tmpDsId == typeIdPrefix) {
-            totalEnumIdInDS++;
-          }
-          if (ei.equals(info)) {
-            result = id;
-          }
-        }
-        localReverseMap.save(k, v, false);
-      }
-
-      if (totalEnumIdInDS == MAX_TYPE_ID) {
-        throw new InternalGemFireError(
-            "Used up all of the PDX enum ids for this distributed system. The maximum number of PDX types is "
-                + MAX_TYPE_ID);
-      }
-      return result;
-    } finally {
-      resumeTX(currentState);
-    }
-  }
-
-    final EnumId existingId = localReverseMap.checkIfExistsInLocal(newInfo);
+    EnumId existingId = reverseMap.getIdFromReverseMap(newInfo);
-      localReverseMap.flushLocalMap();
-      EnumId id = getExistingIdForEnum(newInfo);
-      if (id != null) {
-        return id.intValue();
+      if (reverseMap.shouldReloadFromRegion(getIdToType())) {
+        buildReverseMapsFromRegion();
+      }
+      reverseMap.flushPendingReverseMap();
+
+      // double check if my Enum is in the reverse map in case it was just flushed into it
+      existingId = reverseMap.getIdFromReverseMap(newInfo);
+      if (existingId != null) {
+        return existingId.intValue();
-      id = allocateEnumId(newInfo);
-
+      EnumId id = allocateEnumId(newInfo);
-      localReverseMap.save(id, newInfo, false);
-
-      localReverseMap.flushLocalMap();
+      // flush the reverse map for the member that introduced this new enumInfo
+      reverseMap.flushPendingReverseMap();
-  private void updateLocalMaps(Object key, Object value) {
-    localReverseMap.save(key, value, true);
+  private void updateLocalAndReverseMaps(Object key, Object value) {
+    reverseMap.saveToPending(key, value);
+  @SuppressWarnings("deprecation")
+  protected AttributesFactory<Object, Object> getAttributesFactory() {
+    return new AttributesFactory<>();
+  }
+
+  @VisibleForTesting
-    return localReverseMap.typeToIdSize();
+    return reverseMap.typeToIdSize();
-    return localReverseMap.enumToIdSize();
-  }
-
-  class LocalReverseMap {
-    /**
-     * When a new pdxType or a new enumInfo is added to idToType region, its
-     * listener will add the new type to the pendingTypeToId first, to make sure
-     * the distribution finished.
-     * Then any member who wants to use this new pdxType has to get the dlock to
-     * flush the pendingTypeToId map into typeToId. This design to guarantee that
-     * when using the new pdxType, it should have been distributed to all members.
-     */
-    private final Map<PdxType, Integer> pendingTypeToId =
-        Collections.synchronizedMap(new HashMap<>());
-    private final Map<EnumInfo, EnumId> pendingEnumToId =
-        Collections.synchronizedMap(new HashMap<>());
-
-    /**
-     * This map serves two purposes. It lets us look up an id based on a type, if we previously
-     * found
-     * that type in the region. And, if a type is present in this map, that means we read the type
-     * while holding the dlock, which means the type was distributed to all members.
-     */
-    private final Map<PdxType, Integer> typeToId = Collections.synchronizedMap(new HashMap<>());
-
-    private final Map<EnumInfo, EnumId> enumToId = Collections.synchronizedMap(new HashMap<>());
-
-    void save(Object key, Object value, boolean isPending) {
-      if (value instanceof PdxType) {
-        PdxType type = (PdxType) value;
-        if (isPending) {
-          pendingTypeToId.put(type, (Integer) key);
-        } else {
-          typeToId.put(type, (Integer) key);
-        }
-      } else if (value instanceof EnumInfo) {
-        EnumInfo info = (EnumInfo) value;
-        if (isPending) {
-          pendingEnumToId.put(info, (EnumId) key);
-        } else {
-          enumToId.put(info, (EnumId) key);
-        }
-      }
-    }
-
-    int typeToIdSize() {
-      return typeToId.size();
-    }
-
-    int enumToIdSize() {
-      return enumToId.size();
-    }
-
-    Integer checkIfExistsInLocal(PdxType newType) {
-      return typeToId.get(newType);
-    }
-
-    EnumId checkIfExistsInLocal(EnumInfo newInfo) {
-      return enumToId.get(newInfo);
-    }
-
-    // The local maps should be loaded from the region if there is a mismatch in size between the
-    // region and all local maps
-    boolean shouldReloadFromRegion() {
-      return ((typeToId.size() + pendingTypeToId.size() + enumToId.size()
-          + pendingEnumToId.size()) != getIdToType().size());
-    }
-
-    void flushLocalMap() {
-      if (!pendingTypeToId.isEmpty()) {
-        typeToId.putAll(pendingTypeToId);
-        pendingTypeToId.clear();
-      }
-      if (!pendingEnumToId.isEmpty()) {
-        enumToId.putAll(pendingEnumToId);
-        pendingEnumToId.clear();
-      }
-    }
+    return reverseMap.enumToIdSize();

MOV23 INS31 UPD43 INS29 UPD42 UPD42 INS78 MOV79 UPD83 MOV74 UPD42 UPD42 MOV78 INS83 MOV39 UPD42 MOV42 MOV8 UPD42 UPD42 INS65 MOV60 INS42 UPD43 INS79 INS74 INS66 INS66 INS66 INS66 MOV43 MOV14 UPD42 INS42 INS45 INS43 INS43 INS43 INS32 UPD42 INS21 INS25 INS21 INS60 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS32 MOV60 UPD42 UPD42 MOV32 MOV32 INS8 INS7 MOV43 INS59 UPD42 INS32 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS42 UPD42 INS21 UPD42 UPD42 INS42 INS32 UPD42 INS42 MOV32 UPD42 UPD42 INS42 UPD42 UPD42 INS8 INS32 INS42 UPD42 MOV42 MOV42 UPD42 MOV42 UPD43 MOV60 MOV60 INS25 UPD42 INS42 UPD42 MOV42 MOV27 INS8 MOV21 INS25 INS27 MOV8 UPD42 INS42 INS42 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL9 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL59 DEL60 DEL40 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL70 DEL42 DEL42 DEL27 DEL25 DEL42 DEL41 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL21 DEL9 DEL39 DEL42 DEL42 DEL32 DEL42 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL43 DEL74 DEL14 DEL32 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL43 DEL74 DEL14 DEL32 DEL59 DEL23 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL43 DEL74 DEL14 DEL32 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL43 DEL74 DEL14 DEL32 DEL59 DEL23 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL25 DEL8 DEL31 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL39 DEL31 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL36 DEL27 DEL36 DEL41 DEL8 DEL31 DEL39 DEL42 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL55
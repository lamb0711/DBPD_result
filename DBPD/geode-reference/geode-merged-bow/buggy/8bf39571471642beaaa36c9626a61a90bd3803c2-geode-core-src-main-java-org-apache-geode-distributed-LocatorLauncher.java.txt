Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-@SuppressWarnings({ "unused" })
+@SuppressWarnings({"unused"})
-   * @deprecated This is specific to the internal implementation and may go away in a future release.
+   * @deprecated This is specific to the internal implementation and may go away in a future
+   *             release.
-    helpMap.put("launcher", LocalizedStrings.LocatorLauncher_LOCATOR_LAUNCHER_HELP.toLocalizedString());
-    helpMap.put(Command.START.getName(), LocalizedStrings.LocatorLauncher_START_LOCATOR_HELP.toLocalizedString(String.valueOf(
-      getDefaultLocatorPort())));
-    helpMap.put(Command.STATUS.getName(), LocalizedStrings.LocatorLauncher_STATUS_LOCATOR_HELP.toLocalizedString());
-    helpMap.put(Command.STOP.getName(),LocalizedStrings.LocatorLauncher_STOP_LOCATOR_HELP.toLocalizedString());
-    helpMap.put(Command.VERSION.getName(), LocalizedStrings.LocatorLauncher_VERSION_LOCATOR_HELP.toLocalizedString());
-    helpMap.put("bind-address", LocalizedStrings.LocatorLauncher_LOCATOR_BIND_ADDRESS_HELP.toLocalizedString());
-    helpMap.put("debug",LocalizedStrings.LocatorLauncher_LOCATOR_DEBUG_HELP.toLocalizedString());
-    helpMap.put("dir",LocalizedStrings.LocatorLauncher_LOCATOR_DIR_HELP.toLocalizedString());
+    helpMap.put("launcher",
+        LocalizedStrings.LocatorLauncher_LOCATOR_LAUNCHER_HELP.toLocalizedString());
+    helpMap.put(Command.START.getName(), LocalizedStrings.LocatorLauncher_START_LOCATOR_HELP
+        .toLocalizedString(String.valueOf(getDefaultLocatorPort())));
+    helpMap.put(Command.STATUS.getName(),
+        LocalizedStrings.LocatorLauncher_STATUS_LOCATOR_HELP.toLocalizedString());
+    helpMap.put(Command.STOP.getName(),
+        LocalizedStrings.LocatorLauncher_STOP_LOCATOR_HELP.toLocalizedString());
+    helpMap.put(Command.VERSION.getName(),
+        LocalizedStrings.LocatorLauncher_VERSION_LOCATOR_HELP.toLocalizedString());
+    helpMap.put("bind-address",
+        LocalizedStrings.LocatorLauncher_LOCATOR_BIND_ADDRESS_HELP.toLocalizedString());
+    helpMap.put("debug", LocalizedStrings.LocatorLauncher_LOCATOR_DEBUG_HELP.toLocalizedString());
+    helpMap.put("dir", LocalizedStrings.LocatorLauncher_LOCATOR_DIR_HELP.toLocalizedString());
-    helpMap.put("help", LocalizedStrings.SystemAdmin_CAUSES_GEMFIRE_TO_PRINT_OUT_INFORMATION_INSTEAD_OF_PERFORMING_THE_COMMAND_THIS_OPTION_IS_SUPPORTED_BY_ALL_COMMANDS.toLocalizedString());
-    helpMap.put("hostname-for-clients", LocalizedStrings.LocatorLauncher_LOCATOR_HOSTNAME_FOR_CLIENTS_HELP.toLocalizedString());
+    helpMap.put("help",
+        LocalizedStrings.SystemAdmin_CAUSES_GEMFIRE_TO_PRINT_OUT_INFORMATION_INSTEAD_OF_PERFORMING_THE_COMMAND_THIS_OPTION_IS_SUPPORTED_BY_ALL_COMMANDS
+            .toLocalizedString());
+    helpMap.put("hostname-for-clients",
+        LocalizedStrings.LocatorLauncher_LOCATOR_HOSTNAME_FOR_CLIENTS_HELP.toLocalizedString());
-    helpMap.put("port", LocalizedStrings.LocatorLauncher_LOCATOR_PORT_HELP.toLocalizedString(String.valueOf(
-      getDefaultLocatorPort())));
-    helpMap.put("redirect-output", LocalizedStrings.LocatorLauncher_LOCATOR_REDIRECT_OUTPUT_HELP.toLocalizedString());
+    helpMap.put("port", LocalizedStrings.LocatorLauncher_LOCATOR_PORT_HELP
+        .toLocalizedString(String.valueOf(getDefaultLocatorPort())));
+    helpMap.put("redirect-output",
+        LocalizedStrings.LocatorLauncher_LOCATOR_REDIRECT_OUTPUT_HELP.toLocalizedString());
-    usageMap.put(Command.START, "start <member-name> [--bind-address=<IP-address>] [--hostname-for-clients=<IP-address>] [--port=<port>] [--dir=<Locator-working-directory>] [--force] [--debug] [--help]");
-    usageMap.put(Command.STATUS, "status [--bind-address=<IP-address>] [--port=<port>] [--member=<member-ID/Name>] [--pid=<process-ID>] [--dir=<Locator-working-directory>] [--debug] [--help]");
-    usageMap.put(Command.STOP, "stop [--member=<member-ID/Name>] [--pid=<process-ID>] [--dir=<Locator-working-directory>] [--debug] [--help]");
+    usageMap.put(Command.START,
+        "start <member-name> [--bind-address=<IP-address>] [--hostname-for-clients=<IP-address>] [--port=<port>] [--dir=<Locator-working-directory>] [--force] [--debug] [--help]");
+    usageMap.put(Command.STATUS,
+        "status [--bind-address=<IP-address>] [--port=<port>] [--member=<member-ID/Name>] [--pid=<process-ID>] [--dir=<Locator-working-directory>] [--debug] [--help]");
+    usageMap.put(Command.STOP,
+        "stop [--member=<member-ID/Name>] [--pid=<process-ID>] [--dir=<Locator-working-directory>] [--debug] [--help]");
-   * @deprecated This is specific to the internal implementation and may go away in a future release.
+   * @deprecated This is specific to the internal implementation and may go away in a future
+   *             release.
-  
+
-   * @deprecated This is specific to the internal implementation and may go away in a future release.
+   * @deprecated This is specific to the internal implementation and may go away in a future
+   *             release.
-  
+
-   * @deprecated This is specific to the internal implementation and may go away in a future release.
+   * @deprecated This is specific to the internal implementation and may go away in a future
+   *             release.
-  //private volatile transient boolean debug;
+  // private volatile transient boolean debug;
-  
+
-  
+
-  
+
-  
+
-    }
-    catch (AttachAPINotFoundException e) {
+    } catch (AttachAPINotFoundException e) {
-      DistributionLocator.DEFAULT_LOCATOR_PORT);
+        DistributionLocator.DEFAULT_LOCATOR_PORT);
-   * Gets the instance of the LocatorLauncher used to launch the GemFire Locator, or null if this VM does not
-   * have an instance of LocatorLauncher indicating no GemFire Locator is running.
+   * Gets the instance of the LocatorLauncher used to launch the GemFire Locator, or null if this VM
+   * does not have an instance of LocatorLauncher indicating no GemFire Locator is running.
-   * Private constructor used to properly construct an immutable instance of the LocatorLauncher using a Builder.
-   * The Builder is used to configure a LocatorLauncher instance.  The Builder can process user input from the
-   * command-line or be used to properly construct an instance of the LocatorLauncher programmatically using the API.
+   * Private constructor used to properly construct an immutable instance of the LocatorLauncher
+   * using a Builder. The Builder is used to configure a LocatorLauncher instance. The Builder can
+   * process user input from the command-line or be used to properly construct an instance of the
+   * LocatorLauncher programmatically using the API.
-   * @param builder an instance of LocatorLauncher.Builder for configuring and constructing an instance of the
-   * LocatorLauncher.
+   * @param builder an instance of LocatorLauncher.Builder for configuring and constructing an
+   *        instance of the LocatorLauncher.
+
-  public static LocatorStatusResponse statusLocator(int port, InetAddress bindAddress) throws IOException {
-    //final int timeout = (60 * 2 * 1000); // 2 minutes
+  public static LocatorStatusResponse statusLocator(int port, InetAddress bindAddress)
+      throws IOException {
+    // final int timeout = (60 * 2 * 1000); // 2 minutes
-        new LocatorStatusRequest(), timeout, true);
-    }
-    catch (ClassNotFoundException e) {
+          new LocatorStatusRequest(), timeout, true);
+    } catch (ClassNotFoundException e) {
-   * Gets an identifier that uniquely identifies and represents the Locator associated with this launcher.
+   * Gets an identifier that uniquely identifies and represents the Locator associated with this
+   * launcher.
-    return LocatorState.getBindAddressAsString(this).concat("[").concat(LocatorState.getPortAsString(this)).concat("]");
+    return LocatorState.getBindAddressAsString(this).concat("[")
+        .concat(LocatorState.getPortAsString(this)).concat("]");
-   * Determines whether the PID file is allowed to be overwritten when the Locator is started and a PID file
-   * already exists in the Locator's specified working directory.
+   * Determines whether the PID file is allowed to be overwritten when the Locator is started and a
+   * PID file already exists in the Locator's specified working directory.
-   * Determines whether this launcher will be used to display help information.  If so, then none of the standard
-   * Locator launcher commands will be used to affect the state of the Locator.  A launcher is said to be 'helping'
-   * if the user entered the "--help" option (switch) on the command-line.
+   * Determines whether this launcher will be used to display help information. If so, then none of
+   * the standard Locator launcher commands will be used to affect the state of the Locator. A
+   * launcher is said to be 'helping' if the user entered the "--help" option (switch) on the
+   * command-line.
-  
+
-   * Determines whether this launcher will redirect output to system logs when
-   * starting a new Locator process.
+   * Determines whether this launcher will redirect output to system logs when starting a new
+   * Locator process.
-   * @return a boolean value indicating if this launcher will redirect output 
-   * to system logs when starting a new Locator process
+   * @return a boolean value indicating if this launcher will redirect output to system logs when
+   *         starting a new Locator process
-   * Gets the IP address of the NIC to which the Locator has bound itself listening for client requests.
+   * Gets the IP address of the NIC to which the Locator has bound itself listening for client
+   * requests.
-   * Gets the host, as either hostname or IP address, on which the Locator was bound and running.  An attempt is made
-   * to get the canonical hostname for IP address to which the Locator was bound for accepting client requests.  If
-   * the bind address is null or localhost is unknown, then a default String value of "localhost/127.0.0.1" is returned.
+   * Gets the host, as either hostname or IP address, on which the Locator was bound and running. An
+   * attempt is made to get the canonical hostname for IP address to which the Locator was bound for
+   * accepting client requests. If the bind address is null or localhost is unknown, then a default
+   * String value of "localhost/127.0.0.1" is returned.
-   * Note, this information is purely information and should not be used to re-construct state or for
-   * other purposes.
+   * Note, this information is purely information and should not be used to re-construct state or
+   * for other purposes.
-   * @return the hostname or IP address of the host running the Locator, based on the bind-address, or
-   * 'localhost/127.0.0.1' if the bind address is null and localhost is unknown.
+   * @return the hostname or IP address of the host running the Locator, based on the bind-address,
+   *         or 'localhost/127.0.0.1' if the bind address is null and localhost is unknown.
-    }
-    catch (UnknownHostException ignore) {
-      // TODO determine a better value for the host on which the Locator is running to return here...
-      // NOTE returning localhost/127.0.0.1 implies the bindAddress was null and no IP address for localhost
+    } catch (UnknownHostException ignore) {
+      // TODO determine a better value for the host on which the Locator is running to return
+      // here...
+      // NOTE returning localhost/127.0.0.1 implies the bindAddress was null and no IP address for
+      // localhost
-    return StringUtils.defaultIfBlank(getMemberName(), DEFAULT_LOCATOR_LOG_NAME).concat(DEFAULT_LOCATOR_LOG_EXT);
+    return StringUtils.defaultIfBlank(getMemberName(), DEFAULT_LOCATOR_LOG_NAME)
+        .concat(DEFAULT_LOCATOR_LOG_EXT);
-   * Gets the name of this member (this Locator) in the GemFire distributed system and determined by the 'name' GemFire
-   * property.
+   * Gets the name of this member (this Locator) in the GemFire distributed system and determined by
+   * the 'name' GemFire property.
-   * @return a String indicating the name of the member (this Locator) in the GemFire distributed system.
+   * @return a String indicating the name of the member (this Locator) in the GemFire distributed
+   *         system.
-   * Gets the user-specified process ID (PID) of the running Locator that LocatorLauncher uses to issue status and
-   * stop commands to the Locator.
+   * Gets the user-specified process ID (PID) of the running Locator that LocatorLauncher uses to
+   * issue status and stop commands to the Locator.
-   * @return an Integer value indicating the port number on which the Locator is listening for client requests.
+   * @return an Integer value indicating the port number on which the Locator is listening for
+   *         client requests.
-   * Gets the port number represented as a String value.  If the port number is null, the the default Locator port
-   * (10334) is returned;
+   * Gets the port number represented as a String value. If the port number is null, the the default
+   * Locator port (10334) is returned;
-   * @return a Properties object containing the configuration settings for the GemFire Distributed System (cluster).
+   * @return a Properties object containing the configuration settings for the GemFire Distributed
+   *         System (cluster).
-   * Displays help for the specified Locator launcher command to standard err.  If the Locator launcher command
-   * is unspecified, then usage information is displayed instead.
+   * Displays help for the specified Locator launcher command to standard err. If the Locator
+   * launcher command is unspecified, then usage information is displayed instead.
-    }
-    else {
+    } else {
-      info(StringUtils.wrap("> java ... " + getClass().getName() + " " + usageMap.get(command), 80, "\t\t"));
+      info(StringUtils.wrap("> java ... " + getClass().getName() + " " + usageMap.get(command), 80,
+          "\t\t"));
-   * Displays usage information on the proper invocation of the LocatorLauncher from the command-line to standard err.
+   * Displays usage information on the proper invocation of the LocatorLauncher from the
+   * command-line to standard err.
-   * The Runnable method used to launch the Locator with the specified command.  If 'start' has been issued, then run
-   * will block as expected for the Locator to stop.  The 'start' command is implemented with a call to start()
-   * followed by a call to waitOnLocator().
+   * The Runnable method used to launch the Locator with the specified command. If 'start' has been
+   * issued, then run will block as expected for the Locator to stop. The 'start' command is
+   * implemented with a call to start() followed by a call to waitOnLocator().
-    }
-    else {
+    } else {
-  
+
-   * @return a boolean indicating whether a GemFire Locator can be started with this instance of LocatorLauncher,
-   * which is true if the LocatorLauncher has not already started a Locator or a Locator is not already running.
+   * @return a boolean indicating whether a GemFire Locator can be started with this instance of
+   *         LocatorLauncher, which is true if the LocatorLauncher has not already started a Locator
+   *         or a Locator is not already running.
-   * Starts a Locator running on the specified port and bind address, as determined by getPort and getBindAddress
-   * respectively, defaulting to 10334 and 'localhost' if not specified, with both peer and server location enabled.
+   * Starts a Locator running on the specified port and bind address, as determined by getPort and
+   * getBindAddress respectively, defaulting to 10334 and 'localhost' if not specified, with both
+   * peer and server location enabled.
-   * 'start' is an asynchronous invocation of the Locator.  As such, this method makes no guarantees whether the
-   * Locator's location services (peer and server) are actually running before it returns.  The Locator's
-   * location-based services are initiated in separate, daemon Threads and depends on the relative timing
-   * and scheduling of those Threads by the JVM.  If the application using this API wishes for the Locator to continue
-   * running after normal application processing completes, then one must call <code>waitOnLocator</code>.
+   * 'start' is an asynchronous invocation of the Locator. As such, this method makes no guarantees
+   * whether the Locator's location services (peer and server) are actually running before it
+   * returns. The Locator's location-based services are initiated in separate, daemon Threads and
+   * depends on the relative timing and scheduling of those Threads by the JVM. If the application
+   * using this API wishes for the Locator to continue running after normal application processing
+   * completes, then one must call <code>waitOnLocator</code>.
-   * Given the nature of start, the Locator's status will be in either 1 of 2 possible states.  If the 'request' to
-   * start the Locator proceeds without exception, the status will be 'STARTED'.  However, if any exception is
-   * encountered during the normal startup sequence, then a RuntimeException is thrown and the status is set to
-   * 'STOPPED'.
+   * Given the nature of start, the Locator's status will be in either 1 of 2 possible states. If
+   * the 'request' to start the Locator proceeds without exception, the status will be 'STARTED'.
+   * However, if any exception is encountered during the normal startup sequence, then a
+   * RuntimeException is thrown and the status is set to 'STOPPED'.
-        this.process = new ControllableProcess(this.controlHandler, new File(getWorkingDirectory()), ProcessType.LOCATOR, isForcing());
-        
+        this.process = new ControllableProcess(this.controlHandler, new File(getWorkingDirectory()),
+            ProcessType.LOCATOR, isForcing());
+
-        ProcessLauncherContext.set(isRedirectingOutput(), getOverriddenDefaults(), new StartupStatusListener() {
-          @Override
-          public void setStatus(final String statusMessage) {
-            LocatorLauncher.this.statusMessage = statusMessage;
-          }
-        });
-        
-        //TODO : remove the extra param for loadFromSharedConfigDir
+        ProcessLauncherContext.set(isRedirectingOutput(), getOverriddenDefaults(),
+            new StartupStatusListener() {
+              @Override
+              public void setStatus(final String statusMessage) {
+                LocatorLauncher.this.statusMessage = statusMessage;
+              }
+            });
+
+        // TODO : remove the extra param for loadFromSharedConfigDir
-          this.locator = InternalLocator.startLocator(getPort(), getLogFile(), null, null, null, getBindAddress(),
-            getDistributedSystemProperties(), DEFAULT_ENABLE_PEER_LOCATION, DEFAULT_ENABLE_SERVER_LOCATION,
-              getHostnameForClients(), false);
-        }
-        finally {
+          this.locator = InternalLocator.startLocator(getPort(), getLogFile(), null, null, null,
+              getBindAddress(), getDistributedSystemProperties(), DEFAULT_ENABLE_PEER_LOCATION,
+              DEFAULT_ENABLE_SERVER_LOCATION, getHostnameForClients(), false);
+        } finally {
-        debug("Running Locator on (%1$s) in (%2$s) as (%2$s)...", getId(), getWorkingDirectory(), getMember());
+        debug("Running Locator on (%1$s) in (%2$s) as (%2$s)...", getId(), getWorkingDirectory(),
+            getMember());
-      }
-      catch (IOException e) {
+      } catch (IOException e) {
-        throw new RuntimeException(LocalizedStrings.Launcher_Command_START_IO_ERROR_MESSAGE.toLocalizedString(
-          getServiceName(), getWorkingDirectory(), getId(), e.getMessage()), e);
-      }
-      catch (FileAlreadyExistsException e) {
+        throw new RuntimeException(LocalizedStrings.Launcher_Command_START_IO_ERROR_MESSAGE
+            .toLocalizedString(getServiceName(), getWorkingDirectory(), getId(), e.getMessage()),
+            e);
+      } catch (FileAlreadyExistsException e) {
-        throw new RuntimeException(LocalizedStrings.Launcher_Command_START_PID_FILE_ALREADY_EXISTS_ERROR_MESSAGE
-          .toLocalizedString(getServiceName(), getWorkingDirectory(), getId()), e);
-      }
-      catch (PidUnavailableException e) {
+        throw new RuntimeException(
+            LocalizedStrings.Launcher_Command_START_PID_FILE_ALREADY_EXISTS_ERROR_MESSAGE
+                .toLocalizedString(getServiceName(), getWorkingDirectory(), getId()),
+            e);
+      } catch (PidUnavailableException e) {
-        throw new RuntimeException(LocalizedStrings.Launcher_Command_START_PID_UNAVAILABLE_ERROR_MESSAGE
-          .toLocalizedString(getServiceName(), getId(), getWorkingDirectory(), e.getMessage()), e);
-      }
-      catch (Error e) {
+        throw new RuntimeException(
+            LocalizedStrings.Launcher_Command_START_PID_UNAVAILABLE_ERROR_MESSAGE.toLocalizedString(
+                getServiceName(), getId(), getWorkingDirectory(), e.getMessage()),
+            e);
+      } catch (Error e) {
-      }
-      catch (RuntimeException e) {
+      } catch (RuntimeException e) {
-      }
-      catch (Exception e) {
+      } catch (Exception e) {
-      }
-      finally {
+      } finally {
-    }
-    else {
-      throw new IllegalStateException(LocalizedStrings.Launcher_Command_START_SERVICE_ALREADY_RUNNING_ERROR_MESSAGE
-        .toLocalizedString(getServiceName(), getWorkingDirectory(), getId()));
+    } else {
+      throw new IllegalStateException(
+          LocalizedStrings.Launcher_Command_START_SERVICE_ALREADY_RUNNING_ERROR_MESSAGE
+              .toLocalizedString(getServiceName(), getWorkingDirectory(), getId()));
-     Properties properties = super.getDistributedSystemProperties(getProperties());
-     return properties;
+    Properties properties = super.getDistributedSystemProperties(getProperties());
+    return properties;
-   * A helper method to ensure the same sequence of actions are taken when the Locator fails to start
-   * caused by some exception.
+   * A helper method to ensure the same sequence of actions are taken when the Locator fails to
+   * start caused by some exception.
-    
+
-   * Waits on the Locator to stop causing the calling Thread to join with the Locator's location-based services Thread.
+   * Waits on the Locator to stop causing the calling Thread to join with the Locator's
+   * location-based services Thread.
-   * @throws AssertionError if the Locator has not been started and the reference is null (assertions must be enabled
-   * for the error to be thrown).
+   * @throws AssertionError if the Locator has not been started and the reference is null
+   *         (assertions must be enabled for the error to be thrown).
-    }
-    catch (InterruptedException e) {
+    } catch (InterruptedException e) {
-    }
-    catch (RuntimeException e) {
+    } catch (RuntimeException e) {
-    }
-    catch (Throwable e) {
+    } catch (Throwable e) {
-    }
-    finally {
+    } finally {
-   * Waits for a Locator status request response to be returned up to the specified timeout in the given unit of time.
-   * This call will send status requests at fixed intervals in the given unit of time until the timeout expires.  If
-   * the request to determine the Locator's status is successful, then the Locator is considered to be 'ONLINE'.
-   * Otherwise, the Locator is considered to be unresponsive to the status request.
+   * Waits for a Locator status request response to be returned up to the specified timeout in the
+   * given unit of time. This call will send status requests at fixed intervals in the given unit of
+   * time until the timeout expires. If the request to determine the Locator's status is successful,
+   * then the Locator is considered to be 'ONLINE'. Otherwise, the Locator is considered to be
+   * unresponsive to the status request.
-   * However, this does not necessarily imply the Locator start was unsuccessful, only that a response was not received
-   * in the given time period.
+   * However, this does not necessarily imply the Locator start was unsuccessful, only that a
+   * response was not received in the given time period.
-   * Note, this method does not block or cause the Locator's location-based services (daemon Threads) to continue
-   * running in anyway if the main application Thread terminates when running the Locator in-process.  If the caller
-   * wishes to start a Locator in an asynchronous manner within the application process, then a call should be made to
-   * <code>waitOnLocator</code>.
+   * Note, this method does not block or cause the Locator's location-based services (daemon
+   * Threads) to continue running in anyway if the main application Thread terminates when running
+   * the Locator in-process. If the caller wishes to start a Locator in an asynchronous manner
+   * within the application process, then a call should be made to <code>waitOnLocator</code>.
-   * @param timeout a long value in time unit indicating when the period of time should expire in attempting
-   * to determine the Locator's status.
-   * @param interval a long value in time unit for how frequent the requests should be sent to the Locator.
+   * @param timeout a long value in time unit indicating when the period of time should expire in
+   *        attempting to determine the Locator's status.
+   * @param interval a long value in time unit for how frequent the requests should be sent to the
+   *        Locator.
-   * @return the state of the Locator, which will either be 'ONLINE' or "NOT RESPONDING'.  If the status returned is
-   * 'NOT RESPONDING', it just means the Locator did not respond to the status request within the given time period.
-   * It should not be taken as the Locator failed to start.
+   * @return the state of the Locator, which will either be 'ONLINE' or "NOT RESPONDING'. If the
+   *         status returned is 'NOT RESPONDING', it just means the Locator did not respond to the
+   *         status request within the given time period. It should not be taken as the Locator
+   *         failed to start.
-  public LocatorState waitOnStatusResponse(final long timeout, final long interval, final TimeUnit timeUnit) {
+  public LocatorState waitOnStatusResponse(final long timeout, final long interval,
+      final TimeUnit timeUnit) {
-      }
-      catch (Exception ignore) {
+      } catch (Exception ignore) {
-        }
-        catch (InterruptedException ignoreInterrupt) {
+        } catch (InterruptedException ignoreInterrupt) {
-    // NOTE just because we were not able to communicate with the Locator in the given amount of time does not mean
-    // the Locator is having problems.  The Locator could be slow in starting up and the timeout may not be
+    // NOTE just because we were not able to communicate with the Locator in the given amount of
+    // time does not mean
+    // the Locator is having problems. The Locator could be slow in starting up and the timeout may
+    // not be
-   * Attempts to determine the state of the Locator.  The Locator's status will be in only 1 of 2 possible states,
-   * either ONLINE or OFFLINE.  This method behaves differently depending on which parameters were specified when
-   * the LocatorLauncher was constructed with an instance of Builder.  If either the 'dir' or the 'pid' command-line
-   * option were specified, then an attempt is made to determine the Locator's status by using the dir or pid to
-   * correctly identify the Locator's MemberMXBean registered in the MBeanServer of the Locator's JVM, and invoking
-   * the 'status' operation.  The same behavior occurs if the caller specified the Locator's GemFire member name or ID.
+   * Attempts to determine the state of the Locator. The Locator's status will be in only 1 of 2
+   * possible states, either ONLINE or OFFLINE. This method behaves differently depending on which
+   * parameters were specified when the LocatorLauncher was constructed with an instance of Builder.
+   * If either the 'dir' or the 'pid' command-line option were specified, then an attempt is made to
+   * determine the Locator's status by using the dir or pid to correctly identify the Locator's
+   * MemberMXBean registered in the MBeanServer of the Locator's JVM, and invoking the 'status'
+   * operation. The same behavior occurs if the caller specified the Locator's GemFire member name
+   * or ID.
-   * However, if 'dir' or 'pid' were not specified, then determining the Locator's status defaults to using the
-   * configured bind address and port.  If the bind address or port was not specified when using the Builder to
-   * construct a LocatorLauncher instance, then the defaults for both bind address and port are used.  In either case,
-   * an actual TCP/IP request is made to the Locator's ServerSocket to ensure it is listening for client requests.
-   * This is true even when the LocatorLauncher is used in-process by calling the API.
+   * However, if 'dir' or 'pid' were not specified, then determining the Locator's status defaults
+   * to using the configured bind address and port. If the bind address or port was not specified
+   * when using the Builder to construct a LocatorLauncher instance, then the defaults for both bind
+   * address and port are used. In either case, an actual TCP/IP request is made to the Locator's
+   * ServerSocket to ensure it is listening for client requests. This is true even when the
+   * LocatorLauncher is used in-process by calling the API.
-   * If the conditions above hold, then the Locator is deemed to be 'ONLINE', otherwise, the Locator is considered
-   * 'OFFLINE'.
+   * If the conditions above hold, then the Locator is deemed to be 'ONLINE', otherwise, the Locator
+   * is considered 'OFFLINE'.
-      debug("Getting status from the LocatorLauncher instance that actually launched the GemFire Locator.%n");
+      debug(
+          "Getting status from the LocatorLauncher instance that actually launched the GemFire Locator.%n");
-      debug("Getting Locator status using host (%1$s) and port (%2$s)%n", getBindAddressAsString(), getPortAsString());
+      debug("Getting Locator status using host (%1$s) and port (%2$s)%n", getBindAddressAsString(),
+          getPortAsString());
-    // attempt to get status using host and port (Note, bind address doubles as host when the launcher
+    // attempt to get status using host and port (Note, bind address doubles as host when the
+    // launcher
-      debug("Getting Locator status using host (%1$s) and port (%2$s)%n", getBindAddressAsString(), getPortAsString());
+      debug("Getting Locator status using host (%1$s) and port (%2$s)%n", getBindAddressAsString(),
+          getPortAsString());
-      debug("Getting status from the LocatorLauncher instance that actually launched the GemFire Locator.%n");
+      debug(
+          "Getting status from the LocatorLauncher instance that actually launched the GemFire Locator.%n");
-    }
-    else {
-      debug("Getting Locator status using host (%1$s) and port (%2$s)%n", getBindAddressAsString(), getPortAsString());
+    } else {
+      debug("Getting Locator status using host (%1$s) and port (%2$s)%n", getBindAddressAsString(),
+          getPortAsString());
-      final ProcessController controller = new ProcessControllerFactory().createProcessController(this.controllerParameters, getPid());
+      final ProcessController controller = new ProcessControllerFactory()
+          .createProcessController(this.controllerParameters, getPid());
-    }
-    catch (ConnectionFailedException e) {
+    } catch (ConnectionFailedException e) {
-    } 
-    catch (IOException e) {
+    } catch (IOException e) {
-      return createNoResponseState(e, "Failed to communicate with locator with process id " + getPid());
-    } 
-    catch (MBeanInvocationFailedException e) {
+      return createNoResponseState(e,
+          "Failed to communicate with locator with process id " + getPid());
+    } catch (MBeanInvocationFailedException e) {
-      return createNoResponseState(e, "Failed to communicate with locator with process id " + getPid());
-    } 
-    catch (UnableToControlProcessException e) {
-      return createNoResponseState(e, "Failed to communicate with locator with process id " + getPid());
-    } 
-    catch (InterruptedException e) {
+      return createNoResponseState(e,
+          "Failed to communicate with locator with process id " + getPid());
+    } catch (UnableToControlProcessException e) {
+      return createNoResponseState(e,
+          "Failed to communicate with locator with process id " + getPid());
+    } catch (InterruptedException e) {
-      return createNoResponseState(e, "Interrupted while trying to communicate with locator with process id " + getPid());
-    } 
-    catch (TimeoutException e) {
-      return createNoResponseState(e, "Failed to communicate with locator with process id " + getPid());
+      return createNoResponseState(e,
+          "Interrupted while trying to communicate with locator with process id " + getPid());
+    } catch (TimeoutException e) {
+      return createNoResponseState(e,
+          "Failed to communicate with locator with process id " + getPid());
-    }
-    catch (Exception e) {
+    } catch (Exception e) {
-      final ProcessController controller = new ProcessControllerFactory().createProcessController(this.controllerParameters, new File(getWorkingDirectory()), ProcessType.LOCATOR.getPidFileName(), READ_PID_FILE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
+      final ProcessController controller =
+          new ProcessControllerFactory().createProcessController(this.controllerParameters,
+              new File(getWorkingDirectory()), ProcessType.LOCATOR.getPidFileName(),
+              READ_PID_FILE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
-      
+
-    }
-    catch (ConnectionFailedException e) {
+    } catch (ConnectionFailedException e) {
-    } 
-    catch (FileNotFoundException e) {
+    } catch (FileNotFoundException e) {
-      return createNoResponseState(e, "Failed to find process file " + ProcessType.LOCATOR.getPidFileName() + " in " + getWorkingDirectory());
-    } 
-    catch (IOException e) {
+      return createNoResponseState(e, "Failed to find process file "
+          + ProcessType.LOCATOR.getPidFileName() + " in " + getWorkingDirectory());
+    } catch (IOException e) {
-      return createNoResponseState(e, "Failed to communicate with locator with process id " + parsedPid);
-    } 
-    catch (MBeanInvocationFailedException e) {
+      return createNoResponseState(e,
+          "Failed to communicate with locator with process id " + parsedPid);
+    } catch (MBeanInvocationFailedException e) {
-      return createNoResponseState(e, "Failed to communicate with locator with process id " + parsedPid);
-    } 
-    catch (PidUnavailableException e) {
+      return createNoResponseState(e,
+          "Failed to communicate with locator with process id " + parsedPid);
+    } catch (PidUnavailableException e) {
-      return createNoResponseState(e, "Failed to find usable process id within file " + ProcessType.LOCATOR.getPidFileName() + " in " + getWorkingDirectory());
-    } 
-    catch (UnableToControlProcessException e) {
-      return createNoResponseState(e, "Failed to communicate with locator with process id " + parsedPid);
-    } 
-    catch (InterruptedException e) {
+      return createNoResponseState(e, "Failed to find usable process id within file "
+          + ProcessType.LOCATOR.getPidFileName() + " in " + getWorkingDirectory());
+    } catch (UnableToControlProcessException e) {
+      return createNoResponseState(e,
+          "Failed to communicate with locator with process id " + parsedPid);
+    } catch (InterruptedException e) {
-      return createNoResponseState(e, "Interrupted while trying to communicate with locator with process id " + parsedPid);
-    } 
-    catch (TimeoutException e) {
-      return createNoResponseState(e, "Failed to communicate with locator with process id " + parsedPid);
+      return createNoResponseState(e,
+          "Interrupted while trying to communicate with locator with process id " + parsedPid);
+    } catch (TimeoutException e) {
+      return createNoResponseState(e,
+          "Failed to communicate with locator with process id " + parsedPid);
-   * Determines whether the Locator can be stopped in-process, such as when a Locator is embedded in an application
-   * and the LocatorLauncher API is being used.
+   * Determines whether the Locator can be stopped in-process, such as when a Locator is embedded in
+   * an application and the LocatorLauncher API is being used.
-   * @return a boolean indicating whether the Locator can be stopped in-process (the application's process with
-   * an embedded Locator).
+   * @return a boolean indicating whether the Locator can be stopped in-process (the application's
+   *         process with an embedded Locator).
-   * Stop shuts the running Locator down.  Using the API, the Locator is requested to stop by calling the Locator
-   * object's 'stop' method.  Internally, this method is no different than using the LocatorLauncher class from the
-   * command-line or from within GemFire shell (Gfsh).  In every single case, stop sends a TCP/IP 'shutdown' request
-   * on the configured address/port to which the Locator is bound and listening.
+   * Stop shuts the running Locator down. Using the API, the Locator is requested to stop by calling
+   * the Locator object's 'stop' method. Internally, this method is no different than using the
+   * LocatorLauncher class from the command-line or from within GemFire shell (Gfsh). In every
+   * single case, stop sends a TCP/IP 'shutdown' request on the configured address/port to which the
+   * Locator is bound and listening.
-   * If the "shutdown" request is successful, then the Locator will be 'STOPPED'.  Otherwise, the Locator is considered
-   * 'OFFLINE' since the actual state cannot be fully assessed (as in the application process in which the Locator was
-   * hosted may still be running and the Locator object may still exist even though it is no longer responding to
-   * location-based requests).  The later is particularly important in cases where the system resources (such as
-   * Sockets) may not have been cleaned up yet.  Therefore, by returning a status of 'OFFLINE', the value is meant to
+   * If the "shutdown" request is successful, then the Locator will be 'STOPPED'. Otherwise, the
+   * Locator is considered 'OFFLINE' since the actual state cannot be fully assessed (as in the
+   * application process in which the Locator was hosted may still be running and the Locator object
+   * may still exist even though it is no longer responding to location-based requests). The later
+   * is particularly important in cases where the system resources (such as Sockets) may not have
+   * been cleaned up yet. Therefore, by returning a status of 'OFFLINE', the value is meant to
-    //else if (this.workingDirectorySpecified) {
+    // else if (this.workingDirectorySpecified) {
-    }
-    else {
+    } else {
-  
+
-      final ProcessController controller = new ProcessControllerFactory().createProcessController(new LocatorControllerParameters(), getPid());
+      final ProcessController controller = new ProcessControllerFactory()
+          .createProcessController(new LocatorControllerParameters(), getPid());
-    }
-    catch (ConnectionFailedException e) {
+    } catch (ConnectionFailedException e) {
-    } 
-    catch (IOException e) {
+    } catch (IOException e) {
-      return createNoResponseState(e, "Failed to communicate with locator with process id " + getPid());
-    } 
-    catch (MBeanInvocationFailedException e) {
+      return createNoResponseState(e,
+          "Failed to communicate with locator with process id " + getPid());
+    } catch (MBeanInvocationFailedException e) {
-      return createNoResponseState(e, "Failed to communicate with locator with process id " + getPid());
-    } 
-    catch (UnableToControlProcessException e) {
-      return createNoResponseState(e, "Failed to communicate with locator with process id " + getPid());
+      return createNoResponseState(e,
+          "Failed to communicate with locator with process id " + getPid());
+    } catch (UnableToControlProcessException e) {
+      return createNoResponseState(e,
+          "Failed to communicate with locator with process id " + getPid());
-    }
-    catch (ConnectException e) {
+    } catch (ConnectException e) {
-      } 
-      else {
+      } else {
-      final ProcessController controller = new ProcessControllerFactory().createProcessController(this.controllerParameters, new File(getWorkingDirectory()), ProcessType.LOCATOR.getPidFileName(), READ_PID_FILE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
+      final ProcessController controller =
+          new ProcessControllerFactory().createProcessController(this.controllerParameters,
+              new File(getWorkingDirectory()), ProcessType.LOCATOR.getPidFileName(),
+              READ_PID_FILE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
-      
+
-      
+
-    }
-    catch (ConnectionFailedException e) {
+    } catch (ConnectionFailedException e) {
-    } 
-    catch (FileNotFoundException e) {
+    } catch (FileNotFoundException e) {
-      return createNoResponseState(e, "Failed to find process file " + ProcessType.LOCATOR.getPidFileName() + " in " + getWorkingDirectory());
-    } 
-    catch (IOException e) {
+      return createNoResponseState(e, "Failed to find process file "
+          + ProcessType.LOCATOR.getPidFileName() + " in " + getWorkingDirectory());
+    } catch (IOException e) {
-      return createNoResponseState(e, "Failed to communicate with locator with process id " + parsedPid);
-    } 
-    catch (InterruptedException e) {
+      return createNoResponseState(e,
+          "Failed to communicate with locator with process id " + parsedPid);
+    } catch (InterruptedException e) {
-      return createNoResponseState(e, "Interrupted while trying to communicate with locator with process id " + parsedPid);
-    } 
-    catch (MBeanInvocationFailedException e) {
+      return createNoResponseState(e,
+          "Interrupted while trying to communicate with locator with process id " + parsedPid);
+    } catch (MBeanInvocationFailedException e) {
-      return createNoResponseState(e, "Failed to communicate with locator with process id " + parsedPid);
-    } 
-    catch (PidUnavailableException e) {
+      return createNoResponseState(e,
+          "Failed to communicate with locator with process id " + parsedPid);
+    } catch (PidUnavailableException e) {
-      return createNoResponseState(e, "Failed to find usable process id within file " + ProcessType.LOCATOR.getPidFileName() + " in " + getWorkingDirectory());
-    } 
-    catch (TimeoutException e) {
-      return createNoResponseState(e, "Timed out trying to find usable process id within file " + ProcessType.LOCATOR.getPidFileName() + " in " + getWorkingDirectory());
-    } 
-    catch (UnableToControlProcessException e) {
-      return createNoResponseState(e, "Failed to communicate with locator with process id " + parsedPid);
+      return createNoResponseState(e, "Failed to find usable process id within file "
+          + ProcessType.LOCATOR.getPidFileName() + " in " + getWorkingDirectory());
+    } catch (TimeoutException e) {
+      return createNoResponseState(e, "Timed out trying to find usable process id within file "
+          + ProcessType.LOCATOR.getPidFileName() + " in " + getWorkingDirectory());
+    } catch (UnableToControlProcessException e) {
+      return createNoResponseState(e,
+          "Failed to communicate with locator with process id " + parsedPid);
-    //info(errorMessage);
+    // info(errorMessage);
-  
+
-      getLogFileName());
+        getLogFileName());
-    
+
-  
+
-  
+
-    
+
-  
+
-  
+
-  
+
-    
+
-  
+
-  
+
-   * Following the Builder design pattern, the LocatorLauncher Builder is used to configure and create a properly
-   * initialized instance of the LocatorLauncher class for running the Locator and performing other Locator
-   * operations.
+   * Following the Builder design pattern, the LocatorLauncher Builder is used to configure and
+   * create a properly initialized instance of the LocatorLauncher class for running the Locator and
+   * performing other Locator operations.
-     * Default constructor used to create an instance of the Builder class for programmatical access.
+     * Default constructor used to create an instance of the Builder class for programmatical
+     * access.
-    public Builder() {
-    }
+    public Builder() {}
-     * Constructor used to create and configure an instance of the Builder class with the specified arguments, often
-     * passed from the command-line when launching an instance of this class from the command-line using the Java
-     * launcher.
+     * Constructor used to create and configure an instance of the Builder class with the specified
+     * arguments, often passed from the command-line when launching an instance of this class from
+     * the command-line using the Java launcher.
-     * @return an instance of the JOpt Simple OptionParser configured with the command-line options used by the Locator.
+     * @return an instance of the JOpt Simple OptionParser configured with the command-line options
+     *         used by the Locator.
-     * Parses an array of arguments to configure this Builder with the intent of constructing a Locator launcher to
-     * invoke a Locator.  This method is called to parse the arguments specified by the user on the command-line.
+     * Parses an array of arguments to configure this Builder with the intent of constructing a
+     * Locator launcher to invoke a Locator. This method is called to parse the arguments specified
+     * by the user on the command-line.
-     * @param args the array of arguments used to configure this Builder and create an instance of LocatorLauncher.
+     * @param args the array of arguments used to configure this Builder and create an instance of
+     *        LocatorLauncher.
-      }
-      catch (OptionException e) {
-        throw new IllegalArgumentException(LocalizedStrings.Launcher_Builder_PARSE_COMMAND_LINE_ARGUMENT_ERROR_MESSAGE
-          .toLocalizedString("Locator", e.getMessage()), e);
-      }
-      catch (Exception e) {
+      } catch (OptionException e) {
+        throw new IllegalArgumentException(
+            LocalizedStrings.Launcher_Builder_PARSE_COMMAND_LINE_ARGUMENT_ERROR_MESSAGE
+                .toLocalizedString("Locator", e.getMessage()),
+            e);
+      } catch (Exception e) {
-      // search the list of arguments for the command; technically, the command should be the first argument in the
-      // list, but does it really matter?  stop after we find one valid command.
+      // search the list of arguments for the command; technically, the command should be the first
+      // argument in the
+      // list, but does it really matter? stop after we find one valid command.
-     * Iterates the list of arguments in search of the Locator's GemFire member name.  If the argument does not
-     * start with '-' or is not the name of a Locator launcher command, then the value is presumed to be the member name
-     * for the Locator in GemFire.
+     * Iterates the list of arguments in search of the Locator's GemFire member name. If the
+     * argument does not start with '-' or is not the name of a Locator launcher command, then the
+     * value is presumed to be the member name for the Locator in GemFire.
-     * @param args the array of arguments from which to search for the Locator's member name in GemFire.
+     * @param args the array of arguments from which to search for the Locator's member name in
+     *        GemFire.
-     * @param command the targeted Locator launcher command used during the invocation (run) of LocatorLauncher.
+     * @param command the targeted Locator launcher command used during the invocation (run) of
+     *        LocatorLauncher.
-     * @return a Properties object containing configuration settings for the GemFire Distributed System (cluster).
+     * @return a Properties object containing configuration settings for the GemFire Distributed
+     *         System (cluster).
-     * Gets the boolean value used by the Locator to determine if it should overwrite the PID file if it already exists.
+     * Gets the boolean value used by the Locator to determine if it should overwrite the PID file
+     * if it already exists.
-     * @return the boolean value specifying whether or not to overwrite the PID file if it already exists.
+     * @return the boolean value specifying whether or not to overwrite the PID file if it already
+     *         exists.
-     * Sets the boolean value used by the Locator to determine if it should overwrite the PID file if it already exists.
+     * Sets the boolean value used by the Locator to determine if it should overwrite the PID file
+     * if it already exists.
-     * @param force a boolean value indicating whether to overwrite the PID file when it already exists.
+     * @param force a boolean value indicating whether to overwrite the PID file when it already
+     *        exists.
- 
+
-     * Determines whether the new instance of LocatorLauncher will be used to output help information for either
-     * a specific command, or for using LocatorLauncher in general.
+     * Determines whether the new instance of LocatorLauncher will be used to output help
+     * information for either a specific command, or for using LocatorLauncher in general.
-     * @return a boolean value indicating whether help will be output during the invocation of LocatorLauncher.
+     * @return a boolean value indicating whether help will be output during the invocation of
+     *         LocatorLauncher.
-     * Sets whether the new instance of LocatorLauncher will be used to output help information for either a specific
-     * command, or for using LocatorLauncher in general.
+     * Sets whether the new instance of LocatorLauncher will be used to output help information for
+     * either a specific command, or for using LocatorLauncher in general.
-     * @param help a boolean indicating whether help information is to be displayed during invocation of LocatorLauncher.
+     * @param help a boolean indicating whether help information is to be displayed during
+     *        invocation of LocatorLauncher.
+
-     * @return an InetAddress with the IP address or hostname on which the Locator is bound and listening.
+     * @return an InetAddress with the IP address or hostname on which the Locator is bound and
+     *         listening.
-     * Sets the IP address as an java.net.InetAddress to which the Locator has bound itself listening for client
-     * requests.
+     * Sets the IP address as an java.net.InetAddress to which the Locator has bound itself
+     * listening for client requests.
-     * @param bindAddress the InetAddress with the IP address or hostname on which the Locator is bound and listening.
+     * @param bindAddress the InetAddress with the IP address or hostname on which the Locator is
+     *        bound and listening.
-     * @throws IllegalArgumentException wrapping the UnknownHostException if the IP address or hostname for the
-     * bind address is unknown.
+     * @throws IllegalArgumentException wrapping the UnknownHostException if the IP address or
+     *         hostname for the bind address is unknown.
-      }
-      else {
+      } else {
+          } else {
+            throw new IllegalArgumentException(
+                bindAddress + " is not an address for this machine.");
-          else {
-            throw new IllegalArgumentException(bindAddress + " is not an address for this machine.");
-          }
-        }
-        catch (UnknownHostException e) {
-          throw new IllegalArgumentException(LocalizedStrings.Launcher_Builder_UNKNOWN_HOST_ERROR_MESSAGE
-            .toLocalizedString("Locator"), e);
+        } catch (UnknownHostException e) {
+          throw new IllegalArgumentException(
+              LocalizedStrings.Launcher_Builder_UNKNOWN_HOST_ERROR_MESSAGE
+                  .toLocalizedString("Locator"),
+              e);
-     * @param hostnameForClients a String indicating the hostname Locator binding used in client lookups.
+     * @param hostnameForClients a String indicating the hostname Locator binding used in client
+     *        lookups.
-     * @throws IllegalArgumentException if the hostname was not specified (is blank or empty), such as when the
-     * --hostname-for-clients command-line option may have been specified without any argument.
+     * @throws IllegalArgumentException if the hostname was not specified (is blank or empty), such
+     *         as when the --hostname-for-clients command-line option may have been specified
+     *         without any argument.
-          LocalizedStrings.LocatorLauncher_Builder_INVALID_HOSTNAME_FOR_CLIENTS_ERROR_MESSAGE.toLocalizedString());
+            LocalizedStrings.LocatorLauncher_Builder_INVALID_HOSTNAME_FOR_CLIENTS_ERROR_MESSAGE
+                .toLocalizedString());
-        throw new IllegalArgumentException(LocalizedStrings.Launcher_Builder_MEMBER_NAME_ERROR_MESSAGE
-          .toLocalizedString("Locator"));
+        throw new IllegalArgumentException(
+            LocalizedStrings.Launcher_Builder_MEMBER_NAME_ERROR_MESSAGE
+                .toLocalizedString("Locator"));
-     * Gets the process ID (PID) of the running Locator indicated by the user as an argument to the LocatorLauncher.
-     * This PID is used by the Locator launcher to determine the Locator's status, or invoke shutdown on the Locator.
+     * Gets the process ID (PID) of the running Locator indicated by the user as an argument to the
+     * LocatorLauncher. This PID is used by the Locator launcher to determine the Locator's status,
+     * or invoke shutdown on the Locator.
-     * Sets the process ID (PID) of the running Locator indicated by the user as an argument to the LocatorLauncher.
-     * This PID will be used by the Locator launcher to determine the Locator's status, or invoke shutdown on
-     * the Locator.
+     * Sets the process ID (PID) of the running Locator indicated by the user as an argument to the
+     * LocatorLauncher. This PID will be used by the Locator launcher to determine the Locator's
+     * status, or invoke shutdown on the Locator.
-     * @throws IllegalArgumentException if the process ID (PID) is not valid (greater than zero if not null).
+     * @throws IllegalArgumentException if the process ID (PID) is not valid (greater than zero if
+     *         not null).
-        throw new IllegalArgumentException(LocalizedStrings.Launcher_Builder_PID_ERROR_MESSAGE.toLocalizedString());
+        throw new IllegalArgumentException(
+            LocalizedStrings.Launcher_Builder_PID_ERROR_MESSAGE.toLocalizedString());
-    
+
-     * Gets the port number used by the Locator to listen for client requests.  If the port was not specified, then the
-     * default Locator port (10334) is returned.
+     * Gets the port number used by the Locator to listen for client requests. If the port was not
+     * specified, then the default Locator port (10334) is returned.
-     * Sets the port number used by the Locator to listen for client requests.  The port number must be between 1 and
-     * 65535 inclusive.
+     * Sets the port number used by the Locator to listen for client requests. The port number must
+     * be between 1 and 65535 inclusive.
-     * @param port an Integer value indicating the port used by the Locator to listen for client requests.
+     * @param port an Integer value indicating the port used by the Locator to listen for client
+     *        requests.
-      // NOTE if the user were to specify a port number of 0, then java.net.ServerSocket will pick an ephemeral port
+      // NOTE if the user were to specify a port number of 0, then java.net.ServerSocket will pick
+      // an ephemeral port
-        throw new IllegalArgumentException(LocalizedStrings.Launcher_Builder_INVALID_PORT_ERROR_MESSAGE
-          .toLocalizedString("Locator"));
+        throw new IllegalArgumentException(
+            LocalizedStrings.Launcher_Builder_INVALID_PORT_ERROR_MESSAGE
+                .toLocalizedString("Locator"));
-     * Determines whether the new instance of LocatorLauncher will redirect
-     * output to system logs when starting a Locator.
+     * Determines whether the new instance of LocatorLauncher will redirect output to system logs
+     * when starting a Locator.
-     * @return a boolean value indicating if output will be redirected to system 
-     * logs when starting a Locator
+     * @return a boolean value indicating if output will be redirected to system logs when starting
+     *         a Locator
-     * Sets whether the new instance of LocatorLauncher will redirect output to system logs when starting a Locator.
+     * Sets whether the new instance of LocatorLauncher will redirect output to system logs when
+     * starting a Locator.
-     * @param redirectOutput a boolean value indicating if output will be redirected to system logs when starting
-     * a Locator.
+     * @param redirectOutput a boolean value indicating if output will be redirected to system logs
+     *        when starting a Locator.
-     * Gets the working directory pathname in which the Locator will be ran.  If the directory is unspecified,
-     * then working directory defaults to the current directory.
+     * Gets the working directory pathname in which the Locator will be ran. If the directory is
+     * unspecified, then working directory defaults to the current directory.
-        new File(StringUtils.defaultIfBlank(this.workingDirectory, DEFAULT_WORKING_DIRECTORY)));
+          new File(StringUtils.defaultIfBlank(this.workingDirectory, DEFAULT_WORKING_DIRECTORY)));
-     * Sets the working directory in which the Locator will be ran.  This also the directory in which all Locator
-     * files (such as log and license files) will be written.  If the directory is unspecified, then the working
-     * directory defaults to the current directory.
+     * Sets the working directory in which the Locator will be ran. This also the directory in which
+     * all Locator files (such as log and license files) will be written. If the directory is
+     * unspecified, then the working directory defaults to the current directory.
-     * @param workingDirectory a String indicating the pathname of the directory in which the Locator will be ran.
+     * @param workingDirectory a String indicating the pathname of the directory in which the
+     *        Locator will be ran.
-     * @throws IllegalArgumentException wrapping a FileNotFoundException if the working directory pathname cannot be
-     * found.
+     * @throws IllegalArgumentException wrapping a FileNotFoundException if the working directory
+     *         pathname cannot be found.
-      if (!new File(StringUtils.defaultIfBlank(workingDirectory, DEFAULT_WORKING_DIRECTORY)).isDirectory()) {
+      if (!new File(StringUtils.defaultIfBlank(workingDirectory, DEFAULT_WORKING_DIRECTORY))
+          .isDirectory()) {
-          LocalizedStrings.Launcher_Builder_WORKING_DIRECTORY_NOT_FOUND_ERROR_MESSAGE.toLocalizedString("Locator"),
+            LocalizedStrings.Launcher_Builder_WORKING_DIRECTORY_NOT_FOUND_ERROR_MESSAGE
+                .toLocalizedString("Locator"),
-     * @param propertyName a String indicating the name of the GemFire Distributed System property as described in {@link ConfigurationProperties}
+     * @param propertyName a String indicating the name of the GemFire Distributed System property
+     *        as described in {@link ConfigurationProperties}
-     * Validates the configuration settings and properties of this Builder, ensuring that all invariants have been met.
-     * Currently, the only invariant constraining the Builder is that the user must specify the member name for the
-     * Locator in the GemFire distributed system as a command-line argument, or by setting the memberName property
-     * programmatically using the corresponding setter method.  If the member name is not given, then the user must
-     * have specified the pathname to the gemfire.properties file before validate is called.  It is then assumed,
-     * but not further validated, that the user has specified the Locator's member name in the properties file.
+     * Validates the configuration settings and properties of this Builder, ensuring that all
+     * invariants have been met. Currently, the only invariant constraining the Builder is that the
+     * user must specify the member name for the Locator in the GemFire distributed system as a
+     * command-line argument, or by setting the memberName property programmatically using the
+     * corresponding setter method. If the member name is not given, then the user must have
+     * specified the pathname to the gemfire.properties file before validate is called. It is then
+     * assumed, but not further validated, that the user has specified the Locator's member name in
+     * the properties file.
-            && !isSet(loadGemFireProperties(DistributedSystem.getPropertyFileURL()), NAME))
-        {
-          throw new IllegalStateException(LocalizedStrings.Launcher_Builder_MEMBER_NAME_VALIDATION_ERROR_MESSAGE
-            .toLocalizedString("Locator"));
+            && !isSet(loadGemFireProperties(DistributedSystem.getPropertyFileURL()), NAME)) {
+          throw new IllegalStateException(
+              LocalizedStrings.Launcher_Builder_MEMBER_NAME_VALIDATION_ERROR_MESSAGE
+                  .toLocalizedString("Locator"));
-          throw new IllegalStateException(LocalizedStrings.Launcher_Builder_WORKING_DIRECTORY_OPTION_NOT_VALID_ERROR_MESSAGE
-            .toLocalizedString("Locator"));
+          throw new IllegalStateException(
+              LocalizedStrings.Launcher_Builder_WORKING_DIRECTORY_OPTION_NOT_VALID_ERROR_MESSAGE
+                  .toLocalizedString("Locator"));
-     * Validates the Builder configuration settings and then constructs an instance of the LocatorLauncher class
-     * to invoke operations on a GemFire Locator.
+     * Validates the Builder configuration settings and then constructs an instance of the
+     * LocatorLauncher class to invoke operations on a GemFire Locator.
-    START("start", "bind-address", "hostname-for-clients", "port", "force", "debug", "help"),
-    STATUS("status", "bind-address", "port", "member", "pid", "dir", "debug", "help"),
-    STOP("stop", "member", "pid", "dir", "debug", "help"),
-    VERSION("version"),
-    UNSPECIFIED("unspecified");
+    START("start", "bind-address", "hostname-for-clients", "port", "force", "debug",
+        "help"), STATUS("status", "bind-address", "port", "member", "pid", "dir", "debug",
+            "help"), STOP("stop", "member", "pid", "dir", "debug",
+                "help"), VERSION("version"), UNSPECIFIED("unspecified");
-      assert !StringUtils.isBlank(name) : "The name of the locator launcher command must be specified!";
+      assert !StringUtils
+          .isBlank(name) : "The name of the locator launcher command must be specified!";
-        : Collections.<String>emptyList());
+          : Collections.<String>emptyList());
-     * Determines whether the specified name refers to a valid Locator launcher command, as defined by this
-     * enumerated type.
+     * Determines whether the specified name refers to a valid Locator launcher command, as defined
+     * by this enumerated type.
-     * @return a boolean indicating whether the specified name for a Locator launcher command is valid.
+     * @return a boolean indicating whether the specified name for a Locator launcher command is
+     *         valid.
-     * Determines whether the given Locator launcher command has been properly specified.  The command is deemed
-     * unspecified if the reference is null or the Command is UNSPECIFIED.
+     * Determines whether the given Locator launcher command has been properly specified. The
+     * command is deemed unspecified if the reference is null or the Command is UNSPECIFIED.
-     * Looks up a Locator launcher command by name.  The equality comparison on name is case-insensitive.
+     * Looks up a Locator launcher command by name. The equality comparison on name is
+     * case-insensitive.
-     * @return an enumerated type representing the command name or null if the no such command with the specified name
-     * exists.
+     * @return an enumerated type representing the command name or null if the no such command with
+     *         the specified name exists.
-     * Gets a set of valid options that can be used with the Locator launcher command when used from the command-line.
+     * Gets a set of valid options that can be used with the Locator launcher command when used from
+     * the command-line.
-     * @return a Set of Strings indicating the names of the options available to the Locator launcher command.
+     * @return a Set of Strings indicating the names of the options available to the Locator
+     *         launcher command.
-     * @return a boolean value indicating whether this command has the specified named command-line option.
+     * @return a boolean value indicating whether this command has the specified named command-line
+     *         option.
-   * The LocatorState is an immutable type representing the state of the specified Locator at any given moment in time.
-   * The state of the Locator is assessed at the exact moment an instance of this class is constructed.
+   * The LocatorState is an immutable type representing the state of the specified Locator at any
+   * given moment in time. The state of the Locator is assessed at the exact moment an instance of
+   * this class is constructed.
-        
+
-        final List<String> jvmArguments = Arrays.asList(GfJsonArray.toStringArray(
-          gfJsonObject.getJSONArray(JSON_JVMARGUMENTS)));
+        final List<String> jvmArguments =
+            Arrays.asList(GfJsonArray.toStringArray(gfJsonObject.getJSONArray(JSON_JVMARGUMENTS)));
-        return new LocatorState(status, 
-            gfJsonObject.getString(JSON_STATUSMESSAGE),
-            gfJsonObject.getLong(JSON_TIMESTAMP),
-            gfJsonObject.getString(JSON_LOCATION),
-            gfJsonObject.getInt(JSON_PID),
-            gfJsonObject.getLong(JSON_UPTIME),
-            gfJsonObject.getString(JSON_WORKINGDIRECTORY),
-            jvmArguments,
-            gfJsonObject.getString(JSON_CLASSPATH),
-            gfJsonObject.getString(JSON_GEMFIREVERSION),
-            gfJsonObject.getString(JSON_JAVAVERSION),
-            gfJsonObject.getString(JSON_LOGFILE),
-            gfJsonObject.getString(JSON_HOST),
-            gfJsonObject.getString(JSON_PORT),
+        return new LocatorState(status, gfJsonObject.getString(JSON_STATUSMESSAGE),
+            gfJsonObject.getLong(JSON_TIMESTAMP), gfJsonObject.getString(JSON_LOCATION),
+            gfJsonObject.getInt(JSON_PID), gfJsonObject.getLong(JSON_UPTIME),
+            gfJsonObject.getString(JSON_WORKINGDIRECTORY), jvmArguments,
+            gfJsonObject.getString(JSON_CLASSPATH), gfJsonObject.getString(JSON_GEMFIREVERSION),
+            gfJsonObject.getString(JSON_JAVAVERSION), gfJsonObject.getString(JSON_LOGFILE),
+            gfJsonObject.getString(JSON_HOST), gfJsonObject.getString(JSON_PORT),
-      }
-      catch (GfJsonException e) {
-        throw new IllegalArgumentException("Unable to create LocatorStatus from JSON: ".concat(json), e);
+      } catch (GfJsonException e) {
+        throw new IllegalArgumentException(
+            "Unable to create LocatorStatus from JSON: ".concat(json), e);
-      // if status is NOT_RESPONDING then this is executing inside the JVM asking for he status; pid etc will be set according to the caller's JVM instead
-      this(status,
-        launcher.statusMessage,
-        System.currentTimeMillis(),
-        launcher.getId(),
-        identifyPid(),
-        ManagementFactory.getRuntimeMXBean().getUptime(),
-        launcher.getWorkingDirectory(),
-        ManagementFactory.getRuntimeMXBean().getInputArguments(),
-        System.getProperty("java.class.path"),
-        GemFireVersion.getGemFireVersion(),
-        System.getProperty("java.version"),
-        getLogFileCanonicalPath(launcher),
-        launcher.getBindAddressAsString(),
-        launcher.getPortAsString(),
-        launcher.getMemberName());
+      // if status is NOT_RESPONDING then this is executing inside the JVM asking for he status; pid
+      // etc will be set according to the caller's JVM instead
+      this(status, launcher.statusMessage, System.currentTimeMillis(), launcher.getId(),
+          identifyPid(), ManagementFactory.getRuntimeMXBean().getUptime(),
+          launcher.getWorkingDirectory(), ManagementFactory.getRuntimeMXBean().getInputArguments(),
+          System.getProperty("java.class.path"), GemFireVersion.getGemFireVersion(),
+          System.getProperty("java.version"), getLogFileCanonicalPath(launcher),
+          launcher.getBindAddressAsString(), launcher.getPortAsString(), launcher.getMemberName());
-    
-    public LocatorState(final LocatorLauncher launcher, final Status status, final String errorMessage) {
+
+    public LocatorState(final LocatorLauncher launcher, final Status status,
+        final String errorMessage) {
-    
+
-          final String logFileCanonicalPath = IOUtils.tryGetCanonicalPathElseGetAbsolutePath(logFile);
-          if (!StringUtils.isBlank(logFileCanonicalPath)) { // this is probably not need but a safe check none-the-less.
+          final String logFileCanonicalPath =
+              IOUtils.tryGetCanonicalPathElseGetAbsolutePath(logFile);
+          if (!StringUtils.isBlank(logFileCanonicalPath)) { // this is probably not need but a safe
+                                                            // check none-the-less.
-        final String portAsString =  String.valueOf(locator.getPort());
+        final String portAsString = String.valueOf(locator.getPort());
-    protected LocatorState(final Status status,
-                           final String statusMessage,
-                           final long timestamp,
-                           final String locatorLocation,
-                           final Integer pid,
-                           final Long uptime,
-                           final String workingDirectory,
-                           final List<String> jvmArguments,
-                           final String classpath,
-                           final String gemfireVersion,
-                           final String javaVersion,
-                           final String logFile,
-                           final String host,
-                           final String port,
-                           final String memberName)
-    {
-      super(status, statusMessage, timestamp, locatorLocation, pid, uptime, workingDirectory, jvmArguments, classpath,
-        gemfireVersion, javaVersion, logFile, host, port, memberName);
+    protected LocatorState(final Status status, final String statusMessage, final long timestamp,
+        final String locatorLocation, final Integer pid, final Long uptime,
+        final String workingDirectory, final List<String> jvmArguments, final String classpath,
+        final String gemfireVersion, final String javaVersion, final String logFile,
+        final String host, final String port, final String memberName) {
+      super(status, statusMessage, timestamp, locatorLocation, pid, uptime, workingDirectory,
+          jvmArguments, classpath, gemfireVersion, javaVersion, logFile, host, port, memberName);
-    private LocatorState(final LocatorLauncher launcher, final Status status, final LocatorStatusResponse response) {
-      this(status,
-        launcher.statusMessage,
-        System.currentTimeMillis(),
-        launcher.getId(),
-        response.getPid(),
-        response.getUptime(),
-        response.getWorkingDirectory(),
-        response.getJvmArgs(),
-        response.getClasspath(),
-        response.getGemFireVersion(),
-        response.getJavaVersion(),
-        response.getLogFile(),
-        response.getHost(),
-        String.valueOf(response.getPort()),
-        response.getName());
+    private LocatorState(final LocatorLauncher launcher, final Status status,
+        final LocatorStatusResponse response) {
+      this(status, launcher.statusMessage, System.currentTimeMillis(), launcher.getId(),
+          response.getPid(), response.getUptime(), response.getWorkingDirectory(),
+          response.getJvmArgs(), response.getClasspath(), response.getGemFireVersion(),
+          response.getJavaVersion(), response.getLogFile(), response.getHost(),
+          String.valueOf(response.getPort()), response.getName());

UPD66 INS66 UPD66 INS66 UPD66 INS66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 INS66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 INS66 UPD66 INS66 UPD66 INS66 UPD66 INS66 UPD66 INS66 UPD66 INS66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 INS66 UPD66 INS66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 INS66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 INS66 UPD66 INS66 UPD66 INS66
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

-* Licensed to the Apache Software Foundation (ASF) under one or more
-* contributor license agreements.  See the NOTICE file distributed with
-* this work for additional information regarding copyright ownership.
-* The ASF licenses this file to You under the Apache License, Version 2.0
-* (the "License"); you may not use this file except in compliance with
-* the License.  You may obtain a copy of the License at
-*
-*      http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
- * This class implements the session management using a Gemfire distributedCache
- * as a persistent store for the session objects
+ * This class implements the session management using a Gemfire distributedCache as a persistent
+ * store for the session objects
-   * Boolean indicating whether this manager is defined in the same context (war
-   * / classloader) as the filter.
+   * Boolean indicating whether this manager is defined in the same context (war / classloader) as
+   * the filter.
-  private Map<String, String> nativeSessionMap =
-      new HashMap<String, String>();
+  private Map<String, String> nativeSessionMap = new HashMap<String, String>();
-   * This CL is used to compare against the class loader of attributes getting
-   * pulled out of the cache. This variable should be set to the CL of the
-   * filter running everything.
+   * This CL is used to compare against the class loader of attributes getting pulled out of the
+   * cache. This variable should be set to the CL of the filter running everything.
-      new TypeAwareMap<CacheProperty, Object>(CacheProperty.class) {{
-        put(CacheProperty.REGION_NAME, RegionHelper.NAME + "_sessions");
-        put(CacheProperty.ENABLE_GATEWAY_DELTA_REPLICATION, Boolean.FALSE);
-        put(CacheProperty.ENABLE_GATEWAY_REPLICATION, Boolean.FALSE);
-        put(CacheProperty.ENABLE_DEBUG_LISTENER, Boolean.FALSE);
-        put(CacheProperty.STATISTICS_NAME, "gemfire_statistics");
-        put(CacheProperty.SESSION_DELTA_POLICY, "delta_queued");
-        put(CacheProperty.REPLICATION_TRIGGER, "set");
-        /**
-         * For REGION_ATTRIBUTES_ID and ENABLE_LOCAL_CACHE the default
-         * is different for ClientServerCache and PeerToPeerCache
-         * so those values are set in the relevant constructors when
-         * these properties are passed in to them.
-         */
-      }};
+      new TypeAwareMap<CacheProperty, Object>(CacheProperty.class) {
+        {
+          put(CacheProperty.REGION_NAME, RegionHelper.NAME + "_sessions");
+          put(CacheProperty.ENABLE_GATEWAY_DELTA_REPLICATION, Boolean.FALSE);
+          put(CacheProperty.ENABLE_GATEWAY_REPLICATION, Boolean.FALSE);
+          put(CacheProperty.ENABLE_DEBUG_LISTENER, Boolean.FALSE);
+          put(CacheProperty.STATISTICS_NAME, "gemfire_statistics");
+          put(CacheProperty.SESSION_DELTA_POLICY, "delta_queued");
+          put(CacheProperty.REPLICATION_TRIGGER, "set");
+          /**
+           * For REGION_ATTRIBUTES_ID and ENABLE_LOCAL_CACHE the default is different for
+           * ClientServerCache and PeerToPeerCache so those values are set in the relevant
+           * constructors when these properties are passed in to them.
+           */
+        }
+      };
-    String sessionCookieName = config.getInitParameter(
-        INIT_PARAM_SESSION_COOKIE_NAME);
+    String sessionCookieName = config.getInitParameter(INIT_PARAM_SESSION_COOKIE_NAME);
-    LOG.info("Started GemfireSessionManager (isolated={}, jvmId={})",
-        isolated, jvmId);
+    LOG.info("Started GemfireSessionManager (isolated={}, jvmId={})", isolated, jvmId);
-    GemfireHttpSession session = (GemfireHttpSession) sessionCache.getOperatingRegion().get(
-        id);
+    GemfireHttpSession session = (GemfireHttpSession) sessionCache.getOperatingRegion().get(id);
-        LOG.debug("Recovered serialized session {} (jvmId={})", id,
-            session.getJvmOwnerId());
+        LOG.debug("Recovered serialized session {} (jvmId={})", id, session.getJvmOwnerId());
-    GemfireHttpSession session =
-        new GemfireHttpSession(id, nativeSession);
+    GemfireHttpSession session = new GemfireHttpSession(id, nativeSession);
-    if ("delta_queued".equals(
-        properties.get(CacheProperty.SESSION_DELTA_POLICY))) {
+    if ("delta_queued".equals(properties.get(CacheProperty.SESSION_DELTA_POLICY))) {
-      ((DeltaQueuedSessionAttributes) attributes).setReplicationTrigger(
-          (String) properties.get(CacheProperty.REPLICATION_TRIGGER));
-    } else if ("delta_immediate".equals(
-        properties.get(CacheProperty.SESSION_DELTA_POLICY))) {
+      ((DeltaQueuedSessionAttributes) attributes)
+          .setReplicationTrigger((String) properties.get(CacheProperty.REPLICATION_TRIGGER));
+    } else if ("delta_immediate".equals(properties.get(CacheProperty.SESSION_DELTA_POLICY))) {
-    } else if ("immediate".equals(
-        properties.get(CacheProperty.SESSION_DELTA_POLICY))) {
+    } else if ("immediate".equals(properties.get(CacheProperty.SESSION_DELTA_POLICY))) {
-      LOG.warn(
-          "No session delta policy specified - using default of 'delta_immediate'");
+      LOG.warn("No session delta policy specified - using default of 'delta_immediate'");
-        GemfireHttpSession session = (GemfireHttpSession) sessionCache.getOperatingRegion().get(
-            id);
+        GemfireHttpSession session = (GemfireHttpSession) sessionCache.getOperatingRegion().get(id);
-        GemfireHttpSession session = (GemfireHttpSession) sessionCache.getOperatingRegion().get(
-            id);
+        GemfireHttpSession session = (GemfireHttpSession) sessionCache.getOperatingRegion().get(id);
-   * This method is called when a native session gets destroyed. It will check
-   * if the GemFire session is actually still valid/not expired and will then
-   * attach a new, native session.
+   * This method is called when a native session gets destroyed. It will check if the GemFire
+   * session is actually still valid/not expired and will then attach a new, native session.
-   * @return the id of the newly attached native session or null if the GemFire
-   * session was already invalid
+   * @return the id of the newly attached native session or null if the GemFire session was already
+   *         invalid
-    GemfireHttpSession session = (GemfireHttpSession) sessionCache.getOperatingRegion().get(
-        gemfireId);
+    GemfireHttpSession session =
+        (GemfireHttpSession) sessionCache.getOperatingRegion().get(gemfireId);
-      LOG.error("No 'cache-type' initialization param set. "
-          + "Cache will not be started");
+      LOG.error("No 'cache-type' initialization param set. " + "Cache will not be started");
-       * Process all the init params and see if any apply to the
-       * distributed system.
+       * Process all the init params and see if any apply to the distributed system.
-      for (Enumeration<String> e = config.getInitParameterNames(); e.hasMoreElements(); ) {
+      for (Enumeration<String> e = config.getInitParameterNames(); e.hasMoreElements();) {
-        LOG.info("Setting gemfire property: {} = {}",
-            gemfireProperty, config.getInitParameter(param));
-        distributedCache.setProperty(gemfireProperty,
+        LOG.info("Setting gemfire property: {} = {}", gemfireProperty,
+        distributedCache.setProperty(gemfireProperty, config.getInitParameter(param));
-      throw new IllegalStateException("No cache exists. Please configure "
-          + "either a PeerToPeerCacheLifecycleListener or "
-          + "ClientServerCacheLifecycleListener in the "
-          + "server.xml file.");
+      throw new IllegalStateException(
+          "No cache exists. Please configure " + "either a PeerToPeerCacheLifecycleListener or "
+              + "ClientServerCacheLifecycleListener in the " + "server.xml file.");
-    for (Enumeration<String> e = config.getInitParameterNames(); e.hasMoreElements(); ) {
+    for (Enumeration<String> e = config.getInitParameterNames(); e.hasMoreElements();) {
-      LOG.info("Setting cache parameter: {} = {}",
-          gemfireWebParam, config.getInitParameter(param));
+      LOG.info("Setting cache parameter: {} = {}", gemfireWebParam, config.getInitParameter(param));
-    sessionCache = cache.isClient()
-        ? new ClientServerSessionCache(cache, properties)
+    sessionCache = cache.isClient() ? new ClientServerSessionCache(cache, properties)
-      MBeanServer mbs = MBeanServer.class.cast(
-          ctx.lookup("java:comp/env/jmx/runtime"));
-      ObjectName oname = new ObjectName(
-          Constants.SESSION_STATISTICS_MBEAN_NAME);
+      MBeanServer mbs = MBeanServer.class.cast(ctx.lookup("java:comp/env/jmx/runtime"));
+      ObjectName oname = new ObjectName(Constants.SESSION_STATISTICS_MBEAN_NAME);
-      LOG.warn("Unable to register statistics MBean. Error: {}",
-          ex.getMessage());
+      LOG.warn("Unable to register statistics MBean. Error: {}", ex.getMessage());

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66
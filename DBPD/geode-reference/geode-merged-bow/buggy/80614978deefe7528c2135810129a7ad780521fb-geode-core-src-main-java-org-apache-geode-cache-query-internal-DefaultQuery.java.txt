GEODE-5568: Rewrite QueryMonitor to use ScheduledThreadPoolExecutor (#2744)

* GEODE-5568: Rewrite QueryMonitor to use ScheduledThreadPoolExecutor

Eliminate notify/wait bugs and improve hot-path performance.

Co-authored-by: Bill Burcham <bburcham@pivotal.io>
Co-authored-by: Ryan McMahon <rmcmahon@pivotal.io>
+import java.util.Optional;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.atomic.AtomicBoolean;
+  private Optional<ScheduledFuture> expirationTask;
+
-  private volatile boolean isCanceled = false;
-
-  private CacheRuntimeException canceledException;
-
-  /**
-   * This is declared as array so that it can be synchronized between two threads to validate the
-   * state.
-   */
-  private final boolean[] queryCompletedForMonitoring = new boolean[] {false};
+  private volatile CacheRuntimeException queryCancelledException;
+  static final ThreadLocal<AtomicBoolean> queryCanceled =
+      ThreadLocal.withInitial(AtomicBoolean::new);
+
+  public Optional<ScheduledFuture> getCancelationTask() {
+    return expirationTask;
+  }
+
+  public void setCancelationTask(final ScheduledFuture expirationTask) {
+    this.expirationTask = Optional.of(expirationTask);
+  }
+    this.expirationTask = Optional.empty();
-        queryMonitor.monitorQueryThread(Thread.currentThread(), this);
+        queryMonitor.monitorQueryThread(this);
-      // query execution canceled exception will be thrown from the QueryMonitor
-      // canceled exception should not be null at this point as it should be set
-      // when query is canceled.
-      if (this.canceledException != null) {
-        throw this.canceledException;
-      } else {
-        throw new QueryExecutionCanceledException(
-            "Query was canceled. It may be due to low memory or the query was running longer than the MAX_QUERY_EXECUTION_TIME.");
-      }
+      return reinterpretQueryExecutionCanceledException();
-        queryMonitor.stopMonitoringQueryThread(Thread.currentThread(), this);
+        queryMonitor.stopMonitoringQueryThread(this);
+   * This method attempts to reintrepret a {@link QueryExecutionCanceledException} using the
+   * the value returned by {@link #getQueryCanceledException} (set by the {@link QueryMonitor}).
+   *
+   * @throws if {@link #getQueryCanceledException} doesn't return {@code null} then throw that
+   *         {@link CacheRuntimeException}, otherwise throw {@link QueryExecutionCanceledException}
+   */
+  private Object reinterpretQueryExecutionCanceledException() {
+    final CacheRuntimeException queryCanceledException = getQueryCanceledException();
+    if (queryCanceledException != null) {
+      throw queryCanceledException;
+    } else {
+      throw new QueryExecutionCanceledException(
+          "Query was canceled. It may be due to low memory or the query was running longer than the MAX_QUERY_EXECUTION_TIME.");
+    }
+  }
+
+  /**
-      queryMonitor.monitorQueryThread(Thread.currentThread(), this);
+      queryMonitor.monitorQueryThread(this);
-        queryMonitor.stopMonitoringQueryThread(Thread.currentThread(), this);
+        queryMonitor.stopMonitoringQueryThread(this);
-        // query execution canceled exception will be thrown from the QueryMonitor
-        // canceled exception should not be null at this point as it should be set
-        // when query is canceled.
-        if (this.canceledException != null) {
-          throw this.canceledException;
-        } else {
-          throw new QueryExecutionCanceledException(
-              "Query was canceled. It may be due to low memory or the query was running longer than the MAX_QUERY_EXECUTION_TIME.");
-        }
+        reinterpretQueryExecutionCanceledException();
+      queryCanceled.remove();
-    return this.isCanceled;
+    return getQueryCanceledException() != null;
-    return this.canceledException;
-  }
-
-  boolean[] getQueryCompletedForMonitoring() {
-    return this.queryCompletedForMonitoring;
-  }
-
-  // TODO: parameter value is always true
-  void setQueryCompletedForMonitoring(boolean value) {
-    this.queryCompletedForMonitoring[0] = value;
+    return queryCancelledException;
-  public void setCanceled(CacheRuntimeException canceledException) {
-    this.isCanceled = true;
-    this.canceledException = canceledException;
+  public void setQueryCanceledException(final CacheRuntimeException queryCanceledException) {
+    this.queryCancelledException = queryCanceledException;
-    sb.append(this.isCanceled);
+    sb.append(this.isCanceled());

INS26 INS26 INS26 MOV23 MOV23 MOV31 MOV31 INS40 INS40 INS40 INS31 INS74 INS83 INS43 UPD83 INS74 INS83 INS74 INS42 INS8 UPD39 UPD42 INS44 INS29 UPD83 INS43 INS42 INS8 MOV29 INS83 INS39 UPD42 INS83 MOV43 UPD42 UPD42 INS43 INS43 UPD42 INS42 UPD42 INS43 INS43 UPD42 INS32 INS43 INS43 INS41 INS83 INS43 INS42 INS21 INS21 INS65 INS65 INS42 INS60 INS25 MOV25 INS41 INS83 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS89 INS42 INS42 INS42 INS42 INS7 INS7 INS66 INS65 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS65 INS83 MOV43 INS59 INS27 INS8 MOV8 INS27 INS42 INS43 INS22 INS32 INS22 INS32 INS8 INS42 INS67 INS42 INS67 INS66 INS42 INS42 INS42 INS32 INS42 INS33 INS53 MOV25 INS21 INS32 INS33 UPD42 INS32 INS42 MOV52 UPD42 MOV42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS41 INS42 INS42 INS42 INS42 INS32 INS42 UPD42 INS52 INS42 INS32 UPD42 INS8 INS42 INS42 INS42 INS21 UPD42 INS32 INS42 DEL83 DEL39 DEL9 DEL66 DEL66 DEL65 DEL29 DEL39 DEL85 DEL5 DEL39 DEL85 DEL5 DEL9 DEL4 DEL3 DEL22 DEL41 DEL42 DEL42 DEL32 DEL52 DEL42 DEL22 DEL33 DEL27 DEL52 DEL42 DEL22 DEL53 DEL8 DEL25 DEL8 DEL42 DEL42 DEL32 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL52 DEL42 DEL22 DEL33 DEL27 DEL52 DEL42 DEL22 DEL53 DEL8 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL8 DEL39 DEL85 DEL5 DEL52 DEL42 DEL22 DEL39 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL34 DEL2 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL52 DEL42 DEL22
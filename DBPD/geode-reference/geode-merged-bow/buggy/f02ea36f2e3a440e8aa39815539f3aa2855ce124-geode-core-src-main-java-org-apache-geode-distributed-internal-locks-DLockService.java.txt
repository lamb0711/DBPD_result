GEODE-2024 Deadlock creating a new lock service Grantor

This change-set causes the code in TXLockServiceImpl.release() to
perform periodic checks to see if grantor recovery is being performed.
If so it skips releaseTryLocks, which requires a recovered grantor to
function.  This is in line with the previous attempts to fix this
problem.  The recovery message that is trying to obtain the recovery
write-lock now sets the "recovering" state in TXLockServiceImpl prior
to attempting to get the lock so that it is set when
TXLockServiceImpl.release() checks its state.

-import org.apache.geode.*;
-import org.apache.geode.distributed.*;
+import org.apache.geode.CancelCriterion;
+import org.apache.geode.CancelException;
+import org.apache.geode.InternalGemFireError;
+import org.apache.geode.InternalGemFireException;
+import org.apache.geode.StatisticsFactory;
+import org.apache.geode.SystemFailure;
+import org.apache.geode.distributed.DistributedLockService;
+import org.apache.geode.distributed.DistributedSystem;
+import org.apache.geode.distributed.DistributedSystemDisconnectedException;
+import org.apache.geode.distributed.LeaseExpiredException;
+import org.apache.geode.distributed.LockNotHeldException;
+import org.apache.geode.distributed.LockServiceDestroyedException;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
-              waitForLockGrantorFutureResult(lockGrantorFutureResultRef);
+              waitForLockGrantorFutureResult(lockGrantorFutureResultRef, 0, TimeUnit.MILLISECONDS);
-   * 
+   *
+   * @param timeToWait how many ms to wait, 0 = forever
+   * @param timeUnit the unit of measure for timeToWait
-  private LockGrantorId waitForLockGrantorFutureResult(FutureResult lockGrantorFutureResultRef) {
+  private LockGrantorId waitForLockGrantorFutureResult(FutureResult lockGrantorFutureResultRef,
+      long timeToWait, final TimeUnit timeUnit) {
-        lockGrantorIdRef = (LockGrantorId) lockGrantorFutureResultRef.get();
+        if (timeToWait == 0) {
+          lockGrantorIdRef = (LockGrantorId) lockGrantorFutureResultRef.get();
+        } else {
+          lockGrantorIdRef = (LockGrantorId) lockGrantorFutureResultRef.get(timeToWait, timeUnit);
+        }
+      } catch (TimeoutException e) {
+        break;
-  private void notLockGrantorId(LockGrantorId notLockGrantorId, boolean waitForGrantor) {
+  /**
+   * nulls out grantor to force call to elder
+   * 
+   * @param timeToWait how long to wait for a new grantor. -1 don't wait, 0 no time limit
+   * @param timeUnit the unit of measure of timeToWait
+   */
+  private void notLockGrantorId(LockGrantorId notLockGrantorId, long timeToWait,
+      final TimeUnit timeUnit) {
-        if (waitForGrantor) { // fix for bug #43708
-          waitForLockGrantorFutureResult(lockGrantorFutureResultRef);
+        if (timeToWait >= 0) {
+          waitForLockGrantorFutureResult(lockGrantorFutureResultRef, timeToWait, timeUnit);
-          waitForLockGrantorFutureResult(lockGrantorFutureResultRef);
+          waitForLockGrantorFutureResult(lockGrantorFutureResultRef, 0, TimeUnit.MILLISECONDS);
-   * 
+   *
-
-
-              }
-
-              else if (isDestroyed()) {
+              } else if (isDestroyed()) {
-              }
-
-              else {
+              } else {
-            notLockGrantorId(theLockGrantorId, true);
+            notLockGrantorId(theLockGrantorId, 0, TimeUnit.MILLISECONDS);
-              notLockGrantorId(theLockGrantorId, true);
+              notLockGrantorId(theLockGrantorId, 0, TimeUnit.MILLISECONDS);
-            notLockGrantorId(theLockGrantorId, true);
+            notLockGrantorId(theLockGrantorId, 0, TimeUnit.MILLISECONDS);
-  public void releaseTryLocks(DLockBatchId batchId, boolean onlyIfSameGrantor) {
+  public void releaseTryLocks(DLockBatchId batchId, Callable<Boolean> untilCondition) {
+        try {
+          boolean quit = untilCondition.call();
+          if (quit) {
+            return;
+          }
+        } catch (Exception e) {
+          throw new InternalGemFireException("unexpected exception", e);
+        }
-        if (onlyIfSameGrantor) { // this was a fix for bug #38763, from r19555
-          theLockGrantorId = batchId.getLockGrantorId();
-          synchronized (this.lockGrantorIdLock) {
-            if (!checkLockGrantorId(theLockGrantorId)) {
-              // the grantor is different so break and skip DLockReleaseProcessor
-              break;
-            }
+        theLockGrantorId = batchId.getLockGrantorId();
+        synchronized (this.lockGrantorIdLock) {
+          if (!checkLockGrantorId(theLockGrantorId)) {
+            // the grantor is different so break and skip DLockReleaseProcessor
+            break;
-        } else {
-          theLockGrantorId = getLockGrantorId();
-          final boolean waitForGrantor = onlyIfSameGrantor; // fix for bug #43708
-          notLockGrantorId(theLockGrantorId, waitForGrantor);
+          notLockGrantorId(theLockGrantorId, 100, TimeUnit.MILLISECONDS);
-          notLockGrantorId(theLockGrantorId, true);
+          notLockGrantorId(theLockGrantorId, 0, TimeUnit.MILLISECONDS);
-            notLockGrantorId(theLockGrantorId, true); // nulls out grantor to force call to elder
+            notLockGrantorId(theLockGrantorId, 0, TimeUnit.MILLISECONDS); // nulls out grantor to
+                                                                          // force call to elder

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 INS40 INS40 INS40 INS44 INS44 INS29 INS44 INS65 INS65 INS39 INS42 INS83 INS43 INS42 INS65 INS65 INS65 UPD39 UPD42 INS83 INS43 INS42 INS74 INS42 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS43 INS43 INS42 INS42 INS8 INS12 MOV21 INS25 INS44 INS8 INS54 MOV21 MOV51 INS27 MOV8 INS8 INS43 INS42 INS10 INS27 INS8 INS12 INS42 INS34 INS21 INS42 INS42 INS34 INS60 INS25 INS44 INS8 INS7 INS39 INS59 INS42 MOV8 INS43 INS42 INS53 INS42 INS11 INS42 INS42 INS34 INS40 INS42 INS32 INS41 INS42 INS14 INS34 INS40 INS34 INS40 INS43 INS32 INS42 INS42 INS43 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS40 INS42 INS34 INS40 INS34 INS40 INS34 INS40 INS34 INS40 DEL42 DEL9 DEL9 DEL9 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL83 DEL39 DEL42 DEL42 DEL59 DEL60 DEL42 DEL9 DEL9
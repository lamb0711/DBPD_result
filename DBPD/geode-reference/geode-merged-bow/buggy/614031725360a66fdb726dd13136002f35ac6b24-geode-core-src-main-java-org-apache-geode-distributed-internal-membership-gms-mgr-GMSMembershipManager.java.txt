GEODE-2865 data loss in initial-image replication with multicast

The state-flush algorithm relies on MembershipManager.waitForMessageState()
to ensure that all operations have been received and applied to the cache
prior to state replication starting.  For multicast there was a flaw in
the algorithm caused by two things: 1) cache operations were being sent
out-of-band, allowing them to be processed out of order with the state-
flush message, and 2) JGroupsMessenger was only waiting for the messages
to be dispatched by NAKACK2, which isn't necessarily the same as being
dispatched to the DistributionManager Executor that processes the message.

Cache operation messages are now sent in-band.

JGroupsMessenger now tracks NAKACK2 (multicast) sequence numbers of
messages dispatched to the DistributionManager and this is used in
waitForMessageState() to make sure the messages have been queued.
If multicast is enabled we now flush the serial executor to in
waitForMessageState() to make sure that all messages queued in it have
been applied to the region.

+
+    if (services.getConfig().getTransport().isMcastEnabled()
+        && !services.getConfig().getDistributionConfig().getDisableTcp()) {
+      // GEODE-2865: wait for scheduled multicast messages to be applied to the cache
+      waitForSerialMessageProcessing((InternalDistributedMember) otherMember);
+    }
-        // run a message through the member's serial execution queue to ensure that all of its
-        // current messages have been processed
-        OverflowQueueWithDMStats serialQueue = listener.getDM().getSerialQueue(idm);
-        if (serialQueue != null) {
-          final boolean done[] = new boolean[1];
-          final FlushingMessage msg = new FlushingMessage(done);
-          serialQueue.add(new SizeableRunnable(100) {
-            public void run() {
-              msg.invoke();
-            }
-
-            public String toString() {
-              return "Processing fake message";
-            }
-          });
-          synchronized (done) {
-            while (!done[0]) {
-              done.wait(10);
-            }
-            result = true;
-          }
+        if (waitForSerialMessageProcessing(idm)) {
+          result = true;
+  /**
+   * wait for serial executor messages from the given member to be processed
+   */
+  public boolean waitForSerialMessageProcessing(InternalDistributedMember idm)
+      throws InterruptedException {
+    // run a message through the member's serial execution queue to ensure that all of its
+    // current messages have been processed
+    boolean result = false;
+    OverflowQueueWithDMStats serialQueue = listener.getDM().getSerialQueue(idm);
+    if (serialQueue != null) {
+      final boolean done[] = new boolean[1];
+      final FlushingMessage msg = new FlushingMessage(done);
+      serialQueue.add(new SizeableRunnable(100) {
+        public void run() {
+          msg.invoke();
+        }
+
+        public String toString() {
+          return "Processing fake message";
+        }
+      });
+      synchronized (done) {
+        while (!done[0]) {
+          done.wait(10);
+        }
+        result = true;
+      }
+    }
+    return result;
+  }
+

INS31 INS29 INS83 INS39 INS42 INS44 INS43 MOV8 INS25 INS65 INS43 INS42 INS42 INS60 INS41 INS27 INS8 INS66 INS42 INS39 INS59 INS42 INS32 INS38 INS21 INS25 INS42 INS9 INS32 INS42 INS32 INS32 MOV38 INS8 INS32 INS42 INS32 INS42 INS42 INS11 MOV25 INS42 INS42 INS32 INS42 INS43 INS42 INS32 INS8 INS42 INS42 INS42 INS42 INS42 INS21 INS7 INS42 INS9
GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

-
+import static org.apache.geode.internal.offheap.annotations.OffHeapIdentifier.*;
+
+import java.io.IOException;
+import java.util.Arrays;
+
+import org.apache.logging.log4j.Logger;
+
-import org.apache.geode.cache.*;
+import org.apache.geode.cache.CacheWriterException;
+import org.apache.geode.cache.EntryEvent;
+import org.apache.geode.cache.EntryNotFoundException;
+import org.apache.geode.cache.Operation;
+import org.apache.geode.cache.TimeoutException;
-import org.apache.geode.internal.*;
+import org.apache.geode.internal.Assert;
+import org.apache.geode.internal.ByteArrayDataInput;
+import org.apache.geode.internal.HeapDataOutputStream;
+import org.apache.geode.internal.InternalDataSerializer;
+import org.apache.geode.internal.InternalStatisticsDisabledException;
+import org.apache.geode.internal.Version;
-import org.apache.geode.internal.cache.versions.*;
+import org.apache.geode.internal.cache.versions.ConcurrentCacheModificationException;
+import org.apache.geode.internal.cache.versions.RegionVersionVector;
+import org.apache.geode.internal.cache.versions.VersionSource;
+import org.apache.geode.internal.cache.versions.VersionStamp;
+import org.apache.geode.internal.cache.versions.VersionTag;
-import org.apache.geode.internal.offheap.*;
+import org.apache.geode.internal.offheap.MemoryAllocator;
+import org.apache.geode.internal.offheap.MemoryAllocatorImpl;
+import org.apache.geode.internal.offheap.OffHeapHelper;
+import org.apache.geode.internal.offheap.ReferenceCountHelper;
+import org.apache.geode.internal.offheap.Releasable;
+import org.apache.geode.internal.offheap.StoredObject;
-import org.apache.logging.log4j.Logger;
-
-import java.io.IOException;
-import java.util.Arrays;
-
-import static org.apache.geode.internal.offheap.annotations.OffHeapIdentifier.ABSTRACT_REGION_ENTRY_FILL_IN_VALUE;
-import static org.apache.geode.internal.offheap.annotations.OffHeapIdentifier.ABSTRACT_REGION_ENTRY_PREPARE_VALUE_FOR_CACHE;
- *
- *
-
-   * lastModicationTime.
+   * lastModificationTime.
+
-  private static final long TOMBSTONE_SCHEDULED = 0x04L << 56;
+
+
+
+
-  protected static final long IN_USE_BY_TX = 0x40L << 56;
-
-
-  protected static final long MARKED_FOR_EVICTION = 0x80L << 56;
-  // public Exception removeTrace; // debugging hot loop in AbstractRegionMap.basicPut()
+  private static final long IN_USE_BY_TX = 0x40L << 56;
-    setValue(context, this.prepareValueForCache(context, value, false), false);
-    // setLastModified(System.currentTimeMillis()); [bruce] this must be set later so we can use ==0
+    setValue(context, prepareValueForCache(context, value, false), false);
+
+    // setLastModified(System.currentTimeMillis()); this must be set later so we can use ==0
-  /////////////////////////////////////////////////////////////////////
-  ////////////////////////// instance methods /////////////////////////
-  /////////////////////////////////////////////////////////////////////
-
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "IMSE_DONT_CATCH_IMSE")
+  @Override
+  @SuppressWarnings("IMSE_DONT_CATCH_IMSE")
+  @Override
+  @Override
+  @Override
+  @Override
-  public final void updateStatsForPut(long lastModifiedTime, long lastAccessedTime) {
+  @Override
+  public void updateStatsForPut(long lastModifiedTime, long lastAccessedTime) {
+  @Override
+  @Override
+  @Override
-  public void _removePhase1() {
+  void _removePhase1() {
-    // debugging for 38467 (hot thread in ARM.basicUpdate)
-    // this.removeTrace = new Exception("stack trace for thread " + Thread.currentThread());
-  public void removePhase1(LocalRegion r, boolean isClear) throws RegionClearedException {
+  @Override
+  public void removePhase1(LocalRegion r, boolean clear) throws RegionClearedException {
+  @Override
-    // this.removeTrace = new Exception("stack trace for thread " + Thread.currentThread());
+  @Override
-      boolean newEntry = (getValueAsToken() == Token.REMOVED_PHASE1);
+      boolean newEntry = getValueAsToken() == Token.REMOVED_PHASE1;
-
-      makeTombstone((LocalRegion) e.getRegion(), ((EntryEventImpl) e).getVersionTag());
+      makeTombstone((LocalRegion) e.getRegion(), ((InternalCacheEvent) e).getVersionTag());
-      setValue((LocalRegion) e.getRegion(), v, (EntryEventImpl) e);
+      setValue((RegionEntryContext) e.getRegion(), v, (EntryEventImpl) e);
-  public final boolean isRemoved() {
+  @Override
+  public boolean isRemoved() {
-    return (o == Token.REMOVED_PHASE1) || (o == Token.REMOVED_PHASE2) || (o == Token.TOMBSTONE);
+    return o == Token.REMOVED_PHASE1 || o == Token.REMOVED_PHASE2 || o == Token.TOMBSTONE;
-  public final boolean isDestroyedOrRemoved() {
+  @Override
+  public boolean isDestroyedOrRemoved() {
-  public final boolean isDestroyedOrRemovedButNotTombstone() {
+  @Override
+  public boolean isDestroyedOrRemovedButNotTombstone() {
-  public final boolean isTombstone() {
+  @Override
+  public boolean isTombstone() {
-  public final boolean isRemovedPhase2() {
+  @Override
+  public boolean isRemovedPhase2() {
+  @Override
-      @Retained(ABSTRACT_REGION_ENTRY_FILL_IN_VALUE) InitialImageOperation.Entry dst,
+      @Retained(ABSTRACT_REGION_ENTRY_FILL_IN_VALUE) InitialImageOperation.Entry entry,
-    dst.setSerialized(false); // starting default value
+
+    // starting default value
+    entry.setSerialized(false);
-      v = getValue(region); // OFFHEAP: need to incrc, copy bytes, decrc
+      // OFFHEAP: need to incrc, copy bytes, decrc
+      v = getValue(region);
-    dst.setLastModified(mgr, getLastModified()); // fix for bug 31059
+    entry.setLastModified(mgr, getLastModified()); // fix for bug 31059
-      dst.setInvalid();
+      entry.setInvalid();
-      dst.setLocalInvalid();
+      entry.setLocalInvalid();
-      dst.setTombstone();
+      entry.setTombstone();
-        dst.value = cd.getDeserializedForReading();
+        entry.value = cd.getDeserializedForReading();
-        {
-          Object tmp = cd.getValue();
-          if (tmp instanceof byte[]) {
-            byte[] bb = (byte[]) tmp;
-            dst.value = bb;
-          } else {
-            try {
-              HeapDataOutputStream hdos = new HeapDataOutputStream(Version.CURRENT);
-              BlobHelper.serializeTo(tmp, hdos);
-              hdos.trim();
-              dst.value = hdos;
-            } catch (IOException e) {
-              RuntimeException e2 = new IllegalArgumentException(
-                  LocalizedStrings.AbstractRegionEntry_AN_IOEXCEPTION_WAS_THROWN_WHILE_SERIALIZING
-                      .toLocalizedString());
-              e2.initCause(e);
-              throw e2;
-            }
+        Object tmp = cd.getValue();
+        if (tmp instanceof byte[]) {
+          entry.value = tmp;
+        } else {
+          try {
+            HeapDataOutputStream hdos = new HeapDataOutputStream(Version.CURRENT);
+            BlobHelper.serializeTo(tmp, hdos);
+            hdos.trim();
+            entry.value = hdos;
+          } catch (IOException e) {
+            throw new IllegalArgumentException(
+                LocalizedStrings.AbstractRegionEntry_AN_IOEXCEPTION_WAS_THROWN_WHILE_SERIALIZING
+                    .toLocalizedString(),
+                e);
-          dst.setSerialized(true);
+        entry.setSerialized(true);
-      dst.value = v;
+      entry.value = v;
-      {
-        try {
-          HeapDataOutputStream hdos = new HeapDataOutputStream(Version.CURRENT);
-          BlobHelper.serializeTo(preparedValue, hdos);
-          hdos.trim();
-          dst.value = hdos;
-          dst.setSerialized(true);
-        } catch (IOException e) {
-          RuntimeException e2 = new IllegalArgumentException(
-              LocalizedStrings.AbstractRegionEntry_AN_IOEXCEPTION_WAS_THROWN_WHILE_SERIALIZING
-                  .toLocalizedString());
-          e2.initCause(e);
-          throw e2;
-        }
+      try {
+        HeapDataOutputStream hdos = new HeapDataOutputStream(Version.CURRENT);
+        BlobHelper.serializeTo(preparedValue, hdos);
+        hdos.trim();
+        entry.value = hdos;
+        entry.setSerialized(true);
+      } catch (IOException e) {
+        throw new IllegalArgumentException(
+            LocalizedStrings.AbstractRegionEntry_AN_IOEXCEPTION_WAS_THROWN_WHILE_SERIALIZING
+                .toLocalizedString(),
+            e);
-  public static Object prepareValueForGII(Object v) {
+  static Object prepareValueForGII(Object v) {
+  @Override
-    // Asif: If the thread is an Index Creation Thread & the value obtained is
+
+    // If the thread is an Index Creation Thread & the value obtained is
-    // if ((result == Token.REMOVED_PHASE1 || result == Token.REMOVED_PHASE2) &&
-    // !r.isIndexCreationThread()) {
-    // synchronized (this) {
-    // result = _getValue();
-    // }
-    // }
-    // @todo darrel: This will mark new entries as being recently used
+    // TODO: This will mark new entries as being recently used
-  public void releaseOffHeapRefIfRegionBeingClosedOrDestroyed(RegionEntryContext context,
-      Object ref) {
+  void releaseOffHeapRefIfRegionBeingClosedOrDestroyed(RegionEntryContext context, Object ref) {
-      ((OffHeapRegionEntry) this).release();
+      ((Releasable) this).release();
-  static protected Object compress(RegionEntryContext context, Object value) {
+  protected static Object compress(RegionEntryContext context, Object value) {
-  static protected Object compress(RegionEntryContext context, Object value, EntryEventImpl event) {
+  protected static Object compress(RegionEntryContext context, Object value, EntryEventImpl event) {
-  public final Object getValueInVM(RegionEntryContext context) {
+  @Override
+  public Object getValueInVM(RegionEntryContext context) {
-    if (v == null) { // should only be possible if disk entry
+    if (v == null) {
+      // should only be possible if disk entry
+  @Override
-    // if (result instanceof ByteSource) {
-    // // If the ByteSource contains a Delta or ListOfDelta then we want to deserialize it
-    // Object deserVal = ((CachedDeserializable)result).getDeserializedForReading();
-    // if (deserVal != result) {
-    // OffHeapHelper.release(result);
-    // result = deserVal;
-    // }
-    // }
+  @Override
-  public Object getSerializedValueOnDisk(final LocalRegion r) throws EntryNotFoundException {
+  @Override
+  public Object getSerializedValueOnDisk(final LocalRegion localRegion)
+      throws EntryNotFoundException {
+  @Override
-    // @todo darrel if value is Token.REMOVED || Token.DESTROYED throw EntryNotFoundException
+    // TODO: if value is Token.REMOVED || Token.DESTROYED throw EntryNotFoundException
-  public final boolean initialImagePut(final LocalRegion region, final long lastModifiedTime,
-      Object newValue, boolean wasRecovered, boolean versionTagAccepted)
-      throws RegionClearedException {
+  @Override
+  public boolean initialImagePut(final LocalRegion region, final long lastModified, Object newValue,
+      boolean wasRecovered, boolean acceptedVersionTag) throws RegionClearedException {
-    return initialImageInit(region, lastModifiedTime, newValue, this.isTombstone(), wasRecovered,
-        versionTagAccepted);
+    return initialImageInit(region, lastModified, newValue, this.isTombstone(), wasRecovered,
+        acceptedVersionTag);
-  public boolean initialImageInit(final LocalRegion region, final long lastModifiedTime,
+  @Override
+  public boolean initialImageInit(final LocalRegion region, final long lastModified,
-      final boolean versionTagAccepted) throws RegionClearedException {
+      final boolean acceptedVersionTag) throws RegionClearedException {
+
+
-    if (versionTagAccepted || create || (vTok != Token.DESTROYED || vTok != Token.TOMBSTONE)) { // OFFHEAP
-                                                                                                // noop
+    if (acceptedVersionTag || create || (vTok != Token.DESTROYED || vTok != Token.TOMBSTONE)) {
+      // OFFHEAP noop
-      boolean putValue = versionTagAccepted || create || (newValueToWrite != Token.LOCAL_INVALID
-          && (wasRecovered || (vTok == Token.LOCAL_INVALID))); // OFFHEAP noop
+      // OFFHEAP noop
+      boolean putValue = acceptedVersionTag || create || (newValueToWrite != Token.LOCAL_INVALID
+          && (wasRecovered || (vTok == Token.LOCAL_INVALID)));
-          final Object oldValue = getValueInVM(region); // Heap value should always be deserialized
-                                                        // at this point // OFFHEAP will not be
-                                                        // deserialized
+          // Heap value should always be deserialized at this point // OFFHEAP will not be
+          // deserialized
+          final Object oldValue = getValueInVM(region);
-        if (create || versionTagAccepted) {
+        if (create || acceptedVersionTag) {
-              // Asif: If the region has been issued cleared during
+              // If the region has been issued cleared during
-              newValueToWrite = Token.DESTROYED;
+              newValueToWrite = Token.DESTROYED; // TODO: never used
-          region.updateStatsForPut(this, lastModifiedTime, false);
+          region.updateStatsForPut(this, lastModified, false);
+  @Override
-  public final boolean destroy(LocalRegion region, EntryEventImpl event, boolean inTokenMode,
+  public boolean destroy(LocalRegion region, EntryEventImpl event, boolean inTokenMode,
-    boolean proceed = false;
-    {
-      // A design decision was made to not retrieve the old value from the disk
-      // if the entry has been evicted to only have the CacheListener afterDestroy
-      // method ignore it. We don't want to pay the performance penalty. The
-      // getValueInVM method does not retrieve the value from disk if it has been
-      // evicted. Instead, it uses the NotAvailable token.
-      //
-      // If the region is a WAN queue region, the old value is actually used by the
-      // afterDestroy callback on a secondary. It is not needed on a primary.
-      // Since the destroy that sets WAN_QUEUE_TOKEN always originates on the primary
-      // we only pay attention to WAN_QUEUE_TOKEN if the event is originRemote.
-      //
-      // :ezoerner:20080814 We also read old value from disk or buffer
-      // in the case where there is a non-null expectedOldValue
-      // see PartitionedRegion#remove(Object key, Object value)
-      ReferenceCountHelper.skipRefCountTracking();
-      @Retained
-      @Released
-      Object curValue = _getValueRetain(region, true);
-      ReferenceCountHelper.unskipRefCountTracking();
-      try {
-        if (curValue == null)
-          curValue = Token.NOT_AVAILABLE;
-        if (curValue == Token.NOT_AVAILABLE) {
-          // In some cases we need to get the current value off of disk.
-
-          // if the event is transmitted during GII and has an old value, it was
-          // the state of the transmitting cache's entry & should be used here
-          if (event.getCallbackArgument() != null
-              && event.getCallbackArgument().equals(RegionQueue.WAN_QUEUE_TOKEN)
-              && event.isOriginRemote()) { // check originRemote for bug 40508
-            // curValue = getValue(region); can cause deadlock if GII is occurring
-            curValue = getValueOnDiskOrBuffer(region);
-          } else {
-            FilterProfile fp = region.getFilterProfile();
-            if (fp != null && ((fp.getCqCount() > 0) || expectedOldValue != null)) {
-              // curValue = getValue(region); can cause deadlock will fault in the value
-              // and will confuse LRU. rdubey.
-              curValue = getValueOnDiskOrBuffer(region);
-            }
-          }
-        }
-
-        if (expectedOldValue != null) {
-          if (!checkExpectedOldValue(expectedOldValue, curValue, region)) {
-            throw new EntryNotFoundException(
-                LocalizedStrings.AbstractRegionEntry_THE_CURRENT_VALUE_WAS_NOT_EQUAL_TO_EXPECTED_VALUE
-                    .toLocalizedString());
-          }
-        }
-
-        if (inTokenMode && event.hasOldValue()) {
-          proceed = true;
-        } else {
-          proceed = event.setOldValue(curValue, curValue instanceof GatewaySenderEventImpl)
-              || removeRecoveredEntry || forceDestroy || region.getConcurrencyChecksEnabled() // fix
-                                                                                              // for
-                                                                                              // bug
-                                                                                              // #47868
-                                                                                              // -
-                                                                                              // create
-                                                                                              // a
-                                                                                              // tombstone
-              || (event.getOperation() == Operation.REMOVE // fix for bug #42242
-                  && (curValue == null || curValue == Token.LOCAL_INVALID
-                      || curValue == Token.INVALID));
-        }
-      } finally {
-        OffHeapHelper.releaseWithNoTracking(curValue);
+    // A design decision was made to not retrieve the old value from the disk
+    // if the entry has been evicted to only have the CacheListener afterDestroy
+    // method ignore it. We don't want to pay the performance penalty. The
+    // getValueInVM method does not retrieve the value from disk if it has been
+    // evicted. Instead, it uses the NotAvailable token.
+    //
+    // If the region is a WAN queue region, the old value is actually used by the
+    // afterDestroy callback on a secondary. It is not needed on a primary.
+    // Since the destroy that sets WAN_QUEUE_TOKEN always originates on the primary
+    // we only pay attention to WAN_QUEUE_TOKEN if the event is originRemote.
+    //
+    // We also read old value from disk or buffer
+    // in the case where there is a non-null expectedOldValue
+    // see PartitionedRegion#remove(Object key, Object value)
+    ReferenceCountHelper.skipRefCountTracking();
+    @Retained
+    @Released
+    Object curValue = _getValueRetain(region, true);
+    ReferenceCountHelper.unskipRefCountTracking();
+    boolean proceed;
+    try {
+      if (curValue == null) {
+        curValue = Token.NOT_AVAILABLE;
-    } // end curValue block
+
+      if (curValue == Token.NOT_AVAILABLE) {
+        // In some cases we need to get the current value off of disk.
+
+        // if the event is transmitted during GII and has an old value, it was
+        // the state of the transmitting cache's entry & should be used here
+        if (event.getCallbackArgument() != null
+            && event.getCallbackArgument().equals(RegionQueue.WAN_QUEUE_TOKEN)
+            && event.isOriginRemote()) { // check originRemote for bug 40508
+          // curValue = getValue(region); can cause deadlock if GII is occurring
+          curValue = getValueOnDiskOrBuffer(region);
+        } else {
+          FilterProfile fp = region.getFilterProfile();
+          if (fp != null && (fp.getCqCount() > 0 || expectedOldValue != null)) {
+            // curValue = getValue(region); can cause deadlock will fault in the value
+            // and will confuse LRU.
+            curValue = getValueOnDiskOrBuffer(region);
+          }
+        }
+      }
+
+      if (expectedOldValue != null) {
+        if (!checkExpectedOldValue(expectedOldValue, curValue, region)) {
+          throw new EntryNotFoundException(
+              LocalizedStrings.AbstractRegionEntry_THE_CURRENT_VALUE_WAS_NOT_EQUAL_TO_EXPECTED_VALUE
+                  .toLocalizedString());
+        }
+      }
+
+      if (inTokenMode && event.hasOldValue()) {
+        proceed = true;
+      } else {
+        proceed = event.setOldValue(curValue, curValue instanceof GatewaySenderEventImpl)
+            || removeRecoveredEntry || forceDestroy || region.getConcurrencyChecksEnabled()
+            || (event.getOperation() == Operation.REMOVE && (curValue == null
+                || curValue == Token.LOCAL_INVALID || curValue == Token.INVALID));
+      }
+    } finally {
+      OffHeapHelper.releaseWithNoTracking(curValue);
+    }
-        if (event.getRegion().getServerProxy() != null) { // server will return a version tag
+        if (event.getRegion().getServerProxy() != null) {
+          // server will return a version tag
-          && !event.isFromRILocalDestroy()) { // bug #46780, don't retain tombstones for entries
-                                              // destroyed for register-interest
+          && !event.isFromRILocalDestroy()) {
+        // bug #46780, don't retain tombstones for entries destroyed for register-interest
-        removeEntry = (v == null) || !v.hasValidVersion();
+        removeEntry = v == null || !v.hasValidVersion();
-
-
+
-      return (actualValue == null) || Token.isInvalid(actualValue);
+      return actualValue == null || Token.isInvalid(actualValue);
-  static boolean checkEquals(@Unretained Object v1, @Unretained Object v2,
+  private static boolean checkEquals(@Unretained Object v1, @Unretained Object v2,
-      if (isCompressedOffHeap) { // fix for bug 52248
+      if (isCompressedOffHeap) {
+        // fix for bug 52248
-        /**
+        /*
-        GemFireCacheImpl gfc = GemFireCacheImpl.getForPdx("Could not access Pdx registry");
-        if (gfc != null) {
+        InternalCache internalCache = GemFireCacheImpl.getForPdx("Could not access Pdx registry");
+        if (internalCache != null) {
-            pdxSerializer = gfc.getPdxSerializer();
+            pdxSerializer = internalCache.getPdxSerializer();
-                  || InternalDataSerializer.writePdx(hdos, gfc, obj, pdxSerializer)) {
-                PdxInstance pi = InternalDataSerializer.readPdxInstance(hdos.toByteArray(), gfc);
+                  || InternalDataSerializer.writePdx(hdos, internalCache, obj, pdxSerializer)) {
+                PdxInstance pi =
+                    InternalDataSerializer.readPdxInstance(hdos.toByteArray(), internalCache);
-            } catch (IOException ignore) {
-              // we are not able to convert it so just fall through
-            } catch (PdxSerializationException ignore) {
+            } catch (IOException | PdxSerializationException ignore) {
-
-  /////////////////////////////////////////////////////////////
-  /////////////////////////// fields //////////////////////////
-  /////////////////////////////////////////////////////////////
+    @Override
+    @Override
-  };
+  }
+  @Override
-  protected static boolean okToStoreOffHeap(Object v, AbstractRegionEntry e) {
+  private static boolean okToStoreOffHeap(Object v, AbstractRegionEntry e) {
-  protected final void _setLastModified(long lastModifiedTime) {
+  protected void _setLastModified(long lastModifiedTime) {
-      storedValue = getlastModifiedField();
+      storedValue = getLastModifiedField();
-  protected abstract long getlastModifiedField();
+  protected abstract long getLastModifiedField();
-  public final long getLastModified() {
-    return getlastModifiedField() & LAST_MODIFIED_MASK;
+  @Override
+  public long getLastModified() {
+    return getLastModifiedField() & LAST_MODIFIED_MASK;
-  protected final boolean areAnyBitsSet(long bitMask) {
-    return (getlastModifiedField() & bitMask) != 0L;
+  protected boolean areAnyBitsSet(long bitMask) {
+    return (getLastModifiedField() & bitMask) != 0L;
-  protected final void setBits(long bitMask) {
-    boolean done = false;
+  protected void setBits(long bitMask) {
+    boolean done;
-      long bits = getlastModifiedField();
+      long bits = getLastModifiedField();
-  protected final void clearBits(long bitMask) {
-    boolean done = false;
+  protected void clearBits(long bitMask) {
+    boolean done;
-      long bits = getlastModifiedField();
+      long bits = getLastModifiedField();
+        // TODO: array comparison is broken
+        // TODO: array comparison is broken
-  public final Object _getValue() {
+  public Object _getValue() {
-  public final boolean isUpdateInProgress() {
+  @Override
+  public boolean isUpdateInProgress() {
-  public final void setUpdateInProgress(final boolean underUpdate) {
+  @Override
+  public void setUpdateInProgress(final boolean underUpdate) {
-
-  public final boolean isCacheListenerInvocationInProgress() {
+  @Override
+  public boolean isCacheListenerInvocationInProgress() {
-  public final void setCacheListenerInvocationInProgress(final boolean listenerInvoked) {
-    if (listenerInvoked) {
+  @Override
+  public void setCacheListenerInvocationInProgress(final boolean isListenerInvoked) {
+    if (isListenerInvoked) {
-  public final boolean isInUseByTransaction() {
+  public boolean isInUseByTransaction() {
-  public final void setInUseByTransaction(final boolean v) {
+  public void setInUseByTransaction(final boolean v) {
-  public final synchronized void incRefCount() {
+  public synchronized void incRefCount() {
-  /**
-   * {@inheritDoc}
-   */
-
-  public final synchronized void decRefCount(NewLRUClockHand lruList, LocalRegion lr) {
+  public synchronized void decRefCount(NewLRUClockHand lruList, LocalRegion lr) {
-  public final synchronized void resetRefCount(NewLRUClockHand lruList) {
+  public synchronized void resetRefCount(NewLRUClockHand lruList) {
-  protected final void _setValue(Object val) {
+  void _setValue(Object val) {
+  @Override
-  public final boolean getValueWasResultOfSearch() {
+  @Override
+  public boolean getValueWasResultOfSearch() {
-  public final void setValueResultOfSearch(boolean v) {
+  @Override
+  public void setValueResultOfSearch(boolean v) {
-    boolean has = stamp.getRegionVersion() != 0 || stamp.getEntryVersion() != 0;
-    return has;
+    return stamp.getRegionVersion() != 0 || stamp.getEntryVersion() != 0;
+  @Override
-  /**
-   * @see HashEntry#getMapValue()
-   */
-  public final Object getMapValue() {
+  @Override
+  public Object getMapValue() {
-  /**
-   * @see HashEntry#setMapValue(Object)
-   */
-  public final void setMapValue(final Object newValue) {
+  @Override
+  public void setMapValue(final Object newValue) {
-  public final String toString() {
+  public String toString() {
-    sb.append("key=").append(getKey()).append("; rawValue=").append(_getValue()); // OFFHEAP
-                                                                                  // _getValue ok:
-                                                                                  // the current
-                                                                                  // toString on
-                                                                                  // ObjectChunk is
-                                                                                  // safe to use
-                                                                                  // without incing
-                                                                                  // refcount.
+    // OFFHEAP _getValue ok: the current toString on ObjectChunk is safe to use without incing
+    // refcount.
+    sb.append("key=").append(getKey()).append("; rawValue=").append(_getValue());
-      sb.append("; version=").append(stamp.asVersionTag() + ";member=" + stamp.getMemberID());
+      sb.append("; version=").append(stamp.asVersionTag()).append(";member=")
+          .append(stamp.getMemberID());
-  /*
-   * (non-Javadoc) This generates version tags for outgoing messages for all subclasses supporting
-   * concurrency versioning. It also sets the entry's version stamp to the tag's values.
-   * 
-   * @see
-   * org.apache.geode.internal.cache.RegionEntry#generateVersionTag(org.apache.geode.distributed.
-   * DistributedMember, boolean)
+  /**
+   * This generates version tags for outgoing messages for all subclasses supporting concurrency
+   * versioning. It also sets the entry's version stamp to the tag's values.
-  public VersionTag generateVersionTag(VersionSource mbr, boolean withDelta, LocalRegion region,
+  @Override
+  public VersionTag generateVersionTag(VersionSource member, boolean withDelta, LocalRegion region,
-    if (stamp != null && region.getServerProxy() == null) { // clients do not generate versions
+    if (stamp != null && region.getServerProxy() == null) {
+      // clients do not generate versions
-
-      if (mbr == null) {
+      if (member == null) {
-          mbr = regionMember;
+          member = regionMember;
-      VersionTag tag = VersionTag.create(mbr);
+      VersionTag tag = VersionTag.create(member);
-      stamp.setMemberID(mbr);
+      stamp.setMemberID(member);
-            (event.getContext() == null ? "none"
-                : event.getContext().getDistributedMember().getName()),
+            event.getContext() == null ? "none"
+                : event.getContext().getDistributedMember().getName(),
-  /** set/unset the flag noting that a tombstone has been scheduled for this entry */
-  public void setTombstoneScheduled(boolean scheduled) {
-    if (scheduled) {
-      setBits(TOMBSTONE_SCHEDULED);
-    } else {
-      clearBits(~TOMBSTONE_SCHEDULED);
-    }
-  }
-
-   * return the flag noting whether a tombstone has been scheduled for this entry. This should be
-   * called under synchronization on the region entry if you want an accurate result.
-   */
-  public boolean isTombstoneScheduled() {
-    return areAnyBitsSet(TOMBSTONE_SCHEDULED);
-  }
-
-  /*
-   * (non-Javadoc) This performs a concurrency check.
+   * This performs a concurrency check.
-   * The normal membership ID comparison method is used.<p>
+   * The normal membership ID comparison method is used.
+   * <p>
-   * already been applied to the entry.
-   * 
-   * @see
-   * org.apache.geode.internal.cache.RegionEntry#concurrencyCheck(org.apache.geode.cache.EntryEvent)
+   *         already been applied to the entry.
-
-          && (r.getDataPolicy().withPersistence() || !r.getScope().isLocal())) { // bug #45258 -
-                                                                                 // perf degradation
-                                                                                 // for local
-                                                                                 // regions and RVV
+          && (r.getDataPolicy().withPersistence() || !r.getScope().isLocal())) {
+        // bug #45258 - perf degradation for local regions and RVV
-
-      // [bruce] for a long time I had conflict checks turned off in clients when
+      // for a long time I had conflict checks turned off in clients when
-      // if (r.getServerProxy() != null && conflictCheck) {
-      // // events coming from servers while a local sync is held on the entry
-      // // do not require a conflict check. Conflict checks were already
-      // // performed on the server and here we just consume whatever was sent back.
-      // // Event.isFromServer() returns true for client-update messages and
-      // // for putAll/getAll, which do not hold syncs during the server operation.
-      // conflictCheck = event.isFromServer();
-      // }
-      // else
-      // [bruce] for a very long time we had conflict checks turned off for PR buckets.
+      // events coming from servers while a local sync is held on the entry
+      // do not require a conflict check. Conflict checks were already
+      // performed on the server and here we just consume whatever was sent back.
+      // Event.isFromServer() returns true for client-update messages and
+      // for putAll/getAll, which do not hold syncs during the server operation.
+
+      // for a very long time we had conflict checks turned off for PR buckets.
-      // if (r.isUsedForPartitionedRegionBucket()) {
-      // conflictCheck = false; // primary/secondary model
-      // }
-  protected final void basicProcessVersionTag(LocalRegion region, VersionTag tag,
+  protected void basicProcessVersionTag(LocalRegion region, VersionTag tag,
-    StringBuilder verbose = null;
-
+      StringBuilder verbose = null;
-        if (stampTag.hasValidVersion() && checkForConflict) { // only be verbose here if there's a
-                                                              // possibility we might reject the
-                                                              // operation
+        if (stampTag.hasValidVersion() && checkForConflict) {
+          // only be verbose here if there's a possibility we might reject the operation
-          verbose.append(
-              "processing tag for key " + getKey() + ", stamp=" + stamp.asVersionTag() + ", tag=")
-              .append(tag).append(", checkForConflict=").append(checkForConflict); // .append(",
-                                                                                   // current
-                                                                                   // value=").append(_getValue());
+          verbose.append("processing tag for key ").append(getKey()).append(", stamp=")
+              .append(stamp.asVersionTag()).append(", tag=").append(tag)
+              .append(", checkForConflict=").append(checkForConflict);
-
-    // stamp.setPreviousMemberID(stamp.getMemberID());
-  protected boolean checkForConflict(LocalRegion region, VersionStamp stamp, VersionTag tag,
+  private boolean checkForConflict(LocalRegion region, VersionStamp stamp, VersionTag tag,
-    boolean throwex = false;
-    boolean apply = false;
-
-          verbose
-              .append("\nversion rollover detected: tag=" + tagVersion + " stamp=" + stampVersion);
+          verbose.append("\nversion rollover detected: tag=").append(tagVersion).append(" stamp=")
+              .append(stampVersion);
+    boolean throwex = false;
+    boolean apply = false;
-        } else /*
-                * if (isTombstoneFromGII && isTombstone()) { if (verbose != null) {
-                * verbose.append(" - disallowing duplicate tombstone from GII"); } return false; //
-                * bug #49601 don't schedule tombstones from GII if there's already one here } else
-                */ {
+        } else {
-        && (timestamp + TombstoneService.REPLICATE_TOMBSTONE_TIMEOUT) <= region.cacheTimeMillis();
+        && timestamp + TombstoneService.REPLICATE_TOMBSTONE_TIMEOUT <= region.cacheTimeMillis();
-   * 
-   * @throws InvalidDeltaException
-        public void changeEventValue(Object v) {
-          newValue[0] = v;
+        public void changeEventValue(Object value) {
+          newValue[0] = value;
+
-        timestampedEvent.setOldValue(getValue(timestampedEvent.getRegion())); // OFFHEAP: since
-                                                                              // isRemoved I think
-                                                                              // getValue will never
-                                                                              // be stored off heap
-                                                                              // in this case
+        // OFFHEAP: since isRemoved I think getValue will never be stored off heap in this case
+        timestampedEvent.setOldValue(getValue(timestampedEvent.getRegion()));
-        logger.debug("done invoking resolver {}", thr);
+        logger.debug("done invoking resolver", thr);
-    if (tagTime > stampTime || (tagTime == stampTime && tagDsid >= stampDsid)) {
+    if (tagTime > stampTime || tagTime == stampTime && tagDsid >= stampDsid) {
-      logger.debug("disallowing event for " + event.getKey());
+      logger.debug("disallowing event for {}", event.getKey());
-    return ((value != null) && (context != null) && (context.getCompressor() != null)
-        && !Token.isInvalidOrRemoved(value));
+    return value != null && context != null && context.getCompressor() != null
+        && !Token.isInvalidOrRemoved(value);
+  @Override
+  @Override
-    return (null == getValueAsToken());
+    return null == getValueAsToken();
+  @Override
+  @Override
+  @Override
+  @Override
-   * Maximum size of a string that can be encoded as char.
-   */
-  public static final int MAX_INLINE_STRING_KEY_CHAR_ENCODING = 7;
-  /**
-   * Maximum size of a string that can be encoded as byte.
-   */
-  public static final int MAX_INLINE_STRING_KEY_BYTE_ENCODING = 15;
-
-  /**

MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV31 INS40 INS40 INS40 INS40 UPD40 INS40 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 UPD40 INS40 UPD40 INS40 UPD40 INS40 UPD83 INS78 INS79 INS78 UPD42 INS78 UPD42 INS78 UPD42 INS78 INS78 INS78 INS78 INS78 INS78 INS78 INS78 INS78 INS78 INS78 INS78 INS78 INS78 MOV8 INS78 INS83 INS83 INS78 INS78 INS78 INS78 INS78 MOV43 INS78 INS78 INS78 MOV8 INS83 INS78 MOV43 UPD83 UPD42 INS78 INS78 INS78 INS78 INS78 INS78 INS78 INS78 INS78 INS78 INS78 INS29 INS78 INS29 UPD83 MOV60 MOV60 INS78 INS78 INS78 INS78 INS78 INS78 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 MOV8 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS21 MOV60 MOV25 INS21 INS25 MOV41 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 UPD42 UPD42 INS42 UPD42 UPD42 INS42 INS60 INS25 INS78 INS78 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS65 INS42 UPD42 INS65 INS65 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 MOV27 INS8 INS25 INS39 INS59 INS42 INS8 MOV8 INS42 INS42 UPD42 MOV27 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 MOV27 MOV27 INS27 MOV27 INS42 INS42 INS9 INS42 INS42 INS42 MOV32 INS21 MOV27 INS8 INS25 UPD42 UPD42 UPD42 INS42 MOV25 MOV25 MOV21 MOV25 MOV60 MOV60 INS25 MOV25 MOV41 MOV60 MOV27 INS27 MOV27 MOV27 INS32 INS21 MOV27 INS8 MOV25 INS8 MOV27 INS8 MOV8 UPD42 MOV27 INS27 MOV27 MOV27 INS42 INS32 UPD42 INS42 MOV11 INS42 INS42 INS32 INS21 MOV62 INS25 MOV21 MOV25 INS21 MOV27 INS32 INS42 MOV32 UPD42 UPD42 INS45 MOV32 MOV27 MOV27 INS36 UPD42 MOV42 UPD43 INS42 INS42 INS32 MOV60 INS25 MOV62 INS8 INS8 UPD42 INS7 UPD43 UPD42 UPD42 UPD42 UPD42 INS32 INS42 INS45 UPD42 INS11 UPD42 INS42 INS42 MOV38 MOV8 MOV8 INS21 MOV60 MOV25 INS54 UPD43 UPD42 INS42 INS27 UPD42 UPD42 UPD42 MOV32 MOV42 MOV32 MOV16 UPD45 INS43 INS42 INS7 INS8 INS12 UPD42 UPD27 MOV27 MOV27 MOV38 INS42 INS40 INS42 MOV60 MOV21 MOV21 INS21 INS21 MOV44 INS8 UPD42 MOV27 UPD42 INS32 INS42 INS42 UPD42 UPD40 UPD42 INS7 INS32 INS53 INS27 INS32 INS42 INS45 INS40 INS42 INS42 INS42 INS9 INS14 MOV27 MOV27 INS32 INS42 INS42 UPD42 UPD40 UPD42 MOV43 MOV32 INS42 UPD42 INS84 INS32 INS42 INS45 MOV42 MOV42 INS45 MOV43 MOV43 INS32 INS42 MOV32 UPD40 MOV14 UPD42 INS32 INS42 INS45 INS42 INS32 INS42 MOV32 UPD42 MOV42 MOV42 INS45 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL34 DEL27 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL34 DEL27 DEL59 DEL23 DEL52 DEL40 DEL42 DEL45 DEL80 DEL77 DEL83 DEL83 DEL36 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL83 DEL36 DEL36 DEL36 DEL83 DEL83 DEL83 DEL83 DEL39 DEL85 DEL5 DEL42 DEL39 DEL85 DEL5 DEL42 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL40 DEL42 DEL7 DEL21 DEL8 DEL40 DEL42 DEL7 DEL21 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL54 DEL8 DEL8 DEL25 DEL25 DEL25 DEL25 DEL25 DEL8 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL36 DEL27 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL42 DEL36 DEL27 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL36 DEL42 DEL44 DEL8 DEL12 DEL83 DEL83 DEL83 DEL83 DEL9 DEL83 DEL9 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL65 DEL65 DEL29 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL39 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL68 DEL65 DEL29 DEL83 DEL42 DEL42 DEL42 DEL43 DEL69 DEL68 DEL65 DEL29 DEL83 DEL83 DEL45 DEL27 DEL36 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL38 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL83 DEL45 DEL45 DEL45 DEL27 DEL45 DEL42 DEL45 DEL42 DEL27 DEL36 DEL42 DEL65 DEL36 DEL45 DEL27 DEL36 DEL36 DEL36 DEL36 DEL36 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23
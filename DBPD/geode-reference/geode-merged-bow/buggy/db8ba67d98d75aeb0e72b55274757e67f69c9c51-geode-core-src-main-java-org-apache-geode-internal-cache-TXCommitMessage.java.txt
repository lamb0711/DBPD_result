GEODE-5828: fixes replicates miss transaction commit. (#2571)

* GEODE-5828: fixes replicates miss transaction commit.

 * Always send CommitProcessQueryMessage to other replicates to see if anyone received second message
   as transaction originator for client transaction will be different from transation host.
 * Do not wait for transaction originator to depart when transaction host is crashed. Originator may
   not be the same as the crashed transaction host and never departs from distributed system.

* fix review comments.

-
-      final boolean processMsgReceived = txTracker.commitProcessReceived(this.trackerKey, dm);
+      final boolean processMsgReceived = txTracker.commitProcessReceived(this.trackerKey);
-    this.dm.removeMembershipListener(this);
+    getDistributionManager().removeMembershipListener(this);
-    if (this.farSiders != null && !this.farSiders.isEmpty()) {
+    if (getFarSiders() != null && !getFarSiders().isEmpty()) {
-          final TXCommitMessage mess = TXCommitMessage.this;
-          Object trackerKey = mess.getTrackerKey();
-          DistributedMember member = getMemberFromTrackerKey(trackerKey);
-          if (!mess.getSender().equals(member)) {
-            /*
-             * Do not send a CommitProcessQueryMessage when the sender of CommitMessage is not the
-             * member in the tracker key. (If this happens we are the redundant node for PR, and the
-             * primary just crashed).
-             */
-            txTracker.removeMessage(mess);
-            return;
-          }
-          CommitProcessQueryReplyProcessor replProc =
-              new CommitProcessQueryReplyProcessor(mess.dm, mess.farSiders);
-          CommitProcessQueryMessage query =
-              new CommitProcessQueryMessage(mess.getTrackerKey(), replProc.getProcessorId());
-          query.setRecipients(mess.farSiders);
-          mess.dm.putOutgoing(query);
-          // Wait for any one positive response or all negative responses.
-          // (while() loop removed for bug 36983 - you can't loop on waitForReplies()
-          TXCommitMessage.this.dm.getCancelCriterion().checkCancelInProgress(null);
-          try {
-            replProc.waitForRepliesUninterruptibly();
-          } catch (ReplyException e) {
-            e.handleCause();
-          }
-          if (replProc.receivedACommitProcessMessage()) {
-            if (logger.isDebugEnabled()) {
-              logger.debug(
-                  "Transaction associated with lockID: {} from orign {} is processing due to a received \"commit process\" message",
-                  mess.lockId, id);
-            }
-
-            try {
-              // Set processor to zero to avoid the ack to the now departed origin
-              mess.processorId = 0;
-              mess.basicProcess();
-            } finally {
-              txTracker.processed(mess);
-            }
-          } else {
-            if (logger.isDebugEnabled()) {
-              logger.debug(
-                  "Transaction associated with lockID: {} from origin {} ignored.  No other recipients received \"commit process\" message",
-                  mess.lockId, id);
-            }
-            txTracker.removeMessage(mess);
-          }
-
-        }
-
-        private DistributedMember getMemberFromTrackerKey(Object trackerKey) {
-          if (trackerKey instanceof TXId) {
-            TXId id1 = (TXId) trackerKey;
-            return id1.getMemberId();
-          } else if (trackerKey instanceof TXLockId) {
-            TXLockId id2 = (TXLockId) trackerKey;
-            return id2.getMemberId();
-          }
-          return null;
+          doCommitProcessQuery(id);
+  HashSet getFarSiders() {
+    return farSiders;
+  }
+
+  DistributionManager getDistributionManager() {
+    return dm;
+  }
+
+  void doCommitProcessQuery(final InternalDistributedMember id) {
+    CommitProcessQueryReplyProcessor replyProcessor = createReplyProcessor();
+    CommitProcessQueryMessage queryMessage = createQueryMessage(replyProcessor);
+    queryMessage.setRecipients(this.farSiders);
+    getDistributionManager().putOutgoing(queryMessage);
+    // Wait for any one positive response or all negative responses.
+    // (while() loop removed for bug 36983 - you can't loop on waitForReplies()
+    getDistributionManager().getCancelCriterion().checkCancelInProgress(null);
+    try {
+      replyProcessor.waitForRepliesUninterruptibly();
+    } catch (ReplyException e) {
+      e.handleCause();
+    }
+    if (replyProcessor.receivedACommitProcessMessage()) {
+      if (logger.isDebugEnabled()) {
+        logger.debug(
+            "Transaction associated with lockID: {} from orign {} is processing due to a received \"commit process\" message",
+            lockId, id);
+      }
+
+      try {
+        // Set processor to zero to avoid the ack to the now departed origin
+        processorId = 0;
+        basicProcess();
+      } finally {
+        txTracker.processed(this);
+      }
+    } else {
+      if (logger.isDebugEnabled()) {
+        logger.debug(
+            "Transaction associated with lockID: {} from origin {} ignored.  No other recipients received \"commit process\" message",
+            lockId, id);
+      }
+      txTracker.removeMessage(this);
+    }
+  }
+
+  CommitProcessQueryReplyProcessor createReplyProcessor() {
+    return new CommitProcessQueryReplyProcessor(dm, farSiders);
+  }
+
+  CommitProcessQueryMessage createQueryMessage(CommitProcessQueryReplyProcessor replyProcessor) {
+    return new CommitProcessQueryMessage(getTrackerKey(), replyProcessor.getProcessorId());
+  }
+
+  private DistributedMember getMemberFromTrackerKey(Object trackerKey) {
+    if (trackerKey instanceof TXId) {
+      TXId id1 = (TXId) trackerKey;
+      return id1.getMemberId();
+    } else if (trackerKey instanceof TXLockId) {
+      TXLockId id2 = (TXLockId) trackerKey;
+      return id2.getMemberId();
+    }
+    return null;
+  }
+

INS31 INS31 INS31 INS31 INS31 MOV31 INS43 INS42 INS8 INS43 INS42 INS8 INS39 INS42 INS44 INS8 MOV43 INS42 INS8 MOV43 INS42 INS44 INS8 INS42 INS41 INS42 INS41 INS83 INS43 INS42 INS60 INS60 INS21 INS21 INS21 MOV54 INS25 INS41 INS43 INS42 INS41 INS42 INS42 INS42 MOV43 INS59 MOV43 INS59 MOV32 MOV22 INS32 INS32 INS32 INS8 INS8 INS14 INS42 INS14 INS32 INS42 INS32 INS42 INS32 UPD42 INS42 INS32 INS42 INS42 INS32 INS42 INS33 INS42 INS42 INS25 INS54 INS25 INS21 INS43 INS42 INS42 INS43 INS32 INS32 INS42 INS32 INS32 MOV43 INS42 INS42 INS42 INS42 INS32 INS42 MOV32 INS8 INS8 INS8 MOV32 INS8 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 UPD42 INS21 INS21 INS21 INS21 INS21 INS42 INS42 INS52 INS42 MOV43 INS32 INS7 INS32 INS32 INS32 INS42 INS42 INS45 INS42 INS42 INS42 INS34 INS42 INS42 INS42 INS52 INS42 INS42 INS45 INS42 INS42 INS8 MOV21 UPD42 DEL42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL45 DEL40 DEL83 DEL42 DEL43 DEL42 DEL42 DEL52 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL21 DEL41 DEL8 DEL25 DEL42 DEL40 DEL40 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL42 DEL40 DEL32 DEL21 DEL40 DEL42 DEL42 DEL32 DEL21 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL33 DEL32 DEL21 DEL42 DEL42 DEL32 DEL8 DEL25 DEL40 DEL34 DEL7 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL42 DEL42 DEL45 DEL40 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8
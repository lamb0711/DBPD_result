GEODE-6612: add entry count for list Region and rework filtering by groups (#3465)

Co-authored-by: Owen Nichols <onichols@pivotal.io>
Co-authored-by: Jens Deppe jdeppe@pivotal.io

* Create a RuntimeCacheElement interface to hold multiple groups
* Using RegionConfig can only set/get one group
+import java.util.Map;
+import org.apache.geode.management.configuration.RuntimeCacheElement;
+import org.apache.geode.management.internal.configuration.validators.CacheElementValidator;
-  private HashMap<Class, ConfigurationManager> managers;
-  private HashMap<Class, ConfigurationValidator> validators;
+  private Map<Class, ConfigurationManager> managers;
+  private Map<Class, ConfigurationValidator> validators;
-    managers.put(RegionConfig.class, new RegionConfigManager());
+    managers.put(RegionConfig.class, new RegionConfigManager(cache));
+    validators.put(CacheElement.class, new CacheElementValidator());
-      ConfigurationPersistenceService persistenceService, HashMap managers, HashMap validators) {
+      ConfigurationPersistenceService persistenceService, Map managers, Map validators) {
-    ClusterManagementResult result = new ClusterManagementResult();
-    ConfigurationManager configurationMutator = managers.get(config.getClass());
+    // first validate common attributes of all configuration object
+    validators.get(CacheElement.class).validate(config);
+      // exit early if config element already exists in cache config
+      CacheConfig currentPersistedConfig = persistenceService.getCacheConfig(group, true);
+      if (validator.exists(config, currentPersistedConfig)) {
+        throw new EntityExistsException("cache element " + config.getId() + " already exists.");
+      }
-    // exit early if config element already exists in cache config
-    CacheConfig currentPersistedConfig = persistenceService.getCacheConfig(group, true);
-    if (validator.exists(config, currentPersistedConfig)) {
-      throw new EntityExistsException("cache element " + config.getId() + " already exists.");
+    // validate that user used the correct config object type
+    ConfigurationManager configurationManager = managers.get(config.getClass());
+    if (configurationManager == null) {
+      throw new IllegalArgumentException(String.format("Configuration type %s is not supported.",
+          config.getClass().getSimpleName()));
+    ClusterManagementResult result = new ClusterManagementResult();
+
-        configurationMutator.add(config, cacheConfigForGroup);
+        configurationManager.add(config, cacheConfigForGroup);
-      List<CacheElement> listResults = manager.list(filter, null);
+      List<RuntimeCacheElement> listResults = manager.list(filter, null);
-    List<CacheElement> elements = new ArrayList<>();
+    List<RuntimeCacheElement> resultList = new ArrayList<>();
+
+    // get a list of all the resultList from all groups that satisfy the filter criteria (all
+    // filters
+    // have been applied except the group)
-      if (StringUtils.isBlank(filter.getGroup()) || group.equals(filter.getConfigGroup())) {
-        CacheConfig currentPersistedConfig = persistenceService.getCacheConfig(group, true);
-        List<CacheElement> listInGroup = manager.list(filter, currentPersistedConfig);
-        // only set the group attribute when the config level is not in the cluster level
-        if (!group.equals("cluster")) {
-          listInGroup.stream().forEach(e -> e.setGroup(group));
+      CacheConfig currentPersistedConfig = persistenceService.getCacheConfig(group, true);
+      List<RuntimeCacheElement> listInGroup = manager.list(filter, currentPersistedConfig);
+      for (RuntimeCacheElement element : listInGroup) {
+        element.getGroups().add(group);
+        int index = resultList.indexOf(element);
+        if (index >= 0) {
+          RuntimeCacheElement exist = resultList.get(index);
+          exist.getGroups().add(group);
+        } else {
+          resultList.add(element);
-        elements.addAll(listInGroup);
-    result.setResult(elements);
+    // filtering by group. Do this after iterating through all the groups because some region might
+    // belong to multiple groups and we want the "group" field to show that.
+    if (StringUtils.isNotBlank(filter.getGroup())) {
+      resultList =
+          resultList.stream().filter(e -> e.getGroups().contains(filter.getConfigGroup()))
+              .collect(Collectors.toList());
+    }
+
+    // if "cluster" is the only group of the element, remove it
+    for (RuntimeCacheElement element : resultList) {
+      if (element.getGroups().size() == 1 && "cluster".equals(element.getGroup())) {
+        element.getGroups().clear();
+      }
+    }
+
+    result.setResult(resultList);
+

INS26 INS26 INS26 INS40 INS40 INS40 UPD74 UPD74 MOV60 MOV60 UPD43 UPD43 INS21 UPD43 UPD43 INS21 INS25 INS25 INS70 UPD42 UPD42 INS32 UPD42 UPD42 INS32 INS27 INS8 UPD74 MOV32 INS8 INS44 INS42 INS8 INS42 INS42 INS57 INS14 INS32 INS42 INS42 MOV60 MOV25 UPD42 INS42 INS33 INS53 MOV43 UPD43 UPD42 MOV60 MOV60 INS70 UPD42 INS21 INS43 INS42 INS25 UPD42 INS42 INS43 INS43 INS42 INS42 INS57 INS14 INS74 MOV42 UPD42 UPD74 MOV74 INS44 INS42 INS8 INS7 INS42 INS27 INS8 INS42 INS42 INS43 INS43 INS32 INS43 INS43 UPD43 INS43 INS42 INS21 INS60 INS25 INS42 INS32 INS27 INS32 INS21 INS42 INS42 INS42 INS42 INS45 INS32 INS42 INS42 UPD42 INS42 INS32 INS39 INS59 INS27 INS8 INS8 INS32 INS42 INS32 INS32 INS34 INS45 INS42 INS32 INS32 INS32 INS42 INS32 UPD42 MOV42 INS42 INS42 INS32 INS42 INS34 INS60 INS21 MOV21 INS32 INS42 INS86 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS43 INS59 INS32 INS42 INS42 MOV59 MOV32 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS32 INS32 INS42 MOV42 UPD42 UPD42 UPD42 INS32 UPD42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 DEL42 DEL43 DEL74 DEL27 DEL45 DEL32 DEL38 DEL32 DEL42 DEL32 DEL86 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25
GEODE-4902: Refactor LogMarker class and usage (#1678)

* GEODE-4902: Refactor LogMarker and usage
* Distinguish those markers at the TRACE and DEBUG levels (now Markers named *_VERBOSE) from those that log at a coarser grainularity (now Markers named *_MARKER)
* Suppress only *_VERBOSE markers by default, from previous behavior of suppressing all markers.
* Refactor some pathological log checks, e.g., change a log from debug to trace when it is gated behind ifTraceEnabled block.
* Remove unused Markers.
* Remove any log marker logic from AdminWaiters exception message generation.  Exceptions now always include a full message.
* Remove marker-gated print to System.out in PersistentOplogSet -- direct calls to System.out should not exist in that class.
* Add marker EVENT_ID_TO_STRING_VERBOSE to explicitly distinguish instance of marker used in logic not immediately consumed by a logger.  The consumption of EventId::toString should only exist at logging in any event.
**
* Remove nearby dead code and dead code detected during marker removal.
* Expand wildcard imports in touched files.
* Remove TODO comments, at least one of which was a decade old.
* Collapse nearby, redundant catch blocks
* Remove empty finally blocks
* Update documentation page to refer to GEODE_VERBOSE, from deprecated GEMFIRE_VERBOSE
* The change in log marker names causes one class to compile larger.  Updated sanctionedDataSerializables.

-import java.util.*;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
-import org.apache.geode.cache.*;
+import org.apache.geode.cache.CacheWriterException;
+import org.apache.geode.cache.EntryNotFoundException;
+import org.apache.geode.cache.Operation;
+import org.apache.geode.cache.RegionAttributes;
+import org.apache.geode.cache.RegionDestroyedException;
+import org.apache.geode.cache.TimeoutException;
-  /**
-   * Does a get that attempts to not fault values in from disk or make the entry the most recent in
-   * the LRU.
-   */
-  /*
-   * protected Object optimalGet(Object k) { // Get the object at that key (to remove the index).
-   * Object object = null; try { object = getValueInVM(k); // OFFHEAP deserialize if (object ==
-   * null) { // must be on disk // fault it in w/o putting it back in the region object =
-   * getValueOnDiskOrBuffer(k); if (object == null) { // try memory one more time in case it was
-   * already faulted back in object = getValueInVM(k); // OFFHEAP deserialize if (object == null) {
-   * // if we get this far give up and just do a get object = get(k); } else { if (object instanceof
-   * CachedDeserializable) { object = ((CachedDeserializable)object).getDeserializedValue( this,
-   * this.getRegionEntry(k)); } } } } else { if (object instanceof CachedDeserializable) { object =
-   * ((CachedDeserializable)object).getDeserializedValue(this, this.getRegionEntry(k)); } } } catch
-   * (EntryNotFoundException ok) { // just return null; } if (object == Token.TOMBSTONE) { object =
-   * null; }
-   *
-   * return object; }
-   */
-

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 UPD40 INS40 INS40 INS40 UPD40 INS40 INS40 INS40 DEL66 DEL66 DEL65 DEL29
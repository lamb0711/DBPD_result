Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Class <code>CacheClientProxy</code> represents the server side of the
- * {@link CacheClientUpdater}. It queues messages to be sent from the server to
- * the client. It then reads those messages from the queue and sends them to the
- * client.
+ * Class <code>CacheClientProxy</code> represents the server side of the {@link CacheClientUpdater}.
+ * It queues messages to be sent from the server to the client. It then reads those messages from
+ * the queue and sends them to the client.
-  
+
-  
+
-  
+
-  
+
-   * The list of keys that the client represented by this proxy is interested in
-   * (stored by region)
+   * The list of keys that the client represented by this proxy is interested in (stored by region)
-  
+
-//  /**
-//   * A string representing interest in all keys
-//   */
-//  protected static final String ALL_KEYS = "ALL_KEYS";
-//
+  // /**
+  // * A string representing interest in all keys
+  // */
+  // protected static final String ALL_KEYS = "ALL_KEYS";
+  //
-  protected static final int MAXIMUM_SHUTDOWN_PEEKS = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "MAXIMUM_SHUTDOWN_PEEKS", 50).intValue();
+  protected static final int MAXIMUM_SHUTDOWN_PEEKS = Integer
+      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "MAXIMUM_SHUTDOWN_PEEKS", 50).intValue();
-//   protected static final int MESSAGE_QUEUE_SIZE_DEFAULT = 230000;
+  // protected static final int MESSAGE_QUEUE_SIZE_DEFAULT = 230000;
-   * The time (in seconds ) after which a message in the client queue will
-   * expire.
+   * The time (in seconds ) after which a message in the client queue will expire.
-   * Defaults to true; meaning do some logging of dropped client notification
-   * messages. Set the system property to true to cause dropped messages to NOT
-   * be logged.
+   * Defaults to true; meaning do some logging of dropped client notification messages. Set the
+   * system property to true to cause dropped messages to NOT be logged.
-  protected static final boolean LOG_DROPPED_MSGS = !Boolean
-      .getBoolean(DistributionConfig.GEMFIRE_PREFIX + "disableNotificationWarnings");
+  protected static final boolean LOG_DROPPED_MSGS =
+      !Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "disableNotificationWarnings");
-   * Key in the system property from which the slow starting time value will be
-   * retrieved
+   * Key in the system property from which the slow starting time value will be retrieved
-  
+
-  
+
-  
+
-  
+
-  private Version clientVersion;  
+  private Version clientVersion;
-   * A map of region name as key and integer as its value. Basically, it stores
-   * the names of the regions with <code>DataPolicy</code> as EMPTY. If an 
-   * event's region name is present in this map, it's full value (and not 
-   * delta) is sent to the client represented by this proxy.
+   * A map of region name as key and integer as its value. Basically, it stores the names of the
+   * regions with <code>DataPolicy</code> as EMPTY. If an event's region name is present in this
+   * map, it's full value (and not delta) is sent to the client represented by this proxy.
-  
+
-   * Notify the region when a client interest registration occurs. This tells
-   * the region to update access time when an update is to be pushed to a
-   * client. It is enabled only for <code>PartitionedRegion</code>s
-   * currently.
+   * Notify the region when a client interest registration occurs. This tells the region to update
+   * access time when an update is to be pushed to a client. It is enabled only for
+   * <code>PartitionedRegion</code>s currently.
-  protected static final boolean NOTIFY_REGION_ON_INTEREST = Boolean
-      .getBoolean(DistributionConfig.GEMFIRE_PREFIX + "updateAccessTimeOnClientInterest");
-  
+  protected static final boolean NOTIFY_REGION_ON_INTEREST =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "updateAccessTimeOnClientInterest");
+
-  
+
-  
-  /** To queue the events arriving during message dispatcher initialization */ 
-  private volatile ConcurrentLinkedQueue<Conflatable> queuedEvents = new ConcurrentLinkedQueue<Conflatable>();
-  
+
+  /** To queue the events arriving during message dispatcher initialization */
+  private volatile ConcurrentLinkedQueue<Conflatable> queuedEvents =
+      new ConcurrentLinkedQueue<Conflatable>();
+
-  
+
-   * A counter that keeps track of how many task iterations that have occurred
-   * since the last ping or message. The
-   * {@linkplain CacheClientNotifier#scheduleClientPingTask ping task}
-   * increments it. Normal messages sent to the client reset it. If the counter
-   * reaches 3, a ping is sent.
+   * A counter that keeps track of how many task iterations that have occurred since the last ping
+   * or message. The {@linkplain CacheClientNotifier#scheduleClientPingTask ping task} increments
+   * it. Normal messages sent to the client reset it. If the counter reaches 3, a ping is sent.
-  
-  
+
+
-  /** true when the durable client associated with this proxy is being 
-   * restarted and prevents cqs from being closed and drained**/
+  /**
+   * true when the durable client associated with this proxy is being restarted and prevents cqs
+   * from being closed and drained
+   **/
-  
+
-   * @param ccn
-   *          The <code>CacheClientNotifier</code> registering this proxy
-   * @param socket
-   *          The socket between the server and the client
-   * @param proxyID
-   *          representing the Connection Proxy of the clien
-   * @param isPrimary
-   *          The boolean stating whether this prozxy is primary
+   * @param ccn The <code>CacheClientNotifier</code> registering this proxy
+   * @param socket The socket between the server and the client
+   * @param proxyID representing the Connection Proxy of the clien
+   * @param isPrimary The boolean stating whether this prozxy is primary
-      ClientProxyMembershipID proxyID, boolean isPrimary, byte clientConflation, 
-      Version clientVersion, long acceptorId, boolean notifyBySubscription)
-      throws CacheException {
+      ClientProxyMembershipID proxyID, boolean isPrimary, byte clientConflation,
+      Version clientVersion, long acceptorId, boolean notifyBySubscription) throws CacheException {
-    this._cache = (GemFireCacheImpl)ccn.getCache();
-    this._maximumMessageCount = ccn.getMaximumMessageCount();    
+    this._cache = (GemFireCacheImpl) ccn.getCache();
+    this._maximumMessageCount = ccn.getMaximumMessageCount();
-    this._statistics = new CacheClientProxyStats(factory, 
-        "id_"+this.proxyID.getDistributedMember().getId()+ "_at_"+ this._remoteHostAddress + ":" + this._socket.getPort());
+    this._statistics =
+        new CacheClientProxyStats(factory, "id_" + this.proxyID.getDistributedMember().getId()
+            + "_at_" + this._remoteHostAddress + ":" + this._socket.getPort());
-      new ClientInterestList(this, this.proxyID);
+        new ClientInterestList(this, this.proxyID);
-      new ClientInterestList(this, this.getDurableId());
+        new ClientInterestList(this, this.getDurableId());
-  
-  private void initializeClientAuths()
-  {
-    if(AcceptorImpl.isPostAuthzCallbackPresent())
+
+  private void initializeClientAuths() {
+    if (AcceptorImpl.isPostAuthzCallbackPresent())
-  private void reinitializeClientAuths()
-  {
+  private void reinitializeClientAuths() {
-      }        
+      }
-  
+
-    //TODO:hitesh synchronization
+    // TODO:hitesh synchronization
-    //TODO:hitesh synchronization
+    // TODO:hitesh synchronization
-  
-  public void setCQVsUserAuth(String cqName, long uniqueId, boolean isDurable)
-  {
-    if(postAuthzCallback == null) //only for multiuser
+
+  public void setCQVsUserAuth(String cqName, long uniqueId, boolean isDurable) {
+    if (postAuthzCallback == null) // only for multiuser
-      if(this.clientUserAuths != null)
+      if (this.clientUserAuths != null)
-  private void initializeTransientFields(Socket socket,
-      ClientProxyMembershipID pid, boolean ip,  byte cc, Version vers) {
+  private void initializeTransientFields(Socket socket, ClientProxyMembershipID pid, boolean ip,
+      byte cc, Version vers) {
-  public long getAcceptorId(){
+  public long getAcceptorId() {
-  
+
-  public ClientProxyMembershipID getProxyID()
-  {
+  public ClientProxyMembershipID getProxyID() {
-  
+
-//   /**
-//    * Determines if the proxy represents the client host (and only the host, not
-//    * necessarily the exact VM running on the host)
-//    *
-//    * @return Whether the proxy represents the client host
-//    */
-//   protected boolean representsClientHost(String clientHost)
-//   {
-//     // [bruce] TODO BUGBUGBUG: this should compare InetAddresses, not Strings
-//     return this._remoteHostAddress.equals(clientHost);
-//   }
+  // /**
+  // * Determines if the proxy represents the client host (and only the host, not
+  // * necessarily the exact VM running on the host)
+  // *
+  // * @return Whether the proxy represents the client host
+  // */
+  // protected boolean representsClientHost(String clientHost)
+  // {
+  // // [bruce] TODO BUGBUGBUG: this should compare InetAddresses, not Strings
+  // return this._remoteHostAddress.equals(clientHost);
+  // }
-//   protected boolean representsClientVM(DistributedMember remoteMember)
-//   {
-//     // logger.warn("Is input port " + clientPort + " contained in " +
-//     // logger.warn("Does input host " + clientHost + " equal " +
-//     // this._remoteHostAddress+ ": " + representsClientHost(clientHost));
-//     // logger.warn("representsClientVM: " +
-//     // (representsClientHost(clientHost) && containsPort(clientPort)));
-//     return (proxyID.getDistributedMember().equals(remoteMember));
-//   }
+  // protected boolean representsClientVM(DistributedMember remoteMember)
+  // {
+  // // logger.warn("Is input port " + clientPort + " contained in " +
+  // // logger.warn("Does input host " + clientHost + " equal " +
+  // // this._remoteHostAddress+ ": " + representsClientHost(clientHost));
+  // // logger.warn("representsClientVM: " +
+  // // (representsClientHost(clientHost) && containsPort(clientPort)));
+  // return (proxyID.getDistributedMember().equals(remoteMember));
+  // }
-//   /**
-//    * Determines if the CacheClientUpdater proxied by this instance is listening
-//    * on the input clientHost and clientPort
-//    *
-//    * @param clientHost
-//    *          The host name of the client to compare
-//    * @param clientPort
-//    *          The port number of the client to compare
-//    *
-//    * @return Whether the CacheClientUpdater proxied by this instance is
-//    *         listening on the input clientHost and clientPort
-//    */
-//   protected boolean representsCacheClientUpdater(String clientHost,
-//       int clientPort)
-//   {
-//     return (clientPort == this._socket.getPort() && representsClientHost(clientHost));
-//   }
+  // /**
+  // * Determines if the CacheClientUpdater proxied by this instance is listening
+  // * on the input clientHost and clientPort
+  // *
+  // * @param clientHost
+  // * The host name of the client to compare
+  // * @param clientPort
+  // * The port number of the client to compare
+  // *
+  // * @return Whether the CacheClientUpdater proxied by this instance is
+  // * listening on the input clientHost and clientPort
+  // */
+  // protected boolean representsCacheClientUpdater(String clientHost,
+  // int clientPort)
+  // {
+  // return (clientPort == this._socket.getPort() && representsClientHost(clientHost));
+  // }
-  protected boolean isMember(ClientProxyMembershipID memberId)
-  {
+  protected boolean isMember(ClientProxyMembershipID memberId) {
-  protected boolean isSameDSMember(ClientProxyMembershipID memberId)
-  {
+  protected boolean isSameDSMember(ClientProxyMembershipID memberId) {
-  protected Socket getSocket()
-  {
+  protected Socket getSocket() {
-  
-  public String getSocketHost()
-  {
+
+  public String getSocketHost() {
-  
+
-  protected String getRemoteHostAddress()
-  {
+  protected String getRemoteHostAddress() {
-  public int getRemotePort()
-  {
+  public int getRemotePort() {
+   * 
-  
+
-   * Wait until the receiver's removal has completed before
-   * returning.
+   * Wait until the receiver's removal has completed before returning.
+   * 
-          }
-          catch (InterruptedException e) {
+          } catch (InterruptedException e) {
-      }
-      finally {
+      } finally {
-  
+
-  
+
-  public GemFireCacheImpl getCache()
-  {
+  public GemFireCacheImpl getCache() {
-    for(int i=0; i < this.cils.length; i++){
+    for (int i = 0; i < this.cils.length; i++) {
-  
+
-  public CacheClientProxyStats getStatistics()
-  {
+  public CacheClientProxyStats getStatistics() {
+   * 
-   * Returns the size of the queue for heuristic purposes.  This
-   * size may be changing concurrently if puts/gets are occurring
-   * at the same time.
+   * Returns the size of the queue for heuristic purposes. This size may be changing concurrently if
+   * puts/gets are occurring at the same time.
-    return this._messageDispatcher == null ? 0
-        : this._messageDispatcher.getQueueSize();
+    return this._messageDispatcher == null ? 0 : this._messageDispatcher.getQueueSize();
-  
-  /** 
+
+  /**
-    return this._messageDispatcher == null ? 0
-        : this._messageDispatcher.getQueueSizeStat();  
+    return this._messageDispatcher == null ? 0 : this._messageDispatcher.getQueueSizeStat();
-  
-      
+
+
-    synchronized(drainsInProgressLock) {
+    synchronized (drainsInProgressLock) {
-  
-  //Called from CacheClientNotifier when attempting to restart paused proxy
-  //locking the drain lock requires that no drains are in progress 
-  //when the lock was acquired.
+
+  // Called from CacheClientNotifier when attempting to restart paused proxy
+  // locking the drain lock requires that no drains are in progress
+  // when the lock was acquired.
-    synchronized(drainsInProgressLock) {
+    synchronized (drainsInProgressLock) {
-        synchronized(drainLock) {
+        synchronized (drainLock) {
-          //prevent multiple lockings of drain lock
+          // prevent multiple lockings of drain lock
-  
-  //Called from CacheClientNotifier when completed restart of proxy
+
+  // Called from CacheClientNotifier when completed restart of proxy
-    synchronized(drainLock) {
+    synchronized (drainLock) {
-  
-  //Only close the client cq if it is paused and no one is attempting to restart the proxy
+
+  // Only close the client cq if it is paused and no one is attempting to restart the proxy
-    synchronized(drainsInProgressLock) {
-      numDrainsInProgress ++;
+    synchronized (drainsInProgressLock) {
+      numDrainsInProgress++;
-      //If the drain lock was acquired, the other thread did so before we could bump up
-      //the numDrainsInProgress.  That means we need to stop.
+      // If the drain lock was acquired, the other thread did so before we could bump up
+      // the numDrainsInProgress. That means we need to stop.
-        String msg = LocalizedStrings.CacheClientProxy_COULD_NOT_DRAIN_CQ_DUE_TO_RESTARTING_DURABLE_CLIENT.toLocalizedString(clientCQName, proxyID.getDurableId());
+        String msg =
+            LocalizedStrings.CacheClientProxy_COULD_NOT_DRAIN_CQ_DUE_TO_RESTARTING_DURABLE_CLIENT
+                .toLocalizedString(clientCQName, proxyID.getDurableId());
-      //isConnected is to protect against the case where a durable client has reconnected
-      //but has not yet sent a ready for events message
-      //we can probably remove the isPaused check
+      // isConnected is to protect against the case where a durable client has reconnected
+      // but has not yet sent a ready for events message
+      // we can probably remove the isPaused check
-          InternalCqQuery  cqToClose = cqService.getCq(cqService.constructServerCqName(
-              clientCQName, this.proxyID));
+          InternalCqQuery cqToClose =
+              cqService.getCq(cqService.constructServerCqName(clientCQName, this.proxyID));
-          }
-          else {
-            String msg = LocalizedStrings.CqService_CQ_NOT_FOUND_FAILED_TO_CLOSE_THE_SPECIFIED_CQ_0.toLocalizedString(clientCQName);
+          } else {
+            String msg = LocalizedStrings.CqService_CQ_NOT_FOUND_FAILED_TO_CLOSE_THE_SPECIFIED_CQ_0
+                .toLocalizedString(clientCQName);
-        String msg = LocalizedStrings.CacheClientProxy_COULD_NOT_DRAIN_CQ_DUE_TO_ACTIVE_DURABLE_CLIENT.toLocalizedString(clientCQName, proxyID.getDurableId());
+        String msg =
+            LocalizedStrings.CacheClientProxy_COULD_NOT_DRAIN_CQ_DUE_TO_ACTIVE_DURABLE_CLIENT
+                .toLocalizedString(clientCQName, proxyID.getDurableId());
-  
-  
+
+
-   * Returns whether the proxy is alive. It is alive if its message dispatcher
-   * is processing messages.
+   * Returns whether the proxy is alive. It is alive if its message dispatcher is processing
+   * messages.
-  protected boolean isAlive()
-  {
+  protected boolean isAlive() {
-   * Returns whether the proxy is paused. It is paused if its message dispatcher
-   * is paused. This only applies to durable clients.
+   * Returns whether the proxy is paused. It is paused if its message dispatcher is paused. This
+   * only applies to durable clients.
-   * Closes the proxy. This method checks the message queue for any unprocessed
-   * messages and processes them for MAXIMUM_SHUTDOWN_PEEKS.
+   * Closes the proxy. This method checks the message queue for any unprocessed messages and
+   * processes them for MAXIMUM_SHUTDOWN_PEEKS.
-  protected void close()
-  {
+  protected void close() {
-   * Set to true once this proxy starts being closed.
-   * Remains true for the rest of its existence.
+   * Set to true once this proxy starts being closed. Remains true for the rest of its existence.
-   * @param checkQueue
-   *          Whether to message check the queue and process any contained
-   *          messages (up to MAXIMUM_SHUTDOWN_PEEKS).
-   * @param stoppedNormally
-   *          Whether client stopped normally
+   * @param checkQueue Whether to message check the queue and process any contained messages (up to
+   *        MAXIMUM_SHUTDOWN_PEEKS).
+   * @param stoppedNormally Whether client stopped normally
-    if (isDurable()
-        && (!stoppedNormally || (getDurableKeepAlive() && stoppedNormally))) {
+    if (isDurable() && (!stoppedNormally || (getDurableKeepAlive() && stoppedNormally))) {
-        if (this.postAuthzCallback != null) {//for single user
+        if (this.postAuthzCallback != null) {// for single user
-        }else if(this.clientUserAuths != null) {//for multiple users
+        } else if (this.clientUserAuths != null) {// for multiple users
-    }
-    catch (Exception ex) {
+    } catch (Exception ex) {
-        this._cache.getSecurityLoggerI18n().warning(LocalizedStrings.TWO_ARG_COLON, new Object[] {this, ex});
+        this._cache.getSecurityLoggerI18n().warning(LocalizedStrings.TWO_ARG_COLON,
+            new Object[] {this, ex});
-    if (this._messageDispatcher == null){
+    if (this._messageDispatcher == null) {
-    //BUGFIX for BUG#38234
-    if(!testAndSetPaused(true) && this.isPrimary) {
+    // BUGFIX for BUG#38234
+    if (!testAndSetPaused(true) && this.isPrimary) {
-    
-    synchronized(this._messageDispatcher._pausedLock) {
+
+    synchronized (this._messageDispatcher._pausedLock) {
-      }
-      else {
+      } else {
+
-    if (this._messageDispatcher == null){
+    if (this._messageDispatcher == null) {
-    
+
-    if (logger.isDebugEnabled()) {
-      logger.debug("{}: Terminating processing", this);
-    }
-    if (this._messageDispatcher == Thread.currentThread()) {
-      // I'm not even sure this is possible but if the dispatcher
-      // calls us then at least call stopDispatching
-      // the old code did this (I'm not even sure it is safe to do).
-      // This needs to be done without testing OR setting "closing".
-      this._messageDispatcher.stopDispatching(checkQueue);
+      if (logger.isDebugEnabled()) {
+        logger.debug("{}: Terminating processing", this);
+      }
+      if (this._messageDispatcher == Thread.currentThread()) {
+        // I'm not even sure this is possible but if the dispatcher
+        // calls us then at least call stopDispatching
+        // the old code did this (I'm not even sure it is safe to do).
+        // This needs to be done without testing OR setting "closing".
+        this._messageDispatcher.stopDispatching(checkQueue);
+        this.cils[RegisterInterestTracker.interestListIndex].clearClientInterestList();
+        this.cils[RegisterInterestTracker.durableInterestListIndex].clearClientInterestList();
+        // VJR: bug 37487 fix
+        destroyRQ();
+        return;
+      }
+
+      if (!this.closing.compareAndSet(false, true)) {
+        // must already be closing so just return
+        // this is part of the fix for 37684
+        return;
+      }
+      // Unregister interest in all interests (if necessary)
-      // VJR: bug 37487 fix
-      destroyRQ();
-      return;
-    }
-    if (!this.closing.compareAndSet(false, true)) {
-      // must already be closing so just return
-      // this is part of the fix for 37684
-      return;
-    }
-    // Unregister interest in all interests (if necessary) 
-    this.cils[RegisterInterestTracker.interestListIndex].clearClientInterestList();
-    this.cils[RegisterInterestTracker.durableInterestListIndex].clearClientInterestList();
-
-    // If the message dispatcher is paused, unpause it. The next bit of
-    // code will interrupt the waiter.
-    if (this.testAndSetPaused(false)) {
-      if (logger.isDebugEnabled()) {
-        logger.debug("{}: Paused but terminating processing", this);
+      // If the message dispatcher is paused, unpause it. The next bit of
+      // code will interrupt the waiter.
+      if (this.testAndSetPaused(false)) {
+        if (logger.isDebugEnabled()) {
+          logger.debug("{}: Paused but terminating processing", this);
+        }
+        // Cancel the expiration task
+        cancelDurableExpirationTask(false);
-      // Cancel the expiration task
-      cancelDurableExpirationTask(false);
-    }
-    boolean alreadyDestroyed = false;
-    boolean gotInterrupt = Thread.interrupted(); // clears the flag
-    try {
-      // Stop the message dispatcher
-      this._messageDispatcher.stopDispatching(checkQueue);
+      boolean alreadyDestroyed = false;
+      boolean gotInterrupt = Thread.interrupted(); // clears the flag
+      try {
+        // Stop the message dispatcher
+        this._messageDispatcher.stopDispatching(checkQueue);
-      gotInterrupt |= Thread.interrupted(); // clears the flag
+        gotInterrupt |= Thread.interrupted(); // clears the flag
-      // to fix bug 37684
-      // 1. check to see if dispatcher is still alive
-      if (this._messageDispatcher.isAlive()) {
-        closeSocket();
-        destroyRQ();
-        alreadyDestroyed = true;
-        this._messageDispatcher.interrupt();
+        // to fix bug 37684
+        // 1. check to see if dispatcher is still alive
-          try {
-            this._messageDispatcher.join(1000);
-          } catch (InterruptedException ex) {
-            gotInterrupt = true;
-          }
-          // if it is still alive then warn and move on
+          closeSocket();
+          destroyRQ();
+          alreadyDestroyed = true;
+          this._messageDispatcher.interrupt();
-            //org.apache.geode.internal.OSProcess.printStacks(org.apache.geode.internal.OSProcess.getId());
-            logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientProxy_0_COULD_NOT_STOP_MESSAGE_DISPATCHER_THREAD, this));
+            try {
+              this._messageDispatcher.join(1000);
+            } catch (InterruptedException ex) {
+              gotInterrupt = true;
+            }
+            // if it is still alive then warn and move on
+            if (this._messageDispatcher.isAlive()) {
+              // org.apache.geode.internal.OSProcess.printStacks(org.apache.geode.internal.OSProcess.getId());
+              logger.warn(LocalizedMessage.create(
+                  LocalizedStrings.CacheClientProxy_0_COULD_NOT_STOP_MESSAGE_DISPATCHER_THREAD,
+                  this));
+            }
+      } finally {
+        if (gotInterrupt) {
+          Thread.currentThread().interrupt();
+        }
+        if (!alreadyDestroyed) {
+          destroyRQ();
+        }
-    }
-    finally {
-      if (gotInterrupt) {
-        Thread.currentThread().interrupt();
-      }
-      if (!alreadyDestroyed) {
-        destroyRQ();
-      }
-    }
-      //  Close the statistics
+      // Close the statistics
-      this._cacheClientNotifier.getSocketCloser().asyncClose(this._socket, this._remoteHostAddress, null);
+      this._cacheClientNotifier.getSocketCloser().asyncClose(this._socket, this._remoteHostAddress,
+          null);
-  
+
-    //this.clientVersion = null;
-    closeNonDurableCqs();    
+    // this.clientVersion = null;
+    closeNonDurableCqs();
-  
+
-  private void closeNonDurableCqs(){
+  private void closeNonDurableCqs() {
-      }
-      catch (CqException ex) {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientProxy_CQEXCEPTION_WHILE_CLOSING_NON_DURABLE_CQS_0, ex.getLocalizedMessage()));
+      } catch (CqException ex) {
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.CacheClientProxy_CQEXCEPTION_WHILE_CLOSING_NON_DURABLE_CQS_0,
+            ex.getLocalizedMessage()));
-  
+
-    }
-    catch (RegionDestroyedException rde) {
-//      throw rde;
-    }
-    catch (CancelException e) {
-//      throw e;
-    }
-    catch (Exception warning) {
-      logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientProxy_0_EXCEPTION_IN_CLOSING_THE_UNDERLYING_HAREGION_OF_THE_HAREGIONQUEUE, this), warning);
+    } catch (RegionDestroyedException rde) {
+      // throw rde;
+    } catch (CancelException e) {
+      // throw e;
+    } catch (Exception warning) {
+      logger.warn(LocalizedMessage.create(
+          LocalizedStrings.CacheClientProxy_0_EXCEPTION_IN_CLOSING_THE_UNDERLYING_HAREGION_OF_THE_HAREGIONQUEUE,
+          this), warning);
-  public void registerInterestRegex(String regionName, String regex,
-      boolean isDurable) {
+  public void registerInterestRegex(String regionName, String regex, boolean isDurable) {
-  
-  public void registerInterestRegex(String regionName, String regex,
-      boolean isDurable, boolean receiveValues) {
+
+  public void registerInterestRegex(String regionName, String regex, boolean isDurable,
+      boolean receiveValues) {
-      notifySecondariesAndClient(regionName, regex, InterestResultPolicy.NONE,
-          isDurable, receiveValues, InterestType.REGULAR_EXPRESSION);
+      notifySecondariesAndClient(regionName, regex, InterestResultPolicy.NONE, isDurable,
+          receiveValues, InterestType.REGULAR_EXPRESSION);
-      throw new IllegalStateException(LocalizedStrings.CacheClientProxy_NOT_PRIMARY.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.CacheClientProxy_NOT_PRIMARY.toLocalizedString());
-  public void registerInterest(String regionName, Object keyOfInterest,
-      InterestResultPolicy policy, boolean isDurable) {
+  public void registerInterest(String regionName, Object keyOfInterest, InterestResultPolicy policy,
+      boolean isDurable) {
-  
-  public void registerInterest(String regionName, Object keyOfInterest,
-      InterestResultPolicy policy, boolean isDurable,
-      boolean receiveValues) {
+
+  public void registerInterest(String regionName, Object keyOfInterest, InterestResultPolicy policy,
+      boolean isDurable, boolean receiveValues) {
-        notifySecondariesAndClient(regionName, keyOfInterest, policy,
-            isDurable, receiveValues, InterestType.KEY);
+        notifySecondariesAndClient(regionName, keyOfInterest, policy, isDurable, receiveValues,
+            InterestType.KEY);
-        throw new IllegalStateException(LocalizedStrings.CacheClientProxy_NOT_PRIMARY.toLocalizedString());
+        throw new IllegalStateException(
+            LocalizedStrings.CacheClientProxy_NOT_PRIMARY.toLocalizedString());
-        notifySecondariesAndClient(regionName, keyOfInterest, policy,
-            isDurable, receiveValues, InterestType.KEY);
-        
+        notifySecondariesAndClient(regionName, keyOfInterest, policy, isDurable, receiveValues,
+            InterestType.KEY);
+
-        //addFilterRegisteredClients(regionName, keyOfInterest);
+        // addFilterRegisteredClients(regionName, keyOfInterest);
-        throw new IllegalStateException(LocalizedStrings.CacheClientProxy_NOT_PRIMARY.toLocalizedString());
+        throw new IllegalStateException(
+            LocalizedStrings.CacheClientProxy_NOT_PRIMARY.toLocalizedString());
-  private void notifySecondariesAndClient(String regionName,
-      Object keyOfInterest, InterestResultPolicy policy, boolean isDurable,
-      boolean receiveValues, int interestType) {
+  private void notifySecondariesAndClient(String regionName, Object keyOfInterest,
+      InterestResultPolicy policy, boolean isDurable, boolean receiveValues, int interestType) {
-        new EventID(this._cache.getDistributedSystem()), regionName,
-        keyOfInterest, interestType, policy.getOrdinal(), isDurable,
-        !receiveValues, ClientInterestMessageImpl.REGISTER);
+        new EventID(this._cache.getDistributedSystem()), regionName, keyOfInterest, interestType,
+        policy.getOrdinal(), isDurable, !receiveValues, ClientInterestMessageImpl.REGISTER);
-      registerClientInterestList(regionName, (List) keyOfInterest, isDurable,
-          !receiveValues, true);
+      registerClientInterestList(regionName, (List) keyOfInterest, isDurable, !receiveValues, true);
-      registerClientInterest(regionName, keyOfInterest, interestType,
-          isDurable, !receiveValues, true);
+      registerClientInterest(regionName, keyOfInterest, interestType, isDurable, !receiveValues,
+          true);
-  private void enqueueInitialValue(ClientInterestMessageImpl clientInterestMessage, String regionName, Object keyOfInterest) {
+  private void enqueueInitialValue(ClientInterestMessageImpl clientInterestMessage,
+      String regionName, Object keyOfInterest) {
-    Get70 request = (Get70)Get70.getCommand();
+    Get70 request = (Get70) Get70.getCommand();
-        value = (byte[])entry.value;
+        value = (byte[]) entry.value;
-          logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientProxy_THE_FOLLOWING_EXCEPTION_OCCURRED_0, entry.value), e);
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.CacheClientProxy_THE_FOLLOWING_EXCEPTION_OCCURRED_0, entry.value),
+              e);
-        // If the clientInterestMessage is not null, base the event id off its event id to fix GEM-794.
-        // This will cause the updateMessage created below to have the same event id as the one created
+        // If the clientInterestMessage is not null, base the event id off its event id to fix
+        // GEM-794.
+        // This will cause the updateMessage created below to have the same event id as the one
+        // created
-      ClientUpdateMessage updateMessage = new ClientUpdateMessageImpl(
-          EnumListenerEvent.AFTER_CREATE, lr, keyOfInterest, value, null,
-          (isObject ? (byte) 0x01 : (byte) 0x00), null, this.proxyID,
-          eventId, tag);
+      ClientUpdateMessage updateMessage =
+          new ClientUpdateMessageImpl(EnumListenerEvent.AFTER_CREATE, lr, keyOfInterest, value,
+              null, (isObject ? (byte) 0x01 : (byte) 0x00), null, this.proxyID, eventId, tag);
-  
+
-     }
+      }
-  public void unregisterInterestRegex(String regionName, String regex,
-      boolean isDurable) {
+  public void unregisterInterestRegex(String regionName, String regex, boolean isDurable) {
-  
-  public void unregisterInterestRegex(String regionName, String regex,
-      boolean isDurable, boolean receiveValues) {
+
+  public void unregisterInterestRegex(String regionName, String regex, boolean isDurable,
+      boolean receiveValues) {
-      throw new IllegalStateException(LocalizedStrings.CacheClientProxy_NOT_PRIMARY.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.CacheClientProxy_NOT_PRIMARY.toLocalizedString());
-  
-  public void unregisterInterest(String regionName, Object keyOfInterest,
-      boolean isDurable) {
+
+  public void unregisterInterest(String regionName, Object keyOfInterest, boolean isDurable) {
-  
-  public void unregisterInterest(String regionName, Object keyOfInterest,
-      boolean isDurable, boolean receiveValues) {
+
+  public void unregisterInterest(String regionName, Object keyOfInterest, boolean isDurable,
+      boolean receiveValues) {
-        notifySecondariesAndClient(regionName, keyOfInterest, isDurable,
-            receiveValues, InterestType.KEY);
+        notifySecondariesAndClient(regionName, keyOfInterest, isDurable, receiveValues,
+            InterestType.KEY);
-        throw new IllegalStateException(LocalizedStrings.CacheClientProxy_NOT_PRIMARY.toLocalizedString());
+        throw new IllegalStateException(
+            LocalizedStrings.CacheClientProxy_NOT_PRIMARY.toLocalizedString());
-  private void notifySecondariesAndClient(String regionName,
-      Object keyOfInterest, boolean isDurable, boolean receiveValues,
-      int interestType) {
+  private void notifySecondariesAndClient(String regionName, Object keyOfInterest,
+      boolean isDurable, boolean receiveValues, int interestType) {
-        new EventID(this._cache.getDistributedSystem()), regionName,
-        keyOfInterest, interestType, (byte) 0, isDurable, !receiveValues,
-        ClientInterestMessageImpl.UNREGISTER);
+        new EventID(this._cache.getDistributedSystem()), regionName, keyOfInterest, interestType,
+        (byte) 0, isDurable, !receiveValues, ClientInterestMessageImpl.UNREGISTER);
- 
+
-      unregisterClientInterest(regionName, keyOfInterest, interestType,
-          false);
+      unregisterClientInterest(regionName, keyOfInterest, interestType, false);
- 
+
-  
+
-        subBuffer
-          .append("register ")
-          .append(message.getIsDurable() ? "" : "non-")
-          .append("durable interest in ");
+        subBuffer.append("register ").append(message.getIsDurable() ? "" : "non-")
+            .append("durable interest in ");
-      buffer
-        .append(this)
-        .append(": Notifying secondary proxies to ")
-        .append(subBuffer.toString())
-        .append(message.getRegionName())
-        .append("->")
-        .append(message.getKeyOfInterest())
-        .append("->")
-        .append(InterestType.getString(message.getInterestType()));
+      buffer.append(this).append(": Notifying secondary proxies to ").append(subBuffer.toString())
+          .append(message.getRegionName()).append("->").append(message.getKeyOfInterest())
+          .append("->").append(InterestType.getString(message.getInterestType()));
-  protected void addFilterRegisteredClients(String regionName,
-      Object keyOfInterest) {
-    try {
-      this._cacheClientNotifier.addFilterRegisteredClients(regionName,
-          this.proxyID);
-    } catch (RegionDestroyedException e) {
-      logger.warn(LocalizedStrings.CacheClientProxy_0_INTEREST_REG_FOR_0_FAILED, regionName + "->" + keyOfInterest, e);
-    }
-  }
-  */
-  
+   * protected void addFilterRegisteredClients(String regionName, Object keyOfInterest) { try {
+   * this._cacheClientNotifier.addFilterRegisteredClients(regionName, this.proxyID); } catch
+   * (RegionDestroyedException e) {
+   * logger.warn(LocalizedStrings.CacheClientProxy_0_INTEREST_REG_FOR_0_FAILED, regionName + "->" +
+   * keyOfInterest, e); } }
+   */
+
-   * @param regionName
-   *          The fully-qualified name of the region in which to register
-   *          interest
-   * @param keyOfInterest
-   *          The key in which to register interest
+   * @param regionName The fully-qualified name of the region in which to register interest
+   * @param keyOfInterest The key in which to register interest
-  protected void registerClientInterest(String regionName,
-      Object keyOfInterest, int interestType, boolean isDurable,
-      boolean sendUpdatesAsInvalidates, boolean flushState)
-  {
+  protected void registerClientInterest(String regionName, Object keyOfInterest, int interestType,
+      boolean isDurable, boolean sendUpdatesAsInvalidates, boolean flushState) {
-      this.cils[RegisterInterestTracker.getInterestLookupIndex(
-          isDurable, false)];
+        this.cils[RegisterInterestTracker.getInterestLookupIndex(isDurable, false)];
-      flushForInterestRegistration(regionName, this._cache.getDistributedSystem().getDistributedMember());
+      flushForInterestRegistration(regionName,
+          this._cache.getDistributedSystem().getDistributedMember());
-  
+
-   * flush other regions to the given target.  This is usually the member
-   * that is registering the interest.  During queue creation it is the
-   * queue's image provider.
+   * flush other regions to the given target. This is usually the member that is registering the
+   * interest. During queue creation it is the queue's image provider.
-      if (logger.isDebugEnabled()){
+      if (logger.isDebugEnabled()) {
-      CacheDistributionAdvisee cd = (CacheDistributionAdvisee)r;
+      CacheDistributionAdvisee cd = (CacheDistributionAdvisee) r;
-        // need to flush all buckets.  SFO should be changed to target buckets
+        // need to flush all buckets. SFO should be changed to target buckets
-        sfo = new StateFlushOperation(
-            this._cache.getDistributedSystem().getDistributionManager());
+        sfo = new StateFlushOperation(this._cache.getDistributedSystem().getDistributionManager());
-        sfo = new StateFlushOperation((DistributedRegion)r);
+        sfo = new StateFlushOperation((DistributedRegion) r);
-        sfo.flush(recips,
-            target,
-            DistributionManager.HIGH_PRIORITY_EXECUTOR, true);
+        sfo.flush(recips, target, DistributionManager.HIGH_PRIORITY_EXECUTOR, true);
-   * @param regionName
-   *          The fully-qualified name of the region in which to unregister
-   *          interest
-   * @param keyOfInterest
-   *          The key in which to unregister interest
-   * @param isClosing
-   *          Whether the caller is closing
+   * @param regionName The fully-qualified name of the region in which to unregister interest
+   * @param keyOfInterest The key in which to unregister interest
+   * @param isClosing Whether the caller is closing
-  protected void unregisterClientInterest(String regionName,
-      Object keyOfInterest, int interestType, boolean isClosing)
-  {
+  protected void unregisterClientInterest(String regionName, Object keyOfInterest, int interestType,
+      boolean isClosing) {
-        || !getDurableKeepAlive() /* close and no keepAlive*/) {
-      this.cils[RegisterInterestTracker.durableInterestListIndex].
-        unregisterClientInterest(regionName, keyOfInterest, interestType);
+        || !getDurableKeepAlive() /* close and no keepAlive */) {
+      this.cils[RegisterInterestTracker.durableInterestListIndex]
+          .unregisterClientInterest(regionName, keyOfInterest, interestType);
-    this.cils[RegisterInterestTracker.interestListIndex].
-      unregisterClientInterest(regionName, keyOfInterest, interestType);
+    this.cils[RegisterInterestTracker.interestListIndex].unregisterClientInterest(regionName,
+        keyOfInterest, interestType);
-   * @param regionName
-   *          The fully-qualified name of the region in which to register
-   *          interest
-   * @param keysOfInterest
-   *          The list of keys in which to register interest
+   * @param regionName The fully-qualified name of the region in which to register interest
+   * @param keysOfInterest The list of keys in which to register interest
-  protected void registerClientInterestList(String regionName,
-      List keysOfInterest, boolean isDurable, boolean sendUpdatesAsInvalidates,
-      boolean flushState)
-  {
+  protected void registerClientInterestList(String regionName, List keysOfInterest,
+      boolean isDurable, boolean sendUpdatesAsInvalidates, boolean flushState) {
-    ClientInterestList cil =
-      this.cils[RegisterInterestTracker.getInterestLookupIndex(
-          isDurable, false/*sendUpdatesAsInvalidates*/)];
+    ClientInterestList cil = this.cils[RegisterInterestTracker.getInterestLookupIndex(isDurable,
+        false/* sendUpdatesAsInvalidates */)];
-        flushForInterestRegistration(regionName, this._cache.getDistributedSystem().getDistributedMember());
+        flushForInterestRegistration(regionName,
+            this._cache.getDistributedSystem().getDistributedMember());
-   * @param regionName
-   *          The fully-qualified name of the region in which to unregister
-   *          interest
-   * @param keysOfInterest
-   *          The list of keys in which to unregister interest
-   * @param isClosing
-   *          Whether the caller is closing
+   * @param regionName The fully-qualified name of the region in which to unregister interest
+   * @param keysOfInterest The list of keys in which to unregister interest
+   * @param isClosing Whether the caller is closing
-  protected void unregisterClientInterest(String regionName,
-      List keysOfInterest, boolean isClosing)
-  {
+  protected void unregisterClientInterest(String regionName, List keysOfInterest,
+      boolean isClosing) {
-        || !getDurableKeepAlive() /* close and no keepAlive*/) {
-      this.cils[RegisterInterestTracker.durableInterestListIndex].
-        unregisterClientInterestList(regionName, keysOfInterest);
+        || !getDurableKeepAlive() /* close and no keepAlive */) {
+      this.cils[RegisterInterestTracker.durableInterestListIndex]
+          .unregisterClientInterestList(regionName, keysOfInterest);
-    this.cils[RegisterInterestTracker.interestListIndex].
-      unregisterClientInterestList(regionName, keysOfInterest);
+    this.cils[RegisterInterestTracker.interestListIndex].unregisterClientInterestList(regionName,
+        keysOfInterest);
-  protected void processInterestMessage(ClientInterestMessageImpl message) { 
+  protected void processInterestMessage(ClientInterestMessageImpl message) {
-    int interestType = message.getInterestType(); 
-    String regionName = message.getRegionName(); 
-    Object key = message.getKeyOfInterest(); 
+    int interestType = message.getInterestType();
+    String regionName = message.getRegionName();
+    Object key = message.getKeyOfInterest();
-        registerClientInterestList(regionName, (List) key,
-            message.getIsDurable(), message.getForUpdatesAsInvalidates(), true);
+        registerClientInterestList(regionName, (List) key, message.getIsDurable(),
+            message.getForUpdatesAsInvalidates(), true);
-        registerClientInterest(regionName, key, interestType,
-            message.getIsDurable(), message.getForUpdatesAsInvalidates(), true);
+        registerClientInterest(regionName, key, interestType, message.getIsDurable(),
+            message.getForUpdatesAsInvalidates(), true);
-       
-      // Add the client to the region's filters 
-      //addFilterRegisteredClients(regionName, key); 
- 
-      if (logger.isDebugEnabled()) { 
+
+      // Add the client to the region's filters
+      // addFilterRegisteredClients(regionName, key);
+
+      if (logger.isDebugEnabled()) {
-        buffer 
-          .append(this) 
-          .append(": Interest listener registered ") 
-          .append(message.getIsDurable() ? "" : "non-") 
-          .append("durable interest in ") 
-          .append(message.getRegionName()) 
-          .append("->") 
-          .append(message.getKeyOfInterest())
-          .append("->")
-          .append(InterestType.getString(message.getInterestType()));
-        logger.debug(buffer.toString()); 
-      } 
-    } else { 
-      // Unregister interest in this region->key 
+        buffer.append(this).append(": Interest listener registered ")
+            .append(message.getIsDurable() ? "" : "non-").append("durable interest in ")
+            .append(message.getRegionName()).append("->").append(message.getKeyOfInterest())
+            .append("->").append(InterestType.getString(message.getInterestType()));
+        logger.debug(buffer.toString());
+      }
+    } else {
+      // Unregister interest in this region->key
-       
-      if (logger.isDebugEnabled()) { 
-        StringBuffer buffer = new StringBuffer(); 
-        buffer 
-          .append(this) 
-          .append(": Interest listener unregistered interest in ") 
-          .append(message.getRegionName()) 
-          .append("->") 
-          .append(message.getKeyOfInterest())
-          .append("->")
-          .append(InterestType.getString(message.getInterestType()));
-        logger.debug(buffer.toString()); 
-      } 
+
+      if (logger.isDebugEnabled()) {
+        StringBuffer buffer = new StringBuffer();
+        buffer.append(this).append(": Interest listener unregistered interest in ")
+            .append(message.getRegionName()).append("->").append(message.getKeyOfInterest())
+            .append("->").append(InterestType.getString(message.getInterestType()));
+        logger.debug(buffer.toString());
+      }
-    
+
-    
-    // Enqueue the initial value if the message is register on a key that is not a list (fix for bug #52088)
-    if (message.isRegister()
-        && message.getInterestType() == InterestType.KEY
-        && !(key instanceof List)
-        && InterestResultPolicy.fromOrdinal(message.getInterestResultPolicy()) == InterestResultPolicy.KEYS_VALUES) {
+
+    // Enqueue the initial value if the message is register on a key that is not a list (fix for bug
+    // #52088)
+    if (message.isRegister() && message.getInterestType() == InterestType.KEY
+        && !(key instanceof List) && InterestResultPolicy
+            .fromOrdinal(message.getInterestResultPolicy()) == InterestResultPolicy.KEYS_VALUES) {
-  } 
+  }
-    if (AcceptorImpl.isAuthenticationRequired()
-        && this.postAuthzCallback == null
+    if (AcceptorImpl.isAuthenticationRequired() && this.postAuthzCallback == null
-      ClientUpdateMessageImpl cumi = (ClientUpdateMessageImpl)clientMessage;
+      ClientUpdateMessageImpl cumi = (ClientUpdateMessageImpl) clientMessage;
-        OperationContext opctxt = getOperationContext(clientMessage,
-            regionNameHolder);
+        OperationContext opctxt = getOperationContext(clientMessage, regionNameHolder);
-            if (this.proxyID.isDurable() && this.getDurableKeepAlive()
-                && this._isPaused) {
+            if (this.proxyID.isDurable() && this.getDurableKeepAlive() && this._isPaused) {
-                AuthorizeRequestPP postAuthCallback = this.clientUserAuths
-                    .getUserAuthAttributes(cqNames[i]).getPostAuthzRequest();
+                AuthorizeRequestPP postAuthCallback =
+                    this.clientUserAuths.getUserAuthAttributes(cqNames[i]).getPostAuthzRequest();
-                if (postAuthCallback != null && postAuthCallback
-                    .getPostAuthzCallback().authorizeOperation(
-                        regionNameHolder[0], opctxt)) {
+                if (postAuthCallback != null && postAuthCallback.getPostAuthzCallback()
+                    .authorizeOperation(regionNameHolder[0], opctxt)) {
-              UserAuthAttributes userAuthAttributes = this.clientUserAuths
-                  .getUserAuthAttributes(cqNames[i]);
+              UserAuthAttributes userAuthAttributes =
+                  this.clientUserAuths.getUserAuthAttributes(cqNames[i]);
-              AuthorizeRequestPP postAuthCallback = userAuthAttributes
-                  .getPostAuthzRequest();
+              AuthorizeRequestPP postAuthCallback = userAuthAttributes.getPostAuthzRequest();
-              if (postAuthCallback != null && postAuthCallback
-                  .getPostAuthzCallback().authorizeOperation(
-                      regionNameHolder[0], opctxt)) {
+              if (postAuthCallback != null && postAuthCallback.getPostAuthzCallback()
+                  .authorizeOperation(regionNameHolder[0], opctxt)) {
-            logger.debug("{}: Not adding message to queue. It is not interested in this region and key: {}", clientMessage);
+            logger.debug(
+                "{}: Not adding message to queue. It is not interested in this region and key: {}",
+                clientMessage);
-    }
-    else if (this.postAuthzCallback != null) {
+    } else if (this.postAuthzCallback != null) {
-      OperationContext opctxt = getOperationContext(clientMessage,
-          regionNameHolder);
+      OperationContext opctxt = getOperationContext(clientMessage, regionNameHolder);
-        logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientProxy__0_NOT_ADDING_MESSAGE_TO_QUEUE_1_BECAUSE_THE_OPERATION_CONTEXT_OBJECT_COULD_NOT_BE_OBTAINED_FOR_THIS_CLIENT_MESSAGE, new Object[] {this, clientMessage}));
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.CacheClientProxy__0_NOT_ADDING_MESSAGE_TO_QUEUE_1_BECAUSE_THE_OPERATION_CONTEXT_OBJECT_COULD_NOT_BE_OBTAINED_FOR_THIS_CLIENT_MESSAGE,
+            new Object[] {this, clientMessage}));
-      if (logger.isTraceEnabled()){
+      if (logger.isTraceEnabled()) {
-      if (this.proxyID.isDurable() && this.getDurableKeepAlive()
-          && this._isPaused) {
+      if (this.proxyID.isDurable() && this.getDurableKeepAlive() && this._isPaused) {
-          isAuthorize = this.postAuthzCallback.authorizeOperation(
-              regionNameHolder[0], opctxt);
+          isAuthorize = this.postAuthzCallback.authorizeOperation(regionNameHolder[0], opctxt);
-        isAuthorize = this.postAuthzCallback.authorizeOperation(
-            regionNameHolder[0], opctxt);
+        isAuthorize = this.postAuthzCallback.authorizeOperation(regionNameHolder[0], opctxt);
-        logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientProxy__0_NOT_ADDING_MESSAGE_TO_QUEUE_1_BECAUSE_AUTHORIZATION_FAILED, new Object[] {this, clientMessage}));
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.CacheClientProxy__0_NOT_ADDING_MESSAGE_TO_QUEUE_1_BECAUSE_AUTHORIZATION_FAILED,
+            new Object[] {this, clientMessage}));
-   * @param conflatable 
+   * 
+   * @param conflatable
-  protected void deliverMessage(Conflatable conflatable)
-  {
+  protected void deliverMessage(Conflatable conflatable) {
-    if(conflatable instanceof HAEventWrapper) {
-      clientMessage = ((HAEventWrapper)conflatable).getClientUpdateMessage();
+    if (conflatable instanceof HAEventWrapper) {
+      clientMessage = ((HAEventWrapper) conflatable).getClientUpdateMessage();
-      clientMessage = (ClientUpdateMessage)conflatable;
-    } 
+      clientMessage = (ClientUpdateMessage) conflatable;
+    }
-    if(this.securityService.needPostProcess()) {
+    if (this.securityService.needPostProcess()) {
-      Object newValue = securityService.postProcess(clientMessage.getRegionName(), clientMessage.getKeyOfInterest(), oldValue, clientMessage.valueIsObject());
+      Object newValue = securityService.postProcess(clientMessage.getRegionName(),
+          clientMessage.getKeyOfInterest(), oldValue, clientMessage.valueIsObject());
-          if (this.messageDispatcherInit) {  // Check to see value did not changed while getting the synchronize lock.
+          if (this.messageDispatcherInit) { // Check to see value did not changed while getting the
+                                            // synchronize lock.
-              logger.debug("Message dispatcher for proxy {} is getting initialized. Adding message to the queuedEvents.", this);
+              logger.debug(
+                  "Message dispatcher for proxy {} is getting initialized. Adding message to the queuedEvents.",
+                  this);
-      
+
-          logger.debug("Message is not added to the queue. Message dispatcher for proxy: {} doesn't exist.", this);
+          logger.debug(
+              "Message is not added to the queue. Message dispatcher for proxy: {} doesn't exist.",
+              this);
-    if(state!=null)
+    if (state != null)
-    if (logger.isDebugEnabled()){
+    if (logger.isDebugEnabled()) {
-      if (logger.isDebugEnabled()){
+      if (logger.isDebugEnabled()) {
-      if (logger.isDebugEnabled()){
+      if (logger.isDebugEnabled()) {
-  
-  private OperationContext getOperationContext(ClientMessage cmsg,
-      String[] regionNameHolder) {
-    ClientUpdateMessageImpl cmsgimpl = (ClientUpdateMessageImpl)cmsg;
+
+  private OperationContext getOperationContext(ClientMessage cmsg, String[] regionNameHolder) {
+    ClientUpdateMessageImpl cmsgimpl = (ClientUpdateMessageImpl) cmsg;
-        regionNameHolder[0] = (String)cmsgimpl.getKeyOfInterest();
+        regionNameHolder[0] = (String) cmsgimpl.getKeyOfInterest();
-      }
-      else {
-        PutOperationContext tmp = new PutOperationContext(cmsgimpl.getKeyOfInterest(), cmsgimpl
-            .getValue(), cmsgimpl.valueIsObject(), PutOperationContext.CREATE,
-            true);
+      } else {
+        PutOperationContext tmp = new PutOperationContext(cmsgimpl.getKeyOfInterest(),
+            cmsgimpl.getValue(), cmsgimpl.valueIsObject(), PutOperationContext.CREATE, true);
-    }
-    else if (cmsgimpl.isUpdate()) {
+    } else if (cmsgimpl.isUpdate()) {
-        regionNameHolder[0] = (String)cmsgimpl.getKeyOfInterest();
+        regionNameHolder[0] = (String) cmsgimpl.getKeyOfInterest();
-      }
-      else {
-        PutOperationContext tmp = new PutOperationContext(cmsgimpl.getKeyOfInterest(), cmsgimpl
-            .getValue(), cmsgimpl.valueIsObject(), PutOperationContext.UPDATE,
-            true);
+      } else {
+        PutOperationContext tmp = new PutOperationContext(cmsgimpl.getKeyOfInterest(),
+            cmsgimpl.getValue(), cmsgimpl.valueIsObject(), PutOperationContext.UPDATE, true);
-    }
-    else if (cmsgimpl.isDestroy()) {
+    } else if (cmsgimpl.isDestroy()) {
-        regionNameHolder[0] = (String)cmsgimpl.getKeyOfInterest();
+        regionNameHolder[0] = (String) cmsgimpl.getKeyOfInterest();
-      }
-      else {
-        DestroyOperationContext tmp = new DestroyOperationContext(cmsgimpl.getKeyOfInterest(), true);
+      } else {
+        DestroyOperationContext tmp =
+            new DestroyOperationContext(cmsgimpl.getKeyOfInterest(), true);
-    }
-    else if (cmsgimpl.isDestroyRegion()) {
+    } else if (cmsgimpl.isDestroyRegion()) {
-    }
-    else if (cmsgimpl.isInvalidate()) {
-      InvalidateOperationContext tmp = new InvalidateOperationContext(cmsgimpl.getKeyOfInterest(), true);
+    } else if (cmsgimpl.isInvalidate()) {
+      InvalidateOperationContext tmp =
+          new InvalidateOperationContext(cmsgimpl.getKeyOfInterest(), true);
-    }
-    else if (cmsgimpl.isClearRegion()) {
+    } else if (cmsgimpl.isClearRegion()) {
-   * Initializes the message dispatcher thread. The
-   * <code>MessageDispatcher</code> processes the message queue.
+   * Initializes the message dispatcher thread. The <code>MessageDispatcher</code> processes the
+   * message queue.
-  public void initializeMessageDispatcher() throws CacheException
-  {
+  public void initializeMessageDispatcher() throws CacheException {
-        logger.debug("{}: Initializing message dispatcher with capacity of {} entries", this, _maximumMessageCount);
+        logger.debug("{}: Initializing message dispatcher with capacity of {} entries", this,
+            _maximumMessageCount);
-      String name = "Client Message Dispatcher for "
-        + getProxyID().getDistributedMember() + (isDurable()? " (" + getDurableId()+")" : "");
+      String name = "Client Message Dispatcher for " + getProxyID().getDistributedMember()
+          + (isDurable() ? " (" + getDurableId() + ")" : "");
-      
-      //Fix for 41375 - drain as many of the queued events
-      //as we can without synchronization.
+
+      // Fix for 41375 - drain as many of the queued events
+      // as we can without synchronization.
-        logger.debug("{} draining {} events from init queue into intialized queue", this, this.queuedEvents.size());
+        logger.debug("{} draining {} events from init queue into intialized queue", this,
+            this.queuedEvents.size());
-      while((nextEvent = queuedEvents.poll()) != null) {
+      while ((nextEvent = queuedEvents.poll()) != null) {
-      
-      //Now finish emptying the queue with synchronization to make
-      //sure we don't miss any events.
-      synchronized (this.queuedEventsSync){
-          while((nextEvent = queuedEvents.poll()) != null) {
-            this._messageDispatcher.enqueueMessage(nextEvent);
-          }
-          
-          this.messageDispatcherInit = false; // Done initialization.
+
+      // Now finish emptying the queue with synchronization to make
+      // sure we don't miss any events.
+      synchronized (this.queuedEventsSync) {
+        while ((nextEvent = queuedEvents.poll()) != null) {
+          this._messageDispatcher.enqueueMessage(nextEvent);
+        }
+
+        this.messageDispatcherInit = false; // Done initialization.
-          }
-          else {
+          } else {
-   * Returns whether the client represented by this <code> CacheClientProxy
-   * </code> has registered interest in anything. @return whether the client
-   * represented by this <code> CacheClientProxy </code> has registered interest
-   * in anything
+   * Returns whether the client represented by this <code> CacheClientProxy </code> has registered
+   * interest in anything. @return whether the client represented by this <code> CacheClientProxy
+   * </code> has registered interest in anything
-  protected boolean hasRegisteredInterested()
-  {
-    return
-    this.cils[RegisterInterestTracker.interestListIndex].hasInterest() ||
-    this.cils[RegisterInterestTracker.durableInterestListIndex].hasInterest();
+  protected boolean hasRegisteredInterested() {
+    return this.cils[RegisterInterestTracker.interestListIndex].hasInterest()
+        || this.cils[RegisterInterestTracker.durableInterestListIndex].hasInterest();
-  public String toString()
-  {
+  public String toString() {
-      // .append("client proxy id=")
-      .append(this.proxyID)
-      // .append("; client host name=")
-      // .append(this._socket.getInetAddress().getCanonicalHostName())
-      // .append("; client host address=")
-      // .append(this._remoteHostAddress)
-      .append("; port=").append(this._socket.getPort())
-      .append("; primary=").append(isPrimary)
-      .append("; version=").append(clientVersion)
-      .append("]");
-    return buffer.toString();
-  }
-  
-  public String getState(){
-    StringBuffer buffer = new StringBuffer();
-    buffer.append("CacheClientProxy[")
-      // .append("client proxy id=")
-      .append(this.proxyID)
-      // .append("; client host name=")
-      // .append(this._socket.getInetAddress().getCanonicalHostName())
-      // .append("; client host address=")
-      // .append(this._remoteHostAddress)
-      .append("; port=").append(this._socket.getPort())
-      .append("; primary=").append(isPrimary)
-      .append("; version=").append(clientVersion)
-      .append("; paused=").append(isPaused())
-      .append("; alive=").append(isAlive())
-      .append("; connected=").append(isConnected())
-      .append("; isMarkedForRemoval=").append(isMarkedForRemoval)
-      .append("]");
-    
-    if(_messageDispatcher != null && isAlive()) {
-     buffer.append( LogWriterImpl.getStackTrace(_messageDispatcher));
-    }
-      
+        // .append("client proxy id=")
+        .append(this.proxyID)
+        // .append("; client host name=")
+        // .append(this._socket.getInetAddress().getCanonicalHostName())
+        // .append("; client host address=")
+        // .append(this._remoteHostAddress)
+        .append("; port=").append(this._socket.getPort()).append("; primary=").append(isPrimary)
+        .append("; version=").append(clientVersion).append("]");
-  public boolean isPrimary()
-  {
-    //boolean primary = this._messageDispatcher.isAlive()
-    //    || this._messageDispatcher._messageQueue.isPrimary();
+  public String getState() {
+    StringBuffer buffer = new StringBuffer();
+    buffer.append("CacheClientProxy[")
+        // .append("client proxy id=")
+        .append(this.proxyID)
+        // .append("; client host name=")
+        // .append(this._socket.getInetAddress().getCanonicalHostName())
+        // .append("; client host address=")
+        // .append(this._remoteHostAddress)
+        .append("; port=").append(this._socket.getPort()).append("; primary=").append(isPrimary)
+        .append("; version=").append(clientVersion).append("; paused=").append(isPaused())
+        .append("; alive=").append(isAlive()).append("; connected=").append(isConnected())
+        .append("; isMarkedForRemoval=").append(isMarkedForRemoval).append("]");
+
+    if (_messageDispatcher != null && isAlive()) {
+      buffer.append(LogWriterImpl.getStackTrace(_messageDispatcher));
+    }
+
+    return buffer.toString();
+  }
+
+  public boolean isPrimary() {
+    // boolean primary = this._messageDispatcher.isAlive()
+    // || this._messageDispatcher._messageQueue.isPrimary();
-    //System.out.println(this + ": DISPATCHER IS ALIVE: " + this._messageDispatcher.isAlive());
-    //System.out.println(this + ": DISPATCHER QUEUE IS PRIMARY: " + this._messageDispatcher._messageQueue.isPrimary());
-    //System.out.println(this + ": IS PRIMARY: " + primary);
+    // System.out.println(this + ": DISPATCHER IS ALIVE: " + this._messageDispatcher.isAlive());
+    // System.out.println(this + ": DISPATCHER QUEUE IS PRIMARY: " +
+    // this._messageDispatcher._messageQueue.isPrimary());
+    // System.out.println(this + ": IS PRIMARY: " + primary);
+   * 
-   public HARegionQueue getHARegionQueue() {
-     if (this._messageDispatcher != null){
-       return _messageDispatcher._messageQueue;
-     }
-     return null;
-   }
+  public HARegionQueue getHARegionQueue() {
+    if (this._messageDispatcher != null) {
+      return _messageDispatcher._messageQueue;
+    }
+    return null;
+  }
-   * @param socket
-   *          The socket between the server and the client
-   * @param ip
-   *          whether this proxy represents the primary
+   * 
+   * @param socket The socket between the server and the client
+   * @param ip whether this proxy represents the primary
-  protected void reinitialize(Socket socket, ClientProxyMembershipID proxyId,
-      Cache cache, boolean ip, byte cc, Version ver) {
+  protected void reinitialize(Socket socket, ClientProxyMembershipID proxyId, Cache cache,
+      boolean ip, byte cc, Version ver) {
-  
+
-  
+
-        logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientProxy_0__THE_EXPIRATION_TASK_HAS_FIRED_SO_THIS_PROXY_IS_BEING_TERMINATED, CacheClientProxy.this));
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.CacheClientProxy_0__THE_EXPIRATION_TASK_HAS_FIRED_SO_THIS_PROXY_IS_BEING_TERMINATED,
+            CacheClientProxy.this));
-         * Setting the expiration task to null again and cancelling existing
-         * one, if any. See #50894.
+         * Setting the expiration task to null again and cancelling existing one, if any. See
+         * #50894.
-         * The message dispatcher may again set the expiry task in below path:
-         * <code>
+         * The message dispatcher may again set the expiry task in below path: <code>
-         * This is because message dispatcher may get an IOException with
-         * "Proxy closing due to socket being closed locally" during/after
-         * terminateDispatching(false) above.
+         * This is because message dispatcher may get an IOException with "Proxy closing due to
+         * socket being closed locally" during/after terminateDispatching(false) above.
-          ((SystemTimerTask)task).cancel();
+          ((SystemTimerTask) task).cancel();
-    if(this._durableExpirationTask.compareAndSet(null, task)) {
-      _cache.getCCPTimer().schedule(task,
-          getDurableTimeout()*1000L);
+    if (this._durableExpirationTask.compareAndSet(null, task)) {
+      _cache.getCCPTimer().schedule(task, getDurableTimeout() * 1000L);
-        logger.info(LocalizedMessage.create(LocalizedStrings.CacheClientProxy_0_CANCELLING_EXPIRATION_TASK_SINCE_THE_CLIENT_HAS_RECONNECTED, this));
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.CacheClientProxy_0_CANCELLING_EXPIRATION_TASK_SINCE_THE_CLIENT_HAS_RECONNECTED,
+            this));
-   * Class <code>ClientInterestList</code> provides a convenient interface
-   * for manipulating client interest information.
+   * Class <code>ClientInterestList</code> provides a convenient interface for manipulating client
+   * interest information.
-  static protected class ClientInterestList
-   {
-    
+  static protected class ClientInterestList {
+
-    
+
-     /**
+    /**
-    
+
-    protected void registerClientInterest(String regionName,
-        Object keyOfInterest, int interestType, boolean sendUpdatesAsInvalidates)
-    {
+    protected void registerClientInterest(String regionName, Object keyOfInterest, int interestType,
+        boolean sendUpdatesAsInvalidates) {
-      synchronized(this.interestListLock) {
-        LocalRegion r = (LocalRegion)this.ccp._cache.getRegion(regionName, true);
+      synchronized (this.interestListLock) {
+        LocalRegion r = (LocalRegion) this.ccp._cache.getRegion(regionName, true);
-          throw new RegionDestroyedException("Region could not be found for interest registration", regionName);
+          throw new RegionDestroyedException("Region could not be found for interest registration",
+              regionName);
-        if ( ! (r instanceof CacheDistributionAdvisee) ) {
-          throw new IllegalArgumentException("region " + regionName + " is not distributed and does not support interest registration");
+        if (!(r instanceof CacheDistributionAdvisee)) {
+          throw new IllegalArgumentException("region " + regionName
+              + " is not distributed and does not support interest registration");
-        keysRegistered = p.registerClientInterest(id, keyOfInterest, interestType, sendUpdatesAsInvalidates);
+        keysRegistered =
+            p.registerClientInterest(id, keyOfInterest, interestType, sendUpdatesAsInvalidates);
-      // Perform actions if any keys were registered  
+      // Perform actions if any keys were registered
-      } 
+      }
-    
-    
+
+
-     * @param regionName
-     *          The fully-qualified name of the region in which to unregister
-     *          interest
-     * @param keyOfInterest
-     *          The key in which to unregister interest
+     * @param regionName The fully-qualified name of the region in which to unregister interest
+     * @param keyOfInterest The key in which to unregister interest
-    protected void unregisterClientInterest(String regionName,
-        Object keyOfInterest, int interestType)
-    {
+    protected void unregisterClientInterest(String regionName, Object keyOfInterest,
+        int interestType) {
-        logger.debug("{}: unregisterClientInterest region={} key={}", ccp, regionName, keyOfInterest);
+        logger.debug("{}: unregisterClientInterest region={} key={}", ccp, regionName,
+            keyOfInterest);
-      synchronized(this.interestListLock) {
+      synchronized (this.interestListLock) {
-          keysUnregistered = p.unregisterClientInterest(
-            id, keyOfInterest, interestType);
+          keysUnregistered = p.unregisterClientInterest(id, keyOfInterest, interestType);
-      if (keysUnregistered != null && !keysUnregistered.isEmpty()) { 
-        handleInterestEvent(regionName, keysUnregistered, interestType, false); 
-      } 
+      if (keysUnregistered != null && !keysUnregistered.isEmpty()) {
+        handleInterestEvent(regionName, keysUnregistered, interestType, false);
+      }
-     * @param regionName
-     *          The fully-qualified name of the region in which to register
-     *          interest
-     * @param keysOfInterest
-     *          The list of keys in which to register interest
+     * @param regionName The fully-qualified name of the region in which to register interest
+     * @param keysOfInterest The list of keys in which to register interest
-    protected void registerClientInterestList(String regionName,
-        List keysOfInterest, boolean sendUpdatesAsInvalidates) {
+    protected void registerClientInterestList(String regionName, List keysOfInterest,
+        boolean sendUpdatesAsInvalidates) {
-        throw new RegionDestroyedException("Region not found during client interest registration", regionName);
+        throw new RegionDestroyedException("Region not found during client interest registration",
+            regionName);
-      synchronized(this.interestListLock) {
+      synchronized (this.interestListLock) {
-      // Perform actions if any keys were registered 
+      // Perform actions if any keys were registered
-      } 
+      }
-     * @param regionName
-     *          The fully-qualified name of the region in which to unregister
-     *          interest
-     * @param keysOfInterest
-     *          The list of keys in which to unregister interest
+     * @param regionName The fully-qualified name of the region in which to unregister interest
+     * @param keysOfInterest The list of keys in which to unregister interest
-    protected void unregisterClientInterestList(String regionName,
-        List keysOfInterest)
-    {
+    protected void unregisterClientInterestList(String regionName, List keysOfInterest) {
-      synchronized(this.interestListLock) {
+      synchronized (this.interestListLock) {
-          keysUnregistered = p.unregisterClientInterestList(
-              id, keysOfInterest);
+          keysUnregistered = p.unregisterClientInterestList(id, keysOfInterest);
-     // Perform actions if any keys were unregistered
-      if (!keysUnregistered.isEmpty()) { 
-        handleInterestEvent(regionName, keysUnregistered, InterestType.KEY,false); 
-      } 
+      // Perform actions if any keys were unregistered
+      if (!keysUnregistered.isEmpty()) {
+        handleInterestEvent(regionName, keysUnregistered, InterestType.KEY, false);
+      }
-     * Returns whether this interest list has any keys, patterns or filters of
-     * interest. It answers the question: Are any clients being notified because
-     * of this interest list? @return whether this interest list has any keys,
-     * patterns or filters of interest
+     * Returns whether this interest list has any keys, patterns or filters of interest. It answers
+     * the question: Are any clients being notified because of this interest list? @return whether
+     * this interest list has any keys, patterns or filters of interest
-      
-      synchronized(this.interestListLock) {
-        for (String regionName: regions) {
+
+      synchronized (this.interestListLock) {
+        for (String regionName : regions) {
-              handleInterestEvent(regionName, allKeys,
-                  InterestType.REGULAR_EXPRESSION, false);
+              handleInterestEvent(regionName, allKeys, InterestType.REGULAR_EXPRESSION, false);
-              handleInterestEvent(regionName, keysOfInterest,
-                  InterestType.KEY, false);
+              handleInterestEvent(regionName, keysOfInterest, InterestType.KEY, false);
-            Map<String,Pattern> patternsOfInterest =
-              p.getPatternsOfInterestFor(id);
+            Map<String, Pattern> patternsOfInterest = p.getPatternsOfInterestFor(id);
-    private void handleInterestEvent(String regionName, Set keysOfInterest,
-        int interestType, boolean isRegister) {
+    private void handleInterestEvent(String regionName, Set keysOfInterest, int interestType,
+        boolean isRegister) {
-      if (NOTIFY_REGION_ON_INTEREST && this.ccp.isPrimary()
-          && interestType == InterestType.KEY) {
-        event = new InterestRegistrationEventImpl(this.ccp, regionName,
-            keysOfInterest, interestType, isRegister);
+      if (NOTIFY_REGION_ON_INTEREST && this.ccp.isPrimary() && interestType == InterestType.KEY) {
+        event = new InterestRegistrationEventImpl(this.ccp, regionName, keysOfInterest,
+            interestType, isRegister);
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
-          event = new InterestRegistrationEventImpl(this.ccp, regionName,
-              keysOfInterest, interestType, isRegister);
+          event = new InterestRegistrationEventImpl(this.ccp, regionName, keysOfInterest,
+              interestType, isRegister);
-      }      
+      }
-    private void notifyInterestRegistrationListeners(
-        InterestRegistrationEvent event) {
-      this.ccp.getCacheClientNotifier().notifyInterestRegistrationListeners(
-          event);
+    private void notifyInterestRegistrationListeners(InterestRegistrationEvent event) {
+      this.ccp.getCacheClientNotifier().notifyInterestRegistrationListeners(event);
-      return this.ccp.getCacheClientNotifier()
-          .containsInterestRegistrationListeners();
+      return this.ccp.getCacheClientNotifier().containsInterestRegistrationListeners();
-   * Class <code>MessageDispatcher</code> is a <code>Thread</code> that
-   * processes messages bound for the client by taking messsages from the
-   * message queue and sending them to the client over the socket.
+   * Class <code>MessageDispatcher</code> is a <code>Thread</code> that processes messages bound for
+   * the client by taking messsages from the message queue and sending them to the client over the
+   * socket.
-  static class MessageDispatcher extends Thread
-   {
+  static class MessageDispatcher extends Thread {
-//    /**
-//     * An int used to keep track of the number of messages dropped for logging
-//     * purposes. If greater than zero then a warning has been logged about
-//     * messages being dropped.
-//     */
-//    private int _numberOfMessagesDropped = 0;
+    // /**
+    // * An int used to keep track of the number of messages dropped for logging
+    // * purposes. If greater than zero then a warning has been logged about
+    // * messages being dropped.
+    // */
+    // private int _numberOfMessagesDropped = 0;
-//    /**
-//     * The conflator faciliates message conflation
-//     */
-//     protected BridgeEventConflator _eventConflator;
+    // /**
+    // * The conflator faciliates message conflation
+    // */
+    // protected BridgeEventConflator _eventConflator;
-    //boolean _isPausedDispatcher = false;
-    
+    // boolean _isPausedDispatcher = false;
+
-//    /**
-//     * A boolean verifying whether a warning has already been issued if the
-//     * message queue has reached its capacity.
-//     */
-//    private boolean _messageQueueCapacityReachedWarning = false;
+    // /**
+    // * A boolean verifying whether a warning has already been issued if the
+    // * message queue has reached its capacity.
+    // */
+    // private boolean _messageQueueCapacityReachedWarning = false;
-     * @param proxy
-     *          The <code>CacheClientProxy</code> for which this dispatcher is
-     *          processing messages
+     * @param proxy The <code>CacheClientProxy</code> for which this dispatcher is processing
+     *        messages
-        HARegionQueueAttributes harq= new HARegionQueueAttributes();
+        HARegionQueueAttributes harq = new HARegionQueueAttributes();
-        ((HAContainerWrapper)proxy._cacheClientNotifier.getHaContainer())
-            .putProxy(HARegionQueue.createRegionName(getProxy()
-                .getHARegionName()), getProxy());
-        boolean createDurableQueue = proxy.proxyID.isDurable();            
+        ((HAContainerWrapper) proxy._cacheClientNotifier.getHaContainer())
+            .putProxy(HARegionQueue.createRegionName(getProxy().getHARegionName()), getProxy());
+        boolean createDurableQueue = proxy.proxyID.isDurable();
-            && InternalDistributedSystem.getAnyInstance().getConfig()
-                .getDeltaPropagation()
+            && InternalDistributedSystem.getAnyInstance().getConfig().getDeltaPropagation()
-        this._messageQueue = 
-          HARegionQueue.getHARegionQueueInstance(
-              getProxy().getHARegionName(), getCache(), harq,
-              HARegionQueue.BLOCKING_HA_QUEUE, createDurableQueue, 
-              proxy._cacheClientNotifier.getHaContainer(),
-              proxy.getProxyID(),
-              this._proxy.clientConflation,
-              this._proxy.isPrimary(), canHandleDelta);
+        this._messageQueue = HARegionQueue.getHARegionQueueInstance(getProxy().getHARegionName(),
+            getCache(), harq, HARegionQueue.BLOCKING_HA_QUEUE, createDurableQueue,
+            proxy._cacheClientNotifier.getHaContainer(), proxy.getProxyID(),
+            this._proxy.clientConflation, this._proxy.isPrimary(), canHandleDelta);
-      }
-      catch (CancelException e) {
+      } catch (CancelException e) {
-      }
-      catch (RegionExistsException ree) {
+      } catch (RegionExistsException ree) {
-      }
-      catch (Exception e) {
+      } catch (Exception e) {
-        throw new CacheException(LocalizedStrings.CacheClientProxy_EXCEPTION_OCCURRED_WHILE_TRYING_TO_CREATE_A_MESSAGE_QUEUE.toLocalizedString(), e) {
-          private static final long serialVersionUID = 0L;};
+        throw new CacheException(
+            LocalizedStrings.CacheClientProxy_EXCEPTION_OCCURRED_WHILE_TRYING_TO_CREATE_A_MESSAGE_QUEUE
+                .toLocalizedString(),
+            e) {
+          private static final long serialVersionUID = 0L;
+        };
-    
+
+
+
+
+
-     * @param checkQueue
-     *          Whether to check the message queue for any unprocessed messages
-     *          and process them for MAXIMUM_SHUTDOWN_PEEKS.
+     * @param checkQueue Whether to check the message queue for any unprocessed messages and process
+     *        them for MAXIMUM_SHUTDOWN_PEEKS.
-    protected synchronized void stopDispatching(boolean checkQueue)
-    {
-      if (isStopped()) {     
+    protected synchronized void stopDispatching(boolean checkQueue) {
+      if (isStopped()) {
-        for (int numberOfPeeks = 0; numberOfPeeks < MAXIMUM_SHUTDOWN_PEEKS;
-            ++numberOfPeeks) {
+        for (int numberOfPeeks = 0; numberOfPeeks < MAXIMUM_SHUTDOWN_PEEKS; ++numberOfPeeks) {
-            if (logger.isDebugEnabled()){
-           logger.debug("Waiting for client to drain queue: {}", _proxy.proxyID);
+            if (logger.isDebugEnabled()) {
+              logger.debug("Waiting for client to drain queue: {}", _proxy.proxyID);
-          }
-          catch (InterruptedException e) {
+          } catch (InterruptedException e) {
-            /*GemFireCache c = (GemFireCache)_cache;
-            c.getDistributedSystem().getCancelCriterion().checkCancelInProgress(e);*/
-          }
-          catch (CancelException e) {
+            /*
+             * GemFireCache c = (GemFireCache)_cache;
+             * c.getDistributedSystem().getCancelCriterion().checkCancelInProgress(e);
+             */
+          } catch (CancelException e) {
-          }
-          catch (CacheException e) {
+          } catch (CacheException e) {
-          }
-          finally {
-            if (interrupted) Thread.currentThread().interrupt();
+          } finally {
+            if (interrupted)
+              Thread.currentThread().interrupt();
-      }
-      finally {
+      } finally {
-    protected boolean isStopped()
-    {
+    protected boolean isStopped() {
-     * Returns the size of the queue for heuristic purposes. This size may be
-     * changing concurrently if puts / gets are occurring at the same time.
+     * Returns the size of the queue for heuristic purposes. This size may be changing concurrently
+     * if puts / gets are occurring at the same time.
-    protected int getQueueSize()
-    {
+    protected int getQueueSize() {
-    
+
-     * Returns the size of the queue calculated through stats
-     * This includes events that have dispatched but have yet been removed
+     * Returns the size of the queue calculated through stats This includes events that have
+     * dispatched but have yet been removed
+     * 
-    protected int getQueueSizeStat()
-    {
+    protected int getQueueSizeStat() {
-        return ((int)(stats.getEventsEnqued() - stats.getEventsRemoved() - stats.getEventsConflated() - stats.getMarkerEventsConflated() - stats.getEventsExpired() - stats.getEventsRemovedByQrm() - stats.getEventsTaken() - stats.getNumVoidRemovals()));
+        return ((int) (stats.getEventsEnqued() - stats.getEventsRemoved()
+            - stats.getEventsConflated() - stats.getMarkerEventsConflated()
+            - stats.getEventsExpired() - stats.getEventsRemovedByQrm() - stats.getEventsTaken()
+            - stats.getNumVoidRemovals()));
-    
-    protected void drainClientCqEvents(ClientProxyMembershipID clientId, InternalCqQuery cqToClose) {
-        this._messageQueue.closeClientCq(clientId, cqToClose);
+
+    protected void drainClientCqEvents(ClientProxyMembershipID clientId,
+        InternalCqQuery cqToClose) {
+      this._messageQueue.closeClientCq(clientId, cqToClose);
-    
+
-     * Runs the dispatcher by taking a message from the queue and sending it to
-     * the client attached to this proxy.
+     * Runs the dispatcher by taking a message from the queue and sending it to the client attached
+     * to this proxy.
-    public void run()
-    {
+    public void run() {
-        long slowStartTimeForTesting = Long.getLong(KEY_SLOW_START_TIME_FOR_TESTING,
-            DEFAULT_SLOW_STARTING_TIME).longValue();
+        long slowStartTimeForTesting =
+            Long.getLong(KEY_SLOW_START_TIME_FOR_TESTING, DEFAULT_SLOW_STARTING_TIME).longValue();
-          }
-          catch (InterruptedException ignore) {
+          } catch (InterruptedException ignore) {
-        if(slowStartTimeForTesting < elapsedTime) {
+        if (slowStartTimeForTesting < elapsedTime) {
-//        SystemFailure.checkFailure(); DM's stopper does this
+        // SystemFailure.checkFailure(); DM's stopper does this
-            // ARB: Before waiting for resumption, process acks from client. 
+            // ARB: Before waiting for resumption, process acks from client.
-                logger.info("available ids = " + this._messageQueue.size()+ " , isEmptyAckList =" + this._messageQueue.isEmptyAckList() 
-                            + ", peekInitialized = " + this._messageQueue.isPeekInitialized());
-                while (!this._messageQueue.isEmptyAckList()&& this._messageQueue.isPeekInitialized()) {
+                logger.info("available ids = " + this._messageQueue.size() + " , isEmptyAckList ="
+                    + this._messageQueue.isEmptyAckList() + ", peekInitialized = "
+                    + this._messageQueue.isPeekInitialized());
+                while (!this._messageQueue.isEmptyAckList()
+                    && this._messageQueue.isPeekInitialized()) {
-              }
-              catch (InterruptedException ex) {
-                logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientProxy_0_SLEEP_INTERRUPTED, this));
+              } catch (InterruptedException ex) {
+                logger.warn(LocalizedMessage
+                    .create(LocalizedStrings.CacheClientProxy_0_SLEEP_INTERRUPTED, this));
-            clientMessage = (ClientMessage)this._messageQueue.peek();
-          }
-          catch (RegionDestroyedException skipped) {
+            clientMessage = (ClientMessage) this._messageQueue.peek();
+          } catch (RegionDestroyedException skipped) {
-          if(isDispatched){
+          if (isDispatched) {
-                logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientProxy_0_PROXY_CLOSING_DUE_TO_UNEXPECTED_BROKEN_PIPE_ON_SOCKET_CONNECTION, this));
+                logger.warn(LocalizedMessage.create(
+                    LocalizedStrings.CacheClientProxy_0_PROXY_CLOSING_DUE_TO_UNEXPECTED_BROKEN_PIPE_ON_SOCKET_CONNECTION,
+                    this));
-                logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientProxy_0_PROXY_CLOSING_DUE_TO_UNEXPECTED_RESET_ON_SOCKET_CONNECTION, this));
-              }
-              else if ("Connection reset by peer".equals(e.getMessage())) {
-                logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientProxy_0_PROXY_CLOSING_DUE_TO_UNEXPECTED_RESET_BY_PEER_ON_SOCKET_CONNECTION, this));
-              }
-              else if ("Socket is closed".equals(e.getMessage()) || "Socket Closed".equals(e.getMessage())) {
-                logger.info(LocalizedMessage.create(LocalizedStrings.CacheClientProxy_0_PROXY_CLOSING_DUE_TO_SOCKET_BEING_CLOSED_LOCALLY, this));
-              }
-              else {
-                logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientProxy_0_AN_UNEXPECTED_IOEXCEPTION_OCCURRED_SO_THE_PROXY_WILL_BE_CLOSED, this), e);
+                logger.warn(LocalizedMessage.create(
+                    LocalizedStrings.CacheClientProxy_0_PROXY_CLOSING_DUE_TO_UNEXPECTED_RESET_ON_SOCKET_CONNECTION,
+                    this));
+              } else if ("Connection reset by peer".equals(e.getMessage())) {
+                logger.warn(LocalizedMessage.create(
+                    LocalizedStrings.CacheClientProxy_0_PROXY_CLOSING_DUE_TO_UNEXPECTED_RESET_BY_PEER_ON_SOCKET_CONNECTION,
+                    this));
+              } else if ("Socket is closed".equals(e.getMessage())
+                  || "Socket Closed".equals(e.getMessage())) {
+                logger.info(LocalizedMessage.create(
+                    LocalizedStrings.CacheClientProxy_0_PROXY_CLOSING_DUE_TO_SOCKET_BEING_CLOSED_LOCALLY,
+                    this));
+              } else {
+                logger.warn(LocalizedMessage.create(
+                    LocalizedStrings.CacheClientProxy_0_AN_UNEXPECTED_IOEXCEPTION_OCCURRED_SO_THE_PROXY_WILL_BE_CLOSED,
+                    this), e);
-              logger.debug("{}: interrupted because it is being paused. It will continue and wait for resumption.", this);
+              logger.debug(
+                  "{}: interrupted because it is being paused. It will continue and wait for resumption.",
+                  this);
-        }
-        catch (CancelException e) {
+        } catch (CancelException e) {
-        }
-        catch (RegionDestroyedException e) {
+        } catch (RegionDestroyedException e) {
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
-            logger.fatal(LocalizedMessage.create(LocalizedStrings.CacheClientProxy_0__AN_UNEXPECTED_EXCEPTION_OCCURRED, this), e);
+            logger.fatal(
+                LocalizedMessage.create(
+                    LocalizedStrings.CacheClientProxy_0__AN_UNEXPECTED_EXCEPTION_OCCURRED, this),
+                e);
-      if(!exceptionOccured) {
-      try {
-        // Clear the interrupt status if any,
-        Thread.interrupted();
-        int size = this._messageQueue.size();
-        list = this._messageQueue.peek(size);
-        if (logger.isDebugEnabled()) {
-          logger.debug("{}: After flagging the dispatcher to stop , the residual List of messages to be dispatched={} size={}", this, list, list.size());
-        }
-        if (list.size() > 0) {
-          long start = getStatistics().startTime();
-          Iterator itr = list.iterator();
-          while (itr.hasNext()) {
-            dispatchMessage((ClientMessage)itr.next());
-            getStatistics().endMessage(start);
-            // @todo asif: shouldn't we call itr.remove() since the current msg
-            //             has been sent? That way list will be more accurate
-            //             if we have an exception.
+      if (!exceptionOccured) {
+        try {
+          // Clear the interrupt status if any,
+          Thread.interrupted();
+          int size = this._messageQueue.size();
+          list = this._messageQueue.peek(size);
+          if (logger.isDebugEnabled()) {
+            logger.debug(
+                "{}: After flagging the dispatcher to stop , the residual List of messages to be dispatched={} size={}",
+                this, list, list.size());
-          this._messageQueue.remove();
-        }
-      }
-      catch (CancelException e) {
-        if (logger.isDebugEnabled()) {
-          logger.debug("CacheClientNotifier stopped due to cancellation");
-        }
-      }
-      catch (Exception ignore) {
-        //if (logger.isInfoEnabled()) {
+          if (list.size() > 0) {
+            long start = getStatistics().startTime();
+            Iterator itr = list.iterator();
+            while (itr.hasNext()) {
+              dispatchMessage((ClientMessage) itr.next());
+              getStatistics().endMessage(start);
+              // @todo asif: shouldn't we call itr.remove() since the current msg
+              // has been sent? That way list will be more accurate
+              // if we have an exception.
+            }
+            this._messageQueue.remove();
+          }
+        } catch (CancelException e) {
+          if (logger.isDebugEnabled()) {
+            logger.debug("CacheClientNotifier stopped due to cancellation");
+          }
+        } catch (Exception ignore) {
+          // if (logger.isInfoEnabled()) {
-          
-          if ("Broken pipe".equals(ignore.getMessage())) {            
+
+          if ("Broken pipe".equals(ignore.getMessage())) {
+          } else if (ignore instanceof RegionDestroyedException) {
+            extraMsg =
+                LocalizedStrings.CacheClientProxy_PROBLEM_CAUSED_BY_MESSAGE_QUEUE_BEING_CLOSED;
-          else if (ignore instanceof RegionDestroyedException) {
-            extraMsg = LocalizedStrings.CacheClientProxy_PROBLEM_CAUSED_BY_MESSAGE_QUEUE_BEING_CLOSED;
-          }
-          final Object[] msgArgs = new Object[] {
-              ((!isStopped()) ? this.toString() + ": " : ""),
-              ((list == null) ? 0 : list.size())};        
+          final Object[] msgArgs = new Object[] {((!isStopped()) ? this.toString() + ": " : ""),
+              ((list == null) ? 0 : list.size())};
-            //Dont print exception details, but add on extraMsg
-            logger.info(LocalizedMessage.create(LocalizedStrings.CacheClientProxy_0_POSSIBILITY_OF_NOT_BEING_ABLE_TO_SEND_SOME_OR_ALL_THE_MESSAGES_TO_CLIENTS_TOTAL_MESSAGES_CURRENTLY_PRESENT_IN_THE_LIST_1, msgArgs));
+            // Dont print exception details, but add on extraMsg
+            logger.info(LocalizedMessage.create(
+                LocalizedStrings.CacheClientProxy_0_POSSIBILITY_OF_NOT_BEING_ABLE_TO_SEND_SOME_OR_ALL_THE_MESSAGES_TO_CLIENTS_TOTAL_MESSAGES_CURRENTLY_PRESENT_IN_THE_LIST_1,
+                msgArgs));
-            //Print full stacktrace
-            logger.info(LocalizedMessage.create(LocalizedStrings.CacheClientProxy_0_POSSIBILITY_OF_NOT_BEING_ABLE_TO_SEND_SOME_OR_ALL_THE_MESSAGES_TO_CLIENTS_TOTAL_MESSAGES_CURRENTLY_PRESENT_IN_THE_LIST_1, msgArgs), ignore);
+            // Print full stacktrace
+            logger.info(LocalizedMessage.create(
+                LocalizedStrings.CacheClientProxy_0_POSSIBILITY_OF_NOT_BEING_ABLE_TO_SEND_SOME_OR_ALL_THE_MESSAGES_TO_CLIENTS_TOTAL_MESSAGES_CURRENTLY_PRESENT_IN_THE_LIST_1,
+                msgArgs), ignore);
-      //}
+        // }
-      }
-      else {
+      } else {
-    
+
-     * @param clientMessage
-     *          The <code>ClientMessage</code> to send to the client
+     * @param clientMessage The <code>ClientMessage</code> to send to the client
-    protected boolean dispatchMessage(ClientMessage clientMessage)
-        throws IOException
-    {
-      boolean isDispatched = false ;
+    protected boolean dispatchMessage(ClientMessage clientMessage) throws IOException {
+      boolean isDispatched = false;
-     if (clientMessage instanceof ClientUpdateMessage) {
-        byte[] latestValue = (byte[])((ClientUpdateMessage)clientMessage).getValue();
+      if (clientMessage instanceof ClientUpdateMessage) {
+        byte[] latestValue = (byte[]) ((ClientUpdateMessage) clientMessage).getValue();
-          if (((ClientUpdateMessage)clientMessage).valueIsObject()) {
+          if (((ClientUpdateMessage) clientMessage).valueIsObject()) {
-        
-        message = ((ClientUpdateMessageImpl)clientMessage).getMessage(getProxy(),
-            latestValue);
-        
+
+        message = ((ClientUpdateMessageImpl) clientMessage).getMessage(getProxy(), latestValue);
+
-     }
-     else {
-       message = clientMessage.getMessage(getProxy(), true /* notify */);
-     }
-
-      // //////////////////////////////
-      // TEST CODE BEGIN (Throws exception to test closing proxy)
-      // if (true) throw new IOException("test");
-      // TEST CODE END
-      // //////////////////////////////
-     // Message message = ((ClientUpdateMessageImpl)clientMessage).getMessage(getProxy().proxyID, latestValue);
-     //Message message = clientMessage.getMessage(); removed during merge.
-     // BugFix for BUG#38206 and BUG#37791
-     if (!this._proxy.isPaused()) {
-       sendMessage(message);
-
-      // //////////////////////////////
-      // TEST CODE BEGIN (Throws exception to test closing proxy)
-      // if (true) throw new IOException("test");
-      // TEST CODE END
-      // //////////////////////////////
-      //Message message = ((ClientUpdateMessageImpl)clientMessage).getMessage(getProxy().proxyID, latestValue);
-      //Message message = clientMessage.getMessage(); removed during merge.
-      //message.setComms(getSocket(), getCommBuffer(), getStatistics());
-      //message.send();
-
-      // //////////////////////////////
-      // TEST CODE BEGIN (Introduces random wait in client)
-      // Sleep a random number of ms
-      // java.util.Random rand = new java.util.Random();
-      // try {Thread.sleep(rand.nextInt(5));} catch (InterruptedException e) {}
-      // TEST CODE END
-      // //////////////////////////////
-
-      if (logger.isTraceEnabled()) {
-        logger.trace("{}: Dispatched {}", this, clientMessage);
+      } else {
+        message = clientMessage.getMessage(getProxy(), true /* notify */);
-      isDispatched = true;
-     }
-     else {
-       if (logger.isDebugEnabled()) {
-         logger.debug("Message Dispatcher of a Paused CCProxy is trying to dispatch message");
-       }
-     }
-     if (isDispatched) {
-       this._messageQueue.getStatistics().incEventsDispatched();
-     }
-     return isDispatched;
+
+      // //////////////////////////////
+      // TEST CODE BEGIN (Throws exception to test closing proxy)
+      // if (true) throw new IOException("test");
+      // TEST CODE END
+      // //////////////////////////////
+      // Message message = ((ClientUpdateMessageImpl)clientMessage).getMessage(getProxy().proxyID,
+      // latestValue);
+      // Message message = clientMessage.getMessage(); removed during merge.
+      // BugFix for BUG#38206 and BUG#37791
+      if (!this._proxy.isPaused()) {
+        sendMessage(message);
+
+        // //////////////////////////////
+        // TEST CODE BEGIN (Throws exception to test closing proxy)
+        // if (true) throw new IOException("test");
+        // TEST CODE END
+        // //////////////////////////////
+        // Message message = ((ClientUpdateMessageImpl)clientMessage).getMessage(getProxy().proxyID,
+        // latestValue);
+        // Message message = clientMessage.getMessage(); removed during merge.
+        // message.setComms(getSocket(), getCommBuffer(), getStatistics());
+        // message.send();
+
+        // //////////////////////////////
+        // TEST CODE BEGIN (Introduces random wait in client)
+        // Sleep a random number of ms
+        // java.util.Random rand = new java.util.Random();
+        // try {Thread.sleep(rand.nextInt(5));} catch (InterruptedException e) {}
+        // TEST CODE END
+        // //////////////////////////////
+
+        if (logger.isTraceEnabled()) {
+          logger.trace("{}: Dispatched {}", this, clientMessage);
+        }
+        isDispatched = true;
+      } else {
+        if (logger.isDebugEnabled()) {
+          logger.debug("Message Dispatcher of a Paused CCProxy is trying to dispatch message");
+        }
+      }
+      if (isDispatched) {
+        this._messageQueue.getStatistics().incEventsDispatched();
+      }
+      return isDispatched;
-    
+
-     * @param clientMessage
-     *          The <code>Conflatable</code> to add to the queue
+     * @param clientMessage The <code>Conflatable</code> to add to the queue
-    protected void enqueueMessage(Conflatable clientMessage)
-    {
+    protected void enqueueMessage(Conflatable clientMessage) {
-          this._messageQueue.put(clientMessage);
-          if(this._proxy.isPaused() && this._proxy.isDurable()){
-            this._proxy._cacheClientNotifier._statistics.incEventEnqueuedWhileClientAwayCount();
-            if (logger.isDebugEnabled()) {
-              logger.debug("{}: Queued message while Durable Client is away {}", this, clientMessage);
-            }
-          } else {
-// [bruce] we don't really know that it was added, so don't log this
-//            if (logger.isDebugEnabled() || BridgeServerImpl.VERBOSE) {
-//              logger.debug(LocalizedStrings.DEBUG, this + " added message to queue: " + clientMessage);
-//          }
-      }
-      }
-      catch (CancelException e) {
+        this._messageQueue.put(clientMessage);
+        if (this._proxy.isPaused() && this._proxy.isDurable()) {
+          this._proxy._cacheClientNotifier._statistics.incEventEnqueuedWhileClientAwayCount();
+          if (logger.isDebugEnabled()) {
+            logger.debug("{}: Queued message while Durable Client is away {}", this, clientMessage);
+          }
+        } else {
+          // [bruce] we don't really know that it was added, so don't log this
+          // if (logger.isDebugEnabled() || BridgeServerImpl.VERBOSE) {
+          // logger.debug(LocalizedStrings.DEBUG, this + " added message to queue: " +
+          // clientMessage);
+          // }
+        }
+      } catch (CancelException e) {
-      }
-      catch (Exception e) {
+      } catch (Exception e) {
-          logger.fatal(LocalizedMessage.create(LocalizedStrings.CacheClientProxy_0_EXCEPTION_OCCURRED_WHILE_ATTEMPTING_TO_ADD_MESSAGE_TO_QUEUE, this), e);
+          logger.fatal(LocalizedMessage.create(
+              LocalizedStrings.CacheClientProxy_0_EXCEPTION_OCCURRED_WHILE_ATTEMPTING_TO_ADD_MESSAGE_TO_QUEUE,
+              this), e);
-          logger.debug("{}: Queueing marker message. <{}>. The queue contains {} entries.", this, message, getQueueSize());
+          logger.debug("{}: Queueing marker message. <{}>. The queue contains {} entries.", this,
+              message, getQueueSize());
-          logger.debug("{}: Queued marker message. The queue contains {} entries.", this, getQueueSize());
+          logger.debug("{}: Queued marker message. The queue contains {} entries.", this,
+              getQueueSize());
-      }
-      catch (CancelException e) {
+      } catch (CancelException e) {
-      }
-      catch (Exception e) {
+      } catch (Exception e) {
-          logger.fatal(LocalizedMessage.create(LocalizedStrings.CacheClientProxy_0__EXCEPTION_OCCURRED_WHILE_ATTEMPTING_TO_ADD_MESSAGE_TO_QUEUE, this), e);
+          logger.fatal(LocalizedMessage.create(
+              LocalizedStrings.CacheClientProxy_0__EXCEPTION_OCCURRED_WHILE_ATTEMPTING_TO_ADD_MESSAGE_TO_QUEUE,
+              this), e);
-            logger.fatal(LocalizedMessage.create(LocalizedStrings.CacheClientProxy_0__AN_UNEXPECTED_EXCEPTION_OCCURRED, this), e);
+            logger.fatal(
+                LocalizedMessage.create(
+                    LocalizedStrings.CacheClientProxy_0__AN_UNEXPECTED_EXCEPTION_OCCURRED, this),
+                e);
-          logger.fatal(LocalizedMessage.create(LocalizedStrings.CacheClientProxy_0__AN_UNEXPECTED_EXCEPTION_OCCURRED, this), e);
+          logger.fatal(LocalizedMessage.create(
+              LocalizedStrings.CacheClientProxy_0__AN_UNEXPECTED_EXCEPTION_OCCURRED, this), e);
-        logger.info(LocalizedMessage.create(LocalizedStrings.CacheClientProxy_0__PAUSING_PROCESSING, this));
+        logger.info(
+            LocalizedMessage.create(LocalizedStrings.CacheClientProxy_0__PAUSING_PROCESSING, this));
-        logger.info(LocalizedMessage.create(LocalizedStrings.CacheClientProxy_0__RESUMING_PROCESSING, this));
+      logger.info(
+          LocalizedMessage.create(LocalizedStrings.CacheClientProxy_0__RESUMING_PROCESSING, this));
-        // Notify thread to resume
-        this._pausedLock.notifyAll();
+      // Notify thread to resume
+      this._pausedLock.notifyAll();
-    protected Object deserialize(byte[] serializedBytes)
-    {
+    protected Object deserialize(byte[] serializedBytes) {
-        DataInputStream dis = new DataInputStream(new ByteArrayInputStream(
-            serializedBytes));
+        DataInputStream dis = new DataInputStream(new ByteArrayInputStream(serializedBytes));
-      }
-      catch (Exception e) {
+      } catch (Exception e) {
-    
-    protected void initializeTransients()
-    {
-        while (!this._messageQueue.isEmptyAckList()&& this._messageQueue.isPeekInitialized()) {
-            try {
-                this._messageQueue.remove();
-            }catch(InterruptedException e){
-                e.printStackTrace();
-            }
+
+    protected void initializeTransients() {
+      while (!this._messageQueue.isEmptyAckList() && this._messageQueue.isPeekInitialized()) {
+        try {
+          this._messageQueue.remove();
+        } catch (InterruptedException e) {
+          e.printStackTrace();
+      }
-  public  void incCqCount() {
+  public void incCqCount() {
-   * Returns the number of seconds that have elapsed since the Client proxy
-   * created.
+   * Returns the number of seconds that have elapsed since the Client proxy created.
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV65 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
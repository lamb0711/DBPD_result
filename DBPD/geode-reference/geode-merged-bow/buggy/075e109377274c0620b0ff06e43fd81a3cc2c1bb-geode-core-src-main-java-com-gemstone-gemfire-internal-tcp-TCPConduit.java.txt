Caching the CLUSTER component SocketCreator in TCPConduit

This avoids fetching the SocketCreator each time it's going to be used.
TCPConduit holds onto it and it and Connection use the cached instance.

LocatorDUnitTest SSL tests were failing due to inadequate clean-up in
all of the DUnit JVMs.  Clean-up was only happening in the controller
JVM and in those that use the inherited distributed-system creation
methods.  LocatorDUnitTest can't use the inherited methods since they
force use of the DUnit Locator.  I've removed the FlakyTest designation
from the affected tests.

-  private volatile boolean inhibitNewConnections;
+  /**
+   * The socket producer used by the cluster
+   */
+  private final SocketCreator socketCreator;
-  //  private transient DistributedMembershipListener messageReceiver;
+    
+    this.socketCreator = SocketCreatorFactory.getSSLSocketCreatorForComponent(SSLEnabledComponent.CLUSTER);
-          socket = SocketCreatorFactory.getSSLSocketCreatorForComponent(SSLEnabledComponent.CLUSTER).createServerSocketUsingPortRange(bindAddress, b, isBindAddress, this.useNIO, 0, tcpPortRange);
+          socket = socketCreator.createServerSocketUsingPortRange(bindAddress, b, isBindAddress, this.useNIO, 0, tcpPortRange);
-            socket = SocketCreatorFactory.getSSLSocketCreatorForComponent(SSLEnabledComponent.CLUSTER)
-                                         .createServerSocketUsingPortRange(bindAddress, b, isBindAddress, this.useNIO, this.tcpBufferSize, tcpPortRange);
+            socket = socketCreator.createServerSocketUsingPortRange(bindAddress, b, isBindAddress, this.useNIO, this.tcpBufferSize, tcpPortRange);
-            socket = SocketCreatorFactory.getSSLSocketCreatorForComponent(SSLEnabledComponent.CLUSTER).createServerSocket(p, b, isBindAddress ? bindAddress : null, this.tcpBufferSize);
+            socket = socketCreator.createServerSocket(p, b, isBindAddress ? bindAddress : null, this.tcpBufferSize);
-          SocketCreatorFactory.getSSLSocketCreatorForComponent(SSLEnabledComponent.CLUSTER).configureServerSSLSocket(othersock);
+          socketCreator.configureServerSSLSocket(othersock);
-        if (inhibitNewConnections) {
-          //          if (logger.isTraceEnabled(LogMarker.QA)) {
-          logger.info("Test hook: inhibiting acceptance of connection {}", othersock);
-          //          }
-          othersock.close();
-          while (inhibitNewConnections && !stopped) {
-            this.stopper.checkCancelInProgress(null);
-            boolean interrupted = Thread.interrupted();
-            try {
-              Thread.sleep(2000);
-            } catch (InterruptedException e) {
-              interrupted = true;
-            } finally {
-              if (interrupted) {
-                Thread.currentThread().interrupt();
-              }
-            }
-          } // while
-          if (logger.isTraceEnabled(LogMarker.QA)) {
-            logger.trace(LogMarker.QA, "Test hook: finished inhibiting acceptance of connections");
-          }
-        } else {
-          acceptConnection(othersock);
-        }
+
+        acceptConnection(othersock);
+        
+   * returns the SocketCreator that should be used to produce
+   * sockets for TCPConduit connections.
+   * @return
+   */
+  protected SocketCreator getSocketCreator() {
+    return socketCreator;
+  }
+  /**

INS31 INS29 UPD83 INS43 INS29 INS83 INS43 INS42 INS8 INS65 INS42 UPD42 INS21 INS65 INS65 INS42 INS41 INS66 INS7 INS66 INS66 INS42 INS22 MOV32 INS52 INS42 INS42 MOV21 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 DEL39 DEL42 DEL40 DEL32 DEL42 DEL40 DEL32 DEL42 DEL40 DEL32 DEL42 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL38 DEL27 DEL52 DEL42 DEL22 DEL42 DEL33 DEL32 DEL21 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL34 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL9 DEL7 DEL21 DEL8 DEL12 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL61 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL45 DEL32 DEL21 DEL8 DEL25 DEL8 DEL8 DEL25
GEODE-949: refactor and repackage security test code

* move test security classes from security package to com.gemstone.gemfire.security.generator
* move test security resources from lib package to com.gemstone.gemfire.security.generator
* move test security classes from templates.security package to com.gemstone.gemfire.security.templates
* fix places where security code ate exceptions
* fix up javadocs
* reformat and refactor code to be more readable and follow standards

-package templates.security;
+package com.gemstone.gemfire.security.templates;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.Principal;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
-import java.io.IOException;
-import java.io.InputStream;
-import java.security.Principal;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-
- * An implementation of the <code>{@link AccessControl}</code> interface that
- * allows authorization using the permissions as specified in the given XML
+ * An implementation of the {@link AccessControl} interface that allows
+ * authorization using the permissions as specified in the given XML
- * principal is obtained using the {@link Principal#getName} method and no other
+ * principal is obtained using the {@link Principal#getName()} method and no other
- * either the <code>QUERY</code> permission is provided at the cache-level for
- * the user or when <code>QUERY</code> permission is provided for all the
+ * either the {@code QUERY} permission is provided at the cache-level for
+ * the user or when {@code QUERY} permission is provided for all the
- * unauthenticated clients (i.e. <code>Everyone</code>).
+ * unauthenticated clients (i.e. {@code Everyone}).
- * @author Sumedh Wale
+  private static final Object sync = new Object();
+  private static final String EMPTY_VALUE = "";
+
-
-
-
-
-
-
-
-  private static final String ATTR_FUNCTION_OPTIMIZE_FOR_WRITE =
-    "optimizeForWrite";
-
+  private static final String ATTR_FUNCTION_OPTIMIZE_FOR_WRITE = "optimizeForWrite";
-
-
-  private static Map<String, Map<String,
-    Map<OperationCode, FunctionSecurityPrmsHolder>>> rolePermissions = null;
-
+  private static Map<String, Map<String, Map<OperationCode, FunctionSecurityPrmsHolder>>> rolePermissions = null;
-  private static final Object sync = new Object();
+  private final Map<String, Map<OperationCode, FunctionSecurityPrmsHolder>> allowedOps;
-  private static final String EMPTY_VALUE = "";
+  protected LogWriter systemLogWriter;
+  protected LogWriter securityLogWriter;
-  private final Map<String, Map<OperationCode,
-    FunctionSecurityPrmsHolder>> allowedOps;
+  /**
+   * Public static factory method to create an instance of
+   * {@code XmlAuthorization}. The fully qualified name of the class
+   * ({@code com.gemstone.gemfire.security.templates.XmlAuthorization.create})
+   * should be mentioned as the {@code security-client-accessor} system
+   * property to enable pre-operation authorization checks as implemented in
+   * this class.
+   *
+   * @return an object of {@code XmlAuthorization} class
+   */
+  public static AccessControl create() {
+    return new XmlAuthorization();
+  }
-  protected LogWriter logger;
-
-  protected LogWriter securityLogger;
-
-  private XmlAuthorization() {
-
-    this.allowedOps = new HashMap<String, Map<OperationCode,
-        FunctionSecurityPrmsHolder>>();
-    this.logger = null;
-    this.securityLogger = null;
+  /**
+   * Clear all the statically cached information.
+   */
+  public static void clear() {
+    XmlAuthorization.currentDocUri = null;
+    if (XmlAuthorization.userRoles != null) {
+      XmlAuthorization.userRoles.clear();
+      XmlAuthorization.userRoles = null;
+    }
+    if (XmlAuthorization.rolePermissions != null) {
+      XmlAuthorization.rolePermissions.clear();
+      XmlAuthorization.rolePermissions = null;
+    }
+    XmlAuthorization.xmlLoadFailure = null;
-  public static String normalizeRegionName(String regionName) {
-
+  public static String normalizeRegionName(final String regionName) {
+
+
-    }
-    else {
+    } else {
+
+
-      }
-      else {
+      } else {
+
+
-    }
-    else {
+    } else {
-  /** Get the attribute value for a given attribute name of a node. */
-  private static String getAttributeValue(Node node, String attrName) {
-
-    NamedNodeMap attrMap = node.getAttributes();
-    Node attrNode;
-    if (attrMap != null && (attrNode = attrMap.getNamedItem(attrName)) != null) {
-      return ((Attr)attrNode).getValue();
-    }
-    return EMPTY_VALUE;
-  }
-
-  /** Get the string contained in the first text child of the node. */
-  private static String getNodeValue(Node node) {
-
-    NodeList childNodes = node.getChildNodes();
-    for (int index = 0; index < childNodes.getLength(); index++) {
-      Node childNode = childNodes.item(index);
-      if (childNode.getNodeType() == Node.TEXT_NODE) {
-        return childNode.getNodeValue();
-      }
-    }
-    return EMPTY_VALUE;
+  private XmlAuthorization() {
+    this.allowedOps = new HashMap<String, Map<OperationCode, FunctionSecurityPrmsHolder>>();
+    this.systemLogWriter = null;
+    this.securityLogWriter = null;
-   * Public static factory method to create an instance of
-   * <code>XmlAuthorization</code>. The fully qualified name of the class
-   * (<code>templates.security.XmlAuthorization.create</code>)
-   * should be mentioned as the <code>security-client-accessor</code> system
-   * property to enable pre-operation authorization checks as implemented in
-   * this class.
-   * 
-   * @return an object of <code>XmlAuthorization</code> class
-   */
-  public static AccessControl create() {
-
-    return new XmlAuthorization();
-  }
-
-  /**
-   * Cache authorization information for all users statically. This method is
-   * not thread-safe and is should either be invoked only once, or the caller
-   * should take the appropriate locks.
-   * 
-   * @param cache
-   *                reference to the cache object for the distributed system
-   */
-  private static void init(Cache cache) throws NotAuthorizedException {
-
-    LogWriter logger = cache.getLogger();
-    String xmlDocumentUri = (String)cache.getDistributedSystem()
-        .getSecurityProperties().get(DOC_URI_PROP_NAME);
-    try {
-      if (xmlDocumentUri == null) {
-        throw new NotAuthorizedException("No ACL file defined using tag ["
-            + DOC_URI_PROP_NAME + "] in system properties");
-      }
-      if (xmlDocumentUri.equals(XmlAuthorization.currentDocUri)) {
-        if (XmlAuthorization.xmlLoadFailure != null) {
-          throw XmlAuthorization.xmlLoadFailure;
-        }
-        return;
-      }
-      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
-      factory.setIgnoringComments(true);
-      factory.setIgnoringElementContentWhitespace(true);
-      factory.setValidating(true);
-      DocumentBuilder builder = factory.newDocumentBuilder();
-      XmlErrorHandler errorHandler = new XmlErrorHandler(logger, xmlDocumentUri);
-      builder.setErrorHandler(errorHandler);
-      builder.setEntityResolver(new AuthzDtdResolver());
-      Document xmlDocument = builder.parse(xmlDocumentUri);
-
-      XmlAuthorization.userRoles = new HashMap<String, HashSet<String>>();
-      XmlAuthorization.rolePermissions = new HashMap<String, Map<String,
-          Map<OperationCode, FunctionSecurityPrmsHolder>>>();
-      NodeList roleUserNodes = xmlDocument.getElementsByTagName(TAG_ROLE);
-      for (int roleIndex = 0; roleIndex < roleUserNodes.getLength();
-          roleIndex++) {
-        Node roleUserNode = roleUserNodes.item(roleIndex);
-        String roleName = getAttributeValue(roleUserNode, ATTR_ROLENAME);
-        NodeList userNodes = roleUserNode.getChildNodes();
-        for (int userIndex = 0; userIndex < userNodes.getLength();
-            userIndex++) {
-          Node userNode = userNodes.item(userIndex);
-          if (userNode.getNodeName() == TAG_USER) {
-            String userName = getNodeValue(userNode);
-            HashSet<String> userRoleSet = XmlAuthorization.userRoles
-                .get(userName);
-            if (userRoleSet == null) {
-              userRoleSet = new HashSet<String>();
-              XmlAuthorization.userRoles.put(userName, userRoleSet);
-            }
-            userRoleSet.add(roleName);
-          }
-          else {
-            throw new SAXParseException("Unknown tag ["
-                + userNode.getNodeName() + "] as child of tag [" + TAG_ROLE
-                + ']', null);
-          }
-        }
-      }
-      NodeList rolePermissionNodes = xmlDocument
-          .getElementsByTagName(TAG_PERMS);
-      for (int permIndex = 0; permIndex < rolePermissionNodes.getLength();
-          permIndex++) {
-        Node rolePermissionNode = rolePermissionNodes.item(permIndex);
-        String roleName = getAttributeValue(rolePermissionNode, ATTR_ROLE);
-        Map<String, Map<OperationCode, FunctionSecurityPrmsHolder>>
-          regionOperationMap = XmlAuthorization.rolePermissions.get(roleName);
-        if (regionOperationMap == null) {
-          regionOperationMap = new HashMap<String,
-            Map<OperationCode, FunctionSecurityPrmsHolder>>();
-          XmlAuthorization.rolePermissions.put(roleName, regionOperationMap);
-        }
-        NodeList operationNodes = rolePermissionNode.getChildNodes();
-        HashMap<OperationCode, FunctionSecurityPrmsHolder> operationMap =
-          new HashMap<OperationCode, FunctionSecurityPrmsHolder>();
-        for (int opIndex = 0; opIndex < operationNodes.getLength(); opIndex++) {
-          Node operationNode = operationNodes.item(opIndex);
-          if (operationNode.getNodeName() == TAG_OP) {
-            String operationName = getNodeValue(operationNode);
-            OperationCode code = OperationCode.parse(operationName);
-            if (code == null) {
-              throw new SAXParseException("Unknown operation [" + operationName
-                  + ']', null);
-            }
-            if (code != OperationCode.EXECUTE_FUNCTION) {
-              operationMap.put(code, null);
-            }
-            else {
-              String optimizeForWrite = getAttributeValue(operationNode,
-                  ATTR_FUNCTION_OPTIMIZE_FOR_WRITE);
-              String functionAttr = getAttributeValue(operationNode,
-                  ATTR_FUNCTION_IDS);
-              String keysAttr = getAttributeValue(operationNode,
-                  ATTR_FUNCTION_KEY_SET);
-
-              Boolean isOptimizeForWrite;
-              HashSet<String> functionIds;
-              HashSet<String> keySet;
-
-              if (optimizeForWrite == null || optimizeForWrite.length() == 0) {
-                isOptimizeForWrite = null;
-              }
-              else {
-                isOptimizeForWrite = Boolean.parseBoolean(optimizeForWrite);
-              }
-
-              if (functionAttr == null || functionAttr.length() == 0) {
-                functionIds = null;
-              }
-              else {
-                String[] functionArray = functionAttr.split(",");
-                functionIds = new HashSet<String>();
-                for (int strIndex = 0; strIndex < functionArray.length;
-                    ++strIndex) {
-                  functionIds.add((functionArray[strIndex]));
-                }
-              }
-
-              if (keysAttr == null || keysAttr.length() == 0) {
-                keySet = null;
-              }
-              else {
-                String[] keySetArray = keysAttr.split(",");
-                keySet = new HashSet<String>();
-                for (int strIndex = 0; strIndex < keySetArray.length;
-                    ++strIndex) {
-                  keySet.add((keySetArray[strIndex]));
-                }
-              }
-              FunctionSecurityPrmsHolder functionContext =
-                new FunctionSecurityPrmsHolder(isOptimizeForWrite,
-                    functionIds, keySet);
-              operationMap.put(code, functionContext);
-            }
-          }
-          else {
-            throw new SAXParseException("Unknown tag ["
-                + operationNode.getNodeName() + "] as child of tag ["
-                + TAG_PERMS + ']', null);
-          }
-        }
-        String regionNames = getAttributeValue(rolePermissionNode, ATTR_REGIONS);
-        if (regionNames == null || regionNames.length() == 0) {
-          regionOperationMap.put(EMPTY_VALUE, operationMap);
-        }
-        else {
-          String[] regionNamesSplit = regionNames.split(",");
-          for (int strIndex = 0; strIndex < regionNamesSplit.length;
-              ++strIndex) {
-            regionOperationMap.put(
-                normalizeRegionName(regionNamesSplit[strIndex]), operationMap);
-          }
-        }
-      }
-      XmlAuthorization.currentDocUri = xmlDocumentUri;
-    }
-    catch (Exception ex) {
-      String exStr;
-      if (ex instanceof NotAuthorizedException) {
-        exStr = ex.getMessage();
-      }
-      else {
-        exStr = ex.getClass().getName() + ": " + ex.getMessage();
-      }
-      logger.warning("XmlAuthorization.init: " + exStr);
-      XmlAuthorization.xmlLoadFailure = new NotAuthorizedException(exStr, ex);
-      throw XmlAuthorization.xmlLoadFailure;
-    }
-  }
-
-  /**
-   * Initialize the <code>XmlAuthorization</code> callback for a client having
+   * Initialize the {@code XmlAuthorization} callback for a client having
-   * <code>principal</code> to speed up lookup the
-   * <code>authorizeOperation</code> calls. The permissions for the principal
+   * {@code principal} to speed up lookup the
+   * {@code authorizeOperation} calls. The permissions for the principal
-   * @param principal
-   *                the principal associated with the authenticated client
-   * @param cache
-   *                reference to the cache object
-   * @param remoteMember
-   *                the {@link DistributedMember} object for the remote
-   *                authenticated client
+   * @param  principal
+   *         the principal associated with the authenticated client
+   * @param  cache
+   *         reference to the cache object
+   * @param  remoteMember
+   *         the {@link DistributedMember} object for the remote authenticated
+   *         client
-   *                 if some exception condition happens during the
-   *                 initialization while reading the XML; in such a case all
-   *                 subsequent client operations will throw
-   *                 <code>NotAuthorizedException</code>
+   *         if some exception condition happens during the initialization
+   *         while reading the XML; in such a case all subsequent client
+   *         operations will throw {@code NotAuthorizedException}
-  public void init(Principal principal, DistributedMember remoteMember,
-      Cache cache) throws NotAuthorizedException {
-
+  @Override
+  public void init(final Principal principal, final DistributedMember remoteMember, final Cache cache) throws NotAuthorizedException {
-    this.logger = cache.getLogger();
-    this.securityLogger = cache.getSecurityLogger();
+
+    this.systemLogWriter = cache.getLogger();
+    this.securityLogWriter = cache.getSecurityLogger();
-    }
-    else {
+    } else {
+
-        Map<String, Map<OperationCode, FunctionSecurityPrmsHolder>>
-          regionOperationMap = XmlAuthorization.rolePermissions.get(roleName);
+        Map<String, Map<OperationCode, FunctionSecurityPrmsHolder>> regionOperationMap = XmlAuthorization.rolePermissions.get(roleName);
-          for (Map.Entry<String, Map<OperationCode, FunctionSecurityPrmsHolder>>
-              regionEntry : regionOperationMap.entrySet()) {
+          for (Map.Entry<String, Map<OperationCode, FunctionSecurityPrmsHolder>> regionEntry : regionOperationMap.entrySet()) {
-            Map<OperationCode, FunctionSecurityPrmsHolder> regionOperations =
-              this.allowedOps.get(regionName);
+            Map<OperationCode, FunctionSecurityPrmsHolder> regionOperations = this.allowedOps.get(regionName);
-              regionOperations =
-                new HashMap<OperationCode, FunctionSecurityPrmsHolder>();
+              regionOperations = new HashMap<OperationCode, FunctionSecurityPrmsHolder>();
-   * @param regionName
-   *                When null then it indicates a cache-level operation, else
-   *                the name of the region for the operation.
-   * @param context
-   *                the data required by the operation
+   * @param  regionName
+   *         When null then it indicates a cache-level operation, else the
+   *         name of the region for the operation.
+   * @param  context
+   *         the data required by the operation
-   * 
-  public boolean authorizeOperation(String regionName,
-      final OperationContext context) {
-
+  @Override
+  public boolean authorizeOperation(String regionName, final OperationContext context) {
+
-    if (opCode.isQuery() || opCode.isExecuteCQ() || opCode.isCloseCQ()
-        || opCode.isStopCQ()) {
+    if (opCode.isQuery() || opCode.isExecuteCQ() || opCode.isCloseCQ() || opCode.isStopCQ()) {
-      boolean globalPermission = (operationMap != null && operationMap
-          .containsKey(opCode));
-      Set<String> regionNames = ((QueryOperationContext)context)
-          .getRegionNames();
+      boolean globalPermission = (operationMap != null && operationMap .containsKey(opCode));
+      Set<String> regionNames = ((QueryOperationContext)context) .getRegionNames();
+
-        }
-        else if (!operationMap.containsKey(opCode)) {
+        } else if (!operationMap.containsKey(opCode)) {
-      }else {
+
+      } else {
-        }
-        else {
+
+        } else {
-            FunctionSecurityPrmsHolder functionParameter =
-              operationMap.get(
-                context.getOperationCode());
-            ExecuteFunctionOperationContext functionContext =
-              (ExecuteFunctionOperationContext)context;
+            FunctionSecurityPrmsHolder functionParameter = operationMap.get(context.getOperationCode());
+            ExecuteFunctionOperationContext functionContext = (ExecuteFunctionOperationContext) context;
-              if (functionParameter.isOptimizeForWrite() != null
-                  && functionParameter.isOptimizeForWrite().booleanValue()
-                    != functionContext.isOptimizeForWrite()) {
+              if (functionParameter.isOptimizeForWrite() != null && functionParameter.isOptimizeForWrite().booleanValue() != functionContext.isOptimizeForWrite()) {
-              if (functionParameter.getFunctionIds() != null
-                  && !functionParameter.getFunctionIds().contains(
-                      functionContext.getFunctionId())) {
+              if (functionParameter.getFunctionIds() != null && !functionParameter.getFunctionIds().contains( functionContext.getFunctionId())) {
-              if (functionParameter.getKeySet() != null
-                  && functionContext.getKeySet() != null) {
-                if (functionContext.getKeySet().containsAll(
-                    functionParameter.getKeySet())) {
+              if (functionParameter.getKeySet() != null && functionContext.getKeySet() != null) {
+                if (functionContext.getKeySet().containsAll( functionParameter.getKeySet())) {
-            }
-            else {// On Server execution
-              if (functionParameter.getFunctionIds() != null
-                  && !functionParameter.getFunctionIds().contains(
-                      functionContext.getFunctionId())) {
+
+            } else {// On Server execution
+              if (functionParameter.getFunctionIds() != null && !functionParameter.getFunctionIds().contains(functionContext.getFunctionId())) {
-          }
-          else {
-            ExecuteFunctionOperationContext functionContext =
-              (ExecuteFunctionOperationContext)context;
-            FunctionSecurityPrmsHolder functionParameter = operationMap.get(
-                context.getOperationCode());
+
+          } else {
+            ExecuteFunctionOperationContext functionContext = (ExecuteFunctionOperationContext)context;
+            FunctionSecurityPrmsHolder functionParameter = operationMap.get(context.getOperationCode());
-              if (functionContext.getResult() instanceof ArrayList
-                  && functionParameter.getKeySet() != null) {
-                ArrayList<String> resultList = (ArrayList)functionContext
-                    .getResult();
-                HashSet<String> nonAllowedKeys = functionParameter.getKeySet();
+              if (functionContext.getResult() instanceof ArrayList && functionParameter.getKeySet() != null) {
+                ArrayList<String> resultList = (ArrayList)functionContext.getResult();
+                Set<String> nonAllowedKeys = functionParameter.getKeySet();
-            }
-            else {
-              ArrayList<String> resultList = (ArrayList)functionContext
-                  .getResult();
+
+            } else {
+              ArrayList<String> resultList = (ArrayList)functionContext.getResult();
+  @Override
-
-  /**
-   * Clear all the statically cached information.
-   */
-  public static void clear() {
-
-    XmlAuthorization.currentDocUri = null;
-    if (XmlAuthorization.userRoles != null) {
-      XmlAuthorization.userRoles.clear();
-      XmlAuthorization.userRoles = null;
+  /** Get the attribute value for a given attribute name of a node. */
+  private static String getAttributeValue(final Node node, final String attrName) {
+    NamedNodeMap attrMap = node.getAttributes();
+    Node attrNode;
+    if (attrMap != null && (attrNode = attrMap.getNamedItem(attrName)) != null) {
+      return ((Attr)attrNode).getValue();
-    if (XmlAuthorization.rolePermissions != null) {
-      XmlAuthorization.rolePermissions.clear();
-      XmlAuthorization.rolePermissions = null;
-    }
-    XmlAuthorization.xmlLoadFailure = null;
+    return EMPTY_VALUE;
-  
+
+  /** Get the string contained in the first text child of the node. */
+  private static String getNodeValue(final Node node) {
+    NodeList childNodes = node.getChildNodes();
+    for (int index = 0; index < childNodes.getLength(); index++) {
+      Node childNode = childNodes.item(index);
+      if (childNode.getNodeType() == Node.TEXT_NODE) {
+        return childNode.getNodeValue();
+      }
+    }
+    return EMPTY_VALUE;
+  }
+
+  /**
+   * Cache authorization information for all users statically. This method is
+   * not thread-safe and is should either be invoked only once, or the caller
+   * should take the appropriate locks.
+   *
+   * @param cache reference to the cache object for the distributed system
+   */
+  private static void init(final Cache cache) throws NotAuthorizedException {
+    final LogWriter systemLogWriter = cache.getLogger();
+    final String xmlDocumentUri = (String)cache.getDistributedSystem().getSecurityProperties().get(DOC_URI_PROP_NAME);
+
+    try {
+      if (xmlDocumentUri == null) {
+        throw new NotAuthorizedException("No ACL file defined using tag [" + DOC_URI_PROP_NAME + "] in system properties");
+      }
+      if (xmlDocumentUri.equals(XmlAuthorization.currentDocUri)) {
+        if (XmlAuthorization.xmlLoadFailure != null) {
+          throw XmlAuthorization.xmlLoadFailure;
+        }
+        return;
+      }
+
+      final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+      factory.setIgnoringComments(true);
+      factory.setIgnoringElementContentWhitespace(true);
+      factory.setValidating(true);
+
+      final DocumentBuilder builder = factory.newDocumentBuilder();
+      final XmlErrorHandler errorHandler = new XmlErrorHandler(systemLogWriter, xmlDocumentUri);
+      builder.setErrorHandler(errorHandler);
+      builder.setEntityResolver(new AuthzDtdResolver());
+
+      final Document xmlDocument = builder.parse(xmlDocumentUri);
+
+      XmlAuthorization.userRoles = new HashMap<String, HashSet<String>>();
+      XmlAuthorization.rolePermissions = new HashMap<String, Map<String, Map<OperationCode, FunctionSecurityPrmsHolder>>>();
+
+      final NodeList roleUserNodes = xmlDocument.getElementsByTagName(TAG_ROLE);
+
+      for (int roleIndex = 0; roleIndex < roleUserNodes.getLength(); roleIndex++) {
+        final Node roleUserNode = roleUserNodes.item(roleIndex);
+        final String roleName = getAttributeValue(roleUserNode, ATTR_ROLENAME);
+        final NodeList userNodes = roleUserNode.getChildNodes();
+
+        for (int userIndex = 0; userIndex < userNodes.getLength(); userIndex++) {
+          final Node userNode = userNodes.item(userIndex);
+
+          if (userNode.getNodeName() == TAG_USER) {
+            final String userName = getNodeValue(userNode);
+            HashSet<String> userRoleSet = XmlAuthorization.userRoles.get(userName);
+            if (userRoleSet == null) {
+              userRoleSet = new HashSet<String>();
+              XmlAuthorization.userRoles.put(userName, userRoleSet);
+            }
+            userRoleSet.add(roleName);
+
+          } else {
+            throw new SAXParseException("Unknown tag [" + userNode.getNodeName() + "] as child of tag [" + TAG_ROLE + ']', null);
+          }
+        }
+      }
+
+      final NodeList rolePermissionNodes = xmlDocument.getElementsByTagName(TAG_PERMS);
+
+      for (int permIndex = 0; permIndex < rolePermissionNodes.getLength(); permIndex++) {
+        final Node rolePermissionNode = rolePermissionNodes.item(permIndex);
+        final String roleName = getAttributeValue(rolePermissionNode, ATTR_ROLE);
+        Map<String, Map<OperationCode, FunctionSecurityPrmsHolder>> regionOperationMap = XmlAuthorization.rolePermissions.get(roleName);
+
+        if (regionOperationMap == null) {
+          regionOperationMap = new HashMap<String, Map<OperationCode, FunctionSecurityPrmsHolder>>();
+          XmlAuthorization.rolePermissions.put(roleName, regionOperationMap);
+        }
+
+        final NodeList operationNodes = rolePermissionNode.getChildNodes();
+        final HashMap<OperationCode, FunctionSecurityPrmsHolder> operationMap = new HashMap<OperationCode, FunctionSecurityPrmsHolder>();
+
+        for (int opIndex = 0; opIndex < operationNodes.getLength(); opIndex++) {
+          final Node operationNode = operationNodes.item(opIndex);
+
+          if (operationNode.getNodeName() == TAG_OP) {
+            final String operationName = getNodeValue(operationNode);
+            final OperationCode code = OperationCode.parse(operationName);
+
+            if (code == null) {
+              throw new SAXParseException("Unknown operation [" + operationName + ']', null);
+            }
+
+            if (code != OperationCode.EXECUTE_FUNCTION) {
+              operationMap.put(code, null);
+
+            } else {
+              final String optimizeForWrite = getAttributeValue(operationNode, ATTR_FUNCTION_OPTIMIZE_FOR_WRITE);
+              final String functionAttr = getAttributeValue(operationNode, ATTR_FUNCTION_IDS);
+              final String keysAttr = getAttributeValue(operationNode, ATTR_FUNCTION_KEY_SET);
+
+              Boolean isOptimizeForWrite;
+              HashSet<String> functionIds;
+              HashSet<String> keySet;
+
+              if (optimizeForWrite == null || optimizeForWrite.length() == 0) {
+                isOptimizeForWrite = null;
+              } else {
+                isOptimizeForWrite = Boolean.parseBoolean(optimizeForWrite);
+              }
+
+              if (functionAttr == null || functionAttr.length() == 0) {
+                functionIds = null;
+              } else {
+                final String[] functionArray = functionAttr.split(",");
+                functionIds = new HashSet<String>();
+                for (int strIndex = 0; strIndex < functionArray.length; ++strIndex) {
+                  functionIds.add((functionArray[strIndex]));
+                }
+              }
+
+              if (keysAttr == null || keysAttr.length() == 0) {
+                keySet = null;
+              } else {
+                final String[] keySetArray = keysAttr.split(",");
+                keySet = new HashSet<String>();
+                for (int strIndex = 0; strIndex < keySetArray.length; ++strIndex) {
+                  keySet.add((keySetArray[strIndex]));
+                }
+              }
+
+              final FunctionSecurityPrmsHolder functionContext = new FunctionSecurityPrmsHolder(isOptimizeForWrite, functionIds, keySet);
+              operationMap.put(code, functionContext);
+            }
+
+          } else {
+            throw new SAXParseException("Unknown tag [" + operationNode.getNodeName() + "] as child of tag [" + TAG_PERMS + ']', null);
+          }
+        }
+
+        final String regionNames = getAttributeValue(rolePermissionNode, ATTR_REGIONS);
+        if (regionNames == null || regionNames.length() == 0) {
+          regionOperationMap.put(EMPTY_VALUE, operationMap);
+        } else {
+          final String[] regionNamesSplit = regionNames.split(",");
+          for (int strIndex = 0; strIndex < regionNamesSplit.length; ++strIndex) {
+            regionOperationMap.put(normalizeRegionName(regionNamesSplit[strIndex]), operationMap);
+          }
+        }
+      }
+      XmlAuthorization.currentDocUri = xmlDocumentUri;
+
+    } catch (Exception ex) {
+      String message;
+      if (ex instanceof NotAuthorizedException) {
+        message = ex.getMessage();
+      }
+      else {
+        message = ex.getClass().getName() + ": " + ex.getMessage();
+      }
+      systemLogWriter.warning("XmlAuthorization.init: " + message);
+      XmlAuthorization.xmlLoadFailure = new NotAuthorizedException(message, ex);
+      throw XmlAuthorization.xmlLoadFailure;
+    }
+  }
+
-    Pattern authzPattern = Pattern.compile("authz.*\\.dtd");
+    final Pattern authzPattern = Pattern.compile("authz.*\\.dtd");
-    public InputSource resolveEntity(String publicId, String systemId)
-        throws SAXException, IOException {
+    public InputSource resolveEntity(final String publicId, final String systemId) throws SAXException, IOException {
-        Matcher matcher = authzPattern.matcher(systemId);
-        if(matcher.find()) {
-          String dtdName = matcher.group(0);
-          InputStream stream = XmlAuthorization.class.getResourceAsStream(dtdName);
+        final Matcher matcher = authzPattern.matcher(systemId);
+        if (matcher.find()) {
+          final String dtdName = matcher.group(0);
+          final InputStream stream = XmlAuthorization.class.getResourceAsStream(dtdName);
+

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV23 MOV23 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 UPD40 MOV43 MOV43 INS78 MOV44 INS78 INS78 INS44 MOV44 INS44 UPD66 UPD66 UPD66 INS66 INS65 UPD66 INS66 INS65 UPD66 UPD66 INS65 INS66 UPD42 UPD42 INS83 INS42 INS83 INS83 INS83 INS42 INS42 INS83 MOV43 INS42 INS83 INS83 INS83 MOV43 INS42 INS83 INS68 INS66 INS66 INS66 INS65 UPD66 INS66 INS65 INS66 UPD66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 UPD66 INS65 UPD66 INS65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS65 UPD66 UPD66 UPD66 INS83 INS83 INS83 MOV43 INS83 INS42 INS42 INS66 UPD66 MOV66 INS66 UPD66 MOV66 INS66 INS66 INS66 UPD66 MOV66 MOV32 INS42 MOV32 UPD42 UPD42 UPD42 UPD42 INS83 INS83 INS83 INS83 INS83 INS83 INS83 UPD42 INS83 INS83 INS83 INS83 INS83 INS83 INS83 INS83 UPD42 UPD42 UPD42 UPD42 INS83 INS83 INS83 INS83 INS83 UPD42 UPD42 INS83 INS83 INS83 INS83 INS83 INS83 INS83 UPD74 INS83 INS83 UPD43 INS43 UPD42 INS42 DEL42 DEL42 DEL67 DEL66 DEL65 DEL42 DEL44 DEL42 DEL44 DEL42
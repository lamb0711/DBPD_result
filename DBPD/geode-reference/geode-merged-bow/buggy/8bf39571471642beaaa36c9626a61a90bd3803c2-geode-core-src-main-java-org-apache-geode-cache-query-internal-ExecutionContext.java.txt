Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This is used to carry the state of a query or index update operation. A state
- * of a query is a set of flags to be applied during query execution life cycle.
- * Also, carries the dependencies of where clauses or index expressions to from
- * clause iterators.
+ * This is used to carry the state of a query or index update operation. A state of a query is a set
+ * of flags to be applied during query execution life cycle. Also, carries the dependencies of where
+ * clauses or index expressions to from clause iterators.
-   * a Sequentially increasing number identifying a scope & also indicating
-   * whether a given scope came prior or later to another scope. It is needed
-   * to distiguish between two scopes having same nesting level relative to 
-   * the top scope
+   * a Sequentially increasing number identifying a scope & also indicating whether a given scope
+   * came prior or later to another scope. It is needed to distiguish between two scopes having same
+   * nesting level relative to the top scope
-  private int scopeNum =0;
-  
+  private int scopeNum = 0;
+
-   * Dependency graph. Maps CompiledValues in tree to the RuntimeIterators each
-   * node is dependent on. This information is computed just before the query is
-   * evaluated. The information is good for only one execution, since regions
-   * can be destroyed and re-created with different type constraints. Type of
-   * this map: map <CompiledValue, set <RuntimeIterator>>
+   * Dependency graph. Maps CompiledValues in tree to the RuntimeIterators each node is dependent
+   * on. This information is computed just before the query is evaluated. The information is good
+   * for only one execution, since regions can be destroyed and re-created with different type
+   * constraints. Type of this map: map <CompiledValue, set <RuntimeIterator>>
-   * Map which stores the CompiledIteratorDef as the key & the value is the set
-   * of Independent RuntimeIterators on which it is dependent upon. The idea is
-   * that this Map will identify the final Independent RuntimeIterator or
-   * Iterators , ie. those refering to a Region or BindArgument, on which the
-   * CompiledIteratorDef depends upon . TODO:Asif: For a single vale , should we
-   * still use a Set?
-   *  
+   * Map which stores the CompiledIteratorDef as the key & the value is the set of Independent
+   * RuntimeIterators on which it is dependent upon. The idea is that this Map will identify the
+   * final Independent RuntimeIterator or Iterators , ie. those refering to a Region or
+   * BindArgument, on which the CompiledIteratorDef depends upon . TODO:Asif: For a single vale ,
+   * should we still use a Set?
+   * 
-   * Asif : This Map will store its Region Path String against an Independent
-   * RuntimeIterator An entry in this Map will be only for those
-   * RuntimeIteartors which have an underlying Region as its Collection
-   * Expression
-   *  
+   * Asif : This Map will store its Region Path String against an Independent RuntimeIterator An
+   * entry in this Map will be only for those RuntimeIteartors which have an underlying Region as
+   * its Collection Expression
+   * 
-  private final Map indpndtItrToRgnMap = new HashMap();  
-  
-  //used when querying on a PR: Substitute reference to PartitionedRegion with BucketRegion
+  private final Map indpndtItrToRgnMap = new HashMap();
+
+  // used when querying on a PR: Substitute reference to PartitionedRegion with BucketRegion
+
-   * Param specialIteratorVar name of special variable to use to denote the
-   * current iteration element. Used to implement the "this" var in the query
-   * shortcut methods
+   * Param specialIteratorVar name of special variable to use to denote the current iteration
+   * element. Used to implement the "this" var in the query shortcut methods
-    return ((GemFireCacheImpl)this.cache).getCachePerfStats();
+    return ((GemFireCacheImpl) this.cache).getCachePerfStats();
-   * Add RuntimeIterator as a dependency of a CompiledValue. ASSUMPTION:
-   * unsynchronized, assumed to be single-threaded.
+   * Add RuntimeIterator as a dependency of a CompiledValue. ASSUMPTION: unsynchronized, assumed to
+   * be single-threaded.
- public Set addDependencies(CompiledValue cv, Set set /* <RuntimeIterator> */) {
-    if (set.isEmpty()) return getDependencySet(cv, true);
+  public Set addDependencies(CompiledValue cv, Set set /* <RuntimeIterator> */) {
+    if (set.isEmpty())
+      return getDependencySet(cv, true);
-  //TODO:ASIF:QUERY
+
+  // TODO:ASIF:QUERY
-   * Return true if given CompiledValue is dependent on any RuntimeIterator in
-   * current scope
+   * Return true if given CompiledValue is dependent on any RuntimeIterator in current scope
-    //return !getDependencySet(cv, true).isEmpty();
+    // return !getDependencySet(cv, true).isEmpty();
-      //int currScopeID = this.scopes.size();
+      // int currScopeID = this.scopes.size();
-   * Return true if given CompiledValue is dependent on any RuntimeIterator in
-   * all of the scopes
+   * Return true if given CompiledValue is dependent on any RuntimeIterator in all of the scopes
-   * Return true if given CompiledValue is dependent on specified
-   * RuntimeIterator
+   * Return true if given CompiledValue is dependent on specified RuntimeIterator
-      if (readOnly) return Collections.EMPTY_SET;
+      if (readOnly)
+        return Collections.EMPTY_SET;
-   * Returns all dependencies in from this context which are reused during index
-   * update by new {@link ExecutionContext} for concurrent updates on indexes.
+   * Returns all dependencies in from this context which are reused during index update by new
+   * {@link ExecutionContext} for concurrent updates on indexes.
-        throw new IllegalArgumentException(LocalizedStrings.ExecutionContext_TOO_FEW_QUERY_PARAMETERS.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.ExecutionContext_TOO_FEW_QUERY_PARAMETERS.toLocalizedString());
-  //TODO:ASIF:Query
+  // TODO:ASIF:Query
-    //int currScopeID = this.scopes.size();
-    QScope currentScope= this.currentScope();
+    // int currScopeID = this.scopes.size();
+    QScope currentScope = this.currentScope();
-  public CompiledValue resolve(String name) throws TypeMismatchException,
-      AmbiguousNameException {
+  public CompiledValue resolve(String name) throws TypeMismatchException, AmbiguousNameException {
-    if (value != null) return value;
+    if (value != null)
+      return value;
-        // cannot be resolved
-        throw new TypeMismatchException(LocalizedStrings.ExecutionContext_THE_ATTRIBUTE_OR_METHOD_NAME_0_COULD_NOT_BE_RESOLVED.toLocalizedString(name));
+      // cannot be resolved
+      throw new TypeMismatchException(
+          LocalizedStrings.ExecutionContext_THE_ATTRIBUTE_OR_METHOD_NAME_0_COULD_NOT_BE_RESOLVED
+              .toLocalizedString(name));
-      if (value != null) return value;
+      if (value != null)
+        return value;
-  public void newScope(int scopeID) {  
-    scopes.push(new QScope(scopeID));    
+  public void newScope(int scopeID) {
+    scopes.push(new QScope(scopeID));
-    scopes.pop();    
+    scopes.pop();
-  
+
-  int assosciateScopeID() {     
-    //this.scopeIDMap.put(cs, Integer.valueOf(num));
+  int assosciateScopeID() {
+    // this.scopeIDMap.put(cs, Integer.valueOf(num));
-  
+
- 
+
-   * This function returns a List of RuntimeIterators which have ultimate
-   * dependency on the Single Independent Iterator which is passed as a
-   * parameter to the function. For correct usage it is necessary that the
-   * RuntimeIterator passed is independent. If there are no dependent Iterators
-   * then the list will just contain one element which will be the
-   * RuntimeIterator passed as argument . Also the self independent Runtime
-   * Iterator present in the scope ( that is teh RuntimeIterator same as the
-   * independent iterator passed as argument) is added at start of the list. If
-   * an iterator is dependent on more than one independent iterator, it is not
-   * added to the List TODO:Asif If we are storing a single Iterator instead of
-   * Set , in the itrDefToIndpndtRuntimeItrMap , we need to take care of this
-   * function.
+   * This function returns a List of RuntimeIterators which have ultimate dependency on the Single
+   * Independent Iterator which is passed as a parameter to the function. For correct usage it is
+   * necessary that the RuntimeIterator passed is independent. If there are no dependent Iterators
+   * then the list will just contain one element which will be the RuntimeIterator passed as
+   * argument . Also the self independent Runtime Iterator present in the scope ( that is teh
+   * RuntimeIterator same as the independent iterator passed as argument) is added at start of the
+   * list. If an iterator is dependent on more than one independent iterator, it is not added to the
+   * List TODO:Asif If we are storing a single Iterator instead of Set , in the
+   * itrDefToIndpndtRuntimeItrMap , we need to take care of this function.
-   * <P>author Asif
-   * @param rIter Independent RuntimeIterator on which dependent iterators of
-   *          current scope need to identified
-   * @return List containing the independent Runtime Iterator & its dependent
-   *         iterators
+   * <P>
+   * author Asif
+   * 
+   * @param rIter Independent RuntimeIterator on which dependent iterators of current scope need to
+   *        identified
+   * @return List containing the independent Runtime Iterator & its dependent iterators
-  public List getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(
-      RuntimeIterator rIter) {
+  public List getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(RuntimeIterator rIter) {
-      Set itrSet = (Set) itrDefToIndpndtRuntimeItrMap
-          .get(iteratorInCurrentScope.getCmpIteratorDefn());
-      if (rIter != iteratorInCurrentScope
-          && itrSet.size() == 1
+      Set itrSet =
+          (Set) itrDefToIndpndtRuntimeItrMap.get(iteratorInCurrentScope.getCmpIteratorDefn());
+      if (rIter != iteratorInCurrentScope && itrSet.size() == 1
-  
+
-  private CompiledValue resolveImplicitPath(String name)
-      throws AmbiguousNameException {
+  private CompiledValue resolveImplicitPath(String name) throws AmbiguousNameException {
-   * returns implicit iterator receiver of operation with numArgs args, or null
-   * if cannot be resolved.
+   * returns implicit iterator receiver of operation with numArgs args, or null if cannot be
+   * resolved.
-   * SPECIAL CASE: If we are unable to resolve the name on any iterator, but
-   * there is only one iterator that we don't have type information for it (for
-   * now OBJECT_TYPE, this has to change), then return that one iterator under
-   * the assumption that the operation name must belong to it.
+   * SPECIAL CASE: If we are unable to resolve the name on any iterator, but there is only one
+   * iterator that we don't have type information for it (for now OBJECT_TYPE, this has to change),
+   * then return that one iterator under the assumption that the operation name must belong to it.
-  RuntimeIterator resolveImplicitOperationName(String name, int numArgs,
-      boolean mustBeMethod) throws AmbiguousNameException {
-    //System.out.println("In resolveImplicitOperationName");
+  RuntimeIterator resolveImplicitOperationName(String name, int numArgs, boolean mustBeMethod)
+      throws AmbiguousNameException {
+    // System.out.println("In resolveImplicitOperationName");
-        //Shobhit: If Element type is ObjectType then we don't need to
+        // Shobhit: If Element type is ObjectType then we don't need to
-        if (!TypeUtils.OBJECT_TYPE.equals(itr.getElementType()) && itr.containsProperty(name, numArgs, mustBeMethod)) {
+        if (!TypeUtils.OBJECT_TYPE.equals(itr.getElementType())
+            && itr.containsProperty(name, numArgs, mustBeMethod)) {
-        }
-        else if (TypeUtils.OBJECT_TYPE.equals(itr.getElementType())) {
+        } else if (TypeUtils.OBJECT_TYPE.equals(itr.getElementType())) {
-          }
-          else {
+          } else {
-    if (hits.size() == 1) return (RuntimeIterator) hits.get(0);
+    if (hits.size() == 1)
+      return (RuntimeIterator) hits.get(0);
-          throw new AmbiguousNameException(LocalizedStrings.ExecutionContext_METHOD_NAMED_0_WITH_1_ARGUMENTS_IS_AMBIGUOUS_BECAUSE_IT_CAN_APPLY_TO_MORE_THAN_ONE_VARIABLE_IN_SCOPE.toLocalizedString(new Object[] {name, Integer.valueOf(numArgs)}));
-      throw new AmbiguousNameException(LocalizedStrings.ExecutionContext_ATTRIBUTE_NAMED_0_IS_AMBIGUOUS_BECAUSE_IT_CAN_APPLY_TO_MORE_THAN_ONE_VARIABLE_IN_SCOPE.toLocalizedString(name));
+        throw new AmbiguousNameException(
+            LocalizedStrings.ExecutionContext_METHOD_NAMED_0_WITH_1_ARGUMENTS_IS_AMBIGUOUS_BECAUSE_IT_CAN_APPLY_TO_MORE_THAN_ONE_VARIABLE_IN_SCOPE
+                .toLocalizedString(new Object[] {name, Integer.valueOf(numArgs)}));
+      throw new AmbiguousNameException(
+          LocalizedStrings.ExecutionContext_ATTRIBUTE_NAMED_0_IS_AMBIGUOUS_BECAUSE_IT_CAN_APPLY_TO_MORE_THAN_ONE_VARIABLE_IN_SCOPE
+              .toLocalizedString(name));
-      if (value != null) break;
+      if (value != null)
+        break;
-    //Check if expr is itself RuntimeIterator
+    // Check if expr is itself RuntimeIterator
-      if (path == null) { return null; }
-      if (path instanceof RuntimeIterator) { return path; }
+      if (path == null) {
+        return null;
+      }
+      if (path instanceof RuntimeIterator) {
+        return path;
+      }
-          RuntimeIterator rcvrItr = resolveImplicitOperationName(operation
-              .getMethodName(), operation.getArguments().size(), true);
+          RuntimeIterator rcvrItr = resolveImplicitOperationName(operation.getMethodName(),
+              operation.getArguments().size(), true);
-      } //if we get these exceptions return null
-    }
-    catch (TypeMismatchException e) {
-    }
-    catch (NameResolutionException e) {
+      } // if we get these exceptions return null
+    } catch (TypeMismatchException e) {
+    } catch (NameResolutionException e) {
-   * Calculates set of Runtime Iterators on which a given CompiledValue
-   * ultimately depends. The independent iterators may belong to other scopes.
+   * Calculates set of Runtime Iterators on which a given CompiledValue ultimately depends. The
+   * independent iterators may belong to other scopes.
-   * <P>author Asif/Ketan
+   * <P>
+   * author Asif/Ketan
+   * 
-  //Ketan - Asif:This function will populate the set to its independent
+  // Ketan - Asif:This function will populate the set to its independent
-  //However if the CompiledValue happens to be a CompiledIteratorDef & if it is
+  // However if the CompiledValue happens to be a CompiledIteratorDef & if it is
-  //TODO: Asif : The behaviour of this function will change if we modify the
+  // TODO: Asif : The behaviour of this function will change if we modify the
-  //not the case now
-  //TODO:Asif : If a CompiledIteratorDef has only one dependent RuntimeIterator
+  // not the case now
+  // TODO:Asif : If a CompiledIteratorDef has only one dependent RuntimeIterator
-        Set indRuntimeIterators = (Set) this.itrDefToIndpndtRuntimeItrMap.get(
-            rIter.getCmpIteratorDefn());
+        Set indRuntimeIterators =
+            (Set) this.itrDefToIndpndtRuntimeItrMap.get(rIter.getCmpIteratorDefn());
-   * Asif : This function populates the Map itrDefToIndpndtRuntimeItrMap. It
-   * creates a Set of RuntimeIterators to which the current CompilediteratorDef
-   * is dependent upon. Also it sets the index_internal_id for the
-   * RuntimeIterator, which is used for calculating the canonicalized iterator
-   * definitions for identifying the available index.
+   * Asif : This function populates the Map itrDefToIndpndtRuntimeItrMap. It creates a Set of
+   * RuntimeIterators to which the current CompilediteratorDef is dependent upon. Also it sets the
+   * index_internal_id for the RuntimeIterator, which is used for calculating the canonicalized
+   * iterator definitions for identifying the available index.
-   * @param itrDef
-   *          CompiledIteratorDef object representing iterator in the query from
-   *          clause
+   * @param itrDef CompiledIteratorDef object representing iterator in the query from clause
-    //If the set is empty then add the self RuntimeIterator to the Map.
+    // If the set is empty then add the self RuntimeIterator to the Map.
-      //Asif : Since it is a an independent RuntimeIterator , check if its
+      // Asif : Since it is a an independent RuntimeIterator , check if its
-      CompiledValue startVal = QueryUtils
-          .obtainTheBottomMostCompiledValue(itrDef.getCollectionExpr());
+      CompiledValue startVal =
+          QueryUtils.obtainTheBottomMostCompiledValue(itrDef.getCollectionExpr());
-        rgnPath = ((QRegion)((CompiledRegion)startVal).evaluate(this)).getFullPath();
+        rgnPath = ((QRegion) ((CompiledRegion) startVal).evaluate(this)).getFullPath();
-      }
-      else if (startVal.getType() == OQLLexerTokenTypes.QUERY_PARAM) {
+      } else if (startVal.getType() == OQLLexerTokenTypes.QUERY_PARAM) {
-        CompiledBindArgument cba = (CompiledBindArgument)startVal;
+        CompiledBindArgument cba = (CompiledBindArgument) startVal;
-          this.indpndtItrToRgnMap.put(itr, rgnPath = ((Region)rgn)
-              .getFullPath());
+          this.indpndtItrToRgnMap.put(itr, rgnPath = ((Region) rgn).getFullPath());
-    //Asif : Set the canonicalized index_internal_id if the condition is
+    // Asif : Set the canonicalized index_internal_id if the condition is
-        itr = (RuntimeIterator)set.iterator().next();
-        //if (itr.getScopeID() == this.getScopeCount()) {
+        itr = (RuntimeIterator) set.iterator().next();
+        // if (itr.getScopeID() == this.getScopeCount()) {
-          rgnPath = (String)this.indpndtItrToRgnMap.get(itr);
+          rgnPath = (String) this.indpndtItrToRgnMap.get(itr);
-        //put a check for null and see if we will be executing on a bucket region.
-        if ( ( null == mgr ) && ( null != this.bukRgn) ) {
+        // put a check for null and see if we will be executing on a bucket region.
+        if ((null == mgr) && (null != this.bukRgn)) {
-    currItr
-        .setIndexInternalID((mgr == null || (tempIndexID = mgr
-            .getCanonicalizedIteratorName(itrDef.genFromClause(this))) == null) ? currItr
-            .getInternalId()
-            : tempIndexID);
-    
+    currItr.setIndexInternalID((mgr == null
+        || (tempIndexID = mgr.getCanonicalizedIteratorName(itrDef.genFromClause(this))) == null)
+            ? currItr.getInternalId() : tempIndexID);
+
-  
-  public  List getAllIndependentIteratorsOfCurrentScope() {
-   List independentIterators = new ArrayList(this.indpndtItrToRgnMap.size());
-   Iterator itr = this.indpndtItrToRgnMap.keySet().iterator();
-   int currentScopeId = this.currentScope().getScopeID();
-   while(itr.hasNext()) {
-     RuntimeIterator rIter = (RuntimeIterator)itr.next();
-     if(rIter.getScopeID() == currentScopeId) {
-       independentIterators.add(rIter);
-     }
-   }
-   return independentIterators;
- }
+
+  public List getAllIndependentIteratorsOfCurrentScope() {
+    List independentIterators = new ArrayList(this.indpndtItrToRgnMap.size());
+    Iterator itr = this.indpndtItrToRgnMap.keySet().iterator();
+    int currentScopeId = this.currentScope().getScopeID();
+    while (itr.hasNext()) {
+      RuntimeIterator rIter = (RuntimeIterator) itr.next();
+      if (rIter.getScopeID() == currentScopeId) {
+        independentIterators.add(rIter);
+      }
+    }
+    return independentIterators;
+  }
-   * Asif : This method returns the Region path for the independent
-   * RuntimeIterator if itr exists else returns null. It is the caller's
-   * responsibility to ensure that the passed Iterator is the ultimate
-   * Independent Runtime Iterator or else the method may return null if the
-   * RunTimeIterator is genuinely dependent on a Region iterator
+   * Asif : This method returns the Region path for the independent RuntimeIterator if itr exists
+   * else returns null. It is the caller's responsibility to ensure that the passed Iterator is the
+   * ultimate Independent Runtime Iterator or else the method may return null if the RunTimeIterator
+   * is genuinely dependent on a Region iterator
-  
+
-   * Populates the independent runtime iterator map for index creation purposes.
-   * This method does not create any canonicalized index ids etc.
-   * <p>author Asif
+   * Populates the independent runtime iterator map for index creation purposes. This method does
+   * not create any canonicalized index ids etc.
+   * <p>
+   * author Asif
+   * 
-  public void addToIndependentRuntimeItrMapForIndexCreation(
-      CompiledIteratorDef itrDef) throws AmbiguousNameException,
-      TypeMismatchException, NameResolutionException
-  {
+  public void addToIndependentRuntimeItrMapForIndexCreation(CompiledIteratorDef itrDef)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-    //If the set is empty then add the self RuntimeIterator to the Map.
+    // If the set is empty then add the self RuntimeIterator to the Map.
-  }  
-  
+  }
+
-  
+
-  
+
-  public void reset(){
+  public void reset() {
-  
+
-  
+
-    //throw new UnsupportedOperationException("Method should not have been called");
+    // throw new UnsupportedOperationException("Method should not have been called");
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
-  public PdxString getSavedPdxString(int index){
+
+  public PdxString getSavedPdxString(int index) {
-  
+
-  
+
-  
+
-    return this.currentProjectionField ;
+    return this.currentProjectionField;
-  
+
-  
+
-  
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
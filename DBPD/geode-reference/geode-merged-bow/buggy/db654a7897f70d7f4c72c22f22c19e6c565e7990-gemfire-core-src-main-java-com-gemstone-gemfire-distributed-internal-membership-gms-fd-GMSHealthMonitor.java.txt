Fixing problems with network partition detection

Recent changes in GMSJoinLeave and GMSHealthMonitor destabilized network
partition detection to the point that it was barely working.  This corrects
faults that were causing the failures - exponential barrages of suspect
processing and failure to detect loss of members during membership view
creation.

GMSJoinLeave's removeHealthyMembers and filterMembers methods had some problems
that resulted in unhealthy members not being detected.  GMSHealthMonitor
did not have barriers in place to prevent initiation of concurrent suspect
processing on the same member.  JGroupsMessenger was initiating final checks
on members if unable to send a message to them instead of merely raising
suspicion.

-//  /**
-//   * Members undergoing final checks
-//   */
-//  final private List<InternalDistributedMember> membersInFinalCheck = Collections.synchronizedList(new ArrayList<>(30));
+  /**
+   * Members undergoing final checks
+   */
+  final private List<InternalDistributedMember> membersInFinalCheck = Collections.synchronizedList(new ArrayList<>(30));
-        logger.debug("Unexpected exception", e);
+        // this is expected if it is a connection-timeout or other failure
+        // to connect
-            logger.info("Unexpected exception", e);
+            // expected if the socket is already closed
-   * It records the member activity for current time interval.
+   * Record the member activity for current time interval.
-    TimeStamp cTS = new TimeStamp(currentTimeStamp);
+    contactedBy(sender, currentTimeStamp);
+  }
+  
+  
+  /**
+   * Record member activity at a specified time
+   */
+  private void contactedBy(InternalDistributedMember sender, long timeStamp) {
+    TimeStamp cTS = new TimeStamp(timeStamp);
-      cTS.setTimeStamp(currentTimeStamp);
+      cTS.setTimeStamp(timeStamp);
+  
+    if (services.getJoinLeave().isMemberLeaving(mbr)) {
+      return;
+    }
+    long startTime = System.currentTimeMillis();
+          if (ts != null && ts.getTime() > startTime) {
+            return true;
+          }
-      logger.debug("Unexpected exception", e);
+      // this is expected if it is a connection-timeout or other failure
+      // to connect
-        logger.trace("Unexpected exception", e);
+        // expected
-        this.stats.incFinalCheckResponsesReceived();
-        this.stats.incTcpFinalCheckResponsesReceived();
+        if (b >= 0) {
+          this.stats.incFinalCheckResponsesReceived();
+          this.stats.incTcpFinalCheckResponsesReceived();
+        }
-      contactedBy(m.getSender());
+      contactedBy(m.getSender(), System.currentTimeMillis());
-//    List<InternalDistributedMember> membersChecked = new ArrayList<>(10);
-    try {
-      for (int i = 0; i < sMembers.size(); i++) {
-        final SuspectRequest sr = sMembers.get(i);
-        final InternalDistributedMember mbr = sr.getSuspectMember();
+    for (int i = 0; i < sMembers.size(); i++) {
+      final SuspectRequest sr = sMembers.get(i);
+      final InternalDistributedMember mbr = sr.getSuspectMember();
-        if (!cv.contains(mbr) /*|| membersInFinalCheck.contains(mbr)*/) {
-          continue;
-        }
-
-        if (mbr.equals(localAddress)) {
-          continue;// self
-        }
-        
-//        membersChecked.add(mbr);
-
-        // suspectMemberInView is now set by the heartbeat monitoring code
-        // to allow us to move on from watching members we've already
-        // suspected.  Since that code is updating this collection we
-        // cannot use it here as an indication that a member is currently
-        // undergoing a final check.
-        //      NetView view;
-        //      view = suspectedMemberInView.putIfAbsent(mbr, cv);
-
-        //      if (view == null || !view.equals(cv)) {
-        final String reason = sr.getReason();
-        logger.debug("Scheduling final check for member {}; reason={}", mbr, reason);
-        // its a coordinator
-        checkExecutor.execute(new Runnable() {
-
-          @Override
-          public void run() {
-            try {
-              inlineCheckIfAvailable(initiator, cv, true, mbr,
-                  reason);
-            } catch (DistributedSystemDisconnectedException e) {
-              return;
-            } catch (Exception e) {
-              logger.info("Unexpected exception while verifying member", e);
-            } finally {
-              GMSHealthMonitor.this.suspectedMemberInView.remove(mbr);
-            }
-          }
-
-          
-        });
-        //      }// scheduling for final check and removing it..
+      if (!cv.contains(mbr) || membersInFinalCheck.contains(mbr)) {
+        continue;
-    } finally {
-//      membersInFinalCheck.removeAll(membersChecked);
+
+      if (mbr.equals(localAddress)) {
+        continue;// self
+      }
+
+      // suspectMemberInView is now set by the heartbeat monitoring code
+      // to allow us to move on from watching members we've already
+      // suspected.  Since that code is updating this collection we
+      // cannot use it here as an indication that a member is currently
+      // undergoing a final check.
+      //      NetView view;
+      //      view = suspectedMemberInView.putIfAbsent(mbr, cv);
+
+      //      if (view == null || !view.equals(cv)) {
+      final String reason = sr.getReason();
+      logger.debug("Scheduling final check for member {}; reason={}", mbr, reason);
+      // its a coordinator
+      checkExecutor.execute(new Runnable() {
+
+        @Override
+        public void run() {
+          try {
+            inlineCheckIfAvailable(initiator, cv, true, mbr,
+                reason);
+          } catch (DistributedSystemDisconnectedException e) {
+            return;
+          } catch (Exception e) {
+            logger.info("Unexpected exception while verifying member", e);
+          } finally {
+            GMSHealthMonitor.this.suspectedMemberInView.remove(mbr);
+          }
+        }
+
+
+      });
+      //      }// scheduling for final check and removing it..
-    services.memberSuspected(initiator, mbr, reason);
-    long startTime = System.currentTimeMillis();
-    // for some reason we used to update the timestamp for the member
-    // with the startTime, but we don't want to do that because it looks
-    // like a heartbeat has been received
-
-    logger.info("Performing final check for suspect member {} reason={}", mbr, reason);
-    boolean pinged;
-    int port = cv.getFailureDetectionPort(mbr);
-    if (port <= 0) {
-      logger.info("Unable to locate failure detection port - requesting a heartbeat");
-      if (logger.isDebugEnabled()) {
-        logger.debug("\ncurrent view: {}\nports: {}", cv, Arrays.toString(cv.getFailureDetectionPorts()));
-      }
-      pinged = GMSHealthMonitor.this.doCheckMember(mbr);
-      GMSHealthMonitor.this.stats.incFinalCheckRequestsSent();
-      GMSHealthMonitor.this.stats.incUdpFinalCheckRequestsSent();
-      if (pinged) {
-        GMSHealthMonitor.this.stats.incFinalCheckResponsesReceived();
-        GMSHealthMonitor.this.stats.incUdpFinalCheckResponsesReceived();
-      }
-    } else {
-      pinged = GMSHealthMonitor.this.doTCPCheckMember(mbr, port);
+    if (services.getJoinLeave().isMemberLeaving(mbr)) {
+      return false;
-    if (!pinged && !isStopping) {
-      TimeStamp ts = memberTimeStamps.get(mbr);
-      if (ts == null || ts.getTime() <= startTime) {
-        logger.info("Final check failed - requesting removal of suspect member " + mbr);
-        if (initiateRemoval) {
-          services.getJoinLeave().remove(mbr, reason);
+
+    membersInFinalCheck.add(mbr);
+    try {
+      services.memberSuspected(initiator, mbr, reason);
+      long startTime = System.currentTimeMillis();
+      // for some reason we used to update the timestamp for the member
+      // with the startTime, but we don't want to do that because it looks
+      // like a heartbeat has been received
+  
+      logger.info("Performing final check for suspect member {} reason={}", mbr, reason);
+      boolean pinged;
+      int port = cv.getFailureDetectionPort(mbr);
+      if (port <= 0) {
+        logger.info("Unable to locate failure detection port - requesting a heartbeat");
+        if (logger.isDebugEnabled()) {
+          logger.debug("\ncurrent view: {}\nports: {}", cv, Arrays.toString(cv.getFailureDetectionPorts()));
-        failed = true;
+        pinged = GMSHealthMonitor.this.doCheckMember(mbr);
+        GMSHealthMonitor.this.stats.incFinalCheckRequestsSent();
+        GMSHealthMonitor.this.stats.incUdpFinalCheckRequestsSent();
+        if (pinged) {
+          GMSHealthMonitor.this.stats.incFinalCheckResponsesReceived();
+          GMSHealthMonitor.this.stats.incUdpFinalCheckResponsesReceived();
+        }
-        logger.info("Final check failed but detected recent message traffic for suspect member " + mbr);
+        pinged = GMSHealthMonitor.this.doTCPCheckMember(mbr, port);
+  
+      if (!pinged && !isStopping) {
+        TimeStamp ts = memberTimeStamps.get(mbr);
+        if (ts == null || ts.getTime() <= startTime) {
+          logger.info("Final check failed - requesting removal of suspect member " + mbr);
+          if (initiateRemoval) {
+            services.getJoinLeave().remove(mbr, reason);
+          }
+          failed = true;
+        } else {
+          logger.info("Final check failed but detected recent message traffic for suspect member " + mbr);
+        }
+      }
+      if (!failed) {
+        logger.info("Final check passed for suspect member " + mbr);
+      }
+      // whether it's alive or not, at this point we allow it to
+      // be watched again
+      suspectedMemberInView.remove(mbr);
+    } finally {
+      membersInFinalCheck.remove(mbr);
-    if (!failed) {
-      logger.info("Final check passed for suspect member " + mbr);
-    }
-    // whether it's alive or not, at this point we allow it to
-    // be watched again
-    suspectedMemberInView.remove(mbr);

INS23 INS31 INS29 INS83 INS83 INS74 INS59 MOV78 INS83 INS39 INS42 INS44 INS8 INS29 UPD83 INS44 MOV8 INS8 INS65 INS43 INS43 INS42 INS32 INS43 INS42 INS21 INS65 INS39 INS42 INS25 INS60 INS25 MOV60 INS21 INS54 MOV41 INS66 INS42 INS42 INS42 INS42 INS14 INS42 INS32 INS66 MOV43 INS32 INS8 INS39 INS59 INS32 INS8 INS32 MOV8 INS8 INS74 INS34 INS42 INS42 INS42 INS32 INS42 INS42 INS41 INS42 INS32 INS32 INS42 INS42 INS41 INS42 INS42 INS42 INS21 INS43 MOV43 UPD42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS9 INS32 INS42 UPD42 INS25 INS32 MOV38 INS32 INS42 INS42 INS42 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS25 INS42 INS34 MOV21 MOV21 INS27 INS8 INS27 INS27 INS41 INS42 INS33 INS32 INS42 INS9 INS42 INS42 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8
GEODE-127: Improve test reliability and execution speed.

Recategorize tests involving spawned processes and file system I/O as
IntegrationTests.

Improve reliability and shorten execution time. Fix up asynchronous waits,
correct JUnit 4 syntax and misc code tidying.

Add new TestSuite classes for targeted testing of test.golden and
test.process packages.

+import static org.junit.Assert.*;
+
+import java.util.concurrent.TimeoutException;
-import com.gemstone.gemfire.test.process.*;
-
-import junit.framework.Assert;
-
- * Wraps spawned process to capture output and provide hooks to the
- * {@link java.lang.Process} object.
+ * Wraps spawned {@link java.lang.Process} to capture output and provide interaction with the process.
-public class ProcessWrapper extends Assert {
+public class ProcessWrapper {
-  protected static final String TIMEOUT_MILLIS_PROPERTY = "quickstart.test.TIMEOUT_MILLIS";
-  private static final long TIMEOUT_MILLIS = Long.getLong(TIMEOUT_MILLIS_PROPERTY, 5 * 60 * 1000L); 
-  private static final boolean JAVA_AWT_HEADLESS = true;
+  protected static final String TIMEOUT_MILLIS_PROPERTY = "process.test.timeoutMillis";
+  protected static final long TIMEOUT_MILLIS_DEFAULT = 5 * 60 * 1000;
+  private static final long DELAY = 10;
-  private final String[] jvmArgs;  
+  private final boolean headless;
+  private final long timeoutMillis; 
+  
+  private final String[] jvmArguments;  
-  private final String[] mainArgs;
+  private final String[] mainArguments;
-  public ProcessWrapper(Class<?> main, String[] mainArgs) {
-    this(main, mainArgs, true);
-  }
-
-  public ProcessWrapper(Class<?> main, String[] mainArgs, boolean useMainLauncher) {
-    this(null, main, mainArgs, true);
-  }
-  
-  public ProcessWrapper(String[] jvmArgs, Class<?> main, String[] mainArgs, boolean useMainLauncher) {
-    this.jvmArgs = jvmArgs;
+  private ProcessWrapper(final String[] jvmArguments, final Class<?> mainClass, final String[] mainArguments, final boolean useMainLauncher, final boolean headless, final long timeoutMillis) {
+    this.jvmArguments = jvmArguments;
+    this.mainClass = mainClass;
+    this.mainArguments = mainArguments;
+    this.useMainLauncher = useMainLauncher;
+    this.headless = headless;
+    this.timeoutMillis = timeoutMillis;
-    this.mainClass = main;
-    this.mainArgs = mainArgs;
-
-    
-    this.useMainLauncher = useMainLauncher;
-  public ProcessStreamReader getStandardOutReader() { // TODO:protected
+  public ProcessStreamReader getStandardOutReader() {
-  public ProcessStreamReader getStandardErrorReader() { // TODO:protected
+  public ProcessStreamReader getStandardErrorReader() {
-  private void waitForProcessStart() throws InterruptedException {
-    long start = System.currentTimeMillis();
+  private void waitForProcessStart() throws InterruptedException, TimeoutException {
+    final long start = System.currentTimeMillis();
-        done = (this.process != null || this.processException != null) && 
-            (this.started || this.exitValue.get() > -1 || this.interrupted);
+        done = (this.process != null || this.processException != null) && (this.started || this.exitValue.get() > -1 || this.interrupted);
-      if (!done && System.currentTimeMillis() > start + TIMEOUT_MILLIS) {
-        fail("Timed out launching process");
+      if (!done && System.currentTimeMillis() > start + timeoutMillis) {
+        throw new TimeoutException("Timed out launching process");
-      Thread.sleep(100);
+      Thread.sleep(DELAY);
-  public boolean isAlive() throws InterruptedException {
+  public boolean isAlive() throws InterruptedException, TimeoutException {
-  public int waitFor(long timeout, boolean throwOnTimeout) throws InterruptedException {
+  public int waitFor(final long timeout, final boolean throwOnTimeout) throws InterruptedException {
-    Thread thread = getThread();
+    final Thread thread = getThread();
-  public int waitFor(long timeout) throws InterruptedException {
+  public int waitFor(final long timeout) throws InterruptedException {
-  public int waitFor(boolean throwOnTimeout) throws InterruptedException {
-    return waitFor(TIMEOUT_MILLIS, throwOnTimeout);
+  public int waitFor(final boolean throwOnTimeout) throws InterruptedException {
+    return waitFor(timeoutMillis, throwOnTimeout);
-    return waitFor(TIMEOUT_MILLIS, false);
+    return waitFor(timeoutMillis, false);
-  public String getOutput(boolean ignoreStopped) { 
+  public String getOutput(final boolean ignoreStopped) { 
-    StringBuffer sb = new StringBuffer();
-    Iterator<String> iterator = allLines.iterator();
+    final StringBuffer sb = new StringBuffer();
+    final Iterator<String> iterator = this.allLines.iterator();
-  public ProcessWrapper sendInput(String input) {
+  public ProcessWrapper sendInput(final String input) {
-    PrintStream ps = new PrintStream(this.process.getOutputStream());
+    final PrintStream ps = new PrintStream(this.process.getOutputStream());
-  public ProcessWrapper failIfOutputMatches(String patternString, long timeoutMillis) throws InterruptedException {
+  public ProcessWrapper failIfOutputMatches(final String patternString, final long timeoutMillis) throws InterruptedException {
-
-    Pattern pattern = Pattern.compile(patternString);
+    final Pattern pattern = Pattern.compile(patternString);
-    long start = System.currentTimeMillis();
+    final long start = System.currentTimeMillis();
+    
-      String line = lineBuffer.poll(timeoutMillis, TimeUnit.MILLISECONDS);
-
+      final String line = lineBuffer.poll(timeoutMillis, TimeUnit.MILLISECONDS);
-  public ProcessWrapper waitForOutputToMatch(String patternString, long timeoutMillis) throws InterruptedException {
+  public ProcessWrapper waitForOutputToMatch(final String patternString, final long timeoutMillis) throws InterruptedException {
-    Pattern pattern = Pattern.compile(patternString);
-    
+    final Pattern pattern = Pattern.compile(patternString);
+    
-      String line = this.lineBuffer.poll(timeoutMillis, TimeUnit.MILLISECONDS);
-
+      final String line = this.lineBuffer.poll(timeoutMillis, TimeUnit.MILLISECONDS);
-        fail("Timed out waiting for output \"" + patternString + "\" after " + TIMEOUT_MILLIS + " ms. Output: " + new OutputFormatter(this.allLines));
+        fail("Timed out waiting for output \"" + patternString + "\" after " + timeoutMillis + " ms. Output: " + new OutputFormatter(this.allLines));
-  public ProcessWrapper waitForOutputToMatch(String patternString) throws InterruptedException {
-    return waitForOutputToMatch(patternString, TIMEOUT_MILLIS);
+  public ProcessWrapper waitForOutputToMatch(final String patternString) throws InterruptedException {
+    return waitForOutputToMatch(patternString, timeoutMillis);
-  public ProcessWrapper execute() throws InterruptedException {
+  public ProcessWrapper execute() throws InterruptedException, TimeoutException {
-  public ProcessWrapper execute(Properties props) throws InterruptedException {
-    return execute(props, new File(System.getProperty("user.dir")));
+  public ProcessWrapper execute(final Properties properties) throws InterruptedException, TimeoutException {
+    return execute(properties, new File(System.getProperty("user.dir")));
-  public ProcessWrapper execute(final Properties props, final File workingDirectory) throws InterruptedException {
+  public ProcessWrapper execute(final Properties properties, final File workingDirectory) throws InterruptedException, TimeoutException {
-          exec(props, workingDirectory);
+          start(properties, workingDirectory);
-        System.out.println("ProcessWrapper:execute failed with " + this.processException);
+        logger.error("ProcessWrapper:execute failed with " + this.processException);
-  private void exec(Properties dsProps, final File workingDirectory) {
-    List<String> vmArgList = new ArrayList<String>();
+  private void start(final Properties properties, final File workingDirectory) {
+    final List<String> jvmArgumentsList = new ArrayList<String>();
-    if (dsProps != null) {
-      for (Map.Entry<Object, Object> entry : dsProps.entrySet()) {
+    if (properties != null) {
+      for (Map.Entry<Object, Object> entry : properties.entrySet()) {
-          vmArgList.add("-D" + entry.getKey() + "=" + entry.getValue());
+          jvmArgumentsList.add("-D" + entry.getKey() + "=" + entry.getValue());
-    if (JAVA_AWT_HEADLESS) {
-      vmArgList.add("-Djava.awt.headless=true");
+    if (this.headless) {
+      jvmArgumentsList.add("-Djava.awt.headless=true");
-    if (this.jvmArgs != null) {
-      for (String vmArg: this.jvmArgs) {
-        vmArgList.add(vmArg);
+    if (this.jvmArguments != null) {
+      for (String jvmArgument: this.jvmArguments) {
+        jvmArgumentsList.add(jvmArgument);
-    String[] vmArgs = vmArgList.toArray(new String[vmArgList.size()]);
-
-        String[] command = defineCommand(vmArgs);
+        final String[] command = defineCommand(jvmArgumentsList.toArray(new String[jvmArgumentsList.size()]));
-        StringBuilder processCommand = new StringBuilder();
+        final StringBuilder processCommand = new StringBuilder();
+        
-        String commandString = processCommand.toString();
-        System.out.println("Executing " + commandString);
+        
+        final String commandString = processCommand.toString();
+        logger.debug("Starting " + commandString);
+        
-  
-      
-  private String[] defineCommand(String[] vmArgs) {
-    File javabindir = new File(System.getProperty("java.home"), "bin");
-    File javaexe = new File(javabindir, "java");
+  private String[] defineCommand(final String[] jvmArguments) {
+    final File javaBinDir = new File(System.getProperty("java.home"), "bin");
+    final File javaExe = new File(javaBinDir, "java");
-    List<String> argList = new ArrayList<String>();
-    argList.add(javaexe.getPath());
-    argList.add("-classpath");
-    argList.add(System.getProperty("java.class.path"));
+    final List<String> argumentList = new ArrayList<String>();
+    argumentList.add(javaExe.getPath());
+    argumentList.add("-classpath");
+    argumentList.add(System.getProperty("java.class.path"));
-    int bits = Integer.getInteger("sun.arch.data.model", 0).intValue();
+    final int bits = Integer.getInteger("sun.arch.data.model", 0).intValue();
-      argList.add("-d64");
+      argumentList.add("-d64");
-    argList.add("-Djava.library.path=" + System.getProperty("java.library.path"));
+    argumentList.add("-Djava.library.path=" + System.getProperty("java.library.path"));
-    if (vmArgs != null) {
-      argList.addAll(Arrays.asList(vmArgs));
+    if (jvmArguments != null) {
+      argumentList.addAll(Arrays.asList(jvmArguments));
-      argList.add(MainLauncher.class.getName());
+      argumentList.add(MainLauncher.class.getName());
-    argList.add(mainClass.getName());
+    argumentList.add(mainClass.getName());
-    if (mainArgs != null) {
-      argList.addAll(Arrays.asList(mainArgs));
+    if (mainArguments != null) {
+      argumentList.addAll(Arrays.asList(mainArguments));
-    String[] cmd = argList.toArray(new String[argList.size()]);
-    return cmd;
+    final String[] command = argumentList.toArray(new String[argumentList.size()]);
+    return command;
-  private String toString(String[] strings) {
-    if (strings == null || strings.length < 1) {
-      return null;
-    }
-    StringBuilder sb = new StringBuilder();
-    for (String string : strings) {
-      sb.append(string).append("\n");
-    }
-    return sb.toString();
-  }
-
-      RuntimeException rt = new RuntimeException("Failed to launch process", this.processException);
-      throw rt;
+      throw new RuntimeException("Failed to launch process", this.processException);
+  @Override
-    StringBuilder sb = new StringBuilder(getClass().getSimpleName());
+    final StringBuilder sb = new StringBuilder(getClass().getSimpleName());
-    private String[] jvmArgs = null;
-    private Class<?> main;
-    private String[] mainArgs = null;
+    private String[] jvmArguments = null;
+    private Class<?> mainClass;
+    private String[] mainArguments = null;
+    private boolean headless = true;
+    private long timeoutMillis = TIMEOUT_MILLIS_DEFAULT;
+    private boolean inline = false;
-    public Builder jvmArgs(String[] jvmArgs) {
-      this.jvmArgs = jvmArgs;
+    public Builder jvmArguments(final String[] jvmArguments) {
+      this.jvmArguments = jvmArguments;
-    public Builder main(Class<?> main) { 
-      this.main = main;
+    public Builder mainClass(final Class<?> mainClass) { 
+      this.mainClass = mainClass;
-    public Builder mainArgs(String[] mainArgs) {
-      this.mainArgs = mainArgs;
+    public Builder mainArguments(final String[] mainArguments) {
+      this.mainArguments = mainArguments;
-    public Builder useMainLauncher(boolean useMainLauncher) {
+    public Builder useMainLauncher(final boolean useMainLauncher) {
+    public Builder headless(final boolean headless) {
+      this.headless = headless;
+      return this;
+    }
+    public Builder timeoutMillis(final long timeoutMillis) {
+      this.timeoutMillis = timeoutMillis;
+      return this;
+    }
+    public Builder inline(final boolean inline) {
+      this.inline = inline;
+      return this;
+    }
-      return new ProcessWrapper(jvmArgs, main, mainArgs, useMainLauncher);
+      return new ProcessWrapper(jvmArguments, mainClass, mainArguments, useMainLauncher, headless, timeoutMillis);

MOV26 MOV26 UPD40 UPD40 INS23 INS23 MOV23 MOV23 UPD83 UPD39 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 UPD83 MOV44 MOV44 MOV44 MOV21 INS43 INS43 INS43 INS44 INS43 MOV44 INS43 UPD42 MOV43 INS78 INS23 INS23 INS23 INS31 INS31 INS31 UPD66 UPD66 UPD45 UPD42 INS27 UPD42 INS34 INS42 INS42 UPD42 UPD42 INS83 UPD42 INS83 UPD42 INS83 UPD42 INS83 INS39 INS42 INS83 INS39 INS42 INS83 UPD39 UPD42 INS21 INS21 INS42 INS42 INS83 INS83 INS83 INS83 INS83 INS83 INS83 INS83 INS83 INS83 INS83 MOV43 INS42 INS83 MOV43 INS42 INS42 INS83 UPD42 UPD42 MOV42 INS83 UPD42 INS83 UPD42 INS42 MOV5 INS83 INS39 INS59 INS83 INS39 INS59 INS83 INS39 INS59 UPD42 UPD42 UPD42 INS83 INS43 INS42 INS44 INS8 INS83 INS43 INS42 INS44 INS8 INS83 INS43 INS42 INS44 INS8 MOV34 MOV34 UPD34 MOV34 INS7 INS7 INS83 INS83 INS83 INS83 INS83 INS83 INS83 INS83 INS42 INS83 INS22 INS83 INS83 INS83 INS83 INS83 MOV5 UPD42 INS83 UPD42 UPD42 UPD42 INS42 INS9 INS42 INS42 INS42 INS9 INS83 MOV5 UPD42 INS83 UPD42 INS83 UPD42 INS83 INS42 INS83 INS39 INS42 INS21 INS41 INS42 INS83 INS39 INS42 INS21 INS41 INS42 INS83 INS39 INS42 INS21 INS41 UPD42 UPD42 UPD42 INS22 INS42 INS22 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS52 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS7 INS52 INS7 INS52 INS7 INS52 UPD42 UPD42 INS52 INS42 INS52 INS42 INS22 INS83 INS83 UPD42 UPD42 UPD42 UPD42 MOV14 UPD42 UPD42 UPD42 INS22 INS42 INS22 INS42 INS22 INS42 UPD42 UPD42 UPD42 INS42 INS42 INS53 INS42 INS52 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV5 UPD42 UPD42 UPD42 INS52 INS42 INS52 INS42 INS52 INS42 INS14 INS83 MOV5 INS83 INS83 UPD42 UPD42 UPD42 UPD42 INS43 INS45 UPD42 INS42 UPD42 UPD42 UPD42 INS42 INS42 UPD42 INS32 UPD45 UPD42 UPD42 MOV42 INS42 INS3 MOV5 INS32 INS42 INS42 UPD42 UPD42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL27 DEL32 DEL9 DEL83 DEL42 DEL42 DEL43 DEL76 DEL74 DEL42 DEL44 DEL42 DEL42 DEL9 DEL17 DEL8 DEL31 DEL83 DEL42 DEL39 DEL42 DEL44 DEL33 DEL42 DEL42 DEL9 DEL17 DEL8 DEL31 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL76 DEL74 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL44 DEL42 DEL45 DEL32 DEL21 DEL34 DEL42 DEL42 DEL43 DEL83 DEL42 DEL44 DEL40 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL3 DEL32 DEL59 DEL60 DEL40 DEL42 DEL43 DEL85 DEL5 DEL83 DEL42 DEL42 DEL44 DEL42 DEL33 DEL27 DEL40 DEL34 DEL27 DEL27 DEL33 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL45 DEL32 DEL21 DEL8 DEL70 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42
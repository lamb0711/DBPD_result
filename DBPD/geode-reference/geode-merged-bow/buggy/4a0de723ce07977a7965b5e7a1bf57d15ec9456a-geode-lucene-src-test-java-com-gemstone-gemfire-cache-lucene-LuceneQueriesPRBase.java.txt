GEODE-11 Adding tests of closing a cache during index updates

Testing failover of lucene indexes by closing the cache while in the
middle of updating lucene indexes. Currently there are tests for closing
the cache before the index repository commit, and also during the commit
after a fixed number of updates to the underling index data regions.

I refactored the lucene tests to use 7 buckets, rather than 113, so they
take less time and are easier to debug.

I also removed a call to Thread.interrupt in the WAN code because it was
interrupting itself in my callback. We should never be using interrupt
in the product.

+import static com.gemstone.gemfire.cache.lucene.test.IndexRepositorySpy.doOnce;
-import static org.mockito.Mockito.*;
-import java.io.IOException;
-import java.util.concurrent.Callable;
-import java.util.function.Consumer;
-import org.apache.lucene.analysis.Analyzer;
-import org.junit.Ignore;
-import org.mockito.Mockito;
-import org.mockito.stubbing.Answer;
+import com.gemstone.gemfire.cache.PartitionAttributes;
+import com.gemstone.gemfire.cache.PartitionAttributesFactory;
-import com.gemstone.gemfire.cache.lucene.internal.IndexRepositoryFactory;
-import com.gemstone.gemfire.cache.lucene.internal.LuceneIndexStats;
-import com.gemstone.gemfire.cache.lucene.internal.PartitionedRepositoryManager;
-import com.gemstone.gemfire.cache.lucene.internal.filesystem.FileSystemStats;
-import com.gemstone.gemfire.cache.lucene.internal.repository.IndexRepository;
-import com.gemstone.gemfire.cache.lucene.internal.repository.serializer.LuceneSerializer;
+import com.gemstone.gemfire.cache.lucene.test.IndexRepositorySpy;
-import com.gemstone.gemfire.internal.cache.BucketNotFoundException;
-import com.gemstone.gemfire.internal.cache.PartitionedRegion;
+  protected static final int NUM_BUCKETS = 7;
-
-
-  protected void putEntriesAndValidateQueryResults() {
-    SerializableRunnableIF createIndex = () -> {
-      LuceneService luceneService = LuceneServiceProvider.get(getCache());
-      luceneService.createIndex(INDEX_NAME, REGION_NAME, "text");
-    };
-    dataStore1.invoke(() -> initDataStore(createIndex));
-    accessor.invoke(() -> initAccessor(createIndex));
-    dataStore1.invoke(() -> LuceneTestUtilities.pauseSender(getCache()));
-
-    put113Entries();
-
-    dataStore2.invoke(() -> initDataStore(createIndex));
-    dataStore1.invoke(() -> LuceneTestUtilities.resumeSender(getCache()));
-
-    assertTrue(waitForFlushBeforeExecuteTextSearch(dataStore1, 60000));
-
-    executeTextSearch(accessor, "world", "text", 113);
-  }
-
-    put113Entries();
+    putEntryInEachBucket();
-    executeTextSearch(accessor, "world", "text", 113);
+    executeTextSearch(accessor, "world", "text", NUM_BUCKETS);
-    put113Entries();
+    putEntryInEachBucket();
-    executeTextSearch(accessor, "world", "text", 113);
+    executeTextSearch(accessor, "world", "text", NUM_BUCKETS);
-  protected void put113Entries() {
+  protected PartitionAttributes getPartitionAttributes() {
+    PartitionAttributesFactory factory = new PartitionAttributesFactory();
+    factory.setLocalMaxMemory(100);
+    factory.setTotalNumBuckets(NUM_BUCKETS);
+    return factory.create();
+  }
+
+  protected void putEntriesAndValidateQueryResults() {
+    SerializableRunnableIF createIndex = () -> {
+      LuceneService luceneService = LuceneServiceProvider.get(getCache());
+      luceneService.createIndex(INDEX_NAME, REGION_NAME, "text");
+    };
+    dataStore1.invoke(() -> initDataStore(createIndex));
+    accessor.invoke(() -> initAccessor(createIndex));
+    dataStore1.invoke(() -> LuceneTestUtilities.pauseSender(getCache()));
+
+    putEntryInEachBucket();
+
+    dataStore2.invoke(() -> initDataStore(createIndex));
+    dataStore1.invoke(() -> LuceneTestUtilities.resumeSender(getCache()));
+
+    assertTrue(waitForFlushBeforeExecuteTextSearch(dataStore1, 60000));
+
+    executeTextSearch(accessor, "world", "text", NUM_BUCKETS);
+  }
+
+  protected void putEntryInEachBucket() {
-      IntStream.range(0,113).forEach(i -> region.put(i, new TestObject("hello world")));
+      IntStream.range(0,NUM_BUCKETS).forEach(i -> region.put(i, new TestObject("hello world")));
-      spy.beforeWrite(doOnce(key -> rebalanceRegion(vm)));
+      spy.beforeWriteIndexRepository(doOnce(key -> rebalanceRegion(vm)));
-      spy.beforeWrite(doOnce(key -> moveBucket(destination, key)));
+      spy.beforeWriteIndexRepository(doOnce(key -> moveBucket(destination, key)));
-  protected static class IndexRepositorySpy extends IndexRepositoryFactory {
-
-    private Consumer<Object> beforeWrite = key -> {};
-
-    public static IndexRepositorySpy injectSpy() {
-      IndexRepositorySpy factory = new IndexRepositorySpy();
-      PartitionedRepositoryManager.indexRepositoryFactory = factory;
-      return factory;
-    }
-
-    public static void remove() {
-      PartitionedRepositoryManager.indexRepositoryFactory = new IndexRepositoryFactory();
-    }
-
-    private IndexRepositorySpy() {
-    }
-
-    @Override
-    public IndexRepository createIndexRepository(final Integer bucketId,
-                                                 final PartitionedRegion userRegion,
-                                                 final PartitionedRegion fileRegion,
-                                                 final PartitionedRegion chunkRegion,
-                                                 final LuceneSerializer serializer,
-                                                 final Analyzer analyzer,
-                                                 final LuceneIndexStats indexStats,
-                                                 final FileSystemStats fileSystemStats)
-      throws IOException
-    {
-      final IndexRepository indexRepo = super.createIndexRepository(bucketId, userRegion, fileRegion, chunkRegion,
-        serializer, analyzer,
-        indexStats,
-        fileSystemStats);
-      final IndexRepository spy = Mockito.spy(indexRepo);
-
-      Answer invokeBeforeWrite = invocation -> {
-        beforeWrite.accept(invocation.getArgumentAt(0, Object.class));
-        invocation.callRealMethod();
-        return null;
-      };
-      doAnswer(invokeBeforeWrite).when(spy).update(any(), any());
-      doAnswer(invokeBeforeWrite).when(spy).create(any(), any());
-      doAnswer(invokeBeforeWrite).when(spy).delete(any());
-
-      return spy;
-    }
-
-    /**
-     * Add a callback that runs before a call to
-     * {@link IndexRepository#create(Object, Object)}
-     */
-    public void beforeWrite(Consumer<Object> action) {
-      this.beforeWrite = action;
-    }
-  }
-
-  protected static <T> Consumer<T> doOnce(Consumer<T> consumer) {
-    return new Consumer<T>() {
-      boolean done;
-
-      @Override
-      public void accept(final T t) {
-        if (!done) {
-          done = true;
-          consumer.accept(t);
-        }
-      }
-    };
-  };
+  ;
+  ;

MOV26 MOV26 MOV26 MOV31 MOV31 UPD40 UPD40 UPD40 UPD40 INS23 MOV31 INS83 INS83 UPD83 MOV83 INS39 INS59 UPD42 UPD42 UPD83 INS43 INS42 UPD42 UPD42 MOV42 INS34 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 UPD42 MOV42 MOV21 INS41 UPD43 INS32 UPD42 INS42 UPD42 INS42 UPD42 INS42 INS14 UPD42 UPD42 MOV42 UPD34 MOV34 UPD42 MOV42 UPD42 UPD42 MOV42 UPD42 MOV42 MOV42 UPD42 INS42 INS43 INS42 UPD42 UPD42 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL34 DEL34 DEL42 DEL78 DEL42 DEL43 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL83 DEL43 DEL42 DEL44 DEL83 DEL42 DEL43 DEL42 DEL44 DEL83 DEL42 DEL43 DEL42 DEL44 DEL83 DEL42 DEL43 DEL42 DEL44 DEL83 DEL42 DEL43 DEL42 DEL44 DEL83 DEL42 DEL43 DEL42 DEL44 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL83 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL48 DEL42 DEL42 DEL42 DEL43 DEL57 DEL32 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL59 DEL42 DEL42 DEL32 DEL21 DEL33 DEL41 DEL8 DEL86 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL41 DEL34 DEL34 DEL83 DEL83 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL8 DEL86 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL40 DEL42 DEL7 DEL21 DEL42 DEL41 DEL8 DEL31 DEL83 DEL83 DEL39 DEL42 DEL40 DEL42 DEL43 DEL14 DEL7 DEL21 DEL8 DEL31 DEL83 DEL42 DEL8 DEL31 DEL66 DEL42 DEL42 DEL42 DEL43 DEL69 DEL42 DEL43 DEL69 DEL68 DEL65 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL55 DEL83 DEL83 DEL42 DEL73 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL39 DEL42 DEL59 DEL23 DEL42 DEL78 DEL83 DEL39 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL38 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL1 DEL14 DEL41 DEL8 DEL31
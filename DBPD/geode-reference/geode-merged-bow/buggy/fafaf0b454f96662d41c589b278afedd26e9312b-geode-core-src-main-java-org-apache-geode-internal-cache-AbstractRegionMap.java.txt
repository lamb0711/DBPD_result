GEODE-5134: pendingCallbacks is never null (#1863)

The tx* method implementations now always expect the pendingCallbacks parameter to not be null.
Also "cb" was renamed to "callback" for clarity.


+    assert pendingCallbacks != null;
-    boolean cbEventInPending = false;
+    boolean callbackEventAddedToPending = false;
-              boolean invokeCallbacks = shouldCreateCBEvent(owner, isRegionReady || inRI);
+              boolean invokeCallbacks = shouldCreateCallbackEvent(owner, isRegionReady || inRI);
-              EntryEventImpl cbEvent =
-                  createCBEvent(owner, op, key, null, txId, txEvent, eventId, aCallbackArgument,
-                      filterRoutingInfo, bridgeContext, txEntryState, versionTag, tailKey);
+              EntryEventImpl callbackEvent = createCallbackEvent(owner, op, key, null, txId,
+                  txEvent, eventId, aCallbackArgument, filterRoutingInfo, bridgeContext,
+                  txEntryState, versionTag, tailKey);
-                  txHandleWANEvent(owner, cbEvent, txEntryState);
+                  txHandleWANEvent(owner, callbackEvent, txEntryState);
-                cbEvent.setRegionEntry(re);
-                cbEvent.setOldValue(oldValue);
+                callbackEvent.setRegionEntry(re);
+                callbackEvent.setOldValue(oldValue);
-                  logger.debug("txApplyDestroy cbEvent={}", cbEvent);
+                  logger.debug("txApplyDestroy callbackEvent={}", callbackEvent);
-                  processAndGenerateTXVersionTag(owner, cbEvent, re, txEntryState);
+                  processAndGenerateTXVersionTag(owner, callbackEvent, re, txEntryState);
-                        if (shouldPerformConcurrencyChecks(owner, cbEvent)
-                            && cbEvent.getVersionTag() != null) {
-                          re.makeTombstone(owner, cbEvent.getVersionTag());
+                        if (shouldPerformConcurrencyChecks(owner, callbackEvent)
+                            && callbackEvent.getVersionTag() != null) {
+                          re.makeTombstone(owner, callbackEvent.getVersionTag());
-                  switchEventOwnerAndOriginRemote(cbEvent, hasRemoteOrigin);
-                  if (pendingCallbacks == null) {
-                    owner.invokeTXCallbacks(EnumListenerEvent.AFTER_DESTROY, cbEvent,
-                        true/* callDispatchListenerEvent */);
-                  } else {
-                    pendingCallbacks.add(cbEvent);
-                    cbEventInPending = true;
-                  }
+                  switchEventOwnerAndOriginRemote(callbackEvent, hasRemoteOrigin);
+                  pendingCallbacks.add(callbackEvent);
+                  callbackEventAddedToPending = true;
-                    && cbEvent != null) {
-                  txEntryState.setVersionTag(cbEvent.getVersionTag());
+                    && callbackEvent != null) {
+                  txEntryState.setVersionTag(callbackEvent.getVersionTag());
-                if (!cbEventInPending)
-                  cbEvent.release();
+                if (!callbackEventAddedToPending)
+                  callbackEvent.release();
-        EntryEventImpl cbEvent = null;
+        EntryEventImpl callbackEvent = null;
-                    boolean invokeCallbacks = shouldCreateCBEvent(owner, isRegionReady || inRI);
-                    cbEvent = createCBEvent(owner, op, key, null, txId, txEvent, eventId,
-                        aCallbackArgument, filterRoutingInfo, bridgeContext, txEntryState,
+                    boolean invokeCallbacks =
+                        shouldCreateCallbackEvent(owner, isRegionReady || inRI);
+                    callbackEvent = createCallbackEvent(owner, op, key, null, txId, txEvent,
+                        eventId, aCallbackArgument, filterRoutingInfo, bridgeContext, txEntryState,
-                      cbEvent.setRegionEntry(oldRe);
-                      cbEvent.setOldValue(Token.NOT_AVAILABLE);
+                      callbackEvent.setRegionEntry(oldRe);
+                      callbackEvent.setOldValue(Token.NOT_AVAILABLE);
-                        logger.debug("txApplyDestroy token mode cbEvent={}", cbEvent);
+                        logger.debug("txApplyDestroy token mode callbackEvent={}", callbackEvent);
-                        txHandleWANEvent(owner, cbEvent, txEntryState);
+                        txHandleWANEvent(owner, callbackEvent, txEntryState);
-                      processAndGenerateTXVersionTag(owner, cbEvent, oldRe, txEntryState);
+                      processAndGenerateTXVersionTag(owner, callbackEvent, oldRe, txEntryState);
-                        switchEventOwnerAndOriginRemote(cbEvent, hasRemoteOrigin);
-                        if (pendingCallbacks == null) {
-                          owner.invokeTXCallbacks(EnumListenerEvent.AFTER_DESTROY, cbEvent,
-                              dispatchListenerEvent);
-                        } else {
-                          pendingCallbacks.add(cbEvent);
-                          cbEventInPending = true;
-                        }
+                        switchEventOwnerAndOriginRemote(callbackEvent, hasRemoteOrigin);
+                        pendingCallbacks.add(callbackEvent);
+                        callbackEventAddedToPending = true;
-                      if (!cbEventInPending)
-                        cbEvent.release();
+                      if (!callbackEventAddedToPending)
+                        callbackEvent.release();
-                  if (shouldPerformConcurrencyChecks(owner, cbEvent)
-                      && cbEvent.getVersionTag() != null) {
-                    oldRe.makeTombstone(owner, cbEvent.getVersionTag());
+                  if (shouldPerformConcurrencyChecks(owner, callbackEvent)
+                      && callbackEvent.getVersionTag() != null) {
+                    oldRe.makeTombstone(owner, callbackEvent.getVersionTag());
-              boolean invokeCallbacks = shouldCreateCBEvent(owner, isRegionReady || inRI);
-              cbEvent =
-                  createCBEvent(owner, op, key, null, txId, txEvent, eventId, aCallbackArgument,
-                      filterRoutingInfo, bridgeContext, txEntryState, versionTag, tailKey);
+              boolean invokeCallbacks = shouldCreateCallbackEvent(owner, isRegionReady || inRI);
+              callbackEvent = createCallbackEvent(owner, op, key, null, txId, txEvent, eventId,
+                  aCallbackArgument, filterRoutingInfo, bridgeContext, txEntryState, versionTag,
+                  tailKey);
-                cbEvent.setRegionEntry(newRe);
-                cbEvent.setOldValue(Token.NOT_AVAILABLE);
+                callbackEvent.setRegionEntry(newRe);
+                callbackEvent.setOldValue(Token.NOT_AVAILABLE);
-                  logger.debug("txApplyDestroy token mode cbEvent={}", cbEvent);
+                  logger.debug("txApplyDestroy token mode callbackEvent={}", callbackEvent);
-                  txHandleWANEvent(owner, cbEvent, txEntryState);
+                  txHandleWANEvent(owner, callbackEvent, txEntryState);
-                processAndGenerateTXVersionTag(owner, cbEvent, newRe, txEntryState);
+                processAndGenerateTXVersionTag(owner, callbackEvent, newRe, txEntryState);
-                  switchEventOwnerAndOriginRemote(cbEvent, hasRemoteOrigin);
-                  if (pendingCallbacks == null) {
-                    owner.invokeTXCallbacks(EnumListenerEvent.AFTER_DESTROY, cbEvent,
-                        dispatchListenerEvent);
-                  } else {
-                    pendingCallbacks.add(cbEvent);
-                    cbEventInPending = true;
-                  }
+                  switchEventOwnerAndOriginRemote(callbackEvent, hasRemoteOrigin);
+                  pendingCallbacks.add(callbackEvent);
+                  callbackEventAddedToPending = true;
-                if (shouldPerformConcurrencyChecks(owner, cbEvent)
-                    && cbEvent.getVersionTag() != null) {
-                  newRe.makeTombstone(owner, cbEvent.getVersionTag());
+                if (shouldPerformConcurrencyChecks(owner, callbackEvent)
+                    && callbackEvent.getVersionTag() != null) {
+                  newRe.makeTombstone(owner, callbackEvent.getVersionTag());
-                if (!cbEventInPending)
-                  cbEvent.release();
+                if (!callbackEventAddedToPending)
+                  callbackEvent.release();
-            if (owner.getConcurrencyChecksEnabled() && txEntryState != null && cbEvent != null) {
-              txEntryState.setVersionTag(cbEvent.getVersionTag());
+            if (owner.getConcurrencyChecksEnabled() && txEntryState != null
+                && callbackEvent != null) {
+              txEntryState.setVersionTag(callbackEvent.getVersionTag());
-        EntryEventImpl cbEvent = createCBEvent(owner, op, key, null, txId, txEvent, eventId,
-            aCallbackArgument, filterRoutingInfo, bridgeContext, txEntryState, versionTag, tailKey);
+        EntryEventImpl callbackEvent =
+            createCallbackEvent(owner, op, key, null, txId, txEvent, eventId, aCallbackArgument,
+                filterRoutingInfo, bridgeContext, txEntryState, versionTag, tailKey);
-            txHandleWANEvent(owner, cbEvent, txEntryState);
+            txHandleWANEvent(owner, callbackEvent, txEntryState);
-          switchEventOwnerAndOriginRemote(cbEvent, hasRemoteOrigin);
-          if (pendingCallbacks == null) {
-            owner.invokeTXCallbacks(EnumListenerEvent.AFTER_DESTROY, cbEvent, false);
-          } else {
-            pendingCallbacks.add(cbEvent);
-            cbEventInPending = true;
-          }
+          switchEventOwnerAndOriginRemote(callbackEvent, hasRemoteOrigin);
+          pendingCallbacks.add(callbackEvent);
+          callbackEventAddedToPending = true;
-          if (!cbEventInPending)
-            cbEvent.release();
+          if (!callbackEventAddedToPending)
+            callbackEvent.release();
+    assert pendingCallbacks != null;
-    EntryEventImpl cbEvent = null;
+    EntryEventImpl callbackEvent = null;
-                  boolean invokeCallbacks = shouldCreateCBEvent(owner, owner.isInitialized());
-                  boolean cbEventInPending = false;
-                  cbEvent = createCBEvent(owner,
+                  boolean invokeCallbacks = shouldCreateCallbackEvent(owner, owner.isInitialized());
+                  boolean callbackEventInPending = false;
+                  callbackEvent = createCallbackEvent(owner,
-                    cbEvent.setRegionEntry(oldRe);
-                    cbEvent.setOldValue(oldValue);
+                    callbackEvent.setRegionEntry(oldRe);
+                    callbackEvent.setOldValue(oldValue);
-                      logger.debug("txApplyInvalidate cbEvent={}", cbEvent);
+                      logger.debug("txApplyInvalidate callbackEvent={}", callbackEvent);
-                    processAndGenerateTXVersionTag(owner, cbEvent, oldRe, txEntryState);
+                    processAndGenerateTXVersionTag(owner, callbackEvent, oldRe, txEntryState);
-                      switchEventOwnerAndOriginRemote(cbEvent, hasRemoteOrigin);
-                      if (pendingCallbacks == null) {
-                        owner.invokeTXCallbacks(EnumListenerEvent.AFTER_INVALIDATE, cbEvent,
-                            true/* callDispatchListenerEvent */);
-                      } else {
-                        pendingCallbacks.add(cbEvent);
-                        cbEventInPending = true;
-                      }
+                      switchEventOwnerAndOriginRemote(callbackEvent, hasRemoteOrigin);
+                      pendingCallbacks.add(callbackEvent);
+                      callbackEventInPending = true;
-                    if (shouldPerformConcurrencyChecks(owner, cbEvent) && txEntryState != null) {
-                      txEntryState.setVersionTag(cbEvent.getVersionTag());
+                    if (shouldPerformConcurrencyChecks(owner, callbackEvent)
+                        && txEntryState != null) {
+                      txEntryState.setVersionTag(callbackEvent.getVersionTag());
-                    if (!cbEventInPending)
-                      cbEvent.release();
+                    if (!callbackEventInPending)
+                      callbackEvent.release();
-              boolean invokeCallbacks = shouldCreateCBEvent(owner, owner.isInitialized());
-              boolean cbEventInPending = false;
-              cbEvent =
-                  createCBEvent(owner, localOp ? Operation.LOCAL_INVALIDATE : Operation.INVALIDATE,
-                      key, newValue, txId, txEvent, eventId, aCallbackArgument, filterRoutingInfo,
-                      bridgeContext, txEntryState, versionTag, tailKey);
+              boolean invokeCallbacks = shouldCreateCallbackEvent(owner, owner.isInitialized());
+              boolean callbackEventInPending = false;
+              callbackEvent = createCallbackEvent(owner,
+                  localOp ? Operation.LOCAL_INVALIDATE : Operation.INVALIDATE, key, newValue, txId,
+                  txEvent, eventId, aCallbackArgument, filterRoutingInfo, bridgeContext,
+                  txEntryState, versionTag, tailKey);
-                cbEvent.setRegionEntry(newRe);
+                callbackEvent.setRegionEntry(newRe);
-                  processAndGenerateTXVersionTag(owner, cbEvent, newRe, txEntryState);
+                  processAndGenerateTXVersionTag(owner, callbackEvent, newRe, txEntryState);
-                  switchEventOwnerAndOriginRemote(cbEvent, hasRemoteOrigin);
-                  if (pendingCallbacks == null) {
-                    owner.invokeTXCallbacks(EnumListenerEvent.AFTER_INVALIDATE, cbEvent,
-                        true/* callDispatchListenerEvent */);
-                  } else {
-                    pendingCallbacks.add(cbEvent);
-                    cbEventInPending = true;
-                  }
+                  switchEventOwnerAndOriginRemote(callbackEvent, hasRemoteOrigin);
+                  pendingCallbacks.add(callbackEvent);
+                  callbackEventInPending = true;
-                if (shouldPerformConcurrencyChecks(owner, cbEvent) && txEntryState != null) {
-                  txEntryState.setVersionTag(cbEvent.getVersionTag());
+                if (shouldPerformConcurrencyChecks(owner, callbackEvent) && txEntryState != null) {
+                  txEntryState.setVersionTag(callbackEvent.getVersionTag());
-                if (!cbEventInPending)
-                  cbEvent.release();
+                if (!callbackEventInPending)
+                  callbackEvent.release();
-              boolean invokeCallbacks = shouldCreateCBEvent(owner, owner.isInitialized());
-              boolean cbEventInPending = false;
-              cbEvent =
-                  createCBEvent(owner, localOp ? Operation.LOCAL_INVALIDATE : Operation.INVALIDATE,
-                      key, newValue, txId, txEvent, eventId, aCallbackArgument, filterRoutingInfo,
-                      bridgeContext, txEntryState, versionTag, tailKey);
+              boolean invokeCallbacks = shouldCreateCallbackEvent(owner, owner.isInitialized());
+              boolean callbackEventInPending = false;
+              callbackEvent = createCallbackEvent(owner,
+                  localOp ? Operation.LOCAL_INVALIDATE : Operation.INVALIDATE, key, newValue, txId,
+                  txEvent, eventId, aCallbackArgument, filterRoutingInfo, bridgeContext,
+                  txEntryState, versionTag, tailKey);
-                cbEvent.setRegionEntry(re);
-                cbEvent.setOldValue(oldValue);
+                callbackEvent.setRegionEntry(re);
+                callbackEvent.setOldValue(oldValue);
-                processAndGenerateTXVersionTag(owner, cbEvent, re, txEntryState);
+                processAndGenerateTXVersionTag(owner, callbackEvent, re, txEntryState);
-                  switchEventOwnerAndOriginRemote(cbEvent, hasRemoteOrigin);
-                  if (pendingCallbacks == null) {
-                    owner.invokeTXCallbacks(EnumListenerEvent.AFTER_INVALIDATE, cbEvent,
-                        true/* callDispatchListenerEvent */);
-                  } else {
-                    pendingCallbacks.add(cbEvent);
-                    cbEventInPending = true;
-                  }
+                  switchEventOwnerAndOriginRemote(callbackEvent, hasRemoteOrigin);
+                  pendingCallbacks.add(callbackEvent);
+                  callbackEventInPending = true;
-                if (shouldPerformConcurrencyChecks(owner, cbEvent) && txEntryState != null) {
-                  txEntryState.setVersionTag(cbEvent.getVersionTag());
+                if (shouldPerformConcurrencyChecks(owner, callbackEvent) && txEntryState != null) {
+                  txEntryState.setVersionTag(callbackEvent.getVersionTag());
-                if (!cbEventInPending)
-                  cbEvent.release();
+                if (!callbackEventInPending)
+                  callbackEvent.release();
-          boolean cbEventInPending = false;
-          cbEvent =
-              createCBEvent(owner, localOp ? Operation.LOCAL_INVALIDATE : Operation.INVALIDATE, key,
-                  newValue, txId, txEvent, eventId, aCallbackArgument, filterRoutingInfo,
-                  bridgeContext, txEntryState, versionTag, tailKey);
+          boolean callbackEventInPending = false;
+          callbackEvent = createCallbackEvent(owner,
+              localOp ? Operation.LOCAL_INVALIDATE : Operation.INVALIDATE, key, newValue, txId,
+              txEvent, eventId, aCallbackArgument, filterRoutingInfo, bridgeContext, txEntryState,
+              versionTag, tailKey);
-            switchEventOwnerAndOriginRemote(cbEvent, hasRemoteOrigin);
-            if (pendingCallbacks == null) {
-              owner.invokeTXCallbacks(EnumListenerEvent.AFTER_INVALIDATE, cbEvent, false);
-            } else {
-              pendingCallbacks.add(cbEvent);
-              cbEventInPending = true;
-            }
+            switchEventOwnerAndOriginRemote(callbackEvent, hasRemoteOrigin);
+            pendingCallbacks.add(callbackEvent);
+            callbackEventInPending = true;
-            if (!cbEventInPending)
-              cbEvent.release();
+            if (!callbackEventInPending)
+              callbackEvent.release();
+    assert pendingCallbacks != null;
-    EntryEventImpl cbEvent = null;
-    boolean invokeCallbacks = shouldCreateCBEvent(owner, isRegionReady);
-    boolean cbEventInPending = false;
-    cbEvent = createCallBackEvent(owner, putOp, key, newValue, txId, txEvent, eventId,
-        aCallbackArgument, filterRoutingInfo, bridgeContext, txEntryState, versionTag, tailKey);
+    EntryEventImpl callbackEvent = null;
+    boolean invokeCallbacks = shouldCreateCallbackEvent(owner, isRegionReady);
+    boolean callbackEventInPending = false;
+    callbackEvent =
+        createTransactionCallbackEvent(owner, putOp, key, newValue, txId, txEvent, eventId,
+            aCallbackArgument, filterRoutingInfo, bridgeContext, txEntryState, versionTag, tailKey);
-        logger.debug("txApplyPut cbEvent={}", cbEvent);
+        logger.debug("txApplyPut callbackEvent={}", callbackEvent);
-        newValue = EntryEventImpl.getCachedDeserializable(nv, cbEvent);
-        txHandleWANEvent(owner, cbEvent, txEntryState);
+        newValue = EntryEventImpl.getCachedDeserializable(nv, callbackEvent);
+        txHandleWANEvent(owner, callbackEvent, txEntryState);
-            cbEventInPending = applyTxUpdateOnReplicateOrRedundantCopy(key, nv, didDestroy, txEvent,
-                aCallbackArgument, pendingCallbacks, txEntryState, owner, putOp, newValue,
-                hasRemoteOrigin, cbEvent, invokeCallbacks, cbEventInPending, opCompleted);
+            callbackEventInPending = applyTxUpdateOnReplicateOrRedundantCopy(key, nv, didDestroy,
+                txEvent, aCallbackArgument, pendingCallbacks, txEntryState, owner, putOp, newValue,
+                hasRemoteOrigin, callbackEvent, invokeCallbacks, opCompleted);
-                  if (cbEvent != null) {
-                    cbEvent.setRegionEntry(oldRe);
-                    cbEvent.setOldValue(oldRe.getValueInVM(owner)); // OFFHEAP eei
+                  if (callbackEvent != null) {
+                    callbackEvent.setRegionEntry(oldRe);
+                    callbackEvent.setOldValue(oldRe.getValueInVM(owner)); // OFFHEAP eei
-                      processAndGenerateTXVersionTag(owner, cbEvent, oldRe, txEntryState);
+                      processAndGenerateTXVersionTag(owner, callbackEvent, oldRe, txEntryState);
-                        oldRe.setValue(owner, oldRe.prepareValueForCache(owner, newValue, cbEvent,
-                            !putOp.isCreate()));
+                        oldRe.setValue(owner, oldRe.prepareValueForCache(owner, newValue,
+                            callbackEvent, !putOp.isCreate()));
-                      cbEvent.makeUpdate();
+                      callbackEvent.makeUpdate();
-                    switchEventOwnerAndOriginRemote(cbEvent, hasRemoteOrigin);
-                    if (pendingCallbacks == null) {
-                      owner.invokeTXCallbacks(
-                          cbEvent.op.isCreate() ? EnumListenerEvent.AFTER_CREATE
-                              : EnumListenerEvent.AFTER_UPDATE,
-                          cbEvent, true/* callDispatchListenerEvent */);
-                    } else {
-                      pendingCallbacks.add(cbEvent);
-                      cbEventInPending = true;
-                    }
+                    switchEventOwnerAndOriginRemote(callbackEvent, hasRemoteOrigin);
+                    pendingCallbacks.add(callbackEvent);
+                    callbackEventInPending = true;
-              if (cbEvent != null) {
-                cbEvent.setRegionEntry(newRe);
-                cbEvent.setOldValue(null);
+              if (callbackEvent != null) {
+                callbackEvent.setRegionEntry(newRe);
+                callbackEvent.setOldValue(null);
-                  processAndGenerateTXVersionTag(owner, cbEvent, newRe, txEntryState);
+                  processAndGenerateTXVersionTag(owner, callbackEvent, newRe, txEntryState);
-                    newRe.setValue(owner,
-                        newRe.prepareValueForCache(owner, newValue, cbEvent, !putOp.isCreate()));
+                    newRe.setValue(owner, newRe.prepareValueForCache(owner, newValue, callbackEvent,
+                        !putOp.isCreate()));
-                cbEvent.makeCreate();
-                cbEvent.setOldValue(null);
-                switchEventOwnerAndOriginRemote(cbEvent, hasRemoteOrigin);
-                if (pendingCallbacks == null) {
-                  owner.invokeTXCallbacks(EnumListenerEvent.AFTER_CREATE, cbEvent,
-                      true/* callDispatchListenerEvent */);
-                } else {
-                  pendingCallbacks.add(cbEvent);
-                  cbEventInPending = true;
-                }
+                callbackEvent.makeCreate();
+                callbackEvent.setOldValue(null);
+                switchEventOwnerAndOriginRemote(callbackEvent, hasRemoteOrigin);
+                pendingCallbacks.add(callbackEvent);
+                callbackEventInPending = true;
-        if (owner.getConcurrencyChecksEnabled() && txEntryState != null && cbEvent != null) {
-          txEntryState.setVersionTag(cbEvent.getVersionTag());
+        if (owner.getConcurrencyChecksEnabled() && txEntryState != null && callbackEvent != null) {
+          txEntryState.setVersionTag(callbackEvent.getVersionTag());
-      if (!cbEventInPending)
-        cbEvent.release();
+      if (!callbackEventInPending)
+        callbackEvent.release();
-      boolean hasRemoteOrigin, EntryEventImpl cbEvent, boolean invokeCallbacks,
-      boolean cbEventInPending, boolean opCompleted) {
+      boolean hasRemoteOrigin, EntryEventImpl callbackEvent, boolean invokeCallbacks,
+      boolean opCompleted) {
+    boolean result = false;
-          if (cbEvent != null) {
-            cbEvent.setRegionEntry(re);
-            cbEvent.setOldValue(re.getValueInVM(owner)); // OFFHEAP eei
+          if (callbackEvent != null) {
+            callbackEvent.setRegionEntry(re);
+            callbackEvent.setOldValue(re.getValueInVM(owner)); // OFFHEAP eei
-              processAndGenerateTXVersionTag(owner, cbEvent, re, txEntryState);
+              processAndGenerateTXVersionTag(owner, callbackEvent, re, txEntryState);
-                    re.prepareValueForCache(owner, newValue, cbEvent, !putOp.isCreate()));
+                    re.prepareValueForCache(owner, newValue, callbackEvent, !putOp.isCreate()));
-            cbEventInPending = prepareUpdateCallbacks(pendingCallbacks, owner, hasRemoteOrigin,
-                cbEvent, cbEventInPending);
+            prepareUpdateCallbacks(pendingCallbacks, owner, hasRemoteOrigin, callbackEvent);
+            result = true;
-      cbEvent.makeUpdate();
-      owner.invokeTXCallbacks(EnumListenerEvent.AFTER_UPDATE, cbEvent, false);
+      callbackEvent.makeUpdate();
+      owner.invokeTXCallbacks(EnumListenerEvent.AFTER_UPDATE, callbackEvent, false);
-    if (owner.getConcurrencyChecksEnabled() && txEntryState != null && cbEvent != null) {
-      txEntryState.setVersionTag(cbEvent.getVersionTag());
+    if (owner.getConcurrencyChecksEnabled() && txEntryState != null && callbackEvent != null) {
+      txEntryState.setVersionTag(callbackEvent.getVersionTag());
-    return cbEventInPending;
+    return result;
-  private boolean prepareUpdateCallbacks(List<EntryEventImpl> pendingCallbacks, LocalRegion owner,
-      boolean hasRemoteOrigin, EntryEventImpl cbEvent, boolean cbEventInPending) {
-    cbEvent.makeUpdate();
-    switchEventOwnerAndOriginRemote(cbEvent, hasRemoteOrigin);
-    if (pendingCallbacks == null) {
-      owner.invokeTXCallbacks(EnumListenerEvent.AFTER_UPDATE, cbEvent, hasRemoteOrigin);
-    } else {
-      pendingCallbacks.add(cbEvent);
-      cbEventInPending = true;
-    }
-    return cbEventInPending;
+  private void prepareUpdateCallbacks(List<EntryEventImpl> pendingCallbacks, LocalRegion owner,
+      boolean hasRemoteOrigin, EntryEventImpl callbackEvent) {
+    callbackEvent.makeUpdate();
+    switchEventOwnerAndOriginRemote(callbackEvent, hasRemoteOrigin);
+    pendingCallbacks.add(callbackEvent);
-  private void txHandleWANEvent(final LocalRegion owner, EntryEventImpl cbEvent,
+  private void txHandleWANEvent(final LocalRegion owner, EntryEventImpl callbackEvent,
-    ((BucketRegion) owner).handleWANEvent(cbEvent);
+    ((BucketRegion) owner).handleWANEvent(callbackEvent);
-      txEntryState.setTailKey(cbEvent.getTailKey());
+      txEntryState.setTailKey(callbackEvent.getTailKey());
-  private void processAndGenerateTXVersionTag(final LocalRegion owner, EntryEventImpl cbEvent,
+  private void processAndGenerateTXVersionTag(final LocalRegion owner, EntryEventImpl callbackEvent,
-    if (shouldPerformConcurrencyChecks(owner, cbEvent)) {
+    if (shouldPerformConcurrencyChecks(owner, callbackEvent)) {
-        processVersionTag(re, cbEvent);
+        processVersionTag(re, callbackEvent);
-      // in phase-1 commit into the cbEvent so that ARE.generateVersionTag can later
+      // in phase-1 commit into the callbackEvent so that ARE.generateVersionTag can later
-      if (cbEvent != null && txEntryState != null && txEntryState.getDistTxEntryStates() != null) {
-        cbEvent.setNextRegionVersion(txEntryState.getDistTxEntryStates().getRegionVersion());
+      if (callbackEvent != null && txEntryState != null
+          && txEntryState.getDistTxEntryStates() != null) {
+        callbackEvent.setNextRegionVersion(txEntryState.getDistTxEntryStates().getRegionVersion());
-      // cbEvent.setNextRegionVersion(txEntryState.getNextRegionVersion());
-      owner.generateAndSetVersionTag(cbEvent, re);
+      // callbackEvent.setNextRegionVersion(txEntryState.getNextRegionVersion());
+      owner.generateAndSetVersionTag(callbackEvent, re);
-   * Checks for concurrency checks enabled on Region and that cbEvent is not null.
+   * Checks for concurrency checks enabled on Region and that callbackEvent is not null.
-  private boolean shouldPerformConcurrencyChecks(LocalRegion owner, EntryEventImpl cbEvent) {
-    return owner.getConcurrencyChecksEnabled() && cbEvent != null;
+  private boolean shouldPerformConcurrencyChecks(LocalRegion owner, EntryEventImpl callbackEvent) {
+    return owner.getConcurrencyChecksEnabled() && callbackEvent != null;
-  static boolean shouldCreateCBEvent(final LocalRegion owner, final boolean isInitialized) {
+  static boolean shouldCreateCallbackEvent(final LocalRegion owner, final boolean isInitialized) {
-  EntryEventImpl createCallBackEvent(final LocalRegion re, Operation op, Object key,
+  EntryEventImpl createTransactionCallbackEvent(final LocalRegion re, Operation op, Object key,
-    return createCBEvent(re, op, key, newValue, txId, txEvent, eventId, aCallbackArgument,
+    return createCallbackEvent(re, op, key, newValue, txId, txEvent, eventId, aCallbackArgument,
-  public static EntryEventImpl createCBEvent(final LocalRegion re, Operation op, Object key,
+  public static EntryEventImpl createCallbackEvent(final LocalRegion re, Operation op, Object key,

UPD39 INS44 MOV44 MOV44 UPD42 MOV43 UPD42 UPD42 INS6 INS6 INS6 UPD42 INS60 MOV43 UPD42 MOV21 MOV43 INS42 UPD42 UPD42 INS27 INS27 INS27 INS39 INS59 UPD42 UPD66 INS42 INS33 UPD42 INS42 INS33 UPD42 INS42 INS33 UPD42 UPD42 UPD42 INS42 INS9 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD45 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV21 MOV21 UPD42 UPD42 UPD42 MOV21 MOV21 UPD42 UPD42 INS21 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS32 INS7 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 MOV42 MOV42 MOV42 UPD42 MOV42 INS42 INS9 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV21 MOV21 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV21 MOV21 UPD42 UPD42 UPD42 UPD42 UPD42 MOV21 MOV21 UPD42 UPD42 UPD42 UPD42 MOV21 MOV21 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV21 MOV21 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD45 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV21 MOV21 UPD42 UPD42 UPD45 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV21 MOV21 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD45 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV21 MOV21 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD45 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 DEL42 DEL33 DEL27 DEL42 DEL42 DEL40 DEL42 DEL9 DEL32 DEL21 DEL8 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL40 DEL42 DEL42 DEL32 DEL21 DEL8 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL40 DEL42 DEL42 DEL32 DEL21 DEL8 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL40 DEL42 DEL9 DEL32 DEL21 DEL8 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL40 DEL42 DEL9 DEL32 DEL21 DEL8 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL40 DEL42 DEL9 DEL32 DEL21 DEL8 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL40 DEL42 DEL9 DEL32 DEL21 DEL8 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL40 DEL42 DEL9 DEL32 DEL21 DEL8 DEL8 DEL25 DEL42 DEL42 DEL33 DEL27 DEL42 DEL42 DEL40 DEL42 DEL32 DEL40 DEL40 DEL16 DEL42 DEL9 DEL32 DEL21 DEL8 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL40 DEL42 DEL9 DEL32 DEL21 DEL8 DEL8 DEL25 DEL39 DEL42 DEL44 DEL42 DEL42 DEL32 DEL7 DEL39 DEL42 DEL33 DEL27 DEL42 DEL42 DEL40 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL42 DEL41 DEL42 DEL44 DEL42 DEL44
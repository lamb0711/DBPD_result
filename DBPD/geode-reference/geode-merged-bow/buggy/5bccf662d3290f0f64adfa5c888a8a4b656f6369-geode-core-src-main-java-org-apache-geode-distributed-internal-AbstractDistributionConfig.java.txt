GEODE-5686: Remove LocalizedStrings

This removes the LocalizedStrings class and most uses of LogWriterI18n.
The I18n interfaces are still in place and still work since they're only
deprecated but there are no longer any uses of the StringID logging methods.

Going forward everyone should use the Log4j logging facility.  If you
must use the deprecated LogWriter use that version and not
LogWriterI18n.

-import org.apache.geode.internal.i18n.LocalizedStrings;
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_LESS_THAN_2
-              .toLocalizedString(
-                  propName, value, minValue));
+          String.format(
+              "Could not set \"%s\" to \"%s\" because its value can not be less than \"%s\".",
+
+              propName, value, minValue));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_GREATER_THAN_2
-              .toLocalizedString(
-                  propName, value, maxValue));
+          String.format(
+              "Could not set \"%s\" to \"%s\" because its value can not be greater than \"%s\".",
+              propName, value, maxValue));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_MUST_BE_0_WHEN_2_IS_TRUE
-              .toLocalizedString(
-                  TCP_PORT, value, CLUSTER_SSL_ENABLED));
+          String.format("Could not set %s to %s because its value must be 0 when %s is true.",
+              TCP_PORT, value, CLUSTER_SSL_ENABLED));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_MUST_BE_0_WHEN_2_IS_TRUE
-              .toLocalizedString(
-                  MCAST_PORT, value, CLUSTER_SSL_ENABLED));
+          String.format("Could not set %s to %s because its value must be 0 when %s is true.",
+              MCAST_PORT, value, CLUSTER_SSL_ENABLED));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_IT_WAS_NOT_A_MULTICAST_ADDRESS
-              .toLocalizedString(MCAST_ADDRESS, value));
+          String.format("Could not set %s to %s because it was not a multicast address.",
+              MCAST_ADDRESS, value));
-          LocalizedStrings.AbstractDistributionConfig_BIND_ADDRESS_0_INVALID_MUST_BE_IN_1
-              .toLocalizedString(value, SocketCreator.getMyAddresses()));
+          String.format(
+              "The bind-address %s is not a valid address for this machine.  These are the valid addresses for this machine: %s",
+              value, SocketCreator.getMyAddresses()));
-          LocalizedStrings.AbstractDistributionConfig_BIND_ADDRESS_0_INVALID_MUST_BE_IN_1
-              .toLocalizedString(value, SocketCreator.getMyAddresses()));
+          String.format(
+              "The bind-address %s is not a valid address for this machine.  These are the valid addresses for this machine: %s",
+              value, SocketCreator.getMyAddresses()));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_MUST_BE_FALSE_WHEN_2_IS_NOT_0
-              .toLocalizedString(CLUSTER_SSL_ENABLED, value, MCAST_PORT));
+          String.format("Could not set %s to %s because its value must be false when %s is not 0.",
+              CLUSTER_SSL_ENABLED, value, MCAST_PORT));
-          LocalizedStrings.AbstractDistributionConfig_BIND_ADDRESS_0_INVALID_MUST_BE_IN_1
-              .toLocalizedString(value, SocketCreator.getMyAddresses()));
+          String.format(
+              "The bind-address %s is not a valid address for this machine.  These are the valid addresses for this machine: %s",
+              value, SocketCreator.getMyAddresses()));
-            LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_LESS_THAN_2
-                .toLocalizedString(DISTRIBUTED_SYSTEM_ID, value,
-                    MIN_DISTRIBUTED_SYSTEM_ID));
+            String.format(
+                "Could not set \"%s\" to \"%s\" because its value can not be less than \"%s\".",
+                DISTRIBUTED_SYSTEM_ID, value,
+                MIN_DISTRIBUTED_SYSTEM_ID));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_GREATER_THAN_2
-              .toLocalizedString(DISTRIBUTED_SYSTEM_ID, value,
-                  MAX_DISTRIBUTED_SYSTEM_ID));
+          String.format(
+              "Could not set \"%s\" to \"%s\" because its value can not be greater than \"%s\".",
+              DISTRIBUTED_SYSTEM_ID, value,
+              MAX_DISTRIBUTED_SYSTEM_ID));
-            LocalizedStrings.AbstractDistributionConfig_INVALID_LOCATOR_0_HOST_NAME_WAS_EMPTY
-                .toLocalizedString(value));
+            String.format("Invalid locator %s. Host name was empty.",
+                value));
-              LocalizedStrings.AbstractDistributionConfig_UNKNOWN_LOCATOR_BIND_ADDRESS_0
-                  .toLocalizedString(bindAddr));
+              String.format("Unknown locator bind address:  %s",
+                  bindAddr));
-              LocalizedStrings.AbstractDistributionConfig_INVALID_LOCATOR_0
-                  .toLocalizedString(value));
+              String.format("Invalid locator:  %s",
+                  value));
-              LocalizedStrings.AbstractDistributionConfig_INVALID_LOCATOR_0_THE_PORT_1_WAS_NOT_GREATER_THAN_ZERO_AND_LESS_THAN_65536
-                  .toLocalizedString(value, portVal));
+              String.format(
+                  "Invalid locator %s. The port %s was not greater than zero and less than 65,536.",
+                  value, portVal));
-            LocalizedStrings.AbstractDistributionConfig_INVALID_LOCATOR_0.toLocalizedString(value));
+            String.format("Invalid locator:  %s", value));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_BYTEALLOWANCE_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_LESS_THAN_2
-              .toLocalizedString(MCAST_FLOW_CONTROL, value,
-                  MIN_FC_BYTE_ALLOWANCE));
+          String.format(
+              "Could not set %s.byteAllowance to %s because its value can not be less than %s",
+              MCAST_FLOW_CONTROL, value,
+              MIN_FC_BYTE_ALLOWANCE));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_RECHARGETHRESHOLD_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_LESS_THAN_2
-              .toLocalizedString(MCAST_FLOW_CONTROL, fvalue,
-                  MIN_FC_RECHARGE_THRESHOLD));
+          String.format(
+              "Could not set %s.rechargeThreshold to %s because its value can not be less than %s",
+              MCAST_FLOW_CONTROL, fvalue,
+              MIN_FC_RECHARGE_THRESHOLD));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_RECHARGETHRESHOLD_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_GREATER_THAN_2
-              .toLocalizedString(MCAST_FLOW_CONTROL, fvalue,
-                  MAX_FC_RECHARGE_THRESHOLD));
+          String.format(
+              "Could not set %s.rechargeThreshold to %s because its value can not be greater than %s",
+              MCAST_FLOW_CONTROL, fvalue,
+              MAX_FC_RECHARGE_THRESHOLD));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_RECHARGEBLOCKMS_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_LESS_THAN_2
-              .toLocalizedString(MCAST_FLOW_CONTROL, value,
-                  MIN_FC_RECHARGE_BLOCK_MS));
+          String.format(
+              "Could not set %s.rechargeBlockMs to %s because its value can not be less than %s",
+              MCAST_FLOW_CONTROL, value,
+              MIN_FC_RECHARGE_BLOCK_MS));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_RECHARGEBLOCKMS_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_GREATER_THAN_2
-              .toLocalizedString(MCAST_FLOW_CONTROL, value,
-                  MAX_FC_RECHARGE_BLOCK_MS));
+          String.format(
+              "Could not set %s.rechargeBlockMs to %s because its value can not be greater than %s",
+              MCAST_FLOW_CONTROL, value,
+              MAX_FC_RECHARGE_BLOCK_MS));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_LESS_THAN_2
-              .toLocalizedString(MEMBERSHIP_PORT_RANGE, value[0] + "-" + value[1],
-                  3));
+          String.format(
+              "Could not set \"%s\" to \"%s\" because its value can not be less than \"%s\".",
+              MEMBERSHIP_PORT_RANGE, value[0] + "-" + value[1],
+              3));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_2_MUST_BE_0_WHEN_SECURITY_IS_ENABLED
-              .toLocalizedString(SECURITY_PEER_AUTH_INIT, value, mcastInfo));
+          String.format("Could not set %s to %s because %s must be 0 when security is enabled.",
+              SECURITY_PEER_AUTH_INIT, value, mcastInfo));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_2_MUST_BE_0_WHEN_SECURITY_IS_ENABLED
-              .toLocalizedString(SECURITY_PEER_AUTHENTICATOR, value, mcastInfo));
+          String.format("Could not set %s to %s because %s must be 0 when security is enabled.",
+              SECURITY_PEER_AUTHENTICATOR, value, mcastInfo));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_LESS_THAN_2
-              .toLocalizedString(SECURITY_LOG_LEVEL,
-                  LogWriterImpl.levelToString(value), LogWriterImpl.levelToString(MIN_LOG_LEVEL)));
+          String.format(
+              "Could not set \"%s\" to \"%s\" because its value can not be less than \"%s\".",
+              SECURITY_LOG_LEVEL,
+              LogWriterImpl.levelToString(value), LogWriterImpl.levelToString(MIN_LOG_LEVEL)));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_GREATER_THAN_2
-              .toLocalizedString(SECURITY_LOG_LEVEL,
-                  LogWriterImpl.levelToString(value), LogWriterImpl.levelToString(MAX_LOG_LEVEL)));
+          String.format(
+              "Could not set \"%s\" to \"%s\" because its value can not be greater than \"%s\".",
+              SECURITY_LOG_LEVEL,
+              LogWriterImpl.levelToString(value), LogWriterImpl.levelToString(MAX_LOG_LEVEL)));
-          LocalizedStrings.AbstractDistributionConfig_MEMCACHED_PROTOCOL_MUST_BE_ASCII_OR_BINARY
-              .toLocalizedString());
+          "memcached-protocol must be ASCII or BINARY ");
-          LocalizedStrings.AbstractDistributionConfig_MEMCACHED_BIND_ADDRESS_0_INVALID_MUST_BE_IN_1
-              .toLocalizedString(value, SocketCreator.getMyAddresses()));
+          String.format(
+              "The memcached-bind-address %s is not a valid address for this machine.  These are the valid addresses for this machine: %s",
+              value, SocketCreator.getMyAddresses()));
-          LocalizedStrings.AbstractDistributionConfig_REDIS_BIND_ADDRESS_0_INVALID_MUST_BE_IN_1
-              .toLocalizedString(value, SocketCreator.getMyAddresses()));
+          String.format(
+              "The redis-bind-address %s is not a valid address for this machine.  These are the valid addresses for this machine: %s",
+              value, SocketCreator.getMyAddresses()));
-              LocalizedStrings.AbstractDistributionConfig_SSL_ENABLED_COMPONENTS_0_INVALID_TRY_1
-                  .toLocalizedString(value,
-                      StringUtils
-                          .join(new String[] {SecurableCommunicationChannel.ALL.getConstant(),
-                              SecurableCommunicationChannel.CLUSTER.getConstant(),
-                              SecurableCommunicationChannel.SERVER.getConstant(),
-                              SecurableCommunicationChannel.GATEWAY.getConstant(),
-                              SecurableCommunicationChannel.JMX.getConstant(),
-                              SecurableCommunicationChannel.WEB.getConstant(),
-                              SecurableCommunicationChannel.LOCATOR.getConstant()}, ",")));
+              String.format("%s is not in the valid set of options %s",
+                  value,
+                  StringUtils
+                      .join(new String[] {SecurableCommunicationChannel.ALL.getConstant(),
+                          SecurableCommunicationChannel.CLUSTER.getConstant(),
+                          SecurableCommunicationChannel.SERVER.getConstant(),
+                          SecurableCommunicationChannel.GATEWAY.getConstant(),
+                          SecurableCommunicationChannel.JMX.getConstant(),
+                          SecurableCommunicationChannel.WEB.getConstant(),
+                          SecurableCommunicationChannel.LOCATOR.getConstant()}, ",")));
-            LocalizedStrings.AbstractDistributionConfig_SSL_ENABLED_COMPONENTS_SET_INVALID_DEPRECATED_SSL_SET
-                .toLocalizedString());
+            "When using ssl-enabled-components one cannot use any other SSL properties other than cluster-ssl-* or the corresponding aliases");
-            LocalizedStrings.AbstractDistributionConfig_0_VALUE_1_MUST_BE_OF_TYPE_2
-                .toLocalizedString(attName, attValue, validValueClass.getName()));
+            String.format("%s  value %s must be of type  %s",
+                attName, attValue, validValueClass.getName()));
-          LocalizedStrings.AbstractDistributionConfig_UNHANDLED_ATTRIBUTE_NAME_0
-              .toLocalizedString(attName));
+          String.format("unhandled attribute name %s.",
+              attName));
-          LocalizedStrings.AbstractDistributionConfig_UNHANDLED_ATTRIBUTE_NAME_0
-              .toLocalizedString(attName));
+          String.format("unhandled attribute name %s.",
+              attName));
-          LocalizedStrings.AbstractDistributionConfig_UNHANDLED_ATTRIBUTE_NAME_0
-              .toLocalizedString(attName));
+          String.format("unhandled attribute name %s.",
+              attName));
-        LocalizedStrings.AbstractDistributionConfig_DEFAULT_ACK_WAIT_THRESHOLD_0_1_2
-            .toLocalizedString(DEFAULT_ACK_WAIT_THRESHOLD,
-                MIN_ACK_WAIT_THRESHOLD, MIN_ACK_WAIT_THRESHOLD));
+        String.format(
+            "The number of seconds a distributed message can wait for acknowledgment before it sends an alert to signal that something might be wrong with the system node that is unresponsive. After sending this alert the waiter continues to wait. The alerts are logged in the system log as warnings and if a gfc is running will cause a console alert to be signalled.  Defaults to %s.  Legal values are in the range [%s..%s].",
+            DEFAULT_ACK_WAIT_THRESHOLD,
+            MIN_ACK_WAIT_THRESHOLD, MIN_ACK_WAIT_THRESHOLD));
-        LocalizedStrings.AbstractDistributionConfig_ARCHIVE_FILE_SIZE_LIMIT_NAME
-            .toLocalizedString());
+        "The maximum size in megabytes of a statistic archive file. Once this limit is exceeded, a new statistic archive file is created, and the current archive file becomes inactive. If set to zero, file size is unlimited.");
-        LocalizedStrings.AbstractDistributionConfig_ACK_SEVERE_ALERT_THRESHOLD_NAME
-            .toLocalizedString(ACK_WAIT_THRESHOLD,
-                DEFAULT_ACK_SEVERE_ALERT_THRESHOLD,
-                MIN_ACK_SEVERE_ALERT_THRESHOLD,
-                MAX_ACK_SEVERE_ALERT_THRESHOLD));
+        String.format(
+            "The number of seconds a distributed message can wait for acknowledgment past %s before it ejects unresponsive members from the distributed system.  Defaults to %s.  Legal values are in the range [%s..%s].",
+            ACK_WAIT_THRESHOLD,
+            DEFAULT_ACK_SEVERE_ALERT_THRESHOLD,
+            MIN_ACK_SEVERE_ALERT_THRESHOLD,
+            MAX_ACK_SEVERE_ALERT_THRESHOLD));
-        LocalizedStrings.AbstractDistributionConfig_ARCHIVE_DISK_SPACE_LIMIT_NAME
-            .toLocalizedString());
+        "The maximum size in megabytes of all inactive statistic archive files combined. If this limit is exceeded, inactive archive files will be deleted, oldest first, until the total size is within the limit. If set to zero, disk space usage is unlimited.");
-    m.put(CACHE_XML_FILE, LocalizedStrings.AbstractDistributionConfig_CACHE_XML_FILE_NAME_0
-        .toLocalizedString(DEFAULT_CACHE_XML_FILE));
+    m.put(CACHE_XML_FILE, String.format(
+        "The file whose contents is used, by default, to initialize a cache if one is created.  Defaults to %s.",
+        DEFAULT_CACHE_XML_FILE));
-    m.put(DISABLE_TCP, LocalizedStrings.AbstractDistributionConfig_DISABLE_TCP_NAME_0
-        .toLocalizedString(Boolean.FALSE));
+    m.put(DISABLE_TCP, String.format(
+        "Determines whether TCP/IP communications will be disabled, forcing use of datagrams between members of the distributed system. Defaults to %s",
+        Boolean.FALSE));
-        LocalizedStrings.AbstractDistributionConfig_ENABLE_TIME_STATISTICS_NAME
-            .toLocalizedString());
+        "Turns on timings in distribution and cache statistics.  These are normally turned off to avoid expensive clock probes.");
-    m.put(DEPLOY_WORKING_DIR, LocalizedStrings.AbstractDistributionConfig_DEPLOY_WORKING_DIR_0
-        .toLocalizedString(DEFAULT_DEPLOY_WORKING_DIR));
+    m.put(DEPLOY_WORKING_DIR, String.format(
+        "The working directory that can be used to persist JARs deployed during runtime. Defaults to %s.",
+        DEFAULT_DEPLOY_WORKING_DIR));
-    m.put(LOG_FILE, LocalizedStrings.AbstractDistributionConfig_LOG_FILE_NAME_0
-        .toLocalizedString(DEFAULT_LOG_FILE));
+    m.put(LOG_FILE,
+        String.format("The file a running system will write log messages to.  Defaults to %s.",
+            DEFAULT_LOG_FILE));
-        LocalizedStrings.AbstractDistributionConfig_LOG_LEVEL_NAME_0_1
-            .toLocalizedString(LogWriterImpl.levelToString(DEFAULT_LOG_LEVEL),
-                LogWriterImpl.allowedLogLevels()));
+        String.format(
+            "Controls the type of messages that will actually be written to the system log.  Defaults to %s.  Allowed values %s.",
+            LogWriterImpl.levelToString(DEFAULT_LOG_LEVEL),
+            LogWriterImpl.allowedLogLevels()));
-        LocalizedStrings.AbstractDistributionConfig_LOG_FILE_SIZE_LIMIT_NAME.toLocalizedString());
+        "The maximum size in megabytes of a child log file. Once this limit is exceeded, a new child log is created, and the current child log becomes inactive. If set to zero, child logging is disabled.");
-        LocalizedStrings.AbstractDistributionConfig_LOG_DISK_SPACE_LIMIT_NAME.toLocalizedString());
+        "The maximum size in megabytes of all inactive log files combined. If this limit is exceeded, inactive log files will be deleted, oldest first, until the total size is within the limit. If set to zero, disk space usage is unlimited.");
-    m.put(LOCATORS, LocalizedStrings.AbstractDistributionConfig_LOCATORS_NAME_0
-        .toLocalizedString(DEFAULT_LOCATORS));
+    m.put(LOCATORS, String.format(
+        "A possibly empty list of locators used to find other system nodes. Each element of the list must be a host name followed by bracketed, [], port number. Host names may be followed by a colon and a bind address used by the locator on that host.  Multiple elements must be comma separated. Defaults to %s.",
+        DEFAULT_LOCATORS));
-    m.put(LOCATOR_WAIT_TIME, LocalizedStrings.AbstractDistributionConfig_LOCATOR_WAIT_TIME_NAME_0
-        .toLocalizedString(DEFAULT_LOCATOR_WAIT_TIME));
+    m.put(LOCATOR_WAIT_TIME, String.format(
+        "The amount of time, in seconds, to wait for a locator to be available before throwing an exception during startup.  The default is %s.",
+        DEFAULT_LOCATOR_WAIT_TIME));
-        LocalizedStrings.AbstractDistributionConfig_TCP_PORT_NAME_0_1_2
-            .toLocalizedString(DEFAULT_TCP_PORT,
-                MIN_TCP_PORT, MAX_TCP_PORT));
+        String.format(
+            "The port used for tcp/ip communcations in the distributed system. If zero then a random available port is selected by the operating system.   Defaults to %s.  Legal values are in the range [%s..%s].",
+            DEFAULT_TCP_PORT,
+            MIN_TCP_PORT, MAX_TCP_PORT));
-        LocalizedStrings.AbstractDistributionConfig_MCAST_PORT_NAME_0_1_2
-            .toLocalizedString(DEFAULT_MCAST_PORT,
-                MIN_MCAST_PORT, MAX_MCAST_PORT));
+        String.format(
+            "The port used for multicast communcations in the distributed system. If zero then locators are used, and multicast is disabled.   Defaults to %s.  Legal values are in the range [%s..%s].",
+            DEFAULT_MCAST_PORT,
+            MIN_MCAST_PORT, MAX_MCAST_PORT));
-        LocalizedStrings.AbstractDistributionConfig_MCAST_ADDRESS_NAME_0_1.toLocalizedString(
+        String.format(
+            "The address used for multicast communications. Only used if %s is non-zero.  Defaults to %s.",
-        LocalizedStrings.AbstractDistributionConfig_MCAST_TTL_NAME_0_1_2
-            .toLocalizedString(DEFAULT_MCAST_TTL,
-                MIN_MCAST_TTL, MAX_MCAST_TTL));
+        String.format(
+            "Determines how far through your network mulicast packets will propogate. Defaults to %s.  Legal values are in the range [%s..%s].",
+            DEFAULT_MCAST_TTL,
+            MIN_MCAST_TTL, MAX_MCAST_TTL));
-        LocalizedStrings.AbstractDistributionConfig_MCAST_SEND_BUFFER_SIZE_NAME_0
-            .toLocalizedString(DEFAULT_MCAST_SEND_BUFFER_SIZE));
+        String.format(
+            "Sets the size of multicast socket transmission buffers, in bytes.  Defaults to %s but this may be limited by operating system settings",
+            DEFAULT_MCAST_SEND_BUFFER_SIZE));
-        LocalizedStrings.AbstractDistributionConfig_MCAST_RECV_BUFFER_SIZE_NAME_0
-            .toLocalizedString(DEFAULT_MCAST_RECV_BUFFER_SIZE));
+        String.format(
+            "Sets the size of multicast socket receive buffers, in bytes.  Defaults to %s but this may be limited by operating system settings",
+            DEFAULT_MCAST_RECV_BUFFER_SIZE));
-    m.put(MCAST_FLOW_CONTROL, LocalizedStrings.AbstractDistributionConfig_MCAST_FLOW_CONTROL_NAME_0
-        .toLocalizedString(DEFAULT_MCAST_FLOW_CONTROL));
+    m.put(MCAST_FLOW_CONTROL, String.format(
+        "Sets the flow-of-control parameters for multicast messaging.  Defaults to %s.",
+        DEFAULT_MCAST_FLOW_CONTROL));
-    m.put(MEMBER_TIMEOUT, LocalizedStrings.AbstractDistributionConfig_MEMBER_TIMEOUT_NAME_0
-        .toLocalizedString(DEFAULT_MEMBER_TIMEOUT));
+    m.put(MEMBER_TIMEOUT, String.format(
+        "Sets the number of milliseconds to wait for ping responses when determining whether another member is still alive. Defaults to %s.",
+        DEFAULT_MEMBER_TIMEOUT));
-    String msg = LocalizedStrings.AbstractDistributionConfig_MEMBERSHIP_PORT_RANGE_NAME_0
-        .toLocalizedString(srange);
+    String msg = String.format(
+        "Sets the range of datagram socket ports that can be used for membership ID purposes and unicast datagram messaging. Defaults to %s.",
+        srange);
-        LocalizedStrings.AbstractDistributionConfig_UDP_SEND_BUFFER_SIZE_NAME_0
-            .toLocalizedString(DEFAULT_UDP_SEND_BUFFER_SIZE));
+        String.format(
+            "Sets the size of datagram socket transmission buffers, in bytes.  Defaults to %s but this may be limited by operating system settings",
+            DEFAULT_UDP_SEND_BUFFER_SIZE));
-        LocalizedStrings.AbstractDistributionConfig_UDP_RECV_BUFFER_SIZE_NAME_0
-            .toLocalizedString(DEFAULT_UDP_RECV_BUFFER_SIZE));
+        String.format(
+            "Sets the size of datagram socket receive buffers, in bytes. Defaults to %s but this may be limited by operating system settings",
+            DEFAULT_UDP_RECV_BUFFER_SIZE));
-    m.put(UDP_FRAGMENT_SIZE, LocalizedStrings.AbstractDistributionConfig_UDP_FRAGMENT_SIZE_NAME_0
-        .toLocalizedString(DEFAULT_UDP_FRAGMENT_SIZE));
+    m.put(UDP_FRAGMENT_SIZE, String.format(
+        "Sets the maximum size of a datagram for UDP and multicast transmission.  Defaults to %s.",
+        DEFAULT_UDP_FRAGMENT_SIZE));
-        LocalizedStrings.AbstractDistributionConfig_SOCKET_LEASE_TIME_NAME_0_1_2
-            .toLocalizedString(DEFAULT_SOCKET_LEASE_TIME,
-                MIN_SOCKET_LEASE_TIME, MAX_SOCKET_LEASE_TIME));
+        String.format(
+            "The number of milliseconds a thread can keep exclusive access to a socket that it is not actively using. Once a thread loses its lease to a socket it will need to re-acquire a socket the next time it sends a message. A value of zero causes socket leases to never expire. Defaults to %s .  Legal values are in the range [%s..%s].",
+            DEFAULT_SOCKET_LEASE_TIME,
+            MIN_SOCKET_LEASE_TIME, MAX_SOCKET_LEASE_TIME));
-        LocalizedStrings.AbstractDistributionConfig_SOCKET_BUFFER_SIZE_NAME_0_1_2
-            .toLocalizedString(DEFAULT_SOCKET_BUFFER_SIZE,
-                MIN_SOCKET_BUFFER_SIZE, MAX_SOCKET_BUFFER_SIZE));
+        String.format(
+            "The size of each socket buffer, in bytes. Smaller buffers conserve memory. Larger buffers can improve performance; in particular if large messages are being sent. Defaults to %s.  Legal values are in the range [%s..%s].",
+            DEFAULT_SOCKET_BUFFER_SIZE,
+            MIN_SOCKET_BUFFER_SIZE, MAX_SOCKET_BUFFER_SIZE));
-    m.put(CONSERVE_SOCKETS, LocalizedStrings.AbstractDistributionConfig_CONSERVE_SOCKETS_NAME_0
-        .toLocalizedString(Boolean.TRUE));
+    m.put(CONSERVE_SOCKETS, String.format(
+        "If true then a minimal number of sockets will be used when connecting to the distributed system. This conserves resource usage but can cause performance to suffer. If false, the default, then every application thread that sends distribution messages to other members of the distributed system will own its own sockets and have exclusive access to them. Defaults to %s.",
+        DEFAULT_CONSERVE_SOCKETS));
-        LocalizedStrings.AbstractDistributionConfig_ROLES_NAME_0.toLocalizedString(DEFAULT_ROLES));
+        String.format(
+            "The application roles that this member performs in the distributed system. This is a comma delimited list of user-defined strings. Any number of members can be configured to perform the same role, and a member can be configured to perform any number of roles. Defaults to %s.",
+            DEFAULT_ROLES));
-    m.put(BIND_ADDRESS, LocalizedStrings.AbstractDistributionConfig_BIND_ADDRESS_NAME_0
-        .toLocalizedString(DEFAULT_BIND_ADDRESS));
+    m.put(BIND_ADDRESS, String.format(
+        "The address server sockets will listen on. An empty string causes the server socket to listen on all local addresses. Defaults to %s.",
+        DEFAULT_BIND_ADDRESS));
-        LocalizedStrings.AbstractDistributionConfig_SERVER_BIND_ADDRESS_NAME_0
-            .toLocalizedString(DEFAULT_BIND_ADDRESS));
+        String.format(
+            "The address server sockets in a client-server topology will listen on. An empty string causes the server socket to listen on all local addresses. Defaults to %s.",
+            DEFAULT_BIND_ADDRESS));
-        LocalizedStrings.AbstractDistributionConfig_STATISTIC_ARCHIVE_FILE_NAME_0
-            .toLocalizedString(DEFAULT_STATISTIC_ARCHIVE_FILE));
+        String.format("The file a running system will write statistic samples to.  Defaults to %s.",
+            DEFAULT_STATISTIC_ARCHIVE_FILE));
-        LocalizedStrings.AbstractDistributionConfig_STATISTIC_SAMPLE_RATE_NAME_0_1_2
-            .toLocalizedString(DEFAULT_STATISTIC_SAMPLE_RATE,
-                MIN_STATISTIC_SAMPLE_RATE,
-                MAX_STATISTIC_SAMPLE_RATE));
+        String.format(
+            "The rate, in milliseconds, that a running system will sample statistics.  Defaults to %s.  Legal values are in the range [%s..%s].",
+            DEFAULT_STATISTIC_SAMPLE_RATE,
+            MIN_STATISTIC_SAMPLE_RATE,
+            MAX_STATISTIC_SAMPLE_RATE));
-        LocalizedStrings.AbstractDistributionConfig_STATISTIC_SAMPLING_ENABLED_NAME_0
-            .toLocalizedString(Boolean.TRUE));
+        String.format(
+            "If false then archiving is disabled and operating system statistics are no longer updated.  Defaults to %s.",
+            Boolean.TRUE));
-    m.put(SSL_CLUSTER_ALIAS, LocalizedStrings.AbstractDistributionConfig_CLUSTER_SSL_ALIAS_0
-        .toLocalizedString(Boolean.valueOf(DEFAULT_SSL_ALIAS)));
+    m.put(SSL_CLUSTER_ALIAS, String.format(
+        "SSL communication uses the this alias when determining the key to use from the keystore for SSL. Defaults to %s.",
+        Boolean.valueOf(DEFAULT_SSL_ALIAS)));
-    m.put(CLUSTER_SSL_ENABLED, LocalizedStrings.AbstractDistributionConfig_SSL_ENABLED_NAME_0
-        .toLocalizedString(Boolean.FALSE));
+    m.put(CLUSTER_SSL_ENABLED, String.format(
+        "Communication is performed through SSL when this property is set to true. Defaults to %s.",
+        Boolean.FALSE));
-    m.put(CLUSTER_SSL_PROTOCOLS, LocalizedStrings.AbstractDistributionConfig_SSL_PROTOCOLS_NAME_0
-        .toLocalizedString(DEFAULT_SSL_PROTOCOLS));
+    m.put(CLUSTER_SSL_PROTOCOLS, String.format(
+        "List of available SSL protocols that are to be enabled. Defaults to %s meaning your provider's defaults.",
+        DEFAULT_SSL_PROTOCOLS));
-    m.put(CLUSTER_SSL_CIPHERS, LocalizedStrings.AbstractDistributionConfig_SSL_CIPHERS_NAME_0
-        .toLocalizedString(DEFAULT_SSL_CIPHERS));
+    m.put(CLUSTER_SSL_CIPHERS, String.format(
+        "List of available SSL cipher suites that are to be enabled. Defaults to %s meaning your provider's defaults.",
+        DEFAULT_SSL_CIPHERS));
-        LocalizedStrings.AbstractDistributionConfig_SSL_REQUIRE_AUTHENTICATION_NAME
-            .toLocalizedString(Boolean.TRUE));
+        String.format(
+            "if set to false, ciphers and protocols that permit anonymous peers are allowed. Defaults to %s.",
+            Boolean.TRUE));
-        LocalizedStrings.AbstractDistributionConfig_MAX_WAIT_TIME_FOR_RECONNECT
-            .toLocalizedString());
+        "Specifies the maximum time to wait before trying to reconnect to distributed system in the case of required role loss.");
-        LocalizedStrings.AbstractDistributionConfig_MAX_NUM_RECONNECT_TRIES.toLocalizedString());
+        "Maximum number of tries before shutting the member down in the case of required role loss.");
-        LocalizedStrings.AbstractDistributionConfig_ASYNC_DISTRIBUTION_TIMEOUT_NAME_0_1_2
-            .toLocalizedString(DEFAULT_ASYNC_DISTRIBUTION_TIMEOUT,
-                MIN_ASYNC_DISTRIBUTION_TIMEOUT,
-                MAX_ASYNC_DISTRIBUTION_TIMEOUT));
+        String.format(
+            "The number of milliseconds before a publishing process should attempt to distribute a cache operation before switching over to asynchronous messaging for this process. Defaults to %s. Legal values are in the range [%s..%s].",
+            DEFAULT_ASYNC_DISTRIBUTION_TIMEOUT,
+            MIN_ASYNC_DISTRIBUTION_TIMEOUT,
+            MAX_ASYNC_DISTRIBUTION_TIMEOUT));
-        LocalizedStrings.AbstractDistributionConfig_ASYNC_QUEUE_TIMEOUT_NAME_0_1_2
-            .toLocalizedString(DEFAULT_ASYNC_QUEUE_TIMEOUT,
-                MIN_ASYNC_QUEUE_TIMEOUT,
-                MAX_ASYNC_QUEUE_TIMEOUT));
+        String.format(
+            "The number of milliseconds a queuing may enqueue asynchronous messages without any distribution to this process before that publisher requests this process to depart. Defaults to %s Legal values are in the range [%s..%s].",
+            DEFAULT_ASYNC_QUEUE_TIMEOUT,
+            MIN_ASYNC_QUEUE_TIMEOUT,
+            MAX_ASYNC_QUEUE_TIMEOUT));
-        LocalizedStrings.AbstractDistributionConfig_ASYNC_MAX_QUEUE_SIZE_NAME_0_1_2
-            .toLocalizedString(DEFAULT_ASYNC_MAX_QUEUE_SIZE,
-                MIN_ASYNC_MAX_QUEUE_SIZE,
-                MAX_ASYNC_MAX_QUEUE_SIZE));
+        String.format(
+            "The maximum size in megabytes that a publishing process should be allowed to asynchronously enqueue for this process before asking this process to depart from the distributed system. Defaults to %s. Legal values are in the range [%s..%s].",
+            DEFAULT_ASYNC_MAX_QUEUE_SIZE,
+            MIN_ASYNC_MAX_QUEUE_SIZE,
+            MAX_ASYNC_MAX_QUEUE_SIZE));
-        LocalizedStrings.AbstractDistributionConfig_START_LOCATOR_NAME.toLocalizedString());
+        "The host|bindAddress[port] of a Locator to start in this VM along with the DistributedSystem. The default is to not start a Locator.");
-    m.put(DURABLE_CLIENT_ID, LocalizedStrings.AbstractDistributionConfig_DURABLE_CLIENT_ID_NAME_0
-        .toLocalizedString(DEFAULT_DURABLE_CLIENT_ID));
+    m.put(DURABLE_CLIENT_ID, String.format(
+        "An id used by durable clients to identify themselves as durable to servers. Defaults to %s.",
+        DEFAULT_DURABLE_CLIENT_ID));
-    m.put(CONFLATE_EVENTS, LocalizedStrings.AbstractDistributionConfig_CLIENT_CONFLATION_PROP_NAME
-        .toLocalizedString());
+    m.put(CONFLATE_EVENTS, "Client override for server queue conflation setting");
-        LocalizedStrings.AbstractDistributionConfig_DURABLE_CLIENT_TIMEOUT_NAME_0
-            .toLocalizedString(DEFAULT_DURABLE_CLIENT_TIMEOUT));
+        String.format(
+            "The value (in seconds) used by the server to keep disconnected durable clients alive. Defaults to %s.",
+            DEFAULT_DURABLE_CLIENT_TIMEOUT));
-        LocalizedStrings.AbstractDistributionConfig_SECURITY_CLIENT_AUTH_INIT_NAME_0
-            .toLocalizedString(DEFAULT_SECURITY_CLIENT_AUTH_INIT));
+        String.format(
+            "User defined fully qualified method name implementing AuthInitialize interface for client. Defaults to %s. Legal values can be any method name of a static method that is present in the classpath.",
+            DEFAULT_SECURITY_CLIENT_AUTH_INIT));
-        LocalizedStrings.AbstractDistributionConfig_SECURITY_CLIENT_AUTHENTICATOR_NAME_0
-            .toLocalizedString(DEFAULT_SECURITY_CLIENT_AUTHENTICATOR));
+        String.format(
+            "User defined fully qualified method name implementing Authenticator interface for client verification. Defaults to %s. Legal values can be any method name of a static method that is present in the classpath.",
+            DEFAULT_SECURITY_CLIENT_AUTHENTICATOR));
-        LocalizedStrings.AbstractDistributionConfig_SECURITY_CLIENT_DHALGO_NAME_0
-            .toLocalizedString(DEFAULT_SECURITY_CLIENT_DHALGO));
+        String.format(
+            "User defined name for the symmetric encryption algorithm to use in Diffie-Hellman key exchange for encryption of credentials.  Defaults to %s. Legal values can be any of the available symmetric algorithm names in JDK like DES, DESede, AES, Blowfish. It may be required to install Unlimited Strength Jurisdiction Policy Files from Sun for some symmetric algorithms to work (like AES)",
+            DEFAULT_SECURITY_CLIENT_DHALGO));
-        LocalizedStrings.AbstractDistributionConfig_SECURITY_UDP_DHALGO_NAME_0
-            .toLocalizedString(DEFAULT_SECURITY_UDP_DHALGO));
+        String.format(
+            "User defined name for the symmetric encryption algorithm to use in Diffie-Hellman key exchange for encryption of udp messages.  Defaults to %s. Legal values can be any of the available symmetric algorithm names in JDK like DES, DESede, AES, Blowfish. It may be required to install Unlimited Strength Jurisdiction Policy Files from Sun for some symmetric algorithms to work (like AES)",
+            DEFAULT_SECURITY_UDP_DHALGO));
-        LocalizedStrings.AbstractDistributionConfig_SECURITY_PEER_AUTH_INIT_NAME_0
-            .toLocalizedString(DEFAULT_SECURITY_PEER_AUTH_INIT));
+        String.format(
+            "User defined fully qualified method name implementing AuthInitialize interface for peer. Defaults to %s. Legal values can be any method name of a static method that is present in the classpath.",
+            DEFAULT_SECURITY_PEER_AUTH_INIT));
-        LocalizedStrings.AbstractDistributionConfig_SECURITY_PEER_AUTHENTICATOR_NAME_0
-            .toLocalizedString(DEFAULT_SECURITY_PEER_AUTHENTICATOR));
+        String.format(
+            "User defined fully qualified method name implementing Authenticator interface for peer verificaiton. Defaults to %s. Legal values can be any method name of a static method that is present in the classpath.",
+            DEFAULT_SECURITY_PEER_AUTHENTICATOR));
-        LocalizedStrings.AbstractDistributionConfig_SECURITY_CLIENT_ACCESSOR_NAME_0
-            .toLocalizedString(DEFAULT_SECURITY_CLIENT_ACCESSOR));
+        String.format(
+            "User defined fully qualified method name implementing AccessControl interface for client authorization. Defaults to %s. Legal values can be any method name of a static method that is present in the classpath.",
+            DEFAULT_SECURITY_CLIENT_ACCESSOR));
-        LocalizedStrings.AbstractDistributionConfig_SECURITY_CLIENT_ACCESSOR_PP_NAME_0
-            .toLocalizedString(DEFAULT_SECURITY_CLIENT_ACCESSOR_PP));
+        String.format(
+            "User defined fully qualified method name implementing AccessControl interface for client authorization in post-processing phase. Defaults to %s. Legal values can be any method name of a static method that is present in the classpath.",
+            DEFAULT_SECURITY_CLIENT_ACCESSOR_PP));
-        LocalizedStrings.AbstractDistributionConfig_SECURITY_LOG_LEVEL_NAME_0_1
-            .toLocalizedString(LogWriterImpl.levelToString(DEFAULT_LOG_LEVEL),
-                LogWriterImpl.allowedLogLevels()));
+        String.format(
+            "Controls the type of messages that will actually be written to the system security log. Defaults to %s.  Allowed values %s.",
+            LogWriterImpl.levelToString(DEFAULT_LOG_LEVEL),
+            LogWriterImpl.allowedLogLevels()));
-    m.put(SECURITY_LOG_FILE, LocalizedStrings.AbstractDistributionConfig_SECURITY_LOG_FILE_NAME_0
-        .toLocalizedString(DEFAULT_SECURITY_LOG_FILE));
+    m.put(SECURITY_LOG_FILE, String.format(
+        "The file a running system will write security log messages to. Defaults to %s.",
+        DEFAULT_SECURITY_LOG_FILE));
-        LocalizedStrings.AbstractDistributionConfig_SECURITY_PEER_VERIFYMEMBER_TIMEOUT_NAME_0
-            .toLocalizedString(DEFAULT_SECURITY_PEER_VERIFYMEMBER_TIMEOUT));
+        String.format(
+            "The timeout value (in milliseconds) used by a peer to verify membership of an unknown authenticated peer requesting a secure connection. Defaults to %s milliseconds. The timeout value should not exceed peer handshake timeout.",
+            DEFAULT_SECURITY_PEER_VERIFYMEMBER_TIMEOUT));
-        LocalizedStrings.AbstractDistributionConfig_SECURITY_PREFIX_NAME.toLocalizedString());
+        "Prefix for security related properties which are packed together and invoked as authentication parameter. Neither key nor value can be NULL. Legal tags can be [security-username, security-digitalid] and Legal values can be any string data.");
-        LocalizedStrings.AbstractDistributionConfig_USERDEFINED_PREFIX_NAME.toLocalizedString());
+        "Prefix for user defined properties which are used for replacements in Cache.xml. Neither key nor value can be NULL. Legal tags can be [custom-any-string] and Legal values can be any string data.");
-        LocalizedStrings.AbstractDistributionConfig_REMOVE_UNRESPONSIVE_CLIENT_PROP_NAME_0
-            .toLocalizedString(DEFAULT_REMOVE_UNRESPONSIVE_CLIENT));
+        String.format("Whether to remove unresponsive client or not. Defaults to %s.",
+            DEFAULT_REMOVE_UNRESPONSIVE_CLIENT));
-        LocalizedStrings.AbstractDistributionConfig_REMOTE_DISTRIBUTED_SYSTEMS_NAME_0
-            .toLocalizedString(DEFAULT_REMOTE_LOCATORS));
+        String.format(
+            "A possibly empty list of locators used to find other distributed systems. Each element of the list must be a host name followed by bracketed, [], port number. Host names may be followed by a colon and a bind address used by the locator on that host.  Multiple elements must be comma separated. Defaults to %s.",
+            DEFAULT_REMOTE_LOCATORS));
-    m.put(SSL_JMX_ALIAS, LocalizedStrings.AbstractDistributionConfig_JMX_MANAGER_SSL_ALIAS_0
-        .toLocalizedString(Boolean.valueOf(DEFAULT_SSL_ALIAS)));
+    m.put(SSL_JMX_ALIAS, String.format(
+        "SSL jmx communication uses the this alias when determining the key to use from the keystore for SSL. Defaults to %s.",
+        Boolean.valueOf(DEFAULT_SSL_ALIAS)));
-            + DEFAULT_JMX_MANAGER_SSL_CIPHERS + "\" meaning your provider''s defaults.");
+            + DEFAULT_JMX_MANAGER_SSL_CIPHERS + "\" meaning your provider's defaults.");
-    m.put(SSL_LOCATOR_ALIAS, LocalizedStrings.AbstractDistributionConfig_LOCATOR_SSL_ALIAS_0
-        .toLocalizedString(Boolean.valueOf(DEFAULT_SSL_ALIAS)));
+    m.put(SSL_LOCATOR_ALIAS, String.format(
+        "SSL locator communications uses this alias when determining the key to use from the keystore for SSL. Defaults to %s.",
+        Boolean.valueOf(DEFAULT_SSL_ALIAS)));
-        LocalizedStrings.AbstractDistributionConfig_ENABLE_SHARED_CONFIGURATION
-            .toLocalizedString());
+        "Enables cluster configuration support in dedicated locators.  This allows the locator to share configuration information amongst members and save configuration changes made using GFSH.");
-        LocalizedStrings.AbstractDistributionConfig_USE_SHARED_CONFIGURATION.toLocalizedString());
+        "Boolean flag that allows the cache to use the cluster configuration provided by the cluster config service");
-        LocalizedStrings.AbstractDistributionConfig_LOAD_SHARED_CONFIGURATION_FROM_DIR
-            .toLocalizedString(
-                InternalConfigurationPersistenceService.CLUSTER_CONFIG_ARTIFACTS_DIR_NAME));
+        String.format(
+            "Loads cluster configuration from the %s directory of a locator. This is property is only applicable to the locator(s)",
+
+            InternalConfigurationPersistenceService.CLUSTER_CONFIG_ARTIFACTS_DIR_NAME));
-        LocalizedStrings.AbstractDistributionConfig_CLUSTER_CONFIGURATION_DIR.toLocalizedString());
-    m.put(SSL_SERVER_ALIAS, LocalizedStrings.AbstractDistributionConfig_SERVER_SSL_ALIAS_0
-        .toLocalizedString(Boolean.valueOf(DEFAULT_SSL_ALIAS)));
+        "The directory to store the cluster configuration artifacts and disk-store. This property is only applicable to the locator(s)");
+    m.put(SSL_SERVER_ALIAS, String.format(
+        "SSL inter-server communication (peer-to-peer) uses the this alias when determining the key to use from the keystore for SSL. Defaults to %s.",
+        Boolean.valueOf(DEFAULT_SSL_ALIAS)));
-            + DEFAULT_SERVER_SSL_CIPHERS + "\" meaning your provider''s defaults.");
+            + DEFAULT_SERVER_SSL_CIPHERS + "\" meaning your provider's defaults.");
-    m.put(SSL_GATEWAY_ALIAS, LocalizedStrings.AbstractDistributionConfig_GATEWAY_SSL_ALIAS_0
-        .toLocalizedString(Boolean.valueOf(DEFAULT_SSL_ALIAS)));
+    m.put(SSL_GATEWAY_ALIAS, String.format(
+        "SSL gateway communication uses the this alias when determining the key to use from the keystore for SSL. Defaults to %s.",
+        Boolean.valueOf(DEFAULT_SSL_ALIAS)));
-            + DEFAULT_GATEWAY_SSL_CIPHERS + "\" meaning your provider''s defaults.");
+            + DEFAULT_GATEWAY_SSL_CIPHERS + "\" meaning your provider's defaults.");
-    m.put(SSL_WEB_ALIAS, LocalizedStrings.AbstractDistributionConfig_HTTP_SERVICE_SSL_ALIAS_0
-        .toLocalizedString(Boolean.valueOf(DEFAULT_SSL_ALIAS)));
+    m.put(SSL_WEB_ALIAS, String.format(
+        "SSL http service communication uses the this alias when determining the key to use from the keystore for SSL. Defaults to %s.",
+        Boolean.valueOf(DEFAULT_SSL_ALIAS)));
-            + DEFAULT_HTTP_SERVICE_SSL_CIPHERS + "\" meaning your provider''s defaults.");
+            + DEFAULT_HTTP_SERVICE_SSL_CIPHERS + "\" meaning your provider's defaults.");
-    m.put(OFF_HEAP_MEMORY_SIZE, LocalizedStrings.AbstractDistributionConfig_OFF_HEAP_MEMORY_SIZE_0
-        .toLocalizedString(DEFAULT_OFF_HEAP_MEMORY_SIZE));
-    m.put(LOCK_MEMORY, LocalizedStrings.AbstractDistributionConfig_LOCK_MEMORY
-        .toLocalizedString(DEFAULT_LOCK_MEMORY));
+    m.put(OFF_HEAP_MEMORY_SIZE, String.format(
+        "The amount of off-heap memory to be allocated for GemFire. Value is <n>[g|m], where <n> is the size and [g|m] specifies the units in gigabytes or megabytes. Defaults to %s.",
+        DEFAULT_OFF_HEAP_MEMORY_SIZE));
+    m.put(LOCK_MEMORY, String.format(
+        "Locks heap and off-heap memory pages into RAM, thereby preventing the operating system from swapping them out to disk. Defaults to %s",
+        DEFAULT_LOCK_MEMORY));
-        + DEFAULT_SSL_CIPHERS + "\" meaning your provider''s defaults.");
+        + DEFAULT_SSL_CIPHERS + "\" meaning your provider's defaults.");
-        LocalizedStrings.AbstractDistributionConfig_THREAD_MONITOR_INTERVAL.toLocalizedString());
+        "Defines the time interval (in milliseconds) with which thread monitoring is scheduled to run.");
-        LocalizedStrings.AbstractDistributionConfig_THREAD_MONITOR_ENABLED.toLocalizedString());
+        "Defines whether thread monitoring is to be enabled.");
-        LocalizedStrings.AbstractDistributionConfig_THREAD_MONITOR_TIME_LIMIT.toLocalizedString());
+        "Defines the time period (in milliseconds) after which the monitored thread is considered to be stuck.");
-          LocalizedStrings.AbstractDistributionConfig_UNEXPECTED_PROBLEM_GETTING_INETADDRESS_0
-              .toLocalizedString(ex),
+          String.format("Unexpected problem getting inetAddress: %s",
+              ex),

MOV21 MOV21 MOV21 MOV21 MOV41 MOV41 INS8 MOV8 INS53 INS45 INS45 INS45 INS45 INS45 INS45 INS45 INS45 INS45 INS45 INS45 UPD42 INS45 INS45 INS45 UPD42 UPD42 UPD42 INS45 INS45 INS45 INS14 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 INS42 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD45 UPD42 INS42 INS45 UPD45 UPD42 INS42 INS45 UPD45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD45 MOV43 MOV43 MOV43 INS45 MOV43 INS32 MOV43 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 MOV43 UPD42 INS42 INS45 MOV43 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 INS42 INS42 INS45 INS42 MOV32 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 MOV43 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 MOV43 UPD42 INS42 INS45 UPD42 INS42 INS45 DEL40 DEL26 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL42 DEL32 DEL40 DEL40 DEL42 DEL42 DEL32 DEL14 DEL53 DEL8 DEL40 DEL40 DEL42 DEL32 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL42 DEL32 DEL40 DEL40 DEL42 DEL32 DEL40 DEL40 DEL40 DEL42 DEL32 DEL40 DEL40 DEL40 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL40 DEL40 DEL40 DEL40 DEL42 DEL32 DEL40 DEL40 DEL42 DEL32 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL40 DEL40 DEL40 DEL40 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL40 DEL40 DEL42 DEL32 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL40
GEODE-2198: close and re-create the cache on a server when importing new cluster configuration

* When importing cluster config first check if there is any non-empty region
* close and re-create cache if no data exists when importing new cluster configuration
* put the acquire/release lock inside the ClusterConfigurationService instead of command execution strategy.

-  /**
-   * Gets or creates (if not created) shared configuration lock service
-   */
-  public static DistributedLockService getSharedConfigLockService(DistributedSystem ds) {
-    DistributedLockService sharedConfigDls =
-        DLockService.getServiceNamed(SHARED_CONFIG_LOCK_SERVICE_NAME);
-    try {
-      if (sharedConfigDls == null) {
-        sharedConfigDls = DLockService.create(SHARED_CONFIG_LOCK_SERVICE_NAME,
-            (InternalDistributedSystem) ds, true, true);
-      }
-    } catch (IllegalArgumentException e) {
-      return DLockService.getServiceNamed(SHARED_CONFIG_LOCK_SERVICE_NAME);
-    }
-    return sharedConfigDls;
-  }
-
+  /**
+   * Gets or creates (if not created) shared configuration lock service
+   */
+  private DistributedLockService getSharedConfigLockService(DistributedSystem ds) {
+    DistributedLockService sharedConfigDls =
+        DLockService.getServiceNamed(SHARED_CONFIG_LOCK_SERVICE_NAME);
+    try {
+      if (sharedConfigDls == null) {
+        sharedConfigDls = DLockService.create(SHARED_CONFIG_LOCK_SERVICE_NAME,
+            (InternalDistributedSystem) ds, true, true);
+      }
+    } catch (IllegalArgumentException e) {
+      return DLockService.getServiceNamed(SHARED_CONFIG_LOCK_SERVICE_NAME);
+    }
+    return sharedConfigDls;
+  }
-    Region<String, Configuration> configRegion = getConfigurationRegion();
-    if (groups == null || groups.length == 0) {
-      groups = new String[] {ClusterConfigurationService.CLUSTER_CONFIG};
-    }
-    for (String group : groups) {
-      Configuration configuration = (Configuration) configRegion.get(group);
-      if (configuration == null) {
-        configuration = new Configuration(group);
+    lockSharedConfiguration();
+    try {
+      Region<String, Configuration> configRegion = getConfigurationRegion();
+      if (groups == null || groups.length == 0) {
+        groups = new String[] {ClusterConfigurationService.CLUSTER_CONFIG};
-      String xmlContent = configuration.getCacheXmlContent();
-      if (xmlContent == null || xmlContent.isEmpty()) {
-        StringWriter sw = new StringWriter();
-        PrintWriter pw = new PrintWriter(sw);
-        CacheXmlGenerator.generateDefault(pw);
-        xmlContent = sw.toString();
-      }
-      try {
-        final Document doc = XmlUtils.createAndUpgradeDocumentFromXml(xmlContent);
-        XmlUtils.addNewNode(doc, xmlEntity);
-        configuration.setCacheXmlContent(XmlUtils.prettyXml(doc));
-        configRegion.put(group, configuration);
-      } catch (Exception e) {
-        logger.error("error updating cluster configuration for group " + group, e);
-      }
-    }
-  }
-
-  /**
-   * Deletes the xml entity from the shared configuration.
-   */
-  public void deleteXmlEntity(final XmlEntity xmlEntity, String[] groups) {
-    Region<String, Configuration> configRegion = getConfigurationRegion();
-    // No group is specified, so delete in every single group if it exists.
-    if (groups == null) {
-      Set<String> groupSet = configRegion.keySet();
-      groups = groupSet.toArray(new String[groupSet.size()]);
-    }
-    for (String group : groups) {
-      Configuration configuration = (Configuration) configRegion.get(group);
-      if (configuration != null) {
-        String xmlContent = configuration.getCacheXmlContent();
-        try {
-          if (xmlContent != null && !xmlContent.isEmpty()) {
-            Document doc = XmlUtils.createAndUpgradeDocumentFromXml(xmlContent);
-            XmlUtils.deleteNode(doc, xmlEntity);
-            configuration.setCacheXmlContent(XmlUtils.prettyXml(doc));
-            configRegion.put(group, configuration);
-          }
-        } catch (Exception e) {
-          logger.error("error updating cluster configuration for group " + group, e);
+      for (String group : groups) {
+        Configuration configuration = (Configuration) configRegion.get(group);
+        if (configuration == null) {
+          configuration = new Configuration(group);
-      }
-    }
-  }
-
-  // we don't need to trigger the change listener for this modification, so it's ok to
-  // operate on the original configuration object
-  public void modifyXmlAndProperties(Properties properties, XmlEntity xmlEntity, String[] groups) {
-    if (groups == null) {
-      groups = new String[] {ClusterConfigurationService.CLUSTER_CONFIG};
-    }
-    Region<String, Configuration> configRegion = getConfigurationRegion();
-    for (String group : groups) {
-      Configuration configuration = configRegion.get(group);
-      if (configuration == null) {
-        configuration = new Configuration(group);
-      }
-
-      if (xmlEntity != null) {
-          Document doc = XmlUtils.createAndUpgradeDocumentFromXml(xmlContent);
-          // Modify the cache attributes
-          XmlUtils.modifyRootAttributes(doc, xmlEntity);
-          // Change the xml content of the configuration and put it the config region
+          final Document doc = XmlUtils.createAndUpgradeDocumentFromXml(xmlContent);
+          XmlUtils.addNewNode(doc, xmlEntity);
+          configRegion.put(group, configuration);
+    } finally {
+      unlockSharedConfiguration();
+    }
+  }
-      if (properties != null) {
-        configuration.getGemfireProperties().putAll(properties);
+  /**
+   * Deletes the xml entity from the shared configuration.
+   */
+  public void deleteXmlEntity(final XmlEntity xmlEntity, String[] groups) {
+    lockSharedConfiguration();
+    try {
+      Region<String, Configuration> configRegion = getConfigurationRegion();
+      // No group is specified, so delete in every single group if it exists.
+      if (groups == null) {
+        Set<String> groupSet = configRegion.keySet();
+        groups = groupSet.toArray(new String[groupSet.size()]);
-      configRegion.put(group, configuration);
+      for (String group : groups) {
+        Configuration configuration = (Configuration) configRegion.get(group);
+        if (configuration != null) {
+          String xmlContent = configuration.getCacheXmlContent();
+          try {
+            if (xmlContent != null && !xmlContent.isEmpty()) {
+              Document doc = XmlUtils.createAndUpgradeDocumentFromXml(xmlContent);
+              XmlUtils.deleteNode(doc, xmlEntity);
+              configuration.setCacheXmlContent(XmlUtils.prettyXml(doc));
+              configRegion.put(group, configuration);
+            }
+          } catch (Exception e) {
+            logger.error("error updating cluster configuration for group " + group, e);
+          }
+        }
+      }
+    } finally {
+      unlockSharedConfiguration();
+    }
+  }
+
+  // we don't need to trigger the change listener for this modification, so it's ok to
+  // operate on the original configuration object
+  public void modifyXmlAndProperties(Properties properties, XmlEntity xmlEntity, String[] groups) {
+    lockSharedConfiguration();
+    try {
+      if (groups == null) {
+        groups = new String[] {ClusterConfigurationService.CLUSTER_CONFIG};
+      }
+      Region<String, Configuration> configRegion = getConfigurationRegion();
+      for (String group : groups) {
+        Configuration configuration = configRegion.get(group);
+        if (configuration == null) {
+          configuration = new Configuration(group);
+        }
+
+        if (xmlEntity != null) {
+          String xmlContent = configuration.getCacheXmlContent();
+          if (xmlContent == null || xmlContent.isEmpty()) {
+            StringWriter sw = new StringWriter();
+            PrintWriter pw = new PrintWriter(sw);
+            CacheXmlGenerator.generateDefault(pw);
+            xmlContent = sw.toString();
+          }
+          try {
+            Document doc = XmlUtils.createAndUpgradeDocumentFromXml(xmlContent);
+            // Modify the cache attributes
+            XmlUtils.modifyRootAttributes(doc, xmlEntity);
+            // Change the xml content of the configuration and put it the config region
+            configuration.setCacheXmlContent(XmlUtils.prettyXml(doc));
+          } catch (Exception e) {
+            logger.error("error updating cluster configuration for group " + group, e);
+          }
+        }
+
+        if (properties != null) {
+          configuration.getGemfireProperties().putAll(properties);
+        }
+        configRegion.put(group, configuration);
+      }
+    } finally {
+      unlockSharedConfiguration();
+    lockSharedConfiguration();
+    } finally {
+      unlockSharedConfiguration();
+    }
+    return success;
+  }
+
+  /**
+   * Removes the jar files from the shared configuration. used when undeploy jars
+   *
+   * @param jarNames Names of the jar files.
+   * @param groups Names of the groups which had the jar file deployed.
+   * @return true on success.
+   */
+  public boolean removeJars(final String[] jarNames, String[] groups) {
+    boolean success = true;
+    lockSharedConfiguration();
+    try {
+      Region<String, Configuration> configRegion = getConfigurationRegion();
+      if (groups == null) {
+        groups = configRegion.keySet().stream().toArray(String[]::new);
+      }
+      for (String group : groups) {
+        Configuration configuration = configRegion.get(group);
+        if (configuration == null) {
+          break;
+        }
+        Configuration configurationCopy = new Configuration(configuration);
+        configurationCopy.removeJarNames(jarNames);
+        configRegion.put(group, configurationCopy);
+      }
+    } catch (Exception e) {
+      logger.info("Exception occurred while deleting the jar files", e);
+      success = false;
+    } finally {
+      unlockSharedConfiguration();
-  /**
-   * Removes the jar files from the shared configuration. used when undeploy jars
-   *
-   * @param jarNames Names of the jar files.
-   * @param groups Names of the groups which had the jar file deployed.
-   * @return true on success.
-   */
-  public boolean removeJars(final String[] jarNames, String[] groups) {
-    boolean success = true;
-    try {
-      Region<String, Configuration> configRegion = getConfigurationRegion();
-      if (groups == null) {
-        groups = configRegion.keySet().stream().toArray(String[]::new);
-      }
-      for (String group : groups) {
-        Configuration configuration = configRegion.get(group);
-        if (configuration == null) {
-          break;
-        }
-        Configuration configurationCopy = new Configuration(configuration);
-        configurationCopy.removeJarNames(jarNames);
-        configRegion.put(group, configurationCopy);
-      }
-    } catch (Exception e) {
-      logger.info("Exception occurred while deleting the jar files", e);
-      success = false;
-    }
-    return success;
-  }
-
-
-  public void clearSharedConfiguration() throws Exception {
-    Region<String, Configuration> configRegion = getConfigurationRegion();
-    configRegion.clear();
-  }
-
-
-        this.loadSharedConfigurationFromDisk();
+        loadSharedConfigurationFromDisk();
-        putSecurityPropsIntoClusterConfig(configRegion);
+        persistSecuritySettings(configRegion);
+        // for those groups that have jar files, need to download the jars from other locators
+        // if it doesn't exist yet
-          // for those groups that have jar files, need to download the jars from other locators
-          // if it doesn't exist yet
-  private void putSecurityPropsIntoClusterConfig(final Region<String, Configuration> configRegion) {
+  private void persistSecuritySettings(final Region<String, Configuration> configRegion) {
+
+
+    lockSharedConfiguration();
-    for (File groupName : groupNames) {
-      Configuration configuration = readConfiguration(groupName);
-      sharedConfiguration.put(groupName.getName(), configuration);
+    try {
+      for (File groupName : groupNames) {
+        Configuration configuration = readConfiguration(groupName);
+        sharedConfiguration.put(groupName.getName(), configuration);
+      }
+      Region clusterRegion = getConfigurationRegion();
+      clusterRegion.clear();
+      clusterRegion.putAll(sharedConfiguration);
+
+      // Overwrite the security settings using the locator's properties, ignoring whatever
+      // in the import
+      persistSecuritySettings(clusterRegion);
+
+    } finally {
+      unlockSharedConfiguration();
-
-    getConfigurationRegion().clear();
-    getConfigurationRegion().putAll(sharedConfiguration);
-
-
-  public void writeConfig(final Configuration configuration) throws Exception {
+  public void writeConfigToFile(final Configuration configuration) throws Exception {
+
+  // check if it's ok from populate the properties from one member to another
+  public static boolean isMisConfigured(Properties fromProps, Properties toProps, String key) {
+    String fromPropValue = fromProps.getProperty(key);
+    String toPropValue = toProps.getProperty(key);
+
+    // if this to prop is not specified, this is always OK.
+    if (org.apache.commons.lang.StringUtils.isBlank(toPropValue))
+      return false;
+
+    // to props is not blank, but from props is blank, NOT OK.
+    if (org.apache.commons.lang.StringUtils.isBlank(fromPropValue))
+      return true;
+
+    // at this point check for eqality
+    return !fromPropValue.equals(toPropValue);
+  }

MOV31 MOV31 MOV31 UPD83 INS8 INS8 INS8 UPD42 UPD42 INS83 UPD39 UPD42 INS44 INS44 INS44 INS21 INS54 INS21 INS54 INS21 INS54 INS21 INS21 INS21 INS54 INS43 INS42 INS43 INS42 MOV43 INS42 INS60 INS60 INS25 INS25 INS41 INS32 MOV8 INS8 INS32 MOV8 INS8 INS32 MOV8 INS8 INS32 INS8 INS32 INS8 INS32 INS8 INS8 UPD42 MOV42 INS42 INS43 INS59 INS43 INS59 INS32 INS41 INS32 INS41 INS38 INS42 INS21 INS42 INS21 INS42 INS21 INS42 INS21 INS42 INS21 INS42 MOV70 MOV60 MOV21 MOV21 INS21 INS21 INS42 INS42 INS32 INS42 INS42 INS32 INS40 INS42 INS42 INS9 INS40 INS42 INS42 INS9 INS32 INS32 INS32 INS32 INS32 INS32 MOV43 INS32 INS32 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 UPD42 DEL83 DEL52 DEL42 DEL43 DEL74 DEL32 DEL32 DEL43 DEL32 DEL21
GEODE-6355: Fix Synchronization of Function stats in IDS. (#3158)

* Don't use double-checked locking.
* Use computeIfAbsent instead of locking on the object.

Cleanup:
* Rename listeners to disconnectListeners.
* Remove dead code
* generify collections
* Change some loops to foreach
* Make a ThreadLocal use withInitial
* Make methods and fields private
-  public static final String DISABLE_MANAGEMENT_PROPERTY =
+  private static final String DISABLE_MANAGEMENT_PROPERTY =
-      new AtomicReference<CreationStackGenerator>(DEFAULT_CREATION_STACK_GENERATOR);
+      new AtomicReference<>(DEFAULT_CREATION_STACK_GENERATOR);
-  protected final Object isConnectedMutex = new Object();
+  private final Object isConnectedMutex = new Object();
-  private final Set listeners = new LinkedHashSet(); // needs to be ordered
+  private final Set<DisconnectListener> disconnectListeners = new LinkedHashSet<>(); // needs to be
+                                                                                     // ordered
-  private static final Set connectListeners = new LinkedHashSet(); // needs to be ordered
+  // needs to be ordered
+  private static final Set<ConnectListener> connectListeners = new LinkedHashSet();
-  public static InternalLogWriter getStaticSecurityInternalLogWriter() {
-    InternalDistributedSystem sys = getAnyInstance();
-    if (sys != null) {
-      return sys.securityLogWriter;
-    }
-    return null;
-  }
-
-      this.isReconnectingDS = ((Boolean) o).booleanValue();
+      this.isReconnectingDS = (Boolean) o;
-   * @param reason the reason that the system is disconnecting
-   *
-  private HashSet doDisconnects(boolean doReconnect, String reason) {
+  private HashSet<ShutdownListener> doDisconnects(boolean doReconnect) {
-    HashSet shutdownListeners = new HashSet();
+    HashSet<ShutdownListener> shutdownListeners = new HashSet<>();
-      DisconnectListener listener = null;
-      synchronized (this.listeners) {
-        Iterator itr = listeners.iterator();
+      DisconnectListener listener;
+      synchronized (this.disconnectListeners) {
+        Iterator<DisconnectListener> itr = disconnectListeners.iterator();
-          break;
+          return shutdownListeners;
-        listener = (DisconnectListener) itr.next();
+        listener = itr.next();
-          shutdownListeners.add(listener);
+          shutdownListeners.add((ShutdownListener) listener);
-    return shutdownListeners;
-  private void doShutdownListeners(HashSet shutdownListeners) {
+  private void doShutdownListeners(HashSet<ShutdownListener> shutdownListeners) {
-    Iterator it = shutdownListeners.iterator();
-    while (it.hasNext()) {
-      ShutdownListener s = (ShutdownListener) it.next();
+    for (ShutdownListener shutdownListener : shutdownListeners) {
-        s.onShutdown(this);
+        shutdownListener.onShutdown(this);
-        logger.fatal(String.format("ShutdownListener < %s > threw...", s), t);
+        logger.fatal(String.format("ShutdownListener < %s > threw...", shutdownListener), t);
-      synchronized (this.listeners) {
-        Iterator itr = listeners.iterator();
+      synchronized (this.disconnectListeners) {
+        Iterator<DisconnectListener> itr = disconnectListeners.iterator();
-        dcListener = (DisconnectListener) itr.next();
+        dcListener = itr.next();
-    this.listeners.clear();
+    this.disconnectListeners.clear();
-      HashSet shutdownListeners = null;
+      HashSet<ShutdownListener> shutdownListeners = null;
-          shutdownListeners = doDisconnects(attemptingToReconnect, reason);
+          shutdownListeners = doDisconnects(attemptingToReconnect);
-      new ConcurrentHashMap<String, FunctionStats>();
+      new ConcurrentHashMap<>();
-    FunctionStats stats = functionExecutionStatsMap.get(textId);
-    if (stats == null) {
-      stats = new FunctionStats(this, textId);
-      FunctionStats oldStats = functionExecutionStatsMap.putIfAbsent(textId, stats);
-      if (oldStats != null) {
-        stats.close();
-        stats = oldStats;
-      }
-    }
-    return stats;
+    return functionExecutionStatsMap.computeIfAbsent(textId,
+        key -> new FunctionStats(this, key));
-  public FunctionServiceStats getFunctionServiceStats() {
+  public synchronized FunctionServiceStats getFunctionServiceStats() {
-      synchronized (this) {
-        if (functionServiceStats == null) {
-          functionServiceStats = new FunctionServiceStats(this, "FunctionExecution");
-        }
-      }
+      functionServiceStats = new FunctionServiceStats(this, "FunctionExecution");
-  public Set<String> getAllFunctionExecutionIds() {
-    return functionExecutionStatsMap.keySet();
-  }
-
-    // (new ManagerLogWriter(LogWriterImpl.FINE_LEVEL, System.out)).fine("registering reconnect
-    // listener: " + listener);
-   * Removes a <code>ConnectListener</code> from the list of listeners that will be notified when a
-   * connection is created to a distributed system.
-   *
-   * @return true if listener was in the list
-   */
-  public static boolean removeConnectListener(ConnectListener listener) {
-    synchronized (connectListeners) {
-      return connectListeners.remove(listener);
-    }
-  }
-
-  /**
-      for (Iterator iter = connectListeners.iterator(); iter.hasNext();) {
+      for (ConnectListener listener : connectListeners) {
-          ConnectListener listener = (ConnectListener) iter.next();
-   * Removes a <code>ReconnectListener</code> from the list of listeners that will be notified when
-   * a connection is recreated to a distributed system.
-   */
-  public static void removeReconnectListener(ReconnectListener listener) {
-    synchronized (reconnectListeners) {
-      reconnectListeners.remove(listener);
-    }
-  }
-
-  /**
-      listeners = new ArrayList<ReconnectListener>(reconnectListeners);
+      listeners = new ArrayList<>(reconnectListeners);
-    synchronized (this.listeners) {
-      this.listeners.add(listener);
+    synchronized (this.disconnectListeners) {
+      this.disconnectListeners.add(listener);
-          this.listeners.remove(listener); // don't leave in the list!
+          this.disconnectListeners.remove(listener); // don't leave in the list!
-   *
-   * @return true if listener was in the list
-  public boolean removeDisconnectListener(DisconnectListener listener) {
-    synchronized (this.listeners) {
-      return this.listeners.remove(listener);
+  public void removeDisconnectListener(DisconnectListener listener) {
+    synchronized (this.disconnectListeners) {
+      this.disconnectListeners.remove(listener);
-   * Fires an "informational" <code>SystemMembershipEvent</code> in admin VMs.
-   *
-   * @since GemFire 4.0
-   */
-  public void fireInfoEvent(Object callback) {
-    throw new UnsupportedOperationException(
-        "Not implemented yet");
-  }
-
-  /**
-          DistributedSystem ds = InternalDistributedSystem.getAnyInstance();
+          InternalDistributedSystem ds = InternalDistributedSystem.getAnyInstance();
-            DurableClientAttributes dca = ((InternalDistributedSystem) ds).getDistributedMember()
+            DurableClientAttributes dca = ds.getDistributedMember()
-            ((InternalDistributedSystem) ds).disconnect(false,
+            ds.disconnect(false,
-   * The time at which reconnect attempts last began
-   */
-  private static long reconnectAttemptTime;
-
-  /**
-  public void cancelReconnect() {
-    // (new ManagerLogWriter(LogWriterImpl.FINE_LEVEL, System.out)).fine("cancelReconnect invoked",
-    // new Exception("stack trace");
+  private void cancelReconnect() {
-        if (reconnectAttemptCounter == 0) {
-          reconnectAttemptTime = System.currentTimeMillis();
-        }
-      return;
-
-      for (int i = 0; i < validAttributeNames.length; i++) {
-        String attName = validAttributeNames[i];
+      for (String attName : validAttributeNames) {
-  public String forceStop() {
-    if (this.dm == null) {
-      return "no distribution manager";
-    }
-    String reason = dm.getCancelCriterion().cancelInProgress();
-    return reason;
-  }
-
-  public boolean isServerLocator() {
-    return this.startedLocator.isServerLocator();
-  }
-
-  /**
-   * Provides synchronized time for this process based on other processes in this GemFire
-   * distributed system. GemFire distributed system coordinator adjusts each member's time by an
-   * offset. This offset for each member is calculated based on Berkeley Time Synchronization
-   * algorithm.
-   *
-   * @return time in milliseconds.
-   */
-  public long systemTimeMillis() {
-    return dm.cacheTimeMillis();
-  }
-
-      InternalDistributedSystem recon = this.reconnectDS;
-
-      recon = this.reconnectDS;
+      InternalDistributedSystem recon = this.reconnectDS;
-    // (new ManagerLogWriter(LogWriterImpl.FINE_LEVEL, System.out)).fine("stopReconnecting invoked",
-    // new Exception("stack trace");

INS31 UPD83 UPD83 INS74 INS74 INS74 INS42 INS83 MOV8 MOV29 MOV83 MOV39 MOV42 MOV44 MOV8 UPD83 MOV43 INS43 UPD42 MOV43 MOV43 MOV43 INS43 INS74 INS70 INS41 MOV41 UPD74 INS42 INS74 MOV42 UPD42 MOV42 INS74 MOV43 INS43 INS44 INS42 MOV8 UPD74 INS32 MOV60 MOV43 MOV43 INS43 INS42 MOV43 INS42 MOV42 UPD42 MOV42 MOV42 INS86 INS70 UPD42 UPD42 INS21 INS70 INS42 INS74 UPD42 INS74 INS59 INS14 MOV44 INS42 MOV8 INS32 INS44 INS42 MOV8 MOV11 MOV43 UPD42 UPD42 MOV43 INS43 INS42 MOV43 MOV52 UPD42 MOV42 MOV22 MOV42 MOV42 MOV43 INS42 INS74 INS74 INS42 UPD74 UPD42 UPD42 MOV43 MOV43 MOV41 MOV32 UPD42 MOV43 MOV43 MOV32 UPD42 UPD42 INS11 UPD42 MOV43 INS42 UPD42 MOV43 INS42 INS42 DEL42 DEL43 DEL43 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL40 DEL41 DEL8 DEL25 DEL33 DEL41 DEL8 DEL31 DEL36 DEL42 DEL32 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL44 DEL33 DEL10 DEL11 DEL42 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL11 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL43 DEL14 DEL7 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL41 DEL42 DEL33 DEL27 DEL52 DEL51 DEL8 DEL25 DEL8 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL51 DEL8 DEL31 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL51 DEL8 DEL31 DEL42 DEL43 DEL66 DEL65 DEL32 DEL41 DEL83 DEL39 DEL31 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL31 DEL42 DEL11 DEL36 DEL42 DEL43 DEL42 DEL11 DEL36 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL42 DEL34 DEL27 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL41 DEL42 DEL42 DEL42 DEL2 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL24 DEL83 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL33 DEL27 DEL45 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL42 DEL52 DEL42 DEL22 DEL7 DEL21
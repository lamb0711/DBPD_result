 GEODE-6580: Cleanup static analyzer warnings. (#3415)

+
+import java.util.NoSuchElementException;
-  final HashSet missingRequiredRoles = new HashSet(); // package-private to avoid synthetic accessor
+  private final HashSet<Role> missingRequiredRoles = new HashSet<>();
-    this.initializationLatchAfterMemberTimeout =
+    initializationLatchAfterMemberTimeout =
-    this.distAdvisor = createDistributionAdvisor(internalRegionArgs);
+    distAdvisor = createDistributionAdvisor(internalRegionArgs);
-    Set reqRoles = new HashSet(attrs.getMembershipAttributes().getRequiredRoles());
+    Set<Role> reqRoles = new HashSet<>(attrs.getMembershipAttributes().getRequiredRoles());
-    this.requiresReliabilityCheck = setRequiresReliabilityCheck;
+    requiresReliabilityCheck = setRequiresReliabilityCheck;
-      this.persistenceAdvisor = internalRegionArgs.getPersistenceAdvisor();
+      persistenceAdvisor = internalRegionArgs.getPersistenceAdvisor();
-        this.persistenceAdvisor = new PersistenceAdvisorImpl(this.distAdvisor, dl, storage,
-            this.getFullPath(), diskStats, memberManager);
+        persistenceAdvisor = new PersistenceAdvisorImpl(distAdvisor, dl, storage,
+            getFullPath(), diskStats, memberManager);
-      this.persistenceAdvisor = null;
+      persistenceAdvisor = null;
-    if (this.persistenceAdvisor != null) {
-      this.persistentId = this.persistenceAdvisor.generatePersistentID();
+    if (persistenceAdvisor != null) {
+      persistentId = persistenceAdvisor.generatePersistentID();
-      this.persistentId = null;
+      persistentId = null;
-    if (!this.generateVersionTag) {
+    if (!generateVersionTag) {
-    return this.getConcurrencyChecksEnabled() && (getServerProxy() == null) && !isTX()
-        && this.scope.isDistributed() && !this.getDataPolicy().withReplication();
+    return getConcurrencyChecksEnabled() && (getServerProxy() == null) && !isTX()
+        && scope.isDistributed() && !getDataPolicy().withReplication();
-    if (this.scope.isGlobal() && // lock only applies to global scope
+    if (scope.isGlobal() && // lock only applies to global scope
-      dlock = this.getDistributedLockIfGlobal(event.getKey());
+      dlock = getDistributedLockIfGlobal(event.getKey());
-        if (this.requiresOneHopForMissingEntry(event)) {
+        if (requiresOneHopForMissingEntry(event)) {
-          if (re == null /* || re.isTombstone() */ || !this.generateVersionTag) {
-            if (!event.isBulkOpInProgress() || this.getDataPolicy().withStorage()) {
+          if (re == null /* || re.isTombstone() */ || !generateVersionTag) {
+            if (!event.isBulkOpInProgress() || getDataPolicy().withStorage()) {
-                  expectedOldValue, requireOldValue, !this.generateVersionTag);
+                  expectedOldValue, requireOldValue, !generateVersionTag);
-              if (!this.generateVersionTag && !didDistribute) {
+              if (!generateVersionTag && !didDistribute) {
-    if (this.requiresOneHopForMissingEntry(event)) {
+    if (requiresOneHopForMissingEntry(event)) {
-      if (re == null /* || re.isTombstone() */ || !this.generateVersionTag) {
+      if (re == null /* || re.isTombstone() */ || !generateVersionTag) {
-            false, !this.generateVersionTag);
-        if (!this.generateVersionTag && !didDistribute) {
+            false, !generateVersionTag);
+        if (!generateVersionTag && !didDistribute) {
-              this.getName());
+              getName());
-    boolean isDuplicate = false;
+    boolean isDuplicate;
-    return this.generateVersionTag;
+    return generateVersionTag;
-          this.generateVersionTag, this.getConcurrencyChecksEnabled(), this.getDataPolicy(), event);
+          generateVersionTag, getConcurrencyChecksEnabled(), getDataPolicy(), event);
-    if (!this.getConcurrencyChecksEnabled() || this.getDataPolicy() == DataPolicy.EMPTY
-        || !this.generateVersionTag) {
+    if (!getConcurrencyChecksEnabled() || getDataPolicy() == DataPolicy.EMPTY
+        || !generateVersionTag) {
-    if (!event.isOriginRemote() && this.getDataPolicy().withReplication()) {
+    if (!event.isOriginRemote() && getDataPolicy().withReplication()) {
-    if (!this.getDataPolicy().withReplication() && !this.getDataPolicy().withPersistence()) {
-      if (!entry.getVersionStamp().hasValidVersion()) {
-        // do not generate a version stamp in a region that has no replication if it's not based
-        // on an existing version from a replicate region
-        return false;
-      }
-      return true;
+    if (!getDataPolicy().withReplication() && !getDataPolicy().withPersistence()) {
+      // do not generate a version stamp in a region that has no replication if it's not based
+      // on an existing version from a replicate region
+      return entry.getVersionStamp().hasValidVersion();
-      if (!event.getDistributedMember().equals(this.getMyId())) {
+      if (!event.getDistributedMember().equals(getMyId())) {
-    if (this.requiresReliabilityCheck && this.isMissingRequiredRoles) {
+    if (requiresReliabilityCheck && isMissingRequiredRoles) {
-        synchronized (this.missingRequiredRoles) {
-          if (!this.isMissingRequiredRoles)
+        synchronized (missingRequiredRoles) {
+          if (!isMissingRequiredRoles)
-          Set roles = Collections.unmodifiableSet(new HashSet(this.missingRequiredRoles));
+          Set<Role> roles = Collections.unmodifiableSet(new HashSet<>(missingRequiredRoles));
-    if (this.requiresReliabilityCheck && this.isMissingRequiredRoles) {
+    if (requiresReliabilityCheck && isMissingRequiredRoles) {
-        synchronized (this.missingRequiredRoles) {
-          if (!this.isMissingRequiredRoles)
+        synchronized (missingRequiredRoles) {
+          if (!isMissingRequiredRoles)
-          Set roles = Collections.unmodifiableSet(new HashSet(this.missingRequiredRoles));
+          Set<Role> roles = Collections.unmodifiableSet(new HashSet<>(missingRequiredRoles));
-    if (this.requiresReliabilityCheck) {
+    if (requiresReliabilityCheck) {
-      Set roles = new HashSet();
+      Set<Role> roles = new HashSet<>();
-      Set failedRoles = new HashSet(ra.getRequiredRoles());
+      Set<Role> failedRoles = new HashSet<>(ra.getRequiredRoles());
-    if (this.requiresReliabilityCheck) {
+    if (requiresReliabilityCheck) {
-    return this.requiresReliabilityCheck;
+    return requiresReliabilityCheck;
-    if (this.requiresReliabilityCheck && this.isMissingRequiredRoles) {
+    if (requiresReliabilityCheck && isMissingRequiredRoles) {
-      if (getMembershipAttributes().getLossAction().isLimitedAccess()
-          && expiry.isDistributedAction()) {
-        return false;
-      }
+      return !getMembershipAttributes().getLossAction().isLimitedAccess()
+          || !expiry.isDistributedAction();
-    getDistributionManager().getWaitingThreadPool().execute(new Runnable() {
-      @Override
-      public void run() {
-        try {
-          if (ra.isReinitialize()) {
-            if (logger.isDebugEnabled()) {
-              logger.debug("Reliability resumption for action of reinitialize");
-            }
-            if (!isDestroyed() && !cache.isClosed()) {
-              RegionEventImpl event = new RegionEventImpl(DistributedRegion.this,
-                  Operation.REGION_REINITIALIZE, null, false, getMyId(), generateEventID());
-              reinitialize(null, event);
-            }
-            synchronized (missingRequiredRoles) {
-              // any number of threads may be waiting on missingRequiredRoles
-              missingRequiredRoles.notifyAll();
-              if (hasListener() && id != null) {
-                // fire afterRoleGain event
-                RoleEventImpl relEvent = new RoleEventImpl(DistributedRegion.this,
-                    Operation.REGION_CREATE, null, true, id, newlyAcquiredRoles);
-                dispatchListenerEvent(EnumListenerEvent.AFTER_ROLE_GAIN, relEvent);
-              }
+    getDistributionManager().getWaitingThreadPool().execute(() -> {
+      try {
+        if (ra.isReinitialize()) {
+          if (logger.isDebugEnabled()) {
+            logger.debug("Reliability resumption for action of reinitialize");
+          }
+          if (!isDestroyed() && !cache.isClosed()) {
+            RegionEventImpl event = new RegionEventImpl(this, Operation.REGION_REINITIALIZE, null,
+                false, getMyId(), generateEventID());
+            reinitialize(null, event);
+          }
+          synchronized (missingRequiredRoles) {
+            // any number of threads may be waiting on missingRequiredRoles
+            missingRequiredRoles.notifyAll();
+            if (hasListener() && id != null) {
+              // fire afterRoleGain event
+              RoleEventImpl relEvent = new RoleEventImpl(this, Operation.REGION_CREATE, null, true,
+                  id, newlyAcquiredRoles);
+              dispatchListenerEvent(EnumListenerEvent.AFTER_ROLE_GAIN, relEvent);
-        } catch (Exception e) {
-          logger.fatal("Unexpected exception:", e);
+      } catch (Exception e) {
+        logger.fatal("Unexpected exception:", e);
-    if (getEntryTimeToLive().getTimeout() > 0
-        && (isNoAccess || (isLimitedAccess && getEntryTimeToLive().getAction().isDistributed()))) {
+    if (getEntryTimeToLive().getTimeout() > 0 && (isNoAccess || getEntryTimeToLive().getAction()
+        .isDistributed())) {
-    } else if (getEntryIdleTimeout().getTimeout() > 0
-        && (isNoAccess || (isLimitedAccess && getEntryIdleTimeout().getAction().isDistributed()))) {
+    } else if (getEntryIdleTimeout().getTimeout() > 0 && (isNoAccess || getEntryIdleTimeout()
+        .getAction().isDistributed())) {
-    if (getRegionTimeToLive().getTimeout() > 0
-        && (isNoAccess || (isLimitedAccess && getRegionTimeToLive().getAction().isDistributed()))) {
+    if (getRegionTimeToLive().getTimeout() > 0 && (isNoAccess || getRegionTimeToLive().getAction()
+        .isDistributed())) {
-    if (getRegionIdleTimeout().getTimeout() > 0 && (isNoAccess
-        || (isLimitedAccess && getRegionIdleTimeout().getAction().isDistributed()))) {
+    if (getRegionIdleTimeout().getTimeout() > 0 && (isNoAccess || getRegionIdleTimeout().getAction()
+        .isDistributed())) {
-                RoleEventImpl relEvent = new RoleEventImpl(DistributedRegion.this,
+                RoleEventImpl relEvent = new RoleEventImpl(this,
-        synchronized (this.missingRequiredRoles) {
+        synchronized (missingRequiredRoles) {
-          this.missingRequiredRoles.notifyAll();
+          missingRequiredRoles.notifyAll();
-            RoleEventImpl relEvent = new RoleEventImpl(DistributedRegion.this,
+            RoleEventImpl relEvent = new RoleEventImpl(this,
-  void lockCheckReadiness() { // package-private to avoid synthetic accessor
-    // fix for bug 32610
-    this.cache.getCancelCriterion().checkCancelInProgress(null);
+  private void lockCheckReadiness() {
+    cache.getCancelCriterion().checkCancelInProgress(null);
-    Lock dlock = this.getDistributedLockIfGlobal(key);
+    Lock dlock = getDistributedLockIfGlobal(key);
-        this.getLockService().freeResources(key);
+        getLockService().freeResources(key);
-        this.getLockService().freeResources(key);
+        getLockService().freeResources(key);
-    Lock dlock = this.getDistributedLockIfGlobal(key);
+    Lock dlock = getDistributedLockIfGlobal(key);
-    if (!this.scope.isGlobal()) {
+    if (!scope.isGlobal()) {
-              this.scope));
+              scope));
-    if (!this.scope.isGlobal()) {
+    if (!scope.isGlobal()) {
-              this.scope));
+              scope));
-      for (GatewaySender sender : this.cache.getAllGatewaySenders()) {
+      for (GatewaySender sender : cache.getAllGatewaySenders()) {
-                    this.getFullPath()));
+                    getFullPath()));
-                    sender.getId(), this.getFullPath()));
+                    sender.getId(), getFullPath()));
-    if (this.scope.isGlobal()) {
+    if (scope.isGlobal()) {
-        this.handleDiskAccessException(dae, true);
+        handleDiskAccessException(dae, true);
-      this.isInitializingThread = false;
+      isInitializingThread = false;
-        this.getName());
+        getName());
-              new Object[] {true, snapshotInputStream}));
+              true, snapshotInputStream));
-    if (this.getDataPolicy().withPersistence()) {
+    if (getDataPolicy().withPersistence()) {
-    if (this.getDataPolicy().withPersistence()) {
-      recovered_rvv = this.getVersionVector() == null ? null
-          : this.getVersionVector().getCloneForTransmission();
+    if (getDataPolicy().withPersistence()) {
+      recovered_rvv = getVersionVector() == null ? null
+          : getVersionVector().getCloneForTransmission();
-    if (this.persistenceAdvisor != null) {
-      this.persistenceAdvisor.initialize();
+    if (persistenceAdvisor != null) {
+      persistenceAdvisor.initialize();
-      if (!this.isDestroyed) {
-        this.cache.getInternalResourceManager().addResourceListener(ResourceType.MEMORY, this);
+      if (!isDestroyed) {
+        cache.getInternalResourceManager().addResourceListener(ResourceType.MEMORY, this);
-      } catch (IOException e) {
-        throw new RuntimeException(e); // TODO: change this exception?
-      } catch (ClassNotFoundException e) {
-        throw new RuntimeException(e); // TODO: change this exception?
+      } catch (IOException | ClassNotFoundException e) {
+        throw new RuntimeException(e);
-    InitialImageOperation iiop = new InitialImageOperation(this, this.entries);
+    InitialImageOperation iiop = new InitialImageOperation(this, entries);
-    boolean done = false;
-    while (!done && !isDestroyed()) {
+    while (!isDestroyed()) {
-          || this.getDataPolicy().withPreloaded() && !advice.preloaded.isEmpty() // this is a
-                                                                                 // preloaded
+          || getDataPolicy().withPreloaded() && !advice.preloaded.isEmpty() // this is a
+                                                                            // preloaded
-                this.giiMissingRequiredRoles = false;
+                giiMissingRequiredRoles = false;
-                done = true;
-            done = true;
-          if (this.getDataPolicy().isPreloaded()) {
+          if (getDataPolicy().isPreloaded()) {
-              done = true;
-                new Object[] {this.getFullPath(), persistentId, getPersistentID()});
+                getFullPath(), persistentId, getPersistentID());
-              RegionLogger.logRecovery(this.getFullPath(), persistentId,
+              RegionLogger.logRecovery(getFullPath(), persistentId,
-            RegionLogger.logCreate(this.getFullPath(),
+            RegionLogger.logCreate(getFullPath(),
-              RegionLogger.logPersistence(this.getFullPath(),
+              RegionLogger.logPersistence(getFullPath(),
-                  new Object[] {this.getFullPath(), getPersistentID()});
+                  new Object[] {getFullPath(), getPersistentID()});
-          done = true;
-    if (!this.getConcurrencyChecksEnabled()) {
+    if (!getConcurrencyChecksEnabled()) {
-    InitialImageOperation op = new InitialImageOperation(this, this.entries);
+    InitialImageOperation op = new InitialImageOperation(this, entries);
-        if (this.indexManager != null) {
+        if (indexManager != null) {
-            this.indexManager.rerunIndexCreationQuery();
+            indexManager.rerunIndexCreationQuery();
-  void unlockFailedInitialImageReadLock() {
+  private void unlockFailedInitialImageReadLock() {
-    synchronized (this.advisorListener) {
+    synchronized (advisorListener) {
-      Set others = this.distAdvisor.addMembershipListenerAndAdviseGeneric(this.advisorListener);
-      this.advisorListener.addMembers(others);
+      Set<InternalDistributedMember> others =
+          distAdvisor.addMembershipListenerAndAdviseGeneric(advisorListener);
+      advisorListener.addMembers(others);
-        synchronized (this.missingRequiredRoles) {
-          this.missingRequiredRoles.addAll(getMembershipAttributes().getRequiredRoles());
+        synchronized (missingRequiredRoles) {
+          missingRequiredRoles.addAll(getMembershipAttributes().getRequiredRoles());
-          this.missingRequiredRoles.removeAll(getSystem().getDistributedMember().getRoles());
+          missingRequiredRoles.removeAll(getSystem().getDistributedMember().getRoles());
-            this.missingRequiredRoles.removeAll(other.getRoles());
+            missingRequiredRoles.removeAll(other.getRoles());
-        if (this.giiMissingRequiredRoles) {
+        if (giiMissingRequiredRoles) {
-          this.isInitializingThread = true;
-          synchronized (this.advisorListener) {
-            synchronized (this.missingRequiredRoles) {
+          isInitializingThread = true;
+          synchronized (advisorListener) {
+            synchronized (missingRequiredRoles) {
-              this.isMissingRequiredRoles = true;
+              isMissingRequiredRoles = true;
-              this.isInitializingThread = true;
+              isInitializingThread = true;
-              if (this.missingRequiredRoles.isEmpty()) {
+              if (missingRequiredRoles.isEmpty()) {
-                this.isMissingRequiredRoles = false;
+                isMissingRequiredRoles = false;
-                  this.advisorListener.destroyed = true;
+                  advisorListener.destroyed = true;
-          synchronized (this.advisorListener) {
-            synchronized (this.missingRequiredRoles) {
-              if (this.missingRequiredRoles.isEmpty()) {
-                Assert.assertTrue(!this.isMissingRequiredRoles);
+          synchronized (advisorListener) {
+            synchronized (missingRequiredRoles) {
+              if (missingRequiredRoles.isEmpty()) {
+                Assert.assertTrue(!isMissingRequiredRoles);
-                this.isMissingRequiredRoles = true;
+                isMissingRequiredRoles = true;
-                      this.missingRequiredRoles);
+                      missingRequiredRoles);
-                this.isInitializingThread = true;
+                isInitializingThread = true;
-        if (this.isInitializingThread) {
+        if (isInitializingThread) {
-    this.initializationLatchAfterMemberTimeout.countDown();
+    initializationLatchAfterMemberTimeout.countDown();
-      Iterator/* <Object> */ keysIt = getImageState().getDestroyedEntries();
+      Iterator<Object> keysIt = getImageState().getDestroyedEntries();
-        this.entries.removeIfDestroyed(keysIt.next());
+        entries.removeIfDestroyed(keysIt.next());
-      if (this.persistenceAdvisor != null) {
-        this.persistenceAdvisor.setOnline(GIIStatus.didGII(giiStatus), false, getPersistentID());
+      if (persistenceAdvisor != null) {
+        persistenceAdvisor.setOnline(GIIStatus.didGII(giiStatus), false, getPersistentID());
-    logger.info("Initialization of region {} completed", this.getName());
+    logger.info("Initialization of region {} completed", getName());
-      if (this.requiresOneHopForMissingEntry(event)) {
+      if (requiresOneHopForMissingEntry(event)) {
-        if (re == null /* || re.isTombstone() */ || !this.generateVersionTag) {
+        if (re == null /* || re.isTombstone() */ || !generateVersionTag) {
-            Assert.assertTrue(!this.getDataPolicy().withReplication() || !this.generateVersionTag);
+            Assert.assertTrue(!getDataPolicy().withReplication() || !generateVersionTag);
-          if (!event.isBulkOpInProgress() || this.getDataPolicy().withStorage()) {
+          if (!event.isBulkOpInProgress() || getDataPolicy().withStorage()) {
-                RemoteDestroyMessage.distribute(event, expectedOldValue, !this.generateVersionTag);
+                RemoteDestroyMessage.distribute(event, expectedOldValue, !generateVersionTag);
-            if (!this.generateVersionTag && !didDistribute) {
+            if (!generateVersionTag && !didDistribute) {
-      if (this.scope.isGlobal() && event.isOriginRemote()) {
+      if (scope.isGlobal() && event.isOriginRemote()) {
-      if (this.scope.isGlobal()) {
+      if (scope.isGlobal()) {
-      this.cache.beginDestroy(path, this);
+      cache.beginDestroy(path, this);
-        this.cache.endDestroy(path, this);
+        cache.endDestroy(path, this);
-    if (this.persistenceAdvisor != null) {
-      this.persistenceAdvisor.releaseTieLock();
+    if (persistenceAdvisor != null) {
+      persistenceAdvisor.releaseTieLock();
-      if (this.requiresOneHopForMissingEntry(event)) {
+      if (requiresOneHopForMissingEntry(event)) {
-        if (re == null/* || re.isTombstone() */ || !this.generateVersionTag) {
+        if (re == null/* || re.isTombstone() */ || !generateVersionTag) {
-            Assert.assertTrue(!this.getDataPolicy().withReplication() || !this.generateVersionTag);
+            Assert.assertTrue(!getDataPolicy().withReplication() || !generateVersionTag);
-              RemoteInvalidateMessage.distribute(event, !this.generateVersionTag);
-          if (!this.generateVersionTag && !didDistribute) {
+              RemoteInvalidateMessage.distribute(event, !generateVersionTag);
+          if (!generateVersionTag && !didDistribute) {
-    if (!this.isRegionInvalid() && event.isDistributed() && !event.isOriginRemote()
+    if (!isRegionInvalid() && event.isDistributed() && !event.isOriginRemote()
-    if (!this.isRegionInvalid() && event.isDistributed() && !event.isOriginRemote()
+    if (!isRegionInvalid() && event.isDistributed() && !event.isOriginRemote()
-    Lock dlock = this.getRegionDistributedLockIfGlobal();
+    Lock dlock = getRegionDistributedLockIfGlobal();
-    if (this.getConcurrencyChecksEnabled() && !this.getDataPolicy().withReplication()) {
+    if (getConcurrencyChecksEnabled() && !getDataPolicy().withReplication()) {
-        Set<InternalDistributedMember> repls = this.distAdvisor.adviseReplicates();
+        Set<InternalDistributedMember> repls = distAdvisor.adviseReplicates();
-    boolean enableRVV = useRVV && this.getDataPolicy().withReplication()
-        && this.getConcurrencyChecksEnabled() && !getDistributionManager().isLoner();
+    boolean enableRVV = useRVV && getDataPolicy().withReplication()
+        && getConcurrencyChecksEnabled() && !getDistributionManager().isLoner();
-    synchronized (this.clearLock) {
+    synchronized (clearLock) {
-    if (!this.scope.isGlobal()) { // non-global regions must lock when using RVV
+    if (!scope.isGlobal()) { // non-global regions must lock when using RVV
-    if (!this.scope.isGlobal()) {
+    if (!scope.isGlobal()) {
-      if (this.getAttributes().getScope().isDistributedNoAck()) {
+      if (getAttributes().getScope().isDistributedNoAck()) {
-      synchronized (this.clearLock) {
+      synchronized (clearLock) {
-    this.getCachePerfStats().incTombstoneGCCount();
+    getCachePerfStats().incTombstoneGCCount();
-    return this.distAdvisor;
+    return distAdvisor;
-    return this.distAdvisor;
+    return distAdvisor;
-    return this.persistenceAdvisor;
+    return persistenceAdvisor;
-    return this.persistentId;
+    return persistentId;
-    return this.distAdvisor.createProfile();
+    return distAdvisor.createProfile();
-    Assert.assertTrue(this.scope.isDistributed());
-    cacheProfile.scope = this.scope;
+    Assert.assertTrue(scope.isDistributed());
+    cacheProfile.scope = scope;
-    cacheProfile.hasCacheServer = this.cache.getCacheServers().size() > 0 ? true : false;
-    cacheProfile.requiresOldValueInEvents = this.getDataPolicy().withReplication()
-        && this.filterProfile != null && this.filterProfile.hasCQs();
+    cacheProfile.hasCacheServer = !cache.getCacheServers().isEmpty();
+    cacheProfile.requiresOldValueInEvents = getDataPolicy().withReplication()
+        && filterProfile != null && filterProfile.hasCQs();
-    synchronized (this.dlockMonitor) {
+    synchronized (dlockMonitor) {
-      if (this.dlockService == null) {
-        this.dlockService = DistributedLockService.getServiceNamed(dlsName);
-        if (this.dlockService == null) {
+      if (dlockService == null) {
+        dlockService = DistributedLockService.getServiceNamed(dlsName);
+        if (dlockService == null) {
-          this.dlockService = DLockService.create(getFullPath(), getSystem(), true, false, false);
+          dlockService = DLockService.create(getFullPath(), getSystem(), true, false, false);
-        if (this.isLockGrantor) {
-          this.dlockService.becomeLockGrantor();
+        if (isLockGrantor) {
+          dlockService.becomeLockGrantor();
-      return this.dlockService;
+      return dlockService;
-    return this.scope.isGlobal() && getLockService().isLockGrantor();
+    return scope.isGlobal() && getLockService().isLockGrantor();
-    return this.scope.isGlobal() && this.isLockGrantor;
+    return scope.isGlobal() && isLockGrantor;
-    if (!this.scope.isGlobal()) {
+    if (!scope.isGlobal()) {
-              this.scope));
+              scope));
-    final boolean disabled = this.entries.disableLruUpdateCallback();
+    final boolean disabled = entries.disableLruUpdateCallback();
-        synchronized (re) { // bug #51059 value & version must be obtained atomically
+        synchronized (re) {
+          // value & version must be obtained atomically
-        this.entries.enableLruUpdateCallback();
+        entries.enableLruUpdateCallback();
-        this.entries.lruUpdateCallback();
+        entries.lruUpdateCallback();
-        this.handleDiskAccessException(dae);
+        handleDiskAccessException(dae);
-      Set netWriteRecipients = localWriter == null ? this.distAdvisor.adviseNetWrite() : null;
+      Set netWriteRecipients = localWriter == null ? distAdvisor.adviseNetWrite() : null;
-      Set netWriteRecipients = localWriter == null ? this.distAdvisor.adviseNetWrite() : null;
+      Set netWriteRecipients = localWriter == null ? distAdvisor.adviseNetWrite() : null;
-      synchronized (this.missingRequiredRoles) {
-        this.missingRequiredRoles.notifyAll();
+      synchronized (missingRequiredRoles) {
+        missingRequiredRoles.notifyAll();
-    if (this.persistenceAdvisor != null) {
-      this.persistenceAdvisor.close(); // fix for bug 41094
+    if (persistenceAdvisor != null) {
+      persistenceAdvisor.close(); // fix for bug 41094
-    this.distAdvisor.close();
+    distAdvisor.close();
-    synchronized (this.dlockMonitor) {
-      if (this.dlockService != null) {
-        dls = (DLockService) this.dlockService;
+    synchronized (dlockMonitor) {
+      if (dlockService != null) {
+        dls = (DLockService) dlockService;
-            this.getFullPath(),
+            getFullPath(),
-  protected void waitForCurrentOperations() {
+  private void waitForCurrentOperations() {
-    if (!this.cache.forcedDisconnect() && flushOnClose
-        && this.getDistributionManager().getMembershipManager() != null
-        && this.getDistributionManager().getMembershipManager().isConnected()) {
+    if (!cache.forcedDisconnect() && flushOnClose
+        && getDistributionManager().getMembershipManager() != null
+        && getDistributionManager().getMembershipManager().isConnected()) {
-        logger.warn(String.format("%s: error closing region %s",
-            new Object[] {this, getFullPath()}), e);
+        logger.warn(String.format("%s: error closing region %s", this, getFullPath()), e);
-    synchronized (this.advisorListener) {
-      Set others = this.advisorListener.getInitialMembers();
+    synchronized (advisorListener) {
+      Set<InternalDistributedMember> others = advisorListener.getInitialMembers();
-              DistributedMember[] otherDms = new DistributedMember[others.size()];
-              others.toArray(otherDms);
+              DistributedMember[] otherDms = others.toArray(new DistributedMember[0]);
-      this.advisorListener.initRMLWrappers();
+      advisorListener.initRMLWrappers();
-        this.getCacheDistributionAdvisor().adviseSameGatewaySenderIds(getGatewaySenderIds());
+        getCacheDistributionAdvisor().adviseSameGatewaySenderIds(getGatewaySenderIds());
-              new Object[] {this.getName(), senderIds.get(0), senderIds.get(1)}));
+              getName(), senderIds.get(0), senderIds.get(1)));
-    List<Set<String>> asycnQueueIds = this.getCacheDistributionAdvisor()
+    List<Set<String>> asycnQueueIds = getCacheDistributionAdvisor()
-              new Object[] {this.getName(), asycnQueueIds.get(0), asycnQueueIds.get(1)}));
+              getName(), asycnQueueIds.get(0), asycnQueueIds.get(1)));
-        this.cache.getCancelCriterion().checkCancelInProgress(null);
+        cache.getCancelCriterion().checkCancelInProgress(null);
-          this.cache.getCancelCriterion().checkCancelInProgress(ex);
+          cache.getCancelCriterion().checkCancelInProgress(ex);
-    DiskRegion dr = this.getDiskRegion();
+    DiskRegion dr = getDiskRegion();
-    return this.entries.regionEntries().iterator();
+    return entries.regionEntries().iterator();
-      if (this.subIt != null) {
-        result = this.subIt.hasNext();
+      if (subIt != null) {
+        result = subIt.hasNext();
-          this.subIt = null;
+          subIt = null;
-      result = this.it.hasNext();
-      if (this.usingIt && !result) {
-        this.usingIt = false;
-        this.it = this.diskMap.values().iterator();
-        result = this.it.hasNext();
+      result = it.hasNext();
+      if (usingIt && !result) {
+        usingIt = false;
+        it = diskMap.values().iterator();
+        result = it.hasNext();
-        if (this.subIt != null) {
-          return this.subIt.next();
+        if (subIt != null) {
+          return subIt.next();
-        if (this.usingIt) {
-          RegionEntry regionEntry = (RegionEntry) this.it.next();
+        if (usingIt) {
+          RegionEntry regionEntry = (RegionEntry) it.next();
-            Object value = this.diskMap.get(dPage);
+            Object value = diskMap.get(dPage);
-              this.diskMap.put(dPage, regionEntry);
+              diskMap.put(dPage, regionEntry);
-              List list = (List) value;
+              List<Object> list = (ArrayList<Object>) value;
-              List list = new ArrayList();
+              List<Object> list = new ArrayList<>();
-              this.diskMap.put(dPage, list);
+              diskMap.put(dPage, list);
-              assert false; // must be true
+              throw new NoSuchElementException();
-          Object value = this.it.next();
+          Object value = it.next();
-            List list = (List) value;
-            this.subIt = list.iterator();
-            return this.subIt.next();
+            List<RegionEntry> list = (List<RegionEntry>) value;
+            subIt = list.iterator();
+            return subIt.next();
-      return Long.valueOf(this.oplogId ^ this.offset).hashCode();
+      return Long.valueOf(oplogId ^ offset).hashCode();
-        return this.oplogId == other.oplogId && this.offset == other.offset;
+        return oplogId == other.oplogId && offset == other.offset;
-      int result = Long.signum(this.oplogId - o.oplogId);
+      int result = Long.signum(oplogId - o.oplogId);
-        result = Long.signum(this.offset - o.offset);
+        result = Long.signum(offset - o.offset);
-      StringBuilder sb = new StringBuilder();
-      sb.append('<').append(this.oplogId).append(':').append(this.offset).append('>');
-      return sb.toString();
+      return "<" + oplogId + ':' + offset + '>';
-      this.setPosition(diskPosition.oplogId, diskPosition.offset / DISK_PAGE_SIZE);
+      setPosition(diskPosition.oplogId, diskPosition.offset / DISK_PAGE_SIZE);
-  long getLockLeaseForLock() { // package-private to avoid synthetic accessor
+  private long getLockLeaseForLock() { // package-private to avoid synthetic accessor
-  long getLockTimeoutForLock(long time, TimeUnit unit) { // package-private to avoid synthetic
-                                                         // accessor
+  private long getLockTimeoutForLock(long time, TimeUnit unit) { // package-private to avoid
+                                                                 // synthetic
+    // accessor
-        return getLockService().lock(this.key, 0, getLockLeaseForLock());
+        return getLockService().lock(key, 0, getLockLeaseForLock());
-                getLockService().lockInterruptibly(this.key, waitInterval, getLockLeaseForLock());
+                getLockService().lockInterruptibly(key, waitInterval, getLockLeaseForLock());
-            gotLock = getLockService().lock(this.key, waitInterval, getLockLeaseForLock());
+            gotLock = getLockService().lock(key, waitInterval, getLockLeaseForLock());
-        getLockService().unlock(this.key);
-        if (!DistributedRegion.this.entries.containsKey(this.key)) {
-          getLockService().freeResources(this.key);
+        getLockService().unlock(key);
+        if (!entries.containsKey(key)) {
+          getLockService().freeResources(key);
-      throw new UnsupportedOperationException(
-          "newCondition unsupported");
+      throw new UnsupportedOperationException("newCondition unsupported");
-    Lock dlock = this.getRegionDistributedLockIfGlobal();
+    Lock dlock = getRegionDistributedLockIfGlobal();
-    Lock dlock = this.getRegionDistributedLockIfGlobal();
+    Lock dlock = getRegionDistributedLockIfGlobal();
-    if (!this.isMissingRequiredRoles) { // should we delete this check?
+    if (!isMissingRequiredRoles) { // should we delete this check?
-        while (this.isMissingRequiredRoles) {
+        while (isMissingRequiredRoles) {
-          this.cache.getCancelCriterion().checkCancelInProgress(null);
-          synchronized (this.missingRequiredRoles) {
+          cache.getCancelCriterion().checkCancelInProgress(null);
+          synchronized (missingRequiredRoles) {
-            if (this.isMissingRequiredRoles) {
+            if (isMissingRequiredRoles) {
-              this.missingRequiredRoles.wait(); // spurious wakeup ok
+              missingRequiredRoles.wait(); // spurious wakeup ok
-        while (this.isMissingRequiredRoles) {
+        while (isMissingRequiredRoles) {
-          this.cache.getCancelCriterion().checkCancelInProgress(null);
-          synchronized (this.missingRequiredRoles) {
+          cache.getCancelCriterion().checkCancelInProgress(null);
+          synchronized (missingRequiredRoles) {
-            if (this.isMissingRequiredRoles) {
+            if (isMissingRequiredRoles) {
-                this.missingRequiredRoles.wait(timeToWait); // spurious wakeup ok
+                missingRequiredRoles.wait(timeToWait); // spurious wakeup ok
-    if (this.isMissingRequiredRoles) {
+    if (isMissingRequiredRoles) {
-      synchronized (this.missingRequiredRoles) {
-        return Collections.unmodifiableSet(new HashSet<>(this.missingRequiredRoles));
+      synchronized (missingRequiredRoles) {
+        return Collections.unmodifiableSet(new HashSet<>(missingRequiredRoles));
-    for (DistributedMember member : this.distAdvisor.adviseGeneric()) {
+    for (DistributedMember member : distAdvisor.adviseGeneric()) {
-    synchronized (this.advisorListener) {
-      if (this.advisorListener.members == null && hasListener()) {
+    synchronized (advisorListener) {
+      if (advisorListener.members == null && hasListener()) {
-    Set members = new HashSet(); // package-private to avoid synthetic accessor
+    Set<InternalDistributedMember> members = new HashSet<>(); // package-private to avoid synthetic
+                                                              // accessor
-    synchronized void addMembers(Set newMembers) {
-      this.members.addAll(newMembers);
+    synchronized void addMembers(Set<InternalDistributedMember> newMembers) {
+      members.addAll(newMembers);
-    protected synchronized Set getInitialMembers() {
-      Set initMembers = this.members;
-      this.members = null;
+    protected synchronized Set<InternalDistributedMember> getInitialMembers() {
+      Set<InternalDistributedMember> initMembers = members;
+      members = null;
-          DistributedRegion.this.distAdvisor.adviseGeneric();
+          distAdvisor.adviseGeneric();
-      if (this.destroyed) {
+      if (destroyed) {
-      if (this.members != null) {
-        this.members.add(id);
+      if (members != null) {
+        members.add(id);
-        Set newlyAcquiredRoles = Collections.emptySet();
+        Set<Role> newlyAcquiredRoles = Collections.emptySet();
-            Set roles = id.getRoles();
-            newlyAcquiredRoles = new HashSet(missingRequiredRoles);
+            Set<Role> roles = id.getRoles();
+            newlyAcquiredRoles = new HashSet<>(missingRequiredRoles);
-              if (this.members == null && missingRequiredRoles.isEmpty()) {
+              if (members == null && missingRequiredRoles.isEmpty()) {
-                  this.destroyed = true;
+                  destroyed = true;
-          if (!this.destroyed) {
+          if (!destroyed) {
-        if (!this.destroyed && this.members == null && hasListener()) {
+        if (!destroyed && members == null && hasListener()) {
-      if (this.destroyed) {
+      if (destroyed) {
-      if (this.members != null) {
-        this.members.remove(id);
+      if (members != null) {
+        members.remove(id);
-      if (this.members == null && hasListener()) {
+      if (members == null && hasListener()) {
-        Set newlyMissingRoles = Collections.emptySet();
+        Set<Role> newlyMissingRoles = Collections.emptySet();
-          Set roles = id.getRoles();
-          for (Iterator iter = roles.iterator(); iter.hasNext();) {
-            Role role = (Role) iter.next();
+          Set<Role> roles = id.getRoles();
+          for (Role role : roles) {
-              if (newlyMissingRoles == Collections.emptySet()) {
-                newlyMissingRoles = new HashSet();
+              if (newlyMissingRoles.isEmpty()) {
+                newlyMissingRoles = new HashSet<>();
-              if (this.members == null && !isMissingRequiredRoles) {
+              if (members == null && !isMissingRequiredRoles) {
-                if (getMembershipAttributes().getLossAction().isAllAccess())
+                if (getMembershipAttributes().getLossAction().isAllAccess()) {
-                else if (getMembershipAttributes().getLossAction().isLimitedAccess())
+                } else if (getMembershipAttributes().getLossAction().isLimitedAccess()) {
-                else if (getMembershipAttributes().getLossAction().isNoAccess())
+                } else if (getMembershipAttributes().getLossAction().isNoAccess()) {
+                }
-                  this.destroyed = true;
+                  destroyed = true;
-          if (!this.destroyed) {
+          if (!destroyed) {
-        if (!this.destroyed && this.members == null && hasListener()) {
+        if (!destroyed && members == null && hasListener()) {
-    assert !this.isInternalRegion() || this.isMetaRegionWithTransactions();
-    if (!this.getAttributes().getDataPolicy().withStorage() || (this.getConcurrencyChecksEnabled()
-        && this.getAttributes().getDataPolicy() == DataPolicy.NORMAL)) {
+    assert !isInternalRegion() || isMetaRegionWithTransactions();
+    if (!getAttributes().getDataPolicy().withStorage() || (getConcurrencyChecksEnabled()
+        && getAttributes().getDataPolicy() == DataPolicy.NORMAL)) {
-    if (this.getConcurrencyChecksEnabled() && !generateVersionTag) {
+    if (getConcurrencyChecksEnabled() && !generateVersionTag) {
-    } else if (this.getAttributes().getDataPolicy().withReplication()
-        || this.getAttributes().getDataPolicy().withPreloaded()) {
+    } else if (getAttributes().getDataPolicy().withReplication()
+        || getAttributes().getDataPolicy().withPreloaded()) {
-    final Set singleMember = Collections.singleton(target);
+    final Set<InternalDistributedMember> singleMember =
+        Collections.singleton((InternalDistributedMember) target);
-    HashMap<InternalDistributedMember, Object> memberArgs =
-        new HashMap<InternalDistributedMember, Object>();
+    HashMap<InternalDistributedMember, Object> memberArgs = new HashMap<>();
-        new DistributedRegionFunctionResultWaiter(this.getSystem(), this.getFullPath(), rc,
+        new DistributedRegionFunctionResultWaiter(getSystem(), getFullPath(), rc,
-    public GetRandomReplicate() {}
+    GetRandomReplicate() {}
-    public GetRandomReplicate(boolean onlyPersistent) {
+    GetRandomReplicate(boolean onlyPersistent) {
-      if (this.randIndex < 0) {
-        this.randIndex = PartitionedRegion.RANDOM.nextInt(numProfiles);
+      if (randIndex < 0) {
+        randIndex = PartitionedRegion.RANDOM.nextInt(numProfiles);
-        if (profileIndex >= this.randIndex) {
-          return false;
-        }
+        return profileIndex < randIndex;
-  public InternalDistributedMember getRandomReplicate() {
+  private InternalDistributedMember getRandomReplicate() {
-    this.getCacheDistributionAdvisor().accept(getReplicate, null);
+    getCacheDistributionAdvisor().accept(getReplicate, null);
-  public InternalDistributedMember getRandomPersistentReplicate() {
+  private InternalDistributedMember getRandomPersistentReplicate() {
-    this.getCacheDistributionAdvisor().accept(getPersistentReplicate, null);
+    getCacheDistributionAdvisor().accept(getPersistentReplicate, null);
-  ResultCollector executeLocally(final DistributedRegionFunctionExecutor execution,
-      final Function function, final Object args, int prid, final ResultCollector rc,
-      final Set filter, final ServerToClientFunctionResultSender sender) {
+  private ResultCollector executeLocally(final DistributedRegionFunctionExecutor execution,
+      final Function function, final Object args, int prid,
+      final ResultCollector rc,
+      final Set filter,
+      final ServerToClientFunctionResultSender sender) {
-        DistributedRegion.this, args, filter, null, null, resultSender, execution.isReExecute());
+        this, args, filter, null, null, resultSender, execution.isReExecute());
-    synchronized (this.memoryThresholdReachedMembers) {
-      this.memoryThresholdReachedMembers.remove(member);
-      if (this.memoryThresholdReachedMembers.isEmpty()) {
+    synchronized (memoryThresholdReachedMembers) {
+      memoryThresholdReachedMembers.remove(member);
+      if (memoryThresholdReachedMembers.isEmpty()) {
-    synchronized (this.memoryThresholdReachedMembers) {
-      if (this.memoryThresholdReachedMembers.isEmpty()) {
+    synchronized (memoryThresholdReachedMembers) {
+      if (memoryThresholdReachedMembers.isEmpty()) {
-      this.memoryThresholdReachedMembers.add(idm);
+      memoryThresholdReachedMembers.add(idm);
-          new HashSet<DistributedMember>(memoryThresholdReachedMembers));
+          new HashSet<>(memoryThresholdReachedMembers));
-    assert this.getDataPolicy() != DataPolicy.REPLICATE;
+    assert getDataPolicy() != DataPolicy.REPLICATE;
-    return this.hasNetLoader(getCacheDistributionAdvisor());
+    return hasNetLoader(getCacheDistributionAdvisor());
-    LatestLastAccessTimeOperation op = new LatestLastAccessTimeOperation(this, key);
+    LatestLastAccessTimeOperation op = new LatestLastAccessTimeOperation<>(this, key);

INS26 MOV31 INS40 MOV31 INS31 MOV31 MOV31 INS83 INS74 MOV8 MOV29 UPD83 UPD42 MOV44 MOV44 MOV43 INS8 MOV8 MOV83 MOV39 MOV42 MOV8 MOV78 UPD42 MOV44 MOV78 INS83 UPD42 MOV44 MOV44 MOV43 INS83 MOV78 MOV43 MOV43 MOV78 UPD83 INS83 INS83 UPD83 UPD83 INS83 MOV43 INS43 MOV41 MOV60 INS21 MOV21 MOV21 MOV78 MOV78 UPD39 UPD42 UPD39 UPD42 INS74 INS74 UPD42 MOV42 INS74 INS74 INS42 INS42 INS42 INS42 INS27 INS32 UPD27 MOV27 UPD27 MOV27 UPD27 MOV27 INS8 MOV12 MOV12 MOV43 MOV43 MOV43 MOV38 MOV43 INS42 MOV38 INS27 MOV27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS41 MOV43 MOV43 INS42 INS42 INS43 INS43 INS74 INS43 INS43 INS25 MOV25 INS74 MOV43 INS42 INS42 MOV43 INS43 INS42 INS42 MOV43 INS43 INS42 INS42 INS42 MOV41 INS42 INS42 INS42 INS42 INS42 INS42 MOV25 MOV32 INS42 INS86 MOV27 UPD27 MOV27 MOV27 MOV27 INS25 INS42 INS42 INS42 INS42 INS38 MOV32 MOV38 MOV38 INS42 INS42 INS38 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS74 INS43 INS43 MOV42 INS42 INS74 INS42 MOV8 INS42 INS43 INS43 INS42 INS42 INS74 INS42 INS42 INS42 MOV32 INS74 INS74 UPD27 MOV27 MOV8 UPD27 MOV27 UPD27 UPD27 MOV38 INS8 MOV8 INS42 INS42 INS42 MOV43 INS42 MOV43 INS42 INS74 INS74 MOV38 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 MOV43 MOV43 INS42 INS74 INS42 INS42 INS42 INS45 INS42 INS13 INS42 INS13 INS41 INS21 INS25 INS42 INS43 INS42 INS42 INS42 INS43 INS43 INS42 INS42 INS42 INS42 MOV32 MOV42 INS42 INS11 UPD74 MOV43 INS42 INS41 INS74 INS43 INS42 INS42 INS42 INS42 MOV43 INS43 MOV43 INS43 INS38 INS38 UPD42 UPD27 UPD42 UPD42 INS60 MOV21 MOV21 MOV43 MOV43 INS42 INS42 INS42 INS42 INS43 INS43 INS42 MOV43 INS43 INS42 INS42 INS42 INS42 INS42 MOV32 UPD42 MOV42 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS42 INS42 INS32 INS32 INS38 INS8 MOV32 MOV42 INS42 INS42 INS42 INS74 INS42 INS74 INS8 INS43 INS42 INS27 INS42 INS42 INS42 INS42 MOV43 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS74 UPD42 MOV42 INS74 MOV32 MOV32 UPD42 MOV43 INS59 INS42 INS42 INS9 INS42 INS84 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV27 MOV27 INS42 MOV42 INS42 INS42 INS32 MOV32 MOV32 INS32 MOV32 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 UPD42 MOV42 INS42 INS34 MOV32 INS32 UPD42 MOV42 INS42 INS32 INS21 INS42 INS42 INS40 INS42 MOV43 INS43 MOV32 INS42 MOV43 MOV43 MOV60 INS70 MOV25 MOV32 INS42 INS42 MOV42 INS42 UPD74 INS43 INS43 INS42 INS14 MOV43 MOV43 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV42 MOV42 INS42 INS42 MOV43 MOV43 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS14 INS42 UPD42 MOV42 INS74 INS44 INS42 INS8 INS42 INS42 INS74 INS74 MOV42 MOV42 MOV43 INS45 INS86 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS42 INS42 INS74 INS42 INS60 INS42 INS42 INS42 MOV43 MOV43 INS43 INS42 MOV25 INS42 INS42 INS42 INS42 INS42 INS42 MOV43 INS43 INS42 MOV43 INS43 INS8 INS42 INS42 INS42 INS42 INS42 INS52 INS32 MOV43 MOV43 INS42 INS74 INS43 INS74 MOV59 UPD42 MOV42 MOV42 INS42 INS42 INS42 INS42 INS54 MOV43 INS42 INS42 INS42 MOV42 INS42 INS53 MOV43 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV43 INS43 INS74 INS42 INS74 INS42 INS8 MOV12 MOV32 INS32 INS42 MOV32 MOV32 INS42 INS42 INS42 INS42 INS42 INS14 UPD42 MOV42 INS74 INS42 INS42 MOV32 INS42 INS74 INS32 INS43 INS43 MOV21 MOV21 MOV21 INS51 MOV43 MOV42 INS42 MOV5 INS42 INS74 INS74 INS43 MOV43 INS43 MOV42 INS43 UPD42 MOV42 UPD42 MOV42 MOV42 MOV42 INS42 INS8 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 MOV43 INS43 MOV43 INS43 INS42 INS42 UPD42 MOV42 INS42 MOV42 INS42 INS42 INS8 INS42 MOV43 INS21 INS25 INS42 MOV5 MOV42 UPD42 MOV42 INS3 INS42 INS42 INS74 INS42 INS74 MOV14 INS21 INS8 INS42 INS32 MOV27 INS8 INS42 INS42 INS42 MOV5 INS34 INS43 INS43 MOV43 INS42 MOV32 INS21 INS8 MOV43 INS42 INS42 INS60 MOV21 INS42 INS42 INS42 INS42 MOV32 INS21 INS42 MOV43 INS59 INS40 INS42 MOV32 INS42 INS14 MOV43 INS52 INS40 INS33 INS9 INS42 INS42 DEL43 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL43 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL52 DEL42 DEL22 DEL52 DEL52 DEL42 DEL22 DEL52 DEL52 DEL52 DEL42 DEL22 DEL52 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL9 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL52 DEL52 DEL52 DEL52 DEL42 DEL22 DEL52 DEL52 DEL52 DEL9 DEL38 DEL8 DEL25 DEL9 DEL41 DEL52 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL43 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL43 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL43 DEL43 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL9 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL27 DEL25 DEL8 DEL42 DEL78 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL1 DEL14 DEL32 DEL21 DEL8 DEL31 DEL42 DEL36 DEL27 DEL42 DEL36 DEL27 DEL42 DEL36 DEL27 DEL42 DEL36 DEL27 DEL42 DEL42 DEL45 DEL86 DEL14 DEL59 DEL60 DEL8 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL42 DEL42 DEL52 DEL40 DEL33 DEL9 DEL42 DEL42 DEL14 DEL59 DEL60 DEL8 DEL25 DEL8 DEL51 DEL8 DEL25 DEL8 DEL54 DEL8 DEL52 DEL42 DEL22 DEL39 DEL31 DEL52 DEL83 DEL52 DEL52 DEL52 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL52 DEL52 DEL42 DEL22 DEL52 DEL52 DEL42 DEL22 DEL52 DEL42 DEL43 DEL85 DEL5 DEL9 DEL42 DEL4 DEL3 DEL52 DEL52 DEL52 DEL52 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL52 DEL42 DEL22 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL38 DEL27 DEL52 DEL52 DEL42 DEL22 DEL42 DEL9 DEL7 DEL21 DEL42 DEL9 DEL7 DEL21 DEL52 DEL42 DEL9 DEL7 DEL21 DEL52 DEL32 DEL42 DEL4 DEL3 DEL52 DEL52 DEL52 DEL42 DEL43 DEL85 DEL5 DEL52 DEL42 DEL9 DEL7 DEL21 DEL52 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL43 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL52 DEL52 DEL42 DEL22 DEL52 DEL52 DEL42 DEL22 DEL52 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL52 DEL42 DEL22 DEL52 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL52 DEL42 DEL32 DEL38 DEL27 DEL52 DEL52 DEL52 DEL52 DEL42 DEL22 DEL52 DEL52 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL52 DEL42 DEL22 DEL52 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL32 DEL34 DEL27 DEL9 DEL9 DEL16 DEL52 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL52 DEL42 DEL22 DEL52 DEL52 DEL42 DEL43 DEL85 DEL5 DEL52 DEL4 DEL3 DEL52 DEL42 DEL22 DEL43 DEL52 DEL42 DEL22 DEL32 DEL3 DEL42 DEL42 DEL42 DEL32 DEL21 DEL52 DEL42 DEL22 DEL52 DEL42 DEL43 DEL85 DEL5 DEL52 DEL32 DEL4 DEL3 DEL52 DEL42 DEL43 DEL85 DEL5 DEL52 DEL32 DEL4 DEL3 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL9 DEL6 DEL52 DEL42 DEL22 DEL43 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL13 DEL32 DEL42 DEL52 DEL42 DEL22 DEL32 DEL42 DEL13 DEL32 DEL42 DEL52 DEL42 DEL22 DEL32 DEL42 DEL13 DEL32 DEL21 DEL42 DEL42 DEL32 DEL41 DEL52 DEL52 DEL42 DEL22 DEL32 DEL21 DEL42 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL32 DEL38 DEL42 DEL52 DEL42 DEL22 DEL32 DEL21 DEL8 DEL25 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL34 DEL32 DEL41 DEL52 DEL52 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL22 DEL43 DEL52 DEL42 DEL22 DEL43 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL43 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL25 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL43 DEL43 DEL42 DEL32 DEL27 DEL52 DEL42 DEL22 DEL42 DEL43 DEL14 DEL52 DEL42 DEL22 DEL21 DEL21 DEL21 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL8 DEL24 DEL8 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL52 DEL52 DEL52 DEL52 DEL52 DEL52 DEL52 DEL43 DEL42 DEL42 DEL43 DEL42 DEL43 DEL52 DEL52 DEL83 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL27 DEL9 DEL41 DEL8 DEL25 DEL52 DEL52 DEL42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL52 DEL52